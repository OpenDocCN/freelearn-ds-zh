- en: '*Chapter 3*: Working with Plotly''s Figure Objects'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*：使用 Plotly 的 Figure 对象'
- en: Imagine that you have published an article that contains a chart. Assume that
    your readers will, on average, spend 1 minute looking at the chart. If your chart
    is easy to understand, then they will probably spend 10 seconds understanding
    it and 50 seconds thinking, analyzing, and pondering its implications. On the
    other hand, if the chart is difficult to understand, they will spend 50 seconds
    "reading" it, and very little time thinking about its implications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你发布了一篇包含图表的文章。假设读者平均花费 1 分钟时间查看图表。如果你的图表易于理解，那么他们可能会花 10 秒钟理解图表内容，接着花 50 秒时间思考、分析并琢磨图表的意义。另一方面，如果图表难以理解，他们可能会花费
    50 秒“阅读”图表，而很少有时间去思考其含义。
- en: 'This chapter aims to equip you with tools that will help you to minimize the
    time an audience spends understanding your charts, and to maximize their analysis
    and thinking time. The two previous chapters were about structuring apps and making
    them interactive. In this chapter, we will discuss how to create and control the
    very charts around which your apps are built. Plotly''s **Figure** object is what
    we will primarily explore. In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在为你提供工具，帮助你最大限度减少观众理解图表的时间，并最大化他们分析和思考的时间。前两章主要讨论了如何构建应用程序并使其具备交互性。本章将讨论如何创建和控制构建应用程序所需的图表。我们将主要探索
    Plotly 的 **Figure** 对象。本章将涉及以下主要主题：
- en: Understanding the Figure object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Figure 对象
- en: Getting to know the data attribute
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解数据属性
- en: Getting to know the layout attribute
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解布局属性
- en: Learning about figure traces and how to add them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习图形轨迹及其添加方法
- en: Exploring the different ways of converting figures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索不同的图形转换方式
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will focus on using the `Figure` object from the `graph_objects` module of
    the `plotly` package. Later in the chapter, we will utilize the other packages
    that we have been using to improve our app and add an interactive chart to it.
    As a reminder, the packages that we will use are Dash, Dash HTML Components, Dash
    Core Components, Dash Bootstrap Components, JupyterLab, Jupyter Dash, and pandas.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点使用 `plotly` 包中 `graph_objects` 模块的 `Figure` 对象。在本章后续部分，我们将使用其他包来改进我们的应用程序，并为其添加一个交互式图表。提醒一下，我们将使用的包有
    Dash、Dash HTML 组件、Dash 核心组件、Dash Bootstrap 组件、JupyterLab、Jupyter Dash 和 pandas。
- en: 'The packages can be individually installed by running `pip install <package-name>`,
    but it would be better to install the exact same versions that we use here, to
    reproduce the same results. You can install them all by running one command, `pip
    install –r requirements.txt`, from the root folder of the repository. The latest
    version of the poverty dataset can be downloaded from this link: [https://datacatalog.worldbank.org/dataset/poverty-and-equity-database](https://datacatalog.worldbank.org/dataset/poverty-and-equity-database).
    However, as with the packages, if you want to reproduce the same results, you
    can access the dataset from the `data` folder in the root of the Git repository,
    along with the rest of the code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_03](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_03).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些软件包可以通过运行 `pip install <package-name>` 单独安装，但为了重现相同的结果，最好安装我们在此处使用的确切版本。你可以通过在存储库的根文件夹中运行一条命令
    `pip install -r requirements.txt` 来一次性安装所有这些软件包。贫困数据集的最新版本可以从这个链接下载：[https://datacatalog.worldbank.org/dataset/poverty-and-equity-database](https://datacatalog.worldbank.org/dataset/poverty-and-equity-database)。不过，和软件包一样，如果你想重现相同的结果，你也可以从
    Git 仓库根目录下的 `data` 文件夹访问数据集，除此之外，本章的所有代码也可以在 GitHub 上找到：[https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_03](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_03)。
- en: Check out the following video to see the Code in Action at [https://bit.ly/3x9VhAA](https://bit.ly/3x9VhAA).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，观看代码演示：[https://bit.ly/3x9VhAA](https://bit.ly/3x9VhAA)。
- en: Understanding the Figure object
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Figure 对象
- en: Plotly is a fully fledged data visualization system, which ships with more than
    50 types of charts out of the box (for example, bar charts, scatter plots, and
    histograms). It supports 2D and 3D visualizations, ternary plots, maps, and more.
    The available options for customizing almost any aspect of your charts are very
    detailed and can be overwhelming. This, as they say, is a good problem to have!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Plotly是一个功能完整的数据可视化系统，提供超过50种图表类型（例如，条形图、散点图和直方图）。它支持2D和3D可视化、三元图、地图等。可自定义几乎所有图表方面的选项非常详细，可能会让人感到有些复杂。正如人们所说，这也是一个“好问题”！
- en: We use charts to uncover certain characteristics of our data or the relationships
    between different datasets. However, pure data visualization would be meaningless
    if we didn't know what is being visualized. Imagine a rectangle that has a bunch
    of dots on it with clear patterns. It would still be meaningless if you didn't
    know what the *x* axis represented, for example. If you have different shapes
    and colors in a plot, then they would mean nothing without a legend. Usually,
    titles and annotations are also needed to give us context around the data we are
    trying to understand.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用图表来揭示数据的某些特征或不同数据集之间的关系。然而，如果我们不知道可视化的内容，纯粹的数据可视化是没有意义的。想象一个矩形，里面有一堆点，且这些点有清晰的模式。如果你不知道
    *x* 轴代表什么，它依然是没有意义的。例如，如果在一个图中有不同的形状和颜色，没有图例它们也没有任何意义。通常，标题和注释也很重要，它们帮助我们理解正在分析的数据的背景。
- en: Those two groups, `data` and other supporting elements, which are collectively
    called `layout`, are two top-level attributes of Plotly's `Figure` object. Each
    attribute has several subattributes, at multiple levels, forming a tree-like structure.
    There is also the `frames` attribute, which is mainly used with animations, and
    it is not as common as the other two that are always present in every chart. We
    will not cover it in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个组，`data`和其他支持元素，统称为`layout`，是Plotly的`Figure`对象的两个顶级属性。每个属性都有多个子属性，形成一个类似树状的结构。还有一个`frames`属性，主要用于动画，它不像另外两个属性那样总是在每个图表中出现，因此并不常见。本章将不会涉及这个属性。
- en: 'Let''s now explore these attributes and start plotting to get a better understanding
    of how they fit together within the `Figure` object:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨这些属性，开始绘图，以更好地理解它们如何在`Figure`对象中相互结合：
- en: '`data`: The different attributes of data, and the relationships between them,
    are expressed using graphical/geometrical shapes, for example, circles, rectangles,
    lines, and more. The graphical attributes of those shapes are used to express
    various attributes of the data. The relative size, length, and distance between
    those shapes are how we understand this. Due to their visual and, therefore, intuitive
    nature, those attributes are easy to understand and don''t require much explanation.
    The `data` attribute corresponds to the essence of what we are trying to understand.
    The values you need to provide for the `data` attribute depend on the chart type.
    For a scatter plot, for example, you need to provide `x` and `y` values. For maps,
    you need to have `lat` and `lon`. You can overlay several sets of data on top
    of each other on the same chart; each one is referred to as a **trace**. Each
    chart type can take many other optional values, and many of them will be covered
    in more detail later on in the book.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：数据的不同属性以及它们之间的关系，通过图形/几何形状来表达，比如圆形、矩形、线条等。这些形状的图形属性用于表达数据的各种属性。我们通过这些形状的相对大小、长度和距离来理解数据。由于它们是视觉化的，因此具有直观性，这些属性很容易理解，不需要太多解释。`data`属性对应的是我们试图理解的核心内容。你需要为`data`属性提供的值取决于图表的类型。例如，对于散点图，你需要提供`x`和`y`值；对于地图，你需要提供`lat`和`lon`。你可以将多个数据集叠加在同一个图表上，每个数据集被称为**trace**。每种图表类型可以接受许多其他可选值，很多内容将在本书后续部分详细介绍。'
- en: '`layout`: Everything else around the data belongs to this attribute. Elements
    of the `layout` attribute are more abstract in nature. They typically use text
    to inform the user what they are looking at. Many of them are also styling elements,
    which might not add as much information, but they make the charts easier to understand
    or conform to certain branding guidelines. There are many attributes that we will
    explore, but the most prominent ones are the title, axis titles, ticks, and legend.
    These, in turn, have subattributes, such as the font size, location, and more.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout`：所有与数据无关的内容都属于这个属性。`layout`属性的元素本质上更抽象，通常使用文本来告诉用户他们正在查看什么。许多元素也是样式元素，虽然它们可能不会添加太多信息，但可以使图表更易于理解或符合某些品牌指南。我们将探索许多属性，但最突出的属性是标题、轴标题、刻度和图例。它们又有子属性，例如字体大小、位置等。'
- en: 'It''s much easier to learn by doing, and we can now start by creating our first
    figure. The `graph_objects` module is usually imported as `go`, and we instantiate
    a figure by calling `go.Figure`! *Figure 3.1* shows an empty `Figure` object and
    how it is created and displayed:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实践学习要容易得多，我们现在可以开始创建我们的第一个图形。`graph_objects`模块通常作为`go`导入，我们通过调用`go.Figure`来实例化一个图形！*图
    3.1*展示了一个空的`Figure`对象，以及如何创建和显示它：
- en: '![Figure 3.1 – The default empty Figure object displayed in JupyterLab](img/B16780_03_001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 在 JupyterLab 中显示的默认空 Figure 对象](img/B16780_03_001.jpg)'
- en: Figure 3.1 – The default empty Figure object displayed in JupyterLab
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 在 JupyterLab 中显示的默认空 `Figure` 对象
- en: Of course, we don't get anything from this empty figure, but it is the first
    step before adding the elements we want to it. Although we can create and display
    `Figure` objects by defining everything in the `go.Figure` call, we will use a
    slightly easier and more convenient approach. We will assign the created object
    to a variable, and then iteratively add and/or modify the elements that we want.
    An important benefit of this approach is that we can make changes to our charts
    after creating them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，从这个空图形中我们什么也看不出来，但它是添加我们想要的元素之前的第一步。虽然我们可以通过在`go.Figure`调用中定义所有内容来创建并显示`Figure`对象，但我们将使用一种稍微更简单、更方便的方法。我们将创建的对象赋值给一个变量，然后迭代地添加和/或修改我们需要的元素。这个方法的一个重要好处是，创建图表后我们可以对其进行更改。
- en: Important note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Once you assign a `Figure` object to a variable, this variable becomes available
    in the global scope. Since it is mutable, you can make changes to it in other
    places in your code. Displaying the figure after making such changes will show
    it with the changes you have made. We will be utilizing this important feature
    in order to manage our charts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将`Figure`对象赋值给一个变量，这个变量就可以在全局范围内使用。由于它是可变的，您可以在代码的其他地方对其进行修改。对图表进行修改后，显示该图表将展示您所做的更改。我们将利用这个重要特性来管理我们的图表。
- en: Having created the basic object, we are now ready to start adding our first
    data traces to our first chart.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了基本对象后，我们现在可以开始将我们的第一个数据轨迹添加到我们的第一个图表中。
- en: Getting to know the data attribute
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解数据属性
- en: First, we start by adding a scatter plot using a very small and simple dataset.
    Later in the chapter, we will use our poverty dataset to create other plots. Once
    you have created your `Figure` object and assigned it to a variable, you have
    access to a large number of convenient methods for manipulating that object. The
    methods related to adding data traces all start with `add_`, followed by the type
    of chart we are adding, for example, `add_scatter` or `add_bar`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过添加一个非常小且简单的数据集来开始绘制散点图。在本章的后面部分，我们将使用我们的贫困数据集来创建其他图表。一旦创建了`Figure`对象并将其赋值给一个变量，您就可以访问大量方便的方法来操作该对象。与添加数据轨迹相关的方法都以`add_`开头，后面跟着我们要添加的图表类型，例如`add_scatter`或`add_bar`。
- en: 'Let''s go through the full process of creating a scatter plot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起走完整个散点图创建过程：
- en: 'Import the `graph_objects` module:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`graph_objects`模块：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create an instance of a `Figure` object and assign it to a variable:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Figure`对象的实例并将其赋值给一个变量：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add a scatter trace. The minimum parameters required for this type of chart
    are two arrays for the `x` and `y` values. These can be provided as lists, tuples,
    NumPy arrays, or pandas `Series`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个散点轨迹。此类型图表所需的最小参数是`x`和`y`值的两个数组。这些值可以通过列表、元组、NumPy数组或pandas `Series`提供：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Display the resulting figure. You can simply have the variable on the last
    line in your code cell, and it will also be displayed in JupyterLab once you run
    it. You can also explicitly call the `show` method, which gives you a few more
    options to customize the display of the figure:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示生成的图形。你可以简单地将变量放在代码单元的最后一行，它也会在 JupyterLab 中显示，一旦你运行它。你还可以显式调用 `show` 方法，这样可以提供更多选项来定制图形的显示方式：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can see the full code, as well as the final output, in *Figure 3.2*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *图 3.2* 中看到完整的代码以及最终的输出：
- en: '![Figure 3.2 – A scatter plot displayed in JupyterLab](img/B16780_03_002.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 在 JupyterLab 中显示的散点图](img/B16780_03_002.jpg)'
- en: Figure 3.2 – A scatter plot displayed in JupyterLab
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 在 JupyterLab 中显示的散点图
- en: 'We will now add another similar scatter plot, overlaid on top of this one.
    We simply repeat *step 3*, but with different values:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加另一个类似的散点图，叠加在这个图上。我们只需重复 *步骤 3*，但使用不同的值：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will add the new scatter plot to the same figure. If we call `fig.show()`
    after running this code, we will be able to see the updated figure. Note that
    this trace has four data points, whereas the previous trace had three. We don't
    need to worry about this, as this is handled for us using certain default values.
    We also have the option to modify those default values if we need to.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把新的散点图添加到同一图形中。如果我们在运行此代码后调用 `fig.show()`，我们将能够看到更新后的图形。请注意，这个轨迹有四个数据点，而前一个轨迹有三个。我们不需要担心这一点，因为这是通过某些默认值为我们处理的。如果需要，我们还可以修改这些默认值。
- en: If we want to modify any aspect of our `data` trace, we can do it through the
    `add_<chart_type>` method. The call to those methods provides a lot of options
    through many parameters, and they are specific to the type of chart you are producing.
    Part 2 of this book will go deeper into several chart types and the different
    options that they provide. On the other hand, if we want to modify anything related
    to the `layout` attribute, we can do so by accessing and then assigning the attributes
    and/or subattributes that we want in a simple, declarative way. This is generally
    done using Python's dot notation, for example, `figure.attribute.sub_attribute
    = value`. This guideline is not entirely correct, as there are a few exceptions,
    and in some cases, there is an overlap where an attribute belongs to the `data`
    attribute but is managed by the `layout` attribute, for example. In most cases,
    this is a helpful distinction to keep in mind.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想修改任何关于 `data` 轨迹的方面，可以通过 `add_<chart_type>` 方法来实现。调用这些方法会提供许多选项，通过多种参数进行设置，这些选项是特定于你正在生成的图表类型的。本书的第二部分将深入探讨几种图表类型及其提供的不同选项。另一方面，如果我们想修改与
    `layout` 属性相关的任何内容，我们可以通过访问并赋值我们想要的属性和/或子属性，采用简单的声明式方式来实现。这通常使用 Python 的点符号表示法，例如
    `figure.attribute.sub_attribute = value`。这个指导原则并不完全正确，因为也存在一些例外情况，在某些情况下，有些属性属于
    `data` 属性，但由 `layout` 属性来管理。例如，大多数情况下，这种区分是有帮助的。
- en: Let's now take a look at some of the things that we can change in our figure's
    layout.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看在图形布局中可以更改的一些内容。
- en: Getting to know the layout attribute
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 layout 属性
- en: 'For the current figure that we are working on, let''s add a title (for the
    whole figure), along with axis titles, to see how it works:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们正在处理的当前图形，让我们添加一个标题（针对整个图形），以及轴标题，看看效果如何：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, we are exploring the tree-like structure of our figure. There
    is a `title` attribute that falls directly under `fig.layout`, and there are also
    titles for `fig.layout.xaxis` and `fig.layout.yaxis`. To give you a sense of how
    detailed the available options are, *Figure 3.3* shows some of the `xaxis` attributes
    that start with `tick` only:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在探索图形的树形结构。`title` 属性直接位于 `fig.layout` 下方，此外，还有 `fig.layout.xaxis` 和
    `fig.layout.yaxis` 的标题。为了让你了解可用选项的详细程度，*图 3.3* 展示了以 `tick` 开头的一些 `xaxis` 属性：
- en: '![Figure 3.3 – Some of the Figure object''s layout.xaxis options](img/B16780_03_003.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 一些 Figure 对象的 layout.xaxis 选项](img/B16780_03_003.jpg)'
- en: Figure 3.3 – Some of the Figure object's layout.xaxis options
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 一些 Figure 对象的 layout.xaxis 选项
- en: 'Let''s now look at the effect of the four lines of code we just added:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看我们刚刚添加的四行代码的效果：
- en: '![Figure 3.4 – The updated figure containing two traces, a legend, and titles](img/B16780_03_004.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 更新后的图形，包含两条轨迹、一个图例和标题](img/B16780_03_004.jpg)'
- en: Figure 3.4 – The updated figure containing two traces, a legend, and titles
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 更新后的图形，包含两条轨迹、一个图例和标题
- en: The three titles we have added are self-explanatory. New traces take on new
    default colors to differentiate them. Another interesting thing is the legend,
    which was added automatically. When you just have one trace, there is usually
    no need for a legend, but it becomes important when you have more than one. Descriptive
    names are crucial, of course, and **trace 0** doesn't mean much, but I'm keeping
    it as a memory aid to remember the names of the figure elements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的三个标题是显而易见的。新轨迹采用新的默认颜色来区分它们。另一个有趣的事情是图例，它是自动添加的。当你只有一条轨迹时，通常不需要图例，但当你有多条轨迹时，它就变得非常重要。当然，描述性名称至关重要，**轨迹
    0** 并没有太多意义，但我将其保留作为记忆辅助，帮助记住图形元素的名称。
- en: The figure we just created and displayed is what your users will see. Let's
    now take an interactive peek at the components of this figure.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建并显示的图形就是你的用户将看到的内容。现在让我们通过交互式的方式来查看这个图形的各个组件。
- en: Interactively exploring the Figure object
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式探索 Figure 对象
- en: 'As I mentioned earlier, the `show` method provides a few handy options for
    customizing what and how your figures are displayed. A particularly helpful one
    is setting the `renderer` parameter to JSON. *Figure 3.5* shows how this can be
    useful:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，`show` 方法提供了一些便捷的选项，用于自定义图形的展示方式。一个特别有用的选项是将 `renderer` 参数设置为 JSON。*图
    3.5* 展示了这一点是如何有用的：
- en: '![Figure 3.5 – Interactively exploring the Figure object in JupyterLab](img/B16780_03_005.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 在 JupyterLab 中交互式探索 Figure 对象](img/B16780_03_005.jpg)'
- en: Figure 3.5 – Interactively exploring the Figure object in JupyterLab
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 在 JupyterLab 中交互式探索 Figure 对象
- en: In the top-left corner, you can see the default view. The `Figure` object, and
    the two top-level attributes can be seen right under it. We also get a hint that
    our **data** attribute contains two items (these are the two traces we added).
    The triangles and their directions indicate whether the respective attribute has
    been expanded or collapsed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在左上角，你可以看到默认视图。`Figure` 对象和两个顶层属性显示在它下方。我们还可以看到一个提示，表明我们的**数据**属性包含两个项目（这两个是我们添加的轨迹）。三角形及其方向指示相应的属性是否已经展开或折叠。
- en: In the bottom-left corner, you can see the search functionality in action. This
    is useful for when you want to access or modify a certain attribute but are not
    entirely sure what its exact name is, or to what attribute it belongs. On the
    right-hand side, I have expanded a few of the items, and you can see that they
    correspond to the figure we created.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在左下角，你可以看到搜索功能的实际操作。这在你想要访问或修改某个属性时非常有用，但又不完全确定它的确切名称，或者它属于哪个属性。在右侧，我已展开了一些项目，你可以看到它们对应我们创建的图形。
- en: Important note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This chapter, and the whole book really, is about how to create the charts and
    dashboards that you want. It's not about data visualization's best practices or
    statistical inference. In other words, it's about how to create the things you
    *want* to create, and not about what you *should* create. I'll still try to share
    good practices, and hopefully, make reasonable choices for the charts and their
    details, but it's important to keep this distinction in mind.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，甚至整本书，讲述的是如何创建你想要的图表和仪表盘。它不是关于数据可视化的最佳实践或统计推断。换句话说，它是关于如何创建你*想*要创建的东西，而不是关于你*应该*创建什么。我仍然会尽量分享好的实践，并做出合理的选择来选择图表和其细节，但重要的是要牢记这一点。
- en: I'm sure you have noticed the "mode bar" containing interactive buttons and
    controls in the top-right corner of the figures we created. There are several
    ways to control which buttons to show or hide and a few other options. This is
    available through the `config` parameter of the `show` method.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经注意到我们创建的图形右上角的 "模式栏"，其中包含互动按钮和控制项。有几种方式可以控制显示或隐藏哪些按钮，以及一些其他选项。这些都可以通过
    `show` 方法的 `config` 参数进行控制。
- en: Configuration options for the Figure object
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Figure 对象的配置选项
- en: 'The `config` parameter takes a dictionary and controls several interesting
    options. The keys control which aspect to modify. Additionally, the values can
    be given as strings or lists, depending on which one you are modifying. For example,
    consider the following code snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`config` 参数接受一个字典，并控制多个有趣的选项。键用于控制修改哪个方面。此外，值可以是字符串或列表，具体取决于你正在修改的内容。例如，考虑以下代码片段：'
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here are some of the most important ones:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了一些最重要的选项：
- en: '`displayModeBar`: This defaults to `True`. It controls whether or not to display
    the whole mode bar.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`displayModeBar`：默认为 `True`。它控制是否显示整个模式栏。'
- en: '`responsive`: This defaults to `True`. It controls whether or not to change
    the dimensions of the figure based on the browser window''s size. Sometimes, you
    might want to keep the figure dimensions fixed.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responsive`：默认为`True`。它控制是否根据浏览器窗口的大小调整图形的尺寸。有时，您可能希望保持图形尺寸不变。'
- en: '`toImageButtonOptions`: The camera icon in the mode bar allows users to download
    the figure as an image. This option controls the default formats of downloading
    those images. It takes a dictionary in which you can set the default format (that
    is, SVG, PNG, JPG, or WebP). You can also set default values for the height, width,
    filename, and scale.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toImageButtonOptions`：模式栏中的相机图标允许用户将图形下载为图像。此选项控制下载图像的默认格式。它接受一个字典，您可以在其中设置默认格式（即SVG、PNG、JPG或WebP）。您还可以设置默认的高度、宽度、文件名和缩放比例。'
- en: '`modeBarButtonsToRemove`: This is a list of buttons you don''t want in the
    mode bar.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modeBarButtonsToRemove`：这是一个您不希望出现在模式栏中的按钮列表。'
- en: Now that we have learned how to create, examine, and configure basic charts,
    let's explore what else we can do with them. How can we convert them into other
    formats? And what other formats are available?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何创建、检查和配置基本图表，让我们探索一下我们还能做些什么。我们如何将它们转换成其他格式？还有哪些格式可用？
- en: Exploring the different ways of converting figures
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索转换图形的不同方式
- en: The methods that control converting figures start with either `to_` or `write_`.
    Let's explore some of the most interesting ones.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 控制转换图形的方法通常以`to_`或`write_`开头。让我们探索其中一些最有趣的方法。
- en: Converting figures into HTML
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将图形转换为HTML
- en: Plotly figures are actually HTML objects, together with the JavaScript that
    makes them interactive. We can easily capture that HTML file if we want to share
    it with others via email, for example. You might consider having this as a feature
    in your dashboards. Your users can create the chart or report they want, convert
    it into HTML, download it, and share it with their colleagues.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Plotly图形实际上是HTML对象，并结合使其具有交互性的JavaScript。如果我们想通过电子邮件与他人共享这些图形，我们可以轻松地捕获该HTML文件。例如，您可以考虑在您的仪表板中添加此功能。用户可以创建他们想要的图表或报告，将其转换为HTML，下载并与同事共享。
- en: 'All you have to do is provide a file path of where you want it to be saved.
    The method also takes several optional parameters for further customization. Let''s
    convert our figure into HTML and add a `config` option to make it download the
    figure image in SVG format. The effect of this will be reflected in the HTML file
    when clicking on the camera icon. The code for this is straightforward:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需提供一个文件路径，指定保存位置即可。该方法还提供几个可选参数以进一步定制。让我们将图形转换为HTML，并添加一个`config`选项，使其下载SVG格式的图像。当点击相机图标时，HTML文件将反映这一效果。相关代码非常简单：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can now open the file in a browser as a separate HTML file, filling the
    whole browser screen, as shown in *Figure 3.6*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将该文件作为单独的HTML文件在浏览器中打开，填满整个浏览器屏幕，如*图 3.6*所示：
- en: '![Figure 3.6 – The Figure object is rendered as a separate HTML file in a browser
    window](img/B16780_03_006.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – Figure对象作为一个单独的HTML文件呈现在浏览器窗口中](img/B16780_03_006.jpg)'
- en: Figure 3.6 – The Figure object is rendered as a separate HTML file in a browser
    window
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – Figure对象作为一个单独的HTML文件呈现在浏览器窗口中
- en: Converting figures into images
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将图形转换为图像
- en: We have examined the option that allows users to manually download an image
    of the `Figure` object. There is another way of doing so programmatically, which
    can also be interesting. Just like the `write_html` method, we also have a `write_image`
    method. The format of the image can be explicitly provided or inferred from the
    file extension you provide. You can also set the `height` and `width` values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检查了允许用户手动下载`Figure`对象图像的选项。还有另一种编程方式，也很有趣。就像`write_html`方法一样，我们也有一个`write_image`方法。图像的格式可以显式提供，或者根据您提供的文件扩展名推断出来。您还可以设置`height`和`width`值。
- en: 'This might be interesting for mass image creation. For example, you might want
    to create many plots, one for each country, and save each in a file for a separate
    report on each country. It would be very tedious to do this manually. You might
    also include this in one of your callbacks for your users. You could allow your
    users to assemble certain reports, and click on a button that converts them into
    images and then downloads them, for example. This can be run just like the HTML
    converter:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对大规模图像创建很有趣。例如，你可能想为每个国家创建许多图表，并将每个图表保存到单独的文件中，以便为每个国家生成单独的报告。手动完成这项工作会非常繁琐。你还可以将其作为用户回调的一部分。你可以允许用户生成某些报告，并点击一个按钮将其转换为图像并下载，例如。这可以像
    HTML 转换器一样运行：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this information, we can now get practical and find out more about our
    dataset.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们现在可以更实际地探索数据集，了解更多内容。
- en: Plotting using a real dataset
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用真实数据集进行绘图
- en: In [*Chapter 2*](B16780_02_Final_NM_ePub.xhtml#_idTextAnchor031), *Exploring
    the Structure of a Dash App*, we created a simple report that showed the user
    the population of the selected country in the year 2010\. This type of report
    is used when the user knows what they want. That is, they have a specific question
    about a specific country, metric, and period of time in mind, and our functionality
    provides an answer to their question.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第二章*](B16780_02_Final_NM_ePub.xhtml#_idTextAnchor031)《探索 Dash 应用程序的结构》中，我们创建了一个简单的报告，展示了2010年所选国家的人口。此类报告用于用户已经知道他们想要什么的情况。也就是说，他们有一个关于特定国家、指标和时间段的具体问题，我们的功能提供了答案。
- en: We can think of dashboard functionality falling under two broad categories.
    The first, as we have done already, are visualizations or reports that answer
    a specific question. The second, which we will do now, guide the user in a more
    exploratory approach. In this case, users don't know much about a certain topic
    and they are looking for an overview.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将仪表板功能分为两大类。第一类，就像我们已经做过的那样，是回答特定问题的可视化或报告。第二类，我们现在将要做的是引导用户进行更具探索性的操作。在这种情况下，用户对某个话题了解不多，他们正在寻找一个概览。
- en: Your users can go back and forth between those types of charts. For example,
    first, they explore poverty in the last decade. A certain region stands out. They
    then ask a specific question about that region. When they realize that that region
    had an unusually high rate of another metric, they can go on to another exploratory
    chart in that metric to learn more about it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在这两种类型的图表之间来回切换。例如，首先，他们可以探索过去十年的贫困情况。某个特定地区突出显示。然后，他们会就该地区提出一个具体问题。当他们意识到该地区的另一项指标异常高时，他们可以转到该指标的另一个探索性图表，以了解更多信息。
- en: Now, we will let the user select a year, and the app will display the top 20
    countries by population for the selected year.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将让用户选择一个年份，应用程序将显示该年份按人口排序的前20个国家。
- en: As a quick reminder, our poverty dataset contains columns for the countries
    and their codes, the indicators and their codes, and a column for each year from
    1974 to 2019.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 快速提醒一下，我们的贫困数据集包含国家及其代码、指标及其代码，以及从1974年到2019年的每一年的列。
- en: 'As agreed, let''s first do this in an isolated environment in JupyterLab:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 按照约定，让我们首先在 JupyterLab 中的隔离环境中进行操作：
- en: 'Import `pandas`, use it to open the poverty dataset, and assign it to the `poverty_data`
    variable:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `pandas`，用它打开贫困数据集，并将其分配给 `poverty_data` 变量：
- en: '[PRE9]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Although the column of interest is called `regions` list:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管关注的列名为 `regions` 列表：
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create `population_df`, the subset DataFrame where the `regions`, and the `isin`
    method for pandas `Series` checks whether values in the `Series` are in a certain
    list, and the `~` (tilde) is the logical negation operator:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `population_df`，这是一个子集 DataFrame，其中的 `regions` 列，以及 pandas `Series` 的 `isin`
    方法检查 `Series` 中的值是否在某个列表中，而 `~`（波浪符）是逻辑否定操作符：
- en: '[PRE11]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first few rows of the resulting DataFrame can be displayed as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果 DataFrame 的前几行可以如下显示：
- en: '[PRE12]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It looks similar to the following screenshot:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它看起来像以下屏幕截图：
- en: '![Figure 3.7 – The first few rows of population_df](img/B16780_03_007.jpg)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 3.7 – population_df 的前几行](img/B16780_03_007.jpg)'
- en: Figure 3.7 – The first few rows of population_df
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.7 – population_df 的前几行
- en: 'Create a dynamic `year` variable, and create a `year_df` variable containing
    the countries column along with the selected year''s column. Then, sort those
    values in descending order and extract the first 20:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个动态的 `year` 变量，并创建一个包含国家列以及所选年份列的 `year_df` 变量。然后，将这些值按降序排序，并提取前20个：
- en: '[PRE13]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With a `year_df` variable containing two sorted columns, we can very easily
    create a bar chart just as we did with the scatter plots earlier. We can also
    add a dynamic title, containing the year, as a variable:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了一个包含两个排序列的`year_df`变量，我们可以像之前做散点图一样非常轻松地创建条形图。我们还可以添加一个包含年份作为变量的动态标题：
- en: '[PRE14]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This results in the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Figure 3.8 – A bar chart showing the top 20 countries by population in 2010](img/B16780_03_008.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 显示2010年按人口排序的前20个国家的条形图](img/B16780_03_008.jpg)'
- en: Figure 3.8 – A bar chart showing the top 20 countries by population in 2010
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 显示2010年按人口排序的前20个国家的条形图
- en: As you can see, once we have a proper subset with the relevant columns sorted,
    we can produce the chart we want with a few lines of code. Additionally, note
    that the numbers on the *y* axis were formatted, by default, as billions (or fractions
    of billions) to make them easy to read.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一旦我们拥有一个适当的子集并对相关列进行排序，我们就可以用几行代码生成我们想要的图表。另外，注意*y*轴上的数字默认以十亿（或十亿的分数）格式显示，以便更容易阅读。
- en: 'We didn''t set axis titles. Here, the figure title implicitly tells us about
    both axes: "countries" and "population." With a numeric *y* axis and the country
    names listed on the *x* axis, it should be clear to users.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有设置轴标题。在这里，图表标题隐含地告诉我们两个轴的信息：“国家”和“人口”。由于*y*轴是数字格式，*x*轴列出了国家名称，用户应该能很清楚地理解。
- en: 2010 is an arbitrary year, and we actually want users to be able to select the
    year they want from the ones that are available in the dataset.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年是一个任意年份，实际上我们希望用户能够从数据集中可用的年份中选择他们想要的年份。
- en: 'The code that produced the figure only requires a `def` statement and some
    indentation to become a function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 生成该图表的代码只需要一个`def`语句和一些缩进，就能变成一个函数：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function produces a similar chart to the one that we just produced, but
    for the given `year` argument. You might think that it's as easy to convert this
    function into a callback function, just by adding a line of code. This is exactly
    what we will be doing, but first, I'd like to highlight an observation about data
    manipulation and preparation, and how it relates to data visualization because
    this example illustrates it very well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数生成的图表与我们刚刚生成的图表相似，但它是基于给定的`year`参数。你可能认为，将这个函数转换为回调函数只需要添加一行代码。实际上，这正是我们接下来要做的事情，但首先，我想强调一个关于数据处理和准备的观察，以及它如何与数据可视化相关，因为这个例子很好地说明了这一点。
- en: Data manipulation as an essential part of the data visualization process
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据处理是数据可视化过程中不可或缺的一部分
- en: 'The previous example contains six steps. The first five were for preparing
    the data and getting it in two arrays: one for countries and the other for population
    numbers. The sixth and final step alone was where we produced the chart. There
    was much more code for data preparation than there was for producing the figure.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子包含六个步骤。前五个步骤是为了准备数据并将其整理成两个数组：一个是国家名，另一个是人口数。第六个也是最后一个步骤是生成图表。为了准备数据所写的代码比生成图表的代码多得多。
- en: If you consider the mental effort and time required to produce the chart (that
    is, the final step only), you can easily see that it is the same as the mental
    effort required to produce the scatter plot that we created at the beginning of
    the chapter, featuring the toy dataset. We simply ran `add_scatter(x=[1, 2, 3],
    y=[4, 2, 3])`, and then we did the same for the bar chart, only with different
    values.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑到生成图表所需的心理努力和时间（也就是只有最后一步），你会很容易发现，这与我们在本章开头使用玩具数据集创建散点图所需的心理努力是相同的。我们只需运行`add_scatter(x=[1,
    2, 3], y=[4, 2, 3])`，然后我们为条形图做了相同的操作，只是数值不同。
- en: However, if you consider the mental effort and time spent on preparing the data
    for the bar chart, you can clearly see that there is a huge difference, compared
    to the data preparation for the scatter plot. We needed to know that the `KeyError`
    after trying to access the data for a certain year. We typically spend more time
    and effort on these things, and once the data is in a suitable format, we can
    easily visualize it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你考虑到为条形图准备数据所花费的心理努力和时间，你会明显看到，与为散点图准备数据相比，差异巨大。我们需要知道在尝试访问某一年份的数据时会遇到`KeyError`。通常我们会在这些问题上花费更多时间和精力，而一旦数据格式合适，我们就能轻松地进行可视化。
- en: In [*Chapter 4*](B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060), *Data Manipulation
    and Preparation - Paving the Way to Plotly Express*, we will spend more time on
    this topic, and introduce some important techniques that might be useful in a
    variety of situations. However, keep in mind that your skills in manipulating
    data, reshaping it, merging datasets, regular expressions, and all the tedious
    parts of data preparation form a big part of where your contribution lies. It's
    where most opportunities are, and a lot of it is based on your judgment. Domain
    knowledge is also essential; for instance, knowing the difference between regions
    and countries. Once you have data in a certain format, there are numerous advanced
    techniques and algorithms that you can use to visualize, analyze, and run various
    machine learning pipelines that require comparatively little code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060)，*数据操作和准备 - 通往Plotly
    Express的道路*中，我们将花更多时间讨论这个主题，并介绍一些在各种情况下可能有用的重要技术。然而，请记住，你在操作数据、重塑数据、合并数据集、正则表达式以及所有繁琐的数据准备工作方面的技能构成了你贡献的重要部分。这是大部分机会所在，很多都基于你的判断。领域知识也是必不可少的；例如，知道区域和国家之间的区别。一旦你有了特定格式的数据，就有许多高级技术和算法可以用来可视化、分析和运行各种机器学习流水线，而这些技术只需要相对较少的代码。
- en: Now, let's use our newly created function and learn how to make it interactive
    with a `Dropdown` component and a callback function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们新创建的函数，并学习如何通过`Dropdown`组件和回调函数使其交互。
- en: Making the chart interactive with a callback function
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过回调函数使图表交互
- en: 'First, we will do this as a completely isolated app in JupyterLab, after which
    we will add it to our app. In the isolated environment, our `app.layout` attribute
    will contain two components:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在JupyterLab中作为完全隔离的应用程序进行操作，之后再将其添加到我们的应用程序中。在隔离环境中，我们的`app.layout`属性将包含两个组件：
- en: '`Dropdown`: This will display all the available years so that the user can
    select the one they want.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dropdown`：这将显示所有可用的年份，以便用户可以选择他们想要的年份。'
- en: '`Graph`: This is a new component that we haven''t covered yet, and we will
    be working extensively with it. Adding a `Graph` component to the layout displays
    an empty chart. If you remember our discussion about callback functions, when
    modifying a component in a callback function, we need to provide its `component_id`
    and `component_property`. The property that we will be modifying, in this scenario,
    is the `figure` property, and it only belongs to the `Graph` component.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graph`：这是一个我们尚未涵盖的新组件，我们将会大量使用它。将`Graph`组件添加到布局中会显示一个空图表。如果你还记得我们关于回调函数的讨论，当在回调函数中修改组件时，我们需要提供其`component_id`和`component_property`。在这种情况下，我们将要修改的属性是`figure`属性，它只属于`Graph`组件。'
- en: 'You are now familiar with the imports and app instantiation, so I will mainly
    focus on the `app.layout` attribute of the app:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了导入和应用程序实例化，所以我将主要关注应用程序的`app.layout`属性：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For now, there is nothing special about the `Graph` component. We simply create
    one underneath the `Dropdown` component and give it a descriptive `id` argument.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`Graph`组件没有什么特别之处。我们只是在`Dropdown`组件下面创建一个，并给它一个描述性的`id`参数。
- en: I'm sure you have also noticed that this time, we have slightly different values
    for the `label` and `value` keys in the list of `options` in the `Dropdown` component.
    The difference is that the `value` key is set to `str(year)`. Since `options`
    is a list of dictionaries generated by a list comprehension, it will produce a
    list of integers. The selected number will be used to select the column with that
    value. In this dataset, the columns are all strings, so using `population_df[2010]`
    will not work, because there is really no such column (as an integer). The actual
    column name is **2010**, as a string. So, we are specifying the label as an integer,
    but the actual value that will be used by the callback function is the string
    representation of that integer (the year).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你也注意到了，这一次，在`Dropdown`组件的`options`列表中，`label`和`value`键的值略有不同。不同之处在于`value`键设置为`str(year)`。由于`options`是通过列表推导生成的字典列表，它将生成一个整数列表。所选数字将用于选择具有该值的列。在这个数据集中，所有列都是字符串，因此使用`population_df[2010]`是行不通的，因为实际上并没有这样的列（作为整数）。实际列名是**2010**，作为字符串。因此，我们将标签指定为整数，但回调函数将使用该整数的字符串表示（年份）。
- en: We have also added a new parameter that we haven't discussed yet. The `value`
    parameter of the `Dropdown` component serves as a default that will be shown to
    users the first time they see the app. This is better than showing an empty chart.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个新参数，之前没有讨论过。`Dropdown`组件的`value`参数作为默认值，首次显示给用户时会显示此值。这样比直接显示一个空图表要更好。
- en: 'In some cases, you might want to do the opposite of what we did in this example.
    You might want to keep `value` as it is but modify `label` somehow. For example,
    if your data was all in lowercase, you might want to display the options as capitalized.
    In our colors example, in the previous chapter, we could have done something like
    this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能想做与这个示例中相反的事情。你可能希望保持`value`不变，但以某种方式修改`label`。例如，如果你的数据全是小写字母，你可能希望将选项显示为大写字母。在上一章的颜色示例中，我们也可以做类似的处理：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From the callback function''s perspective, the colors are still the same, because
    it mainly deals with the `value` attribute. But for the user, this would display
    the colors as capitalized: "Blue," "Green," and "Yellow."'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从回调函数的角度看，颜色依然保持不变，因为它主要处理的是`value`属性。但是对于用户来说，这会将颜色显示为大写字母："Blue"、"Green"和"Yellow"。
- en: 'Running the app with the two components defined so far produces the app, as
    shown in *Figure 3.9*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 运行至今定义的两个组件会生成如*图 3.9*所示的应用：
- en: '![Figure 3.9 – An app with a Dropdown component showing a default value and
    an empty graph](img/B16780_03_009.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 一个带有下拉组件的应用，显示默认值和空图表](img/B16780_03_009.jpg)'
- en: Figure 3.9 – An app with a Dropdown component showing a default value and an
    empty graph
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 一个带有下拉组件的应用，显示默认值和空图表
- en: 'We have already created a normal function that takes the data as a year and
    returns a bar chart showing the top 20 countries by population for that year.
    Converting it into a callback function requires one line of code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个正常的函数，它接受年份数据，并返回显示该年份前20个国家按人口排名的柱状图。将其转换为回调函数只需要一行代码：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the previous function definition, the last line was `fig.show()`, and in
    the callback function, we return the figure instead. The reason is that, in the
    first case, we were running it interactively and there was no app or callback
    context. In this case, we have a component with the `population_chart` ID, and,
    most importantly, we want to change its `figure` property. Returning the figure
    will hand it to the `Graph` component and modify its `figure` attribute.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的函数定义中，最后一行是`fig.show()`，而在回调函数中，我们则返回图表对象。这样做的原因是，在第一个例子中，我们是在交互式环境下运行的，并没有应用或回调上下文。而在这个例子中，我们有一个ID为`population_chart`的组件，更重要的是，我们希望修改它的`figure`属性。返回图表对象会将其交给`Graph`组件，从而修改它的`figure`属性。
- en: 'Running this app will produce dynamic charts based on the user selection, as
    you can see in *Figure 3.10*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个应用后，可以根据用户的选择生成动态图表，正如你在*图 3.10*中所看到的：
- en: '![Figure 3.10 – An app displaying a bar chart based on the selected year](img/B16780_03_010.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 一个根据选择的年份显示柱状图的应用](img/B16780_03_010.jpg)'
- en: Figure 3.10 – An app displaying a bar chart based on the selected year
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 一个根据选择的年份显示柱状图的应用
- en: If you compare this to *Figure 3.8*, you will notice that the country names
    are displayed vertically here, while, previously, they were displayed at a certain
    angle. This is simply because the chart was displayed in a wider browser window.
    This is another convenient default that Plotly handles for us without us having
    to do anything. This means that our figures are responsive, which gives them great
    flexibility. This is the same with the apps and their components that we style
    with Dash Bootstrap Components.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此与*图 3.8*进行对比，你会注意到这里国家名称是垂直显示的，而之前它们是以一定角度显示的。之所以会这样，是因为图表显示在了更宽的浏览器窗口中。这是Plotly为我们处理的又一个便捷默认设置，我们不需要做任何事情。这意味着我们的图表具有响应式特性，使它们非常灵活。这对于我们使用Dash
    Bootstrap Components样式的应用和组件同样适用。
- en: Now that we have created an isolated app that works independently, let's look
    at how to add this to our app.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个可以独立运行的应用，接下来我们来看如何将其添加到我们的应用中。
- en: Adding the new functionality to our app
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的应用中添加新功能
- en: 'So far, the latest version of the app contains a `Dropdown` component, and
    underneath that, the `Div` for the population report of 2010\. Underneath that,
    we have the `Tabs` component. Let''s now insert the new `Dropdown` and `Graph`
    components right underneath the report area, and above the `Tabs` component. Let''s
    also add the new callback function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用程序的最新版本包含一个`Dropdown`组件，在其下方是2010年人口报告的`Div`，在其下方是`Tabs`组件。现在，让我们在报告区域下方、`Tabs`组件上方插入新的`Dropdown`和`Graph`组件。我们还要添加新的回调函数：
- en: 'Copy the two new components to where they belong in the `app.layout` attribute:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制这两个新组件，并将它们放到`app.layout`属性中应在的位置：
- en: '[PRE19]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Copy the callback function definition and place it anywhere after the closing
    tag of the top-level `Div` of `app.layout`. You can place it under the previous
    callback function that we created for better organization, but it doesn''t matter
    where you place it in terms of functionality:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制回调函数定义，并将其放置在`app.layout`的顶级`Div`的闭合标签之后的任何位置。为了更好的组织，你可以将它放在我们为更好的组织所创建的上一个回调函数下面，但在功能上它放置的位置无关紧要：
- en: '[PRE20]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the definition of the `regions` list and then `population_df` after the
    definition of `poverty_data`. The order is important because `population_df` depends
    on `regions` to be defined before it, and since it is a subset of `poverty_data`,
    it also needs to be defined after it. This is the order in which these variables
    need to be defined:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义`poverty_data`之后，添加`regions`列表的定义，再添加`population_df`。顺序很重要，因为`population_df`依赖于先定义`regions`，而且它是`poverty_data`的子集，所以它也需要在`poverty_data`之后定义。这是这些变量需要定义的顺序：
- en: '[PRE21]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, if we run the app, you can see what it looks like in *Figure 3.11*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行应用程序，你可以看到它的样子，如*图 3.11*所示：
- en: '![Figure 3.11 – The app with the new components added (Dropdown and Graph).](img/B16780_03_011.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 添加了新组件的应用程序（下拉框和图表）](img/B16780_03_011.jpg)'
- en: Figure 3.11 – The app with the new components added (Dropdown and Graph).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 添加了新组件的应用程序（下拉框和图表）。
- en: 'If you open the debugger and click on the **Callbacks** button, you can also
    see an updated view of the available callbacks, along with the names of the components
    that they link to (the component IDs and the component properties). *Figure 3.12*
    shows this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开调试器并点击**回调函数**按钮，你还可以看到更新后的可用回调函数视图，并查看它们所连接的组件的名称（组件ID和组件属性）。*图 3.12*
    展示了这一点：
- en: '![Figure 3.12 – The app callbacks in the visual debugger](img/B16780_03_012.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 视觉调试器中的应用回调函数](img/B16780_03_012.jpg)'
- en: Figure 3.12 – The app callbacks in the visual debugger
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 视觉调试器中的应用回调函数
- en: Our app now displays more information. It allows users to get information interactively
    from the dataset. We defined two callback functions and have a layout that contains
    several components of different types. We also have about 90 lines of code in
    total. Simply adding new components by inserting them somewhere works fine until
    you have a large enough number of them in the app. Then, we will need to learn
    how to better organize the code and refactor it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序显示了更多信息。它允许用户从数据集中互动式地获取信息。我们定义了两个回调函数，并且有一个包含多种类型组件的布局。我们总共有大约90行代码。通过将新组件插入到某个位置，可以顺利地添加新组件，直到应用程序中的组件数量足够大。然后，我们将需要学习如何更好地组织代码并进行重构。
- en: Let's close this chapter with a fun, easy-to-use aspect of the Plotly `Figure`
    object, which does not require much coding, and then recap the topics covered.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个有趣且易于使用的Plotly `Figure`对象的方面来结束本章，它不需要太多的编码，然后回顾一下我们所讨论的主题。
- en: Theming your figures
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为你的图形设置主题
- en: 'Theming your figures (as opposed to your apps) can be interesting and saves
    a lot of time if you need to change themes. This can be accessed and modified
    through the `template` attribute under `layout`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的图形设置主题（而不是你的应用程序）可能会很有趣，并且如果需要更改主题，这样做可以节省大量时间。这可以通过`layout`中的`template`属性进行访问和修改：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Figure 3.13* shows four different templates and their names:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.13* 展示了四种不同的模板及其名称：'
- en: '![Figure 3.13 – Four different Figure templates](img/B16780_03_013.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 四种不同的图形模板](img/B16780_03_013.jpg)'
- en: Figure 3.13 – Four different Figure templates
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 四种不同的图形模板
- en: The full list of templates is available in `plotly.io.templates`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的模板列表可以在`plotly.io.templates`中找到。
- en: This is helpful when you want your figures to have a template that is compatible
    with the app's theme. It is also a good starting point to enable you to select
    one of the templates and then modify a few of its elements as you see fit.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这在你希望图形具有与应用主题兼容的模板时非常有用。它也是一个很好的起点，可以让你选择一个模板，并根据需要修改其中的一些元素。
- en: Let's now recap the topics that we have covered in this chapter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回顾一下本章中涉及的主题。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started by introducing the `Figure` object, its components, and subcomponents.
    We looked at how to create figures step by step, and how to modify various aspects
    of them. We also took an extensive look at the two main attributes of figures,
    the `data` and `layout` attributes. A few ways of converting figures were also
    explored, and we then created a chart based on our dataset and incorporated it
    into our app.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从介绍`Figure`对象、其组件和子组件开始。我们逐步学习了如何创建图形，以及如何修改它们的各个方面。我们还深入了解了图形的两个主要属性——`data`和`layout`属性。我们还探索了几种图形转换的方法，接着我们基于数据集创建了一个图表，并将其集成到我们的应用程序中。
- en: With the chapters you have read so far, you now know how to create and structure
    apps, how to make them interactive by creating callbacks that link various page
    components together, and how to build charts that fit into the whole system.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，通过你所阅读的章节，你已经知道如何创建和构建应用程序，如何通过创建回调函数将不同的页面组件连接起来使应用互动，以及如何构建适应整个系统的图表。
- en: You now know how to build fully interactive apps, and with the understanding
    developed in this chapter, you also know how to manage the various aspects of
    your figures and make sure that they are easy to read, so your users can spend
    more time on analysis and less time on understanding the charts themselves.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何构建完全互动的应用程序，并且通过本章所学，你还知道如何管理图形的各个方面，并确保它们易于阅读，这样用户就可以花更多时间进行分析，减少理解图表本身的时间。
- en: We briefly observed the importance of data preparation and manipulation, and
    we are now ready to take a more extensive look at it. In the next chapter, we
    will introduce **Plotly Express**, a powerful and higher-level interface that
    is used to create charts concisely.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要观察了数据准备和处理的重要性，现在我们准备更深入地探讨它。在下一章中，我们将介绍**Plotly Express**，这是一种强大且更高层次的接口，用于简洁地创建图表。
