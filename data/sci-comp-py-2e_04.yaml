- en: Linear Algebra - Arrays
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数 - 数组
- en: Linear algebra is one of the essential building blocks of computational mathematics.
    The objects of linear algebra are vectors and matrices. The package NumPy includes
    all the necessary tools to manipulate those objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数是计算数学中的一个基本组成部分。线性代数的对象是向量和矩阵。NumPy包包含了处理这些对象所需的所有工具。
- en: The first task is to build matrices and vectors or to alter existing ones by
    slicing. The other main task is the dot operation, which embodies most linear
    algebra operations (scalar product, matrix-vector product, and matrix-matrix product).
    Finally, various methods are available to solve linear problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是构建矩阵和向量，或通过切片修改现有的矩阵和向量。另一个主要任务是点积运算，它包含了大多数线性代数运算（标量积、矩阵-向量积和矩阵-矩阵积）。最后，提供了多种方法来解决线性问题。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节将涵盖以下主题：
- en: Overview of the array type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组类型概述
- en: Mathematical preliminaries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学预备知识
- en: The array type
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组类型
- en: Accessing array entries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问数组元素
- en: Functions to construct arrays
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造数组的函数
- en: Accessing and changing the shape
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问和更改形状
- en: Stacking
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆叠
- en: Functions acting on arrays
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数组进行操作的函数
- en: Linear algebra methods in SciPy
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SciPy中的线性代数方法
- en: 4.1 Overview of the array type
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 数组类型概述
- en: For the impatient, here is how to use arrays in a nutshell. Be aware though
    that the behavior of arrays may be surprising at first, so we encourage you to
    read on after this introductory section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于急于了解的读者，以下是如何使用数组的简要介绍。不过需要注意的是，数组的行为一开始可能会让人感到惊讶，因此我们建议在阅读完本介绍部分后继续阅读。
- en: 'Note again, the presentation in this chapter assumes like everywhere else in
    this book that you have the module NumPy imported:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，本章节的呈现方式假设你已经导入了NumPy模块，正如本书其他地方所假设的那样：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By importing NumPy, we give access to the datatype `ndarray`, which we'll describe
    in the next sections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入NumPy，我们可以访问数据类型`ndarray`，将在接下来的章节中进行描述。
- en: 4.1.1 Vectors and matrices
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1.1 向量和矩阵
- en: 'Creating vectors is as simple as using the function `array` to convert a list
    into an array:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建向量就像使用`array`函数将一个列表转换为数组一样简单：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The object `v` is now a vector that behaves much like a vector in linear algebra.
    We have already emphasized the differences with the list object in Python in [Section
    3.2](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *A quick glance at the concept
    of arrays*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`v`现在是一个向量，表现得很像线性代数中的向量。我们已经在[第3.2节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)中强调了它与Python中的列表对象的区别：*快速了解数组的概念*。
- en: 'Here are some illustrations of the basic linear algebra operations on vectors:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些对向量进行基本线性代数运算的示例：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that all basic arithmetic operations are performed elementwise:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有基本算术操作都是按元素进行的：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Some functions act elementwise on arrays as well:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些函数也按元素对数组进行操作：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This subject will be covered in [Section](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml) 4.8: *Functions
    acting on arrays.*
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题将在[第4.8节](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)中讲解：*对数组进行操作的函数*。
- en: 'A matrix is created in a similar way to a vector, but from a list of lists
    instead:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的创建与向量类似，只是它是从列表的列表中创建的：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note, vectors are not column or row matrices. An ![](img/dd804db6-ce44-4feb-b8b6-359bc63442df.png)
    vector, an ![](img/75c70cc7-6946-4e16-af4b-c6ba929f7142.png), and a ![](img/6f7b05e6-6f92-4cef-831d-790496c52a3b.png)
    matrix are three different objects even if they contain the same data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，向量并不是列矩阵或行矩阵。一个![](img/dd804db6-ce44-4feb-b8b6-359bc63442df.png)向量、一个![](img/75c70cc7-6946-4e16-af4b-c6ba929f7142.png)，以及一个![](img/6f7b05e6-6f92-4cef-831d-790496c52a3b.png)矩阵是三种不同的对象，即使它们包含相同的数据。
- en: 'To create a row matrix containing the same data as the vector `v = array([1.,
    2., 1.])`, we apply the method `reshape`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个行矩阵，包含与向量`v = array([1., 2., 1.])`相同的数据，我们应用`reshape`方法：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The corresponding column matrix is obtained by `reshape` in a corresponding
    manner:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的列矩阵通过`reshape`以相应的方式获得：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After having learned how to create arrays and after having seen basic array
    operations, we will study now how array elements and subarrays can be addressed
    by indexing and slicing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何创建数组并看到基本的数组操作后，我们现在将学习如何通过索引和切片来访问数组元素和子数组。
- en: 4.1.2 Indexing and slices
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1.2 索引和切片
- en: 'Indexing and slicing are similar to the corresponding operations for lists.
    The main difference is that there may be several indexes or slices when the array
    is a matrix. The subject will be covered in depth in [Section 4.4.1](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml):
    *Basic array slicing*; here, we just give some illustrative examples of indexing
    and slicing:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 索引和切片与列表中的对应操作类似。主要区别在于，当数组是矩阵时，可能会有多个索引或切片。该主题将在[第4.4.1节](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)：*基本数组切片*中深入讨论；在这里，我们仅提供一些索引和切片的示例：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As arrays are the basic datatype for all tasks in computational linear algebra,
    we now present in this overview section some examples, the dot product and the
    solution of linear equation systems.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组是所有计算线性代数任务的基本数据类型，本文本节将展示一些示例、点积及线性方程组的解法。
- en: 4.1.3 Linear algebra operations
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1.3 线性代数操作
- en: 'The essential operator that performs most of the usual operations of linear algebra
    is the Python function `dot`. It is used for matrix-vector multiplications (see
    [Section 4.2.4](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *The dot operations*
    for more details):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 执行大多数常见线性代数操作的关键运算符是Python函数`dot`。它用于矩阵-向量乘法（有关详细信息，请参阅[第4.2.4节](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)：*点积操作*）：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It may be used to compute a scalar product between two vectors:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用来计算两个向量之间的标量积：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly, it is used to compute matrix-matrix products:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它用于计算矩阵-矩阵乘积：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Solving a linear system
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 求解线性系统
- en: If [![](img/d658ccfe-c6c7-4c0f-9b56-efc5b11df1c4.png)] is a matrix and [![](img/16de0f6a-2627-450c-bd4f-0d2a6fab42a3.png)]
    is a vector, you can solve the linear equation system
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[![](img/d658ccfe-c6c7-4c0f-9b56-efc5b11df1c4.png)]是矩阵，[![](img/16de0f6a-2627-450c-bd4f-0d2a6fab42a3.png)]是向量，你可以求解线性方程组
- en: '![](img/1378855e-0cd6-4a0c-b7e0-23e04a9d4809.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1378855e-0cd6-4a0c-b7e0-23e04a9d4809.png)'
- en: 'by using the function `solve` from the linear algebra submodule `numpy.linalg`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性代数子模块`numpy.linalg`中的`solve`函数：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For example, to solve
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，求解
- en: '![](img/b6d5dd31-f278-4cf2-8ab2-cd4287fa3b29.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6d5dd31-f278-4cf2-8ab2-cd4287fa3b29.png)'
- en: 'the following Python statements are executed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下Python语句：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The command `allclose` is used here to compare two vectors. If they are close
    enough to each other, this command returns `True`. Optionally a tolerance value
    can be set. For more methods related to linear equation systems, see [Section](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml) 4.9: *Linear
    algebra methods in SciPy*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`allclose`用于比较两个向量。如果它们足够接近，该命令返回`True`。可以选择设置容差值。有关与线性方程组相关的更多方法，请参阅[第4.9节](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)：*SciPy中的线性代数方法*。
- en: Now, you have seen the first and essential way of how to use arrays in Python.
    In the following sections, we'll show you more details and the underlying principles.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经看到了在Python中使用数组的第一种基本方式。在接下来的章节中，我们将向你展示更多细节及其基本原理。
- en: 4.2 Mathematical preliminaries
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 数学基础
- en: In order to understand how arrays work in NumPy, it is useful to understand
    the mathematical parallel between accessing tensor (matrix and vector) elements
    by indexes and evaluating mathematical functions by providing arguments. We also
    cover in this section the generalization of the dot product as a reduction operator.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解数组在NumPy中的工作原理，了解通过索引访问张量（矩阵和向量）元素与通过提供参数评估数学函数之间的数学关系非常有用。我们还将在本节中介绍点积作为归约算子的推广。
- en: 4.2.1 Arrays as functions
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.1 将数组视为函数
- en: Arrays may be considered from several different points of view. If you want
    to approach the concept from a mathematical point of view, you might benefit from understanding
    arrays through an analogy of functions of several variables. This view will later
    be taken again, when explaining the concept of broadcasting in [Section](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml) 5.5: *Broadcasting**.*
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以从多个不同的角度进行考虑。如果你希望从数学角度理解这一概念，可能会通过将数组类比为多个变量的函数来获益。这个视角将在后续讲解广播概念时再次提到，[第5.5节](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)：*广播*。
- en: 'For instance, selecting a component of a given vector in ![](img/0827edf6-8019-496b-87da-a611639c6ab4.png)may
    just be considered a function from the set of ![](img/49fb25fc-995c-4a1c-b7db-fb0ca393e72e.png)
    to ![](img/cab4aa7c-b61f-459e-afa8-71cd5baa66f1.png), where we define the set:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，选择给定向量中的一个分量，在![](img/0827edf6-8019-496b-87da-a611639c6ab4.png)中可能被视为从![](img/49fb25fc-995c-4a1c-b7db-fb0ca393e72e.png)到![](img/cab4aa7c-b61f-459e-afa8-71cd5baa66f1.png)的函数，其中我们定义集合：
- en: '![](img/f1785531-d885-4fce-80da-fc35bec04dbe.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1785531-d885-4fce-80da-fc35bec04dbe.png)'
- en: Here the set ![](img/9ff103aa-3603-4365-9d45-818b85a2c38d.png) has *n* elements.
    The Python function `range` generates [*![](img/45ed4521-0799-4a89-9601-da50700491a7.png)*].
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，集合 ![](img/9ff103aa-3603-4365-9d45-818b85a2c38d.png) 有 *n* 个元素。Python 函数
    `range` 生成 [*![](img/45ed4521-0799-4a89-9601-da50700491a7.png)*]。
- en: Selecting an element of a given matrix, on the other hand, is a function of
    two parameters, taking its value in ![](img/2dd26863-2ac9-4c48-83ef-25700ef810e6.png).
    Picking a particular element of an *![](img/07d6e38b-b49b-4337-8925-160b771356ab.png)*
    matrix may thus be considered a function from ![](img/5398c6ee-de44-43c1-b7fb-7c30dbfe6117.png)
    to ![](img/f0d6533e-221c-4d66-8138-a00f24e830e0.png).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，选择一个给定矩阵的元素是一个有两个参数的函数，其值域为 ![](img/2dd26863-2ac9-4c48-83ef-25700ef810e6.png)。从一个
    *![](img/07d6e38b-b49b-4337-8925-160b771356ab.png)* 矩阵中选择特定元素，因此可以看作是一个从 ![](img/5398c6ee-de44-43c1-b7fb-7c30dbfe6117.png)
    到 ![](img/f0d6533e-221c-4d66-8138-a00f24e830e0.png) 的函数。
- en: 4.2.2 Operations are elementwise
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.2 操作是逐元素的
- en: NumPy arrays are essentially treated as mathematical functions. This is in particular
    true for operations. Consider two functions, ![](img/4cdad02e-e6f4-4c17-95c7-bfd5cf329282.png)
    and ![](img/6acb3ba5-69f9-4970-a5f4-90f7281ac936.png), defined on the same domain
    and taking real values. The product ![](img/8bd32329-08fb-4861-b05a-64b90be30405.png)
    of those two functions is defined as the pointwise product, that is,
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组本质上被当作数学函数来处理。特别是对于操作来说是这样。考虑两个定义在同一域并且取实值的函数，![](img/4cdad02e-e6f4-4c17-95c7-bfd5cf329282.png)
    和 ![](img/6acb3ba5-69f9-4970-a5f4-90f7281ac936.png)。这两个函数的乘积 ![](img/8bd32329-08fb-4861-b05a-64b90be30405.png)
    被定义为逐点乘积，即：
- en: '![](img/1e717cdf-b96e-492a-a775-81175e062d39.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e717cdf-b96e-492a-a775-81175e062d39.png)'
- en: 'Note that this construction is possible for any operation between two functions.
    For an arbitrary operation defined on two scalars, which we denote here by ![](img/17a32615-8ff1-488f-b7df-8fc015e28be2.png),
    we could define ![](img/4e03099d-ba8c-47a9-865e-a675a56e4e02.png) as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种构造对于两个函数之间的任何操作都是可能的。对于一个在两个标量之间定义的任意操作，我们这里用 ![](img/17a32615-8ff1-488f-b7df-8fc015e28be2.png)
    表示，可以将 ![](img/4e03099d-ba8c-47a9-865e-a675a56e4e02.png) 定义如下：
- en: '![](img/9564f5b5-d0d8-45d1-9a6a-f8d3968aac02.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9564f5b5-d0d8-45d1-9a6a-f8d3968aac02.png)'
- en: 'This innocuous remark allows us to understand NumPy''s stance on operations;
    all operations are elementwise in arrays. For instance, the product between two
    matrices, ![](img/498ba54b-8eb4-40c7-9b03-4ff15b67a00d.png) and ![](img/2aa90bb5-7dbc-4b46-9e63-053f3c934bcf.png),
    is defined, as with functions, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这一看似无害的言论让我们理解了 NumPy 对操作的立场；所有操作在数组中都是逐元素的。例如，两个矩阵之间的乘积，![](img/498ba54b-8eb4-40c7-9b03-4ff15b67a00d.png)
    和 ![](img/2aa90bb5-7dbc-4b46-9e63-053f3c934bcf.png)，就像函数一样，其定义如下：
- en: '![](img/9fc20d80-879e-43b3-be9d-6d65c0bd6d78.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9fc20d80-879e-43b3-be9d-6d65c0bd6d78.png)'
- en: 4.2.3 Shape and number of dimensions
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.3 形状和维度数
- en: 'There is a clear distinction between a:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个明确的区分：
- en: '*Scalar:* A function with no arguments'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标量*：没有参数的函数'
- en: '*Vector:* A function with one argument'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向量*：一个具有一个参数的函数'
- en: '*Matrix:* A function with two arguments'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*矩阵*：具有两个参数的函数'
- en: '*Higher-order tensor*: A function with more than two arguments'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高阶张量*：具有两个以上参数的函数'
- en: In what follows, the number of dimensions is the number of arguments of a function.
    The shape corresponds essentially to the domain of a function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容中，维度数是一个函数的参数个数。形状本质上对应于一个函数的定义域。
- en: 'For instance, a vector of size *n* is a function from the set ![](img/3e022549-3df7-4296-89f7-f07c4a254201.png) to
    ![](img/67c574fe-7309-413d-bc56-5dbfee30661e.png). As a result, its domain  is
    ![](img/914d84e0-9c6a-4895-9e11-c42f794a770a.png). Its shape is defined as the
    singleton (*n,*). Similarly, a matrix of size ![](img/61fcaba3-7269-4d3d-b042-734057d63e0b.png) is
    a function defined on ![](img/cbf9a605-eaf9-45d2-843e-ee7498361ef6.png). The corresponding
    shape is simply the pair (*m*, *n*). The shape of an array is obtained by the
    function `numpy.shape`, and the number of dimensions by the function `numpy.ndim`;
    see also [Section 4.6](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *Accessing
    and changing the shape*.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个大小为 *n* 的向量是一个从集合 ![](img/3e022549-3df7-4296-89f7-f07c4a254201.png) 到 ![](img/67c574fe-7309-413d-bc56-5dbfee30661e.png)
    的函数。因此，它的定义域是 ![](img/914d84e0-9c6a-4895-9e11-c42f794a770a.png)。它的形状定义为单例 (*n*,)。类似地，大小为
    ![](img/61fcaba3-7269-4d3d-b042-734057d63e0b.png) 的矩阵是一个定义在 ![](img/cbf9a605-eaf9-45d2-843e-ee7498361ef6.png)
    上的函数。相应的形状就是一对 (*m*, *n*)。数组的形状由函数 `numpy.shape` 获取，维度数由函数 `numpy.ndim` 获取；请参见
    [第 4.6 节](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)：*访问和更改形状*。
- en: 4.2.4 The dot operations
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.4 点积操作
- en: 'Treating arrays as functions, although very powerful, completely neglects the
    linear algebra structures we are familiar with, that is, matrix-vector and matrix-matrix
    operations. Fortunately, these linear algebra operations may all be written in
    a similar unified form:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组视为函数，虽然非常强大，但完全忽略了我们熟悉的线性代数结构，即矩阵-向量和矩阵-矩阵操作。幸运的是，这些线性代数操作可以都写成类似的统一形式：
- en: 'The vector-vector operation:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 向量-向量操作：
- en: '![](img/5d4531ef-e516-4ea5-907d-0de7b6edc077.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d4531ef-e516-4ea5-907d-0de7b6edc077.png)'
- en: 'The matrix-vector operation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵-向量操作：
- en: '![](img/6b07789a-b088-40b2-aa11-da31e046119c.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b07789a-b088-40b2-aa11-da31e046119c.png)'
- en: 'The matrix-matrix operation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵-矩阵操作：
- en: '![](img/d1e4e002-ee95-448c-91bd-4c9ecfa7120d.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1e4e002-ee95-448c-91bd-4c9ecfa7120d.png)'
- en: 'The vector-matrix operation:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 向量-矩阵操作：
- en: '![](img/91a09614-743b-4b57-8b5c-2b98fd13232b.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91a09614-743b-4b57-8b5c-2b98fd13232b.png)'
- en: 'The essential mathematical concept is that of reduction. For a matrix-vector
    operation, the reduction is given by:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本质的数学概念是“约简”（reduction）。对于矩阵-向量操作，约简由以下公式给出：
- en: '![](img/aec07b60-4dd3-4aa2-a52c-c21caae0c27d.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aec07b60-4dd3-4aa2-a52c-c21caae0c27d.png)'
- en: 'In general, a reduction operation defined between two tensors, ![](img/1f0c151e-39a4-4e33-b6cf-23789680aa6e.png) and
    ![](img/8016ef96-8baa-48ac-80e0-56016e765985.png), of respective number of dimensions
    ![](img/58f0e0a7-a065-40a0-82b0-d8c685294696.png) and ![](img/cfd803fd-209a-4fa1-82cc-b2fa4237e1ac.png) may
    be defined as:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在两个张量之间定义的约简操作，分别是 ![](img/1f0c151e-39a4-4e33-b6cf-23789680aa6e.png) 和
    ![](img/8016ef96-8baa-48ac-80e0-56016e765985.png)，它们的维度分别是 ![](img/58f0e0a7-a065-40a0-82b0-d8c685294696.png) 和
    ![](img/cfd803fd-209a-4fa1-82cc-b2fa4237e1ac.png)，可以定义为：
- en: '![](img/6d735bf5-14bf-40c0-b43b-3347aab64854.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d735bf5-14bf-40c0-b43b-3347aab64854.png)'
- en: Clearly, the shapes of the tensors must be compatible with that operation to
    make
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，张量的形状必须与该操作兼容才能产生
- en: any sense. This requirement is familiar for matrix-matrix multiplication. The
    multiplication ![](img/e5b3c2c8-d223-4b63-9afe-67c3946130b2.png)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求对于矩阵-矩阵乘法也很熟悉。乘法 ![](img/e5b3c2c8-d223-4b63-9afe-67c3946130b2.png)
- en: of matrices ![](img/40c5c7dc-0cc9-4c09-b130-5ed416713e2c.png) and *![](img/2ed6b962-1034-42c4-bcd7-9f6df445ef53.png)*
    only makes sense if the number of columns of ![](img/3f6cc52f-5279-45b4-ab25-c779292f6c32.png) equals
    the number of rows of *![](img/4fc01d29-fe44-4681-8146-b4b1da231ed4.png)*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵 ![](img/40c5c7dc-0cc9-4c09-b130-5ed416713e2c.png) 和 *![](img/2ed6b962-1034-42c4-bcd7-9f6df445ef53.png)*
    之间的操作，只有当 ![](img/3f6cc52f-5279-45b4-ab25-c779292f6c32.png) 的列数等于 *![](img/4fc01d29-fe44-4681-8146-b4b1da231ed4.png)*
    的行数时才有意义。
- en: 'Another consequence of the reduction operation is that it produces a new tensor
    with ![](img/907b8b22-fae5-42f9-bff7-b0381719d8fa.png) dimensions. In *Table 4.1*,
    we gather the output of the reduction operation for the familiar cases involving
    matrices and vectors:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 约简操作的另一个结果是它生成了一个具有 ![](img/907b8b22-fae5-42f9-bff7-b0381719d8fa.png) 维度的新张量。在*表
    4.1*中，我们收集了涉及矩阵和向量的约简操作输出：
- en: '| **![](img/badb856c-cd63-4a10-a3c2-8d733fd6ecc6.png)** | **![](img/61296058-9a76-48b0-a429-4e031bf7f616.png)**
    | **![](img/a80b9a58-4dbc-4325-ba0b-20a3c0b6c80c.png)** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **![](img/badb856c-cd63-4a10-a3c2-8d733fd6ecc6.png)** | **![](img/61296058-9a76-48b0-a429-4e031bf7f616.png)**
    | **![](img/a80b9a58-4dbc-4325-ba0b-20a3c0b6c80c.png)** |'
- en: '| ![](img/28959d31-3da1-4a37-b9ba-a658517250f8.png) | ![](img/669e969c-43c9-462d-8448-9d6663e312eb.png)
    | ![](img/72498382-abab-44ee-ba00-50bbbfecc71e.png) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/28959d31-3da1-4a37-b9ba-a658517250f8.png) | ![](img/669e969c-43c9-462d-8448-9d6663e312eb.png)
    | ![](img/72498382-abab-44ee-ba00-50bbbbfecc71e.png) |'
- en: '| ![](img/9c3f79f5-ffa7-4480-8e0a-590a2a493fe5.png) | ![](img/f6d4ee8a-e85c-4952-a3d1-e6810b28d983.png)
    | ![](img/c6bd4cfd-a634-4531-90b9-69050d2a9ac0.png) |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/9c3f79f5-ffa7-4480-8e0a-590a2a493fe5.png) | ![](img/f6d4ee8a-e85c-4952-a3d1-e6810b28d983.png)
    | ![](img/c6bd4cfd-a634-4531-90b9-69050d2a9ac0.png) |'
- en: '| ![](img/9e9cd9c3-4a88-4eb3-b242-a59c8b0b2b13.png) | ![](img/742d6bd6-3c77-497f-8f05-ba91268a2709.png)
    | ![](img/ab0a2853-845f-403d-818a-9163956b0ba9.png) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/9e9cd9c3-4a88-4eb3-b242-a59c8b0b2b13.png) | ![](img/742d6bd6-3c77-497f-8f05-ba91268a2709.png)
    | ![](img/ab0a2853-845f-403d-818a-9163956b0ba9.png) |'
- en: '| ![](img/74866b6c-26bb-499a-bfc9-93c23837a315.png) | ![](img/f8606684-f88f-4c51-991c-29b266868d6e.png)
    | ![](img/7c5146dc-ee25-4f2b-867d-f726be6c87ab.png) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/74866b6c-26bb-499a-bfc9-93c23837a315.png) | ![](img/f8606684-f88f-4c51-991c-29b266868d6e.png)
    | ![](img/7c5146dc-ee25-4f2b-867d-f726be6c87ab.png) |'
- en: '​Table 4.1: Output of the reduction operation involving matrices and vectors'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ​表 4.1：涉及矩阵和向量的约简操作输出
- en: 'In Python, all reduction operations are performed using the `dot` function
    or alternatively the `@` operator:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，所有的约简操作都可以通过 `dot` 函数或 `@` 操作符来执行：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In Python version 3.5 or higher, the dot product can be written either in its
    operator form, `dot(M, v)`, or by using the infix notation, `M @ v`. From now
    on we'll stick to the more handy infix notation; you can modify the examples if
    the other form is preferred. We note, however, that `dot` performs type casting
    to arrays if its arguments are of other types that can be cast to an array, such
    as list or float. The infix operator form with `@` does not have this feature.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.5及更高版本中，点积可以用其运算符形式`dot(M, v)`表示，或者使用中缀符号表示`M @ v`。从现在起，我们将坚持使用更方便的中缀符号；如果需要其他形式，您可以修改示例。然而，我们需要注意的是，`dot`会在其参数类型为其他可以转换为数组的类型（如列表或浮点数）时执行类型转换。而中缀运算符`@`则不具有这个特性。
- en: 'The multiplication operator `*` is always elementwise. It has nothing to do
    with the dot operation. Even if *![](img/04ede9d1-0823-4b24-a5e7-fc247edcc0fa.png) *is
    a matrix and ![](img/8d8c60e1-cd74-45d6-9ec6-1798e72a0077.png) is a vector, `A*v`
    is still a legal operation. This will be explained in [Section 5.5](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml):
    *Broadcasting*.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法运算符`*`始终是逐元素的。它与点积操作无关。即使*![](img/04ede9d1-0823-4b24-a5e7-fc247edcc0fa.png)*是矩阵，且![](img/8d8c60e1-cd74-45d6-9ec6-1798e72a0077.png)*是向量，`A*v`仍然是合法的操作。这将在[第5.5节](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)中解释：*广播*。
- en: In this section, we identified the use of arrays with matrices and vectors in
    mathematics and explained operations. In particular, the most central operation
    in scientific computation, the dot product, was explained. We turn now to the
    array datatype `ndarray` and its methods more generally.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了在数学中使用数组与矩阵和向量的结合，并解释了相关的操作。特别地，我们解释了科学计算中最核心的操作——点积。接下来，我们将转向数组数据类型`ndarray`及其更一般的方法。
- en: 4.3 The array type
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.3 数组类型
- en: The objects used to manipulate vectors, matrices, and more general tensors in
    NumPy are called ndarrays, or just arrays for short. In this section, we examine
    their essential properties, how to create them, and how to access their information.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 用于操作向量、矩阵以及更一般张量的对象在NumPy中被称为ndarray，简称数组。在本节中，我们将探讨它们的基本属性、如何创建它们以及如何访问其信息。
- en: 4.3.1 Array properties
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3.1 数组属性
- en: 'Arrays are essentially characterized by the three properties, described in
    *Table 4.2*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 数组本质上由三个属性来表征，这些属性在*表4.2*中进行了描述。
- en: '| **Name** | **Description** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| `shape` | This describes how the data should be interpreted, as a vector,
    a matrix, or a higher-order tensor, and it gives the corresponding dimension.
    It is accessed with the attribute `shape`. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `shape` | 该属性描述数据应如何解释，例如作为向量、矩阵或更高阶张量，并给出相应的维度。可以通过`shape`属性访问该值。 |'
- en: '| `dtype` | This gives the type of the underlying data (float, complex, integer,
    and so on). |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `dtype` | 该属性给出基础数据的类型（如浮点数、复数、整数等）。 |'
- en: '| `strides` | This attribute specifies in which order the data should be read.
    For instance, a matrix could be stored in memory contiguously column by column
    (FORTRAN convention), or row by row (C convention). The attribute is a tuple with
    the numbers of bytes that have to be skipped in memory to reach the next row and
    the number of bytes to be skipped to reach the next column. It even allows for
    a more flexible interpretation of the data in memory, which is what makes array
    views possible. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `strides` | 此属性指定数据应该如何读取。例如，一个矩阵可以按照列顺序（FORTRAN约定）或行顺序（C约定）连续存储在内存中。该属性是一个元组，包含到达下一行和下一列时需要跳过的字节数。它甚至允许对内存中的数据进行更灵活的解释，这也使得数组视图成为可能。
    |'
- en: 'Table 4.2: The three characterizing properties of an array'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2：数组的三个特征属性
- en: 'Consider, for example, the following array:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下数组：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Its elements have the type `'int64'`; that is, they use 64 bits or 8 bytes in
    memory. The complete array is stored in memory row-wise. The distance from `A[0,
    0]` to the first element in the next row `A[1,0]` is thus 24 bytes (three matrix
    elements) in memory. Correspondingly, the distance in memory between `A[0,0]` and `A[0,1]` is
    8 bytes (one matrix element). These values are stored in the attribute `strides`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它的元素类型为`'int64'`，即它们在内存中占用64位或8个字节。整个数组按行存储在内存中。从`A[0, 0]`到下一行第一个元素`A[1,0]`的内存距离是24个字节（即三个矩阵元素）。相应地，`A[0,0]`和`A[0,1]`之间的内存距离是8个字节（即一个矩阵元素）。这些值存储在`strides`属性中。
- en: 4.3.2 Creating arrays from lists
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3.2 从列表创建数组
- en: 'The general way to create an array is by using the function `array`. The syntax
    to create a real-valued vector would be:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组的一般方法是使用 `array` 函数。创建实值向量的语法如下：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To create a complex vector with the same data, you use:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个具有相同数据的复数向量，可以使用：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When no type is specified, the type is guessed. The `array` function chooses
    the type that allows storing all the specified values:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定类型，则会猜测类型。`array` 函数会选择允许存储所有指定值的类型：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'NumPy silently casts floats into integers, which might give unexpected results:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 会默默地将浮点数转换为整数，这可能会导致意外的结果：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The same, often unexpected array type casting happens from `complex` to `float`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，常见的、通常是意外的数组类型转换发生在从 `complex` 到 `float` 之间。
- en: '**Array and Python parentheses**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数组和 Python 括号**'
- en: 'As we noticed in [Section 1.2.2](cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml):
    *Line joining*, Python allows a line break when some opening brace or parenthesis
    is not closed. This allows a convenient syntax for array creation, which makes
    it more pleasing to the human eye:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 [第 1.2.2 节](cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml)：*行连接* 中注意到，Python
    允许在某些括号或圆括号没有关闭时换行。这为数组创建提供了方便的语法，使其更加符合人眼的审美：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So far, you saw a lot of differences in the definition and use between arrays
    and lists. Accessing array elements, in contrast, seems quite similar to the way
    list elements are accessed. But especially the use of multiple indexes and the
    resulting objects from the slicing operations require that we look at these issues
    in more detail.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到数组和列表在定义和使用上的许多区别。相比之下，访问数组元素似乎与访问列表元素非常相似。但尤其是多个索引的使用以及切片操作结果的对象，需要我们更加详细地研究这些问题。
- en: 4.4 Accessing array entries
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.4 访问数组条目
- en: Array entries are accessed by indexes. In contrast to vector coefficients, two
    indexes are needed to access matrix coefficients. These are given in one pair
    of brackets. This distinguishes the array syntax from a list of lists. There,
    two pairs of brackets are needed to access elements.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数组条目通过索引访问。与向量系数不同，访问矩阵系数需要两个索引。这些索引放在一对括号中。这使得数组语法与列表的列表有所区别。在后者中，需要两对括号来访问元素。
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's look now in more detail at the use of double indexes and slices.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更详细地来看一下双重索引和切片的使用。
- en: 4.4.1 Basic array slicing
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4.1 基本数组切片
- en: 'Slices are similar to those of lists (see also [Section 3.1.1](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml):
    *Slicing*) except that they might now be in more than one dimension:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 切片与列表的切片类似（另见 [第 3.1.1 节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)：*切片*），不过它们现在可能存在多个维度：
- en: '`M[i,:]` is a vector filled by the row ![](img/60a8e43a-37e5-406e-bad5-90981a04b955.png) of
    ![](img/c0e17bfb-4fea-4289-9f4f-582181cc5699.png)*.*'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M[i,:]` 是由行 ![](img/60a8e43a-37e5-406e-bad5-90981a04b955.png) 填充的向量，来自 ![](img/c0e17bfb-4fea-4289-9f4f-582181cc5699.png)*.*'
- en: '`M[:,j]` is a vector filled by the column ![](img/47def328-ef21-466c-8046-1574defb7ec6.png) of
    ![](img/450c6166-8464-42a9-b6c1-acce375705c0.png)*.*'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M[:,j]` 是由列填充的向量 ![](img/47def328-ef21-466c-8046-1574defb7ec6.png) 来自 ![](img/450c6166-8464-42a9-b6c1-acce375705c0.png)*.*'
- en: '`M[2:4,:]` is a slice of `2:4` on the rows only.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M[2:4,:]` 是对行的 `2:4` 切片。'
- en: '`M[2:4,1:4]` is a slice of rows and columns.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M[2:4,1:4]` 是行和列的切片。'
- en: 'The result of matrix slicing is given in the following *Figure 4.1*:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵切片的结果见 *图 4.1*：
- en: '![](img/b07bb9d1-b49f-46b6-9d8d-9d8db197d47e.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b07bb9d1-b49f-46b6-9d8d-9d8db197d47e.png)'
- en: 'Figure 4.1: The result of matrix slicing'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：矩阵切片的结果
- en: If you omit an index or a slice, NumPy assumes you are taking rows only. `M[3]` is
    a vector that is a view on the third row of *M *and `M[1:3]` is a matrix that
    is a view on the second and third rows of ![](img/26f718b7-5dab-4498-99cf-52a2ff1616a6.png)*.*
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略索引或切片，NumPy 会假定你只是在取行。`M[3]` 是一个向量，它是对 M 的第三行的视图，而 `M[1:3]` 是一个矩阵，它是对 M
    的第二行和第三行的视图：
- en: 'Changing the elements of a slice affects the entire array (see also [Section
    5.1](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Array views and copies*):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 修改切片的元素会影响整个数组（另见 [第 5.1 节](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)：*数组视图和副本*）：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'General slicing rules are given in *Table 4.3*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一般切片规则见 *表 4.3*：
- en: '| **Access** | **ndim** | **Kind** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **访问** | **ndim** | **类型** |'
- en: '| index, index | 0 | scalar |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 索引, 索引 | 0 | 标量 |'
- en: '| slice, index | 1 | vector |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 切片, 索引 | 1 | 向量 |'
- en: '| index, slice | 1 | vector |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 索引, 切片 | 1 | 向量 |'
- en: '| slice, slice | 2 | matrix |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 切片, 切片 | 2 | 矩阵 |'
- en: 'Table 4.3: General slicing rules'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.3：一般切片规则
- en: 'The results of slicing operations for an array `M` of shape *(4, 4)* are given
    in *Table 4.4*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 `M` 的切片操作结果（形状为 *(4, 4)*）见 *表 4.4*：
- en: '| **Access** | **Shape** | **ndim** | **Kind** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **访问** | **形状** | **维度** | **类型** |'
- en: '| `M[:2, 1:-1]` | (2,2) | 2 | matrix |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `M[:2, 1:-1]` | (2,2) | 2 | 矩阵 |'
- en: '| `M[1,:]` | (4,) | 1 | vector |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `M[1,:]` | (4,) | 1 | 向量 |'
- en: '| `M[1,1]` | () | 0 | scalar |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `M[1,1]` | () | 0 | 标量 |'
- en: '| `M[1:2,:]` | (1,4) | 2 | matrix |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `M[1:2,:]` | (1,4) | 2 | 矩阵 |'
- en: '| `M[1:2, 1:2]` | (1,1) | 2 | matrix |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `M[1:2, 1:2]` | (1,1) | 2 | 矩阵 |'
- en: 'Table 4.4: Result of slicing operations for an array M of shape (4,4)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.4：形状为 (4,4) 的数组 M 的切片操作结果
- en: 4.4.2 Altering an array using slices
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4.2 使用切片更改数组
- en: 'You may alter an array using slices or by direct access. The following changes
    only one element in a ![](img/b44e53a3-95ce-43a3-a6b4-3616878d891c.png) matrix ![](img/c54c7a2c-59a0-4e88-bb60-28e29b2a1852.png):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用切片或直接访问来更改数组。以下示例仅更改一个元素，位于 ![](img/b44e53a3-95ce-43a3-a6b4-3616878d891c.png)
    矩阵 ![](img/c54c7a2c-59a0-4e88-bb60-28e29b2a1852.png) 中：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Also, we may change one full row of the matrix:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以更改矩阵中的一整行：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similarly, we may also replace a full submatrix:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以替换整个子矩阵：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'There is a distinction between a column matrix and a vector. The following
    assignment with a column matrix returns no error:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列矩阵和向量之间是有区别的。以下使用列矩阵的赋值不会报错：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'while the assignment with a vector returns a `ValueError`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 而使用向量赋值时会返回 `ValueError`：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The general slicing rules are shown in *Table 4.3*. The matrices and vectors
    in the preceding examples must have the right size to fit into matrix ![](img/b75a4632-4ef1-495c-891e-1184dfa2bc58.png).
    You may also make use of the broadcasting rules (see [Section 5.5](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Broadcasting*)
    to determine the allowed size of the replacement arrays. If the replacement array
    does not have the right shape, a `ValueError` exception will be raised.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的切片规则如 *表 4.3* 所示。前面的矩阵和向量必须具有适当的大小，以适应矩阵 ![](img/b75a4632-4ef1-495c-891e-1184dfa2bc58.png)。你还可以使用广播规则（参见
    [第 5.5 节](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)：*广播*）来确定替换数组的允许大小。如果替换数组的形状不正确，将引发
    `ValueError` 异常。
- en: We saw how to construct arrays from other arrays by slicing. In the next section,
    we will consider special NumPy functions that are useful to directly create and
    initialize arrays.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何通过切片从其他数组中构造数组。在下一节中，我们将考虑一些直接创建和初始化数组的特殊 NumPy 函数。
- en: 4.5 Functions to construct arrays
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.5 构造数组的函数
- en: 'The usual way to set up an array is via a list. But there are also a couple
    of convenient methods for generating special arrays, which are given in *Table
    4.5*:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 设置数组的常见方法是通过列表。但也有一些方便的方法用于生成特殊数组，这些方法在 *表 4.5* 中给出：
- en: '| **Methods** | **Shape** | **Generates** |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **形状** | **生成的结果** |'
- en: '| `zeros((n,m))` | *(n,m)* | Matrix filled with zeros |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `zeros((n,m))` | *(n,m)* | 填充了 0 的矩阵 |'
- en: '| `ones((n,m)) ` | *(n,m)* | Matrix filled with ones |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `ones((n,m))` | *(n,m)* | 填充了 1 的矩阵 |'
- en: '| `full((n,m),q)` | *(n,m)* | Matrix filled with ![](img/d4907979-e755-4827-ae0b-318783930a2d.png)
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `full((n,m),q)` | *(n,m)* | 填充了 ![](img/d4907979-e755-4827-ae0b-318783930a2d.png)
    的矩阵 |'
- en: '| `diag(v,k) ` | *(n,n)* | (Sub-, super-) diagonal matrix from a vector ![](img/9cb240a7-8fe3-4f7a-862a-2057841ca009.png)
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `diag(v,k)` | *(n,n)* | 来自向量的（下、上）对角矩阵 ![](img/9cb240a7-8fe3-4f7a-862a-2057841ca009.png)
    |'
- en: '| `random.rand(n,m) ` | *(n,m)* | Matrix filled with uniformly distributed
    random numbers in `(0,1)` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `random.rand(n,m)` | *(n,m)* | 填充了均匀分布的随机数（在 `(0,1)` 之间）的矩阵 |'
- en: '| `arange(n)` | *(n,)* | First ![](img/cacd22ff-75a8-40a9-ad1d-b8e06d0c8dd9.png) integers
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `arange(n)` | *(n,)* | 前 n 个整数 ![](img/cacd22ff-75a8-40a9-ad1d-b8e06d0c8dd9.png)
    |'
- en: '| `linspace(a,b,n) ` | *(n,)* | Vector with ![](img/76197639-ef19-4b09-89f0-b6702c4638f1.png) equispaced
    points between ![](img/a68eb689-1673-4372-a195-a071d550b333.png) and ![](img/86a00f21-9e02-489e-9ea3-cdd43faa105e.png)
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `linspace(a,b,n)` | *(n,)* | 向量，包含在 ![](img/76197639-ef19-4b09-89f0-b6702c4638f1.png) 和 ![](img/a68eb689-1673-4372-a195-a071d550b333.png) 之间均匀分布的
    n 个点 |'
- en: 'Table 4.5: Commands to create arrays'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.5：创建数组的命令
- en: These commands may take additional arguments. In particular, the commands `zeros`, `ones`,
    `full`, and `arange` take `dtype` as an optional argument. The default type is `float`,
    except for `arange`. There are also methods such as `zeros_like` and `ones_like`,
    which are slight variants of the preceding ones. For instance, the command `zeros_like(A)` is
    equivalent to `zeros(shape(A))`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令可能会接受额外的参数。特别地，命令 `zeros`、`ones`、`full` 和 `arange` 接受 `dtype` 作为可选参数。默认类型是
    `float`，但 `arange` 除外。也有一些方法，如 `zeros_like` 和 `ones_like`，它们是前述命令的轻微变体。例如，命令 `zeros_like(A)`
    等价于 `zeros(shape(A))`。
- en: 'The function `identity` constructs an identity matrix of a given size:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `identity` 用于构造给定大小的单位矩阵：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The command is identical to:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令与以下命令相同：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 4.6 Accessing and changing the shape
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.6 访问和改变形状
- en: The number of dimensions is what distinguishes a vector from a matrix. The *shape* is
    what distinguishes vectors of different sizes, or matrices of different sizes.
    In this section, we examine how to obtain and change the shape of an array.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 维度数是区分向量和矩阵的标志。*形状* 是区分不同大小的向量或矩阵的标志。在这一节中，我们将研究如何获取和改变数组的形状。
- en: 4.6.1 The function shape
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6.1 `shape` 函数
- en: 'The shape of a matrix is the tuple of its dimensions. The shape of an ![](img/116a1156-6428-4645-83b5-91a371d0ac37.png)
    matrix is the tuple `(n, m)`. It can be obtained by the function `shape`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的形状是其维度的元组。一个 ![](img/116a1156-6428-4645-83b5-91a371d0ac37.png) 矩阵的形状是元组 `(n,
    m)`。可以通过 `shape` 函数获得：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: or, simply by its attribute
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，通过其属性来简单获取
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However, the advantage of using `shape` as a function and not as an attribute
    is that the function may be used on scalars and lists as well. This may come in
    handy when code is supposed to work with both scalars and arrays:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `shape` 作为函数而不是属性的优点在于，函数也可以用于标量和列表。这在代码需要同时处理标量和数组时非常有用：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For a vector, the shape is a singleton containing the length of that vector:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个向量，形状是一个包含该向量长度的单一元素：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 4.6.2 Number of dimensions
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6.2 维度数
- en: 'The number of dimensions of an array is obtained with the function `ndim` or
    using the array attribute `ndim`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的维度可以通过 `ndim` 函数或数组的 `ndim` 属性来获得：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that the number of dimensions, given by the function `ndim`, of a tensor `T` (a
    vector, matrix, or higher-order tensor) is always equal to the length of its shape:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，给定张量 `T`（向量、矩阵或更高阶张量）的维度数是由 `ndim` 函数给出的，并且总是等于其形状的长度：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 4.6.3 Reshape
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6.3 重新塑形
- en: 'The method `reshape` gives a new view of the array, with a new shape, without
    copying the data:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `reshape` 为数组提供了一个新的视图，具有新形状，而不复制数据：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The various effects of `reshape` on an array defined by `arange(6)` are given
    in *Figure 4.2*:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`reshape` 对由 `arange(6)` 定义的数组的各种影响如 *图 4.2* 所示：'
- en: '![](img/c83ae739-a14a-4dac-b732-b5926366fe1d.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c83ae739-a14a-4dac-b732-b5926366fe1d.png)'
- en: 'Figure 4.2: The various effects of `reshape` on an array'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：`reshape` 对数组的各种影响
- en: '`reshape` does not create a new array. It rather gives a new view on the existing
    array. In the preceding example, changing one element of `M` would automatically
    result in a change in the corresponding element in `v`. When this behavior is
    not acceptable, you need to copy the data, as explained in [Section 5.1](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml):
    *Array views and copies*.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`reshape` 不会创建一个新数组。它只是为现有数组提供一个新的视图。在前面的示例中，修改 `M` 的一个元素会自动导致 `v` 中相应元素的变化。当这种行为不可接受时，你需要复制数据，如在[第
    5.1 节](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)中解释的那样：*数组视图与副本*。'
- en: 'If you try to reshape an array with a shape that does not multiply to the original
    shape, an error is raised:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试重新塑形一个数组，而其形状不能与原始形状相乘，则会抛出错误：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Sometimes, it is convenient to specify only one `shape` parameter and let Python
    determine the other in such a way that it multiplies to the original shape. This
    is done by setting the free `shape` parameter to `-1`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，指定一个 `shape` 参数并让 Python 自动计算出另一个参数，使得它们的乘积等于原始形状是很方便的。这可以通过将自由的 `shape`
    参数设置为 `-1` 来实现：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Transpose
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转置
- en: A special form of reshaping is *transposing*. It just switches the two shape
    elements of the matrix. The transpose of a matrix ![](img/01c5013f-d771-4398-8b4a-09a7127faf37.png)
    is a matrix ![](img/1e85d89b-68ed-4ce3-afcb-def575a94660.png) such that
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 重新塑形的一种特殊形式是 *转置*。它仅交换矩阵的两个形状元素。矩阵 ![](img/01c5013f-d771-4398-8b4a-09a7127faf37.png)
    的转置是矩阵 ![](img/1e85d89b-68ed-4ce3-afcb-def575a94660.png)，使得
- en: '![](img/0d4d53d1-e828-4034-a089-d1a79219f880.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d4d53d1-e828-4034-a089-d1a79219f880.png)'
- en: 'which is resolved in the following way:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过以下方式解决：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`transpose` does not copy: transposition is very similar to reshaping. In particular,
    it does not copy the data either and just returns a view on the same array:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`transpose` 不会复制：转置与重新塑形非常相似，尤其是它也不复制数据，而是仅返回同一数组的视图：'
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Transposing a vector makes no sense since vectors are tensors of one dimension,
    that is, functions of one variable – the index. NumPy will, however, comply and
    return exactly the same object:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 转置一个向量没有意义，因为向量是一个一维的张量，也就是一个单变量的函数——索引。然而，NumPy 会执行转置并返回完全相同的对象：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'What you have in mind when you want to transpose a vector is probably to create
    a row or column matrix. This is done using `reshape`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想转置一个向量时，你可能是想创建一个行矩阵或列矩阵。这可以通过`reshape`来实现：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 4.7 Stacking
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.7 堆叠
- en: 'The universal method to build matrices from a couple of (matching) submatrices
    is `concatenate`. Its syntax is:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从一对（匹配的）子矩阵构建矩阵的通用方法是`concatenate`。它的语法是：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This command stacks the submatrices vertically (on top of each other) when `axis=0` is
    specified. With the argument `axis=1`, they are stacked horizontally, and this
    generalizes according to arrays with more dimensions. This function is called
    by several convenient functions, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定`axis=0`时，这个命令会将子矩阵垂直堆叠（一个在另一个之上）。使用`axis=1`参数时，它们会水平堆叠，这个操作会根据更高维度的数组进行泛化。这个函数通过多个方便的函数来调用，如下所示：
- en: '`hstack`: Used to stack arrays horizontally'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hstack`：用于水平堆叠数组'
- en: '`vstack`: Used to stack arrays vertically'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vstack`：用于垂直堆叠数组'
- en: '`columnstack`: Used to stack vectors in columns'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`columnstack`：用于将向量堆叠成列'
- en: 4.7.1 Stacking vectors
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7.1 向量堆叠
- en: 'You may stack vectors row-wise or column-wise using `vstack` and `column_stack`,
    as illustrated in *Figure 4.3*:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`vstack`和`column_stack`按行或按列堆叠向量，如*图4.3*所示：
- en: '![](img/489416aa-cee4-4c78-bd61-6d55509b1907.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/489416aa-cee4-4c78-bd61-6d55509b1907.png)'
- en: 'Figure 4.3: Difference between vstack and column_stack'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：vstack和column_stack的区别
- en: Note that `hstack` would produce the concatenation of `v1` and `v2`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`hstack`将会产生`v1`和`v2`的拼接。
- en: 'Let''s consider the symplectic permutation as an example for vector stacking:
    we have a vector of size ![](img/95e7f926-6570-4979-aff3-cfd2456400df.png). We
    want to perform a symplectic transformation of a vector with an even number of
    components, that is, exchange the first half with the second half of the vector
    with sign change:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以辛普森排列为向量堆叠的例子：我们有一个大小为![](img/95e7f926-6570-4979-aff3-cfd2456400df.png)的向量。我们想对具有偶数个分量的向量执行辛普森变换，即将向量的前半部分与后半部分交换，并且改变符号：
- en: '![](img/d1945fef-683a-48a7-8b84-69079e39b55f.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1945fef-683a-48a7-8b84-69079e39b55f.png)'
- en: 'This operation is resolved in Python as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作在Python中是这样解决的：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 4.8 Functions acting on arrays
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.8 对数组的函数
- en: There are different types of functions acting on arrays. Some act elementwise,
    and they return an array of the same shape. Those are called *universal functions*.
    Other array functions return an array of a different shape. In this section, we
    will meet both types of functions and also learn how to convert scalar functions
    into *universal functions*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 数组上有不同类型的函数。有些是逐元素作用的，它们返回一个形状相同的数组，这些被称为*通用函数*。其他数组函数返回形状不同的数组。在本节中，我们将接触这两种类型的函数，并学习如何将标量函数转换为*通用函数*。
- en: 4.8.1 Universal functions
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8.1 通用函数
- en: Universal functions are functions that act elementwise on arrays. They thus
    have an output array that has the same shape as the input array. These functions allow
    us to compute the result of a scalar function on a whole array at once.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通用函数是对数组逐元素作用的函数。因此，它们的输出数组与输入数组具有相同的形状。这些函数允许我们一次性计算标量函数在整个数组上的结果。
- en: Built-in universal functions
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内建通用函数
- en: 'A typical example is the `cos` function (the one provided by NumPy):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是`cos`函数（由NumPy提供）：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that universal functions work on arrays in a componentwise manner. This
    is also true for operators, such as multiplication or exponent:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通用函数是逐分量作用于数组的。操作符，如乘法或指数，也遵循这个规则：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Creation of universal functions
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建通用函数
- en: 'Your function will automatically be universal if you use only universal functions
    in it. If, however, your function uses functions that are not universal, you might
    get scalar results, or even an error when trying to apply them on an array:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在函数中只使用通用函数，那么你的函数会自动变成通用函数。然而，如果你的函数使用了非通用函数，当你试图将它们应用于数组时，可能会得到标量结果，甚至出现错误：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Another example is the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子如下：
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The expected behavior would be that the `heaviside` function applied to a vector `[a, b]` would
    return `[heaviside(*a*), heaviside(*b*)]`. Alas, this does not work because the
    function always returns a scalar, no matter the size of the input argument. Besides,
    using the function with an array input would cause the statement `if` to raise
    an exception, as is explained in detail in [Section 5.2.1](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml):
    *Boolean arrays*.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的行为是，将 `heaviside` 函数应用于一个向量 `[a, b]` 时，应该返回 `[heaviside(*a*), heaviside(*b*)]`。遗憾的是，这并不奏效，因为该函数总是返回一个标量，无论输入参数的大小如何。此外，使用数组输入时，`if`
    语句会引发异常，具体细节可参见 [第 5.2.1 节](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)：*布尔数组*。
- en: 'The NumPy function `vectorize` allows us to quickly solve this problem:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 函数 `vectorize` 使我们能够快速解决这个问题：
- en: '[PRE49]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A typical application of this method is its use when plotting a function:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的典型应用是用于绘制函数时：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Figure 4.4* shows the resulting graph:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.4* 显示了结果图：'
- en: '![](img/87adeed7-835b-464a-bcc8-b0bb49a621e6.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87adeed7-835b-464a-bcc8-b0bb49a621e6.png)'
- en: 'Figure 4.4: Heaviside function'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：Heaviside 函数
- en: The function `vectorize` provides a convenient way to quickly transform a function,
    so that it operates elementwise on lists and arrays.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `vectorize` 提供了一种方便的方式，可以快速地将一个函数转换，使其逐元素作用于列表和数组。
- en: '`vectorize` can also be used as a decorator:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`vectorize` 也可以作为装饰器使用：'
- en: '[PRE51]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Decorators will be introduced in [Section 7.8](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml):
    *Functions as decorators.*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器将在 [第 7.8 节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml) 中介绍：*作为装饰器的函数*。
- en: 4.8.2 Array functions
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8.2 数组函数
- en: There are a number of functions acting on arrays that do not act componentwise.
    Examples of such functions are `max`, `min`, and `sum`. These functions may operate
    on the entire matrix, row-wise, or column-wise. When no argument is provided,
    they act on the entire matrix.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些作用于数组的函数，并不是逐元素作用的。这些函数的例子包括 `max`、`min` 和 `sum`。这些函数可以作用于整个矩阵、按行作用或按列作用。当没有提供参数时，它们会作用于整个矩阵。
- en: 'Suppose:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 假设：
- en: '![](img/b4b74487-2302-49d4-9832-3dfaa7c465be.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4b74487-2302-49d4-9832-3dfaa7c465be.png)'
- en: 'The function `sum` acting on that matrix returns a scalar:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对该矩阵应用的 `sum` 函数返回一个标量：
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The command has an optional parameter, `axis`. It allows us to choose along which
    axis to perform the operation. For instance, if the axis is ![](img/34738052-9fa9-47b9-82ff-83a13e4cff45.png),
    it means that the sum should be computed along the first axis. The sum along axis
    ![](img/b3c35afb-1602-49a5-af3a-b4f4a92bb398.png) of an array of shape ![](img/925c52a4-d0cd-400d-a844-1f5ff7e56e72.png) will
    be a vector of length ![](img/0ae89473-603a-4d7f-a6e1-002309711489.png).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令有一个可选参数 `axis`。它允许我们选择沿哪个轴执行操作。例如，如果轴是 ![](img/34738052-9fa9-47b9-82ff-83a13e4cff45.png)，意味着应该沿第一个轴计算和。沿轴
    ![](img/b3c35afb-1602-49a5-af3a-b4f4a92bb398.png) 对形状为 ![](img/925c52a4-d0cd-400d-a844-1f5ff7e56e72.png)
    的数组求和，将得到一个长度为 ![](img/0ae89473-603a-4d7f-a6e1-002309711489.png) 的向量。
- en: 'Suppose we compute the sum of `A` along the axis ![](img/fb5a95be-3141-40c3-bb6c-4fa00dbd0586.png):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们计算 `A` 沿轴 ![](img/fb5a95be-3141-40c3-bb6c-4fa00dbd0586.png) 的和：
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This amounts to computing the sum on the columns:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于计算列上的和：
- en: '![](img/2aa3de70-06db-4cc0-882f-20d159526e22.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2aa3de70-06db-4cc0-882f-20d159526e22.png)'
- en: 'The result is a vector:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个向量：
- en: '![](img/d594fcb4-c367-4178-8eac-e9669d2c878f.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d594fcb4-c367-4178-8eac-e9669d2c878f.png)'
- en: 'Now suppose we compute the sum along axis *1*:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们计算沿轴 *1* 的和：
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This amounts to computing the sum on the rows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于计算行上的和：
- en: '![](img/b10b3aa4-6ef4-4079-bb86-d68282cd1f94.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b10b3aa4-6ef4-4079-bb86-d68282cd1f94.png)'
- en: 'The result is a vector:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个向量：
- en: '![](img/d8e2b4fb-ca07-4164-8283-bee562f7dd36.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8e2b4fb-ca07-4164-8283-bee562f7dd36.png)'
- en: After having seen in this section functions acting on arrays in general, we
    turn now to some functions solving tasks in basic scientific computing. We exemplify
    this by considering some standard tasks in linear algebra.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经介绍了作用于数组的函数，接下来我们将转向解决基础科学计算任务的函数。我们通过考虑一些线性代数中的标准任务来举例说明。
- en: 4.9 Linear algebra methods in SciPy
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.9 SciPy 中的线性代数方法
- en: SciPy offers a large range of methods from numerical linear algebra in its module `scipy.linalg`.
    Many of these methods are Python wrapping programs from `LAPACK`, a collection
    of well-approved FORTRAN subroutines used to solve linear equation systems and
    eigenvalue problems, see [[5]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml). Linear
    algebra methods are the core of any method in scientific computing, and the fact
    that SciPy uses wrappers instead of pure Python code makes these central methods
    extremely fast. We present in detail here how two linear algebra problems are
    solved with Scipy to give you a flavor of this module.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 提供了一系列数值线性代数方法，这些方法在其模块 `scipy.linalg` 中。许多这些方法是 Python 包装的 `LAPACK` 程序，LAPACK
    是一组广泛认可的 FORTRAN 子程序，用于解决线性方程组和特征值问题，详见 [[5]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)。线性代数方法是科学计算中任何方法的核心，SciPy
    使用包装器而非纯 Python 代码使得这些核心方法极其快速。我们在这里详细展示了如何通过 Scipy 解决两个线性代数问题，旨在让你对该模块有所了解。
- en: You met before some linear algebra functions taken from the module `numpy.linalg`.
    Both packages NumPy and SciPy are compatible, but Scipy has its focus on scientific
    computing methods and is more comprehensive, while NumPy's focus is on the array
    datatype and it provides only some linear algebra methods for convenience.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前接触过一些来自 `numpy.linalg` 模块的线性代数函数。NumPy 和 SciPy 两个包是兼容的，但 Scipy 更侧重于科学计算方法，并且功能更加全面，而
    NumPy 更侧重于数组数据类型，仅提供了一些便捷的线性代数方法。
- en: 4.9.1 Solving several linear equation systems with LU
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9.1 使用 LU 解多个线性方程组
- en: 'Let ![](img/4196e6f5-3ee7-4824-9a06-1e2a0023f791.png) be an *![](img/6e3bf0cd-1219-43c9-8e6e-80888770ba90.png)*
    matrix and ![](img/919aa858-0c1e-4349-929f-6cab888543b5.png) be a sequence of
    ![](img/aec0a0b8-00cd-4635-9c1c-0686cbc24cc0.png) vectors. We consider the problem
    to find ![](img/143b692e-7046-4f9d-b164-fe5cd9effa12.png) vectors ![](img/67cb9bbc-afe6-4faa-849b-1d68041b2802.png)
    such that:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 设 ![](img/4196e6f5-3ee7-4824-9a06-1e2a0023f791.png) 是一个 *![](img/6e3bf0cd-1219-43c9-8e6e-80888770ba90.png)*
    矩阵，且 ![](img/919aa858-0c1e-4349-929f-6cab888543b5.png) 是一系列 ![](img/aec0a0b8-00cd-4635-9c1c-0686cbc24cc0.png)
    向量。我们考虑求解问题，找到 ![](img/143b692e-7046-4f9d-b164-fe5cd9effa12.png) 向量 ![](img/67cb9bbc-afe6-4faa-849b-1d68041b2802.png)，使得：
- en: '![](img/0a0273f7-82f3-4066-88da-b79083ea9d5f.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a0273f7-82f3-4066-88da-b79083ea9d5f.png)'
- en: We assume that the vectors ![](img/85efadf5-99b6-44b4-a962-833b8b3d8355.png) are
    not known simultaneously. In particular, it is quite a common situation that the
    ![](img/871fa756-0080-460c-92c0-fd64f972467f.png)^(th) problem has to be solved
    before ![](img/0282095b-b6ca-4e70-8a8a-dce30fc06d5f.png)becomes available, for
    example in the context of the simplified Newton iteration, see [[24]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设向量 ![](img/85efadf5-99b6-44b4-a962-833b8b3d8355.png) 不是同时已知的。特别地，通常情况下，必须先解决
    ![](img/871fa756-0080-460c-92c0-fd64f972467f.png)^(th) 问题，然后才能获得 ![](img/0282095b-b6ca-4e70-8a8a-dce30fc06d5f.png)，例如在简化的牛顿迭代法中，详见
    [[24]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)。
- en: '![](img/85bac675-3f92-4601-af52-ca94f39eef12.png) factorization is a way to
    organize the classical Gauss elimination method in such a way that the computation
    is done in two steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/85bac675-3f92-4601-af52-ca94f39eef12.png) 因式分解是一种组织经典高斯消元法的方法，能够将计算分为两步进行：'
- en: A factorization step of the matrix ![](img/00bdf963-c2e4-44f6-b55f-d79be2f3f4d9.png) to
    get matrices in triangular form
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的因式分解步骤 ![](img/00bdf963-c2e4-44f6-b55f-d79be2f3f4d9.png)，目的是将矩阵转换为三角形形式
- en: A relatively cheap backward and forward elimination step that works on the instances
    of ![](img/efd18f9b-201c-4d88-a885-7fe6cc05eec3.png)and benefits from the more
    time-consuming factorization step
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种相对廉价的向后和向前消元步骤，作用于 ![](img/efd18f9b-201c-4d88-a885-7fe6cc05eec3.png) 的实例，并且受益于更耗时的因式分解步骤
- en: The method also uses the fact that if ![](img/cecba16b-7cc5-4ca7-a597-a6c22ccac977.png)
    is a permutation matrix such that ![](img/99dfac8f-563a-4c50-98cd-e977f9ac85b5.png)
    is the original matrix with its rows permuted, the two systems ![](img/b6467921-e799-4a7c-87d1-df158307b3d2.png)
    and ![](img/2d88dcdc-57aa-4e10-9cdb-494fbec51d25.png) have the same solution.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法还利用了这样一个事实：如果 ![](img/cecba16b-7cc5-4ca7-a597-a6c22ccac977.png) 是一个置换矩阵，使得
    ![](img/99dfac8f-563a-4c50-98cd-e977f9ac85b5.png) 是原矩阵的行经过置换后的矩阵，那么两个系统 ![](img/b6467921-e799-4a7c-87d1-df158307b3d2.png)
    和 ![](img/2d88dcdc-57aa-4e10-9cdb-494fbec51d25.png) 具有相同的解。
- en: '![](img/4578b253-5ead-4eef-9412-b4e3ea7439f6.png) factorization finds a permutation
    matrix ![](img/6c293ce8-4881-4f96-a225-cc7dfa04a769.png), a lower triangular matrix ![](img/44e8c59b-3b02-4ad4-9363-2b8a92b506fe.png), and
    an upper triangular matrix ![](img/98ffc1b2-a1c7-45ba-9c92-71043ecb2d05.png) such
    that:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/4578b253-5ead-4eef-9412-b4e3ea7439f6.png) 因式分解找到一个置换矩阵 ![](img/6c293ce8-4881-4f96-a225-cc7dfa04a769.png)，一个下三角矩阵
    ![](img/44e8c59b-3b02-4ad4-9363-2b8a92b506fe.png)，以及一个上三角矩阵 ![](img/98ffc1b2-a1c7-45ba-9c92-71043ecb2d05.png)，使得：'
- en: '![](img/caaf71e0-07ba-4fc0-80e0-cb79f1286d6c.png)or equivalently ![](img/beaa3fdf-6087-4498-8883-f8d9797efc06.png).'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/caaf71e0-07ba-4fc0-80e0-cb79f1286d6c.png) 或等价地 ![](img/beaa3fdf-6087-4498-8883-f8d9797efc06.png)。'
- en: Such a factorization always exists. Furthermore, ![](img/3d8a0cf3-0fba-48ef-992d-4654fb86a225.png)
    can be determined in such a way that *![](img/6bc9dce9-f3fd-46c4-a547-553c7e51e6a7.png)*.
    Thus, the essential data from ![](img/35f23021-e8c1-4326-b7e9-7909b1e2f02f.png)
    that has to be stored is ![](img/9f65052f-5fc6-451c-acc0-509bb256677c.png) with ![](img/9e90e974-9f89-492b-a3e8-3e8376d73586.png).
    Consequently, *![](img/2b0e1170-2606-4e74-88b1-2c0681f6076c.png)* and ![](img/8d7fe4fb-c2fb-4d10-9f76-b4ffb42ae6c3.png)
    can be stored together in an ![](img/46e6348b-3f0b-442e-8b32-6c724c4ea4f5.png)
    array, while the information about the permutation matrix ![](img/0bdf51ae-0e08-4759-8a69-fe3479b39ccb.png)
    just requires an ![](img/d0f432d4-6869-4b90-9b12-31e8f12db89b.png) integer vector
    – the pivot vector.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这种因式分解总是存在的。此外，![](img/3d8a0cf3-0fba-48ef-992d-4654fb86a225.png) 可以以 *![](img/6bc9dce9-f3fd-46c4-a547-553c7e51e6a7.png)*
    的方式确定。因此，来自 ![](img/35f23021-e8c1-4326-b7e9-7909b1e2f02f.png) 的核心数据必须存储为 ![](img/9f65052f-5fc6-451c-acc0-509bb256677c.png)，同时
    ![](img/9e90e974-9f89-492b-a3e8-3e8376d73586.png) 被保留。于是，*![](img/2b0e1170-2606-4e74-88b1-2c0681f6076c.png)*
    和 ![](img/8d7fe4fb-c2fb-4d10-9f76-b4ffb42ae6c3.png) 可以存储在一个 ![](img/46e6348b-3f0b-442e-8b32-6c724c4ea4f5.png)
    数组中，而关于置换矩阵 ![](img/0bdf51ae-0e08-4759-8a69-fe3479b39ccb.png) 的信息只需要一个 ![](img/d0f432d4-6869-4b90-9b12-31e8f12db89b.png)
    整数向量——即主元向量。
- en: 'In SciPy, there are two methods to compute the LU factorization. The standard
    one is `scipy.linalg.lu`, which returns the three matrices `L`, `U`, and `P`.
    The other method is `lu_factor`. That is the method we describe here, because
    it will be conveniently used later in combination with `lu_solve`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SciPy 中，有两种方法可以计算 LU 因式分解。标准的方法是 `scipy.linalg.lu`，它返回三个矩阵 `L`、`U` 和 `P`。另一种方法是
    `lu_factor`。我们在这里描述的是这种方法，因为它将方便地与 `lu_solve` 结合使用：
- en: '[PRE55]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here, the matrix `A` is factorized and an array with the information about `L` and `U` is
    returned, together with the pivot vector. With this information, the system can
    be solved by performing row interchanges of the vectors *![](img/153577e0-6458-4c62-92a0-8cf350510081.png)*
    according to the information stored in the pivot vector, backward substitution
    using *![](img/96b762f1-848b-444d-a841-7d0d2766a23c.png),* and finally, forward
    substitution using ![](img/db5a6831-edd9-4a37-bb7e-8284f8a66aef.png). This is
    bundled in Python, in the method `lu_solve`. The following code snippet shows
    how the system ![](img/a8a9ac9f-b68e-45f0-a555-b8e489316cd5.png)is solved once
    the LU factorization is performed and its results stored in the tuple (LU, piv):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，矩阵 `A` 被分解，并返回一个包含 `L` 和 `U` 信息的数组，同时返回主元向量。有了这些信息，通过根据主元向量中的信息对向量 *![](img/153577e0-6458-4c62-92a0-8cf350510081.png)*
    进行行交换，再通过使用 *![](img/96b762f1-848b-444d-a841-7d0d2766a23c.png)* 的回代替换，最后使用 ![](img/db5a6831-edd9-4a37-bb7e-8284f8a66aef.png)
    的前代替换，即可求解系统。这在 Python 中被打包为 `lu_solve` 方法。下面的代码片段展示了如何在执行 LU 因式分解并将其结果存储在元组 (LU,
    piv) 中后，解决系统 ![](img/a8a9ac9f-b68e-45f0-a555-b8e489316cd5.png)：
- en: '[PRE56]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 4.9.2 Solving a least square problem with SVD
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9.2 使用 SVD 求解最小二乘问题
- en: 'A linear equation system ![](img/81eb24c9-baf8-4329-a16e-e721ec9262e1.png), with ![](img/92a1bee6-65ee-4def-b0a6-8ed17278ef02.png)
    being an *![](img/1d73bf3f-58a2-414e-9d7d-1afb6720205a.png)* matrix and *![](img/0fd80a0a-c81b-47b2-8e56-e2d1858c1e2a.png)*,
    is called an overdetermined linear system. In general, it has no classical solution
    and you seek a vector ![](img/6d0da559-17ca-4da7-bf6f-c8fc0c776aae.png) with the
    property:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线性方程组 ![](img/81eb24c9-baf8-4329-a16e-e721ec9262e1.png)，其中 ![](img/92a1bee6-65ee-4def-b0a6-8ed17278ef02.png)
    为 *![](img/1d73bf3f-58a2-414e-9d7d-1afb6720205a.png)* 矩阵，*![](img/0fd80a0a-c81b-47b2-8e56-e2d1858c1e2a.png)*，称为过度确定的线性系统。通常，它没有经典解，你需要寻找一个向量
    ![](img/6d0da559-17ca-4da7-bf6f-c8fc0c776aae.png)，满足以下性质：
- en: '![](img/d2456b56-3d9c-4b6d-b439-8a14d3933796.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2456b56-3d9c-4b6d-b439-8a14d3933796.png)'
- en: Here, ![](img/cbba8bf7-fee6-4d90-bdda-74de6bd48875.png) denotes the Euclidean
    vector norm ![](img/1b83e74f-85d8-4b81-9f8c-03be5257c74e.png).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/cbba8bf7-fee6-4d90-bdda-74de6bd48875.png) 表示欧几里得向量范数 ![](img/1b83e74f-85d8-4b81-9f8c-03be5257c74e.png)。
- en: This problem is called a least square problem. A stable method to solve it is
    based on factorizing ![](img/b6070459-10bf-46cd-8a81-79da90e4677d.png)*,* with ![](img/b2199c3b-3baf-4d99-b440-5a7f8128e122.png)
    being an ![](img/9f894183-c602-4e45-acd2-1a5b1dfa8e57.png) orthogonal matrix, ![](img/321ee887-ee37-47ad-88e9-f433f47452eb.png)
    an ![](img/ec15b505-3dc6-454e-8ac0-432c1126e3c5.png) orthogonal matrix, and ![](img/9b49437c-733d-43d8-a853-e62eeeb21ea9.png)
    an ![](img/e6e9669b-28f8-427e-84dd-a81995d4af03.png) matrix with the property ![](img/408d1afa-77dd-400a-9f84-938372b59921.png) for
    all ![](img/a93a7e22-86c4-451e-b37c-70929ccdb519.png). This factorization is called a **singular
    value decomposition**(**SVD**).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题被称为最小二乘问题。解决此问题的稳定方法是基于对 ![](img/b6070459-10bf-46cd-8a81-79da90e4677d.png)*,*
    进行分解，其中 ![](img/b2199c3b-3baf-4d99-b440-5a7f8128e122.png) 是一个 ![](img/9f894183-c602-4e45-acd2-1a5b1dfa8e57.png)
    正交矩阵，![](img/321ee887-ee37-47ad-88e9-f433f47452eb.png) 是一个 ![](img/ec15b505-3dc6-454e-8ac0-432c1126e3c5.png)
    正交矩阵，而 ![](img/9b49437c-733d-43d8-a853-e62eeeb21ea9.png) 是一个具有属性 ![](img/408d1afa-77dd-400a-9f84-938372b59921.png)
    的矩阵，对于所有的 ![](img/a93a7e22-86c4-451e-b37c-70929ccdb519.png)。这种分解被称为 **奇异值分解**（**SVD**）。
- en: We write
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写作：
- en: '![](img/d56a3d65-e4e2-4ec7-82c4-5c66a05cb0c9.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d56a3d65-e4e2-4ec7-82c4-5c66a05cb0c9.png)'
- en: with a diagonal *![](img/482f5dde-34d4-431c-9b78-7922c29f02c6.png)* matrix ![](img/214f9d14-1fe5-4917-bf5f-903e54fc58fe.png).
    If we assume that ![](img/00bda032-6d12-4c96-bf4f-35e863ba8b90.png) has full rank,
    then [*![](img/40f74b62-32ab-4ffa-91ac-ae281d11d3da.png)*] is invertible and it
    can be shown that
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对角线 *![](img/482f5dde-34d4-431c-9b78-7922c29f02c6.png)* 矩阵 ![](img/214f9d14-1fe5-4917-bf5f-903e54fc58fe.png)。如果我们假设
    ![](img/00bda032-6d12-4c96-bf4f-35e863ba8b90.png) 是满秩的，那么 [*![](img/40f74b62-32ab-4ffa-91ac-ae281d11d3da.png)*]
    是可逆的，并且可以证明：
- en: '![](img/82c957bc-cd01-4ee7-9538-c30b62c29ffc.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82c957bc-cd01-4ee7-9538-c30b62c29ffc.png)'
- en: holds.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 成立。
- en: 'If we split ![](img/871828cc-22c0-46f1-837c-68393d365c37.png) with ![](img/5ef1ec2f-a76a-4523-bfcb-990bf31f162f.png)
    being an ![](img/0a7fbf6f-dae4-4e00-8074-6c9453a683e9.png) submatrix, then the
    preceding equation can be simplified to:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 ![](img/871828cc-22c0-46f1-837c-68393d365c37.png) 分割，其中 ![](img/5ef1ec2f-a76a-4523-bfcb-990bf31f162f.png)
    是一个 ![](img/0a7fbf6f-dae4-4e00-8074-6c9453a683e9.png) 子矩阵，那么前面的方程可以简化为：
- en: '![](img/4a49ee33-bc31-403a-8fa2-723e1e78588d.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a49ee33-bc31-403a-8fa2-723e1e78588d.png)'
- en: 'SciPy provides a function called `svd`, which we use to solve this task:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 提供了一个名为 `svd` 的函数，我们用它来解决这个任务：
- en: '[PRE57]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The keyword `full_matrices` tells whether the complete matrix ![](img/9e72bfce-f08d-4f8a-a8b1-1ffef56ddffa.png) or
    only its submatrix *![](img/51d29c20-bb37-4615-b3eb-5f131e0ed12b.png)* should
    be computed. As you often use `svd` to compute only singular values, ![](img/0ff12784-516f-4184-9447-e2016fa22484.png),
    we have, in our case, to explicitly demand the computation of ![](img/0be678a3-b8e0-4f25-88c3-38878a4d6a97.png)
    and ![](img/e209beca-7321-416e-a764-1645933a0536.png) by using the keyword `compute_uv`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `full_matrices` 指示是计算完整矩阵 ![](img/9e72bfce-f08d-4f8a-a8b1-1ffef56ddffa.png)
    还是仅计算其子矩阵 *![](img/51d29c20-bb37-4615-b3eb-5f131e0ed12b.png)*。由于你经常使用 `svd` 只计算奇异值，![](img/0ff12784-516f-4184-9447-e2016fa22484.png)，在我们的情况下，我们需要明确要求计算
    ![](img/0be678a3-b8e0-4f25-88c3-38878a4d6a97.png) 和 ![](img/e209beca-7321-416e-a764-1645933a0536.png)，这可以通过使用关键字
    `compute_uv` 来实现。
- en: The SciPy function `scipy.linalg.lstsq` solves the least squares problem directly
    by internally using an SVD.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 函数 `scipy.linalg.lstsq` 通过内部使用 SVD 来直接求解最小二乘问题。
- en: 4.9.3 More methods
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9.3 更多方法
- en: 'In the examples so far, you met a couple of methods for computational tasks
    in linear algebra, for example, `solve`. More methods are available after the
    command `import scipy.linalg as sl` is executed. The most common of them are listed
    in *Table 4.6*:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的例子中，你遇到了一些用于线性代数计算任务的方法，例如 `solve`。执行命令 `import scipy.linalg as sl` 后，可以使用更多的方法。最常用的方法列在
    *表 4.6* 中：
- en: '| **Methods** | **Description** |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `sl.det` | Determinant of a matrix |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `sl.det` | 矩阵的行列式 |'
- en: '| `sl.eig` | Eigenvalues and eigenvectors of a matrix |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `sl.eig` | 矩阵的特征值和特征向量 |'
- en: '| `sl.inv` | Matrix inverse |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `sl.inv` | 矩阵的逆 |'
- en: '| `sl.pinv` | Matrix pseudoinverse |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `sl.pinv` | 矩阵伪逆 |'
- en: '| `sl.norm` | Matrix or vector norm |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `sl.norm` | 矩阵或向量的范数 |'
- en: '| `sl.svd` | Singular value decomposition |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `sl.svd` | 奇异值分解 |'
- en: '| `sl.lu` | LU decomposition |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `sl.lu` | LU 分解 |'
- en: '| `sl.qr` | QR decomposition |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `sl.qr` | QR 分解 |'
- en: '| `sl.cholesky` | Cholesky decomposition |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `sl.cholesky` | Cholesky 分解 |'
- en: '| `sl.solve` | Solution of a general or symmetric linear system: *Ax = b* |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `sl.solve` | 一般或对称线性系统的解：*Ax = b* |'
- en: '| `sl.solve.banded` | The same for banded matrices |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `sl.solve.banded` | 带状矩阵的解法 |'
- en: '| `sl.lstsq` | Least squares solution |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `sl.lstsq` | 最小二乘解 |'
- en: 'Table 4.6: Linear algebra functions of the module scipy.linalg'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.6：scipy.linalg 模块的线性代数函数
- en: Execute `import scipy.linalg as sl` first.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 首先执行 `import scipy.linalg as sl`。
- en: 4.10 Summary
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.10 总结
- en: In this chapter, we worked with the most important objects in linear algebra
    – vectors and matrices. For this, we learned how to define arrays and we met important
    array methods. A smaller section demonstrated how to use modules from `scipy.linalg` to
    solve central tasks in linear algebra.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们处理了线性代数中最重要的对象——向量和矩阵。为此，我们学习了如何定义数组，并掌握了重要的数组方法。一个较小的部分展示了如何使用 `scipy.linalg` 中的模块来解决线性代数中的核心任务。
- en: In the following chapter, we consider more advanced and special aspects of arrays.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的一章中，我们将考虑数组的更高级和特殊方面。
- en: 4.11 Exercises
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.11 练习
- en: '**Ex. 1:** Consider a ![](img/94b86ce2-e6b2-475b-9f14-76c5e36c9e19.png) matrix:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 1:** 考虑一个 ![](img/94b86ce2-e6b2-475b-9f14-76c5e36c9e19.png) 矩阵：'
- en: '![](img/b9199d20-b134-4715-ae5c-f5f77974c909.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9199d20-b134-4715-ae5c-f5f77974c909.png)'
- en: Construct this matrix in Python using the function `array`.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用函数 `array` 在Python中构造此矩阵。
- en: Construct the same matrix using the function `arange` followed by a suitable
    `reshape`.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用函数 `arange` 和适当的 `reshape` 构造相同的矩阵。
- en: What is the result of the expression `M[2,:]`? What is the result of the similar
    expression `M[2:]`?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式 `M[2,:]` 的结果是什么？类似表达式 `M[2:]` 的结果是什么？
- en: '**Ex. 2**: Given a vector *x*, construct in Python the following matrix:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 2:** 给定一个向量 *x*，用Python构造如下矩阵：'
- en: '![](img/fe063b6f-16f0-4f56-9598-adfd011526fe.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe063b6f-16f0-4f56-9598-adfd011526fe.png)'
- en: 'Here, ![](img/6b2583e7-6896-4d67-964d-fd049538ba7f.png) are the components
    of the vector ![](img/18d85501-1ef0-49b3-8a5b-9e48a139c592.png) (numbered from
    zero). Given a vector ![](img/219de5ca-b350-487d-aa10-0ad36e6b5f28.png), solve
    in Python the linear equation system ![](img/ebed84dd-d1d0-4f9e-a484-605bfc06c9bb.png).
    Let the components of ![](img/03a227be-9acb-460e-9c61-af0cd3bd9232.png) be denoted
    by *![](img/7e32640f-ea55-4d20-95c8-cb2b8f653841.png)*. Write a function `poly`,
    which has ![](img/2b36f4f3-1189-45e2-bb5a-a0425f127e30.png) and ![](img/782f3b31-642b-4427-8c2a-4ed1be231cd2.png)
    as input and computes the polynomial:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/6b2583e7-6896-4d67-964d-fd049538ba7f.png) 是向量 ![](img/18d85501-1ef0-49b3-8a5b-9e48a139c592.png) 的分量（从零开始编号）。给定向量 ![](img/219de5ca-b350-487d-aa10-0ad36e6b5f28.png)，用Python解决线性方程组 ![](img/ebed84dd-d1d0-4f9e-a484-605bfc06c9bb.png)。让 ![](img/03a227be-9acb-460e-9c61-af0cd3bd9232.png) 的分量用 *![](img/7e32640f-ea55-4d20-95c8-cb2b8f653841.png)* 表示。编写一个函数 `poly`，其输入为 ![](img/2b36f4f3-1189-45e2-bb5a-a0425f127e30.png) 和 ![](img/782f3b31-642b-4427-8c2a-4ed1be231cd2.png)，计算多项式：
- en: '![](img/11bad0bb-4452-4459-9007-88365688c530.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11bad0bb-4452-4459-9007-88365688c530.png)'
- en: 'Plot this polynomial and depict in the same plot the points ![](img/2f31ef49-1465-45fe-8d17-22e1a9ebb089.png) as
    small stars. Try your code with the vectors:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制该多项式，并在同一图中将点 ![](img/2f31ef49-1465-45fe-8d17-22e1a9ebb089.png) 表示为小星号。使用以下向量测试你的代码：
- en: '![](img/9f72d9a2-9a68-4ea6-a11e-3fb839a38d7b.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f72d9a2-9a68-4ea6-a11e-3fb839a38d7b.png)'
- en: '**Ex. 3:** The matrix ![](img/bcb237c4-8b52-4760-b9f7-a53906c9378f.png) in *Ex.
    2* is called a *Vandermonde matrix*. It can be set up in Python directly with
    the command `vander`. Evaluating a polynomial defined by a coefficient vector
    can be done with the Python command `polyval`. Repeat *Ex. 2* by using these commands.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 3:** 矩阵 ![](img/bcb237c4-8b52-4760-b9f7-a53906c9378f.png) 在 *Ex. 2* 中称为*范德蒙矩阵*。可以直接使用命令 `vander` 在Python中设置它。用Python命令 `polyval` 评估由系数向量定义的多项式。使用这些命令重复 *Ex.
    2*。'
- en: '**Ex. 4:** Let ![](img/ee99a147-92c3-476d-a39a-a74ad9c0985c.png) be a one-dimensional
    array. Construct another array ![](img/290f6f75-cb1d-4a2f-8ff2-0a8e1a7921d0.png)
    with values ![](img/6b23c9cd-6a6c-45c1-a2a7-fd6205634028.png). In statistics,
    this array is called the *moving average* of ![](img/31b367fc-8e36-4ceb-930b-b3b4c8cdb0ec.png).
    In approximation theory, it plays the role of the Greville abscissae of cubic
    splines. Try to avoid the use of `for` loops in your scrip t.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 4:** 设 ![](img/ee99a147-92c3-476d-a39a-a74ad9c0985c.png) 是一个一维数组。构造另一个数组 ![](img/290f6f75-cb1d-4a2f-8ff2-0a8e1a7921d0.png)，其值为 ![](img/6b23c9cd-6a6c-45c1-a2a7-fd6205634028.png)。在统计学中，这个数组被称为 *移动平均值*。在逼近理论中，它扮演了三次样条函数的Greville点的角色。尝试在你的脚本中避免使用`for`循环。'
- en: '**Ex. 5:**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 5:**'
- en: Construct from the matrix ![](img/7178b185-4f57-411e-ab36-1878955e902b.png)given
    in *Ex. 2* a matrix ![](img/2df3ed42-0a6a-41a5-a792-3ea9d7c739c0.png) by deleting
    ![](img/0c7572b8-ae60-4056-bc23-b7755d8fd266.png)'s first column.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从矩阵 ![](img/7178b185-4f57-411e-ab36-1878955e902b.png) （见*Ex. 2*）构造一个矩阵 ![](img/2df3ed42-0a6a-41a5-a792-3ea9d7c739c0.png)，删除其中 ![](img/0c7572b8-ae60-4056-bc23-b7755d8fd266.png) 的第一列。
- en: Form the matrix ![](img/6eebcb7e-0a31-45fa-9f86-314c2724d5a4.png).
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 形成矩阵![](img/6eebcb7e-0a31-45fa-9f86-314c2724d5a4.png)。
- en: Compute ![](img/9f1f2ce4-d0bc-4b76-90e6-a007bf3de393.png) with *y* from *Ex.
    2*.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算![](img/9f1f2ce4-d0bc-4b76-90e6-a007bf3de393.png)，并使用*Ex. 2*中的*y*。
- en: Use ![](img/c3627f5c-ffb0-472c-adcd-349774cbc08b.png) and `polyval` to plot
    the polynomial defined by ![](img/6914b439-8e00-43a4-9d05-cf710057f952.png). Plot
    in the same picture again the points ![](img/fa578596-8b6d-4e5d-8d45-3444e2a19f77.png).
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用![](img/c3627f5c-ffb0-472c-adcd-349774cbc08b.png)和`polyval`绘制由![](img/6914b439-8e00-43a4-9d05-cf710057f952.png)定义的多项式。再次在同一图中绘制点![](img/fa578596-8b6d-4e5d-8d45-3444e2a19f77.png)。
- en: '**Ex. 6:** *Ex. 5* describes the least squares method. Repeat that exercise
    but use SciPy''s `scipy.linalg.lstsq` method instead.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 6：** *例 5* 描述了最小二乘法。重复该练习，但改用SciPy的`scipy.linalg.lstsq`方法。'
- en: '**Ex. 7:** Let ![](img/9c8c6479-a5f2-468d-89ff-ebba2e920bf6.png) be a vector
    written in its coordinate form as a ![](img/dfb4ade8-dd92-4337-8bbb-69ad3e591092.png)
    matrix ![](img/d5202a4a-76e0-49b2-aa6a-a3700a41331e.png). Construct the projection
    matrices:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 7：** 设![](img/9c8c6479-a5f2-468d-89ff-ebba2e920bf6.png)是一个向量，以其坐标形式写成![](img/dfb4ade8-dd92-4337-8bbb-69ad3e591092.png)矩阵![](img/d5202a4a-76e0-49b2-aa6a-a3700a41331e.png)。构造投影矩阵：'
- en: '![](img/a37ac33c-9332-43af-88a3-44340ef9916e.png) and ![](img/23ac98e4-77db-423f-8ce7-456009c627ba.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a37ac33c-9332-43af-88a3-44340ef9916e.png)和![](img/23ac98e4-77db-423f-8ce7-456009c627ba.png)'
- en: Show experimentally that ![](img/83a4e7b1-68fc-49e9-b334-210006ce7cf4.png) is
    an eigenvector for both matrices ![](img/92b532e7-074a-4860-aa1c-7f8c7173159e.png)
    and ![](img/0bc7f0fb-df10-4658-b18d-928f7a13cc76.png). What are the corresponding
    eigenvalues?
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 实验表明，![](img/83a4e7b1-68fc-49e9-b334-210006ce7cf4.png)是矩阵![](img/92b532e7-074a-4860-aa1c-7f8c7173159e.png)和![](img/0bc7f0fb-df10-4658-b18d-928f7a13cc76.png)的特征向量。相应的特征值是多少？
- en: '**Ex. 8:** In numerical linear algebra the *![](img/44464ed2-4f61-4367-8619-39608a28d1e7.png)*
    matrix ![](img/5f13f90a-e7a8-4775-a9e7-b9d2228e5ca4.png) with the property'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 8：** 在数值线性代数中，*![](img/44464ed2-4f61-4367-8619-39608a28d1e7.png)*矩阵![](img/5f13f90a-e7a8-4775-a9e7-b9d2228e5ca4.png)具有以下性质'
- en: '![](img/9c02fdfc-2636-4564-b3ff-0995d87fa34d.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c02fdfc-2636-4564-b3ff-0995d87fa34d.png)'
- en: is used as an example for an extreme growth factor, when performing LU factorization,
    see [[36, p. 165]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 被用作极端增长因子的例子，在执行LU分解时，见[[36, p. 165]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)。
- en: Set up this matrix in Python for various values of ![](img/a92b5fed-a950-43f8-ac67-7f39e1606d55.png),
    compute its LU factorization using the command `scipy.linalg.lu`, and derive experimentally
    a statement about the growth factor
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中设置这个矩阵，对于不同的![](img/a92b5fed-a950-43f8-ac67-7f39e1606d55.png)值，使用命令`scipy.linalg.lu`计算其LU分解，并通过实验得出关于增长因子的陈述。
- en: '![](img/92f0c83e-a714-49df-a074-f358f6ea7290.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92f0c83e-a714-49df-a074-f358f6ea7290.png)'
- en: in relation to ![](img/eadd88ba-9e5c-48dc-95c9-f34ba0fe8f6b.png).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 关于![](img/eadd88ba-9e5c-48dc-95c9-f34ba0fe8f6b.png)。
