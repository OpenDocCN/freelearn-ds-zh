- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Numbers, Sequences, and Series
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数字、数列和级数
- en: ”It’s like asking why is Ludwig van Beethoven’s Ninth Symphony beautiful. If
    you don’t see why, someone can’t tell you. I know numbers are beautiful. If they
    aren’t beautiful, nothing is.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “这就像问，为什么路德维希·范·贝多芬的《第九交响曲》那么美。如果你看不出来为什么美，那么没人能告诉你。我知道数字是美的。如果它们不美，那么没有什么是美的。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: — Paul Erdős
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: — 保罗·厄尔德什
- en: 'When I was about to take my first mathematical analysis course at the university,
    coming straight from high school, I wondered why we would spend several lectures
    on real numbers. At the time, I was confident in my knowledge and thought that
    I knew what numbers were. This was my first painful encounter with the [Dunning–Kruger
    effect](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect): the less
    you know, the more confident you are. Suffice to say, after a few classes, I was
    left confused about numbers, taking a while to finally understand them.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我从高中直接进入大学准备上第一堂数学分析课时，我曾想，为什么我们要花几节课讲实数。当时，我对自己的知识很有信心，认为我知道什么是数字。这是我第一次痛苦地遇到[Dunning–Kruger效应](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect)：你知道得越少，信心越大。可以说，几节课之后，我对数字感到困惑，花了些时间才最终理解它们。
- en: If you look at numbers under a magnifying glass, they become extremely complex.
    In this chapter, we are going to make sense of them. To look ahead and keep machine
    learning in our sights, consider that gradient descent (you know, the optimization
    algorithm that is used everywhere) is not possible for functions that are not
    differentiable. In turn, a function f is differentiable at x if the limit
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用放大镜看数字，它们会变得非常复杂。在这一章中，我们将理清这些概念。为了前瞻性地看待并关注机器学习，考虑到梯度下降（你知道的，那个到处都在用的优化算法）对于不可微分的函数是无法应用的。反过来，函数f在x点可微分，当且仅当极限
- en: '![lim f(x)−-f-(y)- x→y x− y ](img/file895.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![lim f(x)−-f-(y)- x→y x− y ](img/file895.png)'
- en: exists. To understand limits, we must understand real numbers first.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 极限存在。要理解极限，我们必须首先理解实数。
- en: 'Another good reason to dig deep into the patterns and structures of numbers:
    they are beautiful (as said above by Paul Erdős, one of the greatest mathematicians
    ever). There is a particular joy to understanding seemingly familiar things on
    a deep level. Even though you might not use this knowledge every day, it teaches
    you perspective about the objects you encounter during your work.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个深入探究数字模式和结构的好理由：它们很美（正如保罗·厄尔德什所说，他是有史以来最伟大的数学家之一）。从深层次理解那些看似熟悉的事物是有一种特殊的乐趣的。即使你可能并不每天都用到这些知识，它仍然能教会你对工作中遇到的对象的全新视角。
- en: So, let’s get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧！
- en: 10.1 Numbers
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 数字
- en: 'There are five famous classes of numbers that one has to know in order to become
    adept in mathematics:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个著名的数字类别，任何想要精通数学的人都必须知道：
- en: natural numbers, denoted by ℕ,
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然数，用符号ℕ表示，
- en: integers, denoted by ℤ,
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数，用符号ℤ表示，
- en: rational numbers, denoted by ℚ,
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有理数，用符号ℚ表示，
- en: real numbers, denoted by ℝ,
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实数，用符号ℝ表示，
- en: and finally, complex numbers, denoted by ℂ.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后是复数，用符号ℂ表示。
- en: These classes increase in order, that is,
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类别是按顺序递增的，也就是说，
- en: '![ℕ ⊆ ℤ ⊆ ℚ ⊆ ℝ ⊆ ℂ. ](img/file896.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![ℕ ⊆ ℤ ⊆ ℚ ⊆ ℝ ⊆ ℂ. ](img/file896.png)'
- en: In this section, we are going to concern ourselves with the first four. (Complex
    numbers will get their own chapter.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将关注前四个自然数。（复数将有自己的章节。）
- en: 10.1.1 Natural numbers and integers
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 自然数和整数
- en: Natural numbers are simply defined as
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自然数被简单地定义为
- en: '![ℕ := {1,2,3,...}. ](img/file897.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![ℕ := {1,2,3,...}. ](img/file897.png)'
- en: Sometimes 0 is included; sometimes it is not. Believe it or not, after a few
    thousand years, mathematicians still cannot decide whether or not 0 is a natural
    number. This problem might sound comical, but trust me, I have seen senior professors
    almost get into a fistfight upon debating this issue. For some people, this is
    a religious question.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候0被包含在内，有时候不包含。信不信由你，经过几千年的讨论，数学家们仍然无法决定0是否是自然数。这个问题听起来可能有些滑稽，但相信我，我见过一些资深教授几乎因为讨论这个问题而打起来。对某些人来说，这是一个宗教性的问题。
- en: I don’t particularly care, and neither should you. I propose using the more
    common and practical definition, which is the one without 0\. When we really need
    to talk about the natural numbers AND 0, I will use the notation ℕ[0] = {0,1,2,…}.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我其实不太在意，你也不必太在意。我建议使用更常见且实用的定义，也就是不包含0的定义。当我们真正需要讨论包括0在内的自然数时，我会使用符号ℕ[0] = {0,1,2,…}。
- en: The cardinality of the set of natural numbers is countably infinite. In fact,
    countability is defined as jℕj. (If you are not familiar with the concept of cardinality,
    check out Appendix C.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 自然数集合的基数是可数的无限大。实际上，可数性定义为 jℕj。（如果你不熟悉基数的概念，请参见附录 C。）
- en: To be able to express negative and zero quantities, we extend natural numbers
    to obtain the set of integers, defined by
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够表达负数和零的数量，我们将自然数扩展为整数集合，定义如下：
- en: '![ℤ = {...,− 2,− 1,0,1,2,...}. ](img/file898.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![ℤ = {...,− 2,− 1,0,1,2,...}. ](img/file898.png)'
- en: 'So far, so good. Integers are also countable: one can enumerate all of its
    elements by'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。整数也是可数的：我们可以通过枚举它的所有元素来实现这一点。
- en: '![0,1,− 1,2,− 2,3,− 3,.... ](img/file899.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![0,1,− 1,2,− 2,3,− 3,.... ](img/file899.png)'
- en: One significant advantage of integers over natural numbers is that they contain
    the additive inverse for each element. In plain English, if n ∈ℤ, then so does
    −n ∈ℤ. This makes it possible to define all kinds of algebraic structures over
    the integers, giving us mathematical tools to reason about phenomena modeled by
    them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 整数相较于自然数的一个重要优势是它们包含每个元素的加法逆元。简单来说，如果 n ∈ℤ，那么 −n 也 ∈ℤ。这样我们就能够在整数上定义各种代数结构，从而为我们提供数学工具来推理与这些现象相关的模型。
- en: Note that if n,m ∈ℤ, then n + m ∈ℤ. In mathematical terminology, we say that
    ℤ is closed to addition.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果 n, m ∈ℤ，那么 n + m ∈ℤ。在数学术语中，我们说 ℤ 对加法封闭。
- en: To summarize, ℤ is
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，ℤ 是
- en: closed to addition,
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对加法封闭，
- en: and every element has an additive inverse.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且每个元素都有加法逆元。
- en: These two properties will guide us on how to go from natural numbers to real
    numbers. Each extension is constructed so that these two properties hold, but
    for different operations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个性质将指导我们如何从自然数扩展到实数。每个扩展的构造方式都确保这两个性质成立，但在不同的运算下有所不同。
- en: 10.1.2 Rational numbers
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 有理数
- en: So, we obtained ℤ from ℕ by extending it with 0 and the additive inverses for
    each element. What about the multiplicative inverses? This idea leads us to the
    concept of rational numbers, numbers that can be written as a ratio of two integers.
    It is defined by
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过向 ℕ 中添加 0 和每个元素的加法逆元来得到 ℤ。那么，乘法逆元呢？这个想法引出了有理数的概念，即可以表示为两个整数的比率的数字。它的定义是：
- en: '![ℚ = {p-: p,q ∈ ℤ,q ⁄= 0}, q ](img/file900.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![ℚ = {p-: p,q ∈ ℤ,q ⁄= 0}, q ](img/file900.png)'
- en: 'It is both closed to multiplication and every element (except 0) has a multiplicative
    inverse. This is not just a l’art pour l’art mathematical construction: rational
    numbers model quantities that are all around us. ”7.9 seconds” to ”100.0 km/h”.
    78.4 kilograms to carry. 0.5 pizza to eat. You get it.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它对乘法封闭，并且每个元素（除 0 外）都有乘法逆元。这不仅仅是为了数学构造而构造的艺术：有理数描述了我们周围的各种量。例如“7.9秒”到“100.0公里/小时”，78.4公斤需要搬运，0.5个披萨要吃。你明白了。
- en: It might be surprising, but ℚ is also countable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能令人惊讶，但 ℚ 也是可数的。
- en: 'One easy way to prove this is to notice that it can be obtained as the countable
    union of countable sets:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 证明这一点的一个简单方法是注意到它可以作为可数集合的可数并集获得：
- en: '![ ⋃ ℚ = {p-: q ∈ ℤ ∖{0}}. p∈ℤ q ](img/file901.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![ ⋃ ℚ = {p-: q ∈ ℤ ∖{0}}. p∈ℤ q ](img/file901.png)'
- en: (If you are not familiar with the basic set operations like union and setminus,
    check out Appendix C.)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你不熟悉基本的集合运算，如并集和差集，请参见附录 C。）
- en: Since the union of countable sets is countable, ℚ is countable as well. Another
    (and perhaps more visual) way to see this is to simply enumerate them in the sequence,
    illustrated by Figure 10.1.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可数集合的并集仍然是可数的，因此 ℚ 也是可数的。另一种（或许更加直观）的方法是简单地将它们按顺序枚举，如图 10.1 所示。
- en: '![PIC](img/file902.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file902.png)'
- en: 'Figure 10.1: Enumeration of rational numbers, where the arrows indicate the
    ordering'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：有理数的枚举，其中箭头表示顺序
- en: Rational numbers can be written in decimal form, like ![1 2](img/file903.png)
    = 0.5, for example. In general, the following is true.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有理数可以写成小数形式，例如 ![1 2](img/file903.png) = 0.5。一般来说，以下是成立的：
- en: Theorem 55\.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 55\.
- en: 'Any rational number x can be represented as a:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有理数 x 都可以表示为：
- en: (a) finite decimal
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 有限小数
- en: '![x = x0 ...xk.xk+1 ...xn, xi ∈ {0,1,2,...,9} ](img/file904.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![x = x0 ...xk.xk+1 ...xn, xi ∈ {0,1,2,...,9} ](img/file904.png)'
- en: (b) or a repeating decimal
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 或者是重复小数
- en: '![x = x0...xk.xk+1 ...x˙n ...x˙m, xi ∈ {0,1,2,...,9}, ](img/file905.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![x = x0...xk.xk+1 ...x˙n ...x˙m, xi ∈ {0,1,2,...,9}, ](img/file905.png)'
- en: where the decimals between the two dots repeat infinitely. (This can be just
    a single digit as well.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，两个点之间的小数部分会无限重复。（这也可以是一个单一的数字。）
- en: 'Note that the decimal representation is not unique: for example, 1.0 0.˙9 are
    equal.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，小数表示法不是唯一的：例如，1.0 0.˙9 是相等的。
- en: The above theorem fully characterizes rational numbers. But what about numbers
    with an infinite decimal form that does not repeat?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述定理完全描述了有理数。那么，具有无限不重复小数形式的数呢？
- en: Like the famous mathematical constant π describing the half circumference of
    the unit circle, that is,
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就像著名的数学常数 π 描述单位圆的半周长一样，
- en: '![π = 3.14159265358979323846264338327950288419716939937510..., ](img/file906.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![π = 3.14159265358979323846264338327950288419716939937510..., ](img/file906.png)'
- en: with no repeating patterns. These are called irrational numbers, and together
    with rationals, they make up the real numbers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数没有重复的模式。它们叫做无理数，和有理数一起构成了实数。
- en: 10.1.3 Real numbers
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3 实数
- en: The simplest way to imagine real numbers is a line, where each point represents
    a number.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 想象实数的最简单方式是将它们表示为一条线，其中每个点代表一个数字。
- en: '![PIC](img/file907.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file907.png)'
- en: 'Figure 10.2: The real number line'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：实数线
- en: If we temporarily let mathematical correctness slide, we can say that
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们暂时忽略数学的严格性，可以说
- en: ℝ = finite decimals∪in finite repeating decimals∪infinite nonrepeating decimals
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ℝ = 有限小数∪有限循环小数∪无限不循环小数
- en: Real numbers are also the first we have encountered in our journey that are
    not countable, and we will prove this! Its proof is so beautiful that it belongs
    in The Book, a collection of the most elegant and beautiful mathematical proofs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 实数是我们旅程中遇到的第一个不可数的集合，我们将证明这一点！它的证明如此美丽，以至于它应该出现在《数学之书》中——这本书收录了最优雅、最美丽的数学证明。
- en: Theorem 56\.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 56\。
- en: ℝ is not countable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ℝ 是不可数的。
- en: 'Proof. To show that ℝ is not countable, let’s take an indirect approach: assume
    that it is countable and deduce a contradiction. This method is called an indirect
    proof, a top-tier tool in a mathematician’s toolkit.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。为了证明 ℝ 是不可数的，我们采取间接方法：假设它是可数的，并推导出矛盾。这个方法叫做间接证明，是数学家工具箱中的一项高级工具。
- en: 'Since [0,1) ⊆ℝ, it is enough to show that [0,1) is not countable. If it is
    countable, we can enumerate it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 [0,1) ⊆ ℝ，只需证明 [0,1) 是不可数的。如果它是可数的，我们可以列举出它的元素：
- en: '![[0,1) = {a1,a2,...}. ](img/file909.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![[0,1) = {a1,a2,...}. ](img/file909.png)'
- en: 'We can write out the decimal forms of these:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写出这些数的十进制形式：
- en: '![a = 0.a a a ..., 1 11 12 13 a2 = 0.a21a22a23..., a3 = 0.a31a32a33.... . ..
    ](img/file910.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![a = 0.a a a ..., 1 11 12 13 a2 = 0.a21a22a23..., a3 = 0.a31a32a33.... . ..
    ](img/file910.png)'
- en: Let’s focus on the diagonal! By changing the digits there, we define
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们聚焦于对角线！通过改变这里的数字，我们定义
- en: '![ ( |{5, if ann ⁄= 5, ˆann := |(1, if ann = 5\. ](img/file911.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{5, 如果 ann ⁄= 5, ˆann := |(1, 如果 ann = 5\. ](img/file911.png)'
- en: Can the number
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字可以表示为
- en: '![aˆ:= 0.ˆa11ˆa22ˆa33... ](img/file912.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![aˆ:= 0.ˆa11ˆa22ˆa33... ](img/file912.png)'
- en: be found in the sequence {a[1],a[2],…}? No, because the i-th decimal of a[i]
    and â must be different for all i ∈ ℕ! We have constructed â by changing the i-th
    decimal of a[i].
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 是否可以在序列 {a[1],a[2],…} 中找到？不可以，因为对于所有 i ∈ ℕ，a[i] 和 â 的第 i 位小数必须不同！我们通过改变 a[i]
    的第 i 位小数构造了 â。
- en: To summarize, our assumption that [0,1) can be enumerated leads to a contradiction
    because we have found an element that cannot possibly be in our enumeration. So,
    [0,1) is not countable, hence ℝ is not countable as well. This is what we needed
    to show!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们假设 [0,1) 可以被列举出来的假设导致了矛盾，因为我们发现了一个不可能出现在列举中的元素。因此，[0,1) 是不可数的，进而 ℝ 也是不可数的。这就是我们需要证明的！
- en: The method of proof that you have seen above is called Cantor’s diagonal argument.
    This is a beautiful and powerful idea, and although we won’t encounter it anymore,
    it is the key to proving several difficult theorems. (Like Gödel’s famous incompleteness
    theorems, essentially stating that an axiomatic system is either inexpressive
    or inconsistent. These threw a huge monkey wrench into the machinery of mathematics
    at the beginning of the 20th century.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才看到的证明方法叫做康托尔对角线论证。这是一个美丽且强大的思想，尽管我们以后不会再遇到它，但它是证明几个困难定理的关键。（比如哥德尔著名的不完备性定理，实质上是说公理系统要么是表达不充分的，要么是自相矛盾的。这些定理在20世纪初给数学的运作带来了巨大冲击。）
- en: 'Notice that real numbers break the pattern we observed previously. Integers
    were constructed by extending the natural numbers with additive inverses and closing
    them to addition; rationals were obtained the same way, except doing it for multiplication.
    As we shall see later, real numbers follow a similar process: we obtain them from
    rationals by closing them to limits.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，实数打破了我们之前观察到的模式。整数是通过扩展自然数并引入加法逆元来构造的，并且对加法封闭；有理数则是通过类似的方式获得的，不过是针对乘法进行封闭。正如我们稍后所见，实数遵循类似的过程：我们通过对有理数进行极限封闭来得到它们。
- en: But what are limits? Let’s see – by studying sequences, the objects that provide
    the context of limits!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但是极限是什么呢？让我们通过研究序列来看看——序列为极限提供了上下文！
- en: 10.2 Sequences
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 序列
- en: Sequences lie at the very heart of mathematics. Sequences and their limits describe
    long-term behavior, like the (occasional) convergence of gradient descent to a
    local optimum. By definition, a sequence is an enumeration of mathematical objects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 序列是数学的核心所在。序列及其极限描述了长期行为，比如梯度下降（偶尔）收敛到局部最优点。根据定义，序列是数学对象的列举。
- en: The elements of a sequence can be any mathematical object, like sets, functions,
    or Hilbert spaces. (Whatever those might be.) For us, sequences are composed of
    numbers. We formally denote them as
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的元素可以是任何数学对象，比如集合、函数或希尔伯特空间。（这些是什么呢？）对于我们来说，序列由数字组成。我们正式地表示它们为
- en: '![ ∞ {an }n=1, an ∈ ℝ. ](img/file913.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞ {an }n=1, an ∈ ℝ. ](img/file913.png)'
- en: For simplicity, the subscripts and the superscripts are often omitted, so don’t
    panic if you see {a[n]}, as it is just an abbreviation. (Or a[n]. Mathematicians
    love abbreviations.) If all elements of the sequence belong to a set A, we often
    write {a[n]}⊆A.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便，通常省略下标和上标，所以如果你看到{a[n]}，不用惊慌，它只是一个缩写。（或者是a[n]。数学家喜欢使用缩写。）如果序列的所有元素都属于集合A，我们通常写作{a[n]}⊆A。
- en: Sequences can be bidirectional as well. Those are denoted as {a[n]}[n=−∞]^∞.
    We don’t need them for now, but they will frequently come up in the context of
    probability distributions later.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 序列也可以是双向的。这些序列表示为{a[n]}[n=−∞]^∞。我们目前不需要它们，但它们在概率分布的上下文中经常会出现。
- en: Sometimes we don’t need an entire sequence, just a subsequence. We will not
    do anything special with them just yet, but here is the formal definition.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不需要整个序列，只需要一个子序列。我们暂时不会对它们做任何特别的处理，但这是它们的正式定义。
- en: Definition 38\. (Subsequences)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 定义38.（子序列）
- en: Let a[nn=1]^∞, and let n[kk=1]^∞⊆ℕ be a strictly increasing sequence of natural
    numbers. Then, the sequence {a[n[k]]}[k=1]^∞ is a subsequence of {a[n]}.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 设a[nn=1]^∞，并且设n[kk=1]^∞⊆ℕ为一个严格递增的自然数序列。那么，序列{a[n[k]]}[k=1]^∞是{a[n]}的一个子序列。
- en: Think of it as throwing elements away from a sequence.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以把它想象成把元素从序列中丢弃。
- en: 10.2.1 Convergence
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 收敛
- en: One of the most important aspects of sequences is their asymptotic behavior,
    or in other words, what they do in the long term. A particular property we often
    look for is convergence. In plain English, the sequence {a[n]} converges to a
    if no matter how small of an interval (a−𝜀,a + 𝜀) we define (where 𝜀 can be really
    small), eventually all of the elements of {a[n]} fall into it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的一个重要方面是它们的渐近行为，换句话说，就是它们在长期中的表现。我们常常关注的一个特性是收敛性。用通俗的语言来说，序列{a[n]}收敛到a，如果无论我们定义一个多小的区间(a−𝜀,
    a + 𝜀)（其中𝜀可以非常小），最终所有{a[n]}的元素都会落入其中。
- en: The following is the mathematically precise definition of convergence.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是收敛的数学精确定义。
- en: Definition 39\. (Convergence of sequences)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 定义39.（序列的收敛性）
- en: The sequence {a[n]}⊆ℝ is said to converge to some a ∈ℝ if for every 𝜀/span>0,
    there is a cutoff index n[0] ∈ℕ such that
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 序列{a[n]}⊆ℝ说是收敛到某个a ∈ℝ，如果对于每个𝜀/span>0，都存在一个截止索引n[0] ∈ℕ，使得
- en: '![|an − a| <𝜀 ](img/file914.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![|an − a| <𝜀 ](img/file914.png)'
- en: holds for all indices n/span>n[0]. The value a is said to be the limit of {a[n]},
    and we write
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有的索引n/span>n[0]成立。值a被称为{a[n]}的极限，我们写作
- en: '![lni→m∞ an = a ](img/file915.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![lni→m∞ an = a ](img/file915.png)'
- en: or
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '![an → a (n → ∞ ). ](img/file916.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![an → a (n → ∞ ). ](img/file916.png)'
- en: Note that the cutoff index n[0] depends on 𝜀. We could write n[0](𝜀) to emphasize
    this dependency, but we rarely do so. To avoid referencing and naming the cutoff
    index n[0] all the time, we often simply say that a given property “holds for
    all n large enough.” (Did I mention that mathematicians love abbreviations?)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，截止索引n[0]依赖于𝜀。我们可以写作n[0](𝜀)来强调这种依赖关系，但我们很少这么做。为了避免一直提到并命名截止索引n[0]，我们通常简单地说“对于所有足够大的n，这个属性成立。”（我提过数学家喜欢缩写吗？）
- en: In plain English, the definition means that no matter how small of an interval
    you enclose a in, all members of the sequence will eventually fall into it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 用通俗的语言来说，这个定义意味着无论你定义一个多小的区间来包含a，序列的所有成员最终都会落入这个区间。
- en: Although mathematically extremely precise and correct, this definition doesn’t
    give us a lot of tools to show if a sequence is convergent or not. First, we have
    to conjure up the limit a and then construct the cutoff indexes. For example,
    consider a[n] := ![1 n](img/file917.png).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在数学上非常精确且正确，但这个定义并没有提供很多工具来判断一个序列是否收敛。首先，我们必须构造极限 a，然后构建截断索引。例如，考虑 a[n] :=
    ![1 n](img/file917.png)。
- en: To make our job easier, we can plot this to visualize the situation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的工作，我们可以绘制图形来可视化这种情况。
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![PIC](img/file918.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file918.png)'
- en: 'Figure 10.3: The 1∕n sequence'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：1∕n 序列
- en: Here, we can explicitly construct the cutoff index n[0] for every 𝜀. Since we
    want to have
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以显式地为每个 𝜀 构造截断索引 n[0]。因为我们希望有
- en: '![1 --< 𝜀, n ](img/file919.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![1 --< 𝜀, n ](img/file919.png)'
- en: we can reorganize the inequality to obtain
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新组织不等式以得到
- en: '![1- 𝜀 <n. ](img/file920.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![1- 𝜀 <n. ](img/file920.png)'
- en: So,
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，
- en: '![n0 := ⌊ 1⌋+ 1 𝜀 ](img/file921.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![n0 := ⌊ 1⌋+ 1 𝜀 ](img/file921.png)'
- en: will do the job.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就能解决问题。
- en: We had it easy in this example, but this is pretty much as far as we can go
    with the definition. For example, how do you show the convergence of
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们比较容易解决问题，但这基本上是我们能够用定义解决的问题的极限了。例如，如何证明
- en: '![ 1 1 1 an := (-+ ----- + ⋅⋅⋅+ ---)−1 n n + 1 2n ](img/file922.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![ 1 1 1 an := (-+ ----- + ⋅⋅⋅+ ---)−1 n n + 1 2n ](img/file922.png)'
- en: with the definition only? You don’t.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用定义来处理吗？不行。
- en: There are more advanced tools for this, as we shall see. (By the way, lim[n→∞]a[n]
    = ![-1- ln 2](img/file923.png)). For sequences that are defined recursively and
    there is no analytic formula available, like
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此问题，存在更为先进的工具，正如我们将看到的那样。（顺便提一下，lim[n→∞]a[n] = ![-1- ln 2](img/file923.png)）。对于递归定义且没有解析公式的序列，例如
- en: '![{L (⃗wn,⃗x,⃗y)}∞n=1, ](img/file924.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![{L (⃗wn,⃗x,⃗y)}∞n=1, ](img/file924.png)'
- en: where L is the loss function for a neural network with weights ![⃗w](img/file925.png)[n]
    and training data (![⃗x](img/file926.png),![⃗y](img/file927.png)), we have even
    more complications. There is no need to worry about them yet; let’s focus on one
    thing at a time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 L 是神经网络的损失函数，带有权重 ![⃗w](img/file925.png)[n] 和训练数据 (![⃗x](img/file926.png),![⃗y](img/file927.png))，我们遇到的情况更为复杂。现在不必担心它们，让我们一次只关注一个问题。
- en: 10.2.2 Properties of convergence
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 收敛性质
- en: In essence, the study of convergence for a particular sequence comes down to
    breaking it into simpler and simpler parts until the limit is known.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，研究特定序列的收敛性就是将其分解为越来越简单的部分，直到知道极限为止。
- en: Is this a “famous” sequence where the limit is known? If yes, we are done. If
    not, go to the next step.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个“著名的”序列，已知其极限吗？如果是，我们就完成了。如果不是，进入下一步。
- en: Can you decompose it into simpler parts? If yes, is the convergence known for
    them? If the convergence is unknown, can you simplify it further?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能将它分解成更简单的部分吗？如果可以，它们的收敛性是否已知？如果收敛性未知，你能进一步简化吗？
- en: We can do this because convergence has some particularly nice properties, as
    summarized in the theorem below.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以能这样做，是因为收敛具有一些特别好的性质，正如下述定理所总结的那样。
- en: Theorem 57\. (Properties of convergence)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 57. （收敛性质）
- en: Let {a[n]}and {b[n]}be two convergent sequences with
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 设 {a[n]} 和 {b[n]} 是两个收敛序列，且
- en: '![ln→im∞ an = a and nli→m∞ bn = b. ](img/file928.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![ln→im∞ an = a and nli→m∞ bn = b. ](img/file928.png)'
- en: 'Then:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 那么：
- en: (a)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: (a)
- en: '![ lim (an + bn) = a + b, n→ ∞ ](img/file929.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![ lim (an + bn) = a + b, n→ ∞ ](img/file929.png)'
- en: (b)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: (b)
- en: '![ lim can = ca for all c ∈ ℝ, n→ ∞ ](img/file930.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![ lim can = ca for all c ∈ ℝ, n→ ∞ ](img/file930.png)'
- en: (c)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: (c)
- en: '![nli→m∞ anbn = ab, ](img/file931.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![nli→m∞ anbn = ab, ](img/file931.png)'
- en: (d) and if a[n]≠0 and a≠0, then
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: (d) 如果 a[n]≠0 且 a≠0，则
- en: '![ 1-- 1- nli→m∞ an = a . ](img/file932.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![ 1-- 1- nli→m∞ an = a . ](img/file932.png)'
- en: The properties (a) and (b) together are called linearity of convergence.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 性质（a）和（b）合起来被称为收敛的线性性质。
- en: 'As we shall see later, the continuity of functions also provides a great tool
    to study convergence properties of a sequence. In fact, continuity is nothing
    more than the interchangeability of limits and functions:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将看到的，函数的连续性也为研究序列的收敛性质提供了一个很好的工具。事实上，连续性不过是极限和函数的可交换性：
- en: '![lnim→∞ f(xn) = f(nl→im∞ xn). ](img/file933.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![lnim→∞ f(xn) = f(nl→im∞ xn). ](img/file933.png)'
- en: One essential property of convergent sequences is that under certain circumstances,
    they preserve inequalities. This is true of function limits as well, so it is
    important for us.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 收敛序列的一个重要性质是，在某些情况下，它们保持不等式。这对于函数极限也同样成立，因此对我们来说非常重要。
- en: Theorem 58\. (The transfer principle)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 58. （传递原理）
- en: Let {a[n]}[n=1]^∞ be a convergent sequence. If a[n] ≥α holds for all n ∈ℕ, where
    α ∈ℝ is some lower bound, then lim[n→∞]a[n] ≥α.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 设 {a[n]}[n=1]^∞ 是一个收敛序列。如果对于所有 n ∈ℕ，a[n] ≥α，其中 α ∈ℝ 是某个下界，那么 lim[n→∞]a[n] ≥α。
- en: Proof. We are going to do this indirectly. If lim[n→∞]a[n] α, then by the definition
    of convergence,
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。我们将通过间接方式来证明。如果 lim[n→∞]a[n] = α，那么根据收敛的定义，
- en: '|a[n] −a|/span> ![|a−α| 2](img/file934.png) for all large n. This means that
    those a[n]-s are actually below α, contradicting our assumptions.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '|a[n] −a|/span> ![|a−α| 2](img/file934.png) 对所有足够大的 n 成立。这意味着这些 a[n] 实际上低于
    α，与我们的假设矛盾。'
- en: This proof is straightforward to understand if you draw a figure and visualize
    what happens, so I encourage you to do so. The identical result is true if we
    replace ≥ with ≤ in the above, with the wording of the proof staying the same.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个证明如果画图并可视化发生了什么，会很容易理解，因此我鼓励你这样做。如果我们将上式中的 ≥ 替换为 ≤，并且证明的措辞保持不变，得到的结果是一样的。
- en: Note that if a[n]/span>α for all n, lim[n→∞]a[n]/span>α is not guaranteed! The
    best example to show this is a[n] := 1∕n, which converges to 0, although all of
    its terms are positive.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果对于所有的 n 都有 a[n]/span>α，lim[n→∞]a[n]/span>α 并不保证！最好的例子是 a[n] := 1∕n，它收敛到
    0，尽管它的所有项都是正数。
- en: As a corollary, we obtain a tool that will be very useful for showing the convergence
    of particular sequences.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 作为推论，我们得到了一个工具，它将对证明特定序列的收敛性非常有用。
- en: Corollary 3\. (The squeeze principle)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 推论 3\.（挤压原理）
- en: Let ![{an} ∞n=1 ](img/file935.png), ![{bn}∞n=1 ](img/file936.png), and ![{cn}∞n=1
    ](img/file937.png) be three sequences such that ![an ≤ bn ≤ cn ](img/file938.png)
    for all large enough ![n ](img/file939.png). If
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 设 ![{an} ∞n=1 ](img/file935.png)、![{bn}∞n=1 ](img/file936.png) 和 ![{cn}∞n=1
    ](img/file937.png) 是三个序列，使得对于所有足够大的 ![n ](img/file939.png)，有 ![an ≤ bn ≤ cn ](img/file938.png)。如果
- en: '![lim an = lim cn = α, n→∞ n→ ∞ ](img/file940.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![lim an = lim cn = α, n→∞ n→ ∞ ](img/file940.png)'
- en: then
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 那么
- en: '![lnim→∞ bn = α. ](img/file941.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![lnim→∞ bn = α. ](img/file941.png)'
- en: In other words, squeezing {b[n]} between two convergent sequences that have
    the same limit implies convergence of b[n] to the joint limit.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，将 {b[n]} 夹在两个具有相同极限的收敛序列之间，意味着 b[n] 收敛到该共同极限。
- en: 10.2.3 Famous convergent sequences
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 知名收敛序列
- en: Because convergence behaves nicely with respect to certain operations (Section [10.2.2](ch018.xhtml#properties-of-convergence)),
    we study sequences by decomposing them into building blocks. Let’s see the most
    important ones that will be useful for us later!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因为收敛在某些操作下表现得很好（见第 [10.2.2](ch018.xhtml#properties-of-convergence)节），我们通过将序列分解为构建块来研究它们。让我们看看哪些最重要的构建块将对我们后续的研究有所帮助！
- en: Example 1\. For any x ≥ 0,
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1\. 对于任意 x ≥ 0，
- en: '![L(U,V ) = {f : U → V | f is linear}](img/equation_(16).png)(10.1)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![L(U,V ) = {f : U → V | f 是线性的}](img/equation_(16).png)(10.1)'
- en: If you think about it for a minute, this is easy to see. The x = 0 and x = 1
    cases are trivial. Regarding the others, because taking the logarithm turns exponentiation
    into multiplication, we have log x^n = nlog x. So,
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想一下，这很容易看出来。x = 0 和 x = 1 的情况是显然的。至于其他情况，因为取对数将指数运算转化为乘法，所以我们有 log x^n =
    nlog x。因此，
- en: '![ ( |{ − ∞ if 0 <x <1, lim nlogx = n→ ∞ |( ∞ if x >1\. ](img/file943.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{ − ∞ 如果 0 <x <1, lim nlogx = n→ ∞ |( ∞ 如果 x >1\. ](img/file943.png)'
- en: Since the logarithm is increasing and invertible, ([10.1](ch018.xhtml#famous-convergent-sequences))
    follows.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对数是递增且可逆的，（[10.1](ch018.xhtml#famous-convergent-sequences)）成立。
- en: Example 2\. For any x ≥ 0,
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2\. 对于任意 x ≥ 0，
- en: '![L(U,V ) = {f : U → V | f is linear}](img/equation_(17).png)(10.2)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![L(U,V ) = {f : U → V | f 是线性的}](img/equation_(17).png)(10.2)'
- en: Similarly to the previous example, this can be shown with the use of logarithms.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于前面的例子，这可以通过对数的运用来证明。
- en: Example 3\. Let’s consider the sequences
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3\. 让我们考虑以下序列
- en: '![a = log n, b = n, c = 2n, d = n!. n n n n ](img/file945.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![a = log n, b = n, c = 2n, d = n!. n n n n ](img/file945.png)'
- en: Can you order them according to the speed of growth? This is quite important
    throughout computer science, as these could represent time complexities. It’s
    almost folklore that logarithmic time complexity beats linear, which beats exponential,
    which beats factorial. In other terms,
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你能按照增长速度对它们进行排序吗？这在计算机科学中非常重要，因为这些可能代表时间复杂度。几乎可以说，对数时间复杂度优于线性，线性优于指数，指数优于阶乘。换句话说，
- en: '![ logn n 2n lim -----= lim -n-= lim ---= 0\. n→ ∞ n n→ ∞ 2 n→ ∞ n! ](img/file946.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![ logn n 2n lim -----= lim -n-= lim ---= 0\. n→ ∞ n n→ ∞ 2 n→ ∞ n! ](img/file946.png)'
- en: Example 4\. We have just learned that n grows faster than log n. From this,
    it follows that
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4\. 我们刚刚学到 n 的增长速度快于 log n。从中可以推得
- en: '![ lim n√n-= 1, n→ ∞ ](img/file947.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![ lim n√n-= 1, n→ ∞ ](img/file947.png)'
- en: 'a surprising result (at least, it surprised me as a young student)! To show
    this, we apply the good old logarithm trick:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个令人惊讶的结果（至少，对于年轻的我来说是惊讶的）！为了证明这一点，我们应用那个老生常谈的对数技巧：
- en: '![ √n-- 1 lnim→∞ n = nli→m∞ nn 1n = nli→m∞ elogn logn = nli→m∞ e n = e0 = 1\.
    ](img/file948.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![ √n-- 1 lnim→∞ n = nli→m∞ nn 1n = nli→m∞ elogn logn = nli→m∞ e n = e0 = 1\.
    ](img/file948.png)'
- en: 10.2.4 The role of convergence in machine learning
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4 收敛性在机器学习中的作用
- en: Convergence is everywhere. You’ve just come across this concept for the first
    time, so you might not realize its importance just yet. However, it is central
    to mathematics and machine learning.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 收敛性无处不在。你现在才刚刚接触到这个概念，可能还没有意识到它的重要性。但它在数学和机器学习中是至关重要的。
- en: 'Just to look ahead and give a few examples, differentiation is defined by a
    limit:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 先来预览并给出几个例子，微分是通过极限来定义的：
- en: '![f ′(x) := lim f-(x-)−-f(y). y→x x − y ](img/file949.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![f ′(x) := lim f-(x-)−-f(y). y→x x − y ](img/file949.png)'
- en: Regarding derivatives, integrals (the “inverse” of differentiation) are limits
    of convergent sequences. For instance,
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于导数，积分（微分的“逆”运算）是收敛序列的极限。例如，
- en: '![∫ 1 2 ∑n k2- 0 x dx = lni→m∞ n3\. k=1 ](img/file950.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![∫ 1 2 ∑n k2- 0 x dx = lni→m∞ n3\. k=1 ](img/file950.png)'
- en: Because integrals are limits, so is every quantity calculated with integration,
    such as expected values, like for the standard normal distribution,
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因为积分是极限，所以用积分计算的每一个量也是极限，比如标准正态分布的期望值，
- en: '![ ∫ ∞ 𝔼[𝒩 (0,1)] = x √1--e−x2∕2dx. −∞ 2π ](img/file951.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![ ∫ ∞ 𝔼[𝒩 (0,1)] = x √1--e−x2∕2dx. −∞ 2π ](img/file951.png)'
- en: Convergence is also central to probability and statistics.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 收敛性在概率论和统计学中也至关重要。
- en: 'There are two famous theorems: the law of large numbers, stating that'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个著名的定理：大数法则，表明
- en: '![ ∑n lim 1- Xk = μ n→∞ nk=1 ](img/file952.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n lim 1- Xk = μ n→∞ nk=1 ](img/file952.png)'
- en: holds; and the central limit theorem, which says
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 公式成立；还有中心极限定理，它说
- en: '![√ --X1 + ⋅⋅⋅ + Xn 2 n(------n------ − μ) → 𝒩 (μ, σ ) (n → ∞ ) ](img/file953.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![√ --X1 + ⋅⋅⋅ + Xn 2 n(------n------ − μ) → 𝒩 (μ, σ ) (n → ∞ ) ](img/file953.png)'
- en: in distribution, for independent and identically distributed random variables
    X[1],X[2],… with finite expected value 𝔼[X[i]] = μ and variance var(X[i]) = σ².
    They are both very important in machine learning and neural networks; for instance,
    the law of large numbers is one of the fundamental ideas behind stochastic gradient
    descent.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布中，对于独立同分布的随机变量 X[1],X[2],…，它们有有限的期望值 𝔼[X[i]] = μ 和方差 var(X[i]) = σ²。它们在机器学习和神经网络中非常重要；例如，大数法则是随机梯度下降法背后的一个基本思想。
- en: Even the gradient descent optimization process is a recursively defined sequence
    of model weights, converging toward an optimum where the model best fits the data.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是梯度下降优化过程也是一个递归定义的模型权重序列，它会收敛到一个最优点，在这个点上模型最符合数据。
- en: We will talk about all of these in detail. So, even if you don’t understand
    these right now, don’t worry. It’ll become clear soon. Before finishing up with
    sequences, we shall discuss what happens when a sequence is not convergent.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细讨论所有这些内容。所以，即使你现在还不理解这些，也不用担心。很快就会明了。在结束序列部分之前，我们将讨论当一个序列不收敛时会发生什么。
- en: 10.2.5 Divergent sequences
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.5 发散序列
- en: We have talked about how convergent sequences are everywhere, and they are at
    the core of mathematics and machine learning. However, not all sequences are convergent.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过收敛序列无处不在，它们是数学和机器学习的核心。然而，并非所有序列都是收敛的。
- en: 'Think about the following example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 试想一下以下例子：
- en: '![a := sin(n ). n ](img/file954.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![a := sin(n ). n ](img/file954.png)'
- en: When plotted, this is how it looks.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当绘制出来时，它看起来是这样的。
- en: '[PRE1]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![PIC](img/file955.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file955.png)'
- en: 'Figure 10.4: The sin(n) sequence'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：sin(n) 序列
- en: 'Although it is hard to prove, this sequence does not converge. Its value is
    constantly oscillating in [ − 1,1]. We call non-convergent sequences divergent.
    Among these, there is a special kind of divergence: approaching infinity.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管证明起来困难，但这个序列是不会收敛的。它的值在区间 [ − 1,1] 内不断震荡。我们称这种不收敛的序列为发散序列。在这些序列中，有一种特殊的发散类型：趋近于无穷大。
- en: Definition 40\. (∞-divergence)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 40.（∞-发散）
- en: The sequence {a[n]} is said to be ∞-divergent if for every arbitrarily large
    number x, there is a cutoff index n[0] such that
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 序列 {a[n]} 被称为 ∞-发散的，如果对于每一个任意大的数 x，都存在一个截止指数 n[0]，使得
- en: '![a >x n ](img/file956.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![a >x n ](img/file956.png)'
- en: holds for all indices n/span>n[0].
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有索引 n/span>n[0] 都成立。
- en: We denote ∞-divergence by writing x[n] →∞. Analogously, (−∞)-divergent sequences
    can be defined.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 x[n] →∞ 来表示 ∞-发散性。类似地，可以定义（−∞）-发散序列。
- en: 'An obvious example is {n} or {nlog n}. These are all across computer science
    as well: the runtime of algorithms given the number of steps or the size of the
    input is ∞-divergent.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显而易见的例子是 {n} 或 {nlog n}。这些也遍布计算机科学领域：算法的运行时间与步骤数量或输入大小相关，呈 ∞-发散。
- en: When you see something like a[n] = O(n), it means that there is a constant c
    such that
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到像 a[n] = O(n) 这样的表达式时，意味着存在一个常数 c，使得
- en: '![0 ≤ an ≤ cn ](img/file957.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![0 ≤ an ≤ cn ](img/file957.png)'
- en: holds for all large enough n.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有足够大的 n 都成立。
- en: 10.2.6 The big and small O notation
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.6 大 O 和小 o 符号
- en: If you have some experience with computer science, you are probably familiar
    with the big O small O notation. There, it is used to express the runtime of algorithms,
    but it is not limited to that. In general, it is used to compare the long-term
    behavior of sequences. Let’s start with the definitions first, and then I’ll explain
    the intuition and some use cases.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些计算机科学的经验，你可能对大 O 小 o 符号有所了解。在那里，它用来表示算法的运行时间，但并不限于此。一般来说，它用于比较序列的长期行为。让我们先从定义开始，然后我会解释直觉和一些应用场景。
- en: Definition 41\. (Big and small O notation)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 41.（大 O 和小 o 符号）
- en: 'Let ![{an}∞ n=1 ](img/file958.png) and ![{bn}∞ n=1 ](img/file959.png) be two
    arbitrary sequences. We say that:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 设 ![{an}∞ n=1 ](img/file958.png) 和 ![{bn}∞ n=1 ](img/file959.png) 为两个任意的序列。我们说：
- en: '![bn = O (an) ](img/file960.png), if there is a constant ![C > 0 ](img/file961.png)
    such that ![|bn | ≤ Can ](img/file962.png) for all sufficiently large ![n ](img/file963.png)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![bn = O (an) ](img/file960.png)，如果存在一个常数 ![C > 0 ](img/file961.png)，使得对于所有足够大的
    ![n ](img/file963.png)，都有 ![|bn | ≤ Can ](img/file962.png)'
- en: '![bn = o(an) ](img/file964.png), if for every ![𝜀 >0 ](img/file965.png), there
    exists a cutoff index ![N ∈ ℕ ](img/file966.png) such that ![|bn| ≤ 𝜀an ](img/file967.png)
    for every ![n >N ](img/file968.png).'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![bn = o(an) ](img/file964.png)，如果对于每个 ![𝜖 >0 ](img/file965.png)，存在一个截止索引 ![N
    ∈ ℕ ](img/file966.png)，使得对于所有 ![n >N ](img/file968.png)，都有 ![|bn| ≤ 𝜖an ](img/file967.png)。'
- en: In plain English, “b[n] is big O of a[n]” means that b[n] grows roughly at the
    same rate as a[n], while “b[n] is small O of a[n]” means that b[n] is an order
    of magnitude smaller than a[n].
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的英语来说，“b[n] 是 a[n] 的大 O”意味着 b[n] 的增长速度大致与 a[n] 相同，而“b[n] 是 a[n] 的小 o”意味着
    b[n] 比 a[n] 小一个数量级。
- en: So, when we say that the runtime of an algorithm is O(n) steps where n is the
    input size, we mean that the algorithm will finish in Cn steps. Often, we don’t
    care about the constant multiplier since it doesn’t mean an order of magnitude
    difference in the long run.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当我们说一个算法的运行时间是 O(n) 步时，其中 n 是输入大小，意味着该算法将在 Cn 步内完成。通常，我们不关心常数因子，因为从长远来看，它不会带来数量级上的差异。
- en: 10.2.7 Real numbers are sequences
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.7 实数是序列
- en: Now that we have familiarized ourselves with the concept of convergent sequences,
    we shall take another look at rational and real numbers. When extending the classes
    of numbers going from ℕ to ℝ, we pick an operation, close the set with respect
    to it, and add inverse elements to that operation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了收敛序列的概念，我们将再次审视有理数和实数。当从 ℕ 扩展到 ℝ 时，我们选择一种运算，对其进行闭包处理，并为该运算添加逆元素。
- en: Extending ℕ with additive inverses −n for all n ∈ℕ yields ℤ. Extending ℤ with
    multiplicative inverses 1∕n for all n and closing it for multiplication yields
    ℚ. The pattern is seemingly different in the case of ℝ, but this is not the case.
    After understanding what convergence is, we have the tools to see why.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 ℕ 为所有 n ∈ℕ 的加法逆元 −n，得到 ℤ。将 ℤ 扩展为所有 n 的乘法逆元 1∕n，并对乘法进行闭包，得到 ℚ。在 ℝ 的情况下，似乎有不同的模式，但事实并非如此。在理解了收敛性之后，我们就有工具来理解为什么。
- en: 'Consider the following sequence:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下序列：
- en: '![ 1 n an := (1+ n-) , n = 1,2,.... ](img/file969.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![ 1 n an := (1+ n-) , n = 1,2,.... ](img/file969.png)'
- en: Since rational numbers are closed to addition and multiplication, we see that
    a[n] is rational. However,
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有理数对加法和乘法封闭，我们可以看出 a[n] 是有理数。然而，
- en: '![lim (1 + 1)n = e, n→∞ n ](img/file970.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![lim (1 + 1)n = e, n→∞ n ](img/file970.png)'
- en: which is the famous Euler constant, is not rational.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个著名的欧拉常数，并不是有理数。
- en: 'Thus, we have found what is missing: ℚ is not closed to taking limits. So,
    we can obtain the set of real numbers by closing ℚ to taking limits.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们找到了缺失的部分：ℚ 对极限运算不封闭。所以，我们可以通过对 ℚ 进行极限运算闭包来获得实数集。
- en: 'The fact that every irrational number can be approximated with rational numbers
    as close as possible is often under-appreciated. Think about this: can you represent
    all real numbers with a computer? Nope. This follows from a simple cardinality
    argument: the number of possible floats is finite, but there are uncountably many
    real numbers. However, certain numbers (like π or e) are essential in engineering
    calculations and simulations. Without approximations, working with irrational
    numbers would be unfeasible.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 每个无理数都可以通过有理数尽可能接近地进行近似这一事实常常被低估。想一想：你能用计算机表示所有的实数吗？不行。这是因为一个简单的基数论证：浮点数的数量是有限的，但实数是不可数的。然而，某些数字（比如π或e）在工程计算和仿真中是至关重要的。没有近似值的帮助，处理无理数将变得不可行。
- en: 'Speaking of e: how would you approximate it for computational purposes? In
    theory, it is enough to take a large enough n and use the value (1 + 1∕n)^n. In
    practice, there are several potential problems: the convergence might be slow,
    and taking a large power of a quantity so close to 1 can be numerically unstable.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 说到e：你会如何为计算目的近似它？理论上，只需取一个足够大的n并使用(1 + 1∕n)^n的值就足够了。在实践中，存在几个潜在的问题：收敛可能会很慢，且对一个接近1的数进行大次幂运算可能会引起数值不稳定。
- en: 'However, there is a solution: the form'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一种解决方案：这种形式
- en: '![ N e = lim ∑ -1 N→ ∞ n! n=0 ](img/file971.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![ N e = lim ∑ -1 N→ ∞ n! n=0 ](img/file971.png)'
- en: solves both of these problems! From a numerical point of view, addition is much
    better than multiplication. Moreover, as n! grows extremely rapidly, the term
    ![ 1 n!](img/file972.png) becomes negligible even for small n-s. Thus, the convergence
    is fast. Check this out.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了这两个问题！从数值角度来看，加法比乘法更好。而且，由于 n! 增长得非常快，即使对于小的 n，项 ![ 1 n!](img/file972.png)
    也变得可以忽略不计。因此，收敛速度很快。看看这个。
- en: '[PRE2]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![PIC](img/file973.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file973.png)'
- en: 'Figure 10.5: Approximating e: Definition vs. series'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：近似e：定义与级数
- en: Expressions of form ∑ [n=0]^∞a[n] are called series, and they are one of the
    most important mathematical objects, both in theory and practice. Let’s see what
    they are and how can we work with them!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 形式为 ∑ [n=0]^∞a[n] 的表达式称为级数，它们是数学中最重要的对象之一，既在理论上也在实践中。让我们看看它们是什么，以及我们如何与它们合作！
- en: 10.3 Series
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 级数
- en: 'There is a great pizza place in my hometown that I used to visit quite a lot.
    There, each pizza is packed in a box that contains a pizza coupon. Ten pizza coupons
    can be exchanged for a free pizza. This begs the question: how much pizza do you
    get with a single purchase?'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我家乡有一家很棒的披萨店，我以前经常去。那里，每个披萨都装在一个盒子里，盒子里有一张披萨优惠券。十张披萨优惠券可以兑换一份免费的披萨。这就引出了一个问题：你通过一次购买能获得多少披萨？
- en: Immediately, you’ll receive a pizza. You’ll also get 1∕10-th of a pizza in the
    form of a coupon, making the “value” of the purchase at least 1 + ![-1 10](img/file974.png)
    pizzas.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，你将得到一份披萨。你还将获得1/10的披萨作为优惠券，使得购买的“价值”至少为 1 + ![-1 10](img/file974.png) 披萨。
- en: However, upon exchanging ten coupons, you get another one. Thus, a coupon represents
    ![1- 10](img/file975.png) + ![-1- 100](img/file976.png) pizzas. Continuing with
    this logic, we’ll obtain that the true value of each purchase is
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，兑换十张优惠券后，你还会得到另一张。因此，一张优惠券代表着 ![1- 10](img/file975.png) + ![-1- 100](img/file976.png)
    披萨。按照这个逻辑，我们可以得到每次购买的真实价值是：
- en: '![∑∞ -1--= 1+ 1--+ -1--+ .... n=0 10n 10 100 ](img/file977.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![∑∞ -1--= 1+ 1--+ -1--+ .... n=0 10n 10 100 ](img/file977.png)'
- en: What is the value of this number? To find out, we’ll take a look at infinite
    series, a main pillar of mathematics. Infinite series (or series for short) are
    sums of the form
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数值是多少呢？为了找出答案，我们将研究无限级数，数学的一个重要支柱。无限级数（或简称级数）是这种形式的求和：
- en: '![ ∞ ∑ an. n=1 ](img/file978.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞ ∑ an. n=1 ](img/file978.png)'
- en: Adding infinitely many terms together might seem like a trivial matter, but
    I assure you, this is far from the truth. For instance, consider the sum
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将无限多个项加在一起可能看起来是一件微不足道的事，但我向你保证，情况远非如此。例如，考虑以下求和：
- en: '![∞∑ (− 1)n = 1− 1 + 1 − 1+ .... n=0 ](img/file979.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![∞∑ (− 1)n = 1− 1 + 1 − 1+ .... n=0 ](img/file979.png)'
- en: On one hand,
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，
- en: '![ ∞ ∑ (− 1)n = (1− 1)+ (1 − 1)+ ... n=0 = 0+ 0 + ... = 0, ](img/file980.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞ ∑ (− 1)n = (1− 1)+ (1 − 1)+ ... n=0 = 0+ 0 + ... = 0, ](img/file980.png)'
- en: but on the other,
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，
- en: '![∑∞ (− 1)n = 1 + (− 1 + 1)+ (− 1+ 1) + ... n=0 = 1 + 0+ 0 + ... = 1\. ](img/file981.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![∑∞ (− 1)n = 1 + (− 1 + 1)+ (− 1+ 1) + ... n=0 = 1 + 0+ 0 + ... = 1\. ](img/file981.png)'
- en: Which one is it? Zero or one? It is neither. We’ll see why in this section.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这到底是哪一个呢？是零还是一？都不是。我们将在本节中看到为什么。
- en: 10.3.1 Convergent and divergent series
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 收敛级数与发散级数
- en: The natural way to make sense of the infinite series
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使无限级数合理的自然方法
- en: '![ ∞ ∑ an n=1 ](img/file982.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞ ∑ an n=1 ](img/file982.png)'
- en: is by taking the limit of the so-called partial sums
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 是通过取所谓的部分和的极限得到的
- en: '![ ∑N SN = an. n=1 ](img/file983.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑N SN = an. n=1 ](img/file983.png)'
- en: This is formalized by the following definition.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过以下定义来形式化的。
- en: Definition 42\.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 42。
- en: (Convergent and divergent series)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: （收敛和发散级数）
- en: Let ![{an}∞n=1 ](img/file984.png) be an arbitrary real sequence. The infinite
    series ![∑ ∞ n=1 an ](img/file985.png) is defined by
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 设 ![{an}∞n=1 ](img/file984.png) 为任意实数序列。无限级数 ![∑ ∞ n=1 an ](img/file985.png)
    定义为
- en: '![∑∞ ∑N an := Nli→m∞ an. n=1 n=1 ](img/file986.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![∑∞ ∑N an := Nli→m∞ an. n=1 n=1 ](img/file986.png)'
- en: If the above limit exists, we say that ![∑ ∞ n=1 an ](img/file987.png) is convergent.
    Otherwise, it is divergent.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述极限存在，我们称![∑ ∞ n=1 an ](img/file987.png)是收敛的。否则，它是发散的。
- en: Sounds simple enough. Let’s see some examples!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很简单。让我们来看一些例子！
- en: Example 1\. The geometric series, given by
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1. 几何级数，如下所示
- en: '![∞ ∑ qn = --1--, q ∈ (− 1,1). n=0 1 − q ](img/file988.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![∞ ∑ qn = --1--, q ∈ (− 1,1). n=0 1 − q ](img/file988.png)'
- en: As S[N] + q^(N+1) = S[N+1] = 1 + qS[N], it follows that S[N] = ![1−qN+1 1−q](img/file989.png).
    Thus,
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 S[N] + q^(N+1) = S[N+1] = 1 + qS[N]，因此，S[N] = ![1−qN+1 1−q](img/file989.png)。因此，
- en: '![ (| ∞ ||| undefined if q ≤ − 1, ∑ n 1-−-qN+1- { 1 q = Nli→m∞ 1 − q = | 1−-q
    if − 1 <q <1, n=0 |||( ∞ if 1 ≤ q. ](img/file990.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![ (| ∞ ||| 如果 q ≤ − 1 未定义，∑ n 1-−-qN+1- { 1 q = Nli→m∞ 1 − q = | 1−-q 如果 −
    1 <q <1, n=0 |||( ∞ 如果 1 ≤ q。 ](img/file990.png)'
- en: This is where the famous formula ∑ [n=1]^∞![1- 2n](img/file991.png) = 1 comes
    from. (Figure [10.6](#) illustrates this fact as well.)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是著名的公式 ∑ [n=1]^∞![1- 2n](img/file991.png) = 1 的来源。（图 [10.6](#) 也说明了这一点。）
- en: '![PIC](img/file992.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file992.png)'
- en: 'Figure 10.6: The visual proof of the convergence of a geometric series for
    q = 1∕2'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6：几何级数收敛性的可视化证明，适用于 q = 1∕2
- en: The geometric series is also the one that appears in our introductory pizza
    coupon example. Now, we can see that the value of a single purchase is
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 几何级数也是我们在入门比萨优惠券示例中看到的那个。现在，我们可以看到单次购买的值为
- en: '![ ∞∑ 1 1 10 --n-= ----1-= --- n=0 10 1− 10 9 ](img/file993.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞∑ 1 1 10 --n-= ----1-= --- n=0 10 1− 10 9 ](img/file993.png)'
- en: pizzas.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 比萨饼。
- en: Example 2\. The harmonic series, given by
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2. 调和级数，如下所示
- en: '![∑∞ -1 = ∞. n=1n ](img/file994.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![∑∞ -1 = ∞. n=1n ](img/file994.png)'
- en: Why is the harmonic series divergent? To see why, first notice that
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么调和级数发散？要看为什么，首先注意到
- en: '![2k+1−1 2k+1−1 ∑ 1- ∑ --1-- n ≥ 2k+1 n=2k n=2k -2k-- = 2k+1 1 = 2-. ](img/file995.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![2k+1−1 2k+1−1 ∑ 1- ∑ --1-- n ≥ 2k+1 n=2k n=2k -2k-- = 2k+1 1 = 2-. ](img/file995.png)'
- en: Thus, by grouping the terms appropriately, we obtain that
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过适当分组项，我们得到
- en: '![ k+1 ∞∑ 1- ∞∑ 2∑ −11- n = ( n ) n=1 k=0 n=2k ∞∑ 1 ≥ -- k=02 = ∞. ](img/file996.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![ k+1 ∞∑ 1- ∞∑ 2∑ −11- n = ( n ) n=1 k=0 n=2k ∞∑ 1 ≥ -- k=02 = ∞. ](img/file996.png)'
- en: If you are having trouble imagining this, here is the plot.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你难以想象这一点，这里有一个图示。
- en: '[PRE3]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![PIC](img/file997.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file997.png)'
- en: 'Figure 10.7: The harmonic series'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7：调和级数
- en: According to the Euler-Maclaurin formula,
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 根据欧拉-麦克劳林公式，
- en: '![N∑ 1- n ≈ logN + γ, n=1 ](img/file998.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![N∑ 1- n ≈ logN + γ, n=1 ](img/file998.png)'
- en: where γ ≈ 0.5772156649… is the famous Euler–Mascheroni constant. Check it out.
    (When the base is omitted, log denotes the natural logarithm, also often denoted
    by ln.)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 γ ≈ 0.5772156649… 是著名的欧拉–马歇罗尼常数。查一下。 （当省略底数时，log 表示自然对数，也常记作 ln。）
- en: '[PRE4]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![PIC](img/file999.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file999.png)'
- en: 'Figure 10.8: The harmonic series and the log(x + γ) function'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8：调和级数和 log(x + γ) 函数
- en: Example 3\. The alternating harmonic series, given by
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3. 交替调和级数，如下所示
- en: '![∑∞ 1 (− 1)n+1--= log2\. n=1 n ](img/file1000.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![∑∞ 1 (− 1)n+1--= log2\. n=1 n ](img/file1000.png)'
- en: Surprisingly, the alternating harmonic series is convergent, with the sum log
    2.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 出人意料的是，交替调和级数是收敛的，求和结果为 log 2。
- en: Example 4\. The Basel problem. Believe it or not, solving polynomial equations
    and evaluating infinite sums were some kind of sport for mathematicians of previous
    eras. One of the most famous ones was the Basel problem, concerning the infinite
    sum of inverse squares. In 1735, the legendary Euler showed that
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4. 巴塞尔问题。信不信由你，解多项式方程和评估无限和曾是数学家们的一种运动。最著名的其中之一就是巴塞尔问题，涉及反平方的无限和。1735年，传奇人物欧拉证明了
- en: '![ ∞ ∑ 1-- π2- n2 = 6 , n=1 ](img/file1001.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞ ∑ 1-- π2- n2 = 6 , n=1 ](img/file1001.png)'
- en: 'which is a stunning result. What on Earth is π doing there? The constant π
    is defined as the half circumference of a circle of radius 1, and seeing it pop
    up in the infinite sum of inverse squares is puzzling to say the least. (There
    is an explanation: the numbers 1∕n² are the (scaled) Fourier coefficients of the
    function f(x) = x, and the sum of the Fourier coefficients always evaluates to
    the integral of the function over the interval [ −π,π]. However, this method is
    beyond the scope of this book.)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个令人震惊的结果。π到底在这里做什么？常数π被定义为半径为1的圆的半周长，而它在反平方的无限和中出现，至少是让人困惑的。（有一种解释：1∕n²这些数字是函数f(x)
    = x的（缩放的）傅里叶系数，而傅里叶系数的和总是等于该函数在区间[ −π,π]上的积分。然而，这种方法超出了本书的讨论范围。）
- en: On a personal note, ∑ [n=1]^∞![1 n2](img/file1002.png) = ![π2 6-](img/file1003.png)
    was the favorite identity of my calculus professor, a teacher who I loved so much
    that I ended up specializing in mathematical analysis. Once, he hit his head in
    an accident. Upon arrival of the ambulance, he was asked by the paramedic to talk,
    just to gauge if his cognitive capabilities were intact. So, he started to explain
    the Basel problem to the medical staff. He was almost shipped to the trauma center,
    but fortunately, his wife was there to explain that he is normal; he’s just a
    mathematician.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，∑ [n=1]^∞![1 n2](img/file1002.png) = ![π2 6-](img/file1003.png)是我微积分教授最喜欢的恒等式。那位教授我非常喜爱，以至于我最终选择了数学分析作为我的专业。曾经，他在一次事故中撞到了头。急救车到达时，急救员让他说话，目的是测试他的认知能力是否正常。所以，他开始向医护人员解释巴塞尔问题。差点就被送到创伤中心了，但幸运的是，他的妻子在场，向大家解释说他没事，他只是个数学家。
- en: Example 5\. Apéry’s constant. We’ve seen the harmonic series and the Basel problem,
    so what about the sum of inverse cubes? Although it is known that the series
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5\. 阿佩里常数。我们已经看过调和级数和巴塞尔问题，那么反立方和的和呢？虽然已知该级数
- en: '![∑∞ 1-- n=1 n3 ](img/file1004.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![∑∞ 1-- n=1 n3 ](img/file1004.png)'
- en: is convergent and its value is irrational, we don’t have a closed-form solution
    just yet!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 是收敛的，并且它的值是无理数，我们还没有得到一个封闭的解析解！
- en: Example 6\. The alternating series
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6\. 交替级数
- en: '![∞∑ (− 1)n. n=0 ](img/file1005.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![∞∑ (− 1)n. n=0 ](img/file1005.png)'
- en: 'This is the first example of a divergent series: as'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个发散级数的第一个例子：因为
- en: '![ ( ∑N |{ 1 if n is even (− 1)n = n=0 |( 0 if n is odd, ](img/file1006.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ∑N |{ 1 如果n为偶数 (− 1)n = n=0 |( 0 如果n为奇数, ](img/file1006.png)'
- en: 'the limit lim[N→∞]∑ [n=0]^N(−1)^n doesn’t exist. This is the resolution of
    the seemingly paradoxical result from the introduction: as ∑ [n=0]^∞(−1)^n is
    divergent, associativity breaks down.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 极限lim[N→∞]∑ [n=0]^N(−1)^n不存在。这就是我们在引言中所说的看似矛盾的结果的解决办法：由于∑ [n=0]^∞(−1)^n是发散的，结合律失效了。
- en: Example 7\. The famous Euler number, defined by e = lim[n→∞](1 + ![1n](img/file1008.png))^n,
    is also given by the infinite series
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7\. 著名的欧拉数，定义为e = lim[n→∞](1 + ![1n](img/file1008.png))^n，也可以表示为无限级数
- en: e = ∑ [n=0]^∞![1- n!](img/file1010.png).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: e = ∑ [n=0]^∞![1- n!](img/file1010.png)。
- en: 'Currently, this is beyond our scope, but later, we’ll see why this is true.
    (Spoiler alert: This is a so-called Taylor series, which we’ll talk about in Chapter [12](ch020.xhtml#differentiation).)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这超出了我们的讨论范围，但稍后我们将看到为什么这个结论是正确的。（剧透：这是所谓的泰勒级数，我们将在第[12章](ch020.xhtml#differentiation)讨论它。）
- en: 'This leads to the following question: is there a method that tells if a series
    is convergent or not? Finding a closed formula for the partial sums is not always
    possible. I urge you to try finding one for ∑ [n=0]^N1∕n!, if you don’t believe
    me.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个问题：是否存在一种方法可以判断一个级数是否收敛？并不是所有级数的部分和都能找到封闭形式的公式。我鼓励你尝试为∑ [n=0]^N1∕n!找出一个公式，如果你不相信我。
- en: 10.3.2 Properties of series
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 级数的性质
- en: Let’s take a look at some of the most important properties of series. First,
    it is immediately clear that the general term of a convergent series should converge
    to 0 as well.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看级数的一些最重要的性质。首先，很明显，收敛级数的通项也应该收敛于0。
- en: Proposition 2\.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 命题2\。
- en: Let ∑ n = 1^∞a[n] be a convergent series. Then lim[N→∞]a[N] = 0.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 设∑ n = 1^∞a[n]是一个收敛级数。那么lim[N→∞]a[N] = 0。
- en: Proof. As a[N] = ∑ [n=1]^Na[n] −∑ [n=1]^(N−1)a[n], we have
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。因为a[N] = ∑ [n=1]^Na[n] −∑ [n=1]^(N−1)a[n]，我们得到
- en: '![ N N−1 lim a = lim (∑ a − ∑ a ) N→ ∞ N N →∞ n=1 n n=1 n N N −1 ∑ ∑ = Nlim→∞
    an − Nlim→∞ an ∞ n=1 ∞ n=1 ∑ ∑ = an − an n=1 n=1 = 0, ](img/file1011.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![ N N−1 lim a = lim (∑ a − ∑ a ) N→ ∞ N N →∞ n=1 n n=1 n N N −1 ∑ ∑ = Nlim→∞
    an − Nlim→∞ an ∞ n=1 ∞ n=1 ∑ ∑ = an − an n=1 n=1 = 0, ](img/file1011.png)'
- en: which is what we had to show.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们要证明的。
- en: Proposition [2](ch018.xhtml#x1-175002r2) can be used to quickly gauge the convergence
    of certain series. For instance, ∑ [n=1]^∞![n+1- n](img/file1012.png) cannot be
    convergent, as lim[n→∞]![n+1- n](img/file1013.png) = 1.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 命题 [2](ch018.xhtml#x1-175002r2)可以用来快速判断某些级数的收敛性。例如，∑ [n=1]^∞![n+1- n](img/file1012.png)
    不可能收敛，因为 lim[n→∞]![n+1- n](img/file1013.png) = 1。
- en: 'On the other hand, note that the reverse of Proposition [2](ch018.xhtml#x1-175002r2)
    is not true: there are divergent series with a general term converging to 0\.
    One immediate example is the harmonic series ∑ [n=1]^∞![1 n](img/file1014.png).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，注意到命题 [2](ch018.xhtml#x1-175002r2)的逆命题不成立：有些发散级数的通项收敛于 0。一个直接的例子是调和级数 ∑
    [n=1]^∞![1 n](img/file1014.png)。
- en: Just like sequences, convergent series behave with respect to addition and scalar
    multiplication, as we expect.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数列一样，收敛级数在加法和数乘方面表现得正如我们所期望的那样。
- en: Theorem 59\. (Linearity of convergent series)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 59．（收敛级数的线性）
- en: Let ∑ n = 1^∞a[n] and ∑ n = 1^∞b[n] be two convergent series, and let α,β ∈ℝ
    be two arbitrary real numbers. Then,
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 令 ∑ n = 1^∞a[n] 和 ∑ n = 1^∞b[n] 为两个收敛级数，且令 α,β ∈ℝ 为任意实数。那么，
- en: '![ ∞ ∞ ∞ α ∑ a + β ∑ b = ∑ (αa + βb ). n n n n n=1 n=1 n=1 ](img/file1015.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞ ∞ ∞ α ∑ a + β ∑ b = ∑ (αa + βb ). n n n n n=1 n=1 n=1 ](img/file1015.png)'
- en: The proof is a direct consequence of Theorem [57](ch018.xhtml#x1-167006r57).
    Feel free to work it out by hand for practice!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 证明是定理 [57](ch018.xhtml#x1-167006r57)的直接推论。可以通过亲自推导来进行练习！
- en: Note that Theorem [59](ch018.xhtml#x1-175004r59) does not apply to divergent
    series. For instance,
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，定理 [59](ch018.xhtml#x1-175004r59)不适用于发散级数。例如，
- en: '![∑∞ n n+1 [(− 1) + (− 1) ] = 0, n=0 ](img/file1016.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![∑∞ n n+1 [(− 1) + (− 1) ] = 0, n=0 ](img/file1016.png)'
- en: However,
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，
- en: '![∑∞ ∑∞ (− 1)n and (− 1)n+1 n=0 n=0 ](img/file1017.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![∑∞ ∑∞ (− 1)n 和 (− 1)n+1 n=0 n=0 ](img/file1017.png)'
- en: are both divergent.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 都是发散的。
- en: The product of a series is slightly more convoluted. We’ll deal with this later
    in the chapter, I promise.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 级数的乘积稍微复杂一点。我们稍后会在本章讨论这个问题，我保证。
- en: 10.3.3 Conditional and absolute convergence
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 条件收敛与绝对收敛
- en: Let’s turn the weirdness up a notch. Recall the alternating harmonic series
    ∑ [n=1]^∞(−1)^(n+1)![1 n](img/file1018.png), whose sum is log 2\. What happens
    if we rearrange its terms?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把怪异程度提高一点。回想一下交替调和级数 ∑ [n=1]^∞(−1)^(n+1)![1 n](img/file1018.png)，它的和是 log
    2。如果我们重新排列它的项会发生什么？
- en: Instead of alternating between one odd and one even term, let’s do one odd and
    two even. (Odd and even with respect to their indices.)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 与其在一个奇数项和一个偶数项之间交替，不如做一个奇数项和两个偶数项的交替。（奇数和偶数是相对于它们的索引而言的。）
- en: This is illustrated by Figure [10.9](#).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这由图 [10.9](#)说明。
- en: '![PIC](img/file1019.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1019.png)'
- en: 'Figure 10.9: A rearrangement of the alternating harmonic series'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9：交替调和级数的重新排列
- en: The change is small, but carries a profound impact. As it turns out, by simply
    rearranging the terms, we change the value of the sum! Check out Figure [10.10](#)
    to see why.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 变化虽小，但却带来了深远的影响。事实证明，通过简单地重新排列项，我们改变了和的值！查看图 [10.10](#)了解原因。
- en: '![PIC](img/file1020.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1020.png)'
- en: 'Figure 10.10: A rearrangement of the alternating harmonic series, explained'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10：交替调和级数的重新排列，解释
- en: This happens because rearrangements are not valid operations in the world of
    series. However, the notion of convergence can be refined in a way that’ll enable
    us to differentiate between rearrangeable and non-rearrangeable series.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在级数的世界中，重新排列并不是有效的操作。然而，收敛性的概念可以被细化，使我们能够区分可重新排列的和不可重新排列的级数。
- en: Enter absolute and conditional convergence.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 进入绝对收敛与条件收敛。
- en: Definition 43\. (Absolute and conditional convergence)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 43．（绝对收敛与条件收敛）
- en: Let ∑ [n=1]^∞a[n] be an infinite series.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 令 ∑ [n=1]^∞a[n] 为一个无穷级数。
- en: (a) If ∑ [n=1]^∞ja[n]j is convergent, then ∑ [n=1]^∞a[n] is called absolutely
    convergent.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 如果 ∑ [n=1]^∞ja[n]j 收敛，那么 ∑ [n=1]^∞a[n] 被称为绝对收敛。
- en: (b) If ∑ [n=1]^∞a[n] is convergent but not absolutely convergent, then it is
    called conditionally convergent.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 如果 ∑ [n=1]^∞a[n] 收敛但不是绝对收敛的，那么它称为条件收敛。
- en: For example, the geometric series ∑ [n=0]^∞![( ) − 1 2](img/file1021.png)^n
    is absolutely convergent, while the alternating harmonic series ∑ [n=1]^∞(−1)^n![1
    n](img/file1022.png) is only conditionally convergent.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，几何级数 ∑ [n=0]^∞![( ) − 1 2](img/file1021.png)^n 是绝对收敛的，而交替调和级数 ∑ [n=1]^∞(−1)^n![1
    n](img/file1022.png) 仅是条件收敛的。
- en: If a series is absolutely convergent, then it is convergent as well. (We’ll
    skip the proof, as the minute technical details are not that important for us.)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个级数是绝对收敛的，那么它也是收敛的。（我们跳过证明，因为其中的细节对我们来说不那么重要。）
- en: 10.3.4 Revisiting rearrangements
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 重访重排
- en: Being absolutely or conditionally convergent has a profound impact on the behavior
    of the series. One prime example is its rearrangeability. As it turns out, absolutely
    convergent series can be rearranged, while conditionally convergent series go
    crazy.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对收敛或条件收敛对级数的行为有着深远的影响。一个重要的例子就是它的重排性。事实证明，绝对收敛级数可以重排，而条件收敛级数则变得不稳定。
- en: Mathematically speaking, rearrangements can be formalized via permutations of
    the index set.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度讲，重排可以通过对索引集合的排列来形式化。
- en: Definition 44\. (Permutations)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 44\. （排列）
- en: 'Let A be an arbitrary set. The mapping σ : A →A is called a permutation of
    A if it is bijective.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '设 A 是一个任意集合。如果映射 σ : A →A 是双射，则称 σ 是 A 的一个排列。'
- en: It seems quite abstract, but permutations are easy to grasp. Think about the
    index set as the increasing sequence
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当抽象，但排列是很容易理解的。可以将索引集合看作是递增的序列
- en: '![1,2,3,4,5,6,.... ](img/file1023.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![1,2,3,4,5,6,.... ](img/file1023.png)'
- en: (It may include 0, or might even start from a larger number.) The simple permutation
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: （它可能包括0，甚至可能从更大的数字开始。）这个简单的排列
- en: '![ (| { 2k − 1 if n = 2k, σ(n) = | ( 2k if n = 2k − 1 ](img/file1024.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![ (| { 2k − 1 if n = 2k, σ(n) = | ( 2k if n = 2k − 1 ](img/file1024.png)'
- en: swaps the neighboring even and odd numbers, turning the index set into
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 交换相邻的偶数和奇数，将索引集合转变为
- en: '![σ(1) = 2,σ(2) = 1,σ (3) = 4,σ(4) = 3,.... ](img/file1025.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![σ(1) = 2,σ(2) = 1,σ (3) = 4,σ(4) = 3,.... ](img/file1025.png)'
- en: For a general series ∑ [n=1]^∞a[n], its rearrangement given by the permutation
    σ is ∑ [n=1]^∞a[σ(n)].
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个一般的级数 ∑ [n=1]^∞a[n]，其由排列 σ 给出的重排为 ∑ [n=1]^∞a[σ(n)]。
- en: So, can you rearrange a convergent series? If it is absolutely convergent, without
    a doubt.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你能重排一个收敛级数吗？如果它是绝对收敛的，毫无疑问可以。
- en: Theorem 60\.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 60\.
- en: 'Let ![∑ ∞ n=1 an ](img/file1026.png) be an absolutely convergent series and
    ![σ : ℕ → ℕ ](img/file1027.png) be an arbitrary permutation. Then, the rearrangement
    ![∑ ∞ aσ(n) n=1 ](img/file1028.png) is convergent as well and'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 设 ![∑ ∞ n=1 an ](img/file1026.png) 是一个绝对收敛级数，![
- en: '![∑∞ ∑∞ aσ(n) = an. n=1 n=1 ](img/file1029.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![∑∞ ∑∞ aσ(n) = an. n=1 n=1 ](img/file1029.png)'
- en: 'We are not going to prove this here, but the essence is, convergent series
    absolutely behave as we expect: we can change the order of terms without affecting
    the result.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不打算证明这个，但本质上是，收敛级数的行为完全符合我们的预期：我们可以改变项的顺序而不影响结果。
- en: What about conditionally convergent series? We have seen that rearranging can
    change the value, but the situation is much more interesting. Meet the Riemann
    rearrangement theorem.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，条件收敛的级数呢？我们已经看到重排可以改变其值，但情况更为有趣。接下来介绍黎曼重排定理。
- en: Theorem 61\. (The Riemann rearrangement theorem)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 61\. （黎曼重排定理）
- en: 'Let ∑ [n=1]^∞a[n] be a conditionally convergent series and let c ∈ ℝ be an
    arbitrary real number. Then, there exists a permutation σ : ℕ →ℕ such that'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '设 ∑ [n=1]^∞a[n] 是一个条件收敛级数，设 c ∈ ℝ 是一个任意的实数。那么，存在一个排列 σ : ℕ →ℕ，使得'
- en: '![∑∞ aσ(n) = c. n=1 ](img/file1030.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![∑∞ aσ(n) = c. n=1 ](img/file1030.png)'
- en: This is quite wild. The Riemann rearrangement theorem states that if you give
    me an arbitrary real number, I can conjure a rearrangement that’ll change the
    value to the number you gave me.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常疯狂。黎曼重排定理指出，如果你给我一个任意的实数，我可以构造一个重排，使得其值变为你给定的那个数。
- en: We won’t prove this either, but here is an intuitive explanation. Suppose that
    you want to rearrange the series to change its sum to 10\. You start putting the
    positive terms in descending order to the front, and when the partial sum overshoots
    10, you continue with the negative terms. When the partial sum undershoots 10,
    you turn to positive values once more, and you keep repeating this until infinity.
    The property of conditional convergence guarantees that this method works.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不会证明这个，但这里有一个直观的解释。假设你想重排级数以改变其和为10。你先将正项按降序排列在前，当部分和超过10时，你继续使用负项。当部分和小于10时，你再次转为正值，并不断重复这个过程，直到无穷。条件收敛的性质保证了这个方法的可行性。
- en: 'Now that we are familiar with the subtle differences between absolute and conditional
    convergence, let’s turn to one of the burning questions we should have asked already:
    how do we know if a series is convergent or not?'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了绝对收敛与条件收敛之间的细微差别，让我们转向一个我们本应早早提出的迫切问题：我们如何知道一个级数是否收敛？
- en: 10.3.5 Convergence tests for series
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.5 级数的收敛性检验
- en: Showing if a series is convergent or not is a hard task. Finding a closed form
    for the partial sums is often impossible, even in the seemingly simplest cases,
    such as ∑ [n=1]^∞![1n2](img/file1031.png).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 判断一个级数是否收敛是一项艰巨的任务。即使在看似最简单的情况下，比如 ∑ [n=1]^∞![1n2](img/file1031.png)，找到其部分和的闭式形式通常是不可能的。
- en: What to do, then? The simplest way is to compare the series with another one
    that we are familiar with.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 那么该怎么办呢？最简单的方法是将该级数与我们熟悉的其他级数进行比较。
- en: Theorem 62\. (The direct comparison test)
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 62\。 （直接比较检验）
- en: Let ![∑ ∞ an n=1 ](img/file1032.png) be an arbitrary series.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 设 ![∑ ∞ an n=1 ](img/file1032.png) 为一个任意级数。
- en: (a) If ∑ [n=1]^∞b[n] is absolutely convergent and ja[n]j ≤jb[n]j for all n after
    a certain cutoff, ∑ [n=1]^∞a[n] is absolutely convergent.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 如果 ∑ [n=1]^∞b[n] 是绝对收敛的，并且对于某个截断点后的所有 n，ja[n]j ≤jb[n]j，那么 ∑ [n=1]^∞a[n]
    是绝对收敛的。
- en: (a) If ∑ [n=1]^∞b[n] = ∞and jb[n]j ≤ja[n]j for all n after a certain cutoff,
    then ∑ [n=1]^∞a[n] = ∞.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 如果 ∑ [n=1]^∞b[n] = ∞并且 jb[n]j ≤ja[n]j 对于某个截断点之后的所有 n，则 ∑ [n=1]^∞a[n] = ∞。
- en: 'Here is a simple use case for Theorem [62](ch018.xhtml#x1-178003r62): the series'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定理[62](ch018.xhtml#x1-178003r62)的一个简单应用案例：该级数
- en: '![∞∑ -1-. n=1n α ](img/file1033.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![∞∑ -1-. n=1n α ](img/file1033.png)'
- en: For ![α >2 ](img/file1034.png), since ![n1α < 12 n ](img/file1035.png), the
    series
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ![α >2 ](img/file1034.png)，由于 ![n1α < 12 n ](img/file1035.png)，因此该级数
- en: '![∑∞ 1 -α- n=1 n ](img/file1036.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![∑∞ 1 -α- n=1 n ](img/file1036.png)'
- en: is convergent via comparison to
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 通过与...的比较收敛
- en: '![∑∞ 1 --2\. n=1n ](img/file1037.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![∑∞ 1 --2\. n=1n ](img/file1037.png)'
- en: On the other hand, for α/span>1, as ![1- nα](img/file1038.png)/span>![1 n](img/file1039.png),
    ∑ [n=1]^∞![1- nα](img/file1040.png) is divergent via comparison to the harmonic
    series.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于 α/span>1， 因为 ![1- nα](img/file1038.png)/span>![1 n](img/file1039.png)，
    ∑ [n=1]^∞![1- nα](img/file1040.png) 通过与调和级数的比较是发散的。
- en: 'Although the direct comparison test is powerful, it has a significant downside:
    you have to conjure up a series for comparison. This is not always simple. Thus,
    we need other tests to show convergence. We’ll talk about two of them: the root
    test and the alternating series test.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管直接比较检验非常强大，但它有一个显著的缺点：你必须想出一个级数来进行比较。这并不总是简单的。因此，我们需要其他的检验来展示收敛性。我们将讨论其中的两个：根号检验和交替级数检验。
- en: Theorem 63\.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 63\。
- en: (The root test)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: （根号检验）
- en: Let ∑ [n=1]^∞a[n] be an arbitrary series. If there exists a positive integer
    N such that
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 设 ∑ [n=1]^∞a[n] 为一个任意级数。如果存在一个正整数 N，使得
- en: '![∘ ---- n |an | <1 ](img/file1041.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![∘ ---- n |an | <1 ](img/file1041.png)'
- en: for all n ≥N, then ∑ [n=1]^∞a[n] is absolutely convergent.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 n ≥N，则 ∑ [n=1]^∞a[n] 是绝对收敛的。
- en: The most important use case for the root test is showing the convergence of
    ![∑ ∞n=0 1n! ](img/file1042.png) (which sums up to the Euler constant ![e ](img/file1043.png),
    but we have no way to evaluate the sum yet). We’ll have one soon, coming from
    the most unexpected place. But I don’t want to spoil the fun yet.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 根号检验的最重要应用案例是展示 ![∑ ∞n=0 1n! ](img/file1042.png) 的收敛性（它的和是欧拉常数 ![e ](img/file1043.png)，但我们目前还没有方法来计算该和）。我们很快会有一种方法，它来自一个最意想不到的地方。不过我还不想提前剧透。
- en: About that sum. As ![lim √nn!- = ∞ n→ ∞ ](img/file1044.png) (which, trust me,
    it really is), ![limn → ∞ n√1n!-= 0 ](img/file1045.png). Thus, the conditions
    of Theorem [63](ch018.xhtml#x1-178005r63) are satisfied, hence ![∑ ∞ 1- n=1 n!
    ](img/file1046.png) is convergent.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 关于该和。由于 ![lim √nn!- = ∞ n→ ∞ ](img/file1044.png)（相信我，它真的存在），![limn → ∞ n√1n!-=
    0 ](img/file1045.png)。因此，定理[63](ch018.xhtml#x1-178005r63)的条件得到满足，从而 ![∑ ∞ 1- n=1
    n! ](img/file1046.png) 是收敛的。
- en: The disadvantage of the root test is that studying the behavior of ![n√--- an](img/file1047.png)
    can be surprisingly hard. We have to be true calculus ninjas to handle all the
    bounds and limits the root test will throw at us. So, we’ll take a look at one
    more convergence test.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 根号检验的缺点是，研究 ![n√--- an](img/file1047.png) 的行为可能出乎意料地困难。我们必须是真正的微积分忍者，才能应对根号检验所抛出的所有界限和极限。因此，我们将再看一个收敛性检验。
- en: Theorem 64\.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 64\。
- en: (The alternating test, a.k.a. the Leibniz criterion)
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: （交替检验，也叫莱布尼茨准则）
- en: Let ![{an}∞n=0 ](img/file1048.png) be a sequence whose terms are either all
    nonnegative or all negative. If
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 设 ![{an}∞n=0 ](img/file1048.png) 为一个序列，其项要么全是非负的，要么全是负的。如果
- en: (a) ja[n]j decreases monotonically
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: (a) ja[n]j 单调递减
- en: (b) and ![limn →∞ an = 0 ](img/file1049.png),
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 且 ![limn →∞ an = 0 ](img/file1049.png)，
- en: then ∑ [n=0]^∞(−1)^na[n] is conditionally convergent.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 则 ∑ [n=0]^∞(−1)^na[n] 是条件收敛的。
- en: It’s that simple. The alternating test is the easiest to apply, but in turn,
    it only implies conditional convergence. With this, we can finally see that the
    alternating harmonic series ∑ [n=1]^∞(−1)^(n+1)![1 n](img/file1050.png) is conditionally
    convergent.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。交替检验是最容易应用的，但它仅仅意味着条件收敛。有了这个，我们终于可以看到交替调和级数 ∑ [n=1]^∞(−1)^(n+1)![1 n](img/file1050.png)
    是条件收敛的。
- en: 10.3.6 The Cauchy product of series
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.6 级数的 Cauchy 积
- en: To close this chapter, let’s talk about the product of two series. We’ve seen
    that the linear combination of convergent series behaves nicely, but what about
    the product? This is slightly more complicated than addition. Here is the exact
    result.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章，我们来谈谈两个级数的积。我们已经看到，收敛级数的线性组合表现得很好，但积的情况如何呢？这比加法稍微复杂一些。这里是准确的结果。
- en: Theorem 65\. (Mertens’ theorem)
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 65. (梅尔腾定理)
- en: Let ![∑ ∞ n=0 an ](img/file1051.png) and ![∑ ∞ n=0 bn ](img/file1052.png) be
    two convergent series, and assume that at least one of them converges absolutely.
    Then, the series
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 设 ![∑ ∞ n=0 an ](img/file1051.png) 和 ![∑ ∞ n=0 bn ](img/file1052.png) 是两个收敛级数，并假设其中至少一个是绝对收敛的。那么，该级数
- en: ∑[n=0]^∞ ( ∑[k=0]^n *a*[k]*b*[n−k] ) (10.3)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ∑[n=0]^∞ ( ∑[k=0]^n *a*[k]*b*[n−k] ) (10.3)
- en: is convergent and
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 是收敛的，并且
- en: '![ ∑∞ ∑∞ ∑∞ ∑n ( ak)( bn) = ( akbn−k). k=0 n=0 n=0 k=0 ](img/file1055.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑∞ ∑∞ ∑∞ ∑n ( ak)( bn) = ( akbn−k). k=0 n=0 n=0 k=0 ](img/file1055.png)'
- en: The series ([65](ch018.xhtml#x1-179004r65)) is called the Cauchy product of
    ![∑ ∞n=0 an ](img/file1056.png) and ![∑ ∞n=0bn ](img/file1057.png). Note that
    in the sum ![∑n k=0akbn−k ](img/file1058.png), the indices of each term ![akbn−
    k ](img/file1059.png) sum up to ![n ](img/file1060.png).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 该级数 ([65](ch018.xhtml#x1-179004r65)) 被称为 Cauchy 积，表示 ![∑ ∞n=0 an ](img/file1056.png)
    和 ![∑ ∞n=0bn ](img/file1057.png) 的积。请注意，在和式 ![∑n k=0akbn−k ](img/file1058.png)
    中，每项的索引 ![akbn− k ](img/file1059.png) 的和为 ![n ](img/file1060.png)。
- en: Instead of an exact proof, here is an intuitive explanation. Let’s unpack what
    is going on when we take the product of sums.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有严格的证明，而是一个直观的解释。让我们来拆解一下在求和积时发生了什么。
- en: As the product is calculated term by term, we have
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个积是逐项计算的，我们得出
- en: '![ ∑∞ ∑∞ ∑∞ ∑∞ ( ak )( bn) = (ak bn) k=0 n=0 k=0 n=0 = a0(b0 + b1 + b2 + ...)
    + a1(b0 + b1 + b2 + ...) + a2(b0 + b1 + b2 + ...) + ... = a0b0 + a0b1 + a0b2 +
    ... + a b + a b + a b + ... 1 0 1 1 12 + a2b0 + a2b1 + a2b2 + ... + .... ](img/file1061.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑∞ ∑∞ ∑∞ ∑∞ ( ak )( bn) = (ak bn) k=0 n=0 k=0 n=0 = a0(b0 + b1 + b2 + ...)
    + a1(b0 + b1 + b2 + ...) + a2(b0 + b1 + b2 + ...) + ... = a0b0 + a0b1 + a0b2 +
    ... + a b + a b + a b + ... 1 0 1 1 12 + a2b0 + a2b1 + a2b2 + ... + .... ](img/file1061.png)'
- en: After spelling out the product term by term, the terms a[k]b[l] are arranged
    in a table. Upon taking the product of ∑ [n=0]^∞a[n] and ∑ [n=0]^∞b[n], we simply
    take the terms in this table and sum them up, row by row.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在逐项展开积的过程之后，项 a[k]b[l] 被排列成一个表格。在计算 ∑ [n=0]^∞a[n] 和 ∑ [n=0]^∞b[n] 的积时，我们只需将表格中的项逐行相加。
- en: However, we can sum the terms diagonally. By taking a look at the table
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过对角线求和。通过观察这个表格
- en: '![a0b0 + a0b1 + a0b2 + ... a1b0 + a1b1 + a1b2 + ... a2b2 + a2b1 + a2b2 + ...
    ](img/file1062.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![a0b0 + a0b1 + a0b2 + ... a1b0 + a1b1 + a1b2 + ... a2b2 + a2b1 + a2b2 + ...
    ](img/file1062.png)'
- en: you can notice that the diagonals sum up to ∑ [k=0]^na[k]b[n−k]. Thus, by taking
    all of them into account, we obtain
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到对角线的和是 ∑ [k=0]^na[k]b[n−k]。因此，考虑所有这些项，我们得出
- en: '![ ∞∑ ∑∞ ∑∞ ∑n ( ak)( bn ) = ( akbn−k). k=0 n=0 n=0 k=0 ](img/file1063.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞∑ ∑∞ ∑∞ ∑n ( ak)( bn ) = ( akbn−k). k=0 n=0 n=0 k=0 ](img/file1063.png)'
- en: Of course, this is not an exact proof, as we’ve used rearrangements without
    showing absolute convergence.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是一个严格的证明，因为我们在没有展示绝对收敛的情况下使用了重新排列。
- en: 10.4 Summary
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 小结
- en: 'Until this chapter, our mathematical study was quite close to machine learning.
    Vectors, matrices, functions: they are all there at the ground zero of theory
    and practice.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 直到这一章，我们的数学研究与机器学习非常接近。向量、矩阵、函数：它们都是理论与实践的基础。
- en: This time, however, we’ve gone far below the surface. We rarely work directly
    with sequences in practice, but despite appearances, they are all over the place,
    providing a solid theoretical foundation for everything that is quantitative.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一次，我们已经远离表面了。我们在实际中很少直接处理序列，但尽管表面上看起来不是这样，序列无处不在，为所有定量的事物提供了坚实的理论基础。
- en: So, what did we learn? What numbers are, for one. Going from natural numbers
    to real numbers is nothing short of a revelation, allowing us to see the evolution
    of the concept of a number. But deep down, sequences hold the concept of numbers
    together. And whenever we talk about sequences, limits and convergence enter the
    picture.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们学到了什么？首先，数字是什么。从自然数到实数的过渡简直是一次启示，让我们看到了数字概念的演变。但从深层次看，序列将数字的概念联系在一起。而每当我们谈论序列时，极限和收敛就会进入视野。
- en: To summarize, gradient descent is about the limit of the sequence
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，梯度下降法是关于序列的极限
- en: '![ ′ xn+1 = xn − hf (xn), ](img/file1064.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![ ′ xn+1 = xn − hf (xn), ](img/file1064.png)'
- en: converging to a local minima of f if the stars are aligned. In the following
    chapters, our main goal is to understand x[n+1] = x[n] −hf^′(x[n]). What is f^′(x),
    and why does x[n] converge to a local minimum? To see the full picture, we need
    to study differentiation and integration, or in other words, calculus.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果星星对齐，x[n+1] = x[n] −hf^′(x[n]) 会收敛到 f 的局部最小值。在接下来的章节中，我们的主要目标是理解 x[n+1] =
    x[n] −hf^′(x[n])。f^′(x)是什么，为什么 x[n] 会收敛到局部最小值？为了看到完整的画面，我们需要学习微分和积分，换句话说，就是微积分。
- en: However, to get there, there’s one more step to take. It’s time to move beyond
    sequences and study the concept of limits in the context of functions!
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要做到这一点，还有一步要走。是时候超越序列，研究函数上下文中的极限概念了！
- en: 10.5 Problems
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 问题
- en: Problem 1\. Which sequences are convergent, ∞-divergent, or neither?
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 1\. 哪些序列是收敛的，哪些是∞发散的，或者两者都不是？
- en: (a) a[n] = 2^(−n²) (b) b[n] = ![√2n--](img/file1065.png) (c) c[n] = ![nn+1-](img/file1066.png)
    (d) d[n] = sin(1∕n) (e) e[n] = e^(n(−1)^n)
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: (a) a[n] = 2^(−n²) (b) b[n] = ![√2n--](img/file1065.png) (c) c[n] = ![nn+1-](img/file1066.png)
    (d) d[n] = sin(1∕n) (e) e[n] = e^(n(−1)^n)
- en: Problem 2\. Calculate the following limits.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 2\. 计算以下极限。
- en: (a) ![lim -5n2+2- n→∞ 3n2−12 ](img/file1067.png)
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: (a) ![lim -5n2+2- n→∞ 3n2−12 ](img/file1067.png)
- en: (b) ![ ( 5n2+2-) limn →∞ ln 3n2− 12 ](img/file1068.png)
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: (b) ![ ( 5n2+2-) limn →∞ ln 3n2− 12 ](img/file1068.png)
- en: (c) ![limn→ ∞ √1+n2n2- ](img/file1069.png)
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: (c) ![limn→ ∞ √1+n2n2- ](img/file1069.png)
- en: (d) ![limn →∞ n1sin (n ) ](img/file1070.png)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: (d) ![limn →∞ n1sin (n ) ](img/file1070.png)
- en: (e) lim[n→∞](1 + ![2 n](img/file1072.png))^n
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: (e) lim[n→∞](1 + ![2 n](img/file1072.png))^n
- en: Problem 3\. Which series are absolute convergent, conditionally convergent,
    or divergent? (Use the direct comparison test, the root test, and the alternating
    series test.)
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 3\. 哪些级数是绝对收敛、条件收敛或发散的？（使用直接比较法、根判别法和交错级数测试。）
- en: (a) ![∑ ∞ 2 n=0e− n ](img/file1074.png)
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: (a) ![∑ ∞ 2 n=0e− n ](img/file1074.png)
- en: (b) ![∑ ( ) ∞n=0(− 1 )n sin 1n ](img/file1075.png)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: (b) ![∑ ( ) ∞n=0(− 1 )n sin 1n ](img/file1075.png)
- en: (c) ![∑ ∞ -nn n=02 ](img/file1076.png)
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: (c) ![∑ ∞ -nn n=02 ](img/file1076.png)
- en: (d) ![∑ ∞ n+1- n=1 n2 ](img/file1077.png)
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: (d) ![∑ ∞ n+1- n=1 n2 ](img/file1077.png)
- en: (e) ∑ [n=0]^∞![--1-- 2n+n](img/file1078.png)
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: (e) ∑ [n=0]^∞![--1-- 2n+n](img/file1078.png)
- en: Join our community on Discord
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他用户、机器学习专家以及作者本人一起阅读本书。提问、为其他读者提供解决方案、通过问我任何问题与作者互动等等。扫描二维码或访问链接加入社区。[https://packt.link/math](https://packt.link/math)
- en: '![PIC](img/file1.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
