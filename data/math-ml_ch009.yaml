- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Linear Algebra in Practice
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数实战
- en: Now that we understand the geometric structure of vector spaces, it’s time to
    put the theory into practice once again. In this chapter, we’ll take a hands-on
    look at norms, inner products, and NumPy array operations in general. Most importantly,
    we’ll also meet matrices for the first time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了向量空间的几何结构，是时候再次将理论付诸实践了。在本章中，我们将动手实践范数、内积和 NumPy 数组操作。最重要的是，我们将首次接触矩阵。
- en: 'The last time we translated theory to code, we left off at finding an ideal
    representation for vectors: NumPy arrays. NumPy is built for linear algebra and
    handles computations much faster than the vanilla Python objects.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 上一次我们将理论转化为代码时，停留在为向量寻找理想表示形式的阶段：NumPy 数组。NumPy 是为线性代数而构建的，它比原生 Python 对象处理计算的速度要快得多。
- en: So, let’s initialize two NumPy arrays to play around with!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们初始化两个 NumPy 数组来玩一玩吧！
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In linear algebra, and in most of machine learning, almost all operations involve
    looping through the vector components one by one. For instance, addition can be
    implemented like this.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性代数中，以及在大多数机器学习中，几乎所有的操作都涉及逐个遍历向量的分量。例如，加法可以这样实现。
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Of course, this is far from optimal. (It may not even work if the vectors have
    different dimensions.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这远非最优。（如果向量的维度不同，这可能甚至不起作用。）
- en: For example, addition is massively parallelizable, and our implementation does
    not take advantage of that. With two threads, we can do two additions simultaneously.
    So, adding together two-dimensional vectors would require just one step, as one
    would compute x[0] + y[0], while the other x[1] + y[1]. Raw Python does not have
    access to such high-performance computing tools, but NumPy does, through functions
    implemented in C. In turn, C uses the LAPACK (Linear Algebra PACKage) library,
    which makes calls to BLAS (Basic Linear Algebra Subprograms). BLAS is optimized
    at the assembly level.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，加法是高度并行化的，而我们的实现并没有充分利用这一点。使用两个线程，我们可以同时执行两个加法操作。因此，两个二维向量的加法只需要一步，计算一个 x[0]
    + y[0]，而另一个计算 x[1] + y[1]。原生 Python 无法访问如此高性能的计算工具，但 NumPy 可以通过 C 实现的函数来实现。反过来，C
    使用 LAPACK（线性代数程序包）库，LAPACK 调用了 BLAS（基础线性代数子程序）。BLAS 在汇编级别进行了优化。
- en: So, whenever it is possible, we should strive to work with vectors in a NumPythonic
    way. (Yes, I just made that term up.) For vector addition, this is simply the
    + operator, as we have seen earlier.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，每当可能时，我们应尽量以 NumPythonic 的方式（是的，我刚刚造了这个词）处理向量。对于向量加法，这仅仅是 + 运算符，如我们之前所见。
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By the way, you shouldn’t ever compare floats with the == operator, as internal
    rounding errors can occur due to the float representation. The example below illustrates
    this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，你永远不应该使用 == 运算符来比较浮点数，因为由于浮点数表示，可能会出现内部舍入误差。下面的例子说明了这一点。
- en: '[PRE6]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To compare arrays, NumPy provides the functions np.allclose and np.equal. These
    compare arrays elementwise, returning a Boolean array. From this, the built-in
    all function can be used to see if all the elements match.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较数组，NumPy 提供了 np.allclose 和 np.equal 函数。这些函数逐元素比较数组，返回一个布尔数组。从中，可以使用内建的 all
    函数来判断是否所有元素都匹配。
- en: '[PRE10]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the following section, we’ll briefly review how to work with NumPy arrays
    in practice.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将简要回顾如何在实践中使用 NumPy 数组。
- en: 3.1 Vectors in NumPy
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 NumPy 中的向量
- en: 'There are two operations that we definitely want to do with our vectors: apply
    a function elementwise or take the sum/product of the elements. Since the +, *,
    and ** operators are implemented for our arrays, certain functions carry over
    from scalars, as the example below shows.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个操作是必须对向量进行的：逐元素应用函数或求元素的和/积。由于 +、* 和 ** 运算符已为我们的数组实现，某些函数可以从标量扩展，如下例所示。
- en: '[PRE12]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, we can’t just plug in ndarrays to every function. For instance, let’s
    take a look at Python’s built-in exp from its math module.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能直接将 ndarray 插入到每个函数中。例如，让我们看看 Python 内建的 exp 函数，它来自 math 模块。
- en: '[PRE14]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To overcome this problem, we could manually apply the function elementwise.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，我们可以手动逐元素应用函数。
- en: '[PRE16]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: (Recall that np.empty_like(x) creates an uninitialized array that matches the
    dimensions of x.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: （回想一下，np.empty_like(x) 创建一个未初始化的数组，该数组的维度与 x 相匹配。）
- en: '[PRE17]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A bit less naive implementation would use a list comprehension to achieve the
    same effect.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个略微不那么天真的实现会使用列表推导式来达到相同的效果。
- en: '[PRE19]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Even though comprehensions are more concise and readable, they still don’t
    avoid the core issue: for loops in Python.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管列表推导式更简洁且更具可读性，但它们仍然无法避免核心问题：Python 中的 for 循环。
- en: This problem is solved by NumPy’s famous ufuncs, that is, functions that operate
    element by element on whole arrays ( [https://numpy.org/doc/stable/reference/generated/numpy.ufunc.html](https://numpy.org/doc/stable/reference/generated/numpy.ufunc.html)).
    Since they are implemented in C, they are blazing fast. For instance, the exponential
    function f(x) = e^x is given by np.exp.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题通过 NumPy 著名的 ufuncs 解决，即对整个数组逐元素操作的函数（[https://numpy.org/doc/stable/reference/generated/numpy.ufunc.html](https://numpy.org/doc/stable/reference/generated/numpy.ufunc.html)）。由于它们是用
    C 实现的，因此运行速度非常快。例如，指数函数 f(x) = e^x 由 np.exp 给出。
- en: '[PRE21]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Not surprisingly, the results of our implementations match.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，我们的实现结果一致。
- en: '[PRE23]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Again, there are more advantages to using NumPy functions and operations than
    simplicity. In machine learning, we care a lot about speed, and as we are about
    to see, NumPy delivers once more.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，使用 NumPy 函数和操作的优势不止于简单。在机器学习中，我们非常关心速度，正如我们即将看到的，NumPy 再次展现了其优势。
- en: '[PRE27]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For further reference, you can find the list of available ufuncs here: [https://numpy.org/doc/stable/reference/ufuncs.html\#available-ufuncs](https://numpy.org/doc/stable/reference/ufuncs.html/#available-ufuncs).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如需进一步参考，您可以在这里找到可用的 ufunc 列表：[https://numpy.org/doc/stable/reference/ufuncs.html\#available-ufuncs](https://numpy.org/doc/stable/reference/ufuncs.html/#available-ufuncs)。
- en: What about operations that aggregate the elements and return a single value?
    Not surprisingly, these can be found within NumPy as well. For instance, let’s
    take a look at the sum. In terms of mathematical formulas, we are looking to implement
    the function
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于汇总元素并返回单一值的操作呢？不出所料，这些操作在 NumPy 中也可以找到。例如，让我们看看求和。在数学公式中，我们要实现的是：
- en: '![ n ∑ n sum (x) = xi, x = (x1,...,xn ) ∈ ℝ . i=1 ](img/file250.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![ n ∑ n sum (x) = xi, x = (x1,...,xn ) ∈ ℝ . i=1 ](img/file250.png)'
- en: A basic approach would be something like this.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一种基本方法可能是这样的：
- en: '[PRE29]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Alternatively, we can use Python’s built-in summing function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 Python 内置的求和函数。
- en: '[PRE31]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The story is the same: NumPy can do this better. We can either call the function
    np.sum or use the array method np.ndarray.sum.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 故事是一样的：NumPy 做得更好。我们可以调用函数 np.sum，或者使用数组方法 np.ndarray.sum。
- en: '[PRE33]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You know by now that I love timing functions, so let’s compare the performances
    once more.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道我喜欢计时函数，所以我们再来比较一次性能。
- en: '[PRE37]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Similarly, the product
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，乘积
- en: '![ ∏n prod (x ) = xi, x = (x1,...,xn) ∈ ℝn i=1 ](img/file251.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![ ∏n prod (x ) = xi, x = (x1,...,xn) ∈ ℝn i=1 ](img/file251.png)'
- en: is implemented by the np.prod function and the np.ndarray.prod method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由 np.prod 函数和 np.ndarray.prod 方法实现。
- en: '[PRE39]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: On quite a few occasions, we need to find the maximum or minimum of an array.
    We can do this using the np.max and np.min functions. (Similarly to the others,
    these are also available as array methods.) The rule of thumb is if you want to
    perform any array operation, use NumPy functions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多情况下，我们需要找到一个数组的最大值或最小值。我们可以使用 np.max 和 np.min 函数来实现。（与其他函数类似，它们也可以作为数组方法使用。）经验法则是，如果你想进行任何数组操作，使用
    NumPy 函数。
- en: 3.1.1 Norms, distances, and dot products
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 范数、距离和点积
- en: 'Now that we have reviewed how to perform operations on our vectors efficiently,
    it’s time to dive deep into the really interesting part: norms and distances.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了如何高效地对向量进行操作，接下来是深入探讨真正有趣的部分：范数和距离。
- en: 'Let’s start with the most important one: the Euclidean norm, also known as
    the 2-norm, defined by'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最重要的一个开始：欧几里得范数，也称为 2-范数，定义为
- en: '![ ∑n ∥x∥2 = ( x2i)1∕2, x = (x1,...,xn) ∈ ℝn. i=1 ](img/file252.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n ∥x∥2 = ( x2i)1∕2, x = (x1,...,xn) ∈ ℝn. i=1 ](img/file252.png)'
- en: A straightforward implementation would be the following.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的实现如下。
- en: '[PRE41]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that our euclidean_norm function is dimension-agnostic; that is, it works
    for arrays of every dimension.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的 euclidean_norm 函数是与维度无关的；也就是说，它适用于所有维度的数组。
- en: '[PRE42]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'But wait, didn’t I just mention that we should use NumPy functions whenever
    possible? Norms are important enough to have their own functions: np.linalg.norm.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，我刚刚不是说过，我们应该尽可能使用 NumPy 函数吗？范数足够重要，以至于有自己的函数：np.linalg.norm。
- en: '[PRE46]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With a quick inspection, we can check that these match for our vector x.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过快速检查，我们可以验证这些结果是否与我们的向量 x 匹配。
- en: '[PRE48]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: However, the Euclidean norm is just a special case of p-norms. Recall that for
    any p ∈ [0,∞), we defined the p-norm by the formula
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，欧几里得范数只是 p-范数的特例。回想一下，对于任何 p ∈ [0,∞)，我们通过以下公式定义 p-范数：
- en: '![ n ∥x∥ = (∑ |x |p)1∕p, x = (x ,...,x ) ∈ ℝn, p i=1 i 1 n ](img/file253.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![ n ∥x∥ = (∑ |x |p)1∕p, x = (x ,...,x ) ∈ ℝn, p i=1 i 1 n ](img/file253.png)'
- en: and
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![∥x∥∞ = max {|x1 |,...,|xn |}, x = (x1,...,xn) ∈ ℝn ](img/file254.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![∥x∥∞ = max {|x1 |,...,|xn |}, x = (x1,...,xn) ∈ ℝn ](img/file254.png)'
- en: 'for p = ∞. It is a good practice to keep the number of functions in a codebase
    minimal to reduce maintenance costs. Can we compact all p-norms into a single
    Python function that takes the value of p as an argument? Sure. We only have a
    small issue: representing ∞. Python and NumPy both provide their own representations,
    but we will go with NumPy’s np.inf. Surprisingly, this is a float type.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 p = ∞。保持代码库中的函数数量最少是一种好习惯，这样可以降低维护成本。我们能否将所有 p-范数合并成一个接收 p 值作为参数的 Python
    函数？当然可以。我们只遇到了一个小问题：表示 ∞。Python 和 NumPy 都提供了各自的表示方法，但我们将使用 NumPy 的 np.inf。令人惊讶的是，这个是浮动类型。
- en: '[PRE50]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since ∞ can have multiple other representations, such as Python’s built-in math.inf,
    we can make our function more robust by using the np.isinf function to check if
    an object represents ∞ or not.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ∞ 可以有多种表示方式，比如 Python 内建的 math.inf，我们可以通过使用 np.isinf 函数来检查一个对象是否表示 ∞，从而让我们的函数更加健壮。
- en: A quick check shows that p_norm works as intended.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 快速检查显示 p_norm 按预期工作。
- en: '[PRE53]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: However, once again, NumPy is one step ahead of us. In fact, the familiar np.linalg.norm
    already does this out of the box. We can achieve the same with less code by passing
    the value of p as the argument ord, short for order. For ord = 2, we obtain the
    good old 2-norm.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，再一次，NumPy 已经领先我们一步。事实上，熟悉的 np.linalg.norm 已经可以直接实现这一功能。我们可以通过将 p 的值作为参数 ord（即
    order 的缩写）传递，从而用更少的代码实现相同的功能。对于 ord = 2，我们得到传统的 2-范数。
- en: '[PRE55]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Somewhat surprisingly, distances don’t have their own NumPy functions. However,
    as the most common distance metrics are generated from norms (Section [2.1.1](ch008.xhtml#defining-distances-from-norms)),
    we can often write our own. For instance, here is the Euclidean distance.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有些令人惊讶的是，距离度量并没有自己独立的 NumPy 函数。然而，由于最常见的距离度量是通过范数（第[2.1.1节](ch008.xhtml#defining-distances-from-norms)）生成的，我们通常可以自己编写。例如，这是欧几里得距离。
- en: '[PRE57]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Besides norms and distances, the third component that defines the geometry of
    our vector spaces is the inner product. During our journey, we’ll almost exclusively
    use the dot product, defined in the vector space ℝ^n by
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了范数和距离，定义我们向量空间几何的第三个组成部分是内积。在我们的学习过程中，我们几乎只会使用点积，它在向量空间 ℝ^n 中的定义为：
- en: '![ n ⟨x, y⟩ = ∑ x y, x, y ∈ ℝn. i i i=1 ](img/file255.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![ n ⟨x, y⟩ = ∑ x y, x, y ∈ ℝn. i i i=1 ](img/file255.png)'
- en: By now, you can easily smash out a Python function that calculates this. In
    principle, the one-liner below should work.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该能够轻松地编写一个计算该值的 Python 函数。原则上，下面的单行代码应该可以工作。
- en: '[PRE58]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Let’s test this out!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看！
- en: '[PRE59]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When the dimension of the vectors doesn’t match, the function throws an exception
    as we expect.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当向量的维度不匹配时，函数会抛出我们预期的异常。
- en: '[PRE61]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: However, upon further attempts to break the code, a strange thing occurs. Our
    function dot_product should fail when called with an n-dimensional and one-dimensional
    vector, and this is not what happens.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在进一步尝试破坏代码时，发生了一件奇怪的事。我们的函数 dot_product 应该在传入一个 n 维向量和一个一维向量时失败，但实际情况并非如此。
- en: '[PRE63]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: I always advocate breaking solutions in advance to avoid later surprises, and
    the above example excellently illustrates the usefulness of this principle. If
    the previous phenomenon occurs in production, you would have code that executes
    properly but gives a totally wrong result. That’s the worst kind of bug.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是主张提前破坏解决方案，以避免后续的意外，而上面的例子很好地说明了这一原则的有用性。如果之前的现象发生在生产环境中，你可能会有一段正常执行的代码，却给出完全错误的结果。这是最糟糕的
    bug。
- en: Behind the scenes, NumPy is doing something called broadcasting. When performing
    an operation on two arrays with mismatching shapes, it tries to guess the correct
    sizes and reshape them so that the operation can go through. Check out what takes
    place when calculating x*y.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，NumPy 正在执行名为广播（broadcasting）的操作。当对两个形状不匹配的数组执行操作时，它会尝试推测正确的大小，并重新调整它们的形状，以使操作得以进行。查看在计算
    x*y 时发生了什么。
- en: '[PRE65]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: NumPy guessed that we want to multiply all elements of x by the scalar y[0],
    so it transforms y = np.array([2.0]) into np.array([2.0, 2.0, 2.0, 2.0]), then
    calculates the elementwise product.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 猜测我们想要将 x 的所有元素乘以标量 y[0]，所以它将 y = np.array([2.0]) 转换为 np.array([2.0, 2.0,
    2.0, 2.0])，然后计算逐元素乘积。
- en: Broadcasting is extremely useful because it allows us to write much simpler
    code by automagically performing transformations. Still, if you are unaware of
    how and when broadcasting is done, it can seriously come back to bite you. Just
    like in our case, as the inner product of a four-dimensional and one-dimensional
    vector is not defined.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 广播非常有用，因为它通过自动执行转换让我们编写更简洁的代码。然而，如果你不清楚广播是如何以及何时进行的，它可能会给你带来麻烦。就像我们的情况一样，四维和一维向量的内积是没有定义的。
- en: To avoid writing excessive checks for edge cases (or missing them altogether),
    we calculate the inner product in practice using the np.dot function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免写过多的边界条件检查（或完全漏掉），我们在实际操作中使用np.dot函数来计算内积。
- en: '[PRE67]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When attempting to call np.dot with misaligned arrays, it fails as supposed
    to, even in cases when broadcasting bails out our custom implementation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试调用np.dot时，如果数组不对齐，它会按预期失败，即便广播功能会让我们自定义的实现成功运行。
- en: '[PRE69]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now that we have a basic arsenal of array operations and functions, it is time
    to do something with them!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了基本的数组操作和函数，是时候用它们做点事情了！
- en: 3.1.2 The Gram-Schmidt orthogonalization process
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 Gram-Schmidt正交化过程
- en: One of the most fundamental algorithms in linear algebra is the Gram-Schmidt
    orthogonalization process (Theorem [13](ch008.xhtml#x1-47004r13)), used to turn
    a set of linearly independent vectors into an orthonormal set.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数中最基本的算法之一是Gram-Schmidt正交化过程（定理[13](ch008.xhtml#x1-47004r13)），用于将一组线性无关的向量转化为标准正交集。
- en: To be more precise, for our input of a set of linearly independent vectors v[1],…,v[n]
    ∈ℝ^n, the Gram-Schmidt process finds the output set of vectors e[1],…,e[n] ∈ℝ^n
    such that ∥e[i]∥ = 1 and ⟨e[i],e[j]⟩ = 0 for all i≠j (that is, the vectors are
    orthonormal), and span(e[1],…,e[k]) = span(v[1],…,v[k]) for all k = 1,…,n.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，对于输入的线性无关向量集v[1],…,v[n] ∈ℝ^n，Gram-Schmidt过程会找到输出的向量集e[1],…,e[n] ∈ℝ^n，使得∥e[i]∥
    = 1且⟨e[i],e[j]⟩ = 0 对所有i≠j（即向量是正交标准的），并且span(e[1],…,e[k]) = span(v[1],…,v[k])
    对所有k = 1,…,n成立。
- en: If you are having trouble recalling how this is done, feel free to revisit Section
    2.2.5, where we first described the algorithm. The learning process is a spiral,
    where we keep revisiting old concepts from new perspectives. For the Gram-Schmidt
    process, this is our second iteration, where we put the mathematical formulation
    into code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记不清楚怎么做了，可以随时回顾第2.2.5节，我们在其中首次描述了该算法。学习过程是一个螺旋式的过程，我们不断从新的角度回顾旧的概念。对于Gram-Schmidt过程来说，这是我们的第二次迭代，我们将数学公式转化为代码。
- en: 'Since we are talking about a sequence of vectors, we need a suitable data structure
    for this purpose. There are several possibilities for this in Python. For now,
    we are going with the conceptually simplest, albeit computationally rather suboptimal,
    one: lists.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理一系列向量，因此需要一个合适的数据结构来存储它们。在Python中，有几种可能的选择。目前我们选择了一个概念上最简单，尽管计算上不太优的方案：列表。
- en: '[PRE71]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The first component of the algorithm is the orthogonal projection operator,
    defined by
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的第一个组成部分是正交投影算子，定义为
- en: '![ ∑k proj (x) = ⟨x,ei⟩ei. e1,...,ek i=1 ⟨ei,ei⟩ ](img/file456.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑k proj (x) = ⟨x,ei⟩ei. e1,...,ek i=1 ⟨ei,ei⟩ ](img/file456.png)'
- en: With our NumPy tools, the implementation is straightforward by now.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有了NumPy工具，实施变得非常直接。
- en: '[PRE73]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: To check if it works, let’s look at a simple example and visualize the results.
    Since this book is written in Jupyter Notebooks, we can do it right here.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查它是否有效，让我们看一个简单的例子并可视化结果。由于本书是用Jupyter Notebooks编写的，我们可以直接在这里进行操作。
- en: '[PRE74]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '![PIC](img/file257.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file257.png)'
- en: 'Figure 3.1: The projection of x to e'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：x到e的投影
- en: Checking the orthogonality of e and x - x to e provides another means of verification.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 检查e和x的正交性——x到e为我们提供了另一种验证手段。
- en: '[PRE76]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: When writing code for production, a couple of visualizations and ad hoc checks
    are not enough. An extensive set of unit tests is customarily written to ensure
    that a function works as intended. We are skipping this to keep our discussion
    on track, but feel free to add some of your tests. After all, mathematics and
    programming are not a spectator’s sport.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在为生产环境编写代码时，几个可视化和临时检查并不足够。通常会编写一套详尽的单元测试，确保函数按预期工作。为了保持讨论的进度，我们跳过了这部分，但你可以随时添加一些测试。毕竟，数学和编程不是观众的运动。
- en: With the projection function available to us, we are ready to knock the Gram-Schmidt
    algorithm out of the park.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有了投影函数，我们准备好大展身手，实现Gram-Schmidt算法。
- en: '[PRE78]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Let’s quickly test out this implementation with a simple example.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子快速测试一下这个实现。
- en: '[PRE80]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: So, we have just created our first algorithm from scratch. This is like the
    base camp for Mount Everest. We have come a long way, but there is much further
    to go before we can create a neural network from scratch. Until then, the journey
    is packed with some beautiful sections, and this is one of them. Take a while
    to appreciate this, then move on when you are ready.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们刚刚从头开始创建了我们的第一个算法。这就像是珠穆朗玛峰的基地营。我们已经走了很长一段路，但在我们能够从头开始创建神经网络之前，还有很长的路要走。直到那时，这段旅程将充满一些美丽的部分，而这就是其中之一。花点时间欣赏这一部分，准备好后再继续前行。
- en: Remark 4\. (Linearly dependent inputs of the Gram-Schmidt process)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 备注 4\. （格拉姆-施密特过程中的线性相关输入）
- en: Recall that if the input vectors of the Gram-Schmidt are linearly dependent,
    some vectors of the output are zero (Remark [3](ch008.xhtml#x1-47008r3)). In practice,
    this causes a lot of problems.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果格拉姆-施密特的输入向量线性相关，则输出的一些向量为零（备注 [3](ch008.xhtml#x1-47008r3)）。在实践中，这会引发许多问题。
- en: 'For instance, we normalize the vectors in the end, using list comprehension:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们在最后对向量进行归一化，使用列表推导式：
- en: '[PRE82]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This can cause numerical issues. If any v is approximately 0, its norm np.linalg.norm(v, ord=2)
    is going to be really small, and division with such small numbers is problematic.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致数值问题。如果任何 v 近似为 0，则其范数 np.linalg.norm(v, ord=2) 会非常小，而用这样的小数进行除法会引发问题。
- en: 'This issue also affects the projection function. Take a look at the definition
    below:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题也影响投影函数。请看下面的定义：
- en: '[PRE83]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: If e is (close to) 0, which can happen if the input vectors are linearly dependent,
    then e_norm_square is small. One way to solve this is to add a small float, say,
    1e-16.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 e 接近 0（当输入向量线性相关时可能发生这种情况），那么 e_norm_square 会很小。解决这个问题的一种方法是加上一个很小的浮动数，例如
    1e-16。
- en: '[PRE84]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, let’s meet the single most important objects in machine learning: matrices.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来认识机器学习中最重要的对象：矩阵。
- en: 3.2 Matrices, the workhorses of linear algebra
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 矩阵，线性代数的主力军
- en: I am quite sure that you were already familiar with the notion of matrices before
    reading this book. Matrices are one of the most important data structures that
    can represent systems of equations, graphs, mappings between vector spaces, and
    many more. Matrices are the fundamental building blocks of machine learning.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我很确定在阅读这本书之前，你已经熟悉矩阵的概念。矩阵是最重要的数据结构之一，可以表示方程组、图、向量空间之间的映射等等。矩阵是机器学习的基本构建块。
- en: At first look, we define a matrix as a table of numbers. If the matrix A has,
    for instance, n rows and m columns of real numbers, we write
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，我们将矩阵定义为一个数字表格。例如，如果矩阵 A 具有 n 行和 m 列的实数，我们写作
- en: '![⌊ ⌋ | a1,1 a1,2 ... a1,m | || a2,1 a2,2 ... a2,m || | . . . . | n×m A = ||
    .. .. .. .. || ∈ ℝ . || a a ... a || ⌈ n,1 n,2 n,m ⌉](img/file258.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![⌊ ⌋ | a1,1 a1,2 ... a1,m | || a2,1 a2,2 ... a2,m || | . . . . | n×m A = ||
    .. .. .. .. || ∈ ℝ . || a a ... a || ⌈ n,1 n,2 n,m ⌉](img/file258.png)'
- en: (3.1)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: (3.1)
- en: When we don’t want to write out the entire matrix as ([3.1](ch009.xhtml#matrices-the-workhorses-of-linear-algebra)),
    we use the abbreviation A = (a[i,j])[i=1,j=1]^(n,m).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不想写出完整的矩阵时，如 ([3.1](ch009.xhtml#matrices-the-workhorses-of-linear-algebra))，我们使用缩写
    A = (a[i,j])[i=1,j=1]^(n,m)。
- en: The set of all n ×m real matrices is denoted by ℝ^(n×m). We will exclusively
    talk about real matrices, but when referring to other types, this notation is
    modified accordingly. For instance, ℤ^({n×m}) denotes the set of integer matrices.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 n ×m 实数矩阵的集合记作 ℝ^(n×m)。我们将专门讨论实矩阵，但在提到其他类型时，这个符号会相应地修改。例如，ℤ^({n×m}) 表示整数矩阵的集合。
- en: Matrices can be added and multiplied together, or multiplied by a scalar.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵可以进行加法和乘法运算，或者与标量相乘。
- en: Definition 14\. (Matrix operations)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 14\. （矩阵运算）
- en: (a) Let A ∈ℝ^(n×m) be a matrix and c ∈ℝ a real number. The multiple of A by
    the scalar c is defined by
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 设 A ∈ℝ^(n×m) 为一个矩阵，c ∈ℝ 为一个实数。矩阵 A 与标量 c 的乘积定义为
- en: '![ n,m cA := (cai,j)i,j=1 ∈ ℝn ×m. ](img/file259.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![ n,m cA := (cai,j)i,j=1 ∈ ℝn ×m. ](img/file259.png)'
- en: (b) Let A,B ∈ℝ^(n×m) be two matrices of matching dimensions. Their sum A + B
    is defined by
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 设 A, B ∈ℝ^(n×m) 为两个匹配维度的矩阵。它们的和 A + B 定义为
- en: '![ n,m n×m A + B := (ai,j + bi,j)i,j=1 ∈ ℝ . ](img/file260.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![ n,m n×m A + B := (ai,j + bi,j)i,j=1 ∈ ℝ . ](img/file260.png)'
- en: (c) Let A ∈ℝ^(n×l) and B ∈ℝ^(l×m) be two matrices. Their product AB ∈ℝ^(n×m)
    is defined by
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: (c) 设 A ∈ℝ^(n×l) 且 B ∈ℝ^(l×m) 为两个矩阵。它们的乘积 AB ∈ℝ^(n×m) 定义为
- en: '![ l ∑ n,m n×m AB := ( ai,kbk,j)i,j=1 ∈ ℝ . k=1 ](img/file261.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![ l ∑ n,m n×m AB := ( ai,kbk,j)i,j=1 ∈ ℝ . k=1 ](img/file261.png)'
- en: Scalar multiplication and addition are clear, but matrix multiplication is not
    as simple to understand. Fortunately, visualization can help. In essence, the
    (i,j)-th element is the dot product of the i-th row of A and the j-th column of
    B.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 标量乘法和加法很容易理解，但矩阵乘法并不像加法那样简单。幸运的是，可视化可以帮助我们理解。实质上，（i,j）元素是矩阵 A 的第 i 行与矩阵 B 的第
    j 列的点积。
- en: '![PIC](img/file262.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file262.png)'
- en: 'Figure 3.2: Visualizing matrix multiplication'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：矩阵乘法可视化
- en: 'Besides addition and multiplication, there is another operation that is worth
    mentioning: transposition.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加法和乘法，还有另一个值得提及的操作：转置。
- en: Definition 15\. (Matrix transposition)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 15.（矩阵转置）
- en: Let A = (a[{]i,j})[{]i,j = 1}^({n,m}) ∈ ℝ^({n×m}) be a matrix. The matrix A^T
    , defined by
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 设 A = (a[{]i,j})[{]i,j = 1}^({n,m}) ∈ ℝ^({n×m}) 是一个矩阵。矩阵 A^T 定义为：
- en: '![AT = (aj,i)ni,,jm=1 ∈ ℝm ×n ](img/file263.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![AT = (aj,i)ni,,jm=1 ∈ ℝm ×n ](img/file263.png)'
- en: is called the transpose of A. The operation A→A^T is called transposition.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 A 的转置。操作 A→A^T 称为转置。
- en: Transposition simply means “flipping” the matrix, replacing rows with columns.
    For example,
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 转置简单来说就是“翻转”矩阵，将行替换为列。例如：
- en: '![ ⌊ ⌋ ⌊ ⌋ ⌈a b⌉ T ⌈a c⌉ A = c d , A = b d , ](img/file265.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ ⌊ ⌋ ⌈a b⌉ T ⌈a c⌉ A = c d , A = b d , ](img/file265.png)'
- en: or
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '![ ⌊0 1⌋ ⌊ ⌋ | | 0 2 4 B = |⌈2 3|⌉ , BT = ⌈ ⌉ . 4 5 1 3 5 ](img/file266.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊0 1⌋ ⌊ ⌋ | | 0 2 4 B = |⌈2 3|⌉ , BT = ⌈ ⌉ . 4 5 1 3 5 ](img/file266.png)'
- en: As opposed to addition and multiplication, transposition is a unary operation.
    (Unary means that it takes one argument. Binary operations take two arguments,
    and so on.)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与加法和乘法不同，转置是一个一元操作。（一元操作意味着它只需要一个参数。二元操作需要两个参数，以此类推。）
- en: Let’s take another look at matrix multiplication, one of the most frequently
    used operations in computing. As it can be performed extremely fast on modern
    computers, it is common to vectorize certain algorithms just to express it in
    terms of matrix multiplications.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一遍矩阵乘法，这是计算中最常用的操作之一。由于现代计算机可以极其快速地执行矩阵乘法，很多算法都被向量化，以便通过矩阵乘法来表示。
- en: Thus, the more we know about it, the better. To get a grip on the operation
    itself, we can take a look at it from a few different angles. Let’s start with
    a special case!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，越了解它越好。为了更好地掌握这一操作，我们可以从不同的角度来看看它。让我们从一个特例开始！
- en: In machine learning, taking the product of a matrix and a column vector is a
    fundamental building block of certain models. For instance, this is linear regression
    in itself, or the famous fully connected layer in neural networks.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，矩阵与列向量的乘积是某些模型的基础组成部分。例如，这本身就是线性回归，或者是神经网络中的著名全连接层。
- en: To see what happens in this case, let A ∈ℝ^(n×m) be a matrix. If we treat x
    ∈ℝ^m as a column vector x ∈ℝ^(m×1), then Ax can be written as
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看这种情况发生了什么，设 A ∈ℝ^(n×m) 是一个矩阵。如果我们把 x ∈ℝ^m 看作一个列向量 x ∈ℝ^(m×1)，那么 Ax 可以写成：
- en: '![ ⌊ ⌋ ⌊ ⌋ ⌊ ∑m ⌋ a1,1 a1,2 ... a1,m x1 j=1a1,jxj || a2,1 a2,2 ... a2,m ||
    || x2|| || ∑m a2,jxj|| Ax = || . . . . || || . || = || j=1\. || . |⌈ .. .. ..
    .. |⌉ |⌈ .. |⌉ |⌈ .. |⌉ ∑m an,1 an,2 ... an,m. xm j=1 an,jxj ](img/file267.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ ⌊ ⌋ ⌊ ∑m ⌋ a1,1 a1,2 ... a1,m x1 j=1a1,jxj || a2,1 a2,2 ... a2,m ||
    || x2|| || ∑m a2,jxj|| Ax = || . . . . || || . || = || j=1\. || . |⌈ .. .. ..
    .. |⌉ |⌈ .. |⌉ |⌈ .. |⌉ ∑m an,1 an,2 ... an,m. xm j=1 an,jxj ](img/file267.png)'
- en: Based on this, the matrix A describes a function that takes a piece of data
    x, then transforms it into the form Ax.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，矩阵 A 描述了一个函数，它接受一块数据 x，然后将其转换为 Ax 的形式。
- en: This is the same as taking the linear combination of the columns of A, that
    is,
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这就相当于对矩阵 A 的列进行线性组合，即：
- en: '![⌊ ⌋⌊ ⌋ ⌊ ⌋ ⌊ ⌋ a1,1 a1,2 ... a1,m x1 a1,1 a1,m || |||| || || || || || ||a2,1
    a2,2 ... a2,m |||| x2|| = x1|| a2,1|| + ⋅⋅⋅+ xm ||a2,m|| |⌈ ... ... ... ... |⌉|⌈
    ...|⌉ |⌈ ... |⌉ |⌈ ... |⌉ an,1 an,2 ... an,m. xm an,1 an,m ](img/file268.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![⌊ ⌋⌊ ⌋ ⌊ ⌋ ⌊ ⌋ a1,1 a1,2 ... a1,m x1 a1,1 a1,m || |||| || || || || || ||a2,1
    a2,2 ... a2,m |||| x2|| = x1|| a2,1|| + ⋅⋅⋅+ xm ||a2,m|| |⌈ ... ... ... ... |⌉|⌈
    ...|⌉ |⌈ ... |⌉ |⌈ ... |⌉ an,1 an,2 ... an,m. xm an,1 an,m ](img/file268.png)'
- en: With a bit more suggestive notation, by denoting the i-th column as a[i], we
    can write
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更具提示性的符号，我们可以将第 i 列表示为 a[i]，这样就可以写成：
- en: '![⌊ ⌋ | a1,1 a1,2 ... a1,m | || a2,1 a2,2 ... a2,m || | . . . . | n×m A = ||
    .. .. .. .. || ∈ ℝ . || a a ... a || ⌈ n,1 n,2 n,m ⌉](img/equation_(1).png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![⌊ ⌋ | a1,1 a1,2 ... a1,m | || a2,1 a2,2 ... a2,m || | . . . . | n×m A = ||
    .. .. .. .. || ∈ ℝ . || a a ... a || ⌈ n,1 n,2 n,m ⌉](img/equation_(1).png)'
- en: (3.2)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: (3.2)
- en: If we replace the vector x with a matrix B, the columns in the product matrix
    AB are linear combinations of the columns of A, where the coefficients are determined
    by B.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用矩阵 B 替代向量 x，那么乘积矩阵 AB 中的列是矩阵 A 的列的线性组合，其中系数由 B 决定。
- en: You should really appreciate that certain operations on the data can be written
    in the form Ax. Elevating this simple property to a higher level of abstraction,
    we can say that the data has the same representation as the function. If you are
    familiar with programming languages like Lisp, you know how beautiful this is.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该真正意识到，对数据进行的某些操作可以写成Ax的形式。将这个简单的性质提升到更高的抽象层次，我们可以说数据和函数有着相同的表示。如果你熟悉像Lisp这样的编程语言，你会知道这有多美妙。
- en: 'There is one more way to think about the matrix product: taking the columnwise
    inner products. If a[i] = (a[i,1],…,a[i,n]) denotes the i-th column of A, then
    Ax can be written as'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种思考矩阵乘积的方式：取列内积。如果a[i] = (a[i,1],…,a[i,n])表示A的第i列，那么Ax可以写成
- en: '![⌊ ⌋ | a1,1 a1,2 ... a1,m | || a2,1 a2,2 ... a2,m || | . . . . | n×m A = ||
    .. .. .. .. || ∈ ℝ . || a a ... a || ⌈ n,1 n,2 n,m ⌉](img/equation_(2).png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![⌊ ⌋ | a1,1 a1,2 ... a1,m | || a2,1 a2,2 ... a2,m || | . . . . | n×m A = ||
    .. .. .. .. || ∈ ℝ . || a a ... a || ⌈ n,1 n,2 n,m ⌉](img/equation_(2).png)'
- en: (3.3)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: (3.3)
- en: That is, the transformation x→Ax projects the input x to the row vectors of
    A, then compacts the results in a vector.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，变换x→Ax将输入x投影到A的行向量上，然后将结果压缩成一个向量。
- en: 3.2.1 Manipulating matrices
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 操作矩阵
- en: Because matrix operations are well defined, we can do algebra on matrices just
    as with numbers. However, there are some major differences. As manipulating matrix
    expressions is an essential skill, let’s take a look at its fundamental rules!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因为矩阵运算是定义良好的，我们可以像处理数字一样对矩阵进行代数运算。然而，还是存在一些主要的区别。由于操作矩阵表达式是一个基本技能，我们来看看它的基本规则！
- en: Theorem 16\. (Properties of matrix addition and multiplication)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 定理16. （矩阵加法和乘法的性质）
- en: (a) Let A,B,C ∈ℝ^(n×l) be arbitrary matrices. Then,
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 设A,B,C ∈ℝ^(n×l)是任意矩阵。那么，
- en: '![A + (B + C ) = (A + B )+ C ](img/file276.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![A + (B + C ) = (A + B )+ C ](img/file276.png)'
- en: holds. That is, matrix addition is associative.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这成立。也就是说，矩阵加法是结合的。
- en: (b) Let A ∈ℝ^(n×l), B ∈ℝ^(l×k), C ∈ℝ^(k×m) be arbitrary matrices. Then,
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 设A ∈ℝ^(n×l), B ∈ℝ^(l×k), C ∈ℝ^(k×m)是任意矩阵。那么，
- en: '![A (BC ) = (AB )C ](img/file277.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![A (BC ) = (AB )C ](img/file277.png)'
- en: holds. That is, matrix multiplication is associative.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这成立。也就是说，矩阵乘法是结合的。
- en: (c) Let A ∈ℝ^(n×l) and B,C ∈ℝ^(l×m) be arbitrary matrices. Then,
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: (c) 设A ∈ℝ^(n×l) 和 B,C ∈ℝ^(l×m)是任意矩阵。那么，
- en: '![A(B + C ) = AB + AC ](img/file278.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![A(B + C ) = AB + AC ](img/file278.png)'
- en: holds. That is, matrix multiplication is left-distributive with respect to addition.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这成立。也就是说，矩阵乘法对加法是左分配的。
- en: (d) Let A,B ∈ℝ^(n×l) and C ∈ℝ^(l×m) be arbitrary matrices. Then,
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: (d) 设A,B ∈ℝ^(n×l) 和 C ∈ℝ^(l×m)是任意矩阵。那么，
- en: '![(A + B)C = AC + BC ](img/file279.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![(A + B)C = AC + BC ](img/file279.png)'
- en: holds. That is, matrix multiplication is right-distributive with respect to
    addition.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这成立。也就是说，矩阵乘法对加法是右分配的。
- en: As the proof is extremely technical and boring, we are going to skip it. However,
    there are a few things to note. Most importantly, matrix multiplication is not
    commutative; that is, AB is not always equal to BA. (It might not even be defined.)
    For instance, consider
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于证明非常技术性且枯燥，我们将跳过它。然而，有几点需要注意。最重要的是，矩阵乘法不是交换的；也就是说，AB不总是等于BA。（它甚至可能没有定义。）例如，考虑
- en: '![ ⌊ ⌋ ⌊ ⌋ ⌈1 1 ⌉ ⌈1 0⌉ A = 1 1 , B = 0 2 . ](img/file280.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ ⌊ ⌋ ⌈1 1 ⌉ ⌈1 0⌉ A = 1 1 , B = 0 2 . ](img/file280.png)'
- en: You can verify by hand that
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动验证
- en: '![ ⌊ ⌋ ⌊ ⌋ ⌈1 2⌉ ⌈1 1⌉ AB = 1 2 , BA = 2 2 , ](img/file281.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ ⌊ ⌋ ⌈1 2⌉ ⌈1 1⌉ AB = 1 2 , BA = 2 2 , ](img/file281.png)'
- en: which are not equal.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不相等。
- en: In line with this, the algebraic identities that we use for scalars are quite
    different. For instance, if A and B are matrices, then
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与此一致，我们用于标量的代数恒等式是完全不同的。例如，如果A和B是矩阵，那么
- en: '![(A + B)(A + B ) = A (A + B) + B (A + B ) = A2 + AB + BA + B2\. ](img/file282.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![(A + B)(A + B ) = A (A + B) + B (A + B ) = A2 + AB + BA + B2\. ](img/file282.png)'
- en: or
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '![(A + B)(A − B ) = A (A − B) + B (A − B ) = A2 − AB + BA − B2\. ](img/file283.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![(A + B)(A − B ) = A (A − B) + B (A − B ) = A2 − AB + BA − B2\. ](img/file283.png)'
- en: Transposition also behaves nicely with respect to addition and multiplication.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 转置操作对于加法和乘法也表现得很好。
- en: Theorem 17\. (Properties of transposition)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 定理17. （转置的性质）
- en: (a) Let A,B ∈ℝ^(n×m) be arbitrary matrices. Then,
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 设A,B ∈ℝ^(n×m)是任意矩阵。那么，
- en: '![(A + B )T = AT + BT ](img/file284.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![(A + B )T = AT + BT ](img/file284.png)'
- en: holds.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这成立。
- en: (b) Let A ∈ℝ^(n×l), B ∈ℝ^(l×m) be arbitrary matrices. Then,
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 设A ∈ℝ^(n×l), B ∈ℝ^(l×m)是任意矩阵。那么，
- en: '![(AB )T = BT AT ](img/file285.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![(AB )T = BT AT ](img/file285.png)'
- en: holds.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这成立。
- en: We are not going to prove this either, but feel free to do so as an exercise.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不打算证明这个，但你可以当做练习来做。
- en: 3.2.2 Matrices as arrays
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 矩阵作为数组
- en: To perform computations with matrices inside a computer, we are looking for
    a data structure that represents a matrix A and supports
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在计算机中执行矩阵运算，我们需要一个能够表示矩阵A并支持以下功能的数据结构：
- en: accessing elements by A[i, j],
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过A[i, j]访问元素，
- en: assigning elements by A[i, j] = value
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过A[i, j] = value进行元素赋值
- en: addition and multiplication with the + and * operators,
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用+和*运算符进行加法和乘法运算，
- en: and works lightning fast. These requirements only specify the interface of our
    matrix data structure, not the actual implementation. An obvious choice would
    be a list of lists, but as discussed when talking about representing vectors in
    computations (Section [1.3](ch007.xhtml#vectors-in-practice)), this is highly
    suboptimal. Can we leverage the C array structure to store a matrix?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 并且运行速度极快。这些要求只指定了我们矩阵数据结构的接口，并没有涉及实际实现。一个显而易见的选择是使用列表的列表，但正如在讨论计算中表示向量时所提到的（第[1.3](ch007.xhtml#vectors-in-practice)节），这种方式非常不理想。我们能否利用C语言的数组结构来存储矩阵？
- en: Yes, and this is precisely what NumPy does, providing a fast and convenient
    representation for matrices in the form of multidimensional arrays. Before learning
    how to use NumPy’s machinery for our purposes, let’s look a bit deeper into the
    heart of the issue.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这正是NumPy所做的，它为矩阵提供了以多维数组形式表示的快速便捷方法。在学习如何使用NumPy的工具之前，让我们深入探讨一下问题的核心。
- en: 'At first glance, there seems to be a problem: a computer’s memory is one-dimensional,
    thus addressed (indexed) by a single key, not two as we want. Thus, we can’t just
    shove a matrix into the memory. The solution is to flatten the matrix and place
    each consecutive row next to each other, like Figure [3.3](#) illustrates in the
    3 × 3 case. This is called row-major ordering.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，似乎有个问题：计算机的内存是单维的，因此是通过单一的键来寻址（索引），而不是我们所需要的两个键。因此，我们不能直接将矩阵塞入内存中。解决方案是将矩阵展平，将每一行依次放在一起，就像图[3.3](#)中在3×3的情况下所示。这叫做行主序排列。
- en: By storing the rows of any n×m matrix in a contiguous array, we get all the
    benefits of the array data structure at the low cost of a simple index transformation
    defined by
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将任何n×m矩阵的行存储在一个连续数组中，我们可以在低成本的简单索引转换下，获得数组数据结构的所有优势，转换方式由以下公式定义：
- en: '![(i,j) ↦→ im + j. ](img/file286.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![(i,j) ↦→ im + j. ](img/file286.png)'
- en: (Note that for programming languages like Fortran or MATLAB that use column-major
    ordering — i.e., the columns are concatenated — this index transformation won’t
    work. I leave figuring out the correct transformation as an exercise to check
    your understanding.)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，对于使用列主序排列的编程语言（如Fortran或MATLAB）——即列是连接起来的——此索引转换将不起作用。我将正确的转换作为一个练习留给你，以检查你对这一部分的理解。）
- en: '![PIC](img/file287.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file287.png)'
- en: 'Figure 3.3: Flattening a matrix'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：展平矩阵
- en: To demonstrate what’s happening, let’s conjure up a prototypical Matrix class
    in Python that uses a single list to store all the values, yet supports accessing
    elements by row and column indices. For the sake of illustration, let’s imagine
    that a Python list is actually a static array. (At least until this presentation
    is over.) This is for educational purposes only, as at the moment, we only want
    to understand the process, not to maximize performance.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示发生了什么，让我们在Python中创建一个典型的Matrix类，它使用一个单一的列表来存储所有值，但支持通过行列索引访问元素。为了便于说明，我们假设Python列表实际上是一个静态数组。（至少在这次演示结束之前是这样。）这仅用于教育目的，因为目前我们只想理解过程，而不是最大化性能。
- en: Take a moment to review the code below. I’ll explain everything line by line.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间查看下面的代码。我会逐行解释。
- en: '[PRE85]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The Matrix object is initialized with the __init__ method. This is called when
    an object is created, like we are about to do now.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵对象通过`__init__`方法初始化。当一个对象被创建时，就会调用该方法，正如我们现在要做的那样。
- en: '[PRE86]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Upon initialization, we supply the dimensions of the matrix in the form of a
    two-dimensional tuple, passed for the shape argument. In our concrete example,
    M is a 3 × 4 matrix, represented by an array of length 12\. For simplicity, our
    simple Matrix is filled up with zeros by default.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化时，我们以二维元组的形式提供矩阵的维度，这个元组被传递给形状参数。在我们的具体示例中，M是一个3×4的矩阵，通过一个长度为12的数组表示。为了简单起见，我们的简单Matrix默认填充为零。
- en: 'Overall, the __init__ method performs three main tasks:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，`__init__`方法执行三个主要任务：
- en: Validates the shape parameter to ensure correctness
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证形状参数以确保正确性
- en: Stores the shape in an instance attribute for future reference
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将形状存储在实例属性中，以便将来参考
- en: Initializes a list of size shape[0] * shape[1], which serves as the primary
    data storage
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个大小为shape[0] * shape[1]的列表，作为主要数据存储。
- en: The second method, suggestively named _linear_idx, is responsible for translating
    between the row-column indices of the matrix and the linear index for our internal
    one-dimensional representation. (In Python, it is customary to prefix methods
    with an underscore if they are not intended to be called externally. Many other
    languages, such as Java, support private methods. Python is not one of them, so
    we have to make do with such polite suggestions instead of strictly enforced rules.)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法，暗示性地命名为_linear_idx，负责在矩阵的行列索引和我们内部一维表示的线性索引之间进行转换。（在Python中，通常用下划线作为前缀表示方法不打算外部调用。许多其他语言，如Java，支持私有方法，而Python不支持，因此我们只能依赖这种礼貌的建议，而不是严格执行的规则。）
- en: 'We can implement item retrieval via indexing by providing the __getitem__ method,
    which expects a two-dimensional integer tuple as the key. For any key = (i, j),
    the method:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过索引提供`__getitem__`方法来实现项目检索，它期望一个二维整数元组作为键。对于任何键 = (i, j)，该方法：
- en: Calculates the linear index using our _linear_idx method.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的_linear_idx方法计算线性索引。
- en: Retrieves the element located at the given linear index from the list.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中检索位于给定线性索引位置的元素。
- en: Item assignment happens similarly, as given by the __setitem__ magic method.
    Let’s try these out to see if they work.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 项目赋值的过程类似，由`__setitem__`魔法方法给出。让我们尝试一下，看看它们是否有效。
- en: '[PRE87]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: By providing a __repr__ method, we specify how a Matrix object is represented
    as a string. So, we can print it out to the standard output in a pretty form.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供`__repr__`方法，我们指定了Matrix对象作为字符串的表示方式。因此，我们可以将其以美观的形式打印到标准输出。
- en: '[PRE89]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Pretty awesome. Now that we understand some of the internals, it is time to
    see how much we can achieve with NumPy.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 相当棒。现在我们了解了一些内部实现，接下来是时候看看我们能用NumPy做些什么了。
- en: 3.2.3 Matrices in NumPy
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 NumPy中的矩阵
- en: As foreshadowed earlier, NumPy provides an excellent out-of-the-box representation
    for matrices in the form of multidimensional arrays. (These are often called tensors,
    but I’ll just stick to the naming array.)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，NumPy为矩阵提供了非常出色的开箱即用表示，采用的是多维数组的形式。（这些通常被称为张量，但我将坚持使用数组这一命名方式。）
- en: 'I have some fantastic news: these are the same np.ndarray objects we have been
    using! We can create one by simply providing a list of lists during initialization.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我有个好消息：这些就是我们一直在使用的np.ndarray对象！我们可以通过在初始化时简单地提供一个列表的列表来创建一个。
- en: '[PRE91]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Everything works the same as we have seen so far. Operations are performed elementwise,
    and you can plug them into functions like np.exp.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都和我们到目前为止看到的一样。操作按元素进行，你可以将它们传递到像np.exp这样的函数中。
- en: '[PRE93]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Since we are working with multidimensional arrays, the transposition operator
    can be defined. Here, this is conveniently implemented as the np.transpose function,
    but can also be accessed at the np.ndarray.T attribute.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在处理多维数组，可以定义转置操作符。在这里，这个操作符方便地实现为np.transpose函数，但也可以通过np.ndarray.T属性进行访问。
- en: '[PRE99]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: As expected, we can get and set elements with the indexing operator []. The
    indexing starts from zero. (Don’t even get me started.)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们可以通过索引操作符[]来获取和设置元素。索引从零开始。（别让我开始讲这个。）
- en: '[PRE103]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Entire rows and columns can be accessed using slicing. Instead of giving the
    exact definitions, I’ll just provide a few examples and let you figure it out
    with your internal pattern matching engine. (That is, your brain.)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用切片访问整行或整列。与其给出精确的定义，我不如提供几个示例，让你通过内部的模式匹配引擎（也就是你的大脑）来弄清楚。
- en: '[PRE105]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: When used as an iterable, a two-dimensional array yields its rows at every step.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为可迭代对象使用时，二维数组每一步都会返回其行。
- en: '[PRE113]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Initializing arrays can be done with the familiar np.zeros, np.ones, and other
    functions.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化数组可以通过熟悉的np.zeros、np.ones和其他函数来完成。
- en: '[PRE115]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: As you have guessed, that shape argument specifies the dimensions of the array.
    We are going to explore this property next. Let’s initialize an example multidimensional
    array with three rows and four columns.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你猜的那样，shape参数指定了数组的维度。接下来我们将探索这个属性。让我们初始化一个具有三行四列的示例多维数组。
- en: '[PRE117]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The shape of an array, stored inside the attribute np.ndarray.shape, is a tuple
    object describing its dimensions. In our example, since we have a 3 × 4 matrix,
    the shape equals (3, 4).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的形状存储在属性np.ndarray.shape中，是一个描述其维度的元组对象。在我们的示例中，既然我们有一个3×4的矩阵，那么形状就是(3, 4)。
- en: '[PRE119]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This innocent-looking attribute determines what kind of operations you can perform
    with your arrays. Let me tell you, as a machine learning engineer, shape mismatches
    will be the bane of your existence. You want to calculate the product of two matrices
    A and B? The second dimension of A must match the first dimension of B. Pointwise
    products? Matching or broadcastable shapes are required. Understanding shapes
    is vital.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似无害的属性决定了你可以对数组执行哪些操作。让我告诉你，作为一名机器学习工程师，形状不匹配将成为你工作的最大障碍。你想计算两个矩阵A和B的乘积吗？A的第二维必须与B的第一维匹配。逐点乘积？需要匹配或可广播的形状。理解形状至关重要。
- en: However, we have just learned that multidimensional arrays are linear arrays
    in disguise. (See Section [3.2.2](ch009.xhtml#matrices-as-arrays).) Because of
    this, we can reshape an array by slicing the linear view differently. For example,
    A can be reshaped into arrays with shapes (12, 1), (6, 2), (4, 3), (3, 4), (2, 6),
    and (1, 12).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们刚刚学到的多维数组其实是线性数组的伪装。（参见第[3.2.2](ch009.xhtml#matrices-as-arrays)节。）因此，我们可以通过不同的切片方式重新排列数组的线性视图。例如，A可以重塑为形状为(12,
    1)、(6, 2)、(4, 3)、(3, 4)、(2, 6)和(1, 12)的数组。
- en: '[PRE121]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The np.ndarray.reshape method returns a newly constructed array object but doesn’t
    change A. In other words, reshaping is not destructive in NumPy.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: np.ndarray.reshape方法返回一个新构建的数组对象，但不会改变A。换句话说，在NumPy中，重塑不会破坏原数组。
- en: '[PRE123]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Reshaping is hard to wrap your head around for the first time. To help you visualize
    the process, Figure [3.4](#) shows precisely what happens in our case.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 初次接触重塑时可能很难理解。为了帮助你更好地可视化这一过程，图[3.4](#)清晰地展示了我们案例中的具体情况。
- en: If you are unaware of the exact dimension along a specific axis, you can get
    away by inputting -1 there during the reshaping. Since the product of dimensions
    is constant, NumPy is smart enough to figure out the missing one for you. This
    trick will get you out of trouble all the time, so it is worth taking note.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道某个特定轴的确切维度，可以在重塑时输入-1。由于维度的乘积是恒定的，NumPy足够聪明，能够为你推算出缺失的维度。这个技巧能帮你经常脱困，因此值得记住。
- en: '[PRE125]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '![PIC](img/file294.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file294.png)'
- en: 'Figure 3.4: Reshaping a one-dimensional array into multiple possible shapes'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：将一维数组重塑为多种可能的形状
- en: We won’t go into the details now, but as you probably guessed, multidimensional
    arrays can have more than two dimensions. The range of permitted shapes for the
    operations will be even more complicated, then. So, building a solid understanding
    now will provide a massive head start in the future.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不讨论细节，但正如你可能猜到的，多维数组可以有多个维度。那么，操作允许的形状范围将会更复杂。因此，现在建立一个扎实的理解，将为将来提供巨大的领先优势。
- en: 3.2.4 Matrix multiplication, revisited
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 矩阵乘法，重新审视
- en: Without a doubt, one of the most important operations regarding matrices is
    multiplication. Computing determinants and eigenvalues? Matrix multiplication.
    Passing data through a fully connected layer? Matrix multiplication. Convolution?
    Matrix multiplication. We will see how these seemingly different things can be
    traced back to matrix multiplication; but first, let’s discuss the operation itself
    from a computational perspective.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，关于矩阵的最重要操作之一就是矩阵乘法。计算行列式和特征值？矩阵乘法。通过全连接层传递数据？矩阵乘法。卷积？矩阵乘法。我们将看到这些看似不同的操作如何追溯到矩阵乘法；但首先，让我们从计算的角度讨论一下这一操作本身。
- en: First, recap the mathematical definition. For any A ∈ℝ^(n×m) and B ∈ℝ^(m×l),
    their product is defined by the formula
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，回顾一下数学定义。对于任意的A ∈ℝ^(n×m)和B ∈ℝ^(m×l)，它们的乘积由以下公式定义：
- en: '![ m ∑ n,l n×l AB = ( ai,kbk,j)i,j=1 ∈ ℝ . k=1 ](img/file295.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![ m ∑ n,l n×l AB = ( ai,kbk,j)i,j=1 ∈ ℝ . k=1 ](img/file295.png)'
- en: Notice that the element in the i-th row and j-th column of AB is the dot product
    of A’s i-th row and B’s j-th column.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，AB中第i行第j列的元素是A的第i行与B的第j列的点积。
- en: We can put this into code using the tools we have learned so far.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用到目前为止学到的工具将其写成代码。
- en: '[PRE129]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Let’s test our function with an example that is easy to verify by hand.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个容易手动验证的例子来测试我们的函数。
- en: '[PRE130]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The result is correct, as we expected.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是正确的，正如我们预期的那样。
- en: Of course, matrix multiplication has its own NumPy function in the form of numpy.matmul.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，矩阵乘法在NumPy中有对应的函数，形式为numpy.matmul。
- en: '[PRE132]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This yields the same result as our custom function. We can test it out by generating
    a bunch of random matrices and checking if the results match.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生的结果与我们的自定义函数相同。我们可以通过生成一堆随机矩阵并检查结果是否匹配来测试它。
- en: '[PRE134]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'According to this small test, our matrix_multiplication function yields the
    same result as NumPy’s built-in one. We are happy, but don’t forget: always use
    your chosen framework’s implementations in practice, whether it be NumPy, TensorFlow,
    or PyTorch.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个简单的测试，我们的 matrix_multiplication 函数与 NumPy 内建函数的结果是一样的。我们很高兴，但别忘了：在实际操作中，始终使用你所选择的框架的实现，无论是
    NumPy、TensorFlow 还是 PyTorch。
- en: Since writing np.matmul is cumbersome when lots of multiplications are present,
    NumPy offers a way to abbreviate using the @ operator.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在存在大量乘法时编写 np.matmul 会显得繁琐，NumPy 提供了一种使用 @ 运算符来简化的方法。
- en: '[PRE136]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 3.2.5 Matrices and data
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.5 矩阵和数据
- en: Now that we are familiar with matrix multiplication, it’s time to make sense
    of them outside of linear algebra. Let’s take a matrix A ∈ℝ^(n×m) and a vector
    x ∈ℝ^m. By treating x as a column vector x ∈ℝ^(m×1), the product of A and x can
    be calculated by
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了矩阵乘法，现在是时候在其他领域理解它们了。假设有一个矩阵 A ∈ℝ^(n×m) 和一个向量 x ∈ℝ^m。通过将 x 视为列向量 x
    ∈ℝ^(m×1)，可以通过以下方式计算 A 和 x 的乘积：
- en: '![ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ a a ... a x ∑m a x | 1,1 1,2 1,m | | 1| | ∑mj=1 1,j j| || a2,1
    a2,2 ... a2,m || || x2|| || j=1a2,jxj|| Ax = || .. .. .. .. || || .. || = || ..
    || . ⌈ . . . . ⌉ ⌈ . ⌉ ⌈ ∑ . ⌉ an,1 an,2 ... an,m. xm mj=1an,jxj ](img/file296.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ a a ... a x ∑m a x | 1,1 1,2 1,m | | 1| | ∑mj=1 1,j j| || a2,1
    a2,2 ... a2,m || || x2|| || j=1a2,jxj|| Ax = || .. .. .. .. || || .. || = || ..
    || . ⌈ . . . . ⌉ ⌈ . ⌉ ⌈ ∑ . ⌉ an,1 an,2 ... an,m. xm mj=1an,jxj ](img/file296.png)'
- en: Mathematically speaking, looking at x as a column vector is perfectly natural.
    Think of it as extending ℝ^m with a dummy dimension, thus obtaining ℝ^(m×1). This
    form also comes naturally by considering that the columns of a matrix are images
    of the basis vectors by their very definition.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度来看，将 x 视为列向量是完全自然的。可以将其看作是通过引入一个虚拟维度来扩展 ℝ^m，从而得到 ℝ^(m×1)。这个形式也可以通过考虑矩阵的列是基向量的像来理解。
- en: 'In practice, things are not as simple as they look. Implicitly, we have made
    a choice here: to represent datasets as a horizontal stack of column vectors.
    To elaborate further, let’s consider two data points with four features and a
    matrix that maps these into a three-dimensional feature space. That is, let x[1],x[2]
    ∈ℝ⁴ and A ∈ℝ^(3×4).'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，事情并不像看起来那么简单。隐含地，我们在这里做出了一个选择：将数据集表示为列向量的水平堆叠。为了进一步阐述，让我们考虑两个具有四个特征的数据点，以及一个将它们映射到三维特征空间的矩阵。也就是说，假设
    x[1], x[2] ∈ℝ⁴ 和 A ∈ℝ^(3×4)。
- en: '[PRE138]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: (I specifically selected these numbers so that the calculations would be easily
    verifiable by hand.) To be sure, we double-check the shapes.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: （我特意选择了这些数字，以便通过手工计算轻松验证结果。）为了确保准确无误，我们再次检查了形状。
- en: '[PRE139]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: What happens when we call the np.matmul function?
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 np.matmul 函数时，会发生什么？
- en: '[PRE143]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The result is correct. However, when we have a bunch of input data points, we
    prefer to calculate the images using a single operation. This way, we can take
    advantage of vectorized code, locality of reference, and all the juicy computational
    magic we have seen so far.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是正确的。然而，当我们有一堆输入数据点时，我们更倾向于通过一次操作计算这些数据点的映像。这样，我们就可以利用向量化代码、引用局部性以及到目前为止我们所看到的所有计算魔法。
- en: We can achieve this by horizontally stacking the column vectors, each one representing
    a data point. Mathematically speaking, we want to perform the calculation in code.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过水平堆叠列向量来实现这一点，每个列向量表示一个数据点。从数学上讲，我们希望在代码中执行该计算。
- en: '![ ⌊ ⌋ ⌊0 1 2 3⌋ | 2 − 1| ⌊ 0 1⌋ | | || 0 1 || | | |⌈4 5 6 7|⌉ | | = |⌈ 8 1|⌉
    |⌈ 0 0 |⌉ 8 9 10 11 0 0 16 1 ](img/file297.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ ⌊0 1 2 3⌋ | 2 − 1| ⌊ 0 1⌋ | | || 0 1 || | | |⌈4 5 6 7|⌉ | | = |⌈ 8 1|⌉
    |⌈ 0 0 |⌉ 8 9 10 11 0 0 16 1 ](img/file297.png)'
- en: Upon looking up the NumPy documentation, we quickly find that the np.hstack
    function might be the tool for the job, at least according to its official documentation
    ( [https://numpy.org/doc/stable/reference/generated/numpy.hstack.html](https://numpy.org/doc/stable/reference/generated/numpy.hstack.html)).
    Yay!
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅 NumPy 文档后，我们很快发现 np.hstack 函数可能是解决问题的工具，至少根据它的官方文档（[https://numpy.org/doc/stable/reference/generated/numpy.hstack.html](https://numpy.org/doc/stable/reference/generated/numpy.hstack.html)）来看是这样。耶！
- en: '[PRE145]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Not yay. What happened? np.hstack treats one-dimensional arrays differently,
    and even though the math works out perfectly by creatively abusing the notation,
    we don’t get away that easily in the trenches of real-life computations. Thus,
    we have to reshape our inputs manually. Meet the true skill gap between junior
    and senior machine learning engineers: correctly shaping multidimensional arrays.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 不太高兴。发生了什么？np.hstack 对一维数组的处理方式不同，尽管通过巧妙地滥用符号，数学计算结果是正确的，但在实际的计算过程中，我们不能这么轻松地逃避。因此，我们必须手动调整输入数据的形状。让我们认识到初级与高级机器学习工程师之间的真正技能差距：正确地调整多维数组的形状。
- en: '[PRE147]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Let’s try this one more time.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一次。
- en: '[PRE149]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Yay! (For real this time.)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！(这次是真的。)
- en: 'Note that we made an extremely impactful choice in this chapter: representing
    individual data points as column vectors. I have written this in bold to emphasize
    its importance.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这一章中我们做出了一个极为重要的选择：将单个数据点表示为列向量。我用粗体字写出这一点，以强调其重要性。
- en: Why? Because we could have gone the other way and treated samples as row vectors.
    With our current choice, we ended up with a multidimensional array of shape
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为我们本可以选择另一种方式，将样本视为行向量。选择当前的方式后，我们得到了形状为
- en: '![number of dimensions× number of samples, ](img/file298.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![维度数 × 样本数，](img/file298.png)'
- en: as opposed to
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相对的是
- en: '![number of samples × number of dimensions. ](img/file299.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![样本数 × 维度数。](img/file299.png)'
- en: The former is called batch-last, while the latter is called batch-first format.
    Popular frameworks like TensorFlow and PyTorch use batch-first, but we are going
    with batch-last. The reasons go back to the very definition of matrices, where
    columns are the images of basis vectors under the given linear transformation.
    This way, we can write multiplication from left to right, like Ax and AB.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 前者称为批次最后（batch-last），而后者称为批次优先（batch-first）格式。像 TensorFlow 和 PyTorch 这样的流行框架使用批次优先，但我们选择了批次最后。之所以如此，是因为这与矩阵的定义密切相关，其中列是给定线性变换下基向量的像。这样，我们可以像从左到右书写乘法一样写出
    Ax 和 AB。
- en: Should we define matrices as rows of basis vector images, everything turns upside
    down. This way, if f and g are linear transformations with “matrices” A and B,
    the “matrix” of the composed transformation f ∘g would be BA. This makes the math
    complicated and ugly.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将矩阵定义为基向量像的行，所有事情都会颠倒过来。这样，如果 f 和 g 是具有“矩阵”A 和 B 的线性变换，那么组合变换 f ∘ g 的“矩阵”将是
    BA。这使得数学变得复杂且不美观。
- en: On the other hand, batch-first makes the data easier to store and read. Think
    about a situation when you have thousands of data points in a single CSV file.
    Due to how input-output is implemented, files are read line by line, so it is
    natural and convenient to have a single line correspond to a single sample.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，批次优先使得数据存储和读取更加方便。想象一下，当你有成千上万的数据点在一个 CSV 文件中时，文件的读取是逐行进行的，因此将每一行与一个样本对应是自然且便捷的。
- en: There are no good choices here; there are sacrifices either way. Since the math
    works out much easier for batch-last, we will use that format. However, in practice,
    you’ll find that batch-first is more common. With this textbook, I don’t intend
    to give you just a manual. My goal is to help you understand the internals of
    machine learning. If I succeed, you’ll be able to apply your knowledge to translate
    between batch-first and batch-last seamlessly.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有绝对的好选择，任何选择都有其牺牲。由于批次最后的数学运算更为简便，我们将使用这种格式。然而，在实践中，你会发现批次优先更为常见。通过这本教科书，我并不打算仅仅给你一本手册。我的目标是帮助你理解机器学习的内部原理。如果我成功了，你将能够毫不费力地在批次优先和批次最后之间进行转换。
- en: 3.3 Summary
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 小结
- en: 'In this chapter, we finally dug into the trenches of practice instead of merely
    looking out from the towers of theory. Previously, we saw that NumPy arrays are
    the ideal tools for numeric computations, especially linear algebra. Now, we use
    them to provide fast and elegant implementations of what we learned in the previous
    chapter: norms, distances, dot products, and the Gram-Schmidt process.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们终于深入实践，而不只是从理论的高塔中展望。之前，我们看到 NumPy 数组是进行数值计算，尤其是线性代数的理想工具。现在，我们用它们来快速且优雅地实现我们在上一章中学到的内容：范数、距离、点积和
    Gram-Schmidt 过程。
- en: Besides vectors, we also finally introduced matrices, one of the most important
    tools of machine learning. This time, we introduced, in a practical manner, viewing
    matrices as a table of numbers. Matrices can be transposed and added together,
    and unlike vectors, they can be multiplied with each other as well.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 除了向量，我们最终还介绍了矩阵，这是机器学习中最重要的工具之一。这一次，我们以一种实际的方式来理解矩阵，将其视为一个数字表格。矩阵可以进行转置和加法运算，不同于向量，矩阵还可以相互相乘。
- en: Speaking of our “from scratch” approach, before looking into how to actually
    work with matrices in practice, we created our very own Matrix implementation
    in vanilla Python. Closing the chapter, we dealt with the fundamentals and best
    practices of two-dimensional NumPy arrays, the prime matrix representation that
    Python can offer.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 说到我们的“从头开始”的方法，在实际研究如何使用矩阵之前，我们用原生 Python 创建了我们自己的矩阵实现。结束这一章时，我们处理了二维 NumPy
    数组的基本概念和最佳实践，这是 Python 能提供的最重要的矩阵表示。
- en: 'In the next chapter, we’ll once more take a theoretical approach. This is how
    we do it in this book: looking at both aspects at once, supercharging our understanding
    of mathematics (and machine learning, along the way). We’ll see that matrices
    are not just plain tables of numbers; they are data transformations as well. This
    property is beautiful beyond words: data and their transformations are represented
    by the same object.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将再次采取理论方法。这就是我们本书的做法：同时查看两个方面，从而提升我们对数学（以及沿途的机器学习）的理解。我们将看到矩阵不仅仅是普通的数字表格；它们也是数据变换。这一特性美得无法用言语形容：数据及其变换由同一个对象表示。
- en: Let’s get to it!
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 3.4 Problems
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 问题
- en: Problem 1\. Implement the mean squared error
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 1\. 实现均方误差
- en: '![ ∑n MSE (x,y) = 1- (xi − yi)2, x, y ∈ ℝn n i=1 ](img/file300.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n MSE (x,y) = 1- (xi − yi)², x, y ∈ ℝⁿ, n i=1 ](img/file300.png)'
- en: both with and without using NumPy functions and methods. (The vectors x and
    y should be represented by NumPy arrays in both cases.)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否使用 NumPy 函数和方法，均需实现。 （向量 x 和 y 应该在这两种情况下都由 NumPy 数组表示。）
- en: Problem 2\. Compare the performances of the built-in maximum function max and
    NumPy’s np.max using timeit.timeit, like we did above. Try running a different
    number of experiments and changing the array sizes to figure out the breakeven
    point between the two performances.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 2\. 使用 `timeit.timeit` 比较内置的最大值函数 `max` 和 NumPy 的 `np.max` 的性能，就像我们上面做的那样。尝试运行不同数量的实验，并改变数组大小，以找出两者性能的平衡点。
- en: Problem 3\. Instead of implementing the general p-norm as we did earlier in
    this chapter in Section [3.1.1](ch009.xhtml#norms-distances-and-dot-products)
    , we can change things around to obtain the version below.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 3\. 不像我们在本章第 [3.1.1](ch009.xhtml#norms-distances-and-dot-products) 节中实现一般的
    p 范数，我们可以改变方法，得到下面的版本。
- en: '[PRE151]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: However, this doesn’t work for p = ∞. What is the problem with it?
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这在 \( p = \infty \) 时不起作用。它的问题是什么？
- en: Problem 4\. Let w ∈ℝ^n be a vector with nonnegative elements. Use NumPy to implement
    the weighted p-norm by
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 4\. 设 \( w \in \mathbb{R}^n \) 是一个包含非负元素的向量。使用 NumPy 实现加权 p 范数，公式为
- en: '![ ∑n ∥x∥wp = ( wi|xi|p)1∕p, x = (x1,...,xn) ∈ ℝn. i=1 ](img/file301.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n ∥x∥wp = ( wi|xi|p)¹/p, x = (x1,...,xn) ∈ ℝn. i=1 ](img/file301.png)'
- en: Can you come up with a scenario where this can be useful in machine learning?
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想出一个机器学习中可能用到这个的场景吗？
- en: Problem 5\. Implement the cosine similarity function, defined by the formula
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 5\. 实现余弦相似度函数，定义公式为
- en: '![cos(x,y ) = ⟨-x-,-y--⟩, x, y ∈ ℝn. ∥x ∥ ∥y∥ ](img/file302.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![cos(x,y ) = ⟨-x-,-y--⟩, x, y ∈ ℝn. ∥x ∥ ∥y∥ ](img/file302.png)'
- en: (Whenever possible, use built-in NumPy functions.)
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: （尽可能使用内置的 NumPy 函数。）
- en: Problem 6\. Calculate the product of the following matrices.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 6\. 计算以下矩阵的乘积。
- en: (a)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: (a)
- en: '![ ⌊ ⌋ ⌊ ⌋ − 1 2 | 6 − 2| A = ⌈ ⌉, B = | 2 − 6|. 1 5 ⌈ ⌉ − 3 2 ](img/file303.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ ⌊ ⌋ − 1 2 | 6 − 2| A = ⌈ ⌉, B = | 2 − 6|. 1 5 ⌈ ⌉ − 3 2 ](img/file303.png)'
- en: (b)
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: (b)
- en: '![ ⌊ ⌋ ⌊ ⌋ 1 2 3 7 8 A = ⌈ ⌉ , B = ⌈ ⌉ . 4 5 6 9 10 ](img/file304.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ ⌊ ⌋ 1 2 3 7 8 A = ⌈ ⌉ , B = ⌈ ⌉ . 4 5 6 9 10 ](img/file304.png)'
- en: Problem 7\. The famous Fibonacci numbers are defined by the recursive sequence
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 7\. 著名的斐波那契数列由递归序列定义
- en: F[0]= 0,
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: F[0]= 0，
- en: F[1]=1,
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: F[1]=1，
- en: F[n]= F[n−1] + F[n−2]
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: F[n]= F[n−1] + F[n−2]
- en: (a) Write a recursive function that computes the n-th Fibonacci number. (Expect
    it to be really slow.)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 编写一个递归函数，计算第 n 个斐波那契数。 （预期它会非常慢。）
- en: (b) Show that
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 展示
- en: '![⌊ ⌋n ⌊ ⌋ ⌈1 1⌉ = ⌈Fn+1 Fn ⌉ , 1 0 Fn Fn− 1 ](img/file305.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![⌊ ⌋n ⌊ ⌋ ⌈1 1⌉ = ⌈Fn+1 Fn ⌉ , 1 0 Fn Fn− 1 ](img/file305.png)'
- en: and use this identity to write a non-recursive function that computes the n-th
    Fibonacci number.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用此恒等式编写一个非递归函数，计算第 n 个斐波那契数。
- en: Use Python’s built-in timeit function to measure the execution of both functions.
    Which one is faster?
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 内置的 `timeit` 函数测量两种函数的执行时间。哪个更快？
- en: Problem 8\. Let A,B ∈ℝ^(n×m) be two matrices. Their Hadamard product is defined
    by
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 8\. 设 \( A,B \in \mathbb{R}^{n \times m} \) 为两个矩阵。它们的 Hadamard 积定义为
- en: '![ ⌊ ⌋ | a1,1b1,1 a1,2b1,2 ... a1,nb1,n| | a2,1b2,1 a2,2b2,2 ... a2,nb2,n|
    || . . . . || A ⊙ B = || .. .. .. .. || . || || ⌈ an,1bn,1 an,2bn,2 ... an,nbn,n⌉
    ](img/file306.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ | a1,1b1,1 a1,2b1,2 ... a1,nb1,n| | a2,1b2,1 a2,2b2,2 ... a2,nb2,n|
    || . . . . || A ⊙ B = || .. .. .. .. || . || || ⌈ an,1bn,1 an,2bn,2 ... an,nbn,n⌉
    ](img/file306.png)'
- en: 'Implement a function that takes two identically shaped NumPy arrays, then performs
    the Hadamard product on them. (There are two ways to do this: with for loops and
    with NumPy operations. It is instructive to implement both.)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个函数，接收两个形状相同的 NumPy 数组，然后对它们执行 Hadamard 乘积。（有两种方法可以实现这一点：使用 for 循环和使用 NumPy
    操作。实现这两种方法都很有启发性。）
- en: Problem 9\. Let A ∈ℝ^(n×n) be a square matrix. Functions of the form
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 9\. 设 A ∈ℝ^(n×n) 为一个方阵。形式如下的函数
- en: '![B(x,y ) = xT Ay, x,y ∈ ℝn ](img/file307.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![B(x,y ) = xT Ay, x,y ∈ ℝn ](img/file307.png)'
- en: are called bilinear forms. Implement a function that takes two vectors and a
    matrix (all represented by NumPy arrays), then calculates the corresponding bilinear
    form.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这称为双线性形式。实现一个函数，接收两个向量和一个矩阵（都由 NumPy 数组表示），然后计算对应的双线性形式。
- en: Join our community on Discord
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、机器学习专家以及作者本人一起阅读本书。提问、为其他读者提供解决方案、通过“问我任何问题”环节与作者聊天，等等。扫描二维码或访问链接加入社区。
    [https://packt.link/math](https://packt.link/math)
- en: '![PIC](img/file1.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
