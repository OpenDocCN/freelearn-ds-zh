- en: Testing
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 测试
- en: In this chapter, we'll focus on two aspects of testing for scientific programming.
    The first aspect is the often difficult topic of *what to test* in scientific
    computing. The second aspect covers the question of *how to test*. We will distinguish
    between manual and automated testing. Manual testing is what is done by every
    programmer to quickly check that a program is doing what it should or should not.
    Automated testing is the refined, automated variant of that idea. We will introduce
    some tools available for automatic testing in general, with a view of the particular
    case of scientific computing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点讨论科学编程中的两个方面的测试。第一个方面是科学计算中经常遇到的*测试什么*的问题。第二个方面涉及*如何测试*的问题。我们将区分手动测试和自动化测试。手动测试是每个程序员用来快速检查程序是否按预期工作的方式。自动化测试则是这一概念的精细化和自动化版本。我们将介绍一些适用于自动化测试的工具，并特别关注科学计算中的应用。
- en: 15.1 Manual testing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.1 手动测试
- en: 'During code development, you do a lot of small tests in order to test its functionality.
    This could be called manual testing. Typically, you would test if a given function
    does what it is supposed to do, by manually testing the function in an interactive
    environment. For instance, suppose that you implement the bisection algorithm.
    It is an algorithm that finds a zero (root) of a scalar non-linear function. To
    start the algorithm, an interval has to be given with the property that the function
    takes different signs on the interval boundaries (see Exercise 4 in [Section 7.10](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml):
    Exercises, for more information).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码开发过程中，你会做很多小的测试，以测试其功能。这可以称为手动测试。通常，你会通过在交互式环境中手动测试函数，来验证给定的函数是否做了它应该做的事。例如，假设你实现了二分法算法。它是一个找到标量非线性函数零点（根）的方法。为了启动该算法，必须给定一个区间，且该区间的边界上的函数值具有不同符号（详情见[第7.10节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)：习题，了解更多信息）。
- en: 'You will then test an implementation of that algorithm, typically by checking
    that:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将测试该算法的实现，通常是通过检查：
- en: A solution is found when the function has opposite signs at the interval boundaries.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当函数在区间边界处具有不同符号时，问题就得到了解决。
- en: An exception is raised when the function has the same sign at the interval boundaries.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当函数在区间边界处具有相同符号时，是否抛出异常。
- en: Manual testing, as necessary as it may seem to be, is unsatisfactory. Once you
    have convinced yourself that the code does what it is supposed to do, you formulate
    a relatively small number of demonstration examples to convince others of the
    quality of the code. At that stage, you often lose interest in the tests made
    during development, and they are forgotten or even deleted. As soon as you change
    a detail and things no longer work correctly, you might regret that your earlier
    tests are no longer available.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试，尽管它看起来是必要的，但并不令人满意。一旦你确信代码做了它应该做的事，你会编写相对较少的示范示例来说服他人代码的质量。在那个阶段，你通常会对开发过程中进行的测试失去兴趣，它们可能会被遗忘或甚至删除。每当你更改了某个细节，导致事情不再正常工作时，你可能会后悔之前的测试已经不再可用。
- en: 15.2 Automatic testing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.2 自动化测试
- en: 'The correct way to develop any piece of code is to use automatic testing. The
    advantages are:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 开发任何代码的正确方法是使用自动化测试。其优势在于：
- en: The automated repetition of a large number of tests after every code refactoring and
    before any new versions are launched.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次代码重构后，以及在发布任何新版本之前，自动化地重复大量测试。
- en: Silent documentation of the use of the code.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对代码使用的静默文档记录。
- en: 'Documentation of the test coverage of your code: Did things work before a change
    or was a certain aspect never tested?'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录代码的测试覆盖率：在更改之前，事情是否正常工作？某个特定方面是否从未经过测试？
- en: Changes in the program and in particular in its structure that do not affect
    its functionality are called code refactoring.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的变化，特别是其结构上的变化，但不影响其功能，称为代码重构。
- en: We suggest developing tests in parallel to coding. Good design of tests is an
    art of its own and there is rarely an investment that guarantees such a good pay-off
    in development time savings as the investment in good tests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议在编码的同时开发测试。良好的测试设计本身就是一门艺术，而且很少有投资能像投资于良好测试那样，保证在开发时间节省方面获得如此好的回报。
- en: Now we will go through the implementation of a simple algorithm with the automated
    testing methods in mind.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过考虑自动化测试方法来实现一个简单的算法。
- en: 15.2.1 Testing the bisection algorithm
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.1 测试二分法算法
- en: 'Let''s examine automated testing for the bisection algorithm. With this algorithm,
    a zero of a real-valued function is found. It is described in *Exercise 4* in [Section
    7.10](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Exercises*. An implementation
    of the algorithm can have the following form:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来研究一下二分法算法的自动化测试。通过该算法，可以找到一个实值函数的零点。它在[第7.10节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)的*练习4*中有所描述：*练习*。该算法的实现可以具有以下形式：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We assume this to be stored in a file named `bisection.py`. As the first test
    case, we test that the zero of the function ![](img/73d8d9ce-c997-4f58-b10d-293373566190.png) is
    found:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设该内容存储在名为`bisection.py`的文件中。作为第一个测试用例，我们测试该函数的零点是否能够找到！[](img/73d8d9ce-c997-4f58-b10d-293373566190.png)。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code, you meet the Python keyword `assert` for the first time. It raises
    the exception `AssertionError` if its first argument returns the value `False`.
    Its optional second argument is a string with additional information. We use the
    function `allclose` in order to test for equality of floats.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，您第一次接触到Python关键字`assert`。如果它的第一个参数返回`False`，它将引发`AssertionError`异常。它的可选第二个参数是一个包含附加信息的字符串。我们使用`allclose`函数来测试浮点数的相等性。
- en: Let's comment on some of the features of the test function. We use an assertion
    to make sure that an exception will be raised if the code does not behave as expected.
    We have to manually run the test in the line `test_identity()`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对测试函数的某些特性进行评论。我们使用断言来确保如果代码没有按预期行为执行，异常将被抛出。我们必须手动运行测试，在`test_identity()`这一行中。
- en: 'There are many tools to automate this kind of call; we will see one of those
    in [Section 15.2.2](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml): *Using the unittest
    module*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以自动化这种调用；我们将在[第15.2.2节](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml)中看到其中的一种：*使用unittest模块*。
- en: 'Let''s now set up a second test that checks if `bisect` raises an exception
    when the function has the same sign on both ends of the interval. For now, we
    will suppose that the exception raised is `ValueError`. In the following example,
    we will check the initial interval ![](img/94594833-3513-47cc-922c-b6e7d33b41bb.png).
    For the bisection algorithm, it should fulfill the sign condition:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们设置第二个测试，检查当函数在区间两端具有相同符号时，`bisect`是否会抛出异常。现在，我们假设抛出的异常是`ValueError`。在以下示例中，我们将检查初始区间！[](img/94594833-3513-47cc-922c-b6e7d33b41bb.png)。对于二分法算法，它应该满足符号条件：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, an `AssertionError` is raised if the exception is not of the type `ValueError`.
    There are tools to simplify the preceding construction to check that an exception
    is raised.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果抛出的异常不是`ValueError`类型，将引发`AssertionError`。有一些工具可以简化之前的构造，以检查是否抛出了异常。
- en: Another useful test is the edge case test. Here we test arguments or user input,
    which are likely to create mathematically undefined situations or states of the
    program not foreseen by the programmer. For instance, what happens if both bounds
    are equal? What happens if ![](img/d002cedc-dd50-438b-ba03-6b7658b83e07.png) ?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的测试是边界情况测试。在这里，我们测试可能会产生数学上未定义的情况或程序员未预见的程序状态的参数或用户输入。例如，如果两个边界相等，会发生什么？如果！[](img/d002cedc-dd50-438b-ba03-6b7658b83e07.png)，会发生什么？
- en: 'The following code is an example for such an edge test:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是此类边界测试的示例：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A test checks that the program unit does what is demanded by its specification.
    In the preceding example, we assumed that the specifications state that in the
    case ![](img/093d5afe-63f2-4229-ab93-0aa2be3c9dae.png) the two values should tacitly
    be interchanged. And that is what was tested. An alternative way would be to specify
    that this situation would be considered as wrong input, which the user has to
    correct. There, we would have tested for an appropriate exception, for example,
    `ValueError`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 测试检查程序单元是否符合其规范的要求。在前面的例子中，我们假设规范要求在情况下！[](img/093d5afe-63f2-4229-ab93-0aa2be3c9dae.png)，这两个值应该默默地交换。并且这就是我们测试的内容。另一种方式是指定这种情况被视为错误输入，用户必须进行修正。在这种情况下，我们将测试是否抛出了适当的异常，例如`ValueError`。
- en: 15.2.2 Using the unittest module
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.2 使用unittest模块
- en: The Python module `unittest` greatly facilitates automated testing. This module
    requires that we rewrite our previous tests to be compatible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python模块`unittest`大大简化了自动化测试。该模块要求我们重写之前的测试以保持兼容性。
- en: 'The first test would have to be rewritten in a `class`, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试需要重写成一个`class`，如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s examine the differences from the previous implementation. First, the
    test is now a method and a part of a class. The class must inherit from `unittest.TestCase`.
    The test method''s name must start with `test`. Note that we may now use one of
    the assertion tools of the `unittest` package, namely `assertAlmostEqual`. Finally,
    the tests are run using `unittest.main`. We recommend writing the tests in a file
    separate from the code to be tested. That is why it starts with an `import`. The
    test passes and returns as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看与之前实现的区别。首先，测试现在是一个方法，并且是类的一部分。类必须继承自 `unittest.TestCase`。测试方法的名称必须以 `test`
    开头。请注意，我们现在可以使用 `unittest` 包中的一个断言工具，即 `assertAlmostEqual`。最后，使用 `unittest.main`
    运行测试。我们建议将测试写在与要测试的代码分开的文件中。因此，它以 `import` 开头。测试通过并返回如下：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we run it with a loose tolerance parameter, for example, `1.e-3`, a failure
    of the test will be reported:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一个宽松的容差参数，例如 `1.e-3`，测试失败时将会报告：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Tests can and should be grouped together as methods of a test class, as given
    in the following example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以并且应该作为测试类的方法进行分组，如下例所示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, in the last test we used the method `unittest.TestCase.assertRaises`.
    It tests whether an exception is correctly raised. Its first parameter is the
    exception type, for example, `ValueError`, `Exception`, and its second argument
    is the name of the function, which is expected to raise the exception. The remaining
    arguments are the arguments for this function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在最后一个测试中我们使用了 `unittest.TestCase.assertRaises` 方法。它测试是否正确引发了异常。它的第一个参数是异常类型，例如
    `ValueError`、`Exception`，第二个参数是预期引发异常的函数的名称。其余的参数是该函数的参数。
- en: The command `unittest.main()` creates an instance of the class `TestIdentity` and
    executes those methods starting with `test`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `unittest.main()` 创建了一个 `TestIdentity` 类的实例，并执行那些以 `test` 开头的方法。
- en: 15.2.3 Test setUp and tearDown methods
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.3 测试的 setUp 和 tearDown 方法
- en: 'The class `unittest.TestCase` provides two special methods, `setUp` and `tearDown`,
    which run before and after every call to a test method. This is needed when testing
    generators, which are exhausted after every test. We demonstrate this by testing
    a program that checks the line in a file in which a given string occurs for the
    first time:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.TestCase` 类提供了两个特殊方法：`setUp` 和 `tearDown`，它们在每次调用测试方法之前和之后执行。这在测试生成器时很有用，因为生成器在每次测试后会被消耗完。我们通过测试一个程序来演示这一点，该程序检查文件中给定字符串首次出现的行：'
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We assume that this code is saved in a file named `find_in_file.py`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设这段代码保存在名为 `find_in_file.py` 的文件中。
- en: 'A test has to prepare a file and open it and remove it after the test as given
    in the following example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试必须准备一个文件，打开并在测试后删除，如下例所示：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before each test `setUp` is run and after each test `tearDown` is executed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试之前执行 `setUp`，在每个测试之后执行 `tearDown`。
- en: Setting up testdata when a test case is created
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在创建测试用例时设置测试数据
- en: The methods `setUp` and `tearDown` are executed before and after any test method
    of a test case. This is necessary when the test methods change the data. They
    guarantee that the test data is restored before the next test is executed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `setUp` 和 `tearDown` 在每个测试方法的前后执行。这在测试方法会改变数据时是必需的。它们保证在执行下一个测试之前，测试数据能够恢复到原始状态。
- en: However, there is also often a situation where your tests do not change the
    test data and you want to save time by only once setting up the data. This is
    done by the class method `setUpClass`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也经常会有一种情况，测试不改变测试数据，你希望通过仅一次设置数据来节省时间。这可以通过类方法 `setUpClass` 来完成。
- en: 'The following code block schematically illustrates how the method `setUpClass`
    is used. You might also want to check [Section 8.4](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Class attributes and class methods* again.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块简要说明了 `setUpClass` 方法的使用。你也许想再次查看 [第 8.4 节](1654fae9-6203-4871-8352-e436445fa49a.xhtml)：*类属性和类方法*。
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 15.2.4 Parameterizing tests
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.4 测试参数化
- en: We frequently want to repeat the same test with different datasets. When using
    the functionalities of `unittest`, this requires us to automatically generate
    test cases with the corresponding methods injected.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常希望用不同的数据集重复相同的测试。当使用 `unittest` 功能时，这要求我们自动生成带有相应方法注入的测试用例。
- en: To this end, we first construct a test case with one or several methods that
    will be used, when we later set up test methods. We'll consider the bisection
    method again and let's check if the values it returns are really zeros of the
    given function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们首先构建一个测试用例，其中包含一个或多个将在后续设置测试方法时使用的方法。我们将再次考虑二分法，并检查它返回的值是否真的是给定函数的零点。
- en: 'We first build the test case and the method that we will use for the tests
    as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构建测试用例和将用于测试的方法，如下所示：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we dynamically create test functions as attributes of this class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们动态创建测试函数作为该类的属性：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the data is provided as a list of dictionaries. The function
    `make_test_function` dynamically generates a test function, which uses a particular
    data dictionary to perform the test with the previously defined method `checkifzero`.
    Finally, the command `setattr` is used to make these test functions methods of
    the class `Tests`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，数据以字典列表的形式提供。函数`make_test_function`动态生成一个测试函数，使用特定的数据字典与之前定义的`checkifzero`方法进行测试。最后，使用命令`setattr`将这些测试函数作为`Tests`类的方法。
- en: 15.2.5 Assertion tools
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.5 断言工具
- en: 'In this section, we collect the most important tools for raising an `AssertionError`.
    We saw the command `assert` and three tools from `unittest`, namely `assertAlmostEqual`,
    `assertEqual`, and `assertRaises`. The following table (Table 15.1) summarizes
    the most important assertion tools and the related modules:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们收集了用于引发`AssertionError`的最重要工具。我们看到了命令`assert`和`unittest`中的三个工具，分别是`assertAlmostEqual`、`assertEqual`和`assertRaises`。以下表格（表15.1）总结了最重要的断言工具及相关模块：
- en: '| **Assertion tool and application example** | **Module** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **断言工具和应用示例** | **模块** |'
- en: '| `assert 5==5` | – |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `assert 5 == 5` | – |'
- en: '| `assertEqual(5.27, 5.27)` | `unittest.TestCase` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `assertEqual(5.27, 5.27)` | `unittest.TestCase` |'
- en: '| `assertAlmostEqual(5.24, 5.2,places = 1)` |  `unittest.TestCase` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `assertAlmostEqual(5.24, 5.2, places = 1)` | `unittest.TestCase` |'
- en: '| `assertTrue(5 > 2)` | `unittest.TestCase` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `assertTrue(5 > 2)` | `unittest.TestCase` |'
- en: '| `assertFalse(2 < 5)` | `unittest.TestCase` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `assertFalse(2 < 5)` | `unittest.TestCase` |'
- en: '| `assertRaises(ZeroDivisionError,lambda x: 1/x,0.)` | `unittest.TestCase`
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `assertRaises(ZeroDivisionError, lambda x: 1/x, 0.)` | `unittest.TestCase`
    |'
- en: '| `assertIn(3,{3,4})` | `unittest.TestCase` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `assertIn(3, {3, 4})` | `unittest.TestCase` |'
- en: '| `assert_array_equal(A,B)` | `numpy.testing` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `assert_array_equal(A, B)` | `numpy.testing` |'
- en: '| `assert_array_almost_equal(A, B, decimal=5)` | `numpy.testing` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `assert_array_almost_equal(A, B, decimal=5)` | `numpy.testing` |'
- en: '| `assert_allclose(A, B, rtol=1.e-3,atol=1.e-5)` | `numpy.testing` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `assert_allclose(A, B, rtol=1.e-3, atol=1.e-5)` | `numpy.testing` |'
- en: 'Table 15.1: Assertion tools in Python, unittest, and NumPy'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.1：Python、unittest和NumPy中的断言工具
- en: 15.2.6 Float comparisons
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.6 浮点数比较
- en: Two floating-point numbers should not be compared with the `==` comparison,
    because the result of a computation is often slightly off due to rounding errors.
    There are numerous tools to test the equality of floats for testing purposes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 两个浮点数不应使用`==`运算符进行比较，因为计算结果通常由于舍入误差略有偏差。为测试目的，存在许多用于测试浮点数相等性的工具。
- en: 'First, `allclose` checks that two arrays are almost equal. It can be used in
    a test function, as shown:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`allclose`检查两个数组是否几乎相等。它可以在测试函数中使用，如下所示：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, `self` refers to a `unittest.Testcase` instance. There are also testing
    tools in the `numpy` package `testing`. These are imported by using:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`self`指的是一个`unittest.Testcase`实例。`numpy`包中的`testing`模块也有测试工具。可以通过以下方式导入：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Testing that two scalars or two arrays are equal is done using `numpy.testing.assert_array_allmost_equal`
    or `numpy.testing.assert_allclose`. These methods differ in the way they describe
    the required accuracy, as shown in the preceding table, *Table 15.1.*
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 测试两个标量或两个数组是否相等，可以使用`numpy.testing.assert_array_allmost_equal`或`numpy.testing.assert_allclose`。这两种方法在描述所需精度的方式上有所不同，如上表*表15.1*所示。
- en: '![](img/561e22e7-9410-4f8e-98c0-5f5472a83c2e.png) factorization decomposes
    a given matrix into a product of an orthogonal matrix ![](img/3ec22240-f164-4c4c-91e2-08c4baac3ee3.png) and
    an upper triangular matrix ![](img/79db8e65-2824-4d59-8a3a-731f50166e27.png) as
    given in the following example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/561e22e7-9410-4f8e-98c0-5f5472a83c2e.png)因式分解将给定矩阵分解为一个正交矩阵![](img/3ec22240-f164-4c4c-91e2-08c4baac3ee3.png)和一个上三角矩阵![](img/79db8e65-2824-4d59-8a3a-731f50166e27.png)，如下所示的例子所示：'
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Is the method applied correctly? We can check this by verifying that ![](img/daa3b63f-d531-4c68-af13-88bd2340ad86.png) is
    indeed an orthogonal matrix:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 方法应用是否正确？我们可以通过验证![](img/daa3b63f-d531-4c68-af13-88bd2340ad86.png)确实是一个正交矩阵来检查：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Furthermore, we might perform a sanity test by checking if ![](img/93b48b98-bfcb-48d8-863c-e9a6af4c7585.png):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能会通过检查是否进行了一项**基本检查**来执行一个合理性测试，方法是检查 ![](img/93b48b98-bfcb-48d8-863c-e9a6af4c7585.png)：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'All this can be collected into the test case `unittest` as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些可以通过如下方式汇总到测试用例`unittest`中：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note in `assert_allclose` the parameter `atol` defaults to zero, which often
    causes problems when working with matrices having small elements.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`assert_allclose`中的参数`atol`默认为零，这在处理具有小元素的矩阵时常常会导致问题。
- en: 15.2.7 Unit and functional tests
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.7 单元测试与功能性测试
- en: Up to now, we have only used functional tests. A functional test checks whether
    the functionality is correct. For the bisection algorithm, this algorithm actually
    finds a zero when there is one. In that simple example, it is not really clear
    what a unit test is. Although it might seem slightly contrived, it is still possible
    to make a unit test for the bisection algorithm. It will demonstrate how unit
    testing often leads to more compartmentalized implementation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了功能性测试。功能性测试检查功能是否正确。对于二分法算法，当存在零时，该算法实际上会找到它。在这个简单的例子中，什么是单元测试并不完全清楚。虽然看起来有点牵强，但仍然可以为二分法算法编写单元测试。它将展示单元测试如何通常导致更具模块化的实现。
- en: 'So, in the bisection method, we would like to check, for instance, that at
    each step the interval is chosen correctly. How to do that? Note that it is absolutely
    impossible with the current implementation because the algorithm is hidden inside
    the function. One possible remedy is to run only one step of the bisection algorithm.
    Since all the steps are similar, we might argue that we have tested all the possible
    steps. We also need to be able to inspect the current bounds `a` and `b` at the
    current step of the algorithm. So we have to add the number of steps to be run
    as a parameter and change the return interface of the function. We will do that
    as shown:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在二分法方法中，我们想要检查，例如，在每一步是否正确选择了区间。如何做到这一点呢？请注意，由于当前实现将算法隐藏在函数内部，这实际上是不可能的。一个可能的解决方法是仅运行一次二分法算法的步骤。由于所有步骤相似，我们可以认为我们已经测试了所有可能的步骤。我们还需要能够检查算法当前步骤中的当前边界`a`和`b`。因此，我们必须将要运行的步骤数作为参数添加，并改变函数的返回接口。我们将按如下方式进行：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that we have to change the existing unit tests in order to accommodate
    that change. We may now add a unit test as shown:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须更改现有的单元测试以适应这一变化。现在我们可以添加一个单元测试，如下所示：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 15.2.8 Debugging
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.8 调试
- en: Debugging is sometimes necessary while testing, in particular, if it is not
    immediately clear why a given test does not pass. In that case, it is useful to
    be able to debug a given test in an interactive session. This is, however, made
    difficult by the design of the class `unittest.TestCase`, which prevents easy
    instantiation of test case objects. The solution is to create a special instance
    for debugging purposes only.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，有时需要调试，特别是当不能立即明确为何某个测试未通过时。在这种情况下，能够在交互式会话中调试特定测试是非常有用的。然而，由于`unittest.TestCase`类的设计，这使得测试用例对象的实例化变得不容易。解决方案是只为调试目的创建一个特殊实例。
- en: 'Suppose that, in the previous example of the class `TestIdentity`, we want
    to test the method `test_functionality`. This would be achieved as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在之前的`TestIdentity`类的示例中，我们想要测试`test_functionality`方法。可以按如下方式实现：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now this test can be run individually with:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个测试可以单独运行，命令是：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will run this individual test and it allows for debugging.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行这个单独的测试，并允许进行调试。
- en: 15.2.9 Test discovery
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.9 测试发现
- en: 'If you write a Python package, various tests might be spread out through the
    package. The module `discover `finds, imports, and runs these test cases. The
    basic call from the command line is:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写一个 Python 包，多个测试可能分散在包的各个部分。模块`discover`会找到、导入并运行这些测试用例。命令行中的基本调用方式是：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It starts looking for test cases in the current directory and recurses the
    directory tree downward to find Python objects with the `''test''` string contained
    in its name. The command takes optional arguments. Most important are `-s` to
    modify the start directory and `-p` to define the pattern to recognize the tests:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它开始在当前目录查找测试用例，并递归目录树向下查找名称中包含`'test'`字符串的 Python 对象。该命令接受可选参数。最重要的参数是`-s`来修改起始目录，`-p`来定义识别测试的模式：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 15.3 Measuring execution time
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.3 测量执行时间
- en: In order to take decisions on code optimization, you often have to compare several
    code alternatives and decide which code should be preferred based on the execution
    time. Furthermore, discussing execution time is an issue when comparing different
    algorithms. In this section, we present a simple and easy way to measure execution
    time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做出代码优化决策，通常需要比较几种代码替代方案，并根据执行时间决定优先使用哪种代码。此外，在比较不同算法时，讨论执行时间是一个重要问题。在本节中，我们展示了一种简单易用的计时方法。
- en: 15.3.1 Timing with a magic function
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.1 使用魔法函数进行计时
- en: The easiest way to measure the execution time of a single statement is to use
    IPython’s magic function `%timeit`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 测量单个语句的执行时间最简单的方法是使用 IPython 的魔法函数 `%timeit`。
- en: The shell IPython adds additional functionality to standard Python. These extra
    functions are called magic functions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 外壳为标准 Python 添加了额外的功能。这些额外的功能被称为魔法函数。
- en: As the execution time of a single statement can be extremely short, the statement is
    placed in a loop and executed several times. By taking the minimum measured time,
    you make sure that other tasks running on the computer do not influence the measured
    result too much.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单个语句的执行时间可能非常短，因此将语句放入循环中并执行多次。通过取最小的测量时间，确保计算机上其他任务不会对测量结果产生过多影响。
- en: 'Let''s consider four alternative ways to extract nonzero elements from an array
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑提取数组中非零元素的四种替代方法，如下所示：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Measuring time with IPython’s magic function `%timeit` gives the following
    result:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IPython 的魔法函数 `%timeit` 测量时间的结果如下：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The parameter `-n` controls how often the statement is executed before time
    is measured and the `-r` parameter controls the number of repetitions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `-n` 控制在计时前语句执行的次数，`-r` 参数控制重复次数。
- en: 15.3.2 Timing with the Python module timeit
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.2 使用 Python 模块 timeit 进行计时
- en: 'Python provides the module `timeit`, which can be used to measure execution
    time. It requires that, first, a time object is constructed. It is constructed from
    two strings: a string with setup commands and a string with the commands to be
    executed.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了 `timeit` 模块，可用于测量执行时间。它要求首先构造一个时间对象。该对象是通过两个字符串构造的：一个包含设置命令的字符串和一个包含要执行命令的字符串。
- en: 'We take the same four alternatives as in the preceding example. The array and
    function definitions are written now in a string called `setup_statements` and
    four timing objects are constructed as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采用与前面示例中相同的四种替代方案。现在，数组和函数的定义写入一个名为 `setup_statements` 的字符串，并按照如下方式构造四个计时对象：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The timer objects have a method `repeat`. It takes the two parameters `repeat` and `number`.
    It executes the statement of the timer object in a loop, measures the time, and
    repeats this experiment corresponding to the parameter `repeat`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器对象有一个 `repeat` 方法。它接受两个参数 `repeat` 和 `number`。该方法在一个循环中执行定时器对象的语句，测量时间，并根据
    `repeat` 参数重复该实验。
- en: 'We continue the preceding example and measure execution times as shown:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续前面的示例，并按照如下方式测量执行时间：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In contrast to the method in the example using `timeit`, we obtain lists of
    all the obtained measurements. As the computing time may vary depending on the
    overall load of the computer, the minimal value in such a list can be considered
    a good approximation to the computation time necessary to execute the statement.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 `timeit` 方法的示例不同，我们获取了所有测量结果的列表。由于计算时间可能根据计算机的整体负载而有所不同，因此该列表中的最小值可以视为执行语句所需计算时间的良好近似。
- en: 15.3.3 Timing with a context manager
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.3 使用上下文管理器进行计时
- en: 'Finally, we present the third method. It serves to show another application
    of a context manager. We first construct a context manager object for measuring
    the elapsed time as shown:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍第三种方法。它展示了上下文管理器的另一种应用。我们首先构造一个用于测量经过时间的上下文管理器对象，如下所示：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Recall that the `__enter__` and `__exit__` methods make this class a context
    manager. The `__exit__` method's parameters `ty`, `val`, and `tb` are in the normal
    case `None`. If an exception is raised during execution, they take the exception
    type, its value, and traceback information. The return value `False` indicates
    that the exception has not been caught so far.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，`__enter__` 和 `__exit__` 方法使得这个类成为一个上下文管理器。`__exit__` 方法的参数 `ty`、`val`
    和 `tb` 在正常情况下为 `None`。如果在执行过程中抛出异常，它们将分别包含异常类型、异常值和追踪信息。返回值 `False` 表示异常尚未被捕获。
- en: 'We''ll now show the use of the context manager to measure the execution time
    of the four alternatives in the previous example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何使用上下文管理器来测量前一个例子中四种方法的执行时间：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will then display a message like `Time elapsed 15.0129795074 ms`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这样将显示类似 `Time elapsed 15.0129795074 ms` 的消息。
- en: 'If the timing result should be accessible in a variable, the `enter` method
    must return the `Timer` instance (uncomment the `return` statement) and a `with
    ... as ...` construction has to be used:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将计时结果存储在变量中，`enter` 方法必须返回 `Timer` 实例（取消注释 `return` 语句），并且必须使用 `with ...
    as ...` 结构：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 15.4 Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.4 总结
- en: No program development without testing! We showed the importance of well-organized
    and documented tests. Some professionals even start development by first specifying
    tests. A useful tool for automatic testing is the module `unittest`, which we
    explained in detail. While testing improves the reliability of code, profiling
    is needed to improve the performance. Alternative ways to code may result in large
    performance differences. We showed how to measure computation time and how to
    localize bottlenecks in your code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 没有测试就没有程序开发！我们展示了组织良好且有文档的测试的重要性。一些专业人士甚至通过首先指定测试来开始开发。一个有用的自动测试工具是 `unittest` 模块，我们已详细解释。虽然测试可以提高代码的可靠性，但性能提升需要通过分析代码的瓶颈来实现。不同的编码方法可能导致性能差异很大。我们展示了如何测量计算时间以及如何定位代码中的瓶颈。
- en: 15.5 Exercises
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.5 习题
- en: '**Ex. 1:** Two matrices ![](img/2d8e6f34-43b2-4e70-82aa-0403dfc9d4e9.png) are
    called similar if there exists a matrix ![](img/2a9104de-2907-4372-acd8-224c1bc3e52c.png),
    such that ![](img/9eb00513-26a8-4b51-bc70-69e23ce0e356.png). The matrices ![](img/bda68266-6133-47e1-af9f-7ceb31af3bb3.png)
    and *![](img/b1ee0969-d1f6-4ca0-b59e-952e73467c51.png)* have the same eigenvalues.
    Write a test checking that two matrices are similar, by comparing their eigenvalues.
    Is it a functional or a unit test?'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 1：** 如果存在一个矩阵 ![](img/2a9104de-2907-4372-acd8-224c1bc3e52c.png)，使得 ![](img/9eb00513-26a8-4b51-bc70-69e23ce0e356.png)，则两个矩阵 ![](img/2d8e6f34-43b2-4e70-82aa-0403dfc9d4e9.png) 被称为相似。矩阵 ![](img/bda68266-6133-47e1-af9f-7ceb31af3bb3.png) 和 *![](img/b1ee0969-d1f6-4ca0-b59e-952e73467c51.png)* 具有相同的特征值。编写一个测试，检查两个矩阵是否相似，通过比较它们的特征值。这个是功能测试还是单元测试？'
- en: '**Ex. 2:** Create two vectors of large dimensions. Compare the execution time
    of various ways to compute their dot product:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 2：** 创建两个大维度的向量。比较计算它们点积的不同方法的执行时间：'
- en: 'SciPy function: `v @ w`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SciPy 函数：`v @ w`
- en: Generator and sum: `sum((x*y for x,y in zip(v,w)))`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器和求和： `sum((x*y for x,y in zip(v,w)))`
- en: Comprehensive list and sum: `sum([x*y for x,y in zip(v,w)])`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 综合列表和求和： `sum([x*y for x,y in zip(v,w)])`
- en: '**Ex. 3:** Let ![](img/3526771a-a59b-41d5-83c6-f33e83a0e3cb.png) be a vector.
    The vector ![](img/bc63c3f4-50dc-4b1c-be52-85d26cfad5bb.png) with components'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 3：** 设！[](img/3526771a-a59b-41d5-83c6-f33e83a0e3cb.png)为一个向量。该向量 ![](img/bc63c3f4-50dc-4b1c-be52-85d26cfad5bb.png)的分量为'
- en: '![](img/084b74cc-dc2c-42bf-a28c-da33c7175588.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/084b74cc-dc2c-42bf-a28c-da33c7175588.png)'
- en: 'is called a moving average of ![](img/8ac291cf-4704-4bef-8bc3-988982c3b547.png).
    Determine which of the two alternatives to compute ![](img/76df3e80-0678-45d1-9303-c3644ca27e70.png)
    is faster:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 ![](img/8ac291cf-4704-4bef-8bc3-988982c3b547.png)的移动平均。确定计算 ![](img/76df3e80-0678-45d1-9303-c3644ca27e70.png)的两个方法中哪个更快：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: or
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
