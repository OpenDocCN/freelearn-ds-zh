- en: Chapter 3. Moving Spatial Data from One Format to Another
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。将空间数据从一个格式移动到另一个格式
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Converting a Shapefile to a PostGIS table using ogr2ogr
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ogr2ogr将Shapefile转换为PostGIS表
- en: Batch importing a folder of Shapefiles into PostGIS using ogr2ogr
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ogr2ogr将Shapefiles文件夹批量导入PostGIS
- en: Batch exporting a list of tables from PostGIS to Shapefiles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从PostGIS批量导出一系列表到Shapefiles
- en: Converting an OpenStreetMap (OSM) XML to a Shapefile
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将OpenStreetMap（OSM）XML转换为Shapefile
- en: Converting a Shapefile (vector) to a GeoTiff (raster)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Shapefile（矢量）转换为GeoTiff（栅格）
- en: Converting a raster (GeoTiff) to a vector (Shapefile) using GDAL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GDAL将栅格（GeoTiff）转换为矢量（Shapefile）
- en: Creating a Shapefile from point data stored in Microsoft Excel
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从存储在Microsoft Excel中的点数据创建Shapefile
- en: Converting an ESRI ASCII DEM to an image height map
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将ESRI ASCII DEM转换为图像高度图
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Geospatial data comes in hundreds of formats and massaging this data from one
    format to another is a simple task. The ability to convert between data types,
    such as rasters or vectors, belongs to data wrangling tasks and can be used for
    better geospatial analysis. Here is an example of a raster and vector dataset
    so that you can take a look at what I am talking about:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 地理空间数据有数百种格式，将数据从一种格式转换为另一种格式是一项简单的任务。在数据类型之间进行转换的能力，如栅格或矢量，属于数据处理任务，可用于更好的地理空间分析。以下是一个栅格和矢量数据集的示例，以便您可以查看我在谈论的内容：
- en: '![Introduction](img/B03543_03_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/B03543_03_01.jpg)'
- en: The best practice methodology is to run analysis functions or models over data
    stored in a common format, such as a PostgreSQL PostGIS database, or a set of
    Shapefiles in a common coordinate system. For example, running an analysis on
    input data stored in multiple formats is also possible, but you can expect to
    find the devil in the detail if something goes wrong or your results are not as
    you expected them to be.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践方法是运行存储在常见格式中的数据（如PostgreSQL PostGIS数据库或一组具有共同坐标系统的Shapefiles）上的分析函数或模型。例如，对存储在多种格式中的输入数据进行分析也是可能的，但如果出现问题或结果不符合预期，您可能会发现问题的细节。
- en: This chapter looks at some common data formats and demonstrates how to move
    these from one format to another with the help of the most common tools.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨一些常见的数据格式，并演示如何使用最常用的工具将这些格式从一种转换为另一种。
- en: Converting a Shapefile to a PostGIS table using ogr2ogr
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ogr2ogr将Shapefile转换为PostGIS表
- en: The simplest way to transform data from one format to another is to directly
    use the *ogr2ogr* tool that comes with the installation of GDAL. This powerful
    tool can convert over 200 geospatial formats. In this solution, we will execute
    the *ogr2ogr* utility from within a Python script to perform generic vector data
    conversions. The Python code is, therefore, used to execute this command-line
    tool and pass around variables so that you can create your own scripts for data
    imports or exports.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据从一种格式转换为另一种格式最简单的方法是直接使用随GDAL安装提供的*ogr2ogr*工具。这个强大的工具可以转换200多种地理空间格式。在这个解决方案中，我们将从Python脚本中执行*ogr2ogr*实用程序以执行通用的矢量数据转换。因此，Python代码被用来执行这个命令行工具并传递变量，这样您就可以创建自己的数据导入或导出脚本。
- en: Using this tool is also recommended if you are not really interested in coding
    too much and simply want to get the job done to move your data. A pure Python
    solution is, of course, possible, but it's definitely more orientated to the needs
    of developers (or a Python purist). Since this book is aimed at developers, analysts,
    or researchers, this kind of a recipe is simple and yet extensible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对编码并不特别感兴趣，只想完成工作以移动你的数据，使用这个工具也是推荐的。当然，纯Python解决方案是可能的，但它无疑更倾向于满足开发人员（或Python纯主义者）的需求。由于本书的目标读者是开发人员、分析师或研究人员，这种类型的配方既简单又易于扩展。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To run this script, you will need the GDAL utilities application installed
    on your system. Windows users can visit OSGeo4W ([http://trac.osgeo.org/osgeo4w](http://trac.osgeo.org/osgeo4w))
    and download the 32-bit or 64-bit Windows installer. Simply double-click on the
    installer to start the script as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，您需要在您的系统上安装GDAL工具应用程序。Windows用户可以访问OSGeo4W（[http://trac.osgeo.org/osgeo4w](http://trac.osgeo.org/osgeo4w)）并下载32位或64位Windows安装程序。只需双击安装程序即可启动脚本，如下所示：
- en: Navigate to the bottom option, **Advanced Installation** | **Next**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到底部选项，**高级安装** | **下一步**。
- en: Click on **Next** to download the GDAL utilities from the Internet (first default
    option).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**从互联网下载GDAL工具（第一个默认选项）。
- en: Click on **Next** to accept the default location of the path or change it to
    your liking.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**接受路径的默认位置或更改为你喜欢的位置。
- en: Click on **Next** to accept the location of local saved downloads (default).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**接受本地保存下载的位置（默认）。
- en: Click on **Next** to accept a direct connection (default).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**接受直接连接（默认）。
- en: Click on **Next** to select the default download site.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**选择默认下载站点。
- en: Now, you can finally see the menu. Click on **+** to open the **Commandline_Utilities**
    tab, and you should see what is shown in this screenshot:![Getting ready](img/B03543_03_02.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你终于可以看到菜单了。点击**+**打开**Commandline_Utilities**标签页，你应该能看到这个截图所示的内容：![准备中](img/B03543_03_02.jpg)
- en: 'Now, select **gdal: The GDAL/OGR library and commandline tools** to install
    it.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，选择**gdal: The GDAL/OGR library and commandline tools**来安装它。'
- en: Click on **Next** to start downloading and install.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**开始下载和安装。
- en: 'Ubuntu/Linux users can use the following steps to install the GDAL utilities:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu/Linux用户可以使用以下步骤安装GDAL工具：
- en: 'Execute this simple one-line command:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下简单的单行命令：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will get you up and running so that you can execute `ogr2ogr` directly
    from your terminal.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使你能够直接从终端执行`ogr2ogr`。
- en: The Shapefile to be imported is located in your `/ch02/geodata/` folder if you've
    downloaded the entire source and code from GitHub at [https://github.com/mdiener21/python-geospatial-analysis-cookbook/](https://github.com/mdiener21/python-geospatial-analysis-cookbook/).
    The Vancouver open geodata portal ([http://data.vancouver.ca/datacatalogue/index.htm](http://data.vancouver.ca/datacatalogue/index.htm))
    is our source that provides a dataset of local bikeways.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要导入的Shapefile位于你的`/ch02/geodata/`文件夹中，如果你已经从GitHub [https://github.com/mdiener21/python-geospatial-analysis-cookbook/](https://github.com/mdiener21/python-geospatial-analysis-cookbook/)下载了整个源代码和代码。温哥华开放地理数据门户
    [http://data.vancouver.ca/datacatalogue/index.htm](http://data.vancouver.ca/datacatalogue/index.htm)
    是我们的数据源，它提供了一个本地自行车道的数据集。
- en: 'Next, let''s set up our PostgreSQL database with the PostGIS extension. To
    do this, we''ll first create a new user to manage our new database and tables
    as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们设置带有PostGIS扩展的PostgreSQL数据库。为此，我们首先创建一个新用户来管理我们的新数据库和表，如下所示：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Enter a password for the new role.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新角色输入密码。
- en: Enter the password again for the new role.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次输入新角色的密码。
- en: Enter a password for the `postgres` user as you will create the user using this
    `postgres` user.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`postgres`用户输入密码，因为你将使用此`postgres`用户创建用户。
- en: The `–P` option prompts you to give the new user, called `pluto`, a password.
    For the following examples, our password is `stars`; I would recommend a much
    more secure password for your production database.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`–P`选项会提示你为名为`pluto`的新用户设置密码。在以下示例中，我们的密码是`stars`；我建议为你的生产数据库使用一个更安全的密码。'
- en: Tip
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Windows users can navigate to the `c:\Program Files\PostgreSQL\9.3\bin\` folder
    and execute the following command, and follow the on-screen instructions as you
    did earlier:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Windows用户可以导航到`c:\Program Files\PostgreSQL\9.3\bin\`文件夹，并执行以下命令，然后按照之前的方式遵循屏幕上的说明：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create the database, we will use the same command-line `createdb` command
    as the `postgres` user to create a database named `py_geoan_cb`, and assign the
    `pluto` user to be the database owner. Here is the command to do this:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建数据库，我们将使用与`postgres`用户相同的`createdb`命令行来创建一个名为`py_geoan_cb`的数据库，并将`pluto`用户指定为数据库所有者。以下是执行此操作的命令：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Windows users can visit `c:\Program Files\PostgreSQL\9.3\bin\` and execute
    the `createdb.exe` command as follows:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Windows用户可以访问`c:\Program Files\PostgreSQL\9.3\bin\`并执行以下`createdb.exe`命令：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we''ll create the PostGIS extension for our newly created database:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的新创建的数据库创建PostGIS扩展：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Windows users can also execute `psql` from within the `c:\Program Files\PostgreSQL\9.3\bin\`
    folder as follows:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Windows用户也可以在`c:\Program Files\PostgreSQL\9.3\bin\`文件夹中执行`psql`，如下所示：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Lastly, we'll create a schema called **geodata** to store our new spatial table.
    It is common to store spatial data in another schema outside the default `public`
    schema of PostgreSQL.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个名为**geodata**的模式来存储我们新的空间表。在PostgreSQL的默认`public`模式之外存储空间数据是常见的。
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Windows users can use the following command to do this:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Windows用户可以使用以下命令来完成此操作：
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now, let''s get into the actual importing of our Shapefile into a PostGIS database
    that will automatically create a new table from our Shapefile:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们开始将我们的Shapefile导入到PostGIS数据库中，这将自动从我们的Shapefile创建一个新表：
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we''ll call our script from the command line:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从命令行调用我们的脚本：
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We begin with importing the standard Python `subprocess` module that will call
    the *ogr2ogr* command-line tool. Next, we'll set up a range of variables that
    are used as input arguments and provide various options for ogr2ogr to execute.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入标准的Python `subprocess`模块，该模块将调用*ogr2ogr*命令行工具。接下来，我们将设置一系列变量，这些变量用作输入参数，并为ogr2ogr执行提供各种选项。
- en: Starting with the PostgreSQL `SCHEMA=geodata` database, we set a nondefault
    database schema for the destination of our new table. It is a best practice to
    store your spatial data tables in a separate schema outside the public schema,
    which is the default. This practice will make backups and restores much easier
    and keeps your database better organized.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从`SCHEMA=geodata`的PostgreSQL数据库开始，我们为我们的新表设置了一个非默认的数据库模式。将空间数据表存储在公共模式之外的一个单独的模式中是一种最佳实践，公共模式是默认模式。这种做法将使备份和恢复变得容易得多，并使数据库组织得更好。
- en: Next, we create a `overwrite_option` variable set to `yes` so that we can overwrite
    any table with the same name when it's created. This is helpful when you want
    to completely replace the table with new data; otherwise, it is recommended to
    use the `-append` option. We also specify the geometry type because, sometimes,
    ogr2ogr does not always guess the correct geometry type of our Shapefile so setting
    this value spares you that worry.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个设置为`yes`的`overwrite_option`变量，这样我们就可以在创建时覆盖任何同名表。当您想完全用新数据替换表时，这很有用；否则，建议使用`-append`选项。我们还指定了几何类型，因为有时ogr2ogr并不总是能正确猜测我们的Shapefile的几何类型，所以设置这个值可以节省您这方面的担忧。
- en: Now, we'll set our `output_format` variable with the `PostgreSQL` key word,
    telling ogr2ogr that we want to output data into a PostgreSQL database. This is
    then followed by the `db_connection` variable that specifies our database connection
    information. We must not forget that the database must already exist along with
    the `geodata` schema; otherwise, we will get an error.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`PostgreSQL`关键字设置我们的`output_format`变量，告诉ogr2ogr我们希望将数据输出到PostgreSQL数据库。然后是`db_connection`变量，它指定了我们的数据库连接信息。我们绝对不能忘记数据库必须已经存在，以及`geodata`模式；否则，我们将得到一个错误。
- en: The last `input_shp` variable is the full path to our Shapefile including the
    `.shp` file ending. We'll call the subprocess module and it will call the ogr2ogr
    command-line tool and pass along the variable options required to run the tool.
    We pass this function an array of arguments, starting with the first object in
    the array being the ogr2ogr command-line tool name. Following the name, we pass
    one option after another in the array to complete the call.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`input_shp`变量是我们Shapefile的完整路径，包括`.shp`文件扩展名。我们将调用subprocess模块，它将调用ogr2ogr命令行工具，并传递运行工具所需的变量选项。我们向该函数传递一个参数数组，数组中的第一个对象是ogr2ogr命令行工具的名称。在名称之后，我们在数组中传递一个选项，以完成调用。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Subprocess can be used to call any command-line tool directly. Subprocess takes
    a list of parameters separated by spaces. This passing of parameters is quite
    fussy, so make sure you follow along closely and don't add any extra spaces or
    commas.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Subprocess可以用来直接调用任何命令行工具。Subprocess接受由空格分隔的参数列表。这种参数传递相当挑剔，所以请确保您紧跟其后，不要添加任何额外的空格或逗号。
- en: Last but not least, we need to execute our script from the command line to actually
    import our Shapefile by calling the Python interpreter and passing the script.
    Now head over to the **PgAdmin** PostgreSQL database viewer and see if it's worked.
    Or, even better, open up Quantum GIS ([www.qgis.org](http://www.qgis.org)) and
    take a look at the newly created tables.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们需要从命令行执行我们的脚本，通过调用Python解释器并传递脚本实际上导入我们的Shapefile。现在转到**PgAdmin**
    PostgreSQL数据库查看器，看看是否成功。或者，更好的是，打开Quantum GIS ([www.qgis.org](http://www.qgis.org))并查看新创建的表。
- en: See also
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'If you would like to see the full list of options available with the ogr2ogr
    command, simply enter the following in the command line:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看ogr2ogr命令可用的完整选项列表，只需在命令行中输入以下内容：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will see the full list of options available. Also, visit [http://gdal.org/ogr2ogr.html](http://gdal.org/ogr2ogr.html)
    to read the available documentation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到可用的完整选项列表。此外，请访问[http://gdal.org/ogr2ogr.html](http://gdal.org/ogr2ogr.html)以阅读可用的文档。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For those of you who are curious to see how this call would run without using
    Python, the call directly to `ogr2ogr` will be as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些好奇如何在不使用Python的情况下运行此调用的人来说，直接调用`ogr2ogr`的调用方式如下：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Batch importing a folder of Shapefiles into PostGIS using ogr2ogr
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ogr2ogr将Shapefile文件夹批量导入PostGIS
- en: We would like to extend our last script to loop over a folder full of Shapefiles
    and import them into PostGIS. Most importing tasks involve more than one file
    to import, so this makes it a very practical task.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望扩展我们最后的脚本，以便遍历一个充满Shapefiles的文件夹并将它们导入到PostGIS中。大多数导入任务都涉及多个文件，因此这是一个非常实用的任务。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Our script will reuse the previous code in the form of a function so that we
    can batch process a list of Shapefiles to import into the PostgreSQL PostGIS database.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本将以函数的形式重用之前的代码，这样我们就可以批量处理要导入到PostgreSQL PostGIS数据库的Shapefiles列表。
- en: 'We will create our list of Shapefiles from a single folder for the sake of
    simplicity:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化起见，我们将从单个文件夹创建我们的Shapefiles列表：
- en: '[PRE13]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can simply run our new script from the command line once again as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以再次从命令行简单地运行我们的新脚本，如下所示：
- en: '[PRE14]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we are reusing our code from the previous script but have converted it
    into a Python function called `run_shp2pg (input_shp)` that takes exactly one
    argument and the complete path to the Shapefile that we want to import. The input
    argument must include the Shapefile ending, `.shp`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在重用之前脚本中的代码，但已将其转换为名为`run_shp2pg(input_shp)`的Python函数，该函数接受一个参数，即我们想要导入的Shapefile的完整路径。输入参数必须包含Shapefile扩展名，`.shp`。
- en: We have a helper function that will get the geometry type as a string by reading
    in the Shapefile feature layer and outputting the geometry type so that the `ogr`
    commands know what to expect. This does not always work and some errors can occur.
    The `–skipfailures` option will plow over any errors that are thrown during insertion
    and will still populate our tables.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个辅助函数，它通过读取Shapefile要素层并输出几何类型作为字符串来获取几何类型，这样`ogr`命令就知道期待什么。这并不总是有效，可能会发生一些错误。`–skipfailures`选项将忽略插入过程中抛出的任何错误，并继续填充我们的表。
- en: To begin with, we need to define the folder that contains all our Shapefiles
    to be imported. Next up, we can create an empty list object called `shapefile_list`
    that will hold the list of all our Shapefiles that we want to import.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义包含所有待导入Shapefiles的文件夹。接下来，我们可以创建一个名为`shapefile_list`的空列表对象，它将保存我们想要导入的所有Shapefiles的列表。
- en: The first `for` loop is used to get a list of all the Shapefiles in the directory
    specified using the standard Python `os.listdir()` function. We do not want all
    the files in this folder. We only want files with the file ending `.shp`; hence,
    the `if` statement that will evaluate to `True` if the file ends with `.shp`.
    Once the `.shp` file is found, we need to append the file path to the filename
    to create a single string that holds the path plus the Shapefile name and the
    `full_shapefile_path` variable. In the final part, we add each new file with its
    attached path to our `shapefile_list` list object so that we have our final list
    to loop through.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`for`循环使用标准Python `os.listdir()`函数获取指定目录中所有Shapefiles的列表。我们不想获取这个文件夹中的所有文件。我们只想获取以`.shp`结尾的文件；因此，有一个`if`语句，如果文件以`.shp`结尾，则评估为`True`。一旦找到`.shp`文件，我们需要将文件路径和文件名连接起来，创建一个包含路径和Shapefile名称的单个字符串，即`full_shapefile_path`变量。在最后部分，我们将每个新文件及其附加路径添加到我们的`shapefile_list`列表对象中，以便我们可以遍历最终的列表。
- en: Now, it is time to loop through each Shapefile in our new list and run our `run_shp2pg(input_shp)`
    function for each Shapefile in the list, importing it into our PostgreSQL PostGIS
    database.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候遍历我们新列表中的每个Shapefile，并对列表中的每个Shapefile运行我们的`run_shp2pg(input_shp)`函数，将其导入到我们的PostgreSQL
    PostGIS数据库中。
- en: There's more…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you have a lot of Shapefiles (and I mean a lot, as in 100 or more Shapefiles),
    performance will be one consideration and will, therefore, require a lot of machines
    with free resources.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多Shapefiles（我的意思是真的很多，比如100个或更多），性能将是一个考虑因素，因此将需要很多具有空闲资源的机器。
- en: Batch exporting a list of tables from PostGIS to Shapefiles
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从PostGIS批量导出表到Shapefiles
- en: We will now change direction and take a look at how we can batch export a list
    of tables from our PostGIS database into a folder of Shapefiles. We'll again use
    the ogr2ogr command-line tool from within a Python script so that you can include
    it in your application programming work flow. Near the end, you can also see how
    all this works in one single command line.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将改变方向，看看我们如何可以从PostGIS数据库批量导出一系列表到Shapefiles文件夹。我们将在Python脚本中使用ogr2ogr命令行工具，这样你就可以将其包含在你的应用程序编程工作流程中。在接近结尾的地方，你还可以看到所有这些是如何在一个单独的命令行中完成的。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following script will fire the `ogr2ogr` command and loop over a list of
    tables to export the Shapefile format into an existing folder. So, let''s take
    a look at how to do this as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下脚本将触发 `ogr2ogr` 命令并遍历表列表以将 Shapefile 格式导出到现有文件夹。因此，让我们看看如何按照以下步骤进行：
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we''ll call our script from the command line as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将按照以下方式从命令行调用我们的脚本：
- en: '[PRE16]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Beginning with the simple import of our `subprocess` and `os` modules, we immediately
    define our destination directory where we want to store the exported Shapefiles.
    This variable is followed by the list of table names that we want to export. This
    list can only include files located in the same PostgreSQL schema. The schema
    is defined as the `active_schema` so that `ogr2ogr` knows where to find tables
    to export.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从简单的 `subprocess` 和 `os` 模块导入开始，我们立即定义了我们想要存储导出 Shapefiles 的目标目录。该变量后面跟着我们想要导出的表名列表。此列表只能包括位于同一
    PostgreSQL 模式中的文件。该模式定义为 `active_schema`，这样 `ogr2ogr` 就知道在哪里找到要导出的表。
- en: Once again, we define the output format as **ESRI Shapefile**. Now, we'll check
    whether the destination folder exists. If it does, we'll continue and call our
    loop. Then, we'll loop through the list of tables stored in our `postgis_tables_list`
    variable. If the destination folder does not exist, you will see an error printed
    on the screen.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将输出格式定义为**ESRI Shapefile**。现在，我们将检查目标文件夹是否存在。如果存在，我们将继续并调用我们的循环。然后，我们将遍历存储在
    `postgis_tables_list` 变量中的表列表。如果目标文件夹不存在，您将在屏幕上看到错误信息。
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Programming an application and then executing the ogr2ogr command from inside
    your script is definitely quick and easy. On the other hand, for a one-off job,
    simply executing the command-line tool is what you want to do when exporting your
    list of Shapefiles. To do this in a one-liner, take a look at this information
    box.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 编写应用程序并从脚本内部执行 ogr2ogr 命令确实既快又简单。另一方面，对于一次性工作，当导出 Shapefile 列表时，您只需执行命令行工具即可。为了以一行命令完成此操作，请参阅以下信息框。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A one-line example of calling the ogr2ogr batch PostGIS table to Shapefiles
    is shown here if you simply want to execute this once and not in a scripting environment:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想执行一次而不在脚本环境中执行，以下是一个调用 ogr2ogr 批量 PostGIS 表到 Shapefiles 的一行示例：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The list of tables you want to export is located at the end as a list separated
    by spaces. The destination location of the exported Shapefiles is `../geodata/temp`.
    Note that this `/temp` directory must exist.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要导出的表列表位于末尾，由空格分隔。导出 Shapefiles 的目标位置是 `../geodata/temp`。请注意，此 `/temp` 目录必须存在。
- en: Converting an OpenStreetMap (OSM) XML to a Shapefile
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 OpenStreetMap (OSM) XML 转换为 Shapefile
- en: OpenStreetMap (OSM) has a wealth of free data, but to use it with most other
    applications, we need to convert it to other formats, such as Shapefile or PostgreSQL
    PostGIS databases. This recipe will use the **ogr2ogr** tool to perform the conversion
    for us within a Python script. The benefit of this is, again, simplicity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: OpenStreetMap (OSM) 拥有丰富的免费数据，但为了与其他大多数应用程序一起使用，我们需要将其转换为其他格式，例如 Shapefile 或
    PostgreSQL PostGIS 数据库。本食谱将使用 **ogr2ogr** 工具在 Python 脚本中为我们执行转换。这种方法的优点再次是简单性。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, you will need to download the OSM data at [http://www.openstreetmap.org/export#map=17/37.80721/-122.47305](http://www.openstreetmap.org/export#map=17/37.80721/-122.47305)
    and save the file (`.osm`) to your `/ch03/geodata` directory. The download button
    is located on the left-hand side bar and, when pressed, it should immediately
    start the download (refer to the following screenshot). The area we are testing
    is in San Francisco, just before the **Golden Gate Bridge**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要下载 OSM 数据，请访问 [http://www.openstreetmap.org/export#map=17/37.80721/-122.47305](http://www.openstreetmap.org/export#map=17/37.80721/-122.47305)
    并将文件（`.osm`）保存到您的 `/ch03/geodata` 目录中。下载按钮位于左侧栏上，按下后应立即开始下载（参见图表）。我们正在测试的区域位于旧金山，就在**金门大桥**之前。
- en: '![Getting ready](img/B03543_03_03.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/B03543_03_03.jpg)'
- en: 'If you choose to download another area from OSM, feel free but make sure you
    take a small area similar to my example. If you select a larger area, the OSM
    web tool will give you a warning and disable the download button. The reason for
    this is simple: if the dataset is very large, it is most likely better suited
    for another tool, such as **osm2pgsql**, ([http://wiki.openstreetmap.org/wiki/Osm2pgsql](http://wiki.openstreetmap.org/wiki/Osm2pgsql))
    for your conversion. If you need to get OSM data for a large area and want to
    export it to Shapefile, it would be advisable to use another tool, such as **osm2pgsql**,
    which will first import your data into a PostgreSQL database. Then, export the
    data from the PostGIS database to Shapefile using the **pgsql2shp** tool.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择从OSM下载另一个区域，请随意，但请确保你选择一个与我示例相似的小区域。如果你选择一个更大的区域，OSM网络工具会给出警告并禁用下载按钮。原因很简单：如果数据集非常大，它可能更适合其他工具，例如**osm2pgsql**([http://wiki.openstreetmap.org/wiki/Osm2pgsql](http://wiki.openstreetmap.org/wiki/Osm2pgsql))进行转换。如果你需要获取大区域的OSM数据并将其导出为Shapefile，建议使用其他工具，例如**osm2pgsql**，它首先将你的数据导入PostgreSQL数据库。然后，使用**pgsql2shp**工具从PostGIS数据库导出数据到Shapefile。
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A Python tool called **imposm** can be used to import the OSM data into a PostGIS
    database and is available at [http://imposm.org/](http://imposm.org/). Version
    2 of it is written in Python and version 3 is written in the *go* programming
    language, if you want to give this a try as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为**imposm**的Python工具可以用来将OSM数据导入PostGIS数据库，并且可以在[http://imposm.org/](http://imposm.org/)找到。它的第2版是用Python编写的，第3版是用*go*编程语言编写的，如果你想尝试这个，也可以。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the following steps to convert an OpenStreetMap (OSM) XML into a Shapefile:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤将OpenStreetMap (OSM) XML转换为Shapefile：
- en: 'Using the subprocess module, we will execute **ogr2ogr** to convert our OSM
    data that we downloaded into a new Shapefile:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用子进程模块，我们将执行**ogr2ogr**将我们下载的OSM数据转换为新的Shapefile：
- en: '[PRE18]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we can call our script from the command line:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从命令行调用我们的脚本：
- en: '[PRE19]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Go and have a look in your `../geodata` folder to see the newly created Shapefiles
    and try to open them up in Quantum GIS, which is a free GIS software ([www.qgis.org](http://www.qgis.org)).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前往你的`../geodata`文件夹查看新创建的Shapefiles，并尝试在Quantum GIS中打开它们，Quantum GIS是一款免费的GIS软件([www.qgis.org](http://www.qgis.org))。
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This script should be clear as we are using the subprocess module call to fire
    our ogr2ogr command-line tool. We'll specify our OSM dataset as an input file,
    including the full path to the file. The Shapefile name is not supplied as ogr2ogr
    will output a set of Shapefiles, one for each geometry shape according to the
    geometry types it finds inside the OSM file. We only need to specify the name
    of the folder where we want ogr2ogr to export the Shapefiles to, automatically
    creating the folder if it does not exist.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本应该很清晰，因为我们使用子进程模块调用来执行ogr2ogr命令行工具。我们将指定我们的OSM数据集作为输入文件，包括文件的完整路径。Shapefile的名称不需要提供，因为ogr2ogr将输出一系列Shapefiles，每个Shapefile根据在OSM文件中找到的几何类型分别对应一个。我们只需要指定我们希望ogr2ogr将Shapefiles导出到的文件夹名称，如果该文件夹不存在，则会自动创建。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Windows users: If you do not have your ogr2ogr tool mapped to your environment
    variables, you can simply uncomment the code at lines 16 and 17 and replace the
    path shown with the path on your machine to the Windows executables.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户：如果你没有将ogr2ogr工具映射到你的环境变量中，你可以简单地取消第16行和第17行的注释，并将显示的路径替换为你机器上Windows可执行文件的路径。
- en: The first subprocess call prints out to the screen the geometry types found
    inside our OSM file. This is helpful in most cases to help identify what is available.
    Shapefiles can only support one geometry type per file, and this is why ogr2ogr
    outputs a folder full of Shapefiles, each one representing a separate geometry
    type.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次子进程调用会在屏幕上打印出我们OSM文件中找到的几何类型。这在大多数情况下很有用，可以帮助识别可用内容。Shapefiles每个文件只能支持一种几何类型，这也是为什么ogr2ogr会输出一个包含多个Shapefiles的文件夹，每个Shapefile代表一个单独的几何类型。
- en: Lastly, we call subprocess to execute ogr2ogr, passing in the output file type
    called ESRI Shapefile, the output folder, and the name of the OSM dataset.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用子进程来执行ogr2ogr，传入输出文件类型为ESRI Shapefile，输出文件夹和OSM数据集的名称。
- en: Converting a Shapefile (vector) to a GeoTiff (raster)
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Shapefile（矢量）转换为GeoTiff（栅格）
- en: Moving data from format to format also includes moving it from vector to raster
    or the other way round. In this recipe, we move data from a vector (Shapefile)
    to a raster (GeoTiff) with the Python `gdal` and `ogr` modules.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式之间移动数据也包括从矢量到栅格或相反。在这个菜谱中，我们使用Python的`gdal`和`ogr`模块将数据从矢量（Shapefile）移动到栅格（GeoTiff）。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to be inside our virtual environment again, so fire it up so that we
    can access the `gdal` and `ogr` Python modules that we installed in [Chapter 1](ch01.html
    "Chapter 1. Setting Up Your Geospatial Python Environment"), *Setting Up Your
    Geospatial Python Environment*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要再次进入我们的虚拟环境，所以启动它，这样我们就可以访问我们在[第1章](ch01.html "第1章。设置您的地理空间Python环境")中安装的`gdal`和`ogr`Python模块，*设置您的地理空间Python环境*。
- en: 'As usual, enter your Python virtual environment with the `workon pygeoan_cb`
    command or this command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，使用`workon pygeoan_cb`命令或此命令进入您的Python虚拟环境：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A Shapefile is also needed, so be sure to download the source and access the
    `/ch03/geodata` folder ([https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip](https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip)).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要一个Shapefile，所以请确保下载源文件并访问`/ch03/geodata`文件夹（[https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip](https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip)）。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s dive in and convert our golf course polygon Shapefile into a GeoTif;
    here comes the code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入进去，将我们的高尔夫球场多边形Shapefile转换为GeoTif；下面是代码：
- en: 'Import the libraries `ogr` and `gdal`, and then define our output pixel size
    along with a value to assign to null:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`ogr`和`gdal`库，然后定义我们的输出像素大小以及分配给空值的值：
- en: '[PRE21]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Set up the input Shapefile we want to convert alongside the new GeoTiff raster
    that will be created when the script is executed:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们想要转换的输入Shapefile，以及当脚本执行时将创建的新GeoTiff栅格：
- en: '[PRE22]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we need to create the input Shapefile object, get the layer information,
    and finally set the extent values:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建输入Shapefile对象，获取图层信息，并最终设置范围值：
- en: '[PRE23]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we need to calculate the resolution distance to pixel value:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们需要计算分辨率距离到像素值的转换：
- en: '[PRE24]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our new raster type is a GeoTiff, so we must explicitly tell GDAL to get this
    driver. The driver is then able to create a new GeoTiff by passing in the filename
    or the new raster that we want to create, called the *x* direction resolution,
    followed by the *y* direction resolution, and then the number of bands; in this
    case, it is 1\. Lastly, we set a new type of `GDT_Byte` raster:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新栅格类型是GeoTiff，因此我们必须明确告诉GDAL获取此驱动程序。然后，驱动程序能够通过传递文件名或我们想要创建的新栅格（称为*x*方向分辨率），然后是*y*方向分辨率，接着是波段数；在这种情况下，是1。最后，我们设置了一种新的`GDT_Byte`栅格类型：
- en: '[PRE25]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we can access the new raster band and assign the no data values and the
    inner data values for the new raster. All the inner values will receive a value
    of 255 similar to what we set in the `burn_values` variable:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以访问新的栅格波段，并为新的栅格分配无数据值和内部数据值。所有内部值都将接收一个值为255，类似于我们在`burn_values`变量中设置的值：
- en: '[PRE26]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here we go; let''s run this script to see what our new raster looks like:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始了；让我们运行这个脚本来看看我们的新栅格是什么样子：
- en: '[PRE27]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our resulting raster should look like what is shown in the following screenshot
    if you open it using **QGIS** ([http://www.qgis.org](http://www.qgis.org)):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用**QGIS**（[http://www.qgis.org](http://www.qgis.org)）打开，我们的结果栅格应该看起来像以下截图所示：
- en: '![How to do it...](img/B03543_03_04.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/B03543_03_04.jpg)'
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are several steps involved in this code so follow along as some points
    could lead to trouble if you are not sure what values to input. We start with
    the import of the *gdal* and *ogr* modules, respectively, since they will do the
    work for us by inputting a Shapefile (vector) and outputting a GeoTiff (raster).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码涉及几个步骤，所以请跟随，因为一些点可能会导致问题，如果你不确定要输入什么值。我们首先导入*gdal*和*ogr*模块，因为它们将通过输入Shapefile（矢量）和输出GeoTiff（栅格）为我们完成工作。
- en: The `pixel_size` variable is very important since it will determine the size
    of the new raster that we will create. In this example, we only have two polygons,
    so we set `pixel_size = 1` to keep a fine border between them. If you have many
    polygons stretching across the globe in one Shapefile, it is wiser to set this
    value to 25 or more. Otherwise, you could end up with a 10 GB raster and your
    machine will run all night long! The `no_data_value` is needed to tell GDAL what
    values to set in the empty space around our input polygons and we set it to `-9999`
    for easy identification.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`pixel_size`变量非常重要，因为它将决定我们将创建的新栅格的大小。在这个例子中，我们只有两个多边形，所以我们设置`pixel_size =
    1`以保持它们之间精细的边界。如果你有一个Shapefile中跨越全球的许多多边形，更明智的做法是将此值设置为25或更多。否则，你可能会得到一个10GB的栅格，你的机器将整夜运行！`no_data_value`是必需的，以告诉GDAL在输入多边形周围的空空间中设置什么值，我们将其设置为`-9999`以便于识别。'
- en: Next, we simply set the input Shapefile stored in EPSG:3857 Web Mercator and
    output GeoTiff. Check to make sure that you change the filenames accordingly if
    you want to use some other dataset. We start by working with the OGR module to
    open the Shapefile and retrieve its layer information and the extent information.
    The extent is important because it is used to calculate the size of the output
    raster width and height values that must be integers represented by the `x_res`
    and `y_res` variables.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们简单地设置输入的Shapefile存储在EPSG:3857 Web Mercator和输出GeoTiff。如果你想使用其他数据集，请确保相应地更改文件名。我们首先使用OGR模块打开Shapefile并检索其层信息和范围信息。范围很重要，因为它用于计算输出栅格的宽度和高度值，这些值必须是整数，由`x_res`和`y_res`变量表示。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the projection of your Shapefile must be in meters and not degrees.
    This is very important since this will NOT work in EPSG:4326, WGS 84, for example.
    The reason for this is that the coordinate units are LAT/LON. This means that
    WGS84 is not a flat plane projection and cannot be drawn as is. Our `x_res` and
    `y_res` values would evaluate to 0 since we cannot get a real ratio using degrees.
    This is a result of us not being able to simply subtract coordinate *x* from coordinate
    *y* because the units are in degrees and not in a flat plane meters projection.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你的Shapefile投影必须是米为单位，而不是度。这一点非常重要，因为例如在EPSG:4326, WGS 84中，这将不会工作。原因在于坐标单位是经纬度。这意味着WGS84不是一个平面投影，不能直接绘制。我们的`x_res`和`y_res`值将评估为0，因为我们无法使用度来获得真实的比例。这是由于我们无法简单地从坐标*x*中减去坐标*y*，因为单位是度而不是平面米投影。
- en: Now, moving on to the raster setup, we define the type of raster we want to
    export as a `Gtiff`. Then, we'll get the correct GDAL driver by the raster type.
    Once the raster type is set, we can create a new empty raster dataset, passing
    in a raster filename, the width, the height of the raster in pixels, the number
    of raster bands, and finally, the type of rasters in GDAL terms, such as `gdal.GDT_Byte`.
    These five parameters are mandatory to create a new raster.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到栅格设置，我们定义要导出的栅格类型为`Gtiff`。然后，我们将通过栅格类型获取正确的GDAL驱动程序。一旦设置栅格类型，我们就可以创建一个新的空栅格数据集，传入栅格文件名、宽度、栅格的像素高度、栅格波段数，以及最后在GDAL术语中的栅格类型，例如`gdal.GDT_Byte`。这五个参数是创建新栅格的必填项。
- en: Next, we call `SetGeoTransform` that handles transforming between pixel/line
    raster space and projection coordinate space. We'll want to activate `band 1`
    as it is the only band we have in our raster. Then, we'll assign the no data value
    to all our empty space around a polygon.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`SetGeoTransform`，它处理像素/行栅格空间和投影坐标空间之间的转换。我们希望激活`波段1`，因为这是我们栅格中唯一的波段。然后，我们将所有围绕多边形的空空间分配为无数据值。
- en: The final step is to call the `gdal.RasterizeLayer()` function and pass in our
    new raster, band, Shapefile, and the value to assign to the inside of our raster.
    All the pixels inside the polygon will be assigned a value of 255.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是调用`gdal.RasterizeLayer()`函数，并传入我们的新栅格、波段、Shapefile以及分配给栅格内部的值。所有在多边形内部的像素将被分配值为255。
- en: See also
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you are interested, you can visit the `gdal_rasterize` command-line tool
    at [http://www.gdal.org/gdal_rasterize.html](http://www.gdal.org/gdal_rasterize.html).
    You can run this straight from the command line.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，可以访问`gdal_rasterize`命令行工具[http://www.gdal.org/gdal_rasterize.html](http://www.gdal.org/gdal_rasterize.html)。你可以直接从命令行运行它。
- en: Converting a raster (GeoTiff) to a vector (Shapefile) using GDAL
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GDAL将栅格（GeoTiff）转换为矢量（Shapefile）
- en: We have now looked at how we can go from a vector to a raster, so it is now
    time to go from a raster to a vector. This method is much more common because
    most of our vector data is derived from remotely sensed data, such as satellite
    images, orthophotos, or some other remote sensing dataset, such as `lidar`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何从矢量转换为栅格，现在是时候从栅格转换为矢量了。这种方法更为常见，因为我们的大部分矢量数据都来源于遥感数据，如卫星图像、正射影像或某些其他遥感数据集，如`lidar`。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As usual, enter the `workon pygeoan_cb` command in your Python virtual environment:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，在您的Python虚拟环境中输入`workon pygeoan_cb`命令：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This recipe only requires four steps utilizing OGR and GDAL so please open
    up a new file for your code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱只需要四个步骤利用OGR和GDAL，所以请为您的代码打开一个新文件：
- en: 'Import the `ogr` and `gdal` modules and go straight ahead and open the raster
    we want to convert by passing it the filename on disk and getting a raster band:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`ogr`和`gdal`模块，并直接打开我们想要转换的栅格，通过传递磁盘上的文件名并获取一个栅格波段：
- en: '[PRE29]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Set up the output vector file as a Shapefile with output_shp, and then get
    a Shapefile driver. Now, we can create the output from our driver and create a
    layer as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输出矢量文件设置为Shapefile格式，使用output_shp，然后获取一个Shapefile驱动程序。现在，我们可以从我们的驱动程序创建输出，并创建一个图层，如下所示：
- en: '[PRE30]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The final step is to run the `gdal.Polygonize` function that does the heavy
    lifting by converting our raster to a vector as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是运行`gdal.Polygonize`函数，它通过将我们的栅格转换为矢量来完成繁重的工作，如下所示：
- en: '[PRE31]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Execute the new script as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式执行新脚本：
- en: '[PRE32]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Working with `ogr` and `gdal` is similar in all our recipes; we must define
    the inputs and get an appropriate file driver to open the files. The GDAL library
    is very powerful and in only one line of code we can convert a raster to a vector
    with the help of the `gdal.Polygonize` function. The preceding code is simply
    setup code to define which format we want to work with and then set up an appropriate
    driver to input and output our new file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有我们的食谱中，使用`ogr`和`gdal`的方式相似；我们必须定义输入并获取适当的文件驱动程序来打开文件。GDAL库非常强大，我们只需一行代码就可以通过`gdal.Polygonize`函数将栅格转换为矢量。前面的代码仅仅是设置代码，用于定义我们想要使用哪种格式，然后设置适当的驱动程序来输入和输出我们的新文件。
- en: Creating a Shapefile from point data stored in Microsoft Excel
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从存储在Microsoft Excel中的点数据创建Shapefile
- en: Excel files are so common these days that often an analyst or developer receives
    an Excel file that needs to be mapped out. Sure, we could save these to a `.csv`
    file and then use the great Python standard *csv* module but this involves an
    extra manual step. We will take a look at how to read a very simple Excel file
    that contains a list of Europe's highest mountains. This data set is derived from
    [http://www.geonames.org](http://www.geonames.org).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Excel文件现在非常普遍，分析师或开发者经常收到需要映射的Excel文件。当然，我们可以将其保存为`.csv`文件，然后使用伟大的Python标准*csv*模块，但这需要额外的手动步骤。我们将看看如何读取一个包含欧洲最高山脉列表的非常简单的Excel文件。这个数据集来源于[http://www.geonames.org](http://www.geonames.org)。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to need one new Python library to read a Microsoft Excel file and
    this library is **xlrd** ([http://www.python-excel.org](http://www.python-excel.org)).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一个新Python库来读取Microsoft Excel文件，这个库是**xlrd** ([http://www.python-excel.org](http://www.python-excel.org))。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This library can only READ an Excel file; if you are looking to write out to
    an Excel file, download and install **xlwt**.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库只能读取Excel文件；如果您想要写入Excel文件，请下载并安装**xlwt**。
- en: First, fire up you virtual environment from your `workon pygeoan_cb` Linux machine,
    run `pip install xlrd`, and you are off to the races.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从您的`workon pygeoan_cb` Linux机器启动虚拟环境，运行`pip install xlrd`，然后您就可以开始比赛了。
- en: To write out to a new Shapefile, we will use the pyshp library we installed
    in [Chapter 1](ch01.html "Chapter 1. Setting Up Your Geospatial Python Environment"),
    *Setting Up Your Geospatial Python environment*, so that there is no need to do
    anything.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入新的Shapefile，我们将使用我们在[第1章](ch01.html "第1章。设置您的地理空间Python环境")中安装的pyshp库，这样就不需要做任何事情。
- en: The data is located in your downloads in `/ch03/geodata` and the output Shapefile
    will also be written to this location after you go through this recipe.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 数据位于您的下载目录中的`/ch03/geodata`，在您完成这个食谱后，输出Shapefile也将被写入这个位置。
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'So let''s get started with some code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从一些代码开始：
- en: 'Start with the import of `xlrd` and the pyshp module; note that the import
    name is `shapefile` and not pyshp as the module name would imply:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入`xlrd`和pyshp模块；注意导入名称是`shapefile`，而不是模块名称所暗示的pyshp：
- en: '[PRE33]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Open the Excel file using the xlrd module and create a variable to hold the
    Excel sheet. We reference the first sheet in the Excel file by an index number,
    always starting with (0) in the first sheet:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用xlrd模块打开Excel文件，并创建一个变量来保存Excel工作表。我们通过索引号引用Excel文件中的第一个工作表，始终从第一个工作表的(0)开始：
- en: '[PRE34]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create the Shapefile object as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式创建Shapefile对象：
- en: '[PRE35]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define the new Shapefile fields and their data types. *F* stands for float
    and *C* is for character:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义新的Shapefile字段及其数据类型。*F*代表浮点数，*C*代表字符：
- en: '[PRE36]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Loop through each row in the Excel file and create the geometry values along
    with attributes:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历Excel文件中的每一行，并创建几何值及其属性：
- en: '[PRE37]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Lastly, we''ll create the new Shapefile in the `/ch03/geodata` folder as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在`/ch03/geodata`文件夹中创建新的Shapefile，如下所示：
- en: '[PRE38]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Go ahead and execute our new `ch03-07_excel2shp.py` script from the command
    line as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式从命令行执行我们新的`ch03-07_excel2shp.py`脚本：
- en: '[PRE39]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Python code reads similar to making a description of how code works and
    is almost all too easy to explain. We start with importing our new *xlrd* module
    along with the Shapefile module needed to write out to a Shapefile. Taking a look
    at our Excel file, we see which fields are available and locate where the *X*
    coordinate (longitude) and *Y* coordinate (latitude) are positioned. This position
    index number remembers the starting point by counting from 0 for the first column.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码的阅读方式类似于描述代码的工作方式，而且几乎所有的解释都非常简单。我们首先导入新的*xlrd*模块以及写入Shapefile所需的Shapefile模块。查看我们的Excel文件，我们可以看到哪些字段可用，并定位到*x*坐标（经度）和*y*坐标（纬度）的位置。这个位置索引号通过从0开始计数来记住起始点。
- en: Our Excel file also has a header row and this is, of course, not to be included
    in the new data attributes; this is why we check to see whether row numbers are
    equal to 0—that is, the first row—and then continue. The continue statements allow
    the code to continue without an error and enter the `else` statement where we
    define the index positions of our columns. Each column is referenced using the
    `pyshp` syntax, referencing the columns by name to make the code even easier to
    read.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Excel文件还有一个标题行，当然，这个标题行不应该包含在新数据属性中；这就是为什么我们要检查行号是否等于0——即第一行——然后继续。continue语句允许代码继续执行而不会出错，并进入`else`语句，在那里我们定义列的索引位置。每个列都使用`pyshp`语法引用，通过名称引用列，使代码更容易阅读。
- en: We call the `w.point` pyshp function to create the point geometry passing in
    our x and y coordinates as floats. The `xlrd` module converts the values for us
    automatically into floats, which is nice. All we need to do in the end is use
    the pyshp save function to write out to our `/ch03/geodata` folder. There is no
    need to add the `.shp` extension; pyshp handles this for us and outputs `.shp`,
    `.dbf`, and `.shx`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`w.point` pyshp函数来创建点几何形状，传入我们的x和y坐标作为浮点数。`xlrd`模块会自动将值转换为浮点数，这很方便。我们最终需要做的只是使用pyshp的保存函数将数据写入我们的`/ch03/geodata`文件夹。不需要添加`.shp`扩展名；pyshp会为我们处理并输出`.shp`、`.dbf`和`.shx`。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that a `.prj` projection file is not automatically output. If you would
    like to have the projection information exported as well, you will need to manually
    create it like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`.prj`投影文件不会自动输出。如果您希望将投影信息一起导出，您需要手动创建它，如下所示：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Converting an ESRI ASCII DEM to an image height map
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将ESRI ASCII DEM转换为图像高度图
- en: To end this chapter with a bang, here is the most complicated conversion we
    have seen so far and the most fun as well. Input is an elevation dataset that's
    stored in *ASCII* format, more specifically, Arc/Info ASCII Grid, for short with
    the AAIGrid with the (`.asc`) file ending. Our output is a *heightmap* image ([http://en.wikipedia.org/wiki/Heightmap](http://en.wikipedia.org/wiki/Heightmap)).
    A heightmap image is an image that stores height elevation as a pixel value. A
    heightmap is also simply known as a **digital elevation model** (**DEM**). The
    benefit of using an image to store elevation data is that it is *web compatible*
    and we can use this in a 3D visualization with **threejs**, for example, as shown
    in [Chapter 10](ch10.html "Chapter 10. Visualizing Your Analysis"), *Visualizing
    Your Analysis*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这一章有一个圆满的结尾，这里是我们迄今为止见过的最复杂的转换，也是最有趣的。输入是一个存储在*ASCII*格式中的高程数据集，更具体地说，是Arc/Info
    ASCII Grid，简称AAIGrid，文件扩展名为(`.asc`)。我们的输出是一个*高度图*图像([http://en.wikipedia.org/wiki/Heightmap](http://en.wikipedia.org/wiki/Heightmap))。高度图图像是一种存储高度高程为像素值的图像。高度图也简单地称为**数字高程模型**(**DEM**)。使用图像存储高程数据的优点是它是*网络兼容的*，我们可以使用它进行3D可视化，例如，如[第10章](ch10.html
    "第10章。可视化您的分析")中所示，*可视化您的分析*。
- en: We need to be careful with regard to the output image format because simply
    storing an 8-bit image limits us to only storing 0 to 255 height values, which
    is typically not enough. The output image should store a minimum of 16-bits, giving
    us a range from -32,767 to 32,767\. If I am correct, the tallest mountain on earth
    is Mt. Everest at a height of 8,848 m, so a 16-bit image should be more than enough
    to hold our elevation data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要小心处理输出图像格式，因为仅仅存储8位图像将限制我们只能存储0到255的高度值，这通常是不够的。输出图像应存储至少16位，给我们一个从-32,767到32,767的范围。如果我是正确的，地球上最高的山是珠穆朗玛峰，高度为8,848米，所以16位图像应该足够存储我们的高程数据。
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A DEM is needed to run this exercise so please make sure you have downloaded
    the code and geodata included at [https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip](https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip)
    and download the sample DEM needed to process. You do not need to run your script
    from within your virtual environment because this script will be executing standard
    Python modules and several GDAL built-in tools installed with GDAL. This simply
    means that you need to make sure your GDAL utilities are properly installed and
    running on your machine. (Refer to [Chapter 2](ch02.html "Chapter 2. Working with
    Projections"), *Working with Projections*, for the reference installation.)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此练习需要一个DEM，请确保您已下载了包含在[https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip](https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip)中的代码和地理数据，并下载所需的示例DEM进行处理。您不需要在虚拟环境中运行您的脚本，因为此脚本将执行标准Python模块和与GDAL一起安装的几个GDAL内置工具。这仅仅意味着您需要确保您的GDAL实用程序已正确安装并在您的机器上运行。（有关参考安装，请参阅[第2章](ch02.html
    "第2章。处理投影")，*处理投影*。）
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will execute this script by calling several GDAL utility scripts installed
    by `gdal` from our Python script:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在Python脚本中调用由`gdal`安装的几个GDAL实用脚本来执行此脚本：
- en: 'We''ll start by importing the subprocess standard module; this will be used
    to execute our GDAL utility functions. Then, we''ll set the base path to where
    we will store our geodata for input files, temporary files, and output files:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先导入`subprocess`标准模块；这将用于执行我们的GDAL实用函数。然后，我们将设置基路径，我们将在这里存储我们的地理数据，包括输入文件、临时文件和输出文件：
- en: '[PRE41]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Windows users who have installed GDAL using the great OSGeo4w installer might
    want to specify the path directly to the GDAL utilities if it is not available
    in the Windows Environment variables as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用伟大的OSGeo4w安装程序安装GDAL的Windows用户可能希望直接指定GDAL实用程序的路径，如果它不在Windows环境变量中，如下所示：
- en: '[PRE42]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Linux users can use these variables:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux用户可以使用以下变量：
- en: '[PRE43]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We''ll create a set of variables to hold our input DEM, output files, temporary
    files, and our final output file. The variables concatenate the base path folder
    to the filename as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一组变量来存储我们的输入DEM、输出文件、临时文件以及我们的最终输出文件。这些变量将基路径文件夹与文件名连接起来，如下所示：
- en: '[PRE44]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we''ll call the `gdal_translate` command to create our new temporary
    GeoTiff as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将调用`gdal_translate`命令来创建我们的新临时GeoTiff，如下所示：
- en: '[PRE45]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we''ll open the temp GeoTiff and read the information about the tiff
    to find out the minimum and maximum height values stored in our data. This is
    not needed to complete the script but is very useful to identify your maximum
    and minimum height values:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将打开临时GeoTiff，读取关于tiff的信息，以找出存储在我们数据中的最小和最大高度值。这虽然不是完成脚本所必需的，但非常有用，可以帮助你识别最大和最小高度值：
- en: '[PRE46]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, call the gdal_translate utility with the following parameters, setting
    the scale range from its original min/max values to a new scale ranging from the
    0 to 65,535 values. Specify the `-ot` output type to be in the vENVI format using
    our temporary GeoTiff as the input:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下参数调用`gdal_translate`工具，将缩放范围从原始的最小/最大值设置为新的范围，从0到65,535个值。指定`-ot`输出类型为vENVI格式，使用我们的临时GeoTiff作为输入：
- en: '[PRE47]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s run our new `ch03-08_dem2heightmap.py` script from the command line:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从命令行运行我们新的`ch03-08_dem2heightmap.py`脚本：
- en: '[PRE48]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s run our new `ch03-08_dem2heightmap.py` script from the command line:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从命令行运行我们新的`ch03-08_dem2heightmap.py`脚本：
- en: '[PRE49]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The result is that you have a new .bin file located in your /ch03/geodata/ folder
    that stores your new ENVI 16-bit image including all your elevation data. The
    image height map can now be used in your 3D software, such as Blender ([www.blender.org](http://www.blender.org)),
    Unity ([www.unity3d.com](http://www.unity3d.com)), or in an even cooler web application
    using a JavaScript library such as `threejs`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，你会在/ch03/geodata/文件夹中找到一个名为.bin的新文件，该文件存储了你的新的ENVI 16位图像，包括所有你的高程数据。现在，这个高度图可以用于你的3D软件，例如Blender([www.blender.org](http://www.blender.org))、Unity([www.unity3d.com](http://www.unity3d.com))，或者在一个更酷的Web应用程序中使用JavaScript库，如`threejs`。
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's start with the imports, and then we'll specify the base path to where
    our inputs and outputs will be stored. After this, we'll see the actual commands
    we used to execute the `gdal_translate` transformation. The commands for Windows
    and Linux are for you to decide whether to use or not and this depends on how
    you have set up up your machine. We then set our variable to define the input
    DEM, temporary GeoTiff, and the output ENVI height map image.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入开始，然后指定我们的输入和输出存储的基本路径。之后，我们将看到实际使用的`gdal_translate`转换命令。Windows和Linux的命令由你自己决定是否使用，这取决于你如何设置你的机器。然后，我们设置变量来定义输入DEM、临时GeoTiff和输出ENVI高度图图像。
- en: At last, we can call the first transformation that converts our DEM ASCII file
    into a GeoTiff with the `gdal_translate` utility. Now to get a little information
    about our data, we print out the `min` and `max` height values to the screen.
    Sometimes, this is very useful when transforming, allowing you to check whether
    the output data actually contains the input height values and that nothing went
    astray during conversion.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`gdal_translate`工具将我们的DEM ASCII文件转换为GeoTiff格式的第一次转换。现在为了获取我们数据的一些信息，我们将最小和最大高度值打印到屏幕上。在转换过程中，这非常有用，可以让你检查输出数据是否确实包含了输入的高度值，并且在转换过程中没有出现错误。
- en: In the end, we simply call the `gdal_translate` utility once again to convert
    our GeoTiff into an ENVI heightmap image. The -scale with no parameters automatically
    fills our 16-bit image with values ranging from 0 to 65,535\. Our next parameter
    is `-ot`, which specifies the output type as 16-bit followed by `-outsize 500
    500`, setting the output image size to 500 x 500 pixels. Lastly, `-of ENVI` is
    our output format followed by the name of the input GeoTiff and the name of the
    output height map.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需再次调用`gdal_translate`工具，将我们的GeoTiff转换为ENVI高度图图像。`-scale`参数没有参数时，会自动将我们的16位图像填充为从0到65,535的值。下一个参数是`-ot`，指定输出类型为16位，后面跟着`-outsize
    500 500`，设置输出图像大小为500 x 500像素。最后，`-of ENVI`是我们的输出格式，后面跟着输入GeoTiff的名称和输出高度图的名称。
- en: 'A typical work flow when working with DEM''s is as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DEM时的一个典型工作流程如下：
- en: Download a DEM that is usually a very large file and covers a large geographic
    region.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载一个DEM，通常是一个非常大的文件，覆盖一个大的地理区域。
- en: Clip the DEM to a smaller region of interest.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将DEM裁剪到较小的感兴趣区域。
- en: Convert the clipped region to another format.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将裁剪区域转换为另一种格式。
- en: Export the DEM as a heightmap image.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将DEM导出为高度图图像。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We introduce `.split()` that will return a Python list of words, separated by
    a character. In our case, the separator character is a *single space* character
    but you could split based on any other character or a combination of characters
    (refer to the Python documentation at [https://docs.python.org/2/library/string.html#string.split](https://docs.python.org/2/library/string.html#string.split))
    This helps us reduce the amount of concatenating that we need to do in our code.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了 `.split()` 方法，它将返回一个由字符分隔的 Python 字符串列表。在我们的例子中，分隔字符是一个 *单个空格* 字符，但你也可以根据任何其他字符或字符组合进行分割（请参阅
    Python 文档中的[https://docs.python.org/2/library/string.html#string.split](https://docs.python.org/2/library/string.html#string.split)）。这有助于我们减少在代码中需要执行的连接操作数量。
