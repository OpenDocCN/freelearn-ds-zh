- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Combinatorial Optimization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合优化
- en: In this chapter, you will learn how genetic algorithms can be utilized in combinatorial
    optimization applications. We will start by describing search problems and combinatorial
    optimization, and outline several hands-on examples of combinatorial optimization
    problems. We will then analyze each of these problems and match them with Python-based
    solutions using the DEAP framework. The optimization problems we’ll cover are
    the well-known knapsack problem, the **traveling salesman problem** (**TSP**),
    and the **vehicle routing problem** (**VRP**). As a bonus, we will cover the topics
    of genotype-to-phenotype mapping and exploration versus exploitation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在组合优化应用中利用遗传算法。我们将首先描述搜索问题和组合优化，并概述几个组合优化问题的实际操作示例。接下来，我们将分析这些问题，并通过使用DEAP框架的Python解决方案进行匹配。我们将涉及的优化问题包括著名的背包问题、**旅行商问题**（**TSP**）和**车辆调度问题**（**VRP**）。此外，我们还将讲解基因型到表型的映射以及探索与开发的主题。
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够完成以下任务：
- en: Understand the nature of search problems and combinatorial optimization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解搜索问题和组合优化的性质
- en: Solve the knapsack problem using a genetic algorithm coded with the DEAP framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DEAP框架编写的遗传算法解决背包问题
- en: Solve the TSP using a genetic algorithm coded with the DEAP framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DEAP框架编写的遗传算法解决旅行商问题（TSP）
- en: Solve the VRP using a genetic algorithm coded with the DEAP framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DEAP框架编写的遗传算法解决车辆调度问题（VRP）
- en: Understand genotype-to-phenotype mapping
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基因型到表型的映射
- en: Gain familiarity with the concept of exploration versus exploitation and its
    relation to elitism
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉探索与开发的概念，并了解它与精英主义的关系
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will be using Python 3 with the following supporting libraries:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Python 3，并辅以以下支持库：
- en: '**deap**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**deap**'
- en: '**numpy**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**numpy**'
- en: '**matplotlib**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**matplotlib**'
- en: '**seaborn**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**seaborn**'
- en: Important note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you use the **requirements.txt** file provided (see [*Chapter 3*](B20851_03.xhtml#_idTextAnchor091)),
    these libraries will already be in your environment.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用提供的**requirements.txt**文件（见[*第3章*](B20851_03.xhtml#_idTextAnchor091)），这些库将已经安装在你的环境中。
- en: In addition, we will be using the benchmark data from the *Rosetta Code* ([https://rosettacode.org/wiki/Rosetta_Code](https://rosettacode.org/wiki/Rosetta_Code))
    and *TSPLIB* ([http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/](http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/))
    web pages.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将使用来自*Rosetta Code*（[https://rosettacode.org/wiki/Rosetta_Code](https://rosettacode.org/wiki/Rosetta_Code)）和*TSPLIB*（[http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/](http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/)）网页的基准数据。
- en: 'The programs that will be used in this chapter can be found in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_04](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_04).
    Check out the following video to see the Code in Action: [https://packt.link/OEBOd](https://packt.link/OEBOd)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用的程序可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_04](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_04)。查看以下视频，观看代码演示：[https://packt.link/OEBOd](https://packt.link/OEBOd)
- en: Search problems and combinatorial optimization
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索问题和组合优化
- en: One common area of applying genetic algorithms is *search problems*, which have
    important applications in fields such as logistics, operations, artificial intelligence,
    and machine learning. Examples include determining the optimal routes for package
    delivery, designing hub-based airline networks, managing investment portfolios,
    and assigning passengers to available drivers in a fleet of taxis.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法应用的一个常见领域是*搜索问题*，这些问题在物流、运营、人工智能和机器学习等领域具有重要应用。示例包括确定包裹投递的最佳路线、设计基于枢纽的航空网络、管理投资组合，以及将乘客分配给出租车车队中的可用司机。
- en: Search algorithms focus on solving a problem through methodic evaluation of
    **states** and **state transitions**, aiming to find a path from the initial state
    to a desirable final (or “goal”) state. Typically, there is a **cost** or a **gain**
    involved in every state transition, and the objective of the corresponding search
    algorithm is to find a path that minimizes the cost or maximizes the gain. Since
    the optimal path is one of many possible ones, this kind of search is related
    to *combinatorial optimization*, a topic that involves finding an optimal object
    from a finite, yet often extremely large, set of possible objects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索算法侧重于通过有序评估 **状态** 和 **状态转移** 来解决问题，目的是找到从初始状态到期望的最终（或“目标”）状态的路径。通常，每个状态转移都会涉及一个
    **成本** 或 **收益**，相应的搜索算法目标是找到一条最小化成本或最大化收益的路径。由于最优路径只是众多可能路径中的一种，这类搜索与 *组合优化* 相关，组合优化涉及从一个有限但通常极为庞大的可能对象集合中找到最优解。
- en: These concepts will be illustrated as we get acquainted with the *knapsack problem*,
    which is the main focus of the next section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念将在我们熟悉 *背包问题* 时得到说明，背包问题是下一节的主要内容。
- en: Solving the knapsack problem
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决背包问题
- en: Think of the familiar situation of packing for a long trip. There are many items
    that you would like to take with you, but you are limited by the capacity of your
    suitcase. In your mind, each item has a certain value it will add to your trip;
    at the same time, it has a size (and weight) associated with it, and it will compete
    with other items over the available space in your suitcase. This situation is
    just one of many real-life examples of the *knapsack problem*, which is considered
    one of the oldest and most investigated combinatorial search problems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个熟悉的场景——为一次长途旅行打包。你有许多想带上的物品，但受限于行李箱的容量。在你心中，每个物品都有一个它会给旅行带来的特定价值；同时，它也有与之相关的大小（和重量），并且它会与其他物品争夺行李箱中的有限空间。这种情况就是
    *背包问题* 的一种现实生活中的例子，背包问题被认为是最古老、最被研究的组合搜索问题之一。
- en: 'More formally, the knapsack problem consists of the following components:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，背包问题由以下几个部分组成：
- en: A set of **items**, each of them associated a certain **value** and a certain
    **weight**
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组 **物品**，每个物品都有一个特定的 **价值** 和 **重量**
- en: A **bag/sack/container** (the “knapsack”) of a certain **weight capacity**
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有特定 **重量容量** 的 **包/袋/容器**（“背包”）
- en: Our goal is to come up with a group of selected items that will provide the
    maximum total value, without exceeding the total weight capacity of the bag.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是选出一组物品，使得它们的总价值最大，同时不超过背包的总重量容量。
- en: In the context of search algorithms, each subset of the items represents a state,
    and the set of all possible item subsets is considered the state space. For an
    instance of the knapsack 0-1 problem with *n* items, the size of the state space
    is 2 n, which can quickly grow very large, even for a modest value of *n*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索算法的背景下，每个物品的子集代表一个状态，所有可能的物品子集的集合被称为状态空间。对于一个具有 *n* 个物品的背包0-1问题，状态空间的大小为2^n，随着
    *n* 值的增加，状态空间的大小会迅速增大，即使是一个适中的 *n* 值也会如此。
- en: In this (original) version of the problem, each item can only be included once
    or not at all, and therefore it is sometimes referred to as the **knapsack 0-1**
    problem. However, it can be expanded into other variants – for example, where
    items can be included multiple times (limited or unlimited) or where multiple
    knapsacks with varying capacities are present.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个（原始）版本的背包问题中，每个物品只能被选择一次，或者根本不被选择，因此它有时被称为 **背包0-1** 问题。然而，它可以扩展到其他变体——例如，物品可以多次（有限次或无限次）被选中，或者存在多个具有不同容量的背包。
- en: Applications of knapsack problems appear in many real-world processes that involve
    resource allocation and decision-making, such as selecting investments when building
    an investment portfolio, minimizing the waste when cutting raw materials, and
    getting the “most bang for your buck” when selecting which questions to answer
    in a timed test.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 背包问题的应用出现在许多实际过程当中，涉及资源分配和决策制定，例如在构建投资组合时选择投资、切割原材料时最小化浪费、以及在限时测试中选择哪些问题来解答，从而“花最少的钱得到最大的回报”。
- en: To get our hands dirty with a knapsack problem, we will look at a widely known
    example.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解背包问题，我们将看一个广为人知的例子。
- en: The Rosetta Code knapsack 0-1 problem
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rosetta Code 背包0-1问题
- en: The *Rosetta Code* website ([rosettacode.org](http://rosettacode.org)) provides
    a collection of programming tasks, each with solutions in numerous languages.
    One of these tasks, described at [rosettacode.org/wiki/Knapsack_problem/0-1](http://rosettacode.org/wiki/Knapsack_problem/0-1),
    is a knapsack 0-1 problem where a tourist needs to decide which items to pack
    for their weekend trip. The tourist has 22 items they can choose from; each item
    is assigned by the tourist with some value that represents its relative importance
    for the upcoming journey.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rosetta Code*网站（[rosettacode.org](http://rosettacode.org)）提供了一系列编程任务，每个任务都有多种语言的解决方案。其中一个任务描述了[rosettacode.org/wiki/Knapsack_problem/0-1](http://rosettacode.org/wiki/Knapsack_problem/0-1)中的背包0-1问题，任务要求一个游客决定在周末旅行中应该带哪些物品。游客可以从22个物品中选择，每个物品都有一个价值，表示它对即将进行的旅行的重要性。'
- en: 'The weight capacity of the tourist’s bag in this problem is **400**. The list
    of items, along with their associated values and weights, is provided in the following
    table:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题中游客背包的重量容量为**400**。物品列表及其对应的价值和重量列在下表中：
- en: '| **Item** | **Weight** | **Value** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **物品** | **重量** | **价值** |'
- en: '| --- | --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `map` | 9 | 150 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `map` | 9 | 150 |'
- en: '| `compass` | 13 | 35 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `compass` | 13 | 35 |'
- en: '| `water` | 153 | 200 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `water` | 153 | 200 |'
- en: '| `sandwich` | 50 | 160 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `sandwich` | 50 | 160 |'
- en: '| `glucose` | 15 | 60 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `glucose` | 15 | 60 |'
- en: '| `tin` | 68 | 45 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `tin` | 68 | 45 |'
- en: '| `banana` | 27 | 60 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `banana` | 27 | 60 |'
- en: '| `apple` | 39 | 40 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `apple` | 39 | 40 |'
- en: '| `cheese` | 23 | 30 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `cheese` | 23 | 30 |'
- en: '| `beer` | 52 | 10 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `beer` | 52 | 10 |'
- en: '| `suntan cream` | 11 | 70 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `suntan cream` | 11 | 70 |'
- en: '| `camera` | 32 | 30 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `camera` | 32 | 30 |'
- en: '| `T-shirt` | 24 | 15 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `T-shirt` | 24 | 15 |'
- en: '| `trousers` | 48 | 10 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `trousers` | 48 | 10 |'
- en: '| `umbrella` | 73 | 40 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `umbrella` | 73 | 40 |'
- en: '| `waterproof trousers` | 42 | 70 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `waterproof trousers` | 42 | 70 |'
- en: '| `waterproof overclothes` | 43 | 75 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `waterproof overclothes` | 43 | 75 |'
- en: '| `note-case` | 22 | 80 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `note-case` | 22 | 80 |'
- en: '| `sunglasses` | 7 | 20 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `sunglasses` | 7 | 20 |'
- en: '| `towel` | 18 | 12 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `towel` | 18 | 12 |'
- en: '| `socks` | 4 | 50 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `socks` | 4 | 50 |'
- en: '| `book` | 30 | 10 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `book` | 30 | 10 |'
- en: 'Table 4.1: A list of Rosetta Code knapsack 0-1 items'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1：Rosetta Code背包0-1物品列表
- en: Before we start solving this problem, we need to discuss one important matter
    – what’s a potential solution?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始解决这个问题之前，需要讨论一个重要问题——什么是潜在的解决方案？
- en: Solution representation
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案表示
- en: When solving the knapsack 0-1 problem, a straightforward way to represent a
    solution is using a list of binary values. Every entry in that list corresponds
    to one of the items in the problem. For the Rosetta Code problem, a solution can
    be represented using a list of 22 integers of the values `0` or `1`. A value of
    `1` represents picking the corresponding item, while a value of `0` means that
    the item hasn’t been picked. When applying the genetic algorithms approach, this
    list of binary values is going to be used as the chromosome.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决背包0-1问题时，一种直接表示解决方案的方法是使用一个二进制值列表。该列表中的每个条目对应问题中的一个物品。对于Rosetta Code问题，解决方案可以通过一个包含22个整数值为`0`或`1`的列表表示。值为`1`表示选择了相应的物品，而值为`0`则意味着该物品没有被选中。在应用遗传算法方法时，这个二进制值列表将作为染色体使用。
- en: However, we have to remember that the total weight of the chosen items cannot
    exceed the capacity of the knapsack. One way to incorporate this restriction into
    the solution is to wait until it gets evaluated. We then evaluate by adding the
    weights of the chosen items one by one, while ignoring any chosen item that will
    cause the accumulated weight to exceed the maximum allowed value. From the genetic
    algorithm’s point of view, this means that the chromosome representation of an
    individual (*genotype*) may not entirely express itself when it gets translated
    into the actual solution (*phenotype*) as some of the 1 values in the chromosome
    may be ignored. This situation is sometimes referred to as **genotype-to-phenotype
    mapping**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须记住，所选择物品的总重量不能超过背包的容量。将这个限制纳入解决方案的一种方法是，等到解决方案进行评估时再考虑这一点。然后，通过逐一添加所选物品的重量来进行评估，同时忽略任何会导致累积重量超过最大允许值的物品。从遗传算法的角度来看，这意味着个体的染色体表示（*基因型*）在转换为实际解决方案（*表现型*）时可能无法完全表达自己，因为染色体中的一些`1`值可能会被忽略。这种情况有时被称为**基因型到表现型的映射**。
- en: The solution representation we just discussed is implemented in the Python class
    described in the next subsection.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的解决方案表示法在下一个小节中描述的Python类中得到了实现。
- en: Python problem representation
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python问题表示
- en: To encapsulate the Rosetta Code knapsack 0-1 problem, we created a Python class
    called `Knapsack01Problem`. This class is contained in the `knapsack.py` file,
    which can be found at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/knapsack.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/knapsack.py).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了封装Rosetta Code的0-1背包问题，我们创建了一个名为`Knapsack01Problem`的Python类。这个类包含在`knapsack.py`文件中，文件可以在[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/knapsack.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/knapsack.py)找到。
- en: 'The class provides the following methods:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该类提供了以下方法：
- en: '**__init_data()**: This initializes the **RosettaCode.org** knapsack 0-1 problem
    data by creating a list of tuples. Each tuple contains the name of an item, followed
    by its weight and its value.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**__init_data()**：此方法通过创建一个元组列表来初始化**RosettaCode.org**的0-1背包问题数据。每个元组包含一个物品的名称，后面跟着它的重量和价值。'
- en: '**getValue(zeroOneList)**: This calculates the value of the chosen items in
    the list while ignoring items that will cause the accumulating weight to exceed
    the maximum weight.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getValue(zeroOneList)**：此方法计算列表中所选物品的价值，同时忽略那些会导致累计重量超过最大重量的物品。'
- en: '**printItems(zeroOneList)**: This prints the chosen items in the list while
    ignoring items that will cause the accumulating weight to exceed the maximum weight.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**printItems(zeroOneList)**：此方法打印出列表中选择的物品，同时忽略那些会导致累计重量超过最大重量的物品。'
- en: 'The `main()` method of the class creates an instance of the `Knapsack01Problem`
    class. It then creates a random solution and prints out its relevant information.
    If we run this class as a standalone Python program, a sample output may look
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类的`main()`方法创建了一个`Knapsack01Problem`类的实例。然后它创建一个随机解并打印出相关信息。如果我们将这个类作为独立的Python程序运行，示例输出可能如下所示：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the last occurrence of `1` in the random solution, representing the
    `note-case` item, fell victim to the *genotype-to-phenotype mapping* discussed
    in the previous subsection. As this item’s weight is 22, it would cause the total
    weight to exceed 400\. As a result, this item was not included in the solution.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在随机解中最后一次出现的`1`代表了`note-case`物品，这个物品遭遇了前一小节中讨论的*基因型到表型的映射*。由于该物品的重量为22，它会导致总重量超过400。因此，这个物品没有包含在解中。
- en: This random solution, as you may expect, is far from being optimal. Let’s try
    and find the optimal solution for this problem using a genetic algorithm.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个随机解，正如你所预期的，远非最优解。接下来，让我们尝试通过遗传算法找到这个问题的最优解。
- en: Genetic algorithm solution
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遗传算法解决方案
- en: To solve our knapsack 0-1 problem using a genetic algorithm, we created the
    `01-solve-knapsack.py` Python program located at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/01_solve_knapsack.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/01_solve_knapsack.py).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们的0-1背包问题，我们使用遗传算法创建了一个名为`01-solve-knapsack.py`的Python程序，该程序位于[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/01_solve_knapsack.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/01_solve_knapsack.py)。
- en: As a reminder, the chromosome representation we decided to use here is a list
    of integers with the values of 0 or 1\. This makes our problem, from the point
    of view of the genetic algorithm, similar to the OneMax problem we solved in the
    previous chapter. The genetic algorithm doesn’t care what the chromosome represents
    (also known as the *phenotype*) – a list of items to pack, a sequence of Boolean
    equation coefficients, or perhaps an actual binary number; it is only concerned
    with the chromosome itself (the *genotype*) and the fitness value of that chromosome.
    Mapping the chromosome to the solution it represents is carried out by the fitness
    evaluation function, which is implemented outside the genetic algorithm. In our
    case, this chromosome mapping and fitness calculation is implemented by the `getValue()`
    method, which is encapsulated within the `Knapsack01Problem` class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，我们决定在这里使用的染色体表示法是一个包含0或1值的整数列表。从遗传算法的角度来看，这使得我们的问题类似于前一章中我们解决的OneMax问题。遗传算法并不关心染色体表示的是什么（也称为*表现型*）——可能是一个要打包的物品列表，一组布尔方程的系数，或者一个实际的二进制数；它关心的只是染色体本身（*基因型*）以及该染色体的适应度值。将染色体映射到其代表的解是由适应度评估函数完成的，该函数在遗传算法之外实现。在我们的案例中，这个染色体映射和适应度计算是通过`getValue()`方法实现的，该方法被封装在`Knapsack01Problem`类中。
- en: The outcome of all this is that we can use the same genetic algorithm implementation
    that we used for the On-Max problem, with a few adaptations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的结果是，我们可以使用与之前解决One-Max问题相同的遗传算法实现，只需要做一些适配。
- en: 'The following steps describe the main points of our solution:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了我们解决方案的主要要点：
- en: 'First, we need to create an instance of the knapsack problem we would like
    to solve:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个我们希望解决的背包问题实例：
- en: '[PRE1]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we must instruct the genetic algorithm to use the **getValue()** method
    of that instance for fitness evaluation:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须指示遗传算法使用该实例的**getValue()**方法进行适应度评估：
- en: '[PRE2]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The genetic operators that are used are compatible with the binary-list chromosome:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用的遗传算子与二进制列表染色体兼容：
- en: '[PRE3]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the genetic algorithm stops, we can use the **printItems()** method to
    pretty-print the best solution that was found:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦遗传算法停止，我们可以使用**printItems()**方法打印出找到的最佳解：
- en: '[PRE4]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can also tweak some of the parameters of the genetic algorithm. As this particular
    problem uses a binary string of length 22, it seems easier than the 100-length
    OneMax problem we previously solved, so we can probably reduce the population
    size and maximum number of generations.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以调整遗传算法的某些参数。由于这个特定问题使用的是长度为22的二进制字符串，它似乎比我们之前解决的100长度的OneMax问题要简单，因此我们可能可以减少人口规模和最大代数。
- en: 'Upon running the algorithm for 50 generations, with a population size of 50,
    we get the following outcome:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在运行算法50代后，人口规模为50时，我们得到以下结果：
- en: '[PRE5]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The total value of `1030` is the known optimal solution for this problem.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`1030`的总值是该问题的已知最优解。'
- en: Here, too, we can see that the last occurrence of 1 in the chromosome of the
    best individual, representing the `book` item, was sacrificed to the actual solution
    in the mapping to keep the accumulated weight from exceeding the limit of 400.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们也可以看到，最佳个体染色体中表示`book`项的最后一个1的出现被牺牲，以便在映射到实际解时保持累计重量不超过400的限制。
- en: 'The following figure, which depicts the max and average fitness over the generations,
    indicates that the best solution was found in less than 10 generations:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了代际中的最大和平均适应度，表明最优解在不到10代的情况下就找到了：
- en: '![Figure 4.1: Stats of the program solving the knapsack 0-1 problem](img/B20851_04_01.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：解决背包 0-1 问题的程序统计数据](img/B20851_04_01.jpg)'
- en: 'Figure 4.1: Stats of the program solving the knapsack 0-1 problem'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：解决背包 0-1 问题的程序统计数据
- en: In the next section, we will shift gears and tackle a more involved, yet still
    classic, combinatorial search task known as the TSP.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将转向一个更复杂，但仍是经典的组合搜索任务，称为TSP。
- en: Solving the TSP
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决 TSP
- en: Imagine that you manage a small fulfillment center and need to deliver packages
    to a list of customers using a single vehicle. What’s the best route for the vehicle
    to take so that you can visit all your customers and then return to the starting
    point? This is an example of the classic **TSP**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你管理一个小型配送中心，需要用一辆车向一系列客户配送包裹。为了访问所有客户并返回起点，车辆应该走哪条最佳路线？这是经典的**TSP**问题的一个例子。
- en: 'The TSP dates back to 1930, and since then has been one of the most thoroughly
    studied problems in optimization. It is often used to benchmark optimization algorithms.
    The problem has many variants, but it was originally formulated after a traveling
    salesman who needs to take a trip that covers several cities:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: TSP起源于1930年，从那时起，它成为了最深入研究的优化问题之一。它常常被用来作为优化算法的基准。这个问题有许多变种，但最初是在描述一个旅行商需要进行一个覆盖多个城市的旅行时提出的：
- en: “Given a list of cities and the distances between each pair of the cities, find
    the shortest possible path that goes through all the cities and then returns to
    the starting city.”
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: “给定一个城市列表和每对城市之间的距离，找到一条尽可能短的路径，这条路径需要经过所有城市并最终返回起点城市。”
- en: Using combinatorics, you could find that when given *n* cities, the number of
    possible paths that go through all cities is (n − 1) !/ 2.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组合数学，你可以发现，当给定*n*个城市时，经过所有城市的可能路径数量是(n − 1)! / 2。
- en: 'The following figure shows the shortest path for the traveling salesperson
    problem that covers the 15 largest cities in Germany:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了覆盖德国15个最大城市的旅行商问题的最短路径：
- en: '![Figure 4.2: The shortest TSP path for the 15 largest cities in Germany. ](img/B20851_04_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：德国15个最大城市的最短TSP路径。](img/B20851_04_02.jpg)'
- en: 'Figure 4.2: The shortest TSP path for the 15 largest cities in Germany.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：德国15个最大城市的最短TSP路径。
- en: 'Source: [https://commons.wikimedia.org/wiki/File:TSP_Deutschland_3.png](https://commons.wikimedia.org/wiki/File:TSP_Deutschland_3.png).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '来源: [https://commons.wikimedia.org/wiki/File:TSP_Deutschland_3.png](https://commons.wikimedia.org/wiki/File:TSP_Deutschland_3.png)。'
- en: Image by Kapitän Nemo.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：Kapitän Nemo。
- en: In this case, *n=15*, so the number of possible routes is *14!/2*, which amounts
    to the staggering number of 43,589,145,600.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*n=15*，所以可能的路径数量是*14!/2*，这将是一个惊人的数字——43,589,145,600。
- en: In the context of search algorithms, each path (or partial path) through the
    cities represents a state, and the set of all possible paths is considered the
    state space. Each of the paths has a corresponding “cost” – the length (distance)
    of the path – and we are looking for the path that will minimize this distance.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索算法的背景下，每一条路径（或部分路径）代表一个状态，所有可能路径的集合被认为是状态空间。每条路径都有一个对应的“成本”——路径的长度（距离）——我们正在寻找的是能够最小化该距离的路径。
- en: As we pointed out, the state space is very large, even for a moderate number
    of cities, which can make it prohibitively expensive to evaluate every possible
    path. As a result, even though it is relatively easy to find a path that goes
    through all the cities, finding the *optimal* path can be very hard.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所指出的，即使对于适度数量的城市，状态空间也非常庞大，这可能使得评估每一条可能路径变得极其昂贵。因此，尽管相对容易找到一条经过所有城市的路径，找到*最优*路径却可能非常困难。
- en: TSPLIB benchmark files
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TSPLIB基准测试文件
- en: 'The **TSPLIB** is a library containing sample problems for the TSP based on
    the actual geographic locations of cities. The library is maintained by Heidelberg
    University, and relevant examples can be found here: [http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/](http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**TSPLIB**是一个包含基于城市实际地理位置的TSP样本问题的库。该库由海德堡大学维护，相关示例可以在此找到：[http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/](http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/)。'
- en: 'Two types of files can be found on this web page: files with the`.tsp.gz` suffix,
    each of them containing the description of a particular TSP problem, and the corresponding
    `.opt.tour.gz` files, containing the optimal solution for each problem.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个网页上可以找到两种类型的文件：带有`.tsp.gz`后缀的文件，每个文件描述了一个特定的TSP问题，以及对应的`.opt.tour.gz`文件，包含每个问题的最优解。
- en: 'The problem description files are text-based and white-space delimited. A typical
    file contains several informational lines, followed by city data. We are interested
    in files that include the x, y coordinates of the participating cities so that
    we can plot the cities and visualize their locations. For example, the contents
    of the `burma14.tsp.gz` file, once unzipped, look as follows (with some of the
    lines omitted here for brevity):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 问题描述文件是基于文本的，使用空格分隔。典型的文件包含几行信息，然后是城市数据。我们感兴趣的文件是包含参与城市的x、y坐标的文件，这样我们可以绘制城市并可视化它们的位置。例如，解压后的`burma14.tsp.gz`文件内容如下（此处省略了一些行以便简洁）：
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The interesting section for us is the lines between `NODE_COORD_SECTION` and
    `EOF`. In some of the files, `DISPLAY_DATA_SECTION` is used instead of `NODE_COORD_SECTION`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，最有趣的部分是`NODE_COORD_SECTION`和`EOF`之间的行。在一些文件中，`DISPLAY_DATA_SECTION`被用来代替`NODE_COORD_SECTION`。
- en: Are we ready to solve a sample problem? Well, before we start doing that, we
    still need to figure out how a potential solution will be represented. This will
    be addressed in the next subsection.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好解决一个示例问题了吗？好吧，在我们开始之前，我们仍然需要弄清楚如何表示潜在解。这将在下一小节中解决。
- en: Solution representation
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解的表示
- en: When solving the TSP, the cities are typically represented by numbers from 0
    to *n-1*, and possible solutions will be sequences of these numbers. A problem
    with five cities, for example, can have solutions of the form [0,1, 2, 3, 4],
    [2, 4, 3, 1, 0], and so on. Each solution can be evaluated by calculating and
    totaling the distances between each two subsequent cities, then adding the distance
    between the last city to the first one. Consequently, when applying the genetic
    algorithms approach to this problem, we can use a similar list of integers to
    serve as the chromosome.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决 TSP 时，城市通常用从 0 到 *n-1* 的数字表示，可能的解将是这些数字的序列。例如，一个有五个城市的问题，可能的解包括[0, 1, 2,
    3, 4]、[2, 4, 3, 1, 0]，依此类推。每个解可以通过计算并汇总每两个连续城市之间的距离，然后加上最后一个城市到第一个城市的距离来进行评估。因此，在应用遗传算法解决这个问题时，我们可以使用类似的整数列表来作为染色体。
- en: The Python class described in the next subsection reads the contents of TSPLIB
    files and calculates the distances between each two cities. In addition, it calculates
    the total distance covered by a given potential solution using the list representation
    we just discussed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节中描述的 Python 类读取 TSPLIB 文件的内容，并计算每两个城市之间的距离。此外，它还使用我们刚才讨论的列表表示法，计算给定潜在解的总距离。
- en: Python problem representation
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 问题表示
- en: To encapsulate the TSP problem, we’ve created a Python class called `TravelingSalesmanProblem`.
    This class is contained in the `tsp.py` file and can be found at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/tsp.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/tsp.py).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了封装 TSP 问题，我们创建了一个名为`TravelingSalesmanProblem`的 Python 类。该类包含在`tsp.py`文件中，您可以在[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/tsp.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/tsp.py)找到它。
- en: 'The class provides the following private methods:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该类提供以下私有方法：
- en: '**__create_data()**: This reads the desired TSPLIB file, extracts the coordinates
    of all cities, calculates the distances between every two cities, and uses them
    to populate a distance matrix (two-dimensional array). It then serializes the
    city locations and the calculated distances to disk using the **pickle** utility.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**__create_data()**：该方法读取所需的 TSPLIB 文件，提取所有城市的坐标，计算每两个城市之间的距离，并用它们填充一个距离矩阵（二位数组）。然后，它使用**pickle**工具将城市位置和计算出的距离序列化到磁盘中。'
- en: '**__read_data()**: This reads the serialized data and, if not available, calls
    **__create_data()** to prepare it.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**__read_data()**：该方法读取序列化数据，如果数据不可用，则调用**__create_data()**进行准备。'
- en: These methods are invoked internally by the constructor, so the data is initialized
    as soon as the instance is created.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法由构造函数内部调用，因此数据在实例创建时就会初始化。
- en: 'In addition, the class provides the following public methods:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该类还提供以下公共方法：
- en: '**getTotalDistance(indices)**: This calculates the total distance of the path
    described by the given list of city indices'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getTotalDistance(indices)**：该方法计算由给定城市索引列表描述的路径的总距离。'
- en: '**plotData(indices)**: This clots the path described by the given list of city
    indices'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**plotData(indices)**：该方法绘制由给定城市索引列表描述的路径。'
- en: 'The main method of the class exercises the class methods mentioned previously:
    first, it creates the `bayg29` problem (29 cities in Bavaria), then calculates
    the distance for the hard-coded optimal solution (as described in the matching
    `.opt.tour` file), and finally plots it. So, if we run this class as a standalone
    Python program, the output will be as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的主要方法执行了之前提到的类方法：首先，它创建了`bayg29`问题（巴伐利亚的29个城市），然后计算了硬编码的最优解的距离（如匹配的`.opt.tour`文件中所述），最后绘制出来。因此，如果我们将此类作为独立的
    Python 程序运行，输出将如下所示：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The plot of the optimal solution looks as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最优解的图如下所示：
- en: '![Figure 4.3: A plot of the optimal solution for the “bayg29” TSP. The red
    dots represent cities](img/B20851_04_03.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3：“bayg29” TSP的最优解的图示。红色的点代表城市](img/B20851_04_03.jpg)'
- en: 'Figure 4.3: A plot of the optimal solution for the “bayg29” TSP. The red dots
    represent cities'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：“bayg29” TSP的最优解的图示。红色的点代表城市
- en: Next, we will try to reach this optimal solution using a genetic algorithm.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试使用遗传算法达到这个最优解。
- en: Genetic algorithm solution
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遗传算法解决方案
- en: For our first attempt at solving the TSP using a genetic algorithm, we created
    the `02-solve-tsp-first-attempt.py` Python program, which is located at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/02_solve_tsp_first_attempt.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/02_solve_tsp_first_attempt.py).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们第一次尝试使用遗传算法解决TSP，我们创建了`02-solve-tsp-first-attempt.py` Python程序，位于[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/02_solve_tsp_first_attempt.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/02_solve_tsp_first_attempt.py)。
- en: 'The main parts of our solution are described in the following steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决方案的主要部分如下所述：
- en: 'The program starts by creating an instance of the **bayg29** problem, as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序通过创建**bayg29**问题的实例开始，如下所示：
- en: '[PRE8]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to define the fitness strategy. Here, we want to minimize the
    distance, which translates to a single-objective minimizing **fitness** class
    that’s defined using a single negative weight:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义适应度策略。在这里，我们希望最小化距离，这意味着一个单目标最小化的**fitness**类，该类通过一个单一的负权重来定义：
- en: '[PRE9]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: creator.create("Individual", array.array, typecode='i',
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: creator.create("Individual", array.array, typecode='i',
- en: fitness=creator.FitnessMin)
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: fitness=creator.FitnessMin)
- en: toolbox.register("randomOrder", random.sample,
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: toolbox.register("randomOrder", random.sample,
- en: range(len(tsp)), len(tsp))
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: range(len(tsp)), len(tsp))
- en: toolbox.register("individualCreator", tools.initIterate,
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: toolbox.register("individualCreator", tools.initIterate,
- en: creator.Individual, toolbox.randomOrder)
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: creator.Individual, toolbox.randomOrder)
- en: toolbox.register("populationCreator", tools.initRepeat, list,
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: toolbox.register("populationCreator", tools.initRepeat, list,
- en: toolbox.individualCreator)
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: toolbox.individualCreator)
- en: '[PRE10]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that the chromosome has been implemented, it’s time to define the fitness
    evaluation function. This is carried out by the **tspDistance()** function, which
    directly utilizes the **getTotalDistance()** method of the **TravelingSalesmanProblem**
    class:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，染色体已经实现，是时候定义适应度评估函数了。此操作由**tspDistance()**函数完成，它直接利用**TravelingSalesmanProblem**类的**getTotalDistance()**方法：
- en: '[PRE11]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to define the genetic operators. For the selection operator,
    we can use tournament selection with a tournament size of **3**, as we did in
    previous cases:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义遗传操作符。对于选择操作符，我们可以使用锦标赛选择，锦标赛的大小为**3**，就像我们在之前的案例中所做的那样：
- en: '[PRE12]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, before picking the crossover and mutation operators, we need to remember
    that the chromosome we use is not just a list of integers but a list of indices
    (or an **ordered list**) that represent the order of the cities, and therefore
    we cannot just mix parts of two lists or arbitrarily change an index in the list.
    Instead, we need to use specialized operators that were designed to produce valid
    lists of indices. In [*Chapter 2*](B20851_02.xhtml#_idTextAnchor053), *Understanding
    the Key Components of Genetic Algorithms*, we examined several of these operators,
    including **ordered crossover** and **scramble mutation**. Here, we’re using DEAP’s
    corresponding implementations of these operators, **cxOrdered** and **mutShuffleIndexes**:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在选择交叉和变异操作符之前，我们需要记住我们使用的染色体不仅仅是一个整数列表，而是一个表示城市顺序的索引列表（或**有序列表**），因此我们不能仅仅混合两个列表的部分或随意改变列表中的索引。相反，我们需要使用专门设计的操作符，这些操作符旨在生成有效的索引列表。在[*第二章*](B20851_02.xhtml#_idTextAnchor053)，*理解遗传算法的关键组成部分*中，我们探讨了其中的几个操作符，包括**有序交叉**和**打乱变异**。在这里，我们使用的是DEAP对这些操作符的相应实现，**cxOrdered**和**mutShuffleIndexes**：
- en: '[PRE13]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, it’s time to invoke the genetic algorithm flow. Here, we use the default
    DEAP built-in **eaSimple** algorithm, with our default **stats** and **halloffame**
    objects to provide information we can display later:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是时候调用遗传算法流程了。在这里，我们使用默认的DEAP内置**eaSimple**算法，并使用默认的**stats**和**halloffame**对象来提供我们稍后可以展示的信息：
- en: '[PRE14]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running this program with the constant values appearing at the top of the file
    (a population size of 300, 200 generations, a crossover probability of 0.9, and
    a mutation probability of 0.1) yields the following results:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件顶部出现的常量值运行此程序（种群大小为300，200代，交叉概率为0.9，突变概率为0.1），会得到以下结果：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The best fitness found (9549.98) is not too far from the known optimal distance
    of 9074.14.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所找到的最佳适应度（9549.98）与已知的最佳距离9074.14相差不远。
- en: 'The program then produces two plots. The first plot illustrates the path of
    the best individual found during the run:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 程序随后生成了两个图。第一个图展示了在运行过程中找到的最佳个体的路径：
- en: '![Figure 4.4: A plot of the best solution found by the first program attempting
    to solve the “bayg29” TSP](img/B20851_04_04.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4：第一个程序尝试解决“bayg29”TSP问题时找到的最佳解的图](img/B20851_04_04.jpg)'
- en: 'Figure 4.4: A plot of the best solution found by the first program attempting
    to solve the “bayg29” TSP'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：第一个程序尝试解决“bayg29”TSP问题时找到的最佳解的图
- en: 'The second plot shows the statistics of the genetic flow. Note that this time,
    we chose to collect data for the *minimum* fitness value rather than the maximum
    as the objective of this problem is to minimize the distance:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个图显示了遗传流的统计数据。注意，这次我们选择收集*最小*适应度值的数据，而不是最大值，因为该问题的目标是最小化距离：
- en: '![Figure 4.5: Stats of the first program attempting to solve the “bayg29” TSP](img/B20851_04_05.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5：第一个程序尝试解决“bayg29”TSP问题时的统计数据](img/B20851_04_05.jpg)'
- en: 'Figure 4.5: Stats of the first program attempting to solve the “bayg29” TSP'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：第一个程序尝试解决“bayg29”TSP问题时的统计数据
- en: Now that we’ve found a good solution but not the best-known one, we can try
    and figure out ways to improve the results. For example, we can experiment with
    changing the population size, number of generations, and probabilities. We can
    also replace the genetic operators with other compatible ones. We can even change
    the random seed we set just to see the effect on the results or make multiple
    runs with different seeds. In the next section, we will try to use **elitism**
    combined with **enhanced exploration** to improve our results.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了一个不错的解，但还不是最优解，我们可以尝试找出改进结果的方法。例如，我们可以尝试改变种群大小、代数和概率。我们还可以用其他兼容的遗传算子替代当前的遗传算子。我们甚至可以更改设置的随机种子，看看结果有何变化，或者使用不同的种子进行多次运行。在下一节中，我们将尝试结合**精英主义**和**增强探索**来改进我们的结果。
- en: Improving the results with enhanced exploration and elitism
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过增强探索和精英主义来改进结果
- en: 'If we try to increase the number of generations in the previous program, we
    will realize that the solution doesn’t improve – it’s stuck in the (somewhat)
    suboptimal solution that was reached sometime before generation 200\. This is
    shown in the following plot, which displays 500 generations:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试增加前一个程序中的代数，我们会发现解并没有改进——它停留在了大约200代之前达到的（稍微）次优解中。这一点在以下图中得到了展示，该图展示了500代的情况：
- en: '![Figure 4.6: Stats of the first program, running for 500 generations](img/B20851_04_06.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6：第一个程序运行500代的统计数据](img/B20851_04_06.jpg)'
- en: 'Figure 4.6: Stats of the first program, running for 500 generations'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：第一个程序运行500代的统计数据
- en: From that point on, the similarity between the average value and the best value
    indicates that this solution took over the population and therefore we will not
    see any improvement unless a lucky mutation turns up. In genetic algorithms terms,
    this means that **exploitation** has overpowered **exploration**. Exploitation
    generally means taking advantage of the current available results, while exploration
    emphasizes the search for new solutions. Striking a delicate balance between the
    two can lead to better results.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，平均值与最佳值之间的相似性表明该解已经主导了种群，因此，除非出现幸运的突变，否则我们将不会看到任何改进。在遗传算法的术语中，这意味着**开发**已经压倒了**探索**。开发通常意味着利用当前可得的结果，而探索则强调寻找新的解决方案。两者之间的微妙平衡可以带来更好的结果。
- en: 'One way to increase exploration could involve reducing the tournament size
    of the tournament selection that’s used from 3 to 2:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 增加探索的一个方法是将用于锦标赛选择的锦标赛大小从3减小到2：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we discussed in [*Chapter 2*](B20851_02.xhtml#_idTextAnchor053), *Understanding
    the Key Components of Genetic Algorithms*, this will increase the chances of less
    successful individuals being selected. These individuals may carry the key to
    better future solutions. However, if we run the same program after making this
    change, the results are far from impressive – the best fitness value is over 13,000,
    and the best solution plot looks as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第二章*](B20851_02.xhtml#_idTextAnchor053)《理解遗传算法的关键组成部分》中讨论的那样，这将增加选中较不成功个体的几率。这些个体可能带有更好的未来解的关键。然而，如果我们在做了这个更改后运行相同的程序，结果却远远不如预期——最佳适应度值超过了13,000，而最佳解的图形如下所示：
- en: '![Figure 4.7: A plot of the best solution found by the program with the tournament
    size reduced to 2](img/B20851_04_07.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7: 程序在锦标赛大小减少到2时找到的最佳解的图形](img/B20851_04_07.jpg)'
- en: 'Figure 4.7: A plot of the best solution found by the program with the tournament
    size reduced to 2'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：程序在锦标赛大小减少到2时找到的最佳解的图形
- en: 'These poor results can be explained using the statistics plot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不理想的结果可以通过统计图来解释：
- en: '![Figure 4.8: Stats of the program with the tournament size reduced to 2](img/B20851_04_08.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8: 经过调整后，程序的统计数据，锦标赛大小减少到2](img/B20851_04_08.jpg)'
- en: 'Figure 4.8: Stats of the program with the tournament size reduced to 2'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：程序的统计数据，锦标赛大小减少到2
- en: This plot illustrates that we cannot retain the best solutions. As evident from
    the “noisy” graph, which keeps jumping between better values to worse values,
    good solutions tend to quickly get “lost” due to the more permissive selection
    scheme, which often enables lesser solutions to be selected. This means that we
    let exploration go too far, and to balance it out, we need to re-introduce a measure
    of exploitation into the mix. This can be done using the **elitism** mechanism,
    which was first introduced in [*Chapter 2*](B20851_02.xhtml#_idTextAnchor053).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该图说明了我们无法保留最好的解。正如“嘈杂”的图形所示，图形在更好的值和更差的值之间不断波动，好的解容易因为更宽松的选择机制而迅速“丢失”，这种机制往往允许较差的解被选中。这意味着我们让探索过度进行，为了平衡这一点，我们需要重新引入一定的开发度。这可以通过使用**精英主义**机制来实现，精英主义首次在[*第二章*](B20851_02.xhtml#_idTextAnchor053)中介绍。
- en: Elitism enables us to keep the best solutions intact by letting them “skip”
    the genetic operators of selection, crossover, and mutation during the genetic
    flow. To implement elitism, we will have to go “under the hood” and modify DEAP’s
    `algorithms.eaSimple()` algorithm as the framework doesn’t provide a direct way
    to skip all three operators.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 精英主义使我们能够保持最好的解不变，允许它们在遗传过程中“跳过”选择、交叉和变异的遗传操作。为了实现精英主义，我们需要“深入底层”，修改DEAP的`algorithms.eaSimple()`算法，因为该框架没有提供直接跳过这三种操作的方法。
- en: The modified algorithm, called `eaSimpleWithElitism()`, can be found in the
    `elitism.py` file, located at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/elitism.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/elitism.py).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的算法，称为`eaSimpleWithElitism()`，可以在`elitism.py`文件中找到，文件位置在[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/elitism.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/elitism.py)。
- en: 'The `eaSimpleWithElitism()` method is similar to the original `eaSimple()`,
    with the modification that the `halloffame` object is now used to implement an
    elitism mechanism. The individuals contained in the `halloffame` object are directly
    injected into the next generation and are not subject to the genetic operators
    of selection, crossover, and mutation. This is essentially the outcome of the
    following modifications:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`eaSimpleWithElitism()`方法与原始的`eaSimple()`类似，唯一的修改是现在使用`halloffame`对象来实现精英机制。`halloffame`对象中包含的个体会直接被注入到下一代，并且不受选择、交叉和变异的遗传操作影响。这本质上是以下修改的结果：'
- en: 'Instead of selecting several individuals equal to the population size, this
    number of selected individuals is reduced by the number of hall-of-fame individuals:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择的个体数量不再等于种群大小，而是通过减少精英个体的数量来调整：
- en: '[PRE17]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After the genetic operators have been applied, the hall-of-fame individuals
    are added back into the population:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用了遗传操作后，精英个体被重新加入到种群中：
- en: '[PRE18]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can now replace the call to `algorithms.eaSimple()` with a call to `elitism.eaSimpleWithElitism()`,
    without changing any of the parameters. Then, we’ll set the `HALL_OF_FAME_SIZE`
    constant to 30, which means that we will always keep the best 30 individuals in
    the population.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将对 `algorithms.eaSimple()` 的调用替换为对 `elitism.eaSimpleWithElitism()` 的调用，而不改变任何参数。然后，我们将
    `HALL_OF_FAME_SIZE` 常量设置为30，这意味着我们将始终保持种群中最优秀的30个个体。
- en: The modified Python program, `03-solve-tsp.py` can be found at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/03_solve_tsp.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/03_solve_tsp.py).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的Python程序 `03-solve-tsp.py` 可以在 [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/03_solve_tsp.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/03_solve_tsp.py)
    找到。
- en: 'Upon running this new program, we are now able to hit the optimal solution:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个新程序后，我们现在能够达到最优解：
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The solution plot is identical to the optimal one we saw previously:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 解的图表与我们之前看到的最优解相同：
- en: '![Figure 4.9: A plot of the best solution found by the program using a tournament
    size of 2 and elitism](img/B20851_04_09.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9：使用2个锦标赛大小和精英主义的程序找到的最佳解的图表](img/B20851_04_09.jpg)'
- en: 'Figure 4.9: A plot of the best solution found by the program using a tournament
    size of 2 and elitism'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9：使用2个锦标赛大小和精英主义的程序找到的最佳解的图表
- en: 'The following statistics plot indicates that we were able to eliminate the
    “noise” we observed before. We were also able to keep some distance between the
    average value and the best values for a lot longer compared to the original attempt:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的统计图表表明，我们成功地消除了之前观察到的“噪声”。与原始尝试相比，我们还能够在更长的时间内保持平均值与最佳值之间的距离：
- en: '![Figure 4.10: Stats of the program using a tournament size of 2 and elitism](img/B20851_04_10.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10：使用2个锦标赛大小和精英主义的程序统计数据](img/B20851_04_10.jpg)'
- en: 'Figure 4.10: Stats of the program using a tournament size of 2 and elitism'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：使用2个锦标赛大小和精英主义的程序统计数据
- en: In the next section, we will look into the **VRP**, which adds an interesting
    twist to the problem we just solved.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论**VRP**，它为我们刚刚解决的问题增添了一个有趣的变化。
- en: Solving the VRP
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 求解VRP
- en: Imagine that you now manage a larger fulfillment center. You still need to deliver
    packages to a list of customers, but now, you have a fleet of several vehicles
    at your disposal. What’s the best way to deliver the packages to the customers
    using these vehicles?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你现在管理一个更大的配送中心。你仍然需要将包裹送到一份客户名单，但现在你可以使用一支多辆车组成的车队。怎样用这些车辆以最佳方式将包裹送到客户那里呢？
- en: 'This is an example of the VRP, a generalization of the TSP described in the
    previous section. The basic VRP consists of the following three components:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个VRP（车辆路径问题）的示例，它是上一节中描述的TSP（旅行商问题）的推广。基本的VRP包括以下三个组件：
- en: The list of locations that need to be visited
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要访问的地点列表
- en: The number of vehicles
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 车辆数量
- en: The location of the depot, which is used as the starting and ending point for
    each of the vehicles
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库的位置，用作每辆车的起点和终点
- en: The problem has numerous variations, such as several depot locations, time-critical
    deliveries, different types of vehicles (varying capacity, varying fuel consumption),
    and many more.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题有许多变种，例如多个仓库位置、时间敏感的交付、不同类型的车辆（不同的容量、不同的燃油消耗）等等。
- en: The goal of the problem is to minimize the cost, which can also be defined in
    many different ways. Examples include minimizing the time it takes to deliver
    all the packages, minimizing the cost of the fuel, and minimizing the variation
    in travel time among the vehicles used.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题的目标是最小化成本，而成本的定义可以有许多不同的方式。例如，包括最小化交付所有包裹所需的时间、最小化燃料成本以及最小化各车辆之间的旅行时间差异。
- en: 'An illustration of a VRP with three vehicles is shown here. The cities are
    marked with dark circles and the depot location with an empty square, while the
    routes of the three vehicles are marked with three different colors:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个带有三辆车的VRP示例。城市用黑色圆圈标记，仓库位置用空白方块标记，而三辆车的路线则用三种不同的颜色标记：
- en: '![Figure 4.11: Example VRP with three vehicles](img/B20851_04_11.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11：具有三辆车的VRP示例](img/B20851_04_11.jpg)'
- en: 'Figure 4.11: Example VRP with three vehicles'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：具有三辆车的VRP示例
- en: In our example, we will aim to optimize the time it takes to deliver all the
    packages. Since all the vehicles operate simultaneously, this measure is determined
    by the vehicle making the longest route. Therefore, we can make it our objective
    to minimize the length of the longest route among the participating vehicles’
    routes. For example, if we have three vehicles, each solution consists of three
    routes. We will evaluate all three, and then only consider the longest one of
    them for scoring – the longer the route, the worse the score. This will inherently
    encourage all three routes to be shorter, as well as closer in size to each other.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将以优化所有包裹的送达时间为目标。由于所有车辆同时运作，这一度量标准由执行最长路线的车辆决定。因此，我们可以将目标设定为最小化参与车辆中最长路线的长度。例如，如果我们有三辆车，每个解决方案包含三条路线，我们将评估这三条路线，然后只考虑其中最长的一条进行评分——路线越长，得分越差。这将本质上鼓励三条路线尽量变短，同时彼此的长度更接近。
- en: Thanks to the similarity between the two problems, we can utilize the code we
    wrote previously to solve the TSP for solving the VRP.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 得益于这两个问题的相似性，我们可以利用之前编写的代码来解决TSP问题，从而解决VRP问题。
- en: 'To build on the solution we created for the TSP, we can represent vehicle routing
    as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为TSP创建的解决方案基础上，我们可以按如下方式表示车辆路线：
- en: A TSP instance, namely a list of cities and their coordinates (or their mutual
    distances)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个TSP实例，即城市及其坐标的列表（或它们之间的相互距离）
- en: The depot location, which is selected out of the existing cities, and represented
    by the index of that city
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库位置，选择自现有城市，并用该城市的索引表示
- en: The number of vehicles used
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的车辆数量
- en: In the next two subsections, we will show you how to implement this solution.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个小节中，我们将向您展示如何实现这个解决方案。
- en: Solution representation
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案表示
- en: As usual, the first question we need to address is how to represent a solution
    to this problem.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们首先需要解决的问题是如何表示这个问题的解决方案。
- en: 'To illustrate our suggested representation, we will look at the 10-city example
    problem shown in the following figure, where the locations of the cities are marked
    with numbers from 0 to 9:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们建议的表示方法，我们将查看下图中的10城市示例问题，其中城市位置用从0到9的数字标记：
- en: '![Figure 4.12: Example VRP with numbered city locations](img/B20851_04_12.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12：带有编号城市位置的VRP示例](img/B20851_04_12.jpg)'
- en: 'Figure 4.12: Example VRP with numbered city locations'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：带有编号城市位置的VRP示例
- en: 'A creative way to represent a candidate VRP solution while maintaining similarity
    to the previously solved TSP is by using a list that contains the numbers from
    0 to *(n-1) + (m-1)*, where *n* is the number of cities and *m* is the number
    of vehicles. For example, if the number of cities is 10 and the number of vehicles
    is 3 (*n = 10, m = 3*), we would have a list containing all the integers from
    0 to 11, as shown here:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一种创造性地表示候选VRP解决方案的方法，同时保持与先前解决的TSP相似性，是使用一个包含从0到 *(n-1) + (m-1)* 的数字的列表，其中 *n*
    是城市的数量，*m* 是车辆的数量。例如，如果城市的数量是10，车辆的数量是3（*n = 10, m = 3*），我们将有一个包含从0到11的所有整数的列表，如下所示：
- en: '[0, 6, 8, 9, 11, 3, 4, 5, 7, 10, 1, 2]'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 6, 8, 9, 11, 3, 4, 5, 7, 10, 1, 2]'
- en: 'The first *n* integer values, which is 0...9 in our case, still represent the
    cities, just like before. However, the last *(m - 1)* integer values, 10 and 11
    in our case, are used as delimiters (or “separators”) that break the list into
    routes. As an example, [0, 6, 8, 9 **11**, 3, 4, 5, 7, **10**, 1, 2] will be broken
    into the following three routes:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前 *n* 个整数值，在我们的例子中是0...9，依然代表城市，和之前一样。然而，最后的 *(m - 1)* 个整数值，在我们的例子中是10和11，用作分隔符（或“分隔符”），将列表分成不同的路线。举个例子，[0,
    6, 8, 9 **11**, 3, 4, 5, 7, **10**, 1, 2]将被分成以下三条路线：
- en: '[0, 6, 8, 9], [3, 4, 5, 7], [1, 2]'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 6, 8, 9], [3, 4, 5, 7], [1, 2]'
- en: 'Next, the index of the depot location needs to be removed since it is not part
    of a particular route. If, for example, the depot location is index **7**, the
    resulting routes will be as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要移除仓库位置的索引，因为它不是特定路线的一部分。如果仓库位置的索引是 **7**，那么得到的路线将如下所示：
- en: '[0, 6, 8, 9], [3, 4, 5], [1, 2]'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 6, 8, 9], [3, 4, 5], [1, 2]'
- en: 'When calculating the distance that each route covers, we need to recall that
    each route starts and ends at the depot location (7). So, to calculate the distances,
    as well as plot the routes, we will be using the following data:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算每条路线所覆盖的距离时，我们需要记住，每条路线都是从仓库位置（7）出发并以该位置结束的。所以，为了计算距离并绘制路线，我们将使用以下数据：
- en: '[**7**, 0, 6, 8, 9, **7**], [**7**, 3, 4, 5, **7**], [**7**, 1, 2, **7**]'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[**7**, 0, 6, 8, 9, **7**], [**7**, 3, 4, 5, **7**], [**7**, 1, 2, **7**]'
- en: 'This candidate solution is illustrated in the following figure:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个候选解决方案在下图中有所体现：
- en: '![Figure 4.13: Visualization of the candidate solution [0, 6, 8, 9, 11, 3,
    4, 5, 7, 10, 1, 2]](img/B20851_04_13.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.13: Visualization of the candidate solution [0, 6, 8, 9, 11, 3,
    4, 5, 7, 10, 1, 2]](img/B20851_04_13.jpg)'
- en: 'Figure 4.13: Visualization of the candidate solution [0, 6, 8, 9, 11, 3, 4,
    5, 7, 10, 1, 2]'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '图4.13: 候选解决方案的可视化 [0, 6, 8, 9, 11, 3, 4, 5, 7, 10, 1, 2]'
- en: In the next subsection, we will look into a Python implementation of this idea.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将探讨这个思想的Python实现。
- en: Python problem representation
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python问题表示
- en: To encapsulate the VRP problem, we created a Python class called `VehicleRoutingProblem`.
    This class is contained in the `vrp.py` file and can be found at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/vrp.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/vrp.py).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了封装VRP问题，我们创建了一个名为`VehicleRoutingProblem`的Python类。此类包含在`vrp.py`文件中，可以在[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/vrp.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/vrp.py)找到。
- en: The `VehicleRoutingProblem` class contains an instance of the `TravelingSalesmanProblem`
    class, which is used as the container for the city indices and their corresponding
    locations and distances. When creating an instance of the `VehicleRoutingProblem`
    class, the instance of the underlying `TravelingSalesmanProblem` is created internally
    and initialized.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`VehicleRoutingProblem`类包含`TravelingSalesmanProblem`类的实例，后者用作包含城市索引及其对应位置和距离的容器。创建`VehicleRoutingProblem`类的实例时，内部会创建和初始化底层`TravelingSalesmanProblem`的实例。'
- en: The `VehicleRoutingProblem` class is initialized using the name of the underlying
    `TravelingSalesmanProblem`, as well as the depot location index and the number
    of vehicles.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用底层`TravelingSalesmanProblem`的名称以及仓库位置索引和车辆数量来初始化`VehicleRoutingProblem`类。
- en: 'In addition, The `VehicleRoutingProblem` class provides the following public
    methods:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`VehicleRoutingProblem`类提供以下公共方法：
- en: '**getRoutes(indices)**: This breaks the list of given indices into separate
    routes by detecting the “separator” indices'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getRoutes(indices)**: 这通过检测“分隔符”索引将给定索引列表分解为单独的路线'
- en: '**getRouteDistance(indices)**: This calculates total the distance of the path
    that starts at the depot location and goes through the cities described by the
    given indices'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getRouteDistance(indices)**: 这计算从仓库位置开始并经过给定索引描述的城市路径的总距离'
- en: '**getMaxDistance(indices)**: This calculates the max distance among the distances
    of the various paths described by the given indices, after breaking the indices
    to separate routes'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getMaxDistance(indices)**: 这在将索引分解为单独路线后，计算给定索引描述的各路径距离中的最大距离'
- en: '**getTotalDistance(indices)**: This calculates the combined distance of the
    various paths described by the given indices'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getTotalDistance(indices)**: 这计算由给定索引描述的各路径组合距离的总和'
- en: '**plotData(indices)**: This breaks the list of indices into separate routes
    and plots each route in a different color'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**plotData(indices)**: 这将索引列表分解为单独的路线并以不同颜色绘制每条路线'
- en: 'When executed as a standalone program, the `main` method of the class exercises
    these methods by creating an instance of `VehicleRoutingProblem` with the underlying
    TSP set to “bayg29” – the same problem we used in the previous section. The number
    of vehicles is set to 3, and the depot location index is set to 12 (which maps
    to a city with a central location). The following figure shows the locations of
    the cities (red dots) and the depot (green “x”):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为独立程序执行时，通过创建`VehicleRoutingProblem`类的实例并将其基础TSP设置为“bayg29”（与前一节中使用的相同问题）的`main`方法，运行这些方法。车辆数量设置为3，仓库位置索引设置为12（映射到一个具有中心位置的城市）。以下图显示了城市位置（红色点）和仓库（绿色“x”）的位置：
- en: '![Figure 4.14: A plot of the VRP based on the “bayg29” TSP. ](img/B20851_04_14.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.14: A plot of the VRP based on the “bayg29” TSP. ](img/B20851_04_14.jpg)'
- en: 'Figure 4.14: A plot of the VRP based on the “bayg29” TSP.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '图4.14: 基于“bayg29” TSP的VRP图表。'
- en: Red dots mark the cities while the green “X” marks the depot
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 红色点标记城市，绿色“X”标记仓库
- en: 'The main method then generates a random solution, breaks it down into routes,
    and calculates the distances, as shown here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，主方法生成一个随机解决方案，将其分解为路线，并计算距离，如下所示：
- en: '[PRE20]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note how the original list of indices of the random solution is broken down
    into separate routes using the separator indices (29 and 30). The plot for this
    random solution is shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，原始的随机解决方案索引列表是如何使用分隔符索引（29和30）被分解为独立的路线的。此随机解决方案的图形如下所示：
- en: '![Figure 4.15: A plot of a random solution for the VRP with three vehicles](img/B20851_04_15.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15：VRP三辆车的随机解决方案图](img/B20851_04_15.jpg)'
- en: 'Figure 4.15: A plot of a random solution for the VRP with three vehicles'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15：VRP三辆车的随机解决方案图
- en: As we would expect from a random solution, it is far from optimal. This is evident
    from the inefficient order of cities along the long (green) route, as well as
    one route (green) being much longer than the other two (red and purple).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从随机解决方案中预期的那样，它远未达到最优。这一点从长（绿色）路线中城市顺序的低效性以及一条路线（绿色）比另外两条（红色和紫色）明显更长可以看出。
- en: In the next subsection, we will attempt to produce good solutions using the
    genetic algorithms method.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将尝试使用遗传算法方法生成良好的解决方案。
- en: Genetic algorithm solution
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遗传算法解决方案
- en: The genetic algorithm solution we created for the VRP resides in the `04-solve-vrp.py`
    Python file located at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/04_solve_vrp.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/04_solve_vrp.py).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为VRP创建的遗传算法解决方案位于`04-solve-vrp.py` Python文件中，文件可以通过[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/04_solve_vrp.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/04_solve_vrp.py)访问。
- en: Since we were able to build on top of the TSP and used a similar representation
    for the solution – an array of indices – we could use the same genetic approach
    we used in the previous section. We could also take advantage of elitism by reusing
    the elitist version that we created for the genetic flow. This makes our genetic
    algorithm solution very similar to the one we used for the TSP.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们能够在TSP的基础上进行构建，并且使用了类似的解决方案表示方法——一个索引数组——我们可以使用与前一节相同的遗传算法方法。我们还可以通过重用为遗传流创建的精英版本来利用精英主义。这使得我们的遗传算法解决方案与我们为TSP所用的解决方案非常相似。
- en: 'The following steps detail the main parts of our solution:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤详细描述了我们解决方案的主要部分：
- en: 'The program starts by creating an instance of the **VehicleRoutingProblem**
    class, using the “bayg29” TSP for its underlying data, and setting the depot location
    to 12 and the number of vehicles to 3:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序通过创建**VehicleRoutingProblem**类的一个实例开始，使用“bayg29”TSP作为其底层数据，并将仓库位置设置为12，车辆数量设置为3：
- en: '[PRE21]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The fitness function is set to minimize the distance of the longest route among
    the three routes produced by each solution:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适应度函数设置为最小化三条路线中最长路线的距离：
- en: '[PRE22]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the genetic operators, we once again use tournament selection with a tournament
    size of 2, which is assisted by the elitist approach, and crossover and mutation
    operators that are specialized for ordered lists:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于遗传操作符，我们再次使用锦标赛选择，锦标赛大小为2，并辅以精英主义方法，以及专门针对有序列表的交叉和变异操作符：
- en: '[PRE23]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As the VRP is inherently more difficult than TSP, we chose a larger population
    size and number of generations than before:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于VRP本质上比TSP更为复杂，我们选择了比之前更大的种群规模和更高的代数：
- en: '[PRE24]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And that’s it! We’re ready to run the program. The results that we obtain with
    these settings are shown here – three routes, with a maximum length of `3857`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们准备好运行程序了。我们通过这些设置得到的结果如下：三条路线，最长路线长度为`3857`：
- en: '[PRE25]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note, again, how the solution is broken down into three separate routes using
    the highest two indices (29, 30) as separators, and ignoring the depot location
    (12). We ended up with three routes, two of them covering nine cities each, and
    the third covering 10 cities.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，解决方案是如何被分解为三条独立的路线的，使用最高的两个索引（29，30）作为分隔符，并忽略了仓库位置（12）。最终我们得到了三条路线，其中两条覆盖了九个城市，第三条覆盖了十个城市。
- en: 'Plotting the solution produces the following figure depicting the three resulting
    routes:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制解决方案时，得到以下图形，显示了三条结果路线：
- en: '![Figure 4.16: A plot of the best solution found by the program for the VRP
    with three vehicles](img/B20851_04_16.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16：程序为VRP三辆车找到的最佳解决方案图](img/B20851_04_16.jpg)'
- en: 'Figure 4.16: A plot of the best solution found by the program for the VRP with
    three vehicles'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16：程序为VRP三辆车找到的最佳解决方案图
- en: 'The following statistics plot shows that the algorithm did most of the optimization
    before reaching 300 generations. After, there are several small improvements:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示的统计数据表明，算法在达到 300 代之前进行了大部分优化。之后，有几个小幅改进：
- en: '![Figure 4.17: Stats of the program solving the VRP with three vehicles](img/B20851_04_17.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.17：使用三辆车解决 VRP 程序的统计数据](img/B20851_04_17.jpg)'
- en: 'Figure 4.17: Stats of the program solving the VRP with three vehicles'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17：使用三辆车解决 VRP 程序的统计数据
- en: 'How about changing the number of vehicles? Let’s run the algorithm again after
    increasing the number of vehicles to six, and making no other changes:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果改变车辆数量呢？让我们在不做其他更改的情况下，将车辆数量增加到六并重新运行算法：
- en: '[PRE26]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The results for this run are shown here – six routes, with a maximum length
    of `2803`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本次运行的结果如下所示——六条路线，最大长度为`2803`：
- en: '[PRE27]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that increasing the number of vehicles two-fold didn’t decrease the maximum
    distance in a similar manner (`2803` with six compared to `3857` with three).
    This is likely because each separate route still needs to start and end at the
    depot location, which is added to the cities in the route.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，增加车辆数量两倍并没有以相似的方式减少最大距离（六辆车的`2803`与三辆车的`3857`相比）。这可能是因为每条单独的路线仍然需要在仓库位置开始和结束，这个位置也算在路线的城市之中。
- en: 'Plotting the solution produces the following figure, depicting the six resulting
    routes:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制解决方案后，得到下图，展示了六条结果路线：
- en: '![Figure 4.18: A plot of the best solution found by the program for the VRP
    with six vehicles](img/B20851_04_18.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.18：程序为六辆车解决 VRP 所找到的最佳解决方案图](img/B20851_04_18.jpg)'
- en: 'Figure 4.18: A plot of the best solution found by the program for the VRP with
    six vehicles'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18：程序为六辆车解决 VRP 所找到的最佳解决方案图
- en: One interesting point demonstrated by this plot is that the orange route doesn’t
    seem to be optimized. Since we told the genetic algorithm to minimize the longest
    route, any route that is shorter than the longest route may not be optimized further.
    You are encouraged to modify our solution to further optimize the routes.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表展示的一个有趣点是，橙色路线似乎没有被优化。由于我们告诉遗传算法最小化最长路线，任何比最长路线短的路线可能不会进一步优化。鼓励你修改我们的解决方案，以进一步优化这些路线。
- en: 'As with the three-vehicle case, the following statistics plot shows that the
    algorithm did most of the optimization before reaching 200 generations, after
    which there are several small improvements:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 与三辆车的情况类似，下图展示的统计数据表明，算法在达到 200 代之前做了大部分优化，之后出现了几个小幅改进：
- en: '![Figure 4.19: Stats of the program solving the VRP with six vehicles](img/B20851_04_19.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.19：使用六辆车解决 VRP 程序的统计数据](img/B20851_04_19.jpg)'
- en: 'Figure 4.19: Stats of the program solving the VRP with six vehicles'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19：使用六辆车解决 VRP 程序的统计数据
- en: The solution we’ve found seems reasonable. Can we do better than that? What
    about other numbers of vehicles? Or other depot locations? Different genetic operators
    or different parameter settings? Perhaps even a different fitness criteria? We
    encourage you to experiment with all these and learn from these experiments.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到的解决方案似乎是合理的。我们能做得更好吗？如果使用其他数量的车辆呢？或者其他仓库位置呢？不同的遗传操作符或不同的参数设置呢？甚至是不同的适应度标准？我们鼓励你尝试这些并从实验中学习。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you were introduced to search problems and combinatorial optimization.
    We then closely examined three classic combinatorial problems – each with numerous
    real-life applications – the knapsack problem, the TSP, and the VRP. For Each
    of these problems, we followed a similar process of finding an appropriate representation
    for a solution, creating a class that encapsulates the problem and evaluates a
    given solution, and then creating a genetic algorithm solution that utilizes that
    class. We ended up with valid solutions for all three problems while experimenting
    with genotype-to-phenotype mapping and elitism-backed exploration.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了搜索问题和组合优化问题。然后，我们深入研究了三类经典的组合问题——它们在现实生活中有着广泛的应用——背包问题、旅行商问题（TSP）和车辆路径问题（VRP）。对于每个问题，我们都采用了类似的过程：找到一个合适的解决方案表示，创建一个封装问题并评估给定解决方案的类，然后创建一个利用该类的遗传算法解决方案。通过实验基因型到表现型的映射和精英主义支持的探索，我们为这三个问题都得到了有效的解决方案。
- en: In the next chapter, we will look into a family of closely related tasks, namely
    *constraint satisfaction problems*, starting with the classic *n-queens* problem.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究一类密切相关的任务，即*约束满足问题*，从经典的*n-皇后问题*开始。
- en: Further reading
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, please refer to the following resources:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请参考以下资源：
- en: Solving the knapsack problem using dynamic programming, from the book *Keras
    Reinforcement Learning Projects*, by Giuseppe Ciaburro, September 2018
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态规划解决背包问题，摘自Giuseppe Ciaburro的《*Keras强化学习项目*》，2018年9月
- en: The VRP, from the book *Keras Reinforcement Learning Projects*, by Giuseppe
    Ciaburro, September 2018
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VRP，摘自Giuseppe Ciaburro的《*Keras强化学习项目*》，2018年9月
