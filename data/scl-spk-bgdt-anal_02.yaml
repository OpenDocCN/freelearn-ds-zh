- en: Object-Oriented Scala
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 的面向对象
- en: '*"The object-oriented model makes it easy to build up programs by accretion.
    What this often means, in practice, is that it provides a structured way to write
    spaghetti code."*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*"面向对象模型使得通过积累来构建程序变得容易。在实践中，这经常意味着它提供了一种结构化的方式来编写意大利面代码。"*'
- en: '- Paul Graham'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 保罗·格雷厄姆'
- en: In the previous chapter, we looked at how to get programming started with Scala.
    Well, if you're writing the procedural program that we followed in the previous
    chapter, you can enforce the code reusability by creating procedures or functions.
    However, if you continue working, consequently, your program gets longer, bigger,
    and more complex. At a certain point, you will not even have any other more simple
    way to organize the entire code before production.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到如何开始使用 Scala 进行编程。如果你正在编写我们在前一章中遵循的过程式程序，你可以通过创建过程或函数来强化代码的可重用性。然而，随着工作的继续，你的程序变得越来越长、越来越大、越来越复杂。在某一点上，你甚至可能没有其他更简单的方法在生产之前组织整个代码。
- en: On the contrary, the **object-oriented programming** (**OOP**) paradigm provides
    a whole new layer of abstraction. You can then modularize your code through defining
    OOP entities such as classes with related properties and methods. You can even
    define the relationship between those entities by utilizing inheritance or an
    interface. You can also group similar classes holding similar functionality together,
    as a helper class maybe; therefore, making your project suddenly feels more spacious
    and extensible. In short, the greatest strengths of OOP languages are discoverability,
    modularity, and extensibility.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，**面向对象编程**（**OOP**）范式提供了一个全新的抽象层次。通过定义类似属性和方法的 OOP 实体，你可以模块化你的代码。甚至可以通过继承或接口定义这些实体之间的关系。你还可以将功能相似的类分组在一起，例如辅助类；从而使你的项目突然感觉更加宽敞和可扩展。总之，OOP
    语言的最大优势在于可发现性、模块化和可扩展性。
- en: 'Considering the preceding features of OOP languages, in this chapter, we will
    discuss the basic object-oriented features in Scala. In a nutshell, the following
    topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前述面向对象编程语言的特点，在本章中，我们将讨论 Scala 中的基本面向对象特性。简而言之，本章将涵盖以下主题：
- en: Variables in Scala
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 中的变量
- en: Methods, classes, and objects in Scala
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 中的方法、类和对象
- en: Packages and package objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包和包对象
- en: Traits and trait linearization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征和特征线性化
- en: Java Interoperability
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 互操作性
- en: Then, we will discuss pattern matching, which is a feature that comes from functional
    programming concepts. Moreover, we will discuss some built-in concepts in Scala,
    such as implicit and generics. Finally, we will discuss some widely used build
    tools that are needed for building our Scala applications into jars.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将讨论模式匹配，这是来自函数式编程概念的一个特性。此外，我们还将讨论 Scala 中的一些内置概念，如隐式和泛型。最后，我们将讨论一些广泛使用的构建工具，这些工具用于将我们的
    Scala 应用程序构建为 JAR 文件。
- en: Variables in Scala
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 中的变量
- en: 'Before entering into the depth of OOP features, first, we need to know details
    about the different types of variables and data types in Scala. To declare a variable
    in Scala, you need to use `var` or `val` keywords. The formal syntax of declaring
    a variable in Scala is as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论面向对象编程（**OOP**）特性之前，首先我们需要了解 Scala 中不同类型的变量和数据类型的细节。在 Scala 中声明变量，你需要使用
    `var` 或 `val` 关键字。Scala 中声明变量的形式语法如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For example, let''s see how can we declare two variables whose data types are
    explicitly specified as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看如何声明两个显式指定数据类型的变量：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can even just declare a variable without specifying the `DataType`. For
    example, let''s see how to declare a variable using `val` or `var`, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以只声明一个不指定 `DataType` 的变量。例如，让我们看看如何使用 `val` 或 `var` 来声明变量，如下所示：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are two types of variables in Scala: mutable and immutable that can be
    defined as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中有两种类型的变量：可变变量和不可变变量，可以如下定义：
- en: '**Mutable:** The ones whose values you can change later'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可变变量：** 可以稍后更改其值的变量'
- en: '**Immutable:** The ones whose values you cannot change once they have been
    set'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变变量：** 一旦设置了值就不能更改其值的变量'
- en: 'In general, for declaring a mutable variable, a `var` keyword is used. On the
    other hand, for specifying an immutable variable, a `val` keyword is used. To
    show an example of using the mutable and immutable variables, let''s consider
    the following code segment:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，为了声明一个可变变量，会使用 `var` 关键字。另一方面，为了指定一个不可变变量，会使用 `val` 关键字。为了展示使用可变和不可变变量的示例，让我们考虑以下代码段：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code works fine until `myVar = 90`, since **`myVar`** is a mutable
    variable. However, if you try to change the value of the immutable variable (that
    is, `myVal`), as shown earlier, your IDE will show a compilation error saying
    reassignment to `val`, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在 `myVar = 90` 之前可以正常工作，因为 **`myVar`** 是一个可变变量。然而，如果你尝试更改不可变变量（即 `myVal`）的值，如前所示，IDE
    会显示编译错误，提示“不能重新赋值给 `val`”，如下所示：
- en: '![](img/00202.jpeg)**Figure 1:** Reassignment of immutable variables is not
    allowed in Scala variable scope'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00202.jpeg)**图 1：** 不可变变量的重新赋值在 Scala 变量作用域中是不允许的'
- en: Don't worry looking at the preceding code with the object and method! We will
    discuss classes, methods, and objects later in this chapter, then things will
    become more clear.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心看到前面的代码中包含对象和方法！我们将在本章稍后讨论类、方法和对象，届时一切都会变得更加清晰。
- en: 'In Scala variables, we can have three different scopes, depending on the place
    where you have declared them:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中的变量，我们可以有三种不同的作用域，这取决于你声明它们的位置：
- en: '**Fields:** These are variables that belong to an instance of a class of your
    Scala code. The fields are, therefore, accessible from inside every method in
    the object. However, depending on the access modifiers, fields can be accessible
    to instances of the other classes.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段：** 这些是属于 Scala 代码中类的实例的变量。因此，字段可以从对象的每个方法内部访问。然而，取决于访问修饰符，字段也可以被其他类的实例访问。'
- en: As discussed earlier, object fields can be mutable or they can be immutable
    (based on the declaration types using either `var` or `val`). But, they can't
    be both at the same time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，对象字段可以是可变的，也可以是不可变的（基于声明类型，使用 `var` 或 `val`）。但它们不能同时是两者。
- en: '**Method arguments:** These are variables, and when the method is called, these
    can be used to pass the value inside a method. Method parameters are accessible
    only from inside the method. However, the objects being passed in may be accessible
    from the outside.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法参数：** 这些是变量，当方法被调用时，可以用来传递值到方法内部。方法参数只能在方法内部访问。然而，传递的对象可能从外部被访问。'
- en: It is to be noted that method parameters/arguments are always immutable, no
    matter what is/are the keyword(s) specified.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，方法的参数/参数总是不可变的，无论指定了什么关键字。
- en: '**Local variables:** These variables are declared inside a method and are accessible
    from the inside the method itself. However, the calling code can access the returned
    value.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部变量：** 这些变量是在方法内部声明的，只能在方法内部访问。然而，调用代码可以访问返回值。'
- en: Reference versus value immutability
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用与值的不可变性
- en: 'According to the section earlier, `val` is used to declare immutable variables,
    so can we change the values of these variables? Will it be similar to the final
    keyword in Java? To help us understand more about this, we will use the following
    code snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的部分，`val` 用于声明不可变变量，那么我们能否更改这些变量的值？这是否与 Java 中的 `final` 关键字类似？为了帮助我们更好地理解这一点，我们将使用以下代码示例：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you run the preceding code, an error at compilation time will be noticed,
    which will tell you that you are trying to reassign to a `val` variable. In general,
    mutable variables bring a performance advantage. The reason is that this is closer
    to how the computer behaves and because introducing immutable values forces the
    computer to create a whole new instance of an object whenever a change (no matter
    how small) to a particular instance is required
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，会发现编译时出现错误，提示你正在尝试重新赋值给 `val` 变量。通常，可变变量带来性能上的优势。原因是，这更接近计算机的行为方式，并且引入不可变值会强制计算机每次需要对特定实例进行更改（无论多么微小）时，都创建一个新的对象实例。
- en: Data types in Scala
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 中的数据类型
- en: 'As mentioned, Scala is a JVM language, so it shares lots in common with Java.
    One of these commonalities is the data types; Scala shares the same data types
    with Java. In short, Scala has all the same data types as Java, with the same
    memory footprint and precision. As mentioned in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, objects are almost everywhere in Scala. and all data
    types are objects and you can call methods in them as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Scala 是一种 JVM 语言，因此与 Java 有很多相似之处。这些相似性之一就是数据类型；Scala 与 Java 共享相同的数据类型。简而言之，Scala
    具有与 Java 相同的数据类型，内存占用和精度相同。如在[第1章](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c)《Scala简介》中提到，*Scala
    中几乎到处都有对象*，所有数据类型都是对象，你可以在它们中调用方法，如下所示：
- en: '| **Sr.No** | **Data Type and Description** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **序号** | **数据类型及描述** |'
- en: '| 1 | **Byte**: 8 bit signed value. Ranges from -128 to 127 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **Byte**：8 位有符号值，范围从 -128 到 127 |'
- en: '| 2 | **Short**: 16 bit signed value. Ranges -32768 to 32767 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **Short**：16 位有符号值，范围从 -32768 到 32767 |'
- en: '| 3 | **Int**: 32 bit signed value. Ranges -2147483648 to 2147483647 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **Int**：32 位有符号值，范围从 -2147483648 到 2147483647 |'
- en: '| 4 | **Long**: 64 bit signed value. -9223372036854775808 to 9223372036854775807
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **Long**：64 位有符号值，范围从 -9223372036854775808 到 9223372036854775807 |'
- en: '| 5 | **Float**: 32 bit IEEE 754 single-precision float |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **Float**：32 位 IEEE 754 单精度浮点数 |'
- en: '| 6 | **Double**: 64 bit IEEE 754 double-precision float |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **Double**：64 位 IEEE 754 双精度浮点数 |'
- en: '| 7 | **Char**: 16 bit unsigned Unicode character. Range from U+0000 to U+FFFF
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 7 | **Char**：16 位无符号 Unicode 字符，范围从 U+0000 到 U+FFFF |'
- en: '| 8 | **String**: A sequence of Chars |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 8 | **String**：一串字符 |'
- en: '| 9 | **Boolean**: Either the literal `true` or the literal `false` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 9 | **Boolean**：要么是字面值 `true`，要么是字面值 `false` |'
- en: '| 10 | **Unit**: Corresponds to no value |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 10 | **Unit**：对应于没有值 |'
- en: '| 11 | **Null**: Null or empty reference |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 11 | **Null**：空引用 |'
- en: '| 12 | **Nothing**: The subtype of every other type; includes no values |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 12 | **Nothing**：每个其他类型的子类型；不包括任何值 |'
- en: '| 13 | **Any**: The supertype of any type; any object is of type *Any* |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 13 | **Any**：任何类型的超类型；任何对象的类型都是 *Any* |'
- en: '| 14 | **AnyRef**: The supertype of any reference type |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 14 | **AnyRef**：任何引用类型的超类型 |'
- en: '**Table 1:** Scala data types, description, and range'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 1：** Scala 数据类型、描述和范围'
- en: All the data types listed in the preceding table are objects. However, note
    that there are no primitive types, as in Java. This means that you can call methods
    on an `Int`, `Long`, and so on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上面表格中列出的所有数据类型都是对象。然而，请注意，Scala 中没有像 Java 那样的原始数据类型。这意味着你可以在 `Int`、`Long` 等类型上调用方法。
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you can start playing around with these variables. Let's get some ideas
    on how to initialize a variable and work on the type annotations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始玩这些变量了。让我们来看看如何初始化一个变量并进行类型注解。
- en: Variable initialization
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量初始化
- en: 'In Scala, it''s a good practice to initialize the variables once declared.
    However, it is to be noted that uninitialized variables aren''t necessarily nulls
    (consider types like `Int`, `Long`, `Double`, `Char`, and so on), and initialized
    variables aren''t necessarily non-null (for example, `val s: String = null`).
    The actual reasons are that:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Scala 中，初始化变量后再使用它是一种良好的实践。然而，需要注意的是，未初始化的变量不一定是 `null`（考虑像 `Int`、`Long`、`Double`、`Char`
    等类型），而已初始化的变量也不一定是非 `null`（例如，`val s: String = null`）。实际原因是：'
- en: 'In Scala, types are inferred from the assigned value. This means that a value
    must be assigned for the compiler to infer the type (how should the compiler consider
    this code: `val a`? Since a value isn''t given, the compiler can''t infer the
    type; since it can''t infer the type, it wouldn''t know how to initialize it).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Scala 中，类型是从赋予的值中推断出来的。这意味着必须赋值，编译器才能推断出类型（如果代码是 `val a`，编译器无法推断出类型，因为没有赋值，编译器无法初始化它）。
- en: In Scala, most of the time, you'll use `val`. Since these are immutable, you
    wouldn't be able to declare them and then initialize them afterward.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Scala 中，大多数时候你会使用 `val`。由于这些是不可变的，因此你不能先声明再初始化它们。
- en: 'Although, Scala language requires you to initialize your instance variable
    before using it, Scala does not provide a default value for your variable. Instead,
    you have to set up its value manually using the wildcard underscore, which acts
    like a default value, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Scala 语言要求你在使用实例变量之前初始化它，但 Scala 并不会为你的变量提供默认值。相反，你必须手动设置它的值，可以使用通配符下划线 `_`，它类似于默认值，如下所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Instead of using the names, such as `val1`, `val2` and so on, you can define
    your own names:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用像 `val1`、`val2` 这样的名称，你可以定义自己的名称：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can use these names in subsequent expressions, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在后续的表达式中使用这些名称，如下所示：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Type annotations
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型注解
- en: If you use a `val` or `var` keyword to declare a variable, its data type will
    be inferred automatically according to the value that you assigned to this variable.
    You also have the luxury of explicitly stating the data type of the variable at
    declaration time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `val` 或 `var` 关键字声明一个变量，它的数据类型会根据你赋给这个变量的值自动推断。你也可以在声明时显式地指定变量的数据类型。
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, let's look at some other aspects that will be needed while working with
    variables and data types in Scala. We will see how to work with type ascription
    and `lazy` variables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看在使用 Scala 中的变量和数据类型时，需要注意的其他方面。我们将看到如何使用类型说明和 `lazy` 变量。
- en: Type ascription
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型说明
- en: 'Type ascription is used to tell the compiler what types you expect out of an
    expression, from all possible valid types. Consequently, a type is valid if it
    respects existing constraints, such as variance and type declarations, and it
    is either one of the types the expression it applies to "is a," or there''s a
    conversion that applies in scope. So, technically, `java.lang.String` extends
    `java.lang.Object`, therefore any `String` is also an `Object`. For example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类型赋值用于告诉编译器你期望表达式的类型是哪些，从所有可能的有效类型中选择。因此，类型是有效的，前提是它符合现有的约束条件，比如变异性和类型声明，并且它要么是表达式所适用类型的某种类型，要么在作用域内有适用的转换。所以，从技术上讲，`java.lang.String`
    扩展自 `java.lang.Object`，因此任何 `String` 也是一个 `Object`。例如：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Lazy val
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟值（Lazy val）
- en: 'The main characteristic of a `lazy val` is that the bound expression is not
    evaluated immediately, but once on the first access. Here''s where the main difference
    between `val` and `lazy val` lies. When the initial access happens, the expression
    is evaluated and the result is bound to the identifier, the `lazy val`. On subsequent
    access, no further evaluation occurs, instead, the stored result is returned immediately.
    Let''s see an interesting example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy val` 的主要特征是绑定的表达式不会立即计算，而是在首次访问时计算。这就是 `val` 和 `lazy val` 之间的主要区别。当第一次访问发生时，表达式会被计算，结果会绑定到标识符
    `lazy val` 上。之后的访问不会再次计算，而是立即返回已存储的结果。我们来看一个有趣的例子：'
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you look at the preceding code in Scala REPL, you will notice that the code
    runs very well without throwing any errors, even though you divided an integer
    with 0! Let''s see a better example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 Scala REPL 中的前面的代码，你会注意到即使你把整数除以 0，代码也能运行得很好，不会抛出任何错误！让我们看一个更好的例子：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This works and, later on, you can access the value of variable `x` when required.
    These are just a few examples of using lazy `val` concepts. Interested readers
    should access this page for more details: [https://blog.codecentric.de/en/2016/02/lazy-vals-scala-look-hood/.](https://blog.codecentric.de/en/2016/02/lazy-vals-scala-look-hood/)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能正常工作，之后你可以在需要时访问变量 `x` 的值。这些只是使用 `lazy val` 概念的一些例子。有兴趣的读者可以访问这个页面以了解更多详细信息：[https://blog.codecentric.de/en/2016/02/lazy-vals-scala-look-hood/.](https://blog.codecentric.de/en/2016/02/lazy-vals-scala-look-hood/)
- en: Methods, classes, and objects in Scala
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 中的方法、类和对象
- en: In the previous section, we saw how to work with Scala variables, different
    data types and their mutability and immutability, along with their usages scopes.
    However, in this section, to get the real flavor of the OOP concept, we are going
    to deal with methods, objects, and classes. These three features of Scala will
    help us understand the object-oriented nature of Scala and its features.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何处理 Scala 变量、不同的数据类型及其可变性和不可变性，以及它们的使用范围。然而，在本节中，为了更好地理解面向对象编程（OOP）的概念，我们将涉及方法、对象和类。Scala
    的这三个特性将帮助我们理解其面向对象的本质及其功能。
- en: Methods in Scala
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 中的方法
- en: 'In this part, we are going to talk about methods in Scala. As you dive into
    Scala, you''ll find that there are lots of ways to define methods in Scala. We
    will demonstrate them in some of these ways:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将讨论 Scala 中的方法。当你深入了解 Scala 时，你会发现有很多种方式可以定义方法。我们将通过以下几种方式来演示它们：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding declaration of the method takes two variables and returns the
    smallest among them. In Scala, all the methods must start with the def keyword,
    which is then followed by a name for this method. Optionally, you can decide not
    to pass any parameters to the method or even decide not to return anything. You''re
    probably wondering how the smallest value is returned, but we will get to this
    later. Also, in Scala, you can define methods without curly braces:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面声明的方法接受两个变量并返回其中的最小值。在 Scala 中，所有方法都必须以 `def` 关键字开头，接着是该方法的名称。你可以选择不向方法传递任何参数，甚至可以选择不返回任何内容。你可能会想知道最小值是如何返回的，但我们稍后会讲到这个问题。此外，在
    Scala 中，你可以在不使用大括号的情况下定义方法：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If your method has a small body, you can declare your method like this. Otherwise,
    it''s preferred to use the curly braces in order to avoid confusion. As mentioned
    earlier, you can pass no parameters to the method if needed:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的方法体很小，你可以像这样声明方法。否则，建议使用大括号以避免混淆。如前所述，如果需要，你可以选择不向方法传递任何参数：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A method with or without parentheses signals the absence or presence of a side
    effect. Moreover, it has a deep connection with the uniform access principle.
    Thus, you can also avoid the braces as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 带有或不带括号的方法表明是否有副作用。此外，它与统一访问原则有着深刻的联系。因此，你也可以像下面这样避免使用大括号：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are also some methods which return the value by explicitly mentioning
    the return types. For example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些方法通过明确指定返回类型来返回值。例如：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It should be mentioned that the preceding code works due to the Scala compiler,
    which is able to infer the return type, just as with values and variables.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 应该提到，前面的代码之所以能够正常工作，是因为 Scala 编译器能够推断返回类型，就像对待值和变量一样。
- en: 'This will return `Hello` concatenated with the passed person name. For example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 `Hello` 和传入的姓名拼接在一起。例如：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The return in Scala
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 中的返回值
- en: 'Before learning how a Scala method returns a value, let''s recap the structure
    of a method in Scala:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习 Scala 方法如何返回值之前，让我们回顾一下 Scala 方法的结构：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the preceding syntax, the return type could be any valid Scala data type
    and a list of parameters will be a list of variables separated by a comma and
    a list of parameters and return type is optional. Now, let''s define a method
    that adds two positive integers and returns the result, which is also an integer
    value:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的语法，返回类型可以是任何有效的 Scala 数据类型，参数列表将是以逗号分隔的变量列表，参数和返回类型是可选的。现在，让我们定义一个方法，添加两个正整数并返回结果，这个结果也是一个整数值：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you now call the preceding method from the `main()` method with the real
    values, such as `addInt(10, 30)`, the method will return an integer value sum,
    which is equal to `40`. As using the keyword `return` is optional, the Scala compiler
    is designed such that the last assignment will be returned with the absence of
    the `return` keyword. As in this situation, the greater value will be returned:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在从 `main()` 方法调用前面的方法，并传入实际的值，比如 `addInt(10, 30)`，方法将返回一个整数值的和，结果是 `40`。由于使用
    `return` 关键字是可选的，Scala 编译器设计成当没有 `return` 关键字时，最后一个赋值会作为返回值。在这种情况下，更大的值将被返回：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Well done! We have seen how to use variables and how to declare a method in
    Scala REPL. Now, its time to see how to encapsulate them inside Scala methods
    and classes. The next section discusses Scala objects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！我们已经看到了如何使用变量以及如何在 Scala REPL 中声明方法。现在，接下来我们将看到如何将它们封装在 Scala 方法和类中。下一部分将讨论
    Scala 对象。
- en: Classes in Scala
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 中的类
- en: 'Classes are considered as a blueprint and then you instantiate this class in
    order to create something that will actually be represented in memory. They can
    contain methods, values, variables, types, objects, traits, and classes which
    are collectively called **members**. Let''s demonstrate this with the following
    example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 类被视为蓝图，然后你实例化这个类以创建一个实际在内存中表示的对象。它们可以包含方法、值、变量、类型、对象、特征和类，这些统称为**成员**。让我们通过以下示例来演示：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have two variables `animalName` and `animalAge` with their setters and getters.
    Now, how do we use them to solve our purpose? Here come the usages of Scala objects.
    Now, we will discuss Scala objects, then we will trace back to our next discussion.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个变量`animalName`和`animalAge`，以及它们的 setter 和 getter。现在，如何使用它们来实现我们的目标呢？这就涉及到
    Scala 对象的使用。接下来我们将讨论 Scala 对象，然后再回到我们的下一个讨论。
- en: Objects in Scala
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 中的对象
- en: 'An **object** in Scala has a slightly different meaning than the traditional
    OOP one, and this difference should be explained. In particular, in OOP, an object
    is an instance of a class, while in Scala, anything that is declared as an object
    cannot be instantiated! The `object` is a keyword in Scala. The basic syntax for
    declaring an object in Scala is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中的 **对象** 的含义与传统面向对象编程中的对象略有不同，这一点需要说明。特别地，在面向对象编程中，对象是类的实例，而在 Scala 中，声明为对象的任何东西都不能被实例化！`object`
    是 Scala 中的一个关键字。声明 Scala 对象的基本语法如下：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To understand the preceding syntax, let''s revisit the hello world program:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解前面的语法，让我们回顾一下 hello world 程序：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This hello world example is pretty similar to the Java ones. The only big difference
    is that the main method is not inside a class, but instead it''s inside an object.
    In Scala, the keyword object can mean two different things:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 hello world 示例与 Java 的类似。唯一的巨大区别是主方法不在类内部，而是放在对象内部。在 Scala 中，`object` 关键字可以表示两种不同的含义：
- en: As in OOP, an object can represent an instance of a class
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如在面向对象编程中，一个对象可以表示一个类的实例
- en: A keyword for depicting a very different type of instance object called **Singleton**
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示非常不同类型实例对象的关键字称为**单例模式**
- en: Singleton and companion objects
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例和伴生对象
- en: 'In this subsection, we will see a comparative analysis between the singleton
    object in Scala and Java. The idea beneath the singleton pattern is to have an
    implementation that makes sure that only a single instance of a class can exist.
    Here''s an example of the Singleton pattern in Java:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一小节中，我们将看到Scala中的单例对象与Java之间的对比分析。单例模式的核心思想是确保一个类只有一个实例可以存在。以下是Java中单例模式的一个示例：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The Scala object does a similar thing, and it''s well taken care of by the
    compiler. Since there will be only one instance, there is no way for object creation
    here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Scala对象做了类似的事情，且由编译器很好地处理。由于只有一个实例，因此这里不能进行对象创建：
- en: '![](img/00215.jpeg)**Figure 3:** Object creation in Scala'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00215.jpeg)**图3：** Scala中的对象创建'
- en: Companion objects
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伴生对象
- en: 'When a `singleton object` is named the same as a class, it is called a `companion
    object`. A companion object must be defined inside the same source file as the
    class. Let''s demonstrate this with the example here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个`singleton object`与类同名时，它被称为`companion object`。伴生对象必须在与类相同的源文件中定义。让我们通过以下示例来演示这一点：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is the way that you will call methods through the companion object
    (preferably with the same name - that is, `Animal`):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过伴生对象调用方法的方式（最好使用相同的名称——即`Animal`）：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A Java equivalent would be very similar, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Java等效的实现会非常相似，如下所示：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Well done! So far, we have seen how to work with Scala objects and classes.
    However, working with the method for implementing and solving your data analytics
    problem is even more important. Thus, we will now see how to work with Scala methods
    in brief.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！到目前为止，我们已经了解了如何使用Scala的对象和类。然而，更重要的是如何使用方法来实现和解决数据分析问题。因此，接下来我们将简要地了解如何使用Scala方法。
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, let's have a brief overview on the accessibility and the visibility of
    the Scala classes in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一节中简要概述一下Scala类的可访问性和可见性。
- en: 'Comparing and contrasting: val and final'
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较与对比：val和final
- en: 'Just like Java, the final keyword also exists in Scala, which works somehow
    similar to the val keyword. In order to differentiate between the `val` and `final`
    keywords in Scala, let''s declare a simple animal class, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Java一样，`final`关键字在Scala中也存在，其作用与`val`关键字有些相似。为了区分Scala中的`val`和`final`关键字，让我们声明一个简单的动物类，如下所示：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As mentioned in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, while listing Scala features, Scala can override variables
    which don''t exist in Java:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c)《Scala简介》中所述，在列出Scala特性时，Scala可以重载在Java中不存在的变量：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, before going deeper, a quick discussion on the keyword `extends` is a mandate.
    Refer to the following information box for details.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在深入讨论之前，有必要快速讨论一下`extends`关键字。详细信息请参考下面的信息框。
- en: 'Using Scala, classes can be extensible. A subclass mechanism using the extends
    keyword makes it possible to *specialize* a class by inheriting all members of
    a given *superclass* and defining additional class members. Let''s look at an
    example, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Scala时，类是可扩展的。通过`extends`关键字的子类机制，可以通过继承给定的*超类*的所有成员，并定义额外的类成员，从而使类变得*特化*。让我们看一个示例，如下所示：
- en: '`class Coordinate(xc: Int, yc: Int) {`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`class Coordinate(xc: Int, yc: Int) {`'
- en: '`val x: Int = xc`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`val x: Int = xc`'
- en: '`val y: Int = yc`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`val y: Int = yc`'
- en: '`def move(dx: Int, dy: Int): Coordinate = new Coordinate(x + dx, y + dy)`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`def move(dx: Int, dy: Int): Coordinate = new Coordinate(x + dx, y + dy)`'
- en: '`}`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`class ColorCoordinate(u: Int, v: Int, c: String) extends Coordinate(u, v)
    {`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`class ColorCoordinate(u: Int, v: Int, c: String) extends Coordinate(u, v)
    {`'
- en: '`val color: String = c`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`val color: String = c`'
- en: '`def compareWith(pt: ColorCoordinate): Boolean = (pt.x == x) && (pt.y == y)
    && (pt.color == color)`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`def compareWith(pt: ColorCoordinate): Boolean = (pt.x == x) && (pt.y == y)
    && (pt.color == color)`'
- en: '`override def move(dx: Int, dy: Int): ColorCoordinate = new ColorCoordinate(x
    + dy, y + dy, color)`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`override def move(dx: Int, dy: Int): ColorCoordinate = new ColorCoordinate(x
    + dy, y + dy, color)`'
- en: '`}`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: 'However, if we declared the age variable as final in the `Animal` class, then
    the `Cat` class will not be able to override it, and it will give the following
    error. For this `Animal` example, you should have learned when to use the `final`
    keyword. Let''s see an example of this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们在 `Animal` 类中将年龄变量声明为 `final`，那么 `Cat` 类将无法重写它，会产生以下错误。对于这个 `Animal`
    示例，你应该学会何时使用 `final` 关键字。让我们看一个例子：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Well done! To achieve the best encapsulation - also called information hiding
    - you should always declare methods with the least visibility that works. In the
    next subsection, we will learn how the access and visibility of classes, companion
    objects, packages, subclasses, and projects work.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！为了实现最佳的封装 - 也称为信息隐藏 - 你应该始终用最少可行的可见性声明方法。在下一小节中，我们将学习类、伴生对象、包、子类和项目的访问和可见性如何工作。
- en: Access and visibility
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问和可见性
- en: 'In this subsection, we will try to understand the access and visibility of
    Scala variables and different data types in the OOP paradigm. Let''s have a look
    at access modifiers in Scala. A similar one for Scala:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一小节中，我们将试图理解 Scala 变量在面向对象编程范式中的访问和可见性。让我们看看 Scala 中的访问修饰符。Scala 的一个类似的例子：
- en: '| **Modifier** | **Class** | **Companion Object** | **Package** | **Subclass**
    | **Project** |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **修饰符** | **类** | **伴生对象** | **包** | **子类** | **项目** |'
- en: '| Default/No modifier | Yes | Yes | Yes | Yes | Yes |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 默认/无修饰符 | 是 | 是 | 是 | 是 | 是 |'
- en: '| Protected | Yes | Yes | Yes | No | No |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 受保护 | 是 | 是 | 是 | 否 | 否 |'
- en: '| Private | Yes | Yes | No | No | No |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 私有 | 是 | 是 | 否 | 否 | 否 |'
- en: '**Public members**: Unlike a private and protected member, it is not required
    to specify the public keyword for public members. There is no explicit modifier
    for public members. Such members can be accessed from anywhere. For example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共成员**：与私有和受保护成员不同，对于公共成员不需要指定公共关键字。对于公共成员没有显式修饰符。这些成员可以从任何地方访问。例如：'
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Private members**: A private member is visible only inside the class or object
    that contains the member definition. Let''s see an example, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有成员**：私有成员仅在包含成员定义的类或对象内可见。让我们看一个例子，如下所示：'
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Protected members**: A protected member is only accessible from subclasses
    of the class in which the member is defined. Let''s see an example, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**受保护成员**：受保护成员仅能从定义成员的类的子类中访问。让我们看一个例子，如下所示：'
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Access modifiers in Scala can be augmented with qualifiers. A modifier of the
    form `private[X]` or `protected[X]` means that access is private or protected
    up to `X`, where `X` designates an enclosing package, class, or singleton object.
    Let''s see an example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，访问修饰符可以通过限定词进行增强。形如 `private[X]` 或 `protected[X]` 的修饰符意味着访问是私有或受保护的，直到
    `X`，其中 `X` 指定了封闭的包、类或单例对象。让我们看一个例子：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here''s a short note on the preceding code segment:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是关于前面代码段的简短说明：
- en: Variable `jboTitle` will be accessible to any class within the enclosing package
    `Professional`
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 `jboTitle` 将对 `Professional` 封闭包中的任何类可见
- en: Variable `friend` will be accessible to any class within the enclosing package
    `Country`
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 `friend` 将对 `Country` 封闭包中的任何类可见
- en: Variable `secret` will be accessible only to the implicit object within instance
    methods (this) only
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 `secret` 仅在实例方法（this）中对隐式对象可见
- en: If you look at the preceding examples, we used the keyword `package`. However,
    we have not discussed this so far. But don't worry; there will be a dedicated
    section later in this chapter. The constructor is a strong feature for any objected-oriented
    programming language. Scala is not an exception. Now, let's have a short overview
    of the constructor.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看前面的例子，我们使用了关键字 `package`。然而，到目前为止我们还没有讨论这个。但别担心，本章后面将有专门的部分来讨论它。构造函数是任何面向对象编程语言的一个强大特性。Scala
    也不例外。现在，让我们简要回顾一下构造函数。
- en: Constructors
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: The concept and the usage of constructors in Scala are a little different than
    what they are in C# or Java. There are two types of constructors in Scala - primary
    and auxiliary constructors. The primary constructor is the class's body, and it's
    parameter list appears right after the class name.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中构造函数的概念和用法与 C# 或 Java 中有些许不同。Scala 中有两种构造函数类型 - 主构造函数和辅助构造函数。主构造函数是类的主体，其参数列表紧跟在类名之后。
- en: 'For example, the following code segment describes the way to use the primary
    constructor in Scala:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码段描述了如何在 Scala 中使用主构造函数：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, to use the preceding constructor, this implementation is similar to the
    previous one, except there are no setters and getters. Instead, we can get the
    animal name and age, as here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用前面的构造函数，这个实现类似于之前的实现，唯一不同的是没有设置器和获取器。相反，我们可以像下面这样获取动物的名字和年龄：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Parameters are given in the class definition time to represent constructors.
    If we declare a constructor, then we cannot create a class without providing the
    default values of the parameters that are specified in the constructor. Moreover,
    Scala allows the instantiation of an object without providing the necessary parameters
    to its constructor: this happens when all constructor arguments have a default
    value defined.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是在类定义时提供的，用于表示构造函数。如果我们声明了构造函数，那么在不提供构造函数中指定的默认参数值的情况下，就无法创建类对象。此外，Scala 允许在不提供必要参数的情况下实例化对象：当所有构造函数参数都已定义默认值时，就会发生这种情况。
- en: Although there is a constraint for using the auxiliary constructors, we are
    free to add as many additional auxiliary constructors as we want. An auxiliary
    constructor must, on the first line of its body, call either another auxiliary
    constructor that has been declared before it, or the primary constructor. To obey
    this rule, each auxiliary constructor will, either directly or indirectly, end
    up invoking the primary constructor.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在使用辅助构造函数时有一些限制，但我们可以自由地添加任意数量的附加辅助构造函数。一个辅助构造函数必须在其主体的第一行调用之前声明的另一个辅助构造函数，或者调用主构造函数。为了遵守这一规则，每个辅助构造函数将直接或间接地调用主构造函数。
- en: 'For example, the following code segment demonstrates the use of the auxiliary
    constructor in Scala:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段演示了在 Scala 中使用辅助构造函数的方式：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the earlier setting, we included a secondary (that is, 2^(nd)) message in
    the primary constructor. The primary constructor will instantiate a new `Hello`
    object. Method `sayHello()` will print the concatenated message.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的设置中，我们在主构造函数中包含了一个次要（即，第2个）消息。主构造函数将实例化一个新的`Hello`对象。方法`sayHello()`将打印拼接后的消息。
- en: '**Auxiliary constructors**: In Scala, defining one or more auxiliary constructors
    for a Scala class gives the consumers of the class different ways to create object
    instances. Define the auxiliary constructors as methods in the class with the
    name this. You can define multiple auxiliary constructors, but they must have
    different signatures (parameter lists). Also, each constructor must call one of
    the previously defined constructors.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**辅助构造函数**：在 Scala 中，为 Scala 类定义一个或多个辅助构造函数，可以为类的使用者提供不同的创建对象实例的方式。将辅助构造函数定义为类中的方法，方法名为`this`。你可以定义多个辅助构造函数，但它们必须有不同的签名（参数列表）。此外，每个构造函数必须调用先前定义的一个构造函数。'
- en: Now let's peep into another important but relatively new concept in Scala, called
    **traits**. We will discuss this in the next section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们窥视一下 Scala 中另一个重要但相对较新的概念，称为**特质**。我们将在下一节中讨论这个概念。
- en: Traits in Scala
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 中的特质
- en: One of the new features in Scala is a trait, which is very similar to the notion
    of an interface in Java, except that it can also contain concrete methods. Although,
    Java 8 already has support for this. On the other hand, traits are one of the
    new concepts in Scala. But the feature already exists in OOP. So, they look like
    abstract classes, except that they don't have constructors.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中的新特性之一是特质，它与 Java 中的接口概念非常相似，不同之处在于它还可以包含具体的方法。虽然 Java 8 已经支持这一特性。另一方面，特质是
    Scala 中的一个新概念，但这个特性在面向对象编程中早已存在。因此，它们看起来像抽象类，只不过没有构造函数。
- en: A trait syntax
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特质语法
- en: 'You need to use the `trait` keyword in order to declare a trait and it should
    be followed by the trait name and body:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用`trait`关键字来声明一个特质，后面应该跟上特质的名称和主体：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Extending traits
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展特质
- en: 'In order to extend traits or classes, you need to use the `extend` keyword.
    Traits cannot be instantiated because it may contain unimplemented methods. So,
    it''s necessary to implement the abstract members in the trait:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展特质或类，你需要使用`extend`关键字。特质不能被实例化，因为它可能包含未实现的方法。因此，必须实现特质中的抽象成员：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A value class is not allowed to extend traits. To permit value classes to extend
    traits, universal traits are introduced, which extends for `Any`. For example,
    suppose that we have the following trait defined:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 值类不允许扩展特质。为了允许值类扩展特质，引入了通用特质，它扩展了`Any`。例如，假设我们有以下定义的特质：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, to extend the preceding trait in Scala using the universal trait, we follow
    the following code segment:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用通用特性扩展前面提到的特性，我们可以按照以下代码段操作：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So, what is the difference between an abstract class and the traits in Scala?
    As you have seen, an abstract class can have constructor parameters, type parameters,
    and multiple parameters. However, a trait in Scala can have only type parameters.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Scala中的抽象类和特性有什么区别呢？正如你所看到的，抽象类可以有构造函数参数、类型参数和多个参数。然而，Scala中的特性只能有类型参数。
- en: A trait is fully interoperable if, and only if, it does not contain any implementation
    code. Furthermore, Scala traits are fully interoperable with Java interfaces in
    Scala 2.12\. Because Java 8 allows method implementations in its interfaces, too.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果特性没有任何实现代码，那么它就是完全互操作的。此外，Scala特性在Scala 2.12中与Java接口完全互操作。因为Java 8也允许在接口中实现方法。
- en: 'There might be other cases for traits as well, for example, an abstract class
    can extend a trait or, if needed, any normal class (including the case classes)
    can extend an existing trait. For example, an abstract class can also extend traits:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 特性也可能有其他用途，例如，抽象类可以扩展特性，或者如果需要，任何普通类（包括案例类）都可以扩展现有的特性。例如，抽象类也可以扩展特性：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Lastly, a normal Scala class also can extend a Scala trait. Since classes are
    concrete, (that is, instances can be created), the abstract members of the trait
    should be implemented. In the next section, we will discuss the Java interoperability
    of Scala codes. Now let's peep into another important concept in every OOP, called
    **abstract classes**. We will discuss this in the next section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个普通的Scala类也可以扩展一个Scala特性。由于类是具体的（也就是说，可以创建实例），因此特性的抽象成员应该被实现。在下一节中，我们将讨论Scala代码的Java互操作性。现在，让我们深入探讨面向对象编程中的另一个重要概念——**抽象类**。我们将在下一节讨论这一内容。
- en: Abstract classes
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类
- en: An abstract class in Scala can have constructor parameters as well as type parameters.
    An abstract class in Scala is fully interoperable with Java. In other words, it
    is possible to call them from Java code without any intermediate wrappers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中的抽象类可以有构造函数参数和类型参数。Scala中的抽象类与Java完全互操作。换句话说，可以从Java代码中调用它们，而不需要任何中间包装器。
- en: 'So, what is the difference between an abstract class and the traits in Scala?
    As you have seen, an abstract class can have constructor parameters, type parameters,
    and multiple parameters. However, a trait in Scala can have only type parameters.
    The following is a simple example of an abstract class:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Scala中的抽象类和特性有什么区别呢？正如你所看到的，抽象类可以有构造函数参数、类型参数和多个参数。然而，Scala中的特性只能有类型参数。以下是一个简单的抽象类示例：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In order to extend this class by another one, we need to implement the unimplemented
    methods earlier `getAnimalAge`, `getAnimalGender`, and `getAnimalOrigin`. For
    `getAnimalName`, we can override it or not, since its implementation is already
    there.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让另一个类扩展这个类，我们需要实现之前未实现的方法`getAnimalAge`、`getAnimalGender`和`getAnimalOrigin`。对于`getAnimalName`，我们可以选择覆盖，也可以不覆盖，因为它的实现已经存在。
- en: Abstract classes and the override keyword
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类和`override`关键字
- en: 'If you want to override a concrete method from the superclass, the override
    modifier is necessary. However, if you are implementing an abstract method, it
    is not strictly necessary to add the override modifier. Scala uses the `override`
    keyword to override a method from a parent class. For example, suppose you have
    the following abstract class and a method `printContents()` to print your message
    on the console:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想覆盖父类中的具体方法，那么`override`修饰符是必须的。然而，如果你实现的是抽象方法，严格来说，不一定需要添加`override`修饰符。Scala使用`override`关键字来覆盖父类的方法。例如，假设你有以下抽象类和一个方法`printContents()`来在控制台打印你的消息：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, add a concrete implementation of the preceding abstract class to print
    the contents on the console as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加前面抽象类的具体实现，将内容打印到控制台，如下所示：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Secondly, if you want to create a trait to modify the behavior of the preceding
    concrete class, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果你想创建一个特性来修改前面具体类的行为，如下所示：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you look at the preceding code segment carefully, you will find two modifiers
    (that is, abstract and override). Now, with the preceding setting, you can do
    the following to use the preceding class:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细查看前面的代码段，你会发现有两个修饰符（即抽象和覆盖）。现在，在前面的设置下，你可以通过以下方式使用前面的类：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In summary, we can add an `override` keyword in front of the method to work
    as expected.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以在方法前添加 `override` 关键字，以使其按预期工作。
- en: Case classes in Scala
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 中的 case 类
- en: 'A **case** class is an instantiable class that includes several automatically
    generated methods. It also includes an automatically generated companion object
    with its own automatically generated methods. The basic syntax of a case class
    in Scala is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**case** 类是一个可实例化的类，它包含几个自动生成的方法。它还包括一个自动生成的伴生对象，并且该对象有自己的自动生成方法。Scala 中 case
    类的基本语法如下：'
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: A case class can be pattern matched, and comes with the following methods already
    implemented the method `hashCode` (location/scope is a class), `apply` (location/scope
    is an object), `copy` (location/scope is a class), `equals` (location/scope is
    a class), `toString` (location/scope is a class), and `unapply` (location/scope
    is an object).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: case 类可以进行模式匹配，并且已经实现了以下方法：`hashCode`（位置/作用域是类）、`apply`（位置/作用域是对象）、`copy`（位置/作用域是类）、`equals`（位置/作用域是类）、`toString`（位置/作用域是类）和`unapply`（位置/作用域是对象）。
- en: 'Like a plain class, a case class automatically define, getter methods for the
    constructor arguments. To get a practical insight about the preceding features
    or a case class, let''s see the following code segment:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 和普通类一样，case 类会自动为构造函数参数定义 getter 方法。为了更好地理解前述功能或 case 类，让我们看看以下代码段：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The preceding code produces the following output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成的输出如下：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For the REPL and the output of the regular expression matching, if you execute
    the preceding code (except the `Object` and `main` method), you should be able
    to see the more interactive output as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 REPL 和正则表达式匹配的输出，如果你执行上述代码（除去`Object`和`main`方法），你应该能够看到更具交互性的输出，如下所示：
- en: '![](img/00373.jpeg)**Figure 2:** Scala REPL for case class'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00373.jpeg)**图 2：** Scala REPL 中的 case 类'
- en: Packages and package objects
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包和包对象
- en: 'Just like Java, a package is a special container or object which contains/defines
    a set of objects, classes, and even packages. Every Scala file has the following
    automatically imported:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Java 一样，包是一个特殊的容器或对象，它包含/定义了一组对象、类，甚至是包。每个 Scala 文件都有以下自动导入：
- en: '`java.lang._`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang._`'
- en: '`scala._`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scala._`'
- en: '`scala.Predef._`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scala.Predef._`'
- en: 'The following is an example for basic imports:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基本导入的示例：
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can even rename a member while importing, and that''s to avoid a collision
    between packages that have the same member name. This method is also called class
    `alias`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以在导入时重命名一个成员，以避免同名成员在不同包中的冲突。这种方法也叫做类的`别名`：
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As mentioned in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, you can also import all the members of a package, but
    some members are also called **member hiding**:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第 1 章](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c)《Scala 入门》中提到的，你也可以导入一个包的所有成员，但其中一些成员也被称为**成员隐藏**：
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you tried this in the REPL, it just tells the compiler the full, canonical
    name of the defined class or object:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 REPL 中尝试此操作，它只会告诉编译器已定义类或对象的完整、规范名称：
- en: '[PRE57]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can even use the style of defining packages in curly braces. You can have
    a single package and nested package means package within a package. For example,
    the following code segment defines a single package named `singlePackage` consisting
    of a single class named `Test`. The `Test` class, on the other hand, consists
    of a single method named `toString()`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用大括号定义包的风格。你可以有一个单一的包和嵌套包，也就是说包内可以有包。例如，以下代码段定义了一个名为`singlePackage`的单一包，其中包含一个名为`Test`的类。`Test`
    类则由一个名为`toString()`的方法组成。
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, you can make the packaging nested. In other words, you can have more than
    one package in a nested way. For example, for the below case, we have two packages,
    namely `NestParentPack` and the `NestChildPack`, each containing their own classes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使包装变得嵌套。换句话说，你可以以嵌套方式拥有多个包。例如，下面的案例中，我们有两个包，分别是`NestParentPack`和`NestChildPack`，每个包内都有自己的类。
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s create a new object (let''s name it `MainProgram`), in which we''ll
    invoke the methods and classes we just defined:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新对象（命名为`MainProgram`），在其中调用我们刚刚定义的方法和类：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You will find more examples on the internet that describe sophisticated use
    cases of packages and package objects. In the next section, we will discuss the
    Java interoperability of Scala codes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在互联网上找到更多描述包和包对象复杂用例的示例。在下一节中，我们将讨论 Scala 代码的 Java 互操作性。
- en: Java interoperability
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 互操作性
- en: Java is one of the most popular languages, and many programmers learn Java programming
    as their first entrance to the programming world. The popularity of Java has increased
    since its initial release back in 1995\. Java has gained in popularity for many
    reasons. One of them is the design of its platform, such that any Java code will
    be compiled to bytecode, which in turn runs on the JVM. With this magnificent
    feature, Java language to be being written once and run anywhere. So, Java is
    a cross-platform language.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Java是最流行的语言之一，许多程序员将Java编程作为他们进入编程世界的第一步。自1995年首次发布以来，Java的流行度已经大幅提升。Java之所以受欢迎，原因有很多。其中之一是其平台设计，任何Java代码都将编译为字节码，然后在JVM上运行。借助这一强大功能，Java语言可以编写一次，随处运行。因此，Java是一种跨平台语言。
- en: Also, Java has lots of support from its community and lots of packages that
    will help you get your idea up and running with the help of these packages. Then
    comes Scala, which has lots of features that Java lacks, such as type inference
    and optional semicolon, immutable collections built right into Scala core, and
    lots more features (addressed in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*). Scala also runs on the JVM, just like Java.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Java在其社区中得到了广泛支持，并且有许多软件包可以帮助您使用这些软件包实现您的想法。接着是Scala，它具有许多Java所缺乏的特性，如类型推断和可选的分号，不可变集合直接内置到Scala核心中，以及许多其他功能（详见[第1章](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c)，*Scala简介*）。Scala也像Java一样运行在JVM上。
- en: '**Semicolon in Scala:** Semicolons are exactly optional, and they are required
    when more lines of code should be written on a single line. That''s probably the
    reason why the compiler doesn''t complain if a semicolon is put at the end of
    a line: it is considered a piece of code followed by an empty piece of code that,
    coincidentally, lives on the same line.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scala中的分号：** 分号是完全可选的，当需要在单行上编写多行代码时，才需要它们。这可能是为什么编译器如果在行末放置分号则不会抱怨的原因：它被认为是一个代码片段，后面跟着一个空的代码片段，巧合地位于同一行。'
- en: 'As you can see that both Scala and Java run on the JVM, it makes sense to use
    them simultaneously in the same program without complaints from the compiler.
    Let''s demonstrate this with an example. Consider the following Java code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Scala和Java都运行在JVM上，因此在同一个程序中同时使用它们是有意义的，而不会受到编译器的投诉。让我们通过一个示例来演示这一点。考虑以下Java代码：
- en: '[PRE61]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In order to write the same code in Scala, you can make use of Java packages.
    Let''s translate the previous example into Scala with the help of using Java collections
    such as `ArrayList`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Scala中编写相同的代码，可以利用Java软件包。让我们借助使用诸如`ArrayList`等Java集合，将前面的示例翻译成Scala：
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The previous mix applies for the standard packages of Java, but you want to
    use libraries that aren't packaged with the standard libraries of Java, or even
    want to use your own classes. Then, you need to make sure that they lie in the
    classpath.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准Java软件包上应用之前的混合，但是你想使用未包含在Java标准库中的库，甚至想使用自己的类。那么，你需要确保它们位于类路径中。
- en: Pattern matching
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: 'One of the widely used features of Scala is pattern matching. Each pattern
    match has a set of alternatives, each of them starting with the case keyword.
    Each alternative has a pattern and expression(s), which will be evaluated if the
    pattern matches and the arrow symbol `=>` separates pattern(s) from expression(s).
    The following is an example which demonstrates how to match against an integer:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的广泛使用功能之一是模式匹配。每个模式匹配都有一组备选项，每个选项都以case关键字开头。每个备选项都有一个模式和表达式，如果模式匹配成功，则箭头符号`=>`将模式与表达式分隔开来。以下是一个示例，演示如何匹配整数：
- en: '[PRE63]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can run the preceding program by saving this file in `PatternMatchingDemo1.scala`
    and then using the following commands to run it. Just use the following command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将此文件保存为`PatternMatchingDemo1.scala`，然后使用以下命令来运行前述程序。只需使用以下命令：
- en: '[PRE64]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You will get the following output:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您将会得到以下输出：
- en: '[PRE65]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The cases statements are used as a function that maps integers to strings.
    The following is another example which matches against different types:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: case语句被用作将整数映射到字符串的函数。以下是另一个示例，用于匹配不同类型：
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You can run this example by doing the same for the example earlier and will
    get the following output:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过与之前示例相同的方式运行此示例，并得到以下输出：
- en: '[PRE67]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Pattern matching is a mechanism for checking a value against a pattern. A successful
    match can also deconstruct a value into its constituent parts. It is a more powerful
    version of the switch statement in Java, and it can likewise be used in place
    of a series of `if...else` statements. You can find more on pattern matching by
    referring to the official docs of Scala (URL: [http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html](http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html)).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是检查一个值是否符合某个模式的机制。成功的匹配还可以将一个值分解为其组成部分。它是 Java 中 switch 语句的更强大的版本，也可以用来代替一系列
    `if...else` 语句。你可以通过查阅 Scala 官方文档了解更多关于模式匹配的内容（网址：[http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html](http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html)）。
- en: In the next section, we will discuss an important feature in Scala that enables
    us a value that can be passed automatically, so to speak, or a conversion from
    one type to another that is made automatically.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论 Scala 中的一个重要特性，它使得我们可以自动传递一个值，或者说，实现从一种类型到另一种类型的自动转换。
- en: Implicit in Scala
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 中的隐式
- en: 'Implicit is another exciting and powerful feature introduced by Scala, and
    it can refer to two different things:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式是 Scala 引入的另一个令人兴奋且强大的特性，它可以指代两种不同的概念：
- en: A value that can be automatically passed
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以自动传递的值
- en: Automatic conversion from one type to another
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一种类型到另一种类型的自动转换
- en: They can be used for extending the capabilities of a class
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以用来扩展类的功能
- en: 'Actual automatic conversion can be accomplished with implicit def, as seen
    in the following example (supposing you are using the Scala REPL):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的自动转换可以通过隐式 `def` 来完成，如下例所示（假设你在使用 Scala REPL）：
- en: '[PRE68]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, having the preceding code in my scope, it''s possible for me to do something
    like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我的作用域中有了前面的代码，我可以像这样做：
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Even if one of the parameters passed to `add()` is a `String` (and `add()` would
    require you to provide two integers), having the implicit conversion in scope
    allows the compiler to automatically convert from `String` to `Int`. Obviously
    enough, this feature could be quite dangerous, because it makes the code less
    readable; moreover, once an implicit conversion is defined, it's not easy to tell
    the compiler when to use it and when to avoid using it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 即使传递给 `add()` 的参数之一是 `String`（而 `add()` 要求提供两个整数），只要隐式转换在作用域内，编译器就能自动将 `String`
    转换为 `Int`。显然，这个特性可能会非常危险，因为它会使代码变得不易阅读；而且，一旦定义了隐式转换，编译器什么时候使用它、什么时候避免使用它就不容易判断了。
- en: 'The first type of implicit is a value that can automatically pass an implicit
    parameter. These parameters are passed while calling a method like any normal
    parameter, but Scala''s compiler tries to fill them automatically. If Scala''s
    compiler fails to automatically fill these parameters, it will complain. The following
    is an example to demonstrate the first type of implicit:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种类型的隐式是一个可以自动传递隐式参数的值。这些参数在调用方法时像任何普通参数一样传递，但 Scala 的编译器会尝试自动填充它们。如果 Scala
    的编译器无法自动填充这些参数，它会报错。以下是演示第一种类型隐式的示例：
- en: '[PRE70]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'By this, you are asking the compiler to look for an implicit value for `num`,
    if not provided during calling the method. You can define implicit value to the
    compiler like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，你要求编译器在调用方法时如果没有提供 `num` 参数，就去查找隐式值。你可以像这样向编译器定义隐式值：
- en: '[PRE71]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, we can simply call the function like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像这样简单地调用函数：
- en: '[PRE72]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here, no parameter is passed, so Scala''s compiler will look for implicit value,
    which is `2`, and then return `4` as the output of the method calling. However,
    a lot of other options have evolved a questions such as:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，没有传递任何参数，因此 Scala 的编译器会查找隐式值，即 `2`，然后返回 `4` 作为方法调用的输出。然而，很多其他选项也引发了类似的问题：
- en: 'Can a method contain both an explicit and an implicit parameter? The answer
    is YES. Let''s see an example on Scala REPL:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法可以同时包含显式和隐式参数吗？答案是可以的。我们来看一个 Scala REPL 中的示例：
- en: '[PRE73]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Can a method contain more than one implicit parameter? The answer is YES. Let''s
    see an example on Scala REPL:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法可以包含多个隐式参数吗？答案是可以的。我们来看一个 Scala REPL 中的示例：
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Can an implicit parameter be explicitly provided? The answer is YES. Let''s
    see an example on Scala REPL:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式参数可以显式地提供吗？答案是可以的。我们来看一个 Scala REPL 中的示例：
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: What happens if more implicits are contained in the same scope and how are implicits
    resolved? Is there any order to how implicits are resolved? To get to know the
    answer to these two questions, refer to this URL at [http://stackoverflow.com/questions/9530893/good-example-of-implicit-parameter-in-scala](http://stackoverflow.com/questions/9530893/good-example-of-implicit-parameter-in-scala).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在同一作用域中包含了多个隐式参数，隐式参数是如何解决的？是否有解决隐式参数的顺序？要了解这两个问题的答案，请参考此 URL：[http://stackoverflow.com/questions/9530893/good-example-of-implicit-parameter-in-scala](http://stackoverflow.com/questions/9530893/good-example-of-implicit-parameter-in-scala)。
- en: In the next section, we will discuss generics in Scala with some examples.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将通过一些示例讨论 Scala 中的泛型。
- en: Generic in Scala
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 中的泛型
- en: Generic classes are classes which take a type as a parameter. They are particularly
    useful for collection classes. Generic classes can be used in everyday data structure
    implementation, such as stack, queue, linked list, and so on. We will see some
    examples.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类是接受类型作为参数的类。它们对于集合类特别有用。泛型类可以用于日常数据结构的实现，如堆栈、队列、链表等。我们将看到一些示例。
- en: Defining a generic class
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个泛型类
- en: 'Generic classes take a type as a parameter within square brackets `[]`. One
    convention is to use the letter `A` as a type parameter identifier, though any
    parameter name may be used. Let''s see a minimal example on Scala REPL, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类在方括号 `[]` 中接受一个类型作为参数。一种约定是使用字母 `A` 作为类型参数标识符，虽然可以使用任何参数名称。让我们看一个在 Scala
    REPL 中的最小示例，如下所示：
- en: '[PRE76]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The preceding implementation of a `Stack` class takes any type A as a parameter.
    This means the underlying list, `var elements: List[A] = Nil` can only store elements
    of type `A`. The procedure def push only accepts objects of type `A` (note: `elements
    = x :: elements` reassigns elements to a new list created by prepending `x` to
    the current elements). Let''s see an example of how to use the preceding class
    to implement a stack:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '前面实现的 `Stack` 类接受任何类型 A 作为参数。这意味着底层的列表 `var elements: List[A] = Nil` 只能存储类型为
    `A` 的元素。程序 def push 只接受类型为 `A` 的对象（注意：`elements = x :: elements` 将元素重新赋值为一个通过将
    `x` 添加到当前元素前面的新列表）。让我们来看一个如何使用前面类实现堆栈的示例：'
- en: '[PRE77]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output is as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE78]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The second use case could be implementing a linked list too. For instance,
    if Scala didn''t have a linked-list class and you wanted to write your own, you
    could write the basic functionality like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个用例也可以是实现一个链表。例如，如果 Scala 没有链表类，而你想自己编写，可以像这样编写基本功能：
- en: '[PRE79]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, let''s see how could we use the preceding linked list implementation:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用前面的链表实现：
- en: '[PRE80]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The output is as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE81]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In summary, at the basic level, creating a generic class in Scala is just like
    creating a generic class in Java, with the exception of the brackets. Well! So
    far we have gotten to know some essential features to get started with an object-oriented
    programming language, Scala.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在基本层面上，创建 Scala 中的泛型类就像在 Java 中创建泛型类一样，唯一的区别是方括号。好了！到目前为止，我们已经了解了一些开始使用面向对象编程语言
    Scala 的基本特性。
- en: Although, we have not covered some other aspects, however, we still think that
    you can continue working. In [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, we discussed what the available editors for Scala are.
    In the next section, we will see how to set up your build environment. More specifically,
    three build systems, like Maven, SBT, and Gradle will be covered.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们没有覆盖一些其他方面，但我们仍然认为你可以继续工作。在[第 1 章](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c)，*Scala
    简介*中，我们讨论了可用的 Scala 编辑器。在下一部分，我们将看到如何设置构建环境。更具体地说，我们将涵盖三种构建系统：Maven、SBT 和 Gradle。
- en: SBT and other build systems
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SBT 和其他构建系统
- en: It's necessary to use a build tool for any enterprise software project. There
    are lots of build tools that you can choose from, such as Maven, Gradle, Ant,
    and SBT. A good choice of build tool is the one which will let you focus on coding
    rather than compilation complexities.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何企业软件项目，都需要使用构建工具。有许多构建工具可以选择，比如 Maven、Gradle、Ant 和 SBT。一个好的构建工具应该是让你专注于编码，而不是编译的复杂性。
- en: Build with SBT
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SBT 构建
- en: 'Here, we are going to give a brief introduction to SBT. Before going any further,
    you need to install SBT using the installation method that fits your system from
    their official installations methods (URL: [http://www.scala-sbt.org/release/docs/Setup.html](http://www.scala-sbt.org/release/docs/Setup.html)).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们将简要介绍 SBT。在继续之前，你需要通过其官方网站上适合你系统的安装方法来安装 SBT（URL: [http://www.scala-sbt.org/release/docs/Setup.html](http://www.scala-sbt.org/release/docs/Setup.html)）。'
- en: 'So, let''s begin with SBT to demonstrate the use of SBT in a terminal. For
    this build tool tutorial, we assume that your source code files are in a directory.
    You need to do the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们从 SBT 开始，演示如何在终端中使用 SBT。对于这个构建工具教程，我们假设你的源代码文件存放在一个目录中。你需要执行以下操作：
- en: Open the terminal and change path to that directory by using `cd`,
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并使用 `cd` 命令切换到该目录，
- en: Create a build file called `build.sbt`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `build.sbt` 的构建文件。
- en: 'Then, populate that build file with the following lines:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下内容填入该构建文件：
- en: '[PRE82]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Let''s see the meaning of these lines:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些行的含义：
- en: The `name` defines a name for your project. This name will be used in the generated
    jar files.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 定义了项目的名称。这个名称将在生成的 jar 文件中使用。'
- en: The `organization` is a namespace that's used to prevent collisions between
    projects that have similar names.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`organization` 是一个命名空间，用于防止具有相似名称的项目之间发生冲突。'
- en: '`scalaVersion` sets the version of Scala that you want to build against.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scalaVersion` 设置你希望构建的 Scala 版本。'
- en: '`Version` specifies the current build version of your project and you can use
    `-SNAPSHOT` for versions that have not been released yet.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Version` 指定当前项目的构建版本，你可以使用 `-SNAPSHOT` 来标识尚未发布的版本。'
- en: After creating this build file, you need to `run` the `sbt` command in your
    terminal and then a prompt starting with `>` will be opened for you. In this prompt,
    you can type `compile` in order to compile your Scala or Java source files in
    your code. Also, you can enter the command in the SBT prompt in order to run the
    program if it's runnable. Or you can use the package command in SBT prompt in
    order to generate a `.jar` file, which will exist in a subdirectory called `target`.
    To read more about SBT and more sophisticated examples, you can refer to the official
    site of SBT.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完这个构建文件后，你需要在终端中运行 `sbt` 命令，然后会弹出一个以 `>` 开头的提示符。在这个提示符中，你可以输入 `compile` 来编译代码中的
    Scala 或 Java 源文件。如果你的程序可以运行，也可以在 SBT 提示符中输入命令以运行程序。或者，你可以在 SBT 提示符中使用 `package`
    命令来生成一个 `.jar` 文件，该文件会保存在一个名为 `target` 的子目录中。要了解更多关于 SBT 的信息和更复杂的示例，你可以参考 SBT
    的官方网站。
- en: Maven with Eclipse
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven 与 Eclipse
- en: Using Eclipse as Scala IDE with Maven as a build tool is very easy and straightforward.
    In this section, we will demonstrate with screenshots how to use Scala with Eclipse
    and Maven. To be able to use Maven in Eclipse, you need to install its plugin,
    which will be different across different versions of Eclipse. After installing
    the Maven plugin, you will find that it doesn't support Scala directly. What we
    need to do in order to get this Maven plugin to support Scala projects is to install
    a connector called **m2eclipse-scala**.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Eclipse 作为 Scala IDE，并以 Maven 作为构建工具是非常简单和直接的。在本节中，我们将通过截图演示如何在 Eclipse 和
    Maven 中使用 Scala。为了在 Eclipse 中使用 Maven，你需要安装其插件，这些插件在不同版本的 Eclipse 中会有所不同。安装 Maven
    插件后，你会发现它并不直接支持 Scala。为了让这个 Maven 插件支持 Scala 项目，我们需要安装一个名为 **m2eclipse-scala**
    的连接器。
- en: 'If you paste this URL ([http://alchim31.free.fr/m2e-scala/update-site](http://alchim31.free.fr/m2e-scala/update-site)
    ) while trying to add new software to Eclipse, you will find that Eclipse understands
    the URL and suggests some plugins for you to add:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在尝试向 Eclipse 添加新软件时粘贴这个 URL（[http://alchim31.free.fr/m2e-scala/update-site](http://alchim31.free.fr/m2e-scala/update-site)），你会发现
    Eclipse 能够识别这个 URL，并建议一些插件供你添加：
- en: '![](img/00184.jpeg)**Figure 4:** Installing Maven plugins on Eclipse to enable
    Maven build'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00184.jpeg)**图 4：** 在 Eclipse 中安装 Maven 插件以启用 Maven 构建'
- en: 'After installing Maven and the connector for Scala support, we are going to
    create a new Scala Maven project. To create a new Scala Maven project, you need
    to navigate to New | Project | Other and then choose Maven Project. After this,
    select the option that has net.alchim31.maven as Group Id:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 Maven 和 Scala 支持的连接器后，我们将创建一个新的 Scala Maven 项目。创建新的 Scala Maven 项目时，你需要导航到
    New | Project | Other，然后选择 Maven Project。之后，选择具有 net.alchim31.maven 作为 Group Id
    的选项：
- en: '![](img/00186.jpeg)**Figure 5:** Creating a Scala Maven project on Eclipse'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00186.jpeg)**图 5：** 在 Eclipse 中创建一个 Scala Maven 项目'
- en: After this selection, you need to follow the wizard and enter the required values,
    such as Group Id, and so on. Then, hit Finish and, with this, you have created
    your first Scala project with Maven support in the workspace. In the project structure,
    you will find something called `pom.xml` where you can add all your dependencies
    and other things.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此选择后，你需要跟随向导输入必填项，如 Group Id 等。然后，点击 Finish，这样你就在工作空间中创建了第一个支持 Maven 的 Scala
    项目。在项目结构中，你会发现一个名为 `pom.xml` 的文件，在那里你可以添加所有依赖项和其他内容。
- en: For more information about how to add dependencies to your project, you can
    refer to this link at [http://docs.scala-lang.org/tutorials/scala-with-maven.html](http://docs.scala-lang.org/tutorials/scala-with-maven.html).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何向项目添加依赖项的更多信息，请参考此链接：[http://docs.scala-lang.org/tutorials/scala-with-maven.html](http://docs.scala-lang.org/tutorials/scala-with-maven.html)。
- en: As a continuation of this section, we will show you how to build your Spark
    application written in Scala in the upcoming chapter.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的延续，我们将在接下来的章节中展示如何构建用 Scala 编写的 Spark 应用程序。
- en: Gradle with Eclipse
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Eclipse 上使用 Gradle
- en: Gradle Inc. provides the Gradle tools and plugins for the Eclipse IDE. This
    tool allows you to create and import Gradle enabled projects into the Eclipse
    IDE. In addition, it allows you to run Gradle tasks and monitor the execution
    of the tasks.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle Inc. 提供了适用于 Eclipse IDE 的 Gradle 工具和插件。该工具允许你在 Eclipse IDE 中创建和导入 Gradle
    启用的项目。此外，它还允许你运行 Gradle 任务并监视任务的执行。
- en: The Eclipse project itself is called **Buildship**. The source code of this
    project is available on GitHub at [https://github.com/eclipse/Buildship](https://github.com/eclipse/Buildship).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse 项目本身叫做 **Buildship**。该项目的源代码可以在 GitHub 上找到，地址为 [https://github.com/eclipse/Buildship](https://github.com/eclipse/Buildship)。
- en: 'There are two options for installing Gradle plugins on Eclipse. These are as
    follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Eclipse 上安装 Gradle 插件有两个选项。具体如下：
- en: Via the Eclipse Marketplace
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Eclipse Marketplace
- en: Via the Eclipse Update Manager
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Eclipse 更新管理器
- en: 'First, let''s see how to install Buildship plugins for Grade build on Eclipse
    using Marketplace: Eclipse | Help | Eclipse Marketplace:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何使用 Marketplace 在 Eclipse 上安装 Buildship 插件以支持 Gradle 构建：Eclipse | 帮助
    | Eclipse Marketplace：
- en: '![](img/00190.jpeg)**Figure 6:** Installing Buildship plugins for Grade build
    on Eclipse using Marketplace'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00190.jpeg)**图 6:** 使用 Marketplace 在 Eclipse 上安装 Buildship 插件以支持 Gradle
    构建'
- en: 'The second option for installing the Gradle plugins on Eclipse is from the
    Help | Install New Software... menu path to install the Gradle tooling as shown
    in the following figure:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Eclipse 上安装 Gradle 插件的第二个选项是通过帮助 | 安装新软件... 菜单路径来安装 Gradle 工具，如下图所示：
- en: '![](img/00192.jpeg)**Figure 7:** Installing Buildship plugins for Grade build
    on Eclipse using install new software'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00192.jpeg)**图 7:** 使用安装新软件方式在 Eclipse 上安装 Buildship 插件以支持 Gradle 构建'
- en: 'For example, the following URL can be used for Eclipse 4.6 (Neon) release:
    [http://download.eclipse.org/releases/neon](http://download.eclipse.org/releases/neon).'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下 URL 可用于 Eclipse 4.6 (Neon) 版本：[http://download.eclipse.org/releases/neon](http://download.eclipse.org/releases/neon)。
- en: 'Once you have installed the Gradle plugins by following any one of the methods
    described earlier, Eclipse Gradle helps you to set up Scala based Gradle projects:
    File | New | Project | Select a wizard | Gradle | Gradle Project.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你通过之前描述的任意方法安装了 Gradle 插件，Eclipse Gradle 将帮助你设置基于 Scala 的 Gradle 项目：文件 | 新建
    | 项目 | 选择向导 | Gradle | Gradle 项目。
- en: '**![](img/00196.jpeg)****Figure 8:** Creating a Gradle project on Eclipse'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/00196.jpeg)****图 8:** 在 Eclipse 上创建 Gradle 项目'
- en: 'Now, if you press Next>, you will get the following wizard to specify the name
    of the project for your purpose:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你点击 Next>，你将进入以下向导，用于为你的项目指定名称：
- en: '**![](img/00198.jpeg)****Figure 9:** Creating a Gradle project on Eclipse specifying
    the project name'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/00198.jpeg)****图 9:** 在 Eclipse 上创建 Gradle 项目并指定项目名称'
- en: 'Finally, press the Finish button to create the project. Pressing the Finish
    button essentially triggers the Gradle `init --type java-library` command and
    imports the project. However, if you would like to get a preview of the configuration
    before the it is created, press Next > to get the following wizard:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击 Finish 按钮以创建项目。点击 Finish 按钮本质上会触发 Gradle `init --type java-library` 命令并导入该项目。然而，如果你希望在创建之前预览配置，点击
    Next >，你将看到以下向导：
- en: '![](img/00050.jpeg)**Figure 10:** Preview of the configuration before it is
    created'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00050.jpeg)**图 10:** 创建前的配置预览'
- en: Finally, you will see the following project structure on Eclipse. However, we
    will see how to build Spark applications using Maven, SBT, and Gradle in a later
    chapter. The reason is that, before starting your project, it is more important
    to learn Scala and Spark together.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将看到在 Eclipse 上的以下项目结构。然而，我们将在后续章节中讨论如何使用 Maven、SBT 和 Gradle 构建 Spark 应用程序。原因是，在开始项目之前，更重要的是先学习
    Scala 和 Spark。
- en: '![](img/00058.jpeg)**Figure 11:** The project structure on Eclipse using Gradle'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00058.jpeg)**图 11：** 使用 Gradle 的 Eclipse 项目结构'
- en: In this section, we have seen three build systems, including SBT, Maven, and
    Gradle. However, throughout the chapters, I will try to mainly use Maven because
    of its simplicity and better code compatibility. However, in later chapters, we
    will use SBT to create JARS from your Spark application.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经看到了三种构建系统，包括 SBT、Maven 和 Gradle。然而，在接下来的章节中，我将主要使用 Maven，因为它简单且更具代码兼容性。不过，在后续章节中，我们将使用
    SBT 从您的 Spark 应用程序创建 JAR 文件。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Structuring code in a sane way, with classes and traits, enhances the reusability
    of your code with generics, and creates a project with standard and widespread
    tools. Improve on the basics to know how Scala implements the OO paradigm to allow
    the building of modular software systems. In this chapter, we discussed the basic
    object-oriented features in Scala, such as classes and objects, packages and package
    objects, traits, and trait linearization, Java interoperability, pattern matching,
    implicit, and generics. Finally, we discussed SBT and other build systems that
    will be needed to build our Spark application on Eclipse or any other IDEs.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 以合理的方式构建代码，使用类和特质，能够通过泛型增强代码的可重用性，并使用标准的广泛工具创建项目。通过了解 Scala 如何实现面向对象（OO）范式，来构建模块化的软件系统。在本章中，我们讨论了
    Scala 中的基本面向对象特性，如类和对象、包和包对象、特质及特质线性化、Java 互操作性、模式匹配、隐式和泛型。最后，我们讨论了在 Eclipse 或任何其他
    IDE 上构建 Spark 应用程序所需的 SBT 及其他构建系统。
- en: In the next chapter, we will discuss what functional programming is and how
    Scala supports it. We will get to know why it matters and what the advantages
    of using functional concepts are. Continuing, you will learn pure functions, higher-order
    functions, Scala collections basics (map, flatMap, filter), for - comprehensions,
    monadic processing, and for extending higher-order functions outside of collections
    using the standard library of Scala.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论什么是函数式编程，以及 Scala 如何支持它。我们将了解它的重要性以及使用函数式概念的优势。接下来，您将学习纯函数、高阶函数、Scala
    集合基础（map、flatMap、filter）、for-comprehensions、单子处理，以及如何使用 Scala 的标准库将高阶函数扩展到集合之外。
