- en: Functions
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 函数
- en: This chapter introduces functions, a fundamental building block in programming.
    We show how to define them, how to handle input and output, how to properly use
    them, and how to treat them as objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了函数，这是编程中的一个基本构建块。我们展示了如何定义函数、如何处理输入和输出、如何正确使用它们以及如何将它们视为对象。
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涉及以下主题：
- en: Functions in mathematics and functions in Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学中的函数与Python中的函数
- en: Parameters and arguments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数和参数值
- en: Return values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值
- en: Recursive functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归函数
- en: Function documentation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数文档
- en: Functions are objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是对象
- en: Anonymous functions – the keyword `lambda`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数 – 关键字`lambda`
- en: Functions as decorators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为装饰器
- en: 7.1 Functions in mathematics and functions in Python
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.1 数学中的函数与Python中的函数
- en: In mathematics, a function is written as a map that uniquely assigns to every
    element ![](img/89f426e0-adb7-4ef9-b912-278993b26f35.png) from the domain *![](img/15cf5f8d-54c0-4464-8e43-130804048db7.png)*
    a corresponding element ![](img/d900968b-92f1-4fdb-9c1c-438c64794e2b.png) from
    the range ![](img/196ecfe6-b8c8-4550-9f29-9b136a555cc7.png).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，函数表示为一个映射，它唯一地将域*！[](img/15cf5f8d-54c0-4464-8e43-130804048db7.png)*中的每个元素*！[](img/89f426e0-adb7-4ef9-b912-278993b26f35.png)*与范围*！[](img/196ecfe6-b8c8-4550-9f29-9b136a555cc7.png)*中的对应元素*！[](img/d900968b-92f1-4fdb-9c1c-438c64794e2b.png)*相联系。
- en: This is expressed by *![](img/89d0dd79-9ade-4d44-b0eb-0626c808e581.png).*
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过*！[](img/89d0dd79-9ade-4d44-b0eb-0626c808e581.png)*来表示。
- en: Alternatively, when considering particular elements ![](img/e2fc557d-295f-4e14-88df-711e26a8f84f.png)
    and ![](img/632e9af1-ad40-45a1-ab58-0e09997f0262.png), you write ![](img/5f74a00c-0ba1-4bf4-9ea2-6ba4bc30ac39.png).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在考虑特定元素*！[](img/e2fc557d-295f-4e14-88df-711e26a8f84f.png)*和*！[](img/632e9af1-ad40-45a1-ab58-0e09997f0262.png)*时，可以写成*！[](img/5f74a00c-0ba1-4bf4-9ea2-6ba4bc30ac39.png)*。
- en: Here, ![](img/56d5d832-f148-4f4b-a6e1-e1f0fcc2652a.png) is called the name of
    the function and ![](img/3588ed47-5f38-428e-acf2-876c76dd8d16.png) is its value
    when applied to ![](img/a5117bc4-e31a-4d05-9465-f5b747caea99.png). Here, *![](img/3435f1a2-4591-43ed-b9af-99edeb63de74.png)*
    is sometimes called the argument of ![](img/ab2f2260-ab84-4410-9a3e-8902931eb19a.png).
    Let's first look at an example before considering functions in Python.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*！[](img/56d5d832-f148-4f4b-a6e1-e1f0fcc2652a.png)*被称为函数的名称，而*！[](img/3588ed47-5f38-428e-acf2-876c76dd8d16.png)*是其应用于*！[](img/a5117bc4-e31a-4d05-9465-f5b747caea99.png)*时的值。这里，*！[](img/3435f1a2-4591-43ed-b9af-99edeb63de74.png)*有时被称为*！[](img/ab2f2260-ab84-4410-9a3e-8902931eb19a.png)*的参数。在考虑Python中的函数之前，让我们先看一个示例。
- en: For example, ![](img/31802895-c824-49de-9a09-bf24daaa65fb.png) and ![](img/f7efefb7-81ad-4118-9f5d-30133e021096.png).
    This function maps two real numbers to their difference.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*！[](img/31802895-c824-49de-9a09-bf24daaa65fb.png)*和*！[](img/f7efefb7-81ad-4118-9f5d-30133e021096.png)*。这个函数将两个实数映射到它们的差值。
- en: 'In mathematics, functions can have numbers, vectors, matrices, and even other
    functions as arguments. Here is an example of a function with mixed arguments:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，函数可以接受数字、向量、矩阵，甚至其他函数作为参数。下面是一个带有混合参数的函数示例：
- en: '![](img/f736ebec-686e-4796-b4a9-f0d3d54ac072.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '*！[](img/f736ebec-686e-4796-b4a9-f0d3d54ac072.png)*'
- en: 'In this case, a real number is returned. When working with functions, we have
    to distinguish between two different steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，返回的是一个实数。在处理函数时，我们需要区分两个不同的步骤：
- en: The definition of the function
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的定义
- en: The evaluation of the function, that is, the computation of *![](img/c1ac1058-17b6-4c2d-ba2f-f8ce7303bde3.png)*
    for a given value of *![](img/7bbf122b-e48d-4395-96df-d601e8dee3dc.png)*
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的求值，也就是计算给定值的*！[](img/c1ac1058-17b6-4c2d-ba2f-f8ce7303bde3.png)*对于*！[](img/7bbf122b-e48d-4395-96df-d601e8dee3dc.png)*
- en: The first step is done once, while the second can be performed many times for
    various arguments.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步只需要执行一次，而第二步可以针对不同的参数执行多次。
- en: 'Functions in programming languages follow mainly the same concept and apply
    it to a wide range of types of input arguments, for example, strings, lists, floats,
    or simply any object. We demonstrate a definition of a function by considering
    the given example again:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言中的函数遵循类似的概念，并将其应用于各种类型的输入参数，例如字符串、列表、浮动数或任何对象。我们通过再次考虑给定的示例来演示函数的定义：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The keyword `def` indicates that we are going to define a function. `subtract`
    is the function’s name and `x1` and `x2` are its parameters. The colon indicates
    that we are using a block command. The value that is returned by the function
    follows the keyword `return`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`def`表示我们将定义一个函数。`subtract`是函数的名称，`x1`和`x2`是它的参数。冒号表示我们正在使用一个代码块。函数返回的值跟在关键字`return`后面。
- en: 'Now, we can evaluate this function. The function is called with its parameters
    replaced by input arguments:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以评估这个函数。该函数在其参数被输入参数替代后被调用：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result `0.7` is computed and assigned to the variable `r`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 结果`0.7`被计算并赋值给变量`r`。
- en: 7.2 Parameters and arguments
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.2 参数和参数值
- en: When defining a function, its input variables are called the *parameters* of
    the function. The input used when executing the function is called its *argument*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数时，其输入变量称为函数的*参数*。在执行函数时使用的输入称为其*参数值*。
- en: 7.2.1 Passing arguments – by position and by keyword
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2.1 传递参数——通过位置和关键字
- en: We will consider the previous example again, where the function takes two parameters,
    namely `x1` and `x2`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次考虑之前的例子，其中函数有两个参数，分别是`x1`和`x2`。
- en: 'Their names serve to distinguish the two numbers, which in this case cannot
    be interchanged without altering the result. The first parameter defines the number
    from which the second parameter is subtracted. When `subtract` is called, every
    parameter is replaced by an argument. Only the order of the arguments matters;
    the arguments can be any object. For instance, we may call the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的名字用于区分这两个数，这两个数在此情况下不能互换，否则会改变结果。第一个参数定义了从中减去第二个参数的数字。当`subtract`函数被调用时，每个参数都被替换为一个参数值。参数的顺序很重要；参数可以是任何对象。例如，我们可以调用如下：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Besides this standard way of calling a function, which is bypassing the arguments
    by position, it might sometimes be convenient to pass arguments using keywords.
    The names of the parameters are the keywords; consider the following instance:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种标准的调用函数方式，即通过位置传递参数，有时使用关键字传递参数可能会更方便。参数的名称就是关键字；考虑以下示例：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, the arguments are assigned to the parameters by name and not by position
    in the call. Both ways of calling a function can be combined so that the arguments
    given by position come first and the arguments given by keyword follow last. We
    show this by using the function `plot`, which was described in [Section 6.1](86c61820-e645-486c-9418-10079ffac7f8.xhtml):
    *Basic plotting*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，参数是通过名称分配给参数的，而不是通过调用中的位置。两种调用函数的方式可以结合使用，使得位置参数排在前面，关键字参数排在后面。我们通过使用函数`plot`来演示这种方式，`plot`函数在[第6.1节](86c61820-e645-486c-9418-10079ffac7f8.xhtml)：*基本绘图*中有描述：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 7.2.2 Changing arguments
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2.2 改变参数值
- en: 'The purpose of parameters is to provide the function with the necessary input
    data. Changing the value of the parameter inside the function normally has no
    effect on its value outside the function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的目的是为函数提供必要的输入数据。在函数内部改变参数的值通常不会影响函数外部的值：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This applies to all immutable arguments, such as strings, numbers, and tuples.
    The situation is different if mutable arguments, such as lists or dictionaries,
    are changed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于所有不可变参数，如字符串、数字和元组。如果更改的是可变参数，如列表或字典，情况就不同了。
- en: 'For example, passing mutable input arguments to a function and changing them
    inside the function can change them outside the function too:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将可变输入参数传递给函数，并在函数内更改它们，可能会改变函数外的值：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Such a function misuses its arguments to return results. We strongly dissuade
    you from such constructions and recommend that you do not change input arguments
    inside the function (for more information, see [Section 7.2.4](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml):
    *Default arguments*).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数错误地使用其参数来返回结果。我们强烈劝阻使用这种构造，并建议你在函数内部不要更改输入参数（有关更多信息，请参见[第7.2.4节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)：*默认参数*）。
- en: 7.2.3 Access to variables defined outside the local namespace
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2.3 访问定义在局部命名空间外的变量
- en: 'Python allows functions to access variables defined in any of its enclosing
    program units. These are called global variables, in contrast to local variables.
    The latter is only accessible within the function. For example, consider the following
    code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许函数访问其任何封闭程序单元中定义的变量。这些变量称为全局变量，与局部变量相对。局部变量只能在函数内部访问。例如，考虑以下代码：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This feature should not be abused. The following code is an example of what
    not to do:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不应滥用此特性。以下代码是一个不该使用这种方式的示例：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When changing the variable `a`, the function `multiply` tacitly changes its
    behavior:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当修改变量`a`时，函数`multiply`默默地改变了其行为：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is much better, in that case, to provide the variable as a parameter through
    the argument list:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，更好的做法是通过参数列表提供该变量：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Global variables can be useful when working with closures; see also the related
    example in [Section 7.7](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Anonymous
    functions – the* *keyword* *lambda**.*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量在处理闭包时非常有用；请参见[第7.7节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)中的相关示例：*匿名函数——*
    *关键字* *lambda**。
- en: 7.2.4 Default arguments
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2.4 默认参数
- en: Some functions can have many parameters, and among them, some might only be
    of interest in nonstandard situations. It would be practical if arguments could
    automatically be set to standard (default) values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数可能有很多参数，其中一些参数可能只在非标准情况下才有意义。如果参数可以自动设置为标准（默认）值，那将是非常实用的。
- en: We demonstrate the use of default arguments by looking at the command `norm`
    in the module `scipy.linalg`. It computes various norms of matrices and vectors. More
    on matrix norms can be found in [[10 ,§2.3]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过查看模块`scipy.linalg`中的命令`norm`来演示默认参数的使用。它计算矩阵和向量的各种范数。更多关于矩阵范数的信息，请参见[[10
    ,§2.3]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)。
- en: 'The following calls for computing the Frobenius **norm** of the ![](img/3966daf2-2ea1-4563-9c44-061c1042b7b3.png)
    identity matrix are equivalent:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '以下用于计算Frobenius **范数**的调用是等效的：  '
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that in the first call, no information about the keyword `ord` is given.
    How does Python know that it should compute the Frobenius norm and not another
    norm, for example, the Euclidean 2-norm?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第一次调用时，并没有提供关键字`ord`的任何信息。Python是如何知道应该计算Frobenius范数而不是其他范数，比如欧几里得2范数的呢？
- en: The answer to the previous question is the use of default values. A default
    value is a value already given by the function definition. If the function is
    called without providing this argument, Python uses the value that the programmer
    provided when the function was defined.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个问题的答案就是使用默认值。默认值是函数定义时已经给定的值。如果调用函数时没有提供该参数，Python将使用函数定义时程序员提供的值。
- en: 'Suppose we call the function `subtract` and provide it with only one argument;
    we would get an error message:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们调用`subtract`函数并只提供一个参数；我们将得到一个错误消息：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To allow the omission of the argument `x2`, the definition of the function
    has to provide a *default value*, for example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许省略参数`x2`，函数的定义必须提供一个*默认值*，例如：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Default arguments are given in the definition of the function by assigning a
    value to one of the parameters.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数是在函数定义时，通过为参数赋值来指定的。
- en: To summarize, arguments can be given as positional arguments and keyword arguments.
    All positional arguments have to be given first. You do not need to provide all
    keyword arguments as long as those omitted arguments have default values in the
    function definition.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，参数可以作为位置参数和关键字参数提供。所有位置参数必须先给出。只要被省略的参数在函数定义中有默认值，就不需要提供所有的关键字参数。
- en: Beware of mutable default arguments
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小心可变的默认参数
- en: 'The default arguments are set upon function definition. Changing mutable arguments
    inside a function has a side effect when working with default values, for example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数是在函数定义时设置的。在函数内部修改可变参数会对使用默认值时产生副作用，例如：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Recall, lists are mutable objects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，列表是可变对象。
- en: 7.2.5 Variable number of arguments
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2.5 可变数量的参数
- en: 'Lists and dictionaries may be used to define or call functions with a variable
    number of arguments. Let''s define a list and a dictionary as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和字典可以用来定义或调用具有可变数量参数的函数。我们可以定义一个列表和一个字典，如下所示：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we can call the `plot` function using starred (`*`) arguments:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用星号（`*`）参数调用`plot`函数：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A variable name prefixed by `*`, such as `*data` in the preceding example,
    means that a list that gets unpacked to provide the function with its arguments.
    In this way, a list generates positional arguments. Similarly, a variable name
    prefixed by `**`, such as `**style` in the example, unpacks a dictionary to keyword
    arguments; see *Figure 7.1*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以`*`开头的变量名，例如前面示例中的`*data`，意味着将一个列表解包以向函数提供其参数。通过这种方式，列表生成位置参数。类似地，带有`**`前缀的变量名，例如示例中的`**style`，将解包一个字典为关键字参数；见
    *图 7.1*：
- en: '![](img/af27c774-d30e-4912-82c4-83562b036b9d.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af27c774-d30e-4912-82c4-83562b036b9d.png)'
- en: 'Figure 7.1: Starred arguments in function calls'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：函数调用中的星号参数
- en: You might also want to use the reverse process, where all given positional arguments
    are packed into a list and all keyword arguments are packed into a dictionary
    when passed to a function. In the function definition, this is indicated by parameters
    prefixed by `*` and `**`, respectively. You will often find the parameters `*args`
    and `**kwargs` in code documentation; see *Figure 7.2.*
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能想要使用反向过程，在这种情况下，所有给定的位置参数会被打包成一个列表，所有的关键字参数会被打包成一个字典并传递给函数。在函数定义中，这通过分别以`*`和`**`作为前缀的参数来表示。你经常会在代码文档中看到`*args`和`**kwargs`这两个参数；参见*图7.2*。
- en: '![](img/351df170-0fda-4879-a49e-9bf80d2526e8.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/351df170-0fda-4879-a49e-9bf80d2526e8.png)'
- en: 'Figure 7.2: Starred arguments in function definitions'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：函数定义中的星号参数
- en: 7.3 Return values
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.3 返回值
- en: A function in Python always returns a single object. If a function has to return
    more than one object, these are packed and returned as a single tuple object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的函数总是返回一个单一的对象。如果一个函数必须返回多个对象，它们会被打包并作为一个单一的元组对象返回。
- en: 'For instance, the following function takes a complex number ![](img/0bac0f3d-d6ac-4268-a99e-0f971194689b.png)
    and returns its polar coordinate representation as magnitude ![](img/5530f0e2-5dac-46e6-9980-2221beb32362.png)
    and angle ![](img/7414aca2-5855-4e3b-9c08-d2f13de7acc3.png):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的函数接受一个复数！[](img/0bac0f3d-d6ac-4268-a99e-0f971194689b.png)，并返回其极坐标表示形式，包含幅度！[](img/5530f0e2-5dac-46e6-9980-2221beb32362.png)和角度！[](img/7414aca2-5855-4e3b-9c08-d2f13de7acc3.png)：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: (See also Euler’s formula, ![](img/de874ce0-e2fa-4001-9103-6dd2ec877c4a.png).)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: （另请参见欧拉公式，![](img/de874ce0-e2fa-4001-9103-6dd2ec877c4a.png)）。
- en: Here, we used the NumPy function `sqrt(x)` for the square root of a number `x`
    and `arctan2(x,y)` for the expression ![](img/b3c0157c-8a54-45ae-99c2-05f5c7ef11d5.png).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了NumPy函数`sqrt(x)`来计算数字`x`的平方根，并使用`arctan2(x, y)`来表示![](img/b3c0157c-8a54-45ae-99c2-05f5c7ef11d5.png)。
- en: 'Let''s try our function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一下我们的函数：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The last three statements can be written more elegantly in a single line:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的三条语句可以在一行中更优雅地写出来：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can test our function by calling `polar_to_comp` defined in *Exercise 1*
    in the *Exercises* section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用在*练习*部分的*练习1*中定义的`polar_to_comp`函数来测试我们的函数。
- en: 'If a function has no `return` statement, it returns the value `None`. There
    are many cases where a function does not need to return any value. This could
    be because the variables passed to a function may be subject to modification.
    Consider, for instance, the following function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数没有`return`语句，它将返回值`None`。有很多情况，函数不需要返回任何值。这可能是因为传递给函数的变量可能会被修改。例如，考虑下面的函数：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding function does not return anything because it modifies one of the
    objects that is given as a mutable argument. There are many methods that behave
    in the same way. To mention the list methods only, the methods `append`, `extend`,
    `reverse`, and `sort` do not return anything (that is, they return `None` ). When
    an object is modified by a method in this way, the modification is called *in
    place*. It is difficult to know whether a method changes an object, except by
    looking at the code or the documentation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数不返回任何内容，因为它修改了作为可变参数传递的一个对象。有很多方法的行为也是如此。仅列举列表方法，`append`、`extend`、`reverse`和`sort`这些方法都不返回任何内容（即它们返回`None`）。当一个对象通过这种方式被方法修改时，称为*就地*修改。很难知道一个方法是否会改变一个对象，除非查看代码或文档。
- en: Another reason for a function, or a method, not to return anything is when it
    prints out a message or writes to a file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 函数或方法不返回任何内容的另一个原因是，当它打印出一条信息或写入文件时。
- en: 'The execution stops at the first occurring `return` statement. Lines after
    that statement are dead code that will never be executed:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 执行会在第一个出现的`return`语句处停止。该语句之后的行是死代码，永远不会被执行：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 7.4 Recursive functions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.4 递归函数
- en: In mathematics, many functions are defined recursively. In this section, we
    will show how this concept can be used even when programming a function. This
    makes the relation of the program to its mathematical counterpart very clear,
    which may ease the readability of the program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，许多函数是递归定义的。在本节中，我们将展示如何在编写函数时使用这个概念。这使得程序与其数学对应物之间的关系变得非常清晰，这可能有助于提高程序的可读性。
- en: Nevertheless, we recommend using this programming technique with care, especially
    within scientific computing. In most applications, the more straightforward iterative
    approach is more efficient. This will become immediately clear from the following
    example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们建议谨慎使用这种编程技巧，尤其是在科学计算中。在大多数应用中，更直接的迭代方法通常更高效。通过以下示例，这一点将立刻变得清晰。
- en: 'Chebyshev polynomials are defined by a three-term recursion:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 切比雪夫多项式由三项递归定义：
- en: '![](img/599c7304-96a1-4b1c-8d58-e91f7d52874b.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/599c7304-96a1-4b1c-8d58-e91f7d52874b.png)'
- en: Such a recursion needs to be initialized, that is, *[![](img/a68a459e-835f-492b-84de-87e405fd258f.png)].*
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种递归需要初始化，即 *[![](img/a68a459e-835f-492b-84de-87e405fd258f.png)]*。
- en: 'In Python, this *three-term recursion* can be realized by the following function
    definition:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，这种 *三项递归* 可以通过以下函数定义来实现：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To compute ![](img/30b7eadf-af02-468d-84cb-081ad13a56cb.png), the function
    is then called like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 ![](img/30b7eadf-af02-468d-84cb-081ad13a56cb.png)，函数可以像这样调用：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This example also illustrates the risk of dramatically wasting computation time.
    The number of function evaluations increases exponentially with the recursion
    level and most of these evaluations are just duplicates of previous computations.
    While it might be tempting to use recursive programs for demonstrating the strong
    relation between code and mathematical definition, production code will avoid
    this programming technique (see also *Exercise* *6 *in the *Exercises *section).
    We also refer to a technique called memoization that combines recursive programming
    with a caching technique to save replicated function evaluations, see [[22]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例还展示了浪费计算时间的巨大风险。随着递归层级的增加，函数评估的数量呈指数增长，而且这些评估中的大多数只是先前计算的重复结果。虽然使用递归程序来展示代码与数学定义之间的紧密关系可能很诱人，但生产代码通常会避免使用这种编程技巧（参见*练习*6
    *节中的练习*部分）。我们还提到了一种叫做记忆化（memoization）的技巧，它将递归编程与缓存技术相结合，以保存重复的函数评估，详见[[22]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)。
- en: 'A recursive function usually has a level parameter. In the previous example,
    it is `n`*.* It is used to control the function''s two main parts:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数通常有一个级别参数。在前面的例子中，它是 `n`*.* 它用来控制函数的两个主要部分：
- en: The base case; here, the first two `if` branches
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本情况；这里是前两个 `if` 分支
- en: The recursive body, in which the function itself is called once or several times
    with smaller-level parameters
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归主体，在这个主体中，函数本身会使用较小级别的参数一次或多次被调用
- en: 'The number of levels passed by the execution of a recursive function is called
    the recursion depth. This quantity should not be too large; otherwise, the computation
    might no longer be efficient and, in the ultimate case, the following error will
    be raised:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 执行递归函数时经过的层数称为递归深度。这个值不应过大，否则计算可能变得低效，并且在极端情况下，会抛出以下错误：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The maximal recursion depth depends on the memory of the computer you use.
    This error also occurs when the initialization step is missing in the function
    definition. We encourage the use of recursive programs for very small recursion
    depths only (for more information, see [Section 9.7.2](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml):
    *Recursion*).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的递归深度取决于你使用的计算机的内存。这个错误也会在函数定义缺少初始化步骤时发生。我们鼓励仅在非常小的递归深度下使用递归程序（更多信息，请参见[第9.7.2节](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml)：*递归*）。
- en: 7.5 Function documentation
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.5 函数文档
- en: 'You should document your functions using a string at the beginning. This string
    is called a *docstring*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在函数开始时使用一个字符串来记录文档，这个字符串叫做 *文档字符串*：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When calling `help(newton)`, you get this docstring displayed together with
    the call of this function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `help(newton)` 时，你会看到这个文档字符串与函数调用一起显示出来：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The docstring is internally saved as an attribute, `__doc__`, of the given function.
    In the example, it is `newton.__doc__`. The minimal information you should provide
    in a docstring is the purpose of the function and the description of the input
    and output objects. There are tools to automatically generate full code documentation
    by collecting all docstrings in your program (for more information, see the documentation
    of Sphinx, [[32]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串被内部保存为给定函数的一个属性，`__doc__`。在这个例子中，它是 `newton.__doc__`。你应该在文档字符串中提供的最基本信息是函数的目的以及输入和输出对象的描述。有一些工具可以通过收集程序中的所有文档字符串来自动生成完整的代码文档（更多信息，请参见
    Sphinx 的文档，[[32]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)）。
- en: 7.6 Functions are objects
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.6 函数是对象
- en: 'Functions are objects, like everything else in Python. You may pass functions
    as arguments, change their names, or delete them. For example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是对象，就像Python中的其他一切。你可以将函数作为参数传递、修改其名称或删除它们。例如：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Passing functions as arguments is very common when applying algorithms in scientific
    computing. The function `fsolve` in `scipy.optimize` for computing a zero of a
    given function or `quad` in `scipy.integrate` for computing integrals are typical
    examples.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学计算中，传递函数作为参数是非常常见的。当应用算法时，`scipy.optimize`中的函数`fsolve`用于计算给定函数的零点，或者`scipy.integrate`中的`quad`用于计算积分，都是典型的例子。
- en: A function itself can have a different number of arguments with differing types.
    So, when passing your function `f` to another function `g` as an argument, make
    sure that `f` has exactly the form described in the docstring of `g`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数本身可以具有不同数量和类型的参数。所以，当你将函数`f`作为参数传递给另一个函数`g`时，请确保`f`的形式与`g`的文档字符串中描述的完全一致。
- en: 'The docstring of `fsolve` gives information about its parameter `func`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`fsolve`的文档字符串提供了关于其参数`func`的信息：'
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 7.6.1 Partial application
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6.1 部分应用
- en: Let's start with an example of a function with two variables.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个具有两个变量的函数例子开始。
- en: 'The function ![](img/9502da7b-86bf-48e3-8564-7821236cc621.png) can be viewed
    as a function in two variables. Often you consider ![](img/338903f2-95ad-4f1e-a84c-eafbfeb69218.png)
    not as a free variable but as a fixed parameter of a family of functions *![](img/eeaff405-ef7d-405b-8f02-e3bff86d22fb.png)*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 ![](img/9502da7b-86bf-48e3-8564-7821236cc621.png) 可以看作是一个双变量的函数。通常，你会把 ![](img/338903f2-95ad-4f1e-a84c-eafbfeb69218.png)
    视为一个固定的参数，而不是一个自由变量，属于一族函数 *![](img/eeaff405-ef7d-405b-8f02-e3bff86d22fb.png)*：
- en: '*![](img/61ae8234-2d80-4209-af59-a3d132be42cb.png)*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](img/61ae8234-2d80-4209-af59-a3d132be42cb.png)*'
- en: This interpretation reduces a function in two variables to a function in one
    variable ![](img/3be52ca7-be0d-413c-990e-475b16061773.png) given a fixed parameter
    value *![](img/49a1eac7-3ffe-48ef-9a3d-3f4b0cca152d.png)*. The process of defining
    a new function by fixing (freezing) one or several parameters of a function is
    called partial application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解释将一个双变量函数简化为一个单变量函数 ![](img/3be52ca7-be0d-413c-990e-475b16061773.png)，其中固定了一个参数值
    *![](img/49a1eac7-3ffe-48ef-9a3d-3f4b0cca152d.png)*。通过固定（冻结）函数的一个或多个参数来定义一个新函数的过程称为部分应用。
- en: 'Partial applications are easily created using the Python module `functools`,
    which provides a function called `partial` for precisely this purpose. We illustrate
    this by constructing a function that returns a sine for a given frequency:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python模块`functools`可以轻松创建部分应用，它提供了一个名为`partial`的函数，专门用于这个目的。我们通过构造一个返回给定频率的正弦函数来说明这一点：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the last line, the newly created function is evaluated at ![](img/7dab2cdb-e183-49f4-a87d-9369f0a1240f.png).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，新的函数在 ![](img/7dab2cdb-e183-49f4-a87d-9369f0a1240f.png) 被求值。
- en: 7.6.2 Using closures
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6.2 使用闭包
- en: 'Using the view that functions are objects, partial applications can be realized
    by writing a function, which itself returns a new function, with a reduced number
    of input arguments. For instance, the function `make_sine` could be defined as
    follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数是对象的角度出发，可以通过编写一个函数来实现部分应用，这个函数本身返回一个新的函数，并且输入参数的数量减少。例如，函数`make_sine`可以定义如下：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, the inner function `mysine` has access to the variable `freq`;
    it is neither a local variable of this function nor is it passed to it via the
    argument list. Python allows such a construction, see [Section](919d9596-6c84-492d-8b65-8f1045866d8e.xhtml)
    13.1, *Namespaces*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，内嵌函数`mysine`可以访问变量`freq`；它既不是该函数的局部变量，也没有通过参数列表传递给它。Python允许这样的构造，参见[章节](919d9596-6c84-492d-8b65-8f1045866d8e.xhtml)13.1，*命名空间*。
- en: 7.7 Anonymous functions – the keyword lambda
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.7 匿名函数 —— 关键字lambda
- en: The keyword `lambda` is used in Python to define anonymous functions, that is,
    functions without a name and described by a single expression. You might just
    want to perform an operation on a function that can be expressed by a simple expression
    without naming this function and without defining this function by a lengthy `def`
    block.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`lambda`在Python中用于定义匿名函数，也就是没有名字、由单一表达式描述的函数。你可能只想对一个可以通过简单表达式表示的函数执行某个操作，而不需要给这个函数命名，也不需要通过冗长的`def`块来定义它。
- en: The name *lambda* originates from a special branch of calculus and mathematical
    logic, the ![](img/8acb12a5-c98d-4653-ac41-9e4fba93f10a.png)-calculus.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 名字*lambda*源自微积分和数学逻辑的一个特殊分支，即 ![](img/8acb12a5-c98d-4653-ac41-9e4fba93f10a.png)-微积分。
- en: 'We demonstrate the use of `lambda`-functions by numerically evaluating the
    following integral:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过数值评估以下积分来演示`lambda`函数的使用：
- en: '![](img/f7b1ca59-f9c8-4ae1-965b-1fe67f6f9331.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7b1ca59-f9c8-4ae1-965b-1fe67f6f9331.png)'
- en: 'We use SciPy’s function `quad`, which requires as its first argument the function
    to be integrated and the integration bounds as the next two arguments. Here, the
    function to be integrated is just a simple one-liner and we use the keyword `lambda`
    to define it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用SciPy的`quad`函数，它的第一个参数是要积分的函数，接下来的两个参数是积分区间。这里，待积分的函数只是一个简单的一行代码，我们使用`lambda`关键字来定义它：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The syntax is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The definition of the function `lambda` can only consist of a single expression
    and, in particular, cannot contain loops. `lambda` functions are, just like other
    functions, objects and can be assigned to variables:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`函数的定义只能由一个单一的表达式组成，特别的是，不能包含循环。`lambda`函数与其他函数一样，都是对象，可以赋值给变量：'
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 7.7.1 The lambda construction is always replaceable
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.1 `lambda`构造总是可以替换的
- en: 'It is important to note that the `lambda` construction is only syntactic sugar
    in Python. Any `lambda` construction may be replaced by an explicit function definition:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`lambda`构造只是Python中的语法糖。任何`lambda`构造都可以被显式的函数定义所替代：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The main reason to use this construction is for very simple functions when a
    full function definition would be too cumbersome.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种构造的主要原因是对于非常简单的函数来说，完整的函数定义会显得过于繁琐。
- en: '`lambda` functions provide a third way to make closures as we demonstrate by
    continuing with the previous example, [![](img/c651f3a5-f426-4197-8b0c-52b7da0dfa85.png)].'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`函数提供了创建闭包的第三种方式，正如我们通过继续前面的例子[![](img/c651f3a5-f426-4197-8b0c-52b7da0dfa85.png)]所演示的那样。'
- en: 'We use the function `sin_omega` from [Section 7.6.1](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml),
    *Partial Application*, to compute the integral of the sine function for various
    frequencies:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用[第7.6.1节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)中的`sin_omega`函数，*部分应用*，来计算不同频率下正弦函数的积分：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 7.8 Functions as decorators
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.8 函数作为装饰器
- en: 'In [Section 7.6.1](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Partial application*,
    we saw how a function can be used to modify another function. A *decorator* is
    a syntax element in Python that conveniently allows us to alter the behavior of
    a function without changing the definition of the function itself. Let''s start
    with the following situation.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7.6.1节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)：*部分应用*中，我们看到如何使用一个函数来修改另一个函数。*装饰器*是Python中的一个语法元素，它方便地允许我们改变函数的行为，而无需修改函数本身的定义。让我们从以下情况开始。
- en: 'Assume that we have a function that determines tcitehe degree of sparsity of
    a matrix:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个函数用来确定矩阵的稀疏度：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This function returns an error if it is not called with an array object as
    input. More precisely, it will not work with an object that does not implement
    the method `reshape`. For instance, the function `how_sparse` will not work with
    a list, because lists have no method `reshape`. The following helper function
    modifies any function with one input parameter so that it tries to make a type
    conversion to an array:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未以数组对象作为输入调用此函数，则会返回一个错误。更准确地说，它将无法与没有实现`reshape`方法的对象一起工作。例如，`how_sparse`函数无法与列表一起工作，因为列表没有`reshape`方法。以下辅助函数修改任何具有一个输入参数的函数，以便尝试将其类型转换为数组：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Thus, the modified function `how_sparse = cast2array(how_sparse)` can be applied
    to any object that can be cast to an array. The same functionality is achieved
    if the definition of `how_sparse` is decorated with this type conversion function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，修改后的函数`how_sparse = cast2array(how_sparse)`可以应用于任何可以转换为数组的对象。如果`how_sparse`的定义用这个类型转换函数进行装饰，也可以实现相同的功能：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To define a decorator, you need a callable object such as a function that modifies
    the definition of the function to be decorated. The main purposes are:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个装饰器，你需要一个可调用的对象，例如一个修改被装饰函数定义的函数。其主要目的包括：
- en: To increase code readability by separating parts from a function that do not
    directly serve its functionality (for example, memoizing)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将不直接服务于函数功能的部分分离来增加代码可读性（例如，记忆化）
- en: To put common preamble and epilogue parts of a family of similar functions in
    a common place (for example, type checking)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一组类似函数的公共前言和尾部部分放在一个共同的地方（例如，类型检查）
- en: To be able to easily switch off and on additional functionalities of a function
    (for example, test prints or tracing)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了能够方便地开关函数的附加功能（例如，测试打印或追踪）
- en: It is recommended also to consider `functools.wraps`,  see also [[8]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 还建议考虑使用`functools.wraps`，详情请见[[8]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)。
- en: 7.9 Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.9 小结
- en: Functions are not only the ideal tools for making your program modular, but
    they also reflect mathematical thinking. You learned the syntax of function definitions
    and how to distinguish between defining and calling a function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不仅是使程序模块化的理想工具，还能反映出数学思维。你已经学习了函数定义的语法，并了解如何区分定义函数和调用函数。
- en: We considered functions as objects that can be modified by other functions.
    When working with functions, it is important to be familiar with the notion of
    the scope of a variable and how information is passed into a function by parameters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将函数视为可以被其他函数修改的对象。在处理函数时，了解变量的作用域以及如何通过参数将信息传递到函数中是非常重要的。
- en: Sometimes, it is convenient to define functions on the fly with so-called anonymous
    functions. For this, we introduced the keyword `lambda`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，定义所谓的匿名函数非常方便。为此，我们引入了关键字`lambda`。
- en: 7.10 Exercises
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.10 练习
- en: '**Ex 1:** Write a function `polar_to_comp`, which takes two arguments ![](img/e834ef4c-2926-4ad9-9504-de4b2234bc13.png)
    and ![](img/4f3160df-59d2-427a-b19a-51eb90212f65.png) and returns the complex
    number ![](img/6e1ade86-768c-4fe4-9963-7bde1348f589.png). Use the NumPy function
    `exp` for the exponential function.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 1**：编写一个函数 `polar_to_comp`，该函数接收两个参数 ![](img/e834ef4c-2926-4ad9-9504-de4b2234bc13.png)
    和 ![](img/4f3160df-59d2-427a-b19a-51eb90212f65.png)，并返回复数 ![](img/6e1ade86-768c-4fe4-9963-7bde1348f589.png)。使用
    NumPy 函数 `exp` 来计算指数函数。'
- en: '**Ex 2**: In the description of the Python module `functools`, [[8]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml),
    you find the following Python function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 2**：在 Python 模块 `functools` 的描述中[[8]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)，你会找到以下
    Python 函数：'
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Explain and test this function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 解释并测试此函数。
- en: '**Ex 3**: Write a decorator for the function `how_sparse`, which cleans the
    input matrix `A` by setting the elements that are less than `1.e-16` to zero (consider
    the example in [Section 7.8](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Functions
    as decorators*).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 3**：为函数 `how_sparse` 编写一个装饰器，该装饰器通过将小于 `1.e-16` 的元素设置为零来清理输入矩阵 `A`（参考 [第
    7.8 节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)：*作为装饰器的函数*）。'
- en: '**Ex 4:** A continuous function ![](img/edafb426-3175-4e5d-af76-2d21dc0acd01.png)
    with ![](img/3c9e124d-b89a-4263-ab14-04b3293dfaea.png) changes its sign in the
    interval ![](img/bff068a9-97e1-48a0-a3f5-3f16aa97fd84.png) and has at least one
    root (zero) in this interval. Such a root can be found with the *bisection method*.
    This method starts from the given interval. Then it investigates the sign changes
    in the subintervals'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 4**：一个连续函数 ![](img/edafb426-3175-4e5d-af76-2d21dc0acd01.png)，其 ![](img/3c9e124d-b89a-4263-ab14-04b3293dfaea.png)
    在区间 ![](img/bff068a9-97e1-48a0-a3f5-3f16aa97fd84.png) 内改变符号，并且在该区间内至少有一个根（零）。可以通过*二分法*找到此根。该方法从给定区间开始，接着检查子区间中的符号变化。'
- en: '![](img/40f2d3ed-3d13-44bd-b5a0-7fe826182297.png) and ![](img/a4aff68c-105a-4e2e-93e1-a93487e3f53e.png).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/40f2d3ed-3d13-44bd-b5a0-7fe826182297.png) 和 ![](img/a4aff68c-105a-4e2e-93e1-a93487e3f53e.png)。'
- en: 'If the sign changes in the first subinterval, ![](img/aeb1a071-16be-4a0e-8dc7-06b3fb165cb3.png)
    is redefined to be:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个子区间内符号发生变化，则 ![](img/aeb1a071-16be-4a0e-8dc7-06b3fb165cb3.png) 将重新定义为：
- en: '![](img/55964a4d-c0f2-4cac-9220-584b8c3f556f.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55964a4d-c0f2-4cac-9220-584b8c3f556f.png)'
- en: 'Otherwise, it is redefined in the same manner to:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，它将以相同的方式重新定义为：
- en: '![](img/da78bd63-e2ee-44d6-a9e2-7ce4c207a3b2.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da78bd63-e2ee-44d6-a9e2-7ce4c207a3b2.png)'
- en: The process is repeated until the length of the interval, ![](img/ac340bd1-abae-44ba-b90f-af0835bce7e6.png),
    is less than a given tolerance.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程会重复进行，直到区间的长度 ![](img/ac340bd1-abae-44ba-b90f-af0835bce7e6.png) 小于给定的容差。
- en: 'Implement this method as a function that takes as arguments:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此方法实现为一个函数，接收以下参数：
- en: The function ![](img/1b4d26a9-8021-47fc-86c0-d9eba66e8ae3.png)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数 ![](img/1b4d26a9-8021-47fc-86c0-d9eba66e8ae3.png)
- en: The initial interval ![](img/d1d3fe72-5545-44ef-9b0c-f9eafcc6b766.png)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始区间 ![](img/d1d3fe72-5545-44ef-9b0c-f9eafcc6b766.png)
- en: The tolerance
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容差
- en: This function `bisec` should return the final interval and its midpoint.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此函数`bisec`应返回最终的区间及其中点。
- en: Test the method with the function `arctan` and also with the polynomial [*![](img/a44ef6a3-4361-4334-a506-8ed64ba6ac2d.png)*]
    in the interval [![](img/cfac34a9-ed11-43cb-ad61-45b93d31b3ce.png)], and alternatively
    in [![](img/11738e6a-23a2-47bc-a263-9bd5d72fa98b.png)].
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数`arctan`测试该方法，并在区间[![](img/cfac34a9-ed11-43cb-ad61-45b93d31b3ce.png)]内，以及在[![](img/11738e6a-23a2-47bc-a263-9bd5d72fa98b.png)]内，测试多项式[*![](img/a44ef6a3-4361-4334-a506-8ed64ba6ac2d.png)*]。
- en: '**Ex. 5:** The greatest common divisor of two integers can be computed with
    *Euclid’s algorithm* described by the following recursion:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 5**：可以使用*欧几里得算法*计算两个整数的最大公约数，该算法通过以下递归实现：'
- en: '![](img/4a74e62b-aed2-4ba1-8520-8a46208dac88.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a74e62b-aed2-4ba1-8520-8a46208dac88.png)'
- en: 'Write a function that computes the greatest common divisor of two integers.
    Write another function that computes the least common multiple of these numbers
    using the relation:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，用于计算两个整数的最大公约数。再编写一个函数，利用以下关系计算这两个数的最小公倍数：
- en: '![](img/31b854bc-725e-4380-8491-1321cefce918.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31b854bc-725e-4380-8491-1321cefce918.png)'
- en: '**Ex. 6**: Study the recursive implementation of Chebyshev polynomials. Consider
    the example in [Section 7.4](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Recursive
    functions*. Rewrite the program in a non-recursive way and study computation time
    versus polynomial degree (see also the module `timeit`).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 6**：研究切比雪夫多项式的递归实现。参考[第7.4节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)中的示例：*递归函数*。将程序改写为非递归形式，并研究计算时间与多项式次数的关系（另见`timeit`模块）。'
