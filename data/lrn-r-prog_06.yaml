- en: Chapter 6. Working with Strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 处理字符串
- en: In the previous chapter, you learned many built-in functions in several categories
    to work with basic objects. You learned how to access object classes, types, and
    dimensions; how to do logical, math, and basic statistical calculations; and how
    to perform simple analytic tasks such as root solving. These functions are the
    building blocks of our solution to specific problems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了多个类别中的许多内置函数，用于处理基本对象。你学习了如何访问对象类、类型和维度；如何进行逻辑、数学和基本统计计算；以及如何执行简单的分析任务，如求根。这些函数是我们解决特定问题的基石。
- en: 'String-related functions are a very important category of functions. They will
    be introduced in this chapter. In R, texts are stored in character vectors, and
    a good number of functions and techniques are useful to manipulate and analyze
    texts. In this chapter, you will learn the basics and useful techniques of working
    with strings, including the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串相关的函数是一个非常重要的函数类别。它们将在本章中介绍。在R中，文本存储在字符向量中，许多函数和技术对于操作和分析文本非常有用。在本章中，你将学习处理字符串的基本和有用技术，包括以下主题：
- en: Basic manipulation of character vectors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符向量的基本操作
- en: Converting between date/time objects and their string representations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在日期/时间对象与其字符串表示之间进行转换
- en: Using regular expressions to extract information from texts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式从文本中提取信息
- en: Getting started with strings
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串入门
- en: Character vectors in R are used to store text data. You previously learned that
    in contrast with many other programming languages, a character vector is not a
    vector of single characters, letters, or alphabet symbols such as a, b, c. Rather,
    it is a vector of strings.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: R中的字符向量用于存储文本数据。你之前了解到，与许多其他编程语言相比，字符向量不是一个由单个字符、字母或字母符号（如a、b、c）组成的向量。相反，它是一个字符串的向量。
- en: R also provides a variety of built-in functions to deal with character vectors.
    Many of them also perform vectorized operations so they can process numerous string
    values in one step.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: R还提供了一系列内置函数来处理字符向量。其中许多也执行向量化操作，因此它们可以一步处理多个字符串值。
- en: In this section, you will learn more about printing, combining, and transforming
    texts stored in character vectors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习更多关于打印、组合和转换存储在字符向量中的文本的内容。
- en: Printing texts
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印文本
- en: Perhaps the most basic thing we can do with texts is to view them. R provides
    several ways to view texts in the console.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们可以用文本做的最基本的事情就是查看它们。R提供了几种在控制台中查看文本的方法。
- en: 'The simplest way is to directly type the string in quotation marks:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是直接在引号内键入字符串：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Like a numeric vector of floating numbers, a character vector is a vector of
    character values, or strings. `Hello` is in the first position and is the only
    element of the character vector we created earlier.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像浮点数的数值向量一样，字符向量是一个字符值或字符串的向量。"Hello"位于第一个位置，是我们之前创建的字符向量的唯一元素。
- en: 'We can also print a string value stored in a variable by simply evaluating
    it:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过简单地评估它来打印存储在变量中的字符串值：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, simply writing a character value in a loop does not print it iteratively.
    It does not print anything at all:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅在循环中写入字符值并不会迭代地打印它。它根本不会打印任何内容：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That''s because R only automatically prints the *value* of an expression as
    it is being typed in the console. A for loop does not explicitly return a value.
    This behavior also explains the difference between the printing behaviors when
    the following two functions are called, respectively:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为R只会在控制台中键入表达式时自动打印表达式的*值*。for循环不会显式地返回一个值。这种行为也解释了当调用以下两个函数时打印行为之间的差异：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding output, `test1` does not print `Hello`, but it prints `World`
    because `test1("World")` returns the value of the last expression `x`, which is
    given as `World`, the value of the function call and R automatically prints this
    value. Let''s assume we remove `x` from the function as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，`test1`没有打印`Hello`，而是打印了`World`，因为`test1("World")`返回最后一个表达式`x`的值，即`World`，这是函数调用的值，R自动打印了这个值。让我们假设我们按照以下方式从函数中移除`x`：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, `test2` always returns `Hello`, no matter what value `x` takes. As a result,
    R automatically prints the value of expression `test2("World")`, that is, `Hello`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`test2`无论`x`取什么值，总是返回`Hello`。因此，R自动打印表达式`test2("World")`的值，即`Hello`。
- en: 'If we want to explicitly print an object, we should use `print()`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想显式地打印一个对象，我们应该使用`print()`：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, the character vector is printed with a position `[1]`. This works in
    a loop too:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，字符向量以位置 `[1]` 打印出来。这同样适用于循环：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It also works in a function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以在函数中使用：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In some cases, we want the texts to appear as a message rather than a character
    vector with indices. In such cases, we can call `cat()` or `message()`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望文本以消息的形式出现，而不是带有索引的字符向量。在这种情况下，我们可以调用 `cat()` 或 `message()` 函数：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can construct the message in a more flexible way:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更灵活地构建消息：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We change the input to print a more formal sentence:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改输入以打印一个更正式的句子：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It looks like the concatenated string appears to use unnecessary spaces between
    different arguments. It is because the space character is used by default as the
    separator between the input strings. We can change it by specifying the `sep=`
    argument. In the following example, we will avoid the default space separator
    and manually write spaces in the input strings to create a correct version:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来连接的字符串似乎在不同的参数之间使用了不必要的空格。这是因为默认情况下，空格字符被用作输入字符串之间的分隔符。我们可以通过指定 `sep=` 参数来更改它。在下面的例子中，我们将避免默认的空格分隔符，并在输入字符串中手动写入空格以创建正确的版本：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'An alternative function is `message()`, which is often used in serious situations
    such as an important event. The output text has a more conspicuous appearance.
    It is distinct from `cat()`, in that, it does not automatically use space separators
    to concatenate input strings:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数是 `message()`，它通常用于重要事件等严肃场合。输出文本具有更明显的显示效果。它与 `cat()` 不同，因为它在连接输入字符串时不会自动使用空格分隔符：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using `message()`, we need to write the separators manually in order to show
    the same text as earlier.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `message()`，我们需要手动写入分隔符，以便显示与之前相同的文本。
- en: Another difference in the behavior between `cat()` and `message()` is that `message()`
    automatically ends the text with a new line while `cat()` does not.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat()` 和 `message()` 之间的另一个行为差异是，`message()` 会自动在文本末尾添加一个新行，而 `cat()` 则不会。'
- en: 'The following two examples demonstrate the difference. We want to print the
    same contents but get different results:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个例子演示了差异。我们想要打印相同的内容，但得到不同的结果：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It is obvious that each time `cat()` is called, it prints the input string
    without a new line appended. The effect is that the three letters show in the
    same line. By contrast, each time `message()` is called, it appends a new line
    to the input string. As a result, the three letters show in three lines. To print
    each letter in a new line using `cat()`, we need to explicitly add a new line
    character in the input. The following code prints exactly the same contents as `message()`
    did in the previous example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，每次调用 `cat()` 时，它都会打印输入字符串而不添加新行。结果是三个字母显示在同一行上。相比之下，每次调用 `message()` 时，它都会在输入字符串后添加一个新行。因此，三个字母显示在三个行上。要使用
    `cat()` 在新的一行上打印每个字母，我们需要在输入中显式添加一个换行符。下面的代码打印了与上一个例子中 `message()` 相同的内容：
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Concatenating strings
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串连接
- en: 'In practice, we often need to concatenate several strings to build a new one.
    The `paste()` function is used to concatenate several character vectors together.
    This function also uses space as the default separator:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们经常需要连接几个字符串来构建一个新的字符串。`paste()` 函数用于将几个字符向量连接在一起。此函数也使用空格作为默认的分隔符：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we don''t want the separator, we can set `sep=""` or alternatively call `paste0()`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想使用分隔符，可以设置 `sep=""` 或者使用 `paste0()` 函数：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Maybe you are confused by `paste()` and `cat()` because they both are capable
    of concatenating strings. But what''s the difference? Although both functions
    concatenate strings, the difference is that `cat()` only prints the string to
    the console, but `paste()` returns the string for further uses. The following
    code demonstrates that `cat()` prints the concatenated string but returns `NULL`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你会对 `paste()` 和 `cat()` 混淆，因为它们都能连接字符串。但它们有什么区别呢？尽管这两个函数都能连接字符串，但区别在于 `cat()`
    只会将字符串打印到控制台，而 `paste()` 则返回字符串以供进一步使用。以下代码演示了 `cat()` 打印连接的字符串但返回 `NULL`：
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In other words, `cat()` only prints strings, but `paste()` creates a new character
    vector.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`cat()` 只打印字符串，而 `paste()` 创建一个新的字符向量。
- en: 'The previous examples show the behavior of `paste()` working with single-element
    character vectors. What about working with multi-element ones? Let''s see how
    this is done:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子展示了 `paste()` 函数与单元素字符向量一起工作的行为。那么，与多元素向量一起工作又是怎样的呢？让我们看看这是如何实现的：
- en: '[PRE18]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can see that `paste()` works element-wise, that is, `paste("A", "C")` first,
    then `paste("B", "D")`, and finally, the results are collected to build a character
    vector of two elements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`paste()`是按元素工作的，即首先`paste("A", "C")`，然后`paste("B", "D")`，最后将结果收集起来构建一个包含两个元素的字符向量。
- en: 'If we want the results to be put together in one string, we can specify how
    these two elements are again concatenated by setting `collapse=`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将结果合并成一个字符串，我们可以通过设置`collapse=`来指定这两个元素再次连接的方式：
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we want to put them in two lines, we can set `collapse` to be `\n` (new
    line):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将它们放在两行中，可以将`collapse`设置为`\n`（新行）：
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The new character vector `result` is a two-lined string, but the text representation
    of it is still written in one line. The new line is represented by `\n` as we
    specified. To view the text we created, we need to call `cat()`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 新的字符向量`result`是一个两行字符串，但它的文本表示仍然写在一行中。新行由我们指定的`\n`表示。要查看我们创建的文本，我们需要调用`cat()`：
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, the two-lined string is printed to the console in its intended format.
    The same thing also works with `paste0()`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两行字符串按照预期格式打印到控制台。同样，`paste0()`也适用。
- en: Transforming texts
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本转换
- en: Turning texts into another form is useful in many cases. It is easy to perform
    a number of basic types of transformation on texts.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本转换为另一种形式在许多情况下都很有用。对文本执行多种基本类型的转换很容易。
- en: Changing cases
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变大小写
- en: When we process data with texts, the input may not comply with our standard
    as supposed. For example, we expect all products to be graded in capital letters,
    from A to F, but the actual input may consist of these letters in both cases.
    Changing cases is useful to ensure that the input strings are consistent in cases.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理文本数据时，输入可能不符合我们的标准。例如，我们期望所有产品都按大写字母评级，从A到F，但实际输入可能包含这些字母的大小写形式。改变大小写有助于确保输入字符串在大小写上的一致性。
- en: 'The `tolower()` function changes the texts to lowercase letters, while `toupper()`
    does the opposite:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`tolower()`函数将文本转换为小写字母，而`toupper()`则相反：'
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is particularly useful when a function accepts character input. For example,
    we can define a function that returns `x + y` when type is `add` in all possible
    cases. It returns `x * y` when type is `times` in all possible cases. The best
    way to do it is to always convert `type` to lowercase or uppercase, no matter
    what the input value is:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这在函数接受字符输入时尤其有用。例如，我们可以定义一个函数，在所有可能的情况下，当`type`为`add`时返回`x + y`，当`type`为`times`时返回`x
    * y`。最好的做法是无论输入值如何，总是将`type`转换为小写或大写：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This gives more tolerance to similar inputs only in different cases so that
    `type` is case-insensitive.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得对相似输入（仅在大小写不同的情况下）有更多的容错性，从而使`type`不区分大小写。
- en: 'In addition, the two functions are vectorized, that is, it changes the cases
    of each string element of the given character vector:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这两个函数是向量化的，也就是说，它会改变给定字符向量中每个字符串元素的大小写：
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Counting characters
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数字符
- en: 'Another useful function is `nchar()`, which simply counts the number of characters
    of each element of a character vector:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的函数是`nchar()`，它简单地计算字符向量中每个元素的字符数：
- en: '[PRE25]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Like `toupper()` and `tolower()`, `nchar()` is also vectorized:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与`toupper()`和`tolower()`类似，`nchar()`也是向量化的：
- en: '[PRE26]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This function is often used to check whether an argument is supplied a valid
    string. For example, the following function takes some personal information of
    a student and stores it in the database:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通常用于检查是否向其提供了有效的字符串参数。例如，以下函数接受学生的某些个人信息并将其存储到数据库中：
- en: '[PRE27]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Before storing the information in the database, the function uses `stopifnot()`
    to check whether `name` and `age` are provided valid values. If the user does
    not provide a meaningful name (for example, no less than two letters), the function
    would stop with an error:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在将信息存储到数据库之前，函数使用`stopifnot()`来检查`name`和`age`是否提供了有效的值。如果用户没有提供有意义的名称（例如，不少于两个字母），函数将停止并显示错误：
- en: '[PRE28]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that `nchar(x) == 0` is equivalent to `x == ""`. To check against an empty
    string, both methods work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`nchar(x) == 0`等价于`x == ""`。要检查空字符串，两种方法都适用。
- en: Trimming leading and trailing whitespaces
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 去除前后空白字符
- en: 'In the previous example, we used `nchar()` to check whether `name` is valid.
    However, sometimes, the input data comes with useless whitespaces. This adds more
    noise to the data and requires a careful checking of string arguments. For example, `store_student()`
    in the previous section makes pass of a name such as `" P"`, which is as invalid
    as a straight `"P"` argument, but `nchar(" P")` returns `3`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了 `nchar()` 来检查 `name` 是否有效。然而，有时输入数据会包含无用的空白字符。这增加了数据的噪声，并需要仔细检查字符串参数。例如，上一节中的
    `store_student()` 函数对 `“P”` 这样的名字进行了处理，它和直接的 `“P”` 参数一样无效，但 `nchar(" P")` 返回 `3`：
- en: '[PRE29]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To take the possibility into account, we need to refine `store_student`. In
    R 3.2.0, `trimws()` is introduced to trim leading and/or trailing whitespaces
    of given strings:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了考虑可能性，我们需要改进 `store_student()` 函数。在 R 3.2.0 中，引入了 `trimws()` 函数，用于去除给定字符串的前导和/或尾随空白字符：
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, the function is more robust to noisy data:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，函数对噪声数据更加鲁棒：
- en: '[PRE31]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The function, by default, trims both the leading and trailing whitespaces,
    which can be spaces and tabs. You can specify whether "left" or "right" to only
    trim one side of the strings:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，该函数会去除前导和尾随空白字符，包括空格和制表符。您可以指定“left”或“right”以仅去除字符串的一侧：
- en: '[PRE32]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Substring
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子字符串
- en: 'In previous chapters, you learned how to subset vectors and lists. We can also
    subset the texts in a character vector by calling `substr()`. Suppose we have
    several dates in the following form:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何对向量和列表进行子集操作。我们还可以通过调用 `substr()` 来对字符向量中的文本进行子集操作。假设我们有以下形式的几个日期：
- en: '[PRE33]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'All the months are represented by three-letter abbreviations. We can use `substr()`
    to extract the months:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有月份都由三个字母的缩写表示。我们可以使用 `substr()` 来提取月份：
- en: '[PRE34]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To extract the day, we need to use `substr()` and `nchar()` together:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取日期，我们需要同时使用 `substr()` 和 `nchar()`：
- en: '[PRE35]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that we can extract both months and days in the input strings, it is useful
    to write a function to transform the strings in such format to numeric values
    to represent the same date. The following function uses many functions and ideas
    you learned previously:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从输入字符串中提取月份和日期，因此编写一个函数将此类格式的字符串转换为数值表示相同的日期是有用的。以下函数使用了你之前学到的许多函数和思想：
- en: '[PRE36]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `substr()` function also has a counterpart function to replace the substrings
    with a given character vector:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`substr()` 函数还有一个对应的函数，用于用给定的字符向量替换子字符串：'
- en: '[PRE37]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Splitting texts
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本分割
- en: 'In many cases, the lengths of string parts to extract are not fixed. For example,
    person names such as "Mary Johnson" or "Jack Smiths" have no fixed lengths for
    the first names and last names. It is more difficult to use `substr()`, as you
    learned in the previous section, to separate and extract both parts. Texts in
    such format have a regular separator such as space or a comma. To extract the
    useful parts, we need to split the texts and make each part accessible. The `strsplit()`
    function is used to split texts by specific separators given as a character vector:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，要提取的字符串部分的长度不是固定的。例如，人名如 "Mary Johnson" 或 "Jack Smiths" 首名和姓氏的长度没有固定值。使用
    `substr()`，如你在上一节中学到的，来分离和提取这两部分会更困难。此类格式的文本有一个常规分隔符，如空格或逗号。为了提取有用的部分，我们需要分割文本并使每个部分可访问。`strsplit()`
    函数用于通过指定的字符向量分隔符分割文本：
- en: '[PRE38]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The function returns a list. Each element in the list is a character vector
    produced from splitting that element in the original character vector. It is because
    `strsplit()`, like all previous string functions we have introduced, is also vectorized,
    that is, it returns a list of character vectors as a result of the splitting:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回一个列表。列表中的每个元素都是从原始字符向量中分割该元素产生的字符向量。这是因为 `strsplit()`，就像我们之前介绍的所有字符串函数一样，也是向量化的，即它返回一个分割的字符向量列表作为结果：
- en: '[PRE39]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `strsplit()` function returns a list of character vectors containing split
    parts by working element-wise. In practice, splitting is only the first step to
    extract or reorganize data. To continue, we can use `rbind` to put the data into
    a matrix and give appropriate names to the columns:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`strsplit()` 函数通过逐元素工作返回一个包含分割部分的字符向量列表。在实践中，分割只是提取或重新组织数据的第一步。为了继续，我们可以使用
    `rbind` 将数据放入矩阵中，并为列赋予适当的名称：'
- en: '[PRE40]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we will convert the matrix to a data frame so that we can transform each
    column to more proper types:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将矩阵转换为数据框，这样我们就可以将每一列转换为更合适的类型：
- en: '[PRE41]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, raw string input students are transformed into a more organized and more
    useful data frame `students_df`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，原始字符串输入的学生已经转换为更组织化和更有用的数据框 `students_df`。
- en: 'One small trick to split the whole string into single characters is to use
    an empty `split` argument:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将整个字符串拆分为单个字符的小技巧是使用一个空的 `split` 参数：
- en: '[PRE42]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In fact, `strsplit()` is more powerful than is shown. It also supports *regular
    expressions*, a very powerful framework to process text data. We will cover this
    topic in the last section of this chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`strsplit()` 的功能比显示的还要强大。它还支持 *正则表达式*，这是一种非常强大的文本数据处理框架。我们将在本章的最后部分介绍这个主题。
- en: Formatting texts
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化文本
- en: Concatenating texts with `paste()` is sometimes not a good idea because the
    text has to be broken into pieces and it becomes harder to read as the format
    gets longer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `paste()` 连接文本有时不是一个好主意，因为文本需要被分割成多个部分，随着格式的变长，阅读起来会变得更加困难。
- en: 'For example, let''s assume we need to print each record in `students_df` in
    the following format:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要以下格式打印 `students_df` 中的每条记录：
- en: '[PRE43]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this case, using `paste()` will be a pain:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用 `paste()` 将会非常麻烦：
- en: '[PRE44]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The code looks messy, and it is hard to get the general template at first glance.
    By contrast, `sprintf()` supports a formatting template and solves the problem
    in a nice way:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来很杂乱，初次看很难一眼看出通用模板。相比之下，`sprintf()` 支持格式化模板，并以一种优雅的方式解决了这个问题：
- en: '[PRE45]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the preceding code, `#%d, name: %s, age: %d, major: %s` is the formatting
    template in which `%d` and `%s` are placeholders to represent the input arguments
    to appear in the string. The `sprintf()` function is especially easy to use because
    it prevents the template string from tearing apart, and each part to replace is
    specified as a function argument. In fact, this function uses C style formatting
    rules as described in detail at [https://en.wikipedia.org/wiki/Printf_format_string](https://en.wikipedia.org/wiki/Printf_format_string).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，`#%d, name: %s, age: %d, major: %s` 是格式化模板，其中 `%d` 和 `%s` 是占位符，用于表示字符串中要出现的输入参数。`sprintf()`
    函数特别易于使用，因为它防止模板字符串被拆分，并且每个要替换的部分都指定为函数参数。实际上，这个函数使用的是在 [https://en.wikipedia.org/wiki/Printf_format_string](https://en.wikipedia.org/wiki/Printf_format_string)
    中详细描述的 C 风格格式化规则。'
- en: 'In the preceding example, `%s` stands for string and `%d` for digits (integers).
    Moreover, `sprintf()` is also very flexible in formatting numeric values using `%f`.
    For example, `%.1f` means to round the number to 0.1:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`%s` 表示字符串，`%d` 表示数字（整数）。此外，`sprintf()` 在使用 `%f` 格式化数值时也非常灵活。例如，`%.1f`
    表示将数字四舍五入到0.1：
- en: '[PRE46]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In fact, there is a formatting syntax of different types of values. The following
    table shows the most commonly used syntax:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，存在不同类型值的格式化语法。以下表格显示了最常用的语法：
- en: '| **Format** | **Output** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **格式** | **输出** |'
- en: '| `sprintf("%s", "A")` | `A` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `sprintf("%s", "A")` | `A` |'
- en: '| `sprintf("%d", 10)` | `10` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `sprintf("%d", 10)` | `10` |'
- en: '| `sprintf("%04d", 10)` | `0010` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `sprintf("%04d", 10)` | `0010` |'
- en: '| `sprintf("%f", pi)` | `3.141593` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `sprintf("%f", pi)` | `3.141593` |'
- en: '| `sprintf("%.2f", pi)` | `3.14` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `sprintf("%.2f", pi)` | `3.14` |'
- en: '| `sprintf("%1.0f", pi)` | `3` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `sprintf("%1.0f", pi)` | `3` |'
- en: '| `sprintf("%8.2f", pi)` | `3.14` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `sprintf("%8.2f", pi)` | `3.14` |'
- en: '| `sprintf("%08.2f", pi)` | `00003.14` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `sprintf("%08.2f", pi)` | `00003.14` |'
- en: '| `sprintf("%+f", pi)` | `+3.141593` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `sprintf("%+f", pi)` | `+3.141593` |'
- en: '| `sprintf("%e", pi)` | `3.141593e+00` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `sprintf("%e", pi)` | `3.141593e+00` |'
- en: '| `sprintf("%E", pi)` | `3.141593E+00` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `sprintf("%E", pi)` | `3.141593E+00` |'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The official documentation ([https://stat.ethz.ch/R-manual/R-devel/library/base/html/sprintf.html](https://stat.ethz.ch/R-manual/R-devel/library/base/html/sprintf.html))
    gives a full description of the supported formats.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档（[https://stat.ethz.ch/R-manual/R-devel/library/base/html/sprintf.html](https://stat.ethz.ch/R-manual/R-devel/library/base/html/sprintf.html)）提供了对支持格式的完整描述。
- en: 'Note that `%` in the format text is a special character and will be interpreted
    as the initial character of a place holder. What if we really mean `%` in the
    string? To avoid formatting interpretation, we need to use `%%` to represent a
    literal `%`. The following code is an example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，格式文本中的 `%` 是一个特殊字符，将被解释为占位符的初始字符。如果我们真的想在字符串中表示 `%`，为了避免格式化解释，我们需要使用 `%%`
    来表示字面量 `%`。以下代码是一个示例：
- en: '[PRE47]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using Python string functions in R
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 R 中使用 Python 字符串函数
- en: 'The `sprintf()` function is powerful but not perfect for all use cases. For
    example, if some parts have to appear multiple times in the template, you will
    need to write the same arguments multiple times. This often makes the code more
    redundant and a bit hard to modify:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`sprintf()` 函数功能强大，但并非所有用例都完美。例如，如果模板中某些部分需要多次出现，您将需要多次编写相同的参数。这通常会使代码更加冗余，并且修改起来有些困难：'
- en: '[PRE48]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'There are other ways to represent the placeholders. The `pystr` package provides
    the `pystr_format()` function to format strings in Python formatting style using
    either numeric or named placeholders. The preceding example can be rewritten with
    this function in two ways:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 表示占位符还有其他方法。`pystr` 包提供了 `pystr_format()` 函数，用于使用数字或命名的占位符以 Python 格式化风格格式化字符串。前面的例子可以用这个函数以两种方式重写：
- en: 'One is using numeric placeholders:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用数字占位符：
- en: '[PRE49]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The other is using named placeholders:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用命名的占位符：
- en: '[PRE50]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In both cases, no argument has to repeat, and the position the input appears
    at can be easily moved to other places in the template string.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，不需要重复任何参数，输入出现的位置可以轻松地移动到模板字符串的其他地方。
- en: Formatting date/time
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期/时间格式化
- en: In data analysis, it is common to encounter date and time data types. Perhaps,
    the simplest functions related with date are `Sys.Date()`, which returns the current
    date, and `Sys.time()`, which returns the current time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据分析中，经常会遇到日期和时间数据类型。也许，与日期最相关的最简单函数是 `Sys.Date()`，它返回当前日期，以及 `Sys.time()`，它返回当前时间。
- en: 'As the book is being rendered, the date is printed as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当书籍正在渲染时，日期的打印方式如下：
- en: '[PRE51]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And the time is:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 时间如下：
- en: '[PRE52]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'From the output, the date and time look like character vectors, but actually
    they are not:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出来看，日期和时间看起来像字符向量，但实际上它们不是：
- en: '[PRE53]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: They are, in essence, numeric values relative to an origin and have special
    methods to do date/time calculations. For a date, its numeric value means the
    number of days passed after 1970-01-01\. For a time, its numeric value means the
    number of seconds passed after 1970-01-01 00:00.00 UTC.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它们本质上是以原点为基准的数值，并且具有执行日期/时间计算的特殊方法。对于一个日期，它的数值表示自 1970-01-01 之后的总天数。对于一个时间，它的数值表示自
    1970-01-01 00:00.00 UTC 之后的总秒数。
- en: Parsing text as date/time
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将文本解析为日期/时间
- en: 'We can create a date relative to a customized origin:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个相对于自定义原点的日期：
- en: '[PRE54]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'However, in more cases, we create date and time from a standard text representation:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在更多情况下，我们从一个标准的文本表示形式创建日期和时间：
- en: '[PRE55]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'But if we can represent time in string such as 2016-02-10, then why do we need
    to create a `Date` object like we did earlier? It is because a date has more features:
    we can do date math with them. Suppose we have a date object, we can add or minus
    a number of days and get a new date:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们可以在字符串中代表时间，如 2016-02-10，那么为什么我们需要创建一个像之前那样创建的 `Date` 对象呢？这是因为日期具有更多功能：我们可以用它们进行日期计算。假设我们有一个日期对象，我们可以添加或减去一定数量的天数来得到一个新的日期：
- en: '[PRE56]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can directly subtract a date from another to get the difference in number
    of days between two dates:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接从另一个日期中减去一个日期，以得到两个日期之间天数差：
- en: '[PRE57]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output of `date2 - date1` looks like a message, but it is actually a numeric
    value. We can make it explicit using `as.numeric()`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`date2 - date1` 的输出看起来像一条消息，但实际上是一个数值。我们可以使用 `as.numeric()` 来使其更明确：'
- en: '[PRE58]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Time is similar, but there is no function called `as.Time()`. To create a date
    time from a text representation, we can use either `as.POSIXct()` or `as.POSIXlt()`.
    These two functions are different implementations of a date/time object under
    the POSIX standard. In the following example, we use `as.POSIXlt` to create a
    date/time object:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 时间类似，但没有名为 `as.Time()` 的函数。要从文本表示形式创建日期时间，我们可以使用 `as.POSIXct()` 或 `as.POSIXlt()`。这两个函数是
    POSIX 标准下日期/时间对象的两种不同实现。在以下示例中，我们使用 `as.POSIXlt` 来创建日期/时间对象：
- en: '[PRE59]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This type of object also defines `+` and `-` for simple time calculations.
    Unlike the date object, it works at the unit of seconds rather than days:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的对象还定义了 `+` 和 `-` 用于简单的时计算。与日期对象不同，它以秒为单位而不是以天为单位：
- en: '[PRE60]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Given a string representation of date or time in data, we have to convert it
    to date or date/time objects, which enable us to do calculations. Often, however,
    what we get in raw data is not always the format that can be directly recognized
    by `as.Date()` or `as.POSIXlt()`. In this case, we need to use a set of special
    letters as placeholders to represent certain parts of a date or time, just like
    we did with `sprintf()`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据中给定日期或时间的字符串表示形式时，我们必须将其转换为日期或日期/时间对象，这样我们就可以进行计算。然而，在原始数据中，我们得到的内容并不总是 `as.Date()`
    或 `as.POSIXlt()` 可以直接识别的格式。在这种情况下，我们需要使用一组特殊字母作为占位符来表示日期或时间的某些部分，就像我们使用 `sprintf()`
    一样。
- en: 'For example, for the input `2015.07.25`, `as.Date()` will produce an error
    if no format string is supplied:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于输入 `2015.07.25`，如果没有提供格式字符串，`as.Date()` 将产生错误：
- en: '[PRE61]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can use a format string as a template to tell `as.Date()` how to parse the
    string to a date:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用格式字符串作为模板来告诉 `as.Date()` 如何将字符串解析为日期：
- en: '[PRE62]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Similarly, for a non-standard date/time string, we also need to specify a template
    string to tell `as.POSIXlt()` how to handle it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于非标准的日期/时间字符串，我们还需要指定一个模板字符串来告诉`as.POSIXlt()`如何处理它：
- en: '[PRE63]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'An alternative (and more direct) function to convert a string to a date/time
    is `strptime()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串转换为日期/时间的另一种（更直接）的函数是`strptime()`：
- en: '[PRE64]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In fact, `as.POSIXlt()` is only a wrapper of `strptime()` for character input,
    but `strptime()` always requires that you supply the format string, while `as.POSIXlt()`
    works for standard formats without a supplied template.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`as.POSIXlt()`只是字符输入的`strptime()`的一个包装器，但`strptime()`始终要求你提供格式字符串，而`as.POSIXlt()`在没有提供模板的情况下适用于标准格式。
- en: 'Just like numeric vectors, date and date/time are vectors too. You can supply
    a character vector to `as.Date()` and get a vector of dates:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数值向量一样，日期和日期/时间也是向量。你可以向`as.Date()`提供一个字符向量，并得到一个日期向量：
- en: '[PRE65]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The math is also vectorized. In the following code, we will add some consecutive
    integers to the date, and we get consecutive dates as expected:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 数学运算也是向量化的。在以下代码中，我们将一些连续的整数添加到日期上，并得到预期的连续日期：
- en: '[PRE66]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The same feature also applies to date/time objects:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的功能也适用于日期/时间对象：
- en: '[PRE67]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Sometimes, the data uses integer representations of date and time. It makes
    parsing the date and time trickier. For example, to parse `20150610`, we will
    run the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，数据使用日期和时间的整数表示。这使得解析日期和时间变得更加复杂。例如，为了解析`20150610`，我们将运行以下代码：
- en: '[PRE68]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To parse `20150610093215`, we can specify the template to describe such a format:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析`20150610093215`，我们可以指定模板来描述这种格式：
- en: '[PRE69]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'A trickier example is to parse the date/time in the following data frame:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂一点的例子是解析以下数据框中的日期/时间：
- en: '[PRE70]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If we use `paste0()`on the columns of `datetimes` and directly call `strptime()`
    with the template used in the previous example, we will get a missing value that
    indicates that the first element is not consistent with the format:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`datetimes`的列上使用`paste0()`，并直接使用之前示例中使用的模板调用`strptime()`，我们将得到一个缺失值，这表明第一个元素与格式不一致：
- en: '[PRE71]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The problem lies in `92325`, which should be `092325`. We need to use `sprintf()`
    to make sure a leading zero is present when necessary:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在`92325`上，它应该是`092325`。我们需要使用`sprintf()`来确保在必要时存在前导零：
- en: '[PRE72]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Finally, the conversion works as supposed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，转换工作如预期的那样进行。
- en: Formatting date/time to strings
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化日期/时间为字符串
- en: 'In the previous section, you learned how to convert strings to date and date/time
    objects. In this section, you will learn the opposite: converting date and date/time
    objects back to strings according to a specific template.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何将字符串转换为日期和日期/时间对象。在本节中，你将学习相反的操作：根据特定的模板将日期和日期/时间对象转换回字符串。
- en: 'Once a date object is created, every time we print it, it is always represented
    in the standard format:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个日期对象，每次我们打印它时，它总是以标准格式表示：
- en: '[PRE73]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can convert the date to a string in a standard representation with `as.character()`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`as.character()`将日期转换为标准表示：
- en: '[PRE74]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'From the output, `my_date` looks the same, but the string is now merely a plain
    text and no longer supports date calculations:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出来看，`my_date`看起来相同，但现在字符串只是一个纯文本，不再支持日期计算：
- en: '[PRE75]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Sometimes, we need to format the date in a non-standard way:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要以非标准的方式格式化日期：
- en: '[PRE76]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In fact, `as.character()` calls `format()` directly behind the scenes. We will
    get exactly the same result using `format()`, and this is recommended in most
    cases:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`as.character()`在幕后直接调用`format()`。我们将得到完全相同的结果，这在大多数情况下是推荐的：
- en: '[PRE77]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The same thing also applies to a date/time object. We can further customize
    the template to include more texts other than the placeholders:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这也适用于日期/时间对象。我们可以进一步自定义模板，以包含除了占位符之外的其他文本：
- en: '[PRE78]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The format placeholders are much more than we mentioned. Read the documentation
    by typing in `?strptime` for detailed information.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 格式占位符远不止我们提到的那么多。通过输入`?strptime`来阅读文档，以获取详细信息。
- en: There are a number of packages to make dealing with date and time much easier.
    I recommend the `lubridate` package ([https://cran.r-project.org/web/packages/lubridate](https://cran.r-project.org/web/packages/lubridate))
    because it provides almost all the functions you need to work with date and time
    objects.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多包可以使处理日期和时间变得更容易。我推荐使用`lubridate`包（[https://cran.r-project.org/web/packages/lubridate](https://cran.r-project.org/web/packages/lubridate)），因为它提供了几乎所有你需要用来处理日期和时间对象的函数。
- en: In the previous sections, you learned a number of basic functions to deal with
    strings and date/time objects. These functions are useful but much less flexible
    than regular expressions. You will learn this very powerful technique in the next
    section.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了处理字符串和日期/时间对象的一些基本函数。这些函数很有用，但与正则表达式相比，它们的灵活性要小得多。你将在下一节学习这种非常强大的技术。
- en: Using regular expressions
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式
- en: 'For research, you may need to download data from open-access websites or authentication-required
    databases. These data sources provide data in various formats, and most of the
    data supplied are very likely well-organized. For example, many economic and financial
    databases provide data in the CSV format, which is a widely supported text format
    to represent tabular data. A typical CSV format looks like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于研究，你可能需要从开放获取网站或需要认证的数据库下载数据。这些数据源提供的数据格式多种多样，而且大部分提供的数据很可能组织得很好。例如，许多经济和金融数据库提供CSV格式的数据，这是一种广泛支持的文本格式，用于表示表格数据。典型的CSV格式如下所示：
- en: '[PRE79]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In R, it is convenient to call `read.csv()` to import a CSV file as a data frame
    with the right header and data types because the format is a natural representation
    of a data frame.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，使用`read.csv()`将CSV文件导入为具有正确标题和数据类型的data frame非常方便，因为这种格式是data frame的自然表示形式。
- en: However, not all data files are well organized, and dealing with poorly organized
    data is painstaking. Built-in functions such as `read.table()` and `read.csv()`
    work in many situations, but they may not help at all for such format-less data.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有数据文件都组织得很好，处理组织不良的数据非常费力。内置函数如`read.table()`和`read.csv()`在许多情况下都有效，但它们可能对这种无格式数据根本无济于事。
- en: 'For example, if you need to analyze raw data (`messages.txt`) organized in
    a CSV-like format as shown here, you had better be careful when you call `read.csv()`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你需要分析如下所示以CSV格式组织的原始数据（`messages.txt`），在调用`read.csv()`时你最好要小心：
- en: '[PRE80]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Suppose you want to import this file as a data frame in the following format
    which is nicely organized:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要以以下格式将此文件导入为data frame，该格式组织得很好：
- en: '[PRE81]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'However, if you blindly call `read.csv()`, then you will see that it does not
    work out correctly. This dataset is somehow special in the message column. There
    are extra commas that will be mistakenly interpreted as separators in a CSV file.
    Here is the data frame translated from the raw text:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你盲目地调用`read.csv()`，你会发现它并没有正确工作。这个数据集在消息列中有些特殊。存在额外的逗号，这些逗号会被错误地解释为CSV文件中的分隔符。以下是翻译自原始文本的数据框：
- en: '[PRE82]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'There are various methods to tackle this problem. You may consider using `strsplit()`
    for each line and manually take out the first several elements and paste others
    for each line split into multiple parts. But one of the simplest and most robust
    ways is to use the so-called Regular Expression ([https://en.wikipedia.org/wiki/Regular_expression](https://en.wikipedia.org/wiki/Regular_expression)).
    Don''t worry if you feel strange about the terminology. Its usage is very simple:
    describe the pattern that matches the text and extract the desired part from that
    text.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有多种方法。你可能考虑对每一行使用`strsplit()`，手动取出前几个元素，并将其他部分粘贴到每一行分割成多个部分。但其中最简单、最稳健的方法是使用所谓的正则表达式（[https://en.wikipedia.org/wiki/Regular_expression](https://en.wikipedia.org/wiki/Regular_expression)）。如果你对术语感到陌生，不要担心。它的用法非常简单：描述匹配文本的模式，并从该文本中提取所需的部分。
- en: Before we apply the technique, we need some basic knowledge. The best way to
    motivate yourself is look at a simpler problem and consider what is needed to
    solve the problem.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用技术之前，我们需要一些基本知识。最好的激励自己的方式是看看一个更简单的问题，并考虑解决该问题需要什么。
- en: 'Suppose we are dealing with the following text (`fruits.txt`) that describes
    the number or status of some fruits:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在处理以下文本（`fruits.txt`），它描述了一些水果的数量或状态：
- en: '[PRE83]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now, we want to pick out all fruits with a number rather than with status information.
    Although we can easily finish the task visually, it is not that easy for a computer.
    If the number of lines exceeds two thousand, it can be easy for a computer with
    the appropriate technique applied and, by contrast, be hard, time-consuming, and
    error prone for a human.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要挑选出带有数字而不是状态信息的所有水果。虽然我们可以轻松地通过视觉完成这项任务，但对于计算机来说并不那么容易。如果行数超过两千行，使用适当的技术处理对于计算机来说可能很容易，而相比之下，对于人类来说则可能很困难、耗时且容易出错。
- en: The first thing that should come to our mind is that we need to distinguish
    fruits with numbers and fruits with no numbers. In general, we need to distinguish
    texts that match a particular pattern from the ones that do not. Here, regular
    expression is definitely the right technique to work with.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该想到的是，我们需要区分带数字和不带数字的水果。一般来说，我们需要区分匹配特定模式和不匹配模式的文本。在这里，正则表达式无疑是处理这个问题的正确技术。
- en: 'Regular expressions solve problems using two steps: the first is to find a
    pattern to match the text and the second is to group the patterns to extract the
    information in need.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式通过两个步骤解决问题：第一步是找到一个匹配文本的模式，第二步是分组模式以提取所需的信息。
- en: Finding a string pattern
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找字符串模式
- en: To solve the problem, our computer does not have to understand what fruits actually
    are. We only need to find out a pattern that describes what we want. Literally,
    we want to get all lines that start with a word followed by a semicolon and a
    space, and end with an integer rather than words or other symbols.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决问题，我们的计算机不需要理解水果实际上是什么。我们只需要找出一个描述我们想要的模式的规律。字面上，我们想要获取所有以下列单词、分号和空格开始的行，并以整数结束而不是单词或其他符号。
- en: 'Regular expression provides a set of symbols to represent patterns. The preceding
    pattern can be described with `^\w+:\s\d+$` where meta-symbols are used to represent
    a class of symbols:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式提供了一套符号来表示模式。前面的模式可以用 `^\w+:\s\d+$` 来描述，其中元符号用于表示符号类：
- en: '`^`: This symbol is used at the beginning of the line'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`：这个符号用于行的开头'
- en: '`\w`: This symbol represents a word character'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\w`：这个符号代表一个单词字符'
- en: '`\s`: This symbol is a space character'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s`：这个符号是一个空格字符'
- en: '`\d`: This symbol is a digit character'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d`：这个符号是一个数字字符'
- en: '`$`: This symbol is used at the end of the line'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`：这个符号用于行的末尾'
- en: Moreover, `\w+` means one or more word characters, `:` is exactly the symbol
    we expect to see after the word, and `\d+` means one or more digit characters.
    See, this pattern is so magical that it represents all the cases we want and excludes
    all the cases we don't want.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`\w+` 表示一个或多个单词字符，`:` 是我们期望在单词后面看到的符号，而 `\d+` 表示一个或多个数字字符。看，这个模式如此神奇，它代表了所有我们想要的案例，并排除了所有我们不想要的案例。
- en: 'More specifically, this pattern matches lines such as `abc: 123` but excludes
    lines otherwise. To pick out the desired cases in R, we use `grep()` to get which
    strings match the pattern:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '更具体地说，这个模式匹配如 `abc: 123` 这样的行，但不包括其他行。为了在 R 中挑选出所需的案例，我们使用 `grep()` 来获取哪些字符串匹配该模式：'
- en: '[PRE84]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Note that `\` in R should be written as `\\` to avoid escaping. Then, we can
    filter `fruits` by `matches`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 R 中，`\` 应该写成 `\\` 以避免转义。然后，我们可以通过 `matches` 过滤 `fruits`：
- en: '[PRE85]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now, we successfully distinguish desirable lines from undesirable ones. The
    lines that match the pattern are chosen, and those that do not match the pattern
    are omitted.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经成功地区分了所需的行和不需要的行。匹配模式的行被选中，不匹配模式的行被省略。
- en: 'Note that we specify a pattern that starts with `^` and ends with `$` because
    we don''t want a partial matching. In fact, regular expressions perform partial
    matching by default, that is, if any part of the string matches the pattern, the
    whole string is considered to match the pattern. For example, the following code
    attempts to find out which strings match the two patterns respectively:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们指定了一个以 `^` 开头以 `$` 结尾的模式，因为我们不希望进行部分匹配。实际上，正则表达式默认执行部分匹配，即如果字符串的任何部分匹配模式，整个字符串就被认为是匹配模式的。例如，以下代码尝试分别找出哪些字符串匹配两个模式：
- en: '[PRE86]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The first pattern matches strings that include any digit (partial matching),
    while the second pattern with `^` and `$` matches strings that have only one digit.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模式匹配包含任何数字的字符串（部分匹配），而第二个模式使用 `^` 和 `$` 匹配只有单个数字的字符串。
- en: 'Once the pattern works correctly, we go to the next step: using groups to extract
    the data.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模式正确工作，我们就进行下一步：使用组来提取数据。
- en: Using groups to extract the data
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用组提取数据
- en: 'In the pattern string, we can make marks to identify the parts we want to extract
    from the texts using parenthesis. In this problem, we can modify the pattern to
    `(\w+):\s(\d+)`, where two groups are marked: one is the fruit name matched by `\w+`
    and the other is the number of the fruit matched by `\d+`.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式字符串中，我们可以用括号标记出我们想要从文本中提取的部分。在这个问题中，我们可以将模式修改为 `(\w+):\s(\d+)`，其中标记了两组：一组是匹配
    `\w+` 的水果名称，另一组是匹配 `\d+` 的水果数量。
- en: 'Now, we can use this modified version of the pattern to extract the information
    we want. Although it is perfectly possible to use built-in functions in R to do
    the job, I strongly recommend using functions in the `stringr` package. This package
    makes it substantially easier to use regular expressions. We call `str_match()`
    with the modified pattern with groups:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个修改后的模式来提取我们想要的信息。虽然使用R的内置函数做这个工作是完全可能的，但我强烈建议使用`stringr`包中的函数。这个包使得使用正则表达式变得容易得多。我们使用修改后的模式并带有组的`str_match()`：
- en: '[PRE87]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This time the matches are a matrix with more than one column. The groups in
    parenthesis are extracted from the text and are put to columns 2 and 3\. Now,
    we can easily transform this character matrix to a data frame with the right header
    and data types:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这次匹配的是一个有多列的矩阵。括号内的组是从文本中提取出来的，并放置在第二列和第三列。现在，我们可以轻松地将这个字符矩阵转换成带有正确标题和数据类型的data
    frame：
- en: '[PRE88]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, `fruits_df` is a data frame with the right header and data types:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`fruits_df`是一个带有正确标题和数据类型的data frame：
- en: '[PRE89]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: If you are not sure about the intermediate results in the preceding code, you
    can run the code line by line and see what happens in each step. Finally, this
    problem is perfectly solved with regular expressions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定前面代码的中间结果，你可以逐行运行代码，看看每一步发生了什么。最后，这个问题完全可以用正则表达式解决。
- en: 'From the previous example, we see that the magic of regular expressions is
    but a group of identifiers used to represent different kinds of characters and
    symbols. In addition to the meta-symbols we have mentioned, the following are
    also useful:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，我们看到正则表达式的魔力只是一组标识符，用于表示不同类型的字符和符号。除了我们提到的元符号外，以下也是很有用的：
- en: '`[0-9]`: This symbol represents a single integer from 0 to 9'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[0-9]`：这个符号代表从0到9的单个整数'
- en: '`[a-z]`: This symbol represents a single lower capital letter from a to z'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[a-z]`：这个符号代表从a到z的单个小写字母'
- en: '`[A-Z]`: This symbol represents a single upper capital letter from A to Z'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[A-Z]`：这个符号代表从A到Z的单个大写字母'
- en: '`.`: This symbol represents any single symbol'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`：这个符号代表任何单个符号'
- en: '`*`: This symbol represents a pattern, which may appear zero, one, or more
    times'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`：这个符号代表一个模式，可能出现零次、一次或多次'
- en: '`+`: This is a pattern, which appears one or more than one time'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`：这是一个模式，出现一次或多次'
- en: '`{n}`: This is a pattern that appears `n` times'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{n}`：这是一个出现`n`次的模式'
- en: '`{m,n}`: This is a pattern that appears at least `m` times and at most `n`
    times'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{m,n}`：这是一个至少出现`m`次且最多出现`n`次的模式'
- en: 'With these meta-symbols, we can easily check or filter string data. For example,
    suppose we have some telephone numbers from two countries that are mixed together.
    If the pattern of telephone numbers in one country is different from that of the
    other, regular expressions can be helpful to split them into two categories:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些元符号，我们可以轻松地检查或过滤字符串数据。例如，假设我们有一些来自两个国家的电话号码混合在一起。如果一个国家的电话号码模式与另一个国家不同，正则表达式可以帮助将它们分成两类：
- en: '[PRE90]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Note that there is an exception in the data. The number has no `-` in the middle.
    For unexceptional cases, it should be easy to figure out the pattern of the two
    types of telephone numbers:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，数据中有一个例外。数字中间没有`-`。对于非例外情况，应该很容易找出两种电话号码的模式：
- en: '[PRE91]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'To find out the exceptional cases, `grepl()` is more useful because it returns
    a logical vector to indicate whether each element matches the pattern. Therefore,
    we can use this function to choose all records that do not match the given patterns:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出例外情况，`grepl()`更有用，因为它返回一个逻辑向量，指示每个元素是否与给定的模式匹配。因此，我们可以使用这个函数来选择所有不匹配给定模式的记录：
- en: '[PRE92]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The preceding code basically says that all records that do not match the two
    patterns are considered exceptional. Imagine we have millions of records to check.
    Exceptional cases may be in any format, so it is more robust to use this method:
    excluding all valid records to find out invalid records.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码基本上表示所有不匹配两种模式的记录都被认为是例外。想象一下，我们有一百万条记录要检查。例外情况可能以任何格式存在，因此使用这种方法（排除所有有效记录以找出无效记录）更为稳健。
- en: Reading data in customizable ways
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以可定制的方式读取数据
- en: 'Now, let''s go back to the problem we faced at the very beginning of this section.
    The procedure is exactly the same with the fruits example: finding the pattern
    and making groups.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到本节开头遇到的问题。这个程序与水果示例中的程序完全相同：找到模式并分组。
- en: 'First, let''s look at a typical line of the raw data:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看原始数据中的一条典型行：
- en: '[PRE93]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: It is obvious that all lines are based on the same format, that is, date, time,
    sender, receiver, and message are separated by commas. The only special thing
    is that commas may appear in the message, but we don't want our code to interpret
    it as separators.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，所有行都是基于相同的格式，即日期、时间、发件人、收件人和消息由逗号分隔。唯一特殊的是，消息中可能包含逗号，但我们不希望我们的代码将其解释为分隔符。
- en: Note that regular expressions perfectly works with this purpose as it did in
    the previous example. To represent one or more symbols that follow the same pattern,
    just place a plus sign (`+`) after the symbolic identifier. For example, `\d+`
    represents a string consisting of one or more digital characters between "0" and
    "9". For example,"1","23", and"456" all match this pattern, while"word" does not.
    There are also situations where a pattern may or may not appear at all. Then,
    we need to place a `*` after the symbolic identifier to mark that this particular
    pattern may appear once or more, or may not appear, in order to match a wide range
    of texts.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，正则表达式与前面的例子一样完美地适用于这个目的。要表示一个或多个遵循相同模式的符号，只需在符号标识符后放置一个加号（`+`）。例如，`\d+` 表示由一个或多个介于
    "0" 和 "9" 之间的数字字符组成的字符串。例如，“1”，“23”，和“456”都匹配这个模式，而“word”则不匹配。也存在某些模式可能或可能不出现的情况。然后，我们需要在符号标识符后放置一个
    `*` 来标记这个特定模式可能出现一次或多次，或者可能不出现，以便匹配广泛的文本。
- en: 'Now, let''s go back to our problem. We need to recognize a sufficiently general
    pattern of a typical line. The following is the pattern with grouping we should
    figure out:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的问题。我们需要识别典型行的足够通用的模式。以下是我们应该解决的分组模式：
- en: '[PRE94]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, we need to import the raw texts in exactly the same way as we did in the
    fruits example using `readLines()`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要以与我们在水果示例中使用 `readLines()` 的相同方式导入原始文本：
- en: '[PRE95]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Then, we need to work out the pattern that represents the text and the information
    we want to extract from the text:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要找出代表我们想要从文本中提取的文本和信息模式的模式：
- en: '[PRE96]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The pattern here looks like some secret code. Don't worry. That's exactly how
    regular expression works, and it should make some sense now if you go through
    the previous examples.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的模式看起来像某种秘密代码。别担心，这正是正则表达式的工作方式，如果你看过了前面的例子，现在应该能理解一些了。
- en: 'The regular expression works perfectly. The `messages_df` file looks like the
    following structure:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式工作得非常完美。`messages_df` 文件看起来像以下结构：
- en: '[PRE97]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The pattern we use is comparable to a key. The hard part of any regular expression
    application is to find the key. Once we get it, we are able to open the door and
    extract as much information as we want from the messy texts. Generally speaking,
    how difficult it is to find that key largely relies on the difference between
    the positive cases and negative cases. If the difference is quite obvious, a few
    symbols will solve the problem. If the difference is subtle and many special cases
    are involved, just like most real-world problems, you need more experience, harder
    thinking, and many trials and errors to work out the solution.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的模式可以比作一把钥匙。任何正则表达式应用的难点在于找到这把钥匙。一旦我们找到了它，我们就能打开门，并从混乱的文本中提取我们想要的信息。一般来说，找到这把钥匙的难度很大程度上取决于正例和反例之间的差异。如果差异非常明显，几个符号就能解决问题。如果差异微妙且涉及许多特殊情况，就像大多数现实世界问题一样，你需要更多的经验，更深入的思考，以及许多尝试和错误来找到解决方案。
- en: Through the motivating examples mentioned earlier, you should now grasp the
    idea of regular expressions. You don't have to understand how it works internally,
    but it is very useful to become familiar with the related functions, whether they
    are built in or provided by certain packages.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面提到的激励性例子，你现在应该已经掌握了正则表达式的概念。你不需要理解它是如何内部工作的，但熟悉相关的函数非常有用，无论是内置的还是某些包提供的。
- en: If you want to learn more, RegexOne ([http://regexone.com/](http://regexone.com/))
    is a very good place to learn the basics in an interactive manner. To learn more
    specific examples and the full set of identifiers, this website ([http://www.regular-expressions.info/](http://www.regular-expressions.info/))
    is a good reference. To find out good patterns to solve your problem, you can
    visit RegExr ([http://www.regexr.com/](http://www.regexr.com/)) to test your patterns
    interactively online.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多，RegexOne ([http://regexone.com/](http://regexone.com/)) 是一个非常好的地方，可以以交互式的方式学习基础知识。要了解更多具体的示例和完整的标识符集合，这个网站
    ([http://www.regular-expressions.info/](http://www.regular-expressions.info/))
    是一个很好的参考。为了找到解决你问题的良好模式，你可以访问 RegExr ([http://www.regexr.com/](http://www.regexr.com/))
    以在线交互式地测试你的模式。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about a number of built-in functions for manipulating
    character vectors and converting between date/time objects and their string representations.
    You also learned about the basic idea of regular expressions, a very powerful
    tool to check and filter string data and extract information from raw texts.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了关于操作字符向量以及在不同日期/时间对象及其字符串表示之间进行转换的许多内置函数。你还了解了正则表达式的基本概念，这是一个非常强大的工具，用于检查和过滤字符串数据，并从原始文本中提取信息。
- en: With the vocabulary we built in this and previous chapters, we are now able
    to work with basic data structures. In the next chapter, you will learn about
    some tools and techniques to work with data. We will get started with reading
    and writing simple data files, producing graphics of various types, applying basic
    statistical analysis and data-mining models on simple datasets, and using numeric
    methods to solve root-solving and optimization problems.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在本章和前几章中构建的词汇，我们现在能够处理基本的数据结构。在下一章中，你将学习一些用于处理数据的工具和技术。我们将从读取和写入简单的数据文件开始，生成各种类型的图形，对简单数据集应用基本的统计分析和数据挖掘模型，以及使用数值方法来解决根求解和优化问题。
