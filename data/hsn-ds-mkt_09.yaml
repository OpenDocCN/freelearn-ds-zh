- en: Recommending the Right Products
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐合适的产品
- en: In this chapter, we are going to dive deeper into building product recommendation
    systems with which we can target customers better, using product recommendations
    that are custom-tailored toward individual customers. Studies have shown that
    personalized product recommendations improve conversion rates and customer retention
    rates. As we have more data available for utilizing data science and machine learning
    for target marketing, the importance and effectiveness of customized product recommendations
    in marketing messages have grown significantly. In this chapter, we are going
    to discuss the commonly-used machine learning algorithms for developing recommendation
    systems, collaborative filtering, and the two approaches to implementing collaborative
    filtering algorithms for product recommendations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨如何构建产品推荐系统，通过为个别客户量身定制的产品推荐来更好地定位客户。研究表明，个性化的产品推荐能够提高转化率和客户留存率。随着我们可以利用数据科学和机器学习进行目标营销的数据越来越多，定制化产品推荐在营销信息中的重要性和有效性显著增长。在本章中，我们将讨论常用的机器学习算法，以开发推荐系统，协同过滤，以及实现协同过滤算法进行产品推荐的两种方法。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Collaborative filtering and product recommendation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协同过滤与产品推荐
- en: Building a product recommendation algorithm with Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python构建产品推荐算法
- en: Building a product recommendation algorithm with R
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用R构建产品推荐算法
- en: Collaborative filtering and product recommendation
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤与产品推荐
- en: According to a study conducted by Salesforce, those customers who are prompted
    with personalized product recommendations drive 24% of the orders and 26% of the
    revenue. This signifies how much impact product recommendation has on order volume
    and the overall sales revenue. In the report that Salesforce published, they have
    also found that product recommendations lead to repeat visits, purchases with
    recommendations yield higher average-order value, and customers do buy recommended
    items. You can view this report at: [https://www.salesforce.com/blog/2017/11/personalized-product-recommendations-drive-just-7-visits-26-revenue](https://www.salesforce.com/blog/2017/11/personalized-product-recommendations-drive-just-7-visits-26-revenue).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Salesforce进行的一项研究，那些收到个性化产品推荐的客户驱动了24%的订单和26%的收入。这表明，产品推荐对订单量和整体销售收入有多大的影响。在Salesforce发布的报告中，他们还发现，产品推荐会导致重复访问，通过推荐进行的购买会产生更高的平均订单价值，且客户确实会购买推荐的商品。你可以查看此报告：[https://www.salesforce.com/blog/2017/11/personalized-product-recommendations-drive-just-7-visits-26-revenue](https://www.salesforce.com/blog/2017/11/personalized-product-recommendations-drive-just-7-visits-26-revenue)。
- en: Product recommender system
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品推荐系统
- en: A **product recommender system** is a system with the goal of predicting and
    compiling a list of items that a customer is likely to purchase. Recommender systems
    have gained lots of popularity in recent years and have been developed and implemented
    for various business use cases. For example, the music streaming service, Pandora,
    utilizes recommender systems for music recommendations for their listeners. The
    e-commerce company, Amazon, utilizes recommendater systems to predict and show
    a list of products that a customer is likely to purchase. The media service provider,
    Netflix, uses recommender systems to recommend movies or TV shows for individual
    users that they are likely to watch. The usage of a recommender system does not
    stop here. It can also be used to recommend related articles, news, or books to
    users. With the potential of being used in a variety of areas, recommender systems
    play a critical role in many businesses, especially in e-commerce and media businesses,
    as they directly impact the sales revenue and user engagements.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**产品推荐系统**是一个旨在预测并编制出客户可能购买的商品列表的系统。推荐系统近年来已经获得了广泛的应用，并且为各种商业用例开发和实施。例如，音乐流媒体服务Pandora使用推荐系统为听众推荐音乐；电子商务公司Amazon使用推荐系统预测并显示客户可能购买的产品列表；媒体服务提供商Netflix使用推荐系统为个别用户推荐他们可能观看的电影或电视剧。推荐系统的使用不仅限于此，它还可以用来推荐相关的文章、新闻或书籍。由于可以应用于多种领域，推荐系统在许多行业中扮演着关键角色，特别是在电子商务和媒体行业，因为它们直接影响销售收入和用户参与度。'
- en: 'There are typically two ways to produce a list of recommendations:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有两种方式来生成推荐列表：
- en: Collaborative filtering
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协同过滤
- en: Content-based filtering
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于内容的过滤
- en: The **collaborative filtering** method is based on previous user behaviors,
    such as pages that they viewed, products that they purchased, or ratings that
    they have given to different items. The collaborative filtering approach then
    uses this data to find similarities between users or items, and recommends the
    most similar items or contents to the users. The basic assumption behind the collaborative
    filtering method is that those who have viewed or purchased similar contents or
    products in the past are likely to view or purchase similar kinds of contents
    or products in the future. Thus, based on this assumption, if one person purchased
    items A, B, and C and another person purchased items A, B, and D in the past,
    then the first person is likely to purchase item D and the other person is likely
    to purchase the item C, as they share lots of similarities between them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**协同过滤**方法基于用户之前的行为，例如他们浏览过的页面、购买过的产品或他们对不同物品给出的评分。协同过滤方法利用这些数据来寻找用户或物品之间的相似性，并向用户推荐最相似的物品或内容。协同过滤方法背后的基本假设是，过去浏览或购买过相似内容或产品的用户，未来也很可能会浏览或购买相似的内容或产品。因此，基于这一假设，如果一个人曾经购买过A、B、C三件物品，另一个人购买过A、B、D三件物品，那么第一个人很可能会购买D，而另一个人则可能会购买C，因为他们之间有很多相似之处。'
- en: '**Content-based filtering**, on the other hand, produces a list of recommendations
    based on the characteristics of an item or a user. It typically looks at the keywords
    that describe the characteristics of an item. The basic assumption behind the
    content-based filtering method is that the users are likely to view or purchase
    items that are similar to those items that they have bought or viewed in the past.
    For example, if a user has listened to some songs in the past, then the content-based
    filtering method will recommend similar kinds of songs that share similar characteristics
    to those songs that the user has already listened to.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**基于内容的过滤**方法根据物品或用户的特征生成推荐列表。它通常会查看描述物品特征的关键词。基于内容的过滤方法背后的基本假设是，用户很可能会浏览或购买与他们过去购买或浏览过的物品相似的物品。例如，如果一个用户过去听过一些歌曲，那么基于内容的过滤方法会推荐与该用户已经听过的歌曲特征相似的其他歌曲。
- en: In this chapter, we are going to use a collaborative filtering algorithm to
    build a product recommendation system. Let's take a closer look at how a collaborative
    filtering algorithm is built in the following section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章节中，我们将使用协同过滤算法来构建一个产品推荐系统。接下来，我们将仔细看看如何在以下部分构建协同过滤算法。
- en: Collaborative filtering
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤
- en: 'As discussed in the previous section, a collaborative filtering algorithm is
    used to recommend products based on the history of user behaviors and the similarities
    between users. The first step to implementing a collaborative filtering algorithm
    for a product recommendation system is building a **user-to-item matrix**. A user-to-item
    matrix comprises individual users in the rows and individual items in the columns.
    It will be easier to explain with an example. Take a look at the following matrix:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如上一节所讨论的，协同过滤算法是根据用户行为的历史和用户之间的相似性来推荐产品的。实现协同过滤算法的第一步是构建一个**用户到物品的矩阵**。用户到物品的矩阵由行中的单个用户和列中的单个物品组成。通过一个示例来解释会更容易。请看以下矩阵：
- en: '![](img/eb6b5e42-258a-4e01-b5ef-788d8648559f.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb6b5e42-258a-4e01-b5ef-788d8648559f.png)'
- en: The rows in this matrix represent each user and the columns represent each item.
    The values in each cell represent whether the given user bought the given item
    or not. For example, user **1** has purchased items **B** and **D** and user **2**
    has purchased items **A**, **B**, **C**, and **E**. In order to build a collaborative
    filtering-based product recommendation system, we need to first build this type
    of user-to-item matrix. We will discuss how to build such a matrix programmatically
    in more detail with an example in the programming exercises in the following section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该矩阵中的行代表每个用户，列代表每个物品。每个单元格中的值表示该用户是否购买了该物品。例如，用户**1**购买了物品**B**和**D**，而用户**2**购买了物品**A**、**B**、**C**和**E**。为了构建基于协同过滤的产品推荐系统，我们需要首先建立这种用户到物品的矩阵。在接下来的编程练习部分，我们将通过一个示例更详细地讨论如何通过编程构建这样的矩阵。
- en: 'With this user-to-item matrix, the next step to building a collaborative filtering-based
    product recommender system is to compute similarities between users. To measure
    the similarities, **cosine similarity** is frequently used. The equation for computing
    the cosine similarity between two users looks as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个用户到物品的矩阵，构建基于协同过滤的产品推荐系统的下一步是计算用户之间的相似性。为了衡量相似性，**余弦相似度**通常被使用。计算两个用户之间余弦相似度的公式如下：
- en: '![](img/22ae66e5-e7e8-4b16-ab16-1bf069d35465.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22ae66e5-e7e8-4b16-ab16-1bf069d35465.png)'
- en: In this equation, *U[1]* and *U[2]* represent user **1** and user **2**. *P[1i]*
    and *P[2i]* represent each product, *i*, that user **1** and user **2** have bought.
    If you use this equation, you will get `0.353553` as the cosine similarity between
    users **1** and **2** in the previous example and `0.866025` as the cosine similarity
    between users **2** and **4**. As you can imagine, the larger the cosine similarity
    is, the more similar the two users are. So, in our example, users **2** and **4**
    are more similar to each other than users **1** and **2**. We will discuss how
    we can compute cosine similarities between users using Python and R in the following
    programming exercise section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，*U[1]* 和 *U[2]* 分别代表用户 **1** 和用户 **2**。*P[1i]* 和 *P[2i]* 分别代表用户 **1**
    和用户 **2** 购买的每一个产品 *i*。如果你使用这个公式，你将得到 `0.353553` 作为用户 **1** 和用户 **2** 之间的余弦相似度，以及
    `0.866025` 作为用户 **2** 和用户 **4** 之间的余弦相似度。正如你所想，余弦相似度越大，两个用户的相似性越高。所以，在我们的例子中，用户
    **2** 和用户 **4** 比用户 **1** 和用户 **2** 更为相似。我们将在接下来的编程练习部分讨论如何使用 Python 和 R 计算用户之间的余弦相似度。
- en: Lastly, when using a collaborative filtering algorithm for product recommendations,
    there are two approaches that you can take—a user-based approach and an item-based
    approach. As the names suggest, the user-based approach to collaborative filtering
    uses the similarities between users. On the other hand, the item-based approach
    collaborative filtering uses the similarities between items. This means that when
    we are calculating similarities between the two users in user-based approach collaborative
    filtering, we need to build and use a user-to-item matrix, as we have discussed
    previously. However, for the item-based approach, we need to calculate similarities
    between the two items, and this means that we need to build and use an item-to-user
    matrix, which we can get by simply transposing the user-to-item matrix. In the
    following programming exercise section, we are going to discuss in more detail
    the differences between these two approaches and how to build recommendation systems
    based on these two approaches using Python and R.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在使用协同过滤算法进行产品推荐时，你可以采取两种方法——基于用户的方法和基于物品的方法。顾名思义，基于用户的协同过滤方法使用用户之间的相似性。另一方面，基于物品的协同过滤方法使用物品之间的相似性。这意味着，当我们在基于用户的方法中计算两个用户之间的相似性时，我们需要构建并使用用户到物品的矩阵，正如我们之前所讨论的。然而，在基于物品的方法中，我们需要计算两个物品之间的相似性，这意味着我们需要构建并使用物品到用户的矩阵，这个矩阵可以通过简单地转置用户到物品的矩阵获得。在接下来的编程练习部分，我们将更详细地讨论这两种方法之间的区别，以及如何使用
    Python 和 R 基于这两种方法构建推荐系统。
- en: Building a product recommendation algorithm with Python
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 构建产品推荐算法
- en: In this section, we are going to discuss how to build a product recommendation
    system using Python. More specifically, we will be learning how to implement a
    collaborative filtering algorithm in Python using a machine learning library,
    `scikit-learn`. For those readers who would like to use R instead of Python for
    this exercise, you can skip to the next section. We will start this section by
    analyzing some e-commerce business data and then discuss the two approaches to
    building a product recommendation system with collaborative filtering.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何使用 Python 构建产品推荐系统。更具体地说，我们将学习如何使用机器学习库 `scikit-learn` 在 Python
    中实现协同过滤算法。对于那些想使用 R 而非 Python 完成本次练习的读者，可以跳过到下一节。本节的开始，我们将分析一些电子商务业务数据，然后讨论使用协同过滤构建产品推荐系统的两种方法。
- en: 'For this exercise, we will be using one of the publicly available datasets
    from the UCI Machine Learning Repository, which can be found at this link: [http://archive.ics.uci.edu/ml/datasets/online+retail#](http://archive.ics.uci.edu/ml/datasets/online+retail#).
    You can follow this link and download the data in Microsoft Excel format, in a
    file named `Online Retail.xlsx`. Once you have downloaded this data, you can load
    it into your Jupyter Notebook by running the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本练习，我们将使用UCI机器学习库中的一个公开数据集，您可以通过以下链接找到它：[http://archive.ics.uci.edu/ml/datasets/online+retail#](http://archive.ics.uci.edu/ml/datasets/online+retail#)。您可以点击该链接并下载名为`Online
    Retail.xlsx`的Microsoft Excel格式数据。下载完数据后，您可以通过运行以下命令将其加载到您的Jupyter Notebook中：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Similar to [Chapter 5](73a716c6-6a84-4785-b04e-87651d0a29d1.xhtml), *Product
    Analytics*, we are using the `read_excel` function in the `pandas` package to
    load the data in Excel format. We provide the path to the data to the argument,
    `io=`, and the name of the Excel spreadsheet to the argument, `sheet_name`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[第5章](73a716c6-6a84-4785-b04e-87651d0a29d1.xhtml)，*产品分析*，我们在`pandas`包中使用`read_excel`函数来加载Excel格式的数据。我们将数据的路径传递给参数`io=`，并将Excel工作表的名称传递给参数`sheet_name`。
- en: 'Once you have loaded this data into a `pandas` `DataFrame`, it should look
    as in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将数据加载到`pandas`的`DataFrame`中，它应该如下所示：
- en: '![](img/e124c242-0c1d-4f1a-bb53-77c13b96399a.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e124c242-0c1d-4f1a-bb53-77c13b96399a.png)'
- en: 'If you recall from the previous chapter, there are records with negative values
    in the `Quantity` column, which represent canceled orders. We are going to disregard
    and remove these records. We can filter out all these records in our `DataFrame` with
    the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得上一章的内容，`Quantity`列中有一些记录的值为负数，表示取消的订单。我们将忽略并移除这些记录。我们可以使用以下代码从`DataFrame`中过滤掉所有这些记录：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Data preparation
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据准备
- en: 'Before we dive into building a product recommender engine using a collaborative
    filtering algorithm, we need to do the following couple of things:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用协同过滤算法构建产品推荐引擎之前，我们需要完成以下几件事情：
- en: Handle `NaN` values in the dataset
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数据集中的`NaN`值
- en: Build a customer-to-item matrix
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建客户-商品矩阵
- en: First, we need to handle `NaN` values in our dataset, especially those `NaNs`
    in the `CustomerID` field. Without correct values in the `CustomerID` field, we
    cannot build a proper recommendation system, since the collaborative filtering
    algorithm depends on the historical item purchase data for individual customers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要处理数据集中的`NaN`值，特别是在`CustomerID`字段中的`NaN`值。没有正确的`CustomerID`值，我们就无法构建一个正确的推荐系统，因为协同过滤算法依赖于单个客户的历史购买数据。
- en: Second, we need to build customer-to-item matrix before we move onto implementing
    the collaborative filtering algorithm for product recommendation. The customer-item
    matrix is simply tabular data, where each column represents each product or item,
    each row represents a customer, and the value in each cell represents whether
    the given customer purchased the given product or not.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在我们继续实现协同过滤算法进行产品推荐之前，我们需要构建客户-商品矩阵。客户-商品矩阵就是一张表格数据，其中每一列代表一个产品或商品，每一行代表一个客户，每个单元格中的值表示该客户是否购买了该商品。
- en: Handling NaNs in the CustomerID field
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理`CustomerID`字段中的NaN值
- en: If you look closely at the data, you will notice that there are some records
    with no `CustomerID`. As we need to build a customer-item matrix where each row
    is specific to each customer, we cannot include those records with no `CustomerID`
    in our data. Let's first take a look at how many records do not have `CustomerID`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看数据后，你会发现有一些记录没有`CustomerID`。由于我们需要构建一个客户-商品矩阵，其中每一行代表一个客户，因此我们不能将没有`CustomerID`的记录包含在数据中。让我们首先看看有多少条记录没有`CustomerID`。
- en: 'Take a look at the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `isna` function that we are using here detects missing values and returns `True`
    for each missing value. By summing over these values, we can count the number
    of records with no `CustomerID`. The result looks as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里使用的`isna`函数可以检测缺失值，并为每个缺失值返回`True`。通过对这些值求和，我们可以计算出没有`CustomerID`的记录数。结果如下所示：
- en: '![](img/b7555d17-37a0-4481-b667-141dce72b1eb.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7555d17-37a0-4481-b667-141dce72b1eb.png)'
- en: 'As you can see from this output, there are `133,361` records with no `CustomerID`.
    And some of the data with missing `CustomerID` looks as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出结果可以看到，有`133,361`条记录没有`CustomerID`。缺少`CustomerID`的数据如下所示：
- en: '![](img/4abdcb7c-5ee9-44bb-b3fa-6f48acb5eeb9.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4abdcb7c-5ee9-44bb-b3fa-6f48acb5eeb9.png)'
- en: 'Now that we know there are records with missing `CustomerID` entries, we need
    to exclude them from further analysis. One way to drop them from our `DataFrame`
    is by using the `dropna` function, as in the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道有一些记录缺少`CustomerID`，我们需要将它们排除在进一步分析之外。将它们从`DataFrame`中删除的一种方法是使用`dropna`函数，代码如下：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `dropna` function in the `pandas` package removes records with missing
    values from a given DataFrame. As you can see from this code snippet, using the `subset`
    parameter, we can drop missing values based on specific columns. Here, we are
    dropping records for those without `CustomerID`. Once you run this code, all the
    records in the DataFrame, `df`, will now have `CustomerID` values. The dimensions
    of the DataFrame, `df`, before and after dropping the missing values should look
    as in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`包中的`dropna`函数会删除给定`DataFrame`中缺失值的记录。从这个代码片段可以看出，使用`subset`参数，我们可以基于特定的列来删除缺失值。在这里，我们删除了没有`CustomerID`的记录。一旦运行这段代码，`DataFrame`中的所有记录，`df`，将会有`CustomerID`值。删除缺失值前后，`DataFrame`的维度应该如下面的截图所示：'
- en: '![](img/92800353-212d-4136-99a3-69124fc51139.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92800353-212d-4136-99a3-69124fc51139.png)'
- en: As you can see from this output, the `133,361` records with no `CustomerID` values
    were dropped from the original `DataFrame`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中可以看出，原始`DataFrame`中没有`CustomerID`值的`133,361`条记录被删除了。
- en: Building a customer-item matrix
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建客户-商品矩阵
- en: The data we have now represents individual items purchased by customers. However,
    in order to build a product recommendation system with a collaborative filtering
    algorithm, we need to have data where each record contains information on which
    item each customer has bought. In this section, we are going to transform the
    data into a customer-item matrix, where each row represents a customer and the
    columns correspond to different products.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有的数据表示客户购买的单个商品。然而，为了使用协同过滤算法构建产品推荐系统，我们需要的数据格式是每条记录包含每个客户购买的商品信息。在本节中，我们将把数据转换成客户-商品矩阵，其中每一行代表一个客户，列对应不同的商品。
- en: 'Let''s take a look at the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的代码：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see from this code snippet, we are using the `pivot_table` function
    to transform our data into a customer-item matrix. Here, we define the `index` as `CustomerID`,
    and use `columns` to represent each `StockCode`. By using `sum` as the `aggfunc`
    and the `Quantity` field for `values`, we can sum all the quantities bought for
    each item. A snapshot of the resulting `customer_item_matrix` looks as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个代码片段可以看出，我们正在使用`pivot_table`函数将数据转换为客户-商品矩阵。在这里，我们将`index`定义为`CustomerID`，并用`columns`表示每个`StockCode`。通过将`aggfunc`设为`sum`，并使用`Quantity`字段作为`values`，我们可以对每个商品的购买数量进行求和。生成的`customer_item_matrix`的快照如下所示：
- en: '![](img/bb68edb5-32e0-4647-9d18-17fbac432bac.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb68edb5-32e0-4647-9d18-17fbac432bac.png)'
- en: Let's take a closer look at this data. The customer with `CustomerID` `12481`
    has bought `36` of the item with `StockCode` `15036`. Similarly, the customer
    with `CustomerID` `12484` has bought `16` of the item with `StockCode` `11001`,
    and the customer with `CustomerID` `12488` has bought `10` of the item with `StockCode`
    `10135`. As you can see from this, we now have a matrix where each row represents
    the total quantities bought for each product for each customer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这些数据。`CustomerID`为`12481`的客户购买了`StockCode`为`15036`的商品`36`件。同样，`CustomerID`为`12484`的客户购买了`StockCode`为`11001`的商品`16`件，`CustomerID`为`12488`的客户购买了`StockCode`为`10135`的商品`10`件。通过这些数据，可以看出，我们现在有了一个矩阵，其中每一行表示每个客户购买的每个商品的总数量。
- en: 'Now, let''s `0`-`1` encode this data, so that the value of `1` means that the
    given product was purchased by the given customer, and the value of `0` means
    that the given product was never purchased by the given customer. Take a look
    at the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对数据进行`0`-`1`编码，使得`1`表示该商品已被给定客户购买，而`0`表示该商品未曾被该客户购买。请看下面的代码：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see from this code, we are using the `applymap` function, which
    applies a given function to each element of a DataFrame. The Lambda function that
    we are using in this code simply encodes all the elements whose values are greater
    than `0` with `1`, and the rest with `0`. A snapshot of this transformed DataFrame
    looks as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码可以看出，我们正在使用`applymap`函数，该函数将给定的函数应用到DataFrame的每个元素上。我们在这段代码中使用的Lambda函数会将所有值大于`0`的元素编码为`1`，其余的编码为`0`。这个转换后的DataFrame快照如下所示：
- en: '![](img/c9a22faa-0a07-46fa-b046-869a3bb2d82f.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9a22faa-0a07-46fa-b046-869a3bb2d82f.png)'
- en: We now have a customer-item matrix that we can use for the collaborative filtering
    algorithm. Let's now move on to building product recommender engines.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个客户-物品矩阵，可以用于协同过滤算法。接下来，我们将进入构建产品推荐引擎的步骤。
- en: Collaborative filtering
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤
- en: In this section, we are going to explore two approaches to building a product
    recommender engine—user-based versus item-based. In the user-based approach, we
    compute similarities between users based on their item purchase history. In the
    item-based approach, on the other hand, we compute similarities between items
    based on which items are often bought together with which other items.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将探索构建产品推荐引擎的两种方法——基于用户的和基于物品的。在基于用户的方法中，我们根据用户的物品购买历史计算用户之间的相似度。而在基于物品的方法中，我们根据哪些物品经常和其他物品一起购买来计算物品之间的相似度。
- en: 'To measure the similarity between users or between items, we are going to use
    the `cosine_similarity` method in the `scikit-learn` package. You can import this
    function using the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了衡量用户之间或物品之间的相似度，我们将使用`cosine_similarity`方法，该方法来自`scikit-learn`包。你可以使用以下代码导入此函数：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This `cosine_similarity` function in the `sklearn` package computes the pair-wise
    cosine similarities in the given data. Let's dive in now!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`sklearn`包中的`cosine_similarity`函数计算给定数据中每对样本之间的余弦相似度。现在让我们深入了解一下！'
- en: User-based collaborative filtering and recommendations
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于用户的协同过滤与推荐
- en: 'In order to build a user-based collaborative filtering algorithm, we need to
    compute cosine similarities between users. Let''s take a look at the following
    code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建基于用户的协同过滤算法，我们需要计算用户之间的余弦相似度。让我们看一下以下代码：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As is noticeable from this code, we are using the `cosine_similarity` function
    from the `sklearn` package''s `metrics.pairwise` module. This function computes
    pairwise cosine similarities between the samples and outputs the results as an
    `array` type. Then, we create a `pandas` `DataFrame` with this output array and
    store it into a variable named `user_user_sim_matrix`, which stands for *user-to-user
    similarity matrix*. The result looks as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码可以看出，我们正在使用`sklearn`包中`metrics.pairwise`模块的`cosine_similarity`函数。该函数计算样本之间的成对余弦相似度，并将结果输出为`array`类型。然后，我们用这个输出数组创建一个`pandas`的`DataFrame`，并将其存储在名为`user_user_sim_matrix`的变量中，这代表*用户-用户相似度矩阵*。结果如下所示：
- en: '![](img/6c9a348a-5b29-48c1-ae38-3c39e6d09f9a.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c9a348a-5b29-48c1-ae38-3c39e6d09f9a.png)'
- en: 'As you can see from this snapshot of the user-to-user similarity matrix, the
    index and column names are not easy to understand. Since each column and each
    row index stand for individual customers, we are going to rename the index and
    columns using the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个用户-用户相似度矩阵的快照中可以看到，索引和列名并不容易理解。由于每一列和每一行的索引代表的是个别客户，我们将使用以下代码重命名索引和列名：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now the result looks as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在结果如下所示：
- en: '![](img/e4036bf2-6b6b-4551-a321-3dd1e022a9bc.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4036bf2-6b6b-4551-a321-3dd1e022a9bc.png)'
- en: Let's take a closer look at this user-to-user similarity matrix. As you can
    imagine, the cosine similarity between a customer to themselves is `1`, and this
    is what we can observe from this similarity matrix. The diagonal elements in this
    user-to-user similarity matrix have values of `1`. The rest represents the pairwise
    cosine similarity between two customers. For example, the cosine similarity measure
    between customers `12347` and `12348` is `0.063022`. On the other hand, the cosine
    similarity between customers `12347` and `12349` is `0.046130`. This suggests
    that customer `12348` is more similar to customer `12347` than customer `12349` is
    to the customer `12347`, based on the products that they purchased. This way,
    we can easily tell which customers are similar to others, and which customers
    have bought similar items to others.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这个用户与用户之间的相似度矩阵。正如你所想，客户与自己之间的余弦相似度是`1`，这是我们从这个相似度矩阵中可以观察到的。这个用户与用户之间的相似度矩阵中的对角线元素的值为`1`。其余的表示两个客户之间的成对余弦相似度。例如，客户`12347`和`12348`之间的余弦相似度为`0.063022`。另一方面，客户`12347`和`12349`之间的余弦相似度为`0.046130`。这表明，基于他们购买的产品，客户`12348`与客户`12347`更为相似，而客户`12349`与客户`12347`的相似度较低。通过这种方式，我们可以轻松地判断哪些客户彼此相似，哪些客户购买了与其他客户相似的商品。
- en: 'These pairwise cosine similarity measures are what we are going to use for
    product recommendations. Let''s work by picking one customer as an example. We
    will first rank the most similar customers to the customer with ID `12350`, using
    the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成对的余弦相似度测量值就是我们将用于产品推荐的依据。我们通过选择一个客户作为示例来进行操作。我们将首先使用以下代码，对与客户ID为`12350`的客户最相似的客户进行排名：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you run this code, you will get the following output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你将得到以下输出：
- en: '![](img/fcd4bc3d-404a-4c70-a389-635a34c46af7.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcd4bc3d-404a-4c70-a389-635a34c46af7.png)'
- en: These are the top 10 customers that are the most similar to customer `12350`.
    Let's pick customer `17935` and discuss how we can recommend products using these
    results. The strategy is as follows. First, we need to identify the items that
    the customers `12350` and `17935` have already bought. Then, we are going to find
    the products that the target customer `17935` has not purchased, but customer `12350` has.
    Since these two customers have bought similar items in the past, we are going
    to assume that the target customer `17935` has a high chance of purchasing the
    items that he or she has not bought, but customer `12350` has bought. Lastly,
    we are going to use this list of items and recommend them to the target customer `17935`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是与客户`12350`最相似的前10个客户。我们选择客户`17935`，并讨论如何根据这些结果推荐产品。策略如下。首先，我们需要确定客户`12350`和`17935`已经购买的商品。然后，我们将找到目标客户`17935`尚未购买，但客户`12350`已购买的商品。由于这两位客户过去购买了相似的商品，我们假设目标客户`17935`有很高的几率购买那些他或她尚未购买，但客户`12350`已经购买的商品。最后，我们将使用这份商品列表，并将其推荐给目标客户`17935`。
- en: 'Let''s first take a look at how we can retrieve the items that the customer `12350` has
    purchased in the past. The code looks as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一下如何检索客户`12350`过去购买的商品。代码如下所示：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see from this code, we are using the `nonzero` function in the `pandas`
    package. This function returns the integer indexes of the elements that are non-zero.
    Using this function on the `customer_item_matrix` for the given customer `12350`,
    we can get the list of items that the customer `12350` has purchased. We can apply
    the same code for the target customer `17935`, as in the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看出，我们使用了`pandas`包中的`nonzero`函数。该函数返回非零元素的整数索引。我们可以通过在给定客户`12350`的`customer_item_matrix`上使用这个函数，得到该客户购买的商品列表。我们也可以对目标客户`17935`应用相同的代码，如下所示：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we have two sets of items that customers `12350` and `17935` have purchased.
    Using a simple set operation, we can find the items that customer `12350` has
    bought, but customer `17935` has not. The code looks like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了客户`12350`和`17935`购买的两个商品集合。通过简单的集合操作，我们可以找到客户`12350`购买了，但客户`17935`没有购买的商品。代码如下所示：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now the items in the `items_to_recommend_to_B` variable are the items that
    customer `12350` purchased, but customer `17935` did not purchase (yet). Based
    on our assumption, these are the items that customer `17935` is likely to purchase.
    The list of items to recommend to customer `17935` looks like the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`items_to_recommend_to_B`变量中的商品是客户`12350`购买的商品，但客户`17935`尚未购买（可能还没有）。根据我们的假设，这些商品是客户`17935`可能会购买的。推荐给客户`17935`的商品列表如下所示：
- en: '![](img/74829a3a-5fb5-4666-aa32-a37294db4f54.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74829a3a-5fb5-4666-aa32-a37294db4f54.png)'
- en: 'In order to get the descriptions of these items, you can use the following
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取这些项目的描述，你可以使用以下代码：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can notice from this code, we are using the `isin` operator to get the
    records that match with the items in the `items_to_recommend_to_B` variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从这段代码中可以注意到的，我们使用`isin`运算符来获取与`items_to_recommend_to_B`变量中的商品匹配的记录。
- en: 'Once you run this code, you will get the following output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行这段代码，你将得到如下输出：
- en: '![](img/c8514630-b2d5-4fb6-931c-4f7c78775442.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8514630-b2d5-4fb6-931c-4f7c78775442.png)'
- en: Using user-based collaborative filtering, we have discussed how we can do targeted
    product recommendations for individual customers. You can custom-tailor and include these
    products that each target customer is likely to purchase in your marketing messages,
    which can potentially drive more conversions from your customers. As discussed
    so far, using a user-based collaborative filtering algorithm, you can easily do
    product recommendations for target customers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于用户的协同过滤方法，我们已经讨论了如何为每个客户进行有针对性的产品推荐。你可以定制并包含每个目标客户可能购买的产品到你的营销信息中，这样可能会提高客户的转化率。正如之前所讨论的，使用基于用户的协同过滤算法，你可以轻松地为目标客户做产品推荐。
- en: However, there is one main disadvantage of using user-based collaborative filtering.
    As we have seen in this exercise, recommendations are based on the individual
    customer's purchase history. For new customers, we are not going to have enough
    data to compare these new customers against the others. In order to handle this
    problem, we can use item-based collaborative filtering, which we are going to
    discuss in the following section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用基于用户的协同过滤存在一个主要的缺点。正如我们在这个练习中所看到的，推荐是基于个别客户的购买历史进行的。对于新客户，我们没有足够的数据将这些新客户与其他客户进行比较。为了解决这个问题，我们可以使用基于项目的协同过滤，接下来我们将讨论这一方法。
- en: Item-based collaborative filtering and recommendations
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于商品的协同过滤和推荐
- en: 'Item-based collaborative filtering is similar to the user-based approach, except
    that it uses the similarity measures between items, instead of between users or
    customers. We had to compute cosine similarities between users before, but now,
    we are going to compute cosine similarities between items. Take a look at the
    following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 基于商品的协同过滤与基于用户的方法相似，区别在于它使用的是商品之间的相似性度量，而不是用户或客户之间的相似性。之前我们需要计算用户之间的余弦相似性，但现在我们将计算商品之间的余弦相似性。请查看以下代码：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you compare this code to the previous code, where we computed a user-to-user
    similarity matrix, the only difference is the fact that we are transposing the
    `customer_item_matrix` here, so that the row indexes represent individual items
    and the columns represent the customers. We are still using the `cosine_similarity`
    function of the `sklearn` package''s `metrics.pairwise` module. In order to correctly
    name the indexes and columns with product codes, you can use the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这段代码与之前计算用户间相似度矩阵的代码进行比较，唯一的区别是我们在这里对`customer_item_matrix`进行了转置，这样行索引表示的是个别商品，而列表示的是客户。我们仍然使用`sklearn`包中的`metrics.pairwise`模块的`cosine_similarity`函数。为了正确命名带有产品代码的索引和列，你可以使用以下代码：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now the result looks as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在结果如下所示：
- en: '![](img/39a947de-cb00-483e-a8b2-9a3fb7fee36d.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39a947de-cb00-483e-a8b2-9a3fb7fee36d.png)'
- en: As before, the diagonal elements have values of `1`. This is because the similarity
    between an item and itself is `1`, meaning the two are identical. The rest of
    the elements contain the similarity measure values between items based on the
    cosine similarity calculation. For example, looking at the preceding item-to-item
    similarity matrix, the cosine similarity between the item with `StockCode` `10002` and
    the item with `StockCode` `10120` is `0.094868`. On the other hand, the cosine
    similarity between the item `10002` and the item `10125` is `0.090351`. This suggests
    that the item with `StockCode` `10120` is more similar to that with `StockCode` `10002`, than
    the item with `StockCode` `10125` is to that with `StockCode` `10002`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前所示，对角线元素的值为`1`。这是因为一个商品与其自身的相似度为`1`，意味着两者是完全相同的。其余的元素则包含基于余弦相似度计算的商品间相似度值。例如，查看前面的商品间相似度矩阵，`StockCode` `10002`和`StockCode` `10120`之间的余弦相似度为`0.094868`。另一方面，`10002`和`10125`之间的余弦相似度为`0.090351`。这表明，`StockCode` `10120`的商品与`StockCode` `10002`的商品更相似，而`StockCode` `10125`的商品与`StockCode` `10002`的商品则相对较不相似。
- en: The strategy for doing product recommendation using this item-to-item similarity
    matrix is similar to what we did using the user-based approach in the previous
    section. First, for the given product that the target customer bought, we are
    going to find the most similar items from the item-to-item similarity matrix that
    we have just built. Then, we are going to recommend these similar items to the
    customer, since those similar items were bought by other customers who have bought
    the product that the target customer initially bought. Let's work with an example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种商品间相似度矩阵进行产品推荐的策略类似于我们在上一节中使用基于用户的推荐方法。首先，对于目标客户购买的给定商品，我们将从刚刚建立的商品间相似度矩阵中找到最相似的商品。然后，我们会推荐这些相似商品给客户，因为这些相似商品是其他购买了目标客户最初购买的商品的顾客购买的。让我们通过一个例子来说明。
- en: 'Assume a new customer just bought a product with `StockCode` `23166`, and we
    want to include some products that this customer is the most likely to purchase
    in our marketing emails. The first thing we need to do is find the most similar
    items to the one with `StockCode` `23166`. You can use the following code to get
    the top 10 most similar items to the item with `StockCode` `23166`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一位新客户刚购买了`StockCode` `23166`的产品，我们希望在营销邮件中包含一些该客户最有可能购买的产品。我们需要做的第一件事是找到与`StockCode` `23166`产品最相似的商品。你可以使用以下代码获取与`StockCode` `23166`产品最相似的前10个商品：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The result looks like the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/c34a8b86-441b-451f-9c98-103ddfa7dd7e.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c34a8b86-441b-451f-9c98-103ddfa7dd7e.png)'
- en: 'We can get the descriptions of these similar items using the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码获取这些相似商品的描述：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see from this code, we are using the `isin` operator to filter for
    the items that match the list of similar items in the `top_10_similar_items` variable.
    Once you run this code, you will see the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这段代码中，我们使用`isin`操作符来筛选出与`top_10_similar_items`变量中的相似商品列表匹配的商品。一旦你运行这段代码，你将看到以下输出：
- en: '![](img/b101fa25-8e6b-414d-a86f-235f73e507d1.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b101fa25-8e6b-414d-a86f-235f73e507d1.png)'
- en: The first item here is the item that the target customer just bought and the
    other nine items are the items that are frequently bought by others who have bought
    the first item. As you can see, those who have bought ceramic top storage jars
    often buy jelly moulds, spice tins, and cake tins. With this data, you can include
    these items in your marketing messages for this target customer as further product
    recommendations. Personalizing the marketing messages with targeted product recommendations
    typically yields higher conversion rates from customers. Using an item-based collaborative
    filtering algorithm, you can now easily do product recommendations for both new
    and existing customers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个商品是目标客户刚购买的商品，其他九个商品是那些购买了第一个商品的顾客经常购买的商品。如你所见，购买陶瓷顶储物罐的人通常还会购买果冻模具、香料罐和蛋糕模具。通过这些数据，你可以在营销信息中为该目标客户提供这些商品作为进一步的产品推荐。通过有针对性的产品推荐个性化营销信息，通常能提高客户的转化率。利用基于商品的协同过滤算法，你现在可以轻松地为新老客户提供产品推荐。
- en: The full details for this Python exercise can be found at: [https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.6/python/ProductRecommendation.ipynb](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.6/python/ProductRecommendation.ipynb)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Python练习的完整细节可以在以下网址找到：[https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.6/python/ProductRecommendation.ipynb](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.6/python/ProductRecommendation.ipynb)
- en: Building a product recommendation algorithm with R
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用R构建产品推荐算法
- en: In this section, we are going to discuss how to build a product recommendation
    system using R. More specifically, we will be learning how to implement a collaborative
    filtering algorithm in R using the `dplyr`, `reshape2`, and `coop` packages. For
    those readers who would like to use Python instead of R for this exercise, you
    can go to the previous section. We will start this section by analyzing some e-commerce
    business data and then discuss the two approaches to building a product recommendation
    system with collaborative filtering.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何使用R构建产品推荐系统。更具体地说，我们将学习如何使用`dplyr`、`reshape2`和`coop`包在R中实现协同过滤算法。对于那些希望使用Python而非R进行此练习的读者，可以参考上一节。我们将从分析一些电子商务业务数据开始，然后讨论使用协同过滤构建产品推荐系统的两种方法。
- en: 'For this exercise, we will be using one of the publicly available datasets
    from the UCI Machine Learning Repository, which can be found at: [http://archive.ics.uci.edu/ml/datasets/online+retail#](http://archive.ics.uci.edu/ml/datasets/online+retail#).
    You can go to this link and download the data, available in Microsoft Excel format,
    named `Online Retail.xlsx`. Once you have downloaded this data, you can load it
    into your RStudio by running the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用来自UCI机器学习库的公开数据集之一，数据集可以在以下网址找到：[http://archive.ics.uci.edu/ml/datasets/online+retail#](http://archive.ics.uci.edu/ml/datasets/online+retail#)。你可以访问此链接并下载数据，数据为Microsoft
    Excel格式，名为`Online Retail.xlsx`。下载数据后，你可以通过运行以下命令将其加载到你的RStudio中：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Similar to the previous chapter, we are using the `read_excel` function in the `readxl` package
    to load the data in Excel format. We provide the path to the data to the argument `path`,
    and the name of the Excel spreadsheet to the argument `sheet`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 和上一章类似，我们使用`readxl`包中的`read_excel`函数加载Excel格式的数据。我们将数据的路径提供给`path`参数，将Excel表格的名称提供给`sheet`参数。
- en: 'Once you have loaded this data into a `DataFrame`, it should look like the
    following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将这些数据加载到`DataFrame`中，它应该如下所示：
- en: '![](img/afb2a4f5-fc1c-42ea-a115-8d69a1eda07f.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afb2a4f5-fc1c-42ea-a115-8d69a1eda07f.png)'
- en: 'If you recall from the previous chapter, there are records with negative values
    in the `Quantity` column, which represent canceled orders. We are going to disregard
    and remove those records. We can filter out all these records in our `DataFrame` with
    the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得上一章的内容，`Quantity`列中有一些负值记录，表示取消的订单。我们将忽略并删除这些记录。我们可以使用以下代码在`DataFrame`中筛选出所有这些记录：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Data preparation
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据准备
- en: Before we dive into building a product recommender engine using a collaborative
    filtering algorithm, there are a couple of things we need to do. First, we need
    to handle `NaN` values in our dataset, especially those records with `NA` values in
    the `CustomerID` field. Without correct values in the `CustomerID` field, we cannot
    build a proper recommendation system, since the collaborative filtering algorithm
    depends on the historical item purchase data for individual customers. Second,
    we need to build customer-to-item matrix before we move onto implementing a collaborative
    filtering algorithm for product recommendation. The customer-item matrix is simply
    tabular data where each column represents each product or item, each row represents
    a customer, and the value in each cell represents whether the given customer purchased
    the given product or not.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建使用协同过滤算法的产品推荐引擎之前，我们需要做几件事。首先，我们需要处理数据集中的`NaN`值，特别是那些在`CustomerID`字段中有`NA`值的记录。如果`CustomerID`字段中的值不正确，我们就无法构建一个正确的推荐系统，因为协同过滤算法依赖于单个客户的历史商品购买数据。其次，在实现产品推荐的协同过滤算法之前，我们需要构建客户与商品的矩阵。客户-商品矩阵实际上是表格数据，其中每列代表一个商品或项目，每行代表一个客户，每个单元格中的值表示该客户是否购买了给定的商品。
- en: Handling NA values in the CustomerID field
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理`CustomerID`字段中的`NA`值
- en: If you look closely at the data, you will notice that there are some records
    with no `CustomerID`. Since we need to build a customer-item matrix, where each
    row is specific to each customer, we cannot include those records with no `CustomerID` in
    our data. Let's first take a look at how many records do not have a `CustomerID`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细查看数据，您会注意到一些没有`CustomerID`的记录。由于我们需要构建一个客户-商品矩阵，其中每行特定于每个客户，我们不能包括那些没有`CustomerID`的记录在我们的数据中。让我们首先看一下有多少条记录没有`CustomerID`。
- en: 'Take a look at the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下代码：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `is.na` function that we are using here detects missing values and returns `TRUE` for
    each of the missing values. By summing over these values using the `sum` function,
    we can count the number of records with no `CustomerID`. The result looks as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此使用的`is.na`函数用于检测缺失值，并对每个缺失值返回`TRUE`。通过使用`sum`函数对这些值进行求和，我们可以计算没有`CustomerID`的记录数。结果如下所示：
- en: '![](img/0a9abc50-60e2-4f84-b386-b8bf5d454b98.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a9abc50-60e2-4f84-b386-b8bf5d454b98.png)'
- en: 'As you can see from this output, there are `133,361` records with no `CustomerID`.
    In order to look at those records with no `CustomerID`, you can use the following
    code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从此输出中可以看出，有`133,361`条没有`CustomerID`的记录。为了查看那些没有`CustomerID`的记录，您可以使用以下代码：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the output looks like the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/dfb92dd0-c302-4e72-9447-cb7c444cd882.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfb92dd0-c302-4e72-9447-cb7c444cd882.png)'
- en: 'Now that we know there are records with missing `CustomerID` values, we need
    to exclude them from further analysis. One way to drop them from our `DataFrame` is
    by using the `na.omit` function, as in the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道有记录缺少`CustomerID`值，我们需要从进一步分析中排除它们。从我们的`DataFrame`中删除它们的一种方法是使用`na.omit`函数，如下所示：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `na.omit` function in R removes records with missing values (`NA`) from
    a DataFrame. Once you run this code, all the records in the DataFrame `df` will
    now have `CustomerID` values. The dimensions of the DataFrame `df` before and
    after dropping the missing values should look as in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在R语言中，`na.omit`函数会从`DataFrame`中删除缺失值（`NA`）。运行此代码后，`df`的`DataFrame`中所有记录现在都将有`CustomerID`值。在删除缺失值之前和之后，`DataFrame`
    `df`的维度应如以下截图所示：
- en: '![](img/8bcd2960-7950-4f04-a09c-71af11a813ee.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bcd2960-7950-4f04-a09c-71af11a813ee.png)'
- en: As you can see from the outputs of the `dim(df)` commands, the `133,361` records
    with no `CustomerID` values were dropped from the original `DataFrame`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，从`dim(df)`命令的输出可以看出，原始`DataFrame`中`133,361`条没有`CustomerID`值的记录已被删除。
- en: Building a customer-item matrix
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建客户-商品矩阵
- en: The data we have now represents individual items purchased by customers. However,
    in order to build a product recommendation system with a collaborative filtering
    algorithm, we need to have data where each record contains information on which
    item each customer has bought. In this section, we are going to transform the
    data into a customer-item matrix, where each row represents a customer and the
    columns correspond to different products.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们手头的数据表示客户购买的个别商品。然而，为了使用协同过滤算法构建产品推荐系统，我们需要有每条记录包含客户购买的哪个商品的数据。在本节中，我们将把数据转换成客户-商品矩阵，其中每行代表一个客户，列对应不同的产品。
- en: 'In order to transform our data into a customer-item matrix, we are going to
    use the `dcast` function in the `reshape2` package. If you do not already have
    this package installed in your R environment, you can run the following commands
    to install and include this package in your R environment:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的数据转换成客户-商品矩阵，我们将使用`reshape2`包中的`dcast`函数。如果您的R环境中尚未安装此包，您可以运行以下命令来安装并包含此包：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s take a look at the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `dcast` function of the `reshape2` package uses a formula to reshape a
    `DataFrame` into another form of `DataFrame`. In our case, we want our data to
    be reshaped so that the rows represent individual customers and the columns represent
    the different products. By defining the formula as `CustomerID ~ StockCode`, the
    `dcast` function is going to reshape the data, so that the individual codes of
    the `StockCode` map to columns and each row represents an individual customer.
    The `value.var` argument defines which value to take. Here, we are telling the
    `dcast` function to take the values of the `Quantity` field as the values of the
    elements in the reshaped `DataFrame`. The result looks like the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`dcast`函数来自`reshape2`包，使用公式将`DataFrame`重塑为另一种形式的`DataFrame`。在我们的案例中，我们希望数据的重塑方式是：行表示单个客户，列表示不同的产品。通过将公式定义为`CustomerID
    ~ StockCode`，`dcast`函数将重塑数据，使得每个`StockCode`的代码映射为列，而每一行则代表一个单独的客户。`value.var`参数定义了要取的值。在这里，我们告诉`dcast`函数将`Quantity`字段的值作为重塑后`DataFrame`中元素的值。结果如下所示：'
- en: '![](img/36ec0e90-40ad-47c3-ac31-73c93b473055.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36ec0e90-40ad-47c3-ac31-73c93b473055.png)'
- en: Let's take a closer look at this data. The customer with `CustomerID` `12731` has
    bought `3` of the item with `StockCode` `10002`. Similarly, the customer with `CustomerID` `12748` has
    bought `2` of the item with `StockCode` `10080`, and the customer with `CustomerID` `12735` has
    bought `1` of the item with `StockCode` `10125`. As you can see from this, we
    now have a matrix where each row represents the total quantities bought for each
    product for each customer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这些数据。`CustomerID`为`12731`的客户购买了`StockCode`为`10002`的商品`3`件。同样，`CustomerID`为`12748`的客户购买了`StockCode`为`10080`的商品`2`件，而`CustomerID`为`12735`的客户购买了`StockCode`为`10125`的商品`1`件。正如您从中看到的，我们现在拥有一个矩阵，其中每一行表示每个客户购买的每个产品的总数量。
- en: 'Now, let''s `0`-`1` encode this data, so that the value of `1` means that the
    given product was purchased by the given customer, and a value of `0` means that
    the given product was never purchased by the given customer. Take a look at the
    following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对这些数据进行`0`-`1`编码，使得`1`表示该产品被给定客户购买，而`0`表示该产品从未被该客户购买。请看以下代码：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see from this code, we first define the encoding function, `encode_fn`.
    This function simply encodes each value as `1` if it is greater than `0`, and
    as `0` if it is not. Then we are using the `muate_at` function of the `dplyr`
    package, which applies the `encode_fn` encoding function to each element of the
    matrix, except the `CustomerID` column. The result should look as in the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从代码中看到的，我们首先定义了编码函数`encode_fn`。该函数简单地将每个值编码为`1`（如果大于`0`），否则编码为`0`。然后，我们使用`dplyr`包中的`mutate_at`函数，该函数将`encode_fn`编码函数应用于矩阵中的每个元素，除了`CustomerID`列。结果应如下所示：
- en: '![](img/2f4237b9-9ed7-4709-8ccc-e61ca747c888.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f4237b9-9ed7-4709-8ccc-e61ca747c888.png)'
- en: We now have a customer-item matrix that we can use for a collaborative filtering
    algorithm. Let's now move on to building product recommender engines.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了一个客户-商品矩阵，可以用于协同过滤算法。接下来，让我们继续构建产品推荐引擎。
- en: Collaborative filtering
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤
- en: 'In this section, we are going to explore two approaches to building a product
    recommender engine—user-based versus item-based. In the user-based approach, we
    compute similarities between users based on their item purchase history. In the
    item-based approach, on the other hand, we compute similarities between items
    based on which items are often bought together with other items. To measure the
    similarity between users or between items, we are going to use the `cosine` function
    in the `coop` library, which is a library for fast implementation of cosine similarity
    computation in R. You can install and this R library using the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索两种建立产品推荐引擎的方法——基于用户的与基于项目的。在基于用户的方法中，我们根据用户的商品购买历史计算用户之间的相似性。另一方面，在基于项目的方法中，我们计算项目之间的相似性，这些项目通常与其他商品一起购买。为了衡量用户或项目之间的相似性，我们将使用`coop`库中的`cosine`函数，这是一个在R中实现快速余弦相似度计算的库。您可以使用以下代码安装该R库：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `cosine` function in the `coop` library computes the cosine similarity matrix
    efficiently in R. Let's dive in now!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`coop`库中的`cosine`函数能够高效地计算R中的余弦相似度矩阵。现在让我们深入了解吧！'
- en: User-based collaborative filtering and recommendations
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于用户的协同过滤与推荐
- en: 'In order to build a user-based collaborative filtering algorithm, we need to
    compute cosine similarities between users. Let''s take a look at the following
    code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建基于用户的协同过滤算法，我们需要计算用户之间的余弦相似度。让我们来看一下下面的代码：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As is noticeable from this code, using the `cosine` function from the `coop` library,
    you can compute and build a cosine similarity matrix. One thing to note in this
    code is the fact that we transpose the `customerItemMatrix` before computing cosine
    similarities. This is to compute user-to-user similarities. Without the transposition,
    the `cosine` function will be computing item-to-item similarities. Lastly, we
    are renaming the columns with customer IDs in the last line of this code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看出，使用`coop`库中的`cosine`函数，可以计算并构建余弦相似度矩阵。需要注意的是，在计算余弦相似度之前，我们对`customerItemMatrix`进行了转置。这是为了计算用户之间的相似度。如果没有转置，`cosine`函数将计算商品之间的相似度。最后，在代码的最后一行，我们通过顾客ID重命名了列名。
- en: 'The result looks as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/8fcc0c2f-cdaa-44da-a400-1c746ff39ee1.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fcc0c2f-cdaa-44da-a400-1c746ff39ee1.png)'
- en: Let's take a closer look at this user-to-user similarity matrix. As you can
    imagine, the cosine similarity between a customer to himself or herself is `1`
    and this is what we can observe from this similarity matrix. The diagonal elements
    in this user-to-user similarity matrix have values of `1`. The rest represents
    the pairwise cosine similarity between two customers. For example, the cosine
    similarity measure between customers `12347` and `12348` is `0.06302187`. On the
    other hand, the cosine similarity between customers `12347` and `12349` is `0.04612963`.
    This suggests that customer `12348` is more similar to customer `12347` than customer `12349` to
    customer `12347`, based on the products that they purchased previously. This way
    we can easily tell which customers are similar to which others and which customers
    have bought similar items to which others.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这个用户与用户之间的相似度矩阵。正如你可以想象的那样，一个客户与他或她自己的余弦相似度是`1`，这可以从这个相似度矩阵中看到。这个用户与用户相似度矩阵中的对角线元素的值为`1`。其余部分表示两个客户之间的成对余弦相似度。例如，客户`12347`和`12348`之间的余弦相似度为`0.06302187`。另一方面，客户`12347`和`12349`之间的余弦相似度为`0.04612963`。这表明，基于他们之前购买的商品，客户`12348`与客户`12347`比客户`12349`与客户`12347`更相似。通过这种方式，我们可以轻松地判断哪些客户与哪些其他客户相似，以及哪些客户购买了哪些其他客户也购买过的相似商品。
- en: 'These pairwise cosine similarity measures are what we are going to use for
    product recommendations. Let''s work by picking one customer as an example. We
    will first rank the most similar customers to customer with ID `12350` using the
    following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成对的余弦相似度度量将用于产品推荐。让我们通过选择一个客户作为例子来操作。我们首先使用以下代码对与客户ID`12350`最相似的客户进行排序：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see from this code, we are using the order function to sort the values
    in the column `12350` of `userToUserSimMatrix`. With the `decreasing = TRUE` flag,
    we can sort the values in descending order.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从这段代码中看到的，我们使用`order`函数对`userToUserSimMatrix`中的`12350`列的值进行排序。通过设置`decreasing
    = TRUE`标志，我们可以按降序排序这些值。
- en: 'When you run this code, you will get the following output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你会得到以下输出：
- en: '![](img/5cce0e7b-48bd-4460-b4d1-059e3878d548.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cce0e7b-48bd-4460-b4d1-059e3878d548.png)'
- en: These are the top 10 customers that are the most similar to customer `12350`.
    Let's pick customer `17935` and discuss how we can recommend products using these
    results. The strategy is as follows. First we need to identify the items that
    customers `12350` and `17935` have already bought. Then, we are going to find
    the products that the target customer `17935` has not purchased, but customer `12350` has.
    Since these two customers have bought similar items in the past, we are going
    to assume that the target customer `17935` has high chance of purchasing these
    items that he or she has not bought, but that customer `12350` has bought. Lastly,
    we are going to use this list of items and recommend them to the target customer `17935`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与客户`12350`最相似的前10个客户。我们选择客户`17935`并讨论如何利用这些结果来推荐产品。策略如下。首先，我们需要识别客户`12350`和`17935`已经购买的商品。然后，我们要找出目标客户`17935`尚未购买但客户`12350`已购买的产品。由于这两位客户之前购买了相似的商品，我们假设目标客户`17935`有很大机会购买这些他或她尚未购买的商品，而客户`12350`已经购买了。最后，我们将使用这个商品清单并将其推荐给目标客户`17935`。
- en: 'Let''s first take a look at how we can retrieve the items that customer `12350` has
    purchased in the past. The code looks as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看一下如何获取客户`12350`过去购买的商品。代码如下所示：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see from this code, we are using the `which` operator to find the
    column indexes of the elements that are non-zero. The result of this code looks
    as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了`which`操作符来查找非零元素的列索引。该代码的输出结果如下：
- en: '![](img/5b53e815-97c5-46a5-a767-c9263c581da4.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b53e815-97c5-46a5-a767-c9263c581da4.png)'
- en: 'Using the following code, we can get the list of items that the customer `17935` has
    purchased:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码，我们可以获取客户`17935`所购买的商品列表：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The items that customer `17935` has bought are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 客户`17935`购买的商品如下：
- en: '![](img/2fdc0326-a8a6-47a8-990f-8c7a44647e15.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fdc0326-a8a6-47a8-990f-8c7a44647e15.png)'
- en: 'Now we have two sets of items that customers `12350` and `17935` have purchased.
    Using the simple set operation, we can find the items that customer `12350` has
    bought, but customer `17935` has not. The code looks like the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了客户`12350`和`17935`购买的两组商品。通过简单的集合操作，我们可以找到客户`12350`购买的但客户`17935`未购买的商品。代码如下所示：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now the items in the, `itemsToRecommendToB` variable, are the items that customer `12350` purchased,
    but customer `17935` did not purchase yet. Based on our assumption, these are
    the items that customer `17935` is likely to purchase. The list of items to recommend
    to customer `17935` looks as in the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`itemsToRecommendToB`变量中的商品是客户`12350`购买的，但客户`17935`尚未购买的商品。根据我们的假设，这些是客户`17935`可能会购买的商品。推荐给客户`17935`的商品列表如下所示：
- en: '![](img/f7f47bec-3222-449f-b197-5903b3a72ab7.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7f47bec-3222-449f-b197-5903b3a72ab7.png)'
- en: 'In order to get the descriptions of these items, you can use the following
    code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取这些商品的描述，你可以使用以下代码：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can notice from this code, we are using the `%in%` operator to get the
    records that match with the items in the `itemsToRecommendToB` variable. Once
    you run this code, you will get the following output that has descriptions of
    the recommended items:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从代码中看到的，我们使用了`%in%`操作符来获取与`itemsToRecommendToB`变量中的物品匹配的记录。运行此代码后，你将得到以下包含推荐商品描述的输出：
- en: '![](img/3401d7e1-77f1-4850-aef5-4dd15d258c58.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3401d7e1-77f1-4850-aef5-4dd15d258c58.png)'
- en: Using user-based collaborative filtering, we have discussed how we can do targeted
    product recommendations for individual customers. You can custom-tailor and include these
    products that each target customer is likely to purchase in your marketing messages,
    which can potentially drive more conversions from your customers. As discussed
    so far, using a user-based collaborative filtering algorithm, you can easily create
    product recommendations for target customers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于用户的协同过滤，我们已经讨论了如何为单个客户做出针对性的产品推荐。你可以根据客户的兴趣定制并在营销信息中包含每个目标客户可能购买的产品，这样可以有效地推动更多的转化。如前所述，使用基于用户的协同过滤算法，你可以轻松为目标客户创建产品推荐。
- en: However, there is one main disadvantage of using user-based collaborative filtering.
    As we have seen in this exercise, recommendations are based on the individual
    customer's purchase history. For new customers, we are not going to have enough
    data to compare them with the others. In order to handle this problem, we can
    use item-based collaborative filtering that we will be discussing in the following
    section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用基于用户的协同过滤方法有一个主要缺点。正如我们在这个练习中所看到的，推荐是基于单个客户的购买历史进行的。对于新客户，我们没有足够的数据与其他客户进行对比。为了应对这个问题，我们可以使用基于物品的协同过滤，接下来我们将讨论这个方法。
- en: Item-based collaborative filtering and recommendations
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤和推荐
- en: 'Item-based collaborative filtering is similar to the user-based approach, except
    that it is using the similarity measures between items, instead of between users
    or customers. We had to compute cosine similarities between users before, but
    now we are going to compute cosine similarities between items. Take a look at
    the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤与基于用户的方法类似，不同之处在于它使用的是物品之间的相似度度量，而不是用户或顾客之间的相似度。我们之前需要计算用户之间的余弦相似度，但现在我们要计算物品之间的余弦相似度。请看以下代码：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you compare this code to the previous code, where we computed user-to-user
    similarity matrix, the only difference is the fact that we are not transposing
    the `customerItemMatrix` this time. We are still using the `cosine` function of
    the `coop` library.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将这段代码与之前计算用户间相似度矩阵的代码进行比较，唯一的区别在于这次我们没有转置`customerItemMatrix`。我们仍然使用`coop`库中的`cosine`函数。
- en: 'The result looks as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/b2de1e8a-a7af-4973-aaf5-e3371da48859.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2de1e8a-a7af-4973-aaf5-e3371da48859.png)'
- en: As before, the diagonal elements have values of `1`. This is because the similarity
    between an item and itself is `1`, meaning the two are identical. The other elements
    contain the similarity measure values between items based on the cosine similarity
    calculation. For example, looking at the preceding item-to-item similarity matrix,
    the cosine similarity between the item with `StockCode` `10002` and the item with `StockCode` `10120` is `0.09486833`.
    On the other hand, the cosine similarity between item `10002` and item `10125` is `0.09035079`.
    This suggests that the item with `StockCode` `10120` is more similar to that with `StockCode` `10002` than
    the item with `StockCode` `10125` is to that with `StockCode` `10002`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，对角线元素的值为`1`。这是因为一个商品与其自身的相似度为`1`，即这两个商品是完全相同的。其他元素则包含根据余弦相似度计算的商品间相似度值。例如，观察前面的商品间相似度矩阵，`StockCode`为`10002`的商品与`StockCode`为`10120`的商品之间的余弦相似度为`0.09486833`。另一方面，`10002`与`10125`之间的余弦相似度为`0.09035079`。这表明，`StockCode`为`10120`的商品与`10002`的商品比`StockCode`为`10125`的商品更为相似。
- en: The strategy to do product recommendation using this item-to-item similarity
    matrix is similar to what we did using the user-based approach in the previous
    section. First, for the given product that the target customer bought, we are
    going to find the most similar items from the item-to-item similarity matrix that
    we have just built. Then, we are going to recommend these similar items to the
    customer, since those similar items were bought by other customers who have bought
    the product that the target customer initially bought. Let's work with an example.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个商品间相似度矩阵进行产品推荐的策略与我们在上一节中使用基于用户的方法类似。首先，对于目标客户购买的特定产品，我们将从刚刚构建的商品间相似度矩阵中找到最相似的商品。然后，我们将这些相似商品推荐给客户，因为这些相似商品是由其他购买了目标客户最初购买的产品的客户所购买的。让我们通过一个例子来说明。
- en: 'Assume a new customer just bought a product with `StockCode` `23166`, and we
    want to include some products that this customer is most likely to purchase in
    our marketing emails. The first thing we need to do is find the most similar items
    to the one with `StockCode` `23166`. You can use the following code to get the
    top 10 most similar items to the item with `StockCode` `23166`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个新客户刚刚购买了一款`StockCode`为`23166`的商品，我们希望在营销邮件中推荐一些该客户最有可能购买的商品。我们首先需要做的是找到与`StockCode`为`23166`的商品最相似的商品。你可以使用以下代码来获取与`StockCode`为`23166`的商品最相似的前10个商品：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using the `order` function with the `decreasing = TRUE` flag, we can sort the
    similar items in descending order. Then, with this reverse sorted list of indexes,
    we can get the top 10 similar items to the item with `StockCode` `23166`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`order`函数并设置`decreasing = TRUE`标志，我们可以按降序排列相似商品。然后，借助这个反向排序的索引列表，我们可以找到与`StockCode`为`23166`的商品最相似的前10个商品。
- en: 'The result looks as in the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/3b7dc18a-ad78-4097-98a9-fcd94ca86a74.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b7dc18a-ad78-4097-98a9-fcd94ca86a74.png)'
- en: 'We can get the descriptions of these similar items using the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码获取这些相似商品的描述：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see from this code, we are using the `%in%` operator to filter for
    the items that match the list of similar items in the variable `top10SimilarItemsTo23166`.
    Once you run this code, you will see the following output:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从这段代码中看到的，我们使用`%in%`操作符来筛选与变量`top10SimilarItemsTo23166`中列出的相似商品匹配的商品。一旦运行这段代码，你将看到以下输出：
- en: '![](img/7d4e688b-27eb-40a9-a42b-a0cb136342c0.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d4e688b-27eb-40a9-a42b-a0cb136342c0.png)'
- en: The first item here is the item that the target customer just bought, and the
    remaining 10 items are the items that are frequently bought by others who have
    bought the first item. As you can see, those who have bought ceramic-top storage
    jars often buy jelly moulds, spice tins, and cake tins. With this data, you can
    include these items in your marketing messages for this target customer as further
    product recommendations. Personalizing the marketing messages with targeted product
    recommendations typically yields higher conversion rates from customers. Using
    an item-based collaborative filtering algorithm, you can now easily do product
    recommendations for both new and existing customers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个项目是目标客户刚刚购买的商品，剩余的 10 个项目是其他购买了第一个商品的顾客常买的物品。正如你所看到的，购买陶瓷顶存储罐的人通常会购买果冻模具、香料罐和蛋糕模具。有了这些数据，你可以在针对目标客户的营销信息中加入这些商品，作为进一步的产品推荐。通过个性化营销信息和定向产品推荐，通常能提高客户的转化率。通过基于商品的协同过滤算法，你现在可以轻松地为新客户和现有客户做产品推荐。
- en: The full code for this R exercise can be found in this link: [https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.6/R/ProductRecommendation.R](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.6/R/ProductRecommendation.R)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本 R 练习的完整代码可以通过以下链接找到：[https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.6/R/ProductRecommendation.R](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.6/R/ProductRecommendation.R)
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed product recommender systems. We have learned
    how personalized product recommendations improve conversion and customer retention
    rates, according to a study conducted by Salesforce. We have discussed the two
    approaches, collaborative filtering and content-based filtering, to building product
    recommendation systems; how they differ from one another; and what their assumptions
    are. Then, we dove deeper into how we can build collaborative filtering-based
    recommender systems. As you might recall, the first step to building a collaborative
    filtering-based recommender system is to build a user-to-item matrix, and then
    the next step is to use cosine similarity to compute the similarities between
    the users. We have also discussed the two different approaches to utilizing a
    collaborative filtering algorithm for product recommendations—a user-based approach
    and an item-based approach.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了产品推荐系统。我们学习了根据 Salesforce 进行的一项研究，个性化产品推荐如何提高转化率和客户保持率。我们讨论了构建产品推荐系统的两种方法：协同过滤和基于内容的过滤；它们的不同之处，以及它们的假设。接着，我们深入探讨了如何构建基于协同过滤的推荐系统。正如你可能还记得的，构建基于协同过滤的推荐系统的第一步是建立一个用户与商品的矩阵，接下来的步骤是使用余弦相似度来计算用户之间的相似性。我们还讨论了利用协同过滤算法进行产品推荐的两种不同方法——基于用户的方法和基于商品的方法。
- en: From the next chapter, we are going to switch gears and focus on utilizing customer
    behavior data to our advantage to improve our marketing strategies. In the next
    chapter, we are going to discuss the benefits and importance of conducting customer
    analytics.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从下章开始，我们将转变方向，重点利用客户行为数据来提升我们的营销策略。在下一章中，我们将讨论进行客户分析的好处和重要性。
