- en: '*Chapter 3*: Data Visualization'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：数据可视化'
- en: Visualization is fundamental to the modern data scientist. It is often the central
    lens used to understand items such as statistical models (for example, via an
    AUC chart), the distribution of a crucial variable (via a histogram), or even
    important business metrics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化是现代数据科学家的基本技能。它通常是用来理解统计模型（例如，通过AUC图表）、关键变量的分布（通过直方图）或重要商业指标的核心视角。
- en: In the last two chapters, we used the most popular Python graphing libraries
    (**Matplotlib** and **Seaborn**) in our examples. This chapter will focus on extending
    that ability to a broad range of Python graphing libraries, along with including
    some graphing functions native to Streamlit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两章中，我们在示例中使用了最流行的Python图表库（**Matplotlib**和**Seaborn**）。本章将重点扩展这些能力，涵盖多种Python图表库，并加入一些Streamlit的原生图表功能。
- en: By the end of this chapter, you should feel comfortable with using Streamlit's
    native graphing functions, and also using Streamlit's visualization functions
    to place graphs made from major Python visualization libraries in your own Streamlit
    app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够熟练使用Streamlit的原生图表功能，同时也能使用Streamlit的可视化功能，将通过主要Python可视化库生成的图表嵌入到自己的Streamlit应用中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: San Francisco Trees – A new dataset
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧金山树木——一个新数据集
- en: Streamlit's built-in graphing functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Streamlit内建的图表功能
- en: Streamlit's built-in visualization options
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Streamlit内建的可视化选项
- en: 'Importing Python visualization libraries into Streamlit. In this section, we
    will cover the following libraries:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Python可视化库导入到Streamlit中。在本节中，我们将介绍以下库：
- en: (a) **Plotly** (for interactive visualizations)
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (a) **Plotly**（用于交互式可视化）
- en: (b) **Seaborn+Matplotlib** (for classic statistical visualizations)
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (b) **Seaborn+Matplotlib**（用于经典的统计可视化）
- en: (c) **Bokeh** (for interactive visualization in web browsers)
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (c) **Bokeh**（用于网页浏览器中的交互式可视化）
- en: (d) **Altair** (for declarative, interactive visualizations)
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (d) **Altair**（用于声明式交互式可视化）
- en: (e) **PyDeck** (for interactive map-based visualizations)
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (e) **PyDeck**（用于交互式基于地图的可视化）
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we will be working with a new dataset that can be found at
    [https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv](https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv).
    A further explanation of the dataset can be found in the following section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用一个新数据集，可以在[https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv](https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv)找到。关于该数据集的进一步说明请参见下节内容。
- en: San Francisco Trees – A new dataset
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旧金山树木——一个新数据集
- en: 'We''re going to be working with all sorts of graphs in this chapter, so we''re
    going to need a new dataset that has much more info, especially dates and locations.
    Enter *SF Trees*. The department of public works in San Francisco has a dataset
    (cleaned by the wonderful folks in the R community who run Tidy Tuesday, a weekly
    event where people publish interesting visualizations of new data each week) of
    every tree planted and maintained in the city of San Francisco. They cleverly
    call this dataset *EveryTreeSF – Urban Forest map*, and update this dataset every
    day. I have selected a random 10,000 trees with complete info and placed this
    data in the main GitHub repository under the `trees` folder (I''m not as clever
    as the data engineer in SF''s DPW, I know). The GitHub repo can be found at [https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps). If
    you would like to download the full dataset, the link is here: [https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq](https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理各种各样的图表，因此需要一个包含更多信息的新数据集，特别是日期和位置。于是，我们引入了*SF Trees*。旧金山公共事务局拥有一个数据集（由R社区的优秀人员清理，他们运营Tidy
    Tuesday，这是一个每周发布有趣数据可视化的活动），该数据集包含了旧金山城市中所有种植和维护的树木。这个数据集被巧妙地命名为*EveryTreeSF –
    城市森林地图*，并且每天都会更新。我已随机选择了10,000棵树，并提供了完整信息，将该数据存放在主GitHub仓库的`trees`文件夹中（我承认，我的聪明程度不及旧金山DPW的数据工程师）。GitHub仓库可以在[https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps)找到。如果你想下载完整数据集，可以点击此链接：[https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq](https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq)。
- en: 'From the main `streamlit_apps` folder we''ve been using throughout this book,
    start by making a new folder, making a new Python file, and then downloading our
    data into the folder, the same thing as we did in [*Chapter 2*](B16864_02_Final_VK_ePub.xhtml#_idTextAnchor024),
    *Uploading, Downloading, and Manipulating Data*, but just adding some new data!
    You can run the following code in your terminal to set this up:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们整个书籍过程中使用的主要 `streamlit_apps` 文件夹中，首先创建一个新文件夹，创建一个新的 Python 文件，然后将我们的数据下载到该文件夹中，就像我们在
    [*第二章*](B16864_02_Final_VK_ePub.xhtml#_idTextAnchor024)《上传、下载与处理数据》中所做的一样，只不过这次添加了一些新数据！你可以在终端中运行以下代码来完成设置：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I'll note here that if this does not work, or if you are on an operating system
    without these commands (such as Windows, for example), you can always go and download
    the CSV file directly by going to the GitHub repo mentioned in the preceding paragraph
    ([https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我想提到，如果这不奏效，或者你使用的操作系统没有这些命令（例如 Windows），你总是可以直接访问 GitHub 仓库下载 CSV 文件，如前面提到的仓库链接：[https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps)。
- en: Now that we have our setup, our next step is to open our `trees.py` file in
    our favorite editor and get to making our Streamlit app.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了设置，接下来的步骤是打开我们最喜欢的编辑器中的 `trees.py` 文件，开始构建我们的 Streamlit 应用。
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: We will follow these exact same steps at the beginning of the rest of the chapters,
    so in the future, we will not cover these explicitly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节的开头继续按照这些步骤进行，因此将来我们不会再次详细介绍这些内容。
- en: 'Let''s start by titling our app and printing out some example rows using the
    following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先通过以下代码给我们的应用命名，并打印出一些示例行：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can then run the following command in our terminal and see the resulting
    Streamlit app in our browser:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在终端中运行以下命令，并在浏览器中查看生成的 Streamlit 应用：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that this is neither the easiest nor the best way to see the first few
    rows of a dataset, but we can do this purely because we already know that we''re
    going to build a Streamlit app using this data. The general workflow usually begins
    with some data exploration outside of Streamlit (in Jupyter notebooks, through
    SQL queries, or whatever the preferred workflow is for you as a data scientist
    or analyst). That said, let''s continue looking at our dataset by looking at the
    output of the preceding code in the new Streamlit app in our browser:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这不是查看数据集前几行的最简单或最好的方法，但我们之所以这样做，完全是因为我们已经知道我们将使用这些数据构建一个 Streamlit 应用。一般的工作流通常是在
    Streamlit 之外进行数据探索（通过 Jupyter 笔记本、SQL 查询，或者作为数据科学家或分析师你更喜欢的工作流）。也就是说，让我们继续查看数据集，并查看在浏览器中新
    Streamlit 应用中执行上述代码的输出：
- en: '![Figure 3.1 – The first few rows of trees'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 树木的前几行'
- en: '](img/B16864_03_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_03_01.jpg)'
- en: Figure 3.1 – The first few rows of trees
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 树木的前几行
- en: This dataset contains a huge amount of info about the trees in SF, from their
    width (`dbh`) to the longitude and latitude points, the species, their address,
    and even the date they were planted. Before we get started with graphing, let's
    talk a bit about the visualization options in front of us.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据集包含了关于旧金山树木的大量信息，从它们的直径（`dbh`）到经纬度、物种、地址，甚至是它们的种植日期。在我们开始绘制图表之前，先来了解一下我们面前的可视化选项。
- en: Streamlit visualization use cases
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Streamlit 可视化用例
- en: Some Streamlit users are relatively experienced Python developers with well-tested
    workflows in visualization libraries of their choice. For these users, the best
    path forward is the one we've taken so far, which is to create our graphs in our
    library of choice (Seaborn, Matplotlib, Bokeh, and so on) and then use the appropriate
    Streamlit function to write this to the app.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Streamlit 用户是经验丰富的 Python 开发者，拥有在自己选择的可视化库中经过充分测试的工作流。对于这些用户，最佳的前进路径就是我们迄今为止采取的方式，即在我们选择的库（如
    Seaborn、Matplotlib、Bokeh 等）中创建图表，然后使用合适的 Streamlit 函数将其写入应用中。
- en: Other Streamlit users will have less experience in Pythonic graphing, and especially
    for these users, Streamlit offers a few built-in functions. We'll start with built-in
    libraries and move on to learning how to import the most popular and powerful
    libraries for our Streamlit apps.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 Streamlit 用户可能在 Python 图形绘制方面经验较少，尤其是对于这些用户，Streamlit 提供了一些内置的功能。我们将从内置库开始，并逐步学习如何将最流行和最强大的库导入到我们的
    Streamlit 应用中。
- en: Streamlit's built-in graphing functions
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Streamlit 内置的绘图功能
- en: 'There are three built-in functions for graphing – `st.line_chart()`, `st.bar_chart()`,
    and `st.area_chart()`. They all work similarly by trying to figure out what variables
    you''re already trying to graph, and then put them into a line, bar, or area chart,
    respectively. In our dataset, we have a variable called `dbh`, which is the width
    of the tree at chest height. First, we can group our DataFrame by `dbh`, and then
    push that directly to the line chart, bar chart, and area chart. The following
    code should group our dataset by width, count the unique trees of each width,
    and then make a line, bar, and area chart of each:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个内置的绘图函数——`st.line_chart()`、`st.bar_chart()` 和 `st.area_chart()`。它们的工作方式类似，通过试图找出你已经准备绘制的变量，然后分别将它们放入折线图、条形图或面积图。在我们的数据集中，有一个名为`dbh`的变量，它表示树木在胸部高度的直径。首先，我们可以按`dbh`对DataFrame进行分组，然后将其直接推送到折线图、条形图和面积图中。以下代码应该根据宽度对数据集进行分组，统计每个宽度的独特树木数量，并绘制每个的折线图、条形图和面积图：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code should show our three graphs right after one another, as
    is shown in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应当显示我们三个图表，依次排列，如以下截图所示：
- en: '![Figure 3.2 – Lines, bars, area, and tree height'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 线条、条形、面积和树木高度'
- en: '](img/B16864_03_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_03_02.jpg)'
- en: Figure 3.2 – Lines, bars, area, and tree height
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 线条、条形、面积和树木高度
- en: We gave the function nothing except for the DataFrame, and it was able to guess
    correctly which items should be on the *x* and *y* axes and plot those to our
    Streamlit chart. Each of these charts is interactive by default! We can zoom in
    or out, roll out the mouse over points/bars/lines to see each data point, and
    even view fullscreen out of the box. These Streamlit functions are actually calling
    another popular graphing library called **Altair**, which we will learn how to
    use in more depth later in this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只给了函数一个DataFrame，它就能够正确猜测应该将哪些项目放在*x*轴和*y*轴上，并将这些数据绘制到我们的Streamlit图表中。每个图表默认都是交互式的！我们可以进行缩放，悬停鼠标在点/条/线上的位置查看每个数据点，甚至可以查看全屏。这些Streamlit函数实际上是调用了另一个流行的图形库**Altair**，我们将在本章后面更深入地学习如何使用它。
- en: 'Now that we see the basics of the built-in (it''s clear that the term *built-in*
    is fairly loose here, as Streamlit is built to be a great and convenient web application
    library, not a great visualization library) functions, let''s push these functions
    to see how they handle more data. First, we''re going to make a new column of
    random numbers between -500 and 500 in our `df_dbh_grouped` DataFrame using the
    `numpy` library and use the same plotting code that we used before. The following
    code plots two line charts, one before we added the new column, and one after:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了内置函数的基础（很明显，“内置”的定义在这里比较宽松，因为Streamlit被设计为一个很棒且方便的Web应用库，而不是一个很棒的可视化库），接下来我们将通过这些函数看看它们如何处理更多的数据。首先，我们将在`df_dbh_grouped`
    DataFrame中使用`numpy`库生成一个-500到500之间的随机数新列，并使用之前的绘图代码。以下代码绘制了两张折线图，一张是在我们添加新列之前，另一张是在添加新列之后：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code should produce an app that looks like the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该生成一个应用，效果如以下截图所示：
- en: '![Figure 3.3 – Two sequential line charts'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – 两个连续的折线图'
- en: '](img/B16864_03_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_03_03.jpg)'
- en: Figure 3.3 – Two sequential line charts
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 两个连续的折线图
- en: Again, these functions put whatever is on the index as the *x* axis and use
    all the columns they can as variables on the *y* axis. These built-in functions
    are very useful if we have an incredibly straightforward graphing problem in front
    of us (as in the example). However, these visualization functions are, overall,
    less flexible in comparison to libraries with the sole purpose of visualization
    and it may be difficult to debug the behavior behind these functions. The recommendation
    here is that if you are working with data that is easy to massage into a format
    where the index of the DataFrame belongs on the *x* axis, and the rest of the
    columns are plotted on the *y* axis, these functions will work well. For more
    complicated tasks, we should use other graphing libraries.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这些函数将索引中的内容作为*x*轴，并将所有可以作为变量的列用作*y*轴。对于我们面对的非常简单的绘图问题（如示例中所示），这些内置函数非常有用。然而，相比于专门用于可视化的库，这些可视化函数的灵活性较差，调试这些函数的行为也可能会有些困难。这里的建议是，如果你的数据很容易被整理成一种格式，其中DataFrame的索引位于*x*轴，其他列绘制在*y*轴上，这些函数会表现得很好。对于更复杂的任务，我们应该使用其他绘图库。
- en: 'There is one more built-in Streamlit graphing function that we should discuss
    here, `st.map()`. Just like the preceding functions, this wraps around another
    Python graphing library, this time `st.map()` using the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个我们应该在这里讨论的内置 Streamlit 图形函数，`st.map()`。就像前面的函数一样，它也是对另一个 Python 图形库的封装，这次是
    `st.map()`，使用以下代码：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This works perfectly well, right out of the box! We get a beautiful interactive
    map of the trees in San Francisco, as we can see in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这完美地工作，开箱即用！我们得到了一张美丽的旧金山树木交互式地图，正如下面的截图所示：
- en: '![Figure 3.4 – Default SF map of trees'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 默认的旧金山树木地图'
- en: '](img/B16864_03_04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_03_04.jpg)'
- en: Figure 3.4 – Default SF map of trees
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 默认的旧金山树木地图
- en: As with the other functions, we don't have many options for customization here
    other than an optional zoom parameter, but this works very well for a quick visualization.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他函数一样，除了可选的缩放参数外，我们在这里没有太多自定义选项，但这对于快速可视化来说效果非常好。
- en: As we've seen, these built-in functions can be useful for making Streamlit apps
    quickly, but we trade off speed for customizability. In practice, I rarely use
    these functions when I produce Streamlit apps, but often use these when doing
    quick visualizations of data already in Streamlit. In production, more powerful
    libraries, such as **Matplotlib**, **Seaborn**, and **PyDdeck**, give us the flexibility
    and customizability we want. The rest of this chapter will walk through six different
    popular Python visualization libraries.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这些内置函数对于快速制作 Streamlit 应用非常有用，但我们也牺牲了自定义性以换取速度。实际上，我在制作 Streamlit 应用时很少使用这些函数，但在快速可视化
    Streamlit 中已有的数据时，常常会使用它们。在生产环境中，更强大的库，如 **Matplotlib**、**Seaborn** 和 **PyDeck**，为我们提供了所需的灵活性和可定制性。本章接下来将介绍六种不同的流行
    Python 可视化库。
- en: Streamlit's built-in visualization options
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Streamlit 内置的可视化选项
- en: For the rest of this chapter, we're going to run through the rest of the Streamlit
    visualization options, which are **Plotly**, **Matplotlib**, **Seaborn**, **Bokeh**,
    **Altair**, and **PyDeck**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余部分，我们将依次介绍 Streamlit 的其他可视化选项，分别是 **Plotly**、**Matplotlib**、**Seaborn**、**Bokeh**、**Altair**
    和 **PyDeck**。
- en: Plotly
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Plotly
- en: Plotly is an interactive visualization library that many data scientists use
    for visualizing data in Jupyter, in the browser locally, or even hosting these
    graphs to be viewed on a platform for visualizations and dashboards created by
    the Plotly team called **Dash**. This library is very similar to Streamlit in
    its intent and is primarily used for internal or external dashboards (hence, the
    name Dash).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Plotly 是一个交互式可视化库，许多数据科学家用它来在 Jupyter 中、在本地浏览器中，甚至在 Plotly 团队创建的可视化和仪表盘平台 **Dash**
    上托管这些图表，以供查看。这个库与 Streamlit 的意图非常相似，主要用于内部或外部的仪表盘（因此得名 Dash）。
- en: 'Streamlit allows us to call `plotly` graphs from within Streamlit apps using
    the `st.plotly_chart()` function, which makes it a breeze to port any Plotly or
    Dash dashboards. We''ll test this out by making a histogram of the height of the
    trees in SF, essentially the same graph that we''ve made before. The following
    code makes our Plotly histogram:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 允许我们通过 `st.plotly_chart()` 函数在 Streamlit 应用中调用 `plotly` 图表，这使得迁移任何
    Plotly 或 Dash 仪表盘变得非常简单。我们将通过制作旧金山树木高度的直方图来进行测试，这基本上就是我们之前制作的相同图表。以下代码生成了我们的 Plotly
    直方图：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we''ll notice, all the interactivity native to Plotly works by default in
    Streamlit. The user can scroll over the histogram bars and get the exact info
    about each one. There are a few other useful built-in features to Plotly that
    port over to Streamlit, such as the ability to zoom in and out, download the plot
    as a `png`, and select a group of data points/bars/lines. The full features can
    be seen in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所注意到的，Plotly 的所有原生交互功能在 Streamlit 中默认是可以使用的。用户可以滚动查看直方图条形图并获得每个条形的准确信息。Plotly
    还有一些其他有用的内置功能会传递到 Streamlit，例如缩放、将图表下载为 `png` 文件，以及选择一组数据点/条形/线条。完整的功能可以在以下截图中查看：
- en: '![Figure 3.5 – First Plotly chart'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 第一个 Plotly 图表'
- en: '](img/B16864_03_05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_03_05.jpg)'
- en: Figure 3.5 – First Plotly chart
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 第一个 Plotly 图表
- en: Now that we're comfortable with Plotly, we can move on to other popular visualization
    libraries, **Matplotlib** and **Seaborn**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 Plotly 足够熟悉，可以继续学习其他流行的可视化库，**Matplotlib** 和 **Seaborn**。
- en: Matplotlib and Seaborn
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Matplotlib 和 Seaborn
- en: 'Earlier in this book, we learned how to use the Matplotlib and Seaborn visualization
    libraries inside Streamlit, so we will just go over them briefly here. There is
    a column called **date** in the trees dataset that corresponds to the date that
    the tree was planted. We can use the datetime library to figure out the age of
    each tree in days, and plot that histogram using Seaborn and Matplotlib, respectively.
    The following code creates a new column called age, which is the difference in
    days between the tree planting date and today, and then graphs the histogram of
    the age using both Seaborn and Matplotlib:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本书前面，我们学习了如何在Streamlit中使用Matplotlib和Seaborn可视化库，因此这里我们只会简要讲解它们。树木数据集中有一列名为**date**，对应着树木栽种的日期。我们可以使用datetime库来计算每棵树的年龄（以天为单位），然后分别使用Seaborn和Matplotlib绘制该年龄的直方图。以下代码创建了一个名为age的新列，表示树木栽种日期与今天之间的天数差，然后使用Seaborn和Matplotlib分别绘制该年龄的直方图：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we defined unique subplots for each graph, created a
    Seaborn or Matplotlib graph for each, and then used the `st.pyplot()` function
    to insert each graph in order onto our Streamlit app. The preceding code should
    show an app similar to the following screenshot (I say similar because, depending
    on when you run this, the age of the trees will be different as `pd.to_datetime`
    (''today'') will return your current date:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为每个图形定义了独特的子图，为每个图形创建了Seaborn或Matplotlib图形，然后使用`st.pyplot()`函数将每个图形按顺序插入到我们的Streamlit应用中。前面的代码应该会展示一个类似于以下屏幕截图的应用（我说“类似”是因为，根据你运行代码的时间，树木的年龄会有所不同，因为`pd.to_datetime`（'today'）将返回当前日期）：
- en: '![Figure 3.6 – Seaborn and Matplotlib histograms'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – Seaborn 和 Matplotlib 直方图'
- en: '](img/B16864_03_06.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_03_06.jpg)'
- en: Figure 3.6 – Seaborn and Matplotlib histograms
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – Seaborn 和 Matplotlib 直方图
- en: Whether you use Seaborn or Matplotlib, you'll use the `st.pyplot()` function
    in the same way. Now that we're more comfortable with these libraries, we should
    learn about another interactive visualization library – **Bokeh**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用Seaborn还是Matplotlib，你都会以相同的方式使用`st.pyplot()`函数。既然我们已经对这些库更加熟悉，现在我们应该了解另一个交互式可视化库——**Bokeh**。
- en: Bokeh
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bokeh
- en: Bokeh is another web-based interactive visualization library that also has dashboarding
    products built on top of it. It is a direct competitor to Plotly, but is more
    focused on the Python ecosystem, whereas Plotly is built on top of `Plotly.js`.
    Either way, Bokeh is an extremely popular Python visualization package that Python
    users may be very comfortable using.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Bokeh是另一个基于Web的交互式可视化库，且其上有构建仪表盘产品。它是Plotly的直接竞争对手，但更加专注于Python生态系统，而Plotly则是建立在`Plotly.js`之上的。无论如何，Bokeh是一个极受欢迎的Python可视化包，Python用户可能会非常熟悉使用它。
- en: 'We can call Bokeh graphs using the same format as Plotly. First, we create
    the Bokeh graph, and then we use the `st.bokeh_chart()` function to write the
    app to Streamlit. In Bokeh, we have to first instantiate a Bokeh figure object,
    and then change aspects of that figure before we plot it out. The important lesson
    here is that if we change an aspect of the Bokeh figure object after we call the
    `st.bokeh_chart()` function, we will not change the graph shown on the Streamlit
    app. For example, when we run the following code, we will not see a new *x* axis
    title at all:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与Plotly相同的格式调用Bokeh图形。首先，我们创建Bokeh图形，然后使用`st.bokeh_chart()`函数将应用写入Streamlit。在Bokeh中，我们必须先实例化一个Bokeh图形对象，然后在绘制之前更改该图形的一些属性。这里的重要教训是，如果我们在调用`st.bokeh_chart()`函数后更改Bokeh图形对象的某个属性，我们将不会改变Streamlit应用中显示的图形。例如，当我们运行以下代码时，我们将看不到新的*x*轴标题：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Instead, we'll have to switch the order of the last two lines, which will now
    show up on our app. We'll add a *y* axis for good measure as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要交换最后两行代码的顺序，这样它们就会在应用中显示出来。我们还将添加一个*y*轴以确保图形的完整性。
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code will create a Bokeh chart of `dbh` versus `site_order`,
    as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将创建一个Bokeh图表，展示`dbh`与`site_order`的关系，如下所示的屏幕截图：
- en: '![Figure 3.7 – Bokeh scatterplot'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – Bokeh 散点图'
- en: '](img/B16864_03_07.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_03_07.jpg)'
- en: Figure 3.7 – Bokeh scatterplot
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – Bokeh 散点图
- en: Now, onto our next visualization library – Altair!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍下一个可视化库——Altair！
- en: Altair
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Altair
- en: We've already used `st.line_chart()` or `st.map()`, but now we'll explore how
    to use Altair directly. Altair is a declarative visualization library, which loosely
    means that instead of explicitly writing out each feature in a graph (such as
    naming *x* axes), we pass the relationships between the columns as desired, and
    Altair takes care of the rest.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用过 `st.line_chart()` 或 `st.map()`，但现在我们将探索如何直接使用 Altair。Altair 是一个声明式可视化库，简单来说，意味着我们不需要显式地编写图表中的每个特性（如命名
    *x* 轴），我们只需传递列之间的关系，Altair 会自动处理剩下的部分。
- en: We've made quite a few graphs with this dataset already, but why don't we explore
    a new column, the caretaker column? This bit of data defines who is in charge
    of the tree (public or private) and if public, what government organization is
    responsible for upkeep. Thrilling!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用这个数据集制作了不少图表，但为什么不探索一下新的列——看护人列呢？这一数据定义了谁负责照看这些树（公共还是私有），如果是公共的，那么是哪个政府机构负责维护。真是激动人心！
- en: 'The following code groups our DataFrame by caretaker, and then uses that grouped
    DataFrame within Altair:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将我们的 DataFrame 按照看护人进行分组，然后在 Altair 中使用这个分组后的 DataFrame：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Altair also allows us to summarize our data directly within the `y` value of
    `mark_bar()`, so we can simplify this by instead using the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Altair 还允许我们直接在 `mark_bar()` 的 `y` 值中汇总数据，因此我们可以通过以下代码来简化操作：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code will create a Streamlit app showing the count of trees by
    caretaker in SF, shown in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建一个 Streamlit 应用，展示 SF 中按照看护人分类的树木数量，如下图所示：
- en: '![Figure 3.8 – Altair bar chart'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – Altair 条形图'
- en: '](img/B16864_03_08.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_03_08.jpg)'
- en: Figure 3.8 – Altair bar chart
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – Altair 条形图
- en: This should be it for traditional visualization libraries, but Streamlit also
    allows us to use more complex visualization libraries such as `st.map()` function
    and will explore this in more depth in the following section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传统的可视化库，这应该就是全部了，但 Streamlit 还允许我们使用更复杂的可视化库，如 `st.map()` 函数，并将在下一部分中深入探讨这个功能。
- en: PyDeck
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyDeck
- en: PyDeck is a visualization library that plots visualizations as layers on top
    of **Mapbox** (a mapping company with a truly exceptional free tier) maps. Both
    Streamlit and PyDeck have a base set of limited features available without signing
    up for a Mapbox account, but greatly expand their free features when we get a
    **Mapbox** token, which we will do in this next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: PyDeck 是一个可视化库，可以将可视化作为图层绘制在 **Mapbox**（一家拥有真正出色免费套餐的地图公司）地图上。Streamlit 和 PyDeck
    都提供了一个基础的功能集，在未注册 Mapbox 账户的情况下可以使用，但当我们获得 **Mapbox** 令牌后，这些功能将大大扩展，我们将在下一部分获取该令牌。
- en: Configuration options
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置选项
- en: 'In order to set up your own `config.toml`. To view our current settings, we
    can run the following command anywhere in the terminal:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置你自己的 `config.toml`，我们可以在终端中的任何地方运行以下命令来查看当前设置：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are four methods that Streamlit offers for changing our default configuration
    settings, I'll show you my recommended option and one of the other options, which
    should provide you with the majority of the use cases. If you find these options
    insufficient, the Streamlit documentation ([https://docs.streamlit.io/](https://docs.streamlit.io/))
    goes over all four options in great detail.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 提供了四种更改默认配置设置的方法，我将向你展示我推荐的选项和另一个选项，这两个选项应该能满足大多数使用场景。如果你觉得这些选项不足，Streamlit
    文档（[https://docs.streamlit.io/](https://docs.streamlit.io/)）会详细介绍这四种方法。
- en: 'The first option is to set global configuration options by directly editing
    the `config.toml` file. We can edit the file directly by opening it in our text
    editor. The following command will open the file in `sublime`. For other text
    editors (such as Vim and Atom), replace `''sublime''` with the appropriate command
    or open the file directly from the text editor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是通过直接编辑 `config.toml` 文件来设置全局配置选项。我们可以通过文本编辑器直接打开该文件进行编辑。以下命令将在 `sublime`
    中打开该文件。对于其他文本编辑器（如 Vim 和 Atom），请将 `'sublime'` 替换为相应的命令，或直接从文本编辑器打开该文件：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If this fails, it likely means that we do not have the file generated already.
    We can either copy and paste the output of `~/.streamlit/config.toml`, or we can
    run the following shortcut for Mac/Linux:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果失败了，这很可能意味着我们还没有生成文件。我们可以复制并粘贴 `~/.streamlit/config.toml` 的输出，或者可以在 Mac/Linux
    上运行以下快捷方式：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have the file opened in `sublime`, we can view and edit any of the
    options directly. This option is great for a config option such as a `8501 serverPort`.
    It would not make sense to change a global option for a project-specific change,
    which leads us to the second option.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在`sublime`中打开了文件，可以直接查看并编辑任何选项。这个选项非常适合配置选项，比如`8501 serverPort`。改变全局选项来进行项目特定的更改是没有意义的，这也引出了第二个选项。
- en: The second option is to create and edit a project-specific `config.toml` file.
    Our previous config sets our default config options, while this option is specific
    per Streamlit app. Here is where our individual project folders within the `streamlit_apps`
    folder come in handy!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是创建并编辑一个项目特定的`config.toml`文件。我们之前的配置设置了默认的配置选项，而这个选项则是针对每个Streamlit应用程序的特定设置。此时，我们在`streamlit_apps`文件夹中的每个单独项目文件夹就派上用场了！
- en: 'Broadly speaking, we will do the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从大致来说，我们将执行以下操作：
- en: Check our current working directory.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们的当前工作目录。
- en: Make a config file for our project.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的项目创建一个配置文件。
- en: Use the config file within PyDeck.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PyDeck中使用配置文件。
- en: Our first step is to make sure our current working directory is the `trees_app`
    folder by running the `pwd` command in your terminal, which will show our current
    working directory and should end with `trees_app`' (for example, mine looks like
    `Users/tyler/Documents/streamlit_apps/trees_app`).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是确保当前工作目录是`trees_app`文件夹，可以通过在终端中运行`pwd`命令来查看当前工作目录，结果应该以`trees_app`结尾（例如，我的路径是`Users/tyler/Documents/streamlit_apps/trees_app`）。
- en: 'Now, we need to make a config file just for our project. First, we will make
    a folder called `.streamlit`, and then we will repeat the Mac/Linux shortcut we
    used above:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为我们的项目制作一个配置文件。首先，我们将创建一个名为`.streamlit`的文件夹，然后我们将重复之前在Mac/Linux上使用的快捷方式：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can then edit our config options just as we did before, but this will only
    be applicable to our Streamlit apps when we run Streamlit from that directory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像之前一样编辑我们的配置选项，但这将仅适用于我们从该目录运行Streamlit时的Streamlit应用程序。
- en: 'Now, finally, we can go back to `37.77, -122.4`. We can do this using the following
    code, which first defines the initial state (where we want to start viewing the
    map), and then calls `st.pydeck_chart()` using that initial state:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，我们可以回到`37.77, -122.4`。我们可以使用以下代码来实现，代码首先定义初始状态（我们希望从哪里开始查看地图），然后使用该初始状态调用`st.pydeck_chart()`：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code will produce a map of San Francisco, which we can use to layer on
    data points. We notice a couple of things here. First, that the black default
    map may be difficult to see, and second, that we need to spend time zooming in
    to San Francisco to get the view that we need. We can fix both these items by
    using the defaults suggested in the Streamlit documentation ([https://docs.streamlit.io/](https://docs.streamlit.io/)),
    as seen in the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将生成一张旧金山的地图，我们可以用它来叠加数据点。我们在这里注意到几件事。首先，黑色的默认地图可能不太容易看到，其次，我们需要花时间缩放到旧金山以获得所需的视图。我们可以通过使用Streamlit文档中建议的默认值来修复这两个问题（[https://docs.streamlit.io/](https://docs.streamlit.io/)），如下代码所示：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code should create a map that looks like the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码应该会创建一张如下截图所示的地图：
- en: '![Figure 3.9 – PyDeck mapping: SF base map'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.9 – PyDeck映射：旧金山基础地图'
- en: '](img/B16864_03_09.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_03_09.jpg)'
- en: 'Figure 3.9 – PyDeck mapping: SF base map'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – PyDeck映射：旧金山基础地图
- en: 'This is exactly what we want! We can see the entire `11` so we can see each
    point better:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们需要的！我们可以看到整个`11`，所以可以更好地看到每个数据点：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The best values for both the zoom and radius parameters are dependent on your
    visualization preferences. Try a few options out to see what looks the best. The
    preceding code will make the following map:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放和半径参数的最佳值取决于您的可视化偏好。尝试一些选项，看看哪种效果最好。上面的代码将生成以下地图：
- en: '![Figure 3.10 – Mapping SF trees'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.10 – 映射旧金山的树木'
- en: '](img/B16864_03_10.png)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_03_10.png)'
- en: Figure 3.10 – Mapping SF trees
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 映射旧金山的树木
- en: As with previous maps, this is interactive by default, so we can zoom into different
    parts of San Francisco to see where the places with the highest tree density are.
    For our next change to this map, we are going to add another layer, this time
    of hexagons, which will be colored based on the density of the trees in SF. We
    can use the same code as above, but change the scatterplot layer to a hexagon
    layer. We also will include the option to have the hexagon extrude vertically,
    which isn't necessary, but it is certainly a fun visualization style.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的地图一样，这个地图默认是互动的，因此我们可以缩放到旧金山的不同区域，查看树木密度最高的地方。对于地图的下一个变化，我们将添加另一个图层，这一次是六边形图层，将根据旧金山的树木密度进行着色。我们可以使用与上面相同的代码，但将散点图层更改为六边形图层。我们还将包括一个选项，可以让六边形在垂直方向上突出显示，虽然这不是必须的，但绝对是一种有趣的可视化风格。
- en: 'Our last change is to change the pitch or the angle at which we are viewing
    the map. The default pitch, as we can see, is nearly directly down at the city,
    which will not work if we are trying to view vertical hexagons on our map. The
    following code implements each one of these changes:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的改动是更改我们查看地图时的视角或角度。默认的视角，如我们所见，几乎是直接向下查看城市，但如果我们要在地图上查看垂直的六边形，这个角度将无法使用。以下代码实现了这些变化：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As with the previous map, the optimal radius and pitch parameters will change
    based on your visualizations. Try changing each one of these around a few times
    to see whether you can get the hang of it! The preceding code will produce the
    following app:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的地图一样，最佳的半径和视角参数将根据你的可视化效果而有所不同。试着更改这些参数几次，看看是否能掌握其诀窍！上面的代码将生成以下应用程序：
- en: '![Figure 3.11 – Final San Francisco Trees map'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.11 – 最终的旧金山树木地图'
- en: '](img/B16864_03_11.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_03_11.jpg)'
- en: Figure 3.11 – Final San Francisco Trees map
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 最终的旧金山树木地图
- en: From this screenshot, we can see that **PyDeck** creates darker circles where
    there exists a higher density of trees in SF. We can observe from this many interesting
    details, such as the fact that the dataset seems to be missing trees from the
    famous Golden Gate Park on the west side of the city, and that the area around
    the Golden Gate Bridge also seems to have very few trees in the dataset.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张截图中，我们可以看到**PyDeck**在旧金山的树木密度较高的地方绘制了较暗的圆圈。从中我们可以观察到很多有趣的细节，比如数据集似乎缺少了位于城市西侧著名的金门公园中的树木，而且金门大桥周围的区域似乎也在数据集中几乎没有树木。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After this chapter, you hopefully have a solid understanding of how to leverage
    the incredible open source Python visualization libraries to make web apps in
    Streamlit.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章之后，你应该能够牢固掌握如何利用令人惊叹的开源Python可视化库来在Streamlit中创建Web应用程序。
- en: First, we learned how to use the default visualization options, such as `st.line_chart()`
    and `st.map()`, and then we dove into interactive libraries such as Plotly, mapping
    libraries such as PyDeck, and everything in between.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们学习了如何使用默认的可视化选项，如`st.line_chart()`和`st.map()`，然后我们深入了解了像Plotly这样的交互式库，像PyDeck这样的地图绘图库，以及介于两者之间的一切。
- en: In our next chapter, we will cover how to use machine learning in Streamlit.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讲解如何在Streamlit中使用机器学习。
