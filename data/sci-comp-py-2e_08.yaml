- en: Classes
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: 'In mathematics, when we write ![](img/b1869c68-1acd-4903-8bde-c96d445836db.png),
    we refer to a mathematical object for which we know many methods from elementary
    calculus. For example:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，当我们写 ![](img/b1869c68-1acd-4903-8bde-c96d445836db.png) 时，我们指的是一个数学对象，对于这个对象，我们知道很多初等微积分的方法。例如：
- en: We might want to evaluate [![](img/a629d68f-bc0d-4504-922b-d25a0ffd394a.png)]
    at [![](img/b8a07b49-896f-4d82-b58b-93e1134b360f.png)], that is, compute ![](img/5566ed05-3ece-4bd8-9e92-47a924e36044.png),
    which returns a real number.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想在 [![](img/a629d68f-bc0d-4504-922b-d25a0ffd394a.png)] 处评估 [![](img/b8a07b49-896f-4d82-b58b-93e1134b360f.png)]，即计算
    ![](img/5566ed05-3ece-4bd8-9e92-47a924e36044.png)，其结果为一个实数。
- en: We might want to compute its derivative, which gives us another mathematical
    object, **cos**.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想计算它的导数，这会给我们另一个数学对象，**cos**。
- en: We might want to compute the first three coefficients of its Taylor polynomial.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想计算其泰勒多项式的前三个系数。
- en: These methods may be applied not only to **sin** but also to other sufficiently
    smooth functions. There are, however, other mathematical objects, for example,
    the number *5,* for which these methods would make no sense.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法不仅适用于 **sin**，还适用于其他足够光滑的函数。然而，也有其他数学对象，例如数字 *5*，对于这些对象，这些方法是没有意义的。
- en: Objects that have the same methods are grouped together in abstract classes,
    for example, functions. Every statement and every method that can be applied to
    functions in general applies in particular to **sin** or **cos**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同方法的对象被归为抽象类，例如函数。可以应用于函数的每个语句和方法，特别适用于 **sin** 或 **cos**。
- en: Other examples for such classes might be a rational number, for which a denominator
    and numerator method exist; an interval, which has a left and right boundary method;
    an infinite sequence, for which we can ask whether it has a limit, and so on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此类的其他例子可能是有理数，存在分母和分子方法；区间，具有左边界和右边界方法；无限序列，我们可以询问它是否有极限，等等。
- en: In this case, ![](img/796b437a-5221-4fa9-af25-8c1efb98be48.png) is called an
    *instance* of the class. The mathematical phrase *Let g be a function...* is,
    in this context, called **instantiation**. Here, ![](img/b441010f-f760-498d-83b1-19bbbacf79ca.png)
    is the name of the function, one of many *attributes* that can be assigned to
    it. Another attribute might be its domain.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，![](img/796b437a-5221-4fa9-af25-8c1efb98be48.png) 被称为*实例*。数学表达式 *设 g
    为一个函数...* 在这种情况下被称为**实例化**。这里，![](img/b441010f-f760-498d-83b1-19bbbacf79ca.png)
    是函数的名称，这是可以分配给它的众多*属性*之一。另一个属性可能是它的定义域。
- en: The mathematical object [![](img/792a1325-520d-43b7-a0e4-3bab90b0f537.png)]
    is just like the sine function. Every function method applies to ![](img/a10ad167-28bd-4fc6-9c5f-8a658b818ccb.png),
    but we can also define special methods for ![](img/5b332529-ae82-48ca-86f5-8858c45f7ae7.png).
    We might, for instance, ask for ![](img/4d4879f1-5b0b-4547-8323-dc47f88332e5.png)*'*s
    coefficients. These methods can be used to define the class of polynomials. As
    polynomials are functions, they additionally *inherit* all methods of the function
    class.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数学对象 [![](img/792a1325-520d-43b7-a0e4-3bab90b0f537.png)] 就像正弦函数。每个函数方法都适用于 ![](img/a10ad167-28bd-4fc6-9c5f-8a658b818ccb.png)，但我们也可以为
    ![](img/5b332529-ae82-48ca-86f5-8858c45f7ae7.png) 定义特殊的方法。例如，我们可能会要求 ![](img/4d4879f1-5b0b-4547-8323-dc47f88332e5.png)*'*s
    的系数。这些方法可以用来定义多项式类。由于多项式是函数，它们还*继承*了函数类的所有方法。
- en: In mathematics, we often use the same operator symbol for completely different
    operations. For instance, in ![](img/b3530656-c09b-4bda-87e2-34e9dac3fec7.png)
    and ![](img/23af4c8e-d3ba-4c2a-b5be-9d1e88f67112.png), the operator symbol `+`
    has different meanings. By using the same symbol, similarities to corresponding
    mathematical operations are emphasized. We have introduced these terms from object-oriented
    programming by applying them to mathematical examples, such as classes, instance
    and instantiation, inheritance, methods, attributes, and operator overloading.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，我们经常使用相同的运算符符号来表示完全不同的运算。例如，在 ![](img/b3530656-c09b-4bda-87e2-34e9dac3fec7.png)
    和 ![](img/23af4c8e-d3ba-4c2a-b5be-9d1e88f67112.png) 中，运算符符号 `+` 的含义是不同的。通过使用相同的符号，强调了与对应数学运算的相似性。我们通过将这些术语从面向对象编程引入数学示例中，来应用它们，如类、实例和实例化、继承、方法、属性以及运算符重载。
- en: 'Specifically, in this chapter, we are going to cover the following topics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，我们将涵盖以下主题：
- en: Introduction to classes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的简介
- en: Bound and unbound methods
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定方法和非绑定方法
- en: Class attributes and class methods
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类属性和类方法
- en: Subclasses and inheritance
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类和继承
- en: Encapsulation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Classes as decorators
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类作为装饰器
- en: In this chapter, we will show how these concepts are used in Python and start
    with some fundamentals.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示这些概念如何在 Python 中使用，并从一些基础知识开始。
- en: 8.1 Introduction to classes
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.1 类简介
- en: This section introduces the most common terms of classes and their realization
    in Python.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了类的最常见术语及其在 Python 中的实现。
- en: First, we set up a guiding example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置一个指导性示例。
- en: '8.1.1 A guiding example: Rational numbers'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.1 一个指导性示例：有理数
- en: We will illustrate the concept of classes with the example of rational numbers,
    that is, numbers of the form ![](img/66f8f5f2-953a-4695-ba5d-a6ed3021626e.png),
    where ![](img/830cf1ec-1cf4-43f7-9771-6b50c9b2ed63.png) and ![](img/99434b20-95a8-41b5-b0fa-79fbd50f80f7.png)
    are integers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过有理数的示例来说明类的概念，即形如 ![](img/66f8f5f2-953a-4695-ba5d-a6ed3021626e.png) 的数字，其中
    ![](img/830cf1ec-1cf4-43f7-9771-6b50c9b2ed63.png) 和 ![](img/99434b20-95a8-41b5-b0fa-79fbd50f80f7.png)
    是整数。
- en: 'The following figure gives an example of a class declaration:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示给出了一个类声明的示例：
- en: '![](img/cecb5307-8e17-4e70-92d6-ac4927583d45.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cecb5307-8e17-4e70-92d6-ac4927583d45.png)'
- en: 'Figure 8.1: Example of a class declaration'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：类声明示例
- en: We use rational numbers here only as an example of the class concept. For future
    work in Python with rational numbers, use the Python module `fractions`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们仅使用有理数作为类概念的示例。若要在 Python 中进行有理数运算，请使用 Python 模块 `fractions`。
- en: 8.1.2 Defining a class and making an instance
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.2 定义类并创建实例
- en: 'The definition of a class is made by a block command with the keyword `class`,
    the name of the class, and some statements in the block (see *Figure 8.1*):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类的定义是通过一个块命令来完成的，该命令使用 `class` 关键字、类名以及块中的一些语句（见 *图 8.1*）：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An instance of this class (or in other words, an object of the type `RationalNumber`)
    is created by `r = RationalNumber()` and the query `type(r)` returns the answer,
    `<class''__main__.RationalNumber''>`. If we want to investigate whether an object
    is an instance of this class, we can use the following lines:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `r = RationalNumber()` 创建该类的实例（或换句话说，创建一个 `RationalNumber` 类型的对象），并且查询 `type(r)`
    返回的结果是 `<class'__main__.RationalNumber'>`。如果我们想检查一个对象是否是该类的实例，可以使用以下代码：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So far, we have generated an object of the type `RationalNumber` that has no
    data yet. Furthermore, there are no methods defined to perform operations with
    these objects. This is the subject of the next sections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经生成了一个类型为 `RationalNumber` 的对象，但该对象尚未包含任何数据。此外，尚未定义任何方法来对这些对象进行操作。接下来的章节将讨论这一主题。
- en: 8.1.3 The __init__ method
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.3 `__init__` 方法
- en: 'Now we provide our example class with some attributes, that is, we give it
    defining data. In our case, this data will be the values of the denominator and
    the numerator. To this end, we have to define a method, `__init__`, used to initialize
    the class with these values:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为示例类提供一些属性，即我们为其定义数据。在我们的例子中，这些数据将是分子和分母的值。为此，我们需要定义一个方法 `__init__`，用来使用这些值初始化类：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Before we explain the special function `__init__`, which we added to the class,
    we demonstrate the instantiation of a `RationalNumber` object:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释添加到类中的特殊函数 `__init__` 之前，我们先演示 `RationalNumber` 对象的实例化：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A new object of type `RationalNumber` is created by using the class name as
    if it were a function. This statement does two things:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将类名作为函数使用，可以创建一个新的 `RationalNumber` 类型的对象。这条语句做了两件事：
- en: It first creates an empty object, `q`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它首先创建一个空对象 `q`。
- en: Then it applies the `__init__` function to it; that is, `q.__init__(10, 20)`
    is executed.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它应用 `__init__` 函数；也就是说，执行 `q.__init__(10, 20)`。
- en: The first parameter of `__init__` refers to the new object itself. On a function
    call, this first parameter is replaced by the object's instance. This applies
    to all methods of the class and not just to the special method `__init__`. The
    special role of this first parameter is reflected by the convention to name it
    `self`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__` 的第一个参数指的是新对象本身。在函数调用时，这个第一个参数被对象的实例替代。这适用于类的所有方法，而不仅仅是特殊方法 `__init__`。这个第一个参数的特殊作用体现在约定中，通常将其命名为
    `self`。'
- en: In the previous example, the function `__init__` defines two attributes of the
    new object, `numerator` and `denominator`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`__init__` 函数定义了新对象的两个属性，`numerator` 和 `denominator`。
- en: 8.1.4 Attributes and methods
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.4 属性和方法
- en: 'One of the main reasons for working with classes is that objects can be grouped
    together and bound to a common object. We saw this already when looking at rational
    numbers; `denominator` and `numerator` are two objects that we bound to an instance
    of the class `RationalNumber`. They are called **attributes of the instance**.
    The fact that an object is an attribute of a class instance becomes apparent from
    the way they are referenced, which we have used tacitly before:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类的一个主要原因是可以将对象归为一组并绑定到一个共同的对象上。当我们查看有理数时就看到了这一点；`denominator` 和 `numerator`
    是两个我们绑定到 `RationalNumber` 类实例的对象。它们被称为**实例的属性**。一个对象作为类实例的属性这一事实，通过它们的引用方式变得显而易见，我们之前已经默契地使用过这种方式：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here are some examples of instantiation and attribute reference:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些实例化和属性引用的示例：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once an instance is defined, we can set, change, or delete attributes of that
    particular instance. The syntax is the same as for regular variables:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例定义好，我们就可以设置、更改或删除该实例的属性。语法与普通变量相同：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Changing or deleting an attribute may have undesired side effects, which might
    even render the object useless. We will be learning more about this in [Section
    8.2](1654fae9-6203-4871-8352-e436445fa49a.xhtml): *Attributes that depend on each
    other*. As functions are objects too, we can also use functions as attributes;
    they are called methods of the instance:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更改或删除属性可能会产生不希望出现的副作用，甚至可能导致对象失效。我们将在[第 8.2 节](1654fae9-6203-4871-8352-e436445fa49a.xhtml)中学习更多内容：*相互依赖的属性*。由于函数也是对象，我们也可以将函数作为属性使用；它们被称为实例的方法：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For example, let''s add a method to the class `RationalNumber` that converts
    the number to a float:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们向 `RationalNumber` 类添加一个方法，将数字转换为浮点数：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Again, this method takes as its first (and only) argument `self`, the reference
    to the object itself. We use this method with a regular function call:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个方法将 `self` 作为第一个（也是唯一的）参数，`self` 是对对象本身的引用。我们使用这个方法时像调用普通函数一样：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is equivalent to the following call:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这等价于以下调用：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note again that the object instance is inserted as the first argument of the
    function. This use of the first argument explains the error message that would
    occur if this particular method were used with additional arguments. The call
    `q.convert2float(15)` provokes this error message:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，对象实例作为函数的第一个参数插入。这种第一个参数的使用解释了如果该方法带有附加参数时所产生的错误消息。调用 `q.convert2float(15)`
    会引发以下错误消息：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The reason this does not work is that `q.convert2float(15)` is precisely equivalent
    to `RationalNumber.comvert2float(q,15)`, which fails because `RationalNumber.convert2float`
    takes only one argument.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以不起作用，是因为 `q.convert2float(15)` 正好等同于 `RationalNumber.convert2float(q,15)`，而这失败了，因为
    `RationalNumber.convert2float` 只接受一个参数。
- en: 8.1.5 Special methods
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.5 特殊方法
- en: 'The special method `__repr__` gives us the ability to define the way the object
    is represented in a Python interpreter. For rational numbers, a possible definition
    of this method could be as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法 `__repr__` 使我们能够定义对象在 Python 解释器中的表现方式。对于有理数，这个方法的可能定义如下：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this method defined, just typing `q` returns `10 / 20`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这个方法后，只需输入 `q` 就会返回 `10 / 20`。
- en: 'We would like to have a method that performs the addition of two rational numbers.
    A first attempt could result in a method like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一个方法能执行两个有理数的加法。第一次尝试可能会得到如下方法：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A call to this method takes the following form:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法的形式如下：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It would be much nicer if we could write `q + p` instead. But so far, the plus
    sign is not defined for the type `RationalNumber`. This is done by using the special
    method `__add__`. So, just renaming `add` to `__add__` allows using the plus sign
    for rational numbers:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够写成 `q + p` 会更好。但到目前为止，加号对 `RationalNumber` 类型还没有定义。这是通过使用特殊方法 `__add__`
    来完成的。因此，只需将 `add` 重命名为 `__add__`，就可以对有理数使用加号：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The expression `q + p` is, in fact, an alias for the expression `q.__add__(p)`.
    In *Table 8.1*, you find special methods for binary operators such as `+`, `-`,
    or `*`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `q + p` 实际上是 `q.__add__(p)` 表达式的别名。在*表 8.1* 中，你可以找到二元运算符（如 `+`、`-` 或 `*`）的特殊方法：
- en: '| **Operator** | **Method** | **Operator** | **Method** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **方法** | **运算符** | **方法** |'
- en: '| `+` | `__add__` | `+=` | `__iadd__` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `+` | `__add__` | `+=` | `__iadd__` |'
- en: '| `*` | `__mul__` | `*=` | `__imul__` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `*` | `__mul__` | `*=` | `__imul__` |'
- en: '| `-` | `__sub__` | `-=` | `__isub__` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `-` | `__sub__` | `-=` | `__isub__` |'
- en: '| `/` | `__truediv__` | `/=` | `__itruediv__` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `/` | `__truediv__` | `/=` | `__itruediv__` |'
- en: '| `//` | `__floordiv__` | `//=` | `__ifloordiv__` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `//` | `__floordiv__` | `//=` | `__ifloordiv__` |'
- en: '| `**` | `__pow__` |  |  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `**` | `__pow__` |  |  |'
- en: '| `==` | `__eq__` | `!=` | `qD__ne__` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `==` | `__eq__` | `!=` | `qD__ne__` |'
- en: '| `<=` | `__le__` | `<` | `__lt__` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | `__le__` | `<` | `__lt__` |'
- en: '| `>=` | `__ge__` | `>` | `__gt__` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | `__ge__` | `>` | `__gt__` |'
- en: '| `()` | `__call__` | `[]` | `__getitem__` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `()` | `__call__` | `[]` | `__getitem__` |'
- en: 'Table 8.1: Some Python operators and corresponding class methods'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1：一些Python运算符及其对应的类方法
- en: 'The implementation of those operators for a new class is called **operator
    overloading**. Another example of operator overloading is a method for examining
    whether two rational numbers are the same:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为新类实现这些运算符被称为**运算符重载**。运算符重载的另一个示例是一个方法，用于检查两个有理数是否相等：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It is used like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用方式如下：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Operations between objects belonging to different classes need special care:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类之间的操作需要特别注意：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By default, the operator `+` invokes the left operand's method, `__add__`. We
    programmed it so that it allows both objects of type `int` and objects of type
    `RationalNumber`. In the statement `5+p`, the operands are commuted and the method
    `__add__` of the built-in type `int` is invoked. This method returns an error
    as it cannot know how to handle rational numbers. This case can be handled by
    the method `__radd__`, with which we now will equip the class `RationalNumber`.
    The method `__radd__` is called **reverse addition**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，运算符`+`会调用左侧操作数的方法`__add__`。我们编写了代码，使其支持`int`类型和`RationalNumber`类型的对象。在语句`5+p`中，操作数会被交换，调用内建类型`int`的`__add__`方法。由于该方法不知道如何处理有理数，因此会返回错误。这个问题可以通过`__radd__`方法解决，我们现在将其添加到`RationalNumber`类中。方法`__radd__`被称为**反向加法**。
- en: Reverse operations
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反向操作
- en: If operations such as `+` are applied to two operands of different types, the
    corresponding method (in this case, `__add__`) of the left operand is invoked
    first. If this raises an exception, the reverse method (here, `__radd__`) of the
    right operand is called. If this method does not exist, a `TypeError` exception
    is raised.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对两个不同类型的操作数应用如`+`这样的操作，首先调用左侧操作数的相应方法（在此情况下为`__add__`）。如果此方法引发异常，则调用右侧操作数的反向方法（这里是`__radd__`）。如果该方法不存在，则会引发`TypeError`异常。
- en: 'In order to enable the operation [![](img/c395f657-6c03-422c-ba41-23a1b55c9001.png)],
    where [![](img/a1f1efad-32cf-4fb3-a1c6-e031ee758cc3.png)] is an instance of `RationalNumber`,
    we define `__radd__` as:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现操作[![](img/c395f657-6c03-422c-ba41-23a1b55c9001.png)]，其中[![](img/a1f1efad-32cf-4fb3-a1c6-e031ee758cc3.png)]是`RationalNumber`的一个实例，我们将`__radd__`定义为：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that `__radd__` interchanges the order of the arguments; `self` is the
    object of type `RationalNumber` while `other` is the object that has to be converted.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`__radd__`会交换参数的顺序；`self`是`RationalNumber`类型的对象，而`other`是必须转换的对象。
- en: Methods mimicking function calls and iterables
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟函数调用和可迭代对象的方法
- en: Using a class instance together with parentheses or brackets*,* `()` or `[]`,
    invokes a call to one of the special methods `__call__` or `__getitem__`, giving
    the instance the behavior of a function or of an iterable; see also *Table 8.1*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类实例和括号或中括号`()`或`[]`，调用的是特殊方法`__call__`或`__getitem__`，使得该实例表现得像函数或可迭代对象；另见*表8.1*。
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Which now may be used as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以按如下方式使用：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The special method `__getitem__` makes sense if the class provides an iterator
    (it is recommended that you review [Section 9.2.1](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml):
    *Generators* before you consider the following example).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法`__getitem__`是有意义的，如果类提供了迭代器（建议你在考虑以下示例之前，回顾[第9.2.1节](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml)：*生成器*）。
- en: 'The recursion [![](img/deae62f4-7489-4c8f-9bd3-cf784904f150.png)] is called
    a **three*-*term recursion**. It plays an important role in applied mathematics,
    in particular in the construction of orthogonal polynomials. We can set up a three-term
    recursion as a class in the following way:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 递归[![](img/deae62f4-7489-4c8f-9bd3-cf784904f150.png)]被称为**三项递归**。它在应用数学中扮演着重要角色，尤其是在构造正交多项式时。我们可以通过以下方式将三项递归设置为一个类：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, the method `__iter__` defines a generator object, which allows us to
    use an instance of the class as an iterator:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，方法`__iter__`定义了一个生成器对象，使得我们可以将类的实例作为迭代器使用：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The method `__getitem__` enables us to directly access the iterations as if
    `r3` were a list:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`__getitem__`使我们能够像访问列表一样直接访问迭代结果，假设`r3`是一个列表：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that we used `itertools.islice` when coding `__getitem__` (see [Section
    9.3.2](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml): *Iterator tools* for more
    information).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在编写`__getitem__`时，我们使用了`itertools.islice`（有关更多信息，请参见[第9.3.2节](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml)：“迭代器工具”）。
- en: 8.2 Attributes that depend on each other
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 彼此依赖的属性
- en: Attributes of an instance can be changed (or created) by simply assigning them
    a value. However, if other attributes depend on the one just changed, it is desirable
    to change them simultaneously.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实例的属性可以通过简单地为其赋值来修改（或创建）。然而，如果其他属性依赖于刚刚改变的属性，最好同时修改它们。
- en: 'To demonstrate this, we consider an example: let''s define a class that defines
    an object for planar triangles from three given points. A first attempt to set
    up such a class could be as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，我们考虑一个例子：假设我们定义一个类，该类通过三个给定点来定义平面三角形对象。第一次尝试建立这样一个类可能是如下所示：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'An instance of this triangle is created by this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个三角形的实例通过以下方式创建：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then its area is computed by calling the corresponding method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过调用相应的方法计算其面积：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we change an attribute, say point *B*, the corresponding edges *a* and *c*
    are not automatically updated and the computed area is wrong:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改变一个属性，比如点*B*，对应的边*a*和*c*不会自动更新，计算出的面积也会出错：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A remedy is to define a method that is executed when an attribute is changed;
    such a method is called a **setter method**. Correspondingly, you might ask for
    a method that is executed when a value of an attribute is requested; such a method
    is called a **getter method**. We explain now how these two methods are defined.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方法是定义一个方法，该方法在属性改变时执行；这样的一个方法称为**设置器方法**。相应地，你可能需要一个在请求属性值时执行的方法；这样的一个方法称为**获取器方法**。我们现在将解释这两种方法是如何定义的。
- en: 8.2.1 The function property
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2.1 函数属性
- en: 'The special function `property` links an attribute to such a getter, setter,
    and deleter method. It might also be used to assign a documentation string to
    an attribute:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊函数`property`将属性与获取器、设置器和删除器方法关联。它也可以用来为属性分配文档字符串：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We continue with the previous example with a setter method and consider the
    class `Triangle` again. If the following statement is included in the definition
    of this class, the command `tr.B = <something>` invokes the setter method `set_B`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续之前的例子，使用设置器方法，再次考虑`Triangle`类。如果在该类的定义中包括以下语句，那么命令`tr.B = <某些值>`会调用设置器方法`set_B`：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s modify the `Triangle` class accordingly:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们相应地修改`Triangle`类：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the attribute `B` is changed, then the `set_B` method stores the new value
    in the internal attribute `_B` and changes all depending attributes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性`B`被改变，那么`set_B`方法会将新值存储到内部属性`_B`中，并改变所有依赖的属性：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The way the deleter method is used here is to prevent the deletion of attributes:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用删除器方法的方式是为了防止删除属性：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The use of an underscore as a prefix of attribute names is a convention used
    to indicate attributes that are not designed to be accessed directly. They are
    intended to hold data for attributes handled by setters and getters. These attributes
    are not private in the sense of other programming languages; they are just not
    intended to be accessed directly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下划线作为属性名的前缀是一种约定，用来表示这些属性不打算被直接访问。它们用于存储由设置器和获取器处理的属性的数据。这些属性并不像其他编程语言中的私有属性那样真正私密，它们只是没有直接访问的设计意图。
- en: 8.3 Bound and unbound methods
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.3 绑定与未绑定的方法
- en: 'We will now take a closer look at attributes that are methods. Let''s consider
    an example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更详细地查看作为方法的属性。我们来看一个例子：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A little inspection shows us how the nature of `func` changes after creating
    an instance:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微检查一下，我们可以发现创建实例后，`func`的性质发生了变化：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Calling, for example, `A.func(3)` would result in an error message such as
    this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，调用`A.func(3)`会导致类似这样的错误信息：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`instA.func(3)` is executed as expected. Upon creation of an instance, the
    method `func` is bound to the instance. The argument `self` gets the instance
    assigned as its value. Binding a method to an instance makes the method applicable
    as a function. Before that, it is of no use. Class methods, which we will consider
    in [Section 8.4.2](1654fae9-6203-4871-8352-e436445fa49a.xhtml): *Class methods*,
    are different in this aspect.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`instA.func(3)`按预期执行。在实例创建时，方法`func`绑定到该实例。参数`self`被分配为实例的值。将方法绑定到实例上，使得该方法可以作为函数使用。在此之前，它没有任何用途。类方法（我们将在[第8.4.2节](1654fae9-6203-4871-8352-e436445fa49a.xhtml)：“类方法”中讨论）在这一点上与之不同。'
- en: 8.4 Class attributes and class methods
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.4 类属性和类方法
- en: So far, we have seen attributes and methods that are bound to an instance of
    a class. In this section, we introduce class attributes and class methods. They
    allow access to methods and data before an instance is created.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了绑定到类实例上的属性和方法。在这一节中，我们介绍类属性和类方法。它们允许在实例创建之前访问方法和数据。
- en: 8.4.1 Class attributes
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4.1 类属性
- en: 'Attributes specified in the class declaration are called **class attributes**.
    Consider the following example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明中指定的属性称为**类属性**。考虑以下示例：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Class attributes are useful for simulating default values and can be used if
    values have to be reset:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性对于模拟默认值非常有用，如果需要重置值时可以使用：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Both instances have an attribute, `tol`, with the value initialized in the
    class definition:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 两个实例都有一个属性 `tol`，其值在类定义中初始化：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Altering the class attribute automatically affects all the corresponding attributes
    of all instances:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 修改类属性会自动影响所有实例的相应属性：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Altering `tol` for one instance does not affect the other instance:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 修改一个实例的 `tol` 不会影响另一个实例：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'But now, `N2.tol` is detached from the class attribute. Changing `Newton.tol`
    no longer has any effect on `N2.tol`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，`N2.tol` 已从类属性中分离出来。更改 `Newton.tol` 不再对 `N2.tol` 产生任何影响：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 8.4.2 Class methods
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4.2 类方法
- en: 'We saw in [Section 8.3](1654fae9-6203-4871-8352-e436445fa49a.xhtml): *Bound
    and unbound methods* how methods are either bound to an instance of a class or
    remain in a state as unbound methods. Class methods are different. They are always
    bound methods. They are bound to the class itself.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8.3节](1654fae9-6203-4871-8352-e436445fa49a.xhtml)中看到过：*绑定和未绑定的方法*，方法要么绑定到类的实例，要么保持未绑定的方法状态。类方法则不同，它们始终是绑定方法。它们绑定到类本身。
- en: We will first describe the syntactic details and then give some examples to
    show what these methods can be used for.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先描述语法细节，然后给出一些示例，展示这些方法的用途。
- en: 'To indicate that a method is a class method, the decorator line precedes the
    method definition:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表明一个方法是类方法，装饰器行应当出现在方法定义之前：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: While standard methods make a reference to an instance by the use of their first
    argument, the first argument of a class method refers to the class itself. By
    convention, the first argument is called `self` for standard methods and `cls`
    for class methods.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 标准方法通过其第一个参数引用实例，而类方法的第一个参数引用的是类本身。按照约定，标准方法的第一个参数称为 `self`，类方法的第一个参数称为 `cls`。
- en: 'The following is an example of the standard case:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是标准情况的示例：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is contrasted by an example of the `classmethod` case:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `classmethod` 的示例对比：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In practice, class methods may be useful for executing commands before an instance
    is created, for instance, in a preprocessing step. See the following example.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，类方法可能用于在创建实例之前执行命令，例如在预处理步骤中。请参阅以下示例。
- en: 'In this example, we show how class methods can be used to prepare data before
    creating an instance:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们展示了如何使用类方法在创建实例之前准备数据：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The class is designed so that a polynomial object is created by specifying its
    coefficients. Alternatively, the class method `by_points` allows us to define
    a polynomial by interpolation points.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的设计使得通过指定系数可以创建一个多项式对象。或者，类方法 `by_points` 允许我们通过插值点定义一个多项式。
- en: 'We can transform the interpolation data to the polynomial coefficients even
    when no instance of `Polynomial` is available:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有 `Polynomial` 的实例，我们也可以将插值数据转化为多项式系数：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Another example of a class method is presented in [Section 8.7](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Classes as decorators*. There, a class method is used to access information related
    to several (or all) instances from this class.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8.7节](1654fae9-6203-4871-8352-e436445fa49a.xhtml)中展示了类方法的另一个示例：*类作为装饰器*。在那里，类方法用于访问与该类的多个（或所有）实例相关的信息。'
- en: 8.5 Subclasses and inheritance
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.5 子类和继承
- en: 'In this section, we introduce some central concepts from object-oriented programming:
    **abstract classes**, **subclasses**, and **inheritance**. To guide you through
    these concepts, we consider another mathematical example: one-step methods for
    solving a differential equation.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们介绍一些面向对象编程中的核心概念：**抽象类**、**子类**和**继承**。为了帮助你理解这些概念，我们考虑了另一个数学示例：求解微分方程的单步方法。
- en: 'The generic form of an ordinary initial value problem is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 普通初值问题的通用形式如下：
- en: '![](img/984b6f95-b6c1-45b0-b4b9-a33b4a888ee6.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/984b6f95-b6c1-45b0-b4b9-a33b4a888ee6.png)'
- en: The data is the right-hand side function ![](img/ae32d475-3b7f-42fc-ba19-35f6c70f1e90.png),
    the initial value ![](img/110bf954-0df2-465d-a569-e653d9b7bfec.png), and the interval
    of interest ![](img/84ce4328-754a-4cae-a02c-6149358e7cf5.png).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包括右侧函数 ![](img/ae32d475-3b7f-42fc-ba19-35f6c70f1e90.png)，初始值 ![](img/110bf954-0df2-465d-a569-e653d9b7bfec.png)，以及感兴趣的区间
    ![](img/84ce4328-754a-4cae-a02c-6149358e7cf5.png)。
- en: The solution to this problem is a function [![](img/aee7a0ad-6c39-4d75-88a7-dff14759956f.png)].
    A numerical algorithm gives this solution as a vector ![](img/6564bfaf-0da4-44ae-ae55-6e5e89f4e9ca.png)
    of discrete values ![](img/c623b321-35c6-4b22-9667-2847e637a603.png) being approximations
    to [![](img/4cb2ef0c-bb63-4b63-a245-f971704ba437.png)]. Here, [![](img/d1198a41-c4a7-4bd9-af0c-827318e13aad.png)]
    and [![](img/72ef7f04-3a16-4a59-99c6-340ae218054f.png)] are discretized values
    of the independent variable ![](img/b47fccf1-7514-4e00-bfb2-adfc999d7379.png),
    which in physical models often represents time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题的解是一个函数[![](img/aee7a0ad-6c39-4d75-88a7-dff14759956f.png)]。一个数值算法将这个解表示为一个离散值的向量
    ![](img/6564bfaf-0da4-44ae-ae55-6e5e89f4e9ca.png)，这些离散值 ![](img/c623b321-35c6-4b22-9667-2847e637a603.png)
    是对[![](img/4cb2ef0c-bb63-4b63-a245-f971704ba437.png)]的近似值。在这里，[![](img/d1198a41-c4a7-4bd9-af0c-827318e13aad.png)]
    和 [![](img/72ef7f04-3a16-4a59-99c6-340ae218054f.png)] 是独立变量 ![](img/b47fccf1-7514-4e00-bfb2-adfc999d7379.png)
    的离散化值，在物理模型中，通常表示时间。
- en: 'A one-step method constructs the solution values ![](img/39df427c-bf50-4e98-9e2d-be6e53c2b29f.png)
    by the recursion steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一步法通过递归步骤构造解的值 ![](img/39df427c-bf50-4e98-9e2d-be6e53c2b29f.png)：
- en: '![](img/b8b77557-6e14-4250-951f-c876172b3cad.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8b77557-6e14-4250-951f-c876172b3cad.png)'
- en: 'Here, ![](img/c29823d2-ff3c-45aa-a1c1-b0ca44432554.png) is a step function
    that characterizes the individual methods, see also [[28]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![](img/c29823d2-ff3c-45aa-a1c1-b0ca44432554.png)是一个步进函数，用于描述各个方法，详情请参见[[28]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)：
- en: 'Explicit Euler: ![](img/991c703e-d8c4-4210-9328-b2f82309f864.png)_'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '显式欧拉法: ![](img/991c703e-d8c4-4210-9328-b2f82309f864.png)_'
- en: 'Midpoint rule: ![](img/c1d72a3a-495e-49e2-b4cd-5bc4162546a3.png)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中点法则：![](img/c1d72a3a-495e-49e2-b4cd-5bc4162546a3.png)
- en: 'Runge–Kutta 4: ![](img/ccd180d0-7786-4692-9697-1790a3f151a8.png)with ![](img/ae77b771-8d9e-4352-bbbf-38aa1f1c44a9.png)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 龙格-库塔4法：![](img/ccd180d0-7786-4692-9697-1790a3f151a8.png)与 ![](img/ae77b771-8d9e-4352-bbbf-38aa1f1c44a9.png)
- en: 'What we did here is the typical way of describing a mathematical algorithm.
    We first described a method by its idea, giving its steps in an abstract way.
    To actually use it, we have to fill in the parameters of a concrete method, in
    this example, the function [![](img/8e3a3508-cd7c-412c-ad83-961369b45912.png)].
    This is also the way things are explained in object-oriented programming. First,
    we set up a class with the abstract description of the method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的，是描述数学算法的典型方式。我们首先通过其思想描述了一种方法，以抽象的方式给出了步骤。要实际使用它，我们必须填写具体方法的参数，在这个例子中，就是函数[![](img/8e3a3508-cd7c-412c-ad83-961369b45912.png)]。这也是面向对象编程中常见的解释方式。首先，我们设定一个类，提供方法的抽象描述：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This abstract class, with its methods, is used as a template for the individual
    methods:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个抽象类及其方法被用作个别方法的模板：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that in the class definitions, the name of the abstract class that we
    used as a template, `OneStepMethod`, is given as an extra argument:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在类定义中，我们作为模板使用的抽象类名称`OneStepMethod`被作为一个额外的参数给出：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: That class is called the **parent class**. All methods and attributes of the
    parent class are inherited by the subclasses as long as they are not overridden.
    They are overridden if they are redefined in the subclass. The method `step` is
    redefined in the subclasses, while the method `generate` is generic for the entire
    family and therefore inherited from the parent.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类被称为**父类**。父类的所有方法和属性都可以被子类继承，前提是这些方法没有被重写。如果在子类中重新定义了这些方法，就会覆盖父类中的方法。方法`step`在子类中被重写，而方法`generate`则是整个家族通用的，因此从父类继承。
- en: 'Before considering further details, we will demonstrate how these three classes
    can be used:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑进一步的细节之前，我们将演示如何使用这三种类：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can avoid the repetition of common parameter lists by using the star operator
    (see [Section 7.2.5](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Variable number
    of arguments* for more details):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以通过使用星号操作符避免重复编写常见的参数列表（有关更多细节，请参见[第7.2.5节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml):
    *可变参数数量*)：'
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that the abstract class has never been used to create an instance. As the
    method `step` was not completely defined, calling it raises an exception of type
    `NotImplementedError`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，抽象类从未被用来创建实例。由于方法`step`没有完全定义，调用它会引发类型为`NotImplementedError`的异常。
- en: Sometimes you have to access the methods or attributes of a parent class. This
    is done using the command `super`. This is useful when the child class uses its
    own `__init__` method in order to extend the parent’s `__init__` method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要访问父类的方法或属性。这可以通过命令`super`来实现。当子类使用自己的`__init__`方法扩展父类的`__init__`方法时，这非常有用。
- en: 'For example, let''s assume that we want to give every solver class a string
    variable with the solver’s name. To this end, we provide the solver with an `__init__`
    method as it overrides the parent''s `__init__` method. In the case that both
    methods should be used, we have to refer to the parent’s method by the command
    `super`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想给每个求解器类提供一个包含求解器名称的字符串变量。为此，我们为求解器提供一个`__init__`方法，以覆盖父类的`__init__`方法。如果两者都需要使用，我们必须通过命令`super`来引用父类的方法：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note, you could have used the name of the parent class explicitly. The use of
    `super` instead allows us to change the name of the parent class without having
    to change all the references to the parent class.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你本可以明确地使用父类的名称。使用`super`则允许我们在不更改所有父类引用的情况下更改父类的名称。
- en: 8.6 Encapsulation
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.6 封装
- en: Sometimes the use of inheritance is impractical or even impossible. This motivates
    the use of encapsulation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有时使用继承是不实际的，甚至是不可能的。这促使我们使用封装。
- en: 'We will explain the concept of encapsulation by considering Python functions,
    that is, objects of the Python type `function`, which we encapsulate in a new
    class, `Function`, and provide with some relevant methods:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过考虑Python函数来解释封装的概念，即我们将Python类型`function`的对象封装到一个新的类`Function`中，并为其提供一些相关的方法：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that the operations `__add__` and `__mul__` should return an instance of
    the same class. This is achieved by the statement `return type(self)(sum)`, which
    in this case is a more general form of writing `return Function(sum)`. We can
    now derive subclasses by inheritance.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，操作`__add__`和`__mul__`应该返回相同类的实例。这是通过语句`return type(self)(sum)`来实现的，在这种情况下，这比写`return
    Function(sum)`更为通用。我们现在可以通过继承来派生子类。
- en: 'Consider as an example Chebyshev polynomials. They can be computed in the interval
    [![](img/542ff6cb-5696-4556-a905-85fbabbafda1.png)] by:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以切比雪夫多项式为例。它们可以在区间[![](img/542ff6cb-5696-4556-a905-85fbabbafda1.png)]内计算：
- en: '[![](img/5213e4fc-3a20-4de8-a6af-a7bad2fa8e97.png)]'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/5213e4fc-3a20-4de8-a6af-a7bad2fa8e97.png)]'
- en: 'We construct a Chebyshev polynomial as an instance of the class `Function`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将切比雪夫多项式构建为`Function`类的一个实例：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Chebyshev polynomials are orthogonal in the sense:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 切比雪夫多项式是正交的，意思是：
- en: '![](img/5828d012-2424-4a0c-9c78-6055184edd76.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5828d012-2424-4a0c-9c78-6055184edd76.png)'
- en: 'This can easily be checked using this construction:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过这种构造轻松检查：
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Without encapsulation, multiplying functions as simply as writing `weight *
    T5 * T6` would not have been possible.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有封装，像写`weight * T5 * T6`这样的乘法函数是不可能实现的。
- en: 8.7 Classes as decorators
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.7 类作为装饰器
- en: 'In [Section 7.8](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Function as
    decorators*, we saw how functions can be modified by applying another function
    as a decorator. In [Section 8.1.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Special methods*, we saw how classes can be made to behave as functions as long
    as they are provided with the method `__call__`. We will use this here to show
    how classes can be used as decorators.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7.8节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)：*函数作为装饰器*中，我们看到了如何通过将另一个函数作为装饰器来修改函数。在[第8.1.5节](1654fae9-6203-4871-8352-e436445fa49a.xhtml)：*特殊方法*中，我们看到只要类提供了`__call__`方法，类就可以像函数一样工作。我们将在这里使用这个方法来展示如何将类用作装饰器。
- en: 'Let''s assume that we want to change the behavior of some functions in such
    a way that before the function is invoked, all input parameters are printed. This
    could be useful for debugging purposes. We take this situation as an example to
    explain the use of a decorator class:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想改变某些函数的行为，使得在调用函数之前，所有的输入参数都被打印出来。这对于调试非常有用。我们以这个情况为例，来解释装饰器类的使用：
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We use this class to decorate function definitions:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个类来装饰函数定义：
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, call the function as usual:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像往常一样调用函数：
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'On the second call, we obtain the following output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次调用时，我们得到以下输出：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This example shows that both classes and functions can be used as decorators.
    Classes allow more possibilities, as they can be used to collect data as well.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，类和函数都可以用作装饰器。类提供了更多的可能性，因为它们还可以用来收集数据。
- en: 'Indeed, we observe that:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，我们观察到：
- en: Every decorated function creates a new instance of the decorator class.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个被装饰的函数都会创建一个新的装饰器类实例。
- en: 'Data collected by one instance can be saved and made accessible to another
    instance by class attributes; see [Section 8.4](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Class* *attributes and class methods*.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实例收集的数据可以通过类属性保存，并使另一个实例能够访问；请参见[章节8.4](1654fae9-6203-4871-8352-e436445fa49a.xhtml)：*类*
    *属性和类方法*。
- en: The last point emphasizes the difference between function decorators. We show
    this now with a decorator that counts function calls and stores the result in
    a dictionary with the function as the key.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一项强调了函数装饰器之间的区别。我们现在通过一个装饰器来展示，它能够计数函数调用次数，并将结果存储在一个以函数为键的字典中。
- en: 'In order to analyze the performance of algorithms, it might be useful to count
    the calls of particular functions. We can get counter information without changing
    the function definition:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析算法的性能，可能有用的是计算特定函数的调用次数。我们可以在不改变函数定义的情况下获取计数器信息：
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we use the class attribute `CountCalls.instances` to store the counters
    for each individual instance.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用类属性`CountCalls.instances`来存储每个实例的计数器。
- en: 'Let''s see how this decorator works:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个装饰器是如何工作的：
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 8.8 Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.8 总结
- en: One of the most important programming concepts in modern computer science is
    object-oriented programming. We learned in this chapter how to define objects
    as instances of classes, which we provide with methods and attributes. The first
    parameter of methods, usually denoted by `self`, plays an important and special
    role. You saw methods that can be used to define basic operations for your own
    classes such as `+` and `*`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机科学中最重要的编程概念之一是面向对象编程。在本章中，我们学习了如何将对象定义为类的实例，并为其提供方法和属性。方法的第一个参数，通常表示为`self`，在其中扮演着重要且特殊的角色。你会看到一些方法，它们可以用来为自定义类定义基本运算，比如`+`和`*`。
- en: While in other programming languages attributes and methods can be protected
    against unintended use, Python allows a technique to hide attributes and access
    these hidden attributes through special getter and setter methods. To this end,
    you met an important function, `property`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在其他编程语言中，属性和方法可以防止被意外使用，但 Python 允许一种技巧来隐藏属性，并通过特殊的 getter 和 setter 方法访问这些隐藏的属性。为此，你会遇到一个重要的函数`property`。
- en: 8.9 Exercises
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.9 练习
- en: Write a method simplify to the class `RationalNumber`. This method should return
    the simplified version of the fraction as a tuple.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`RationalNumber`类编写一个` simplify`方法。该方法应返回该分数的简化版本，形式为一个元组。
- en: 'To provide results with confidence intervals, a special calculus, so-called
    interval arithmetic, is introduced in numerical mathematics. Define a class called
    `Interval` and provide it with methods for addition, subtraction, division, multiplication,
    and power (with positive integers only). These operations obey the following rules:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提供带有置信区间的结果，数值数学中引入了一种特殊的计算方法，称为区间算术。定义一个名为`Interval`的类，并为其提供加法、减法、除法、乘法和幂运算（仅限正整数）的相关方法。这些运算遵循以下规则：
- en: '![](img/f6b0c186-7c26-4084-8b79-d623f4f52a86.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6b0c186-7c26-4084-8b79-d623f4f52a86.png)'
- en: 'Provide this class with methods that allow operations of the type `a + I, a
    I, I + a, I a`, where `I` is an interval and `a` is an integer or float. Convert
    an integer or float into an interval `[a,a]` first. (Hint: you may want to use
    function decorators for this; see [Section](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)
    7.8: *Function as decorators*.) Furthermore, implement the method `__contains__`,
    which enables you to check whether a given number belongs to the interval using
    the syntax `x in I` for an object `I` of type `Interval`. Test your class by applying
    a polynomial `f=lambda x: 25*x**2-4*x+1` to an interval.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '为这个类提供方法，使得可以进行`a + I, a I, I + a, I a`类型的运算，其中`I`是一个区间，`a`是整数或浮点数。首先，将整数或浮点数转换为区间`[a,a]`。（提示：你可能想使用函数装饰器来实现这一点；请参见[章节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)7.8：*函数作为装饰器*。）此外，实现`__contains__`方法，它使你能够使用`x
    in I`语法检查某个数字是否属于区间`I`，其中`I`是`Interval`类型的对象。通过将多项式`f=lambda x: 25*x**2-4*x+1`应用于一个区间来测试你的类。'
- en: 'Consider the example in [Section 8.7](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Classes as decorators*. Extend this example to obtain a *function decorator*
    that counts how often a certain function is called; see also [Section](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)
    7.8: *Functions as decorators.*'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑[第8.7节](1654fae9-6203-4871-8352-e436445fa49a.xhtml)中的示例：*类作为装饰器*。扩展这个示例，创建一个*函数装饰器*，用于统计某个函数被调用的次数；另见[第7.8节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)：*函数作为装饰器*。
- en: 'Compare the two ways to implement a method for reverse addition `__radd__`
    in the class `RationalNumber`: the one given in the example in [Section 8.1.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Special methods* and the one given here:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较两种在`RationalNumber`类中实现反向加法`__radd__`的方法：一种是[第8.1.5节](1654fae9-6203-4871-8352-e436445fa49a.xhtml)中的示例：*特殊方法*，另一种是此处给出的实现：
- en: '[PRE63]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Do you expect an error in this version? What is the error and how do you explain
    it? Test your answer by executing:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你预期这个版本会出错吗？错误是什么，你如何解释它？通过执行以下代码测试你的答案：
- en: '[PRE64]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Consider the decorator class `CountCalls` as in the example in [Section 8.7](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Classes as decorators*. Provide this class with a method, `reset`, that sets
    the counters of all functions in the dictionary `CountCalls.instances` to `0`.
    What would happen if the dictionary were replaced by an empty dictionary instead?'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑装饰器类`CountCalls`，如[第8.7节](1654fae9-6203-4871-8352-e436445fa49a.xhtml)中的示例：*类作为装饰器*。为这个类提供一个方法`reset`，该方法将字典`CountCalls.instances`中所有函数的计数器重置为`0`。如果将字典替换为空字典，会发生什么？
