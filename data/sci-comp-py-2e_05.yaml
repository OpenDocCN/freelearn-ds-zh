- en: Advanced Array Concepts
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 高级数组概念
- en: In this chapter, we will explain some more advanced aspects of arrays. First,
    we will cover the notion of an array view – a concept that a NumPy programmer
    absolutely must be aware of to avoid hard-to-debug programming errors. Then, Boolean
    arrays will be introduced along with the ways to compare arrays. Furthermore,
    we will briefly describe indexing and vectorization, explaining special topics
    such as broadcasting and sparse matrices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释一些数组的高级概念。首先，我们将介绍数组视图的概念——这是每个 NumPy 程序员必须了解的，以避免难以调试的编程错误。然后将介绍布尔数组及比较数组的方法。此外，我们还将简要描述索引和向量化，解释一些特殊话题，比如广播和稀疏矩阵。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: Array views and copies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组视图与副本
- en: Comparing arrays
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较数组
- en: Array indexing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组索引
- en: Performance and vectorization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能与向量化
- en: Broadcasting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广播
- en: Sparse matrices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稀疏矩阵
- en: 5.1 Array views and copies
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 数组视图与副本
- en: In order to control precisely how memory is used, NumPy offers the concept of
    a view of an array. Views are smaller arrays that share the same data as a larger
    array. This works just like a reference to one single object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了精确控制内存的使用，NumPy 提供了数组视图的概念。视图是共享同一数据的大数组的较小数组。这就像是一个对单一对象的引用。
- en: 5.1.1 Array views
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.1 数组视图
- en: 'The simplest example of a view is given by a slice of an array:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的视图示例是通过数组切片获得的：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding slice `v ` is a view of `M`. It shares the same data as `M`.
    Modifying `v` will modify `M` as well:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的切片 `v` 是 `M` 的视图。它与 `M` 共享相同的数据。修改 `v` 将同时修改 `M`：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is possible to access the object that owns the data using the array attribute `base`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过数组属性 `base` 访问拥有数据的对象：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If an array owns its data, the attribute base is `None`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数组拥有其数据，那么属性 base 的值为 `None`：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 5.1.2 Slices as views
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.2 切片作为视图
- en: 'There are precise rules on which slices will return views and which ones will
    return copies. Only basic slices (mainly index expressions with `:`) return views,
    whereas any advanced selections (such as slicing with a Boolean) will return a
    copy of the data. For instance, it is possible to create new matrices by indexing
    with lists (or arrays):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于哪些切片返回视图，哪些切片返回副本，有明确的规则。只有基本切片（主要是使用 `:` 的索引表达式）返回视图，而任何高级选择（如用布尔值切片）都会返回数据的副本。例如，可以通过索引列表（或数组）来创建新的矩阵：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, the array `b` is not a view, whereas the array `c`,
    obtained with a simpler slice, is a view.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，数组 `b` 不是视图，而通过更简单的切片获得的数组 `c` 是视图。
- en: 'There is an especially simple slice of an array that returns a view of the
    whole array:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特别简单的数组切片，它返回整个数组的视图：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 5.1.3 Generating views by transposing and reshaping
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.3 通过转置和重塑生成视图
- en: 'Some other important operations return views. For instance, transposing an
    array returns a view:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些重要操作也会返回视图。例如，转置一个数组返回的是一个视图：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The same applies to all  reshaping operations:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的规则适用于所有的重塑操作：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 5.1.4 Array copies
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.4 数组副本
- en: 'Sometimes it is necessary to explicitly request that the data be copied. This
    is simply achieved with the NumPy function called `array`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要显式地请求复制数据。这可以通过 NumPy 的 `array` 函数轻松实现：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can verify that the data has indeed been copied:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证数据确实已被复制：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this section, you saw the concept of array views. NumPy works with views
    instead of copies of a given array to save memory, which – especially for large
    arrays – can be crucial. On the other hand, unintentionally using views may cause
    programming errors that are hard to debug.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了数组视图的概念。NumPy 通过使用视图而不是数组副本来节省内存，尤其对于大型数组来说，这一点至关重要。另一方面，无意中使用视图可能会导致难以调试的编程错误。
- en: 5.2 Comparing arrays
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 比较数组
- en: 'Comparing two arrays is not as simple as it may seem. Consider the following
    code, which is intended to check whether two matrices are close to each other:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个数组并不像看起来那么简单。考虑以下代码，它旨在检查两个矩阵是否相近：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code raises the following exception when the `if` statement is executed:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在执行 `if` 语句时会引发以下异常：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this section, we'll explain why this is so and how to remedy this state of
    affairs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释为什么会这样，以及如何解决这种情况。
- en: 5.2.1 Boolean arrays
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2.1 布尔数组
- en: 'Boolean arrays are useful for advanced array indexing (also see [Section 5.3.1](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml):
    Indexing with Boolean arrays). A Boolean array is simply an array for which the
    entries have the type `bool`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数组对于高级数组索引非常有用（另见[第5.3.1节](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)：使用布尔数组索引）。布尔数组就是条目类型为`bool`的数组：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Any comparison operator acting on arrays will create a Boolean array instead
    of a simple Boolean:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 任何作用于数组的比较运算符都会生成一个布尔数组，而不是一个简单的布尔值：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that because array comparison creates Boolean arrays, one cannot use array
    comparison directly in conditional statements, for example, `if` statements. The
    solution is to use the methods `all` and `any` to create a simple `True` or `False`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于数组比较会创建布尔数组，因此不能直接在条件语句中使用数组比较，例如`if`语句。解决方法是使用`all`和`any`方法来创建一个简单的`True`或`False`：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, the use of one of the methods `all` and `any` results in a "scalar" Boolean,
    which now allows array comparisons in `if` statements.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用`all`和`any`方法之一将导致一个“标量”布尔值，这现在允许在`if`语句中进行数组比较。
- en: 5.2.2 Checking for array equality
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2.2 数组相等性检查
- en: 'Checking the equality of two float arrays is not straightforward, because two
    floats may be very close without being equal. In NumPy, it is possible to check
    for equality with `allclose`. This function checks for the equality of two arrays
    up to a given precision:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 检查两个浮动数组的相等性并不简单，因为两个浮点数可能非常接近，但不完全相等。在NumPy中，可以通过`allclose`来检查相等性。这个函数检查两个数组在给定精度范围内的相等性：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The tolerance is given in terms of a relative tolerance bound, `rtol`, and
    an absolute error bound, `atol`. The command `allclose` is a short form of:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 容差是通过相对容差界限`rtol`和绝对误差界限`atol`来给定的。命令`allclose`是以下内容的简写：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that `allclose` can be also applied to scalars:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`allclose`也可以应用于标量：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 5.2.3 Boolean operations on arrays
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2.3 数组上的布尔操作
- en: 'You cannot use `and`, `or`, and `not` on Boolean arrays. Indeed, those operators
    force the casting from array to Boolean, which is not permitted. Instead, we can
    use the operators given in Table 5.1 for component-wise logical operations on
    Boolean arrays:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不能在布尔数组上使用`and`、`or`和`not`。实际上，这些运算符会强制将数组转换为布尔值，这是不允许的。相反，我们可以使用表5.1中给出的运算符来对布尔数组执行逐元素的逻辑操作：
- en: '| **Logic operator** | **Replacement for Boolean arrays** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑运算符** | **布尔数组的替代方法** |'
- en: '| `A and B` | `A & B` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `A and B` | `A & B` |'
- en: '| `A or B` | `A &#124; B` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `A or B` | `A &#124; B` |'
- en: '| `not A` | `~ A` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `not A` | `~ A` |'
- en: 'Table 5.1: Logical operators for component-wise logical array operations'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1：按元素逻辑数组操作的逻辑运算符
- en: 'Here is an example usage of logical operators with Boolean arrays:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用布尔数组进行逻辑运算符的示例：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Suppose that we have a sequence of data that is marred with some measurement
    error. Suppose further that we run a regression and it gives us a deviation for
    each value. We wish to obtain all the exceptional values and all the values with
    a little deviation that are lower than a given threshold:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一系列数据，受到一些测量误差的影响。进一步假设我们进行回归分析，并且它给出了每个值的偏差。我们希望获得所有异常值和所有偏差小于给定阈值的值：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, we first created a data vector and then we perturbed it with
    some deviations sampled from normally distributed random numbers. We demonstrated
    two alternative ways of finding elements of data with large perturbations in absolute
    values, and finally, we collected only small data values for small perturbations.
    Here, we used a Boolean array instead of indexes when working with the array `data`.
    This technique will be explained in the next section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先创建了一个数据向量，然后用一些从正态分布随机数中抽样的偏差对其进行扰动。我们展示了两种替代方法，用于找到具有大扰动绝对值的数据元素，最后，我们收集了仅对小扰动的小数据值。在这里，我们在处理数组`data`时使用了布尔数组，而不是索引。这一技术将在下一节中进行解释。
- en: 5.3 Array indexing
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 数组索引
- en: We have already seen that we can index arrays with combinations of slices and
    integers – this is a basic slicing technique. There are, however, many more possibilities
    that allow for a variety of ways to access and modify array elements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以使用切片和整数的组合来索引数组——这是一种基本的切片技术。然而，还有许多其他可能性，可以通过多种方式访问和修改数组元素。
- en: 5.3.1 Indexing with Boolean arrays
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3.1 使用布尔数组索引
- en: 'It is often useful to access and modify only parts of an array, depending on
    its value. For instance, you might want to access all the positive elements of
    an array. This turns out to be possible using Boolean arrays, which act like masks
    to select only some elements of an array. The result of such indexing is *always* a
    vector. For instance, consider the following example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数组的值，通常有必要仅访问和修改数组的部分内容。例如，你可能想要访问数组中所有的正元素。实际上，这是通过布尔数组实现的，布尔数组像掩码一样，仅选择数组中的部分元素。这样的索引结果*总是*一个向量。例如，考虑以下示例：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In fact, the command `M[B]` is equivalent to `M[B].flatten()`. You can then
    replace the resulting vector with another vector. For instance, you can replace
    all the elements with zero:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，命令`M[B]`等同于`M[B].flatten()`。你可以用另一个向量替换结果向量。例如，你可以用零替换所有元素：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Or you can replace all the selected values with others:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以用其他值替换所有选中的值：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'By combining the creation of Boolean arrays (`M > 2`), smart indexing (indexing
    with a Boolean array), and broadcasting, you can use the following elegant syntax:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合布尔数组的创建（`M > 2`）、智能索引（使用布尔数组索引）和广播，你可以使用以下优雅的语法：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The expression broadcasting here refers to the tacit conversion of the scalar
    `0` to a vector of an appropriate shape (also see [Section 5.5](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml):
    *Broadcasting*).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的广播表达式是指标量`0`被巧妙地转换为适当形状的向量（另见[第5.5节](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)：*广播*）。
- en: 5.3.2 Using the command where
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3.2 使用`where`命令
- en: The command `where` gives a useful construct that can take a Boolean array as
    a condition and either return the indexes of the array elements satisfying the
    condition or return different values depending on the values in the Boolean array.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`where`提供了一个有用的构造，可以将布尔数组作为条件，返回满足条件的数组元素的索引，或者根据布尔数组中的值返回不同的值。
- en: 'The basic structure is:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基本结构是：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will return values from `a` when the condition is `True` and values from `b` when
    it is `False`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件为`True`时，这将返回来自`a`的值，而当条件为`False`时，返回来自`b`的值。
- en: 'For instance, consider a *Heaviside* function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个*海维赛德*函数：
- en: '![](img/460877e6-45a6-42bb-b9a6-c002278d76c7.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/460877e6-45a6-42bb-b9a6-c002278d76c7.png)'
- en: 'and its implementation with the command `where`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以及它与`where`命令的实现：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second and third arguments can be either arrays of the same size as the
    condition (the Boolean array) or scalars. We''ll give two more examples to demonstrate
    how to manipulate elements from an array or a scalar depending on a condition:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第三个参数可以是与条件（布尔数组）相同大小的数组，也可以是标量。我们将给出两个示例，以演示如何根据条件操作数组元素或标量：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the second and third arguments are omitted, then a tuple containing the indexes
    of the elements satisfying the condition is returned.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略第二个和第三个参数，则返回一个元组，其中包含满足条件的元素的索引。
- en: 'For example, consider the use of `where` with only one argument in the following
    code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑在以下代码中仅使用一个参数的`where`：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This example demonstrates how to find out indexes of those elements of a Boolean
    array that are `True`. The command `where` is a very handy tool to search in an
    array for elements fulfilling a given condition.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例演示了如何找出布尔数组中值为`True`的元素的索引。命令`where`是一个非常实用的工具，用于在数组中查找满足给定条件的元素。
- en: In this section, you saw various use cases of Boolean arrays. Whenever your
    code contains `for` loops operating on conditions and arrays, check if the concept
    of Boolean arrays could help to remove unnecessary `for` loops and increase at
    least the readability of your code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你看到了布尔数组的各种使用场景。每当你的代码中包含基于条件和数组操作的`for`循环时，检查是否可以使用布尔数组的概念来帮助去除不必要的`for`循环，并至少提高代码的可读性。
- en: 5.4 Performance and vectorization
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.4 性能与向量化
- en: When it comes to the performance of your Python code, it often boils down to
    the difference between interpreted code and compiled code. Python is an interpreted
    programming language and basic Python code is executed directly without any intermediate
    compilation to machine code. With a compiled language, the code needs to be translated to
    machine instructions before execution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到Python代码的性能时，它通常归结为解释型代码与编译型代码之间的差异。Python是一种解释型编程语言，基本的Python代码是直接执行的，不需要经过中间的机器代码编译。而在编译型语言中，代码在执行前需要被转换成机器指令。
- en: The benefits of an interpreted language are many but interpreted code cannot
    compete with compiled code for speed. To make your code faster, you can write
    some parts in a compiled language such as FORTRAN, C, or C++. This is what NumPy
    and SciPy do.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 解释型语言有许多优点，但解释型代码在速度上无法与编译型代码竞争。为了加速代码，可以将某些部分用 FORTRAN、C 或 C++ 等编译语言编写。这正是
    NumPy 和 SciPy 的做法。
- en: 'For this reason, it is best to use functions in NumPy and SciPy over interpreted
    versions whenever possible. NumPy array operations such as matrix multiplication,
    matrix-vector multiplication, matrix factorization, scalar products, and so on
    are much faster than any pure Python equivalent. Consider the simple case of scalar
    products. The scalar product is much slower than the compiled NumPy function `dot(a,b)` (more
    than 100 times slower for arrays with about 100 elements):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好在可能的情况下使用 NumPy 和 SciPy 中的函数，而不是使用解释型版本。NumPy 数组操作，如矩阵乘法、矩阵-向量乘法、矩阵分解、标量积等，比任何纯
    Python 等价物都要快得多。以标量积为例，标量积比编译后的 NumPy 函数`dot(a,b)`要慢得多（对于大约有 100 个元素的数组，它的速度慢超过
    100 倍）：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Measuring the speed of your functions is an important aspect of scientific
    computing. See [Section 15.3](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml): *Measuring
    execution time* for details on measuring execution times.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 测量函数的速度是科学计算中的一个重要方面。有关测量执行时间的详细信息，请参见[第 15.3 节](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml)：*测量执行时间*。
- en: 5.4.1 Vectorization
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4.1 向量化
- en: To improve performance, you have often to vectorize the code. Replacing `for` loops
    and other slower parts of the code with NumPy slicing, operations, and functions
    can give significant improvements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能，通常需要将代码向量化。用 NumPy 的切片、操作和函数替代`for`循环和其他较慢的代码部分，能够显著提升性能。
- en: 'For example, the simple addition of a scalar to a vector by iterating over
    the elements is very slow:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过遍历元素将标量加到向量上的简单操作非常慢：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But using NumPy''s addition is much faster:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用 NumPy 的加法运算要快得多：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Using NumPy slicing can also give significant speed improvements over iterating
    with `for` loops. To demonstrate this, let''s consider forming the average of
    neighbors in a two-dimensional array:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy 的切片操作也能显著提高性能，优于使用`for`循环进行迭代。为了演示这一点，假设我们需要在一个二维数组中计算邻居的平均值：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These functions both assign each element the average of its four neighbors.
    The second version, using slicing, is much faster.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都将每个元素的值设为其四个邻居的平均值。使用切片的第二个版本速度要快得多。
- en: 'Besides replacing `for` loops and other slower constructions with NumPy functions,
    there is a useful function called `vectorized` (see [Section 4.8](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml):
    *Functions acting on arrays*). This takes a function and creates a vectorized
    version that applies the function on all elements of an array using functions
    wherever possible.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用 NumPy 函数替换`for`循环和其他较慢的构造外，还有一个有用的函数叫做`vectorized`（参见[第 4.8 节](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)：*作用于数组的函数*）。它接收一个函数，并创建一个向量化版本，该版本使用函数对数组中的所有元素进行操作，尽可能使用函数。
- en: 'Consider the following function which we will use to demonstrate how to vectorize
    functions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数，我们将用它来演示如何将函数向量化：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Applying this function on elements of a vector ![](img/4586f943-368a-4d03-9422-88fe5ca55f9a.png) with
    100 elements in a non-vectorized way:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以非向量化的方式在一个包含 100 个元素的向量上应用此函数！[](img/4586f943-368a-4d03-9422-88fe5ca55f9a.png)：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'is nearly three times slower than using it in the vectorized way:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用向量化方式时，它的速度几乎是传统方式的三倍：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this section, we showed several examples of the vectorization of computations
    with NumPy arrays. An active use of this concept is recommended not only for speeding
    up the execution of your code but also for improving the readability of your code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了几个使用 NumPy 数组进行计算向量化的例子。强烈推荐积极使用这一概念，这不仅能加速代码的执行，还能提高代码的可读性。
- en: 5.5 Broadcasting
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.5 广播
- en: Broadcasting in NumPy denotes the ability to guess a common, compatible shape
    between two arrays. For instance, when adding a vector (one-dimensional array)
    and a scalar (zero-dimensional array), the scalar is extended to a vector, in
    order to allow for the addition. The general mechanism is called broadcasting.
    We will first review that mechanism from a mathematical point of view, and then
    proceed to give the precise rules for broadcasting in NumPy. The mathematical
    view might give a mathematically trained reader easier access to broadcasting,
    while other readers might want to skip the mathematical details and directly continue
    reading [Section 5.5.2](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Broadcasting
    arrays*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 中，广播指的是能够推测两个数组之间的共同兼容形状。例如，当向量（单维数组）和标量（零维数组）相加时，标量会被扩展为一个向量，以便进行加法操作。这个一般机制叫做广播。我们首先从数学角度回顾这一机制，然后给出
    NumPy 中广播的精确规则。数学视角可能让受过数学训练的读者更容易理解广播，而其他读者可能想跳过数学细节，直接继续阅读 [第5.5.2节](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)：
    *广播数组*。
- en: 5.5.1 Mathematical views
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5.1 数学视角
- en: Broadcasting is often performed in mathematics, mainly implicitly. Examples
    are expressions such as ![](img/69891ec8-0b8d-4396-9e75-2192d35dd16f.png) or ![](img/92db4562-4d42-4820-a1e6-0d22d11a35e1.png).
    We will give an explicit description of that technique in this section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 广播在数学中经常进行，通常是隐式的。例如，表达式如 ![](img/69891ec8-0b8d-4396-9e75-2192d35dd16f.png)
    或 ![](img/92db4562-4d42-4820-a1e6-0d22d11a35e1.png) 就是广播的应用。我们将在这一节中详细描述该技术。
- en: 'We have in mind the very close relationship between functions and NumPy arrays,
    as described in [Section 4.2.1](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *Arrays
    as functions*.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们牢记函数与 NumPy 数组之间的密切关系，如 [第4.2.1节](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)所描述：
    *数组作为函数*。
- en: Constant functions
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常数函数
- en: 'One of the most common examples of broadcasting is the addition of a function
    and a constant; if ![](img/66a23cd3-5e96-4255-9e41-2491f350b5da.png) is a scalar,
    we often write:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 广播的一个最常见的例子是函数与常数相加；如果 ![](img/66a23cd3-5e96-4255-9e41-2491f350b5da.png) 是一个标量，我们通常写作：
- en: '![](img/ef17988a-4b0c-4195-8d65-d04ad4f6c07d.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef17988a-4b0c-4195-8d65-d04ad4f6c07d.png)'
- en: 'This is an abuse of notation since you should not be able to add functions
    and constants. Constants are, however, implicitly broadcast to functions. The
    broadcast version of the constant ![](img/371dcbce-b9e2-4331-8072-7038d84c16ef.png)
    is the function ![](img/6c1b9471-8cc7-4600-bff9-b0720043b17e.png) defined by:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种符号滥用，因为你不应该能将函数和常数相加。然而，常数会隐式地广播到函数。常数 ![](img/371dcbce-b9e2-4331-8072-7038d84c16ef.png)
    的广播版本是函数 ![](img/6c1b9471-8cc7-4600-bff9-b0720043b17e.png)，由以下公式定义：
- en: '![](img/f15a1f56-1c7a-429c-a38b-e1481f7436e1.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f15a1f56-1c7a-429c-a38b-e1481f7436e1.png)'
- en: 'Now it makes sense to add two functions together:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将两个函数相加是有意义的：
- en: '![](img/dfba5757-8042-4e11-ad24-6e7b231cc428.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfba5757-8042-4e11-ad24-6e7b231cc428.png)'
- en: 'We are not being pedantic for the sake of it, but because a similar situation
    may arise for arrays, as in the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不是为了矫揉造作，而是因为数组也可能出现类似的情况，如下方的代码所示：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, everything happens as if the scalar `1.` had been converted
    to an array of the same length as `vector`, that is, `array([1.,1.,1.,1.])`, and
    then added to `vector`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一切的发生就像标量 `1.` 被转换成与 `vector` 相同长度的数组，即 `array([1.,1.,1.,1.])`，然后再与 `vector`
    相加。
- en: This example is exceedingly simple, so we'll proceed to show less obvious situations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子极为简单，因此我们将展示一些不那么明显的情况。
- en: Functions of several variables
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多变量函数
- en: 'A more intricate example of broadcasting arises when building functions of
    several variables. Suppose, for instance, that we were given two functions of
    one variable, ![](img/ac094d60-643a-4288-aaa0-a59873bf1149.png) and *![](img/fb48d608-1c7e-47ed-92f8-b8348723c3a9.png)*,
    and that we want to construct a new function, *![](img/568707f0-40b8-4f1a-9483-66297d555257.png)*,
    according to the formula:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建多个变量的函数时，会出现一个更为复杂的广播示例。例如，假设我们有两个单变量函数，![](img/ac094d60-643a-4288-aaa0-a59873bf1149.png)
    和 *![](img/fb48d608-1c7e-47ed-92f8-b8348723c3a9.png)*，我们希望根据以下公式构造一个新的函数， *![](img/568707f0-40b8-4f1a-9483-66297d555257.png)*：
- en: '![](img/9ee8e56a-18e9-423a-b540-587e6a6997a9.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ee8e56a-18e9-423a-b540-587e6a6997a9.png)'
- en: This is clearly a valid mathematical definition. We would like to express this
    definition as the sum of two functions in two variables defined as
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个有效的数学定义。我们希望将这个定义表示为两个变量的函数之和，定义为：
- en: '![](img/a348796b-1a2e-4cfe-9fe5-b78373d683e4.png),'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/a348796b-1a2e-4cfe-9fe5-b78373d683e4.png)。'
- en: 'and now we may simply write:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以简单地写成：
- en: '![](img/fdb81504-466e-467b-abc2-3c8b78df504c.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdb81504-466e-467b-abc2-3c8b78df504c.png)'
- en: 'The situation is similar to that arising when adding a column matrix and a
    row matrix:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况类似于添加列矩阵和行矩阵时的情况：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is especially useful when sampling functions of two variables, as shown
    in [Section 5.5.3](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Typical examples*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这在采样两个变量的函数时尤其有用，正如[5.5.3节](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)所示：*典型示例*。
- en: General mechanism
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用机制
- en: 'We have seen how to add a function and a scalar and how to build a function
    of two variables from two functions of one variable. Let''s now focus on the general
    mechanism that makes this possible. The general mechanism consists of two steps:
    *reshaping* and *extending*.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何将函数与标量相加，以及如何从两个单变量函数构建一个双变量函数。现在，让我们聚焦于使这一切成为可能的通用机制。这个通用机制包括两个步骤：*重塑*和*扩展*。
- en: 'First, the function ![](img/b3f744ae-3eb2-4a0d-ad22-e109b90e4b30.png) is *reshaped* to
    the function ![](img/744ec18e-d9c8-48ae-90bc-52778afdef85.png), which takes two
    arguments. One of these arguments is a dummy argument, which we take to be zero,
    as a convention:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，函数![](img/b3f744ae-3eb2-4a0d-ad22-e109b90e4b30.png)被*重塑*为函数![](img/744ec18e-d9c8-48ae-90bc-52778afdef85.png)，它接受两个参数。其中一个参数是虚拟参数，我们约定将其视为零：
- en: '![](img/ba7c8aec-ae56-4b15-877a-7936cbb1b6f6.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba7c8aec-ae56-4b15-877a-7936cbb1b6f6.png)'
- en: 'Mathematically, the domain of the definition of ![](img/c1a4c9a1-5a05-4bb5-936f-fd31524e29dc.png)
    is now ![](img/ec7c650c-102d-4c3a-820b-99effb8c4af3.png) Then the function ![](img/d442142f-b300-4b26-9f85-a94741d9e562.png)
    is *reshaped* in a way similar to:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度看，![](img/c1a4c9a1-5a05-4bb5-936f-fd31524e29dc.png)的定义域现在是![](img/ec7c650c-102d-4c3a-820b-99effb8c4af3.png)。然后，函数![](img/d442142f-b300-4b26-9f85-a94741d9e562.png)以类似于下述方式*重塑*：
- en: '![](img/af5cef49-26d4-4daf-b64c-119ed180760a.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af5cef49-26d4-4daf-b64c-119ed180760a.png)'
- en: Now both ![](img/e3bf73d2-a1a3-44fb-af5e-c0779496df1f.png)and ![](img/13afea47-b115-429d-b132-28d5905a513f.png)
    take two arguments, although one of them is always zero. We proceed to the next
    step, *extending*. It is the same step that converted a constant into a constant
    function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，![](img/e3bf73d2-a1a3-44fb-af5e-c0779496df1f.png)和![](img/13afea47-b115-429d-b132-28d5905a513f.png)都接受两个参数，尽管其中一个始终是零。接下来我们进行*扩展*步骤。这与将常数转化为常数函数的步骤相同。
- en: 'The function ![](img/5d7e6e3f-a7df-408b-9161-38c50b311745.png) is *extended*
    to:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 函数![](img/5d7e6e3f-a7df-408b-9161-38c50b311745.png)被*扩展*为：
- en: '![](img/4bf12815-d1ac-4df8-8ec5-b93901699031.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bf12815-d1ac-4df8-8ec5-b93901699031.png)'
- en: 'The function ![](img/0b274b2e-637a-4aaa-b3ce-7e34acb94f31.png) is extended
    to:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 函数![](img/0b274b2e-637a-4aaa-b3ce-7e34acb94f31.png)被扩展为：
- en: '![](img/de132c36-12e2-42e2-9f1d-8cc0137eb711.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de132c36-12e2-42e2-9f1d-8cc0137eb711.png)'
- en: 'Now the function of two variables, ![](img/a8620c7e-d435-4557-85d9-be15cbafb7d3.png),
    which was sloppily defined by ![](img/eed2403f-0afd-4741-bfc4-11fd7ab13a03.png),
    may be defined without reference to its arguments:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个变量的函数，![](img/a8620c7e-d435-4557-85d9-be15cbafb7d3.png)，它由![](img/eed2403f-0afd-4741-bfc4-11fd7ab13a03.png)粗略定义，可以在不参考其参数的情况下定义：
- en: '![](img/8de1d5f3-13e4-4d33-afff-95477ad21e9d.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8de1d5f3-13e4-4d33-afff-95477ad21e9d.png)'
- en: 'For example, let''s describe the preceding mechanism for constants. A constant
    is a scalar, that is, a function of zero arguments. The *reshaping step* is thus
    to define the function of one (empty) variable:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们描述之前的机制在常数情况下的表现。常数是标量，也就是零参数的函数。因此，*重塑步骤*是定义一个（一空）变量的函数：
- en: '![](img/15e63522-e49d-4dd7-8114-35a33fab1d8c.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15e63522-e49d-4dd7-8114-35a33fab1d8c.png)'
- en: 'Now the *extension step* proceeds simply with:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，*扩展步骤*简单地进行如下：
- en: '![](img/2e4751c9-6b14-4d2e-a08b-95f9cb52e64e.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e4751c9-6b14-4d2e-a08b-95f9cb52e64e.png)'
- en: Conventions
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 约定
- en: The last ingredient is the convention for how to add the extra arguments to
    a function, that is, how the reshaping is automatically performed. By convention,
    a function is automatically reshaped by adding zeros on the left.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要素是关于如何将额外参数添加到函数中的约定，也就是如何自动执行重塑。根据约定，函数会通过在左边添加零来自动重塑。
- en: 'For example, if a function ![](img/dbd64242-e716-4805-b924-487009f23a49.png)
    of two arguments has to be reshaped to three arguments, the new function will
    be defined by:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个有两个参数的函数![](img/dbd64242-e716-4805-b924-487009f23a49.png)需要重塑为三个参数，则新函数将由以下方式定义：
- en: '![](img/35e31143-4398-41a3-be36-f193b706925d.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35e31143-4398-41a3-be36-f193b706925d.png)'
- en: After having seen a more mathematical motivation for broadcasting, we now show
    how this applies to NumPy arrays.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在看过广播的更数学化动机之后，我们现在展示它如何应用于NumPy数组。
- en: 5.5.2 Broadcasting arrays
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5.2 广播数组
- en: We'll now repeat the observation that arrays are merely functions of several
    variables (see [Section](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml) 4.2: *Mathematical
    preliminaries*). Array broadcasting thus follows exactly the same procedure as
    explained above for mathematical functions. Broadcasting is done automatically
    in NumPy.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将重复观察，数组只是几个变量的函数（见[第4.2节](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)：*数学基础*）。因此，数组广播完全遵循上述为数学函数所解释的相同程序。广播在NumPy中是自动完成的。
- en: 'In Figure 5.1, we show what happens when adding a matrix of shape (4, 3) to
    a matrix of size (1, 3). The resulting matrix is of the shape (4, 3):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在图5.1中，我们展示了将形状为(4, 3)的矩阵加到形状为(1, 3)的矩阵时发生了什么。结果矩阵的形状是(4, 3)：
- en: '![](img/c2e7cf3e-17d3-4938-a31f-0456a76e19ec.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2e7cf3e-17d3-4938-a31f-0456a76e19ec.png)'
- en: 'Figure 5.1: Broadcasting between a matrix and a vector'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：矩阵与向量之间的广播
- en: The broadcasting problem
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广播问题
- en: When NumPy is given two arrays with different shapes and is asked to perform
    an operation thatwould require the two shapes to be the same, both arrays are
    broadcast to a common shape.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当NumPy给定两个形状不同的数组，并要求执行需要这两个形状相同的操作时，两个数组会广播到一个共同的形状。
- en: 'Suppose the two arrays have shapes ![](img/f5574319-181a-4f32-aba0-71d06d7ba0de.png) and ![](img/5b47ea61-2df0-4ea2-a664-f16987b19b1a.png).
    Broadcasting consists of the two steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设两个数组的形状分别为！[](img/f5574319-181a-4f32-aba0-71d06d7ba0de.png)和！[](img/5b47ea61-2df0-4ea2-a664-f16987b19b1a.png)。广播由以下两步组成：
- en: If the shape ![](img/c3046fe0-1e71-44e6-9b37-66789ee79b95.png) is shorter than
    the shape ![](img/30589aa2-56ff-41ea-a6a0-670c80e814e1.png), that is, `len(s1)
    < len(s2)`, then ones are added on the left of the shape ![](img/00af5683-394d-4b11-b526-a0d661fd1445.png).
    This is reshaping.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果形状！[](img/c3046fe0-1e71-44e6-9b37-66789ee79b95.png)比形状！[](img/30589aa2-56ff-41ea-a6a0-670c80e814e1.png)短，即`len(s1)
    < len(s2)`，那么在形状！[](img/00af5683-394d-4b11-b526-a0d661fd1445.png)的左侧会添加1。这就是重塑。
- en: When the shapes have the same length, the first array is extended to match the
    shape *s[2]* (if possible).
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当形状长度相同时，第一个数组会扩展以匹配形状*s[2]*（如果可能的话）。
- en: Suppose we want to add a vector of shape ![](img/c3a599e3-145d-4a1b-9155-a668ffca988f.png)
    to a matrix of shape ![](img/cd2275cc-e7d9-4129-b18d-4fba55afaea3.png). The vector
    needs to be broadcast. The first operation is reshaping; the shape of the vector
    is converted from (3, ) to (1, 3). The second operation is an extension; the shape
    is converted from (1, 3) to (4, 3).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想将一个形状为！[](img/c3a599e3-145d-4a1b-9155-a668ffca988f.png)的向量加到一个形状为！[](img/cd2275cc-e7d9-4129-b18d-4fba55afaea3.png)的矩阵中。该向量需要广播。第一个操作是重塑；将向量的形状从(3,)转换为(1,
    3)。第二个操作是扩展；将形状从(1, 3)转换为(4, 3)。
- en: 'For instance, suppose a vector ![](img/25dcaa7c-1ab6-48ef-8f60-2d002c90f591.png)
    of size *n* is to be broadcast to the shape (*m, n*):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个大小为*n*的向量！[](img/25dcaa7c-1ab6-48ef-8f60-2d002c90f591.png)需要广播到形状(*m,
    n*)：
- en: '![](img/d012613e-decb-42fa-aba9-5d3fe7dc155b.png) is automatically reshaped
    to (1, *n*).'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![](img/d012613e-decb-42fa-aba9-5d3fe7dc155b.png)会自动重塑为(1, *n*)。'
- en: '![](img/077eabe8-be98-4d56-b46c-6424aa64c9e1.png) is extended to (*m*, *n*).'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![](img/077eabe8-be98-4d56-b46c-6424aa64c9e1.png)被扩展到(*m*, *n*)。'
- en: 'To demonstrate this, we consider a matrix defined by:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们考虑由以下定义的矩阵：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'and a vector given by:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 和一个向量给定：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we may add `M` and `v` directly:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以直接将`M`和`v`相加：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The result is this matrix:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是这个矩阵：
- en: '![](img/9f0e0965-3ef7-48ff-9dbf-25c7ab17f013.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f0e0965-3ef7-48ff-9dbf-25c7ab17f013.png)'
- en: Shape mismatch
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 形状不匹配
- en: It is not possible to automatically broadcast a vector `v` of length `n` to
    the shape `(n,m)`. This is illustrated in *Figure 5.2*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 不能自动将长度为`n`的向量`v`广播到形状`(n, m)`。这一点在*图5.2*中有所说明。
- en: '![](img/6c77c88d-e3f2-4a51-a36b-d8ce883f6059.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c77c88d-e3f2-4a51-a36b-d8ce883f6059.png)'
- en: 'Figure 5.2: Failure of broadcasting due to shape mismatch'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：由于形状不匹配导致广播失败
- en: 'The broadcasting fails, because the shape `(n,)` may not be automatically broadcast
    to the shape `(m, n)`. The solution is to manually reshape `v` to the shape `(n,1)`.
    The broadcasting will now work as usual (by extension only):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 广播失败，因为形状`(n,)`可能无法自动广播到形状`(m, n)`。解决方案是手动将`v`重塑为形状`(n, 1)`。广播现在会像往常一样工作（仅通过扩展）：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is illustrated by the following example.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过以下示例来说明。
- en: 'Define a matrix with:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个矩阵：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'and a vector with:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 和一个向量：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now automatic broadcasting will fail because automatic reshaping does not work:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在自动广播将失败，因为自动重塑不起作用：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The solution is thus to take care of the reshaping manually. What we want in
    that case is to add 1 on the right, that is, transform the vector into a column
    matrix. The broadcasting then works directly:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解决方案是手动处理重塑。我们想要在这种情况下右侧加1，即将向量转换为列矩阵。然后，广播将直接起作用：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '(For the shape parameter `-1`, see [Section 4.6.3](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml):
    *Reshape.*) The result is this matrix:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: （关于形状参数`-1`，请参见[第4.6.3节](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)：*重塑*。）结果是这个矩阵：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 5.5.3 Typical examples
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5.3 典型示例
- en: Let's examine some typical examples where broadcasting may come in handy.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些典型示例，在这些示例中，广播可能会派上用场。
- en: Rescale rows
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重标定行
- en: 'Suppose `M` is an *![](img/8c502202-49f7-4a8e-a850-142921b05540.png)* matrix
    and we want to multiply each row by a coefficient. The coefficients are stored
    in a vector `coeff` with *n* components. In that case, automatic reshaping will
    not work, and we have to execute:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`M`是一个*![](img/8c502202-49f7-4a8e-a850-142921b05540.png)*矩阵，我们希望将每行乘以一个系数。系数存储在长度为*n*的向量`coeff`中。在这种情况下，自动重塑将不起作用，我们必须执行：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Rescale columns
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重标定列
- en: 'The setup is the same here, but we would like to rescale each column with a
    coefficient stored in a vector `coeff` of length *m*. In this case, automatic
    reshaping will work:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的设置相同，但我们希望使用存储在长度为*m*的向量`coeff`中的系数来重新标定每一列。在这种情况下，自动重塑将起作用：
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Obviously, we may also do the reshaping manually and achieve the same result
    with:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们也可以手动进行重塑，并通过以下方式达到相同的结果：
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Functions of two variables
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两个变量的函数
- en: 'Suppose ![](img/1c262619-1c75-4291-970a-1daad2e23f1b.png) and ![](img/d304100a-0ec4-4653-8315-abc1a427de3a.png)
    are vectors and we want to form the matrix ![](img/52654bb6-2f26-451d-8b06-9d16eb84a766.png)
    with elements ![](img/e082400a-96c1-4e39-9567-2b20d7548b88.png). This would correspond
    to the function ![](img/44feaca2-8d65-40cf-86ee-4f32300f2b0b.png). The matrix ![](img/6d1d25c9-5da6-4eb1-95e0-2f78f4318103.png)
    is merely defined by:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 假设！[](img/1c262619-1c75-4291-970a-1daad2e23f1b.png)和！[](img/d304100a-0ec4-4653-8315-abc1a427de3a.png)是向量，我们希望形成矩阵！[](img/52654bb6-2f26-451d-8b06-9d16eb84a766.png)，其中的元素是！[](img/e082400a-96c1-4e39-9567-2b20d7548b88.png)。这对应于函数！[](img/44feaca2-8d65-40cf-86ee-4f32300f2b0b.png)。矩阵！[](img/6d1d25c9-5da6-4eb1-95e0-2f78f4318103.png)仅由以下方式定义：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If the vectors *![](img/7c329343-7ce8-40d9-b58e-ee57831cc5b8.png)* and ![](img/a8a0819d-b28c-415e-aa33-3a8748d54267.png)
    are ![](img/5abfef87-142c-4971-801d-95e0dfa50d20.png) and ![](img/e875b9e9-c719-4c4c-beb9-7a506626e90d.png) respectively,
    the result is:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向量*![](img/7c329343-7ce8-40d9-b58e-ee57831cc5b8.png)*和！[](img/a8a0819d-b28c-415e-aa33-3a8748d54267.png)分别是！[](img/5abfef87-142c-4971-801d-95e0dfa50d20.png)和！[](img/e875b9e9-c719-4c4c-beb9-7a506626e90d.png)，那么结果是：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'More generally, suppose that we want to sample the function ![](img/514d009e-f785-4285-8728-cf6a0e8ae6d9.png).
    Supposing that the vectors ![](img/ca628e79-cf1c-413b-94b4-d13cdef8c319.png) and ![](img/6146f5d4-8840-4353-8999-f0bc24d15203.png)
    are defined, the matrix ![](img/0c41556d-bccb-4901-9eac-0370087b4249.png) of sampled
    values is obtained with:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，假设我们希望采样函数！[](img/514d009e-f785-4285-8728-cf6a0e8ae6d9.png)。假设向量！[](img/ca628e79-cf1c-413b-94b4-d13cdef8c319.png)和！[](img/6146f5d4-8840-4353-8999-f0bc24d15203.png)已经定义，采样值的矩阵！[](img/0c41556d-bccb-4901-9eac-0370087b4249.png)可以通过以下方式获得：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note that this is very frequently used in combination with `ogrid`. The vectors
    obtained from `ogrid` are already conveniently shaped for broadcasting. This allows
    for the following elegant sampling of the function ![](img/e25a91bf-92cb-4797-8317-39708a208778.png):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这通常与`ogrid`结合使用。从`ogrid`获得的向量已经便于广播。这允许以下优雅的函数采样！[](img/e25a91bf-92cb-4797-8317-39708a208778.png)：
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The syntax of `ogrid` needs some explanation: First, `ogrid` is not a function.
    It is an instance of a class with a `__getitem__` method (see [Section 8.1.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Special methods*). That is why it is used with brackets instead of parentheses.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`ogrid`的语法需要一些解释：首先，`ogrid`不是一个函数。它是一个类的实例，具有`__getitem__`方法（参见[第8.1.5节](1654fae9-6203-4871-8352-e436445fa49a.xhtml)：*特殊方法*）。因此，它是用方括号而不是圆括号来使用的。'
- en: 'The two commands are equivalent:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令是等效的：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The stride parameter in the preceding example is a complex number. This is
    to indicate that it is the number of steps instead of the step size. The rules
    for the stride parameter might be confusing at first glance:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的步长参数是一个复数。这表明它是步数而不是步长。步长参数的规则乍一看可能令人困惑：
- en: If the stride is a real number, then it defines the size of the steps between
    start and stop and stop is not included in the list.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果步长是实数，则它定义了起始和结束之间的步伐大小，并且结束值不包括在列表中。
- en: If the stride is a complex number `s`, then the integer part of `s.imag` defines
    the number of steps between start and stop and stop is included in the list.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果步幅是一个复数`s`，那么`s.imag`的整数部分定义了从开始到结束的步数，并且结束值包括在列表中。
- en: 'The output of `ogrid` is a tuple with two arrays, which can be used for broadcasting:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`ogrid`的输出是一个包含两个数组的元组，可以用于广播：'
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This gives:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出的是：
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'which is equivalent to:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于：
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 5.6\. Sparse matrices
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.6 稀疏矩阵
- en: Matrices with a small number of nonzero entries are called *sparse matrices*.
    Sparse matrices occur, for example, in scientific computing when describing discrete
    differential operators in the context of numerically solving partial differential
    equations.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 非零元素较少的矩阵称为*sparse matrices*（稀疏矩阵）。稀疏矩阵通常出现在科学计算中，例如在数值求解偏微分方程时，用于描述离散的微分算子。
- en: Sparse matrices often have large dimensions, sometimes so large that the entire
    matrix (with zero entries) would not even fit in the available memory. This is
    one motivation for a special datatype for sparse matrices. Another motivation
    is better performance of operations where zero matrix entries can be avoided.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵通常具有较大的维度，有时大到整个矩阵（包含零元素）甚至无法放入可用内存。这是为稀疏矩阵设计特殊数据类型的一个动机。另一个动机是能够避免零矩阵元素，从而提高操作的性能。
- en: There are only a very limited number of algorithms for general, unstructured
    sparse matrices in linear algebra. Most of them are iterative in nature and based
    on efficient implementations of matrix-vector multiplication for sparse matrices.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一般的非结构化稀疏矩阵，在线性代数中只有极少数的算法可用。大多数算法是迭代型的，基于稀疏矩阵的矩阵-向量乘法的高效实现。
- en: Examples of sparse matrices are diagonal or banded matrices. The simple pattern
    of these matrices allows straightforward storing strategies; the principal diagonal
    and the sub- and super-diagonals are stored in 1D arrays. Conversion from a sparse
    representation to the classical array type and vice versa can be done with the
    NumPy command `diag`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵的例子包括对角矩阵或带状矩阵。这些矩阵的简单模式使得存储策略变得直接；主对角线以及上下对角线存储在一维数组中。从稀疏表示转换为经典数组类型以及反向转换，可以通过NumPy命令`diag`完成。
- en: In general, there is not such a simple structure and the description of sparse
    matrices requires special techniques and standards.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，稀疏矩阵并没有如此简单的结构，因此描述稀疏矩阵需要特殊的技术和标准。
- en: An example of such a matrix is shown in Figure 5.3\. There, the pixels denote
    nonzero entries in the 1250 × 1250 matrix.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这种矩阵的例子如图5.3所示。在该图中，像素表示在1250 × 1250矩阵中的非零元素。
- en: In this section, we present a row and a column-oriented type for sparse matrices,
    both available through the module `scipy.sparse`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了两种稀疏矩阵的行和列导向类型，这两者都可以通过模块`scipy.sparse`使用。
- en: '![](img/f80bc23d-f23a-4f62-bd62-7fa64296e1ce.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f80bc23d-f23a-4f62-bd62-7fa64296e1ce.png)'
- en: 'Figure 5.3: A stiffness matrix from a finite element model of an elastic plate.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：来自弹性板有限元模型的刚度矩阵。
- en: 5.6.1 Sparse matrix formats
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6.1 稀疏矩阵格式
- en: 'The module `scipy.sparse` provides many different storing formats for sparse matrices.
    Here, we''ll describe only the most important ones: CSR, CSC, and LIL. The LIL
    format should be used for generating and altering sparse matrices; CSR and CSC
    are efficient formats for matrix-matrix and matrix-vector operations.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`scipy.sparse`提供了多种不同的稀疏矩阵存储格式。在这里，我们只描述最重要的几种：CSR、CSC和LIL。LIL格式应当用于生成和修改稀疏矩阵；CSR和CSC是矩阵-矩阵和矩阵-向量运算的高效格式。
- en: Compressed sparse row format (CSR)
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩稀疏行格式（CSR）
- en: 'The **compressed sparse row** (**CSR**) format uses three arrays: `data`, `indptr`,
    and `indices`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**压缩稀疏行**（**CSR**）格式使用三个数组：`data`、`indptr`和`indices`：'
- en: The 1D array `data` stores all the nonzero values in order. It has as many elements
    as there are nonzero elements, often denoted by the variable `nnz`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一维数组`data`按顺序存储所有非零值。它的元素数量等于非零元素的数量，通常用变量`nnz`表示。
- en: The 1D array `indptr` contains integers such that `indptr[i]` is the index of
    the element in `data`, which is the first nonzero element of row *i*. If the entire
    row *i* is zero, then `indptr[i]==indptr[i+1]`. If the original matrix has *m* rows,
    then `len(indptr)==m+1`.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一维数组`indptr`包含整数，`indptr[i]`是`data`中元素的索引，表示第*i*行的第一个非零元素。如果整行*i*都是零，那么`indptr[i]==indptr[i+1]`。如果原始矩阵有*m*行，那么`len(indptr)==m+1`。
- en: The 1D array `indices` contains the column index information in such a way that `indices[indptr[i]:indptr[i+1]]` is
    an integer array with the column indexes of the nonzero elements in row *i*. Obviously, `len(indices)==len(data)==nnz`.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1D 数组 `indices` 包含列索引信息，使得 `indices[indptr[i]:indptr[i+1]]` 是一个整数数组，包含第 *i*
    行非零元素的列索引。显然，`len(indices)==len(data)==nnz`。
- en: 'Let''s see an example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: 'The CSR format of the matrix:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的 CSR 格式：
- en: '![](img/3637523e-fddf-44da-8c67-6286fe700b5a.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3637523e-fddf-44da-8c67-6286fe700b5a.png)'
- en: 'is given by the three arrays:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由以下三个数组给出：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The module `scipy.sparse` provides a type, `csr_matrix`, with a constructor,
    which can be used in the following ways:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 `scipy.sparse` 提供了一种类型 `csr_matrix`，并提供了一个构造函数，可以通过以下方式使用：
- en: With a 2D array as an argument
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二维数组作为参数
- en: With a matrix in one of the other sparse formats in `scipy.sparse`
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `scipy.sparse` 中的其他稀疏格式之一的矩阵
- en: With a shape argument, `(m,n)`, to generate a zero matrix in CSR format
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用形状参数 `(m,n)` 来生成 CSR 格式的零矩阵
- en: By a 1D array for `data` and an integer array `ij` with the shape `(2,len(data))` such
    that `ij[0,k]` is the row index and `ij[1,k]` is the column index of `data[k]` of
    the matrix
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个 1D 数组 `data` 和一个形状为 `(2,len(data))` 的整数数组 `ij`，其中 `ij[0,k]` 是行索引，`ij[1,k]`
    是矩阵中 `data[k]` 的列索引
- en: The three arguments, `data`, `indptr`, and `indices`, can be given to the constructor
    directly
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个参数 `data`、`indptr` 和 `indices` 可以直接传递给构造函数
- en: The first two options are there for conversion purposes while the last two directly
    define the sparse matrix.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个选项用于转换目的，而最后两个选项直接定义稀疏矩阵。
- en: 'Consider the above example; in Python, it looks like:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑上面的示例；在 Python 中，它看起来是这样的：
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Among others, the following attributes are provided:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 其中包括以下属性：
- en: '[PRE59]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Compressed sparse column format (CSC)
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩稀疏列格式（CSC）
- en: The CSR format has a column-oriented twin – the **compressed sparse column**
    (**CSC**) format. The only difference in it compared to the CSR format is the
    definition of the `indptr` and `indices` arrays, which are now column-related.
    The type for the CSC format is `csc_matrix` and its use corresponds to `csr_matrix`,
    explained previously in this subsection.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: CSR 格式有一个列导向的对应物——**压缩稀疏列**（**CSC**）格式。与 CSR 格式相比，它唯一的不同是 `indptr` 和 `indices`
    数组的定义，现在它们与列相关。CSC 格式的类型是 `csc_matrix`，它的使用方式与之前在本小节中解释的 `csr_matrix` 相同。
- en: 'Continuing the same example in CSC format:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用 CSC 格式的相同示例：
- en: '[PRE60]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Row-based linked list format (LIL)
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于行的链表格式（LIL）
- en: The linked list sparse format stores the nonzero matrix entries row-wise in
    a list `data` such that `data[k]` is a list of the nonzero entries in row *k*.
    If all entries in that row are 0, it contains an empty list.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 链表稀疏格式按行存储非零矩阵项，存储在一个列表 `data` 中，使得 `data[k]` 是第 *k* 行的非零项列表。如果该行的所有项均为 0，则该列表为空。
- en: 'A second list, `rows`, contains at position *k* a list of column indexes of
    the nonzero elements in row *k*. Here is an example in row-based **linked list**
    (**LIL**) format:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个列表 `rows` 在位置 *k* 处包含第 *k* 行中非零元素的列索引。以下是基于行的**链表**（**LIL**）格式的示例：
- en: '[PRE61]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Altering and slicing matrices in LIL format
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改和切片 LIL 格式的矩阵
- en: 'The LIL format is the one best suited for slicing, that is, extracting submatrices
    in LIL format, and for changing the sparsity pattern by inserting nonzero elements.
    Slicing is demonstrated by the next example:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: LIL 格式最适合切片，即提取 LIL 格式的子矩阵，并通过插入非零元素来改变稀疏模式。切片操作通过以下示例演示：
- en: '[PRE62]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The insertion of a new nonzero element automatically updates the attributes:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 插入新的非零元素会自动更新属性：
- en: '[PRE63]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: These operations are discouraged in the other sparse matrix formats as they
    are extremely inefficient.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作在其他稀疏矩阵格式中不建议使用，因为它们非常低效。
- en: 5.6.2 Generating sparse matrices
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6.2 生成稀疏矩阵
- en: The NumPy commands `eye`, `identity`, `diag`, and `rand` have their sparse counterparts.
    They take an additional argument; it specifies the sparse matrix format of the
    resulting matrix.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 命令 `eye`、`identity`、`diag` 和 `rand` 都有它们的稀疏版本。它们需要一个额外的参数，指定结果矩阵的稀疏矩阵格式。
- en: 'The following commands generate the identity matrix but in different sparse
    matrix formats:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令生成单位矩阵，但采用不同的稀疏矩阵格式：
- en: '[PRE64]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The command `sp.rand` takes an additional argument describing the density of
    the generated random matrix. A dense matrix has density 1 while a zero matrix
    has density 0:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `sp.rand` 采用一个额外的参数，用于描述生成随机矩阵的密度。密集矩阵的密度为 1，而零矩阵的密度为 0：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'There is no direct correspondence to the NumPy command `zeroes`. Matrices completely
    filled with zeros are generated by instantiating the corresponding type with the
    shape parameters as constructor parameters:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 没有与NumPy命令`zeroes`直接对应的命令。完全填充零的矩阵可以通过实例化相应类型，并将形状参数作为构造参数来生成：
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: After having studied different sparse matrix formats, we now turn to special
    methods for a sparse matrix, mainly conversion methods.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究了不同的稀疏矩阵格式之后，我们现在转向稀疏矩阵的特殊方法，主要是转换方法。
- en: 5.6.3 Sparse matrix methods
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6.3 稀疏矩阵方法
- en: 'There are methods to convert one sparse type into another or into an array:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有方法可以将一种稀疏类型转换为另一种类型或数组：
- en: '[PRE67]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The type of a sparse matrix can be inspected by the methods `issparse`, `isspmatrix_lil`,
    `isspmatrix_csr`, and `isspmatrix_csc`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过方法`issparse`、`isspmatrix_lil`、`isspmatrix_csr`和`isspmatrix_csc`来检查稀疏矩阵的类型。
- en: Elementwise operations `+`, `*`, `/`, and `**` on sparse matrices are defined
    as for NumPy arrays. Regardless of the sparse matrix format of the operands, the
    result is always `csr_matrix`. Applying elementwise operating functions to sparse
    matrices requires first transforming them to either CSR or CSC format and applying
    the functions to their `data` attribute, as demonstrated by the next example.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵上的逐元素操作`+`、`*`、`/`和`**`的定义与NumPy数组相同。无论操作数的稀疏矩阵格式如何，结果始终是`csr_matrix`。将逐元素操作函数应用于稀疏矩阵时，首先需要将其转换为CSR或CSC格式，并对其`data`属性应用函数，如下例所示。
- en: 'The elementwise sine of a sparse matrix can be defined by an operation on its `data` attribute:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵的逐元素正弦可以通过对其`data`属性进行操作来定义：
- en: '[PRE68]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'For matrix-matrix or matrix-vector multiplications, there is a sparse matrix
    method, `dot`. It returns either a `csr_matrix` or a 1D NumPy `array`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩阵-矩阵或矩阵-向量乘法，有一个稀疏矩阵方法`dot`。它返回一个`csr_matrix`或一个1D的NumPy`array`：
- en: 'Consider the following function on which we will demonstrate how to vectorize
    a function:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数，我们将在此展示如何向量化一个函数：
- en: '[PRE69]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Avoid using NumPy's command `dot` on sparse matrices, as this might lead to
    unexpected results. Use the command `dot` from `scipy.sparse` instead.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在稀疏矩阵上使用NumPy的`dot`命令，因为这可能会导致意外结果。应使用来自`scipy.sparse`的`dot`命令。
- en: Other linear algebra operations such as system solving, least squares, eigenvalues,
    and singular values are provided by the module `scipy.sparse.linalg`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 其他线性代数操作，如系统求解、最小二乘法、特征值和奇异值，由模块`scipy.sparse.linalg`提供。
- en: 5.7 Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.7 小结
- en: The concept of views is one of the important topics you should have learned
    from this chapter. Missing this topic will give you a hard time when debugging
    your code. Boolean arrays occur at various places throughout this book. They are
    handy and compact tools for avoiding lengthy `if` constructions and loops when
    working with arrays. In nearly all large computational projects, sparse matrices
    become an issue. You have seen how they are handled and which related methods
    are available.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的概念是本章你应该学习的重要主题之一。缺少这一主题会使你在调试代码时遇到困难。布尔数组在本书的多个地方出现。它们是避免冗长的`if`语句和循环处理数组时的简洁工具。在几乎所有大型计算项目中，稀疏矩阵都会成为一个问题。你已经看到如何处理它们以及可用的相关方法。
