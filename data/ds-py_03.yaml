- en: Chapter 3. Accelerate your Data Analysis with Python Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：使用Python库加速数据分析
- en: '"Every vision is a joke until the first man accomplishes it; once realized,
    it becomes commonplace."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “每一个愿景都是笑话，直到第一个人实现它；一旦实现，它就变得平凡。”
- en: – *Robert H Goddard*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – *罗伯特·戈达德*
- en: In this chapter, we will do a technical deep dive into the PixieApp framework.
    You will be able to use the following information both as a *Getting Started*
    tutorial and as reference documentation for the PixieApp programming model.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨PixieApp框架的技术细节。你将能够将以下信息既作为*入门教程*，也作为PixieApp编程模型的参考文档。
- en: We will start with a high-level description of the anatomy of a PixieApp before
    diving in to its foundational concepts, such as routes and requests. To help follow
    along, we will incrementally build a *GitHub Tracking* sample application that
    applies the capabilities and best practices as they are being introduced, starting
    from building the data analytics to integrating them into the PixieApp.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从PixieApp的基本结构入手，然后再深入探讨其基础概念，如路由和请求。为了帮助大家跟进，我们将逐步构建一个*GitHub 跟踪*示例应用程序，应用介绍的功能和最佳实践，从构建数据分析开始，到将其集成到PixieApp中。
- en: By the end of this chapter, you should be able to apply the lessons learned
    to your own use case, including writing your own PixieApp.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够将学到的知识应用到自己的实际案例中，包括编写自己的PixieApp。
- en: Anatomy of a PixieApp
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PixieApp的结构
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: The PixieApp programming model doesn''t require any prior experience
    with JavaScript, however, it is expected that the reader is familiar with the
    following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：PixieApp编程模型不要求有JavaScript的先验经验，但期望读者熟悉以下内容：'
- en: Python ([https://www.python.org](https://www.python.org))
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python ([https://www.python.org](https://www.python.org))
- en: HTML5 ([https://www.w3schools.com/html](https://www.w3schools.com/html))
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML5 ([https://www.w3schools.com/html](https://www.w3schools.com/html))
- en: CSS3 ([https://www.w3schools.com/css](https://www.w3schools.com/css))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS3 ([https://www.w3schools.com/css](https://www.w3schools.com/css))
- en: The term **PixieApp** stands for **Pixie Application,** and is meant to emphasize
    its tight integration with the PixieDust capabilities, especially the `display()`
    API. Its main goal is to make it easy for developers to build a user interface
    that can invoke the data analytics implemented in the Jupyter Notebook.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**PixieApp**一词代表**Pixie应用程序**，旨在强调其与PixieDust功能的紧密集成，特别是`display()` API。其主要目标是使开发者能够轻松构建可以调用Jupyter
    Notebook中实现的数据分析的用户界面。'
- en: A PixieApp follows the **single-page application** (**SPA**) design pattern
    ([https://en.wikipedia.org/wiki/Single-page_application](https://en.wikipedia.org/wiki/Single-page_application)),
    where the user is presented with a welcome screen that is dynamically updated
    to respond to a user interaction. An update can be a partial refresh, such as
    updating a graph after the user clicks on a control or a full refresh, such as
    a new screen in a multistep process. In each case, the update is controlled on
    the server side by a route that is triggered using a specific mechanism that we'll
    discuss later. When triggered, the route executes code to handle the request and
    then emits an HTML fragment, which is applied to the right target DOM element
    ([https://www.w3schools.com/js/js_htmldom.asp](https://www.w3schools.com/js/js_htmldom.asp))
    on the client side.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个PixieApp遵循**单页应用程序**（**SPA**）设计模式 ([https://en.wikipedia.org/wiki/Single-page_application](https://en.wikipedia.org/wiki/Single-page_application))，用户会看到一个欢迎页面，并根据用户的交互动态更新。更新可以是部分刷新，例如用户点击控件后更新图表，或是完全刷新，比如在多步骤过程中显示新页面。在每种情况下，更新都由服务器端的路由控制，路由通过特定机制触发，我们将在后面讨论。当触发时，路由会执行代码处理请求，然后返回一个HTML片段，该片段会应用到客户端的目标DOM元素上
    ([https://www.w3schools.com/js/js_htmldom.asp](https://www.w3schools.com/js/js_htmldom.asp))。
- en: 'The following sequence diagram shows how the client side and server side interact
    with each other when running a PixieApp:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下时序图展示了在运行PixieApp时，客户端和服务器端是如何相互交互的：
- en: '![Anatomy of a PixieApp](img/B09699_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![PixieApp的结构](img/B09699_03_01.jpg)'
- en: Sequence diagram showing the information flow of a PixieApp
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 显示PixieApp信息流的时序图
- en: When the PixieApp is started (by calling the `run` method), the default route
    is invoked, and the corresponding HTML fragment is returned. As the user interacts
    with the application, more requests are executed, triggering the associated routes
    which refresh the UI accordingly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PixieApp 启动时（通过调用`run`方法），默认路由会被调用，并返回相应的 HTML 片段。当用户与应用交互时，会执行更多请求，触发关联的路由，并相应地刷新
    UI。
- en: From an implementation perspective, a PixieApp is simply a regular Python class that
    has been decorated with the `@PixieApp` decorator. Under the cover, the ` PixieApp`
    decorator instruments the class to add methods and fields required to run the
    app, such as the `run` method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从实现的角度来看，PixieApp 只是一个常规的 Python 类，已经使用了`@PixieApp`装饰器。在幕后，`PixieApp`装饰器为类添加了运行应用所需的方法和字段，例如
    `run` 方法。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More information on Python decorators can be found here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Python 装饰器的信息可以在这里找到：
- en: '[https://wiki.python.org/moin/PythonDecorators](https://wiki.python.org/moin/PythonDecorators)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.python.org/moin/PythonDecorators](https://wiki.python.org/moin/PythonDecorators)'
- en: 'To get things started, the following code shows a simple *Hello World* PixieApp:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，以下代码展示了一个简单的 *Hello World* PixieApp：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode1.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode1.py)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode1.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode1.py)'
- en: The preceding code shows the structure of a PixieApp, how to define the routes,
    and how to instantiate and run the app. Because PixieApps are regular Python classes,
    they can inherit from other classes, including other PixieApps, which is convenient
    for larger projects to make the code modular and reusable.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了 PixieApp 的结构，如何定义路由，以及如何实例化并运行应用。由于 PixieApps 是常规的 Python 类，因此它们可以继承其他类，包括其他
    PixieApp，这对于大型项目来说，能够使代码模块化和可重用。
- en: Routes
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由
- en: 'Routes are used to dynamically update all or part of the client screen. They
    can be easily defined by using the `@route` decorator on any class method, based
    on the following rules:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 路由用于动态更新客户端屏幕的全部或部分内容。可以通过在任何类方法上使用`@route`装饰器来轻松定义路由，依据以下规则：
- en: A route method is required to return a string that represents the HTML fragment
    for the update.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由方法需要返回一个字符串，表示用于更新的 HTML 片段。
- en: Note
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: CSS and JavaScript are allowed to be used in the fragment.'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**：在片段中允许使用 CSS 和 JavaScript。'
- en: 'The `@route` decorator can have one or more keyword arguments, which are required
    to be of the String type. These keyword arguments can be thought of as request
    parameters, which are used internally by the PixieApp framework to dispatch the
    request to the route that is the best match according to the following rules:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@route`装饰器可以有一个或多个关键字参数，这些参数必须是字符串类型。可以将这些关键字参数视为请求参数，PixieApp 框架内部使用它们将请求分发到最匹配的路由，依据以下规则：'
- en: The routes with most arguments are always evaluated first.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数最多的路由总是会被优先评估。
- en: All arguments must match for a route to be selected.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有参数必须匹配，才能选择一个路由。
- en: If the route is not found, then the default route is selected as a fallback.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未找到路由，则会选择默认路由作为备用。
- en: Routes can be configured using a wildcard, that is, `*`, in which case, any
    value for the state argument will be a match.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由可以使用通配符`*`进行配置，在这种情况下，任何状态参数的值都会匹配。
- en: 'Following is an example:'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A PixieApp is required to have one, and only one, default route, which is a route
    with no argument, that is, `@route()`.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PixieApp 必须有且仅有一个默认路由，即没有参数的路由，即`@route()`。
- en: It is very important to configure the routes in a way that doesn't cause conflict,
    especially if your application has hierarchical states. For example, a route associated
    with `state1="load"` could be responsible for loading data and then a second route
    associated with `(state1="load", state2="graph")` could be responsible for plotting
    the data. In this case, a request with both `state1` and `state2` specified will match
    the second route because route evaluation happens from most specific to least
    specific, stopping at the first matching route.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 配置路由时避免冲突非常重要，特别是当你的应用有层次化状态时。例如，关联 `state1="load"` 的路由可能负责加载数据，然后关联 `(state1="load",
    state2="graph")` 的第二个路由可能负责绘制数据。在这种情况下，带有 `state1` 和 `state2` 两个指定参数的请求将匹配第二个路由，因为路由评估是从最具体到最不具体的顺序进行的，直到找到第一个匹配的路由为止。
- en: 'To clarify, the following diagram shows how requests are matched with routes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚，以下图示展示了请求与路由是如何匹配的：
- en: '![Routes](img/B09699_03_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Routes](img/B09699_03_02.jpg)'
- en: Matching requests to routes
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请求与路由的匹配
- en: 'The expected contract for a method defined as a route is to return an HTML
    fragment, which can contain Jinja2 templating constructs. Jinja2 is a powerful
    Python template engine that provides a rich set of features to dynamically generate
    text, including access to Python variables, methods, and control structures, such
    as `if...else`, `the for` loop, and so on. Covering all its features would be
    beyond the scope of this book, but let''s discuss a few important constructs that
    are used frequently:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为路由的方法的预期合同是返回一个 HTML 片段，其中可以包含 Jinja2 模板构造。Jinja2 是一个强大的 Python 模板引擎，提供了一套丰富的功能来动态生成文本，包括访问
    Python 变量、方法和控制结构，如 `if...else`、`for` 循环等。覆盖所有功能超出了本书的范围，但我们将讨论一些常用的重要构造：
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: If you want to know more about Jinja2, you can read the full documentation
    here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：如果你想了解更多关于 Jinja2 的内容，可以在这里阅读完整文档：'
- en: '[http://jinja.pocoo.org/docs/templates](http://jinja.pocoo.org/docs/templates)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://jinja.pocoo.org/docs/templates](http://jinja.pocoo.org/docs/templates)'
- en: '**Variables**: You can use the double-curly braces to access variables that
    are in scope, for example, `"<div>This is my variable {{my_var}}</div>"`. During
    rendering, the `my_var` variable will be replaced with its actual value. You can
    also use the `.` (dot) notation to access complex object, for example, `"<div>This
    is a nested value {{my_var.sub_value}}</div>"`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**：你可以使用双花括号来访问作用域中的变量，例如，`"<div>这是我的变量 {{my_var}}</div>"`。在渲染时，`my_var`
    变量将被其实际值替换。你还可以使用 `.`（点）符号来访问复杂对象，例如，`"<div>这是一个嵌套的值 {{my_var.sub_value}}</div>"`。'
- en: '**for loop**: You can use the `{%for ...%}...{%endfor%}` notation to dynamically
    generate text by iterating over a sequence of items (list, tuple, dictionary,
    and so on), as in the example:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**for 循环**：你可以使用 `{%for ...%}...{%endfor%}` 语法来通过迭代一系列项目（如列表、元组、字典等）动态生成文本，如下例所示：'
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**if statement**: You can use the `{%if ...%}...{%elif ...%}...{%else%}…{%endif%}`
    notation to conditionally output text, as in the example:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if 语句**：你可以使用 `{%if ...%}...{%elif ...%}...{%else%}…{%endif%}` 语法来有条件地输出文本，如下例所示：'
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is also important to know how variables and methods come into the scope
    of the JinJa2 template string returned by the route. PixieApp automatically provides
    access to three types of variables and methods:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 了解变量和方法如何进入 Jinja2 模板字符串的作用域也非常重要。PixieApp 会自动提供三种类型的变量和方法供你访问：
- en: '**Class variables and methods**: These are accessible using the `this` keyword.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类变量和方法**：可以使用 `this` 关键字访问这些内容。'
- en: Note
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: The reason we''re not using the more Pythonic `self` keyword is that it
    is unfortunately already taken by Jinja2 itself.'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**：我们没有使用更符合 Python 风格的 `self` 关键字，因为不幸的是，Jinja2 本身已经占用了这个关键字。'
- en: '**Method arguments**: This is useful when the route arguments use the `*` value
    and you want to have access to that value at runtime. In this case, you can add
    arguments to the method itself using the same name as the one defined in the route
    arguments and the PixieApp framework will automatically pass the correct value.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法参数**：当路由参数使用 `*` 值，并且你希望在运行时访问该值时，这个功能非常有用。在这种情况下，你可以在方法中添加与路由参数中定义的名称相同的参数，PixieApp
    框架会自动传递正确的值。'
- en: Note
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: The order of the arguments actually doesn''t matter. You also do
    not have to use every argument defined in the route, which is convenient if you
    are only interested in using a subset of the arguments.'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**：参数的顺序实际上无关紧要。你也不必使用路由中定义的每个参数，这样如果你只关心使用其中的一部分参数会更加方便。'
- en: 'The variable will also be in the scope of the Jinja2 template string, as shown
    in the example:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该变量也会在Jinja2模板字符串的作用域内，如下例所示：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode2.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode2.py)'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode2.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode2.py)'
- en: '**Local variables to the method**: PixieApp will automatically put all the local variables
    defined in the method in scope of the Jinja2 template string, provided that you
    add the `@templateArgs` decorator to the method, as shown in the example:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法的局部变量**：PixieApp将自动把在方法中定义的所有局部变量放入Jinja2模板字符串的作用域中，前提是你在方法中添加了`@templateArgs`装饰器，如下例所示：'
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code here:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode3.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode3.py)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode3.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode3.py)'
- en: Generating requests to routes
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成请求到路由
- en: 'As mentioned before, PixieApp follows the SPA design pattern. After the first
    screen is loaded, all subsequent interactions with the server are done using dynamic requests
    as opposed to URL links as is the case for multipage web applications. There are
    three ways to generate a kernel request to a route:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，PixieApp遵循SPA设计模式。在第一次加载屏幕后，所有与服务器的后续交互都是通过动态请求进行的，而不是像多页面Web应用程序那样使用URL链接。有三种方法可以生成到路由的内核请求：
- en: 'Use the `pd_options` custom attribute to define a list of states to be passed
    to the server, as in the following example:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pd_options`自定义属性定义要传递给服务器的状态列表，如下例所示：
- en: '[PRE6]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you already have a JSON object that contains the `pd_options` value—as in the
    case of invoking `display()`—you would have to transform it into the format expected
    by the `pd_options` HTML attribute, which can be time-consuming. In this case,
    it is more convenient to specify `pd_options` as a child element, which allows
    the options to be passed directly as a JSON object (and avoid the extra work of
    transforming the data), as in the following example:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你已经有一个包含`pd_options`值的JSON对象——例如在调用`display()`时——你需要将其转换为`pd_options` HTML属性所期望的格式，这可能会非常耗时。在这种情况下，更方便的方法是将`pd_options`指定为子元素，这样就能直接将选项作为JSON对象传递（避免了转换数据的额外工作），如下例所示：
- en: '[PRE7]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Programmatically by calling the `invoke_route` method, as in the following
    example:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`invoke_route`方法以编程方式，如下例所示：
- en: '[PRE8]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: Remember to use `this`, as opposed to `self`, if you are calling
    this method from a Jinja2 template string, as `self` is already used by Jinja2
    itself.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：记得使用`this`，而不是`self`，如果你是从Jinja2模板字符串中调用此方法，因为`self`已经被Jinja2本身使用。'
- en: When the state values passed in `pd_options` need to be dynamically computed
    based on user selections, you need to use the `$val(arg)` special directive, which
    acts as a macro that will be resolved at the time the kernel request is executed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当`pd_options`中传递的状态值需要根据用户选择动态计算时，你需要使用`$val(arg)`特殊指令，该指令作为宏，在内核请求执行时解析。
- en: 'The `$val(arg)` directive takes one argument that can be one of the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`$val(arg)`指令接受一个参数，该参数可以是以下之一：'
- en: 'The ID of an HTML element on the page, such as an input or a combobox, as in
    the following example:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面上HTML元素的ID，例如输入框或组合框，如下例所示：
- en: '[PRE9]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A JavaScript function that must return the desired value, as in the following
    example:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个必须返回期望值的JavaScript函数，如下例所示：
- en: '[PRE10]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: Dynamic value using the `$val` directive are supported by most of the
    PixieDust custom attributes.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：使用`$val`指令的动态值被大多数PixieDust自定义属性支持。'
- en: A GitHub project tracking sample application
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个GitHub项目追踪示例应用程序
- en: Let's apply what we learned so far to implementing the sample application. To try
    things out, we want to use the GitHub Rest APIs ([https://developer.github.com/v3](https://developer.github.com/v3))
    to search for projects and load the results into a pandas DataFrame for analysis.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将迄今为止学到的内容应用到实现示例应用程序中。为了试验，我们将使用 GitHub Rest API ([https://developer.github.com/v3](https://developer.github.com/v3))
    来搜索项目并将结果加载到 pandas DataFrame 中进行分析。
- en: 'The initial code shows the welcome screen with a simple input box to enter
    the GitHub query and a button to submit the request:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 初始代码显示欢迎界面，包含一个简单的输入框用于输入 GitHub 查询，并有一个按钮提交请求：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode4.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode4.py)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode4.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode4.py)'
- en: 'A few things to note from the preceding code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码中有几点需要注意：
- en: The Bootstrap CSS framework ([https://getbootstrap.com/docs/3.3](https://getbootstrap.com/docs/3.3))
    and the jQuery JS framework ([https://jquery.com](https://jquery.com)) are provided
    by the Jupyter Notebook. We can readily use them in our code without the need
    to install them.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bootstrap CSS 框架 ([https://getbootstrap.com/docs/3.3](https://getbootstrap.com/docs/3.3))
    和 jQuery JS 框架 ([https://jquery.com](https://jquery.com)) 已由 Jupyter Notebook
    提供。我们可以直接在代码中使用它们，无需安装。
- en: Font Awesome icons ([https://fontawesome.com](https://fontawesome.com)) are
    also available by default in the Notebook.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Font Awesome 图标 ([https://fontawesome.com](https://fontawesome.com)) 在 Notebook
    中默认可用。
- en: The PixieApp code could be executed in multiple cells of the Notebook. Since
    we're relying on DOM element IDs, it is important to make sure that two elements
    do not have the same ID which would cause undesirable side effects. To that end,
    it is recommended to always include the unique identifier `{{prefix}}`, provided
    by the PixieDust framework, for example, `"query{{prefix}}"`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PixieApp 代码可以在 Notebook 的多个单元格中执行。由于我们依赖于 DOM 元素 ID，因此确保两个元素没有相同的 ID 是很重要的，否则会导致不希望出现的副作用。为此，建议始终包括由
    PixieDust 框架提供的唯一标识符`{{prefix}}`，例如 `"query{{prefix}}"`。
- en: 'The results are shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在以下截图中：
- en: '![A GitHub project tracking sample application](img/B09699_03_03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![A GitHub project tracking sample application](img/B09699_03_03.jpg)'
- en: Welcome screen of our GitHub Tracking application
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 GitHub 跟踪应用的欢迎界面
- en: The next step is to create a new route that takes the user value and returns
    the results. This route will be invoked by the **Submit Query** button.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个新路由，接收用户输入并返回结果。此路由将通过 **提交查询** 按钮调用。
- en: 'To keep things simple, the following code doesn''t use a Python library to
    interface with GitHub, such as PyGithub ([http://pygithub.readthedocs.io/en/latest](http://pygithub.readthedocs.io/en/latest)),
    instead, we''ll directly call the REST APIs as documented in the GitHub website:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，以下代码没有使用与 GitHub 交互的 Python 库，如 PyGithub ([http://pygithub.readthedocs.io/en/latest](http://pygithub.readthedocs.io/en/latest))，而是直接调用
    GitHub 网站中文档化的 REST API：
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: When you see the following notation `[[GitHubTracking]]`, this means
    that the code is meant to be added to the `GitHubTracking` PixieApp class and,
    to avoid repeating the surrounding code over and over again, it has been omitted.
    When in doubt, you can always refer to the complete Notebook specified at the
    end of the section.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：当你看到以下符号 `[[GitHubTracking]]` 时，表示该代码应添加到 `GitHubTracking` PixieApp
    类中，为了避免重复代码，已省略周围的代码。在有疑问时，你可以参考本节末尾指定的完整 Notebook。'
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode5.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode5.py)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode5.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode5.py)'
- en: 'In the preceding code, we created a route called `do_search` that takes one
    argument called `query`, which we use to build an API URL to GitHub. Using the
    `requests` Python module ([http://docs.python-requests.org](http://docs.python-requests.org))
    to issue a GET request to this URL, we get a JSON payload that we turn into a
    pandas DataFrame. According to the GitHub documentation, the Search API paginates
    with the next page being stored in the link''s headers. The code uses a `while`
    loop to go over each link and load the next page into a new DataFrame. We then
    concatenate all the DataFrames into one called `pdf`. All we have left to do is
    build the HTML fragment that will display the results. The fragment uses the Jinja2
    notation `{{...}}` to access the `pdf` variable defined as a local variable, which
    only works because we used the `@templateArgs` decorator in the `do_search` method.
    Notice that we also use a Jinja2 filter called `length` to display the number
    of repositories found: `{{pdf|length}}`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个名为`do_search`的路由，它接受一个名为`query`的参数，我们用这个参数来构建GitHub的API URL。使用`requests`
    Python模块（[http://docs.python-requests.org](http://docs.python-requests.org)）向这个URL发出GET请求，我们得到一个JSON数据包，并将其转换为一个pandas
    DataFrame。根据GitHub文档，搜索API会进行分页，下一页的链接会存储在响应头中。代码使用`while`循环遍历每个链接，并将下一页加载到新的DataFrame中。然后，我们将所有的DataFrame合并为一个名为`pdf`的DataFrame。接下来，我们只需构建一个HTML片段来显示结果。该片段使用Jinja2语法`{{...}}`来访问定义为局部变量的`pdf`，这只因为我们在`do_search`方法中使用了`@templateArgs`装饰器。请注意，我们还使用了一个Jinja2过滤器`length`来显示找到的仓库数量：`{{pdf|length}}`。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on filters, visit the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有关过滤器的更多信息，请访问以下链接：
- en: '[http://jinja.pocoo.org/docs/templates/#filters](http://jinja.pocoo.org/docs/templates/#filters)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://jinja.pocoo.org/docs/templates/#filters](http://jinja.pocoo.org/docs/templates/#filters)'
- en: 'We still need to invoke the `do_search` route when the user clicks on the **Submit Query**
    button. For that, we add the `pd_options` attribute to the `<button>` element,
    as highlighted here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**提交查询**按钮时，我们仍然需要调用`do_search`路由。为此，我们在`<button>`元素中添加`pd_options`属性，如下所示：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use the `$val()` directive in the `pd_options` attribute to dynamically retrieve
    the value of the input box with ID equals to `"query{{prefix}}"` and store it
    in the query argument.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`pd_options`属性中使用了`$val()`指令，动态获取ID为`"query{{prefix}}"`的输入框的值，并将其存储在`query`参数中。
- en: Displaying the search results in a table
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在表格中显示搜索结果
- en: 'The preceding code loads all the data at once, which is not recommended since
    we could have a huge number of hits. Similarly, displaying it all in one go would
    make the UI sluggish and non-practical. Thankfully, we can easily build a paginated
    table without too much effort, using the following steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码一次性加载所有数据，这并不推荐，因为我们可能会有大量数据。类似地，一次性展示所有数据会导致界面变得缓慢且不实用。幸运的是，我们可以通过以下步骤轻松构建一个分页表格，而无需太多努力：
- en: Create a route called `do_retrieve_page` that takes a URL as an argument and
    returns the HTML fragment for the table body
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`do_retrieve_page`的路由，接受一个URL作为参数，并返回表格主体的HTML片段
- en: Maintain the first, previous, next, and last URLs as fields in the PixieApp
    class
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`first`、`previous`、`next`和`last`的URL作为字段保存在PixieApp类中
- en: Create a pagination widget (we'll use Bootstrap since it's available) with `First`,
    `Prev`, `Next`, and `Last` button
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个分页控件（我们将使用Bootstrap，因为它是现成的），包括`First`、`Prev`、`Next`和`Last`按钮
- en: Create a table placeholder with the columns headers to be displayed
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表格占位符，显示需要显示的列标题
- en: 'We''ll now update the code for `do_search,` as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更新`do_search`方法，如下所示：
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: The following code is referencing the `do_retrieve_page` method which
    we will define a little later. Please do not attempt to run this code as is until
    you also add the `do_retrieve_page` method.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：以下代码引用了`do_retrieve_page`方法，我们稍后会定义它。在你添加`do_retrieve_page`方法之前，请不要尝试运行此代码。'
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode6.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode6.py)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode6.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode6.py)'
- en: The preceding code sample shows a very important property of PixieApps, which
    is that you can maintain state throughout the life cycle of the application by
    simply storing the data into class variables. In this case, we use `self.first_url`,
    `self.prev_url`, `self.next_url`, and `self.last_url`. These variables use the
    `pd_options` property for each button in the pagination widget and update each
    time the `do_retrieve_page` route is invoked. The fragment returned by `do_search`
    now returns a table with a placeholder for the body, identified by `body{{prefix}},`
    which becomes the `pd_target` for each button. We also use the `invoke_route`
    method to make sure that we get the first page when the table is first displayed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码示例展示了 PixieApps 的一个非常重要的特性，那就是你可以通过简单地将数据存储到类变量中来保持应用程序生命周期中的状态。在这个例子中，我们使用了
    `self.first_url`、`self.prev_url`、`self.next_url` 和 `self.last_url` 变量。这些变量为每个分页控件中的按钮使用
    `pd_options` 属性，并在每次调用 `do_retrieve_page` 路由时更新。`do_search` 返回的片段现在返回一个表格，其中包含一个由
    `body{{prefix}}` 标识的占位符，成为每个按钮的 `pd_target`。我们还使用 `invoke_route` 方法来确保在首次显示表格时获取第一页。
- en: We've seen before that the HTML fragment returned by a route is used to replace
    the entire page, but in the preceding code, we use the `pd_target="body{{prefix}}"`
    attribute to signify that the HTML fragment will be injected in the body element
    of the table that has the `body{{prefix}}` ID. If needed, you can also define
    multiple targets for a user action, by creating one or more `<target>` elements
    as children of the clickable source element. Each `<target>` element can itself
    use all the PixieApp custom attributes to configure kernel requests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，路由返回的 HTML 片段用于替换整个页面，但在前面的代码中，我们使用了 `pd_target="body{{prefix}}"` 属性来表示
    HTML 片段将被注入到具有 `body{{prefix}}` ID 的表格主体元素中。如果需要，你还可以通过创建一个或多个 `<target>` 元素作为可点击源元素的子元素，来定义多个目标以响应用户操作。每个
    `<target>` 元素本身可以使用所有 PixieApp 自定义属性来配置内核请求。
- en: 'Here is an example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Back to our GitHub sample application, the `do_retrieve_page` method now looks
    like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 GitHub 示例应用程序，`do_retrieve_page` 方法现在看起来像这样：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode7.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode7.py)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode7.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode7.py)'
- en: The `page` argument is a string that contains the name of the `url` class variable
    we want to display. We use the standard `getattr` Python function ([https://docs.python.org/2/library/functions.html#getattr](https://docs.python.org/2/library/functions.html#getattr))
    to get the `url` value from the page. We then issue a GET request on the GitHub
    API `url` to retrieve the payload as JSON format which we pass to the Jinja2 template
    to generate the set of rows that will be injected in the table. For that, we use
    the `{%for…%}` loop control structure available in Jinja2 ([http://jinja.pocoo.org/docs/templates/#for](http://jinja.pocoo.org/docs/templates/#for))
    to generate a sequence of `<tr>` and `<td>` HTML tags.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`page` 参数是一个字符串，包含我们想要显示的 `url` 类变量的名称。我们使用标准的 `getattr` Python 函数 ([https://docs.python.org/2/library/functions.html#getattr](https://docs.python.org/2/library/functions.html#getattr))
    来从页面中获取 `url` 值。然后，我们对 GitHub API 的 `url` 发出 GET 请求，获取以 JSON 格式返回的有效载荷，并将其传递给
    Jinja2 模板，以生成将注入到表格中的一组行。为此，我们使用 Jinja2 中的 `{%for…%}` 循环控制结构 ([http://jinja.pocoo.org/docs/templates/#for](http://jinja.pocoo.org/docs/templates/#for))
    来生成一系列 `<tr>` 和 `<td>` HTML 标签。'
- en: 'The following screenshot shows the search results for the query: `pixiedust`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了查询 `pixiedust` 的搜索结果：
- en: '![Displaying the search results in a table](img/B09699_03_04.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![在表格中显示搜索结果](img/B09699_03_04.jpg)'
- en: Screen showing the list of GitHub repo resulting from a query
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 显示来自查询的 GitHub 仓库列表的屏幕
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In Part 1, we showed how to create the `GitHubTracking` PixieApp, invoke the
    GitHub query REST API, and display the results in a table using pagination. You
    can find the complete Notebook with the source code here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，我们展示了如何创建 `GitHubTracking` PixieApp，调用 GitHub 查询 REST API，并使用分页在表格中显示结果。你可以在这里找到包含源代码的完整笔记本：
- en: '`https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%201.ipynb`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%201.ipynb`'
- en: In the next section, we will explore more PixieApp features that will allow
    us to improve the application by letting the user drill down into a particular
    repository and visualize various statistics about the repository.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将探索更多 PixieApp 的功能，这些功能将帮助我们通过让用户深入某个特定的仓库，并可视化该仓库的各种统计数据，来改进应用程序。
- en: The first step is to add a button to each row of the search results table that
    triggers a new route for visualizing the selected repository statistics.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是为搜索结果表格的每一行添加一个按钮，该按钮触发一个新路由，用于可视化所选仓库的统计信息。
- en: 'The following code is part of the `do_search` function and adds a new column
    in the table header:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 `do_search` 函数的一部分，并在表头中添加了一个新列：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To complete the table, we update the `do_retrieve_page` method to add a new
    cell that contains a `<button>` element, with `pd_options` arguments that match
    the new route: `analyse_repo_owner` and `analyse_repo_name`. The values of these
    arguments are extracted from the `row` element used for iterating over the payload
    received from the GitHub request:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成表格，我们更新了 `do_retrieve_page` 方法，添加了一个新单元格，其中包含一个 `<button>` 元素，带有与新路由匹配的
    `pd_options` 参数：`analyse_repo_owner` 和 `analyse_repo_name`。这些参数的值是从用于遍历从 GitHub
    请求中接收到的有效负载的 `row` 元素中提取的：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this simple code change in place, restart the PixieApp by running the cell
    again and we can now see the button for each repo, even though we haven't yet
    implemented the corresponding route, which we'll implement next. As a reminder,
    when no matching route is found, the default route is triggered.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的代码更改完成后，通过重新运行单元格来重启 PixieApp，现在我们可以看到每个仓库的按钮，尽管我们还没有实现相应的路由，接下来我们将实现该路由。提醒一下，当没有找到匹配的路由时，默认路由将被触发。
- en: 'The following screenshot shows the table with the added buttons:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了添加按钮后的表格：
- en: '![Displaying the search results in a table](img/B09699_03_05.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![在表格中显示搜索结果](img/B09699_03_05.jpg)'
- en: Adding action buttons for each row
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为每一行添加操作按钮
- en: 'The next step is to create the route associated with the Repo Visualization
    page. The design for this page is rather simple: from a combobox, the user chooses
    the type of data they want to visualize on the page. The GitHub REST API provides
    access to many types of data but, for this sample application, we will use the
    commit activity data, which is part of the Statistics category (see [https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data](https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data)
    for a detailed description of this API).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建与仓库可视化页面关联的路由。该页面的设计相当简单：用户从下拉框中选择他们想要在页面上可视化的数据类型。GitHub REST API 提供了多种类型的数据访问，但对于这个示例应用程序，我们将使用提交活动数据，这是统计类别的一部分（请参阅
    [https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data](https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data)
    以获取此 API 的详细说明）。
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As an exercise, feel free to improve this sample application by adding visualizations
    for other types of APIs, such as the Traffic API ([https://developer.github.com/v3/repos/traffic](https://developer.github.com/v3/repos/traffic)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，您可以通过添加其他类型 API 的可视化效果来改进这个示例应用程序，例如流量 API（[https://developer.github.com/v3/repos/traffic](https://developer.github.com/v3/repos/traffic)）。
- en: It's also important to note that, even though most of the GitHub APIs work without
    authentication, the server may throttle the responses if you don't provide credentials.
    To authenticate the requests, you will need to use your GitHub password or generate
    a personal access token by selecting the **Developer settings** menu on your GitHub
    **Settings** page, then click on **Personal access tokens** menu, followed by
    the **Generate new token button**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 同时需要注意的是，尽管大多数 GitHub API 可以在没有认证的情况下工作，但如果未提供凭证，服务器可能会限制响应。要进行请求认证，您需要使用 GitHub
    密码或通过在 GitHub **设置**页面中选择**开发者设置**菜单，点击**个人访问令牌**菜单，然后点击**生成新令牌按钮**来生成个人访问令牌。
- en: 'In a separate Notebook cell, we will create two variables for the GitHub user
    ID and token:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个单独的 Notebook 单元格中，我们将为 GitHub 用户 ID 和令牌创建两个变量：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These variables will be used later on to authenticate the requests. Note that,
    even though these variables are created in their own cell, they are visible to
    the entire Notebook, including the PixieApp code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量稍后将在请求认证中使用。请注意，尽管这些变量是在各自的单元格中创建的，但它们对整个 Notebook 可见，包括 PixieApp 代码。
- en: To provide good code modularity and reuse, we'll implement the Repo Visualization
    page in a new class and have our main PixieApp class inherit from it and automatically
    reuse its routes. This is a pattern to keep in mind when you start having large
    projects and want to break it down into multiple classes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供良好的代码模块化和复用性，我们将在一个新类中实现 Repo Visualization 页面，并让主 PixieApp 类继承该类并自动复用它的路由。这是一个模式，当你开始处理大型项目并希望将其拆分为多个类时，需要记住。
- en: 'The main route for the Repo Visualization page returns an HTML fragment that
    has a drop-down menu and a `<div>` placeholder for the visualizations. The drop-down
    menu is created using Bootstrap `dropdown` class ([https://www.w3schools.com/bootstrap/bootstrap_dropdowns.asp](https://www.w3schools.com/bootstrap/bootstrap_dropdowns.asp)).
    To make the code easier to maintain, the menu items are generated using a Jinja2
    `{%for..` `%}` loop over an array of tuples ([https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences](https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences))
    called `analyses` that contains a description and a function for loading the data
    into a pandas DataFrame. Again here, we create this array in its own cell, which
    will be referenced in the PixieApp class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Repo Visualization 页面的主路由返回一个包含下拉菜单和 `<div>` 占位符的 HTML 片段。下拉菜单使用 Bootstrap `dropdown`
    类创建（[https://www.w3schools.com/bootstrap/bootstrap_dropdowns.asp](https://www.w3schools.com/bootstrap/bootstrap_dropdowns.asp)）。为了使代码更易于维护，菜单项是通过
    Jinja2 `{%for..` `%}` 循环生成的，该循环遍历一个包含元组的数组（[https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences](https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences)），数组名为
    `analyses`，它包含一个描述和一个用于将数据加载到 pandas DataFrame 中的函数。这里，我们再次在自己的单元格中创建这个数组，并将在
    PixieApp 类中引用它：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: The `load_commit_activity` function will be discussed later on in
    this section.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：`load_commit_activity` 函数将在本节后面讨论。'
- en: For the purpose of this sample application, the array only contains one element
    related to the commit activity, but any element you may add in the future will
    automatically be picked up by the UI.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例应用程序，数组仅包含一个与提交活动相关的元素，但将来你添加的任何元素都会自动被 UI 捕捉到。
- en: 'The `do_analyse_repo` route has two arguments: `analyse_repo_owner` and `analyse_repo_name,`
    which should be sufficient to access the GitHub APIs. We also need to save these
    arguments as class variables because they will be needed in the route that generates
    the visualizations:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_analyse_repo` 路由有两个参数：`analyse_repo_owner` 和 `analyse_repo_name`，这些应该足以访问
    GitHub APIs。我们还需要将这些参数保存为类变量，因为它们将在生成可视化的路由中使用：'
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode8.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode8.py)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode8.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode8.py)'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Two things to note in the preceding code are the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中需要注意两件事：
- en: 'The Jinja2 template references the `analyses` array using the `this` keyword,
    even though the `analyses` variable is not defined as a class variable. This works
    because of another important PixieApp feature: any variable defined in the Notebook itself
    can be referenced as if they were class variables of the PixieApp.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja2 模板使用 `this` 关键字引用 `analyses` 数组，尽管 `analyses` 变量并未定义为类变量。之所以能够这样工作，是因为
    PixieApp 的另一个重要特性：在 Notebook 中定义的任何变量都可以像类变量一样引用。
- en: I store `analyse_repo_owner` and `analyse_repo_name` as class variables with
    a different name, for example, `_analyse_repo_owner` and `_analyse_repo_name`.
    This is important because using the same name would have a side effect on the
    route matching algorithm, which also looks at class variables to find arguments.
    Using the same name would then cause this route to always be found, which is not
    the desired effect.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将 `analyse_repo_owner` 和 `analyse_repo_name` 作为类变量存储，并使用不同的名称，例如 `_analyse_repo_owner`
    和 `_analyse_repo_name`。这很重要，因为使用相同的名称会对路由匹配算法产生副作用，算法也会查看类变量来查找参数。使用相同的名称会导致该路由始终被找到，这显然不是我们想要的效果。
- en: The action button link is defined by the `<a>` tag and uses `pd_options` to
    access a route that has one argument called `analyse_type`, as well as `pd_target`
    pointing at the `"analyse_vis{{prefix}}"` placeholder, `<div>,` defined below
    in the same HTML fragment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 动作按钮链接由 `<a>` 标签定义，并使用 `pd_options` 访问一个包含名为 `analyse_type` 的参数的路由，此外 `pd_target`
    指向同一 HTML 片段下方定义的 `"analyse_vis{{prefix}}"` 占位符 `<div>`。
- en: Invoking the PixieDust display() API using pd_entity attribute
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`pd_entity`属性调用PixieDust的display() API
- en: When using the `pd_options` attribute to create a kernel request, the PixieApp
    framework uses the current PixieApp class as the target. However, you can change
    this target by specifying a `pd_entity` attribute. You could, for example, point
    at another PixieApp or, more interestingly, point at a data structure supported
    by the `display()` API, such as a pandas or Spark DataFrame. In this case, and
    provided that you include the correct options as expected by the `display()` API,
    the generated output will be the chart itself (an image in the case of Matplotlib,
    Iframe in the case of Mapbox, or an SVG in the case of Bokeh). One simple way
    to get the correct options is to invoke the `display()` API in its own cell, configure
    the chart as desired using the menus and then copy the cell metadata JSON fragment
    available by clicking on the **Edit Metadata** button. (You may first have to
    enable the button by using the menu **View** | **Cell Toolbar** | **Edit Metadata**).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`pd_options`属性创建内核请求时，PixieApp框架会将当前的PixieApp类作为目标。但是，你可以通过指定`pd_entity`属性来更改这个目标。例如，你可以指向另一个PixieApp，或者更有趣的是，指向`display()`
    API支持的数据结构，比如pandas或Spark DataFrame。在这种情况下，只要你包含`display()` API所期望的正确选项，生成的输出将是图表本身（在Matplotlib的情况下是图像，在Mapbox的情况下是Iframe，在Bokeh的情况下是SVG）。获取正确选项的一种简单方法是，在自己的单元格中调用`display()`
    API，使用菜单配置所需的图表，然后复制通过点击**编辑元数据**按钮获得的单元格元数据JSON片段。（你可能需要先通过菜单**视图** | **单元格工具栏**
    | **编辑元数据**来启用该按钮）。
- en: You can also specify `pd_entity` without any value. In this case, the PixieApp
    framework will use the entity passed as the first argument to the `run` method
    used to launch the PixieApp application. For example, `my_pixieapp.run(cars)`
    with `cars` being a pandas or Spark DataFrame created by the `pixiedust.sampleData()`
    method. The value of `pd_entity` can also be a function call that returns the
    entity. This is useful when you want to dynamically compute the entity before
    rendering it. As with other variables, the scope of `pd_entity` can be either
    the PixieApp class or any variable declared in the Notebook.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在不指定任何值的情况下指定`pd_entity`。在这种情况下，PixieApp框架将使用传递给`run`方法的第一个参数作为实体，该方法用于启动PixieApp应用程序。例如，`my_pixieapp.run(cars)`，其中`cars`是通过`pixiedust.sampleData()`方法创建的pandas或Spark
    DataFrame。`pd_entity`的值也可以是返回实体的函数调用。当你想在渲染实体之前动态计算实体时，这很有用。与其他变量一样，`pd_entity`的作用范围可以是PixieApp类，也可以是Notebook中声明的任何变量。
- en: 'For example, we can create a function in its own cell that takes a prefix as
    an argument and returns a pandas DataFrame. We then use it as a `pd_entity` value in my
    PixieApp, as shown in the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在一个单元格中创建一个函数，该函数以前缀作为参数并返回一个pandas DataFrame。然后我们将其用作我的PixieApp中的`pd_entity`值，如下代码所示：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode9.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode9.py)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode9.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode9.py)'
- en: In the preceding code, we used Python list comprehensions ([https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions](https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions))
    to quickly generate mock data based on the `key` argument.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用了Python列表推导式（[https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions](https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions)）来快速生成基于`key`参数的模拟数据。
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Python list comprehensions are one of my favorite features of the Python language
    as they let you create, transform, and extract data with an expressive and concise
    syntax.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Python列表推导式是我最喜欢的Python语言特性之一，因为它让你能够以简洁而富有表现力的语法创建、转换和提取数据。
- en: 'I can then create a PixieApp that uses the `compute_pdf` function as a `pd_entity`
    to render the data as a table:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以创建一个PixieApp，使用`compute_pdf`函数作为`pd_entity`来将数据呈现为表格：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode10.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode10.py)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode10.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode10.py)'
- en: In the preceding code, for simplicity, I hardcoded the key to `'prefix'` and
    I'll leave it as an exercise to use an input control and the `$val()` directive
    to make it user definable.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，为了简便起见，我将键硬编码为`'prefix'`，接下来留给您作为练习，使用输入控件和`$val()`指令使其可以由用户定义。
- en: Another important thing to notice is the use of the `pd_render_onload` attribute
    in the div that displays the chart. This attribute tells PixieApp to execute the
    kernel request defined by the element immediately after it is loaded into the
    browser DOM.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的重要事项是，在显示图表的div中使用了`pd_render_onload`属性。这个属性告诉PixieApp，在元素加载到浏览器DOM中后，立即执行由该元素定义的内核请求。
- en: 'The results for the preceding PixieApp are shown in the following screenshot:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了前面PixieApp的结果：
- en: '![Invoking the PixieDust display() API using pd_entity attribute](img/B09699_03_06.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![使用pd_entity属性调用PixieDust display() API](img/B09699_03_06.jpg)'
- en: Dynamic DataFrame creation within a PixieApp
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在PixieApp中动态创建DataFrame
- en: 'Back to our *GitHub Tracking* application, let''s now apply the `pd_entity`
    value to the DataFrame loaded from the GitHub Statistics API. We create a method
    called `load_commit_activity,` responsible for loading the data into a pandas
    DataFrame and returning it along with the `pd_options` needed to display the chart:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的*GitHub跟踪*应用程序，现在让我们将`pd_entity`值应用到从GitHub统计API加载的DataFrame中。我们创建一个名为`load_commit_activity`的方法，负责将数据加载到pandas
    DataFrame并返回它和显示图表所需的`pd_options`：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode11.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode11.py)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode11.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode11.py)'
- en: 'The preceding code sends a GET request to GitHub, authenticated with the `github_user`
    and `github_token` variables set up at the beginning of the Notebook. The response
    is a JSON payload that we''ll use to create a pandas DataFrame. Before we can
    create the DataFrame, we need to transform the JSON payload in to the right format.
    Right now, the payload looks like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码向GitHub发送了一个GET请求，并使用在笔记本开始时设置的`github_user`和`github_token`变量进行身份验证。响应是一个JSON负载，我们将使用它来创建一个pandas
    DataFrame。在创建DataFrame之前，我们需要将JSON负载转换为正确的格式。目前，负载看起来像这样：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need to drop the `days` key as it''s not needed for displaying the chart
    and, for proper chart display, we need to convert the value of the `week` key,
    which is a Unix timestamp, into a Python `datetime` object. This transformation
    is done using a Python list comprehension with a simple line of code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要删除`days`键，因为它不需要用于显示图表，而且为了正确显示图表，我们需要将`week`键的值（Unix时间戳）转换为Python的`datetime`对象。此转换通过Python列表推导和一行简单代码完成：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the current implementation, the `load_commit_activity` function is defined
    in its own cell, but we could also have defined it as a member method of the PixieApp.
    As a best practice, using its own cell is very convenient because we can unit
    test the function and iterate rapidly on it without incurring the overhead of
    running the full app every time.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前实现中，`load_commit_activity`函数定义在它自己的单元格中，但我们也可以将其定义为PixieApp的成员方法。作为最佳实践，使用自己的单元格非常方便，因为我们可以对函数进行单元测试并快速迭代，而无需每次都运行整个应用程序，避免了额外的开销。
- en: 'To get the `pd_options` value, we can simply run the function with a sample
    repo information and then call the `display()` API in a separate cell:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`pd_options`值，我们只需运行该函数，使用示例仓库信息，然后在单独的单元格中调用`display()` API：
- en: '![Invoking the PixieDust display() API using pd_entity attribute](img/B09699_03_07.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![使用pd_entity属性调用PixieDust display() API](img/B09699_03_07.jpg)'
- en: Using display() in a separate cell to get the visualization configuration
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在单独的单元格中使用display()获取可视化配置
- en: To obtain the preceding chart, you need to select **Line Chart** and then, in
    the **Options** dialog, drag and drop the `week` column to the **Keys** box and
    the `total` column to the **Values** box. You also need to select Bokeh as the
    renderer. Once done, notice that PixieDust will automatically detect that the
    *x* axis is a datetime and will adjust the rendering accordingly.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取前面的图表，您需要选择**折线图**，然后在**选项**对话框中，将`week`列拖到**键**框中，将`total`列拖到**值**框中。您还需要选择Bokeh作为渲染器。完成后，注意到PixieDust会自动检测到*x*轴是一个日期时间，并相应地调整渲染。
- en: 'Using the **Edit Metadata** button, we can now copy the chart options JSON
    fragment:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**编辑元数据**按钮，我们现在可以复制图表选项的JSON片段：
- en: '![Invoking the PixieDust display() API using pd_entity attribute](img/B09699_03_08.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![使用pd_entity属性调用PixieDust的display() API](img/B09699_03_08.jpg)'
- en: Capturing the display() JSON configuration
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获display() JSON配置
- en: 'And return it in the `load_commit_activity` payload:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其返回到`load_commit_activity`数据负载中：
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are now ready to implement the `do_analyse_type` route in the `RepoAnalysis`
    class, as shown in the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备在`RepoAnalysis`类中实现`do_analyse_type`路由，如以下代码所示：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode12.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode12.py)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode12.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode12.py)'
- en: The route has one argument called `analyse_type,` which we use as a key to find
    the load function in the `analyses` array (notice that I again use a list comprehension
    to do the search quickly). We then call this function passing the repo owner and
    name to get the `vis_info` JSON payload and store the pandas DataFrame into a
    class variable called `pdf`. The returned HTML fragment will then use `pdf` as
    the `pd_entity` value and `vis_info["chart_options"]` as `pd_optio` `ns`. Here
    I use the `tojson` Jinja2 filter ([http://jinja.pocoo.org/docs/templates/#list-of-builtin-filters](http://jinja.pocoo.org/docs/templates/#list-of-builtin-filters))
    to ensure that it is properly escaped in the generated HTML. I am also allowed
    to use the `vis_info` variable even though it's been declared on the stack because
    I used the `@templateArgs` decorator for the function.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该路由有一个名为`analyse_type`的参数，我们用它作为键来查找`analyses`数组中的load函数（注意，我再次使用列表推导式来快速执行查找）。然后，我们调用这个函数，并传入仓库的所有者和名称，以获取`vis_info`
    JSON数据包，并将pandas DataFrame存储在一个名为`pdf`的类变量中。返回的HTML片段将使用`pdf`作为`pd_entity`的值，并使用`vis_info["chart_options"]`作为`pd_options`。在这里，我使用了`tojson`
    Jinja2过滤器（[http://jinja.pocoo.org/docs/templates/#list-of-builtin-filters](http://jinja.pocoo.org/docs/templates/#list-of-builtin-filters)）以确保它在生成的HTML中被正确转义。尽管`vis_info`变量在栈上声明，但由于我为该函数使用了`@templateArgs`装饰器，因此仍然可以使用它。
- en: 'The last thing to do before testing our improved application is to make sure
    the main `GitHubTracking` PixieApp class inherits from the `RepoAnalysis` PixieApp:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试我们改进后的应用程序之前，最后一步是确保主`GitHubTracking` PixieApp类继承自`RepoAnalysis` PixieApp：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode13.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode13.py)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode13.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode13.py)'
- en: 'A screenshot of the Repo Analysis page is shown here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示的是Repo分析页面的截图：
- en: '![Invoking the PixieDust display() API using pd_entity attribute](img/B09699_03_09.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![使用pd_entity属性调用PixieDust的display() API](img/B09699_03_09.jpg)'
- en: GitHub repo commit activity visualization
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub仓库提交活动可视化
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to experiment further, you can find the complete Notebook for the
    *GitHub Tracking application* Part 2 here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步实验，可以在这里找到完整的Notebook，针对*GitHub跟踪应用程序*第2部分：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%202.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%202.ipynb)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%202.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%202.ipynb)'
- en: Invoking arbitrary Python code with pd_script
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pd_script调用任意Python代码
- en: 'In this section, we look at the `pd_script` custom attribute which lets you
    run arbitrary Python code whenever a kernel request is triggered. There are a
    few rules that govern how the Python code is executed:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将查看`pd_script`自定义属性，它可以让你在每次触发内核请求时运行任意的Python代码。执行Python代码时有几个规则需要遵循：
- en: 'The code has access to the PixieApp class using the `self` keyword, as well
    as any variables, functions, and classes defined in the Notebook, as in the following
    example:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可以通过`self`关键字访问PixieApp类，以及Notebook中定义的任何变量、函数和类，如以下示例所示：
- en: '[PRE30]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If a `pd_target` is specified, then any statement using the `print` function
    will be output in the `target` element. This is not the case if no `pd_target`
    is present. In other words, you cannot use `pd_script` to do a full-page refresh
    (you would have to use the `pd_options` attribute instead), as in the example:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指定了`pd_target`，则任何使用`print`函数的语句都会输出到`target`元素中。如果没有`pd_target`，则不会这样做。换句话说，你不能使用`pd_script`来进行页面的完全刷新（你需要使用`pd_options`属性），例如以下示例：
- en: '[PRE31]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode14.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode14.py)'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode14.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode14.py)'
- en: 'If the code contains more than one line, it is recommended to use the `pd_script`
    child element, which lets you write the Python code using multiple lines. When
    using this form, make sure that the code respects the Python language rules for
    indentation, as in the example:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码包含多行，建议使用`pd_script`子元素，这样可以使用多行编写Python代码。在使用这种形式时，确保代码遵循Python语言的缩进规则，如以下示例所示：
- en: '[PRE32]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode15.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode15.py)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode15.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode15.py)'
- en: One common use case for `pd_script` is to update some state on the server before triggering
    a kernel request. Let's apply this technique to our *GitHub Tracking* application
    by adding a checkbox to switch the visualization between a line chart and a statistical
    summary of the data.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd_script`的一个常见使用场景是在触发内核请求之前更新服务器上的某些状态。让我们通过添加一个复选框，在我们的*GitHub Tracking*应用中切换数据的可视化方式，从线图切换为统计数据摘要。'
- en: 'In the fragment HTML returned by `do_analyse_repo`, we add the checkbox element
    used to switch between the chart and the statistics summary:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在`do_analyse_repo`返回的HTML片段中，我们添加了一个复选框元素，用于在图表和统计摘要之间切换：
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the `checkbox` element, we include a `pd_script` attribute that modifies
    a variable state on the server based on the state of the `checkbox` element. We
    use the `$val()` directive to retrieve the value of the `show_stats_{{prefix}}`
    element and compare it with the `true string`. When the user clicks on the checkbox,
    the state is immediately changed on the server and, the next time the user clicks
    on the menu, the stats are showing instead of the charts.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在`checkbox`元素中，我们包含了一个`pd_script`属性，该属性根据`checkbox`元素的状态修改服务器上的变量状态。我们使用`$val()`指令来获取`show_stats_{{prefix}}`元素的值，并将其与`true
    string`进行比较。当用户点击复选框时，状态会立即在服务器上改变，下一次用户点击菜单时，数据显示的是统计数据而不是图表。
- en: 'We now need to change the `do_analyse_type` route to dynamically configure
    `pd_entity` and `chart_options`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要更改`do_analyse_type`路由，以动态配置`pd_entity`和`chart_options`：
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the file here:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode16.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode16.py)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode16.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode16.py)'
- en: '`chart_options` is now a local variable that contains options for displaying
    as a table if `show_stats` is `true` and regular line chart options if not.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`chart_options`现在是一个本地变量，包含了在`show_stats`为`true`时以表格形式显示的选项，以及在不为`true`时作为常规折线图选项的显示方式。'
- en: '`pd_entity` is now set to the `get_pdf()` method, which is responsible for returning the
    appropriate DataFrame based on the `show_stats` variable:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd_entity`现在被设置为`get_pdf()`方法，该方法负责根据`show_stats`变量返回相应的DataFrame：'
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode17.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode17.py)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode17.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode17.py)'
- en: We use the pandas `describe()` method ([https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.describe.html](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.describe.html))
    that returns a DataFrame containing summary statistics, such as count, mean, standard
    deviation, and so on. We also make sure that the first column of this DataFrame
    contains the name of the statistic.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用pandas的`describe()`方法（[https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.describe.html](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.describe.html)），该方法返回一个包含统计摘要的DataFrame，诸如计数、均值、标准差等。我们还确保这个DataFrame的第一列包含统计数据的名称。
- en: The last change we need to make is to initialize the `show_stats` variable because,
    if we don't, then the first time we check it, we'll get an `AttributeError` exception.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进行的最后一次修改是初始化`show_stats`变量，因为如果我们不这样做，那么第一次检查它时会得到`AttributeError`异常。
- en: 'Because of the internal mechanics of using the `@PixieApp` decorator, you can''t
    use the `__init__` method to initialize variables; instead, the PixieApp programming
    model requires you to use a method called `setup,` which is guaranteed to be called
    when the application starts:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用`@PixieApp`装饰器的内部机制，你不能使用`__init__`方法来初始化变量；相反，PixieApp编程模型要求你使用一个名为`setup`的方法，该方法在应用程序启动时保证会被调用：
- en: '[PRE36]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: If you have a class inheriting from other PixieApps, then the PixieApp
    framework will automatically call all `setup` functions from base classes using
    their order of appearance.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：如果你有一个类继承自其他PixieApps，那么PixieApp框架将自动按其出现顺序调用所有基类的`setup`函数。'
- en: 'The following screenshot shows the summary statistics being displayed:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了统计摘要的展示：
- en: '![Invoking arbitrary Python code with pd_script](img/B09699_03_10.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![使用pd_script调用任意Python代码](img/B09699_03_10.jpg)'
- en: Summary statistics for a GitHub repo
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 仓库的统计摘要
- en: Note
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the complete Notebook for the *GitHub Tracking* application Part
    3 here:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到完整的*GitHub跟踪*应用程序第3部分的笔记本：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%203.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%203.ipynb)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%203.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%203.ipynb)'
- en: Making the application more responsive with pd_refresh
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`pd_refresh`使应用程序更具响应性
- en: We want to improve the user experience by making the **Show Statistics** button directly
    show the statistics table instead of having the user to click on the menu again.
    Similar to the menu that loads the **Commit Activity**, we could add a `pd_options`
    attribute to the checkbox with the `pd_target` attribute pointing at the `analyse_vis{{prefix}}`
    element. Instead of duplicating `pd_options` in each of the controls that triggers
    a new display, we could add it once to `analyse_vis{{prefix}}` and have it update
    itself with the `pd_refresh` attribute.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过让**显示统计**按钮直接展示统计表格来改善用户体验，而不是让用户再次点击菜单。类似于加载**提交活动**的菜单，我们可以为复选框添加`pd_options`属性，并将`pd_target`属性指向`analyse_vis{{prefix}}`元素。我们可以将`pd_options`添加到`analyse_vis{{prefix}}`一次，而不是在每个触发新显示的控件中重复添加，然后通过`pd_refresh`属性让它自行更新。
- en: 'The following diagram shows the differences between the two designs:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了两种设计之间的差异：
- en: '![Making the application more responsive with pd_refresh](img/B09699_03_11.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![使用pd_refresh使应用程序更具响应性](img/B09699_03_11.jpg)'
- en: Sequence diagram with and without pd_refresh
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 带有和不带`pd_refresh`的时序图
- en: In both cases, step 1 is to update some state on the server side. In the case
    of the route being invoked by the **Control** shown in step 2, the request specification
    is stored in the control itself, triggering step 3, which is to generate the HTML
    fragment and inject it in the target element. With `pd_refresh`, the control doesn't
    know the `pd_options` to invoke the route, instead, it simply uses `pd_refresh`
    to signal the target element, which in turn will invoke the route. In this design,
    we only need to specify the request once (in the target element) and user control
    needs only to update state before triggering a refresh. This makes the implementation
    much easier to maintain.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种情况下，第一步都是更新服务器端的某些状态。在第2步中由**控件**调用的路由的情况下，请求规范存储在控件本身中，触发第3步，即生成HTML片段并将其注入目标元素。使用`pd_refresh`时，控件不知道`pd_options`来调用路由，相反，它只是使用`pd_refresh`来通知目标元素，而后者将调用路由。在这种设计中，我们只需要在目标元素中指定一次请求，用户控件只需在触发刷新之前更新状态。这使得实现更容易维护。
- en: To better understand the differences between the two designs, let's compare
    both implementations in the `RepoAnalysis` class.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这两种设计之间的差异，我们来对比`RepoAnalysis`类中的两种实现。
- en: 'For the **Analysis** menu, the changes are as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**分析**菜单，变更如下：
- en: 'Before, the control triggered the `analyse_type` route, passing the `{{analysis}}`
    selection as part of the kernel request, targeting `analyse_vis{{prefix}}`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，控件触发了`analyse_type`路由，将`{{analysis}}`选择作为内核请求的一部分，目标是`analyse_vis{{prefix}}`：
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After, the control now stores the selection state as a class field and asks
    the `analyse_vis{{prefix}}` element to refresh itself:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，控件现在将选择状态存储为类字段，并请求`analyse_vis{{prefix}}`元素刷新自身：
- en: '[PRE38]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Similarly, the changes for the **Show Statistics** checkbox are as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，**显示统计信息**复选框的变更如下：
- en: 'Before the checkbox simply set the `show_stats` state in the class; the user had
    to click on the menu again to get the visualization:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，复选框只是简单地在类中设置`show_stats`状态；用户必须再次点击菜单才能获取可视化：
- en: '[PRE39]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After, the visualization is updated as soon as the checkbox is selected, thanks
    to the `pd_refresh` attribute:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，感谢`pd_refresh`属性，复选框一旦被选中，可视化就会立即更新：
- en: '[PRE40]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, the changes for the `analyse_vis{{prefix}}` element are as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`analyse_vis{{prefix}}`元素的变更如下：
- en: 'Before, the element didn''t know how to update itself, it relies on other controls
    to direct a request to the appropriate route:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，元素不知道如何更新自己，它依赖其他控件将请求定向到合适的路由：
- en: '[PRE41]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After, the element carries the kernel configuration to update itself; any control
    can now change state and call refresh:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，元素携带内核配置以更新自身；现在，任何控件都可以更改状态并调用刷新：
- en: '[PRE42]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the complete Notebook for this section for the *GitHub Tracking*
    application Part 4 here:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到本节的完整Notebook，适用于*GitHub跟踪*应用程序第4部分：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%204.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%204.ipynb)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%204.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%204.ipynb)'
- en: Creating reusable widgets
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可重用的小部件
- en: 'The PixieApp programming model provides a mechanism for packaging the HTML and
    logic of a complex UI construct into a widget that can be easily called from other
    PixieApps. The steps to create a widget are as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: PixieApp编程模型提供了一种机制，将复杂UI构造的HTML和逻辑封装成一个小部件，可以轻松地从其他PixieApp中调用。创建小部件的步骤如下：
- en: Create a PixieApp class that will contain the widget.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含小部件的PixieApp类。
- en: 'Create a route with a special `widget` attribute, as in the example:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有特殊`widget`属性的路由，如示例所示：
- en: '[PRE43]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It will be the starting route for the widget.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将是小部件的起始路由。
- en: Create a consumer PixieApp class that inherits from the widget PixieApp class.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个消费者PixieApp类，继承自小部件PixieApp类。
- en: Invoke the widget from a `<div>` element by using the `pd_widget` attribute.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`pd_widget`属性从`<div>`元素调用小部件。
- en: 'Here is an example of how to create a widget and consumer PixieApp class:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建小部件和消费者PixieApp类的示例：
- en: '[PRE44]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code here:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到代码：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode18.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode18.py)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode18.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode18.py)'
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've covered the foundational building blocks of the PixieApp
    programming model that lets you create powerful tools and dashboards directly
    in the Notebook.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了PixieApp编程模型的基础构建模块，使您能够直接在Notebook中创建强大的工具和仪表板。
- en: We've also illustrated PixieApp concepts and techniques by showing how to build
    a *GitHub Tracking* sample application, including detailed code examples. Best
    practices and more advanced PixieApp concepts will be covered in [Chapter 5](ch05.xhtml
    "Chapter 5. Python and PixieDust Best Practices and Advanced Concepts"), *Python
    and PixieDust Best Practices and Advanced Concepts*, including events, streaming,
    and debugging.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过展示如何构建*GitHub Tracking*示例应用程序（包括详细的代码示例）来说明了PixieApp的概念和技术。关于最佳实践和更高级的PixieApp概念将在[第5章](ch05.xhtml
    "Chapter 5. Python and PixieDust Best Practices and Advanced Concepts")中介绍，*Python
    and PixieDust Best Practices and Advanced Concepts*，包括事件、流处理和调试。
- en: By now, you should hopefully have a good idea of how Jupyter Notebooks, PixieDust,
    and PixieApps can help bridge the gap between data scientists and developers by
    enabling them to collaborate from within a single tool, such as Jupyter Notebook.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该已经对Jupyter Notebooks、PixieDust和PixieApps如何通过使数据科学家和开发人员能够在单一工具（如Jupyter
    Notebook）中进行协作有了一个良好的理解。
- en: In the next chapter, we'll show how to free the PixieApp from the Notebook and publish
    it as a web application using the PixieGateway microservice server.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将展示如何将PixieApp从Notebook中解放出来，并使用PixieGateway微服务服务器将其发布为Web应用程序。
