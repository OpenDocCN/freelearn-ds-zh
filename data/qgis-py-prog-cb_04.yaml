- en: Chapter 4. Using Raster Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 使用栅格数据
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Loading a raster layer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载栅格图层
- en: Getting the cell size of a raster layer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取栅格图层的单元格大小
- en: Obtaining the width and height of a raster
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取栅格的宽度和高度
- en: Counting raster bands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算栅格波段数量
- en: Swapping raster bands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换栅格波段
- en: Querying the value of a raster at a specified point
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询指定点的栅格值
- en: Reprojecting a raster
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新投影栅格
- en: Creating an elevation hillshade
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建高程晕渲
- en: Creating vector contours from elevation data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从高程数据创建矢量等高线
- en: Sampling a raster dataset using a regular grid
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用规则网格对栅格数据集进行采样
- en: Adding elevation data to line using a digital elevation model
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数字高程模型将高程数据添加到线
- en: Creating a common extent for rasters
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建栅格的共同范围
- en: Resampling raster resolution
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重采样栅格分辨率
- en: Counting the unique values in a raster
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算栅格中的唯一值
- en: Mosaicing rasters
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栅格镶嵌
- en: Converting a TIFF image to a JPEG image
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将TIFF图像转换为JPEG图像
- en: Creating pyramids for a raster
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为栅格创建金字塔
- en: Converting a pixel location to a map coordinate
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将像素位置转换为地图坐标
- en: Converting a map coordinate to a pixel location
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将地图坐标转换为像素位置
- en: Creating a KML image overlay for a raster
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为栅格创建KML图像叠加
- en: Classifying a raster
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对栅格进行分类
- en: Converting a raster to a vector
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将栅格转换为矢量
- en: Georeferencing a raster from ground control points
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用地面控制点对栅格进行地理配准
- en: Clipping a raster using a shapefile
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用形状文件裁剪栅格
- en: Introduction
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter shows you how to bring raster data into a GIS and create derivative
    raster products using QGIS and Python. QGIS is equally adept at working with raster
    data as with vector data, by incorporating leading-edge open source libraries
    and algorithms, including GDAL, SAGA, and the Orfeo Toolbox. QGIS provides a consistent
    interface to for large array of remote sensing tools. We will switch back and
    forth between visually working with raster data and using QGIS as a processing
    engine via the Processing Toolbox, to completely automating remote sensing workflows.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示如何使用QGIS和Python将栅格数据引入GIS，并创建派生栅格产品。QGIS在处理栅格数据方面与矢量数据一样熟练，通过整合领先的开源库和算法，包括GDAL、SAGA和Orfeo
    Toolbox。QGIS为大量遥感工具提供了一个一致的接口。我们将通过处理工具箱在视觉上处理栅格数据和使用QGIS作为处理引擎之间来回切换，以完全自动化遥感工作流程。
- en: Raster data consists of rows and columns of cells or pixels, with each cell
    representing a single value. The easiest way to think of raster data is as images,
    which is how they are typically represented by software. However, raster datasets
    are not necessarily stored as images. They can also be ASCII text files or **binary
    large objects** (**BLOBs**) in databases.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格数据由行和列的单元格或像素组成，每个单元格代表一个单一值。将栅格数据视为图像是最简单的方法，这也是它们通常由软件表示的方式。然而，栅格数据集不一定以图像的形式存储。它们也可以是ASCII文本文件或数据库中的**二进制大对象**（**BLOBs**）。
- en: Another difference between geospatial raster data and regular digital images
    is their resolution. Digital images express resolution as dots-per-inch, if they
    are printed in full size. Resolution can also be expressed as the total number
    of pixels in the image, defined as megapixels. However, geospatial raster data
    uses the ground distance that each cell represents. For example, a raster dataset
    with a two-feet resolution means that a single cell represents two feet on the
    ground. This also means that only objects larger than two feet can be identified
    visually in the dataset.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 地理空间栅格数据与常规数字图像之间的另一个区别是它们的分辨率。如果以全尺寸打印，数字图像以每英寸点数表示分辨率。分辨率也可以表示为图像中的总像素数，定义为百万像素。然而，地理空间栅格数据使用每个单元格代表的地面距离。例如，具有两英尺分辨率的栅格数据集意味着单个单元格代表地面上的两英尺。这也意味着只有大于两英尺的物体可以在数据集中通过视觉识别。
- en: Raster datasets may contain multiple bands, meaning that different wavelengths
    of light can be collected at the same time over the same area. Often, this range
    is from 3 to 7 bands wide, but it can be several hundred bands wide in hyperspectral
    systems. These bands are viewed individually or swapped in and out as the RGB
    bands of an image. They can also be recombined using mathematics into a derived
    single band image and then recolored using a set number of classes, representing
    similar values within the dataset.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格数据集可能包含多个波段，这意味着可以在同一区域同时收集不同波长的光。通常，这个范围从3到7个波段，但在高光谱系统中，波段可以宽达数百个。这些波段可以单独查看，也可以作为图像的RGB波段进行交换。它们还可以通过数学方法重新组合成派生单波段图像，然后使用一定数量的类别重新着色，这些类别在数据集中表示相似值。
- en: Loading a raster layer
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载栅格图层
- en: The `QGSRasterLayer` API provides a convenient, high-level interface to raster
    data. To use this interface, we must load a layer into QGIS. The API allows you
    to work with a layer without adding it to the map. In this way, we'll load layer
    and then add it to the map.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGSRasterLayer` API为栅格数据提供了一个方便的高级接口。要使用此接口，我们必须将图层加载到QGIS中。API允许你在不将其添加到地图的情况下处理图层。因此，我们将先加载图层，然后再将其添加到地图中。'
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As with the other recipes in this book, you need to create a directory called
    `qgis_data` in our root or user directory, which provides a short pathname without
    spaces. This setup will help prevent any frustrating errors that result from path-related
    issues on a given system. In this recipe, and the others, we'll use a Landsat
    satellite image of the Mississippi Gulf Coast, which you can download from [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的其他食谱一样，你需要在我们的根目录或用户目录中创建一个名为`qgis_data`的目录，这提供了一个没有空格的短路径名。这种设置将有助于防止因系统中的路径相关问题而导致的任何令人沮丧的错误。在本食谱和其他食谱中，我们将使用密西西比湾海岸的Landsat卫星图像，你可以从[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)下载。
- en: Unzip the `SatImage.tif` and `SatImage.tfw` files and place them in a directory
    named `rasters` within your `qgis_data` directory.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 解压`SatImage.tif`和`SatImage.tfw`文件，并将它们放置在`qgis_data`目录下名为`rasters`的目录中。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Now, we'll go through how to load a raster layer and then step by step add it
    to the map
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将逐步介绍如何加载栅格图层，并将其逐步添加到地图中。
- en: Start QGIS.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**插件**菜单中选择**Python控制台**。
- en: 'Then, in the **Python Console**, create the layer by specifying the source
    file and a layer name:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在**Python控制台**中，通过指定源文件和图层名称来创建图层：
- en: '[PRE0]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, ensure that the layer is created as expected. The following command should
    return `True`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确保图层已按预期创建。以下命令应返回`True`：
- en: '[PRE1]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, add the layer to the layer registry:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将图层添加到图层注册表中：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Verify that your QGIS map looks similar to the following image:![How to do it...](img/00029.jpeg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认你的QGIS地图看起来与以下图像相似：![如何操作...](img/00029.jpeg)
- en: QGIS zooms to the extent of the raster layer when it is loaded as shown in this
    example of a Landsat satellite image of the Mississippi Gulf Coast
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当加载栅格图层时，QGIS会自动缩放到图层的范围，如下所示，这是一个密西西比湾海岸的Landsat卫星图像示例。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `QgsRasterLayer` object requires the location of the file and a name for
    the layer in QGIS. The underlying GDAL library determines the appropriate method
    of loading the layer. This approach contrasts with the `QgsVectorLayer()` method,
    which requires you to specify a data provider. Raster layers also have a data
    provider, but unlike vector layers, all raster layers are managed through GDAL.
    One of the best features of QGIS is that it combines the best of breed open source
    geospatial tools into one package. GDAL can be used as a library as we are using
    it here from Python or as a command-line tool.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`QgsRasterLayer`对象需要文件的路径和QGIS中图层的名称。底层GDAL库确定加载图层的适当方法。这种方法与`QgsVectorLayer()`方法不同，后者需要你指定数据提供者。栅格图层也有数据提供者，但与矢量图层不同，所有栅格图层都通过GDAL进行管理。QGIS的其中一个最佳特性是它将最优秀的开源地理空间工具结合到一个软件包中。GDAL可以作为库使用，正如我们在这里从Python中使用它一样，也可以作为命令行工具使用。'
- en: Once we have created the `QgsRasterLayer` object, we do a quick check using
    the `rasterLayer.isValid()` method to see whether the file was loaded properly.
    This method will return `True` if the layer is valid. We won't use this method
    in every recipe; however, it is a best practice, especially when building dynamic
    applications that accept user input. Because most of the PyQGIS API is built around
    C libraries, many methods do not throw exceptions if an operation fails. You must
    use specialized methods to verify the output.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了 `QgsRasterLayer` 对象，我们将使用 `rasterLayer.isValid()` 方法进行快速检查，以查看文件是否正确加载。如果图层有效，此方法将返回
    `True`。我们不会在每一道菜谱中都使用此方法；然而，这是一个最佳实践，尤其是在构建接受用户输入的动态应用程序时。由于 PyQGIS API 大部分基于
    C 库构建，许多方法在操作失败时不会抛出异常。你必须使用专用方法来验证输出。
- en: Finally, we add the layer to the map layer registry, which makes it available
    on the map and in the legend. The registry keeps track of all the loaded layers
    by separating, loading, and visualizing the layers. QGIS allows you to work behind
    the scenes in order to perform unlimited intermediate processes on a layer before
    adding the final product to the map.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将图层添加到地图图层注册表中，使其在地图和图例中可用。注册表通过分离、加载和可视化图层来跟踪所有加载的图层。QGIS 允许你在幕后工作，以便在将最终产品添加到地图之前对图层执行无限的中继过程。
- en: Getting the cell size of a raster layer
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取栅格图层的单元格大小
- en: The first key element of a geospatial raster is the width and height, in pixels.
    The second key element is the ground distance of each pixel, also called the pixel
    size. Once you know the cell size and a coordinate somewhere on the image (usually
    the upper-left corner), you can begin using remote sensing tools on the image.
    In this recipe, we'll query the cell size of a raster.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 地理空间栅格的第一个关键元素是像素宽度和高度。第二个关键元素是每个像素的地面距离，也称为像素大小。一旦你知道单元格大小和图像上的某个坐标（通常是左上角），你就可以开始使用遥感工具处理图像。在本菜谱中，我们将查询栅格的单元格大小。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Once again, we will use the SatImage raster available at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将使用可在 [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)
    获取的 SatImage 栅格。
- en: Place this raster in your `/qgis_data/rasters` directory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将此栅格放入你的 `/qgis_data/rasters` 目录。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will load the raster as a layer and then use the `QgsRasterLayer` API to
    get the cell size for the *x* and *y* axis. To do this, we need to perform the
    following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载栅格作为图层，然后使用 `QgsRasterLayer` API 获取 *x* 和 *y* 轴的单元格大小。为此，我们需要执行以下步骤：
- en: Start QGIS.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **插件** 菜单中选择 **Python 控制台**。
- en: 'Load the layer and validate it:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载图层并验证它：
- en: '[PRE3]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, call the x distance method, which should return 0.00029932313140079714:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，调用 x 距离方法，它应返回 0.00029932313140079714：
- en: '[PRE4]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, call the *y* distance, which should be `0.00029932313140079714`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用 *y* 距离，其值应为 `0.00029932313140079714`：
- en: '[PRE5]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: GDAL provides this information, which is passed through to the layer API. Note
    that while the *x* and *y* values are essentially the same in this case, it is
    entirely possible for the *x* and *y* distances to be different—especially if
    an image is projected or warped in some way.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL 提供此信息，并将其传递给图层 API。请注意，虽然在此情况下 *x* 和 *y* 值本质上相同，但 *x* 和 *y* 距离完全可能是不同的——特别是如果图像以某种方式投影或扭曲。
- en: Obtaining the width and height of a raster
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取栅格的宽度和高度
- en: All raster layers have a width and height in pixels. Because remote sensing
    data can be considered an image as well as an array or matrix, you will often
    see different terms used, including columns and rows or pixels and lines. These
    different terms surface many times within the QGIS API.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所有栅格图层都有像素宽度和高度。因为遥感数据可以被视为图像、数组或矩阵，所以你经常会看到使用不同的术语，包括列和行或像素和线。这些不同的术语在 QGIS
    API 中多次出现。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the SatImage raster again, which is available at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用 SatImage 栅格，它可在 [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)
    获取。
- en: Place this raster in your `/qgis_data/rasters` directory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将此栅格放入你的 `/qgis_data/rasters` 目录。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Start QGIS.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **插件** 菜单中选择 **Python 控制台**。
- en: 'In the Python Console, load the layer and ensure that it is valid:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python控制台中，加载图层并确保它是有效的：
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Check the name of SatImage after unzipping.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解压SatImage后检查其名称。
- en: 'Obtain the layer''s width, which should be `2592`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取图层的宽度，应该是`2592`：
- en: '[PRE7]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, get the raster''s height, which will return `2693`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，获取栅格的高度，这将返回`2693`：
- en: '[PRE8]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The width and height of a raster are critical pieces of information for many
    algorithms, including calculating the map units that the raster occupies.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格的宽度和高度对于许多算法至关重要，包括计算栅格占用的地图单位。
- en: Counting raster bands
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算栅格波段
- en: A raster might have one or more bands. Bands represent layers of information
    within a raster. Each band has the same number of columns and rows.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个栅格可能有一个或多个波段。波段代表栅格中的信息层。每个波段都有相同数量的列和行。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: We will again use the SatImage raster available at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用位于[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)的SatImage栅格。
- en: Place this raster in your `/qgis_data/rasters` directory.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将此栅格放在你的`/qgis_data/rasters`目录中。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will load the layer and then print the band count to the console. To do
    this, we need to perform the following steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载图层并将波段数量打印到控制台。为此，我们需要执行以下步骤：
- en: Start QGIS.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**插件**菜单中选择**Python控制台**。
- en: 'In the Python Console, load the layer and ensure that it is valid:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python控制台中，加载图层并确保它是有效的：
- en: '[PRE9]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, get the band count, which should be `3` in this case:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，获取波段数量，在这种情况下应该是`3`：
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It is important to note that raster bands are not zero-based indexes. When you
    want to access the first band, you reference it as `1` instead of `0`. Most sequences
    within a programming context start with `0`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，栅格波段不是基于零的索引。当你想访问第一个波段时，你将其引用为`1`而不是`0`。在编程环境中，大多数序列从`0`开始。
- en: Swapping raster bands
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换栅格波段
- en: Computer displays render images in the visible spectrum of red, green, and blue
    light (RGB). However, raster images may contain bands outside the visible spectrum.
    These types of rasters make poor visualizations, so you will often want to recombine
    the bands to change the RGB values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机显示器以红、绿、蓝光（RGB）的可视光谱渲染图像。然而，栅格图像可能包含可视光谱之外的波段。这类栅格图像的视觉效果较差，因此你通常会想要重新组合波段以改变RGB值。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: For this recipe, we will use a false-color image, which you can download from
    [https://geospatialpython.googlecode.com/files/FalseColor.zip](https://geospatialpython.googlecode.com/files/FalseColor.zip).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用假彩色图像，你可以从[https://geospatialpython.googlecode.com/files/FalseColor.zip](https://geospatialpython.googlecode.com/files/FalseColor.zip)下载。
- en: Unzip this `tif` file and place it in your `/qgis_data/rasters` directory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 解压这个`tif`文件并将其放在你的`/qgis_data/rasters`目录中。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will load this raster and swap the order of the first and second bands.
    Then, we will add it to the map. To do this, we need to perform the following
    steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载这个栅格并交换第一和第二波段的位置。然后，我们将它添加到地图上。为此，我们需要执行以下步骤：
- en: Start QGIS.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**插件**菜单中选择**Python控制台**。
- en: 'In the **Python Console**, load the layer and ensure that it is valid:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Python控制台**中，加载图层并确保它是有效的：
- en: '[PRE11]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we must access the layer renderer in order to manipulate the order of
    the bands displayed. Note that this change does not affect the underlying data:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须访问图层渲染器以操纵显示的波段顺序。请注意，此更改不会影响底层数据：
- en: '[PRE12]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we will set the `red band` to band `2`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置`红色波段`为波段`2`：
- en: '[PRE13]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we will set the `green band` to band `1`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置`绿色波段`为波段`1`：
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, add the altered raster layer to the map:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将修改后的栅格图层添加到地图上：
- en: '[PRE15]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Load the source image into QGIS as well to compare the results. In the false-color
    image, vegetation appears red, while in the band-swapped image, trees appear a
    more natural green and the water is blue. QGIS uses the RGB order to allow you
    to continue to reference the bands by number. Even though band `2` is displayed
    first, it is still referenced as band `2`. Also, notice that the band order is
    controlled by a `QgsMultiBandColorRenderer` object instantiated by the layer rather
    than the layer itself. The type of renderer that is needed is determined at load
    time by the data type and number of bands.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将源图像也加载到 QGIS 中以比较结果。在假彩色图像中，植被呈红色，而在波段交换图像中，树木呈现更自然的绿色，水呈蓝色。QGIS 使用 RGB 顺序允许你继续通过编号引用波段。尽管波段
    `2` 首先显示，但它仍然被引用为波段 `2`。此外，请注意，波段顺序是由图层实例化的 `QgsMultiBandColorRenderer` 对象控制的，而不是图层本身。所需的渲染器类型在加载时由数据类型和波段数量确定。
- en: There's more...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The `QgsMultiBandColorRenderer()` method has other methods to control contrast
    enhancement for each band, such as `setRedContrastEnhancement()`. You can learn
    more about raster renderers for different types of data in the QGIS API documentation
    at [http://qgis.org/api/classQgsRasterRenderer.html](http://qgis.org/api/classQgsRasterRenderer.html).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`QgsMultiBandColorRenderer()` 方法有其他方法可以控制每个波段的对比度增强，例如 `setRedContrastEnhancement()`。你可以在
    QGIS API 文档中了解有关不同类型数据的栅格渲染器的更多信息，文档地址为 [http://qgis.org/api/classQgsRasterRenderer.html](http://qgis.org/api/classQgsRasterRenderer.html)。'
- en: Querying the value of a raster at a specified point
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在指定点查询栅格的值
- en: A common remote sensing operation is to get the raster data value at a specified
    coordinate. In this recipe, we'll query the data value in the center of the image.
    It so happens that the raster layer will calculate the center coordinate of its
    extent for you.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的遥感操作是在指定坐标处获取栅格数据值。在这个食谱中，我们将查询图像中心的值。碰巧的是，栅格图层会为你计算其范围的中心坐标。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As with many recipes in this chapter, we will again use the SatImage raster,
    which is available at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的许多食谱一样，我们再次使用 SatImage 栅格，该栅格可在 [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)
    获取。
- en: Place this raster in your `/qgis_data/rasters` directory.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将此栅格放在你的 `/qgis_data/rasters` 目录中。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will load the layer, get the center coordinate, and then query the value.
    To do this, we need to perform the following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载图层，获取中心坐标，然后查询值。为此，我们需要执行以下步骤：
- en: 'First, load and validate the layer:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，加载并验证图层：
- en: '[PRE16]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, get the layer''s center point from its `QgsRectangle extent` object,
    which will return a tuple with the *x* and *y* values:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从图层的 `QgsRectangle 范围` 对象获取图层的中心点，它将返回一个包含 *x* 和 *y* 值的元组：
- en: '[PRE17]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, using the layer''s data provider, we can query the data value at that
    point using the `identify()` method:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用图层的数据提供者，我们可以使用 `identify()` 方法查询该点的数据值：
- en: '[PRE18]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Because a query error won''t throw an exception, we must validate the query:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为查询错误不会抛出异常，我们必须验证查询：
- en: '[PRE19]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we can view the query results, which will return a Python dictionary
    with each band number as the key pointing to the data values in that band:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以查看查询结果，它将返回一个Python字典，其中每个波段编号作为键，指向该波段中的数据值：
- en: '[PRE20]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Verify that you get the following output:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证你是否得到以下输出：
- en: '[PRE21]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe is short compared to others, however, we have touched upon several
    portions of the PyQGIS raster API. First start with a raster layer and get the
    extents; we then calculate the center and create a point at the center coordinates,
    and lastly we query the raster at that point. If we were to perform this same,
    seemingly simple operation using the Python API of the underlying GDAL library,
    which does the work, this example would have be approximately seven times longer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他食谱相比，这个食谱很短，但我们已经触及了 PyQGIS 栅格 API 的几个部分。首先从一个栅格图层开始，获取范围；然后我们计算中心并创建一个位于中心坐标的点，最后在该点查询栅格。如果我们使用底层
    GDAL 库的 Python API 来执行这个看似简单的操作，该库负责执行工作，这个例子将大约长七倍。
- en: Reprojecting a raster
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重投影栅格
- en: A core requirement for all geospatial analysis is the ability to change the
    map projection of data in order to allow different layers to be open on the same
    map. Reprojection can be challenging, but QGIS makes it a snap of the fingers.
    Starting with this recipe, we will begin using the powerful QGIS Processing Toolbox.
    The Processing Toolbox wraps over 600 algorithms into a highly consistent API,
    available to Python and also as interactive tools. This toolbox was originally
    a third-party plugin named SEXTANTE, but is now a standard plugin distributed
    with QGIS.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有地理空间分析的核心要求之一是能够更改数据的地图投影，以便允许不同的图层在同一地图上打开。重投影可能具有挑战性，但QGIS使其变得轻而易举。从本食谱开始，我们将开始使用强大的QGIS处理工具箱。处理工具箱将600多个算法包装成一个高度一致的API，可供Python使用，也可以作为交互式工具。这个工具箱最初是一个名为SEXTANTE的第三方插件，但现在它是与QGIS一起分发的标准插件。
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As with many recipes in this chapter, we will use the SatImage raster available
    at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章中许多食谱一样，我们将使用位于[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)的SatImage栅格。
- en: Place this raster in your `/qgis_data/rasters` directory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将此栅格文件放置在您的`/qgis_data/rasters`目录中。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we will use the `gdal warp` algorithm of the `processing` module
    to reproject our image from `EPSG 4326` to `3722`. To do this, we need to perform
    the following steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用`processing`模块的`gdal warp`算法将我们的图像从`EPSG 4326`重新投影到`3722`。为此，我们需要执行以下步骤：
- en: Start QGIS.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**插件**菜单中选择**Python控制台**。
- en: 'The first line of code is used to import the `processing` module:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的第一行用于导入`processing`模块：
- en: '[PRE22]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we load our raster layer and validate it:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们加载我们的栅格图层并验证它：
- en: '[PRE23]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we run the `gdal warp` algorithm by inserting the correct parameters,
    including the layer reference, current projection, desired projection, `None`
    for changes to the resolution, `0` to represent nearest neighbor resampling, `None`
    for additional parameters, `0 –Byte` output raster data type (`1 for int16`),
    and an output name for the reprojected image:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过插入正确的参数来运行`gdal warp`算法，包括图层引用、当前投影、期望投影、`None`用于更改分辨率、`0`表示最近邻重采样、`None`用于其他参数、`0
    –Byte`输出栅格数据类型（`1 for int16`），以及重投影图像的输出名称：
- en: '[PRE24]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Verify that the output image, `warped.tif`, was properly created in the filesystem.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证输出图像`warped.tif`是否已在文件系统中正确创建。
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Processing Toolbox is essentially a wrapper for command-line tools. However,
    unlike the tools it accesses, the toolbox provides a consistent and mostly predictable
    API. Users familiar with Esri's ArcGIS ArcToolbox will find this approach familiar.
    Besides consistency, the toolbox adds additional validation of parameters and
    logging, making these tools more user friendly. It is important to remember that
    you must explicitly import the `processing` module. PyQGIS automatically loads
    the QGIS API, but this module is not yet included. Remember that it was a third-party
    plugin until fairly recently.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 处理工具箱基本上是对命令行工具的包装。然而，与它访问的工具不同，工具箱提供了一个一致且大部分可预测的API。熟悉Esri的ArcGIS ArcToolbox的用户会发现这种方法很熟悉。除了一致性之外，工具箱还增加了参数验证和日志记录，使这些工具更加用户友好。重要的是要记住，您必须显式导入`processing`模块。PyQGIS会自动加载QGIS
    API，但此模块尚未包含。记住，它直到最近还是第三方插件。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `runalg()` method, short for the run algorithm, is the most common way to
    run processing commands. There are other processing methods that you can use though.
    If you want to load the output of your command straight into QGIS, you can swap
    `runalg()` for the `runandload()` method. All arguments to the method remain the
    same. You can also get a list of processing algorithms with descriptions by running
    `processing.alglist()`. For any given algorithm, you can run the `alghelp()` command
    to see the types of input it requires, such as `processing.alghelp("gdalogr:warpproject")`.
    You can also write your own processing scripts based on combinations of algorithms
    and add them to the processing toolbox. There is also a visual modeler for chaining
    processing commands together.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`runalg()` 方法，即运行算法，是运行处理命令最常见的方式。尽管如此，您还可以使用其他处理方法。如果您想直接将命令的输出加载到 QGIS 中，可以将
    `runalg()` 替换为 `runandload()` 方法。该方法的所有参数保持不变。您还可以通过运行 `processing.alglist()`
    获取带有描述的处理算法列表。对于任何给定的算法，您可以通过运行 `alghelp()` 命令来查看它所需的输入类型，例如 `processing.alghelp("gdalogr:warpproject")`。您还可以根据算法的组合编写自己的处理脚本，并将它们添加到处理工具箱中。此外，还有一个用于将处理命令链接在一起的视觉模型器。'
- en: Creating an elevation hillshade
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建高程阴影
- en: A hillshade, or shaded relief, is a technique to visualize elevation data in
    order to make it photorealistic for presentation as a map. This capability is
    part of GDAL and is available in QGIS in two different ways. It is a tool in the
    **Terrain Analysis** menu under the **Raster** menu and it is also an algorithm
    in the Processing Toolbox.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 高程阴影，或称为阴影地形，是一种可视化高程数据的技术，以便将其作为地图以照片逼真的方式展示。这种功能是 GDAL 的一部分，在 QGIS 中有两种不同的方式提供。它位于
    **栅格** 菜单下的 **地形分析** 菜单中的工具，同时也是处理工具箱中的一个算法。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to download a DEM from [https://geospatialpython.googlecode.com/files/dem.zip](https://geospatialpython.googlecode.com/files/dem.zip).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从 [https://geospatialpython.googlecode.com/files/dem.zip](https://geospatialpython.googlecode.com/files/dem.zip)
    下载 DEM。
- en: Unzip the file named `dem.asc` and place it in your `/qgis_data/rasters` directory.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 解压缩名为 `dem.asc` 的文件，并将其放置在您的 `/qgis_data/rasters` 目录中。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we will load the DEM layer and run the `Hillshade` processing
    algorithm against it. To do this, we need to perform the following steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将加载 DEM 图层并对其运行 `高程阴影` 处理算法。为此，我们需要执行以下步骤：
- en: Start QGIS.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **插件** 菜单中选择 **Python 控制台**。
- en: 'Import the `processing` module:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `processing` 模块：
- en: '[PRE25]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Load and validate the layer:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载和验证图层：
- en: '[PRE26]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the `Hillshade` algorithm, providing the algorithm name, layer reference,
    band number, compute edges option, zevenbergen option for smoother terrain, `z`-factor
    elevation exaggeration number, scaling ratio of vertical to horizontal units,
    azimuth (angle of the light source), altitude (height of the light source), and
    output image''s name:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `高程阴影` 算法，提供算法名称、图层引用、波段号、计算边缘选项、zevenbergen 选项以获得更平滑的地形、`z`-因子高程夸张数值、垂直与水平单位的比例、方位角（光源的角度）、高度（光源的高度）以及输出图像的名称：
- en: '[PRE27]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Verify that the output image, `hillshade.tif`, looks similar to the following
    image in QGIS. It should be automatically loaded into QGIS via the `processing.runandload()`
    method:![How to do it...](img/00030.jpeg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 QGIS 中验证输出图像 `hillshade.tif` 是否与以下图像相似。它应通过 `processing.runandload()` 方法自动加载到
    QGIS 中：![如何操作...](img/00030.jpeg)
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Hillshade` algorithm simulates a light source over an elevation dataset
    to make it more visually appealing. Most of the time, the only variables in the
    algorithm you need to alter are the z-factor, azimuth, and altitude to get different
    effects. However, if the resulting image doesn't look right, you may need to alter
    the scale. According to the GDAL documentation, if your DEM is in degrees, you
    should set a scale of `111120`, and if it is in meters, you should set a scale
    of `370400`. This dataset covers a small area such that a scale of 1 is sufficient.
    For more information on these values, see the gdaldem documentation at [http://www.gdal.org/gdaldem.html](http://www.gdal.org/gdaldem.html).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`高程阴影` 算法通过在高度数据集上模拟光源来使其更具视觉吸引力。通常，您只需要更改算法中的 z 因子、方位角和高度以获得不同的效果。然而，如果生成的图像看起来不正确，您可能需要更改比例。根据
    GDAL 文档，如果您的 DEM 以度为单位，则应设置比例 `111120`，如果以米为单位，则应设置比例 `370400`。此数据集覆盖的区域较小，因此比例
    1 就足够了。有关这些值的更多信息，请参阅 [gdaldem](http://www.gdal.org/gdaldem.html) 文档。'
- en: Creating vector contours from elevation data
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从海拔数据创建矢量等高线
- en: Contours provides an effective visualization of terrain data by tracing a line
    along the same elevation to form a loop at set intervals in the dataset. Similar
    to the hillshade capability in QGIS, the **Contour** tool is provided by GDAL
    both as a menu option under the **Raster** menu in the **Extraction category**
    as well as a Processing Toolbox algorithm.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 等高线通过在数据集中以相同的海拔追踪线条，在设定的时间间隔内形成环，从而有效地可视化地形数据。类似于QGIS中的阴影能力，**等高线**工具由GDAL提供，既作为**提取类别**下**栅格**菜单中的菜单选项，也作为处理工具箱算法。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses the DEM from [https://geospatialpython.googlecode.com/files/dem.zip](https://geospatialpython.googlecode.com/files/dem.zip),
    which is used in the other recipes as well.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方使用来自[https://geospatialpython.googlecode.com/files/dem.zip](https://geospatialpython.googlecode.com/files/dem.zip)的DEM，该DEM也用于其他配方。
- en: Unzip the file named `dem.asc` and place it in your `/qgis_data/rasters` directory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 解压名为`dem.asc`的文件，并将其放置在您的`/qgis_data/rasters`目录中。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we will load and validate the DEM layer, add it to the map,
    and then produce and load the contour vector as a layer. To do this, we need to
    perform the following steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们将加载并验证DEM图层，将其添加到地图中，然后生成并加载等高线矢量图层。为此，我们需要执行以下步骤：
- en: Start QGIS.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**插件**菜单中选择**Python控制台**。
- en: Import the `processing` module.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`processing`模块。
- en: '[PRE28]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Load and validate the DEM:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载并验证DEM：
- en: '[PRE29]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the DEM to the map using the `mapLayerRegistry` method:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mapLayerRegistry`方法将DEM添加到地图中：
- en: '[PRE30]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the contour algorithm and draw the results on top of the DEM layer, specifying
    the algorithm name, layer reference, interval between contour lines in map units,
    name of the vector data attribute field that will contain the elevation value,
    any extra parameters, and output filename:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行等高线算法，并在DEM图层上绘制结果，指定算法名称、图层引用、等高线之间的地图单位间隔、将包含海拔值的矢量数据属性字段名称、任何额外参数和输出文件名：
- en: '[PRE31]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Verify that the output in QGIS looks similar to the following screenshot:![How
    to do it...](img/00031.jpeg)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认QGIS中的输出类似于以下截图：![如何操作...](img/00031.jpeg)
- en: This recipe overlays the resulting elevation contours over the DEM as a way
    to convert elevation data into a vector data set.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此配方将生成的海拔等高线叠加到DEM上，作为将海拔数据转换为矢量数据集的方法。
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The contour algorithm creates a vector dataset, that is a shapefile. The layer
    attribute table contains the elevation values for each line. Depending on the
    resolution of the elevation dataset, you may need to change the contour interval
    to stop the contours from becoming too crowded or too sparse at your desired map
    resolution. Usually, autogenerated contours like this are a starting point, and
    you must manually edit the result to make it visually appealing. You may want
    to smoothen lines or remove unnecessary small loops.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 等高线算法创建一个矢量数据集，即shapefile。图层属性表包含每条线的海拔值。根据海拔数据集的分辨率，您可能需要更改等高线间隔，以防止等高线在所需的地图分辨率下过于密集或过于稀疏。通常，像这样的自动生成的等高线是一个起点，您必须手动编辑结果以使其更具视觉吸引力。您可能想要平滑线条或删除不必要的微小环。
- en: Sampling a raster dataset using a regular grid
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用规则网格对栅格数据集进行采样
- en: Sometimes, you need to sample a raster dataset at regular intervals in order
    to provide summary statistics or for quality assurance purposes on the raster
    data. A common way to accomplish this regular sampling is to create a point grid
    over the dataset, query the grid at each point, and assign the results as attributes
    to those points. In this recipe, we will perform this type of sampling over a
    satellite image. QGIS has a tool to perform this operation called regular points,
    which is in the **Vector** menu under **Research Tools**. However, there is no
    tool in the QGIS API to perform this operation programmatically. However, we can
    implement this algorithm directly using Python's `numpy` module.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要以规则间隔对栅格数据集进行采样，以便提供汇总统计信息或对栅格数据进行质量保证。实现这种规则采样的常见方法是在数据集上创建一个点网格，在每个点上查询网格，并将结果作为属性分配给这些点。在此配方中，我们将在卫星图像上执行此类采样。QGIS有一个名为**规则点**的工具来执行此操作，它位于**研究工具**下的**矢量**菜单中。然而，QGIS
    API中没有工具可以以编程方式执行此操作。但是，我们可以直接使用Python的`numpy`模块实现此算法。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the previously used SatImage raster, available at
    [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用之前使用的 SatImage 栅格，可在 [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)
    找到。
- en: Place this raster in your `/qgis_data/rasters` directory.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将此栅格放在您的 `/qgis_data/rasters` 目录中。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The order of operation for this recipe is to load the raster layer, create
    a vector layer in memory, add points at regular intervals, sample the raster layer
    at these points, and then add the sampling data as attributes for each point.
    To do this, we need to perform the following steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的操作顺序是加载栅格图层，在内存中创建一个矢量图层，以规则间隔添加点，在这些点上采样栅格图层，然后将采样数据作为每个点的属性添加。为此，我们需要执行以下步骤：
- en: Start QGIS.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **插件** 菜单中选择 **Python 控制台**。
- en: 'We will need to import the `numpy` module, which is included with QGIS, as
    well as the Qt core module:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导入 `numpy` 模块，它是 QGIS 的一部分，以及 Qt 核心模块：
- en: '[PRE32]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we will create a `spacing` variable to control how far apart the points
    are in map units:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 `spacing` 变量来控制点在地图单位中的间隔距离：
- en: '[PRE33]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we will create an `inset` variable to determine how close to the edge
    of the image the points start, in map units:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个 `inset` 变量来决定点从图像边缘开始有多近，以地图单位计算：
- en: '[PRE34]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we load and validate the raster layer:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们加载并验证栅格图层：
- en: '[PRE35]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we collect the coordinate reference system and extent from the raster
    layer in order to transfer it to the point layer:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们收集栅格图层的坐标参考系统和范围，以便将其传输到点图层：
- en: '[PRE36]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we create an in-memory vector point layer, which won''t be written to
    disk:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个内存中的矢量点图层，它不会写入磁盘：
- en: '[PRE37]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In order to add points to the vector layer, we must access its data provider:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了向矢量图层添加点，我们必须访问其数据提供者：
- en: '[PRE38]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we create the attributes'' fields to store the raster data samples:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建属性字段来存储栅格数据样本：
- en: '[PRE39]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We use the `inset` variable to set up the layer''s extents inside the raster
    layer:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `inset` 变量来设置图层在栅格图层内的范围：
- en: '[PRE40]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we use the `numpy` module to efficiently create the coordinates of the
    points in our regular grid:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用 `numpy` 模块高效地创建我们规则网格中点的坐标：
- en: '[PRE41]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we create a list to store the point features we will create:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个列表来存储我们将创建的点要素：
- en: '[PRE42]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In one loop, we create the point features, query the raster, and then update
    the attribute table. We store the points in a list for now:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个循环中，我们创建点要素，查询栅格，然后更新属性表。我们目前将这些点存储在一个列表中：
- en: '[PRE43]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we pass the list of points to the data provider of the points layer:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将点列表传递给点图层数据提供者：
- en: '[PRE44]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we update the layer''s extents:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们更新图层的范围：
- en: '[PRE45]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we add both the raster and vector layers to the map in the list. The
    last item in the list is on top:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将栅格图层和矢量图层都添加到地图列表中。列表中的最后一项在最上面：
- en: '[PRE46]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we refresh the map to see the result:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们刷新地图以查看结果：
- en: '[PRE47]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows the end result, with one of the points in the
    grid identified using the **Identify Features** map tool. The results dialog shows
    the raster values of the selected point:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了最终结果，其中一个网格点使用 **Identify Features** 地图工具被识别。结果对话框显示了所选点的栅格值：
- en: '![How it works...](img/00032.jpeg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00032.jpeg)'
- en: When you use the QGIS Identification Tool to click on one of the points, the
    results dialog shows the extracted Red, Green, and Blue values from the image.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 QGIS 识别工具点击其中一个点时，结果对话框会显示从图像中提取的红色、绿色和蓝色值。
- en: Using memory layers in QGIS is an easy way to perform quick, one-off operations
    without the overhead of creating files on disk. Memory layers also tend to be
    fast if your machine has the resources to spare.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QGIS 中使用内存图层是执行快速、一次性操作的一种简单方法，无需在磁盘上创建文件的开销。如果您的机器有足够的资源，内存图层通常也很快。
- en: There's more...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this example, we used a regular grid, but we could have just as easily modified
    the numpy-based algorithm to create a random points grid, which in some cases
    is more useful. However, the Processing Toolbox also has a simple algorithm for
    random points called `grass:v.random`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个规则网格，但我们可以轻松修改基于 numpy 的算法来创建一个随机点网格，在某些情况下这可能更有用。然而，处理工具箱还有一个简单的随机点算法，称为
    `grass:v.random`。
- en: Adding elevation data to line vertices using a digital elevation model
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数字高程模型向线顶点添加高程数据
- en: If you have a transportation route through some terrain, it is useful to know
    the elevation profile of that route. This operation can be accomplished using
    the points that make up the line along the route to query a DEM and to assign
    elevation values to that point. In this recipe, we'll do exactly that.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一些地形中的交通路线，了解该路线的高程剖面是有用的。此操作可以使用构成路线的线上的点查询 DEM 并将高程值分配给该点来完成。在这个菜谱中，我们将做
    exactly that。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need an elevation grid and a route. You can download this dataset from
    [https://geospatialpython.googlecode.com/svn/path.zip](https://geospatialpython.googlecode.com/svn/path.zip).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个高程格网和一个路线。您可以从 [https://geospatialpython.googlecode.com/svn/path.zip](https://geospatialpython.googlecode.com/svn/path.zip)
    下载此数据集。
- en: Unzip the `path` directory containing a shapefile and the elevation grid. Place
    the whole path directory in your `qgis_data/rasters` directory.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 解压包含 shapefile 和高程格网的 `path` 目录。将整个路径目录放置在您的 `qgis_data/rasters` 目录中。
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will need two processing algorithms to complete this recipe. We will load
    the raster and vector layers, convert the line feature to points, and then use
    these points to query the raster. The resulting point dataset will serve as the
    elevation profile for the route. To do this, we need to perform the following
    steps:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个处理算法来完成这个菜谱。我们将加载栅格和矢量图层，将线要素转换为点，然后使用这些点查询栅格。生成的点数据集将作为路线的高程剖面。为此，我们需要执行以下步骤：
- en: Start QGIS.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **插件** 菜单中选择 **Python 控制台**。
- en: 'Import the `processing` module:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `processing` 模块：
- en: '[PRE48]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Set up the filenames as variables, so they can be used throughout the script:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件名设置为变量，以便在整个脚本中使用：
- en: '[PRE49]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Load and validate the source layers:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载并验证源图层：
- en: '[PRE50]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Add the layers to the map:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图层添加到地图中：
- en: '[PRE51]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create an intermediate point dataset from the line using a SAGA algorithm in
    the Processing Toolbox:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用处理工具箱中的 SAGA 算法从线创建一个中间点数据集：
- en: '[PRE52]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, use another processing algorithm from SAGA to create the final dataset
    with the grid values assigned to the points:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 SAGA 的另一个处理算法创建最终数据集，并将网格值分配给点：
- en: '[PRE53]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The following image saved from QGIS shows the DEM, route line, and elevation
    points with elevation labels, all displayed on the map, with some styling:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 QGIS 保存的图像显示了数字高程模型（DEM）、路线线和带有高程标签的高程点，所有这些都在地图上显示，并应用了一些样式：
- en: '![How it works...](img/00033.jpeg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/00033.jpeg)'
- en: It is necessary to convert the lines to points because a line feature can only
    have one set of attributes. You can perform the same operation with a polygon
    as well.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 必须将线转换为点，因为线要素只能有一组属性。您也可以用多边形执行相同的操作。
- en: There's more...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Instead of running two algorithms, we can build a processing script that combines
    these two algorithms into one interface and then added it to the toolbox. In the
    Processing Toolbox, there is a category called **Scripts**, which has a tool called
    **Create new script**. Double-clicking on this tool will bring up an editor that
    lets you build your own processing scripts. Depending on your platform, you may
    need to install or configure SAGA to use this algorithm. You can find binary packages
    for Linux at [http://sourceforge.net/p/saga-gis/wiki/Binary%20Packages/](http://sourceforge.net/p/saga-gis/wiki/Binary%20Packages/).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建一个处理脚本，将这两个算法组合到一个界面中，然后将其添加到工具箱中，而不是运行两个算法。在处理工具箱中，有一个名为 **脚本** 的类别，其中有一个名为
    **创建新脚本** 的工具。双击此工具将打开一个编辑器，允许您构建自己的处理脚本。根据您的平台，您可能需要安装或配置 SAGA 以使用此算法。您可以在 [http://sourceforge.net/p/saga-gis/wiki/Binary%20Packages/](http://sourceforge.net/p/saga-gis/wiki/Binary%20Packages/)
    找到 Linux 的二进制包。
- en: 'Also, on Linux, you may need to change the following option:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 Linux 上，您可能需要更改以下选项：
- en: In the **Processing** menu, select **Options…**.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **处理** 菜单中，选择 **选项…**。
- en: In the **Options** dialog, open the **Providers** tree menu and then open the
    **Saga** tree menu.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **选项** 对话框中，打开 **提供者** 树菜单，然后打开 **SAGA** 树菜单。
- en: Uncheck **the Use 2.0.8 syntax** option.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选择 **使用 2.0.8 语法** 选项。
- en: Creating a common extent for rasters
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建栅格的共同范围
- en: 'If you are trying to compare two raster images, it is important that they have
    the same extent and resolution. Most software packages won''t even allow you to
    attempt to compare images if they don''t have the same extent. Sometimes, you
    have images that overlap but do not share a common extent and/or are of different
    resolutions. The following illustration is an example of this scenario:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图比较两个栅格图像，它们必须具有相同的范围和分辨率。大多数软件包甚至不允许你尝试比较没有相同范围的图像。有时，你会有重叠的图像，但它们没有共享一个共同的区域，或者具有不同的分辨率。以下插图是这种情况的一个例子：
- en: '![Creating a common extent for rasters](img/00034.jpeg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![为栅格创建共同范围](img/00034.jpeg)'
- en: In this recipe, we'll take two overlapping images and give them the same extents.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将取两个重叠的图像并给它们相同的范围。
- en: Getting ready
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download two overlapping images from [https://geospatialpython.googlecode.com/svn/overlap.zip](https://geospatialpython.googlecode.com/svn/overlap.zip).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[https://geospatialpython.googlecode.com/svn/overlap.zip](https://geospatialpython.googlecode.com/svn/overlap.zip)下载两个重叠的图像。
- en: Unzip the images and place them in your `/qgis_data/rasters` directory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 解压图像并将它们放在你的`/qgis_data/rasters`目录中。
- en: 'You will also need to download the following processing script from:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要从以下位置下载以下处理脚本：
- en: '[https://geospatialpython.googlecode.com/svn/unify_extents.zip](https://geospatialpython.googlecode.com/svn/unify_extents.zip)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/svn/unify_extents.zip](https://geospatialpython.googlecode.com/svn/unify_extents.zip)'
- en: Unzip the contents and place the scripts in your `\.qgis2\processing\scripts`
    directory, found within your user directory. For example, on a Windows 64-bit
    machine, the directory will be `C:\Users\<username>\.qgis2\processing\scripts`,
    replacing `<username>` with your username.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 解压内容并将脚本放在你的`\.qgis2\processing\scripts`目录中，该目录位于你的用户目录内。例如，在一个Windows 64位机器上，该目录将是`C:\Users\<username>\.qgis2\processing\scripts`，将`<username>`替换为你的用户名。
- en: Make sure you restart QGIS. This script is a modified version of the one created
    by Yury Ryabov on his blog at [http://ssrebelious.blogspot.com/2014/01/unifying-extent-and-resolution-of.html](http://ssrebelious.blogspot.com/2014/01/unifying-extent-and-resolution-of.html).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你重新启动QGIS。此脚本是Yury Ryabov在他的博客[http://ssrebelious.blogspot.com/2014/01/unifying-extent-and-resolution-of.html](http://ssrebelious.blogspot.com/2014/01/unifying-extent-and-resolution-of.html)上创建的修改版本。
- en: The original script used a confirmation dialog that required user interaction.
    The modified script adheres to the Processing Toolbox programming conventions
    and allows you to use it programmatically as well.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 原始脚本使用了一个需要用户交互的确认对话框。修改后的脚本遵循处理工具箱编程约定，并允许你以编程方式使用它。
- en: How to do it...
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The only step in QGIS is to run the newly created processing command. To do
    this, we need to perform the following steps:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在QGIS中，唯一的步骤是运行新创建的处理命令。为此，我们需要执行以下步骤：
- en: Start QGIS.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**插件**菜单中选择**Python控制台**。
- en: 'Import the `processing` module:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`processing`模块：
- en: '[PRE54]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Run the newly added processing algorithm, specifying the algorithm name, path
    to the two images, an optional no data value, an output directory for the unified
    images, and a Boolean flag to load the images into QGIS:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行新添加的处理算法，指定算法名称、两个图像的路径、可选的无数据值、统一图像的输出目录以及一个布尔标志，用于将图像加载到QGIS中：
- en: '[PRE55]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the QGIS table of contents, verify that you have two images named:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在QGIS的目录中，请确认你有以下两个名为的图片：
- en: '[PRE56]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows the common extent for the rasters, by setting
    the transparency of `Image1_unified.tif` to the pixel `0,0,0`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了通过将`Image1_unified.tif`的透明度设置为像素`0,0,0`的栅格的常见范围：
- en: '![How it works...](img/00035.jpeg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00035.jpeg)'
- en: If you don't use the transparency setting, you will see that both images fill
    the non-overlapping areas with no data within the minimum bounding box of both
    extents. The no data values, specified as `-9999`, will be ignored by other processing
    algorithms.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用透明度设置，你会看到两个图像都填充了非重叠区域，在两个范围的最小边界框内没有数据。这些无数据值，指定为`-9999`，将被其他处理算法忽略。
- en: Resampling raster resolution
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重采样栅格分辨率
- en: Resampling an image allows you to change the current resolution of an image
    to a different resolution. Resampling to a lower resolution, also known as downsampling,
    requires you to remove pixels from the image while maintaining the geospatial
    referencing integrity of the dataset. In the QGIS Processing Toolbox, the `gdalogr:warpproject`
    algorithm is used, which is the same as the algorithm used for reprojection.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 重采样图像允许您将图像的当前分辨率更改为不同的分辨率。将分辨率降低，也称为下采样，需要您从图像中删除像素，同时保持数据集的地理空间参照完整性。在QGIS处理工具箱中，使用的是`gdalogr:warpproject`算法，这与用于重投影的算法相同。
- en: Getting ready
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will again use the SatImage raster available at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用可在[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)找到的SatImage栅格数据。
- en: Place this raster in your `/qgis_data/rasters` directory.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 将此栅格放在您的`/qgis_data/rasters`目录中。
- en: How to do it...
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'There''s an extra step in this process, where we will get the current pixel
    resolution of the raster as a reference to calculate the new resolution and pass
    it to the algorithm. To do this, we need to perform the following steps:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中有一个额外的步骤，我们将获取栅格当前像素分辨率作为参考来计算新的分辨率并将其传递给算法。为此，我们需要执行以下步骤：
- en: Start QGIS.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**插件**菜单中选择**Python控制台**。
- en: 'Import the `processing` module:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`processing`模块：
- en: '[PRE57]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Load and validate the raster layer:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载并验证栅格图层：
- en: '[PRE58]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The algorithm requires projection information. We are not changing it, so just
    assign the current projection to a variable:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法需要投影信息。我们不会更改它，所以只需将当前投影分配给一个变量：
- en: '[PRE59]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Get the current pixel''s ground distance and multiply it by 2 to calculate
    half the ground resolution. We only use the X distance because in this case, it
    is identical to the Y distance:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前像素的地面距离并将其乘以2以计算地面分辨率的一半。我们只使用X距离，因为在这种情况下，它与Y距离相同：
- en: '[PRE60]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Run the resampling algorithm, specifying the algorithm name, layer reference,
    input and then output spatial reference system, desired resolution, resampling
    algorithm (`0` is the nearest neighbor), any additional parameters, `0` for output
    raster data type, and the output filename:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行重采样算法，指定算法名称、图层引用、输入和输出空间参考系统、期望的分辨率、重采样算法（`0`是最近邻）、任何附加参数、`0`为输出栅格数据类型，以及输出文件名：
- en: '[PRE61]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Verify that the `resampled.tif` image was created in your `/qgis_data/rasters`
    directory.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认`resampled.tif`图像已创建在您的`/qgis_data/rasters`目录中。
- en: How it works...
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It is counterintuitive at first to reduce the resolution by multiplying it.
    However, by increasing the spatial coverage of each pixel, it takes less pixels
    to cover the extent of the raster. You can easily compare the difference between
    the two in QGIS visually by loading both the images and zooming to an area with
    buildings or other detailed structures and then turning one layer off or on.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，通过乘法降低分辨率似乎是不直观的。然而，通过增加每个像素的空间覆盖范围，覆盖栅格范围所需的像素更少。您可以在QGIS中通过加载两个图像并放大到有建筑物或其他详细结构的区域，然后关闭或打开一个图层来轻松比较两者之间的差异。
- en: Counting the unique values in a raster
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算栅格中的唯一值
- en: Remotely-sensed images are not just pictures; they are data. The value of the
    pixels has meaning that can be automatically analyzed by a computer. The ability
    to run statistical algorithms on a dataset is key to remote sensing. This recipe
    counts the number of unique combinations of pixels across multiple bands. A use
    case for this recipe will be to assess the results of image classification, which
    is a recipe that we'll cover later in this chapter. This recipe is in contrast
    to the typical histogram function, which totals the unique values and the frequency
    of each value per band.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 遥感图像不仅仅是图片；它们是数据。像素的值具有意义，可以由计算机自动分析。在数据集上运行统计算法是遥感的关键。此菜谱计算多个波段中像素唯一组合的数量。此菜谱的一个用例将是评估图像分类的结果，这是一个我们将在本章后面讨论的菜谱。此菜谱与典型的直方图函数相反，后者总计唯一值以及每个波段中每个值的频率。
- en: Getting ready
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the SatImage raster available at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用可在[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)找到的SatImage栅格数据。
- en: Place this raster in your `/qgis_data/rasters` directory.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 将此栅格放在您的`/qgis_data/rasters`目录中。
- en: How to do it...
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This algorithm relies completely on the `numpy` module, which is included with
    PyQGIS. Numpy can be accessed through the GDAL package''s `gdalnumeric` module.
    To do this, we need to perform the following steps:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法完全依赖于`numpy`模块，该模块包含在PyQGIS中。Numpy可以通过GDAL包的`gdalnumeric`模块访问。为此，我们需要执行以下步骤：
- en: Start QGIS.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**插件**菜单中选择**Python控制台**。
- en: 'First, we must import the bridge module called `gdalnumeric`, which connects
    GDAL to Numpy in order to perform an array math on geospatial images:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须导入名为`gdalnumeric`的桥梁模块，该模块将GDAL与Numpy连接，以便在地理空间图像上执行数组数学：
- en: '[PRE62]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, we will load our raster image directly into a multidimensional array:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将直接将我们的栅格图像加载到多维数组中：
- en: '[PRE63]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following code counts the number of pixel combinations in the image:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码计算图像中的像素组合数量：
- en: '[PRE64]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we can take a look at the size of the resulting one-dimensional array
    to get the unique values count:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以查看结果一维数组的大小以获取唯一值计数：
- en: '[PRE65]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Lastly, verify that the result is `16085631`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，验证结果是否为`16085631`。
- en: How it works...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `numpy` module is an open source equivalent of the commercial package `Matlab`.
    You can learn more about Numpy at: [http://Numpy.org](http://Numpy.org).'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy`模块是商业软件包`Matlab`的开源等效物。你可以在[http://Numpy.org](http://Numpy.org)了解更多关于Numpy的信息。'
- en: When you load an image using Numpy, it is loaded as a multidimensional array
    of numbers. Numpy allows you to do an array math on the entire array using operators
    and specialized functions, in the same way you would on variables containing a
    single numeric value.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Numpy加载一个图像时，它被加载为一个多维数组。Numpy允许你使用操作符和专用函数在整个数组上进行数组数学，就像你在包含单个数值变量的变量上做的那样。
- en: Mosaicing rasters
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栅格镶嵌
- en: Mosaicing rasters is the process of fusing multiple geospatial images with the
    same resolution and map projection into one raster. In this recipe, we'll combine
    two overlapping satellite images into a single dataset.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格镶嵌是将具有相同分辨率和地图投影的多个地理空间图像融合成一个栅格的过程。在本菜谱中，我们将结合两个重叠的卫星图像形成一个单一的数据集。
- en: Getting ready
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to download the overlapping dataset from [https://geospatialpython.googlecode.com/svn/overlap.zip](https://geospatialpython.googlecode.com/svn/overlap.zip)
    if you haven't downloaded it from a previous recipe.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有从其他菜谱中下载，你需要从[https://geospatialpython.googlecode.com/svn/overlap.zip](https://geospatialpython.googlecode.com/svn/overlap.zip)下载重叠数据集。
- en: Place the two images in your `/qgis_data/rasters/` directory.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个图像放置在您的`/qgis_data/rasters/`目录中。
- en: How to do it...
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This process is relatively straightforward and has a dedicated algorithm within
    the Processing Toolbox. Perform the following steps:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程相对简单，在处理工具箱中有一个专门的算法。执行以下步骤：
- en: Start QGIS.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**插件**菜单中选择**Python控制台**。
- en: 'Run the gdalogr:merge algorithm, specifying the process name, two images, a
    boolean to use the pseudocolor palette from the first image, a boolean to stack
    each image into a separate band, and the output filename:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行gdalogr:merge算法，指定进程名称、两个图像、一个布尔值以使用第一个图像的伪彩色调色板、一个布尔值以将每个图像堆叠到单独的波段中，以及输出文件名：
- en: '[PRE66]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Verify that the `merged.tif` image has been created and displays the two images
    as a single raster within QGIS.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`merged.tif`图像是否已创建，并在QGIS中显示为单个栅格中的两个图像。
- en: How it works...
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The **merge** processing algorithm is a simplified version of the actual `gdal_merge`
    command-line utility. This algorithm is limited to the GDAL output and aggregates
    the extent of input rasters. It can only merge two rasters at a time. The gdal_merge
    tool has far more options, including additional output formats, the ability to
    merge more than two rasters at once, the ability to control the extent, and more.
    You can also use the GDAL API directly to take advantage of these features, but
    it will take far more code than what is used in this simple example.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**合并**处理算法是实际`gdal_merge`命令行工具的简化版本。此算法仅限于GDAL输出并汇总输入栅格的范围。它一次只能合并两个栅格。gdal_merge工具具有更多选项，包括额外的输出格式、一次合并多个栅格的能力、控制范围的能力等。你还可以直接使用GDAL
    API来利用这些功能，但将需要比这个简单示例更多的代码。'
- en: Converting a TIFF image to a JPEG image
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将TIFF图像转换为JPEG图像
- en: Image format conversion is a part of nearly every geospatial project. Rasters
    come in dozens of different specialized formats, making conversion to a more common
    format a necessity. The GDAL utilities include a tool called `gdal_translate`
    specifically for format conversion. Unfortunately, the algorithm in the Processing
    Toolbox is limited in functionality. For format conversion, it is easier to use
    the core GDAL API.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图像格式转换是几乎所有地理空间项目的一部分。栅格有多种不同的专用格式，将它们转换为更常见的格式是必要的。GDAL工具包括一个名为`gdal_translate`的工具，专门用于格式转换。不幸的是，Processing工具箱中的算法功能有限。对于格式转换，使用核心GDAL
    API更容易。
- en: Getting ready
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the SatImage raster available at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用位于[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)的SatImage栅格。
- en: Place this raster in your `/qgis_data/rasters` directory.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 将此栅格放置在您的`/qgis_data/rasters`目录中。
- en: How to do it...
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we''ll open a TIFFimage using GDAL and copy it to a new dataset
    as a JPEG2000 image, which allows you to use the common JPEG format while maintaining
    geospatial information. To do this, we need to perform the following steps:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用GDAL打开一个TIFF图像并将其复制到一个新的数据集作为JPEG2000图像，这允许您在保持地理空间信息的同时使用常见的JPEG格式。为此，我们需要执行以下步骤：
- en: Start QGIS.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**插件**菜单中选择**Python控制台**。
- en: 'Import the gdal module:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入gdal模块：
- en: '[PRE67]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Get a GDAL driver for our desired format:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取我们所需格式的GDAL驱动程序：
- en: '[PRE68]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Open the source image:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开源图像：
- en: '[PRE69]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Copy the source dataset to the new format:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源数据集复制到新格式：
- en: '[PRE70]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works...
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For the straight format conversion of an image format, the core GDAL library
    is extremely fast and simple. GDAL supports the creation of over 60 raster formats
    and the reading of over 130 raster formats.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图像格式的直接格式转换，核心GDAL库非常快且简单。GDAL支持创建超过60种栅格格式和读取超过130种栅格格式。
- en: Creating pyramids for a raster
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为栅格创建金字塔
- en: Pyramids, or overview images, sacrifice the disk space for map rendering speed
    by storing resampled, lower-resolution versions of images in the file alongside
    the full resolution image. Once you have finalized a raster, building pyramid
    overviews is a good idea.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔，或概述图像，通过在文件中存储与全分辨率图像一起的重新采样、低分辨率图像版本来牺牲磁盘空间以换取地图渲染速度。一旦您最终确定了一个栅格，构建金字塔概述是一个好主意。
- en: Getting ready
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use a false-color image, that you can download from
    [https://geospatialpython.googlecode.com/files/FalseColor.zip](https://geospatialpython.googlecode.com/files/FalseColor.zip).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用一个假彩色图像，您可以从[https://geospatialpython.googlecode.com/files/FalseColor.zip](https://geospatialpython.googlecode.com/files/FalseColor.zip)下载。
- en: Unzip this `TIF` file and place it in your `/qgis_data/rasters` directory.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 解压此`TIF`文件并将其放置在您的`/qgis_data/rasters`目录中。
- en: How to do it...
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The Processing Toolbox has a dedicated algorithm for building pyramid images.
    Perform the following steps to create pyramids for a raster
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Processing工具箱有一个专门用于构建金字塔图像的算法。执行以下步骤以创建栅格金字塔：
- en: Start QGIS.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QGIS。
- en: From the **Plugins** menu, select **Python Console**.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**插件**菜单中选择**Python控制台**。
- en: 'Import the `processing` module:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`processing`模块：
- en: '[PRE71]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Run the `gdalogr:overviews` algorithm, specifying the process name, input image,
    overview levels, the option to remove existing overviews, resampling method (`0`
    is the nearest neighbor), and overview format (`1` is internal):'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`gdalogr:overviews`算法，指定进程名称、输入图像、概述级别、删除现有概述的选项、重采样方法（`0`是最近邻）和概述格式（`1`是内部）：
- en: '[PRE72]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now, load the raster into QGIS by dragging and dropping it from the filesystem
    onto the map canvas.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过从文件系统拖放到地图画布上，将栅格加载到QGIS中。
- en: Double-click on the layer name in the map's legend to open the **Layer Properties**
    dialog.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击地图图例中的图层名称以打开**图层属性**对话框。
- en: In the **Layer Properties** dialog, click on the **Pyramids** tab and verify
    that the layer has multiple resolutions listed.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图层属性**对话框中，点击**金字塔**选项卡并验证图层是否列出了多个分辨率。
- en: How it works...
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The concept of overview images is quite simple. You resample the images several
    times, and then a viewer chooses the most appropriate, smallest file to load on
    the map, depending on scale. The overviews can be stored in the header of the
    file for certain formats or as an external file format. The level of overviews
    needed depends largely on the file size and resolution of your current image,
    but is really arbitrary. In this example, we double the scale by a factor of 2,
    which a is common practice. Most of the zoom tools in the applications will double
    the scale when you click to zoom in. The factor of 2 gives you enough zoom levels,
    so that you usually won't zoom to a level where there is no pyramid image. There
    is a point of diminishing returns if you create too many levels because pyramids
    take up additional disk space. Usually 4 to 5 levels is effective.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 概览图像的概念相当简单。你多次重采样图像，然后查看器根据比例选择最合适的、最小的文件加载到地图上。概览可以存储在文件的头部，对于某些格式或作为外部文件格式。所需概览的级别在很大程度上取决于当前图像的文件大小和分辨率，但实际上是任意的。在这个例子中，我们通过2的倍数放大比例，这是一种常见的做法。大多数应用程序中的缩放工具在点击放大时都会将比例加倍。2的倍数为你提供了足够的缩放级别，因此你通常不会缩放到没有金字塔图像的水平。如果你创建太多级别，因为金字塔会占用额外的磁盘空间，所以会有一个收益递减的点。通常4到5个级别是有效的。
- en: Converting a pixel location to a map coordinate
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将像素位置转换为地图坐标
- en: The ability to view rasters in a geospatial context relies on the conversion
    of pixel locations to coordinates on the ground. Sooner or later when you use
    Python to write geospatial programs, you'll have to perform this conversion yourself.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在地理空间环境中查看栅格的能力依赖于将像素位置转换为地面坐标。迟早，当你使用Python编写地理空间程序时，你必须自己执行这种转换。
- en: Getting ready
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use the SatImage raster available at:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在以下位置可用的SatImage栅格：
- en: '[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)'
- en: Place this raster in your `/qgis_data/rasters` directory.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 将此栅格放置在您的`/qgis_data/rasters`目录中。
- en: How to do it...
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will use GDAL to extract the information needed to convert pixels to coordinates
    and then use pure Python to perform the calculation. We'll use the center pixel
    of the image as the location to convert.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用GDAL提取将像素转换为坐标所需的信息，然后使用纯Python执行计算。我们将使用图像的中心像素作为转换的位置。
- en: Start QGIS.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QGIS。
- en: From the **Plugins** menu select **Python Console**
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**插件**菜单选择**Python控制台**
- en: 'We need to import the `gdal` module:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导入`gdal`模块：
- en: '[PRE73]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, we need to define the reusable function that does the conversion accepting
    a GDAL `GeoTransform` object containing the raster georeferencing information
    and the pixel''s *x*,*y* values:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要定义一个可重用的函数，该函数执行转换，接受包含栅格地理参考信息的GDAL `GeoTransform`对象以及像素的*x*、*y*值：
- en: '[PRE74]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now, we'll open the image in GDAL
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用GDAL打开图像
- en: '[PRE75]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, get the `GeoTransform` object from the image:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从图像中获取`GeoTransform`对象：
- en: '[PRE76]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, calculate the center pixel of the image:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，计算图像的中心像素：
- en: '[PRE77]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, perform the conversion by calling our function:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过调用我们的函数来执行转换：
- en: '[PRE78]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Verify the coordinates returned are close to the following output:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证返回的坐标是否接近以下输出：
- en: '[PRE79]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How it works...
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Pixel conversion is just a scaling ratio between two planes, the image coordinate
    system and the Earth coordinate system. When dealing with large areas, this conversion
    can become a more complex projection because the curvature of the Earth comes
    into play. The GDAL website has a nice tutorial about the geotransform object
    at the following URL: [http://www.gdal.org/gdal_tutorial.html](http://www.gdal.org/gdal_tutorial.html)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 像素转换只是两个平面之间的缩放比例，即图像坐标系和地球坐标系。当处理大面积时，这种转换可能成为一个更复杂的投影，因为地球的曲率会发挥作用。GDAL网站在以下URL有一个关于地理变换对象的优秀教程：[http://www.gdal.org/gdal_tutorial.html](http://www.gdal.org/gdal_tutorial.html)
- en: Converting a map coordinate to a pixel location
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将地图坐标转换为像素位置
- en: When you receive a map coordinate as user input or from some other source, you
    must be able to convert it back to the appropriate pixel location on a raster.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 当你收到一个地图坐标作为用户输入或来自其他来源时，你必须能够将其转换回栅格上的适当像素位置。
- en: Getting ready
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use the SatImage raster available at:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在以下位置可用的SatImage栅格：
- en: '[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)'
- en: Place this raster in your `/qgis_data/rasters` directory.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 将此栅格文件放置在您的`/qgis_data/rasters`目录中。
- en: How to do it...
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Similar to the previous recipe, we will define a function, extract the GDAL
    `GeoTransform` object from our raster, and use it for the conversion.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的菜谱类似，我们将定义一个函数，从我们的栅格中提取GDAL `GeoTransform`对象，并用于转换。
- en: Start QGIS.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QGIS。
- en: From the **Plugins** menu select **Python Console**
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**插件**菜单中选择**Python控制台**
- en: 'We need to import the gdal module:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导入gdal模块：
- en: '[PRE80]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then, we need to define the reusable function that does the coordinate to pixel
    conversion. We get the GDAL `GeoTransform` object containing the raster georeferencing
    information and the map *x*,*y* coordinates:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要定义一个可重用的函数，该函数执行坐标到像素的转换。我们获取包含栅格地理参考信息的GDAL `GeoTransform`对象和地图*x*，*y*坐标：
- en: '[PRE81]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next, we open the source image:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们打开源图像：
- en: '[PRE82]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, get the GeoTransform object:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，获取GeoTransform对象：
- en: '[PRE83]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Finally, perform the conversion:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，执行转换：
- en: '[PRE84]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Verify your output is the following:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您的输出如下：
- en: '[PRE85]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: How it works...
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This conversion is very reliable over small areas, but as the area of interest
    expands you must account for elevation as well, which requires a far more complex
    transformation depending on how an image was generated.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换在小范围内非常可靠，但随着感兴趣区域的扩大，您还必须考虑高程，这需要一个更复杂的转换，具体取决于图像是如何生成的。
- en: Note
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following presentation from the University of Massachusetts does an excellent
    job of explain the challenges of georeferencing data:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 马萨诸塞大学提供的以下演示文稿出色地解释了地理参考数据的挑战：
- en: '[http://courses.umass.edu/nrc592g-cschweik/pdfs/Class_3_Georeferencing_concepts.pdf](http://courses.umass.edu/nrc592g-cschweik/pdfs/Class_3_Georeferencing_concepts.pdf)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[UMass大学课程资料](http://courses.umass.edu/nrc592g-cschweik/pdfs/Class_3_Georeferencing_concepts.pdf)'
- en: Creating a KML image overlay for a raster
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为栅格创建KML图像叠加
- en: '**GoogleEarth** is one of the most widely available geospatial viewers in existence.
    The XML data format used by GoogleEarth for geospatial data is called **KML**.
    The Open Geospatial Consortium adopted KML as a data standard. Converting rasters
    into a **KML** overlay compressed in a **KMZ** archive file is a very popular
    way to make data available to end users who know how to use GoogleEarth.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '**GoogleEarth**是现有最广泛使用的地理空间查看器之一。GoogleEarth用于地理空间数据的XML数据格式称为**KML**。开放地理空间联盟采用了KML作为数据标准。将栅格转换为压缩在**KMZ**存档文件中的**KML**叠加是一种非常流行的将数据提供给知道如何使用GoogleEarth的最终用户的方式。'
- en: Getting ready
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use the SatImage raster again available at the following URL if you
    haven''t downloaded it from previous recipes:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未从之前的菜谱中下载，我们将再次使用以下URL中可用的SatImage栅格：
- en: '[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '[SatImage下载链接](https://geospatialpython.googlecode.com/files/SatImage.zip)'
- en: Place this raster in your `/qgis_data/rasters` directory.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 将此栅格文件放置在您的`/qgis_data/rasters`目录中。
- en: How to do it...
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, we'll create a **KML** document describing our image. Then we'll
    convert the image to a **JPEG** in memory using GDAL's specialized virtual file
    system and write all of the contents directly to a **KMZ** file using Python's
    `zipfile` module.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将创建一个描述我们图像的**KML**文档。然后，我们将使用GDAL的专用虚拟文件系统将图像转换为内存中的**JPEG**，并使用Python的`zipfile`模块将所有内容直接写入**KMZ**文件。
- en: Start QGIS.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QGIS。
- en: From the **Plugins** menu select **Python Console**
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**插件**菜单中选择**Python控制台**
- en: 'We need to import the `gdal` module as well as the Python `zipfile` module:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导入`gdal`模块以及Python的`zipfile`模块：
- en: '[PRE86]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, we''ll open our satellite image in `gdal`:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`gdal`中打开我们的卫星图像：
- en: '[PRE87]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, we''ll create a variable with our virtualized file name, using the GDAL
    virtual file naming convention beginning with `vismem`:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用以`vismem`开头的GDAL虚拟文件命名约定，创建一个包含虚拟文件名的变量：
- en: '[PRE88]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We create the JPEG gdal driver object for the output format:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为输出格式创建JPEG gdal驱动程序对象：
- en: '[PRE89]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, we can open the source file:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以打开源文件：
- en: '[PRE90]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Then, we can copy that source file to our virtual JPEG:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将源文件复制到我们的虚拟JPEG：
- en: '[PRE91]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, we are going to create a raster layer in QGIS for our raster, just for
    the benefit of it calculating the image''s extent:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为我们的栅格创建一个QGIS栅格图层，仅为了计算图像的范围：
- en: '[PRE92]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Next, we get the layer''s extent:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们获取图层的范围：
- en: '[PRE93]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Next, we format our KML document template and insert the image extents:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们格式化KML文档模板并插入图像范围：
- en: '[PRE94]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, we open our virtual JPEG in GDAL and prepare it for reading:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们打开我们的虚拟JPEG文件在GDAL中，并为其读取做准备：
- en: '[PRE95]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Finally, we write our KML document and virtual JPEG into a zipped KMZ file:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将我们的KML文档和虚拟JPEG写入一个压缩的KMZ文件：
- en: '[PRE96]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Now, open the KMZ file in GoogleEarth and verify it looks like the following
    screenshot:![How to do it...](img/00036.jpeg)
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在GoogleEarth中打开KMZ文件，并确认它看起来像以下截图：![如何操作...](img/00036.jpeg)
- en: How it works...
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: KML is a straightforward XML format. There are entire libraries in Python dedicated
    to reading and writing it, but for a simple export to share an image or two, the
    PyQGIS console is more than adequate. While we run this script in the QGIS Python
    interpreter, it could be run outside of QGIS using just GDAL.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: KML是一个简单的XML格式。在Python中，有专门的库用于读取和写入它，但对于简单的导出以共享一个或两个图像，PyQGIS控制台已经足够了。虽然我们在这个脚本中运行QGIS
    Python解释器，但它也可以仅使用GDAL在QGIS之外运行。
- en: There's more...
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The **Orfeo Toolbox** has a processing algorithm called `otb:imagetokmzexport`
    which has a much more sophisticated KMZ export tool for images.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**Orfeo Toolbox**有一个名为`otb:imagetokmzexport`的处理算法，它为图像提供了一个更复杂的KMZ导出工具。'
- en: Classifying a raster
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栅格分类
- en: Image classification is one of the most complex aspects of remote sensing. While
    QGIS is able to color pixels based on values for visualization, it stops short
    of doing much classification. It does provide a Raster Calculator tool where you
    can perform arbitrary math formulas on an image, however it does not attempt to
    implement any common algorithms. The Orfeo Toolbox is dedicated purely to remote
    sensing and includes an automated classification algorithm called K-means clustering,
    which groups pixels into an arbitrary number of similar classes to create a new
    image. We can do a nice demonstration of image classification using this algorithm.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 图像分类是遥感中最复杂的方面之一。虽然QGIS能够根据值对像素进行着色以进行可视化，但它并没有进行太多的分类。它确实提供了一个栅格计算器工具，你可以在图像上执行任意数学公式，然而它并没有尝试实现任何常见算法。Orfeo
    Toolbox完全致力于遥感，包括一个名为K-means聚类的自动分类算法，该算法将像素分组到任意数量的相似类别中，以创建一个新的图像。我们可以使用这个算法做一个很好的图像分类演示。
- en: Getting ready
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will use a false color image which you can download here:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用一个假彩色图像，你可以从这里下载：
- en: '[https://geospatialpython.googlecode.com/files/FalseColor.zip](https://geospatialpython.googlecode.com/files/FalseColor.zip)'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/files/FalseColor.zip](https://geospatialpython.googlecode.com/files/FalseColor.zip)'
- en: Unzip this TIFF file and place it in your `/qgis_data/rasters` directory.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 解压这个TIFF文件，并将其放置在你的`/qgis_data/rasters`目录中。
- en: How to do it...
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: All we need to do is run the algorithm on our input image. The important parameters
    are the second, third, sixth, and tenth parameters. They define the input image
    name, the amount of RAM to dedicate to the task, the number of classes, and the
    output name respectively.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是在我们输入的图像上运行算法。重要的参数是第二个、第三个、第六个和第十个参数。它们分别定义了输入图像名称、分配给任务的RAM量、类别数量和输出名称。
- en: 'First, import the `processing` module in the QGIS **Python Console**:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在QGIS **Python控制台**中导入`processing`模块：
- en: '[PRE97]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Next, run the `otb` algorithm using the `processing.runandload()` method to
    display the output in QGIS:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`processing.runandload()`方法运行`otb`算法，以在QGIS中显示输出：
- en: '[PRE98]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: When the image loads in QGIS, double click the layer name in the **Table of
    Contents**.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当图像在QGIS中加载时，双击**内容表**中的图层名称。
- en: In the **Layer Properties** dialog, choose **Style**.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图层属性**对话框中，选择**样式**。
- en: Change the **Render type** menu to **Singleband pseudocolor**.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**渲染类型**菜单更改为**单波段伪彩色**。
- en: Change the **color map** menu on the right to **Spectral**.
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将右侧的**颜色图**菜单更改为**光谱**。
- en: Click the **Classify** button.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**分类**按钮。
- en: Choose the **Ok** button at the bottom of the window.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口底部选择**确定**按钮。
- en: Verify your image looks similar to the following image, except without the class
    labels:![How to do it...](img/00037.jpeg)
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认你的图像看起来与以下图像相似，但不要有类别标签：![如何操作...](img/00037.jpeg)
- en: How it works...
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Keeping the class number low allows the automated classification algorithm
    to focus on the major features in the image and helps when us to achieve a very
    high level of accuracy determining overall land use. Additional automated classification
    would require supervised analysis with training data sets and more in-depth preparation.
    But the overall concept would remain the same. QGIS has a nice plugin for semi-automatic
    classification. You can learn more about it at the following URL:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 保持类别编号低，可以让自动化分类算法专注于图像中的主要特征，并在我们达到非常高的整体土地利用准确性时有所帮助。额外的自动化分类将需要带有训练数据集的监督分析和更深入的准备。但整体概念将保持不变。QGIS有一个用于半自动分类的插件。您可以在以下URL了解更多信息：
- en: '[https://plugins.qgis.org/plugins/SemiAutomaticClassificationPlugin/](https://plugins.qgis.org/plugins/SemiAutomaticClassificationPlugin/)'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://plugins.qgis.org/plugins/SemiAutomaticClassificationPlugin/](https://plugins.qgis.org/plugins/SemiAutomaticClassificationPlugin/)'
- en: Converting a raster to a vector
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将栅格转换为矢量
- en: Raster datasets represent real-world features efficiently but can have limited
    usage for geospatial analysis. Once you have classified an image into a manageable
    data set, you can convert those raster classes into a vector data set for more
    sophisticated GIS analysis. GDAL has a function for this operation called **polygonize.**
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格数据集有效地表示现实世界的特征，但在地理空间分析中可能用途有限。一旦将图像分类为可管理的数据集，您可以将这些栅格类别转换为矢量数据集，以便进行更复杂的GIS分析。GDAL有一个名为
    **polygonize** 的函数用于此操作。
- en: Getting ready
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need to download the following classified raster and place it in your
    `/qgis_data/rasters` directory:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要下载以下分类栅格并将其放置在您的 `/qgis_data/rasters` 目录中：
- en: '[https://geospatialpython.googlecode.com/svn/landuse_bay.zip](https://geospatialpython.googlecode.com/svn/landuse_bay.zip)'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/svn/landuse_bay.zip](https://geospatialpython.googlecode.com/svn/landuse_bay.zip)'
- en: How to do it...
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Normally, you would save the output of this recipe as a shapefile. We won't
    specify an output file name. The Processing Toolbox will assign it a temporary
    filename and return that filename. We'll simply load the temporary file into QGIS.
    The algorithm allows you to write to a shapefile by specifying it as the last
    parameter.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会将此菜谱的输出保存为形状文件。我们不会指定输出文件名。处理工具箱将分配一个临时文件名并返回该文件名。我们只需将临时文件加载到QGIS中。该算法允许您通过将其指定为最后一个参数来写入形状文件。
- en: 'In the QGIS **Python Console**, import the `processing` module:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在QGIS **Python控制台**中导入`processing`模块：
- en: '[PRE99]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Next, run the algorithm specifying the process name, input image, the field
    name for the class number, and optionally the output shapefile:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行算法，指定进程名称、输入图像、类别编号的字段名称，以及可选的输出形状文件：
- en: '[PRE100]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'You should get a vector layer with three classes, defined as polygons, denoting
    developed areas. In the sample image below, we have assigned unique colors to
    each class: developed area (darkest), water (midtones), and land (lightest color):![How
    to do it...](img/00038.jpeg)'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该获得一个包含三个类别的矢量图层，定义为多边形，表示已开发区域。在下面的示例图像中，我们为每个类别分配了独特的颜色：开发区域（最暗），水域（中间色调），和陆地（最浅颜色）：![如何操作...](img/00038.jpeg)
- en: How it works...
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: GDAL looks for clusters of pixels and creates polygons around them. It is important
    to have as few classes as possible. If there is too much variation in the pixels,
    then GDAL will create a polygon around each pixel in the image. You turn this
    recipe into a true analysis product by using the recipe in [Chapter 1](part0015_split_000.html#page
    "Chapter 1. Automating QGIS"), *Calculating the Area of a Polygon* to quantify
    each class of land use.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL寻找像素簇并在其周围创建多边形。尽可能少地使用类别很重要。如果像素之间存在太多差异，那么GDAL将在图像中的每个像素周围创建一个多边形。您可以通过使用[第1章](part0015_split_000.html#page
    "第1章. 自动化QGIS")中的菜谱 *计算多边形面积* 来将此菜谱转换为真正的分析产品，以量化每种土地利用类别。
- en: Georeferencing a raster from control points
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从控制点进行栅格地理配准
- en: Sometimes a raster that represents features on the earth is just an image with
    no georeferencing information. That is certainly the case with historical scanned
    maps. However, you can use a referenced data set of the same area to create tie
    points, or ground control points, and then use an algorithm to warp the image
    to fit the model of the earth. It is common for data collection systems to just
    store the **ground control points (GCP)** along with the raster to keep the image
    in as raw a format as possible. Each change to an image holds the possibility
    of losing data. So georeferencing an image on demand is often the best approach.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，代表地球特征的栅格图可能只是一个没有地理参照信息的图像。历史扫描地图的情况就是这样。然而，你可以使用同一区域的参考数据集来创建连接点，或称为地面控制点，然后使用算法将图像扭曲以适应地球模型。数据收集系统通常只存储与栅格一起的**地面控制点（GCP**），以尽可能保持图像的原始格式。每次对图像的更改都可能导致数据丢失。因此，按需地理参照图像通常是最佳方法。
- en: In this recipe, we'll georeference a historical survey map of the Louisiana
    and Mississippi Gulf Coast from 1853\. The control points were manually created
    with the QGIS Georeferencer plugin and saved to a standardized control point file.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将地理参照1853年路易斯安那州和密西西比州墨西哥湾沿岸的历史调查地图。控制点是使用QGIS地理参照插件手动创建并保存到标准控制点文件的。
- en: Getting ready
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Download the following zip file, unzip the contents, and put the `georef` directory
    in `/qgis_data/rasters`:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 下载以下zip文件，解压内容，并将`georef`目录放在`/qgis_data/rasters`：
- en: '[https://geospatialpython.googlecode.com/svn/georef.zip](https://geospatialpython.googlecode.com/svn/georef.zip)'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/svn/georef.zip](https://geospatialpython.googlecode.com/svn/georef.zip)'
- en: How to do it...
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will use a low-level module of the processing API to access some specialized
    GDAL utility functions.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用处理API的低级模块来访问一些专门的GDAL实用工具函数。
- en: 'In the QGIS **Python Console**, import the `GdalUtils` module:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在QGIS **Python控制台**中，导入`GdalUtils`模块：
- en: '[PRE101]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now, we will set up some path names for source and target data, which will
    be used multiple times:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为源数据和目标数据设置一些路径名，这些路径名将被多次使用：
- en: '[PRE102]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Next, we will open up our GCP file and read past the header line:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将打开我们的GCP文件并读取标题行：
- en: '[PRE103]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Then, we can begin building our first gdal utility command:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以开始构建我们的第一个gdal实用工具命令：
- en: '[PRE104]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Loop through the GCP file and append the points to the command arguments:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历GCP文件并将点追加到命令参数中：
- en: '[PRE105]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now, add the input and output file to the command:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将输入和输出文件添加到命令中：
- en: '[PRE106]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Next, we can execute the first command:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以执行第一个命令：
- en: '[PRE107]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Next, we change the command to warp the image:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将命令更改为扭曲图像：
- en: '[PRE108]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Add the output of the last command as the input and use the final image path
    as the output:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上一个命令的输出添加为输入，并使用最终图像路径作为输出：
- en: '[PRE109]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now, run the warp command to complete the task:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行扭曲命令以完成任务：
- en: '[PRE110]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: How it works...
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The GdalUtils API exposes the underlying tools used by the Processing Toolbox
    algorithm, yet provides a robust cross-platform approach that is better than other
    traditional methods of accessing external programs from Python. If you pull the
    output image into QGIS and compare it to the USGS coastline shapefile, you can
    see the results are fairly accurate and could be improved with additional control
    points and referenced data. The number of GCPs required for a given image is a
    matter of trial and error. Adding more GCPs won''t necessarily lead to better
    results. You can find out more about creating GCPs in the QGIS documentation:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: GdalUtils API公开了Processing工具箱算法使用的底层工具，同时提供了一个比其他传统方法更好的跨平台方法，这些传统方法是从Python访问外部程序。如果你将输出图像拖入QGIS并与USGS海岸线shapefile进行比较，你可以看到结果相当准确，并且可以通过添加更多的控制点和参考数据来改进。对于给定图像所需的GCP数量是一个试错的问题。添加更多的GCP并不一定会导致更好的结果。你可以在QGIS文档中了解更多关于创建GCP的信息：
- en: '[http://docs.qgis.org/2.6/en/docs/user_manual/plugins/plugins_georeferencer.html](http://docs.qgis.org/2.6/en/docs/user_manual/plugins/plugins_georeferencer.html)'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.qgis.org/2.6/en/docs/user_manual/plugins/plugins_georeferencer.html](http://docs.qgis.org/2.6/en/docs/user_manual/plugins/plugins_georeferencer.html)'
- en: Clipping a raster using a shapefile
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用shapefile裁剪栅格
- en: Sometimes you need to use a subset of an image which covers an area of interest
    for a project. In fact, areas of an image outside your area of interest can distract
    your audience from the idea you are trying to convey. Clipping a raster to a vector
    boundary allows you to only use the portions of the raster you need. It can also
    save processing time by eliminating areas outside your area of interest.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要使用图像的一部分，这部分覆盖了项目感兴趣的区域。实际上，图像中你感兴趣区域外的区域可能会分散听众对你试图传达的想法的注意力。将栅格裁剪到矢量边界可以让你只使用所需的栅格部分。这还可以通过消除你感兴趣区域外的区域来节省处理时间。
- en: Getting ready
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use the SatImage raster again available at the following URL if you
    haven''t downloaded it from previous recipes:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前没有从之前的菜谱中下载，我们将再次使用以下URL中可用的SatImage栅格：
- en: '[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)'
- en: Place this raster in your `/qgis_data/rasters` directory.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 将此栅格放置在你的`/qgis_data/rasters`目录中。
- en: How to do it...
  id: totrans-566
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Clipping is a common operation and GDAL is well suited for it.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 裁剪是一种常见的操作，GDAL非常适合进行这项操作。
- en: 'First, in the QGIS **Python Console**, run import the processing module:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在QGIS的**Python控制台**中运行导入处理模块：
- en: '[PRE111]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Next, run the processing command specifying the input image name as the second
    argument and the output image as the seventh argument:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行处理命令，将输入图像名称作为第二个参数，输出图像作为第七个参数：
- en: '[PRE112]'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Verify your `output` raster looks like the following screenshot:![How to do
    it...](img/00039.jpeg)
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证你的`输出`栅格看起来像以下截图：![如何操作...](img/00039.jpeg)
- en: How it works...
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: GDAL creates a no data mask outside the shapefile boundary. To the extent of
    the original image remains the same, however you no longer visualize it and processing
    algorithms will ignore the no data values.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL在shapefile边界外创建了一个无数据掩码。原始图像的尺寸保持不变，但你不再可视化它，处理算法将忽略无数据值。
