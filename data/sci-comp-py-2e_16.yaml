- en: Symbolic Computations - SymPy
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 符号计算 - SymPy
- en: In this chapter, we will give a brief introduction to using Python for symbolic
    computations. There is powerful software on the market for performing symbolic
    computations, for example, Maple™ or Mathematica™. But sometimes, it might be
    favorable to make symbolic calculations in the language or framework you are used
    to. At this stage of the book, we assume that this language is Python, so we seek
    a tool in Python—the module SymPy.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简要介绍如何使用Python进行符号计算。市场上有许多强大的软件可以执行符号计算，例如Maple™或Mathematica™。但有时，可能更倾向于在自己熟悉的语言或框架中进行符号计算。在本书的这一阶段，我们假设这种语言是Python，因此我们寻找一个Python工具——模块SymPy。
- en: A complete description of SymPy, if even possible, would fill an entire book,
    and that is not the purpose of this chapter. Instead, we will stake out a path
    into this tool by examining some guiding examples, giving a flavor of the potential
    of this tool as a complement to NumPy and SciPy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对SymPy的完整描述，如果有可能的话，将填满整本书，而这并非本章的目的。相反，我们将通过一些指导性示例来为您指明通向该工具的道路，展示其作为NumPy和SciPy的补充工具的潜力。
- en: 16.1 What are symbolic computations?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.1 什么是符号计算？
- en: All computations we did so far in this book were so-called numeric computations.
    These were a sequence of operations mainly on floating-point numbers. It is the
    nature of numeric computations that the result is an approximation of the exact
    solution.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，本书中所有的计算都属于所谓的数值计算。这些是主要基于浮动点数的一系列操作。数值计算的特点是，结果是精确解的近似值。
- en: Symbolic computations operate on formulas or symbols by transforming them as
    taught in algebra or calculus into other formulas. The last step of these transformations
    might then require that numbers are inserted and a numeric evaluation is performed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 符号计算通过对公式或符号进行变换，像代数或微积分中所教的那样，将其转化为其他公式。这些变换的最后一步可能需要插入数字并进行数值计算。
- en: 'We illustrate the difference by computing this definite integral:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过计算这个定积分来说明两者之间的区别：
- en: '![](img/4e541523-3e99-444e-8518-72719cb7a212.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e541523-3e99-444e-8518-72719cb7a212.png)'
- en: 'Symbolically this expression can be transformed by considering the primitive
    function of the integrand:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从符号上看，通过考虑被积函数的原始函数，可以对这个表达式进行变换：
- en: '![](img/136a2183-869c-4bea-9ed8-7e88338f8fb8.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/136a2183-869c-4bea-9ed8-7e88338f8fb8.png)'
- en: 'We now obtain a formula for the definite integral by inserting the integral
    bounds:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在通过插入积分界限来获得定积分的公式：
- en: '![](img/b24fc4d8-f270-4bff-ab7b-f80f61ec4949.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b24fc4d8-f270-4bff-ab7b-f80f61ec4949.png)'
- en: This is called a closed-form expression for the integral. Very few mathematical
    problems have a solution that can be given in a closed-form expression. It is
    the exact value of the integral without any approximation. Also, no error is introduced
    by representing real numbers as floating-point numbers, which would otherwise
    introduce round-off errors.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为积分的封闭形式表达式。极少数数学问题有解可以用封闭形式表达式表示。这是积分的精确值，没有任何近似。此外，通过将实数表示为浮动点数，也不会引入误差，否则会产生舍入误差。
- en: 'Approximation and round-off come into play at the very last moment, when this
    expression needs to be evaluated. The square root and the *arctan* can only be
    evaluated approximately by numerical methods. Such an evaluation gives the final
    result up to a certain (often unknown) precision:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 近似和舍入误差在最后一刻发挥作用，当需要对这个表达式进行求值时。平方根和*arctan*只能通过数值方法近似求值。这样的求值给出的是最终结果，精度达到某个特定的（通常是未知的）程度：
- en: '![](img/f38ec7ea-892d-4253-820e-8278a24de278.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f38ec7ea-892d-4253-820e-8278a24de278.png)'
- en: 'On the other hand, numerical computation would directly approximate the definite
    integral by some approximation method, for example, Simpson''s rule, and deliver
    a numeric result, often with an estimate of error. In Python, this is done by
    these commands:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，数值计算会直接通过某种近似方法（例如辛普森法则）来近似定积分，并给出数值结果，通常还会给出误差估计。在Python中，这可以通过以下命令完成：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: They return the value [![](img/5cb34e56-2413-4cbf-a974-1d7aa4b7d1d1.png)] and
    an estimate for the error bound [![](img/4cbcec0e-c1e6-415f-b92e-40da53f782ea.png)]*.*
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它们返回值[![](img/5cb34e56-2413-4cbf-a974-1d7aa4b7d1d1.png)]和误差边界的估计[![](img/4cbcec0e-c1e6-415f-b92e-40da53f782ea.png)]*。
- en: 'The following diagram (*Figure 16.1*) shows the comparison of the numeric and
    symbolic approximations:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图（*图16.1*）展示了数值和符号近似的比较：
- en: '![](img/d9bd0385-f8ad-4d45-9a0a-68c897d580fc.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9bd0385-f8ad-4d45-9a0a-68c897d580fc.png)'
- en: 'Figure 16.1: Symbolic and numeric quadrature'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：符号和数值求积
- en: 16.1.1 Elaborating an example in SymPy
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1.1 在 SymPy 中展开一个示例
- en: To begin with, let's elaborate on the previous example in SymPy and explain
    the steps.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将展开之前的示例，并解释步骤。
- en: 'First, we have to import the module:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须导入模块：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second command makes sure that formulas are presented in a graphical way,
    if possible. Then, we generate a symbol and define the integrand:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令确保公式如果可能的话以图形方式呈现。接着，我们生成一个符号并定义被积函数：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`x` is now a Python object of type `Symbol` and `f` is a SymPy `Lambda` function
    (note the command starting with a capital letter).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 现在是一个类型为 `Symbol` 的 Python 对象，`f` 是一个 SymPy `Lambda` 函数（注意命令以大写字母开头）。'
- en: 'Now we start with the symbolic computation of the integral:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始进行积分的符号计算：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Depending on your working environment, the result is presented in different
    ways; see the following screenshot (*Figure 16.2*), which represents two different
    results of a SymPy formula in different environments:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的工作环境，结果的呈现方式不同；见下图 (*图16.2*)，展示了在不同环境下 SymPy 公式的两种不同结果：
- en: '![](img/61592d97-d85f-4fb2-bb2f-7c177778629d.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61592d97-d85f-4fb2-bb2f-7c177778629d.png)'
- en: 'Figure 16.2: Two screenshots of a SymPy presentation of formula in two different
    environments'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：在两种不同环境下，SymPy 公式的两张截图
- en: 'We can check by differentiation whether the result is correct. To this end,
    we assign a name to the primitive function and differentiate with respect to ![](img/1618222e-1bbe-4fb4-8342-4f4d2261bf0a.png):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过微分来检查结果是否正确。为此，我们为原始函数分配一个名称，并对其关于 ![](img/1618222e-1bbe-4fb4-8342-4f4d2261bf0a.png)
    进行微分：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result obtained will be as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的结果如下：
- en: '![](img/99763022-847a-4874-84d2-f502ea8eb61e.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99763022-847a-4874-84d2-f502ea8eb61e.png)'
- en: 'Which can be simplified by using the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下命令进行简化：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到
- en: '![](img/0acf16ff-1cf7-483e-aa59-4569326b1970.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0acf16ff-1cf7-483e-aa59-4569326b1970.png)'
- en: This is the result we expected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们预期的结果。
- en: 'The definite integral is obtained by using the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 定积分通过以下命令获得：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It gives the following output after simplification with `simplify`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 简化后通过 `simplify` 命令得到的输出是：
- en: '![](img/879b6eed-a37e-405d-8375-9a5343e23cea.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/879b6eed-a37e-405d-8375-9a5343e23cea.png)'
- en: 'To obtain a numerical value, we finally evaluate this expression to a floating-point
    number:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得数值结果，我们最终将这个表达式求值为一个浮动点数：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 16.2 Basic elements of SymPy
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.2 SymPy 的基本元素
- en: Here we introduce the basic elements of SymPy. You will find it favorable to
    be already familiar with classes and data types in Python.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们介绍了 SymPy 的基本元素。你会发现，如果已经熟悉 Python 中的类和数据类型，会更有利于理解。
- en: 16.2.1 Symbols – the basis of all formulas
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2.1 符号 – 所有公式的基础
- en: 'The basic construction element to build a formula in SymPy is the symbol. As
    we saw in the introductory example, a symbol is created by the command `symbols`.
    This SymPy command generates symbol objects from a given string:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SymPy 中构建公式的基本构建元素是符号。正如我们在引言示例中看到的，符号是通过命令 `symbols` 创建的。这个 SymPy 命令通过给定的字符串生成符号对象：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is actually a short form of the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是以下命令的简写：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Followed by an unpacking step to obtain variables:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进行解包操作以获取变量：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The arguments of the command define the string representation of the symbol.
    The variable name of the symbol chosen is often identical to its string representation,
    but this is not required by the language:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的参数定义了符号的字符串表示形式。所选符号的变量名通常与其字符串表示相同，但这并不是语言要求的：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we also defined that the symbol is assumed to be an integer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们也定义了符号假定为整数。
- en: 'An entire set of symbols can be defined in a very compact way:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过非常紧凑的方式定义一整套符号：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similarly, symbols for indexed variables can be defined by using the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以通过以下方式定义索引变量的符号：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This gives a tuple of symbols:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了一个符号元组：
- en: '![](img/71f68d7f-b2f6-41b8-afe5-64ecdf84348d.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71f68d7f-b2f6-41b8-afe5-64ecdf84348d.png)'
- en: 'The rules for the range of the indexes are those we saw earlier in this book
    when working with slices (see [Section 3.1.1](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml):
    *Slicing**,* for more details).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 索引的范围规则是我们在本书中使用切片时看到的规则（参见[第3.1.1节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)：*切片**，了解更多详细信息）。
- en: 16.2.2 Numbers
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2.2 数字
- en: 'Python evaluates operations on numbers directly and introduces unavoidable
    rounding errors. These would obstruct all symbolic calculations. This is avoided
    when we `sympify` numbers:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python直接对数字进行运算，并且引入了不可避免的舍入误差。这些误差会妨碍所有的符号计算。通过`sympify`数字可以避免这一问题：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `sympify` command converts an integer to an object of type `sympy.core.numbers.Integer`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympify`命令将整数转换为类型为`sympy.core.numbers.Integer`的对象。'
- en: Instead of writing **1/3** as an operation of two integers, it can also be represented
    directly as a rational number by `Rational(1,3)`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代替将**1/3**写作两个整数的运算，它也可以通过`Rational(1,3)`直接表示为一个有理数。
- en: 16.2.3 Functions
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2.3 函数
- en: SymPy distinguishes between defined and undefined functions. The term undefined
    functions (which might be a bit misleading) refers to well-defined Python objects
    for generic functions that have no special properties.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy区分已定义函数和未定义函数。未定义函数（这一术语可能有些误导）指的是那些没有特殊性质的通用函数，虽然它们是已定义的Python对象。
- en: An example of a function with special properties is `atan` or the `Lambda` function
    used in the introductory example of this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有特殊性质的函数例子是`atan`或本章入门示例中使用的`Lambda`函数。
- en: Note the different names for the different implementations of the same mathematical
    function: `sympy.atan` and `scipy.arctan`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，同一数学函数的不同实现有不同的名称：`sympy.atan`和`scipy.arctan`。
- en: Undefined functions
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未定义函数
- en: 'A symbol for an undefined function is created by giving the `symbols` command
    an extra class argument:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给`symbols`命令一个额外的类参数，可以创建未定义函数的符号：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The same can be achieved by using the constructor `Function` :'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的效果可以通过使用构造函数`Function`来实现：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With undefined functions, we can evaluate the general rules of calculus.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于未定义的函数，我们可以评估微积分的通用规则。
- en: 'For example, let''s evaluate the following expression:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们评估以下表达式：
- en: '![](img/689cb5c3-3743-4ad4-ad2d-696ebdb021f9.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/689cb5c3-3743-4ad4-ad2d-696ebdb021f9.png)'
- en: 'This is symbolically computed in Python by using the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过以下命令在Python中符号计算得到的：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When executed, the previous code returns the following as output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，前面的代码返回以下输出：
- en: '![](img/5df9fcf5-d204-48f3-8337-1d0270539196.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5df9fcf5-d204-48f3-8337-1d0270539196.png)'
- en: This example shows how the product rule and the chain rule were applied.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何应用乘积法则和链式法则。
- en: 'We can even use an undefined function as a function in several variables, for
    example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用一个未定义的函数作为多个变量的函数，例如：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'which returns the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '![](img/19994640-c42f-4bcf-92ac-f90628562304.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19994640-c42f-4bcf-92ac-f90628562304.png)'
- en: 'Note the use of the star operator to unpack a tuple to form *f* with arguments; see
    [Section 7.2.5](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Variable Number
    of Arguments*.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用星号操作符来解包元组以形成带有参数的*f*；请参见[第7.2.5节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)：*可变数量的参数*。
- en: 'By using list comprehension, we can construct a list of all partial derivatives
    of [![](img/b097026c-fa3d-44d8-ae9c-b0e748c17a08.png)]:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过列表推导，我们可以构造一个包含所有偏导数的列表[![](img/b097026c-fa3d-44d8-ae9c-b0e748c17a08.png)]：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This returns a list with the elements of [![](img/90f569a5-38c2-4bf1-a20f-cecf98f7ef51.png)]
    (the gradient of ![](img/6b258487-c295-41cf-89ad-f94b0fef08e5.png)):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个列表，包含[![](img/90f569a5-38c2-4bf1-a20f-cecf98f7ef51.png)]（![](img/6b258487-c295-41cf-89ad-f94b0fef08e5.png)的梯度）：
- en: '![](img/234a205a-53c2-4ff5-ba25-566ae553601e.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/234a205a-53c2-4ff5-ba25-566ae553601e.png)'
- en: 'The command can also be rewritten by using the method `diff` of the `Function` object:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令也可以通过使用`Function`对象的`diff`方法来重写：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Another method is Taylor series expansion:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是泰勒级数展开：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This returns Taylor''s formula, together with the rest term expressed by the
    Landau symbol:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回泰勒公式，并且包含通过兰道符号表示的余项：
- en: '![](img/03334177-36ef-494b-bb9e-43a0984f1471.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03334177-36ef-494b-bb9e-43a0984f1471.png)'
- en: 16.2.4 Elementary functions
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2.4 基本函数
- en: 'Examples for elementary functions in SymPy are trigonometric functions and
    their inverses. The following example shows how `simplify` acts on an expression
    which includes elementary functions:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy中的基本函数例子包括三角函数及其反函数。以下例子展示了`simplify`如何作用于包含基本函数的表达式：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is another example of the use of elementary functions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个使用基本函数的例子：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you use SciPy and SymPy together, we strongly recommend that you use them
    in different namespaces:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你同时使用SciPy和SymPy，我们强烈建议你将它们放在不同的命名空间中：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 16.2.5 Lambda functions
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2.5 Lambda函数
- en: 'In [Section 7.7](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Anonymous functions*,
    we saw how to define so-called anonymous functions in Python. The SymPy counterpart is
    the command `Lambda`. Note the difference; `lambda` is a keyword while `Lambda` is
    a constructor.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7.7节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)：*匿名函数*中，我们看到如何在Python中定义所谓的匿名函数。SymPy的对应命令是`Lambda`。请注意两者的区别；`lambda`是一个关键字，而`Lambda`是一个构造函数。
- en: The command `Lambda` takes two arguments, the symbol of the function's independent
    variable, and a SymPy expression to evaluate the function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`Lambda`接受两个参数，一个是函数的自变量符号，另一个是用于求值的SymPy表达式。
- en: 'Here is an example that defines air resistance (also called drag) as a function
    of speed:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，定义了空气阻力（也叫做拖力）作为速度的函数：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`f_drag` is displayed as a graphical expression:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`f_drag`以图形表达式的形式显示：'
- en: '![](img/0ae44672-2bd5-4ad4-9fd6-7c9023392d9b.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ae44672-2bd5-4ad4-9fd6-7c9023392d9b.png)'
- en: 'This function can be evaluated in the usual way by providing it with an argument:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以通过提供一个参数来以常规方式进行求值：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Which results in the expressions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到以下表达式：
- en: '![](img/c39440e8-bc2b-4de3-b2ee-bc078927e835.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c39440e8-bc2b-4de3-b2ee-bc078927e835.png)'
- en: 'It is also possible to create functions in several variables by just providing
    the first parameter of `Lambda` with a tuple, as follows for example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过仅提供`Lambda`的第一个参数为一个元组，来创建多个变量的函数，例如如下所示：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A call to this function can be done in two ways, either by directly providing
    several arguments:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个函数有两种方式，可以通过直接提供多个参数来完成：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Or by unpacking a tuple or list:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过解包元组或列表：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Matrix objects in SymPy even make it possible to define vector-valued functions:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy中的矩阵对象甚至使我们能够定义向量值函数：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This enables us to compute Jacobians:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们能够计算雅可比矩阵：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Which gives the following expression as output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下表达式：
- en: '![](img/41952fb2-f56e-46dc-a96c-e271fadd03b7.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41952fb2-f56e-46dc-a96c-e271fadd03b7.png)'
- en: 'In the case of more variables, it is convenient to use a more compact form
    to define the function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有更多变量，使用更紧凑的形式来定义函数会更加方便：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 16.3 Symbolic linear algebra
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.3 符号线性代数
- en: Symbolic linear algebra is supported by SymPy's data type `matrix` which we
    will introduce first. Then we will present some linear algebra methods as examples
    for the broad spectrum of possibilities for symbolic computations in this field.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 符号线性代数由SymPy的`matrix`数据类型支持，我们将首先介绍它。然后我们将展示一些线性代数方法，作为符号计算在这一领域广泛应用的示例。
- en: 16.3.1 Symbolic matrices
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3.1 符号矩阵
- en: 'We briefly met the `matrix` data type when we discussed vector-valued functions.
    There, we saw it in its simplest form, which converts a list of lists into a matrix.
    To see an example, let''s construct a rotation matrix:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讨论向量值函数时简要介绍了`matrix`数据类型。在那里，我们看到了它最简单的形式，能够将一个列表的列表转换为矩阵。为了举个例子，让我们构造一个旋转矩阵：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When working with SymPy matrices we have to note that the operator `*` performs
    matrix multiplications and is not acting as an elementwise multiplication, which
    is the case for NumPy arrays.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用SymPy矩阵时，我们需要注意，操作符`*`执行的是矩阵乘法，而不是像NumPy数组那样的逐元素乘法。
- en: 'The previously defined rotation matrix can be checked for orthogonality by
    using this matrix multiplication and the transpose of a matrix:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的旋转矩阵可以通过使用矩阵乘法和矩阵的转置来检查其正交性：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The previous example shows how a matrix is transposed and how the identity
    matrix is created. Alternatively, we could have checked whether its inverse is
    its transpose, which can be done as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了如何转置一个矩阵以及如何创建单位矩阵。或者，我们本可以检查其逆矩阵是否为其转置，方法如下：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Another way to set up a matrix is by providing a list of symbols and a shape:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 设置矩阵的另一种方法是通过提供符号列表和形状：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This creates the following matrix:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建以下矩阵：
- en: '![](img/cb71b0fa-f4bc-4b43-8b5d-bf5bf626e49d.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb71b0fa-f4bc-4b43-8b5d-bf5bf626e49d.png)'
- en: 'A third way to create a matrix is by generating its entries by a given function.
    The syntax is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建矩阵的第三种方法是通过给定函数生成其条目。语法如下：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We exemplify the preceding matrix by considering a Toeplitz matrix. It is a
    matrix with constant diagonals. Given a [![](img/279a3df8-a97a-4ac5-89e4-d6c9bd841688.png)]data
    vector ![](img/296cf8da-ce9c-4a65-85c5-6acd0ae169c0.png), its elements are defined
    as:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过考虑一个Toeplitz矩阵来举例说明前面的矩阵。它是一个具有常数对角线的矩阵。给定一个[![](img/279a3df8-a97a-4ac5-89e4-d6c9bd841688.png)]数据向量！[](img/296cf8da-ce9c-4a65-85c5-6acd0ae169c0.png)，其元素定义为：
- en: '![](img/cb66a951-698a-47f1-a2ed-7a237cbc8efb.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb66a951-698a-47f1-a2ed-7a237cbc8efb.png)'
- en: 'In SymPy, the matrix can be defined by directly making use of this definition:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SymPy 中，可以直接使用此定义来定义矩阵：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Executing the previous code gives `toeplitz(5)`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码会得到`toeplitz(5)`：
- en: '![](img/61377252-d6c9-4ef9-b650-9c3b81c933dd.png).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/61377252-d6c9-4ef9-b650-9c3b81c933dd.png)。'
- en: 'We can see clearly the desired structures; all elements along the subdiagonals
    and superdiagonals are the same. We can access matrix elements by the indexes
    and slices according to the Python syntax introduced in [Section 3.1.1](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *Slicing*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到所需的结构；所有沿副对角线和超对角线的元素都相同。我们可以根据 Python 语法（见[第 3.1.1 节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)：*切片*）通过索引和切片访问矩阵元素：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 16.3.2 Examples for linear algebra methods in SymPy
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3.2 SymPy 中线性代数方法的示例
- en: 'The basic task in linear algebra is to solve linear equation systems:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数中的基本任务是求解线性方程组：
- en: '![](img/8c1fb4f9-24ee-4cbf-8466-2cb8d3a8ba0b.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c1fb4f9-24ee-4cbf-8466-2cb8d3a8ba0b.png)'
- en: 'Let''s do this symbolically for a ![](img/980b1643-67ce-4e96-aa4e-5cfcf5d6595b.png) matrix:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用符号方法处理一个 ![](img/980b1643-67ce-4e96-aa4e-5cfcf5d6595b.png) 矩阵：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of this relatively small problem is already merely readable, which
    can be seen in the following graphical expression:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相对较小问题的输出已经只是可读的，我们可以在以下的图形表达式中看到：
- en: '![](img/d7dd2130-1af6-4fcf-8170-4800b3427a0d.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7dd2130-1af6-4fcf-8170-4800b3427a0d.png)'
- en: 'Again, the use of `simplify` command helps us to detect canceling terms and
    to collect common factors:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，使用`simplify`命令有助于我们检测抵消项并收集公共因子：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Which will result in the following output, which looks much better:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出，结果看起来更好：
- en: '![](img/41ea66c8-111a-4300-aa55-af4eb092b947.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41ea66c8-111a-4300-aa55-af4eb092b947.png)'
- en: Symbolic computations become very slow when increasing matrix dimensions. For
    dimensions bigger than 15, memory problems might even occur.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当矩阵维度增加时，符号计算变得非常慢。对于大于 15 的维度，甚至可能出现内存问题。
- en: 'The next figure (*Figure 16.3*) illustrates the differences in CPU time between
    symbolically and numerically solving a linear system:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下一幅图（*图 16.3*）展示了符号求解和数值求解线性系统之间 CPU 时间的差异：
- en: '![](img/9b5bcdaa-6bed-4e61-9c85-c5754b2d9381.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b5bcdaa-6bed-4e61-9c85-c5754b2d9381.png)'
- en: 'Figure 16.3: CPU time for numerically and symbolically solving a linear system'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3：数值和符号求解线性系统的 CPU 时间
- en: 16.4 Substitutions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.4 替代
- en: 'Let''s first consider a simple symbolic expression:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先考虑一个简单的符号表达式：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What happens if we set `x = 0` ? We observe that `b` did not change. What we
    did was that we changed the Python variable `x`. It now no longer refers to the
    symbol object but to the integer object `0`. The symbol represented by the string `'x'` remains
    unaltered, and so does `b`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设置 `x = 0` 会发生什么？我们观察到 `b` 并没有改变。我们所做的是改变了 Python 变量 `x`，它现在不再引用符号对象，而是引用了整数对象
    `0`。由字符串 `'x'` 表示的符号保持不变，`b` 也没有变化。
- en: 'Instead, altering an expression by replacing symbols with numbers, other symbols,
    or expressions is done by a special substitution method, which can be seen in
    the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，通过将符号替换为数字、其他符号或表达式，来改变表达式是通过一种特殊的替代方法完成的，以下代码展示了这一点：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This method takes one or two arguments. The following two statements are equivalent:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个或两个参数。以下两个语句是等价的：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Dictionaries as arguments allow us to make several substitutions in one step:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将字典作为参数允许我们一步完成多个替代：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As items in dictionaries have no defined order—we can never know which would
    be the first—there is a need for ensuring that permuting the items would not affect
    the substitution result. Therefore in SymPy, substitutions are first made within
    the dictionary and then on the expression. This is demonstrated by the following
    example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字典中的项目没有固定顺序——我们永远无法知道哪个是第一个——因此需要确保对项目的排列不会影响替代结果。因此，在 SymPy 中，替代操作首先在字典中进行，然后再在表达式中进行。以下示例演示了这一点：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Both substitutions return the same result:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 两种替代方法返回相同的结果：
- en: '[![](img/8a5144a8-5cbf-4da4-9869-c915a219a942.png)]'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/8a5144a8-5cbf-4da4-9869-c915a219a942.png)]'
- en: 'A third alternative to defining multiple substitutions is by using a list of
    old-value/new-value pairs instead:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 定义多个替代的第三种方法是使用旧值/新值对的列表：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It is also possible to substitute entire expressions for others:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以将整个表达式替换为其他表达式：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To illustrate substitutions of matrix elements, we take the ![](img/3a72dcd0-f73c-4b62-8d90-2b07c3477916.png) Toeplitz
    matrix again:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明矩阵元素的替代，我们再次取 ![](img/3a72dcd0-f73c-4b62-8d90-2b07c3477916.png) Toeplitz
    矩阵：
- en: '![](img/5babfd5f-3ae7-48a1-b6d2-f3532b0201fa.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5babfd5f-3ae7-48a1-b6d2-f3532b0201fa.png)'
- en: Consider the substitution `T.subs(T[0,2],0)`. It changes the symbol object at
    position `[0, 2]`, which is the symbol ![](img/ac3eb574-96b2-42d8-9e91-627d68e3c16b.png).
    It also occurs at two other places, which are automatically affected by this substitution.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑替换`T.subs(T[0,2],0)`。它改变了位置`[0, 2]`处的符号对象，即符号![](img/ac3eb574-96b2-42d8-9e91-627d68e3c16b.png)。它还出现在其他两个地方，这些地方会被这个替换自动影响。
- en: 'The given expression is the resulting matrix:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的表达式是结果矩阵：
- en: '![](img/981c6235-96e4-4a07-954d-66636e4e29fd.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/981c6235-96e4-4a07-954d-66636e4e29fd.png)'
- en: 'Alternatively, we can create a variable for this symbol and use it in the substitution:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以为该符号创建一个变量并在替换中使用它：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As a more complex example for substitution, let''s consider how to turn the
    Toeplitz matrix into a tridiagonal Toeplitz matrix*.* This can be done in the
    following ways:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个更复杂的替换示例，让我们考虑如何将Toeplitz矩阵转换为三对角Toeplitz矩阵*.* 这可以通过以下方式完成：
- en: 'First, we generate a list of those symbols that we want to substitute; and
    then we use the `zip` command to generate a list of pairs. Finally, we substitute
    by giving a list of old-value/new-value pairs as described previously:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们生成一个符号列表，选择我们要替换的符号；然后使用`zip`命令生成一对对的列表。最后，我们通过给出旧值/新值对的列表进行替换，如前所述：
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This gives the following matrix as a result:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这会得到以下矩阵作为结果：
- en: '![](img/0f3fc866-797d-4810-bffd-f77832bedc89.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f3fc866-797d-4810-bffd-f77832bedc89.png)'
- en: 16\. 5 Evaluating symbolic expressions
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16\.5 评估符号表达式
- en: In the context of scientific computing, there is often the need to first make
    symbolic manipulations and then convert the symbolic result into a floating-point
    number.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学计算中，通常需要先进行符号运算，然后将符号结果转换为浮点数。
- en: 'The central tool for evaluating a symbolic expression is `evalf`. It converts
    symbolic expressions to floating-point numbers by using the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 评估符号表达式的核心工具是`evalf`。它通过使用以下方法将符号表达式转换为浮点数：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The data type of the resulting object is `Float` (note the capitalization),
    which is a SymPy data type that allows floating-point numbers with an arbitrary
    number of digits (arbitrary precision).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 结果对象的数据类型是`Float`（注意大写），这是一个SymPy数据类型，允许使用任意位数（任意精度）的浮点数。
- en: The default precision corresponds to 15 digits, but it can be changed by giving `evalf` an
    extra positive integer argument
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 默认精度对应于15位数字，但可以通过给`evalf`一个额外的正整数参数来改变它。
- en: 'specifying the desired precision in terms of the numbers of digits:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定所需精度的数字位数：
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A consequence of working with arbitrary precision is that numbers can be arbitrarily
    small, that is, the limits of the classical floating-point representation are
    broken; see [Section 2.2.2](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml): *Floating-point
    numbers*.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任意精度的一个结果是，数字可以非常小，也就是说，打破了经典浮点数表示的限制；请参见[第2.2.2节](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml)：*浮点数*。
- en: Interestingly enough, evaluating a SymPy function with an input of type `Float` returns
    a `Float` with the same precision as the input. We demonstrate the use of this
    fact in a more elaborated example from numerical analysis.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，用`Float`类型的输入来评估SymPy函数会返回一个与输入精度相同的`Float`。我们将在一个来自数值分析的更复杂示例中演示这一事实的使用。
- en: '16.5.1 Example: A study on the convergence order of Newton''s method'
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.5.1 示例：牛顿法收敛阶的研究
- en: An iterative method that iterates [*![](img/8038e264-c9a7-4d5f-b660-cd3997fc5d6c.png)*]
    is said to converge with order ![](img/e551ea10-3819-42ef-b8b1-3884edbf01bc.png) with
    ![](img/36ff2bdf-6ca2-4169-ab30-3f4ffcdaccb4.png)[,] if there exists a positive
    constant ![](img/d1e134fb-86be-4b63-ab18-e936219620fe.png) such that
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一个迭代方法，如果迭代[*![](img/8038e264-c9a7-4d5f-b660-cd3997fc5d6c.png)*]，被称为以阶数![](img/e551ea10-3819-42ef-b8b1-3884edbf01bc.png)收敛，并且存在一个正的常数![](img/d1e134fb-86be-4b63-ab18-e936219620fe.png)，使得：
- en: '![](img/69ef133f-4f49-401c-a132-ee87c1697bba.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69ef133f-4f49-401c-a132-ee87c1697bba.png)'
- en: 'Newton''s method, when started with a good initial value, has order ![](img/d5d4c2b0-7c21-4ae7-abe1-13d87cd15d2e.png),
    and for certain problems, even ![](img/3778c99a-3238-4758-81e5-ffa04d05c1e4.png).
    Newton''s method when applied to the problem ![](img/3e25a412-60af-451a-9075-b63f22edc726.png) gives
    the following iteration scheme:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿法，当从一个好的初值开始时，其收敛阶为![](img/d5d4c2b0-7c21-4ae7-abe1-13d87cd15d2e.png)，对于某些问题，甚至可以达到![](img/3778c99a-3238-4758-81e5-ffa04d05c1e4.png)。应用牛顿法解决问题![](img/3e25a412-60af-451a-9075-b63f22edc726.png)时，给出以下迭代方案：
- en: '![](img/df5318b5-ae44-434b-8a96-8c55c1dccdab.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df5318b5-ae44-434b-8a96-8c55c1dccdab.png)'
- en: Which converges cubically; that is, *q* = 3.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的收敛速度是立方收敛；也就是说，*q* = 3。
- en: This implies that the number of correct digits triples from iteration to iteration.
    To demonstrate cubic convergence and to numerically determine the constant [![](img/b1a781f0-07e6-4d0d-b5d1-0d40c1bb15fc.png)]
    is hardly possible with the standard 16-digit `float` data type.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着正确数字的数量会随着每次迭代从上一轮迭代中三倍增加。为了演示立方收敛并数值求解常数，[![](img/b1a781f0-07e6-4d0d-b5d1-0d40c1bb15fc.png)]使用标准的16位数字`float`数据类型几乎无法实现。
- en: 'The following code uses SymPy together with high-precision evaluation instead
    and takes the study on cubic convergence to the extreme:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用SymPy并结合高精度求值，将立方收敛研究推向极致：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The result is depicted in the next figure (*Figure 16.4*), which shows that
    the number of correct digits triples from iteration to iteration:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下图所示（*图16.4*），显示了每次迭代正确数字的数量是如何从上一轮迭代中三倍增加的：
- en: '![](img/0944745e-3381-43e2-b3da-8ce9027d2364.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0944745e-3381-43e2-b3da-8ce9027d2364.png)'
- en: 'Figure 16.4: A study on the convergence of Newton''s method applied to ![](img/188cd499-6f66-4039-bcfd-e039c4de31da.png)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4：对应用于![](img/188cd499-6f66-4039-bcfd-e039c4de31da.png)的牛顿法收敛性的研究
- en: 'This extreme precision requirement (3,000 digits!) enables us to evaluate seven
    terms of the preceding sequence to demonstrate cubic convergence in the following
    way:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这种极高精度要求（3,000位数字！）使我们能够以如下方式评估前面序列的七项，从而演示立方收敛：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The result is a list of seven terms that let us assume that ![](img/7282e682-14f4-42f1-b2da-f22d4a0db8bb.png):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含七项的列表，让我们假设！[](img/7282e682-14f4-42f1-b2da-f22d4a0db8bb.png)：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 16.5.2 Converting a symbolic expression into a numeric function
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.5.2 将符号表达式转换为数值函数
- en: 'As we have seen, the numerical evaluation of symbolic expressions is done in
    three steps: first, we do some symbolic computations and then we substitute values
    by numbers and do an evaluation to a floating-point number with `evalf`.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，符号表达式的数值求解分为三个步骤：首先，我们进行一些符号计算，然后通过数字替换变量，最后使用`evalf`进行浮动点数的求值。
- en: The reason for symbolic computations is often that we want to make parameter
    studies. This requires that the parameter is modified within a given parameter
    range. This requires that a symbolic expression is eventually turned into a numeric
    function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 进行符号计算的原因通常是我们希望进行参数研究。这要求在给定的参数范围内修改参数。这要求符号表达式最终被转换为数值函数。
- en: A study on the parameter dependency of polynomial coefficients
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对多项式系数的参数依赖性研究
- en: We demonstrate a symbolic/ numeric parameter study by an interpolation example
    to introduce the SymPy command `lambdify`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个插值示例展示了符号/数值参数研究，以介绍SymPy命令`lambdify`。
- en: Let's consider the task to interpolate the data ![](img/1186c128-483c-4d51-8df7-207d483a2da8.png) and
    ![](img/58696cc5-47bd-4b9d-a3f5-0c0344b1abda.png). Here, ![](img/99eedf3c-a08b-4a54-85e3-061b29472f88.png) is
    a free parameter, which we will vary over the interval![](img/a32da2e1-a0f2-4cd7-aa5b-badedd42495b.png).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑任务，即对数据![](img/1186c128-483c-4d51-8df7-207d483a2da8.png) 和 ![](img/58696cc5-47bd-4b9d-a3f5-0c0344b1abda.png)进行插值。在这里，![](img/99eedf3c-a08b-4a54-85e3-061b29472f88.png)是一个自由参数，我们将在区间![](img/a32da2e1-a0f2-4cd7-aa5b-badedd42495b.png)上变化。
- en: 'The quadratic interpolation polynomial has coefficients depending on this parameter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 二次插值多项式具有依赖于该参数的系数：
- en: '![](img/ed52c599-8a50-410d-a261-02989af80625.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed52c599-8a50-410d-a261-02989af80625.png)'
- en: 'Using SymPy and the monomial approach described in *Exercise 3* in [Section
    4.11](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *Exercises* gives us the closed
    formula for these coefficients:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SymPy和*练习3*中描述的单项式方法，如[第4.11节](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)中的*练习*给出了这些系数的封闭公式：
- en: '[PRE56]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We obtain a symbolic function for the leading coefficient [![](img/ebfc6511-9b09-49d3-b0a7-3cee878c7d64.png)]
    of the interpolation polynomial:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为插值多项式的主系数[![](img/ebfc6511-9b09-49d3-b0a7-3cee878c7d64.png)]获得了一个符号函数：
- en: '![](img/958edc0c-d7a9-46bd-8e0f-65209f5dc4cc.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/958edc0c-d7a9-46bd-8e0f-65209f5dc4cc.png)'
- en: Now it is time to turn the expression into a numeric function, for example,
    to make a plot. This is done by the function `lamdify`. This function takes two
    arguments, the independent variable, and a SymPy function.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是将表达式转换为数值函数的时候了，例如，为了生成一个图形。这是通过`lamdify`函数完成的。该函数接受两个参数，一个是自变量，另一个是SymPy函数。
- en: 'For our example in Python, we can write:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Python示例中，我们可以编写：
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This function can now be plotted, for example, by the following commands:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过以下命令绘制该函数，例如：
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*Figure 16.5* is the result of this parameter study, we can clearly see the
    singularities due to multiple interpolation points (here at ![](img/97299a92-07c9-427b-943c-7dcf074dcf70.png) or
    ![](img/266b98d5-623e-4ca0-9e10-2a00f2f33642.png)):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.5* 是此参数研究的结果，我们可以清楚地看到由于多个插值点（这里在 ![](img/97299a92-07c9-427b-943c-7dcf074dcf70.png)
    或 ![](img/266b98d5-623e-4ca0-9e10-2a00f2f33642.png)）而产生的奇点：'
- en: '![](img/25c98c0b-464c-49ce-980f-bb827afc9a79.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25c98c0b-464c-49ce-980f-bb827afc9a79.png)'
- en: 'Figure 16.5: The dependency of a polynomial coefficient on the location of
    an interpolation point'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5：多项式系数依赖于插值点位置的关系
- en: 16.6 Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.6 小结
- en: In this chapter, you were introduced to the world of symbolic computations and
    you got a glimpse of the power of SymPy. By following the examples, you learned
    how to set up symbolic expressions, how to work with symbolic matrices, and you
    saw how to make simplifications. Working with symbolic functions and transforming
    them into numerical evaluations, finally, established the link to scientific computing
    and floating-point results. You experienced the strength of SymPy as you used
    its full integration into Python with its powerful constructs and legible syntax.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你初步了解了符号计算的世界，并领略了SymPy的强大功能。通过学习这些例子，你掌握了如何设置符号表达式、如何操作符号矩阵，并学习了如何进行简化处理。通过处理符号函数并将其转化为数值计算，你最终建立了与科学计算和浮点结果之间的联系。你体验了SymPy的强大，它通过与Python的完美集成，提供了强大的构造和易读的语法。
- en: Consider this last chapter as an appetizer rather than a complete menu. We hope
    you became hungry for future fascinating programming challenges in scientific
    computing and mathematics.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将最后一章视为开胃菜，而非完整菜单。我们希望你对未来在科学计算和数学中的精彩编程挑战产生兴趣。
