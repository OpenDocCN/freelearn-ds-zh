- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Using the DEAP Framework
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DEAP 框架
- en: In this chapter – as promised – the real fun begins! You will be introduced
    to **Distributed Evolutionary Algorithms in Python** (**DEAP**) – a powerful and
    flexible evolutionary computation framework capable of solving real-life problems
    using genetic algorithms. After a brief introduction, you will get acquainted
    with two of its main modules – the creator and the toolbox – and learn how to
    create the various components needed for the genetic algorithm flow. We will then
    write a Python program that solves the OneMax problem – the Hello World of genetic
    algorithms – using the DEAP framework. This will be followed by a more concise
    version of the same program, where we’ll take advantage of the built-in algorithms
    of the framework. We’ve saved the best for the last part of this chapter, where
    we will be experimenting with various settings of the genetic algorithm we created
    and discover the effects of our modifications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中——如前所述——真正有趣的部分开始了！你将了解**Python中的分布式进化算法**（**DEAP**）——一个强大且灵活的进化计算框架，能够通过遗传算法解决实际问题。经过简要介绍后，你将熟悉其中的两个主要模块——创建器和工具箱——并学习如何创建遗传算法流程所需的各个组件。接下来，我们将编写一个
    Python 程序，使用 DEAP 框架解决 OneMax 问题——遗传算法的“Hello World”。然后是一个简化版本的相同程序，我们将利用该框架的内置算法。最后一部分是本章最精彩的部分，我们将尝试调整我们创建的遗传算法的各种设置，并发现这些修改的效果。
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你将能够做到以下几点：
- en: Express your familiarity with the DEAP framework and its genetic algorithm modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达你对 DEAP 框架及其遗传算法模块的熟悉程度
- en: Understand the concepts of the creator and toolbox modules in the DEAP framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 DEAP 框架中创建器和工具箱模块的概念
- en: Translate a simple problem into a genetic algorithm representation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个简单问题转化为遗传算法表示
- en: Create a genetic algorithm solution using the DEAP framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DEAP 框架创建一个遗传算法解决方案
- en: Understand how to use the DEAP framework’s built-in algorithms to produce concise
    code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何使用 DEAP 框架的内置算法编写简洁的代码
- en: Solve the OneMax problem using a genetic algorithm coded with the DEAP framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DEAP 框架编写的遗传算法解决 OneMax 问题
- en: Experiment with various settings of the genetic algorithm and interpret the
    differences in the results
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试遗传算法的各种设置，并解读结果中的差异
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Here are the technical requirements for this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的技术要求。
- en: 'Important note:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: 'For the latest information regarding the technical requirements, please refer
    to the README file at: [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/README.md](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/README.md)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有关技术要求的最新信息，请参考 README 文件：[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/README.md](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/README.md)
- en: Python version
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 版本
- en: 'In this book, we will be using Python 3, version 3.11 or newer. Python can
    be downloaded from the Python Software Foundation at [https://www.python.org/downloads/](https://www.python.org/downloads/).
    Additional useful instructions can be found here: [https://realpython.com/installing-python/](https://realpython.com/installing-python/).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将使用 Python 3，版本 3.11 或更新版本。可以从 Python 软件基金会的官方网站下载 Python：[https://www.python.org/downloads/](https://www.python.org/downloads/)。更多有用的安装说明可以在这里找到：[https://realpython.com/installing-python/](https://realpython.com/installing-python/)。
- en: Using a virtual environment
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用虚拟环境
- en: It is generally good practice to use a virtual environment when working on a
    Python-based project as it enables you to keep the dependencies of your project
    isolated from other Python projects, as well as the system’s existing settings
    and dependencies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行基于 Python 的项目时，使用虚拟环境通常是一个好习惯，因为它可以将项目的依赖与其他 Python 项目以及系统现有的设置和依赖隔离开来。
- en: 'One common way to create a virtual environment is by using **venv**, as described
    here: [https://docs.python.org/3/library/venv.html](https://docs.python.org/3/library/venv.html).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建虚拟环境的常用方法之一是使用**venv**，详细说明见：[https://docs.python.org/3/library/venv.html](https://docs.python.org/3/library/venv.html)。
- en: 'Another popular way to manage Python environments and packages is using **conda**,
    as described here: [https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html](https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种流行的 Python 环境和软件包管理方式是使用 **conda**，详细介绍见此处：[https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html](https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html)。
- en: Important note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When using a virtual environment, make sure you **activate** it before installing
    the required libraries, as described in the following section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟环境时，确保在安装所需库之前先**激活**虚拟环境，如以下部分所述。
- en: Installing the necessary libraries
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装必要的库
- en: Throughout this book, we will be using the DEAP library, as well as various
    other Python packages. There are a couple of options to install these dependencies,
    as outlined in the following subsections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将使用 DEAP 库以及其他各种 Python 软件包。有几种方法可以安装这些依赖项，具体方法在以下小节中列出。
- en: Using requirements.txt
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `requirements.txt`
- en: Whether you choose to use a virtual environment or not, you can utilize the
    `requirements.txt` file we provide to install all the required dependencies at
    once. This file contains all the packages that will be used throughout this book
    and can be found in this book’s GitHub repository at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/requirements.txt](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/requirements.txt).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否选择使用虚拟环境，都可以使用我们提供的 `requirements.txt` 文件，一次性安装所有必需的依赖项。该文件包含本书中将使用的所有软件包，并可在本书的
    GitHub 仓库中找到，链接：[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/requirements.txt](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/requirements.txt)。
- en: 'Typically, the `requirements.txt` file is used in conjunction with the `pip`
    utility and can be installed by applying the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`requirements.txt` 文件与 `pip` 工具一起使用，可以通过以下命令进行安装：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing individual packages
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装单个软件包
- en: If you prefer to install the required packages individually as you go through
    this book, the Technical requirements section of each chapter will mention the
    particular packages that will be used within that chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢在阅读本书的过程中逐个安装所需的软件包，每章的技术要求部分会提到该章节中将使用的特定软件包。
- en: 'To start with, we will need to install the DEAP library. The recommended ways
    to install DEAP are using `easy_install` or `pip`, like so:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装 DEAP 库。推荐的安装 DEAP 方法是使用 `easy_install` 或 `pip`，如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For more information, check out the DEAP documentation: [https://deap.readthedocs.io/en/master/installation.html](https://deap.readthedocs.io/en/master/installation.html).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请查看 DEAP 文档：[https://deap.readthedocs.io/en/master/installation.html](https://deap.readthedocs.io/en/master/installation.html)。
- en: 'If you prefer to install DEAP via Conda, consult the following link: [https://anaconda.org/conda-forge/deap](https://anaconda.org/conda-forge/deap).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更倾向于通过 Conda 安装 DEAP，请参阅以下链接：[https://anaconda.org/conda-forge/deap](https://anaconda.org/conda-forge/deap)。
- en: 'In addition, for this chapter, you will need the following packages:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章需要以下软件包：
- en: '**NumPy**: [https://www.numpy.org/](https://www.numpy.org/)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NumPy**: [https://www.numpy.org/](https://www.numpy.org/)'
- en: '**Matplotlib**: [https://matplotlib.org/](https://matplotlib.org/)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Matplotlib**: [https://matplotlib.org/](https://matplotlib.org/)'
- en: '**Seaborn**: [https://seaborn.pydata.org/](https://seaborn.pydata.org/)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Seaborn**: [https://seaborn.pydata.org/](https://seaborn.pydata.org/)'
- en: We are now ready to use DEAP. The framework’s most useful tools and utilities
    will be covered in the next two sections. But first, we will get acquainted with
    DEAP and understand why we chose this framework for working with genetic algorithms.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好使用 DEAP。框架中最有用的工具和实用程序将在接下来的两部分中介绍。但首先，我们将了解 DEAP，并理解为什么我们选择这个框架来处理遗传算法。
- en: The programs that will be used in this chapter can be found in this book’s GitHub
    repository at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_03](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_03).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将使用的程序可以在本书的 GitHub 仓库中找到，链接：[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_03](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_03)。
- en: 'Check out the following video to see the Code in Action: [https://packt.link/OEBOd](https://packt.link/OEBOd).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://packt.link/OEBOd](https://packt.link/OEBOd)。
- en: Introduction to DEAP
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DEAP 介绍
- en: As we have seen in the previous chapters, the basic ideas behind genetic algorithms
    and the genetic flow are relatively simple, and so are many of the genetic operators.
    Therefore, developing a program from scratch that implements a genetic algorithm
    to solve a particular problem is entirely feasible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中所看到的，遗传算法和遗传流的基本思想相对简单，许多遗传操作符也是如此。因此，从零开始开发一个程序来实现遗传算法以解决特定问题是完全可行的。
- en: However, as is often the case when developing software, using a tried-and-true
    dedicated library or framework can make our lives easier. It helps us create solutions
    faster and with fewer bugs and gives us many options to choose from (and experiment
    with) right out of the box, without the need to reinvent the wheel.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如在开发软件时常见的那样，使用经过验证的专用库或框架可以让我们的工作变得更加轻松。它帮助我们更快地创建解决方案并减少错误，并且为我们提供了许多现成的选择（以及可以实验的选项），无需重新发明轮子。
- en: Numerous Python frameworks have been created for working with genetic algorithms
    – PyGAD, GAFT, Pyevolve, and PyGMO, to mention a few. After looking into several
    options, we chose to use the DEAP framework for this book thanks to its ease of
    use and a large selection of features, as well as its extensibility and ample
    documentation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 已经创建了许多用于遗传算法的 Python 框架——如 PyGAD、GAFT、Pyevolve 和 PyGMO，仅举几例。经过对多个选项的研究，我们选择使用
    DEAP 框架，因为它易于使用，功能丰富，且具有良好的扩展性和大量文档支持。
- en: DEAP is a Python framework that supports the rapid development of solutions
    using genetic algorithms, as well as other evolutionary computation techniques.
    DEAP offers various data structures and tools that prove essential when implementing
    a wide range of genetic-algorithm-based solutions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: DEAP 是一个 Python 框架，支持使用遗传算法以及其他进化计算技术快速开发解决方案。DEAP 提供了各种数据结构和工具，这些工具在实现基于遗传算法的多种解决方案时至关重要。
- en: DEAP has been developed at the Canadian Laval University since 2009 and is available
    under the GNU **Lesser General Public** **License** (**LGPL**).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: DEAP 自 2009 年起在加拿大拉瓦尔大学开发，并且采用 GNU **Lesser General Public** **License** (**LGPL**)
    许可证。
- en: The source code for DEAP is available at [https://github.com/DEAP/deap](https://github.com/DEAP/deap)
    and the documentation can be found at [https://deap.readthedocs.io/en/master/](https://deap.readthedocs.io/en/master/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: DEAP 的源代码可在 [https://github.com/DEAP/deap](https://github.com/DEAP/deap) 上找到，文档可在
    [https://deap.readthedocs.io/en/master/](https://deap.readthedocs.io/en/master/)
    查看。
- en: Using the creator module
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 creator 模块
- en: The first powerful tool provided by the DEAP framework is the `creator` module.
    The `creator` module is used as a meta-factory, and it enables us to extend existing
    classes by augmenting them with new attributes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: DEAP 框架提供的第一个强大工具是 `creator` 模块。`creator` 模块用作元工厂，允许我们通过增加新属性来扩展现有的类。
- en: 'For example, suppose we have a class called `Employee`. Using the `creator`
    tool, we can extend the `Employee` class by creating a `Developer` class, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个名为 `Employee` 的类。通过 `creator` 工具，我们可以通过创建一个 `Developer` 类来扩展 `Employee`
    类，如下所示：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first argument that’s passed to the `create()` function is the desired name
    for the new class. The second argument is the existing base class to be extended.
    Then, each additional argument defines an attribute for the new class. If the
    argument is assigned a data structure (such as `dict` or `set`), it is added to
    the new class as an instance attribute that’s initialized in the constructor.
    If the argument is a simple type, such as a literal, it’s added as a class attribute
    that’s shared among all instances of the class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`create()` 函数的第一个参数是新类的期望名称。第二个参数是要扩展的现有基类。然后，每个额外的参数定义了新类的一个属性。如果参数被分配了一个数据结构（例如
    `dict` 或 `set`），它将作为实例属性添加到新类中，并在构造函数中进行初始化。如果参数是一个简单类型，如字面量，它将作为类属性添加，并且在该类的所有实例之间共享。'
- en: 'Consequently, the created `Developer` class will extend the `Employee` class
    and will have a class attribute, `position`, set to `Developer`, and an instance
    attribute, `programmingLanguages` of the `set` type, which is initialized in the
    constructor. So, effectively, the new class is equivalent to the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建的 `Developer` 类将扩展 `Employee` 类，并且将拥有一个类属性 `position`，其值为 `Developer`，以及一个实例属性
    `programmingLanguages`，其类型为 `set`，并在构造函数中进行初始化。因此，实际上，新类等同于以下代码：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Important notes
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 1\. This new class exists within the **creator** module and therefore needs
    to be referenced as **creator.Developer**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 这个新类存在于**creator**模块中，因此需要引用为**creator.Developer**。
- en: 2\. Extending the **numpy.ndarray** class is a special case that will be discussed
    later in this book.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 扩展**numpy.ndarray**类是一个特殊情况，稍后将在本书中讨论。
- en: When using DEAP, the `creator` module usually serves to create the `Fitness`
    class, as well as the `Individual` class, to be used by the genetic algorithm,
    as we will see next.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用DEAP时，`creator`模块通常用于创建`Fitness`类和`Individual`类，以供遗传算法使用，正如我们接下来将看到的。
- en: Creating the Fitness class
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Fitness类
- en: When using DEAP, fitness values are encapsulated within a `Fitness` class. DEAP
    enables fitness to be combined into several components (also called objectives),
    each having its own weight. The combination of these weights defines the behavior
    or strategy of the fitness for the given problem.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用DEAP时，适应度值被封装在一个`Fitness`类中。DEAP允许将适应度合并为多个组件（也称为目标），每个组件都有自己的权重。这些权重的组合定义了适应度在给定问题中的行为或策略。
- en: Defining the fitness strategy
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义适应度策略
- en: 'To help define this strategy, DEAP comes with the abstract `base.Fitness` class,
    which contains a `weights` tuple. This tuple needs to be assigned values to define
    the strategy and make the class usable. This can be done by extending the base
    `Fitness` class using `creator`, in a similar manner to what we did with the preceding
    `Developer` class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助定义这个策略，DEAP提供了抽象的`base.Fitness`类，该类包含一个`weights`元组。这个元组需要被赋值，以定义策略并使类可用。这可以通过使用`creator`扩展基础的`Fitness`类来实现，方式类似于我们之前为`Developer`类所做的：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: creator.create("FitnessCompound", base.Fitness,
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: creator.create("FitnessCompound", base.Fitness,
- en: creator.FitnessCompound class, which will utilize three different fitness components.
    The first will be given a weight of 1.0, the second 0.2, and the third -0.5. This
    fitness strategy will tend to maximize the first and the second components (or
    objectives) and minimize the third. In terms of importance, the first component
    has the most importance, followed by the third component and then the second one.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: creator.FitnessCompound类，它将使用三个不同的适应度组件。第一个将赋予权重1.0，第二个赋予0.2，第三个赋予-0.5。这个适应度策略将倾向于最大化第一个和第二个组件（或目标），并最小化第三个。从重要性来看，第一个组件最重要，其次是第三个组件，最后是第二个组件。
- en: Storing the fitness values
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 存储适应度值
- en: While the `weights` tuple defines the fitness strategy, a matching tuple, called
    `values`, is used to contain the actual fitness values within the `base.Fitness`
    class. These values are obtained from a separately defined function, typically
    called `evaluate()`, as will be described later in this chapter. Just like the
    `weights` tuple, the `values` tuple contains one value for each fitness component
    (objective).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当`weights`元组定义了适应度策略时，一个匹配的元组，称为`values`，用于包含`base.Fitness`类中的实际适应度值。这些值通过一个单独定义的函数获取，通常称为`evaluate()`，将在本章后续部分介绍。与`weights`元组类似，`values`元组包含每个适应度组件（目标）的一个值。
- en: A third tuple, `wvalues`, contains the weighted values that are obtained by
    multiplying each component of the values tuple with its matching component of
    the `weights` tuple. Whenever the fitness values of an instance are set, the weighted
    values are calculated and inserted into `wvalues`. These are used internally for
    comparison operations between individuals.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个元组`wvalues`包含通过将`values`元组的每个组件与其对应的`weights`元组组件相乘而得到的加权值。每当设置一个实例的适应度值时，加权值会被计算并插入到`wvalues`中。这些值在内部用于个体之间的比较操作。
- en: 'The weighted fitness values may be lexicographically compared using the following
    operators:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 权重适应度值可以使用以下运算符按字典顺序进行比较：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once the `Fitness` class is created, we can use it in the definition of the
    `Individual` class, as shown in the next subsection.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了`Fitness`类，我们可以在定义`Individual`类时使用它，如下一小节所示。
- en: Creating the Individual class
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Individual类
- en: The second common use of the `creator` tool in DEAP is defining the individuals
    that form the population for the genetic algorithm. As we saw in the previous
    chapters, the individuals in genetic algorithms are represented using a chromosome
    that can be manipulated by genetic operators. In DEAP, the `Individual` class
    is created by extending a base class that represents the chromosome. In addition,
    each instance in DEAP needs to contain its fitness function as an attribute.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`creator`工具在DEAP中的第二个常见用途是定义构成遗传算法种群的个体。正如我们在前几章所看到的，遗传算法中的个体是通过一个染色体表示的，可以通过遗传操作符进行操作。在DEAP中，`Individual`类是通过扩展一个表示染色体的基类来创建的。此外，DEAP中的每个实例都需要将其适应度函数作为一个属性。'
- en: 'To fulfill these two requirements, we can utilize `creator` to create the `creator.Individual`
    class, as shown in this example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这两个要求，我们可以利用`creator`创建`creator.Individual`类，如下例所示：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This line provides the following two effects:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行提供了以下两个效果：
- en: The created **Individual** class extends the Python **list** class. This means
    that the chromosome that’s used is of the **list** type.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建的**Individual**类扩展了Python的**list**类。这意味着使用的染色体是**list**类型的。
- en: Each instance of this **Individual** class will have an attribute called **fitness**,
    of the **FitnessMax** class, which we created previously.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个**Individual**类的每个实例都会有一个叫做**fitness**的属性，属于我们之前创建的**FitnessMax**类。
- en: We will learn to use the `Toolbox` class in the next section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中学习如何使用`Toolbox`类。
- en: Using the Toolbox class
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Toolbox类
- en: The second mechanism offered by the DEAP framework is the `base.Toolbox` class.
    `Toolbox` is used as a container for functions (or operators) and enables us to
    create new operators by aliasing and customizing existing functions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: DEAP框架提供的第二种机制是`base.Toolbox`类。`Toolbox`用作函数（或操作符）的容器，使我们能够通过别名和自定义现有函数来创建新操作符。
- en: 'For example, suppose we have a function, `sumOfTwo()`, defined as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个函数`sumOfTwo()`，其定义如下：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using `toolbox`, we can now create a new operator, `incrementByFive()`, which
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`toolbox`，我们现在可以创建一个新的操作符`incrementByFive()`，它
- en: 'customizes the `sumOfTwo()` function, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义`sumOfTwo()`函数，如下所示：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: toolbox.incrementByFive(10)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: toolbox.incrementByFive(10)
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: sumOfTwo(10, 5)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: sumOfTwo(10, 5)
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: from deap import tools
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: from deap import tools
- en: toolbox.register("select",tools.selTournament,tournsize=3)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: toolbox.register("select",tools.selTournament,tournsize=3)
- en: toolbox.register("mate", tools.cxTwoPoint)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: toolbox.register("mate", tools.cxTwoPoint)
- en: toolbox.register("mutate", tools.mutFlipBit, indpb=0.02)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: toolbox.register("mutate", tools.mutFlipBit, indpb=0.02)
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: randomList = tools.initRepeat(list is the type serving as the container to be
    filled, random.random is the generator function, and 30 is the number of times
    we will call the function to generate values that fill the container.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: randomList = tools.initRepeat(list是作为容器填充的类型，random.random是生成器函数，30是我们调用函数生成值并填充容器的次数。
- en: 'What if we wanted to fill the list with integer random numbers that are *either*
    0 or 1? We could, for example, create a function that utilizes `random.radint()`
    to generate a single random value of 0 or 1, and then use it as the generator
    function of `initRepeat()`, as shown in the following code snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想用整数随机数填充列表，而这些随机数*要么*是0，要么是1，我们可以创建一个函数，利用`random.randint()`生成一个0或1的单个随机值，然后将其作为`initRepeat()`的生成器函数，如下代码片段所示：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: toolbox.register("zeroOrOne", random.randint, 0, 1)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: toolbox.register("zeroOrOne", random.randint, 0, 1)
- en: randomList = tools.initRepeat(list, zeroOrOne() function, we created the zeroOrOne
    operator (or alias), which calls random.radint() with the fixed parameters of
    0 and 1.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: randomList = tools.initRepeat(list, zeroOrOne()函数，我们创建了zeroOrOne操作符（或别名），它调用random.randint()并使用固定参数0和1。
- en: Calculating the fitness
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 计算适应度
- en: 'As mentioned previously, while the `Fitness` class defines the fitness *weights*
    that determine its strategy (such as *maximization* or *minimization*), the actual
    fitness values are obtained from a separately defined function. This fitness calculation
    function is typically registered with the `toolbox` module using an alias of `evaluate`,
    as shown in the following code snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，尽管`Fitness`类定义了决定其策略的适应度*权重*（如*最大化*或*最小化*），实际的适应度值是通过一个单独定义的函数获得的。这个适应度计算函数通常会使用`evaluate`别名注册到`toolbox`模块，如下代码片段所示：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: from deap import base
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from deap import base
- en: from deap import creator
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from deap import creator
- en: from deap import tools
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from deap import tools
- en: import random
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import random
- en: import matplotlib.pyplot as plt
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: '[PRE15]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'problem constants:'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题常量：
- en: ONE_MAX_LENGTH = 100   # length of bit string to be
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ONE_MAX_LENGTH = 100   # 位字符串的长度
- en: '# optimized'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# 优化'
- en: 'Genetic Algorithm constants:'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗传算法常数：
- en: 'POPULATION_SIZE = 200 # number of individuals in'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'POPULATION_SIZE = 200 # 种群个体数量'
- en: '# population'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# 种群'
- en: P_CROSSOVER = 0.9     # probability for crossover
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: P_CROSSOVER = 0.9     # 交叉概率
- en: P_MUTATION = 0.1      # probability for mutating
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: P_MUTATION = 0.1      # 突变概率
- en: '# an individual'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# 一个个体'
- en: MAX_GENERATIONS = 50  # max number of generations for
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MAX_GENERATIONS = 50  # 最大代数
- en: '# stopping condition'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# 停止条件'
- en: '[PRE16]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: RANDOM_SEED = 42
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RANDOM_SEED = 42
- en: random.seed(RANDOM_SEED)
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: random.seed(RANDOM_SEED)
- en: '[PRE17]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: toolbox = base.Toolbox()
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: toolbox = base.Toolbox()
- en: toolbox.register("zeroOrOne", random.randint, 0, 1)
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: toolbox.register("zeroOrOne", random.randint, 0, 1)
- en: '[PRE18]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: creator.create("FitnessMax", base.Fitness, \
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: creator.create("FitnessMax", base.Fitness, \
- en: weights=1.0,))
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: weights=1.0,))
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: creator.create("Individual", list, \
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: creator.create("Individual", list, \
- en: fitness=creator.FitnessMax)
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: fitness=creator.FitnessMax)
- en: '[PRE20]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: toolbox.register("individualCreator",\
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: toolbox.register("individualCreator",\
- en: tools.initRepeat,\
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: tools.initRepeat,\
- en: creator.Individual,\
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: creator.Individual,\
- en: toolbox.zeroOrOne, ONE_MAX_LENGTH)
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: toolbox.zeroOrOne, ONE_MAX_LENGTH)
- en: '[PRE21]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: toolbox.register("populationCreator", \
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: toolbox.register("populationCreator", \
- en: tools.initRepeat, \
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: tools.initRepeat, \
- en: list, toolbox.individualCreator)
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: list, toolbox.individualCreator)
- en: '[PRE22]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'def oneMaxFitness(individual):'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def oneMaxFitness(individual):'
- en: 'return sum(individual), # return a tuple'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'return sum(individual), # 返回一个元组'
- en: '[PRE23]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'toolbox.register("tools module and setting the argument values as needed. Here,
    we chose the following:*   Tournament selection with a tournament size of 3*   Single-point
    crossover*   Flip-bit mutationNote the `indpb` parameter of the `mutFlipBit` function.
    This function iterates over all the attributes of the individual – a list containing
    values of 1s and 0s in our case – where each attribute will use this argument
    value as the probability of flipping (applying the `not` operator to) the attribute
    value. This value is independent of the mutation probability, which is set by
    the `P_MUTATION` constant that we defined earlier and has not been used yet. The
    mutation probability serves to decide whether the `mutFlipBit` function is called
    for a given individual in the population:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: toolbox.register("tools module and setting the argument values as needed. Here,
    we chose the following:*   锦标赛选择，锦标赛大小为3*   单点交叉*   翻转位突变请注意`mutFlipBit`函数的`indpb`参数。该函数会遍历个体的所有属性——在我们的情况下是包含1和0的列表——每个属性会使用该参数值作为翻转（应用`not`操作符）该属性值的概率。该值独立于突变概率，突变概率由我们之前定义的`P_MUTATION`常量设置，但尚未使用。突变概率用于决定是否对种群中的个体调用`mutFlipBit`函数：
- en: '[PRE24]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: population = toolbox.populationCreator(n=POPULATION_SIZE)
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: population = toolbox.populationCreator(n=POPULATION_SIZE)
- en: generationCounter = 0
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: generationCounter = 0
- en: '[PRE26]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: fitnessValues = list(map(toolbox.evaluate,\
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: fitnessValues = list(map(toolbox.evaluate,\
- en: population))
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: population))
- en: '[PRE27]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'for individual, fitnessValue in zip(population, fitnessValues):'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'for individual, fitnessValue in zip(population, fitnessValues):'
- en: individual.fitness.values = fitnessValue
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: individual.fitness.values = fitnessValue
- en: '[PRE28]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: fitnessValues = [
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: fitnessValues = [
- en: individual.fitness.values[0] for individual in population
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: individual.fitness.values[0] for individual in population
- en: ']'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '[PRE29]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: maxFitnessValues = []
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: maxFitnessValues = []
- en: meanFitnessValues = []
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: meanFitnessValues = []
- en: '[PRE30]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: while max(fitnessValues) < ONE_MAX_LENGTH and \
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: while max(fitnessValues) < ONE_MAX_LENGTH and \
- en: 'generationCounter < MAX_GENERATIONS:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'generationCounter < MAX_GENERATIONS:'
- en: '[PRE31]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: generationCounter = generationCounter + 1
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: generationCounter = generationCounter + 1
- en: '[PRE32]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: offspring = toolbox.select(population, len(population))
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: offspring = toolbox.select(population, len(population))
- en: '[PRE33]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: offspring = list(map(toolbox.clone, offspring))
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: offspring = list(map(toolbox.clone, offspring))
- en: '[PRE34]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'for child1, child2 in zip(offspring[::2], offspring[1::2]):'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'for child1, child2 in zip(offspring[::2], offspring[1::2]):'
- en: 'if random.random() < P_CROSSOVER:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if random.random() < P_CROSSOVER:'
- en: toolbox.mate(child1, child2)
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: toolbox.mate(child1, child2)
- en: del child1.fitness.values
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: del child1.fitness.values
- en: del child2.fitness.values
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: del child2.fitness.values
- en: '[PRE35]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'for mutant in offspring:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'for mutant in offspring:'
- en: 'if random.random() < P_MUTATION:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if random.random() < P_MUTATION:'
- en: toolbox.mutate(mutant)
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: toolbox.mutate(mutant)
- en: del mutant.fitness.values
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: del mutant.fitness.values
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: freshIndividuals = [
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: freshIndividuals = [
- en: ind for ind in offspring if not ind.fitness.valid]
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ind for ind in offspring if not ind.fitness.valid]
- en: freshFitnessValues = list(map(toolbox.evaluate,
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: freshFitnessValues = list(map(toolbox.evaluate,
- en: freshIndividuals))
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: freshIndividuals))
- en: for individual, fitnessValue in zip(freshIndividuals,
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: for individual, fitnessValue in zip(freshIndividuals,
- en: freshFitnessValues
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: freshFitnessValues
- en: '):'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '):'
- en: individual.fitness.values = fitnessValue
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: individual.fitness.values = fitnessValue
- en: '[PRE37]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: population[:] = offspring
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: population[:] = offspring
- en: '[PRE38]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: fitnessValues = [ind.fitness.values[0] for ind in population]
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: fitnessValues = [ind.fitness.values[0] for ind in population]
- en: '[PRE39]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: maxFitness = max(fitnessValues)
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: maxFitness = max(fitnessValues)
- en: meanFitness = sum(fitnessValues) / len(population)
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: meanFitness = sum(fitnessValues) / len(population)
- en: maxFitnessValues.append(maxFitness)
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: maxFitnessValues.append(maxFitness)
- en: meanFitnessValues.append(meanFitness)
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: meanFitnessValues.append(meanFitness)
- en: 'print(f"- Generation {generationCounter}:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'print(f"- 代数 {generationCounter}:'
- en: Max Fitness = {maxFitness}, \
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最大适应度 = {maxFitness}, \
- en: Avg Fitness = {meanFitness}")
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 平均适应度 = {meanFitness}")
- en: '[PRE40]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: best_index = fitnessValues.index(max(fitnessValues))
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: best_index = fitnessValues.index(max(fitnessValues))
- en: print("Best Individual = ", *population[best_index], "\n")
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print("最佳个体 = ", *population[best_index], "\n")
- en: '[PRE41]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: plt.plot(maxFitnessValues, color='red')
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: plt.plot(maxFitnessValues, color='red')
- en: plt.plot(meanFitnessValues, color='green')
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: plt.plot(meanFitnessValues, color='green')
- en: plt.xlabel('Generation')
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: plt.xlabel('代数')
- en: plt.ylabel('Max / Average Fitness')
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: plt.ylabel('最大/平均适应度')
- en: plt.title('Max and Average fitness over Generations')
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: plt.title('代数中的最大与平均适应度')
- en: plt.show()
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: plt.show()
- en: '[PRE42]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '- Generation 1: Max Fitness = 65.0, Avg Fitness = 53.575'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '- 代数 1: 最大适应度 = 65.0, 平均适应度 = 53.575'
- en: Best Individual = 1 1 0 1 0 1 0 0 1 0 0 0 1 1 1 0 1 0 0 1 0 1 0 0 0 1 1 1 1
    1 0 1 1 1 1 0 1 0 1 1 1 1 0 0 1 1 111101111101111111000 0 1 0 1 0 1 1 1 0 1 1
    0 0 0 1 1 1 0011111111111100
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳个体 = 1 1 0 1 0 1 0 0 1 0 0 0 1 1 1 0 1 0 0 1 0 1 0 0 0 1 1 1 1 1 0 1 1 1 1
    0 1 0 1 1 1 1 0 0 1 1 111101111101111111000 0 1 0 1 0 1 1 1 0 1 1 0 0 0 1 1 1
    0011111111111100
- en: '...'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '- Generation 40: Max Fitness = 100.0, Avg Fitness = 98.29'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '- 代数 40: 最大适应度 = 100.0, 平均适应度 = 98.29'
- en: Best Individual = 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 111111111111111111111 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1111111111111111
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳个体 = 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 111111111111111111111 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1111111111111111
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'stats = tools.Statistics(lambda ind: ind.fitness.values)'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'stats = tools.Statistics(lambda ind: ind.fitness.values)'
- en: '[PRE44]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: stats.register("max", numpy.max)
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: stats.register("max", numpy.max)
- en: stats.register("avg", numpy.mean)
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: stats.register("avg", numpy.mean)
- en: '[PRE45]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: population, logbook = algorithms.eaSimple(population, toolbox,
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 种群，日志 = 算法.eaSimple(种群, 工具箱,
- en: cxpb=P_CROSSOVER,
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: cxpb=P_CROSSOVER,
- en: mutpb=P_MUTATION,
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: mutpb=P_MUTATION,
- en: ngen=MAX_GENERATIONS,
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ngen=MAX_GENERATIONS,
- en: stats=stats,
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: stats=stats,
- en: verbose=True)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: verbose=True)
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: maxFitnessValues, meanFitnessValues = logbook.select("max", "avg")
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: maxFitnessValues, meanFitnessValues = logbook.select("max", "avg")
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: gen   nevals  max    avg
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 代数   评估次数  最大    平均
- en: 0     200     61     49.695
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 0     200     61     49.695
- en: 1     193     65     53.575
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 1     193     65     53.575
- en: '...'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 39    192     99     98.04
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 39    192     99     98.04
- en: 40    173     100    98.29
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 40    173     100    98.29
- en: '...'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 49    187     100    99.83
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 49    187     100    99.83
- en: 50    184     100    99.89
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 50    184     100    99.89
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: HALL_OF_FAME_SIZE = 10
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: HALL_OF_FAME_SIZE = 10
- en: '[PRE49]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: hof = tools.HallOfFame(HALL_OF_FAME_SIZE)
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: hof = tools.HallOfFame(HALL_OF_FAME_SIZE)
- en: '[PRE50]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: population, logbook = algorithms.eaSimple(\
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 种群，日志 = 算法.eaSimple(\
- en: population, toolbox, cxpb=P_CROSSOVER, \
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 种群，工具箱，cxpb=P_CROSSOVER, \
- en: mutpb=P_MUTATION, ngen=MAX_GENERATIONS, \
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: mutpb=P_MUTATION, ngen=MAX_GENERATIONS, \
- en: stats=stats, halloffame=hof, verbose=True)
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: stats=stats, halloffame=hof, verbose=True)
- en: '[PRE51]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: print("Hall of Fame Individuals = ", *hof.items, sep="\n")
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print("名人堂个体 = ", *hof.items, sep="\n")
- en: print("Best Ever Individual = ", hof.items[0])
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print("最佳历史个体 = ", hof.items[0])
- en: '[PRE52]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Hall of Fame Individuals =
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名人堂个体 =
- en: '[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  [1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  [1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]'
- en: '...'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE53]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Best Ever Individual = [1, 1, 1, 1, ..., 0, ..., 1]
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最佳个体 = [1, 1, 1, 1, ..., 0, ..., 1]
- en: '[PRE54]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: POPULATION_SIZE = 400
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: POPULATION_SIZE = 400
- en: '[PRE55]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: POPULATION_SIZE = 100
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: POPULATION_SIZE = 100
- en: '[PRE56]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: MAX_GENERATIONS = 80
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MAX_GENERATIONS = 80
- en: '[PRE57]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: toolbox.register("mate", tools.cxTwoPoint)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 工具箱.register("配对", tools.cxTwoPoint)
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: toolbox.register("mutate", tools.mutFlipBit, \
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 工具箱.register("变异", tools.mutFlipBit, \
- en: P_MUTATION determines the probability of an individual being mutated, indpb
    determines the probability of each bit in a given individual being flipped. In
    our program, we set the value of indpb to 1.0/ONE_MAX_LENGTH, which means that,
    on average, a single bit will be flipped in a mutated solution. For our 100-bit-long
    OneMax problem, this seems to limit the effect of the mutation, regardless of
    the P_MUTATION constant value.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: P_MUTATION决定个体变异的概率，indpb决定给定个体中每位的翻转概率。在我们的程序中，我们将indpb的值设置为1.0/ONE_MAX_LENGTH，这意味着在变异解中平均会翻转一位。对于我们的100位OneMax问题，这似乎限制了变异的效果，无论P_MUTATION常数值如何。
- en: 'Now, let’s increase the value of **indpb** tenfold, as follows:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将**indpb**的值增加十倍，如下所示：
- en: '[PRE59]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The result of running the algorithm with this value is somewhat erratic, as
    shown in the following figure:'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用此值运行算法的结果有些不稳定，如下图所示：
- en: '![Figure 3.8: Stats of the program after a tenfold increase in the per-bit
    mutation probability](img/B20851_03_8.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8：在每位变异概率增加十倍后程序的统计数据](img/B20851_03_8.jpg)'
- en: 'Figure 3.8: Stats of the program after a tenfold increase in the per-bit mutation
    probability'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：在每位变异概率增加十倍后程序的统计数据
- en: The figure indicates that while at first, the algorithm can improve the results,
    it quickly gets stuck in a state of oscillations without being able to make significant
    improvements.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示，尽管一开始算法可以改善结果，但很快陷入振荡状态，无法取得显著改进。
- en: 'Increasing the **indpb** value further, to **50.0/ONE_MAX_LENGTH**, results
    in the following, unstable-looking, graph:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进一步增加**indpb**值至**50.0/ONE_MAX_LENGTH**，得到如下不稳定的图表：
- en: '![Figure 3.9: Stats of the program after a fifty-fold increase in the per-bit
    mutation probability](img/B20851_03_9.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9：在每位变异概率增加五十倍后程序的统计数据](img/B20851_03_9.jpg)'
- en: 'Figure 3.9: Stats of the program after a fifty-fold increase in the per-bit
    mutation probability'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：在每位变异概率增加五十倍后程序的统计数据
- en: As evident from this plot, the genetic algorithm has turned into the equivalent
    of a random search – it may stumble upon the best solution by chance, but it doesn’t
    make any progress toward better solutions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这张图所示，遗传算法已经变成了等效于随机搜索的过程 – 它可能偶然发现最佳解，但没有向更好的解决方案前进。
- en: Selection operator
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 选择操作符
- en: Next, we’ll look at the **selection** operator. First, we’ll change the tournament
    size to see the combined effect of this parameter with the mutation probability.
    Then, we’ll look at using *roulette* selection instead of *tournament* selection.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看**selection**操作符。首先，我们将改变锦标赛规模以观察该参数与变异概率的综合效果。然后，我们将考虑使用*轮盘*选择而不是*锦标赛*选择。
- en: Tournament size and relation to mutation probability
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 锦标赛规模及其与变异概率的关系
- en: 'Once again, we’ll start by changing back to the original settings of the program
    before we make new modifications and run some experiments:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将从程序的原始设置开始，进行新的修改和实验之前：
- en: 'First, we’ll modify the **tournamentSize** parameter of the tournament selection
    algorithm and change it to **2** (instead of the original value of **3**):'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将修改锦标赛选择算法的**tournamentSize**参数，并将其改为**2**（而不是原来的**3**）：
- en: '[PRE60]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This doesn’t seem to have a noticeable effect on the algorithm’s behavior:'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这似乎对算法的行为没有明显影响：
- en: '![Figure 3.10: Stats of the program solving the OneMax problem after decreasing
    the tournament size to 2](img/B20851_03_10.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10：在将锦标赛规模减少至2后程序解决OneMax问题的统计数据](img/B20851_03_10.jpg)'
- en: 'Figure 3.10: Stats of the program solving the OneMax problem after decreasing
    the tournament size to 2'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：在将锦标赛规模减少至2后程序解决OneMax问题的统计数据
- en: What if we increase the tournament size to a very large value, say **100**?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将锦标赛规模增加到一个非常大的值，比如**100**，会发生什么？
- en: 'Let’s see:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看：
- en: '[PRE61]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The algorithm still behaves well and finds the best solution in less than 40
    generations. One noticeable effect is that the max fitness now closely resembles
    the average fitness, as shown in the following graph:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该算法仍然表现良好，并在不到40代中找到了最佳解。一个显著的效果是最大适应度现在与平均适应度非常接近，如下图所示：
- en: '![Figure 3.11: Stats of the program after increasing the tournament size to
    100](img/B20851_03_11.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11：在将锦标赛规模增加至100后程序的统计数据](img/B20851_03_11.jpg)'
- en: 'Figure 3.11: Stats of the program after increasing the tournament size to 100'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：在将锦标赛规模增加至100后程序的统计数据
- en: This behavior occurs because when the tournament size increases, the chance
    of weak individuals being selected diminishes, and better solutions tend to take
    over the population. In real-life problems, this takeover might cause suboptimal
    solutions to saturate the population and prevent the best solution from being
    found (a phenomenon known as **premature convergence**). However, in the case
    of the simple OneMax problem, this doesn’t seem to be an issue. A possible explanation
    is that the mutation operator provides enough diversity to keep the solutions
    moving in the right direction.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为发生的原因是，当锦标赛规模增大时，弱个体被选中的机会减少，较好的解法倾向于占据整个种群。在实际问题中，这种占据可能导致次优解充斥种群，从而阻止最佳解的出现（这种现象称为**过早收敛**）。然而，在简单的OneMax问题中，这似乎不是问题。一个可能的解释是，突变操作符提供了足够的多样性，确保解法朝着正确的方向前进。
- en: 'To put this explanation to the test, let’s reduce the mutation probability
    tenfold, to **0.01**:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证这个解释，我们将突变概率降低十倍，设为**0.01**：
- en: '[PRE62]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If we run the algorithm again, we’ll see that the results stop improving soon
    after the start of the algorithms, and then improve at a much slower pace, with
    an occasional improvement here and there. The overall results are far worse than
    the previous run as the best fitness is around 80 rather than 100:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们再次运行算法，我们会看到结果在算法开始后很快停止改善，然后以更慢的速度改进，偶尔会有一些提升。整体结果比上一次运行差得多，因为最佳适应度大约是80，而不是100：
- en: '![Figure 3.12: Stats of the program with a tournament size of 100 and a mutation
    probability of 0.01](img/B20851_03_12.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12：程序统计，锦标赛规模为100，突变概率为0.01](img/B20851_03_12.jpg)'
- en: 'Figure 3.12: Stats of the program with a tournament size of 100 and a mutation
    probability of 0.01'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12：程序统计，锦标赛规模为100，突变概率为0.01
- en: This interpretation is that due to the large tournament size, the best individuals
    from the initial population take over within a small number of generations, which
    shows in the initial quick increase of both graphs in the plot. After that, only
    an occasional mutation in the right direction – one that flips a 0 to 1 –creates
    a better individual; this is indicated in the plot by a jump of the red line.
    Soon after, this individual takes over the entire population again, where the
    green line catches up with the red one.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这一解释是，由于锦标赛规模较大，初始种群中的最佳个体在少数几代内就占据了主导地位，这在图表的初期迅速增长中得到了体现。之后，只有偶尔出现正确方向的突变——即将0翻转为1——才能产生更好的个体；这一点在图表中通过红线的跃升表示。很快，这个个体又会占据整个种群，绿线会追赶上红线。
- en: 'To make this situation even more extreme, we can further reduce the mutation
    rate:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这种情况更加极端，我们可以进一步降低突变率：
- en: '[PRE63]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can now see the same general behavior, but since mutations are very rare,
    the improvements are few and far between:'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以看到相同的一般行为，但由于突变非常罕见，改进也很少且间隔较长：
- en: '![Figure 3.13: Stats of the program with a tournament size of 100 and a mutation
    probability of 0.001](img/B20851_03_13.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13：程序统计，锦标赛规模为100，突变概率为0.001](img/B20851_03_13.jpg)'
- en: 'Figure 3.13: Stats of the program with a tournament size of 100 and a mutation
    probability of 0.001'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13：程序统计，锦标赛规模为100，突变概率为0.001
- en: 'Now, if we increase the number of generations to 500, we can see this behavior
    more clearly:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们将代数增加到500代，我们可以更清楚地看到这种行为：
- en: '![Figure 3.14: Stats of the program with a tournament size of 100 and a mutation
    probability of 0.001, over 500 generations](img/B20851_03_14.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14：程序统计，锦标赛规模为100，突变概率为0.001，经过500代](img/B20851_03_14.jpg)'
- en: 'Figure 3.14: Stats of the program with a tournament size of 100 and a mutation
    probability of 0.001, over 500 generations'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14：程序统计，锦标赛规模为100，突变概率为0.001，经过500代
- en: 'Just out of curiosity, let’s dial back the tournament size to **3** again and
    restore the number of generations to **50**, leaving the small mutation rate in
    place:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出于好奇，我们将锦标赛规模再次调整为**3**，并将代数恢复为**50**代，同时保持较小的突变率：
- en: '[PRE64]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The resulting plot is a lot closer to the original one:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终的图表与原始图表更为接近：
- en: '![Figure 3.15: Stats of the program with a tournament size of 3 and a mutation
    probability of 0.001, over 50 generations](img/B20851_03_15.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15：程序统计，锦标赛规模为3，突变概率为0.001，经过50代](img/B20851_03_15.jpg)'
- en: 'Figure 3.15: Stats of the program with a tournament size of 3 and a mutation
    probability of 0.001, over 50 generations'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15：程序在使用锦标赛规模为 3 和突变概率为 0.001 的情况下，在 50 代中的统计数据
- en: Here, it seems that a takeover occurred as well, but far later, around generation
    30, when the best fitness was already close to the maximum value of 100\. Here,
    a more reasonable mutation rate would help us find the best solution, as happened
    with the original settings.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，似乎也发生了接管现象，但发生得较晚，大约是在第 30 代左右，当时最好的适应度已经接近 100 的最大值。在这种情况下，使用更合理的突变率将帮助我们找到最佳解决方案，就像在原始设置中发生的那样。
- en: Roulette wheel selection
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 轮盘赌选择
- en: 'Let’s go back to the original settings once more, in preparation for our last
    experiment, as we will now try replacing the tournament selection algorithm with
    **roulette wheel selection**, which was described in [*Chapter 2*](B20851_02.xhtml#_idTextAnchor053),
    *Understanding the Key Components of Genetic Algorithms*. This is done as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再一次回到原始设置，准备进行最后的实验，因为我们将尝试用**轮盘赌选择**替换锦标赛选择算法，这在[*第2章*](B20851_02.xhtml#_idTextAnchor053)中有描述，*理解遗传算法的关键组件*。操作步骤如下：
- en: '[PRE65]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This change seems to harm the algorithm’s results. As the following plot shows,
    there are numerous points in time where the best solution is forgotten as a result
    of the selection, and the max fitness value decreases, at least temporarily, although
    the average fitness value keeps increasing. This is because the roulette selection
    algorithm selects individuals with a probability proportionate to their fitness;
    when the differences between the individuals are relatively small, there is a
    better chance for weaker individuals to be selected, in comparison to the tournament
    selection we had before:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变化似乎对算法的结果造成了负面影响。正如下面的图所示，在多个时刻，由于选择过程的影响，最佳解决方案被遗忘，并且最大适应度值至少在短期内下降，尽管平均适应度值仍在上升。这是因为轮盘赌选择算法以与适应度成比例的概率选择个体；当个体之间的差异较小的时候，较弱个体被选中的机会更大，这与我们之前使用的锦标赛选择方法不同：
- en: '![Figure 3.16: Stats of the program when using roulette wheel selection](img/B20851_03_16.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16：使用轮盘赌选择的程序统计数据](img/B20851_03_16.jpg)'
- en: 'Figure 3.16: Stats of the program when using roulette wheel selection'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16：使用轮盘赌选择的程序统计数据
- en: To compensate for this behavior, we can use the **elitist approach** mentioned
    in [*Chapter 2*](B20851_02.xhtml#_idTextAnchor053), *Understanding the Key Components
    of Genetic Algorithms*. This approach allows a certain number of the best individuals
    from the current generation to carry over to the next generation unaltered and
    prevents them from being lost. In the next chapter, we will explore applying the
    elitist approach when using the DEAP library.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弥补这种行为，我们可以使用在[*第2章*](B20851_02.xhtml#_idTextAnchor053)中提到的**精英主义方法**，*理解遗传算法的关键组件*。该方法允许当前世代中最优秀的个体直接转移到下一代，并且保持不变，从而避免它们的丧失。在下一章中，我们将探讨在使用
    DEAP 库时应用精英主义方法。
- en: Summary
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 小结
- en: In this chapter, you were introduced to `creator` and `toolbox` modules, and
    how to use them to create the various components needed for the genetic algorithm’s
    flow. DEAP was then used to write two versions of a Python program that solves
    the *OneMax* problem, the first with full implementation of the genetic algorithm
    flow, and the other – more concise – taking advantage of the built-in algorithms
    of the framework. A third version of the program introduced the HOF feature offered
    by DEAP. We then experimented with various settings of the genetic algorithm and
    discovered the effects of changing the population size, as well as modifying the
    *selection*, *crossover*, and *mutation* operators.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您介绍了 `creator` 和 `toolbox` 模块，以及如何使用它们来创建遗传算法流程所需的各种组件。接着，我们使用 DEAP 编写了两个版本的
    Python 程序来解决 *OneMax* 问题，第一个版本是完整实现遗传算法流程，第二个版本则更简洁，利用了框架中内置的算法。第三个版本引入了 DEAP
    提供的 HOF 特性。然后，我们通过不同的遗传算法设置进行实验，发现了改变种群大小、以及修改 *选择*、*交叉* 和 *突变* 运算符的效果。
- en: In the next chapter, expanding on what we learned in this chapter, we will start
    solving real-life combinatorial problems, including the *traveling salesman problem*
    and the *vehicle routing problem*, using DEAP-based Python programs.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，基于本章的内容，我们将开始解决实际的组合优化问题，包括*旅行商问题*和*车辆路径规划问题*，并使用基于 DEAP 的 Python 程序来实现。
- en: Further reading
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, please refer to the following resources:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请参考以下资源：
- en: 'DEAP documentation: [https://deap.readthedocs.io/en/master/](https://deap.readthedocs.io/en/master/)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DEAP 文档：[https://deap.readthedocs.io/en/master/](https://deap.readthedocs.io/en/master/)
- en: 'DEAP source code on GitHub: [https://github.com/DEAP/deap](https://github.com/DEAP/deap)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DEAP 源代码在 GitHub 上：[https://github.com/DEAP/deap](https://github.com/DEAP/deap)
- en: '[PRE66]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
