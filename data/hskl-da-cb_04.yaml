- en: Chapter 4. Data Hashing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 数据哈希
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Hashing a primitive data type
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希原始数据类型
- en: Hashing a custom data type
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希自定义数据类型
- en: Running popular cryptographic hash functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行流行的加密哈希函数
- en: Running a cryptographic checksum on a file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对文件运行加密校验和
- en: Performing fast comparisons between data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据类型之间进行快速比较
- en: Using a high-performance hash table
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高性能哈希表
- en: Using Google's CityHash hash functions for strings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google的CityHash哈希函数对字符串进行哈希
- en: Computing Geohash for location coordinates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算位置坐标的Geohash
- en: Using a bloom filter to remove unique items
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布隆过滤器去除唯一项
- en: Running MurmurHash, a simple but speedy hashing algorithm
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行MurmurHash，一个简单但快速的哈希算法
- en: Measuring image similarity with perceptual hashes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用感知哈希测量图像相似度
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '![Introduction](img/ch04.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/ch04.jpg)'
- en: A **hash** is a lossy way of representing an object into a small and typically
    fixed-length value. Hashing data embellishes us with speedy lookups and lightweight
    handling of massive datasets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希**是一种有损的方式，将对象表示为一个小而通常是固定长度的值。哈希数据使我们能够快速查找和轻松处理大量数据集。'
- en: The output of a hashing function is referred to as a **digest**. One of the
    principal properties of a good hashing function is that it must be deterministic,
    which means a given input must always produce the same corresponding output. Sometimes,
    two different inputs may end up producing the same output, and we call that a
    **collision**. Given a hash alone, we cannot invert the process to rediscover
    the object within an adequate time. To minimize the chances of a collision, another
    property of a hash function called **uniformity** is used. In other words, the
    probability of each output occurring should be nearly the same.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的输出被称为**摘要**。一个好的哈希函数的主要特性之一是它必须是确定性的，这意味着给定的输入必须始终产生相同的输出。有时，两个不同的输入可能最终产生相同的输出，我们称之为**碰撞**。仅凭哈希值，我们无法反转过程在合理的时间内重新发现原始对象。为了最小化碰撞的几率，哈希函数的另一个特性叫做**均匀性**。换句话说，每个输出出现的概率应该几乎相同。
- en: We will start by first producing a simple digest from an input. Then in the
    next recipe, we will run the hashing algorithm on our custom-made data type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先从输入生成一个简单的摘要。然后，在下一个食谱中，我们将对自定义数据类型运行哈希算法。
- en: Another important application of hashing is in cryptography. We will cover some
    of the most popular cryptographic hashing algorithms such as SHA-512\. We will
    also apply these hashes on files for computing checksums to ensure file integrity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希的另一个重要应用是在加密学中。我们将介绍一些最流行的加密哈希算法，如SHA-512。我们还将应用这些哈希对文件进行校验和计算，以确保文件完整性。
- en: Lastly, we will cover many nontraditional hashing approaches including CityHash,
    GeoHashing, bloom filters, MurmurHash, and pHash.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍许多非传统的哈希方法，包括CityHash、GeoHashing、布隆过滤器、MurmurHash和pHash。
- en: Hashing a primitive data type
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希原始数据类型
- en: This recipe demonstrates how to use a simple hash function on various primitive
    data types.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱演示了如何在各种原始数据类型上使用简单的哈希函数。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `Data.Hashable` package from Cabal as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从Cabal安装`Data.Hashable`包，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Import the hashing function with the following line:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下行导入哈希函数：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Test the `hash` function on a string as follows; this function is actually
    a wrapper around the `hashWithSalt` function with a default salt value:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试`hash`函数对字符串的作用，如下所示；该函数实际上是一个包装器，围绕着默认盐值的`hashWithSalt`函数：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Test out the `hashWithSalt` functions using different initial salt values as
    follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同的初始盐值测试`hashWithSalt`函数，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also hash tuples and lists as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以如下对元组和列表进行哈希：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice in the following output how the first three hashes produce different
    results even though their input is the same:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意以下输出中的前三个哈希尽管输入相同，却产生了不同的结果：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Hashing with a salt means applying the hash function only after slightly modifying
    it. It's as if we "salted up" the input before processing it through the hash
    function. Even the slightest change in salt values produces dramatically different
    hashed digests.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用盐值进行哈希意味着在稍微修改数据后再应用哈希函数。就像我们在通过哈希函数处理输入之前“加盐”了一样。即使盐值稍有变化，也会产生完全不同的哈希摘要。
- en: We need this concept of a salt for better password security. Hash functions
    always produce the same output for the same input, and this is both good and bad.
    There are databases of rainbow tables for every commonly used password in existence
    for all major hashing algorithms. If a website with a login system service (such
    as Packt Publishing) stores the password using cryptographic hashes, but without
    being salted, then it's no better than plain text if the password itself is considered
    weak. If a service such as Packt Publishing uses salt in its cryptographic hashing
    (and it should), then it's an added layer of security and rainbow tables are rendered
    useless.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这种盐的概念来提高密码安全性。哈希函数对于相同的输入总是产生相同的输出，这既有好处也有坏处。对于所有主要的哈希算法，都有现成的彩虹表数据库，其中包含每个常用密码。如果一个具有登录系统服务的网站（例如
    Packt Publishing）使用加密哈希存储密码，但没有使用盐，那么如果密码本身被认为是弱密码，它与明文密码没有区别。如果像 Packt Publishing
    这样的服务在其加密哈希中使用盐（并且应该使用），那么它就增加了一层安全性，而彩虹表则变得无用。
- en: There's more…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'The previous code produced a hash of a string, but the algorithm is not limited
    to just strings. The following data types also implement `hashable`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码生成了一个字符串的哈希，但这个算法不限于字符串。以下数据类型也实现了 `hashable`：
- en: Bool
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bool
- en: Char
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Char
- en: Int
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int
- en: Int8
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int8
- en: Int16
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int16
- en: Int32
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int32
- en: Int64
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int64
- en: Word
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Word
- en: Word8
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Word8
- en: Word16
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Word16
- en: Word32
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Word32
- en: Word64
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Word64
- en: ByteString
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ByteString
- en: List of hashable items
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可哈希项的列表
- en: Tuple of hashable items
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希项的元组
- en: Maybe of a hashable item
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许是一个可哈希的项
- en: See also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: For using a hash function on a custom-made data type, refer to the *Hashing
    a custom data type* recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何对自定义数据类型使用哈希函数，请参考 *哈希一个自定义数据类型* 这个配方。
- en: Hashing a custom data type
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希一个自定义数据类型
- en: Even a custom-defined data type can be hashed easily. Dealing with hashed digests
    is often useful when the data itself is too space consuming to manage directly.
    By referencing a data by its digest, we can easily skip the cost of carrying around
    whole data types. This is especially useful in data analysis.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是自定义定义的数据类型也可以轻松进行哈希。当数据本身占用空间过大，无法直接管理时，处理哈希摘要通常非常有用。通过使用数据的摘要引用，我们可以轻松避免携带整个数据类型的开销。这在数据分析中尤其有用。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: 'Install the `Data.Hashable` package from Cabal as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式从 Cabal 安装 `Data.Hashable` 包：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How to do it…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Use the GHC language extension `DeriveGeneric` to autodefine the hash functions
    for our custom data types as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 GHC 语言扩展 `DeriveGeneric` 自动定义我们自定义数据类型的哈希函数，如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Import the relevant packages using the following lines of code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行导入相关包：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a custom data type and let `GHC` autodefine its hashable instance as
    follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自定义数据类型，并让 `GHC` 自动定义其哈希实例，如下所示：
- en: '[PRE9]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `main`, create three points. Let two of them be the same, and let the third
    point be different, as shown in the following code snippet:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 中，创建三个点。让其中两个相同，第三个不同，如以下代码片段所示：
- en: '[PRE10]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Print the hash values of identical points as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印相同点的哈希值，如下所示：
- en: '[PRE11]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Print the hash values of different points as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印不同点的哈希值，如下所示：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output will be as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE13]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There's more…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'We can define a custom hashing function on our own data types by providing
    an instance for Hashable. The Hashable instance only requires the implementation
    of `hashWithSalt :: Int -> a -> Int`. To help implement `hashWithSalt`, we also
    have two useful functions:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以通过为 `Hashable` 提供实例来为自定义数据类型定义哈希函数。`Hashable` 实例只需要实现 `hashWithSalt ::
    Int -> a -> Int`。为了帮助实现 `hashWithSalt`，我们还提供了两个有用的函数：'
- en: 'Hashing a pointer with salt is performed as shown in the following code snippet:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用盐对指针进行哈希操作，如以下代码片段所示：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Hashing a byte array with salt is performed as shown in the following code
    snippet:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用盐对字节数组进行哈希操作，如以下代码片段所示：
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: To hash a built-in primitive, refer to the *Hashing a primitive data type* recipe.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要哈希一个内建的原始类型，请参考 *哈希一个原始数据类型* 这个配方。
- en: Running popular cryptographic hash functions
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行流行的加密哈希函数
- en: A cryptographic hash function has specific properties that make it different
    from other hash functions. First of all, producing a possible input message from
    a given hash digest output should be intractable, meaning that it must take an
    exponentially long time to solve in practice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个加密哈希函数具有特定的属性，使其与其他哈希函数不同。首先，从给定的哈希摘要输出生成可能的输入消息应该是不可行的，意味着在实践中解决这个问题必须耗费指数级的时间。
- en: For example, if a hash produces the digest `66fc01ae071363ceaa4178848c2f6224`,
    then in principle, discovering the content used to generate a digest should be
    difficult.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果哈希值产生了摘要`66fc01ae071363ceaa4178848c2f6224`，那么原则上，发现用于生成摘要的内容应该是困难的。
- en: In practice, some hash functions are easier to crack than others. For example,
    MD5 and SHA-1 are considered trivial to crack and should not be used, but are
    demonstrated later for completeness. More information about how MD5 and SHA-1
    are insecure can be found at [http://www.win.tue.nl/hashclash/rogue-ca](http://www.win.tue.nl/hashclash/rogue-ca)
    and [https://www.schneier.com/blog/archives/2005/02/cryptanalysis_o.html](https://www.schneier.com/blog/archives/2005/02/cryptanalysis_o.html)
    respectively.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，一些哈希函数比其他的更容易破解。例如，MD5和SHA-1被认为很容易破解，不应再使用，但为了完整性，稍后会展示这两个哈希函数。关于MD5和SHA-1不安全的更多信息可以参考[http://www.win.tue.nl/hashclash/rogue-ca](http://www.win.tue.nl/hashclash/rogue-ca)和[https://www.schneier.com/blog/archives/2005/02/cryptanalysis_o.html](https://www.schneier.com/blog/archives/2005/02/cryptanalysis_o.html)。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `Crypto.Hash` package from Cabal as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从Cabal安装`Crypto.Hash`包，如下所示：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Import the cryptographic hash function library as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式导入加密哈希函数库：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define each hash functions by explicitly associating the data types as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式通过明确关联数据类型来定义每个哈希函数：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Test out each cryptographic hash function on the same input, as shown in the
    following code snippet:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下代码片段测试每个加密哈希函数在相同输入上的表现：
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The final output can be seen in the following screenshot:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终输出可在以下截图中看到：
- en: '[PRE20]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![How to do it…](img/6331OS_04_05.jpg)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作……](img/6331OS_04_05.jpg)'
- en: See also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: To run one of these cryptographic hash functions on a file to perform an integrity
    check, refer to the *Running a cryptographic checksum on a file* recipe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在文件上运行这些加密哈希函数以执行完整性检查，请参考*在文件上运行加密校验和*的配方。
- en: Running a cryptographic checksum on a file
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件上运行加密校验和
- en: One of the most effective methods to determine whether a file on a computer
    is different from another file elsewhere is by comparing their cryptographic hashes.
    If the two hashes are equal, it's only highly probable that the files are equal,
    but not strictly necessary due to the possibility of collisions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 判断计算机上的文件是否与其他地方的文件不同的最有效方法之一是通过比较它们的加密哈希值。如果两个哈希值相等，虽然文件相等的可能性非常高，但由于碰撞的可能性，不能严格保证文件完全相同。
- en: 'After downloading a file online, such as Arch Linux from [https://www.archlinux.org/download](https://www.archlinux.org/download),
    it is a good idea to ensure the cryptographic hashes match up. For example, have
    a look at the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下载一个文件，例如从[https://www.archlinux.org/download](https://www.archlinux.org/download)下载Arch
    Linux，最好确保其加密哈希值匹配。例如，看看以下截图：
- en: '![Running a cryptographic checksum on a file](img/6331OS_04_07.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![在文件上运行加密校验和](img/6331OS_04_07.jpg)'
- en: The preceding screenshot shows the corresponding hashes for the Arch Linux download
    as of late May, 2014.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了截至2014年5月底Arch Linux下载的相应哈希值。
- en: Notice how both MD5 and SHA1 hashes are provided. This recipe will show how
    to compute these hashes in Haskell to ensure data integrity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意同时提供了MD5和SHA1哈希值。本配方将展示如何在Haskell中计算这些哈希值，以确保数据的完整性。
- en: We will compute the SHA256, SHA512, and MD5 hashes of its own source file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将计算其源文件的SHA256、SHA512和MD5哈希值。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `Crypto.Hash` package from Cabal as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从Cabal安装`Crypto.Hash`包，如下所示：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How to do it…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Create a file named `Main.hs` and insert the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Main.hs`的文件，并插入以下代码：
- en: 'Import the relevant packages as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式导入相关的包：
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define the `MD5` hash function as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式定义`MD5`哈希函数：
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define the `SHA256` hash function as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式定义`SHA256`哈希函数：
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Define the `SHA512` hash function as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式定义`SHA512`哈希函数：
- en: '[PRE25]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Open a file of the `ByteString` type using the `readFile` function provided
    by the `Data.ByteString` package as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Data.ByteString`包提供的`readFile`函数打开`ByteString`类型的文件，如下所示：
- en: '[PRE26]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Test out the various hashes on the file as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式测试文件上的各种哈希值：
- en: '[PRE27]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following output is generated:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是生成的输出：
- en: '[PRE28]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: See also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: To apply the cryptographic hash functions on data types instead, refer to the
    *Running popular cryptographic hash functions* recipe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在数据类型上应用加密哈希函数，请参考*运行常见加密哈希函数*的配方。
- en: Performing fast comparisons between data types
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行数据类型间的快速比较
- en: 'The `StableName` package allows us to establish constant time comparisons of
    arbitrary data types. The Hackage documentation elegantly describes this ([http://hackage.haskell.org/package/base-4.7.0.0/docs/System-Mem-StableName.html](http://hackage.haskell.org/package/base-4.7.0.0/docs/System-Mem-StableName.html)):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`StableName`包允许我们对任意数据类型建立常数时间的比较。Hackage文档优雅地描述了这一点（[http://hackage.haskell.org/package/base-4.7.0.0/docs/System-Mem-StableName.html](http://hackage.haskell.org/package/base-4.7.0.0/docs/System-Mem-StableName.html)）：'
- en: '*"Stable names solve the following problem: suppose you want to build a hash
    table with Haskell objects as keys, but you want to use pointer equality for comparison;
    maybe because the keys are large and hashing would be slow, or perhaps because
    the keys are infinite in size. We can''t build a hash table using the address
    of the object as the key, because objects get moved around by the garbage collector,
    meaning a re-hash would be necessary after every garbage collection."*'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“稳定名称解决了以下问题：假设你想要用Haskell对象作为键来构建哈希表，但你希望使用指针相等性进行比较；可能是因为键非常大，哈希操作会很慢，或者是因为键的大小是无限的。我们不能使用对象的地址作为键来构建哈希表，因为对象会被垃圾收集器移动，这意味着每次垃圾回收后都需要重新哈希。”*'
- en: How to do it…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Import the built-in `StableName` package as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式导入内置的`StableName`包：
- en: '[PRE29]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a custom data type as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式创建一个自定义数据类型：
- en: '[PRE30]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In `main`, define two points as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`中，按如下方式定义两个点：
- en: '[PRE31]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Get the stable name of each point and display it using the following set of
    commands:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取每个点的稳定名称，并使用以下命令集显示它：
- en: '[PRE32]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice in the following result how we can easily obtain the stable name of
    arbitrary data types:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意以下结果，我们可以轻松获取任意数据类型的稳定名称：
- en: '[PRE33]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using a high-performance hash table
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高性能哈希表
- en: Haskell already comes with a `Data.Map` module based on size-balanced binary
    trees. There exist better-optimized hash table libraries such as `Data.HashMap`
    from the unordered-containers package.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell已经提供了一个基于大小平衡二叉树的`Data.Map`模块。还有一些优化更好的哈希表库，如`unordered-containers`包中的`Data.HashMap`。
- en: For example, both `Data.Map` and `Data.HashMap` have insertion and lookup time
    complexities of O(log n); however, the latter uses a large base, so in practice
    these operations are constant time. More documentation on `Data.HashMap` can be
    found at [http://hackage.haskell.org/package/unordered-containers-0.2.4.0/docs/Data-HashMap-Lazy.html](http://hackage.haskell.org/package/unordered-containers-0.2.4.0/docs/Data-HashMap-Lazy.html).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Data.Map`和`Data.HashMap`都具有O(log n)的插入和查找时间复杂度；然而，后者使用了较大的基数，因此在实际操作中，这些操作是常数时间。有关`Data.HashMap`的更多文档可以在[http://hackage.haskell.org/package/unordered-containers-0.2.4.0/docs/Data-HashMap-Lazy.html](http://hackage.haskell.org/package/unordered-containers-0.2.4.0/docs/Data-HashMap-Lazy.html)找到。
- en: In this recipe, we will use the unordered-contains library from Hackage to create
    a mapping of word size to a set of words of that size.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Hackage上的unordered-contains库，创建一个将单词长度映射到该长度单词集合的映射。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Download a large corpus of text and name the file `big.txt` as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下载一个大文本语料库并将文件命名为`big.txt`，如下所示：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Install the `Data.HashMap` package using Cabal as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cabal安装`Data.HashMap`包，方法如下：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How to do it…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Import the `HashMap` package as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式导入`HashMap`包：
- en: '[PRE36]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a helper function to define an empty hash map using the following line
    of code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个辅助函数来定义一个空的哈希映射，使用以下代码行：
- en: '[PRE37]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define a function to insert a word to the hash map using the following code
    snippet:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段定义一个函数，将单词插入哈希映射：
- en: '[PRE38]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Find all words of a specific length from a map as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式从映射中查找特定长度的所有单词：
- en: '[PRE39]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Construct the hashmap from a corpus of text using the following line of code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行从文本语料库构建哈希映射：
- en: '[PRE40]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Read the large corpus of text, construct the hash map, and print the number
    of words of each length, as shown in the following code snippet:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读大型文本语料库，构建哈希映射，并打印每个长度单词的数量，代码片段如下：
- en: '[PRE41]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE42]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we plot the data, we can discover an interesting trend as shown in the following
    figure:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们绘制数据图表，可以发现一个有趣的趋势，如下图所示：
- en: '![How to do it…](img/6331OS_04_01.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作……](img/6331OS_04_01.jpg)'
- en: How it works…
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理……
- en: 'Technical specifics about the library are explained in the following blog post
    by the author:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有关该库的技术细节，请参见作者在以下博客文章中的说明：
- en: '[http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html](http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html](http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html)'
- en: Using Google's CityHash hash functions for strings
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google 的 CityHash 哈希函数处理字符串
- en: Google's CityHash hash functions are optimized for hashing strings, but are
    not meant to be cryptographically secure. CityHash is ideal for implementing a
    hash table dealing with strings. We will use it in this recipe to produce both
    64-bit and 128-bit digests.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Google 的 CityHash 哈希函数专为字符串哈希优化，但并不适用于密码学安全。CityHash 非常适合实现处理字符串的哈希表。我们将在本食谱中使用它来生成
    64 位和 128 位的摘要。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Install the `cityhash` package from Cabal as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，从 Cabal 安装 `cityhash` 包：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How to do it…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Import the relevant packages as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示导入相关包：
- en: '[PRE44]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Test the various hashing function on an input string using the following code
    snippet:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段测试不同的哈希函数在输入字符串上的效果：
- en: '[PRE45]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Display the output as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示显示输出：
- en: '[PRE46]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Google describes its package on its blog announcement at [http://google-opensource.blogspot.com/2011/04/introducing-cityhash.html](http://google-opensource.blogspot.com/2011/04/introducing-cityhash.html)
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Google 在其博客公告中描述了该包，地址为 [http://google-opensource.blogspot.com/2011/04/introducing-cityhash.html](http://google-opensource.blogspot.com/2011/04/introducing-cityhash.html)，如下所示：
- en: '*"The key advantage of our approach is that most steps contain at least two
    independent mathematical operations. Modern CPUs tend to perform best with this
    type of code."*'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"我们方法的关键优势在于，大多数步骤至少包含两个独立的数学运算。现代 CPU 在这种类型的代码上表现最好。"*'
- en: See also
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: To see a more generic hashing function, refer to the *Hashing a primitive data
    type* and *Hashing a custom data type* recipes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看更通用的哈希函数，请参考 *哈希原始数据类型* 和 *哈希自定义数据类型* 这两个食谱。
- en: Computing a Geohash for location coordinates
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算位置坐标的 Geohash
- en: A Geohash is a practical encoding of latitude-longitude coordinates. It does
    not behave like a typical hash function since minor changes in location only produce
    minor changes in the output digest. Geohash allows efficient proximity search
    and arbitrary precision determined by the specified length of the digest.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Geohash 是一种实际的经纬度坐标编码。与典型的哈希函数不同，Geohash 在位置上有细微变化时，输出摘要也会发生小变化。Geohash 允许高效的邻近搜索，精度由摘要长度决定。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Install the Geohashing library as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Geohashing 库，如下所示：
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How to do it…
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Import the `Geohash` library as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示导入 `Geohash` 库：
- en: '[PRE48]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a geohash of a latitude-longitude coordinate pair as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个经纬度坐标对的地理哈希值，如下所示：
- en: '[PRE49]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Display the geohash using the following code snippet:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段显示地理哈希值：
- en: '[PRE50]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a geohash of another similar latitude-longitude coordinate pair as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个相似的经纬度坐标对的地理哈希值，如下所示：
- en: '[PRE51]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Display the geohash using the following code snippet:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段显示地理哈希值：
- en: '[PRE52]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The output is as follows. Notice how the geohash appears to share the same prefix
    due to their closeness.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出如下所示。请注意，由于它们的相似性，地理哈希值似乎共享相同的前缀。
- en: '[PRE53]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Using a bloom filter to remove unique items
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Bloom 过滤器去除唯一项
- en: 'A bloom filter is an abstract data type that tests whether an item exists in
    a set. Unlike a typical hash map data structure, a bloom filter only takes up
    a constant amount of space. The advantage comes in handy when dealing with billions
    of data, such as representations of DNA strands as strings: "GATA", "CTGCTA",
    and so on.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Bloom 过滤器是一种抽象数据类型，用于测试某个项是否存在于集合中。与典型的哈希映射数据结构不同，Bloom 过滤器仅占用恒定的空间。它的优势在于处理数十亿数据时非常有效，例如
    DNA 链条的字符串表示："GATA"、"CTGCTA" 等。
- en: 'In this recipe, we will use a bloom filter to try to remove unique DNA strands
    from a list. This is often desired because a typical DNA sample may contain thousands
    of strands that only appear once. The major disadvantage of a bloom filter is
    that false positive results for membership are possible. The bloom filter may
    accidentally claim that an element exists. Though false negatives are not possible:
    a bloom filter will never claim that an element does not exist when it actually
    does.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用 Bloom 过滤器尝试从列表中移除唯一的 DNA 链条。这通常是需要的，因为一个典型的 DNA 样本可能包含成千上万只出现一次的链条。Bloom
    过滤器的主要缺点是可能会产生假阳性结果，即它可能错误地认为某个元素存在。尽管如此，假阴性是不可发生的：Bloom 过滤器永远不会错误地认为某个元素不存在，即使它实际存在。
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Import the bloom filter package from Cabal as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，从 Cabal 导入 Bloom 过滤器包：
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How to do it…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Import the bloom filter package as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示导入 Bloom 过滤器包：
- en: '[PRE55]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a function to remove the unique elements from a list. First check to
    see if each item exists in the bloom filter; if so, add it to a hash map. If not,
    add it to the bloom filter, as presented in the following code snippet:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来移除列表中的唯一元素。首先检查每个项目是否存在于布隆过滤器中；如果存在，将其添加到哈希映射中。如果不存在，则将其添加到布隆过滤器中，代码示例如下：
- en: '[PRE56]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Run the algorithm on a couple of DNA strand examples as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在几个DNA链示例上运行算法，如下所示：
- en: '[PRE57]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We see the following strands that likely occur at least twice:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们看到以下可能至少出现两次的串：
- en: '[PRE58]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A bloom filter is composed of a couple of hashing functions and a list of numbers
    initialized at zero. When inserting an element to this data structure, hashes
    are computed from each of the hashing functions and the corresponding item in
    the list is updated. Membership tests on a bloom filter are conducted by computing
    each of the hash functions in the input and testing whether all corresponding
    list elements are above some threshold value.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 布隆过滤器由几个哈希函数和一个初始化为零的数字列表组成。当将元素插入该数据结构时，会根据每个哈希函数计算哈希，并更新列表中相应的项。布隆过滤器的成员测试是通过计算输入的每个哈希函数并测试所有相应的列表元素是否都超过某个阈值来进行的。
- en: '![How it works…](img/6331OS_04_06.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/6331OS_04_06.jpg)'
- en: For example, in the preceding figure, three hash functions are applied to every
    input. When a hash is calculated for **x**, **y**, and **z**, the corresponding
    element in the list representing the bloom filter is incremented. We can determine
    whether **w** exists in this bloom filter by computing the three hashes and checking
    if corresponding indices are all at a desired value. In this case, **w** does
    not exist in the bloom filter.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的图示中，三个哈希函数会应用于每个输入。当计算**x**、**y**和**z**的哈希时，表示布隆过滤器的列表中的相应元素会增加。我们可以通过计算三个哈希并检查相应索引是否都达到所需值来确定**w**是否存在于此布隆过滤器中。在此情况下，**w**并不存在于布隆过滤器中。
- en: Running MurmurHash, a simple but speedy hashing algorithm
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行MurmurHash，一个简单但快速的哈希算法
- en: Sometimes, the priority of a hashing function should be in maximizing its computation
    speed. The MurmurHash algorithm exists for this reason. When dealing with massive
    **data sets**, speed is essential.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，哈希函数的优先级应该是最大化其计算速度。MurmurHash算法正是为此目的而存在。当处理大规模**数据集**时，速度至关重要。
- en: Tip
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There are negative qualities of a fast hashing algorithm. If hashing algorithm
    A is 10 times faster than hashing algorithm B, then it's also 10 times faster
    to stumble upon the content used to create a digest with A than with B using a
    random content search. A hashing algorithm should be fast, but not so fast as
    to impact the security of the algorithm.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 快速哈希算法也有其负面影响。如果哈希算法A比哈希算法B快10倍，那么用随机内容搜索时，找到用A生成摘要的内容也会比用B快10倍。哈希算法应该快速，但不能快到影响算法的安全性。
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Install the Murmur hashing algorithm from Cabal as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从Cabal安装Murmur哈希算法，如下所示：
- en: '[PRE59]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How to do it…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Import the Murmur hashing algorithm as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入Murmur哈希算法，如下所示：
- en: '[PRE60]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Define a custom data type and implement an instance to use Murmur as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个自定义数据类型并实现一个实例来使用Murmur，如下所示：
- en: '[PRE61]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Run the hashing algorithm on various inputs, using the following code snippet:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同的输入上运行哈希算法，使用以下代码片段：
- en: '[PRE62]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The following hashes are produced:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成以下哈希：
- en: '[PRE63]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Measuring image similarity with perceptual hashes
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用感知哈希衡量图像相似度
- en: A perceptual hash produces a small digest from an image file where slight changes
    in the images only produce a slight change in the hash. This can be useful to
    quickly compare thousands of images.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 感知哈希从图像文件中生成一个小的摘要，其中图像的微小变化只会导致哈希值的轻微变化。这在快速比较成千上万张图像时非常有用。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Install the `pHash` library from [www.phash.org](http://www.phash.org). On
    a Debian-based system, we can install it by using `apt-get` as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 从[www.phash.org](http://www.phash.org)安装`pHash`库。在基于Debian的系统上，我们可以使用`apt-get`命令进行安装，如下所示：
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Install the `phash` library from Cabal as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 从Cabal安装`phash`库，如下所示：
- en: '[PRE65]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Find three nearly identical images. We will use the following image:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 找到三张几乎相同的图像。我们将使用以下图像：
- en: '![Getting ready](img/6331OS_04_02.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6331OS_04_02.jpg)'
- en: This is the second image that we will be using
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将使用的第二张图片
- en: '![Getting ready](img/6331OS_04_03.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6331OS_04_03.jpg)'
- en: 'And the following image is the third:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像是第三张：
- en: '![Getting ready](img/6331OS_04_04.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6331OS_04_04.jpg)'
- en: How to do it…
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Import the `phash` library as follows:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`phash`库，代码如下：
- en: '[PRE66]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Hash an image as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对一张图片进行哈希处理，结果如下：
- en: '[PRE67]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Hash a similar image as follows:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对一张相似的图片进行哈希处理，结果如下：
- en: '[PRE68]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Hash a slightly different image as follows:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对一张稍微不同的图片进行哈希处理，结果如下：
- en: '[PRE69]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Compute the similarity of the first two images using the following code snippet:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段计算前两张图片的相似度：
- en: '[PRE70]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Compute the similarity of the first to the third image as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算第一张图片与第三张图片的相似度，结果如下：
- en: '[PRE71]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output hashes are as follows:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出哈希值如下：
- en: '[PRE72]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: It's much easier to visualize how similar these hashes are in hexadecimal (or
    binary), since Hamming distance operates in bits.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在十六进制（或二进制）中可视化这些哈希值的相似性要容易得多，因为哈明距离是按比特操作的。
- en: 'The hexadecimal representation of the three images are as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 三张图片的十六进制表示如下：
- en: '**Image 1**: c316b1bc36947e1c'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图片 1**: c316b1bc36947e1c'
- en: '**Image 2**: c912b1fc36947e1c'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图片 2**: c912b1fc36947e1c'
- en: '**Image 3**: 851639bc3650fe9c'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图片 3**: 851639bc3650fe9c'
- en: By comparing these values, we can see that images 1 and 2 differ by only four,
    whereas images 1 and 3 differ by a whopping 10 characters.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较这些值，我们可以看到，图片1和图片2仅相差四个字符，而图片1和图片3相差整整10个字符。
