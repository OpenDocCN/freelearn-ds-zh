- en: Chapter 14. Graphs, Geometry, and Geographic Information Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章：图、几何学和地理信息系统
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Manipulating and visualizing graphs with NetworkX
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NetworkX 操作和可视化图
- en: Analyzing a social network with NetworkX
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NetworkX 分析社交网络
- en: Resolving dependencies in a Directed Acyclic Graph with a topological sort
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用拓扑排序解决有向无环图中的依赖关系
- en: Computing connected components in an image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算图像中的连通分量
- en: Computing the Voronoi diagram of a set of points
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算一组点的沃罗诺伊图
- en: Manipulating geospatial data with Shapely and basemap
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Shapely 和 basemap 操作地理空间数据
- en: Creating a route planner for a road network
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为路网创建路径规划器
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will cover Python's capabilities in graph theory, geometry,
    and geography.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖 Python 在图论、几何学和地理学方面的能力。
- en: '**Graphs** are mathematical objects describing relations between items. They
    are ubiquitous in science and engineering, as they can represent many kinds of
    real-world relations: friends in a social network, atoms in a molecule, website
    links, cells in a neural network, neighboring pixels in an image, and so on. Graphs
    are also classical data structures in computer science. Finally, many domain-specific
    problems may be re-expressed as graph problems, and then solved with well-known
    algorithms.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**图**是描述物体之间关系的数学对象。它们在科学和工程中无处不在，因为它们可以表示许多现实世界的关系：社交网络中的朋友、分子中的原子、网站链接、神经网络中的细胞、图像中的相邻像素等。图还是计算机科学中的经典数据结构。最后，许多领域特定的问题可以重新表达为图论问题，然后使用著名的算法来解决。'
- en: We will also see a few recipes related to **geometry** and **Geographic Information
    Systems** (**GIS**), which refers to the processing and analysis of any kind of
    spatial, geographical, or topographical data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到一些与**几何**和**地理信息系统**（**GIS**）相关的内容，GIS 指的是对任何类型的空间、地理或地形数据的处理和分析。
- en: In this introduction, we will give a brief overview of these topics.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本介绍中，我们将简要概述这些主题。
- en: Graphs
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图
- en: Mathematically, a **graph** *G = (V, E)* is defined by a set *V* of **vertices**
    or **nodes**, and a set *E* of **edges** (two-element subsets of V). Two nodes
    *v* and *v*' are said to be **connected** if *(v, v')* is an edge (element of
    *E*).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度来看，**图** *G = (V, E)* 由一组**顶点**或**节点** *V* 和一组**边** *E*（V 的二元子集）定义。若 *(v,
    v')* 是一条边（*E* 的元素），则称两个节点 *v* 和 *v'* 是**连接**的。
- en: If the edges are *unordered* (meaning that *(v,v') = (v',v)*), the graph is
    said to be **undirected**
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果边是*无序的*（意味着 *(v,v') = (v',v)*），则图被称为**无向图**
- en: If the edges are *ordered* (meaning that *(v,v')* ≠ *(v',v)*), the graph is
    said to be **directed**
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果边是*有序的*（意味着 *(v,v')* ≠ *(v',v)*），则图被称为**有向图**
- en: An edge in an undirected graph is represented by a line segment between the
    two nodes. In a directed graph, it is represented by an arrow.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在无向图中，边由连接两个节点的线段表示。在有向图中，它由箭头表示。
- en: '![Graphs](img/4818OS_14_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Graphs](img/4818OS_14_01.jpg)'
- en: Undirected and directed graphs
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 无向图和有向图
- en: A graph can be represented by different data structures, notably an **adjacency
    list** (for each vertex, a list of adjacent vertices) or an **adjacency matrix**
    (matrix of connections between vertices).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以通过不同的数据结构表示，特别是**邻接表**（每个顶点的邻接顶点列表）或**邻接矩阵**（顶点之间连接的矩阵）。
- en: Problems in graph theory
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图论中的问题
- en: 'Here are a few examples of classical graph problems:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个经典的图论问题的示例：
- en: '**Graph traversal**: How to walk through a graph, discussed at [http://en.wikipedia.org/wiki/Graph_traversal](http://en.wikipedia.org/wiki/Graph_traversal)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图遍历**：如何遍历图，详细讨论见 [http://en.wikipedia.org/wiki/Graph_traversal](http://en.wikipedia.org/wiki/Graph_traversal)'
- en: '**Graph coloring**: How to color nodes in a graph such that no two adjacent
    vertices share the same color, discussed at [http://en.wikipedia.org/wiki/Graph_coloring](http://en.wikipedia.org/wiki/Graph_coloring)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图着色**：如何给图中的节点着色，使得相邻的两个顶点不共享相同的颜色，详细讨论见 [http://en.wikipedia.org/wiki/Graph_coloring](http://en.wikipedia.org/wiki/Graph_coloring)'
- en: '**Connected components**: How to find connected components in a graph, explained
    at [http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29](http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连通分量**：如何在图中找到连通分量，详细解释见 [http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29](http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29)'
- en: '**Shortest paths**: What is the shortest path from one node to another in a
    given graph?, discussed at [http://en.wikipedia.org/wiki/Shortest_path_problem](http://en.wikipedia.org/wiki/Shortest_path_problem)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最短路径**：在给定图中，从一个节点到另一个节点的最短路径是什么？讨论见[http://en.wikipedia.org/wiki/Shortest_path_problem](http://en.wikipedia.org/wiki/Shortest_path_problem)'
- en: '**Hamiltonian paths**: Does a graph include a Hamiltonian path, visiting every
    vertex exactly once?, explained at [http://en.wikipedia.org/wiki/Hamiltonian_path](http://en.wikipedia.org/wiki/Hamiltonian_path)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈密尔顿路径**：一个图是否包含哈密尔顿路径，访问每个顶点恰好一次？详细解释见[http://en.wikipedia.org/wiki/Hamiltonian_path](http://en.wikipedia.org/wiki/Hamiltonian_path)'
- en: '**Eulerian paths**: Does a graph include an Eulerian path, visiting every *edge*
    exactly once?, discussed at [http://en.wikipedia.org/wiki/Eulerian_path](http://en.wikipedia.org/wiki/Eulerian_path)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**欧拉路径**：一个图是否包含欧拉路径，访问每条 *边* 恰好一次？讨论见[http://en.wikipedia.org/wiki/Eulerian_path](http://en.wikipedia.org/wiki/Eulerian_path)'
- en: '**Traveling Salesman Problem**: What is the shortest route visiting every node
    exactly once (Hamiltonian path)?, explained at [http://en.wikipedia.org/wiki/Traveling_salesman_problem](http://en.wikipedia.org/wiki/Traveling_salesman_problem)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旅行商问题**：访问每个节点恰好一次（哈密尔顿路径）的最短路径是什么？详细解释见[http://en.wikipedia.org/wiki/Traveling_salesman_problem](http://en.wikipedia.org/wiki/Traveling_salesman_problem)'
- en: Random graphs
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机图
- en: '**Random graphs** are particular kinds of graphs defined with probabilistic
    rules. They are useful for understanding the structure of large real-world graphs
    such as social graphs.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机图** 是一种特殊的图，通过概率规则定义。它们有助于理解大规模现实世界图的结构，如社交图。'
- en: In particular, **small-world networks** have sparse connections, but most nodes
    can be reached from every other node in a small number of steps. This property
    is due to the existence of a small number of **hubs** that have a high number
    of connections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，**小世界网络**具有稀疏的连接，但大多数节点可以在少数几步内从其他任何节点到达。这一特性源于少数几个具有大量连接的 **枢纽** 的存在。
- en: Graphs in Python
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 中的图
- en: Although graphs can be manipulated with native Python structures, it is more
    convenient to use a dedicated library implementing specific data structures and
    manipulation routines. In this chapter, we will use **NetworkX**, a pure Python
    library. Alternative Python libraries include **python-graph** and **graph-tool**
    (largely written in C++).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以使用原生的 Python 结构操作图，但使用专门的库来实现特定数据结构和操作例程会更方便。在本章中，我们将使用 **NetworkX**，一个纯
    Python 库。其他 Python 库包括 **python-graph** 和 **graph-tool**（主要用 C++ 编写）。
- en: NetworkX implements a flexible data structure for graphs, and it contains many
    algorithms. NetworkX also lets us draw graphs easily with matplotlib.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX 实现了一个灵活的图数据结构，并包含许多算法。NetworkX 还允许我们使用 matplotlib 轻松绘制图。
- en: Geometry in Python
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 中的几何学
- en: '**Shapely** is a Python library used to manipulate 2D geometrical shapes such
    as points, lines, and polygons. It is most notably useful in Geographic Information
    Systems.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shapely** 是一个 Python 库，用于处理二维几何图形，如点、线和多边形。它在地理信息系统中尤其有用。'
- en: It is not straightforward to combine Shapely with matplotlib. Fortunately, the
    **descartes** package makes this task much easier.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Shapely 与 matplotlib 结合并非易事。幸运的是，**descartes** 包使这个任务变得更加简单。
- en: Geographical Information Systems in Python
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 中的地理信息系统（GIS）
- en: There are several Python modules used to manipulate geographical data and plotting
    maps.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个 Python 模块用于处理地理数据和绘制地图。
- en: In this chapter, we will use matplotlib's basemap, Shapely, descartes, and Fiona
    to handle GIS files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 matplotlib 的 basemap、Shapely、descartes 和 Fiona 来处理 GIS 文件。
- en: The ESRI **shapefile** is a popular geospatial vector data format. It can be
    read by basemap, NetworkX, and Fiona.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ESRI **Shapefile** 是一种流行的地理空间矢量数据格式。它可以被 basemap、NetworkX 和 Fiona 读取。
- en: We will also use the **OpenStreetMap** service, a free, open source, collaborative
    service providing maps of the world.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 **OpenStreetMap** 服务，这是一个免费的开源协作服务，提供全球地图。
- en: Other GIS/mapping systems in Python that we couldn't cover in this chapter include
    **GeoPandas**, **Kartograph**, **Vincent**, and **cartopy**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本章未涉及的其他 Python 中的 GIS/地图系统包括 **GeoPandas**、**Kartograph**、**Vincent** 和 **cartopy**。
- en: References
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Here are a few references about graphs:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于图的一些参考资料：
- en: Graph theory on Wikipedia, available at [http://en.wikipedia.org/wiki/Graph_theory](http://en.wikipedia.org/wiki/Graph_theory)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科中的图论，访问[http://en.wikipedia.org/wiki/Graph_theory](http://en.wikipedia.org/wiki/Graph_theory)
- en: Data structures for graphs, described at [http://en.wikipedia.org/wiki/Graph_(abstract_data_type)](http://en.wikipedia.org/wiki/Graph_(abstract_data_type))
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述图的数据结构，请参考[http://en.wikipedia.org/wiki/Graph_(abstract_data_type)](http://en.wikipedia.org/wiki/Graph_(abstract_data_type))
- en: Random graphs on Wikipedia, available at [http://en.wikipedia.org/wiki/Random_graph](http://en.wikipedia.org/wiki/Random_graph)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可在维基百科上查看随机图的页面，网址为[http://en.wikipedia.org/wiki/Random_graph](http://en.wikipedia.org/wiki/Random_graph)
- en: Small-world graphs on Wikipedia, available at [http://en.wikipedia.org/wiki/Small-world_network](http://en.wikipedia.org/wiki/Small-world_network)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可在维基百科上查看小世界图的页面，网址为[http://en.wikipedia.org/wiki/Small-world_network](http://en.wikipedia.org/wiki/Small-world_network)
- en: NetworkX package, available at [http://networkx.github.io](http://networkx.github.io)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetworkX 软件包的网址为[http://networkx.github.io](http://networkx.github.io)
- en: The python-graph package, available at [https://code.google.com/p/python-graph/](https://code.google.com/p/python-graph/)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: python-graph 软件包的网址为[https://code.google.com/p/python-graph/](https://code.google.com/p/python-graph/)
- en: The graph-tool package, available at [http://graph-tool.skewed.de](http://graph-tool.skewed.de)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[http://graph-tool.skewed.de](http://graph-tool.skewed.de)获取 graph-tool 软件包。
- en: 'Here are a few references about geometry and maps in Python:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于 Python 中几何和地图的一些参考资料：
- en: Basemap at [http://matplotlib.org/basemap/](http://matplotlib.org/basemap/)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Basemap 的网址为[http://matplotlib.org/basemap/](http://matplotlib.org/basemap/)
- en: Shapely at [http://toblerity.org/shapely/project.html](http://toblerity.org/shapely/project.html)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shapely 的网址为[http://toblerity.org/shapely/project.html](http://toblerity.org/shapely/project.html)
- en: Fiona at [http://toblerity.org/fiona/](http://toblerity.org/fiona/)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fiona 的网址为[http://toblerity.org/fiona/](http://toblerity.org/fiona/)
- en: descartes at [https://pypi.python.org/pypi/descartes](https://pypi.python.org/pypi/descartes)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: descartes 的网址为[https://pypi.python.org/pypi/descartes](https://pypi.python.org/pypi/descartes)
- en: Shapefile at [http://en.wikipedia.org/wiki/Shapefile](http://en.wikipedia.org/wiki/Shapefile)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shapefile 的网址为[http://en.wikipedia.org/wiki/Shapefile](http://en.wikipedia.org/wiki/Shapefile)
- en: OpenStreetMap at [www.openstreetmap.org](http://www.openstreetmap.org)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenStreetMap 的网址为[www.openstreetmap.org](http://www.openstreetmap.org)
- en: Folium at [https://github.com/wrobstory/folium](https://github.com/wrobstory/folium)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Folium 的网址为[https://github.com/wrobstory/folium](https://github.com/wrobstory/folium)
- en: GeoPandas at [http://geopandas.org](http://geopandas.org)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GeoPandas 的网址为[http://geopandas.org](http://geopandas.org)
- en: Kartograph at [http://kartograph.org](http://kartograph.org)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kartograph 的网址为[http://kartograph.org](http://kartograph.org)
- en: Cartopy at [http://scitools.org.uk/cartopy/](http://scitools.org.uk/cartopy/)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cartopy 的网址为[http://scitools.org.uk/cartopy/](http://scitools.org.uk/cartopy/)
- en: Vincent at [https://github.com/wrobstory/vincent](https://github.com/wrobstory/vincent)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vincent 的网址为[https://github.com/wrobstory/vincent](https://github.com/wrobstory/vincent)
- en: Manipulating and visualizing graphs with NetworkX
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NetworkX 操作和可视化图形
- en: In this recipe, we will show how to create, manipulate, and visualize graphs
    with NetworkX.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将展示如何使用 NetworkX 创建、操作和可视化图形。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can find the installation instructions for NetworkX in the official documentation
    at [http://networkx.github.io/documentation/latest/install.html](http://networkx.github.io/documentation/latest/install.html).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到 NetworkX 的安装说明，网址为[http://networkx.github.io/documentation/latest/install.html](http://networkx.github.io/documentation/latest/install.html)。
- en: With Anaconda, you can type `conda install networkx` in a terminal. Alternatively,
    you can type `pip install networkx`. On Windows, you can also use Chris Gohlke's
    installer, available at [www.lfd.uci.edu/~gohlke/pythonlibs/#networkx](http://www.lfd.uci.edu/~gohlke/pythonlibs/#networkx).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Anaconda，您可以在终端中输入`conda install networkx`。或者，您也可以输入`pip install networkx`。在
    Windows 上，您还可以使用 Chris Gohlke 的安装程序，网址为[www.lfd.uci.edu/~gohlke/pythonlibs/#networkx](http://www.lfd.uci.edu/~gohlke/pythonlibs/#networkx)。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s import NumPy, NetworkX, and matplotlib:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入 NumPy、NetworkX 和 matplotlib：
- en: '[PRE0]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are many different ways of creating a graph. Here, we create a list of
    edges (pairs of node indices):'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建图形的方法有很多种。在这里，我们创建了一个边的列表（节点索引的对）：
- en: '[PRE1]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We instantiate a `Graph` object with our list of edges:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用边的列表实例化一个`Graph`对象：
- en: '[PRE2]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s check the list of nodes and edges of the graph, and its adjacency matrix:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查图的节点和边的列表，以及其邻接矩阵：
- en: '[PRE3]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s display this graph. NetworkX comes with a variety of drawing functions.
    We can either specify the nodes'' positions explicitly, or we can use an algorithm
    to automatically compute an interesting layout. Here, we use the `draw_circular()`
    function that simply positions nodes linearly on a circle:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们显示这个图。NetworkX 自带各种绘图函数。我们可以明确指定节点的位置，也可以使用算法自动计算一个有趣的布局。在这里，我们使用了`draw_circular()`函数，它会将节点线性地放置在一个圆上：
- en: '[PRE4]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![How to do it…](img/4818OS_14_02.jpg)'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/4818OS_14_02.jpg)'
- en: Graphs can be modified easily. Here, we add a new node connected to all existing
    nodes. We also specify a `color` attribute to this node. In NetworkX, every node
    and edge comes with a convenient Python dictionary containing arbitrary attributes.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图可以很容易地修改。在这里，我们添加一个连接到所有现有节点的新节点。我们还为此节点指定了一个`color`属性。在NetworkX中，每个节点和边都带有一个方便的Python字典，包含任意属性。
- en: '[PRE5]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s draw the modified graph again. This time, we specify the nodes''
    positions and colors explicitly:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们再次绘制修改后的图。这次，我们明确指定节点的位置和颜色：
- en: '[PRE6]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![How to do it…](img/4818OS_14_03.jpg)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作方法…](img/4818OS_14_03.jpg)'
- en: 'Let''s also use an automatic layout algorithm:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也使用自动布局算法：
- en: '[PRE7]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![How to do it…](img/4818OS_14_04.jpg)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作方法…](img/4818OS_14_04.jpg)'
- en: There's more…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In NetworkX, nodes are not necessarily integers. They can be numbers, strings,
    tuples, and instances of any hashable Python class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在NetworkX中，节点不一定是整数。它们可以是数字、字符串、元组和任何可哈希的Python类的实例。
- en: In addition, every node and edge comes with optional attributes (which form
    a dictionary).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个节点和边都带有可选属性（形成一个字典）。
- en: A few layout algorithms are implemented in NetworkX. The `draw_spectral()` function
    uses the eigenvectors of the graph's **Laplacian matrix**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在NetworkX中实现了一些布局算法。`draw_spectral()`函数使用图的**拉普拉斯矩阵**的特征向量。
- en: The `draw_spring()` function implements the **Fruchterman-Reingold force-directed**
    algorithm. Nodes are considered as masses subject to edge-dependent forces. A
    force-directed graph drawing algorithm minimizes the system's energy so as to
    find an equilibrium configuration. This results in an aesthetically appealing
    layout with as few crossing edges as possible.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw_spring()`函数实现了**Fruchterman-Reingold力导向**算法。节点被视为受边缘相关力的质点。力导向图绘制算法通过最小化系统的能量来找到平衡配置。这将导致一个美观的布局，尽可能少地交叉边。'
- en: 'Here are a few references:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: Graph drawing, described at [http://en.wikipedia.org/wiki/Graph_drawing](http://en.wikipedia.org/wiki/Graph_drawing)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图绘制，在[http://en.wikipedia.org/wiki/Graph_drawing](http://en.wikipedia.org/wiki/Graph_drawing)有描述
- en: Laplacian matrix on Wikipedia, available at [http://en.wikipedia.org/wiki/Laplacian_matrix](http://en.wikipedia.org/wiki/Laplacian_matrix)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的拉普拉斯矩阵，网址为[http://en.wikipedia.org/wiki/Laplacian_matrix](http://en.wikipedia.org/wiki/Laplacian_matrix)
- en: Force-directed graph drawing, described at [http://en.wikipedia.org/wiki/Force-directed_graph_drawing](http://en.wikipedia.org/wiki/Force-directed_graph_drawing)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述在[http://en.wikipedia.org/wiki/Force-directed_graph_drawing](http://en.wikipedia.org/wiki/Force-directed_graph_drawing)的力导向图绘制
- en: See also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Analyzing a social network with NetworkX* recipe
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用NetworkX分析社交网络*配方'
- en: Analyzing a social network with NetworkX
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NetworkX分析社交网络
- en: In this recipe, we will show how to analyze social data in Python. Social data
    is generated by people's activity on social networks such as Facebook, Twitter,
    Google+, GitHub, and others.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将展示如何在Python中分析社交数据。社交数据是由人们在社交网络上的活动生成的，如Facebook、Twitter、Google+、GitHub等。
- en: In this recipe, we will analyze and visualize a Twitter user's social network
    with NetworkX.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用NetworkX分析和可视化Twitter用户的社交网络。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, you need to install the **Twitter** Python package. You can install it
    with `pip install twitter`. You'll find more information at [https://pypi.python.org/pypi/twitter](https://pypi.python.org/pypi/twitter).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装**Twitter** Python包。您可以使用`pip install twitter`进行安装。您可以在[https://pypi.python.org/pypi/twitter](https://pypi.python.org/pypi/twitter)找到更多信息。
- en: Then, you need to obtain authentication codes in order to access your Twitter
    data. The procedure is free. In addition to a Twitter account, you also need to
    create an *Application* on the Twitter Developers website at [https://dev.twitter.com/apps](https://dev.twitter.com/apps).
    Then, you will be able to retrieve the **OAuth authentication codes** that are
    required for this recipe.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要获取认证代码以访问您的Twitter数据。该过程是免费的。除了Twitter账号外，您还需要在Twitter开发者网站上创建一个*应用程序*，网址为[https://dev.twitter.com/apps](https://dev.twitter.com/apps)。然后，您将能够检索到此配方所需的**OAuth认证代码**。
- en: 'You need to create a `twitter.txt` text file in the current folder with the
    four private authentication keys. There must be one key per line, in the following
    order:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在当前文件夹中创建一个`twitter.txt`文本文件，其中包含四个私有认证密钥。每行必须有一个密钥，顺序如下：
- en: API key
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API密钥
- en: API secret
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API秘钥
- en: Access token
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问令牌
- en: Access token secret
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问令牌密钥
- en: Note that access to the Twitter API is limited. Most methods can only be called
    a few times within a given time window. Unless you study small networks or look
    at small portions of large networks, you will need to *throttle* your requests.
    In this recipe, we only consider a small portion of the network, so that the API
    limit should not be reached. Otherwise, you will have to wait a few minutes before
    the next time window starts. The API limits are available at [https://dev.twitter.com/docs/rate-limiting/1.1/limits](https://dev.twitter.com/docs/rate-limiting/1.1/limits).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对 Twitter API 的访问是有限制的。大多数方法在给定时间窗口内只能调用几次。除非您研究小网络或查看大网络的小部分，否则您将需要*节流*您的请求。在这个示例中，我们只考虑网络的一小部分，因此不应该达到
    API 限制。否则，您将需要等待几分钟，直到下一个时间窗口开始。API 限制可在[https://dev.twitter.com/docs/rate-limiting/1.1/limits](https://dev.twitter.com/docs/rate-limiting/1.1/limits)查看。
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s import a few packages:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入一些包：
- en: '[PRE8]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We get the secret consumer and OAuth keys from our `twitter.txt` file:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从我们的`twitter.txt`文件中获取秘密的消费者和 OAuth 密钥：
- en: '[PRE9]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We now create an instance of the `Twitter` class that will give us access to
    the Twitter API:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个`Twitter`类的实例，这将使我们能够访问 Twitter API：
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We use the 1.1 version of the Twitter API in this recipe. The `twitter` library
    defines a direct mapping between the REST API and the attributes of the `Twitter`
    instance. Here, we execute the `account/verify_credentials` REST request to obtain
    the identifier of the authenticated user (me here, or you if you execute this
    notebook yourself!):'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用 Twitter API 的1.1版本。`twitter`库在`Twitter`实例的属性之间定义了 REST API 和直接映射。在这里，我们执行`account/verify_credentials`
    REST 请求来获取认证用户的标识符（这里是我，或者如果您自己执行这个笔记本，则是您！）：
- en: '[PRE11]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s define a simple function that returns the identifiers of all followers
    of a given user (the authenticated user by default):'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个简单的函数，返回给定用户（默认为认证用户）的所有关注者的标识符：
- en: '[PRE12]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we define a function that retrieves the full profile of Twitter users.
    As the `users/lookup` batch request is limited to 100 users per call, and only
    a small number of calls are allowed within a time window, we only look at a subset
    of all the followers:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义一个函数，用于检索 Twitter 用户的完整资料。由于`users/lookup`批量请求每次限制为100个用户，并且在时间窗口内只允许少量调用，我们只查看所有关注者的一个子集：
- en: '[PRE13]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also start to define the graph with the followers, using an adjacency list
    (technically, a dictionary of lists). This is called the **ego graph**. This graph
    represents all *following* connections between our followers:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还开始用关注者定义图形，使用邻接表（技术上来说，是一个列表的字典）。这被称为**自我图**。这个图表示我们的关注者之间的所有*关注*连接：
- en: '[PRE14]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we are going to take a look at the part of the ego graph related to Python.
    Specifically, we will consider the followers of the 10 most followed users whose
    descriptions contain "Python":'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将查看与 Python 相关的自我图部分。具体来说，我们将考虑包含“Python”描述的前10位最受关注用户的关注者：
- en: '[PRE15]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The request for retrieving the followers of a given user is rate-limited. Let''s
    check how many remaining calls we have:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检索给定用户的关注者的请求受到速率限制。让我们来看看我们还剩下多少次调用：
- en: '[PRE16]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that our graph is defined as an adjacency list in a dictionary, we will
    load it in NetworkX:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的图被定义为字典中的邻接表，我们将在 NetworkX 中加载它：
- en: '[PRE17]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s take a look at the graph''s statistics:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看一下图的统计数据：
- en: '[PRE18]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are now going to plot this graph. We will use different sizes and colors
    for the nodes, according to the number of followers and the number of tweets for
    each user. Most followed users will be bigger. Most active users will be redder.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将绘制这个图。我们将根据每个用户的关注者数量和推文数量使用不同的大小和颜色来绘制节点。最受关注的用户将更大。最活跃的用户将更红。
- en: '[PRE19]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we use the `draw()` function to display the graph. We need to specify
    the nodes'' sizes and colors as lists, and the labels as a dictionary:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`draw()`函数来显示图形。我们需要将节点的大小和颜色指定为列表，标签指定为字典：
- en: '[PRE20]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![How to do it…](img/4818OS_14_05.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/4818OS_14_05.jpg)'
- en: There's more…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'A great reference on social data analysis with Python is Matthew A. Russel''s
    book *Mining the Social Web*, *O''Reilly Media*. The code is available on GitHub
    as IPython notebooks at [https://github.com/ptwobrussell/Mining-the-Social-Web-2nd-Edition](https://github.com/ptwobrussell/Mining-the-Social-Web-2nd-Edition).
    The following networks are covered: Twitter, Facebook, LinkedIn, Google+, GitHub,
    mailboxes, websites, and others.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一本关于使用Python进行社交数据分析的重要参考资料是Matthew A. Russel的书籍*《Mining the Social Web》*，由*O'Reilly
    Media*出版。 代码可以在GitHub上的IPython笔记本中找到，网址为[https://github.com/ptwobrussell/Mining-the-Social-Web-2nd-Edition](https://github.com/ptwobrussell/Mining-the-Social-Web-2nd-Edition)。
    以下网络被涵盖：Twitter、Facebook、LinkedIn、Google+、GitHub、邮箱、网站等。
- en: See also
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Manipulating and visualizing graphs with NetworkX* recipe
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用NetworkX操纵和可视化图形*示例'
- en: Resolving dependencies in a directed acyclic graph with a topological sort
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用拓扑排序在有向无环图中解析依赖关系
- en: 'In this recipe, we will show an application of a well-known graph algorithm:
    **topological sorting**. Let''s consider a directed graph describing dependencies
    between items. For example, in a package manager, before we can install a given
    package *P*, we may need to install *dependent* packages.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将展示一个著名的图算法应用：**拓扑排序**。 让我们考虑描述项目之间依赖关系的有向图。 例如，在软件包管理器中，在安装给定软件包*P*之前，我们可能需要安装*依赖*软件包。
- en: The set of dependencies forms a directed graph. With topological sorting, the
    package manager can resolve the dependencies and find the right installation order
    of the packages.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系集合形成一个有向图。 通过拓扑排序，软件包管理器可以解析依赖关系并找到软件包的正确安装顺序。
- en: Topological sorting has many other applications. Here, we will illustrate this
    notion on real data from the Debian package manager. We will find the installation
    order of the required packages for IPython.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑排序有许多其他应用。 在这里，我们将在Debian软件包管理器的真实数据上说明这个概念。 我们将找到IPython所需软件包的安装顺序。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need the `python-apt` package in order to build the package dependency graph.
    The package is available at [https://pypi.python.org/pypi/python-apt/](https://pypi.python.org/pypi/python-apt/).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要`python-apt`软件包才能构建软件包依赖关系图。 该软件包可在[https://pypi.python.org/pypi/python-apt/](https://pypi.python.org/pypi/python-apt/)上找到。
- en: We also assume that this notebook is executed on a Debian system (such as Ubuntu).
    If you don't have such a system, you can download the *Debian* dataset directly
    from the book's GitHub repository at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data).
    Extract it in the current directory, and start directly from step 7 in this notebook.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设此笔记本在Debian系统（如Ubuntu）上执行。 如果您没有这样的系统，可以直接从书的GitHub存储库[https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)下载*Debian*数据集。
    将其解压缩到当前目录，并直接从此笔记本的第7步开始。
- en: How to do it…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We import the `apt` module and we build the list of packages:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入`apt`模块并构建软件包列表：
- en: '[PRE21]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `graph` dictionary will contain the adjacency list of a small portion of
    the dependency graph:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`graph`字典将包含依赖关系图的一小部分的邻接表：'
- en: '[PRE22]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We define a function that returns the list of dependencies of a package:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个返回软件包依赖关系列表的函数：
- en: '[PRE23]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We now define a *recursive* function that builds the dependency graph for a
    particular package. This function updates the `graph` variable:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们定义一个*递归*函数，用于构建特定软件包的依赖关系图。 此函数更新`graph`变量：
- en: '[PRE24]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s build the dependency graph for IPython:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为IPython构建依赖关系图：
- en: '[PRE25]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we save the adjacency list in JSON:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将邻接表保存为JSON：
- en: '[PRE26]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Start here if you don't have a Debian operating system (you first need to download
    the *Debian* dataset from the book's repository).
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您没有Debian操作系统，请从书籍的存储库中下载*Debian*数据集。
- en: 'We import a few packages:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入一些包：
- en: '[PRE27]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s load the adjacency list from the JSON file:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从JSON文件中加载邻接表：
- en: '[PRE28]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we create a directed graph (`DiGraph` in NetworkX) from our adjacency
    list. We reverse the graph to get a more natural ordering:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们从邻接表创建一个有向图（NetworkX中的`DiGraph`）。 我们反转图以获得更自然的顺序：
- en: '[PRE29]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A topological sort only exists when the graph is a **directed acyclic graph**
    (**DAG**). This means that there is no cycle in the graph, that is, no circular
    dependency. Is our graph a DAG? Let''s see:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当图形是**有向无环图**（**DAG**）时才存在拓扑排序。 这意味着图中没有循环，也就是说，没有循环依赖。 我们的图是DAG吗？ 让我们看看：
- en: '[PRE30]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What are the packages responsible for the cycles? We can find them with the
    `simple_cycles()` function:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些软件包负责循环？ 我们可以使用`simple_cycles()`函数找到它们：
- en: '[PRE31]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we can try to remove these packages. In an actual package manager, these
    cycles need to be carefully taken into account.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以尝试移除这些包。在实际的包管理器中，这些循环需要仔细考虑。
- en: '[PRE32]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The graph is now a DAG. Let''s display it first:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，图是一个DAG。让我们先展示它：
- en: '[PRE33]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![How to do it…](img/4818OS_14_06.jpg)'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/4818OS_14_06.jpg)'
- en: 'Finally, we can perform the topological sort, thereby obtaining a linear installation
    order satisfying all dependencies:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以执行拓扑排序，从而获得一个满足所有依赖关系的线性安装顺序：
- en: '[PRE34]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There's more…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: Directed acyclic graphs are found in many applications. They can represent causal
    relations, influence diagrams, dependencies, and other concepts. For example,
    the version history of a distributed revision control system such as Git is described
    with a DAG.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有向无环图在许多应用中都有出现。它们可以表示因果关系、影响图、依赖关系以及其他概念。例如，像 Git 这样的分布式版本控制系统的版本历史就是用DAG来描述的。
- en: Topological sorting is useful in any scheduling task in general (project management
    and instruction scheduling).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑排序在一般的调度任务中非常有用（项目管理和指令调度）。
- en: 'Here are a few references:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: Topological sorting on Wikipedia, available at [http://en.wikipedia.org/wiki/Topological_sorting](http://en.wikipedia.org/wiki/Topological_sorting)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的拓扑排序，链接：[http://en.wikipedia.org/wiki/Topological_sorting](http://en.wikipedia.org/wiki/Topological_sorting)
- en: Directed acyclic graphs, described at [http://en.wikipedia.org/wiki/Directed_acyclic_graph](http://en.wikipedia.org/wiki/Directed_acyclic_graph)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有向无环图，详见：[http://en.wikipedia.org/wiki/Directed_acyclic_graph](http://en.wikipedia.org/wiki/Directed_acyclic_graph)
- en: Computing connected components in an image
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算图像中的连通分量
- en: In this recipe, we will show an application of graph theory in image processing.
    We will compute **connected components** in an image. This method will allow us
    to label contiguous regions of an image, similar to the *bucket* fill tool of
    paint programs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将展示图论在图像处理中的应用。我们将计算图像中的**连通分量**。这种方法将允许我们标记图像中的连续区域，类似于绘图程序中的*桶形填充*工具。
- en: Finding connected components is also useful in many puzzle video games such
    as Minesweeper, bubble shooters, and others. In these games, contiguous sets of
    items with the same color need to be automatically detected.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 找到连通分量在许多益智类视频游戏中也很有用，如扫雷、泡泡龙等。在这些游戏中，需要自动检测同一颜色的连续物品集。
- en: How to do it…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s import the packages:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入这些包：
- en: '[PRE35]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We create a *10 x 10* image where each pixel can take one of three possible
    labels (or colors):'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个*10 x 10*的图像，每个像素可以取三个可能的标签（或颜色）之一：
- en: '[PRE36]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we create the underlying 2D grid graph encoding the structure of the image.
    Each node is a pixel, and a node is connected to its nearest neighbors. NetworkX
    defines a `grid_2d_graph` function to generate this graph:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个底层的二维网格图，编码图像的结构。每个节点是一个像素，且一个节点与其最近的邻居相连。NetworkX 定义了一个`grid_2d_graph`函数来生成这个图：
- en: '[PRE37]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s create two functions to display the image and the corresponding graph:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建两个函数来显示图像和相应的图形：
- en: '[PRE38]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is the original image superimposed with the underlying graph:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是原始图像与底层图叠加后的效果：
- en: '[PRE39]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![How to do it…](img/4818OS_14_07.jpg)'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/4818OS_14_07.jpg)'
- en: 'Now, we are going to find all contiguous dark blue regions containing more
    than three pixels. First, we consider the *subgraph* corresponding to all dark
    blue pixels:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将找出所有包含超过三个像素的连续深蓝色区域。首先，我们考虑对应所有深蓝色像素的*子图*：
- en: '[PRE40]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![How to do it…](img/4818OS_14_08.jpg)'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/4818OS_14_08.jpg)'
- en: 'We see that the requested contiguous regions correspond to the *connected components*
    containing more than three nodes in the subgraph. We can use the `connected_components`
    function of NetworkX to find those components:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们看到，所请求的连续区域对应于包含超过三个节点的*连通分量*。我们可以使用 NetworkX 的`connected_components`函数来找到这些分量：
- en: '[PRE41]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we assign a new color to each of these components, and we display
    the new image:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为每个分量分配一个新颜色，并显示新的图像：
- en: '[PRE42]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![How to do it…](img/4818OS_14_09.jpg)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/4818OS_14_09.jpg)'
- en: How it works…
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The problem we solved is called **connected-component labeling**. It is also
    closely related to the **flood-fill algorithm**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决的问题被称为**连通分量标记**。它也与**洪水填充算法**密切相关。
- en: The idea to associate a grid graph to an image is quite common in image processing.
    Here, contiguous color regions correspond to **connected components** of subgraphs.
    A connected component can be defined as an equivalence class of the **reachability**
    relation. Two nodes are connected in the graph if there is a path from one node
    to the other. An equivalence class contains nodes that can be reached from one
    another.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将网格图与图像关联的想法在图像处理领域非常常见。在这里，连续的颜色区域对应于**连通组件**的子图。一个连通组件可以定义为**可达性**关系的等价类。如果两个节点之间有一条路径，则它们在图中是连通的。一个等价类包含可以互相到达的节点。
- en: Finally, the simple approach described here is only adapted to basic tasks on
    small images. More advanced algorithms are covered in [Chapter 11](ch11.html "Chapter 11. Image
    and Audio Processing"), *Image and Audio Processing*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里描述的简单方法仅适用于小图像上的基本任务。更高级的算法将在[第11章](ch11.html "第11章. 图像与音频处理")，*图像与音频处理*中讲解。
- en: There's more…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Here are a few references:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: Connected components on Wikipedia, available at [http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29](http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia上的连通组件，访问[http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29](http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29)
- en: Connected-component labeling on Wikipedia, at [http://en.wikipedia.org/wiki/Connected-component_labeling](http://en.wikipedia.org/wiki/Connected-component_labeling)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia上的连通组件标记算法，访问[http://en.wikipedia.org/wiki/Connected-component_labeling](http://en.wikipedia.org/wiki/Connected-component_labeling)
- en: Flood-fill algorithm on Wikipedia, available at [http://en.wikipedia.org/wiki/Flood_fill](http://en.wikipedia.org/wiki/Flood_fill)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia上的Flood-fill算法，访问[http://en.wikipedia.org/wiki/Flood_fill](http://en.wikipedia.org/wiki/Flood_fill)
- en: Computing the Voronoi diagram of a set of points
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算一组点的Voronoi图
- en: The **Voronoi diagram** of a set of *seed* points divides space into several
    regions. Each region contains all points closer to one seed point than to any
    other seed point.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一组*种子*点的**Voronoi图**将空间划分为多个区域。每个区域包含所有离某个种子点比任何其他种子点更近的点。
- en: The Voronoi diagram is a fundamental structure in computational geometry. It
    is widely used in computer science, robotics, geography, and other disciplines.
    For example, the Voronoi diagram of a set of metro stations gives us the closest
    station from any point in the city.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Voronoi图是计算几何中的基本结构。它广泛应用于计算机科学、机器人学、地理学和其他学科。例如，一组地铁站的Voronoi图可以告诉我们城市中任意一个点离哪个地铁站最近。
- en: In this recipe, we compute the Voronoi diagram of the set of metro stations
    in Paris using SciPy.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用SciPy计算巴黎地铁站集的Voronoi图。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need the Smopy module to display the OpenStreetMap map of Paris. You can
    install this package with `pip install smopy`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要Smopy模块来显示巴黎的OpenStreetMap地图。你可以使用`pip install smopy`安装该包。
- en: You also need to download the *RATP* dataset from the book's GitHub repository
    at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)
    and extract it in the current directory. The data was obtained on RATP's open
    data website (Paris' public transport operator, [http://data.ratp.fr](http://data.ratp.fr)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要从书籍的GitHub仓库下载*RATP*数据集，网址为[https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)，并将其解压到当前目录。数据来自RATP的开放数据网站（巴黎的公共交通运营商，[http://data.ratp.fr](http://data.ratp.fr)）。
- en: How to do it…
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Let''s import NumPy, pandas, matplotlib, and SciPy:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入NumPy、pandas、matplotlib和SciPy：
- en: '[PRE43]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s load the dataset with pandas:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用pandas加载数据集：
- en: '[PRE44]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `DataFrame` object contains the coordinates, name, city, district, and
    type of station. Let''s select all metro stations:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DataFrame`对象包含站点的坐标、名称、城市、区域和类型。让我们选择所有地铁站：'
- en: '[PRE45]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We are going to extract the district number of Paris' stations. With pandas,
    we can use vectorized string operations using the `str` attribute of the corresponding
    column.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将提取巴黎各地铁站的区域编号。使用pandas时，我们可以通过相应列的`str`属性进行向量化的字符串操作。
- en: '[PRE46]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We also extract the coordinates of all metro stations:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还提取所有地铁站的坐标：
- en: '[PRE47]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s retrieve Paris'' map with OpenStreetMap. We specify the map''s
    boundaries with the extreme latitude and longitude coordinates of all our metro
    stations. We use the lightweight Smopy module to generate the map:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用OpenStreetMap获取巴黎的地图。我们通过所有地铁站的极端纬度和经度坐标来指定地图的边界。我们使用轻量级的Smopy模块来生成地图：
- en: '[PRE48]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We now compute the Voronoi diagram of the stations using SciPy. A `Voronoi`
    object is created with the points coordinates. It contains several attributes
    we will use for display:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在使用SciPy计算车站的Voronoi图。一个`Voronoi`对象通过点的坐标创建。它包含了我们将用于显示的几个属性：
- en: '[PRE49]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We create a generic function to display a Voronoi diagram. SciPy already implements
    such a function, but this function does not take infinite points into account.
    The implementation we will use has been obtained in Stack Overflow and is present
    at [http://stackoverflow.com/a/20678647/1595060](http://stackoverflow.com/a/20678647/1595060).
    This function is relatively long, and we won't copy it entirely here. The full
    version can be found in the book's GitHub repository.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个通用函数来显示Voronoi图。SciPy已经实现了这样一个函数，但该函数没有考虑无限点。我们将使用的实现来自Stack Overflow，地址是[http://stackoverflow.com/a/20678647/1595060](http://stackoverflow.com/a/20678647/1595060)。这个函数相对较长，我们不会在这里完全复制它。完整版本可以在书籍的GitHub仓库中找到。
- en: '[PRE50]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `voronoi_finite_polygons_2d()` function returns a list of regions and a
    list of vertices. Every region is a list of vertex indices. The coordinates of
    all vertices are stored in `vertices`. From these structures, we can create a
    list of *cells*. Every cell represents a polygon as an array of vertex coordinates.
    We also use the `to_pixels()` method of the `smopy.Map` instance. This function
    converts latitude and longitude geographical coordinates to pixels in the image.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`voronoi_finite_polygons_2d()`函数返回一个区域列表和一个顶点列表。每个区域都是顶点索引的列表。所有顶点的坐标存储在`vertices`中。从这些结构中，我们可以创建一个*单元格*列表。每个单元格表示一个多边形，作为顶点坐标的数组。我们还使用`smopy.Map`实例的`to_pixels()`方法。此函数将纬度和经度的地理坐标转换为图像中的像素。'
- en: '[PRE51]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we compute the color of every polygon:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们计算每个多边形的颜色：
- en: '[PRE52]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we display the map with the Voronoi diagram, using the `show_mpl()`
    method of the `Map` instance:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`Map`实例的`show_mpl()`方法来显示带有Voronoi图的地图：
- en: '[PRE53]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![How to do it…](img/4818OS_14_10.jpg)'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现…](img/4818OS_14_10.jpg)'
- en: How it works…
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s give the mathematical definition of the Voronoi diagram in a Euclidean
    space. If *(x[i])* is a set of points, the Voronoi diagram of this set of points
    is the collection of subsets *V[i]* (called **cells** or **regions**) defined
    by:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给出欧几里得空间中Voronoi图的数学定义。如果*(x[i])*是一个点集，那么这个点集的Voronoi图就是由以下定义的子集*V[i]*（称为**单元格**或**区域**）的集合：
- en: '![How it works…](img/4818OS_14_11.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/4818OS_14_11.jpg)'
- en: The dual graph of the Voronoi diagram is the **Delaunay triangulation**. This
    geometrical object covers the convex hull of the set of points with triangles.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Voronoi图的双重图是**德劳内三角剖分**。这个几何对象通过三角形覆盖了点集的凸包。
- en: SciPy computes Voronoi diagrams with **Qhull**, a computational geometry library
    in C++.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy使用**Qhull**（一个C++计算几何库）来计算Voronoi图。
- en: There's more…
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'Here are further references:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有更多参考资料：
- en: Voronoi diagram on Wikipedia, available at [http://en.wikipedia.org/wiki/Voronoi_diagram](http://en.wikipedia.org/wiki/Voronoi_diagram)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的Voronoi图，地址是[http://en.wikipedia.org/wiki/Voronoi_diagram](http://en.wikipedia.org/wiki/Voronoi_diagram)
- en: Delaunay triangulation on Wikipedia, available at [http://en.wikipedia.org/wiki/Delaunay_triangulation](http://en.wikipedia.org/wiki/Delaunay_triangulation)
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的德劳内三角剖分，地址是[http://en.wikipedia.org/wiki/Delaunay_triangulation](http://en.wikipedia.org/wiki/Delaunay_triangulation)
- en: The documentation of `scipy.spatial.voronoi` available at [http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.spatial.Voronoi.html](http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.spatial.Voronoi.html)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scipy.spatial.voronoi`文档可在[http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.spatial.Voronoi.html](http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.spatial.Voronoi.html)找到'
- en: The Qhull library available at [www.qhull.org](http://www.qhull.org)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可在[www.qhull.org](http://www.qhull.org)获取Qhull库
- en: See also
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Manipulating geospatial data with Shapely and basemap* recipe
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Shapely和basemap操作地理空间数据*食谱'
- en: Manipulating geospatial data with Shapely and basemap
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Shapely和basemap操作地理空间数据
- en: In this recipe, we will show how to load and display geographical data in the
    Shapefile format. Specifically, we will use data from **Natural Earth** ([www.naturalearthdata.com](http://www.naturalearthdata.com))
    to display the countries of Africa, color coded with their population and **Gross
    Domestic Product** (**GDP**).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将展示如何加载和显示Shapefile格式的地理数据。具体而言，我们将使用**自然地球**（[www.naturalearthdata.com](http://www.naturalearthdata.com)）的数据来显示非洲各国，并通过其人口和**国内生产总值**（**GDP**）进行着色。
- en: '**Shapefile** ([http://en.wikipedia.org/wiki/Shapefile](http://en.wikipedia.org/wiki/Shapefile))
    is a popular geospatial vector data format for GIS software. It can be read by
    **Fiona**, a Python wrapper to **GDAL/OGR** (a C++ library supporting GIS file
    formats). We will also use **Shapely**, a Python package used to handle two-dimensional
    geometrical shapes, and **descartes**, used to render Shapely shapes in matplotlib.
    Finally, we will use **basemap** to plot maps.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shapefile**（[http://en.wikipedia.org/wiki/Shapefile](http://en.wikipedia.org/wiki/Shapefile)）是一种广泛使用的地理空间矢量数据格式，适用于GIS软件。它可以通过**Fiona**读取，Fiona是**GDAL/OGR**（一个支持GIS文件格式的C++库）的Python封装库。我们还将使用**Shapely**，这是一个用于处理二维几何图形的Python包，以及**descartes**，它用于在matplotlib中渲染Shapely图形。最后，我们将使用**basemap**绘制地图。'
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You need the following packages:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下包：
- en: GDAL/OGR available at [www.gdal.org/ogr/](http://www.gdal.org/ogr/)
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDAL/OGR可以在[www.gdal.org/ogr/](http://www.gdal.org/ogr/)找到
- en: Fiona available at [http://toblerity.org/fiona/README.html](http://toblerity.org/fiona/README.html)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fiona可以在[http://toblerity.org/fiona/README.html](http://toblerity.org/fiona/README.html)找到
- en: Shapely available at [http://toblerity.org/shapely/project.html](http://toblerity.org/shapely/project.html)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shapely可以在[http://toblerity.org/shapely/project.html](http://toblerity.org/shapely/project.html)找到
- en: descartes available at [https://pypi.python.org/pypi/descartes](https://pypi.python.org/pypi/descartes)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: descartes可以在[https://pypi.python.org/pypi/descartes](https://pypi.python.org/pypi/descartes)找到
- en: Basemap available at [http://matplotlib.org/basemap/](http://matplotlib.org/basemap/)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Basemap可以在[http://matplotlib.org/basemap/](http://matplotlib.org/basemap/)找到
- en: 'With Anaconda, you can do:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Anaconda，你可以执行以下操作：
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Shapely and descartes can be installed with:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely和descartes可以通过以下命令安装：
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: On Windows, you can find binary installers for all of those packages except
    descartes on Chris Gohlke's webpage, [www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows系统中，除了descartes，你可以在Chris Gohlke的网页[www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/)上找到所有这些包的二进制安装程序。
- en: On other systems, you can find installation instructions on the projects' websites.
    GDAL/OGR is a C++ library that is required by Fiona. The other packages are regular
    Python packages.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他系统中，你可以在项目网站上找到安装说明。GDAL/OGR是Fiona所必需的C++库。其他包是常规的Python包。
- en: Finally, you need to download the *Africa* dataset on the book's GitHub repository
    at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data).
    The data was obtained on Natural Earth's website, [www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-countries/](http://www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-countries/).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要在本书的GitHub仓库中下载*非洲*数据集，链接为[https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)。数据来自Natural
    Earth网站，地址为[www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-countries/](http://www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-countries/)。
- en: How to do it…
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s import the packages:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入相关包：
- en: '[PRE56]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We load the *Shapefile* dataset with Fiona. This dataset notably contains the
    borders of all countries in the world.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用Fiona加载*Shapefile*数据集。这个数据集包含了全世界所有国家的边界。
- en: '[PRE57]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We select the countries in Africa:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择非洲的国家：
- en: '[PRE58]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we create a basemap map showing the African continent:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个显示非洲大陆的底图：
- en: '[PRE59]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s write a function converting the geographical coordinates of the countries''
    borders to map coordinates. This will allow us to display the borders in basemap:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个函数，将国家边界的地理坐标转换为地图坐标。这将使我们能够在底图中显示边界：
- en: '[PRE60]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The next step is to create matplotlib `PatchCollection` objects from the *Shapefile*
    dataset loaded with Fiona. We use Shapely and descartes for this:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建来自Fiona加载的*Shapefile*数据集的matplotlib `PatchCollection`对象。我们将使用Shapely和descartes来完成：
- en: '[PRE61]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We also define a function to get countries'' colors depending on a specific
    field in the *Shapefile* dataset. Indeed, our dataset not only contains countries
    borders, but also a few administrative, economical, and geographical properties
    for each country. Here, we will choose the color according to the countries''
    population and GDP:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了一个函数，根据*Shapefile*数据集中的特定字段获取国家的颜色。实际上，我们的数据集不仅包含国家边界，还包含每个国家的行政、经济和地理属性。在这里，我们将根据国家的人口和GDP选择颜色：
- en: '[PRE62]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we display the maps. We display the coastlines with basemap, and the
    countries with our *Shapefile* dataset:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们显示地图。我们使用basemap显示海岸线，并使用我们的*Shapefile*数据集显示国家：
- en: '[PRE63]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '![How to do it…](img/4818OS_14_12.jpg)'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作……](img/4818OS_14_12.jpg)'
- en: See also
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating a route planner for a road network* recipe
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建道路网络路线规划器*的配方'
- en: Creating a route planner for a road network
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个道路网络的路线规划器
- en: In this recipe, we build upon several techniques described in the previous recipes
    in order to create a simple GPS-like route planner in Python. We will retrieve
    California's road network data from the United States Census Bureau in order to
    find shortest paths in the road network graph. This allows us to display road
    itineraries between any two locations in California.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，我们基于前面几个实例中描述的技术，创建了一个简单的类似 GPS 的路线规划器。我们将从美国人口普查局获取加利福尼亚州的道路网络数据，用来在道路网络图中寻找最短路径。这使我们能够显示加利福尼亚州任意两地之间的道路路线。
- en: Getting ready
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need NetworkX and Smopy for this recipe. In order for NetworkX to read Shapefile
    datasets, you also need GDAL/OGR. You can find more information in the previous
    recipe.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本实例需要 NetworkX 和 Smopy。在让 NetworkX 读取 Shapefile 数据集时，还需要 GDAL/OGR。更多信息可以参考前面的实例。
- en: You also need to download the *Road* dataset from the book's GitHub repository
    at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data),
    and extract it in the current directory.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要从书籍的 GitHub 仓库下载 *Road* 数据集：[https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)，并将其解压到当前目录。
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of this writing, NetworkX's support of Shapefile doesn't seem to
    be compatible with Python 3.x. For this reason, this recipe has only been successfully
    tested with Python 2.x.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这篇文章时，NetworkX 对 Shapefile 的支持似乎与 Python 3.x 不兼容。因此，这个方法仅在 Python 2.x 下成功测试过。
- en: How to do it…
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Let''s import the packages:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入相关包：
- en: '[PRE64]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We load the data (a Shapefile dataset) with NetworkX. This dataset contains
    detailed information about the primary roads in California. NetworkX's `read_shp()`
    function returns a graph, where each node is a geographical position, and each
    edge contains information about the road linking the two nodes. The data comes
    from the United States Census Bureau website at [www.census.gov/geo/maps-data/data/tiger.html](http://www.census.gov/geo/maps-data/data/tiger.html).
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 NetworkX 加载数据（Shapefile 数据集）。这个数据集包含了加利福尼亚州主要道路的详细信息。NetworkX 的 `read_shp()`
    函数返回一个图，其中每个节点是一个地理位置，每条边包含连接两个节点的道路信息。数据来自美国人口普查局网站 [www.census.gov/geo/maps-data/data/tiger.html](http://www.census.gov/geo/maps-data/data/tiger.html)。
- en: '[PRE65]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This graph is not necessarily connected, but we need a connected graph in order
    to compute shortest paths. Here, we take the largest connected subgraph using
    the `connected_component_subgraphs()` function:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个图不一定是连通的，但为了计算最短路径，我们需要一个连通图。在这里，我们使用 `connected_component_subgraphs()` 函数获取最大的连通子图：
- en: '[PRE66]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We define two positions (with the latitude and longitude) and find the shortest
    path between these two positions:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了两个位置（包含纬度和经度），并找出这两个位置之间的最短路径：
- en: '[PRE67]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Each edge in the graph contains information about the road, including a list
    of points along this road. We first create a function that returns this array
    of coordinates, for any edge in the graph:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图中的每条边包含道路的详细信息，包括沿道路的点的列表。我们首先创建一个函数，返回图中任意一条边的坐标数组：
- en: '[PRE68]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can notably use the road path to compute its length. We first need to define
    a function that computes the distance between any two points in geographical coordinates.
    This function has been found in Stack Overflow ([http://stackoverflow.com/questions/8858838/need-help-calculating-geographical-distance](http://stackoverflow.com/questions/8858838/need-help-calculating-geographical-distance)):'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过道路路径来计算其长度。我们首先需要定义一个函数，计算地理坐标系中任意两点之间的距离。这个函数可以在 Stack Overflow 上找到 ([http://stackoverflow.com/questions/8858838/need-help-calculating-geographical-distance](http://stackoverflow.com/questions/8858838/need-help-calculating-geographical-distance))：
- en: '[PRE69]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we define a function computing a path''s length:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义一个计算路径长度的函数：
- en: '[PRE70]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we update our graph by computing the distance between any two connected
    nodes. We add this information in the `distance` attribute of the edges:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过计算任何两个连接节点之间的距离来更新我们的图。我们将这个信息添加到边的 `distance` 属性中：
- en: '[PRE71]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The last step before we can find the shortest path in the graph is to find
    the two nodes in the graph that are closest to the two requested positions:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够找到图中的最短路径之前，最后一步是找出图中最接近两个请求位置的两个节点：
- en: '[PRE72]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, we use NetworkX''s `shortest_path()` function to compute the shortest
    path between our two positions. We specify that the weight of every edge is the
    length of the road between them:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用 NetworkX 的 `shortest_path()` 函数来计算两个位置之间的最短路径。我们指定每条边的权重为它们之间道路的长度：
- en: '[PRE73]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The itinerary has been computed. The `path` variable contains the list of edges
    that form the shortest path between our two positions. Now, we can get information
    about the itinerary with pandas. The dataset has a few fields of interest, including
    the name and type (State, Interstate, and so on) of the roads:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行程已计算完成。`path` 变量包含了构成我们两点之间最短路径的边的列表。现在，我们可以通过 pandas 获取有关行程的信息。数据集中有几个感兴趣的字段，包括道路的名称和类型（州道、州际公路等）：
- en: '[PRE74]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here is the total length of this itinerary:'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是此行程的总长度：
- en: '[PRE75]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, let''s display the itinerary on the map. We first retrieve the map
    with Smopy:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们在地图上展示该行程。我们首先通过 Smopy 获取地图：
- en: '[PRE76]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Our path contains connected nodes in the graph. Every edge between two nodes
    is characterized by a list of points (constituting a part of the road). Therefore,
    we need to define a function that concatenates the positions along every edge
    in the path. We have to concatenate the positions in the right order along our
    path. We choose the order based on the fact that the last point in an edge needs
    to be close to the first point in the next edge:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的路径包含图中的连接节点。每两个节点之间的边由一系列点（构成道路的一部分）来描述。因此，我们需要定义一个函数，将路径中每个边上的位置串联起来。我们必须按照正确的顺序连接这些位置。我们选择的顺序是基于这样一个事实：一条边的最后一个点需要接近下一条边的第一个点：
- en: '[PRE77]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We convert the path in pixels in order to display it on the Smopy map:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将路径转换为像素，以便在 Smopy 地图上显示：
- en: '[PRE78]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Finally, let''s display the map, with our two positions and the computed itinerary
    between them:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们展示地图，标出我们的两个位置以及它们之间计算出的行程：
- en: '[PRE79]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![How to do it…](img/4818OS_14_13.jpg)'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现…](img/4818OS_14_13.jpg)'
- en: How it works…
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We computed the shortest path with NetworkX's `shortest_path()` function. Here,
    this function used **Dijkstra's algorithm**. This algorithm has a wide variety
    of applications, for example in network routing protocols.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 NetworkX 的 `shortest_path()` 函数计算了最短路径。这里，这个函数使用了**Dijkstra 算法**。这个算法有着广泛的应用，例如网络路由协议。
- en: 'There are different ways to compute the geographical distance between two points.
    Here, we used a relatively precise formula: the **orthodromic distance** (also
    called **great-circle distance**), which assumes that the Earth is a perfect sphere.
    We could also have used a simpler formula since the distance between two successive
    points on a road is small.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 计算两个点之间的地理距离有多种方法。在这里，我们使用了一个相对精确的公式：**正弦距离**（也叫做**大圆距离**），该公式假设地球是一个完美的球体。我们也可以使用一个更简单的公式，因为在一条路上两个连续点之间的距离很小。
- en: There's more…
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'You can find more information about shortest path problems and Dijkstra''s
    algorithm in the following references:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下参考资料中找到关于最短路径问题和 Dijkstra 算法的更多信息：
- en: Shortest paths on Wikipedia, available at [http://en.wikipedia.org/wiki/Shortest_path_problem](http://en.wikipedia.org/wiki/Shortest_path_problem)
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的最短路径，[http://en.wikipedia.org/wiki/Shortest_path_problem](http://en.wikipedia.org/wiki/Shortest_path_problem)
- en: Dijkstra's algorithm, described at [http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dijkstra 算法，描述见 [http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
- en: 'Here are a few references about geographical distances:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于地理距离的参考资料：
- en: Geographical distance on Wikipedia, at [http://en.wikipedia.org/wiki/Geographical_distance](http://en.wikipedia.org/wiki/Geographical_distance)
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的地理距离，[http://en.wikipedia.org/wiki/Geographical_distance](http://en.wikipedia.org/wiki/Geographical_distance)
- en: Great circles on Wikipedia, at [http://en.wikipedia.org/wiki/Great_circle](http://en.wikipedia.org/wiki/Great_circle)
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的大圆，[http://en.wikipedia.org/wiki/Great_circle](http://en.wikipedia.org/wiki/Great_circle)
- en: Great-circle distance on Wikipedia, at [http://en.wikipedia.org/wiki/Great-circle_distance](http://en.wikipedia.org/wiki/Great-circle_distance)
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的大圆距离，[http://en.wikipedia.org/wiki/Great-circle_distance](http://en.wikipedia.org/wiki/Great-circle_distance)
