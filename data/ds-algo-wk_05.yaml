- en: Clustering into K Clusters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据聚类为K个簇
- en: Clustering is a technique for dividing data into clusters, with the same features
    in the same cluster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类是一种将数据划分为簇的技术，相同特征的项会被归为同一个簇。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: How to use the *k*-means clustering algorithm, using an example involving household
    incomes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用*k*-均值聚类算法，通过涉及家庭收入的例子来演示
- en: How to classify features by clustering them first with the features, along with
    the known classes, using an example of gender classification
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过将特征与已知类别一起聚类，使用性别分类的例子来对特征进行分类
- en: How to implement the *k*-means clustering algorithm in Python in the *Implementation
    of k-means clustering algorithm* section
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在*实现k均值聚类算法*部分中使用Python实现*k*-均值聚类算法
- en: An example of house ownership and how to choose an appropriate number of clusters
    for your analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 房屋拥有情况的例子，以及如何为你的分析选择合适的簇数
- en: How to use the example of house ownership to scale a given set of numerical
    data appropriately to improve the accuracy of classification by using a clustering
    algorithm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过使用聚类算法，利用房屋拥有情况的例子，合理地缩放给定的数值数据，以提高分类的准确性
- en: An understanding of how different numbers of clusters alter the meaning of the
    dividing line between those clusters, using an example of document clustering
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不同簇数如何改变簇与簇之间分界线的含义，通过文档聚类的例子来说明
- en: Household incomes – clustering into k clusters
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 家庭收入 – 将数据聚类为k个簇
- en: For example, let's look at households whose annual earnings in USD are $40,000,
    $55,000, $70,000, $100,000, $115,000, $130,000 and $135,000\. Then, if we were
    to combine those households into two clusters, taking their earnings as a measure
    of similarity, the first cluster would have those households earning 40 k, 55
    k, and 70 k, while the second cluster would include those households earning 100
    k, 115 k, 130 k, and 135 k.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们来看一下年收入分别为40,000美元、55,000美元、70,000美元、100,000美元、115,000美元、130,000美元和135,000美元的家庭。然后，如果我们将这些家庭根据收入作为相似度标准分为两个簇，第一个簇会包括年收入为40k、55k和70k的家庭，而第二个簇会包括年收入为100k、115k、130k和135k的家庭。
- en: This is because 40k and 135k are furthest away from each other so, because we
    want to have two clusters, these have to be in different clusters. 55 K is closer
    to 40 k than to 135 k, so 40 k and 55 k will be in the same cluster. Similarly,
    130 k and 135 k will be in the same cluster. 70 K is closer to 40 k and 55 k than
    to 130 K and 135 k, so 70 k should be in the cluster with 40 k and 55 k. 115 K
    is closer to 130 k and 135 k than to the first cluster containing 40 k, 55 k, and
    70 k, so it will be in the second cluster. Finally, 100 k is closer to the second
    cluster, containing 115 k, 130 k, and 135 k, so it will be located there. Therefore,
    the first cluster will include 40 k, 55 k, and 70  households. The second cluster
    will include the 100 k, 115 k, 130 k, and 135 k households.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为40k和135k相距最远，所以我们希望分成两个簇，它们必须分别属于不同的簇。55k比135k更接近40k，因此40k和55k会在同一个簇。类似地，130k和135k会在同一个簇。70k比130k和135k更接近40k和55k，因此70k应该和40k、55k在同一个簇。115k比40k、55k和70k所在的第一个簇更接近130k和135k，因此它会在第二个簇。最后，100k更接近包含115k、130k和135k的第二个簇，因此它会被归类到那里。因此，第一个簇将包括年收入为40k、55k和70k的家庭。第二个簇将包括年收入为100k、115k、130k和135k的家庭。
- en: Clustering the features of groups with similar properties and assigning a cluster
    to a feature is a form of classification. It is up to a data scientist to interpret
    the result of the clustering and what classification it induces. Here, the cluster
    containing the households with annual incomes of USD 40 k, 55 k, and 70 k represents
    a class of households with a low income. The second cluster, including households
    with an annual income of USD 100 k, 115 k, 130 k, and 135 k, represents a class
    of households with a high income.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类具有相似属性的组的特征，并将簇分配给某个特征是一种分类形式。数据科学家需要解释聚类结果以及它所引发的分类。在这里，包含年收入为40k、55k和70k家庭的簇代表了低收入家庭类。第二个簇，包括年收入为100k、115k、130k和135k的家庭，代表了高收入家庭类。
- en: We clustered the households into the two clusters in an informal way based on
    intuition and common sense. There are clustering algorithms that cluster data
    according to precise rules. These algorithms include a fuzzy c-means clustering
    algorithm, a hierarchical clustering algorithm, a Gaussian (EM) clustering algorithm,
    a quality threshold clustering algorithm, and a *k*-means clustering algorithm,
    which is the focus of this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据直觉和常识，非正式地将家庭收入划分为两个簇。也有一些聚类算法根据精确的规则对数据进行聚类。这些算法包括模糊C均值聚类算法、层次聚类算法、高斯（EM）聚类算法、质量阈值聚类算法和*k*均值聚类算法，本章将重点介绍后者。
- en: K-means clustering algorithm
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: K均值聚类算法
- en: The *k*-means clustering algorithm classifies given points into *k* groups in
    such a way that the distance between members of the same group is minimized.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*k*均值聚类算法将给定的点分类到*k*个组中，使得同一组内的成员之间的距离最小。'
- en: The *k*-means clustering algorithm determines the initial *k*-centroids (points
    in a cluster center)—one for each cluster. Then, each feature is classified into
    the cluster whose centroid is closest to that feature. After classifying all the
    features, we have formed an initial *k* clusters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*k*均值聚类算法确定初始的*k*质心（每个簇的中心点）——每个簇一个质心。然后，每个特征会被分类到与该特征距离最近的簇中。分类所有特征之后，我们就形成了初始的*k*个簇。'
- en: For each cluster, we recomputed the centroid to be the average of the points
    in that cluster. After we have moved the centroids, we recompute the classes again.
    The features in the classes may change. In this case, we have to recompute the
    centroids again. If the centroids no longer move, then the *k*-means clustering
    algorithm terminates.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个簇，我们重新计算质心，作为该簇内所有点的平均值。在移动了质心之后，我们再次重新计算类别。类别中的特征可能会发生变化。在这种情况下，我们需要重新计算质心。如果质心不再移动，则*k*均值聚类算法终止。
- en: Picking the initial k-centroids
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择初始的k个质心
- en: We could pick the initial *k*-centroids to be any of the *k* features in the
    data to be classified. But, ideally, we would like to pick points that belong
    to different clusters from the very outset. Therefore, we may want to aim to maximize
    their mutual distance in a certain way. Simplifying the process, we could pick
    the first centroid to be any point from the features. The second could be the
    one that is furthest from the first. The third could be the one that is furthest
    from both the first and second, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将初始的*k*个质心选择为数据中任意的*k*个特征。但是，理想情况下，我们希望从一开始就选择属于不同簇的点。因此，我们可能希望通过某种方式最大化它们之间的相互距离。简化过程后，我们可以将第一个质心选为数据中任意一个点。第二个质心可以选为距离第一个质心最远的点。第三个质心可以选为同时距离第一个和第二个质心最远的点，依此类推。
- en: Computing a centroid of a given cluster
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算给定簇的质心
- en: A centroid of a cluster is just an average of the points in that cluster. If
    a cluster contains one-dimensional points with the coordinates *x[1], x[2], …,
    x[n]*, then the centroid of that cluster would be  ![](img/a1e22e13-4d22-4526-a133-86bca036067f.png).
    If a cluster contains two-dimensional points with the coordinates *(x[1],y[1]),(x[2],y[2]),…,(x[n],y[n])*,
    then the *x*-coordinate of the centroid of the cluster would have the value *(1/n)*(x[1]+x[2]+...+x[n])*,
    and the *y*-coordinate would have the value ![](img/afbc1a34-7864-4496-a187-513dc5e5d8f1.png).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个簇的质心只是该簇内所有点的平均值。如果一个簇包含一维点，其坐标为*x[1]、x[2]、…、x[n]*，那么该簇的质心为![](img/a1e22e13-4d22-4526-a133-86bca036067f.png)。如果一个簇包含二维点，其坐标为*(x[1],y[1])、(x[2],y[2])、…、(x[n],y[n])*，那么该簇的质心在*x*坐标的值为*(1/n)*(x[1]+x[2]+...+x[n])*，在*y*坐标的值为![](img/afbc1a34-7864-4496-a187-513dc5e5d8f1.png)。
- en: This computation generalizes easily to higher dimensions. If the value of the
    higher-dimensional features for the *x*-coordinate are *x[1], x[2], …, x[n]*,
    then the value of the *x*-coordinate for the centroid is ![](img/afbc1a34-7864-4496-a187-513dc5e5d8f1.png).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算方法可以轻松扩展到更高的维度。如果在*x*坐标的高维特征值为*x[1]、x[2]、…、x[n]*，那么该簇的质心在*x*坐标的值为![](img/afbc1a34-7864-4496-a187-513dc5e5d8f1.png)。
- en: Using the k-means clustering algorithm on the household income example
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在家庭收入的例子中使用k均值聚类算法
- en: We will apply the *k*-clustering algorithm to the household income example.
    In the beginning, we have households with incomes of $40,000, $55,000, $70,000,
    $100,000, $115,000, $130,000 and $135,000.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用*k*聚类算法来分析家庭收入的例子。一开始，我们有收入分别为$40,000、$55,000、$70,000、$100,000、$115,000、$130,000和$135,000的家庭。
- en: The first centroid to be picked up can be any feature, for example, $70,000\.
    The second centroid should be the feature that is furthest from the first one,
    that is 135 k, since 135 k minus 70 k is 65 k, which is the greatest difference
    between any other feature and 70 k. Thus, 70 k is the centroid of the first cluster,
    while 135 k is the centroid of the second cluster.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个被选择的质心可以是任何特征，例如，$70,000\. 第二个质心应该是与第一个最远的特征，即135 k，因为135 k减去70 k是65 k，这是任何其他特征与70
    k之间的最大差异。因此，70 k是第一个簇的质心，而135 k是第二个簇的质心。
- en: Now, by taking the difference, 40 k, 55 k, 70 k, and 100 k are closer to 70
    k than to 135 k, so they will be in the first cluster, while 115 k, 130 k, and
    135 k are closer to 135 k than to 70 k, so they will be in the second cluster.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过差异，40 k、55 k、70 k和100 k更接近70 k而不是135 k，因此它们将位于第一个簇中，而115 k、130 k和135 k更接近135
    k而不是70 k，因此它们将位于第二个簇中。
- en: 'After we have classified the features according to the initial centroids, we
    recompute the centroids. The centroid of the first cluster is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在根据初始质心对特征进行分类之后，我们重新计算质心。第一个簇的质心如下：
- en: '![](img/ee300cca-5ab2-44aa-ab19-2c686e619d9d.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee300cca-5ab2-44aa-ab19-2c686e619d9d.png)'
- en: 'The centroid of the second cluster is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个簇的质心如下：
- en: '![](img/179e82f3-1388-4a6c-b804-02c8bd469ee9.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/179e82f3-1388-4a6c-b804-02c8bd469ee9.png)'
- en: 'Using the new centroids, we reclassify the features as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的质心，我们重新分类特征如下：
- en: The first cluster containing the centroid 66.25 k will contain the features
    40 k, 55 k, and 70 k
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含质心66.25 k的第一个簇将包含特征40 k、55 k和70 k
- en: The second cluster containing the centroid 126.66 k will contain the features
    100 k, 115 k, 130 k, and 135 k
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含质心126.66 k的第二个簇将包含特征100 k、115 k、130 k和135 k
- en: We notice that the 100 k feature moved from the first cluster to the second,
    since it is now closer to the centroid of the second cluster (*distance |100 k-126.66
    k|=26.66 k*) than to the centroid of the first cluster (*distance |100 k-66.25
    k|=33.75 k*). Since the features in the clusters have changed, we have to recompute
    the centroids again.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，100 k特征从第一个簇移动到第二个簇，因为它现在更接近第二个簇的质心（*距离 |100 k-126.66 k|=26.66 k*），而不是第一个簇的质心（*距离
    |100 k-66.25 k|=33.75 k*）。由于簇中的特征已经改变，我们必须重新计算质心。
- en: 'The centroid of the first cluster is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个簇的质心如下：
- en: '![](img/e5779d6d-ccc3-4ba7-ada3-509f3df61c4c.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5779d6d-ccc3-4ba7-ada3-509f3df61c4c.png)'
- en: 'The centroid of the second cluster is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个簇的质心如下：
- en: '![](img/28b0ff92-f3a2-4778-82cd-d6d8e878de27.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28b0ff92-f3a2-4778-82cd-d6d8e878de27.png)'
- en: Using these centroids, we reclassify the features into the clusters. The first
    centroid, 55 k, will contain the features 40 k, 55 k, and 70 k. The second centroid,
    120 k, will contain the features 100 k, 115 k, 130 k, and 135 k. Thus, when the
    centroids were updated, the clusters did not change. Hence, their centroids will
    remain the same.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些质心，我们将特征重新分类到簇中。第一个质心，55 k，将包含特征40 k、55 k和70 k。第二个质心，120 k，将包含特征100 k、115
    k、130 k和135 k。因此，在更新质心时，簇没有改变。因此，它们的质心将保持不变。
- en: 'Therefore, the algorithm terminates with the two clusters: the first cluster
    having the features 40 k, 55 k, and 70 k, and the second cluster having the features
    100 k, 115 k, 130 k, and 135 k.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，算法以两个簇终止：第一个簇包含特征40 k、55 k和70 k，第二个簇包含特征100 k、115 k、130 k和135 k。
- en: Gender classification – clustering to classify
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性别分类 – 聚类分类
- en: 'The following data is taken from the gender classification example, *Problem
    6*, Chapter 2, *Naive Bayes*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的数据来自性别分类示例，*问题6*，第2章，*朴素贝叶斯*：
- en: '| **Height in cm** | **Weight in kg** | **Hair length** | **Gender** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '**身高（厘米）** | **体重（公斤）** | **头发长度** | **性别** |'
- en: '| 180 | 75 | Short | Male |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 180 | 75 | 短 | 男 |'
- en: '| 174 | 71 | Short | Male |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 174 | 71 | 短 | 男 |'
- en: '| 184 | 83 | Short | Male |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 184 | 83 | 短 | 男 |'
- en: '| 168 | 63 | Short | Male |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 168 | 63 | 短 | 男 |'
- en: '| 178 | 70 | Long | Male |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 178 | 70 | 长 | 男 |'
- en: '| 170 | 59 | Long | Female |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 170 | 59 | 长 | 女 |'
- en: '| 164 | 53 | Short | Female |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 164 | 53 | 短 | 女 |'
- en: '| 155 | 46 | Long | Female |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 155 | 46 | 长 | 女 |'
- en: '| 162 | 52 | Long | Female |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 162 | 52 | 长 | 女 |'
- en: '| 166 | 55 | Long | Female |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 166 | 55 | 长 | 女 |'
- en: '| 172 | 60 | Long | ? |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 172 | 60 | 长 | ? |'
- en: 'To simplify matters, we will remove the column entitled **Hair length**. We
    will also remove the column entitled **Gender**, since we would like to cluster
    the people in the table based on their height and weight. We would like to establish
    whether the eleventh person in the table is more likely to be a man or a woman
    using clustering:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们将移除名为 **Hair length** 的列。我们还将移除名为 **Gender** 的列，因为我们希望根据身高和体重对表中的人进行聚类。我们希望通过聚类判断表中第十一位人的性别更可能是男性还是女性：
- en: '| **Height in cm** | **Weight in kg** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **Height in cm** | **Weight in kg** |'
- en: '| 180 | 75 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 180 | 75 |'
- en: '| 174 | 71 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 174 | 71 |'
- en: '| 184 | 83 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 184 | 83 |'
- en: '| 168 | 63 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 168 | 63 |'
- en: '| 178 | 70 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 178 | 70 |'
- en: '| 170 | 59 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 170 | 59 |'
- en: '| 164 | 53 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 164 | 53 |'
- en: '| 155 | 46 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 155 | 46 |'
- en: '| 162 | 52 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 162 | 52 |'
- en: '| 166 | 55 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 166 | 55 |'
- en: '| 172 | 60 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 172 | 60 |'
- en: Analysis
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析
- en: We may apply scaling to the initial data, but to simplify matters, we will use
    the unscaled data in the algorithm. We will cluster the data we have into two
    clusters, since there are two possibilities for gender—male or female. Then, we
    will aim to classify a person with a height of 172 cm and a weight of 60 kg as
    being more likely be a man if, and only if, there are more men in that cluster.
    The clustering algorithm is a very efficient technique. Thus, classifying in this
    way is very fast, especially if there are a lot of features to classify.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对初始数据进行缩放，但为了简化问题，我们将在算法中使用未经缩放的数据。我们将把已有数据聚类为两个簇，因为性别只有两种可能——男性或女性。然后，我们将根据聚类结果来分类一个身高为
    172 厘米、体重为 60 公斤的人，如果且仅当该聚类中男性更多时，才将其归类为男性。聚类算法是一种非常高效的技术。因此，以这种方式进行分类非常快速，尤其是在需要分类的特征非常多的情况下。
- en: So, let's apply the *k*-means clustering algorithm to the data we have. First,
    we pick the initial centroids. Let the first centroid, for example, be a person
    with a height of 180 cm and a weight of 75 kg, denoted in a vector as *(180,75)*.
    The point that is furthest away from *(180,75)* is *(155,46)*. So that will be
    the second centroid.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们对已有数据应用 *k*-均值聚类算法。首先，选择初始质心。例如，将第一个质心设为一个身高 180 厘米、体重 75 公斤的人，用向量表示为
    *(180,75)*。与 *(180,75)* 最远的点是 *(155,46)*。所以它将作为第二个质心。
- en: 'The points that are closer to the first centroid *(180,75)* by taking Euclidean
    distance are *(180,75)*, *(174,71)*, *(184,83)*, *(168,63), (178,70)*, *(170,59)*,
    and *(172,60)*. So these points will be in the first cluster. The points that
    are closer to the second centroid *(155,46)* are *(155,46)*, *(164,53)*, *(162,52)*,
    and *(166,55)*. So these points will be in the second cluster. The current situation
    involving these two clusters is displayed in the following diagram:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算欧几里得距离，离第一个质心 *(180,75)* 最近的点是 *(180,75)*, *(174,71)*, *(184,83)*, *(168,63)*,
    *(178,70)*, *(170,59)* 和 *(172,60)*。所以这些点将属于第一个簇。离第二个质心 *(155,46)* 最近的点是 *(155,46)*,
    *(164,53)*, *(162,52)* 和 *(166,55)*。所以这些点将属于第二个簇。涉及这两个聚类的当前情况如下面的图示所示：
- en: '![](img/2ca5c8e6-7dd7-4d76-83ac-ea0752aebe07.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ca5c8e6-7dd7-4d76-83ac-ea0752aebe07.png)'
- en: 'Figure 5.1: Clustering of people according to their height and weight'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：根据身高和体重对人的聚类
- en: Let's recompute the centroids of the clusters. The blue cluster with the features
    (*180,75)*, *(174,71)*, *(184,83)*, *(168,63)*, *(178,70), (170,59)*, and *(172,60)*
    will have the centroid *((180+174+184+168+178+170+172)/7,(75+71+83+63+70+59+60)/7)~(175.14,68.71)*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新计算聚类的质心。具有特征 (*180,75)*, *(174,71)*, *(184,83)*, *(168,63)*, *(178,70)*,
    *(170,59)* 和 *(172,60)* 的蓝色聚类将有质心 *((180+174+184+168+178+170+172)/7,(75+71+83+63+70+59+60)/7)~(175.14,68.71)*。
- en: The red cluster with the features *(155,46)*, *(164,53)*, *(162,52)*, and *(166,55)*
    will have the centroid *((155+164+162+166)/4,(46+53+52+55)/4)=(161.75, 51.5)*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 红色聚类包含特征 *(155,46)*, *(164,53)*, *(162,52)* 和 *(166,55)*，其质心为 *((155+164+162+166)/4,(46+53+52+55)/4)=(161.75,
    51.5)*。
- en: 'Reclassifying the points using the new centroid, the classes of the points
    do not change. The blue cluster will have the points *(180,75)*, *(174,71)*, *(184,83)*,
    *(168,63)*, *(178,70)*, *(170,59)*, and *(172,60)*. The red cluster will have
    the points *(155,46)*, *(164,53)*, *(162,52)*, and *(166,55)*. Therefore, the
    clustering algorithm terminates with clusters, as depicted in the following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的质心重新分类点时，点的类别没有变化。蓝色聚类将包含点 *(180,75)*, *(174,71)*, *(184,83)*, *(168,63)*,
    *(178,70)*, *(170,59)* 和 *(172,60)*。红色聚类将包含点 *(155,46)*, *(164,53)*, *(162,52)*
    和 *(166,55)*。因此，聚类算法在以下图示中结束，得到了聚类：
- en: '![](img/736d91cc-3378-4953-9286-8034a22357e1.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/736d91cc-3378-4953-9286-8034a22357e1.png)'
- en: 'Figure 5.2: Clustering of people according to their height and weight'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：根据身高和体重对人的聚类
- en: Now we would like to classify the instance *(172,60)* as to whether that person
    is a male or a female. The instance *(172,60)* is in the blue cluster, so it is
    similar to the features in the blue cluster. Are the remaining features in the
    blue cluster more likely male or female? Five out of six features are male, while
    only one is female. Since the majority of the features are male in the blue cluster
    and the person *(172,60)* is in the blue cluster as well, we classify a person
    with a height of 172 cm and a weight of 60 kg as male.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们希望将实例 *(172,60)* 分类为男性还是女性。实例 *(172,60)* 位于蓝色簇中，因此它与蓝色簇中的特征相似。剩余的特征是在蓝色簇中更可能是男性还是女性呢？六个特征中有五个是男性，只有一个是女性。由于蓝色簇中的大多数特征是男性，而且
    *(172,60)* 也位于蓝色簇中，因此我们将身高 172 cm、体重 60 kg 的人分类为男性。
- en: Implementation of the k-means clustering algorithm
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: k-means 聚类算法的实现
- en: 'We will now implement the *k*-means clustering algorithm. It takes a CSV file
    as input with one data item per line. A data item is converted into a point. The
    algorithms classify these points into the specified number of clusters. In the
    end, the clusters are visualized on a graph using the `matplotlib` library:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现 *k*-means 聚类算法。它以 CSV 文件作为输入，每一行代表一个数据项。每个数据项被转换为一个点。算法将这些点分为指定数量的簇。最终，聚类结果将在图表上可视化，使用
    `matplotlib` 库：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Input data from gender classification
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性别分类输入数据
- en: 'We save data from the gender classification example into the CSV file as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将性别分类示例中的数据保存到 CSV 文件中，如下所示：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Program output for gender classification data
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性别分类数据的程序输出
- en: 'We run the program, implementing the *k*-means clustering algorithm on the
    data from the gender classification example. The numerical argument `2` means
    that we would like to cluster the data into two clusters, as can be seen in the
    following block of code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行程序，实施 *k*-means 聚类算法在性别分类示例的数据上。数值参数 `2` 表示我们希望将数据聚类成两个簇，如下方代码块所示：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The program also outputs a graph, visible in *Figure 5.2.* The `last` parameter
    means that we would like the program to perform clustering until the final step.
    If we would like to display only the first step (step 0), we could change the
    last to `0` in order to run, as can be seen in the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 程序还输出了一个图表，见于*图 5.2*。`last` 参数表示我们希望程序进行聚类直到最后一步。如果我们只想显示第一步（步骤 0），可以将 `last`
    改为 `0`，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Upon execution of the program, we would get a graph of the clusters and their
    centroids in the initial step, as in *Figure 5.1*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行后，我们将得到一个关于聚类及其质心的图像，如*图 5.1*所示。
- en: House ownership – choosing the number of clusters
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 房屋所有权 – 选择聚类数量
- en: 'Let''s take the example from the first chapter regarding house ownership:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以第一章中的房屋所有权示例为例：
- en: '| **Age** | **Annual income in USD** | **House ownership status** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **年龄** | **年收入（美元）** | **房屋所有权状态** |'
- en: '| 23 | 50,000 | Non-owner |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 23 | 50,000 | 非拥有者 |'
- en: '| 37 | 34,000 | Non-owner |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 37 | 34,000 | 非拥有者 |'
- en: '| 48 | 40,000 | Owner |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 48 | 40,000 | 拥有者 |'
- en: '| 52 | 30,000 | Non-owner |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 52 | 30,000 | 非拥有者 |'
- en: '| 28 | 95,000 | Owner |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 28 | 95,000 | 拥有者 |'
- en: '| 25 | 78,000 | Non-owner |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 25 | 78,000 | 非拥有者 |'
- en: '| 35 | 13,0000 | Owner |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 35 | 13,0000 | 拥有者 |'
- en: '| 32 | 10,5000 | Owner |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 10,5000 | 拥有者 |'
- en: '| 20 | 10,0000 | Non-owner |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 10,0000 | 非拥有者 |'
- en: '| 40 | 60,000 | Owner |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 40 | 60,000 | 拥有者 |'
- en: '| 50 | 80,000 | Peter |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 80,000 | Peter |'
- en: We would like to predict whether Peter is a house owner using clustering.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过聚类预测 Peter 是否是房屋拥有者。
- en: Analysis
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析
- en: Just as in the first chapter, we will have to scale the data, since the *income*
    axis is significantly greater and thus would diminish the impact of the *age*
    axis, which actually has a good predictive power in this kind of problem. This
    is because it is expected that older people have had more time to settle down,
    save money, and buy a house, as compared to younger people.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像第一章一样，我们需要对数据进行缩放，因为 *收入* 轴的数值明显大于 *年龄* 轴，从而减少了 *年龄* 轴的影响，而实际上在这种问题中，*年龄*
    具有很好的预测能力。因为预期年长的人有更多的时间定居、存钱并购买房产，而相较于年轻人，年长的人更可能是房屋拥有者。
- en: 'We apply the same rescaling from [Chapter 1](e0824a1e-65dc-4fee-a0e5-56170fdb36b9.xhtml), *Classification
    Using K Nearest Neighbors*, and obtain the following table:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用了[第一章](e0824a1e-65dc-4fee-a0e5-56170fdb36b9.xhtml)中的相同重缩放方法，*基于 K 最近邻的分类*，并得到了以下表格：
- en: '| **Age** | **Scaled age** | **Annual income in USD** | **Scaled annual income**
    | **House ownership status** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **年龄** | **缩放后的年龄** | **年收入（美元）** | **缩放后的年收入** | **房屋所有权状态** |'
- en: '| 23 | 0.09375 | 50000 | 0.2 | non-owner |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 23 | 0.09375 | 50000 | 0.2 | 非房主 |'
- en: '| 37 | 0.53125 | 34000 | 0.04 | non-owner |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 37 | 0.53125 | 34000 | 0.04 | 非房主 |'
- en: '| 48 | 0.875 | 40000 | 0.1 | owner |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 48 | 0.875 | 40000 | 0.1 | 房主 |'
- en: '| 52 | 1 | 30000 | 0 | non-owner |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 52 | 1 | 30000 | 0 | 非房主 |'
- en: '| 28 | 0.25 | 95000 | 0.65 | owner |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 28 | 0.25 | 95000 | 0.65 | 房主 |'
- en: '| 25 | 0.15625 | 78000 | 0.48 | non-owner |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 25 | 0.15625 | 78000 | 0.48 | 非房主 |'
- en: '| 35 | 0.46875 | 130000 | 1 | owner |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 35 | 0.46875 | 130000 | 1 | 房主 |'
- en: '| 32 | 0.375 | 105000 | 0.75 | owner |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 0.375 | 105000 | 0.75 | 房主 |'
- en: '| 20 | 0 | 100000 | 0.7 | non-owner |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 0 | 100000 | 0.7 | 非房主 |'
- en: '| 40 | 0.625 | 60000 | 0.3 | owner |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 40 | 0.625 | 60000 | 0.3 | 房主 |'
- en: '| 50 | 0.9375 | 80000 | 0.5 | ? |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 0.9375 | 80000 | 0.5 | ? |'
- en: Given the table, we produce the input file for the algorithm and execute it,
    clustering the features into two clusters.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 根据该表，我们生成算法的输入文件并执行它，将特征聚类为两个簇。
- en: '**Input**:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**：'
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Output for two clusters**:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**两个簇的输出**：'
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/d27bf970-4129-4f73-a650-d9109a755968.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d27bf970-4129-4f73-a650-d9109a755968.png)'
- en: The blue cluster contains scaled features – *(0.09375,0.2)*, *(0.25,0.65)*,
    *(0.15625,0.48)*, *(0.46875,1)*, *(0.375,0.75)*, and *(0,0.7),* and unscaled ones
    – *(23,50000)*, *(28,95000)*, *(25,78000)*, *(35,130000)*, *(32,105000)*, and *(20,100000)*.
    The red cluster contains scaled features –*(0.53125,0.04)*, *(0.875,0.1)*, *(1,0)*,
    *(0.625,0.3)*, and *(0.9375,0.5),* and unscaled ones *(37,34000)*, *(48,40000)*,
    *(52,30000)*, *(40,60000)*, and *(50,80000)*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色簇包含已缩放的特征–*(0.09375,0.2)*，*(0.25,0.65)*，*(0.15625,0.48)*，*(0.46875,1)*，*(0.375,0.75)*，和未缩放的特征–*(23,50000)*，*(28,95000)*，*(25,78000)*，*(35,130000)*，*(32,105000)*，和*(20,100000)*。红色簇包含已缩放的特征–*(0.53125,0.04)*，*(0.875,0.1)*，*(1,0)*，*(0.625,0.3)*，和*(0.9375,0.5)*，以及未缩放的特征–*(37,34000)*，*(48,40000)*，*(52,30000)*，*(40,60000)*，和*(50,80000)*。
- en: So, Peter belongs to the red cluster. What is the proportion of house owners
    in the red cluster, not counting Peter? 2/4, or 1/2, of the people in the red
    cluster are house owners. Thus, the red cluster, to which Peter belongs, does
    not seem to have a high predictive power in determining whether Peter would be
    a house owner or not. We may try to cluster the data into more clusters, in the
    hope that we would gain a purer cluster that could be more reliable for the prediction
    of house ownership for Peter. Therefore, let's try to cluster the data into three
    clusters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，彼得属于红色簇。那么，在不计彼得的情况下，红色簇中房主的比例是多少？红色簇中有2/4，或者说1/2的人是房主。因此，彼得所在的红色簇似乎在判断彼得是否为房主上没有太高的预测能力。我们可以尝试将数据聚类成更多簇，希望能获得一个更纯粹的簇，这样对预测彼得是否为房主会更可靠。因此，让我们尝试将数据聚类成三个簇。
- en: '**Output for three clusters**:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**三个簇的输出**：'
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/4e4dbc70-3394-483c-9e88-fcfc3cbcd199.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e4dbc70-3394-483c-9e88-fcfc3cbcd199.png)'
- en: The red cluster has stayed the same. So let's cluster the data into four clusters.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 红色簇保持不变。所以我们将数据聚类成四个簇。
- en: '**Output for four clusters**:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**四个簇的输出**：'
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/39fd3799-c004-48c0-bfa9-e87f0befb50b.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39fd3799-c004-48c0-bfa9-e87f0befb50b.png)'
- en: Now, the red cluster, where Peter belongs, has changed. What is the proportion
    of house owners in the red cluster now? If we do not count Peter, 2/3 of people
    in the red cluster own a house. When we clustered into two or three clusters,
    the proportion was only ½, which did not tell us whether Peter is a house owner
    or not. Now, there is a majority of house owners in the red cluster, not counting
    Peter, so we have a stronger belief that Peter is also a house owner. However,
    2/3 is still a relatively low confidence level for classifying Peter as a house
    owner. Let's cluster the data into five clusters to see what happens.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，彼得所在的红色簇发生了变化。那么，红色簇中房主的比例是多少呢？如果不计算彼得，红色簇中有2/3的人是房主。当我们聚成两个簇或三个簇时，这个比例只有1/2，这并没有告诉我们彼得是否是房主。现在，红色簇中房主的比例多数（不算彼得），所以我们更相信彼得也是房主。然而，2/3仍然是一个相对较低的置信度，无法将彼得确定为房主。让我们将数据聚类成五个簇，看看会发生什么。
- en: '**Output for five clusters:**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**五个簇的输出**：'
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](img/51db4dd3-3ecb-4aa4-a035-8dfeb21018fb.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51db4dd3-3ecb-4aa4-a035-8dfeb21018fb.png)'
- en: Now, the red cluster contains only Peter and a non-owner. This clustering suggests
    that Peter is more likely a non-owner as well. However, according to the previous
    cluster, Peter is more likely be an owner of a house. Therefore, it may not be
    so clear whether Peter owns a house or not. Collecting more data would improve
    our analysis and should be carried out before making a definite classification
    of this problem.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，红色聚类只包含彼得和一名非所有者。这种聚类表明，彼得更可能是一个非所有者。然而，根据之前的聚类，彼得更可能是房主。因此，是否拥有房产的问题可能并不那么清晰。收集更多数据将有助于改善我们的分析，并应在做出最终分类之前进行。
- en: From our analysis, we noticed that a different number of clusters can result
    in a different result for a classification, since the nature of members in an
    individual cluster can change. After collecting more data, we should perform cross-validation
    to determine the number of clusters that classifies the data with the highest
    accuracy.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的分析，我们注意到，聚类的不同数量可能会导致分类结果不同，因为单个聚类中的成员性质可能会变化。收集更多数据后，我们应进行交叉验证，以确定能够以最高准确率对数据进行分类的聚类数量。
- en: Document clustering – understanding the number of k clusters in a semantic context
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档聚类——理解语义上下文中的 k 个聚类数量
- en: 'We are given the following information about the frequency counts for the words
    *money* and *god(s)* in the following 17 books from the Project Gutenberg library:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了关于来自古腾堡计划的 17 本书中 *money* 和 *god(s)* 词汇频率的信息如下：
- en: '| **Book number** | **Book name** | **Money as a %** | **God(s) as a %** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **书籍编号** | **书名** | **货币占比** | **神明占比** |'
- en: '| 1 | *The Vedanta-Sutras, with the commentary by**Ramanuja*, by Trans. George
    Thibaut | 0 | 0.07 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *吠檀多经注释* 由**拉马努贾**翻译，乔治·希博特译 | 0 | 0.07 |'
- en: '| 2 | *The Mahabharata of Krishna-Dwaipayana Vyasa**-Adi Parva*, by Kisari
    Mohan Ganguli | 0 | 0.17 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *克里希纳·德瓦伊帕亚纳·维亚萨史诗* ——阿底帕尔瓦卷，由吉萨里·莫汉·甘古利翻译 | 0 | 0.17 |'
- en: '| 3 | *The Mahabharata of Krishna-Dwaipayana**Vyasa, Pt. 2*, by Krishna-Dwaipayana
    Vyasa | 0.01 | 0.10 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *克里希纳·德瓦伊帕亚纳·维亚萨史诗* 第2部分，由克里希纳·德瓦伊帕亚纳·维亚萨编著 | 0.01 | 0.10 |'
- en: '| 4 | *The Mahabharata of Krishna-Dwaipayana Vyasa Bk.**3 Pt. 1*, by Krishna-Dwaipayana
    Vyasa | 0 | 0.32 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *克里希纳·德瓦伊帕亚纳·维亚萨史诗* 第3卷 第1部分，由克里希纳·德瓦伊帕亚纳·维亚萨编著 | 0 | 0.32 |'
- en: '| 5 | *The Mahabharata of Krishna-Dwaipayana Vyasa**Bk. 4*, by Kisari Mohan
    Ganguli | 0 | 0.06 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *克里希纳·德瓦伊帕亚纳·维亚萨史诗* 第4卷，由吉萨里·莫汉·甘古利翻译 | 0 | 0.06 |'
- en: '| 6 | *The Mahabharata of Krishna-Dwaipayana Vyasa**Bk. 3 Pt. 2*, translated
    by Kisari Mohan Ganguli | 0 | 0.27 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 6 | *克里希纳·德瓦伊帕亚纳·维亚萨史诗* 第3卷 第2部分，由吉萨里·莫汉·甘古利翻译 | 0 | 0.27 |'
- en: '| 7 | *The Vedanta-Sutras, with commentary* bySankaracarya | 0 | 0.06 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 7 | *吠檀多经注释* 由桑卡拉查里亚编著 | 0 | 0.06 |'
- en: '| 8 | *The King James Bible* | 0.02 | 0.59 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 8 | *钦定版圣经* | 0.02 | 0.59 |'
- en: '| 9 | *Paradise Regained*, by John Milton | 0.02 | 0.45 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 9 | *失乐园*，由约翰·弥尔顿编著 | 0.02 | 0.45 |'
- en: '| 10 | *Imitation of Christ*, by Thomas A Kempis | 0.01 | 0.69 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 10 | *基督的模仿*，由托马斯·阿·肯皮斯编著 | 0.01 | 0.69 |'
- en: '| 11 | *The Koran*, as translated by Rodwell | 0.01 | 1.72 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 11 | *可兰经*，由罗德威尔翻译 | 0.01 | 1.72 |'
- en: '| 12 | The Adventures of Tom Sawyer, complete, byMark Twain (Samuel Clemens)
    | 0.05 | 0.01 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 12 | *汤姆·索亚历险记* 完整版，马克·吐温（塞缪尔·克莱门斯）编著 | 0.05 | 0.01 |'
- en: '| 13 | *The Adventures of Huckleberry Finn*, complete,by Mark Twain (Samuel
    Clemens) | 0.08 | 0 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 13 | *哈克贝里·费恩历险记* 完整版，由马克·吐温（塞缪尔·克莱门斯）编著 | 0.08 | 0 |'
- en: '| 14 | *Great Expectations*, by Charles Dickens | 0.04 | 0.01 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 14 | *远大前程*，由查尔斯·狄更斯编著 | 0.04 | 0.01 |'
- en: '| 15 | *The Picture of Dorian Gray*, by Oscar Wilde | 0.03 | 0.03 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 15 | *道林·格雷的画像*，由奥斯卡·王尔德编著 | 0.03 | 0.03 |'
- en: '| 16 | *The Adventures of Sherlock Holmes*, by Arthur Conan Doyle | 0.04 |
    0.03 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 16 | *福尔摩斯的冒险*，由阿瑟·柯南·道尔编著 | 0.04 | 0.03 |'
- en: '| 17 | *Metamorphosi**s*, by Franz KafkaTranslated by David Wyllie | 0.06 |
    0.03 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 17 | *变形记*，由弗朗茨·卡夫卡，戴维·威利翻译 | 0.06 | 0.03 |'
- en: We would like to cluster this dataset, based on the chosen frequency counts
    of the words, into groups according to their semantic context.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望根据所选的单词频率，将该数据集按照其语义上下文聚类成不同的组。
- en: Analysis
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析
- en: 'First, we will perform rescaling, since the highest frequency count of the
    word *money* is 0.08 percent, whereas the highest frequency count of the word
    "god(s)" is 1.72%. So, we will divide the frequency count of money by 0.08, and
    the frequency count of god(s) by 1.72, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将进行重缩放，因为单词 *money* 的最高频率为 0.08%，而单词 “god(s)” 的最高频率为 1.72%。因此，我们将 money
    的频率除以 0.08，god(s) 的频率除以 1.72，计算结果如下：
- en: '| **Book number** | **Money scaled** | **God(s) scaled** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **书籍编号** | **货币重缩放** | **神明重缩放** |'
- en: '| 1 | 0 | 0.0406976744 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0.0406976744 |'
- en: '| 2 | 0 | 0.0988372093 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0 | 0.0988372093 |'
- en: '| 3 | 0.125 | 0.0581395349 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0.125 | 0.0581395349 |'
- en: '| 4 | 0 | 0.1860465116 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0 | 0.1860465116 |'
- en: '| 5 | 0 | 0.0348837209 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0 | 0.0348837209 |'
- en: '| 6 | 0 | 0.1569767442 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0 | 0.1569767442 |'
- en: '| 7 | 0 | 0.0348837209 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 0 | 0.0348837209 |'
- en: '| 8 | 0.25 | 0.3430232558 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 0.25 | 0.3430232558 |'
- en: '| 9 | 0.25 | 0.261627907 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 0.25 | 0.261627907 |'
- en: '| 10 | 0.125 | 0.4011627907 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 0.125 | 0.4011627907 |'
- en: '| 11 | 0.125 | 1 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 0.125 | 1 |'
- en: '| 12 | 0.625 | 0.0058139535 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 0.625 | 0.0058139535 |'
- en: '| 13 | 1 | 0 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 1 | 0 |'
- en: '| 14 | 0.5 | 0.0058139535 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 0.5 | 0.0058139535 |'
- en: '| 15 | 0.375 | 0.0174418605 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 0.375 | 0.0174418605 |'
- en: '| 16 | 0.5 | 0.0174418605 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 0.5 | 0.0174418605 |'
- en: '| 17 | 0.75 | 0.0174418605 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 0.75 | 0.0174418605 |'
- en: Now that we have rescaled the data, let's apply the *k*-means clustering algorithm
    by trying to divide the data into a different amount of clusters.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对数据进行了重缩放，接下来我们通过尝试将数据划分为不同数量的聚类，应用 *k*-均值聚类算法。
- en: '**Input**:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**：'
- en: '[PRE9]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Output for two clusters**:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**两个聚类的输出**：'
- en: '[PRE10]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/42911ca1-e009-4853-a961-b7eda68a1a91.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42911ca1-e009-4853-a961-b7eda68a1a91.png)'
- en: We can observe that clustering into two clusters divides books into religious
    ones, which are the ones in the blue cluster, and non-religious ones, which are
    the ones in the red cluster. Let's try to cluster the books into three clusters
    to observe how the algorithm will divide up the data.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到，将数据聚类成两个类别时，书籍被划分为宗教书籍（蓝色聚类）和非宗教书籍（红色聚类）。现在我们尝试将书籍分成三个聚类，看看算法是如何划分数据的。
- en: '**Output for three clusters**:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**三个聚类的输出**：'
- en: '[PRE11]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/baabeb91-1761-4629-b5d2-02c942e15b85.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/baabeb91-1761-4629-b5d2-02c942e15b85.png)'
- en: This time, the algorithm separated The Koran, from the religious books, into
    a green cluster. This is because, in fact, the word *god* is the fifth most commonly
    occurring word in The Koran. The clustering here happens to divide the books according
    to the writing style they were written in. Clustering into four clusters separates
    one book, which has a relatively high frequency of the word *money*, from the
    red cluster of non-religious books into a separate cluster. Now let's look at
    clustering into five clusters.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，算法将《可兰经》从宗教书籍中分离出来，单独放入一个绿色聚类。这是因为事实上，*god*（上帝）一词是《可兰经》中第五大高频词。这里的聚类恰好是根据书籍的写作风格将其划分的。四个聚类的结果将一本高频出现
    *money*（金钱）一词的书从红色的非宗教书籍聚类中分离出来，单独成类。现在我们来看一下五个聚类的情况。
- en: '**Output for five clusters**:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**五个聚类的输出**：'
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/ba0f2f79-1c06-45b9-97fa-73b1a7e1ff2b.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba0f2f79-1c06-45b9-97fa-73b1a7e1ff2b.png)'
- en: This clustering further divides the blue cluster of the remaining religious
    books into a blue cluster of Hindu books and a gray cluster of Christian books.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这种聚类进一步将蓝色宗教书籍聚类划分为印度教书籍的蓝色聚类和基督教书籍的灰色聚类。
- en: We can use clustering in this way to group items with similar properties and
    then find similar items quickly based on the given example. The granularity of
    the clustering under the parameter *k* determines how similar we can expect the
    items in a group to be. The higher the parameter, the more similar the items in
    the cluster are going to be, albeit in a smaller number.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这种方式使用聚类将具有相似属性的项分组，然后基于给定示例快速找到相似的项。聚类的粒度由参数 *k* 决定，它决定了我们可以期望组内项目之间的相似度。参数越高，聚类中的项目相似度越大，但聚类中的项目数量会减少。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how the clustering of data is very efficient and
    can be used to facilitate the faster classification of new features by classifying
    a feature as belonging to the class that is represented in the cluster of that
    feature. An appropriate number of clusters can be determined through cross-validation,
    by choosing the one that results in the most accurate classification.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了数据聚类的高效性，并且了解了如何通过将特征分类为属于该特征所在聚类的类别，从而加速新特征的分类。通过交叉验证，可以确定一个合适的聚类数量，选择最能提供准确分类结果的聚类数。
- en: Clustering orders data according to its similarity. The more clusters there
    are, the greater the similarity between the features in a cluster, but the fewer
    features in a cluster there are.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类根据数据的相似性对其进行排序。聚类的数量越多，聚类中各特征的相似性越大，但每个聚类中的特征数越少。
- en: We also learned that the *k*-means algorithm is a clustering algorithm that
    tries to cluster features in such a way that the mutual distance of the features
    in a cluster is minimized. To do this, the algorithm computes the centroid of
    each cluster and a feature belongs to the cluster whose centroid is closest to
    it. The algorithm finishes the computation of the clusters as soon as they or
    their centroids no longer change.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，*k*-均值算法是一种聚类算法，它试图以最小化簇内特征之间的互相距离为目标将特征聚集在一起。为了实现这一点，算法计算每个簇的质心，并且一个特征会归属于其质心最近的簇。算法在簇或其质心不再变化时结束计算。
- en: In the next chapter, we will analyze the relationship between dependent variables
    using mathematical regression. Unlike with the classification and clustering algorithms,
    regression analysis will be used to estimate the most probable value of a variable,
    such as weight, distance, or temperature.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用数学回归分析因变量之间的关系。与分类和聚类算法不同，回归分析将用于估算一个变量的最可能值，例如体重、距离或温度。
- en: Problems
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '**Problem 1**: Compute the centroid of the following clusters:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 1**：计算以下簇的质心：'
- en: a) 2, 3, 4
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: a) 2, 3, 4
- en: b) USD 100, USD 400, USD 1,000
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: b) 100 美元，400 美元，1,000 美元
- en: c) (10,20), (40, 60), (0, 40)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: c) (10,20)，(40,60)，(0,40)
- en: d) (USD 200, 40 km), (USD 300, 60 km), (USD 500, 100 km), (USD 250, 200 km)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: d) (200 美元，40 公里)，(300 美元，60 公里)，(500 美元，100 公里)，(250 美元，200 公里)
- en: e) (1,2,4), (0,0,3), (10,20,5), (4,8,2), (5,0,1)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: e) (1,2,4), (0,0,3), (10,20,5), (4,8,2), (5,0,1)
- en: '**Problem 2**: Cluster the following datasets into two, three, and four clusters
    using the *k*-means clustering algorithm:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 2**：使用 *k*-均值聚类算法将以下数据集聚成两个、三个和四个簇：'
- en: a) 0, 2, 5, 4, 8, 10, 12, 11
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: a) 0，2，5，4，8，10，12，11
- en: b) (2,2), (2,5), (10,4), (3,5), (7,3), (5,9), (2,8), (4,10), (7,4), (4,4), (5,8),
    (9,3)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: b) (2,2)，(2,5)，(10,4)，(3,5)，(7,3)，(5,9)，(2,8)，(4,10)，(7,4)，(4,4)，(5,8)，(9,3)
- en: '**Problem 3**: We are given the ages of the couples and the number of children
    they have:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 3**：我们给出了一对夫妇的年龄以及他们的子女数量：'
- en: '| **Couple number** | **Wife''s age** | **Husband''s age** | **Number of children**
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **夫妻编号** | **妻子年龄** | **丈夫年龄** | **子女数量** |'
- en: '| 1 | 48 | 49 | 5 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 48 | 49 | 5 |'
- en: '| 2 | 40 | 43 | 2 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 40 | 43 | 2 |'
- en: '| 3 | 24 | 28 | 1 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 24 | 28 | 1 |'
- en: '| 4 | 49 | 42 | 3 |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 49 | 42 | 3 |'
- en: '| 5 | 32 | 34 | 0 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 32 | 34 | 0 |'
- en: '| 6 | 24 | 27 | 0 |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 24 | 27 | 0 |'
- en: '| 7 | 29 | 32 | 2 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 29 | 32 | 2 |'
- en: '| 8 | 35 | 35 | 2 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 35 | 35 | 2 |'
- en: '| 9 | 33 | 36 | 1 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 33 | 36 | 1 |'
- en: '| 10 | 42 | 47 | 3 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 42 | 47 | 3 |'
- en: '| 11 | 22 | 27 | 2 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 22 | 27 | 2 |'
- en: '| 12 | 41 | 45 | 4 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 41 | 45 | 4 |'
- en: '| 13 | 39 | 43 | 4 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 39 | 43 | 4 |'
- en: '| 14 | 36 | 38 | 2 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 36 | 38 | 2 |'
- en: '| 15 | 30 | 32 | 1 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 30 | 32 | 1 |'
- en: '| 16 | 36 | 38 | 0 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 36 | 38 | 0 |'
- en: '| 17 | 36 | 39 | 3 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 36 | 39 | 3 |'
- en: '| 18 | 37 | 38 | ? |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 37 | 38 | ? |'
- en: We would like to guess, using clustering, how many children a couple has where
    the age of the husband is 37 and the age of the wife is 38.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想通过聚类来猜测一对夫妻的子女数量，其中丈夫的年龄为 37 岁，妻子的年龄为 38 岁。
- en: Analysis
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析
- en: '**Problem 1**:  a) **![](img/dbe2db56-78ad-4fb8-874e-3b405828a540.png)**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 1**： a) **![](img/dbe2db56-78ad-4fb8-874e-3b405828a540.png)**'
- en: b) ![](img/05c3cee4-8cb6-42a3-a46d-1762b351aedd.png)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: b) **![](img/05c3cee4-8cb6-42a3-a46d-1762b351aedd.png)**
- en: c)  ![](img/e5697e9f-d754-41e6-b0a4-1a9f1fb72978.png)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: c) **![](img/e5697e9f-d754-41e6-b0a4-1a9f1fb72978.png)**
- en: d)**![](img/cc01cdbe-b8d3-4609-ace6-a4054f085f4f.png)**
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: d)**![](img/cc01cdbe-b8d3-4609-ace6-a4054f085f4f.png)**
- en: e) ![](img/135753ed-7971-4a68-998f-e25309588af5.png)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: e) **![](img/135753ed-7971-4a68-998f-e25309588af5.png)**
- en: '**Problem 2**: a) We add a second coordinate and set it to `0` for all the
    features. This way, the distance between the features does not change and we can
    use the clustering algorithm we implemented earlier in this chapter.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 2**： a) 我们添加第二个坐标，并将其设置为所有特征的 `0`。这样，特征之间的距离保持不变，我们可以使用本章早些时候实现的聚类算法。'
- en: '**Input**:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**：'
- en: '[PRE13]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**For two clusters**:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于两个簇**：'
- en: '[PRE14]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**For three clusters**:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于三个簇**：'
- en: '[PRE15]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**For four clusters**:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于四个簇**：'
- en: '[PRE16]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: b) We use the implemented algorithm again.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: b) 我们再次使用实现的算法。
- en: '**Input**:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**：'
- en: '[PRE17]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Output for two clusters**:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**两个簇的输出**：'
- en: '[PRE18]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Output for three clusters**:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**三个簇的输出**：'
- en: '[PRE19]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Output for four clusters**:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**四个簇的输出**：'
- en: '[PRE20]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Problem 3**: We are given the ages of 17 couples and the number of children
    they have, and would like to find out how many children the 18^(th) couple has.
    We will use the first 14 couples as training data, and the next 3 couples for
    cross-validation to determine the number of clusters *k* that we will use to find
    out how many children the 18^(th) couple is expected to have.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 3**：我们给出了17对夫妇的年龄和他们的孩子数量，并希望找出第18对夫妇的孩子数量。我们将使用前14对夫妇的数据作为训练数据，接下来的3对夫妇用于交叉验证，以确定我们将用来估算第18对夫妇孩子数量的聚类数*k*。'
- en: After clustering, we will say that a couple is likely to have roughly the number
    of children that is the average in that cluster. Using cross-validation, we will
    choose the number of clusters that will minimize the difference between the actual
    and predicted number of children. We will capture this difference for all the
    items in the cluster cumulatively as the square root of the squares of the differences
    between the number of children of each couple. This will minimize the variance
    of the random variable in relation to the predicted number of children for the
    18^(th) couple.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类后，我们会说，一对夫妇很可能会拥有该聚类中的平均孩子数量。通过交叉验证，我们将选择能够最小化实际孩子数量与预测孩子数量之间差异的聚类数。我们将通过聚类内所有项的差异的平方和的平方根来累计捕捉这种差异。这将最小化随机变量与第18对夫妇预测的孩子数量之间的方差。
- en: We will perform clustering into two, three, four, and five clusters.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行两个、三个、四个和五个聚类的聚类分析。
- en: '**Input**:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**：'
- en: '[PRE21]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Output for two clusters**:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**两个聚类的输出**：'
- en: 'A couple listed for a cluster is of the form `(couple_number,(wife_age,husband_age))`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的每对夫妇对应一个聚类的形式是`(couple_number,(wife_age,husband_age))`：
- en: '[PRE22]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We would like to determine the expected number of children for the 15^(th)
    couple *(30,32)*, that is, where the wife is 30 years old and the husband is 32
    years old. *(30,32)* is in cluster 1\. The couples in cluster 1 are as follows:
    *(24.0, 28.0)*, *(32.0, 34.0)*, *(24.0, 27.0)*, *(29.0, 32.0)*, *(35.0, 35.0)*,
    *(33.0, 36.0)*, *(22.0, 27.0)*, and *(30.0, 32.0)*. Of these, and the first 14
    couples used for data purposes, the remaining couples are: *(24.0, 28.0)*, *(32.0,
    34.0)*, *(24.0, 27.0)*, *(29.0, 32.0)*, *(35.0, 35.0)*, *(33.0, 36.0)*, and *(22.0,
    27.0)*. The average number of children for these couples is *est15=8/7~1.14*.
    This is the estimated number of children for the 15^(th) couple, based on the
    data from the first 14 couples.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望确定第15对夫妇*(30,32)*的预计孩子数量，即妻子30岁，丈夫32岁。*(30,32)*属于聚类1。聚类1中的夫妇如下：*(24.0, 28.0)*，*(32.0,
    34.0)*，*(24.0, 27.0)*，*(29.0, 32.0)*，*(35.0, 35.0)*，*(33.0, 36.0)*，*(22.0, 27.0)*，以及*(30.0,
    32.0)*。其中，包括前14对夫妇的数据，剩余的夫妇是：*(24.0, 28.0)*，*(32.0, 34.0)*，*(24.0, 27.0)*，*(29.0,
    32.0)*，*(35.0, 35.0)*，*(33.0, 36.0)*，以及*(22.0, 27.0)*。这些夫妇的孩子数量平均值是*est15=8/7~1.14*。这是基于前14对夫妇数据估算的第15对夫妇的孩子数量。
- en: The estimated number of children for the 16^(th) couple is *est16=23/7~3.29*.
    The estimated number of children for the 17^(th) couple is also *est17=23/7~3.29 *since
    both the 16^(th) and 17^(th) couples belong to the same cluster.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 第16对夫妇的估计孩子数量是*est16=23/7~3.29*。第17对夫妇的估计孩子数量也是*est17=23/7~3.29*，因为第16对和第17对夫妇属于同一聚类。
- en: 'Now we will calculate the *E2* error (two for two clusters) between the estimated
    number of children (for example, denoted *est15* for the 15^(th) couple) and the
    actual number of children (for example, denoted *act15* for the 15^(th) couple)
    as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将计算*E2*误差（对于两个聚类来说是两个）在估计孩子数量（例如，第15对夫妇的孩子数量用*est15*表示）与实际孩子数量（例如，第15对夫妇的孩子数量用*act15*表示）之间的差异，如下所示：
- en: '![](img/002cecdc-82e4-40f7-9781-a478866c51c4.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/002cecdc-82e4-40f7-9781-a478866c51c4.png)'
- en: '![](img/b2ca6e56-f0de-42e9-9227-cb25a7fd8498.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2ca6e56-f0de-42e9-9227-cb25a7fd8498.png)'
- en: Now that we have calculated the *E2* error, we will calculate the errors in
    terms of the estimation with the other clusters. We will choose the number of
    clusters containing the fewest errors to estimate the number of children for the
    18^(th) couple.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计算了*E2*误差，我们将根据其他聚类来计算估算误差。我们将选择包含最少误差的聚类数来估算第18对夫妇的孩子数量。
- en: '**Output for three clusters**:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**三个聚类的输出**：'
- en: '[PRE23]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, the 15^(th) couple is in cluster 1, the 16^(th) couple is in cluster 2,
    and the 17^(th) couple is in cluster 2\. So the estimated number of children for
    each couple is *5/4=1.25*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第15对夫妇在聚类1，第16对夫妇在聚类2，第17对夫妇在聚类2。因此，每对夫妇的估计孩子数量是*5/4=1.25*。
- en: 'The *E3* error of the estimation is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 估算的 *E3* 错误如下：
- en: '![](img/72664168-009d-4b4f-a5e4-833789796640.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72664168-009d-4b4f-a5e4-833789796640.png)'
- en: '**Output for four clusters**:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**四个聚类的输出**：'
- en: '[PRE24]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The 15^(th) couple is in cluster 3, the 16^(th) is in cluster 2, and the 17^(th) is
    in cluster 2\. So, the estimated number of children for the 15^(th) couple is
    *5/4=1.25*. The estimated number of children for the 16^(th) and 17^(th) couples
    is 8/3=2.67.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第 15^(th) 对夫妻位于聚类 3，第 16^(th) 对夫妻位于聚类 2，第 17^(th) 对夫妻也位于聚类 2。因此，第 15^(th) 对夫妻的估计子女数为
    *5/4=1.25*。第 16^(th) 和第 17^(th) 对夫妻的估计子女数为 8/3=2.67。
- en: 'The *E4* error of the estimation is as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 估算的 *E4* 错误如下：
- en: '![](img/f995b78a-8035-4b00-91cc-f4593b3795c8.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f995b78a-8035-4b00-91cc-f4593b3795c8.png)'
- en: '**Output for five clusters**:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**五个聚类的输出**：'
- en: '[PRE25]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The 15^(th) couple is in cluster 3, the 16^(th) is in cluster 2, and the 17^(th) is
    in cluster 2\. So, the estimated number of children for the 15^(th) couple is
    1\. The estimated number of children for the 16^(th) and 17^(th) couples is 5/3=1.67.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 第 15^(th) 对夫妻位于聚类 3，第 16^(th) 对夫妻位于聚类 2，第 17^(th) 对夫妻也位于聚类 2。因此，第 15^(th) 对夫妻的估计子女数为
    1。第 16^(th) 和第 17^(th) 对夫妻的估计子女数为 5/3=1.67。
- en: 'The *E5* error of the estimation is as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 估算的 *E5* 错误如下：
- en: '![](img/9781e3d2-892b-419f-8121-85ece972c9e4.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9781e3d2-892b-419f-8121-85ece972c9e4.png)'
- en: '**Using cross-validation to determine the outcome**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用交叉验证来确定结果**'
- en: 'We used 14 couples as training data for the estimation and three other couples
    for cross-validation to find the best parameter of *k* clusters among the values
    2, 3, 4, and 5\. We could try to cluster into more clusters, but since we have
    such a relatively small amount of data, it should be sufficient to cluster into
    five clusters at most. Let''s summarize the errors arising from the estimation:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 14 对夫妻作为估算的训练数据，并使用另外三对夫妻进行交叉验证，以找出在 2、3、4 和 5 个聚类值之间的最佳 *k* 聚类参数。我们可以尝试聚类为更多的聚类，但由于数据量相对较小，最多聚类为五个聚类就足够了。让我们总结一下估算过程中产生的错误：
- en: '| **Number of clusters** | **Error rate** |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| **聚类数** | **错误率** |'
- en: '| 2 | 3.3 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3.3 |'
- en: '| 3 | 2.17 |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2.17 |'
- en: '| 4 | 2.7 |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2.7 |'
- en: '| 5 | 2.13 |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2.13 |'
- en: The error rate is lowest for **3** and **5** clusters. The fact that the error
    rate goes up for **4** clusters and then down again for **5** clusters could indicate
    that we don't have enough data to make a good estimate. A natural expectation
    would be that there are not local maxims of errors for values of *k* greater than
    2\. Moreover, the difference between the error rate for clustering with **3**
    and **5** clusters is very small, and one cluster out of **5** is smaller than
    one cluster out of **3**. For this reason, we choose 3 clusters over 5 to estimate
    the number of children for the 18^(th) couple.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**3** 和 **5** 个聚类的错误率最低。错误率在 **4** 个聚类时上升，随后在 **5** 个聚类时下降，这可能表明我们没有足够的数据来做出准确的估计。一个自然的预期是，对于
    *k* 大于 2 的值，不应存在局部最大错误值。此外，**3** 个聚类和 **5** 个聚类的错误率差异非常小，而且 **5** 个聚类中的单个聚类要比
    **3** 个聚类中的单个聚类小。因此，我们选择 **3** 个聚类而非 **5** 个聚类来估算第 18^(th) 对夫妻的子女数量。'
- en: When clustering into three clusters, the 18^(th) couple is in cluster **2**.
    Therefore, the estimated number of children for the 18^(th) couple is 1.25.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当聚类为三个时，第 18^(th) 对夫妻位于聚类 **2**。因此，第 18^(th) 对夫妻的估计子女数为 1.25。
