- en: Chapter 5. High-performance Computing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 高性能计算
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Accelerating pure Python code with Numba and Just-In-Time compilation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Numba 和即时编译加速纯 Python 代码
- en: Accelerating array computations with Numexpr
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Numexpr 加速数组计算
- en: Wrapping a C library in Python with ctypes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ctypes 将 C 库包装为 Python
- en: Accelerating Python code with Cython
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cython 加速 Python 代码
- en: Optimizing Cython code by writing less Python and more C
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编写更少的 Python 代码和更多的 C 代码来优化 Cython 代码
- en: Releasing the GIL to take advantage of multi-core processors with Cython and
    OpenMP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cython 和 OpenMP 释放 GIL，利用多核处理器
- en: Writing massively parallel code for NVIDIA graphics cards (GPUs) with CUDA
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CUDA 为 NVIDIA 图形卡（GPU）编写大规模并行代码
- en: Writing massively parallel code for heterogeneous platforms with OpenCL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenCL 为异构平台编写大规模并行代码
- en: Distributing Python code across multiple cores with IPython
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IPython 将 Python 代码分配到多个核心
- en: Interacting with asynchronous parallel tasks in IPython
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 IPython 中与异步并行任务进行交互
- en: Parallelizing code with MPI in IPython
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 IPython 中使用 MPI 并行化代码
- en: Trying the Julia language in the notebook
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 notebook 中尝试 Julia 语言
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The previous chapter presented techniques for code optimization. Sometimes,
    these methods are not sufficient, and we need to resort to advanced high-performance
    computing techniques.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了代码优化的技术。有时，这些方法不足以满足需求，我们需要诉诸于更高级的高性能计算技术。
- en: 'In this chapter, we will see three broad, but not mutually exclusive categories
    of methods:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到三种广泛的方法类别，它们并不互相排斥：
- en: '**Just-In-Time compilation** (**JIT**) of Python code'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即时编译**（**JIT**）Python 代码'
- en: Resorting to a lower-level language, such as C, from Python
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Python 转向低级语言，如 C
- en: Dispatching tasks across multiple computing units using parallel computing
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并行计算将任务分配到多个计算单元
- en: With Just-In-Time compilation, Python code is dynamically compiled into a lower-level
    language. Compilation occurs at runtime rather than ahead of execution. The translated
    code runs faster since it is compiled rather that interpreted. JIT compilation
    is a popular technique as it can lead to fast *and* high-level languages, whereas
    these two characteristics used to be mutually exclusive in general.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过即时编译，Python 代码会动态编译成低级语言。编译发生在运行时，而不是执行之前。由于代码是编译的而非解释的，因此运行速度更快。JIT 编译是一种流行的技术，因为它能够同时实现快速和高级语言，而这两个特点在过去通常是互相排斥的。
- en: JIT compilation techniques are implemented in packages such as **Numba**, **Numexpr**,
    **Blaze**, and others. In this chapter, we will cover the first two packages.
    Blaze is a promising project but it is still in its infancy at the time of writing
    this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JIT 编译技术已经在如 **Numba**、**Numexpr**、**Blaze** 等包中实现。在本章中，我们将介绍前两个包。Blaze 是一个有前景的项目，但在写本书时，它仍处于起步阶段。
- en: We will also introduce a new high-level language, **Julia**, which uses JIT
    compilation to achieve high performance. This language can be used effectively
    in the IPython notebook, thanks to the **IJulia** package.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍一种新的高级语言，**Julia**，它使用 JIT 编译实现高性能。这种语言可以在 IPython notebook 中有效使用，得益于
    **IJulia** 包。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**PyPy** ([http://pypy.org](http://pypy.org)), successor of Psyco, is another
    related project. This alternative implementation of Python (the reference implementation
    being CPython) integrates a JIT compiler. Thus, it is typically much faster than
    CPython. However, at the time of writing this book, PyPy does not fully support
    NumPy yet. Additionally, PyPy and SciPy tend to form distinct communities.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyPy** ([http://pypy.org](http://pypy.org))，Psyco 的继任者，是另一个相关的项目。这个 Python
    的替代实现（参考实现是 CPython）集成了 JIT 编译器。因此，它通常比 CPython 快得多。然而，在本书写作时，PyPy 还不完全支持 NumPy。此外，PyPy
    和 SciPy 往往形成各自独立的社区。'
- en: Resorting to a lower-level language such as C is another interesting method.
    Popular libraries include **ctypes**, **SWIG**, or **Cython**. Using ctypes requires
    writing C code and having access to a C compiler, or using a compiled C library.
    By contrast, Cython lets us write code in a superset of Python, which is translated
    to C with various performance results. Unfortunately, it is not always easy to
    write efficient Cython code. In this chapter, we will cover ctypes and Cython,
    and we will see how to achieve interesting speedups on complex examples.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 求助于如 C 这样的低级语言是另一种有趣的方法。流行的库包括**ctypes**、**SWIG** 或 **Cython**。使用 ctypes 需要编写
    C 代码并能够访问 C 编译器，或者使用编译过的 C 库。相比之下，Cython 允许我们在 Python 的超集语言中编写代码，然后将其转译为 C，并带来不同的性能结果。不幸的是，编写高效的
    Cython 代码并不总是容易的。在本章中，我们将介绍 ctypes 和 Cython，并展示如何在复杂示例中实现显著的加速。
- en: 'Finally, we will cover two classes of parallel computing techniques: using
    multiple CPU cores with IPython and using massively parallel architectures such
    as **Graphics Processing Units** (**GPUs**).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍两类并行计算技术：使用 IPython 利用多个 CPU 核心和使用大规模并行架构，如**图形处理单元**（**GPU**）。
- en: 'Here are a few references:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: A blog post on PyPy and NumPy by Travis Oliphant available at [http://technicaldiscovery.blogspot.com/2011/10/thoughts-on-porting-numpy-to-pypy.html](http://technicaldiscovery.blogspot.com/2011/10/thoughts-on-porting-numpy-to-pypy.html)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Travis Oliphant 关于 PyPy 和 NumPy 的博客文章，内容可以在[http://technicaldiscovery.blogspot.com/2011/10/thoughts-on-porting-numpy-to-pypy.html](http://technicaldiscovery.blogspot.com/2011/10/thoughts-on-porting-numpy-to-pypy.html)找到
- en: Interfacing Python with C, a tutorial in the scikit lectures notes available
    at [http://scipy-lectures.github.io/advanced/interfacing_with_c/interfacing_with_c.html](http://scipy-lectures.github.io/advanced/interfacing_with_c/interfacing_with_c.html)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 C 语言接口的 Python教程，详细内容请参考[http://scipy-lectures.github.io/advanced/interfacing_with_c/interfacing_with_c.html](http://scipy-lectures.github.io/advanced/interfacing_with_c/interfacing_with_c.html)
- en: CPython and concurrent programming
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPython 和并发编程
- en: Python is sometimes criticized for its poor native support of multi-core processors.
    Let's explain why.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有时因为对多核处理器的本地支持较差而受到批评。让我们来解释一下原因。
- en: 'The mainstream implementation of the Python language is **CPython**, written
    in C. CPython integrates a mechanism called the **Global Interpreter Lock** (**GIL**).
    As mentioned at [http://wiki.python.org/moin/GlobalInterpreterLock](http://wiki.python.org/moin/GlobalInterpreterLock):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python 语言的主流实现是用 C 编写的**CPython**。CPython 集成了一种机制，称为**全局解释器锁**（**GIL**）。正如在[http://wiki.python.org/moin/GlobalInterpreterLock](http://wiki.python.org/moin/GlobalInterpreterLock)中所提到的：
- en: '*The GIL facilitates memory management by preventing multiple native threads
    from executing Python bytecodes at once.*'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*GIL 通过防止多个本地线程同时执行 Python 字节码来促进内存管理。*'
- en: In other words, by disabling concurrent threads within one Python process, the
    GIL considerably simplifies the memory management system. Memory management is
    therefore not thread-safe in CPython.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，通过禁用一个 Python 进程中的并发线程，GIL 大大简化了内存管理系统。因此，内存管理在 CPython 中并不是线程安全的。
- en: An important implication is that with CPython, a pure Python program cannot
    be easily executed in parallel over multiple cores. This is an important issue
    as modern processors contain more and more cores.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的影响是，使用 CPython 时，一个纯 Python 程序无法轻松地在多个核心上并行执行。这是一个重要问题，因为现代处理器的核心数量越来越多。
- en: What possible solutions do we have in order to take advantage of multi-core
    processors?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有什么可能的解决方案，以便利用多核处理器？
- en: Removing the GIL in CPython. This solution has been tried but has never made
    it into CPython. It would bring too much complexity in the implementation of CPython,
    and it would degrade the performance of single-threaded programs.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除 CPython 中的 GIL。这个解决方案曾经被尝试过，但从未被纳入 CPython。这会在 CPython 的实现中带来太多复杂性，并且会降低单线程程序的性能。
- en: Using multiple processes instead of multiple threads. This is a popular solution;
    it can be done with the native **multiprocessing** module or with IPython. We
    will cover the latter in this chapter.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个进程而非多个线程。这是一个流行的解决方案；可以使用原生的**multiprocessing**模块，或者使用 IPython。在本章中，我们将介绍后者。
- en: Rewriting specific portions of your code in Cython and replacing all Python
    variables with C variables. This allows you to remove the GIL temporarily in a
    loop, thereby enabling use of multi-core processors. We will cover this solution
    in the *Releasing the GIL to take advantage of multi-core processors with Cython
    and OpenMP* recipe.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Cython重写代码的特定部分，并用C语言变量替换所有Python变量。这样可以暂时移除GIL，使得在循环中能够使用多核处理器。我们将在*释放GIL以利用Cython和OpenMP实现多核处理器*的配方中讨论这一解决方案。
- en: Implementing a specific portion of your code in a language that offers better
    support for multi-core processors and calling it from your Python program.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用一种对多核处理器有更好支持的语言实现代码的特定部分，并从你的Python程序中调用它。
- en: Making your code use the NumPy functions that benefit from multi-core processors,
    such as `numpy.dot()`. NumPy needs to be compiled with BLAS/LAPACK/ATLAS/MKL.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的代码使用可以从多核处理器中受益的NumPy函数，如`numpy.dot()`。NumPy需要用BLAS/LAPACK/ATLAS/MKL进行编译。
- en: A must-read reference on the GIL can be found at [http://www.dabeaz.com/GIL/](http://www.dabeaz.com/GIL/).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关于GIL的必读参考资料可以在[http://www.dabeaz.com/GIL/](http://www.dabeaz.com/GIL/)找到。
- en: Compiler-related installation instructions
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与编译器相关的安装说明
- en: In this section, we will give a few instructions for using compilers with Python.
    Use-cases include using ctypes, using Cython, and building C extensions for Python.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提供一些使用编译器与Python配合的说明。使用场景包括使用ctypes、使用Cython以及构建Python的C扩展。
- en: Linux
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux
- en: On Linux, you can install the **GCC** (**GNU Compiler Collection**) compiler.
    On Ubuntu or Debian, you can install GCC with the `sudo apt-get install build-essential`
    command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，你可以安装**GCC**（**GNU编译器集合**）。在Ubuntu或Debian上，你可以通过命令`sudo apt-get install
    build-essential`安装GCC。
- en: Mac OS X
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mac OS X
- en: On Mac OS X, you can install Apple XCode. Starting with XCode 4.3, you must
    manually install command-line tools from XCode's menu through **Preferences**
    | **Downloads** | **Command Line Tools**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS X上，你可以安装Apple XCode。从XCode 4.3开始，你必须通过XCode菜单中的**Preferences** | **Downloads**
    | **Command Line Tools**手动安装命令行工具。
- en: Windows
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows
- en: 'On Windows, using compilers with Python is notoriously tedious. It is generally
    difficult to find all the necessary instructions online. We detail these instructions
    here (you''ll also find them on the book''s GitHub repository):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，使用编译器与Python配合使用是著名的麻烦。通常很难在线找到所有必要的说明。我们在这里详细说明这些说明（你也可以在本书的GitHub仓库中找到它们）：
- en: 'The instructions differ according to whether you use a 32-bit or 64-bit version
    of Python, and whether you use Python 2.x or Python 3.x. To quickly find out this
    information in a Python terminal, type the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 说明根据你使用的是32位还是64位版本的Python，以及你使用的是Python 2.x还是Python 3.x有所不同。要快速了解这些信息，你可以在Python终端中键入以下命令：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Python 32-bit
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Python 32位
- en: First, you need to install a C compiler. With Python 32-bit, you can download
    and install MinGW from [http://www.mingw.org](http://www.mingw.org), which is
    an open source distribution of GCC.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要安装一个C编译器。对于Python 32位，你可以从[http://www.mingw.org](http://www.mingw.org)下载并安装MinGW，它是GCC的开源发行版。
- en: Depending on your version of the `distutils` library, you may need to manually
    fix a bug in its source code. Open `C:\Python27\Lib\distutils\cygwinccompiler.py`
    in a text editor (or a similar path depending on your specific configuration),
    and replace all occurrences of `-mno-cygwin` with an empty string.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你所使用的`distutils`库的版本，你可能需要手动修复其源代码中的一个bug。用文本编辑器打开`C:\Python27\Lib\distutils\cygwinccompiler.py`（或者根据你的具体配置路径类似的文件），并将所有`-mno-cygwin`的出现位置替换为空字符串。
- en: 'Open or create a text file named `distutils.cfg` in `C:\Python27\Lib\distutils\`
    and add the following lines:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开或创建一个名为`distutils.cfg`的文本文件，路径为`C:\Python27\Lib\distutils\`，并添加以下行：
- en: '[PRE1]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Python 64-bit
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Python 64位
- en: With Python 2.x, you need Visual Studio 2008 Express. With Python 3.x, you need
    Visual Studio 2010 Express.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Python 2.x，你需要Visual Studio 2008 Express。对于Python 3.x，你需要Visual Studio 2010
    Express。
- en: 'You also need the Microsoft Windows SDK (2008 or 2010 according to your Python
    version):'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要微软Windows SDK（根据你的Python版本选择2008或2010版本）：
- en: '**Python 2.x**: Microsoft Windows SDK for Windows 7 and .NET Framework 3.5
    available at [http://www.microsoft.com/en-us/download/details.aspx?id=3138](http://www.microsoft.com/en-us/download/details.aspx?id=3138)'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python 2.x**：可在[http://www.microsoft.com/en-us/download/details.aspx?id=3138](http://www.microsoft.com/en-us/download/details.aspx?id=3138)下载Windows
    7和.NET Framework 3.5的微软Windows SDK。'
- en: '**Python 3.x**: Microsoft Windows SDK for Windows 7 and .NET Framework 4 available
    at [http://www.microsoft.com/en-us/download/details.aspx?id=8279](http://www.microsoft.com/en-us/download/details.aspx?id=8279)'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python 3.x**：适用于Windows 7和.NET Framework 4的Microsoft Windows SDK，下载地址：[http://www.microsoft.com/en-us/download/details.aspx?id=8279](http://www.microsoft.com/en-us/download/details.aspx?id=8279)'
- en: Make sure that the path to the folder containing `cl.exe` is in the system's
    `PATH` environment variable. This path should look like `C:\Program Files (x86)\Microsoft
    Visual Studio 9.0\VC\bin\amd64` (using Visual Studio 2008's C compiler available
    with the Microsoft Windows SDK for Windows 7 and .NET Framework 3.5).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保包含`cl.exe`的文件夹路径在系统的`PATH`环境变量中。该路径应类似于`C:\Program Files (x86)\Microsoft Visual
    Studio 9.0\VC\bin\amd64`（使用适用于Windows 7和.NET Framework 3.5的Microsoft Windows SDK中的Visual
    Studio 2008 C编译器）。
- en: 'You need to execute a few commands in Windows'' command-line terminal every
    time you want to use the compiler with Python (for example, before typing `ipython
    notebook`):'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次你想要在Python中使用编译器时（例如，在输入`ipython notebook`之前），需要在Windows的命令行终端中执行几个命令：
- en: '[PRE2]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: DLL hell
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DLL地狱
- en: When using compiled packages, particularly those obtained on Chris Gohlke's
    webpage at [http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/),
    you may get obscure DLL-related errors. To fix those problems, you can open the
    spurious DLLs in Dependency Walker available at [http://www.dependencywalker.com](http://www.dependencywalker.com).
    This program can tell you that a DLL is missing. You can search for it in your
    computer and add its location to the `PATH` environment variable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编译包时，特别是那些在Chris Gohlke的网页上获取的包（[http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/)），可能会遇到一些晦涩的DLL相关错误。要解决这些问题，你可以使用Dependency
    Walker打开这些无效的DLL，Dependency Walker的下载地址为[http://www.dependencywalker.com](http://www.dependencywalker.com)。该程序可以告诉你缺少了哪个DLL文件，你可以在电脑上搜索它并将其位置添加到`PATH`环境变量中。
- en: References
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Here are a few references:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: Installing Cython on Windows, at [http://wiki.cython.org/InstallingOnWindows](http://wiki.cython.org/InstallingOnWindows)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上安装Cython，参考[http://wiki.cython.org/InstallingOnWindows](http://wiki.cython.org/InstallingOnWindows)
- en: Cython on Windows 64-bit, at [https://github.com/cython/cython/wiki/64BitCythonExtensionsOnWindows](https://github.com/cython/cython/wiki/64BitCythonExtensionsOnWindows)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows 64位上使用Cython，参考[https://github.com/cython/cython/wiki/64BitCythonExtensionsOnWindows](https://github.com/cython/cython/wiki/64BitCythonExtensionsOnWindows)
- en: Building Python wheels for Windows, at [http://cowboyprogrammer.org/building-python-wheels-for-windows/](http://cowboyprogrammer.org/building-python-wheels-for-windows/)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Windows构建Python wheel，参考[http://cowboyprogrammer.org/building-python-wheels-for-windows/](http://cowboyprogrammer.org/building-python-wheels-for-windows/)
- en: Accelerating pure Python code with Numba and just-in-time compilation
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Numba和即时编译加速纯Python代码
- en: Numba ([http://numba.pydata.org](http://numba.pydata.org)) is a package created
    by Continuum Analytics ([http://www.continuum.io](http://www.continuum.io)). At
    the time of writing, Numba is still a young and relatively experimental package,
    but its technology is promising. Numba takes pure Python code and translates it
    automatically (just-in-time) into optimized machine code. In practice, this means
    that we can write a non-vectorized function in pure Python, using `for` loops,
    and have this function vectorized automatically by using a single decorator. Performance
    speedups when compared to pure Python code can reach several orders of magnitude
    and may even outmatch manually-vectorized NumPy code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Numba（[http://numba.pydata.org](http://numba.pydata.org)）是由Continuum Analytics（[http://www.continuum.io](http://www.continuum.io)）创建的一个包。截止本文撰写时，Numba仍然是一个较新的、相对实验性的包，但其技术前景可期。Numba会自动（即时）将纯Python代码翻译成优化后的机器码。实际上，这意味着我们可以在纯Python中编写一个非矢量化的函数，使用`for`循环，并通过使用一个装饰器自动将该函数矢量化。与纯Python代码相比，性能的提升可以达到几个数量级，甚至可能超越手动矢量化的NumPy代码。
- en: In this section, we will show how to accelerate pure Python code generating
    the Mandelbrot fractal.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何加速生成曼德尔布罗特分形的纯Python代码。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The easiest way to install Numba is to use the Anaconda distribution (also maintained
    by Continuum Analytics), and type in a terminal `conda install numba`. On Windows,
    an alternative is to download a binary installer from Chris Gohlke's webpage at
    [http://www.lfd.uci.edu/~gohlke/pythonlibs/#numba](http://www.lfd.uci.edu/~gohlke/pythonlibs/#numba).
    In this case, there are dependencies (Numpy-MKL, LLVMPy, llvmmath, and Meta),
    all available on the same page.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Numba 最简单的方法是使用 Anaconda 发行版（也是 Continuum Analytics 维护的），然后在终端输入`conda install
    numba`。在 Windows 上，另一种选择是从 Chris Gohlke 的网页下载二进制安装程序，网址为[http://www.lfd.uci.edu/~gohlke/pythonlibs/#numba](http://www.lfd.uci.edu/~gohlke/pythonlibs/#numba)。在这种情况下，有一些依赖项（Numpy-MKL、LLVMPy、llvmmath
    和 Meta），它们都可以在同一页面上找到。
- en: How to do it…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Let''s import NumPy and define a few variables:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入 NumPy 并定义几个变量：
- en: '[PRE3]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The following function generates the fractal in pure Python. It accepts an empty
    array `m` as argument.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数使用纯 Python 生成分形。它接受一个空数组 `m` 作为参数。
- en: '[PRE4]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s run the simulation and display the fractal:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行这个模拟并显示分形图：
- en: '[PRE5]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![How to do it…](img/4818OS_05_01.jpg)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现…](img/4818OS_05_01.jpg)'
- en: The Mandelbrot fractal
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 曼德尔布罗特分形
- en: 'Now, we evaluate the time taken by this function:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们评估这个函数所用的时间：
- en: '[PRE6]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s try to accelerate this function using Numba. First, we import the package:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试使用 Numba 加速这个函数。首先，我们导入这个包：
- en: '[PRE7]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we add the `@jit` decorator right above the function definition. Numba
    tries to automatically infer the type of the local variables, but we can also
    specify the types explicitly:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在函数定义上方添加`@jit`装饰器。Numba 会尝试自动推断局部变量的类型，但我们也可以显式地指定类型：
- en: '[PRE8]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function works just like the pure Python version. How much faster is it?
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数与纯 Python 版本的功能完全相同。它到底快了多少呢？
- en: '[PRE9]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Numba version is more than 100 times faster than the pure Python version
    here!
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里 Numba 版本的速度比纯 Python 版本快超过 100 倍！
- en: How it works…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Python bytecode is normally interpreted at runtime by the Python interpreter
    (for example, CPython). By contrast, a Numba function is parsed and translated
    directly to machine code ahead of execution, using a powerful compiler architecture
    named **LLVM** (**Low Level Virtual Machine**). Citing the official documentation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Python 字节码通常在运行时由 Python 解释器（例如 CPython）解释执行。相比之下，Numba 函数会在执行前直接解析并转换为机器代码，使用名为**LLVM**（**低级虚拟机**）的强大编译器架构。引用官方文档：
- en: '*Numba is aware of NumPy arrays as typed memory regions and so can speedup
    code using NumPy arrays. Other, less well-typed code will be translated to Python
    C-API calls effectively removing the "interpreter" but not removing the dynamic
    indirection.*'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Numba 能识别 NumPy 数组作为已类型化的内存区域，因此可以加速使用 NumPy 数组的代码。其他类型不太明确的代码将被转换为 Python
    C-API 调用，从而有效地去除了“解释器”，但并未去除动态间接性。*'
- en: Numba is not able to compile any Python functions. There are also some subtle
    restrictions on the type of local variables. Numba tries to infer the type of
    the function's variables automatically, but it is not always successful. In this
    case, we can specify the types explicitly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 并不是能够编译所有 Python 函数。对于局部变量的类型也有一些微妙的限制。Numba 会尝试自动推断函数变量的类型，但并不总是成功。在这种情况下，我们可以显式地指定类型。
- en: Numba generally gives the most impressive speedups on functions that involve
    tight loops on NumPy arrays (such as in this recipe).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 通常在涉及 NumPy 数组的紧密循环（如本食谱中的示例）时能提供最显著的加速。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Blaze**, another project from Continuum Analytics, is the next generation
    of NumPy. It will offer data structures with much more flexibility than NumPy
    arrays, and it will support out-of-core computations. Together with Numba, Blaze
    will form a highly efficient compiler-like infrastructure for big data algorithms
    and complex numerical simulations. We can expect Blaze to play an important role
    in the future, as it should combine the nice and easy syntax of Python with the
    performance of native code and parallel processing techniques (notably multi-core
    processors and Graphical Processing Units). Other worthwhile related projects,
    but slightly older than Blaze and Numba, include **Theano** and **Numexpr** (which
    we will see in the next recipe).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**Blaze** 是 Continuum Analytics 的另一个项目，它是 NumPy 的下一代版本。它将提供比 NumPy 数组更具灵活性的数据结构，并且支持外存计算。与
    Numba 一起，Blaze 将形成一个高效的类似编译器的基础设施，用于大数据算法和复杂的数值模拟。我们可以预期 Blaze 在未来会发挥重要作用，因为它应该将
    Python 简洁易用的语法与原生代码的性能和并行处理技术（特别是多核处理器和图形处理单元）相结合。其他值得一提的相关项目，虽然稍微比 Blaze 和 Numba
    旧，但仍有价值，包括**Theano**和**Numexpr**（我们将在下一个食谱中看到它们）。'
- en: There's more…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'Let''s compare the performance of Numba with manually-vectorized code using
    NumPy, which is the standard way of accelerating pure Python code such as the
    code given in this recipe. In practice, it means replacing the code inside the
    two loops over `i` and `j` with array computations. This is relatively easy here
    as the operations closely follow the **Single Instruction, Multiple Data** (**SIMD**)
    paradigm:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较 Numba 与使用 NumPy 手动向量化代码的性能，后者是加速纯 Python 代码的标准方法，例如本教程中的代码。实际上，这意味着将 `i`
    和 `j` 循环中的代码替换为数组计算。在这里，这相对容易，因为这些操作紧跟 **单指令多数据** (**SIMD**) 的范式：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, Numba beats NumPy. However, we cannot draw any firm conclusion from this
    single experiment. Whether Numba or NumPy is faster depends on the particular
    implementation of the algorithm, simulation parameters, machine characteristics,
    and so on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Numba 超过了 NumPy。然而，我们不能仅凭这一个实验得出明确的结论。Numba 或 NumPy 哪个更快，取决于算法的具体实现、仿真参数、机器特性等因素。
- en: 'Here are a few references:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: Documentation of Numba available at [http://numba.pydata.org/doc.html](http://numba.pydata.org/doc.html)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Numba 文档，请见 [http://numba.pydata.org/doc.html](http://numba.pydata.org/doc.html)
- en: Types supported by Numba available at [http://numba.pydata.org/numba-doc/dev/types.html](http://numba.pydata.org/numba-doc/dev/types.html)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Numba 支持的类型，请见 [http://numba.pydata.org/numba-doc/dev/types.html](http://numba.pydata.org/numba-doc/dev/types.html)
- en: Numba examples available at [http://numba.pydata.org/numba-doc/dev/examples.html](http://numba.pydata.org/numba-doc/dev/examples.html)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Numba 示例请见 [http://numba.pydata.org/numba-doc/dev/examples.html](http://numba.pydata.org/numba-doc/dev/examples.html)
- en: Blaze available at [http://blaze.pydata.org](http://blaze.pydata.org)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blaze 可用，请见 [http://blaze.pydata.org](http://blaze.pydata.org)
- en: Theano available at [http://deeplearning.net/software/theano/](http://deeplearning.net/software/theano/)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Theano 可用，请见 [http://deeplearning.net/software/theano/](http://deeplearning.net/software/theano/)
- en: See also
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Accelerating array computations with Numexpr* recipe
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Numexpr 加速数组计算* 的方案'
- en: Accelerating array computations with Numexpr
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Numexpr 加速数组计算
- en: '**Numexpr** is a package that improves upon a weakness of NumPy; the evaluation
    of complex array expressions is sometimes slow. The reason is that multiple temporary
    arrays are created for the intermediate steps, which is suboptimal with large
    arrays. Numexpr evaluates algebraic expressions involving arrays, parses them,
    compiles them, and finally executes them faster than NumPy.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**Numexpr** 是一个改进了 NumPy 弱点的包；复杂数组表达式的评估有时会很慢。原因是，在中间步骤中会创建多个临时数组，这在处理大数组时不是最优的。Numexpr
    评估涉及数组的代数表达式，对其进行解析、编译，最后比 NumPy 更快地执行它们。'
- en: This principle is somewhat similar to Numba, in that normal Python code is compiled
    dynamically by a JIT compiler. However, Numexpr only tackles algebraic array expressions
    rather than arbitrary Python code. We will see how that works in this recipe.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原理与 Numba 有些相似，因为普通的 Python 代码是通过 JIT 编译器动态编译的。然而，Numexpr 只处理代数数组表达式，而不是任意的
    Python 代码。我们将在本教程中看到它是如何工作的。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will find the instructions to install Numexpr in the documentation available
    at [http://github.com/pydata/numexpr](http://github.com/pydata/numexpr).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://github.com/pydata/numexpr](http://github.com/pydata/numexpr) 的文档中找到安装
    Numexpr 的说明。
- en: How to do it…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Let''s import NumPy and Numexpr:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入 NumPy 和 Numexpr：
- en: '[PRE11]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we generate three large vectors:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们生成三个大向量：
- en: '[PRE12]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we evaluate the time taken by NumPy to calculate a complex algebraic expression
    involving our vectors:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们评估 NumPy 计算涉及我们向量的复杂代数表达式所需的时间：
- en: '[PRE13]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s perform the same calculation with Numexpr. We need to give the expression
    as a string:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用 Numexpr 执行相同的计算。我们需要将表达式作为字符串给出：
- en: '[PRE14]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Numexpr can use multiple cores. Here, we have 2 physical cores and 4 virtual
    threads with Intel''s Hyper-Threading Technology. We can specify how many cores
    we want Numexpr to use using the `set_num_threads()` function:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Numexpr 可以使用多个核心。在这里，我们有 2 个物理核心和 4 个虚拟线程，支持英特尔超线程技术。我们可以使用 `set_num_threads()`
    函数指定希望 Numexpr 使用的核心数：
- en: '[PRE15]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Numexpr analyzes the array expression, parses it, and compiles it into a lower-level
    language. Numexpr is aware of CPU-vectorized instructions as well as CPU cache
    characteristics. As such, Numexpr can optimize vectorized computations dynamically.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Numexpr 会分析数组表达式，对其进行解析，并将其编译成低级语言。Numexpr 知道 CPU 向量化指令和 CPU 缓存特性。因此，Numexpr
    可以动态优化向量化计算。
- en: There is some overlap between Numexpr, Numba, and Blaze. We can probably expect
    some crosstalk between these projects in the future.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Numexpr、Numba 和 Blaze 之间存在一定的重叠。我们可以预期将来这些项目之间会有一些交叉影响。
- en: See also
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Accelerating pure Python code with Numba and just-in-time compilation*
    recipe
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Numba 和即时编译加速纯 Python 代码* 的食谱'
- en: Wrapping a C library in Python with ctypes
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ctypes 在 Python 中包装 C 库
- en: Wrapping a C library in Python allows us to leverage existing C code or to implement
    a critical part of the code in a fast language such as C.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中包装 C 库使我们能够利用现有的 C 代码，或在像 C 这样快速的语言中实现代码的关键部分。
- en: It is relatively easy to use externally-compiled libraries with Python. The
    first possibility is to call a command-line executable with an `os.system` command,
    but this method does not extend to compiled libraries (on Windows, **Dynamically
    Linked Libraries**, or **DLLs**). A more powerful method consists of using a native
    Python module called **ctypes**. This module allows us to call functions defined
    in a compiled library (written in C) from Python. The `ctypes` module takes care
    of the data type conversions between C and Python. In addition, the `numpy.ctypeslib`
    module provides facilities to use NumPy arrays wherever data buffers are used
    in the external library.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 调用外部编译的库相对简单。第一种方式是通过 `os.system` 命令调用命令行可执行文件，但这种方法不能扩展到已编译的库（在 Windows
    上，**动态链接库**，或称 **DLL**）。更强大的方法是使用一个名为 **ctypes** 的本地 Python 模块。该模块允许我们从 Python
    调用在编译库中定义的函数（这些库是用 C 编写的）。`ctypes` 模块负责 C 和 Python 之间的数据类型转换。此外，`numpy.ctypeslib`
    模块提供了在外部库使用数据缓冲区的地方使用 NumPy 数组的功能。
- en: In this example, we will rewrite the code of the Mandelbrot fractal in C, compile
    it in a shared library, and call it from Python.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将用 C 重写 Mandelbrot 分形的代码，将其编译成共享库，并从 Python 调用它。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code of this recipe is written for Windows. It can be adapted to other systems
    with minor changes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是为 Windows 编写的，可以通过一些小修改适配到其他系统。
- en: A C compiler is required. You will find all compiler-related instructions in
    this chapter's introduction. In particular, for the C compiler to work on Windows,
    you need to execute a sequence of instructions in the Windows terminal before
    launching the IPython notebook. You will find a batch script with the appropriate
    instructions on the book's repository (in the folder containing the code for this
    chapter).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个 C 编译器。你将在本章的介绍部分找到所有与编译器相关的指令。特别是，要使 C 编译器在 Windows 上工作，你需要在启动 IPython
    笔记本之前，在 Windows 终端执行一系列指令。你将在书籍的仓库中找到包含本章代码的文件夹中的批处理脚本，里面有适当的指令。
- en: How to do it…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The first step is to write and compile the Mandelbrot example in C. The second
    step is to access the library from Python using ctypes. If you are only interested
    in discovering how to access an existing compiled library, you can go straight
    to step 3, assuming that `mandelbrot.dll` is a compiled library defining a function
    named `mandelbrot()`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是用 C 编写并编译 Mandelbrot 示例。第二步是使用 ctypes 从 Python 访问库。如果你只关心如何访问一个已编译的库，可以直接跳到第
    3 步，假设 `mandelbrot.dll` 是一个已编译的库，定义了名为 `mandelbrot()` 的函数。
- en: 'Let''s write the code of the Mandelbrot fractal in C:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用 C 编写 Mandelbrot 分形的代码：
- en: '[PRE16]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s build this C source file into a DLL with Microsoft Visual Studio''s
    `cl.exe`. The `/LD` option specifies that a DLL is to be created:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Microsoft Visual Studio 的 `cl.exe` 将这个 C 源文件构建成一个 DLL。`/LD` 选项指定创建
    DLL：
- en: '[PRE17]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s access the library with ctypes:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 ctypes 访问库：
- en: '[PRE18]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'NumPy and ctypes allow us to wrap the C function defined in the DLL:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 和 ctypes 使我们能够包装 DLL 中定义的 C 函数：
- en: '[PRE19]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To use this function, we first need to initialize an empty array and pass it
    as an argument to the `mandelbrot()` wrapper function:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用这个函数，我们首先需要初始化一个空数组，并将其作为参数传递给 `mandelbrot()` 包装函数：
- en: '[PRE20]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We free the library at the end of the script:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在脚本的最后释放库：
- en: '[PRE21]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何运作…
- en: In the C code, the `__declspec(dllexport)` command declares the function visible
    in the DLL. The `__stdcall` keyword declares the standard calling convention on
    Windows.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 代码中，`__declspec(dllexport)` 命令声明该函数在 DLL 中可见。`__stdcall` 关键字声明 Windows 上的标准调用约定。
- en: 'As arguments, the `mandelbrot()` function accepts:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`mandelbrot()` 函数接受以下参数：'
- en: The **size** of the `col` buffer (the `col` value is the last iteration where
    the corresponding point is within a disc around the origin)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`col` 缓冲区的**大小**（`col` 值是对应点位于原点周围圆盘内的最后一次迭代）'
- en: The number of **iterations**
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代次数**的数量'
- en: A **pointer** to the buffer of integers
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指针**指向整数缓冲区'
- en: '`mandelbrot()` does not return any value; rather, it updates the buffer that
    was passed by reference to the function (it is a pointer).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`mandelbrot()`不返回任何值；相反，它更新了通过引用传递给函数的缓冲区（它是一个指针）。'
- en: To wrap this function in Python, we need to declare the types of the input arguments.
    The ctypes module defines constants for the different data types. In addition,
    the `numpy.ctypeslib.ndpointer()` function lets us use a NumPy array wherever
    a pointer is expected in the C function. The data type given as argument to `ndpointer()`needs
    to correspond to the NumPy data type of the array passed to the function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中包装这个函数，我们需要声明输入参数的类型。ctypes模块为不同的数据类型定义了常量。此外，`numpy.ctypeslib.ndpointer()`函数允许我们在C函数中需要指针的地方使用NumPy数组。传递给`ndpointer()`的参数数据类型需要与传递给函数的NumPy数组的数据类型相对应。
- en: Once the function has been correctly wrapped, it can be called as if it was
    a standard Python function. Here, the initially-empty NumPy array is filled with
    the Mandelbrot fractal after the call to `mandelbrot()`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数正确地被包装，它就可以像标准Python函数一样调用。这里，在调用`mandelbrot()`之后，最初为空的NumPy数组被填充上了曼德布罗特分形。
- en: There's more…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: SciPy contains a module called **weave** that provides similar functionality.
    We can write C code in a Python string and let weave compile and execute it at
    runtime using a C compiler. This module does not seem well-maintained and appears
    to be incompatible with Python 3\. Cython or ctypes are probably better options.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy包含一个名为**weave**的模块，提供类似的功能。我们可以在Python字符串中编写C代码，然后让weave在运行时使用C编译器编译并执行它。这个模块似乎维护得不好，且似乎与Python
    3不兼容。Cython或ctypes可能是更好的选择。
- en: A more recent alternative to ctypes is cffi ([http://cffi.readthedocs.org](http://cffi.readthedocs.org)),
    which may be a bit faster and more convenient to use. You can also refer to [http://eli.thegreenplace.net/2013/03/09/python-ffi-with-ctypes-and-cffi/](http://eli.thegreenplace.net/2013/03/09/python-ffi-with-ctypes-and-cffi/).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ctypes的一个更新替代品是cffi（[http://cffi.readthedocs.org](http://cffi.readthedocs.org)），它可能会更快且更方便使用。你还可以参考[http://eli.thegreenplace.net/2013/03/09/python-ffi-with-ctypes-and-cffi/](http://eli.thegreenplace.net/2013/03/09/python-ffi-with-ctypes-and-cffi/)。
- en: Accelerating Python code with Cython
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cython加速Python代码
- en: '**Cython** is both a language (a superset of Python) and a Python library.
    With Cython, we start from a regular Python program and we add annotations about
    the type of the variables. Then, Cython translates that code to C and compiles
    the result to a Python extension module. Finally, we can use this compiled module
    in any Python program.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cython**既是一种语言（Python的超集），也是一个Python库。使用Cython，我们从一个常规的Python程序开始，并添加有关变量类型的注释。然后，Cython将这段代码翻译为C，并将结果编译为Python扩展模块。最后，我们可以在任何Python程序中使用这个编译后的模块。'
- en: While dynamic typing comes with a performance cost in Python, statically-typed
    variables in Cython generally lead to faster code execution.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python中的动态类型会带来性能开销，但Cython中的静态类型变量通常会导致代码执行更快。
- en: Performance gains are most significant in CPU-bound programs, notably in tight
    Python loops. By contrast, I/O-bound programs are not expected to benefit much
    from a Cython implementation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升在CPU密集型程序中最为显著，特别是在紧密的Python循环中。相比之下，I/O密集型程序预计从Cython实现中受益不大。
- en: In this recipe, we will see how to accelerate the Mandelbrot code example with
    Cython.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何使用Cython加速曼德布罗特代码示例。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A C compiler is required. You will find all compiler-related instructions in
    the introduction of this chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个C编译器。你将在本章的介绍部分找到所有与编译器相关的说明。
- en: You also need to install Cython from [http://www.cython.org](http://www.cython.org).
    With Anaconda, you can type `conda install cython` in a terminal.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要从[http://www.cython.org](http://www.cython.org)安装Cython。在Anaconda中，你可以在终端输入`conda
    install cython`。
- en: How to do it…
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: We assume that the variables `size` and `iterations` have been defined as in
    the previous recipes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设`size`和`iterations`变量已如前面的示例中定义。
- en: 'To use Cython in the IPython notebook, we first need to import the `cythonmagic`
    extension provided by IPython:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在IPython笔记本中使用Cython，我们首先需要导入IPython提供的`cythonmagic`扩展：
- en: '[PRE22]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As a first try, let''s just add the `%%cython` magic before the definition
    of the `mandelbrot()` function. Internally, this cell magic compiles the cell
    into a standalone Cython module, hence the need for all required imports to occur
    within the same cell. This cell does not have access to any variable or function
    defined in the interactive namespace:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一次尝试，我们只需在`mandelbrot()`函数定义之前添加`%%cython`魔法命令即可。内部， 该单元魔法会将单元编译为独立的Cython模块，因此所有必需的导入操作都需要在同一单元中完成。此单元无法访问交互式命名空间中定义的任何变量或函数：
- en: '[PRE23]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How fast is this version?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个版本有多快？
- en: '[PRE24]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We get virtually no speedup here. We need to specify the type of our Python
    variables.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里几乎没有加速效果。我们需要指定Python变量的类型。
- en: 'Let''s add type information using typed memory views for NumPy arrays (we explain
    these in the *How it works…* section). We also use a slightly different way to
    test whether particles have escaped from the domain (`if` test):'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用类型化内存视图为NumPy数组添加类型信息（我们将在*如何工作……*部分进行解释）。我们还采用了稍微不同的方式来测试粒子是否已经逃离了域（`if`测试）：
- en: '[PRE25]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How fast is this new version?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个新版本有多快？
- en: '[PRE26]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: All we have done is specified the type of the local variables and function arguments
    and bypassed NumPy's `np.abs()` function when computing the absolute value of
    `z`. These changes have helped Cython to generate more optimized C code from Python
    code.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们所做的只是指定了局部变量和函数参数的类型，并且在计算`z`的绝对值时绕过了NumPy的`np.abs()`函数。这些变化帮助Cython从Python代码生成了更优化的C代码。
- en: How it works…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作……
- en: The `cdef` keyword declares a variable as a statically-typed C variable. C variables
    lead to faster code execution because the overhead from Python's dynamic typing
    is mitigated. Function arguments can also be declared as statically-typed C variables.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdef`关键字将变量声明为静态类型的C变量。C变量能加速代码执行，因为它减少了Python动态类型带来的开销。函数参数也可以声明为静态类型的C变量。'
- en: In general, variables used inside tight loops should be declared with `cdef`.
    To ensure that our code is well-optimized, we can use **annotations**. We just
    add the `-a` flag after the `%%cython` magic and the non-optimized lines will
    be shown in a gradient of yellow (white lines are faster, yellow lines are slower).
    This is shown in the following screenshot. The color depends on the relative number
    of Python API calls at each line.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在紧密循环中使用的变量应当使用`cdef`声明。为了确保代码得到良好的优化，我们可以使用**注解**。只需在`%%cython`魔法命令后添加`-a`标志，未优化的行将以黄色渐变显示（白色行表示较快，黄色行表示较慢）。这一点可以通过以下截图看到。颜色的变化取决于每行相对的Python
    API调用次数。
- en: '![How it works…](img/4818OS_05_02.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作……](img/4818OS_05_02.jpg)'
- en: Annotations in Cython
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Cython中的注解
- en: 'There are two ways of declaring NumPy arrays as C variables with Cython: using
    **array buffers** or using **typed memory views**. In this recipe, we used typed
    memory views. We will cover array buffers in the next recipe.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以使用Cython将NumPy数组声明为C变量：使用**数组缓冲区**或使用**类型化内存视图**。在这个示例中，我们使用了类型化内存视图。在下一个示例中，我们将介绍数组缓冲区。
- en: Typed memory views allow efficient access to data buffers with a NumPy-like
    indexing syntax. For example, we can use `int[:,::1]` to declare a C-ordered 2D
    NumPy array with integer values, with `::1` meaning a contiguous layout in this
    dimension. Typed memory views can be indexed just like NumPy arrays.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化内存视图允许使用类似NumPy的索引语法高效地访问数据缓冲区。例如，我们可以使用`int[:,::1]`来声明一个按C顺序存储的二维NumPy数组，数组元素类型为整数，`::1`表示该维度是连续布局。类型化内存视图可以像NumPy数组一样进行索引。
- en: However, memory views do not implement element-wise operations like NumPy. Thus,
    memory views act as convenient data containers within tight `for` loops. For element-wise
    NumPy-like operations, array buffers should be used instead.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，内存视图并不实现像NumPy那样的逐元素操作。因此，内存视图在紧密的`for`循环中充当便捷的数据容器。对于逐元素的NumPy类似操作，应使用数组缓冲区。
- en: We could achieve a significant performance speedup by replacing the call to
    `np.abs` with a faster expression. The reason is that `np.abs` is a NumPy function
    with a slight call overhead. It is designed to work with relatively large arrays,
    not scalar values. This overhead results in a significant performance hit in a
    tight loop such as here. This bottleneck can be spotted with Cython annotations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将调用`np.abs`替换为更快的表达式，我们可以显著提高性能。原因是`np.abs`是一个NumPy函数，具有一定的调用开销。它是为处理较大数组而设计的，而不是标量值。这种开销在紧密的循环中会导致性能大幅下降。使用Cython注解可以帮助发现这一瓶颈。
- en: There's more…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: Using Cython from IPython is very convenient with the `%%cython` cell magic.
    However, it is sometimes necessary to create a reusable C extension module with
    Cython. This is actually what IPython's `%%cython` cell magic does under the hood.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cython从IPython中进行操作非常方便，尤其是通过`%%cython`单元魔法。然而，有时我们需要使用Cython创建一个可重用的C扩展模块。实际上，IPython的`%%cython`单元魔法在后台正是这么做的。
- en: The first step is to write a standalone Cython script in a `.pyx` file. This
    should correspond exactly to the entire contents of a `%%cython` cell magic.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是编写一个独立的Cython脚本，保存在`.pyx`文件中。它应当与`%%cython`单元魔法的完整内容完全一致。
- en: 'The second step is to create a `setup.py` file that we will use to compile
    the Cython module. Here is a basic `setup.py` file, assuming a `mandelbrot.pyx`
    file:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是创建一个`setup.py`文件，我们将用它来编译Cython模块。以下是一个基本的`setup.py`文件，假设有一个`mandelbrot.pyx`文件：
- en: '[PRE27]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The third step is to execute this setup script with Python:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步是用Python执行这个设置脚本：
- en: '[PRE28]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Two files have been created during the build process: the C source file and
    a compiled Python extension. The file extension is `.pyd` on Windows (DLL files)
    and `.so` on UNIX:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建过程中创建了两个文件：C源文件和已编译的Python扩展。文件扩展名在Windows上是`.pyd`（DLL文件），在UNIX上是`.so`：
- en: '[PRE29]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finally, we can load the compiled module as usual (using `from mandelbrot import
    mandelbrot`).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以像往常一样加载已编译的模块（使用`from mandelbrot import mandelbrot`）。
- en: 'With this technique, Cython code can also be integrated within a Python package.
    Here are a few references:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，Cython代码也可以集成到Python包中。以下是一些参考资料：
- en: Distributing Cython modules, explained at [http://docs.cython.org/src/userguide/source_files_and_compilation.html](http://docs.cython.org/src/userguide/source_files_and_compilation.html)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发Cython模块，详见[http://docs.cython.org/src/userguide/source_files_and_compilation.html](http://docs.cython.org/src/userguide/source_files_and_compilation.html)
- en: Compilation with Cython, explained at [http://docs.cython.org/src/reference/compilation.html](http://docs.cython.org/src/reference/compilation.html)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cython进行编译，详见[http://docs.cython.org/src/reference/compilation.html](http://docs.cython.org/src/reference/compilation.html)
- en: See also
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Optimizing Cython code by writing less Python and more C* recipe
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过编写更少的Python代码和更多的C代码来优化Cython代码*的食谱'
- en: The *Releasing the GIL to take advantage of multicore processors with Cython
    and OpenMP* recipe
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放GIL以利用多核处理器，使用Cython和OpenMP*的食谱'
- en: Optimizing Cython code by writing less Python and more C
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过编写更少的Python代码和更多的C代码来优化Cython代码
- en: In this recipe, we will consider a more complicated Cython example. Starting
    from a slow implementation in pure Python, we will use different Cython features
    to speed it up progressively.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将考虑一个更复杂的Cython示例。从一个纯Python中的慢实现开始，我们将逐步使用不同的Cython特性来加速它。
- en: We will implement a very simple ray tracing engine. **Ray tracing** consists
    of rendering a scene by simulating the physical properties of light propagation.
    This rendering method leads to photorealistic scenes, but it is computationally
    intensive.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个非常简单的光线追踪引擎。**光线追踪**通过模拟光传播的物理属性来渲染场景。这种渲染方法能够生成照片级真实感的场景，但计算量非常大。
- en: Here, we will render a single sphere with diffuse and specular lighting. First
    we'll give the example's code in pure Python. Then, we will accelerate it incrementally
    with Cython.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将渲染一个单一的球体，带有漫反射和镜面反射光照。首先，我们将给出纯Python版本的示例代码。然后，我们将逐步使用Cython加速它。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code is long and contains many functions. We will first give the full code
    of the pure Python version. Then, we will just describe the changes required to
    accelerate the code with Cython. The entire scripts are available on the book's
    website.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很长，包含许多函数。我们将首先给出纯Python版本的完整代码。然后，我们将描述用Cython加速代码所需的更改。所有脚本可以在本书网站上找到。
- en: How to do it…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'First, let''s implement the pure Python version:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们实现纯Python版本：
- en: '[PRE30]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We create a normalization function for vectors:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们为向量创建一个归一化函数：
- en: '[PRE31]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we create a function that computes the intersection of a ray with a sphere:'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们创建一个计算光线与球体交点的函数：
- en: '[PRE32]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following function traces a ray:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下函数进行光线追踪：
- en: '[PRE33]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, the main loop is implemented in the following function:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，主循环在以下函数中实现：
- en: '[PRE34]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we initialize the scene and define a few parameters:'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们初始化场景并定义一些参数：
- en: '[PRE35]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s render the scene:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们渲染场景：
- en: '[PRE36]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![How to do it…](img/4818OS_05_03.jpg)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/4818OS_05_03.jpg)'
- en: 'Ray tracing with Python and Cython. Left: the outcome of this recipe. Right:
    outcome of an extended version.'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Python和Cython进行光线追踪。左侧：这个食谱的结果。右侧：扩展版本的结果。
- en: How slow is this implementation?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个实现有多慢？
- en: '[PRE37]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If we just use the `%%cython` magic with the adequate `import numpy as np` and
    `cimport numpy as np` commands at the top of the cell, we only get a modest improvement,
    only a tenth of a second quicker.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只使用 `%%cython` 魔法并在单元格顶部添加适当的 `import numpy as np` 和 `cimport numpy as np`
    命令，我们只能获得适度的改进，仅比原来快了十分之一秒。
- en: 'We could do better by giving information about the type of the variables. Since
    we use vectorized computations on NumPy arrays, we cannot easily use memory views.
    Rather, we will use array buffers. First, at the very beginning of the Cython
    module (or `%%cython` cell), we declare NumPy data types as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过提供变量类型的信息来做得更好。由于我们在 NumPy 数组上执行向量化计算，我们不能轻易使用内存视图。因此，我们将使用数组缓冲区。首先，在
    Cython 模块（或 `%%cython` 单元格）的最开始，我们声明 NumPy 数据类型，如下所示：
- en: '[PRE38]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Then, we declare a NumPy array with `cdef np.ndarray[DBL_C, ndim=1]` (in this
    example, a 1D array of double precision floating point numbers). There is a difficulty
    here because NumPy arrays can only be declared inside functions, not at the top
    level. Thus, we need to slightly tweak the overall architecture of the code by
    passing some arrays as function arguments instead of using global variables. However,
    even by declaring the type of all variables, we gain virtually no speedup at all.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们声明一个 NumPy 数组，使用 `cdef np.ndarray[DBL_C, ndim=1]`（在此示例中，是一个一维的双精度浮点数数组）。这里有一个难点，因为
    NumPy 数组只能在函数内部声明，不能在顶层声明。因此，我们需要稍微调整代码的整体架构，将一些数组作为函数参数传递，而不是使用全局变量。然而，即使声明了所有变量的类型，我们几乎没有获得任何加速。
- en: In the current implementation, we incur a performance hit because of the large
    number of NumPy function calls on tiny arrays (three elements). NumPy is designed
    to deal with large arrays, and it does not make much sense to use it for arrays
    that small.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前的实现中，由于大量对小数组（三个元素）的 NumPy 函数调用，我们遭遇了性能下降。NumPy 设计上是处理大数组的，对于这么小的数组使用它并没有多大意义。
- en: 'In this specific situation, we can try to bypass NumPy by rewriting some functions
    using the C standard library. We use the `cdef` keyword to declare a C-style function.
    These functions can yield significant performance speedups. Here, we get a 2-3x
    speedup by replacing the `normalize()` Python function with the following C function:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，我们可以尝试通过使用 C 标准库重写一些函数来绕过 NumPy。我们使用 `cdef` 关键字声明一个 C 风格的函数。这些函数可以带来显著的性能加速。在这里，通过将
    `normalize()` Python 函数替换为以下 C 函数，我们获得了 2-3 倍的加速：
- en: '[PRE39]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To get the most interesting speedups, we need to completely bypass NumPy. Where
    do we use NumPy precisely?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获得最显著的加速，我们需要完全绕过 NumPy。那么，究竟在什么地方使用了 NumPy 呢？
- en: Many variables are NumPy arrays (mostly one-dimensional vectors with three elements).
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多变量是 NumPy 数组（主要是一维向量，包含三个元素）。
- en: Element-wise operations yield implicit NumPy API calls.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按元素操作会产生隐式的 NumPy API 调用。
- en: We also use a few NumPy built-in functions such as `numpy.dot()`.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还使用了一些 NumPy 内置函数，比如 `numpy.dot()`。
- en: 'In order to bypass NumPy in our example, we need to reimplement all these features
    for our specific needs. The first possibility is to use a native Python type for
    vectors (for example, tuples), and write C-style functions that implement operations
    on tuples (always assuming they have exactly three elements). For example, the
    addition between two tuples can be implemented as follows:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了在我们的示例中绕过 NumPy，我们需要根据具体需求重新实现这些功能。第一个选择是使用原生 Python 类型（例如元组）来表示向量，并编写 C 风格的函数来实现对元组的操作（假设它们总是有三个元素）。例如，两个元组相加可以实现如下：
- en: '[PRE40]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We get an interesting speedup (30x compared to pure Python), but we can do even
    better by using a pure C data type.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们获得了一个有趣的加速（相比纯 Python 快了 30 倍），但是通过使用纯 C 数据类型，我们可以做到更好。
- en: 'We are going to define a pure C structure instead of using a Python type for
    our vectors. In other words, we are not only bypassing NumPy, but we are also
    bypassing Python by moving to pure C code. To declare a C structure representing
    a 3D vector in Cython, we can use the following code:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义一个纯 C 结构体，而不是使用 Python 类型来表示我们的向量。换句话说，我们不仅绕过了 NumPy，还通过转向纯 C 代码绕过了 Python。为了在
    Cython 中声明表示 3D 向量的 C 结构体，我们可以使用以下代码：
- en: '[PRE41]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To create a new `Vec3` variable, we can use the following function:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建一个新的 `Vec3` 变量，我们可以使用以下函数：
- en: '[PRE42]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As an example, here is the function used to add two `Vec3` objects:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为一个例子，以下是用于加法操作两个 `Vec3` 对象的函数：
- en: '[PRE43]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The code can be updated to make use of these fast C-style functions. Finally,
    the image can be declared as a 3D memory view. With all these changes, the Cython
    implementation runs in ~12 ms, 300 times faster than the pure Python version!
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码可以更新，以利用这些快速的 C 风格函数。最后，图像可以声明为 3D 内存视图。经过这些改动，Cython 实现的速度达到了约 12 毫秒，比纯 Python
    版本快了 300 倍！
- en: In summary, we have achieved a very interesting speedup by basically rewriting
    the entire implementation in C with an enhanced Python syntax.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们通过将整个实现基本重写为 C 语言，并结合改进的 Python 语法，获得了非常有趣的加速效果。
- en: How it works…
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何运作…
- en: 'Let''s explain briefly how the ray tracing code works. We model a three-dimensional
    scene with objects such as planes and spheres (here, there is only one sphere).
    There is also a camera and a plane representing the rendered image:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 简要说明一下光线追踪代码是如何工作的。我们将三维场景建模为包含平面和球体等物体（此处仅有一个球体）。此外，还有一个相机和一个表示渲染图像的平面：
- en: '![How it works…](img/4818OS_05_04.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![如何运作...](img/4818OS_05_04.jpg)'
- en: Principles of ray tracing ("Ray trace diagram" by Henrik, Wikimedia Commons)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 光线追踪原理（“光线追踪图”由 Henrik 提供，来自 Wikimedia Commons）
- en: 'There is a main loop over all pixels of the image. For each pixel, we launch
    a ray from the camera center to the scene through the current pixel and compute
    the first intersection point between that ray and an object from the scene. Then,
    we compute the pixel''s color as a function of the object material''s color, the
    position of the lights, the normal of the object at the intersection point, and
    so on. There are several physics-inspired lighting equations that describe how
    the color depends on these parameters. Here, we use the **Blinn-Phong shading
    model** with ambient, diffuse, and specular lighting components:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中有一个主循环，遍历图像的所有像素。对于每个像素，我们从相机中心发射一条光线，穿过当前像素并与场景中的物体相交，计算该光线与物体的第一个交点。然后，我们根据物体材质的颜色、光源的位置、物体在交点处的法线等因素，计算像素的颜色。这里有几个受物理启发的光照方程，描述了颜色如何依赖于这些参数。在这里，我们使用**Blinn-Phong
    着色模型**，包括环境光、漫反射光和镜面反射光组件：
- en: '![How it works…](img/4818OS_05_05.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![如何运作...](img/4818OS_05_05.jpg)'
- en: Blinn-Phong shading model ("Phong components", Wikimedia Commons)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Blinn-Phong 着色模型（“Phong 组件”，来自 Wikimedia Commons）
- en: 'Of course, a full ray tracing engine is far more complex than what we have
    implemented in this example. We can model other optic and lighting characteristics
    such as reflections, refractions, shadows, depth of field, and others. It is also
    possible to implement ray tracing algorithms on the graphics card for real-time
    photorealistic rendering. Here are a few references:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，完整的光线追踪引擎远比我们在这个示例中实现的复杂。我们还可以模拟其他光学和光照特性，如反射、折射、阴影、景深等。也可以将光线追踪算法实现到显卡上，进行实时的真实感渲染。这里有几个参考资料：
- en: Blinn-Phong shading model on Wikipedia, available at [http://en.wikipedia.org/wiki/Blinn-Phong_shading_model](http://en.wikipedia.org/wiki/Blinn-Phong_shading_model)
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blinn-Phong 着色模型的 Wikipedia 页面，详见 [http://en.wikipedia.org/wiki/Blinn-Phong_shading_model](http://en.wikipedia.org/wiki/Blinn-Phong_shading_model)
- en: Ray tracing on Wikipedia, available at [http://en.wikipedia.org/wiki/Ray_tracing_(graphics)](http://en.wikipedia.org/wiki/Ray_tracing_(graphics))
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光线追踪的 Wikipedia 页面，详见 [http://en.wikipedia.org/wiki/Ray_tracing_(graphics)](http://en.wikipedia.org/wiki/Ray_tracing_(graphics))
- en: There's more…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Although powerful, Cython requires a good understanding of Python, NumPy, and
    C. The most interesting performance speedups are achieved when dynamically-typed
    Python variables are converted to statically-typed C variables, notably within
    tight loops.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管功能强大，Cython 仍然需要对 Python、NumPy 和 C 有较好的理解。最显著的性能提升来自于将动态类型的 Python 变量转换为静态类型的
    C 变量，尤其是在紧凑的循环中。
- en: 'Here are a few references:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个参考资料：
- en: Cython extension types available at [http://docs.cython.org/src/userguide/extension_types.html](http://docs.cython.org/src/userguide/extension_types.html)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的 Cython 扩展类型，详情见 [http://docs.cython.org/src/userguide/extension_types.html](http://docs.cython.org/src/userguide/extension_types.html)
- en: Extended version of our ray tracing engine available at [http://gist.github.com/rossant/6046463](http://gist.github.com/rossant/6046463)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的光线追踪引擎的扩展版本，详见 [http://gist.github.com/rossant/6046463](http://gist.github.com/rossant/6046463)
- en: See also
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见：
- en: The *Accelerating Python code with Cython* recipe
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Cython 加速 Python 代码* 配方'
- en: The *Releasing the GIL to take advantage of multicore processors with Cython
    and OpenMP* recipe
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Cython 和 OpenMP 释放 GIL 以利用多核处理器* 配方'
- en: Releasing the GIL to take advantage of multicore processors with Cython and
    OpenMP
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cython 和 OpenMP 释放 GIL，以充分利用多核处理器
- en: As we have seen in this chapter's introduction, CPython's GIL prevents pure
    Python code from taking advantage of multi-core processors. With Cython, we have
    a way to release the GIL temporarily in a portion of the code in order to enable
    multi-core computing. This is done with **OpenMP**, a multiprocessing API that
    is supported by most C compilers.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章介绍中所看到的，CPython的GIL阻止了纯Python代码利用多核处理器。使用Cython，我们可以在代码的某个部分临时释放GIL，从而启用多核计算。这是通过**OpenMP**完成的，OpenMP是一个多处理API，大多数C编译器都支持它。
- en: In this recipe, we will see how to parallelize the previous recipe's code on
    multiple cores.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将看到如何在多个核心上并行化前一个食谱的代码。
- en: Getting ready
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To enable OpenMP in Cython, you just need to specify some options to the compiler.
    There is nothing special to install on your computer besides a good C compiler.
    See the instructions in this chapter's introduction for more details.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Cython中启用OpenMP，您只需为编译器指定一些选项。除了一个好的C编译器之外，您无需在计算机上安装任何特殊的软件。有关更多详细信息，请参阅本章介绍中的说明。
- en: In this recipe, we use Microsoft's Visual C++ compiler on Windows, but the code
    can be easily adapted to other systems.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们使用的是微软的Visual C++编译器（适用于Windows），但代码可以轻松适应其他系统。
- en: How to do it…
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: Our simple ray tracing engine implementation is **embarrassingly parallel**;
    there is a main loop over all pixels, within which the exact same function is
    called repetitively. There is no crosstalk between loop iterations. Therefore,
    it would be theoretically possible to execute all iterations in parallel.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单光线追踪引擎实现是**极其并行**的；有一个遍历所有像素的主循环，在这个循环中，完全相同的函数会被重复调用。循环迭代之间没有串扰。因此，理论上可以在并行中执行所有迭代。
- en: Here, we will execute one loop (over all columns in the image) in parallel with
    OpenMP.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将并行执行一个循环（遍历图像中的所有列），使用OpenMP。
- en: 'You will find the entire code on the book''s website. We will only show the
    most important steps here:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在书籍网站上找到完整的代码。我们这里只展示最重要的步骤：
- en: 'We add the following options to the `%%cython` magic command: `--compile-args=/openmp
    --link-args=/openmp`. The exact syntax may depend on your compiler and/or your
    system. For example, `/openmp` should be replaced by `-fopenmp` with GCC.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`%%cython`魔法命令中添加以下选项：`--compile-args=/openmp --link-args=/openmp`。具体语法可能依赖于您的编译器和/或系统。例如，`/openmp`应该替换为GCC中的`-fopenmp`。
- en: 'We import the `prange()` function:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入了`prange()`函数：
- en: '[PRE44]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We add `nogil` after each function definition in order to remove the GIL. We
    cannot use any Python variable or function inside a function annotated with `nogil`.
    For example:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在每个函数定义后添加`nogil`，以移除GIL。在标记为`nogil`的函数中，不能使用任何Python变量或函数。例如：
- en: '[PRE45]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To run a loop in parallel over the cores with OpenMP, we use `prange()`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用OpenMP在多个核心上并行运行循环，我们使用`prange()`：
- en: '[PRE46]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The GIL needs to be released before using any parallel computing feature such
    as `prange()`.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在使用任何并行计算功能（如`prange()`）之前，需要释放GIL。
- en: With these changes, we reach a 4x speedup on a quad-core processor.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这些更改，我们在四核处理器上达到了4倍的加速。
- en: How it works…
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原理…
- en: The GIL has been described in the introduction of this chapter. The `nogil`
    keyword tells Cython that a particular function or code section should be executed
    without the GIL. When the GIL is released, it is not possible to make any Python
    API calls, meaning that only C variables and C functions (declared with `cdef`)
    can be used.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: GIL（全局解释器锁）已经在本章的介绍中描述过。`nogil`关键字告诉Cython，某个特定的函数或代码段应该在没有GIL的情况下执行。当GIL被释放时，无法进行任何Python
    API调用，这意味着只能使用C变量和C函数（用`cdef`声明的函数）。
- en: See also
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Accelerating Python code with Cython* recipe
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用Cython加速Python代码* 食谱'
- en: The *Optimizing Cython code by writing less Python and more C* recipe
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过编写更少的Python代码和更多的C代码来优化Cython代码* 食谱'
- en: The *Distributing Python code across multiple cores with IPython* recipe
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过IPython将Python代码分配到多个核心* 食谱'
- en: Writing massively parallel code for NVIDIA graphics cards (GPUs) with CUDA
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为NVIDIA显卡（GPU）编写大规模并行代码，使用CUDA
- en: '**Graphics Processing Units** (**GPUs**) are powerful processors specialized
    in real-time rendering. We find GPUs in virtually any computer, laptop, video
    game console, tablet, or smartphone. Their massively parallel architecture comprises
    tens to thousands of cores. The video game industry has been fostering the development
    of increasingly powerful GPUs over the last two decades.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形处理单元**（**GPU**）是专门用于实时渲染的强大处理器。我们几乎在任何计算机、笔记本、视频游戏主机、平板或智能手机中都能找到 GPU。它们的并行架构包含数十到数千个核心。视频游戏产业在过去二十年里一直在推动更强大
    GPU 的发展。'
- en: GPUs are routinely used in modern supercomputers (for example in Cray's Titan
    at Oak Ridge National Laboratory, ~20 petaFLOPS, ~20,000 CPUs, and as many NVIDIA
    GPUs). A high-end $1000 GPU today is roughly as powerful as a $100 million supercomputer
    from 2000 (several teraFLOPS).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: GPUs（图形处理单元）已被广泛应用于现代超级计算机中（例如，位于橡树岭国家实验室的 Cray Titan，约 20 佩塔FLOPS，约 20,000
    个 CPU，以及大量的 NVIDIA GPUs）。今天，一个高端 $1000 的 GPU 大致相当于 2000 年的一个价值 $1 亿的超级计算机（约几个
    teraFLOPS）。
- en: Note
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: FLOPS means FLoating-point Operations Per Second. A 1 teraFLOPS GPU can perform
    up to one trillion floating-point operations per second.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: FLOPS 指的是每秒浮点运算次数（FLoating-point Operations Per Second）。一个 1 teraFLOPS 的 GPU
    每秒可以执行高达一万亿次浮点运算。
- en: 'Since the mid-2000s, GPUs are no longer limited to graphics processing. We
    can now implement scientific algorithms on a GPU. The only condition is that the
    algorithm follows the **SIMD (Single Instruction, Multiple Data) paradigm**, where
    a sequence of instructions is executed in parallel with multiple data. This is
    called **General Purpose Programming on Graphics Processing Units** (**GPGPU**).
    GPGPU is used in many areas: meteorology, data mining, computer vision, image
    processing, finance, physics, bioinformatics, and many more. Writing code for
    GPUs can be challenging as it requires understanding the internal architecture
    of the hardware.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2000 年代中期以来，GPU 已不再局限于图形处理。我们现在可以在 GPU 上实现科学算法。唯一的条件是算法必须遵循 **SIMD（单指令多数据）范式**，即一系列指令并行执行多个数据。这被称为
    **图形处理单元上的通用计算**（**GPGPU**）。GPGPU 已被应用于多个领域：气象学、数据挖掘、计算机视觉、图像处理、金融、物理学、生物信息学等多个领域。为
    GPU 编写代码可能具有挑战性，因为它需要理解硬件的内部架构。
- en: '**CUDA** is a proprietary GPGPU framework created in 2007 by NVIDIA Corporation,
    one of the main GPU manufacturers. Programs written in CUDA only work on NVIDIA
    graphics cards. There is another competing GPGPU framework called **OpenCL**,
    an open standard supported by other major companies. OpenCL programs can work
    on GPUs and CPUs from most manufacturers (notably NVIDIA, AMD, and Intel).'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**CUDA** 是由 NVIDIA 公司于 2007 年创建的专有 GPGPU 框架，是主要的 GPU 制造商之一。用 CUDA 编写的程序仅能在
    NVIDIA 显卡上运行。还有另一个竞争性的 GPGPU 框架，称为 **OpenCL**，这是一个由其他主要公司支持的开放标准。OpenCL 程序可以在大多数厂商的
    GPU 和 CPU 上运行（特别是 NVIDIA、AMD 和英特尔）。'
- en: In this recipe, we will show a very basic example of GPGPU. We'll implement
    the embarrassingly parallel computation of the Mandelbrot fractal in CUDA. In
    the next recipe, we will implement the exact same example in OpenCL.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将展示一个非常基础的 GPGPU 示例。我们将使用 CUDA 实现 Mandelbrot 分形的非常简单的并行计算。在下一个示例中，我们将使用
    OpenCL 实现完全相同的例子。
- en: Tip
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Should you choose OpenCL or CUDA for a new project? The answer depends most
    notably on the hardware of your user base. If you need the highest performance
    possible for a specific project in your lab where all computers have an NVIDIA
    card, and if releasing your program to the world is not a high priority, you could
    choose CUDA. If you envision distributing your program to many people running
    different platforms, you should probably choose OpenCL. Featurewise, these two
    platforms are very roughly equivalent.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个新项目，你应该选择 OpenCL 还是 CUDA？答案主要取决于你用户群体的硬件配置。如果你需要在实验室中针对所有配备 NVIDIA 显卡的计算机实现尽可能高的性能，并且发布你的程序到全球并不是优先考虑的事情，你可以选择
    CUDA。如果你计划将程序分发给使用不同平台的多人，你应该选择 OpenCL。在功能上，这两者大体上是相当的。
- en: We can use CUDA in Python thanks to PyCUDA, a Python package written by Andreas
    Klöckner ([http://documen.tician.de/pycuda/](http://documen.tician.de/pycuda/)).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 PyCUDA 在 Python 中使用 CUDA，这是由 Andreas Klöckner 编写的一个 Python 包 ([http://documen.tician.de/pycuda/](http://documen.tician.de/pycuda/))。
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Installing and configuring PyCUDA is not straightforward in general. First,
    you need an NVIDIA GPU. Then, you need to install the CUDA SDK. Finally, you have
    to install and configure PyCUDA. Note that PyCUDA depends on a few external packages,
    notably pytools.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和配置PyCUDA通常不简单。首先，您需要一块NVIDIA GPU。然后，您需要安装CUDA SDK。最后，您需要安装并配置PyCUDA。请注意，PyCUDA依赖于一些外部包，特别是pytools。
- en: On Windows, you should use Chris Gohlke's package. Make sure your version of
    CUDA matches the version used in the PyCUDA package. If you have DLL-related problems,
    use Dependency Walker on the `*.pyd` files in PyCUDA's installation folder (with
    Anaconda, it should look like `C:\anaconda\lib\site-packages\pycuda`). If you
    use Windows 64-bit, make sure that `C:\Windows\SysWOW64` is in your system PATH.
    Finally, make sure you have the version of Visual Studio that corresponds to your
    version of Python (see the instructions related to C compilers at the beginning
    of this chapter).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，您应该使用Chris Gohlke的包。确保您的CUDA版本与PyCUDA包中使用的版本匹配。如果遇到DLL相关的问题，使用Dependency
    Walker检查PyCUDA安装文件夹中的`*.pyd`文件（在Anaconda下，它应该位于`C:\anaconda\lib\site-packages\pycuda`）。如果您使用的是Windows
    64位，确保`C:\Windows\SysWOW64`在您的系统PATH中。最后，确保您有与Python版本相对应的Visual Studio版本（请参阅本章开头关于C编译器的说明）。
- en: 'You will find more information at the following links:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到更多信息：
- en: CUDA SDK available at [http://developer.nvidia.com/cuda-downloads](http://developer.nvidia.com/cuda-downloads)
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可在[http://developer.nvidia.com/cuda-downloads](http://developer.nvidia.com/cuda-downloads)下载CUDA
    SDK
- en: PyCUDA wiki available at [http://wiki.tiker.net](http://wiki.tiker.net)
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCUDA维基可以在[http://wiki.tiker.net](http://wiki.tiker.net)找到
- en: How to do it...
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Let''s import PyCUDA:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入PyCUDA：
- en: '[PRE47]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We initialize the NumPy array that will contain the fractal:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们初始化一个将包含分形的NumPy数组：
- en: '[PRE48]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We allocate GPU memory for this array:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为这个数组分配GPU内存：
- en: '[PRE49]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We write the CUDA kernel in a string. Arguments to the `mandelbrot()` function
    are:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将CUDA内核写入字符串中。`mandelbrot()`函数的参数包括：
- en: The figure **size**
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的**大小**
- en: The number of **iterations**
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代次数**'
- en: The **pointer** to the memory buffer
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指针**指向内存缓冲区'
- en: 'This function executes on every single pixel. It updates the `col` buffer with
    the pixel''s color:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数在每个像素上执行。它更新`col`缓冲区中的像素颜色：
- en: '[PRE50]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we compile the CUDA program:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们编译CUDA程序：
- en: '[PRE51]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We define the block size and the grid size, specifying how the threads will
    be parallelized with respect to the data:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了块大小和网格大小，指定线程如何根据数据进行并行化：
- en: '[PRE52]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We call the compiled function:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用编译后的函数：
- en: '[PRE53]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once the function has completed, we copy the contents of the CUDA buffer back
    to the NumPy array `col`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦函数执行完毕，我们将CUDA缓冲区的内容复制回NumPy数组`col`：
- en: '[PRE54]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `col` array now contains the Mandelbrot fractal. We find that this CUDA
    program is executed in 0.7 ms on a mobile GeForce GPU.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`col`数组包含了曼德尔布罗特分形。我们发现这个CUDA程序在移动GeForce GPU上执行时间为0.7毫秒。
- en: How it works…
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: GPU programming is a rich and highly technical topic, encompassing low-level
    architectural details of GPUs. Of course, we only scratched the surface here with
    the simplest paradigm possible (the "embarrassingly parallel" problem). We give
    further references in a later section.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: GPU编程是一个丰富且高度技术性的主题，涉及GPU的低级架构细节。当然，我们这里只用最简单的范式（“极其并行”的问题）浅尝辄止。我们将在后续部分提供更多参考。
- en: A CUDA GPU has a number of **multiprocessors**, and each multiprocessor has
    multiple **stream processors** (also called **CUDA cores**). Each multiprocessor
    executes in parallel with the others. Within a multiprocessor, the stream processors
    execute the same instruction at the same time, but on multiple data bits (SIMD
    paradigm).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一个CUDA GPU有多个**多处理器**，每个多处理器有多个**流处理器**（也称为**CUDA核心**）。每个多处理器与其他多处理器并行执行。在一个多处理器中，流处理器在相同时间执行相同的指令，但操作不同的数据位（SIMD范式）。
- en: 'Central notions to the CUDA programming model are those of kernels, threads,
    blocks, and grids:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: CUDA编程模型的核心概念包括内核、线程、块和网格：
- en: A **kernel** is a program written in a C-like language that runs on the GPU.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核**是用类似C的语言编写的程序，运行在GPU上。'
- en: A **thread** represents one execution of a kernel on one *stream processor*.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程**代表在一个*流处理器*上执行的一个内核。'
- en: A **block** contains multiple threads executing on one *multiprocessor*.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**块**包含多个在一个*多处理器*上执行的线程。
- en: A **grid** contains a number of blocks.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**网格**包含多个块。
- en: The number of threads per block is limited by the size of the multiprocessors
    and depends on the graphics card model (1024 in recent models). However, a grid
    can contain an arbitrary number of blocks.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 每个块的线程数受多处理器大小的限制，并且取决于显卡型号（在最近的型号中为 1024）。然而，一个网格可以包含任意数量的块。
- en: Within a block, threads are executed within **warps** of typically 32 threads.
    Better performance is achieved when conditional branching in a kernel is organized
    into groups of 32 threads.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个块内，线程通常以 **warp**（通常是 32 个线程）的形式执行。当内核中的条件分支组织成 32 个线程一组时，性能会更好。
- en: Threads within a block can synchronize at synchronization barriers using the
    `__syncthreads()` function. This feature enables inter-thread communication within
    one block. However, blocks execute independently so that two threads from different
    blocks cannot synchronize.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 块内的线程可以通过 `__syncthreads()` 函数在同步屏障处进行同步。此功能允许一个块内的线程之间进行通信。然而，块是独立执行的，因此来自不同块的两个线程不能同步。
- en: Within a block, threads are organized into a 1D, 2D, or 3D structure, and similarly
    for blocks within a grid, as shown in the following figure. This structure is
    convenient as it matches most common multidimensional datasets encountered in
    real-world problems.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个块内，线程被组织成 1D、2D 或 3D 结构，网格中的块也是如此，如下图所示。这个结构非常方便，因为它与现实世界问题中常见的多维数据集相匹配。
- en: '![How it works…](img/4818OS_05_06.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/4818OS_05_06.jpg)'
- en: The CUDA programming model (showing threads, blocks, and grids — image by NVIDIA
    Corporation)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: CUDA 编程模型（显示线程、块和网格 — 图像来自 NVIDIA 公司）
- en: The kernel can retrieve the thread index within the block (`threadIdx`), as
    well as the block index within the grid (`blockIdx`) to determine which bit of
    data it should work on. In this recipe, the 2D image of the fractal is partitioned
    into 10 x 10 blocks, each block containing 100 pixels, with one thread per pixel.
    The kernel `mandelbrot` computes the color of a single pixel.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 内核可以检索块内的线程索引（`threadIdx`）以及网格内的块索引（`blockIdx`），以确定它应该处理的数据部分。在这个配方中，分形的 2D
    图像被划分为 10 x 10 的块，每个块包含 100 个像素，每个像素对应一个线程。内核 `mandelbrot` 计算单个像素的颜色。
- en: There are several levels of memory on the GPU, ranging from small, fast, and
    local memory shared by a few threads within a block; to large, slow, and global
    memory shared by all blocks. We need to tweak the memory access patterns in the
    code to match the hardware constraints and achieve higher performance. In particular,
    data access is more efficient when the threads within a warp access *consecutive*
    addresses in the global memory; the hardware **coalesces** all memory accesses
    into a single access to consecutive **DRAM** (**Dynamic Random Access Memory**)
    locations.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 上有多个内存层次，从块内少数线程共享的小而快的本地内存，到所有块共享的大而慢的全局内存。我们需要调整代码中的内存访问模式，以匹配硬件约束并实现更高的性能。特别地，当
    warp 内的线程访问全局内存中的 *连续* 地址时，数据访问效率更高；硬件会将所有内存访问合并为对连续 **DRAM**（**动态随机存取内存**）位置的单次访问。
- en: PyCUDA lets us upload/download data from NumPy arrays to buffers residing on
    the GPU. This operation is generally costly. Complex real-world problems frequently
    involve iterative steps happening on both the CPU and on the GPU, such that communication
    between the two is a common performance bottleneck. Higher performance is achieved
    when there are few of these exchanges.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: PyCUDA 让我们可以将数据从 NumPy 数组上传/下载到驻留在 GPU 上的缓冲区。这项操作通常非常耗费资源。复杂的现实世界问题常常涉及在 CPU
    和 GPU 上都进行迭代步骤，因此二者之间的通信成为常见的性能瓶颈。当这些交换较少时，性能可以得到提升。
- en: There is some boilerplate code in (Py)CUDA on the C/Python side that consists
    of initializing the GPU, allocating data, uploading/downloading data to/from the
    GPU, compiling the kernel, executing the kernel, and so on. You can find all the
    details in the CUDA/PyCUDA documentation, but as a first approach, you can also
    just copy and paste code from this recipe or any tutorial.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在 (Py)CUDA 的 C/Python 端有一些模板代码，涉及初始化 GPU、分配数据、将数据上传/下载到/从 GPU、编译内核、执行内核等等。你可以在
    CUDA/PyCUDA 文档中找到所有的详细信息，但作为一种初步方法，你也可以直接复制并粘贴这个配方或任何教程中的代码。
- en: There's more…
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'Here are a few references:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: Official CUDA portal at [http://developer.nvidia.com/category/zone/cuda-zone](http://developer.nvidia.com/category/zone/cuda-zone)
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 CUDA 门户：[http://developer.nvidia.com/category/zone/cuda-zone](http://developer.nvidia.com/category/zone/cuda-zone)
- en: Education and training for CUDA, at [http://developer.nvidia.com/cuda-education-training](http://developer.nvidia.com/cuda-education-training)
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CUDA的教育与培训，详情请见[http://developer.nvidia.com/cuda-education-training](http://developer.nvidia.com/cuda-education-training)
- en: Suggested books about CUDA, at [http://developer.nvidia.com/suggested-reading](http://developer.nvidia.com/suggested-reading)
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于CUDA的推荐书籍，详见[http://developer.nvidia.com/suggested-reading](http://developer.nvidia.com/suggested-reading)
- en: Choosing between CUDA or OpenCL, at [http://wiki.tiker.net/CudaVsOpenCL](http://wiki.tiker.net/CudaVsOpenCL)
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于选择CUDA还是OpenCL，详见[http://wiki.tiker.net/CudaVsOpenCL](http://wiki.tiker.net/CudaVsOpenCL)
- en: A blog post on CUDA and OpenCL available at [http://streamcomputing.eu/blog/2011-06-22/opencl-vs-cuda-misconceptions/](http://streamcomputing.eu/blog/2011-06-22/opencl-vs-cuda-misconceptions/)
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于CUDA和OpenCL的博客文章，详见[http://streamcomputing.eu/blog/2011-06-22/opencl-vs-cuda-misconceptions/](http://streamcomputing.eu/blog/2011-06-22/opencl-vs-cuda-misconceptions/)
- en: See also
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Writing massively parallel code for heterogeneous platforms with OpenCL*
    recipe
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为异构平台编写大规模并行代码与OpenCL*食谱'
- en: Writing massively parallel code for heterogeneous platforms with OpenCL
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为异构平台编写大规模并行代码与OpenCL
- en: In the previous recipe, we introduced CUDA, a *proprietary* GPGPU framework
    created by NVIDIA Corporation. In this recipe, we present OpenCL, an alternative
    *open* framework initiated by Apple in 2008\. It is now adopted by mainstream
    companies including Intel, NVIDIA, AMD, Qualcomm, ARM, and others. These companies
    are regrouped within the non-profit technology consortium **Khronos Group** (which
    also maintains the OpenGL real-time rendering specification). Programs written
    in OpenCL can run on GPUs and CPUs (**heterogeneous computing**).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个食谱中，我们介绍了CUDA，这是由NVIDIA公司创建的*专有*GPGPU框架。在这个食谱中，我们介绍了OpenCL，这是一个由苹果公司在2008年启动的*开放*框架。现在，主流公司，包括Intel、NVIDIA、AMD、Qualcomm、ARM等，均已采用。它们都属于非盈利的技术联盟**Khronos
    Group**（该联盟还维护着OpenGL实时渲染规范）。用OpenCL编写的程序可以在GPU和CPU上运行（**异构计算**）。
- en: Tip
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: CUDA and OpenCL are relatively similar in terms of concepts, syntax, and features.
    CUDA sometimes leads to slightly higher performance, since its API matches the
    hardware more closely than OpenCL's generic API.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念、语法和特性上，CUDA和OpenCL相对相似。由于CUDA的API与硬件的匹配度比OpenCL的通用API更高，CUDA有时能带来稍微更高的性能。
- en: We can use OpenCL in Python thanks to **PyOpenCL**, a Python package written
    by Andreas Klöckner ([http://documen.tician.de/pyopencl/](http://documen.tician.de/pyopencl/)).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过**PyOpenCL**在Python中使用OpenCL，这是Andreas Klöckner编写的一个Python包([http://documen.tician.de/pyopencl/](http://documen.tician.de/pyopencl/))。
- en: In this recipe, we will implement the Mandelbrot fractal in OpenCL. The OpenCL
    kernel is very similar to the CUDA kernel from the previous recipe. The Python
    API used to access OpenCL is somewhat different from PyCUDA, but the concepts
    are equivalent.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用OpenCL实现曼德布罗特分形。OpenCL内核与前一个食谱中的CUDA内核非常相似。用于访问OpenCL的Python API与PyCUDA略有不同，但概念是相同的。
- en: Getting ready
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Installing PyOpenCL is generally not straightforward. The first step is to install
    the OpenCL SDK for your hardware (CPU and/or GPU). Then, you have to install and
    configure PyOpenCL. On Windows, you should use Chris Gohlke's package. Some installation
    instructions in the previous recipe apply here as well.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 安装PyOpenCL通常并不简单。第一步是安装适用于你硬件（CPU和/或GPU）的OpenCL SDK。然后，你需要安装并配置PyOpenCL。在Windows上，你应使用Chris
    Gohlke的包。上一食谱中的一些安装说明在这里同样适用。
- en: 'Here are a few references:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: The PyOpenCL Wiki available at [http://wiki.tiker.net](http://wiki.tiker.net)
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyOpenCL Wiki可在[http://wiki.tiker.net](http://wiki.tiker.net)访问
- en: The documentation of PyOpenCL available at [http://documen.tician.de/pyopencl/](http://documen.tician.de/pyopencl/)
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyOpenCL的文档可在[http://documen.tician.de/pyopencl/](http://documen.tician.de/pyopencl/)查看
- en: 'Here are the links to the various OpenCL SDKs:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是各个OpenCL SDK的链接：
- en: Intel's SDK is available at [http://software.intel.com/en-us/vcsource/tools/opencl-sdk](http://software.intel.com/en-us/vcsource/tools/opencl-sdk)
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Intel的SDK可在[http://software.intel.com/en-us/vcsource/tools/opencl-sdk](http://software.intel.com/en-us/vcsource/tools/opencl-sdk)下载
- en: AMD's SDK is available at [http://developer.amd.com/tools-and-sdks/heterogeneous-computing/](http://developer.amd.com/tools-and-sdks/heterogeneous-computing/)
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMD的SDK可在[http://developer.amd.com/tools-and-sdks/heterogeneous-computing/](http://developer.amd.com/tools-and-sdks/heterogeneous-computing/)下载
- en: NVIDIA's SDK is available at [http://developer.nvidia.com/opencl](http://developer.nvidia.com/opencl)
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NVIDIA的SDK可在[http://developer.nvidia.com/opencl](http://developer.nvidia.com/opencl)下载
- en: How to do it…
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s import PyOpenCL:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入PyOpenCL：
- en: '[PRE55]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following object defines some flags related to memory management on the
    device:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下对象定义了一些与设备内存管理相关的标志：
- en: '[PRE56]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We create an OpenCL context and a command queue:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个 OpenCL 上下文和一个命令队列：
- en: '[PRE57]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we initialize the NumPy array that will contain the fractal:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们初始化将包含分形的 NumPy 数组：
- en: '[PRE58]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We allocate GPU memory for this array:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为这个数组分配 GPU 内存：
- en: '[PRE59]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We write the OpenCL kernel in a string:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 OpenCL 内核写入字符串中：
- en: '[PRE60]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, we compile the OpenCL program:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们编译 OpenCL 程序：
- en: '[PRE61]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We call the compiled function, passing the command queue, the grid size, and
    the buffers as arguments:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用已编译的函数，并将命令队列、网格大小和缓冲区作为参数传递：
- en: '[PRE62]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Once the function has completed, we copy the contents of the OpenCL buffer
    back into the NumPy array `col`:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦函数执行完成，我们将 OpenCL 缓冲区的内容复制回 NumPy 数组 `col`：
- en: '[PRE63]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Finally, we can check that the function was successful by `imshow()`-ing the
    NumPy array `col`. We can also do a quick benchmark with `%timeit`, and we find
    that this function takes ~3.7 ms to complete on an Intel i3 dual-core CPU.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过 `imshow()` 显示 NumPy 数组 `col` 来检查函数是否成功。我们还可以使用 `%timeit` 进行快速基准测试，结果显示该函数在
    Intel i3 双核 CPU 上大约需要 3.7 毫秒完成。
- en: How it works…
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The principles detailed in the previous recipe apply here as well. There is
    a change of terminology between CUDA and OpenCL:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 前面食谱中详细介绍的原理同样适用于此。CUDA 和 OpenCL 之间存在术语上的差异：
- en: CUDA threads are equivalent to OpenCL **work items**.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CUDA 线程相当于 OpenCL 的**工作项**。
- en: CUDA blocks are equivalent to OpenCL **work groups**.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CUDA 块相当于 OpenCL 的**工作组**。
- en: A CUDA grid is equivalent to an OpenCL **NDRange**.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CUDA 网格相当于 OpenCL 的**NDRange**。
- en: A CUDA streaming processor is equivalent to an OpenCL **compute unit**.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CUDA 流处理器相当于 OpenCL 的**计算单元**。
- en: In the kernel, we can get a work item's index with `get_local_id(dim)`, `get_group_id(dim)`,
    and `get_global_id(dim)`. The `global` qualifier in the function's arguments specifies
    that a variable corresponds to an object in global memory.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核中，我们可以使用 `get_local_id(dim)`、`get_group_id(dim)` 和 `get_global_id(dim)` 获取工作项的索引。函数参数中的
    `global` 限定符表示某个变量对应于全局内存中的对象。
- en: An OpenCL context is the environment within which work items execute. It includes
    devices with their memories and command queues. The command queue is a queue used
    by the host application to submit work to a device.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL 上下文是工作项执行的环境。它包括带有内存和命令队列的设备。命令队列是主机应用程序用来将工作提交到设备的队列。
- en: This program works the same on a CPU or a GPU, depending on the installed OpenCL
    SDK and on the available OpenCL context. If multiple contexts exist, PyOpenGL
    may ask the user to choose the device. The context may also be specified programmatically
    (see [http://documen.tician.de/pyopencl/runtime.html#pyopencl.Context](http://documen.tician.de/pyopencl/runtime.html#pyopencl.Context)).
    On a CPU, the code is parallelized and vectorized over multiple cores and with
    vector instructions such as SSE or AVX.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序在 CPU 或 GPU 上的表现相同，取决于安装的 OpenCL SDK 和可用的 OpenCL 上下文。如果存在多个上下文，PyOpenCL 可能会要求用户选择设备。上下文也可以通过编程方式指定（参见
    [http://documen.tician.de/pyopencl/runtime.html#pyopencl.Context](http://documen.tician.de/pyopencl/runtime.html#pyopencl.Context)）。在
    CPU 上，代码通过多核和使用 SSE 或 AVX 等向量指令进行并行化和向量化。
- en: There's more…
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: OpenCL is a relatively young standard but we should expect it to have more and
    more importance in the future. It is supported by the biggest companies in the
    GPU industry. It supports interoperability with OpenGL, the industry standard
    for real-time, hardware-accelerated computer graphics (maintained by the very
    same Khronos Group). It is on its way to being supported on mobile platforms (smartphones
    and tablets), and in the browser as well with **WebCL** (which is still a draft
    at the time of writing).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL 是一个相对年轻的标准，但我们应该预期它在未来会变得越来越重要。它得到了 GPU 行业内最大公司的支持。它支持与 OpenGL 的互操作性，OpenGL
    是实时硬件加速计算机图形的行业标准（由同样的 Khronos Group 维护）。它正在逐步支持移动平台（智能手机和平板电脑），并且在浏览器中也在逐步支持，使用**WebCL**（在撰写本文时仍为草案阶段）。
- en: 'Here are a few OpenCL resources:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些 OpenCL 资源：
- en: OpenCL tutorial available at [http://opencl.codeplex.com](http://opencl.codeplex.com)
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCL 教程可用：[http://opencl.codeplex.com](http://opencl.codeplex.com)
- en: Courses available at [http://developer.amd.com/partners/university-programs/opencl-university-course-listings/](http://developer.amd.com/partners/university-programs/opencl-university-course-listings/)
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的课程列表：[http://developer.amd.com/partners/university-programs/opencl-university-course-listings/](http://developer.amd.com/partners/university-programs/opencl-university-course-listings/)
- en: Books on OpenCL, at [http://streamcomputing.eu/knowledge/for-developers/books/](http://streamcomputing.eu/knowledge/for-developers/books/)
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于OpenCL的书籍，见 [http://streamcomputing.eu/knowledge/for-developers/books/](http://streamcomputing.eu/knowledge/for-developers/books/)
- en: See also
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Writing massively parallel code for NVIDIA graphics cards (GPUs) with CUDA*
    recipe
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为NVIDIA显卡（GPU）编写大规模并行代码（CUDA）*的配方'
- en: Distributing Python code across multiple cores with IPython
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IPython将Python代码分发到多个核心。
- en: Despite CPython's GIL, it is possible to execute several tasks in parallel on
    multi-core computers using multiple processes instead of multiple threads. Python
    offers a native **multiprocessing** module. IPython offers an even simpler interface
    that brings powerful parallel computing features in an interactive environment.
    We will describe this tool here.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管CPython的GIL存在，仍然可以通过使用多个进程而不是多个线程，在多核计算机上并行执行多个任务。Python提供了一个本地的**multiprocessing**模块。IPython提供了一个更简单的界面，带来了强大的并行计算功能，并且支持交互式环境。我们将在这里描述这个工具。
- en: How to do it…
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'First, we launch four IPython engines in separate processes. We have basically
    two options to do this:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在单独的进程中启动四个IPython引擎。我们基本上有两个选项来做到这一点：
- en: Executing `ipcluster start -n 4` in a system shell
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统shell中执行`ipcluster start -n 4`。
- en: Using the web interface provided in the IPython notebook's main page by clicking
    on the **Clusters** tab and launching four engines
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击 **Clusters** 标签并启动四个引擎，使用IPython笔记本主页提供的网页界面。
- en: 'Then, we create a client that will act as a proxy to the IPython engines. The
    client automatically detects the running engines:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个客户端，作为IPython引擎的代理。该客户端会自动检测正在运行的引擎：
- en: '[PRE64]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let''s check the number of running engines:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查一下正在运行的引擎数量：
- en: '[PRE65]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To run commands in parallel over the engines, we can use the `%px` line magic
    or the `%%px` cell magic:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在多个引擎上并行运行命令，我们可以使用`%px`行魔法命令或`%%px`单元格魔法命令：
- en: '[PRE66]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We can specify which engines to run the commands on using the `--targets` or
    `-t` option:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`--targets`或`-t`选项指定在哪些引擎上运行命令：
- en: '[PRE67]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'By default, the `%px` magic executes commands in **blocking mode**; the cell
    only returns when the commands have completed on all engines. It is possible to
    run non-blocking commands with the `--noblock` or `-a` option. In this case, the
    cell returns immediately, and the task''s status and results can be polled asynchronously
    from IPython''s interactive session:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`%px`魔法命令在**阻塞模式**下执行命令；只有当所有引擎上的命令完成时，单元格才会返回。也可以使用`--noblock`或`-a`选项运行非阻塞命令。在这种情况下，单元格会立即返回，任务的状态和结果可以从IPython的交互式会话中异步轮询：
- en: '[PRE68]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The previous command returned an `ASyncResult` instance that we can use to
    poll the task''s status:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的命令返回了一个`ASyncResult`实例，我们可以用它来轮询任务的状态：
- en: '[PRE69]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `%pxresult` blocks until the task finishes:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%pxresult`会阻塞，直到任务完成：'
- en: '[PRE70]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'IPython provides convenient functions for common use cases, such as a parallel
    `map` function:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPython提供了适用于常见用例的方便函数，例如并行的`map`函数：
- en: '[PRE71]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How it works…
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'There are several steps to distribute code across multiple cores:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码分发到多个核心的步骤如下：
- en: Launching several IPython **engines** (there is typically one process per core).
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动多个IPython **引擎**（通常每个核心对应一个进程）。
- en: Creating a `Client` that acts as a proxy to these engines.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个作为这些引擎代理的`Client`。
- en: Using the client to launch tasks on the engines and retrieve the results.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用客户端在引擎上启动任务并获取结果。
- en: Engines are Python processes that execute code on different computing units.
    They are very similar to IPython kernels.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎是执行代码的Python进程，它们运行在不同的计算单元上。它们与IPython内核非常相似。
- en: 'There are two main interfaces for accessing the engines:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要的接口用于访问引擎：
- en: With the **direct interface**, we access engines directly and explicitly with
    their identifiers.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**直接接口**，我们可以直接并显式地通过它们的标识符访问引擎。
- en: With the **load-balanced interface**, we access engines through an interface
    that automatically and dynamically assigns work to appropriate engines.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**负载均衡接口**，我们通过一个接口访问引擎，该接口会自动并动态地将任务分配到合适的引擎。
- en: We can also create custom interfaces for alternative styles of parallelism.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为替代的并行方式创建自定义接口。
- en: In this recipe, we used the direct interface; we addressed individual engines
    explicitly by specifying their identifiers in the `%px` magics.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了直接接口；通过在`%px`魔法命令中明确指定引擎的标识符，我们显式地访问了各个引擎。
- en: As we have seen in this recipe, tasks can be launched synchronously or asynchronously.
    The `%px*` magic commands are particularly convenient in the notebook, as they
    let us work seamlessly on multiple engines in parallel.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这个示例中所看到的，任务可以同步或异步启动。`%px*` 魔法命令在笔记本中尤其方便，因为它们让我们能够在多个引擎上无缝并行工作。
- en: There's more…
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The parallel computing capabilities of IPython offer an easy way to launch independent
    jobs in parallel over multiple cores. A more advanced use case is when jobs have
    **dependencies**.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 的并行计算功能为我们提供了一种简单的方式，可以在多个核心上并行启动独立的任务。一个更高级的用例是任务之间有 **依赖** 的情况。
- en: Dependent parallel tasks
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖并行任务
- en: 'There are two types of dependencies:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖有两种类型：
- en: '**Functional dependency**: It determines whether a given task can execute on
    a given engine, according to the engine''s operating system, the presence or absence
    of specific Python modules, or other conditions. IPython provides a `@require`
    decorator for functions that need specific Python modules to run on the engines.
    Another decorator is `@depend`; it lets us define arbitrary conditions implemented
    in a Python function returning `True` or `False`.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能依赖**：它决定了给定任务是否可以在特定引擎上执行，依据引擎的操作系统、特定 Python 模块的存在与否或其他条件。IPython 提供了一个
    `@require` 装饰器，用于那些需要特定 Python 模块才能在引擎上运行的函数。另一个装饰器是 `@depend`，它让我们可以定义任意的条件，这些条件在
    Python 函数中实现，并返回 `True` 或 `False`。'
- en: '**Graph dependency**: It determines whether a given task can execute at a given
    time on a given engine. We may require a task to run only after one or several
    other tasks have finished. Additionally, we can impose this condition within any
    individual engine; an engine may need to execute a specific set of tasks before
    executing our task. For example, here is how to require tasks B and C (with asynchronous
    results `arB` and `arC`) to finish before task A starts:'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图依赖**：它决定了给定任务是否可以在给定时间、特定引擎上执行。我们可能要求某个任务仅在一个或多个其他任务完成后才能执行。此外，我们可以在任何单独的引擎中强制执行这个条件；某个引擎可能需要先执行一组特定任务，才会执行我们的任务。例如，下面是如何要求任务
    B 和 C（它们的异步结果分别为 `arB` 和 `arC`）在任务 A 启动前完成：'
- en: '[PRE72]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: IPython provides options to specify whether all or any of the dependencies should
    be met for the task to run. Additionally, we can specify whether success- and/or
    failure-dependent tasks should be considered as met or not.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 提供了选项，指定任务运行所需的依赖是否全部或部分满足。此外，我们还可以指定是否应将依赖于成功和/或失败的任务视为满足条件。
- en: When a task's dependency is unmet, the scheduler reassigns it to one engine,
    then to another engine, and so on until an appropriate engine is found. If the
    dependency cannot be met on any engine, an `ImpossibleDependency` error is raised
    for the task.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个任务的依赖未满足时，调度器会将任务重新分配到一个引擎，再到另一个引擎，依此类推，直到找到合适的引擎。如果无法在任何引擎上满足依赖条件，任务将引发
    `ImpossibleDependency` 错误。
- en: 'Passing data between dependent tasks is not particularly easy with IPython.parallel.
    A first possibility is to use blocking calls in the interactive session; wait
    for tasks to finish, retrieve the results, and send them back to the next tasks.
    Another possibility is to share data between engines via the filesystem, but this
    solution does not work well on multiple computers. An alternate solution is described
    at: [http://nbviewer.ipython.org/gist/minrk/11415238](http://nbviewer.ipython.org/gist/minrk/11415238).'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPython.parallel 中，将数据传递给依赖任务并不特别容易。一种可能性是在交互式会话中使用阻塞调用；等待任务完成，获取结果并将其发送回下一个任务。另一种可能性是通过文件系统在引擎之间共享数据，但这种方案在多个计算机上效果不好。一个替代方案可以参考：[http://nbviewer.ipython.org/gist/minrk/11415238](http://nbviewer.ipython.org/gist/minrk/11415238)。
- en: Alternative parallel computing solutions
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代的并行计算解决方案
- en: Besides IPython, there are numerous alternative parallel computing frameworks
    in Python, including **ParallelPython**, **joblib**, and many others.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 IPython，还有许多其他的 Python 并行计算框架，包括 **ParallelPython**、**joblib** 等等。
- en: 'There are also third-party (often commercial) services that provide Python-based
    clouds, such as **PythonAnywhere** or **Wakari**. They are generally used in two
    ways:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些第三方（通常是商业）服务提供基于 Python 的云服务，如 **PythonAnywhere** 或 **Wakari**。它们通常有两种使用方式：
- en: '**Distributing a large number of computational tasks across multiple nodes
    in parallel**: Instead of being limited to a few cores with one or several local
    computers, we can use hundreds or thousands of servers in parallel without worrying
    about the maintenance of the whole infrastructure (it is handled by the company).'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将大量计算任务分配到多个节点并行执行**：我们可以使用数百或数千台服务器进行并行计算，而无需担心整个基础设施的维护（由公司负责处理）。'
- en: '**Hosting Python applications online, typically with a web interface**: For
    example, with Wakari, IPython notebooks can run on the cloud. An interesting use
    case is teaching, where students can instantaneously use IPython from a web browser
    connected to the Internet without installing anything locally.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线托管Python应用程序，通常带有Web界面**：例如，使用Wakari，IPython笔记本可以在云端运行。一个有趣的应用场景是教学，学生可以通过连接到互联网的Web浏览器即时使用IPython，而无需在本地安装任何软件。'
- en: References
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Here are a few references about IPython.parallel:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于IPython.parallel的一些参考资料：
- en: Documentation of IPython.parallel available at [http://ipython.org/ipython-doc/dev/parallel/](http://ipython.org/ipython-doc/dev/parallel/)
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPython.parallel文档，见[http://ipython.org/ipython-doc/dev/parallel/](http://ipython.org/ipython-doc/dev/parallel/)
- en: IPython parallel tutorial by the IPython developers available at [http://nbviewer.ipython.org/github/minrk/IPython-parallel-tutorial/blob/master/Index.ipynb](http://nbviewer.ipython.org/github/minrk/IPython-parallel-tutorial/blob/master/Index.ipynb)
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPython开发者提供的IPython并行教程，见[http://nbviewer.ipython.org/github/minrk/IPython-parallel-tutorial/blob/master/Index.ipynb](http://nbviewer.ipython.org/github/minrk/IPython-parallel-tutorial/blob/master/Index.ipynb)
- en: Dependencies in IPython.parallel, explained at [http://ipython.org/ipython-doc/dev/parallel/parallel_task.html#dependencies](http://ipython.org/ipython-doc/dev/parallel/parallel_task.html#dependencies)
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPython.parallel中的依赖关系解释，见[http://ipython.org/ipython-doc/dev/parallel/parallel_task.html#dependencies](http://ipython.org/ipython-doc/dev/parallel/parallel_task.html#dependencies)
- en: DAG dependencies, described at [http://ipython.org/ipython-doc/dev/parallel/dag_dependencies.html](http://ipython.org/ipython-doc/dev/parallel/dag_dependencies.html)
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DAG依赖关系的描述，见[http://ipython.org/ipython-doc/dev/parallel/dag_dependencies.html](http://ipython.org/ipython-doc/dev/parallel/dag_dependencies.html)
- en: Examples of advanced techniques with IPython.parallel available at [http://github.com/ipython/ipython/tree/master/examples/Parallel%20Computing](http://github.com/ipython/ipython/tree/master/examples/Parallel%20Computing)
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关IPython.parallel的高级技巧示例，见[http://github.com/ipython/ipython/tree/master/examples/Parallel%20Computing](http://github.com/ipython/ipython/tree/master/examples/Parallel%20Computing)
- en: 'Here are some references about alternative parallel computing solutions in
    Python:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于Python中替代并行计算解决方案的一些参考资料：
- en: Parallel Python available at [http://www.parallelpython.com](http://www.parallelpython.com)
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Parallel Python，见[http://www.parallelpython.com](http://www.parallelpython.com)
- en: Joblib available at [http://pythonhosted.org/joblib/parallel.html](http://pythonhosted.org/joblib/parallel.html)
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Joblib，见[http://pythonhosted.org/joblib/parallel.html](http://pythonhosted.org/joblib/parallel.html)
- en: List of parallel computing packages available at [http://wiki.python.org/moin/ParallelProcessing](http://wiki.python.org/moin/ParallelProcessing)
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的并行计算包列表，见[http://wiki.python.org/moin/ParallelProcessing](http://wiki.python.org/moin/ParallelProcessing)
- en: Python Anywhere available at [http://www.pythonanywhere.com](http://www.pythonanywhere.com)
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Anywhere，见[http://www.pythonanywhere.com](http://www.pythonanywhere.com)
- en: Wakari available at [http://wakari.io](http://wakari.io)
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wakari，见[http://wakari.io](http://wakari.io)
- en: IPCluster on Wakari described at [http://continuum.io/blog/ipcluster-wakari-intro](http://continuum.io/blog/ipcluster-wakari-intro)
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Wakari上使用IPCluster的介绍，见[http://continuum.io/blog/ipcluster-wakari-intro](http://continuum.io/blog/ipcluster-wakari-intro)
- en: Teaching with Wakari described at [http://continuum.io/blog/teaching-with-wakari](http://continuum.io/blog/teaching-with-wakari)
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Wakari进行教学的介绍，见[http://continuum.io/blog/teaching-with-wakari](http://continuum.io/blog/teaching-with-wakari)
- en: See also
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Interacting with asynchronous parallel tasks in IPython* recipe
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在IPython中与异步并行任务交互*的示例'
- en: The *Parallelizing code with MPI in IPython* recipe
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在IPython中使用MPI并行化代码*的示例'
- en: Interacting with asynchronous parallel tasks in IPython
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在IPython中与异步并行任务交互
- en: In this recipe, we will show how to interact with asynchronous tasks running
    in parallel with IPython.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将展示如何与在IPython中并行运行的异步任务交互。
- en: Getting ready
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to start the IPython engines (see the previous recipe). The simplest
    option is to launch them from the **Clusters** tab in the notebook dashboard.
    In this recipe, we use four engines.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要启动 IPython 引擎（参见前面的步骤）。最简单的选项是从笔记本仪表板的 **Clusters** 标签页启动它们。在这个步骤中，我们使用了四个引擎。
- en: How to do it…
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s import a few modules:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入一些模块：
- en: '[PRE73]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We create a `Client`:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个 `Client`：
- en: '[PRE74]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, we create a load-balanced view on the IPython engines:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个基于 IPython 引擎的负载均衡视图：
- en: '[PRE75]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We define a simple function for our parallel tasks:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为并行任务定义一个简单的函数：
- en: '[PRE76]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We will run this function on 100 integer numbers in parallel:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在 100 个整数上并行运行此函数：
- en: '[PRE77]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We execute `f()` on our list `numbers` in parallel across all of our engines,
    using `map_async()`. This function immediately returns an `AsyncResult` object
    that allows us to interactively retrieve information about the tasks:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `map_async()` 在所有引擎上并行执行 `f()` 函数，作用对象是我们的 `numbers` 列表。该函数会立即返回一个 `AsyncResult`
    对象，允许我们交互式地检索任务的相关信息：
- en: '[PRE78]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This object has a `metadata` attribute: a list of dictionaries for all engines.
    We can get the date of submission and completion, the status, the standard output
    and error, and other information:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该对象有一个 `metadata` 属性：所有引擎的字典列表。我们可以获取提交和完成日期、状态、标准输出和错误以及其他信息：
- en: '[PRE79]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Iterating over the `AsyncResult` instance works normally; the iteration progresses
    in real-time while the tasks are being completed:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历 `AsyncResult` 实例时工作正常；迭代实时进行，任务在完成时进展：
- en: '[PRE80]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, we create a simple progress bar for our asynchronous tasks. The idea is
    to create a loop polling for the tasks'' status at every second. An `IntProgressWidget`
    widget is updated in real-time and shows the progress of the tasks:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们为异步任务创建一个简单的进度条。其思路是创建一个循环，每秒轮询任务状态。`IntProgressWidget` 小部件实时更新，显示任务的进度：
- en: '[PRE81]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The progress bar is shown in the following screenshot:'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了进度条：
- en: '![How to do it…](img/4818OS_05_07.jpg)'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/4818OS_05_07.jpg)'
- en: 'Finally, it is easy to debug a parallel task on an engine. We can launch a
    Qt client on the remote kernel by calling `%qtconsole` within a `%%px` cell magic:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调试引擎上的并行任务非常容易。我们可以通过在 `%%px` 单元魔法中调用 `%qtconsole` 来启动远程内核上的 Qt 客户端：
- en: '[PRE82]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The Qt console allows us to inspect the remote namespace for debugging or analysis
    purposes, as shown in the following screenshot:'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qt 控制台允许我们检查远程命名空间进行调试或分析，如下图所示：
- en: '![How to do it…](img/4818OS_05_08.jpg)'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/4818OS_05_08.jpg)'
- en: Qt console for debugging an IPython engine
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于调试 IPython 引擎的 Qt 控制台
- en: How it works…
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`AsyncResult` instances are returned by asynchronous parallel functions. They
    implement several useful attributes and methods, notably:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncResult` 实例由异步并行函数返回。它们实现了几个有用的属性和方法，特别是：'
- en: '`elapsed`: Elapsed time since submission'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elapsed`: 自提交以来的经过时间'
- en: '`progress`: Number of tasks that have competed so far'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`progress`: 到目前为止已完成的任务数量'
- en: '`serial_time`: Sum of the computation time of all of the tasks done in parallel'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serial_time`: 所有并行任务计算时间的总和'
- en: '`metadata`: Dictionary with further information about the task'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`: 包含任务更多信息的字典'
- en: '`ready()`: Returns whether the call has finished'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ready()`: 返回调用是否已完成'
- en: '`successful()`: Returns whether the call has completed without raising an exception
    (an exception is raised if the task has not completed yet)'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`successful()`: 返回调用是否没有抛出异常（如果任务尚未完成则抛出异常）'
- en: '`wait()`: Blocks until the tasks have completed (there is an optional timeout
    argument)'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait()`: 阻塞直到任务完成（有一个可选的超时参数）'
- en: '`get()`: Blocks until the tasks have completed and returns the result (there
    is an optional timeout argument)'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 阻塞直到任务完成并返回结果（有一个可选的超时参数）'
- en: There's more…
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Here are a few references:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些参考资料：
- en: Documentation of the AsyncResult class available at [http://ipython.org/ipython-doc/dev/parallel/asyncresult.html](http://ipython.org/ipython-doc/dev/parallel/asyncresult.html)
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncResult` 类的文档请参阅 [http://ipython.org/ipython-doc/dev/parallel/asyncresult.html](http://ipython.org/ipython-doc/dev/parallel/asyncresult.html)'
- en: Documentation of the task interface available at [http://ipython.org/ipython-doc/dev/parallel/parallel_task.html](http://ipython.org/ipython-doc/dev/parallel/parallel_task.html)
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务接口的文档请参阅 [http://ipython.org/ipython-doc/dev/parallel/parallel_task.html](http://ipython.org/ipython-doc/dev/parallel/parallel_task.html)
- en: Printing engines output in real-time, demonstrated at [http://github.com/ipython/ipython/blob/master/examples/Parallel%20Computing/iopubwatcher.py](http://github.com/ipython/ipython/blob/master/examples/Parallel%20Computing/iopubwatcher.py)
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时打印引擎输出，示例代码可在[http://github.com/ipython/ipython/blob/master/examples/Parallel%20Computing/iopubwatcher.py](http://github.com/ipython/ipython/blob/master/examples/Parallel%20Computing/iopubwatcher.py)中找到
- en: See also
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Distributing Python code across multiple cores with IPython* recipe
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用IPython跨多个核心分发Python代码*的配方'
- en: The *Parallelizing code with MPI in IPython* recipe
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用MPI在IPython中并行化代码*的配方'
- en: Parallelizing code with MPI in IPython
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MPI在IPython中并行化代码
- en: '**Message Passing Interface** (**MPI**) is a standardized communication protocol
    for parallel systems. It is used in many parallel computing applications to exchange
    data between nodes. MPI has a high barrier to entry, but it is very efficient
    and powerful.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息传递接口**（**MPI**）是一个用于并行系统的标准化通信协议。它在许多并行计算应用中被用来在节点之间交换数据。MPI的入门门槛较高，但它非常高效且功能强大。'
- en: IPython's parallel computing system has been designed from the ground up to
    work with MPI. If you are new to MPI, it is a good idea to start using it from
    IPython. If you are an experienced MPI user, you will find that IPython integrates
    seamlessly with your parallel application.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: IPython的并行计算系统从底层设计时就考虑到了与MPI的兼容。如果你是MPI的新手，从IPython开始使用它是个不错的选择。如果你是有经验的MPI用户，你会发现IPython与你的并行应用无缝集成。
- en: In this recipe, we will see how to use MPI with IPython through a very simple
    example.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看到如何通过一个非常简单的例子，使用MPI与IPython结合。
- en: Getting ready
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use MPI with IPython, you need:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 要在IPython中使用MPI，你需要：
- en: A standard MPI implementation such as OpenMPI available at [http://www.open-mpi.org](http://www.open-mpi.org)
    or MPICH available at [http://www.mpich.org](http://www.mpich.org)
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标准的MPI实现，例如[OpenMPI](http://www.open-mpi.org)或[MPICH](http://www.mpich.org)
- en: The mpi4py package available at [http://mpi4py.scipy.org](http://mpi4py.scipy.org)
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mpi4py包可以在[http://mpi4py.scipy.org](http://mpi4py.scipy.org)找到
- en: 'For example, here are the commands to install MPI for IPython on Ubuntu and
    Anaconda:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是Ubuntu和Anaconda上安装MPI的命令：
- en: '[PRE83]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You can also do `pip install mpi4py` for mpi4py. MPI can also be used on Windows.
    The website of *Python Tools for Visual Studio* available at [http://pytools.codeplex.com](http://pytools.codeplex.com)
    contains the instructions to do this.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`pip install mpi4py`来安装mpi4py。MPI也可以在Windows上使用。可以参考*Python Tools for
    Visual Studio*的网站，网址为[http://pytools.codeplex.com](http://pytools.codeplex.com)，该网站提供了相关的安装指导。
- en: How to do it…
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'We first need to create a MPI profile with:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要创建一个MPI配置文件，命令为：
- en: '[PRE84]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Then, we open `~/.ipython/profile_mpi/ipcluster_config.py` and add the line
    `c.IPClusterEngines.engine_launcher_class = 'MPI'`.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打开`~/.ipython/profile_mpi/ipcluster_config.py`文件并添加一行：`c.IPClusterEngines.engine_launcher_class
    = 'MPI'`。
- en: 'Once the MPI profile has been created and configured, we can launch the engines
    by typing in a terminal: `ipcluster start -n 2 --engines MPI --profile=mpi`.'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦MPI配置文件创建并配置好，我们可以通过在终端中输入：`ipcluster start -n 2 --engines MPI --profile=mpi`来启动引擎。
- en: 'Now, to actually use the engines, we create a client in the notebook:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了真正使用引擎，我们在笔记本中创建一个客户端：
- en: '[PRE85]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let''s create a view on all engines:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在所有引擎上创建一个视图：
- en: '[PRE86]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In this example, we compute the sum of all integers between 0 and 15 in parallel
    over two cores. We first distribute the array with the 16 values across the engines
    (each engine gets a subarray):'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过两个核心并行计算0到15之间所有整数的总和。我们首先将包含16个值的数组分配给各个引擎（每个引擎获取一个子数组）：
- en: '[PRE87]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We compute the total sum in parallel using MPI''s `allreduce()` function. Every
    node makes the same computation and returns the same result:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用MPI的`allreduce()`函数并行计算总和。每个节点执行相同的计算并返回相同的结果：
- en: '[PRE88]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Tip
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you get a different result, it means that the engines were not actually started
    with MPI (see [http://stackoverflow.com/a/20159018/1595060](http://stackoverflow.com/a/20159018/1595060)).
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到了不同的结果，意味着引擎实际上并没有使用MPI启动（请参见[http://stackoverflow.com/a/20159018/1595060](http://stackoverflow.com/a/20159018/1595060)）。
- en: How it works…
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'In this example, each node:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个节点：
- en: Receives a subset of the integers
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收整数的一个子集
- en: Computes the local sum of those integers
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算这些整数的局部和
- en: Sends this local sum to all other engines
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这个局部和发送到所有其他引擎
- en: Receives the local sum of the other engines
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收其他引擎的局部和
- en: Computes the total sum of those local sums
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算这些局部和的总和
- en: This is how `allreduce()` works in MPI; the principle is to **scatter** data
    across engines first, then to **reduce** the local computations through a global
    operator (here, `MPI.SUM`).
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`allreduce()`在MPI中的工作原理；其原理是首先**分发**数据到各个引擎，然后通过一个全局操作符（此处为`MPI.SUM`）**减少**本地计算。
- en: IPython's direct interface also supports the scatter/gather paradigm natively,
    without resorting to MPI. However, these operations can only be launched from
    the interactive session, not from the engines themselves.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: IPython的直接接口也本地支持scatter/gather范式，而不需要使用MPI。然而，这些操作只能在交互式会话中启动，而不能在引擎本身启动。
- en: 'There are many other parallel computing paradigms in MPI. You can find more
    information here:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: MPI中还有许多其他的并行计算范式。你可以在这里找到更多信息：
- en: MPI tutorials by Wes Kendall available at [http://mpitutorial.com](http://mpitutorial.com)
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wes Kendall的MPI教程，可以在[http://mpitutorial.com](http://mpitutorial.com)找到
- en: MPI tutorials by Blaise Barney, Lawrence Livermore National Laboratory, available
    at [http://computing.llnl.gov/tutorials/mpi/](http://computing.llnl.gov/tutorials/mpi/)
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blaise Barney（劳伦斯·利弗莫尔国家实验室）的MPI教程，可以在[http://computing.llnl.gov/tutorials/mpi/](http://computing.llnl.gov/tutorials/mpi/)找到
- en: See also
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Distributing Python code across multiple cores with IPython* recipe
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用IPython将Python代码分布到多个核心*的食谱'
- en: The *Interacting with asynchronous parallel tasks in IPython* recipe
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在IPython中与异步并行任务交互*的食谱'
- en: Trying the Julia language in the notebook
  id: totrans-580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在笔记本中尝试Julia语言
- en: Julia ([http://julialang.org](http://julialang.org)) is a young, high-level,
    dynamic language for high-performance numerical computing. The first version was
    released in 2012 after three years of development at MIT. Julia borrows ideas
    from Python, R, MATLAB, Ruby, Lisp, C, and other languages. Its major strength
    is to combine the expressivity and ease of use of high-level, dynamic languages
    with the speed of C (almost). This is achieved via an LLVM-based Just-In-Time
    (JIT) compiler that targets machine code for x86-64 architectures.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: Julia（[http://julialang.org](http://julialang.org)）是一种年轻的高层次动态语言，专为高性能数值计算而设计。它的第一个版本在2012年发布，在MIT进行了三年的开发。Julia借鉴了Python、R、MATLAB、Ruby、Lisp、C等语言的思想。它的主要优势是将高层次动态语言的表现力和易用性与C语言（几乎）的速度相结合。这是通过基于LLVM的即时编译器（JIT）实现的，目标是x86-64架构的机器代码。
- en: In this recipe, we will try Julia in the IPython notebook using the **IJulia**
    package available at [http://github.com/JuliaLang/IJulia.jl](http://github.com/JuliaLang/IJulia.jl).
    We will also show how to use Python packages (such as NumPy and matplotlib) from
    Julia. Specifically, we will compute and display a Julia set.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用**IJulia**包在IPython笔记本中尝试Julia，IJulia包可以在[http://github.com/JuliaLang/IJulia.jl](http://github.com/JuliaLang/IJulia.jl)找到。我们还将展示如何从Julia使用Python包（如NumPy和matplotlib）。具体来说，我们将计算并显示一个Julia集。
- en: This recipe is inspired by a Julia tutorial given by David P. Sanders at the
    SciPy 2014 conference ([http://nbviewer.ipython.org/github/dpsanders/scipy_2014_julia/tree/master/](http://nbviewer.ipython.org/github/dpsanders/scipy_2014_julia/tree/master/)).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱灵感来自David P. Sanders在SciPy 2014会议上提供的Julia教程（[http://nbviewer.ipython.org/github/dpsanders/scipy_2014_julia/tree/master/](http://nbviewer.ipython.org/github/dpsanders/scipy_2014_julia/tree/master/)）。
- en: Getting ready
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You first need to install Julia. You will find packages for Windows, Mac OS
    X, and Linux on Julia's website at [http://julialang.org/downloads/](http://julialang.org/downloads/).
    On Ubuntu, you can type `sudo apt-get install julia` in a terminal. For IJulia,
    you also need a C++ compiler. On Ubuntu, you can type `sudo apt-get install build-essential`.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装Julia。你可以在Julia官网[http://julialang.org/downloads/](http://julialang.org/downloads/)上找到适用于Windows、Mac
    OS X和Linux的安装包。在Ubuntu上，你可以在终端输入`sudo apt-get install julia`。对于IJulia，你还需要一个C++编译器。在Ubuntu上，你可以输入`sudo
    apt-get install build-essential`。
- en: Then, open a Julia terminal with the `julia` command, and install IJulia by
    typing `Pkg.add("IJulia")` in the Julia terminal. This package should also create
    a `julia` profile in your IPython installation.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`julia`命令打开一个Julia终端，并在Julia终端中输入`Pkg.add("IJulia")`来安装IJulia。这个包还会在你的IPython安装中创建一个`julia`配置文件。
- en: Finally, to launch a Julia notebook, run `ipython notebook --profile=julia`
    in a terminal. You'll recognize the dashboard of the IPython notebook. The only
    difference is that the Julia language is used in the notebook instead of Python.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要启动Julia笔记本，请在终端中运行`ipython notebook --profile=julia`。你将看到IPython笔记本的仪表板。唯一的区别是，在笔记本中使用的是Julia语言，而不是Python。
- en: This recipe has been tested on Ubuntu 14.04 with Julia 0.2.1.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱已在Ubuntu 14.04和Julia 0.2.1版本上进行测试。
- en: How to do it…
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'We can''t avoid the customary *Hello World* example. The `println()` function
    displays a string and adds a line break at the end:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们无法避免传统的*Hello World*示例。`println()`函数用于显示一个字符串，并在末尾添加换行符：
- en: '[PRE89]'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We create a polymorphic function, `f`, that computes the expression `z*z+c`.
    We will evaluate this function on arrays, so we use element-wise operators with
    a dot (`.`) prefix:'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个多态函数`f`，计算表达式`z*z+c`。我们将在数组上评估这个函数，因此我们使用带点（`.`）前缀的逐元素操作符：
- en: '[PRE90]'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Let's evaluate `f` on scalar complex numbers (the imaginary number *i* is `1im`).
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在标量复数上评估`f`（虚数* i *是`1im`）。
- en: '[PRE91]'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, we create a (2, 2) matrix. Components are separated by a space and rows
    are separated by a semicolon (`;`). The type of this `Array` is automatically
    inferred from its components. The `Array` type is a built-in data type in Julia,
    similar, but not identical, to NumPy''s `ndarray` type:'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个(2, 2)矩阵。组件之间用空格隔开，行之间用分号（`;`）隔开。这个`Array`的类型会根据其组件自动推断出来。`Array`类型是Julia中的内建数据类型，类似但不完全等同于NumPy的`ndarray`类型：
- en: '[PRE92]'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can index arrays with brackets `[]`. A notable difference with Python is
    that indexing starts from 1 instead of 0\. MATLAB has the same convention. Furthermore,
    the keyword `end` refers to the last item in that dimension:'
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用方括号`[]`对数组进行索引。与Python的一个显著不同之处在于，索引是从1开始的，而不是0。MATLAB也有相同的惯例。此外，关键字`end`表示该维度中的最后一个元素：
- en: '[PRE93]'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We can evaluate `f` on the matrix `z` and a scalar `c` (polymorphism):'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在矩阵`z`和标量`c`（多态）上评估`f`：
- en: '[PRE94]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, we create a function, `julia`, that computes a Julia set. Optional named
    arguments are separated from positional arguments by a semicolon (`;`). Julia''s
    syntax for flow control is close to that of Python''s, except that colons are
    dropped, indentation doesn''t count, and block `end` keywords are mandatory:'
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个函数`julia`，用于计算Julia集。可选的命名参数与位置参数通过分号（`;`）分隔。Julia的流程控制语法接近Python，但省略了冒号，缩进不重要，并且`end`关键字是必需的：
- en: '[PRE95]'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We can use Python packages from Julia. First, we have to install the `PyCall`
    package by using Julia''s built-in package manager (`Pkg`). Once the package is
    installed, we can use it in the interactive session with `using PyCall`:'
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在Julia中使用Python包。首先，我们需要通过Julia的内置包管理器（`Pkg`）安装`PyCall`包。安装完成后，我们可以通过`using
    PyCall`在交互式会话中使用它：
- en: '[PRE96]'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We can import Python packages with the `@pyimport` **macro** (a metaprogramming
    feature in Julia). This macro is the equivalent of Python''s `import` command:'
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`@pyimport` **宏**（Julia中的元编程特性）导入Python包。这个宏相当于Python中的`import`命令：
- en: '[PRE97]'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The `np` namespace is now available in the Julia interactive session. NumPy
    arrays are automatically converted to Julia `Array` objects:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`np`命名空间现在在Julia的交互式会话中可用。NumPy数组会自动转换为Julia的`Array`对象：'
- en: '[PRE98]'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We can use list comprehensions to evaluate the function `julia` on many arguments:'
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用列表推导式来在多个参数上评估函数`julia`：
- en: '[PRE99]'
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Let''s try the Gadfly plotting package. This library offers a high-level plotting
    interface inspired by Dr. Leland Wilkinson''s textbook *The Grammar of Graphics*.
    In the notebook, plots are interactive thanks to the **D3.js** library:'
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一下Gadfly绘图包。这个库提供了一个高级绘图接口，灵感来源于Leland Wilkinson博士的教材*《图形语法》*。在笔记本中，借助**D3.js**库，图表是交互式的：
- en: '[PRE100]'
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Here is a screenshot:'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个截图：
- en: '![How to do it…](img/4818OS_05_09.jpg)'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现…](img/4818OS_05_09.jpg)'
- en: A Gadfly plot in the IPython notebook with Julia
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在IPython笔记本中用Julia绘制的Gadfly图：
- en: 'Now, we compute a Julia set by using two nested loops. In general, and unlike
    Python, there is no significant performance penalty in using `for` loops instead
    of vectorized operations. High-performance code can be written either with vectorized
    operations or `for` loops:'
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过使用两个嵌套的循环来计算Julia集。通常，与Python不同，使用`for`循环而不是向量化操作并不会显著影响性能。高性能的代码可以通过向量化操作或`for`循环来编写：
- en: '[PRE101]'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Finally, we use the `PyPlot` package to draw matplotlib figures in Julia:'
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`PyPlot`包来绘制Julia中的matplotlib图形：
- en: '[PRE102]'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '![How to do it…](img/4818OS_05_10.jpg)'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现…](img/4818OS_05_10.jpg)'
- en: How it works…
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Languages used to be either low-level, difficult to use, but fast (such as C);
    or high-level, easy to use, but slow (such as Python). In Python, solutions to
    this problem include NumPy and Cython, among others.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，编程语言通常是低级的，使用起来困难但运行快速（例如C）；或者是高级的，使用方便但运行较慢（例如Python）。在Python中，解决这个问题的方法包括NumPy和Cython等。
- en: Julia developers chose to create a new high-level but fast language, bringing
    the best of both worlds together. This is essentially achieved through modern
    Just-In-Time compilation techniques implemented with LLVM.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 开发者选择创建一种新的高层次但快速的语言，将两者的优点结合在一起。这本质上通过使用 LLVM 实现的现代即时编译技术来实现。
- en: Julia dynamically parses code and generates low-level code in the LLVM Intermediate
    Representation. This representation features a language-independent instruction
    set that is then compiled to machine code. Code written with explicit loops is
    directly compiled to machine code. This explains why the performance-motivated
    vectorization of code is generally not required with Julia.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 动态解析代码并生成低级代码，采用 LLVM 中间表示。这种表示具有独立于语言的指令集，然后编译为机器码。使用显式循环编写的代码会直接编译为机器码。这也解释了为什么在
    Julia 中通常不需要进行性能驱动的向量化代码。
- en: There's more…
  id: totrans-626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Strengths of Julia include:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的优势包括：
- en: A powerful and flexible dynamic type system based on multiple dispatch for parametric
    polymorphism
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于多重分派的强大灵活的动态类型系统，用于参数化多态性
- en: Facilities for metaprogramming
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持元编程的功能
- en: A simple interface for calling C, FORTRAN, or Python code from Julia
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的接口，用于从 Julia 调用 C、FORTRAN 或 Python 代码
- en: Built-in support for fine-grained parallel and distributed computing
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内建对精细粒度并行和分布式计算的支持
- en: A built-in multidimensional array data type and numerical computing library
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内建的多维数组数据类型和数值计算库
- en: A built-in package manager based on Git
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Git 的内建包管理器
- en: External packages for data analysis such as DataFrames (equivalent of pandas)
    and Gadfly (statistical plotting library)
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于数据分析的外部包，如 DataFrames（相当于 pandas）和 Gadfly（统计绘图库）
- en: Integration in the IPython notebook
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 IPython notebook 中的集成
- en: What are the strengths of Python over Julia? At the time of this writing, Julia
    is much younger and less mature than Python and SciPy. Therefore, there are fewer
    packages and less documentation in Julia than in Python. The syntax of the Julia
    language is still changing. Additionally, Python is much more commonly found in
    production environments than Julia. Thus, bringing numerical computing code to
    a production environment is easier when the code is in Python.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: Python 相对于 Julia 的优势是什么？截至本文撰写时，Julia 比 Python 和 SciPy 更年轻且不够成熟。因此，Julia 的包和文档比
    Python 少。Julia 语言的语法仍在变化。此外，Python 在生产环境中的使用比 Julia 更为普遍。因此，将数值计算代码引入生产环境时，Python
    代码会更容易。
- en: That being said, the Julia ecosystem and its community are growing fast. We
    can reasonably expect Julia to become increasingly popular in the future. Also,
    since both languages can be used in the IPython notebook, we don't necessarily
    have to *choose* between Python and Julia. We can call Python code and use Python
    modules from Julia and vice versa.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Julia 生态系统和社区正在快速增长。我们可以合理预期，Julia 在未来将变得越来越受欢迎。而且，既然两种语言都可以在 IPython notebook
    中使用，我们不必在 Python 和 Julia 之间*选择*。我们可以从 Julia 调用 Python 代码并使用 Python 模块，反之亦然。
- en: We have only scratched the surface of the Julia language in this recipe. Topics
    of interest we couldn't cover in details here include Julia's type system, the
    metaprogramming features, the support for parallel computing, and the package
    manager, among others.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这篇食谱中仅仅触及了 Julia 语言的表面。我们未能详细覆盖的一些有趣话题包括 Julia 的类型系统、元编程功能、并行计算支持和包管理器等。
- en: 'Here are some references:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: The Julia language on Wikipedia available at [http://en.wikipedia.org/wiki/Julia_%28programming_language%29](http://en.wikipedia.org/wiki/Julia_%28programming_language%29)
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia 上的 Julia 语言条目可在 [http://en.wikipedia.org/wiki/Julia_%28programming_language%29](http://en.wikipedia.org/wiki/Julia_%28programming_language%29)
    查阅
- en: Official documentation of Julia available at [http://docs.julialang.org/en/latest/](http://docs.julialang.org/en/latest/)
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 官方文档可在 [http://docs.julialang.org/en/latest/](http://docs.julialang.org/en/latest/)
    阅读
- en: The *Why We Created Julia* blog post available at [http://julialang.org/blog/2012/02/why-we-created-julia/](http://julialang.org/blog/2012/02/why-we-created-julia/)
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们为何创建 Julia* 博客文章，可在 [http://julialang.org/blog/2012/02/why-we-created-julia/](http://julialang.org/blog/2012/02/why-we-created-julia/)
    阅读'
- en: PyCall.jl for calling Python from Julia available at [http://github.com/stevengj/PyCall.jl](http://github.com/stevengj/PyCall.jl)
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于从 Julia 调用 Python 的 PyCall.jl，可在 [http://github.com/stevengj/PyCall.jl](http://github.com/stevengj/PyCall.jl)
    获取
- en: PyPlot.jl for using matplotlib in Julia available at [http://github.com/stevengj/PyPlot.jl](http://github.com/stevengj/PyPlot.jl)
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在 Julia 中使用 matplotlib 的 PyPlot.jl 可在 [http://github.com/stevengj/PyPlot.jl](http://github.com/stevengj/PyPlot.jl)
    获取
- en: Gadfly.jl, a Julia plotting library, available at [http://dcjones.github.io/Gadfly.jl/](http://dcjones.github.io/Gadfly.jl/)
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gadfly.jl，一个用于绘图的Julia库，访问地址：[http://dcjones.github.io/Gadfly.jl/](http://dcjones.github.io/Gadfly.jl/)
- en: DataFrames.jl, an equivalent of pandas for Julia, available at [http://juliastats.github.io/DataFrames.jl/](http://juliastats.github.io/DataFrames.jl/)
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataFrames.jl，Julia中类似pandas的库，访问地址：[http://juliastats.github.io/DataFrames.jl/](http://juliastats.github.io/DataFrames.jl/)
- en: Julia Studio, an IDE for Julia, available at [http://forio.com/labs/julia-studio/](http://forio.com/labs/julia-studio/)
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia Studio，适用于Julia的集成开发环境，访问地址：[http://forio.com/labs/julia-studio/](http://forio.com/labs/julia-studio/)
