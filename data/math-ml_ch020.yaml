- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Differentiation
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微分
- en: I turn with terror and horror from this lamentable scourge of continuous functions
    with no derivatives.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我转身，充满恐惧和恐慌，远离这个没有导数的连续函数的悲惨灾难。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: — Charles Hermite
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: — 查尔斯·埃尔米特
- en: In the history of science, a few milestones are as significant as inventing
    the wheel. Even among these, differentiation is a highlight. With the invention
    of calculus, Newton created mechanics as we know it. Differentiation is all over
    science and engineering, and as it turns out, it’s a key component of machine
    learning as well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学史上，很少有里程碑像发明轮子一样具有重要意义。在这些里程碑中，微分尤为突出。随着微积分的发明，牛顿创造了我们今天所知的力学。微分在科学和工程中无处不在，事实证明，它也是机器学习的关键组成部分。
- en: Why? Because of optimization! As it turns out, the extremal points of a function
    can be characterized in terms of their derivative, and these extremal points can
    be iteratively found via gradient descent.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为优化！事实证明，函数的极值点可以通过其导数来表征，而这些极值点可以通过梯度下降法反复找到。
- en: In this chapter, we’ll learn what differentiation is, what its origins are,
    and most importantly, how to use it in practice. Let’s go!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习微分是什么，它的起源是什么，以及最重要的，如何在实践中使用它。让我们开始吧！
- en: 12.1 Differentiation in theory
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 理论中的微分
- en: 'Instead of jumping straight into the mathematical definition, let’s start our
    discussion with a straightforward example: a point-like object moving along a
    straight line. Its movement is fully described by the time-distance plot (Figure [12.1](#)),
    which shows its distance from the starting point at a given time.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接进入数学定义之前，让我们先从一个简单的例子开始：一个沿直线运动的质点。它的运动完全由时间-距离图（图 [12.1](#)）描述，该图展示了它在某一时刻离起点的距离。
- en: '![PIC](img/file1145.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1145.png)'
- en: 'Figure 12.1: Time-distance plot of our moving object'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：我们运动物体的时间-距离图
- en: Our goal is to calculate the object’s velocity at a given time. In high school,
    we learned that
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是计算物体在某一时刻的速度。在高中时，我们学到：
- en: '![ distance average velocity = -time---. ](img/file1146.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![距离 平均速度 = -时间---.](img/file1146.png)'
- en: To put this into a quantitative form, if f(t) denotes the time-distance function,
    and t[1]/span>t[2] are two arbitrary points in time, then
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其转化为定量形式，假设 f(t) 表示时间-距离函数，t[1] 和 t[2] 是任意的两个时间点，那么
- en: '![average velocity between t and t = f-(t2)−--f(t1). 1 2 t2 − t1 ](img/file1147.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![平均速度在 t 和 t = f-(t2)−--f(t1). 1 2 t2 − t1](img/file1147.png)'
- en: Expressions like ![f(t2t2)−−ft(1t1)-](img/file1148.png) are called differential
    quotients. Note that if the object moves backwards, the average velocity is negative.
    (As opposed to speed, which is always positive. Velocity is speed and direction.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 像 ![f(t2t2)−−ft(1t1)-](img/file1148.png) 这样的表达式被称为微分商。请注意，如果物体是倒退的，则平均速度为负值。（与速度不同，速度总是正值。速度包括速率和方向。）
- en: 'The average velocity has a simple geometric interpretation: if you replace
    the object’s motion with a constant velocity motion moving with that average,
    you’ll end up at exactly the same place. In graphical terms, this is equivalent
    of connecting (t[1],f(t[1])) and (t[2],f(t[2])) with a single line.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 平均速度有一个简单的几何解释：如果你将物体的运动替换为一个恒定速度的运动，且该速度与平均速度相同，你最终将到达完全相同的位置。从图形的角度来看，这等同于用一条直线连接
    (t[1], f(t[1])) 和 (t[2], f(t[2]))。
- en: The average velocity is just the slope of this line. This is visualized by Figure [12.2](#).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 平均速度就是这条直线的斜率。图 [12.2](#) 直观地展示了这一点。
- en: '![PIC](img/file1149.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1149.png)'
- en: 'Figure 12.2: Average velocity between t[1] and t[2]'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：t[1] 和 t[2] 之间的平均速度
- en: 'Given this, we can calculate the exact velocity at a single time point t, which
    we’ll denote with v(t). The idea is simple: the average speed in the small time-interval
    between t and t + Δt should get closer and closer to v(t) if Δt is small enough.
    (Δt can be negative as well.)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，我们可以计算在某一时间点 t 上的精确速度，我们将其表示为 v(t)。这个思想很简单：如果 Δt 足够小，那么在 t 和 t + Δt 之间的小时间间隔内的平均速度应该越来越接近
    v(t)。（Δt 也可以是负值。）
- en: So,
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，
- en: v(t) = lim[Δt → 0] (f(t + Δt) - f(t)) / Δt, (12.1)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: v(t) = lim[Δt → 0] (f(t + Δt) - f(t)) / Δt, (12.1)
- en: if the above limit exists. Figure [12.3](#) illustrates the limit defined by
    ([12.1](#)). There, we can see that as Δt gets closer and closer to 0, the slope
    of the line connecting (t,f(t)) to (t + Δt,f(t + Δt)) gets closer and closer to
    the slope of the tangent.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述极限存在。图 [12.3](#) 说明了由 ([12.1](#)) 定义的极限。在那里，我们可以看到，随着 Δt 越来越接近 0，连接 (t,
    f(t)) 和 (t + Δt, f(t + Δt)) 的直线的斜率也越来越接近切线的斜率。
- en: '![PIC](img/file1151.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1151.png)'
- en: 'Figure 12.3: Approximating the speed at t'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：在 t 时刻近似速度
- en: Following our geometric intuition, we see that v(t) is simply the slope of the
    tangent line of f at t. Keeping this in mind, we are ready to introduce the formal
    definition.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的几何直觉，我们看到 v(t) 就是 f 在 t 时刻的切线斜率。记住这一点后，我们准备介绍正式定义。
- en: Definition 54\. (Differentiability)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 54.（可微性）
- en: 'Let f : ℝ →ℝ be an arbitrary function. We say that f is differentiable at x[0]
    ∈ℝ if the limit'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f : ℝ →ℝ 为任意函数。我们说 f 在 x[0] ∈ℝ 处是可微的，当且仅当极限'
- en: '![-df-(x0) = lim f(x)-−-f(x0) dx x→x0 x − x0 ](img/file1152.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![-df-(x0) = lim f(x)-−-f(x0) dx x→x0 x − x0 ](img/file1152.png)'
- en: exists. If so, this is called the derivative of f at x[0].
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 存在。如果存在，这被称为 f 在 x[0] 处的导数。
- en: In other words, if f describes a time-distance function of a moving object,
    then the derivative is simply its velocity.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果 f 描述的是一个物体运动的时间-距离函数，那么导数就是物体的速度。
- en: Similar to continuity, differentiability is a local property. However, we’ll
    be more interested in functions that are differentiable (almost) everywhere. In
    those cases, the derivative is a function, often denoted with f^′(x).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于连续性，可微性是局部性质。然而，我们更关注的是那些几乎到处都可微的函数。在这些情况下，导数是一个函数，通常记作 f^′(x)。
- en: Sometimes it is confusing that x can denote the variable of f and the exact
    point where the derivative is taken. Here is a quick glossary of terms to clarify
    the difference between derivative and derivative function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会让人困惑的是，x 既可以表示 f 的自变量，也可以表示求导数时的具体点。以下是一个快速的术语表，用于澄清导数和导数函数之间的区别。
- en: '![df- dx](img/file1153.png)(x[0]): derivative of f with respect to the variable
    x at the point x[0]. This is a scalar, also denoted with f^′(x[0]).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![df- dx](img/file1153.png)(x[0])：f 关于变量 x 在点 x[0] 处的导数。这是一个标量，通常记作 f^′(x[0])。'
- en: '![df- dx](img/file1154.png): derivative function of f with respect to the variable
    x. This is a function, also denoted with f^′.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![df- dx](img/file1154.png)：f 关于变量 x 的导数函数。这是一个函数，通常记作 f^′。'
- en: Remark 9\. (Variables in the limit)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注释 9.（极限中的变量）
- en: 'Don’t let the change in notation from t and t + Δt to x[0] and x confuse you;
    the limit that defines the derivative means exactly the same as before:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被符号的变化从 t 和 t + Δt 到 x[0] 和 x所困惑；定义导数的极限与之前完全相同：
- en: '![ f(x0 + h)− f(x0) f(x)− f(x0) lhim→0 -------h---------= xli→mx0 ---x−--x----.
    0 ](img/file1155.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![ f(x0 + h)− f(x0) f(x)− f(x0) lhim→0 -------h---------= xli→mx0 ---x−--x----.
    0 ](img/file1155.png)'
- en: Also note that
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另外需要注意的是
- en: '![lim f(x)−-f(x0)-= lim f(x0)−--f(x). x→x0 x− x0 x→x0 x0 − x ](img/file1156.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![lim f(x)−-f(x0)-= lim f(x0)−--f(x). x→x0 x− x0 x→x0 x0 − x ](img/file1156.png)'
- en: On occasion, we might even use x and y instead of x[0] and x, writing
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们甚至可能使用 x 和 y 来代替 x[0] 和 x，写成
- en: '![ ′ f-(x-)−-f(y) f (x) = yli→mx x − y ](img/file1157.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![ ′ f-(x-)−-f(y) f (x) = yli→mx x − y ](img/file1157.png)'
- en: We’ll use whichever is more convenient.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会使用更方便的表示方式。
- en: Let’s see some examples!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些例子！
- en: Example 1\. f(x) = x. For any x, we have
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1. f(x) = x。对于任意的x，我们有
- en: '![lim f(x)−-f(y)-= lim x-−-y = 1\. y→x x − y y→x x − y ](img/file1158.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![lim f(x)−-f(y)-= lim x-−-y = 1\. y→x x − y y→x x − y ](img/file1158.png)'
- en: Thus, f(x) = x is differentiable everywhere and its derivative is the constant
    function f^′(x) = 1.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，f(x) = x 在每一点都是可微的，它的导数是常数函数 f^′(x) = 1。
- en: Example 2\. f(x) = x². Here, we have
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2. f(x) = x²。在这里，我们有
- en: '![ f(x)− f (y ) x2 − y2 lim -----------= lim ------- y→x x− y y→x x − y (x-−-y)(x+-y)
    = yli→mx x − y = yli→mx x + y = 2x. ](img/file1159.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![ f(x)− f (y ) x² − y² lim -----------= lim ------- y→x x− y y→x x − y (x-−-y)(x+-y)
    = yli→mx x − y = yli→mx x + y = 2x. ](img/file1159.png)'
- en: So, f(x) = x² is differentiable everywhere and f^′(x) = 2x. Later, when talking
    about elementary functions, we’ll see the general case f(x) = x^k.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，f(x) = x² 在每一点都是可微的，且 f^′(x) = 2x。稍后，当我们讨论初等函数时，我们将看到更一般的情况 f(x) = x^k。
- en: Example 3\. f(x) = jxj at x = 0\. For this, we have
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3. f(x) = |x| 在 x = 0 处。对于这个例子，我们有
- en: '![lim f(0)−-f-(y-)= lim |y|. y→0 0− y y→0 y ](img/file1160.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![lim f(0)−-f-(y-)= lim |y|. y→0 0− y y→0 y ](img/file1160.png)'
- en: Since
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因为
- en: '![ ( |{ 1 if y >0, |y|-= y |( − 1 if y <0, ](img/file1161.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{ 1 if y >0, |y|-= y |( − 1 if y <0, ](img/file1161.png)'
- en: this limit does not exist, as it is illustrated on Figure [12.4](#). This is
    our first example of a non-differentiable function. However, jxj is differentiable
    everywhere else.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个极限不存在，如图[12.4](#)所示。这是我们第一个非可微函数的例子。然而，|x|在其他地方是可微的。
- en: It is worth drawing a picture here to enhance our understanding of differentiability.
    Recall that the value of the derivative at a given point equals the slope of the
    tangent line to the function’s graph.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里画一张图来增强我们对可微性的理解是值得的。回忆一下，某一点的导数值等于函数图像的切线斜率。
- en: Since jxj has a sharp corner at 0, the tangent line is not well-defined.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 jxj 在 0 处有尖锐的拐角，切线不定义。
- en: '![PIC](img/file1162.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1162.png)'
- en: 'Figure 12.4: Tangent planes of f(x) = jxj at 0'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4：f(x) = jxj 在 0 处的切平面
- en: 'Differentiability means no sharp corners in the graph, so differentiable functions
    are often called smooth. This is one reason we prefer differentiable functions:
    the rate of change is tractable.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可微分性意味着图形中没有尖锐的拐角，因此可微函数通常被称为光滑函数。这是我们更喜欢可微函数的原因之一：变化率是可控的。
- en: 'Next, we’ll see an equivalent definition of differentiability, involving local
    approximation with a linear function. From this perspective, differentiability
    means manageable behavior: no wrinkles, corners, or sharp changes in value.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到微分的等价定义，涉及到用线性函数进行局部近似。从这个角度看，可微分性意味着可控的行为：没有皱纹、角落或剧烈的值变化。
- en: 12.1.1 Equivalent forms of differentiation
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 微分的等价形式
- en: 'To really understand derivatives and differentiation, we are going to take
    a look at it from another point of view: local linear approximations.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解导数和微分，我们将从另一个角度来看待它：局部线性近似。
- en: Approximation is a very natural idea in mathematics. Say, have you ever thought
    about what happens when you punch sin(2.18) into a calculator? We cannot express
    the function sin with finitely many additions and multiplications, so we have
    to approximate it. In practice, we use functions of the form
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 近似是数学中的一个非常自然的概念。比如，你有没有想过当你在计算器中输入 sin(2.18) 时会发生什么？我们无法用有限次加法和乘法表达 sin 函数，因此我们必须对其进行近似。实际上，我们使用形式为的函数
- en: '![p(x) = p0 + p1x+ ⋅⋅⋅+ pnxn, ](img/file1163.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![p(x) = p0 + p1x+ ⋅⋅⋅+ pnxn, ](img/file1163.png)'
- en: which, can be evaluated easily. These are called polynomials, and they are just
    a finite combination of additions and multiplications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以很容易地计算出来。它们被称为多项式，它们只是有限次加法和乘法的组合。
- en: Can we just replace functions with polynomials to make computations easier?
    (Even at the cost of perfect precision.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否仅通过将函数替换为多项式来简化计算？（即使这以失去完美精度为代价。）
- en: It turns out that we can, and differentiation is one way to do so. In essence,
    the derivative desribes the best local approximation with a linear function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明我们可以这么做，微分是其中的一种方法。从本质上讲，导数描述了用线性函数进行的最佳局部近似。
- en: The following theorem makes this clear.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定理使这一点变得清晰。
- en: Theorem 77\. (Differentiation as a local linear approximation)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 77. （作为局部线性近似的微分）
- en: 'Let f : ℝ →ℝ be an arbitrary function. The following are equivalent.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f : ℝ → ℝ 为任意函数。以下是等价的。'
- en: (a) f is differentiable at x[0].
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: (a) f 在 x[0] 处可微。
- en: (b) there is an α ∈ℝ such that
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 存在一个 α ∈ ℝ 使得
- en: f(x) = f(x₀) + α(x − x₀) + o(|x − x₀|) *as* x → x₀. (12.2)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: f(x) = f(x₀) + α(x − x₀) + o(|x − x₀|) *当* x → x₀。 (12.2)
- en: Recall that the small O notation (see Definition [52](ch019.xhtml#x1-190013r52))
    means that the function is an order of magnitude smaller around x[0] than the
    function |x −x[0]|.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，小 O 符号（见定义[52](ch019.xhtml#x1-190013r52)）意味着该函数在 x[0] 附近比函数 |x − x[0]|
    小一个数量级。
- en: If exists, the α in the above theorem is the derivative f^′(x[0]). In other
    words, f(x) can be locally written as
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在，上述定理中的 α 就是导数 f^′(x[0])。换句话说，f(x) 可以局部写成
- en: f(x[0]) + f′(x[0])(x − x[0]) + o(|x − x[0]|). (12.3)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: f(x[0]) + f′(x[0])(x − x[0]) + o(|x − x[0]|)。 (12.3)
- en: Proof. To show the equivalence of two statements, we have to prove that differentiation
    implies the desired property and vice versa. Although this might seem complicated,
    it is straightforward and entirely depends on how functions can be written as
    their limit plus an error term (Theorem [71](ch019.xhtml#x1-191002r71)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。为了证明两个陈述的等价性，我们必须证明微分意味着所需的属性，反之亦然。虽然这看起来可能复杂，但其实是直接的，并且完全取决于函数如何可以写成它们的极限加上一个误差项（定理[71](ch019.xhtml#x1-191002r71)）。
- en: (a) ⇒ (b). The existence of the limit
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: (a) ⇒ (b)。极限的存在
- en: '![ f-(x)−-f(x0) ′ lxi→mx0 x − x0 = f (x0) ](img/file1165.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![ f-(x)−-f(x0) ′ lxi→mx0 x − x0 = f (x0) ](img/file1165.png)'
- en: implies that we can write the slope of the approximating tangent in the form
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以将近似切线的斜率写成
- en: '![f(x) − f(x0) ′ ---x-−-x----= f(x0) + error(x), 0 ](img/file1166.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![f(x) − f(x0) ′ ---x-−-x----= f(x0) + error(x), 0 ](img/file1166.png)'
- en: where lim[x→x[0]]error(x) = 0.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 lim[x→x[0]]error(x) = 0。
- en: With some simple algebra, we obtain
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些简单的代数运算，我们得到
- en: '![f(x) = f (x0 )+ f′(x0)(x − x0)+ error(x)(x − x0). ](img/file1167.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![f(x) = f (x0 )+ f′(x0)(x − x0)+ error(x)(x − x0). ](img/file1167.png)'
- en: Since the error term tends to zero as x goes to x[0], error(x)(x −x[0]) = o(|x
    −x[0]|), which is what we wanted to show.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于误差项随着 x 接近 x[0] 而趋近于零，误差(x)(x − x[0]) = o(|x − x[0]|)，这就是我们想要证明的。
- en: (b) ⇒ (a). Now, repeat what we did in the previous part, just in reverse order.
    We can rewrite
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: (b) ⇒ (a)。现在，按照我们之前所做的，只是倒过来。我们可以重写
- en: '![f (x) = f (x0) + α(x − x0)+ o(|x− x0|) ](img/file1169.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![f (x) = f (x0) + α(x − x0)+ o(|x− x0|) ](img/file1169.png)'
- en: in the form
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 形式为
- en: '![f(x)−-f-(x0) x− x = α + o(1), 0 ](img/file1170.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![f(x)−-f-(x0) x− x = α + o(1), 0 ](img/file1170.png)'
- en: which, according to what we have used before, implies that
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前使用的知识，这意味着
- en: '![ ](img/file1171.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![ ](img/file1171.png)'
- en: So, f is differentiable at x[0] and its derivative is f^′(x[0]) = α.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，f 在 x[0] 处可微，且其导数为 f^′(x[0]) = α。
- en: One huge advantage of this form is that it will be easily generalized to multivariate
    functions. Even though we are far from it, we can get a glimpse. Multivariate
    functions map vectors to scalars, so the ratio
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的一个巨大优势是它可以很容易地推广到多变量函数。尽管我们离此还有很长一段距离，但可以先窥见一二。多变量函数将向量映射到标量，因此比例
- en: '![f(x)-−-f(x0), x,x0 ∈ ℝn x − x0 ](img/file1172.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![f(x)-−-f(x0), x,x0 ∈ ℝn x − x0 ](img/file1172.png)'
- en: is not even defined. (Since we can’t divide with a vector.) However, the expression
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至无法定义。（因为我们不能用向量进行除法。）然而，表达式
- en: '![f (x ) = f (x0 )+ ∇f (x0)T(x− x0)+ o(∥x − x0∥) ](img/file1173.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![f (x ) = f (x0 )+ ∇f (x0)T(x− x0)+ o(∥x − x0∥) ](img/file1173.png)'
- en: makes perfect sense, since ∇f(x[0])^T (x −x[0]) is a scalar. Here, ∇f(x[0])
    denotes the gradient of f, that is, the multivariable version of derivatives.
    ∇f(x[0]) is an n-dimensional vector. Don’t worry if you are not familiar with
    this notation, we’ll cover everything in due time. The take-home message is that
    this alternative definition will be more convenient for us in the future.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 完全有意义，因为 ∇f(x[0])^T (x −x[0]) 是标量。这里，∇f(x[0]) 表示 f 的梯度，即导数的多变量版本。∇f(x[0]) 是一个
    n 维向量。如果你不熟悉这种符号，别担心，我们会在适当的时候讲解。重点是，这种替代定义将来对我们更为方便。
- en: Another advantage of the locally-best-approximation mindset is that Theorem [77](ch020.xhtml#x1-199002r77)
    can be generalized to higher derivatives.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 局部最佳近似思想的另一个优势是，定理 [77](ch020.xhtml#x1-199002r77) 可以推广到更高阶的导数。
- en: Check out the following theorem.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下定理。
- en: Theorem 78\. (Taylor’s theorem)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 78\. （泰勒定理）
- en: 'Let f : ℝ →ℝ function that is n times differentiable at x[0]. Then'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f : ℝ →ℝ 是在 x[0] 处 n 次可微的函数。那么'
- en: '![ ∑n f(k)(x0) f (x ) = -------(x − x0)k + o(|x− x0|n) k=0 k! ](img/file1174.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n f(k)(x0) f (x ) = -------(x − x0)k + o(|x− x0|n) k=0 k! ](img/file1174.png)'
- en: holds, where f^((k))(x[0]) denotes the k-th derivative of f at x[0].
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 成立，其中 f^((k))(x[0]) 表示 f 在 x[0] 处的第 k 阶导数。
- en: (Note that the zeroth derivative f^((0)) equals to f.)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，零阶导数 f^((0)) 等于 f。）
- en: In other words, Theorem [78](ch020.xhtml#x1-199005r78) says that if f is differentiable
    enough times, it can be written as a polynomial plus a small error term. For infinitely
    differentiable functions, Taylor’s theorem gives rise to the famous Taylor expansion.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，定理 [78](ch020.xhtml#x1-199005r78) 表示，如果 f 可以足够多次微分，它可以表示为一个多项式加上一个小的误差项。对于无限可微的函数，泰勒定理产生了著名的泰勒展开式。
- en: Definition 55\. (Taylor expansion)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 55\. （泰勒展开式）
- en: 'Let f : ℝ → ℝ be a function that is differentiable at x[0] infinitely many
    times. The series defined by'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f : ℝ → ℝ 是在 x[0] 处可无限次微分的函数。由下式定义的级数'
- en: '![ ∞ (k) f(x) ∼ ∑ f---(x0)(x− x )k k! 0 k=0 ](img/file1175.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞ (k) f(x) ∼ ∑ f---(x0)(x− x )k k! 0 k=0 ](img/file1175.png)'
- en: is called the Taylor expansion of f around x[0].
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 称为 f 在 x[0] 处的泰勒展开。
- en: To give you an example, as (e^x)^′ = e^x, the Taylor expansion of e^x around
    0 is
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，因 (e^x)^′ = e^x，所以 e^x 在 0 处的泰勒展开式为
- en: '![ ∞ ex = ∑ 1-xk. k! k=0 ](img/file1176.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞ ex = ∑ 1-xk. k! k=0 ](img/file1176.png)'
- en: 'Note that the equality sign is not an accident: the Taylor expansion of e^x
    equals e^x! (This is not always the case.) Now we see why e = ∑ [k=0]^∞![1k!](img/file1177.png),
    as we hinted earlier when discussing sequences and series.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，等式符号并非偶然：e^x 的泰勒展开式等于 e^x！(这并非总是如此。)现在我们看到为什么 e = ∑ [k=0]^∞![1k!](img/file1177.png)，如我们在讨论数列与级数时所暗示的那样。
- en: In other words,
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，
- en: '![ x ∑n 1 k e ≈ k!x , k=0 ](img/file1178.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![ x ∑n 1 k e ≈ k!x , k=0 ](img/file1178.png)'
- en: meaning that on any interval [ −α,α] and for any arbitrarily small 𝜀/span>0,
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，在任意区间 [ −α,α] 上，对于任何任意小的 𝜖/span>0，
- en: '![ ∑n |ex − -1xk| <𝜀 k=0k! ](img/file1179.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n |ex − -1xk| <𝜖 k=0k! ](img/file1179.png)'
- en: holds if n is large enough. In practice, this polynomial is evaluated to approximate
    the value of e^x.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当 n 足够大时，成立。实际上，这个多项式被用来近似 e^x 的值。
- en: 12.1.2 Differentiation and continuity
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 微分与连续性
- en: As the following theorem states, differentiation is a more strict condition
    than continuity.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如下定理所述，微分是比连续性更严格的条件。
- en: Theorem 79\.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 79\.
- en: Differentiable functions are continuous.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可微函数是连续的。
- en: 'If f : ℝ →ℝ is differentiable at a, it is also continuous there.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 f : ℝ → ℝ 在 a 处可微，那么它在该点也是连续的。'
- en: Proof. We’ll use Theorem [77](ch020.xhtml#x1-199002r77) to prove the result.
    With the general form ([12.2](ch020.xhtml#x1-199002r77)), we have
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。我们将使用定理[77](ch020.xhtml#x1-199002r77)来证明这个结果。根据一般形式（[12.2](ch020.xhtml#x1-199002r77)），我们得到：
- en: '![ lim f (x) = lim (f(x )+ f′(x )(x− x ) + o(|x − x |)) = f(x ), x→x0 x→x0
    0 0 0 0 0 ](img/file1180.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![ lim f (x) = lim (f(x )+ f′(x )(x− x ) + o(|x − x |)) = f(x ), x→x0 x→x0
    0 0 0 0 0 ](img/file1180.png)'
- en: which shows the continuity of f at x[0].
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 f 在 x[0] 处是连续的。
- en: 'Note that the previous theorem is not true the other way around: a function
    can be continuous, but not differentiable. (As the example f(x) = jxj at x = 0
    shows.)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的定理并不是反过来成立的：一个函数可以是连续的，但并不是可微的。（正如 f(x) = jxj 在 x = 0 处的例子所示。）
- en: 'This can be taken to the extremes: there are functions that are continuous
    everywhere but differentiable nowhere. One of the first examples was provided
    by Weierstrass (from the [Bolzano-Weierstrass theorem](#)). The function itself
    is defined by the infinite sum'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以推到极限：存在一些函数在每一点上都是连续的，但在任何地方都不可微。第一个例子是由魏尔斯特拉斯提供的（来自[博尔扎诺-魏尔斯特拉斯定理](#)）。该函数本身由无限和式定义：
- en: '![ ∑∞ W (x) = ancos(bnπx), n=0 ](img/file1181.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑∞ W (x) = ancos(bnπx), n=0 ](img/file1181.png)'
- en: where a ∈ (0,1), b is a positive odd integer, and ab/span>1 + 3π∕2\.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 a ∈ (0,1)，b 是一个正奇数，且 ab/span>1 + 3π∕2\。
- en: 'I agree, this definition feels totally random, and you are probably wondering:
    how did the author come up with it? To get a grip on this function, imagine this
    as the superposition of cosine waves with smaller and smaller amplitude but higher
    and higher frequency. Remember that differentiation implies “no sharp corners”?
    This definition puts a sharp corner at every point on the real line.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我同意，这个定义看起来完全随机，您可能会想：作者是怎么想到这个的？为了理解这个函数，想象它是多个余弦波的叠加，每个波的振幅越来越小，但频率越来越高。记住，微分意味着“没有尖角”吗？这个定义在实数线上的每个点上都放置了一个尖角。
- en: Its graph is a fractal curve with self-similarity, as illustrated below.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它的图形是一条具有自相似性的分形曲线，如下所示。
- en: '![PIC](img/file1182.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1182.png)'
- en: 'Figure 12.5: Graph of the Weierstrass function. Source: [https://en.wikipedia.org/wiki/Weierstrass_function](https://en.wikipedia.org/wiki/Weierstrass_function)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5：魏尔斯特拉斯函数的图形。来源：[https://en.wikipedia.org/wiki/Weierstrass_function](https://en.wikipedia.org/wiki/Weierstrass_function)
- en: 'Examples such as this inspired the opening quote of the section:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的例子启发了本节的开头引述：
- en: I turn with terror and horror from this lamentable scourge of continuous functions
    with no derivatives. — Charles Hermite
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我从这个可悲的无导数连续函数的祸害中，满怀恐惧和惊恐地转过身来。 — 查尔斯·埃米特
- en: 19th-century mathematicians certainly did not think much about nondifferentiable
    functions. However, there are much more of them than differentiable ones. We won’t
    go into the details, but amongst all continuous functions, the set of ones that
    are differentiable at at least one point is meagre. Meagre is a proper technical
    term for sets, and although we don’t need to know what it means exactly, its name
    implies that it is extremely small.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 19世纪的数学家们显然没有太多关注不可微函数。然而，这类函数的数量远远超过了可微函数。我们不会深入讨论这一点，但在所有连续函数中，至少在一个点可微的函数集合是稀疏的。稀疏是一个专业的术语，虽然我们不需要确切理解它的含义，但它的名字暗示它是极其小的。
- en: Now that we understand what the derivative is, it’s time to put theory into
    practice. How do we compute derivatives, and how do we work with them in machine
    learning? We’ll see in the next section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了什么是导数，是时候将理论付诸实践了。我们如何计算导数，又如何在机器学习中使用它们呢？我们将在下一节中看到。
- en: 12.2 Differentiation in practice
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 实践中的微分
- en: During our first encounter with differentiation, we saw that computing derivatives
    by the definition
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一次接触微分时，我们看到通过定义计算导数
- en: '![f′(x0) = lim f(x0)−-f-(x-) x→x0 x0 − x ](img/file1183.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![f′(x0) = lim f(x0)−-f-(x-) x→x0 x0 − x ](img/file1183.png)'
- en: can be really hard in practice if we encounter convoluted functions such as
    f(x) = cos(x)sin(e^x). Similar to convergent sequences and limits, using the definition
    of differentiation won’t get us far—the complexity piles on fast. So, we have
    to find ways to decompose the complexity into its fundamental building blocks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，如果遇到复杂的函数，如 f(x) = cos(x)sin(e^x)，微分可能会非常困难。类似于收敛序列和极限，使用微分定义是无法快速解决的——复杂性迅速堆积。因此，我们必须找到方法将复杂性分解为其基本构件。
- en: 12.2.1 Rules of differentiation
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 导数的规则
- en: 'First, we’ll look at the simplest of operations: scalar multiplication, addition,
    multiplication, and division.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看最简单的几种操作：标量乘法、加法、乘法和除法。
- en: Theorem 80\. (Rules of differentiation)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 80.（微分法则）
- en: 'Let f : ℝ → ℝ and g : ℝ → ℝ be two arbitrary functions and let x ∈ ℝ. Suppose
    that both f and g is differentiable at x. Then'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '令f : ℝ → ℝ 和 g : ℝ → ℝ 为两个任意函数，且令x ∈ ℝ。假设f和g在x处都可微。则'
- en: (a) (cf)^′(x) = cf^′(x) for all c ∈ℝ,
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: (a) (cf)^′(x) = cf^′(x)，对所有c ∈ℝ成立。
- en: (b) (f + g)^′(x) = f^′(x) + g^′(x),
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: (b) (f + g)^′(x) = f^′(x) + g^′(x)，
- en: (c) (fg)^′(x) = f^′(x)g(x) + f(x)g^′(x) (the product rule),
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: (c) (fg)^′(x) = f^′(x)g(x) + f(x)g^′(x)（乘积法则），
- en: (d) (![f g](img/file1185.png))^′(x) = ![f′(x)g(x)−-f(x)g′(x) g(x)2](img/file1187.png)
    if g(x)≠0 (the quotient rule).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: (d) (![f g](img/file1185.png))^′(x) = ![f′(x)g(x)−-f(x)g′(x) g(x)2](img/file1187.png)，当g(x)≠0时（商法则）。
- en: Proof. (a) and (b) is a direct consequence of the Theorem [70](ch019.xhtml#x1-190011r70).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 证明：（a）和（b）是定理[70](ch019.xhtml#x1-190011r70)的直接结果。
- en: 'To show (c), we have to do a bit of algebra:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明(c)，我们需要做一些代数运算：
- en: '![lim f(x)g(x)−-f-(y)g(y)-= lim f(x)g(x)−--f(y)g-(x-)+-f(y)g(x)−-f-(y)g(y)-
    y→x x − y x→y x − y f(x)g(x)− f(y)g (x ) f(y)g(x)− f (y)g (y) = lyim→x -------x−--y-------+
    lxi→my -------x−-y-------- = lim [f(x)−-f(y)g(x)]+ f (y ) lim g(x)−-g(y)- y→x
    x − y x→y x − y = f′(x)g(x)+ f(x)g′(x), ](img/file1188.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![lim f(x)g(x)−-f-(y)g(y)-= lim f(x)g(x)−--f(y)g-(x-)+-f(y)g(x)−-f-(y)g(y)-
    y→x x − y x→y x − y f(x)g(x)− f(y)g (x ) f(y)g(x)− f (y)g (y) = lyim→x -------x−--y-------+
    lxi→my -------x−-y-------- = lim [f(x)−-f(y)g(x)]+ f (y ) lim g(x)−-g(y)- y→x
    x − y x→y x − y = f′(x)g(x)+ f(x)g′(x), ](img/file1188.png)'
- en: from which (c) follows.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从中可以得到(c)。
- en: For (d), we are going to start with the special case of (1∕g)^′. We have
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于(d)，我们将从(1∕g)^′的特例开始。我们有
- en: '![ g1(x) − g1(y) 1 g(y)− g (x ) lyim→x --x-−-y---= lyim→x g(x)g(y)---x−--y---
    ′ = − g-(x-), g(x)2 ](img/file1189.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![ g1(x) − g1(y) 1 g(y)− g (x ) lyim→x --x-−-y---= lyim→x g(x)g(y)---x−--y---
    ′ = − g-(x-), g(x)2 ](img/file1189.png)'
- en: from which the general case follows by applying (c) to f and 1∕g.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从中，通过对f和1∕g应用(c)，可以得到一般情况。
- en: 'There is one operation which we haven’t covered in the previous theorem: function
    composition. In the study of neural networks, composition plays an essential role.
    Each layer can be thought of as a function, which are composed together to form
    the entire network.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种操作我们在之前的定理中没有涉及：函数复合。在神经网络的研究中，复合起着至关重要的作用。每一层都可以看作一个函数，这些函数组合在一起形成整个网络。
- en: Theorem 81\. (Chain rule/Leibniz rule)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 81.（链式法则/莱布尼茨法则）
- en: 'Let f : ℝ→ℝ and g : ℝ→ℝ be two arbitrary functions and let x ∈ ℝ. Suppose that
    g is differentiable at x and f is differentiable at g(x). Then'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '令f : ℝ→ℝ 和 g : ℝ→ℝ 为两个任意函数，且令x ∈ ℝ。假设g在x处可微，且f在g(x)处可微。则'
- en: '![ ′ ′ ′ (f ∘g) (x) = f (g(x))g(x) ](img/file1192.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![′ ′ ′ (f ∘g) (x) = f (g(x))g(x)](img/file1192.png)'
- en: holds.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 保持不变。
- en: 'Proof. First, we rewrite the differential quotient into the following form:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 证明：首先，我们将微分商重写成以下形式：
- en: '![lim f(g(x))−-f(g(y)) = lim f(g(x))−-f(g(y))g(x)-−-g(y) y→x x − y y→x g(x)−
    g(y) x − y f(g(x))− f(g(y)) g(x) − g(y) = lyim→x ---g(x)−-g(y)---xli→my ---x-−-y---.
    ](img/file1193.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![lim f(g(x))−-f(g(y)) = lim f(g(x))−-f(g(y))g(x)-−-g(y) y→x x − y y→x g(x)−
    g(y) x − y f(g(x))− f(g(y)) g(x) − g(y) = lyim→x ---g(x)−-g(y)---xli→my ---x-−-y---.](img/file1193.png)'
- en: Because g is differentiable at x, it is also continuous there, so lim[y→x]g(y)
    = g(x). So, the first term can be rewritten as
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因为g在x处可微，它在该点也是连续的，因此lim[y→x]g(y) = g(x)。因此，第一项可以重写为
- en: '![lim f(g(x-))-−-f(g(y))= lim f(y)−-f(g(x))-= f′(g(x)). y→x g(x) − g(y) y→g
    (x) y − g(x) ](img/file1194.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![lim f(g(x-))-−-f(g(y))= lim f(y)−-f(g(x))-= f′(g(x)). y→x g(x) − g(y) y→g
    (x) y − g(x)](img/file1194.png)'
- en: Since g is differentiable at x, the second term is g^′(x). Thus, we have
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于g在x处可微，第二项是g^′(x)。因此，我们有
- en: '![lim f-(g(x-))-−-f(g(y))= f ′(g(x))g′(x), y→x x − y ](img/file1195.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![lim f-(g(x-))-−-f(g(y))= f ′(g(x))g′(x), y→x x − y](img/file1195.png)'
- en: which is what we had to show.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要证明的内容。
- en: As neural networks are just huge composed functions, their derivative is calculated
    with the repeated application of the chain rule. (Although the derivatives of
    its layers are vectors and matrices since they are multivariable functions.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于神经网络本质上是由大量复合函数组成的，其导数是通过反复应用链式法则来计算的。（虽然它的各层导数是向量和矩阵，因为它们是多变量函数。）
- en: 12.2.2 Derivatives of elementary functions
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 初等函数的导数
- en: 'Following the already familiar pattern, now we calculate the derivatives for
    the most important class: elementary functions. There are a few that we will encounter
    all the time, like in the mean squared error, cross-entropy, Kullback-Leibler
    divergence, etc.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 按照已经熟悉的模式，现在我们计算最重要的类别的导数：初等函数。有一些是我们经常遇到的，比如均方误差、交叉熵、Kullback-Leibler散度等。
- en: Theorem 82\. (Derivatives of elementary functions)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 82。（基本函数的导数）
- en: (a) (x⁰)^′ = 0 and (x^n)^′ = nx^(n−1), where n ∈ℤ ∖ 0,
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: (a) (x⁰)^′ = 0 和 (x^n)^′ = nx^(n−1)，其中 n ∈ℤ ∖ 0，
- en: (b) (sinx)^′ = cosx and (cosx)^′ = −sinx,
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: (b) (sinx)^′ = cosx 和 (cosx)^′ = −sinx，
- en: (c) (e^x)^′ = e^x,
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: (c) (e^x)^′ = e^x，
- en: (d) (log x)^′ = ![1 x](img/file1196.png).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: (d) (log x)^′ = ![1 x](img/file1196.png)。
- en: You don’t necessarily have to know how to prove these. I’ll include the proof
    of (a), but feel free to skip it, especially if this is your first encounter with
    calculus. What you have to remember, though, are the derivatives themselves. (However,
    I’ll refer back to this part when necessary.)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定要知道如何证明这些。我将包括（a）的证明，但如果这是你第一次接触微积分，完全可以跳过它。你需要记住的，是这些导数本身。（不过，当需要时，我会回到这一部分。）
- en: 'Proof. (a) It is easy to see that for n = 0, the derivative (x⁰)^′ = 0\. The
    case n = 1 is also simple: calculating the differential quotient shows that (x)^′
    = 1\. For the case n ≥ 2, we are going to employ a small trick. Writing out the
    differential quotient for f(x) = x^n, we obtain'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。（a）很容易看出，当 n = 0 时，导数 (x⁰)^′ = 0。n = 1 的情况也很简单：计算微分商可以得到 (x)^′ = 1。对于 n ≥
    2 的情况，我们将使用一个小技巧。写出 f(x) = x^n 的微分商，得到
- en: '![ n n x--−-y- , x − y ](img/file1197.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![ n n x--−-y- , x − y ](img/file1197.png)'
- en: which we want to simplify. If you don’t have a lot of experience in math, it
    might seem like magic, but x^n −y^n can be written as
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想简化这个。如果你在数学上没有太多经验，可能觉得这像是魔法，但 x^n −y^n 可以写成
- en: '![xn − yn = (x− y )(xn− 1 + xn− 2y + ⋅⋅⋅+ xyn− 2 + yn−1) n−1 ∑ n− 1− k k =
    (x− y ) x y . k=0 ](img/file1198.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![xn − yn = (x− y )(xn− 1 + xn− 2y + ⋅⋅⋅+ xyn− 2 + yn−1) n−1 ∑ n− 1− k k =
    (x− y ) x y . k=0 ](img/file1198.png)'
- en: 'This can be seen easily by calculating the product:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算乘积，可以很容易看出这一点：
- en: '![ n∑−1 n−1−k k n n−1 n−1 (x − y) x y .= x + [x y + ⋅⋅⋅+ xy ] k=0 − [xn− 1y
    + ⋅⋅⋅+ xyn− 1]− yn = xn − yn. ](img/file1199.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![ n∑−1 n−1−k k n n−1 n−1 (x − y) x y .= x + [x y + ⋅⋅⋅+ xy ] k=0 − [xn− 1y
    + ⋅⋅⋅+ xyn− 1]− yn = xn − yn. ](img/file1199.png)'
- en: Thus, we have
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到
- en: '![ ∑ xn-−-yn (x-−-y)--nk−=01xn−1−kyk- liy→mx x− y = xli→my x− y n∑−1 = lim
    xn−1−kyk y→x k=0 = nxn −1\. ](img/file1200.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑ xn-−-yn (x-−-y)--nk−=01xn−1−kyk- liy→mx x− y = xli→my x− y n∑−1 = lim
    xn−1−kyk y→x k=0 = nxn −1\. ](img/file1200.png)'
- en: So, (x^n)^′ = nx^(n−1). With this and the rules of differentiation, we can calculate
    the derivative of any polynomial p(x) = ∑ [k=0]^np[k]x^k as
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，(x^n)^′ = nx^(n−1)。有了这个以及微分法则，我们可以计算任何多项式 p(x) = ∑ [k=0]^np[k]x^k 的导数：
- en: '![ ′ ∑n k−1 p(x) = kpkx . k=1 ](img/file1201.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![ ′ ∑n k−1 p(x) = kpkx . k=1 ](img/file1201.png)'
- en: The case n/span>0 follows from x^(−n) = 1∕x^n using the rules of differentiation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: n/span>0 的情况可以通过使用微分法则将 x^(−n) = 1∕x^n 得出。
- en: With these rules under our belt, we can calculate the derivatives for some of
    the most famous activation functions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些规则，我们可以计算一些最著名的激活函数的导数。
- en: The most classical one, the sigmoid function is defined by
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最经典的一个是 sigmoid 函数，定义为
- en: '![ ---1--- σ(x) = 1+ e− x. ](img/file1202.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![ ---1--- σ(x) = 1+ e− x. ](img/file1202.png)'
- en: 'Since it is an elementary function, it is differentiable everywhere. To calculate
    its derivative, we can use the quotient rule:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个基本函数，所以它在任何地方都是可微的。为了计算它的导数，我们可以使用商法则：
- en: '![L(U,V ) = {f : U → V | f is linear}](img/file1203.png)(12.4)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![L(U,V ) = {f : U → V | f 是线性映射}](img/file1203.png)(12.4)'
- en: Now that we have the sigmoid and its derivative, let’s plot them together!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 sigmoid 函数及其导数，让我们一起绘制它们的图像吧！
- en: '[PRE0]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![PIC](img/file1204.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1204.png)'
- en: 'Figure 12.6: Sigmoid and its derivative'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6：Sigmoid 及其导数
- en: Another popular activation function is the ReLU, defined by
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的激活函数是 ReLU，定义为
- en: '![ ( |{x if x >0, ReLU (x) = |(0 otherwise. ](img/file1205.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{x if x >0, ReLU (x) = |(0 otherwise. ](img/file1205.png)'
- en: Let’s plot its graph first!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先绘制它的图像！
- en: '[PRE2]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![PIC](img/file1206.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1206.png)'
- en: 'Figure 12.7: Graph of the ReLU function'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7：ReLU 函数的图像
- en: By looking at it, we can suspect that it is not differentiable at 0\. Indeed,
    since
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察它，我们可以怀疑它在 0 处不可微。确实，因
- en: '![ (| ReLU (x) − ReLU (0) { 1 if x >0, ---------x--------- = | ( 0 if x <0,
    ](img/file1207.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![ (| ReLU (x) − ReLU (0) { 1 if x >0, ---------x--------- = | ( 0 if x <0,
    ](img/file1207.png)'
- en: the limit of the differential quotient doesn’t exist.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 微分商的极限不存在。
- en: However, besides 0, it is differentiable and
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了 0 之外，它是可微的，并且
- en: '![ (| ′ {1 if x >0, ReLU (x) = | (0 if x <0\. ](img/file1208.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![ (| ′ {1 if x >0, ReLU (x) = | (0 if x <0\. ](img/file1208.png)'
- en: Even though ReLU is not differentiable at 0, this is not a problem in practice.
    When performing backpropagation, it is extremely unlikely that ReLU^′(x) will
    receive 0 as its input. Even if this is the case, the derivative can be artificially
    extended to zero by defining it as 0.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ReLU在0点不可导，但在实际应用中这并不成问题。在进行反向传播时，ReLU^′(x)接收到0作为输入的情况极为不可能。即使发生这种情况，也可以通过将其定义为0来人为扩展导数为零。
- en: 12.2.3 Higher-order derivatives
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.3 高阶导数
- en: One last thing to do before we move on is to talk about higher-order derivatives.
    Because derivatives are functions, it is a completely natural idea to calculate
    the derivative of derivatives. As we will see when studying the basics of optimization
    in Chapter 14, the second derivatives contain quite a lot of essential information
    regarding minima and maxima.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们要谈谈高阶导数。由于导数本身是函数，因此计算导数的导数是一个完全自然的想法。正如我们在第14章学习优化基础时将会看到的，二阶导数包含了有关最小值和最大值的许多重要信息。
- en: The n-th derivative of f is denoted with f^((n)), where f^((0)) = f. There are
    a few rules regarding them that are worth keeping in mind. Although, we have to
    note that a derivative function is not always differentiable, as the example
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: f的n阶导数记作f^((n))，其中f^((0)) = f。有几个关于它们的规则值得记住。尽管我们需要注意，导数函数并不总是可导的，正如这个例子所示
- en: '![ ( | { 0 if x <0, f (x) = |( 2 x otherwise ](img/file1209.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![ ( | { 0 if x <0, f (x) = |( 2 x otherwise ](img/file1209.png)'
- en: shows. Now, about those rules regarding higher-order derivatives.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于高阶导数的那些规则。
- en: Theorem 83\.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 定理83。
- en: 'Let f : ℝ →ℝ and g : ℝ →ℝ be two arbitrary functions.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '设f : ℝ →ℝ 和 g : ℝ →ℝ 是两个任意函数。'
- en: (a) (f + g)^((n)) = f^((n)) + g^((n))
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: (a) (f + g)^((n)) = f^((n)) + g^((n))
- en: (b) (fg)^((n)) = ∑ [k=0]^n![(n) k](img/file1210.png)f^((n−k))g^((k))
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: (b) (fg)^((n)) = ∑ [k=0]^n![(n) k](img/file1210.png)f^((n−k))g^((k))
- en: Proof. (a) trivially follows from the linearity of differentiation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。(a) 显然来自于微分的线性性质。
- en: Regarding (b), we are going to use proof by induction. For n = 1, the statement
    simply says that (fg)^′ = f^′g + fg^′, as we have seen before.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 关于(b)，我们将使用归纳法证明。对于n = 1，该命题简单地表示(fg)^′ = f^′g + fg^′，正如我们之前所见。
- en: Now, we assume that it is true for n and deduce the n + 1 case. For this, we
    have
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们假设对于n成立，并推导出n + 1的情况。为此，我们有
- en: '![ ∑n ( ) (fg)(n+1) = ((fg)(n))′ = n (f(n−k)g(k))′ k=0 k ∑n ( ) = n [f(n−k+1)g(k)
    + f(n−k)g(k+1)] k=0 k ∑n ( ) ∑n ( ) = n f(n− k+1)g (k) + n f(n−k)g(k+1) k=0 k
    k=0 k ( ) n ( ) n− 1( ) ( ) = n f (n+1)g + [∑ n f(n+1−k)g(k)]+ [∑ n f(n−k)g(k+1)]+
    n fg(n+1). 0 k k n k=1 k=0 ](img/file1211.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n ( ) (fg)(n+1) = ((fg)(n))′ = n (f(n−k)g(k))′ k=0 k ∑n ( ) = n [f(n−k+1)g(k)
    + f(n−k)g(k+1)] k=0 k ∑n ( ) ∑n ( ) = n f(n− k+1)g (k) + n f(n−k)g(k+1) k=0 k
    k=0 k ( ) n ( ) n− 1( ) ( ) = n f (n+1)g + [∑ n f(n+1−k)g(k)]+ [∑ n f(n−k)g(k+1)]+
    n fg(n+1). 0 k k n k=1 k=0 ](img/file1211.png)'
- en: First, we note that ![( ) n 0](img/file1212.png) = ![( ) n+1 0](img/file1213.png)
    = 1 and ![( ) n n](img/file1214.png) = ![( ) n+1 n+1](img/file1215.png) = 1\.
    Second, the recursive relation for binomial coefficients says that
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们注意到！[( ) n 0](img/file1212.png) = ![( ) n+1 0](img/file1213.png) = 1，且！[(
    ) n n](img/file1214.png) = ![( ) n+1 n+1](img/file1215.png) = 1。其次，二项式系数的递推关系告诉我们
- en: '![( ) ( ) ( ) n+ 1 = n + n . k k k − 1 ](img/file1216.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![( ) ( ) ( ) n+ 1 = n + n . k k k − 1 ](img/file1216.png)'
- en: With a simple reindexing, we have
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的重新索引，我们得到
- en: '![n−1( ) n ( ) ∑ n f(n− k)g(k+1) = ∑ n f(n+1−k)g (k), k k − 1 k=0 k=1 ](img/file1217.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![n−1( ) n ( ) ∑ n f(n− k)g(k+1) = ∑ n f(n+1−k)g (k), k k − 1 k=0 k=1 ](img/file1217.png)'
- en: so we can join the two sums together and obtain
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将两个和式合并，得到
- en: '![ ( ) n ( ) ( ) ( ) (fg)(n+1) = n + 1 f(n+1)g + ∑ [ n + n f(n+1−k)g(k)]+ n+
    1 fg(n+1) 0 k k − 1 n+ 1 ( ) k=1 n∑+1 n + 1 (n+1−k) (k) = k f g , k=0 ](img/file1218.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ) n ( ) ( ) ( ) (fg)(n+1) = n + 1 f(n+1)g + ∑ [ n + n f(n+1−k)g(k)]+ n+
    1 fg(n+1) 0 k k − 1 n+ 1 ( ) k=1 n∑+1 n + 1 (n+1−k) (k) = k f g , k=0 ](img/file1218.png)'
- en: which is what we had to show.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要证明的内容。
- en: 12.2.4 Extending the Function base class
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.4 扩展函数基类
- en: Now that we have several tools under our belt to calculate derivatives, it’s
    time to think about implementations. Since we have our own Function base class
    (Section [9.2.3](ch017.xhtml#function-base-class)), a natural idea is to implement
    the derivative as a method. This is a simple solution that is in line with object-oriented
    principles as well, so we should go for it!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经掌握了计算导数的几种工具，是时候考虑实现方法了。由于我们有自己的Function基类（第[9.2.3](ch017.xhtml#function-base-class)节），一个自然的想法是将导数实现为一个方法。这是一个简单的解决方案，也符合面向对象原则，所以我们应该采用它！
- en: '[PRE4]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To see a concrete example, let’s revisit the sigmoid function, whose derivative
    is given by ([12.4](ch020.xhtml)):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到一个具体的例子，让我们回顾一下sigmoid函数，它的导数由([12.4](ch020.xhtml))给出：
- en: '![ ′ σ (x) = σ(x)(1− σ (x )). ](img/file1219.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![ ′ σ (x) = σ(x)(1− σ (x )). ](img/file1219.png)'
- en: '[PRE5]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Simple implementation, powerful functionality. Now that we have the derivatives
    covered, let’s move towards calculating the derivative of more complex functions!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的实现，强大的功能。现在我们已经处理了导数问题，接下来让我们计算更复杂函数的导数！
- en: 12.2.5 The derivative of compositions
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.5 组合函数的导数
- en: At this point, I have probably emphasized the importance of function compositions
    and the chain rule (Theorem [81](ch020.xhtml#x1-202003r81)) dozens of times. We
    have finally reached a point when we are ready to implement a simple neural network
    and compute its derivative! (Of course, our methods will be far more refined in
    the end, but still, this is a milestone.)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我可能已经强调了函数组合和链式法则（定理[81](ch020.xhtml#x1-202003r81)）的重要性数十次。我们终于达到了一个节点，准备实现一个简单的神经网络并计算其导数！（当然，最终我们的方法会更加精细，但这仍然是一个里程碑。）
- en: How can we calculate the derivative for a composition of n functions?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何计算 n 个函数组合的导数？
- en: To see the pattern, let’s map out the first few cases. For n = 2, we have the
    good old chain rule
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了观察模式，让我们列出前几个情况。当 n = 2 时，我们得到经典的链式法则
- en: '![ ′ ′ ′ (f2(f1(x))) = f2(f1(x))⋅f1(x). ](img/file1220.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![ ′ ′ ′ (f2(f1(x))) = f2(f1(x))⋅f1(x). ](img/file1220.png)'
- en: For n = 3, we have
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当 n = 3 时，我们得到
- en: '![(f (f (f (x))))′ = f ′(f (f (x ))) ⋅f′(f (x))⋅f ′(x). 3 2 1 3 2 1 2 1 1 ](img/file1221.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![(f (f (f (x))))′ = f ′(f (f (x ))) ⋅f′(f (x))⋅f ′(x). 3 2 1 3 2 1 2 1 1 ](img/file1221.png)'
- en: Among the multitude of parentheses, we can notice a pattern. First, we should
    calculate the value of the composed function f[3] ∘f[2] ∘f[1] at x while storing
    the intermediate results, then pass these to the appropriate derivatives and take
    the product of the result.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多括号中，我们可以注意到一个模式。首先，我们应该计算组合函数 f[3] ∘ f[2] ∘ f[1] 在 x 处的值，并存储中间结果，然后将这些结果传递给适当的导数并求得结果的积。
- en: '[PRE6]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To see if our implementation works, we should test it on a simple test case,
    say for
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们的实现是否有效，我们应该在一个简单的测试案例上进行测试，比如：
- en: '![f1(x) = 2x, f2(x) = 3x, f3(x) = 4x. ](img/file1222.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![f1(x) = 2x, f2(x) = 3x, f3(x) = 4x. ](img/file1222.png)'
- en: The derivative of the composition (f[3] ∘f[2] ∘f[1])(x) = 24x should be constant
    24.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 组合函数 (f[3] ∘ f[2] ∘ f[1])(x) = 24x 的导数应为常数 24。
- en: '[PRE7]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![PIC](img/file1223.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1223.png)'
- en: 'Figure 12.8: The derivative of f(x) = 24x'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8：f(x) = 24x 的导数
- en: Success! Even though we’re only dealing with single-variable functions for now,
    our Composition is going to be the skeleton for neural networks.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！尽管我们现在只处理单变量函数，但我们的组合将成为神经网络的骨架。
- en: 12.2.6 Numerical differentiation
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.6 数值微分
- en: So far, we have seen that in the cases when at least some formula is available
    for the function in question, we can apply the rules of differentiation (see Theorem [80](ch020.xhtml#x1-202002r80))
    to obtain the derivative.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到，当至少有一些公式可以用于给定的函数时，我们可以应用微分规则（参见定理[80](ch020.xhtml#x1-202002r80)）来求导。
- en: However, in practice, this is often not the case. For instance, think about
    the case when the function represents a recorded audio signal. If we can’t compute
    the derivative exactly, a natural idea is to approximate it, that is, provide
    an estimate that is sufficiently close to the real value.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，情况往往并非如此。例如，想象一下函数表示的是录制的音频信号。如果我们无法准确地计算导数，一个自然的想法是进行近似，即提供一个足够接近真实值的估计。
- en: For the sake of example, suppose that we don’t know the exact formula of our
    function to be differentiated, which is secretly the good old sine function.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们不知道要微分的函数的准确公式，实际上它是经典的正弦函数。
- en: '[PRE9]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Recall that, by definition, the derivative is given by
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，根据定义，导数由以下公式给出
- en: '![f′(x ) = lim f(x-+-h)−-f(x). h→0 h ](img/file1226.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![f′(x ) = lim f(x-+-h)−-f(x). h→0 h ](img/file1226.png)'
- en: Since we can’t take limits inside a computer (as computers can’t deal with infinity),
    the second best thing to do is to approximate this by
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法在计算机内求极限（因为计算机无法处理无穷大），第二好的做法是通过以下方法进行近似：
- en: '![ f (x + h) − f(x) Δhf (x ) =-------h-------, ](img/file1227.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![ f (x + h) − f(x) Δhf (x ) =-------h-------, ](img/file1227.png)'
- en: where h/span>0 is an arbitrarily small but fixed quantity. Δ[h]f(x) is called
    the forward difference quotient. In theory, Δ[h]f(x) ≈f^′(x) holds when h is sufficiently
    small. Let’s see how they perform!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 h/span>0 是一个任意小但固定的量。Δ[h]f(x) 称为前向差分商。在理论上，当 h 足够小时，Δ[h]f(x) ≈ f^′(x) 成立。让我们看看它们是如何表现的！
- en: '[PRE10]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![PIC](img/file1228.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1228.png)'
- en: 'Figure 12.9: Approximating the derivative with finite differences'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9：用有限差分近似导数
- en: Although the Δ[h]f(x) functions seem to be close f^′(x), when h is small, there
    is a plethora of potential issues.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Δ[h]f(x) 函数似乎接近 f^′(x)，但当 h 很小时，仍然存在许多潜在问题。
- en: For one, Δ[h]f(x) = ![f(x+h)−-f(x) h](img/file1229.png) only approximates the
    derivative from the right of x, as h/span>0\. To solve this, one might use the
    backward difference quotient
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Δ[h]f(x) = ![f(x+h)−-f(x) h](img/file1229.png) 仅仅是从 x 的右侧近似导数，因为 h/span>0\.
    为了解决这个问题，人们可能会使用后向差分商。
- en: '![∇hf (x ) = f-(x-)−-f(x-−-h), h ](img/file1230.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![∇hf (x ) = f-(x-)−-f(x-−-h), h ](img/file1230.png)'
- en: but that seem to have the same problems. The crux of the issue is that if f
    is differentiable at some x, then
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 但似乎也有相同的问题。问题的关键是，如果 f 在某个 x 处可微，那么
- en: '![f(x+--h)−-f(x)-≈ f-(x)−-f(x-−-h), h h ](img/file1231.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![f(x+--h)−-f(x)-≈ f-(x)−-f(x-−-h), h h ](img/file1231.png)'
- en: but only if h is very small, and the “good enough” choice for h can vary from
    point to point.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 但只有当 h 非常小时，且对于不同点来说，“足够好”的 h 值可能会有所不同。
- en: A middle ground is provided by the so-called symmetric difference quotients,
    defined by
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一个折中的方法是所谓的对称差分商，定义为
- en: '![ f(x + h)− f (x − h) δhf(x) = --------2h--------, h ∈ (0,∞ ), ](img/file1232.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![ f(x + h)− f (x − h) δhf(x) = --------2h--------, h ∈ (0,∞ ), ](img/file1232.png)'
- en: 'which is the average of forward and backward differences: δ[h]f(x) = ![Δhf(x)+-∇hf(x)-
    2](img/file1233.png). These three approximators are called finite differences.
    With their repeated application, we can approximate higher-order derivatives as
    well.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前向差分和后向差分的平均值：δ[h]f(x) = ![Δhf(x)+-∇hf(x)- 2](img/file1233.png)。这三种近似方法被称为有限差分。通过它们的重复应用，我们也可以逼近高阶导数。
- en: Even though symmetric differences are provably better, the approximation errors
    can still be significantly amplified in the long run.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对称差分在理论上证明更好，但在长期内，近似误差仍可能显著放大。
- en: All things considered, we are not going to use finite differences for machine
    learning in practice. However, as we’ll see, the gradient descent method is simply
    a forward difference approximation of a special differential equation.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 综合考虑，我们实际上不会在机器学习中使用有限差分。然而，正如我们将看到的，梯度下降法实际上是特殊微分方程的前向差分近似。
- en: 12.3 Summary
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 小结
- en: This chapter taught us about differentiation, the key component of optimizing
    functions. Yes, even functions with millions of variables.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲解了微分，这是优化函数的关键组成部分。是的，即使是具有百万个变量的函数。
- en: Even though we focused on univariate functions (for now), we managed to build
    a deep understanding of differentiation. For instance, we’ve learned that the
    derivative
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们目前专注于一元函数，但我们成功地构建了对微分的深刻理解。例如，我们已经了解到导数
- en: '![f′(x) = lim f-(x-)−-f(y) y→x x − y ](img/file1234.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![f′(x) = lim f-(x-)−-f(y) y→x x − y ](img/file1234.png)'
- en: describes the slope of the tangent line drawn to the graph of f at x, which
    describes the velocity if f is the trajectory of a one-dimensional motion. From
    the perspective of physics, the derivative describes the rate of change.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 该式描述了切线在 x 处的斜率，若 f 是一维运动的轨迹，则描述了速度。从物理学的角度来看，导数描述了变化率。
- en: 'However, from the perspective of mathematics, differentiation offers much more
    than the rate of change: we’ve seen that a differentiable function can be written
    in the form'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从数学的角度来看，微分提供的远不止是变化率：我们已经看到可微函数可以写成如下形式
- en: '![f (x ) = f(x0) + f′(x0)(x − x0)+ o(|x− x0|) ](img/file1235.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![f (x ) = f(x0) + f′(x0)(x − x0)+ o(|x− x0|) ](img/file1235.png)'
- en: around some x[0] ∈ℝ. In other words, locally speaking, a differentiable function
    is a linear part plus a small error term. Unlike the limit-of-quotients definition,
    this will generalize for multiple variables without an issue. Moreover, we can
    apply a similar idea to obtain the so-called Taylor expansion
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个 x[0] ∈ℝ 附近。换句话说，从局部角度来看，一个可微函数是线性部分加上一个小的误差项。与商的极限定义不同，这种方法可以轻松推广到多个变量。更重要的是，我们可以应用类似的思想来得到所谓的泰勒展开
- en: '![ ∑n f (k)(x0) f(x) = --------(x− x0 )k + o(|x − x0|n), k=0 k! ](img/file1236.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n f (k)(x0) f(x) = --------(x− x0 )k + o(|x − x0|n), k=0 k! ](img/file1236.png)'
- en: allowing us to approximate transcendental functions like log x,sinx,cosx,e^x
    with polynomials.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够用多项式逼近像 log x, sinx, cosx, e^x 这样的超越函数。
- en: In addition to the theory, we also learned about computing derivatives in practice.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 除了理论，我们还学习了如何在实践中计算导数。
- en: This is done by either 1) decomposing complex functions into their building
    blocks, then calculating the derivative using the rules
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过 1) 将复杂函数分解为基本构件，然后使用规则计算导数来实现
- en: '![ ′ ′ (cf) (x) = cf (x), (f + g)′(x) = f ′(x)+ g′(x), (fg)′(x) = f ′(x)g(x)+
    f (x )g ′(x), (f ∘g)′(x) = f ′(g(x))g′(x), ](img/file1237.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![ ′ ′ (cf) (x) = cf (x), (f + g)′(x) = f ′(x)+ g′(x), (fg)′(x) = f ′(x)g(x)+
    f (x )g ′(x), (f ∘g)′(x) = f ′(g(x))g′(x), ](img/file1237.png)'
- en: or 2) approximating the derivative with finite differences like
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 或者 2) 使用有限差分近似导数，如下所示
- en: '![ f (x + h) − f(x) Δhf (x ) =---------------, h ](img/file1238.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![ f (x + h) − f(x) Δhf (x ) =---------------, h ](img/file1238.png)'
- en: where h/span>0 is a small constant. The former method is the foundation of backpropagation,
    while the latter lies at the heart of gradient descent. These are the methods
    that truly enable training huge neural networks.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 h/span>0 是一个小常数。前者方法是反向传播的基础，而后者方法是梯度下降的核心。这些方法使得训练巨大的神经网络成为可能。
- en: 'Now that we understand differentiation, it’s time to talk about its counterpart:
    integration. Let’s go!'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了微分，是时候讨论它的对立面：积分了。开始吧！
- en: 12.4 Problems
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 问题
- en: Problem 1\. Calculate the derivative of the tanh(x) function defined by
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 1\. 计算由下式定义的 tanh(x) 函数的导数
- en: '![ ex − e− x tanh(x) = -x---−-x. e + e ](img/file1239.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![ ex − e− x tanh(x) = -x---−-x. e + e ](img/file1239.png)'
- en: Problem 2\. Define the function
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 2\. 定义函数
- en: '![ ( |{ 0 if x <0, f(x) = |( x2 otherwise. ](img/file1240.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{ 0 如果 x <0, f(x) = |( x2 否则。 ](img/file1240.png)'
- en: Find the derivative of f(x). Is f^′(x) differentiable everywhere?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 求 f(x) 的导数。f^′(x) 是否在每个点都可导？
- en: Problem 3\. Define the function
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 3\. 定义函数
- en: '![ ( | { x2 if x ∈ ℚ, f (x ) = |( 2 − x otherwise. ](img/file1241.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![ ( | { x2 如果 x ∈ ℚ, f (x ) = |( 2 − x 否则。 ](img/file1241.png)'
- en: Show that
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 证明
- en: (a) f is differentiable at 0, and f^′(0) = 0, (b) and f is nowhere else differentiable.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: (a) f 在 0 处可导且 f^′(0) = 0，(b) f 在其他地方不可导。
- en: Problem 4\. Calculate the derivatives of the following functions.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 4\. 计算以下函数的导数。
- en: (a) f(x) = e^(−![ 2 x2-](img/file1242.png)) (b) f(x) = x²e^(sin x) (c) f(x)
    = sin(cosx²) (d) f(x) = ![x2+1 x2−-1](img/file1243.png)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: (a) f(x) = e^(−![ 2 x2-](img/file1242.png)) (b) f(x) = x²e^(sin x) (c) f(x)
    = sin(cosx²) (d) f(x) = ![x2+1 x2−-1](img/file1243.png)
- en: Problem 5\. Find the Taylor expansion of the following functions around 0.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 5\. 求以下函数在 0 附近的泰勒展开。
- en: (a) f(x) = sinx (b) f(x) = cosx (c) f(x) = log x (d) f(x) = e^({-x)2}
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: (a) f(x) = sinx (b) f(x) = cosx (c) f(x) = log x (d) f(x) = e^({-x)2}
- en: Problem 6\. Find the Taylor expansion of the function
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 6\. 求函数的泰勒展开
- en: '![ ( |{ − 12 f(x) = e x if x ⁄= 0, |( 0 if x = 0\. ](img/file1244.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{ − 12 f(x) = e x 如果 x ⁄= 0, |( 0 如果 x = 0\. ](img/file1244.png)'
- en: around 0\. Is the Taylor expansion of f equal to f?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0 附近。f 的泰勒展开是否等于 f？
- en: Join our community on Discord
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、机器学习专家以及作者本人一起阅读本书。提出问题，为其他读者提供解决方案，通过问我任何问题的环节与作者聊天，等等。扫描二维码或访问链接加入社区。[https://packt.link/math](https://packt.link/math)
- en: '![PIC](img/file1.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
