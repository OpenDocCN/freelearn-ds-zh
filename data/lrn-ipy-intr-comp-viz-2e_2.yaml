- en: Chapter 2. Interactive Work with IPython
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 与IPython进行交互工作
- en: 'In this chapter, we will detail the various improvements that IPython brings
    to the standard Python console. In particular, we will perform the following tasks:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细介绍IPython为标准Python控制台带来的各种改进。特别是，我们将执行以下任务：
- en: Access the system shell from IPython for powerful interactions between the shell
    and Python
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从IPython访问系统shell，实现强大的shell和Python之间的交互
- en: Use dynamic introspection to explore Python objects or even a new Python package
    without even the need to look at the documentation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态内省来探索Python对象，甚至是一个新的Python包，甚至无需查看文档
- en: Easily debug and benchmark your code from IPython
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从IPython轻松调试和基准测试您的代码
- en: Learn how to use the IPython notebook to improve considerably the way you interact
    with Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用IPython笔记本显著改善与Python的交互方式
- en: The extended shell
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展的shell
- en: IPython is not only an extended Python console, but it also provides several
    ways to interact with the operating system during a Python interactive session
    without quitting the console. The shell features of IPython are not meant to replace
    the Unix shell, and IPython offers far less features. Yet, it is still quite convenient
    to be able to navigate through the filesystem during a Python session and to occasionally
    call system commands from IPython. Moreover, IPython provides useful magic commands
    that considerably improve productivity and reduce repetitive typing during an
    interactive session.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: IPython不仅是一个扩展的Python控制台，还提供了几种在Python交互会话期间与操作系统交互的方式，而无需退出控制台。IPython的shell功能并不意味着取代Unix
    shell，并且IPython提供的功能远不及Unix shell。然而，在Python会话期间浏览文件系统并偶尔从IPython调用系统命令仍然非常方便。此外，IPython提供了有用的魔术命令，可以显著提高生产力，并在交互会话期间减少重复输入。
- en: Navigating through the filesystem
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览文件系统
- en: Here, we will show how we can download and extract compressed files from the
    Internet, navigate in a filesystem hierarchy, and open text files from IPython.
    To do this, we will use an example with real data about the social networks of
    hundreds of anonymous people on Facebook (who volunteered to share their data
    anonymously to computer scientists for research purposes). This BSD-licensed data
    are provided freely by the SNAP project from Stanford University ([http://snap.stanford.edu/data/](http://snap.stanford.edu/dat)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将展示如何从互联网下载并提取压缩文件，在文件系统层次结构中导航，并从IPython打开文本文件。为此，我们将使用一个关于数百名匿名Facebook用户社交网络的真实数据示例（他们自愿匿名分享数据以供计算机科学家进行研究）。这些受BSD许可的数据由斯坦福大学的SNAP项目免费提供（[http://snap.stanford.edu/data/](http://snap.stanford.edu/dat)）。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: 'You can download the example code files for all Packt books that you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you. In addition, all examples
    can be downloaded from the author''s website: [http://ipython.rossant.net](http://ipython.rossant.net).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)购买的所有Packt图书的帐户中下载示例代码文件。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。此外，所有示例都可以从作者的网站下载：[http://ipython.rossant.net](http://ipython.rossant.net)。
- en: 'First, we need to download the ZIP file containing the data from the author''s
    webpage. We use the native Python module `urllib2` to download the file, and the
    `zipfile` module to extract it. Let''s enter the following commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从作者的网页下载包含数据的ZIP文件。我们使用原生Python模块`urllib2`下载文件，并使用`zipfile`模块进行解压。让我们输入以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we downloaded the file `http://ipython.rossant.net/facebook.zip` in the
    memory, and we are going to save it on the hard drive.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在内存中下载了文件`http://ipython.rossant.net/facebook.zip`，并将其保存在硬盘上。
- en: 'Now, we create a new folder named `data` in the current directory, and we enter
    it. The dollar (`$`) sign allows us to use a Python variable within a system or
    magic command. Let''s enter the following commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在当前目录中创建一个名为`data`的新文件夹，并进入其中。美元符号（`$`）允许我们在系统或魔术命令中使用Python变量。让我们输入以下命令：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, `mkdir` is a particular IPython *alias* redirecting a magic command to
    a shell command. The list of aliases can be obtained with the magic `%alias` command.
    In this folder, we are going to save the file we have just downloaded (in line
    eight, we locally save the ZIP file in `facebook.zip` in the current directory
    `data`), and extract it in the current folder (as shown in line nine, with the
    `extractall` method of `zip` and a `ZipFile` object). Let''s enter the following
    commands:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mkdir` 是一个特定的 IPython *别名*，它将一个魔法命令重定向为一个 shell 命令。可以通过魔法命令 `%alias` 获取别名列表。在这个文件夹中，我们将保存刚刚下载的文件（在第八行，我们将
    ZIP 文件 `facebook.zip` 本地保存到当前目录 `data` 中），并在当前文件夹中解压它（如第九行所示，使用 `zip` 的 `extractall`
    方法和 `ZipFile` 对象）。让我们输入以下命令：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s explore what we have just downloaded using the following commands:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令来探索刚刚下载的内容：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, each number identifies a Facebook user (called the `ego` user).
    The `.edges` file contains its *social graph*, that is, the graph where each node
    is a friend, and two friends of the `ego` user are connected if they are friends
    of each other. This graph is stored as an `edges` list, a text file where each
    line contains two connected nodes' identifiers separated by a space. The `.circles`
    file contains manually-created friends' lists, that is, the groups of friends
    that share common attributes from the `ego` user's viewpoint.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，每个数字表示一个 Facebook 用户（称为 `ego` 用户）。`.edges` 文件包含其 *社交图*，即每个节点是一个朋友，如果 `ego`
    用户的两个朋友互为朋友，则它们之间有连接。该图以 `edges` 列表的形式存储，这是一个文本文件，每行包含两个用空格分隔的连接节点标识符。`.circles`
    文件包含手动创建的朋友列表，即从 `ego` 用户的视角出发，拥有共同属性的朋友组。
- en: 'Finally, we save the current `facebook` directory as a bookmark using the following
    command so we can easily enter into this directory later:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下命令将当前 `facebook` 目录保存为书签，以便以后可以轻松进入该目录：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, in any future session with the same IPython profile, we can type `cd fbdata`
    to enter into this directory, whichever directory we call this command from. The
    `-l` and `-d` options allow to respectively list all defined bookmarks, and delete
    a specified bookmark. Typing `%bookmark?` displays the list of all options. This
    magic command can be really helpful when navigating back and forth between several
    folders.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在任何未来使用相同 IPython 配置文件的会话中，我们都可以键入 `cd fbdata` 进入此目录，无论我们从哪个目录调用此命令。`-l`
    和 `-d` 选项分别允许列出所有定义的书签和删除指定书签。输入 `%bookmark?` 会显示所有选项的列表。当在多个文件夹之间来回导航时，这个魔法命令非常有用。
- en: 'Another convenient navigation-related function in IPython is *tab* completion.
    IPython can automatically complete the file or folder name we are typing if we
    press the *Tab* key. If several options are possible, IPython will show us the
    list of all possible options. It also works with filenames, for instance, in the
    `open` built-in function, as shown in the following example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 中另一个方便的与导航相关的功能是 *Tab* 补全。只要按下 *Tab* 键，IPython 就能自动完成我们正在输入的文件或文件夹名称。如果有多个选项，IPython
    会显示所有可能选项的列表。它也适用于文件名，例如在 `open` 内置函数中，如下例所示：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Accessing the system shell from IPython
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 IPython 访问系统 shell
- en: 'We can also launch commands using the system shell directly from IPython, and
    retrieve the result as a list of strings in a Python variable. To do this, we
    need to prefix shell commands with `!`. For example, assuming that we are using
    a Unix system, we can type the following commands:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以直接从 IPython 启动命令，使用系统 shell 并将结果作为字符串列表保存在 Python 变量中。为此，我们需要在 shell 命令前加上
    `!`。例如，假设我们使用的是 Unix 系统，我们可以输入以下命令：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Unix command `ls -1 -S` lists all files in the current directory, sorted
    by decreasing size, and with one file per line. The pipe `| grep edges` filters
    only those files that contain `edges` (these are the files with social graphs
    of different networks). Then, the Python variable `files` contains the list of
    all filenames, as shown in the following example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 命令 `ls -1 -S` 列出当前目录中的所有文件，按大小降序排序，并且每行列出一个文件。管道 `| grep edges` 仅筛选包含 `edges`
    的文件（这些是包含不同网络社交图的文件）。然后，Python 变量 `files` 包含所有文件名的列表，如下例所示：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also use Python variables in the system command, using either the `$`
    syntax for single variables, or `{}` for any Python expression, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在系统命令中使用 Python 变量，使用 `$` 语法表示单个变量，或使用 `{}` 来表示任何 Python 表达式，如下所示：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `head -n5 {files[0]}` command displays the first five lines of the first
    file in the `files` list, that is, the first five lines of the largest `.edges`
    file in the dataset.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`head -n5 {files[0]}` 命令显示 `files` 列表中第一个文件的前五行，即数据集中最大 `.edges` 文件的前五行。'
- en: 'If we find ourselves using the same command over and over, we can create an
    **alias** to save some repetitive typing, using the magic `%alias` command. For
    instance, in the following example we create an alias called `largest` that is
    used to display on a single column `(-1`) all files with their sizes (`-hs`),
    filtered with a specified string (`grep`) and ordered by their decreasing size
    (`-S`):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现自己一遍又一遍地使用相同的命令，我们可以创建一个 **别名** 来减少重复输入，使用魔法命令 `%alias`。例如，在以下示例中，我们创建了一个名为
    `largest` 的别名，用于显示所有文件及其大小（`-hs`），并按其大小降序排序（`-S`），同时使用指定的字符串（`grep`）进行过滤，显示在单列中（`-1`）：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In line five, note the `%s` positional placeholder for the `largest` alias,
    which will be replaced by any argument given to the alias (as shown in line six).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第五行中，注意 `%s` 是 `largest` 别名的定位符，它会被传递给别名的任何参数所替代（如第六行所示）。
- en: 'Note that, by default, this alias will not be saved for future use in the next
    interactive sessions (after closing IPython). We need to save it explicitly with
    the `%store` magic command as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，这个别名不会保存到下次交互式会话中（关闭 IPython 后）。我们需要使用 `%store` 魔法命令显式地保存它，如下所示：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In addition, to recover the stored aliases and variables in a later session,
    we will need to type `%store -r`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，要在以后的会话中恢复存储的别名和变量，我们需要输入 `%store -r`。
- en: The extended Python console
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展的 Python 控制台
- en: We will now explore the Python-related capabilities of the **IPython** console.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探索 **IPython** 控制台与 Python 相关的功能。
- en: Exploring the history
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览历史记录
- en: IPython keeps track of all our input history across all sessions. Since this
    history can become quite large after months or years of working with IPython,
    there are convenient ways of navigating through it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 会跟踪我们所有会话中的输入历史记录。由于在使用 IPython 数月或数年后，这些历史记录可能会变得相当庞大，因此提供了方便的方式来浏览历史记录。
- en: First, we can press the up and down keys at any time in the IPython prompt to
    navigate linearly through our recent history. If we type something before pressing
    the up and downkeys, we only navigate through the input commands that match what
    we have typed so far. Pressing *Ctrl* + *R* opens a prompt that allows us to search
    for a line that contains whatever we type in this prompt.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以随时按下上下键，在 IPython 提示符下线性地浏览我们最近的历史记录。如果我们在按上下键之前输入了内容，系统只会在匹配我们已输入的内容的命令中浏览历史记录。按下
    *Ctrl* + *R* 会打开一个提示符，让我们搜索包含我们输入的任何内容的行。
- en: The `%history` magic command (and `%hist`, which is an alias) accepts multiple
    convenient options to display the part of the input history we are interested
    in. By default, `%history` displays all our input history in the current session.
    We can specify a specific line range with a simple syntax, for example, `hist
    4-6 8` for lines four to six and line eight. We can also choose to display our
    history from the previous sessions with the syntax `hist 243/4-8` for lines four
    to eight in session 243\. Finally, we can number the sessions relative to the
    current session using the syntax `%hist ~1/7`, which shows line seven of the previous
    session.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`%history` 魔法命令（以及它的别名 `%hist`）接受多个方便的选项，来显示我们感兴趣的输入历史记录部分。默认情况下，`%history`
    会显示当前会话中的所有输入历史记录。我们可以使用简单的语法指定特定的行范围，例如，`hist 4-6 8` 表示第四到第六行和第八行。我们还可以选择使用语法
    `hist 243/4-8` 来显示第243号会话中的第四到第八行历史记录。最后，我们可以使用语法 `%hist ~1/7` 来相对于当前会话编号历史记录行，它会显示前一个会话的第七行。'
- en: 'Other useful options for `%history` include `-o`, which displays the output
    in addition to the input; `-n`, which displays the line numbers; `-f`, which saves
    the history to a file; and `-p`, which displays the classic `>>>` prompt. For
    example, this can prove to be useful for automatically creating a `doctest` file
    from the history. Also, the `-g` option allows to filter the history with a specified
    string (like `grep`). Consider the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`%history` 还有其他有用的选项，包括 `-o`，它会显示输入历史记录的输出；`-n`，它会显示行号；`-f`，它会将历史记录保存到文件；`-p`，它会显示经典的
    `>>>` 提示符。例如，这对于自动从历史记录中创建 `doctest` 文件可能会非常有用。另外，`-g` 选项允许使用指定的字符串（如 `grep`）过滤历史记录。考虑以下示例：'
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we display the history of the first two lines with the line
    number, the output, and the default Python prompt.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们显示了前两行的历史记录，包括行号、输出和默认的Python提示符。
- en: Finally, a related command is `%store`, which is used to save the content of
    any Python variable for later use in any future interactive session. The `%store
    name` command saves the variable `name`, and `%store -d name` deletes it. To recover
    the stored variables, we need to use `%store -r`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个相关的命令是`%store`，用于保存任何Python变量的内容，以便在任何未来的交互式会话中使用。`%store name`命令保存变量`name`，`%store
    -d name`删除它。要恢复存储的变量，我们需要使用`%store -r`。
- en: Import/export of Python code
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入/导出Python代码
- en: In the following section, we will first see how to import code from a Python
    script in the interactive console, and then how to export code from the history
    into an external file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将首先看到如何从Python脚本中的交互式控制台导入代码，然后看看如何将历史记录中的代码导出到外部文件。
- en: Importing code in IPython
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在IPython中导入代码
- en: A first possibility to import code in IPython is to copy and paste code from
    a file to IPython. When using the **IPython** console, the `%paste` magic command
    can be used to import and execute the code contained in the clipboard. IPython
    automatically dedents the code and removes the `>` and `+` characters at the beginning
    of the lines, allowing to paste the `diff` and `doctest` files directly from e-mails.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPython中导入代码的第一种可能性是将代码从文件复制粘贴到IPython中。当使用**IPython**控制台时，`%paste`魔术命令可用于导入并执行剪贴板中包含的代码。IPython会自动去除代码的缩进，并删除行首的`>`和`+`字符，从而可以直接从电子邮件中粘贴`diff`和`doctest`文件。
- en: In addition, the `%run` magic command executes a Python script in the console,
    by default, in an empty namespace. It means that any variable defined in the interactive
    namespace is not available within the executed script. However, at the end of
    the execution, the control returns to IPython's prompt, and the variables defined
    in the script are then imported in the interactive namespace. This is very convenient
    for exploring the state of all variables at the end of the script's execution.
    This behavior can be changed with the `-i` option, which uses the interactive
    namespace for the execution. The variables defined in the interactive namespace
    before the script's execution are then available in the script.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`%run`魔术命令在控制台中执行Python脚本，默认情况下在一个空的命名空间中。这意味着在交互式命名空间中定义的任何变量在执行的脚本中不可用。然而，在执行结束时，控制返回到IPython提示符，并且在交互式命名空间中导入了脚本中定义的变量。这对于探索脚本执行结束时所有变量的状态非常方便。可以使用`-i`选项更改此行为，该选项在执行时使用交互式命名空间。在执行脚本之前在交互式命名空间中定义的变量然后在脚本中可用。
- en: 'For example, let''s write a script `/home/me/data/egos.py` that lists all ego
    identifiers in Facebook''s `data` folder. Since each filename is of the form `<egoid>.<extension>`,
    we list all the files, remove the extensions, and take the sorted list of all
    unique identifiers. The script should contain the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们编写一个脚本`/home/me/data/egos.py`，列出Facebook的`data`文件夹中的所有自我标识符。由于每个文件名的格式为`<egoid>.<extension>`，我们列出所有文件，删除扩展名，并获取所有唯一标识符的排序列表。脚本应包含以下代码：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here is an explanation of what the last line does. The `lambda` function takes
    a filename as an argument following the template `<egoid>.<extension>`, and returns
    the `egoid` ID as an integer. It uses the `split` method of any string, which
    splits a string with a given character and returns a list of substrings, which
    are separated by this character. Here, the first element of the list is the `<egoid>`
    part. The `map` built-in Python function applies this `lambda` function to all
    filenames. The `set` function converts this list to a `set` object, thereby removing
    all duplicates and keeping only a list of unique identifiers (since any identifier
    appears twice with two different extensions). Finally, the `sorted` function converts
    the `set` object to a list, and sorts it in an increasing order.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里解释了最后一行的作用。`lambda`函数以`<egoid>.<extension>`的模板作为参数，返回`egoid` ID作为整数。它使用任何字符串的`split`方法，该方法使用给定字符拆分字符串，并返回由此字符分隔的子字符串列表。在这里，列表的第一个元素是`<egoid>`部分。内置的Python
    `map`函数将此`lambda`函数应用于所有文件名。`set`函数将此列表转换为`set`对象，从而删除所有重复项，仅保留唯一标识符的列表（因为任何标识符都会以两种不同的扩展出现两次）。最后，`sorted`函数将`set`对象转换为列表，并按升序排序。
- en: 'Assuming the current directory in IPython is `/home/me/data`, following is
    the command to execute this script:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 IPython 中的当前目录是 `/home/me/data`，以下是执行此脚本的命令：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `egos.py` script, the folder name `facebook` is retrieved from the command-line
    arguments, like in a standard command-line Python script, with `sys.argv[1]`.
    After the script has been executed, the `ids` variable defined in the script is
    available in the interactive namespace, and contains the list of unique `ego`
    identifiers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `egos.py` 脚本中，文件夹名称 `facebook` 是从命令行参数中检索的，就像在标准命令行 Python 脚本中一样，使用 `sys.argv[1]`。脚本执行后，在交互式命名空间中可用的
    `ids` 变量包含了唯一 `ego` 标识符的列表。
- en: 'Now, following is what happens if we do not provide the folder name as an argument
    to the script:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们不将文件夹名称作为脚本的参数提供，将会发生以下情况：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: An exception is raised in line four since `folder` is not defined. If we want
    the script to use the `folder` variable defined in the interactive namespace,
    we need to use the `-i` option.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四行引发了一个异常，因为未定义 `folder`。如果希望脚本使用交互式命名空间中定义的 `folder` 变量，需要使用 `-i` 选项。
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Interactive workflow in exploratory research**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**探索性研究中的交互式工作流**'
- en: A standard workflow in exploratory research or in data analysis is to implement
    algorithms in one or several Python modules and write a script that executes the
    full process. This script can then be executed with `%run` and allows further
    interactive exploration of the script variables. This iterative process involves
    switching between a text editor and the **IPython** console. A more modern and
    practical approach is to use the IPython notebook, as we will see in the section
    *Using the IPython notebook*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索性研究或数据分析中的标准工作流程是在一个或多个 Python 模块中实现算法，并编写一个执行完整流程的脚本。然后可以使用 `%run` 执行此脚本，并允许进一步交互式探索脚本变量。这个迭代过程涉及在文本编辑器和**IPython**控制台之间切换。一个更现代和实用的方法是使用
    IPython 笔记本，我们将在 *使用 IPython 笔记本* 部分看到。
- en: Exporting code to a file
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将代码导出到文件
- en: 'While the `%run` magic command allows to import code from a file to the interactive
    console, the `%edit` command does the opposite. By default, `%edit` opens the
    system''s text editor and executes the code when we close the editor. If we supply
    an argument to `%edit`, this command will try to open the text editor with the
    code we supplied. The argument can be as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `%run` 魔术命令允许从文件导入代码到交互式控制台，但 `%edit` 命令则相反。默认情况下，`%edit` 打开系统的文本编辑器，并在关闭编辑器时执行代码。如果向
    `%edit` 提供参数，此命令将尝试使用我们提供的代码打开文本编辑器。参数可以是以下内容：
- en: A Python script filename
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 脚本文件名
- en: A string variable containing Python code
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 Python 代码的字符串变量
- en: A range of line numbers, with the same syntax of `%history`, which was used
    previously
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列行号，与之前使用的 `%history` 语法相同
- en: Any Python object, in which case IPython will try to open the editor with the
    file where this object has been defined
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何 Python 对象，此时 IPython 将尝试使用包含定义此对象的文件打开编辑器
- en: A more modern and powerful way of using a multiline text editor with IPython
    is to use the notebook, as we will see in the *Using the IPython notebook* section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IPython 与多行文本编辑器的更现代和强大的方式是使用笔记本，我们将在 *使用 IPython 笔记本* 部分看到。
- en: Dynamic introspection
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态内省
- en: IPython offers several features for dynamically inspecting Python objects in
    the namespace.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 提供了几个功能，用于动态检查命名空间中的 Python 对象。
- en: Tab completion
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制表完成
- en: At any time, we can type `TAB` in the console to let IPython either complete
    or propose a list of possible names or commands that match what we have typed
    so far. This allows, in particular, to dynamically inspect all attributes and
    methods of any Python object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以在控制台中键入 `TAB`，让 IPython 完成或提供与我们迄今为止键入的内容匹配的可能名称或命令列表。这允许特别动态地检查任何 Python
    对象的所有属性和方法。
- en: Tab completion also works for global variables in the interactive namespace,
    modules, and file paths in the current directory. By default, variables that begin
    with `_` (underscore) are not shown, because it is a Python convention to prefix
    private variables with an underscore. However, typing `_` before pressing *Tab*
    forces IPython to display all private variables.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 制表完成也适用于交互式命名空间中的全局变量、模块和当前目录中的文件路径。默认情况下，以 `_`（下划线）开头的变量不会显示，因为 Python 习惯于使用下划线前缀私有变量。但是，在按下
    *Tab* 之前键入 `_` 强制 IPython 显示所有私有变量。
- en: An example of tab completion NetworkX
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 NetworkX 中使用制表完成的示例
- en: 'Here, we will use tab completion to find out how we can load and manipulate
    a graph with the *NetworkX* package. This package is commonly used when working
    with graphs. Let''s execute the following command to import the package:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用制表符补全来找出如何使用 *NetworkX* 包加载和操作图形。在处理图形时，这个包通常被使用。让我们执行以下命令来导入这个包：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To find the available options for opening a graph, we can look for the possible
    methods prefixed with `read`, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出打开图形的可用选项，我们可以查找以 `read` 为前缀的可能方法，如下所示：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since the `.edges` files contain a list of edges, we try the following command
    (assuming we are in the `fbdata` folder):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `.edges` 文件包含一系列边，我们尝试以下命令（假设我们在 `fbdata` 文件夹中）：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that the graph `g` appears to be loaded, we can explore the methods offered
    by this new object, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在图形 `g` 看起来已经加载，我们可以探索这个新对象提供的方法，如下所示：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The 0 ego user then appears to have 333 friends, and there are 2519 connections
    between these friends.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第 0 个 ego 用户似乎有 333 个朋友，这些朋友之间有 2519 个连接。
- en: 'Let''s explore the structure of this graph a bit more. How well connected are
    any two users in this graph? The theory of small-world graphs predicts that any
    two persons are about six links away in a social graph. Here, we can compute the
    *radius* and *diameter* of the graph, that is, the minimum and maximum path length
    between any two nodes. Tab completion shows that there is a `radius` method in
    the NetworkX package. So, we try the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探索这个图形的结构。在这个图形中，任意两个用户之间有多好的连接？小世界图的理论预测，在社交图中，任意两个人之间大约相隔六个链接。在这里，我们可以计算图形的*半径*和*直径*，即任意两个节点之间的最小和最大路径长度。制表符补全显示
    NetworkX 包中有一个 `radius` 方法。因此，我们尝试以下命令：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our graph appears to be disconnected since the radius and diameter are not
    well defined. To work around this problem, we can take a connected component of
    the graph, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图形似乎是不连通的，因为半径和直径没有明确定义。为了解决这个问题，我们可以取图形的一个连通分量，如下所示：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second proposition looks like a good choice (hence, the importance of choosing
    good names when creating a package!), as shown in the following commands:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命题看起来是一个不错的选择（因此，在创建包时选择好的名称的重要性就显现出来了！），如下所示：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are five connected components; we take the largest one and compute its
    radius and diameter. Hence, any two friends are connected through less than 11
    levels, and there is one friend that is less than six links away from any other
    friend.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个连通分量；我们取最大的一个并计算它的半径和直径。因此，任意两个朋友之间通过不到 11 个级别连接，而且有一个朋友距离任何其他朋友不到六个链接。
- en: Tab completion with custom classes
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用自定义类的制表符补全
- en: 'If we define our own classes, we can customize the way their instances work
    with IPython tab completion. All we have to do is override the `__dir__` method
    to return the list of attributes as shown in the following commands:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义自己的类，我们可以定制它们的实例在 IPython 制表符补全中的工作方式。我们所要做的就是重写 `__dir__` 方法，返回属性列表，如下所示：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This feature can be useful in some scenarios where the list of interesting attributes
    of an instance is defined dynamically.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性在某些情况下可能很有用，其中实例的有趣属性列表是动态定义的。
- en: Source code introspection
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源代码内省
- en: IPython can also display information about the internals of a variable, in particular
    about the source code when it is defined in a file. First, typing `?` before or
    after a variable name prints useful information about it. Typing `??` gives more
    detailed information, in particular, the source code of the object, if it is a
    function defined in a file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 还可以显示有关变量内部的信息，特别是当它在文件中定义时的源代码信息。首先，在变量名之前或之后键入 `?` 会打印有用的信息。键入 `??`
    会给出更详细的信息，特别是对象的源代码，如果它是在文件中定义的函数。
- en: In addition, several magic commands display specific information about a variable,
    such as the source code of the function (`%psource`) or of the file (`%pfile`)
    where it is defined, the docstring (`%pdoc`), or the definition header `(%pdef`).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，几个魔术命令显示有关变量的特定信息，例如函数的源代码（`%psource`）或定义它的文件的源代码（`%pfile`），文档字符串（`%pdoc`），或定义头部（`%pdef`）。
- en: The `%pfile` magic command also accepts a Python filename, in which case, it
    prints the file's contents with syntax highlighting. With this function, IPython
    can then act as a code viewer with syntax highlighting.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`%pfile` 魔术命令还接受一个 Python 文件名，此时它会打印带有语法高亮的文件内容。有了这个功能，IPython 就可以作为带有语法高亮的代码查看器。'
- en: Using the interactive debugger
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用交互式调试器
- en: For most of us, debugging is an important part of the programming job. IPython
    makes it extremely convenient to debug a script or an entire application. It provides
    interactive access to an enhanced version of the Python debugger.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们大多数人来说，调试是编程工作中一个重要的部分。IPython 使得调试脚本或整个应用程序变得极其方便。它提供了交互式访问增强版的 Python 调试器。
- en: First, when we encounter an exception, we can use the `%debug` magic command
    to launch the IPython debugger at the exact point where the exception was raised.
    If we activate the `%pdb` magic command, the debugger will be automatically launched
    upon the very next exception. We can also start IPython with `ipython --pdb` for
    the same behavior. Finally, we can run a whole script under the control of the
    debugger with the `%run -d` command. This command executes the specified script
    with a break point at the first line so that we can precisely control the execution
    flow of the script. We can also specify explicitly where to put the first breakpoint;
    typing `%run -d -b29 script.py` pauses the program execution on line 29 of `script.py`.
    We first need to type `c` to start the script execution.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当我们遇到异常时，可以使用 `%debug` 魔法命令在异常抛出的位置启动 IPython 调试器。如果我们激活 `%pdb` 魔法命令，调试器将在下一个异常发生时自动启动。我们还可以通过
    `ipython --pdb` 启动 IPython，以获得相同的行为。最后，我们可以使用 `%run -d` 命令在调试器的控制下运行整个脚本。此命令会在第一行设置断点执行指定的脚本，以便我们可以精确控制脚本的执行流程。我们还可以显式指定第一断点的位置；输入
    `%run -d -b29 script.py` 会在 `script.py` 的第 29 行暂停程序执行。我们需要先输入 `c` 来开始执行脚本。
- en: 'When the debugger launches, the prompt becomes `ipdb>`. The program execution
    is then paused at a given point in the code. We can use the `w` command to display
    the line and the location in the stack traceback where the debugger has paused.
    At this point, we have access to all local variables and we can control precisely
    how we want to resume the execution. Within the debugger, several commands are
    available to navigate into the traceback:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试器启动时，提示符变为 `ipdb>`。程序执行将在代码中的某个特定位置暂停。我们可以使用 `w` 命令来显示调试器暂停时的代码行及堆栈跟踪位置。在这个时候，我们可以访问所有本地变量，并可以精确控制如何继续执行。在调试器中，提供了若干命令用于在堆栈跟踪中导航：
- en: '`u`/`d` for going *up/down* into the call stack'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u`/`d` 用于在调用堆栈中向 *上/下* 移动'
- en: '`s` to *step* into the next statement'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s` 用于 *进入* 下一条语句'
- en: '`n` to continue execution until the *next line* in the current function'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n` 用于继续执行，直到当前函数中的 *下一行*'
- en: '`r` to continue execution until the current function *returns*'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r` 用于继续执行，直到当前函数 *返回*'
- en: '`c` to *continue* execution until the next breakpoint or exception'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c` 用于 *继续* 执行，直到下一个断点或异常'
- en: 'Other useful commands include:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的命令包括：
- en: '`p` to evaluate and *print* any expression'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p` 用于评估并 *打印* 任何表达式'
- en: '`a` to obtain the *arguments* of the current functions'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a` 用于获取当前函数的 *参数*'
- en: The `!` prefix to execute any Python command within the debugger
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!` 前缀用于在调试器中执行任何 Python 命令'
- en: The entire list of commands can be found in the documentation of the `pdb` module
    in Python.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的命令列表可以在 Python 中的 `pdb` 模块文档中找到。
- en: Interactive benchmarking and profiling
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式基准测试和性能分析
- en: 'Donald Knuth said:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 唐纳德·克努斯（Donald Knuth）曾说：
- en: '"Premature optimization is the root of all evil."'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “过早的优化是万恶之源。”
- en: This means that optimization should only occur in case of absolute necessity,
    and if the code has been thoroughly profiled so that you know exactly what portion
    of the code needs to be optimized. IPython makes this benchmarking and profiling
    process easy.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着优化只应在绝对必要的情况下进行，并且在代码经过充分分析后，您需要明确知道哪些部分的代码需要优化。IPython 使得这一基准测试和性能分析过程变得简便。
- en: Controlling the execution time of a command
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制命令的执行时间
- en: First, the `%timeit` magic function uses the Python's `timeit` module to estimate
    the execution time of any Python statement. If we have defined a function `fun(x)`,
    `%timeit fun(x)` executes this command multiple times and returns an average of
    the execution time. The number of calls is determined automatically; there are
    `r` loops of `n` executions each. These numbers can be specified with the `-r`
    and `-n` options to `%timeit`. Also, we can easily estimate the execution time
    of a script with the `%run -t` command.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`%timeit` 魔法函数使用 Python 的 `timeit` 模块来估算任何 Python 语句的执行时间。如果我们定义了一个函数 `fun(x)`，`%timeit
    fun(x)` 将多次执行该命令并返回执行时间的平均值。调用次数会自动确定；每个循环有 `r` 次执行，每次执行 `n` 次。这些数字可以通过 `%timeit`
    的 `-r` 和 `-n` 选项进行指定。此外，我们还可以使用 `%run -t` 命令轻松估算脚本的执行时间。
- en: 'In the following example, we compute the *center* of `sg`, that is, the set
    of nodes with eccentricity equal to the radius (that is, the friends in the `ego`
    circle who are the most well connected to all other friends), and estimate the
    time it takes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们计算`sg`的*中心*，即偏心率等于半径的节点集合（即在`ego`圈子中与所有其他朋友最为连接的朋友），并估算其所需时间：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can see in the previous example that it took 377 milliseconds for Python
    and NetworkX to compute the center of `sg`. The `center` function has been called
    three times (`best of 3` in the output `19`), and the smallest time of execution
    has been automatically selected (since the very first execution can take longer,
    due to some Python imports, for instance).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的示例中看到，Python 和 NetworkX 计算`sg`的中心花费了377毫秒。`center`函数被调用了三次（输出中的`best
    of 3`为`19`），并且自动选择了最短的执行时间（因为第一次执行可能会更长，举例来说，可能因为一些Python导入的原因）。
- en: Profiling a script
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本分析
- en: To obtain much more detailed information about the execution time of a program,
    we can execute it under the control of a *profiler*, like the one provided natively
    by the `profile` Python module. Profiling is a complex topic, and we are just
    going to show a basic usage example here. More details about the `profile` module
    can be found in the official Python documentation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取有关程序执行时间的更详细信息，我们可以在*分析器*的控制下执行它，像Python的`profile`模块原生提供的那样。分析是一个复杂的话题，我们这里只展示一个基本的使用示例。有关`profile`模块的更多细节，可以参考官方的Python文档。
- en: To run a script under the control of the profiler, we can execute it from IPython
    with `%run -p` or with the equivalent `%prun` magic command.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要在分析器的控制下运行脚本，我们可以通过IPython执行`%run -p`或等效的`%prun`魔术命令。
- en: 'Here, we will write a small Python script that computes the center of the graph
    without using the built-in NetworkX `center` function. Let''s create a script
    called `center.py` with the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写一个小的Python脚本，计算图的中心，而不使用内置的NetworkX `center`函数。让我们创建一个名为`center.py`的脚本，代码如下：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s run it and estimate the time it takes using the following commands:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行它并使用以下命令估算所需的时间：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This script took more than two minutes to execute; this looks particularly bad!
    We can run the profiler with the command `%run –p center.py` to find out what
    is taking so long.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本执行了超过两分钟；这看起来特别糟糕！我们可以使用命令`%run –p center.py`运行分析器，找出到底是什么导致了这么长的时间。
- en: 'The profiler outputs details about calls of every Python function used directly
    or indirectly in this script. For example, the `cumtime` column prints the cumulative
    time spent within every function. It appears, from the previous example, that
    `eccentricity` and `radius` are the major bottlenecks, because they are called
    648 and 324 times, respectively! Looking more closely at the code shows that we
    are indeed doing something stupid; that is, we are calling these two functions
    repetitively within the loop. We can considerably improve the performance of this
    script by *caching* the output of these functions. Let''s modify the script in
    `center2.py`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器输出了关于每个直接或间接使用的Python函数的调用详情。例如，`cumtime`列打印了每个函数内累计的时间。从前面的示例来看，`eccentricity`和`radius`是主要的瓶颈，因为它们分别被调用了648次和324次！仔细查看代码后发现，我们确实做了一些愚蠢的事情；也就是说，我们在循环内重复调用这两个函数。通过*缓存*这些函数的输出，我们可以显著提高这个脚本的性能。让我们修改`center2.py`中的脚本：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we compute the eccentricity of all nodes with a single call to `eccentricity`
    before the loop, and we compute the radius of the graph only once. Let''s check
    the performance of this improved script by executing the following commands:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在循环之前通过一次调用`eccentricity`计算所有节点的偏心率，并且只计算一次图的半径。让我们通过执行以下命令来检查改进后脚本的性能：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this modification, our computation takes less than a second instead of
    two minutes! Of course, even if this example was a particularly trivial one, this
    kind of mistake can be made by any programmer at some point in a long program.
    Then, it may not be so obvious to find this bottleneck just by reading the code.
    The best way to find such hotspots is to use a profiler, and IPython makes this
    task particularly easy.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个修改，我们的计算时间缩短到不到一秒，而不是两分钟！当然，即使这个示例特别简单，这种错误也可能是任何程序员在编写长程序时犯的。然后，仅通过阅读代码，可能不容易发现这个瓶颈。找到这些热点的最佳方式是使用分析器，而IPython使这个任务变得特别简单。
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Using a line-by-line profiler**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**逐行分析器的使用**'
- en: For even more fine-grained profiling, we can use a line-by-line profiler. This
    tool analyzes the time taken by every single line in a set of functions chosen
    by the programmer. In Python, the `line_profiler` package does exactly this. The
    functions to profile are indicated with a `@profile` decorator. Its usage is less
    straightforward than the IPython profiler, and we invite the interested reader
    to check out the package's website at [http://packages.python.org/line_profiler/](http://packages.python.org/line_profiler/).
    We will also mention it in [Chapter 6](ch06.html "Chapter 6. Customizing IPython"),
    *Customizing IPython*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更精细的性能分析，我们可以使用逐行分析器。该工具分析程序员选择的一组函数中每一行所花费的时间。在 Python 中，`line_profiler`
    包正是完成这项工作的工具。要分析的函数通过 `@profile` 装饰器标注。其使用方法比 IPython 分析器稍微复杂一些，我们邀请有兴趣的读者访问该包的官方网站
    [http://packages.python.org/line_profiler/](http://packages.python.org/line_profiler/)。我们将在
    [第六章](ch06.html "第六章. 定制 IPython")，*定制 IPython* 中进一步提及它。
- en: Using the IPython notebook
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IPython 笔记本
- en: The IPython notebook is increasingly used in the Python community, in particular
    for scientific research and education. It brings both a powerful HTML user interface
    to IPython and a way of saving a whole interactive session in a notebook file
    in a JSON format. The latter functionality brings reproducibility to interactive
    computing, a crucial feature notably in scientific research. Notebooks run in
    the browser and can contain, not only Python code, but also text in a markup language,
    such as Markdown, as well as images, videos, or rich content media. Notebooks
    can be converted into other formats, such as Python scripts, HTML, or PDF. Courses,
    blog posts, and books are being written with the notebook.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 笔记本在 Python 社区中越来越常用，尤其是在科学研究和教育领域。它为 IPython 提供了一个强大的 HTML 用户界面，并且能够将整个交互式会话保存在
    JSON 格式的笔记本文件中。后者的功能为交互式计算带来了可重现性，这在科学研究中尤其重要。笔记本可以在浏览器中运行，除了 Python 代码外，还可以包含文本（如
    Markdown 等标记语言），以及图像、视频或富媒体内容。笔记本可以转换为其他格式，如 Python 脚本、HTML 或 PDF。许多课程、博客文章和书籍都是使用笔记本编写的。
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**IPython Qt console**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPython Qt 控制台**'
- en: There is another rich IPython frontend similar to the notebook that is based
    on Qt instead of HTML. You can find more information about it at [http://ipython.org/ipython-doc/stable/interactive/qtconsole.html](http://ipython.org/ipython-doc/stable/interactive/qtconsole.html).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个类似于笔记本的丰富的 IPython 前端，它基于 Qt 而非 HTML。你可以在 [http://ipython.org/ipython-doc/stable/interactive/qtconsole.html](http://ipython.org/ipython-doc/stable/interactive/qtconsole.html)
    查找更多信息。
- en: Installation
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: The IPython notebook server requires several dependencies. If you use either
    a full distribution, or if you have installed IPython from a binary package, you
    should have nothing more to do. If you have installed IPython manually, you will
    need PyZMQ and Tornado. PyZMQ is a Python wrapper to the ZMQ socket library, whereas
    Tornado is a Python library implementing the HTTP server that the notebook uses.
    You can install these packages either with `easy_install` , `pip`, or from the
    source.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 笔记本服务器需要一些依赖项。如果你使用完整的发行版，或者从二进制包安装了 IPython，那么应该无需额外操作。如果你是手动安装的 IPython，你需要安装
    PyZMQ 和 Tornado。PyZMQ 是 ZMQ 套接字库的 Python 封装，而 Tornado 是一个 Python 库，用于实现笔记本使用的
    HTTP 服务器。你可以通过 `easy_install`、`pip` 或源代码安装这些包。
- en: The notebook dashboard
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 笔记本仪表盘
- en: 'To check that everything is correctly installed, type `ipython notebook` in
    a shell. This will launch a local web server on the 8888 port (by default). Go
    to `http://127.0.0.1:8888/` in a browser and check if you can see the following
    page:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一切是否正确安装，在终端中输入 `ipython notebook`。这将在 8888 端口（默认）启动一个本地 web 服务器。然后在浏览器中访问
    `http://127.0.0.1:8888/`，检查是否可以看到以下页面：
- en: '![The notebook dashboard](img/9932_02_01.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![笔记本仪表盘](img/9932_02_01.jpg)'
- en: The notebook dashboard
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本仪表盘
- en: Tip
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Browser compatibility with the notebook**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**笔记本的浏览器兼容性**'
- en: The IPython notebook is compatible with browsers such as Chrome, Safari, Firefox
    6 and later versions, and Internet Explorer 10 and later versions. These browsers
    support the **WebSocket** protocol, which is used by the notebook.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 笔记本与以下浏览器兼容：Chrome、Safari、Firefox 6 及更高版本，以及 Internet Explorer 10 及更高版本。这些浏览器支持笔记本使用的
    **WebSocket** 协议。
- en: The page in the previous screenshot is the **notebook dashboard** ; it lists
    all notebooks in the directory where we launched `ipython notebook` from. An IPython
    notebook file has a `.ipynb` extension; it is a text file containing structured
    data in JSON.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前面截图中的页面是**笔记本仪表板**；它列出了我们从中启动`ipython notebook`的目录中的所有笔记本。IPython笔记本文件的扩展名为`.ipynb`，它是一个包含JSON结构化数据的文本文件。
- en: This file contains the inputs and outputs of an interaction session, as well
    as some metadata used by IPython internally.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本文件包含一个交互会话的输入和输出，以及IPython内部使用的一些元数据。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Viewing notebooks online**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**在线查看笔记本**'
- en: IPython notebooks can be viewed and shared online on the IPython Notebook Viewer
    available at [http://nbviewer.ipython.org/](http://nbviewer.ipython.org/).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: IPython笔记本可以在IPython笔记本查看器上在线查看和共享，网址为[http://nbviewer.ipython.org/](http://nbviewer.ipython.org/)。
- en: Let's start and create a new notebook. Click on the **New Notebook** button
    at the top-right of the page.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个新的笔记本。点击页面右上角的**New Notebook**按钮。
- en: Working with cells
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理单元格
- en: We are now in a notebook. The user interface is clean and focuses on the essential
    features. At the top, the menu and the toolbar offer access to all commands. The
    main area below them shows, by default, an empty input cell. Python code can be
    typed into this input cell. An important feature of an input cell is that pressing
    the *Enter* key does not execute the cell, but rather inserts a new line. Writing
    code into a cell is then closer to what a standard text editor offers, compared
    to the classic **IPython** console.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于一个笔记本中。用户界面简洁，专注于基本功能。顶部的菜单和工具栏提供了所有命令的访问。它们下方的主要区域默认显示一个空的输入单元格。Python代码可以输入到这个输入单元格中。输入单元格的一个重要特性是按下*Enter*键不会执行该单元格，而是插入一个新行。因此，将代码写入单元格更接近于标准文本编辑器提供的功能，而不是经典的**IPython**控制台。
- en: 'Start typing the command as shown in the following screenshot, and note how
    tab completion is implemented:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 开始输入如下截图中显示的命令，并注意Tab补全的实现方式：
- en: '![Working with cells](img/9932_02_02.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![处理单元格](img/9932_02_02.jpg)'
- en: Tab completion in the notebook
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本中的Tab补全
- en: An input cell can be executed in two ways. By pressing *Shift* + *Enter*, all
    the code within the cell is executed in the current IPython interactive namespace.
    The output then appears in an output area right below the input cell, and a new
    input cell is created below. By pressing *Ctrl* + *Enter*, no new input cell is
    created and only the output is shown. Typically, we will use the latter command
    for quick in-place experiments when we just need to evaluate some Python expression
    and we do not want to save the cell's output in the notebook (although we can
    always delete cells later).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过两种方式执行输入单元格。按下*Shift* + *Enter*，将执行单元格内的所有代码在当前IPython交互命名空间中。然后，输出会显示在输入单元格正下方的输出区域，并在其下创建一个新的输入单元格。按下*Ctrl*
    + *Enter*，不会创建新的输入单元格，只显示输出。通常，当我们只需评估一些Python表达式并且不想在笔记本中保存单元格的输出时，会使用后者进行快速原地实验（尽管我们随时可以稍后删除单元格）。
- en: In the end, a notebook contains a linear succession of input and output cells,
    representing a coherent and reproducible interactive session. Typically, a single
    cell contains a set of instructions, which perform some high-level action that
    requires several consecutive commands.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个笔记本包含一系列线性的输入和输出单元格，代表一个连贯且可重现的交互式会话。通常，单个单元格包含一组指令，执行一些需要几个连续命令的高级操作。
- en: The interface offers commands to edit, delete, split, and merge cells. These
    commands can be accessed through the menu, the toolbar, or keyboard shortcuts.
    We can display the list of all keyboard shortcuts by pressing *Ctrl* + *M*, then
    *H*. Most notebook commands are executed with a sequence of keystrokes that begin
    with *Ctrl* + *M*, followed by a single key press.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该界面提供了编辑、删除、拆分和合并单元格的命令。可以通过菜单、工具栏或键盘快捷键访问这些命令。我们可以通过按下*Ctrl* + *M*，然后*H*来显示所有键盘快捷键的列表。大多数笔记本命令通过以*Ctrl*
    + *M*开头的一系列按键操作来执行，后面跟着单个按键。
- en: Cell magics
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元格魔法
- en: '**Cell magics** are special magic commands that are applied to a whole cell
    instead of a single line. They are prefixed with `%%` instead of `%`, and can
    be used either in the **IPython** console, or in the IPython notebook. The list
    of all cell magics can be obtained with the command `%lsmagic`. Two useful cell
    magics include `%%!` for executing several system shell commands from IPython,
    and `%%file` for creating a text file, as shown in the following example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cell magics** 是应用于整个单元格的特殊魔法命令，而不是单独的一行。它们以 `%%` 而不是 `%` 为前缀，可以在 **IPython**
    控制台或 IPython 笔记本中使用。通过命令 `%lsmagic` 可以获得所有 cell magics 的列表。两个有用的 cell magics 包括
    `%%!`，用于从 IPython 执行多个系统 shell 命令，以及 `%%file`，用于创建文本文件，下面的示例展示了这一点：'
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Managing notebooks
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理笔记本
- en: We can save the notebook we are working on at any time by clicking on the **Save**
    button or by pressing *Ctrl* + *S* or *Ctrl* + *M*, then *S*. By default, the
    notebook filename is `Untitled0`, but we can rename it with the `Rename` command
    in the **File** menu.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以随时通过点击 **Save** 按钮或按 *Ctrl* + *S* 或 *Ctrl* + *M*，然后 *S* 来保存正在工作的笔记本。默认情况下，笔记本文件名为
    `Untitled0`，但我们可以通过 **File** 菜单中的 `Rename` 命令重命名它。
- en: We can create a new notebook from an existing Python script by dragging the
    Python file from the system explorer to the IPython dashboard. This will create
    a new notebook with the same name as our script, but with a `.ipynb` extension.
    A notebook can be downloaded as a Python script or as a `.ipynb` file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 Python 文件从系统资源管理器拖到 IPython 控制台，来根据现有的 Python 脚本创建一个新的笔记本。这将创建一个与我们的脚本同名但扩展名为
    `.ipynb` 的新笔记本。笔记本可以作为 Python 脚本或 `.ipynb` 文件进行下载。
- en: Multimedia and rich text editing
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多媒体和富文本编辑
- en: A very useful feature of the notebook is the possibility to insert rich text
    in cells using a popular marker text format called **Markdown** (described at
    [http://daringfireball.net/projects/markdown/syntax](http://daringfireball.net/projects/markdown/syntax)).
    Edition features such as bold, italic, headers, and bullet points can be inserted
    with a simple syntax. To do this, we need to convert a cell into a **Markdown**
    cell with the `Cell >` Markdown command.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有用的功能是可以通过流行的标记文本格式 **Markdown** 在单元格中插入富文本（详细描述见[http://daringfireball.net/projects/markdown/syntax](http://daringfireball.net/projects/markdown/syntax)）。编辑功能如粗体、斜体、标题和项目符号可以通过简单的语法插入。为了做到这一点，我们需要使用
    `Cell >` Markdown 命令将单元格转换为 **Markdown** 单元格。
- en: 'Then, we can type our text with the Markdown syntax. If we press *Shift* +
    *Enter*, the text will be automatically formatted, and it can be edited with a
    double-click. The following screenshot shows both the Markdown code and the corresponding
    formatted text:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 Markdown 语法输入文本。如果按下 *Shift* + *Enter*，文本将自动格式化，且可以通过双击进行编辑。以下截图展示了
    Markdown 代码和相应的格式化文本：
- en: '![Multimedia and rich text editing](img/9932OS_02_03.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Multimedia and rich text editing](img/9932OS_02_03.jpg)'
- en: Markdown input and output in the notebook
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本中的 Markdown 输入和输出
- en: Graph plotting
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图表绘制
- en: 'Let''s illustrate the plotting capabilities of the notebook with our social
    network example. We are going to draw the graph `sg`. First, we need to launch
    the notebook with the command `ipython notebook --pylab inline`. This option will
    be covered in more detail in [Chapter 4](ch04.html "Chapter 4. Interactive Plotting
    and Graphical Interfaces"), *Figures and Graphical Interfaces*. It allows to insert
    figures within the notebook, thanks to the Matplotlib library. NetworkX offers
    several Matplotlib-based commands to plot graphs. In the following example, we
    use the `draw_networkx` function to draw the graph `sg`, along with several parameters
    to improve the readability of the graph (the full list of options can be found
    on the NetworkX documentation website):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过社交网络示例来说明笔记本的绘图功能。我们将绘制图表 `sg`。首先，我们需要通过命令 `ipython notebook --pylab inline`
    启动笔记本。这个选项将在[第4章](ch04.html "Chapter 4. Interactive Plotting and Graphical Interfaces")中详细介绍，*图形和图形界面*。它允许在笔记本中插入图形，得益于
    Matplotlib 库。NetworkX 提供了几个基于 Matplotlib 的命令来绘制图表。在以下示例中，我们使用 `draw_networkx`
    函数绘制图表 `sg`，并通过多个参数来提高图表的可读性（完整的选项列表可以在 NetworkX 文档网站上找到）：
- en: '![Graph plotting](img/9932_02_06.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![Graph plotting](img/9932_02_06.jpg)'
- en: Drawing a graph in the notebook
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本中绘制图表
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We now have a broad overview of the features that IPython offers to simplify
    and extend the way we interact with IPython in our day-to-day programming job.
    From the powerful Python history to the essential dynamic introspection features,
    deciding whether to use IPython or the standard Python console for interactive
    programming is a no-brainer. Also, the notebook offers a modern way of using IPython
    for a wide variety of uses, such as simply recording an interactive session and
    creating a programming course, a presentation, or even a book!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对 IPython 提供的功能有了一个全面的了解，这些功能简化并扩展了我们在日常编程工作中与 IPython 的交互方式。从强大的 Python
    历史记录到必不可少的动态 introspection 特性，决定是使用 IPython 还是标准的 Python 控制台进行交互式编程，简直是显而易见的选择。而且，notebook
    提供了一种现代化的方式来使用 IPython，适用于多种用途，比如简单地记录交互式会话，创建编程课程、演示文稿，甚至是一本书！
- en: 'Yet, what IPython offers does not stop here. It really comes into its own when
    using it with external packages offering numerical computing and visualization
    features: NumPy, SciPy, Matplotlib, and others. These packages can absolutely
    be used without IPython. However, using IPython fully makes sense since it then
    allows *interactive* numerical computing and visualization with the Python programming
    language. Together, these tools are becoming the platform of choice for open-source
    scientific computing, even competing with the widespread commercial solutions
    of reference. In the next chapter, we will cover the numerical computing capabilities
    of the platform.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，IPython 提供的功能远不止这些。它真正发挥作用的时刻是与外部包结合使用时，这些包提供了数值计算和可视化功能：NumPy、SciPy、Matplotlib
    等。这些包完全可以在没有 IPython 的情况下使用。然而，完全使用 IPython 是有意义的，因为它可以让你在 Python 编程语言中进行*交互式*的数值计算和可视化。综合来看，这些工具正逐渐成为开源科学计算的首选平台，甚至与广泛使用的商业解决方案进行竞争。在下一章，我们将介绍该平台的数值计算能力。
