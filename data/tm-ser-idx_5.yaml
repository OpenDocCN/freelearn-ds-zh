- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Joining and Comparing iSAX Indexes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入和比较 iSAX 索引
- en: In the previous chapter, we developed a Python package called `isax` that creates
    iSAX indexes for indexing the subsequences of a time series given a sliding window.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开发了一个名为 `isax` 的 Python 包，用于创建 iSAX 索引，以索引时间序列的子序列，给定一个滑动窗口。
- en: In this chapter, we are going to experiment with how the sliding window size
    affects the number of splits and the number of accesses to subsequences while
    creating an iSAX index.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实验滑动窗口大小如何影响在创建 iSAX 索引时分割数和子序列访问次数的数量。
- en: Then, we are going to use the iSAX indexes created by the `isax` package and
    try to join and compare them. By *comparing*, we aim to understand the efficiency
    of an iSAX index, and by *joining*, we mean being able to find similar nodes in
    two iSAX indexes based on SAX representations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用 `isax` 包创建的 iSAX 索引，尝试将它们连接并比较。通过 *比较*，我们旨在了解 iSAX 索引的效率，而通过 *连接*，我们意味着能够根据
    SAX 表示找到两个 iSAX 索引中的相似节点。
- en: The last part of this chapter is going to briefly discuss Python testing before
    developing simple tests for the `isax` package. *Testing is a serious part of
    the development process and should not be overlooked*. The time spent writing
    tests is time well spent!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分将简要讨论 Python 测试，然后再为 `isax` 包开发简单的测试。*测试是开发过程中的一个重要部分，不应被忽视*。编写测试所花费的时间是值得的！
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: How the sliding window size affects the iSAX construction speed
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑动窗口大小如何影响 iSAX 构建速度
- en: Checking the search speed of iSAX indexes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 iSAX 索引的搜索速度
- en: Joining iSAX indexes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接 iSAX 索引
- en: Implementing the joining of iSAX indexes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 iSAX 索引的连接
- en: Explaining the Python code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释 Python 代码
- en: Using the Python code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 代码
- en: Writing Python tests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 Python 测试
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The GitHub repository for this book can be found at [https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing).
    The code for each chapter is in its own directory. Therefore, the code for this
    chapter can be found in the `ch05` folder. You can download the entire repository
    on your computer using `git(1)` or you can access the desired files via the GitHub
    user interface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的相关 GitHub 仓库可以在 [https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing)
    找到。每个章节的代码都在自己的目录中。因此，本章的代码可以在 `ch05` 文件夹中找到。您可以使用 `git(1)` 在您的计算机上下载整个仓库，或者您可以通过
    GitHub 用户界面访问所需的文件。
- en: How the sliding window size affects the iSAX construction speed
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滑动窗口大小如何影响 iSAX 构建速度
- en: In this section, we are going to continue working with the `accessSplit.py`
    utility we developed in the previous chapter to find out whether the sliding window
    size affects the construction speed of an iSAX index, provided that the remaining
    iSAX parameters stay the same.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续使用上一章中开发的 `accessSplit.py` 工具，以找出滑动窗口大小是否会影响 iSAX 索引的构建速度，前提是剩余的 iSAX
    参数保持不变。
- en: 'Put simply, we will use different methods to find out more about the quality
    of iSAX indexes and whether the sliding window size affects the construction speed.
    We are going to perform our experiments using the following sliding window sizes:
    `16`, `256`, `1024`, `4096`, and `16384`. We are going to experiment using the
    `500k.gz` time series from [*Chapter 4*](B14769_04.xhtml#_idTextAnchor102), 8
    segments, a maximum cardinality value of `32`, and a threshold value of `500`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将使用不同的方法来了解更多关于 iSAX 索引的质量以及滑动窗口大小是否会影响构建速度。我们将使用以下滑动窗口大小进行实验：`16`、`256`、`1024`、`4096`
    和 `16384`。我们将使用来自 [*第 4 章*](B14769_04.xhtml#_idTextAnchor102) 的 `500k.gz` 时间序列，8
    个段，最大基数值为 `32`，阈值值为 `500`。
- en: 'For the window size of `16`, the results are the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于窗口大小为 `16` 的情况，结果如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For the sliding window size of `256`, the results are the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于滑动窗口大小为 `256` 的情况，结果如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compared to the sliding window size of `16`, the iSAX index created using a
    sliding window size of `256` had more than three times the number of splits and
    four times the number of subsequence accesses.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与滑动窗口大小为 `16` 相比，使用滑动窗口大小为 `256` 创建的 iSAX 索引具有超过三倍的分割数和四倍的子序列访问次数。
- en: 'Next, for the window size of `1024`, the results are the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于窗口大小为 `1024` 的情况，结果如下：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As before, we have more splits than the `16` and `256` sliding window sizes
    and more subsequence accesses. Put simply, it took more CPU time for this iSAX
    index to be constructed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们比`16`和`256`滑动窗口大小有更多的分割和子序列访问。简单来说，构建这个iSAX索引需要更多的CPU时间。
- en: 'Next, for the window size of `4096`, the results are the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于窗口大小为`4096`的结果如下：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, it is not only slower to construct the iSAX index but we also
    have an `500.gz` time series are not going to fit into an iSAX index with these
    parameters and we are going to need to use different iSAX parameters for the iSAX
    index to work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，不仅构建iSAX索引的速度较慢，而且一个`500.gz`时间序列也无法适应这些参数的iSAX索引，我们将需要使用不同的iSAX参数才能使iSAX索引工作。
- en: Do overflows have an impact on the construction of iSAX indexes?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出对iSAX索引的构建有影响吗？
- en: When we have one or multiple overflows on an iSAX index, it means that the full
    cardinality has been used on all SAX words—recall that the number of SAX words
    is defined by the number of segments. Therefore, we have multiple splits on terminal
    nodes that are fully based on the current threshold value, which means that we
    have many more subsequence accesses than usual. Therefore, overflows have a great
    impact on the construction time of iSAX indexes. Additionally, as if this were
    not bad enough, we have to find new iSAX parameters that prevent the overflow
    from happening while keeping the iSAX operation efficient. Keep in mind that the
    number of splits is also a naïve indication of how close we are to an overflow.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在iSAX索引上有一个或多个溢出时，这意味着所有SAX词的全基数已经被使用——回想一下，SAX词的数量由段的数量定义。因此，我们在终端节点上有多个基于当前阈值值的分割，这意味着我们比通常有更多的子序列访问。因此，溢出对iSAX索引的构建时间有很大影响。此外，就像这还不够糟糕一样，我们必须找到新的iSAX参数，以防止溢出发生，同时保持iSAX操作高效。记住，分割的数量也是我们接近溢出的一个简单指示。
- en: 'Lastly, for the biggest window size (`16384`), the results are the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于最大的窗口大小（`16384`），结果如下：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once again, we have an overflow situation with the sliding window size of `16384`,
    this time on a different SAX representation. We are going to leave both overflows
    as they are and create some plots of the results. The resolution of the overflows
    is left as an exercise for you.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有一个溢出情况，这次是在`16384`滑动窗口大小上，针对不同的SAX表示。我们将保留这两个溢出，并创建一些结果图。溢出的分辨率留给你作为练习。
- en: '*Figure 5**.1* shows the number of splits per sliding window size where we
    can see that the bigger the sliding window size, the larger the number of splits
    that take place for that particular time series.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5**.1*显示了每个滑动窗口大小的分割数量，我们可以看到滑动窗口的大小越大，特定时间序列的分割数量就越多。'
- en: '![Figure 5.1– Splits per sliding window size plot](img/Figure_5.1_B14769.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1– 每个滑动窗口大小的分割数量图](img/Figure_5.1_B14769.jpg)'
- en: Figure 5.1– Splits per sliding window size plot
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1– 每个滑动窗口大小的分割数量图
- en: '*Figure 5**.2* shows the number of subsequence accesses per sliding window
    size. In this case, instead of plotting the absolute number of subsequence accesses,
    we divide the number of total subsequence accesses by the total number of subsequences
    to display a fraction. This is a fair calculation as bigger time series have a
    larger number of subsequences.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5**.2*显示了每个滑动窗口大小的子序列访问次数。在这种情况下，我们不是绘制子序列访问的绝对数量，而是将总子序列访问次数除以总子序列数来显示一个分数。这是一个公平的计算，因为较大的时间序列有更多的子序列。'
- en: '![Figure 5.2 – Subsequence accesses percentage per sliding window size plot](img/Figure_5.2_B14769.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 每个滑动窗口大小的子序列访问百分比图](img/Figure_5.2_B14769.jpg)'
- en: Figure 5.2 – Subsequence accesses percentage per sliding window size plot
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 每个滑动窗口大小的子序列访问百分比图
- en: In *Figure 5**.2*, we can see that the bigger the sliding window size, the bigger
    the number of subsequence accesses. For the smallest sliding window (`16`), we
    have about eight times fewer accesses to the subsequence of the time series compared
    to the largest sliding window (`16384`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图5**.2*中，我们可以看到滑动窗口的大小越大，子序列访问的次数也越多。对于最小的滑动窗口（`16`），与最大的滑动窗口（`16384`）相比，对时间序列子序列的访问次数大约少八倍。
- en: The construction speed of an iSAX index is one important factor. However, it
    is not the only criterion for the quality of iSAX indexes. The next section investigates
    the search speed of iSAX indexes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: iSAX索引的构建速度是一个重要因素。然而，它并不是iSAX索引质量的唯一标准。下一节将探讨iSAX索引的搜索速度。
- en: Checking the search speed of iSAX indexes
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查iSAX索引的搜索速度
- en: 'This section presents a utility that takes two time series, named `TS1` and
    `TS2`, which ideally have similar lengths, creates two iSAX indexes, named `D1`
    and `D2`, and performs the following searches:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一个实用工具，它接受两个时间序列，分别命名为`TS1`和`TS2`，理想情况下它们的长度相似，创建两个iSAX索引，分别命名为`D1`和`D2`，并执行以下搜索：
- en: Searches `D1` for all the subsequences of `TS2`. In this case, we are not sure
    whether a subsequence from `TS2` is in `D1` or not. In most cases, *we are not
    going to be able to find the subsequences of TS2 in TS1*. This is the main reason
    that a *join* based on the SAX representations of the iSAX nodes might be more
    appropriate when looking for similarities between subsequences.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`D1`中搜索`TS2`的所有子序列。在这种情况下，我们不确定`TS2`的子序列是否在`D1`中。在大多数情况下，*我们无法在`TS1`中找到`TS2`的子序列*。这是基于iSAX节点SAX表示的*连接*在寻找子序列相似性时可能更合适的主要原因。
- en: Searches `D2` for all the subsequences of `TS1`. In this case, we are not sure
    whether a subsequence from `TS1` is in `D2` or not. As before, in most cases,
    we are not going to be able to find the subsequences of `TS1` in `TS2` and therefore,
    in the iSAX index created from `TS2` (`D2`).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`D2`中搜索`TS1`的所有子序列。在这种情况下，我们不确定`TS1`的子序列是否在`D2`中。和之前一样，在大多数情况下，我们无法在`TS2`中找到`TS1`的子序列，因此，在从`TS2`创建的iSAX索引（`D2`）中也无法找到。
- en: Searches `D1` for all the subsequences of `TS1`, which means that all subsequences
    of `TS1` are in `D1`. With that test, we just want to discover more about the
    speed of an iSAX index when performing search operations. This search operation
    mainly depends on the threshold size because a bigger threshold value means more
    subsequences to look for once we come to the appropriate terminal node.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`D1`中搜索`TS1`的所有子序列，这意味着`TS1`的所有子序列都在`D1`中。通过这个测试，我们只想了解iSAX索引在执行搜索操作时的速度。这个搜索操作主要取决于阈值大小，因为更大的阈值意味着在到达适当的终端节点时需要查找更多的子序列。
- en: Searches `D2` for all the subsequences of `TS2`, which means that all subsequences
    of `TS2` are in `D2` and are going to be found.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`D2`中搜索`TS2`的所有子序列，这意味着`TS2`的所有子序列都在`D2`中，并且将被找到。
- en: All these searches are implemented in a Python script named `speed.py`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些搜索都在一个名为`speed.py`的Python脚本中实现。
- en: 'The core functionality of `speed.py` is implemented in functions. The first
    function contains the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`speed.py`的核心功能在函数中实现。第一个函数包含以下代码：'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `createISAX()` function creates an iSAX index and returns a link to an `isax.ISAX()`
    class as well as a NumPy array with all the elements of the time series.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`createISAX()`函数创建一个iSAX索引，并返回一个指向`isax.ISAX()`类的链接以及一个包含时间序列所有元素的NumPy数组。'
- en: 'The second function is implemented as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数实现如下：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the first part of `query()`, we construct the SAX representation of a potential
    child of the root node of the iSAX index using `tools.lowerCardinality()` and
    `segs`. From that, we construct the `lower_cardinality_str` string:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`query()`的第一部分，我们使用`tools.lowerCardinality()`和`segs`构建iSAX索引根节点潜在子节点的SAX表示，然后构建`lower_cardinality_str`字符串：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the second part of `query()`, we check whether the `lower_cardinality_str`
    key can be found in the iSAX index.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`query()`的第二部分，我们检查`lower_cardinality_str`键是否可以在iSAX索引中找到。
- en: If it can be found, then we follow that subtree, which begins with a child of
    the root node of the iSAX index, until we find the appropriate terminal node.
    If it cannot be found, then we have a miss, and the process terminates.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以找到，我们就跟随那个子树，它从iSAX索引的根节点的一个子节点开始，直到我们找到适当的终端节点。如果找不到，那么我们有一个错误，并且过程终止。
- en: The `query()` function returns `True` if the subsequence is found and `False`
    otherwise. Its second return value is the number of subsequence accesses that
    took place while trying to find that query subsequence.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`query()`函数如果找到子序列则返回`True`，否则返回`False`。它的第二个返回值是在尝试找到该查询子序列时发生的子序列访问次数。'
- en: 'The rest of the code of `speed.py` is placed in the `main()` function and is
    going to be presented in three parts – the first part being the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`speed.py`的其余代码放在`main()`函数中，并将分三部分介绍——第一部分如下：'
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this first part, we construct the two iSAX indexes and store the number of
    splits and accesses to subsequences.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一部分，我们构建两个iSAX索引，并存储拆分和子序列访问次数。
- en: 'The second part of `speed.py` contains the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`speed.py`的第二个部分包含以下代码：'
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this part of the program, we query the first iSAX index. In the first `for`
    block, we search iSAX for all the subsequences of the first time series. As this
    iSAX indexes the first time series, all subsequences are going to be found in
    the iSAX index. While doing that, we store the number of accesses to subsequences,
    which is returned by the `query()` function. In the second `for` block, we do
    the same but this time, for the second time series. Therefore, there is a small
    possibility of finding the subsequences of the second time series (`TS2`) in the
    iSAX index of the first time series (`TS1`).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的这个部分，我们查询第一个iSAX索引。在第一个`for`循环块中，我们在iSAX中搜索第一个时间序列的所有子序列。由于这个iSAX索引了第一个时间序列，所有子序列都将在这个iSAX索引中找到。在这样做的时候，我们存储了对子序列的访问次数，这是由`query()`函数返回的。在第二个`for`循环块中，我们做同样的事情，但这次是为第二个时间序列。因此，在第一个时间序列的iSAX索引中找到第二个时间序列（`TS2`）的子序列的可能性很小。
- en: 'The last part of `speed.py` is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`speed.py`的最后一部分如下所示：'
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This last part of `main()`is similar to the previous code. The only difference
    is that this time, we query the second iSAX index instead of the first one. Once
    again, we store the number of accesses to subsequences.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数的最后一部分与之前的代码类似。唯一的区别是这次我们查询的是第二个iSAX索引，而不是第一个。再次，我们存储了对子序列的访问次数。'
- en: 'Before running `speed.py`, we need to create another time series, which is
    going to be stored in `506k.gz`. In this case, the second time series was created
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`speed.py`之前，我们需要创建另一个时间序列，它将被存储在`506k.gz`中。在这种情况下，第二个时间序列被创建如下：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Although the two time series do not need to have the same length, we have decided
    to make them pretty close in length.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两个时间序列不需要有相同的长度，但我们决定使它们的长度尽可能接近。
- en: 'Using `speed.py` generates the following kind of output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`speed.py`生成以下类型的输出：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Keep in mind that the previous command took *more than three hours* on a MacBook
    Pro machine! The speed will depend on your CPU.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，之前的命令在MacBook Pro机器上花费了**超过三个小时**！速度将取决于你的CPU。
- en: 'If we used different SAX parameters, the output would look as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用了不同的SAX参数，输出将如下所示：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Although the first run of `speed.py` required 1,106 splits and the second one
    2,034 splits, both results were close as far as the total number of subsequence
    accesses is concerned.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第一次运行`speed.py`需要1,106次分割，第二次运行需要2,034次分割，但就总子序列访问次数而言，两个结果都非常接近。
- en: As expected, the number of total queries is the same in both cases because we
    are dealing with the same time series and, therefore, the same number of subsequences.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，两种情况下总查询次数相同，因为我们处理的是相同的时间序列，因此子序列的数量也相同。
- en: Now that we know how to perform lookups and searches on iSAX indexes, it is
    time to learn about another important operation, which is the joining of iSAX
    indexes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何在iSAX索引上执行查找和搜索，是时候学习另一个重要的操作了，那就是iSAX索引的连接。
- en: Joining iSAX indexes
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接iSAX索引
- en: At this point, we have iSAX indexes that we want to use to perform basic time
    series data mining tasks. One of them is **finding similar subsequences** between
    two or more time series. In our case, we are working with two time series, but
    the method can be extended to more time series with small changes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了想要用于执行基本时间序列数据挖掘任务的iSAX索引。其中之一是**在两个或多个时间序列之间找到相似子序列**。在我们的案例中，我们正在处理两个时间序列，但通过一些小的改动，这个方法可以扩展到更多的时间序列。
- en: How to join iSAX indexes
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如何连接iSAX索引
- en: Given two or more iSAX indexes, it is up to us to decide how and why we are
    going to join them. We can even join them using SAX representations with a cardinality
    value of `2`. However, using the SAX representations of the nodes as our keys
    for the join is the most logical choice.In our case, we are going to use the iSAX
    indexes and the SAX representations of the nodes to look for similar subsequences.
    This is because we have the intuition that subsequences in nodes with the same
    SAX representation are *close* to each other. The term *close* is defined relative
    to a **distance metric**. For the purposes of this chapter, we are going to use
    the Euclidean distance to compare subsequences of the same size.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个或多个iSAX索引，我们决定如何以及为什么将它们连接起来。我们甚至可以使用具有`2`的基数值的SAX表示来连接它们。然而，使用节点SAX表示作为连接键是最合理的选择。在我们的案例中，我们将使用iSAX索引和节点的SAX表示来寻找相似子序列。这是因为我们有这样的直觉：具有相同SAX表示的节点中的子序列彼此之间是**接近的**。术语**接近**是相对于一个**距离度量**来定义的。为了本章的目的，我们将使用欧几里得距离来比较相同大小的子序列。
- en: Now, let us rephrase that in a more precise way. A **join** of two iSAX indexes
    that is based on the SAX representation is a way of finding the most similar node
    (based on the SAX representation) for each of the nodes of the first iSAX index
    when searching the nodes of the second iSAX index, which was constructed using
    the same parameters. This way, we save time because we only have to compare subsequences
    of similar terminal nodes. Is similarity based on SAX representation perfect?
    No, it is not. But we are using a time series index to make things faster.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用更精确的方式重新表述。基于 SAX 表示的 iSAX 索引的 **连接** 是一种在搜索使用相同参数构建的第二 iSAX 索引的节点时，为第一个
    iSAX 索引的每个节点找到最相似节点（基于 SAX 表示）的方法。这样，我们节省了时间，因为我们只需要比较相似终端节点的子序列。基于 SAX 表示的相似性完美吗？不，它并不完美。但我们使用时间序列索引来使事情更快。
- en: The idea behind this join came after reading the *Scalable Hybrid Similarity
    Join over Geolocated Time Series* paper, which was written by Georgios Chatzigeorgakidis,
    Kostas Patroumpas, Dimitrios Skoutas, Spiros Athanasiou, and Spiros Skiadopoulos.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种连接背后的想法是在阅读了由 Georgios Chatzigeorgakidis、Kostas Patroumpas、Dimitrios Skoutas、Spiros
    Athanasiou 和 Spiros Skiadopoulos 撰写的 *Scalable Hybrid Similarity Join over Geolocated
    Time Series* 论文之后产生的，该论文发表在 *Scalable Hybrid Similarity Join over Geolocated Time
    Series* 上。
- en: The next section is going to show how to implement the joining of iSAX indexes
    based on the SAX representations of their nodes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将展示如何根据其节点的 SAX 表示实现 iSAX 索引的连接。
- en: Implementing the joining of iSAX indexes
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 iSAX 索引的连接
- en: For the implementation of the iSAX index join, we are going to assume that we
    have two iSAX indexes ready to be used saved in two separate Python variables,
    and continue from there. We are going to need a Python function that accepts two
    iSAX indexes and returns a list of Euclidean distances, which are the nearest
    neighbors of all subsequences in both time series. Keep in mind that if a node
    from one of the iSAX indexes does not match the other iSAX index, then that node,
    and as a consequence its subsequences, is not going to get processed. Therefore,
    the list of Euclidean distances might be a little shorter than expected. That
    is the main reason why we must not use unnecessarily big iSAX parameters. Put
    simply, do not use 16 segments when 4 segments can do the job.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 iSAX 索引连接的实现，我们将假设我们有两个准备好的 iSAX 索引，分别保存在两个不同的 Python 变量中，并继续进行。我们需要一个 Python
    函数，该函数接受两个 iSAX 索引并返回一个欧几里得距离列表，这是两个时间序列中所有子序列的最近邻。请记住，如果一个 iSAX 索引的节点与另一个 iSAX
    索引不匹配，那么该节点及其子序列将不会得到处理。因此，欧几里得距离列表可能比预期的要短一些。这就是我们为什么不能使用不必要的大的 iSAX 参数的主要原因。简单地说，当
    4 个段可以完成任务时，不要使用 16 个段。
- en: Additionally, keep in mind that the real nearest neighbor of a subsequence might
    not be located in the terminal node with the same SAX representation – this is
    the price we pay for the extra speed and avoiding the quadratic processing cost
    (comparing every subsequence of the first time series with all subsequences of
    the second time series, and vice versa).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，子序列的真实最近邻可能不在具有相同 SAX 表示的终端节点中——这是我们为了额外的速度和避免二次处理成本（比较第一时间序列的所有子序列与第二时间序列的所有子序列，反之亦然）所付出的代价。
- en: So, we need to implement the previous functionality for the `isax` package based
    on the current implementation and representation of the iSAX index.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要根据当前的 iSAX 索引实现和表示实现 `isax` 包的先前功能。
- en: As a result, we are going to put that functionality inside the `isax` package,
    using a separate file named `iSAXjoin.py`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将该功能放在 `isax` 包中，使用一个名为 `iSAXjoin.py` 的单独文件。
- en: 'Apart from that file, we added a function for calculating the Euclidean distance
    between two subsequences in `isax/tools.py`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了那个文件之外，我们在 `isax/tools.py` 中添加了一个用于计算两个子序列之间欧几里得距离的函数：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you recall from [*Chapter 1*](B14769_01.xhtml#_idTextAnchor015), in the `ch01/ed.py`
    script, `euclidean()` uses the magic of NumPy to calculate Euclidean distances
    between two subsequences. Do not forget that we always compare **normalized subsequences**
    in this book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得从 [*第 1 章*](B14769_01.xhtml#_idTextAnchor015)，在 `ch01/ed.py` 脚本中，`euclidean()`
    使用 NumPy 的魔法来计算两个子序列之间的欧几里得距离。不要忘记，在这本书中，我们总是比较 **归一化子序列**。
- en: 'Lastly, we added the following variable to `isax/variables.py`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 `isax/variables.py` 中添加了以下变量：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `ED` global variable is a Python list used to hold the result of the join
    between two iSAX indexes, which is a list of Euclidean distances.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`ED` 全局变量是一个 Python 列表，用于存储两个 iSAX 索引之间连接的结果，这是一个欧几里得距离的列表。'
- en: Let us now present and explain the code of `isax/iSAXjoin.py`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将展示并解释`isax/iSAXjoin.py`的代码。
- en: Explaining the Python code
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释Python代码
- en: The code in `iSAXjoin.py` is going to be presented in five parts.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`iSAXjoin.py`中的代码将分为五个部分。'
- en: 'The first part is the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Join()` function is the entry point to the join of the two iSAX indexes.
    However, that function has a single purpose, which is creating all the combinations
    between the children of the two iSAX root nodes in order to pass control to `_Join()`.
    As the order of the arguments in `_Join()` is significant, `_Join()` is called
    two times. The first time, a root child node from the first iSAX index is the
    first parameter, and the second time, a root child node from the second iSAX index
    is the first parameter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join()`函数是两个iSAX索引连接的入口点。然而，该函数只有一个目的，即创建两个iSAX根节点子节点的所有组合，以便传递控制到`_Join()`。由于`_Join()`中参数的顺序很重要，因此`_Join()`被调用了两次。第一次，第一个iSAX索引的根子节点是第一个参数，第二次，第二个iSAX索引的根子节点是第一个参数。'
- en: 'The second part of `iSAXjoin.py` is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`iSAXjoin.py`的第二部分如下：'
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When we are dealing with inner nodes from both iSAX indexes, we just combine
    all their children – remember that each inner node has two children – and recursion
    takes care of the rest.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理来自两个iSAX索引的内部节点时，我们只需组合它们的所有子节点——记住每个内部节点有两个子节点——其余部分由递归处理。
- en: 'The third part contains the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含以下代码：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we are dealing with an inner node and a terminal node, we expand the inner
    node, and recursion takes care of the rest.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在处理一个内部节点和一个终端节点，我们将扩展内部节点，其余部分由递归处理。
- en: 'The fourth part of `iSAXjoin.py` is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`iSAXjoin.py`的第四部分如下：'
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As before, when dealing with an inner node and a terminal node, we expand the
    inner node, and recursion takes care of the rest.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当处理一个内部节点和一个终端节点时，我们扩展内部节点，其余部分由递归处理。
- en: 'The last part comes with the following Python code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分包含以下Python代码：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This last part is where the recursive calling to `_Join()` stops because we
    are dealing with two terminal nodes. This means that we are able to calculate
    the Euclidean distances of their subsequences. The fact that we are not normalizing
    the subsequences before calling `tools.euclidean()` means that we expect to have
    the subsequences in all terminal nodes in a normalized form. Notice that we store
    the results in the `variables.ED` list.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这部分是递归调用`_Join()`停止的地方，因为我们正在处理两个终端节点。这意味着我们可以计算它们子序列的欧几里得距离。我们没有在调用`tools.euclidean()`之前对子序列进行归一化的事实意味着我们期望所有终端节点中的子序列都是以归一化的形式存储的。请注意，我们将结果存储在`variables.ED`列表中。
- en: That is all regarding the implementation of the joining of two iSAX indexes.
    The next section covers how to use the (similarity) join code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关于两个iSAX索引连接的实现就到这里。下一节将介绍如何使用（相似性）连接代码。
- en: Using the Python code
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python代码
- en: 'In this section, we are going to use the similarity join code we have developed
    to start joining iSAX indexes. The source code of `join.py` is presented in three
    parts. The first part is the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用我们开发的相似性连接代码来开始连接iSAX索引。`join.py`的源代码分为三个部分。第一部分如下：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Nothing new here – we just have to import the necessary external packages, including
    `isax.iSAXjoin`, and develop a function that creates an iSAX index given a time
    series file and a sliding window size. The function returns the root node of the
    iSAX index. However, please note that *subsequences are stored in their normalized
    form* inside all `TS()` objects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有新的内容——我们只需要导入必要的外部包，包括`isax.iSAXjoin`，并开发一个函数，该函数根据时间序列文件和滑动窗口大小创建一个iSAX索引。该函数返回iSAX索引的根节点。然而，请注意，*子序列以归一化的形式存储*在所有`TS()`对象内部。
- en: 'The second part is the beginning of the `main()` function and comes with the
    following Python code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是`main()`函数的开始，并包含以下Python代码：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we are joining two iSAX indexes, we need two separate command-line arguments
    (`TS1` and `TS2`) to define the paths of the compressed plain text files with
    the time series data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在连接两个iSAX索引，我们需要两个单独的命令行参数（`TS1`和`TS2`）来定义包含时间序列数据的压缩纯文本文件的路径。
- en: 'The last part of `join.py` is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`join.py`的最后一部分如下：'
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we create the two iSAX indexes by calling `buildISAX()` two times and
    then join them using `Join()`, which returns no values. In order to look at the
    list of computed values, we need to access `variables.ED`. We print the length
    of the list of Euclidean distances as well as the theoretical maximum length of
    it, which is equal to `time_series_length – sliding_window_size + 1`, to have
    a better idea of the number of subsequences without a match. In the output, we
    also print the time it took to create each iSAX index as extra information about
    the process.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过两次调用`buildISAX()`创建两个iSAX索引，然后使用`Join()`将它们连接起来，该函数返回没有值。为了查看计算出的值列表，我们需要访问`variables.ED`。我们打印欧几里得距离列表的长度以及它的理论最大长度，即`time_series_length
    – sliding_window_size + 1`，以便更好地了解没有匹配的子序列数量。在输出中，我们还打印了创建每个iSAX索引所需的时间，作为过程额外信息的补充。
- en: At this point, we are ready to use `join.py`. This means that we should provide
    it with the necessary parameters and input.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好使用`join.py`。这意味着我们应该提供必要的参数和输入。
- en: 'Using `join.py` produces the following kind of output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`join.py`会产生以下类型的输出：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So, it took `170.94` seconds to create the first index and `179.80` seconds
    to create the second iSAX index. The list of Euclidean distances has `970603`
    elements, whereas the maximum number of elements is `1006188`, which means that
    we missed some terminal nodes because their SAX representation did not have a
    match in the other iSAX index. This is not unusual and we should expect it most
    of the time as time series and their iSAX indexes differ.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建第一个索引花费了`170.94`秒，创建第二个iSAX索引花费了`179.80`秒。欧几里得距离列表有`970603`个元素，而最大元素数量是`1006188`，这意味着我们错过了一些终端节点，因为它们的SAX表示在另一个iSAX索引中没有匹配。这并不罕见，我们大多数时候都应该预料到这种情况，因为时间序列及其iSAX索引是不同的。
- en: We have a long list of Euclidean distances, so what?
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们有一长串欧几里得距离，那又如何呢？
- en: 'You might be asking, “What do we do with that list of Euclidean distances?”
    Put simply, what is the main purpose of creating such a list of distances? There
    are many uses, including the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，“我们该如何处理那个欧几里得距离列表？”简单地说，创建这样一个距离列表的主要目的是什么？有很多用途，包括以下：
- en: Finding out how close two time series are by finding the minimum Euclidean distance
    in the list.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过找到列表中的最小欧几里得距离来找出两个时间序列有多接近。
- en: Finding out the list of Euclidean distances that are in a given numeric range.
    This is another way of comparing the similarity of two time series.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找出给定数值范围内的欧几里得距离列表。这是比较两个时间序列相似性的另一种方法。
- en: Finding subsequences that are more different than others based on a distance
    measure. In data mining terminology, these subsequences are called **outliers**.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据距离度量找出与其他子序列相比差异更大的子序列。在数据挖掘术语中，这些子序列被称为**异常值**。
- en: I think you get the idea of why we perform the join computation – we need to
    be able to better understand the connection between the two time series involved
    in the join. The reason for using the SAX representation is to prune nodes and
    subsequences and save CPU time.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你明白了我们为什么要执行连接计算——我们需要更好地理解参与连接的两个时间序列之间的联系。使用SAX表示的原因是为了剪枝节点和子序列，从而节省CPU时间。
- en: As the joining operation can be slow, the next subsection presents a handy technique
    for saving the list of Euclidean distances on disk and loading the list from disk
    in order to use it without having to carry out the entire process from scratch.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于连接操作可能很慢，下一小节将介绍一种方便的技术，用于将欧几里得距离列表保存到磁盘上，并在需要时从磁盘加载列表，以便无需从头开始执行整个过程。
- en: Saving the output
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存输出
- en: The joining of iSAX indexes can take time. Is there a way to make that process
    less painful? Yes, we can save the contents of the similarity join, which is a
    list, into a file, which saves us from having to recreate that list from scratch
    each time we need it. Keep in mind that for this to work, the two iSAX indexes
    must be created with the same parameters for the exact same time series.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: iSAX索引的连接可能需要时间。有没有办法让这个过程不那么痛苦？是的，我们可以将相似性连接的内容，即一个列表，保存到文件中，这样我们就不必每次需要时都从头创建该列表。记住，为了使这可行，两个iSAX索引必须使用相同的参数为完全相同的时间序列创建。
- en: 'The `saveLoadList.py` script demonstrates the idea in the `main()` function
    – you can see the implementation of `buildISAX()` in `join.py`. The first part
    of `main()` is as follows. Some code is omitted for brevity:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveLoadList.py`脚本在`main()`函数中展示了这个想法——你可以看到`join.py`中`buildISAX()`的实现。`main()`函数的前部分如下。为了简洁起见，省略了一些代码：'
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the previous code, we put the similarity join data into `variables.ED` by
    calling `Join()` from `isax.iSAXjoin` and printing its length. After that, we
    computed the filename of the output file that is saved in the `filename` variable,
    which is based on the parameters of the program. This is a handy way of creating
    `variables.ED` into that file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将相似性连接数据放入 `variables.ED` 中，通过从 `isax.iSAXjoin` 调用 `Join()` 并打印其长度。之后，我们计算了输出文件的文件名，该文件名存储在
    `filename` 变量中，该变量基于程序的参数。这是一种将 `variables.ED` 创建到该文件中的便捷方法。
- en: 'The second part of `main()` contains the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 的第二部分包含以下代码：'
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the previous code, we tried to read the filename that we used for storing
    the contents of `variables.ED` and put the contents of the plain text file into
    the `PQ` variable. Lastly, we printed the length of `PQ` in order to compare it
    with the length of `variables.ED` and make sure that everything worked as expected.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们尝试读取用于存储 `variables.ED` 内容的文件名，并将纯文本文件的内容放入 `PQ` 变量中。最后，我们打印 `PQ`
    的长度，以便将其与 `variables.ED` 的长度进行比较，并确保一切按预期工作。
- en: 'Running the `saveLoadList.py` script generates the following output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `saveLoadList.py` 脚本生成以下输出：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From the previous output, we understand that the list contains `970603` elements.
    Additionally, the filename where we saved the contents of the list is `List_500k.gz_506k.gz_32_8_16.txt`.
    The only information missing from the filename is the threshold value.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以理解列表包含 `970603` 个元素。此外，我们保存列表内容的文件名为 `List_500k.gz_506k.gz_32_8_16.txt`。文件名中缺少的唯一信息是阈值值。
- en: The next subsection presents a utility that finds the nodes of an iSAX index
    that do not have a match in another iSAX index, and vice versa.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小节将介绍一个实用程序，该实用程序查找在另一个 iSAX 索引中没有匹配的 iSAX 索引的节点，反之亦然。
- en: Finding iSAX nodes without a match
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找没有匹配的 iSAX 节点
- en: In this subsection, we specify the nodes of an iSAX index that do not have a
    match in another iSAX index, and vice versa. In reality, we are going to print
    the SAX representations of the terminal nodes of each iSAX index that do not have
    a match to a terminal node on the other iSAX.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们指定了在另一个 iSAX 索引中没有匹配的 iSAX 索引的节点，反之亦然。实际上，我们将打印出每个 iSAX 索引终端节点的 SAX
    表示，这些终端节点在另一个 iSAX 索引中没有匹配的终端节点。
- en: 'The `noMatch.py` script implements the idea using the following code – we assume
    that we have already created two iSAX indexes for the two time series so that
    we do not have to repeat the code for creating iSAX indexes:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`noMatch.py` 脚本通过以下代码实现了该想法——我们假设我们已经为两个时间序列创建了两个 iSAX 索引，因此我们不需要重复编写创建 iSAX
    索引的代码：'
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The previous code visits all the nodes of the first iSAX index looking for terminal
    nodes. Once a terminal node is found, we get its SAX representation and look in
    the other iSAX index for a terminal node with the same SAX representation. If
    such a node cannot be found, we print the SAX representation of the terminal node
    of the first iSAX index that does not have a match.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码遍历第一个 iSAX 索引的所有节点，寻找终端节点。一旦找到终端节点，我们就获取其 SAX 表示，并在另一个 iSAX 索引中寻找具有相同 SAX
    表示的终端节点。如果找不到这样的节点，我们就打印出第一个 iSAX 索引终端节点的 SAX 表示，该节点没有匹配项。
- en: 'We should now use the same process for the second time series and the second
    iSAX index. The code presented here is similar to the previous one:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该对第二个时间序列和第二个 iSAX 索引使用相同的流程。这里展示的代码与前面的代码类似：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So, right after examining the second iSAX index, we print the total number of
    terminal nodes without a match.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在检查第二个 iSAX 索引后，我们打印出没有匹配的终端节点的总数。
- en: 'Running `noMatch.py` generates the following kind of output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `noMatch.py` 生成以下类型的输出：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we are using the same promotion strategy for both iSAX indexes, the output
    shows that the two iSAX indexes have a different structure, hence the dissimilarities
    in the list of SAX representations without a match on the second iSAX index. Additionally,
    we can see that the maximum cardinality in the printed SAX representations is
    just `8` and that most SAX words have a cardinality of `4`, which means that there
    were not so many splits.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为两个 iSAX 索引使用相同的提升策略，输出显示两个 iSAX 索引具有不同的结构，因此第二个 iSAX 索引上没有匹配的 SAX 表示列表中的差异。此外，我们还可以看到打印的
    SAX 表示中的最大基数仅为 `8`，并且大多数 SAX 单词的基数是 `4`，这意味着没有太多的分割。
- en: Lastly, keep in mind that, in general, the smaller the number of segments in
    a SAX representation, the smaller the number of nodes without a match is going
    to be. Additionally, the larger the threshold value, the smaller the number of
    nodes without a match is going to be, because large threshold values minimize
    splits. In general, *the smaller the number of possible SAX representations is,
    the smaller the number of nodes without a match is going* *to be*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，一般来说，SAX表示中的段数越少，没有匹配的节点数就越少。此外，阈值值越大，没有匹配的节点数就越少，因为大的阈值值会最小化分割。一般来说，*可能的SAX表示越少，没有匹配的节点数就越少*。
- en: 'This can be seen in the following output, where we have reduced the number
    of segments to `4` and increased the cardinality to `64`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在以下输出中看到，其中我们将段的数量减少到`4`，并将基数增加到`64`：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, we have fewer terminal nodes without a match.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们没有那么多没有匹配的终端节点。
- en: The next section briefly touches on the topic of testing Python code by writing
    three basic Python tests for the `isax` package.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节简要介绍了通过编写三个基本的Python测试来测试`isax`包的Python代码的主题。
- en: Writing Python tests
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Python测试
- en: In this last section of this chapter, we are going to learn about Python testing
    and write three tests for our code with the help of the `pytest` package.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将学习Python测试，并使用`pytest`包编写三个测试来测试我们的代码。
- en: As the `pytest` package is not installed by default, the first task you should
    carry out is installing it using your favorite method. Part of the `pytest` package
    is the `pytest` command-line utility, which is used for running the tests.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pytest`包默认未安装，你应该首先使用你喜欢的安装方法来安装它。`pytest`包的一部分是`pytest`命令行工具，用于运行测试。
- en: Unit testing
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试
- en: In this section, we are writing unit tests, which are usually functions that
    we write to make sure that our code works as expected. The result of a unit test
    is either `PASS` or `FAIL`. The more extensive the unit testing is, the more useful
    it is.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们正在编写单元测试，这些通常是用来确保我们的代码按预期工作的函数。单元测试的结果要么是`PASS`，要么是`FAIL`。单元测试越广泛，就越有用。
- en: 'After a successful installation, if you execute the `pytest` command on a directory
    that does not contain any valid tests, you are going to get information about
    your system and your Python installation. On a macOS machine, the output is the
    following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 安装成功后，如果你在一个不包含任何有效测试的目录上执行`pytest`命令，你会得到有关你的系统和Python安装的信息。在macOS机器上，输出如下：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As far as testing functions are concerned, there is a simple rule that you have
    to keep in mind. A testing function when using the `pytest` package is any Python
    function that is prefixed with `test_` in a file where its filename is also prefixed
    by `test_`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就测试函数而言，有一个简单的规则你必须记住。当使用`pytest`包时，任何以`test_`为前缀的Python函数，其文件名也以`test_`为前缀，都可以作为测试函数。
- en: There are many tests that could be written. Usually, we want to test as much
    as possible, starting from the most critical parts of the code and moving to the
    less critical ones. For the purposes of this chapter, we have decided to test
    the core logic of the implementation by writing three tests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编写许多测试。通常，我们希望尽可能多地测试，从代码中最关键的部分开始，逐步过渡到不那么关键的部分。为了本章的目的，我们决定通过编写三个测试来测试实现的核心理念。
- en: The next subsection talks about the three tests that we are going to implement
    in this chapter in more detail.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节将更详细地讨论本章将要实现的三个测试。
- en: What are we going to test?
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们要测试什么？
- en: 'The first thing to define is what we are going to test and why. For this chapter,
    we are going to write the following three tests:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要定义的是我们要测试什么以及为什么要测试。对于本章，我们将编写以下三个测试：
- en: We are going to count the number of subsequences in an iSAX index and make sure
    that the iSAX index holds all the subsequences.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将计算iSAX索引中的子序列数量，并确保iSAX索引包含所有子序列。
- en: We are going to test the number of node splits of an iSAX construction – this
    time, the correct number of splits is going to be stored in a global variable.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将测试iSAX构建过程中的节点分割数量——这次，正确的分割数量将被存储在一个全局变量中。
- en: Lastly, we are going to join the same time series with itself. This means that
    we should get a list of Euclidean distances where all values are equal to 0\.
    Keep in mind that as we are talking about floating-point numbers, the Euclidean
    distances might be very close to 0 but not exactly 0.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将对同一时间序列进行自我连接。这意味着我们应该得到一个欧几里得距离列表，其中所有值都等于0。请记住，由于我们谈论的是浮点数，欧几里得距离可能非常接近0，但不是正好等于0。
- en: The list of tests is far from complete, but it is a good way to illustrate the
    use and usefulness of tests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 测试列表远未完整，但它是一个很好的方式来展示测试的使用和实用性。
- en: The filenames of the time series and the iSAX parameters, as well as the number
    of splits and subsequences, are going to be given as global variables in the source
    code file that holds the testing code for reasons of simplicity. If you want to
    dynamically pass parameters to `pytest` tests, visit the *Basic patterns and examples
    of pytest* link in the *Useful links* section at the end of the chapter for more
    information.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列的文件名、iSAX参数以及分割和子序列的数量将被作为全局变量在包含测试代码的源代码文件中给出，以简化原因。如果您想动态地将参数传递给`pytest`测试，请访问章节末尾的“有用链接”部分中的“*Basic
    patterns and examples of pytest*”链接以获取更多信息。
- en: Comparing the number of subsequences
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较子序列数量
- en: In this test, we compare the number of subsequences in an iSAX index to the
    theoretical number of subsequences based on the sliding window size and the time
    series length.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们比较iSAX索引中的子序列数量与基于滑动窗口大小和时间序列长度的理论子序列数量。
- en: 'The relevant code is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 相关代码如下：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, we appropriately set the global variables in `./isax/variables.py` based
    on the global values found in the preamble of `test_isax.py`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们根据在`test_isax.py`的前置部分中找到的全局值，在`./isax/variables.py`中适当地设置全局变量。
- en: The `createISAX()` helper function is used to create iSAX indexes for testing.
    You have seen that function before in the `speed.py` utility.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`createISAX()`辅助函数用于创建测试用的iSAX索引。您之前在`speed.py`实用程序中见过这个函数。'
- en: What is important and closely related to the test is the use of the `assert`
    keyword. `assert` checks the trueness of the statement that follows. If the statement
    is `True`, then the `assert` statement passes. Otherwise, it throws an exception,
    and as a result, the test function fails. The `assert` keyword is used in all
    our test functions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，与测试密切相关的是`assert`关键字的用法。`assert`检查随后的语句的真实性。如果语句为`True`，则`assert`语句通过。否则，它抛出一个异常，结果测试函数失败。`assert`关键字被用于我们所有的测试函数中。
- en: Next, we are going to discuss the test that checks the number of node splits.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论检查节点分割数量的测试。
- en: Checking the number of node splits
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查节点分割数量
- en: For the purposes of this test, we assume that we have a different program in
    any programming language that we consider correct that gives us the actual number
    of node splits. This number of node splits is stored in a global variable (`splits`)
    and read by the test function.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行这个测试，我们假设我们有一个任何编程语言中的不同程序，该程序被认为是正确的，并且给我们实际的节点分割数量。这个节点分割数量存储在一个全局变量（`splits`）中，并由测试函数读取。
- en: 'The relevant Python code is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的Python代码如下：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this code, we first appropriately set the global variables in `./isax/variables.py`
    based on the global values found in `test_isax.py`. Do not forget to reset `variables.nSplits`
    and select the correct promotion strategy (`variables.defaultPromotion`) in your
    test function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先根据在`test_isax.py`中找到的全局值，在`./isax/variables.py`中适当地设置全局变量。不要忘记在您的测试函数中重置`variables.nSplits`并选择正确的提升策略（`variables.defaultPromotion`）。
- en: The last test function computes the join of a time series with itself, which
    means that all Euclidean distances after the join should be equal to `0`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个测试函数计算时间序列与自身的连接，这意味着连接后的所有欧几里得距离都应该等于`0`。
- en: All Euclidean distances are 0
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有欧几里得距离都是0
- en: In this test, we are going to create the iSAX index of a time series and join
    it with itself. As we are comparing a time series with itself, the list of Euclidean
    distances should only *contain zeros*. Therefore, with this unit test, we examine
    the logical correctness of our code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们将创建时间序列的iSAX索引并将其与自身连接。由于我们正在比较时间序列与自身，欧几里得距离列表应该只*包含零*。因此，通过这个单元测试，我们检查我们代码的逻辑正确性。
- en: 'The relevant Python test function is implemented as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的Python测试函数实现如下：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, we appropriately set the global variables in `./isax/variables.py` based
    on the global values found in `test_isax.py`. After that, we call `createISAX()`
    to construct the iSAX index and then call the `Join()` function to populate the
    list of Euclidean distances.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们根据在 `test_isax.py` 中找到的全局值，在 `./isax/variables.py` 中适当地设置全局变量。然后，我们调用 `createISAX()`
    来构建iSAX索引，然后调用 `Join()` 函数来填充欧几里得距离列表。
- en: The NumPy `zeros()` function creates a NumPy array with all zeros. Its parameter
    defines the length of the NumPy array that is going to be returned. The NumPy
    `allclose()` function returns `True` if its two NumPy array arguments are equal
    within a tolerance. This is mainly the case because when using floating-point
    values, there might be small differences due to rounding.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的 `zeros()` 函数创建一个所有元素为零的NumPy数组。它的参数定义了将要返回的NumPy数组的长度。NumPy 的 `allclose()`
    函数在其两个NumPy数组参数在容差范围内相等时返回 `True`。这主要是因为当使用浮点值时，由于四舍五入可能会存在小的差异。
- en: In the next subsection, we are going to run the tests and see the results.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将运行测试并查看结果。
- en: Running the tests
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: In this section, we are going to run the tests and see their results. All the
    previous code can be found in the `./``ch05/test_isax.py` file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将运行测试并查看其结果。所有之前的代码都可以在 `./ch05/test_isax.py` 文件中找到。
- en: 'The results of the tests, which are all successful, are as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试均成功，结果如下：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the case that there were one or more failed tests, the output would look
    like the following (in this case, only one test failed):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个或多个测试失败，输出将如下所示（在这种情况下，只有一个测试失败）：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The good thing is that the output shows the reason that one or more tests have
    failed and includes the relevant code. In this case, it is the `assert variables.nSplits
    == splits` statement that failed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于输出显示了为什么一个或多个测试失败的原因，并包含了相关的代码。在这种情况下，是 `assert variables.nSplits == splits`
    语句失败了。
- en: This is the last section of this chapter, yet the most important one, as testing
    can save you lots of time during development. The main purpose of our tests is
    to test the logic and the correctness of the code, which is very important.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的最后一节，但也是最重要的一节，因为测试可以在开发过程中为你节省大量时间。我们测试的主要目的是测试代码的逻辑和正确性，这非常重要。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen code for testing the speed of an iSAX index and
    joining two iSAX indexes based on the SAX representations of their nodes. Then,
    we briefly discussed the subject of testing Python code and implemented three
    tests for the `isax` package.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了测试iSAX索引速度和基于节点SAX表示合并两个iSAX索引的代码。然后，我们简要讨论了测试Python代码的主题，并为 `isax`
    包实现了三个测试。
- en: We also discussed the joining of iSAX indexes, which is based on the node types.
    Additionally, the tests we carried out made sure that the core logic of our code
    is correct.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了基于节点类型的iSAX索引的合并，以及我们进行的测试确保了代码的核心逻辑是正确的。
- en: In the next chapter, we are going to learn how to visualize iSAX indexes to
    better understand their structure and performance.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何可视化iSAX索引，以更好地理解其结构和性能。
- en: Before you start reading and working through [*Chapter 6*](B14769_06.xhtml#_idTextAnchor145),
    experiment with the command-line utilities that we have developed in this chapter
    and try to create your own.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始阅读并学习[*第6章*](B14769_06.xhtml#_idTextAnchor145)之前，尝试使用本章中开发的命令行工具，并尝试创建你自己的。
- en: Useful links
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用链接
- en: 'The `pytest` package: https://pypi.org/project/pytest/'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest` 包：https://pypi.org/project/pytest/'
- en: 'Official `pytest` documentation: [https://docs.pytest.org/](https://docs.pytest.org/%0D)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 `pytest` 文档：[https://docs.pytest.org/](https://docs.pytest.org/%0D)
- en: '*Practices of the Python Pro*, written by Dane Hillard'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python专业实践》*，由Dane Hillard著'
- en: '*Mastering Python, 2nd Edition*, written by Rick van Hattem'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《精通Python，第2版》*，由Rick van Hattem著'
- en: '*Robust Python: Write Clean and Maintainable Code*, written by Patrick Viafore'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《编写整洁且可维护的Python代码：Robust Python》*，由Patrick Viafore著'
- en: '*Python Testing with pytest, 2nd Edition*, written by Brian Okken'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用pytest进行Python测试，第2版》*，由Brian Okken著'
- en: 'Basic patterns and examples of `pytest`: [https://docs.pytest.org/en/latest/example/simple.xhtml](https://docs.pytest.org/en/latest/example/simple.xhtml%0D)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest` 的基本模式和示例：[https://docs.pytest.org/en/latest/example/simple.xhtml](https://docs.pytest.org/en/latest/example/simple.xhtml%0D)'
- en: Exercises
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try to work through the following exercises:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试完成以下练习：
- en: 'Use `accessSplit.py` to learn how the sliding window size affects the construction
    speed of the `2M.gz` time series from [*Chapter 4*](B14769_04.xhtml#_idTextAnchor102).
    Perform your experiments for the following sliding window sizes: `16`, `256`,
    `1024`, `4096`, `16384`, and `32786`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`accessSplit.py`来了解滑动窗口大小如何影响从[*第4章*](B14769_04.xhtml#_idTextAnchor102)中构建`2M.gz`时序数据的速度。为以下滑动窗口大小进行实验：`16`、`256`、`1024`、`4096`、`16384`和`32786`。
- en: Can you resolve the overflow situations with `accessSplit.py` and the `500.gz`
    time series we came across at the beginning of the chapter?
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能否使用`accessSplit.py`和我们在本章开头遇到的`500.gz`时序数据解决溢出情况？
- en: Try reducing the threshold values in the `speed.py` examples presented in the
    *Checking the search speed of iSAX indexes* section and see what happens.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试减少在*检查iSAX索引的搜索速度*部分中展示的`speed.py`示例中的阈值值，并看看会发生什么。
- en: Create two time series with 250,000 elements each and use `speed.py` to understand
    their behavior when the number of segments is in the 20 to 40 range. Do not forget
    to use an appropriate sliding window size.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个包含250,000个元素的时序数据，并使用`speed.py`来理解当段落数量在20到40范围内时它们的行为。不要忘记使用适当的大小滑动窗口。
- en: Experiment with `speed.py` but this time, change the threshold value instead
    of the number of segments. Is the threshold value more important than the number
    of segments in the search speed of an iSAX index?
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`speed.py`进行实验，但这次，改变阈值值而不是段落数量。在iSAX索引的搜索速度中，阈值值是否比段落数量更重要？
- en: Modify `speed.py` to display the number of misses in subsequence queries.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`speed.py`以显示子序列查询中的缺失次数。
- en: Modify `join.py` to print the time it took to perform the join.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`join.py`以打印执行连接操作所需的时间。
- en: Modify `saveLoadList.py` to include the threshold value in the filename where
    we save the contents of the list with the Euclidean distances.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`saveLoadList.py`以在保存包含欧几里得距离的列表内容时将阈值值包含在文件名中。
- en: Run the `pytest` command on your own machines and see the output that you get.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自己的机器上运行`pytest`命令，并查看你得到的输出。
