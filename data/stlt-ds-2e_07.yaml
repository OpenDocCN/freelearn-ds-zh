- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Exploring Streamlit Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Streamlit 组件
- en: So far in this book, we have explored features that have been developed by the
    Streamlit core development team, who works full-time on these new and exciting
    features. This chapter, however, will focus on community-driven development, through
    Streamlit Components. While building Streamlit, the team created an established
    method for other developers to create additional features on top of all the existing
    Streamlit open-source magic we have already seen. This method is called Components!
    Streamlit Components allow developers the flexibility to go out and make features
    that are crucial to their workflows or are just simply fun and interesting.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经探索了由 Streamlit 核心开发团队开发的功能，他们全职致力于这些新奇且令人兴奋的功能。然而，本章将专注于社区驱动的开发，通过
    Streamlit 组件。在构建 Streamlit 时，团队创建了一种方法，允许其他开发者在我们已经看到的所有现有 Streamlit 开源魔法之上，创建额外的功能。这种方法被称为组件（Components）！Streamlit
    组件允许开发者灵活地构建出对他们工作流程至关重要的功能，或者仅仅是有趣和好玩的功能。
- en: As Streamlit has become increasingly popular as a framework, so have its Components.
    It feels like every day, I see a new and interesting component that I want to
    try out on my own apps! This chapter will be focused on how to both find and use
    community-made Streamlit Components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Streamlit 成为越来越流行的框架，其组件也在不断增加。感觉每天我都能看到一个新颖且有趣的组件，我想在自己的应用程序中尝试！本章将重点介绍如何查找和使用社区制作的
    Streamlit 组件。
- en: 'In this chapter, we will cover the following six Streamlit Components:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下六个 Streamlit 组件：
- en: Adding editable DataFrames with `streamlit-aggrid`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `streamlit-aggrid` 添加可编辑的 DataFrame
- en: Creating drill-down graphs with `streamlit-plotly-events`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `streamlit-plotly-events` 创建钻取图
- en: Creating beautiful GIFs with `streamlit-lottie`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `streamlit-lottie` 创建美丽的 GIF 动画
- en: Automated analysis with `pandas-profiling`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pandas-profiling` 进行自动化分析
- en: Interactive maps with `st-folium`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `st-folium` 创建交互式地图
- en: Helpful mini-functions with `streamlit-extras`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `streamlit-extras` 创建有用的小函数
- en: Finding more Components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找更多组件
- en: Let’s look at the technical requirements in the next section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看下一节中的技术要求。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we can work with new Streamlit Components, we need to download them
    first. We can download each using `pip` (or any other package manager), just as
    we did with Streamlit in *Chapter 1,* *An Introduction to Streamlit*. These are
    the Components to be downloaded:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用新的 Streamlit 组件之前，首先需要下载它们。我们可以像在*第一章*《Streamlit 简介》中一样，使用 `pip`（或其他包管理器）下载每个组件。这些是需要下载的组件：
- en: '`streamlit-aggrid`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`streamlit-aggrid`'
- en: '`streamlit-plotly-events`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`streamlit-plotly-events`'
- en: '`streamlit-lottie`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`streamlit-lottie`'
- en: '`streamlit-pandas-profiling`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`streamlit-pandas-profiling`'
- en: '`streamlit-folium`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`streamlit-folium`'
- en: '`streamlit-extras`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`streamlit-extras`'
- en: To try out all of these libraries, we’re going to create a multi-page app with
    each library as a self-contained Streamlit app. We will try this out in a new
    folder, which we’ll call `components_example`. For our multi-page app, we need
    a folder called `pages`, and for our first library (`streamlit-aggrid`), we will
    need to add a Python file called `aggrid.py` inside the `pages` folder. We’ll
    be using data from both the penguins and trees datasets that we have already used,
    so copy those into the folder as well.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试所有这些库，我们将创建一个多页应用，每个库都是一个独立的 Streamlit 应用。我们将在一个新文件夹中进行尝试，并命名为 `components_example`。对于我们的多页应用，我们需要一个名为
    `pages` 的文件夹，而对于我们的第一个库（`streamlit-aggrid`），我们需要在 `pages` 文件夹中添加一个名为 `aggrid.py`
    的 Python 文件。我们将使用之前已使用过的企鹅和树木数据集中的数据，因此也要将它们复制到文件夹中。
- en: 'At the end of all that, your `components_example` folder should look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些操作结束后，您的 `components_example` 文件夹应该是这样的：
- en: '![](img/B18444_07_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_07_01.png)'
- en: 'Figure 7.1: Folder Structure'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：文件夹结构
- en: 'Within `streamlit_app.py`, we can add the following code to inform the user
    that all the examples live within the rest of the multi-page app:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `streamlit_app.py` 中，我们可以添加以下代码，以告知用户所有示例都位于其余的多页应用中：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, onto `streamlit-aggrid`!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进入 `streamlit-aggrid`！
- en: Adding editable DataFrames with streamlit-aggrid
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `streamlit-aggrid` 添加可编辑的 DataFrame
- en: We have already used a few methods for showing DataFrames in our Streamlit apps,
    such as the built-in `st.write` and `st.dataframe` functions. We also covered
    the experimental editable DataFrame that Streamlit released in version 1.19, which
    is not as feature-rich in comparison to `streamlit-aggrid` but is significantly
    easier to use! `streamlit-aggrid` essentially creates a beautiful, interactive,
    and editable version of `st.dataframe`, and is built on top of a JavaScript product
    called `AgGrid` ([https://www.ag-grid.com/](https://www.ag-grid.com/)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Streamlit应用中使用了几种显示DataFrame的方法，如内置的`st.write`和`st.dataframe`函数。我们还介绍了Streamlit在1.19版本中发布的实验性可编辑DataFrame，尽管它的功能不如`streamlit-aggrid`丰富，但使用起来显著更简单！`streamlit-aggrid`本质上创建了一个漂亮、交互式且可编辑的`st.dataframe`版本，构建在一个名为`AgGrid`的JavaScript产品之上（[https://www.ag-grid.com/](https://www.ag-grid.com/)）。
- en: The best way to understand this library is to give it a shot! Let’s start by
    using the example of the penguins dataset, with the desire to make an interactive
    and editable DataFrame, which `AgGrid` is so good at.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这个库的最佳方式是亲自尝试！我们从使用企鹅数据集的例子开始，目的是制作一个交互式和可编辑的DataFrame，而这是`AgGrid`的强项。
- en: 'Within `aggrid.py`, we can pull in the penguins data, and use the central function
    in `streamlit-aggrid` called `AgGrid` to display the data in our Streamlit app.
    The code looks like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`aggrid.py`中，我们可以提取企鹅数据，并使用`streamlit-aggrid`中的核心函数`AgGrid`来在Streamlit应用中显示数据。代码如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This gets us to 80% of our desired solution. It creates an app with a whole
    host of features! This app looks like this as of now:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们接近了80%的理想解决方案。它创建了一个具有丰富功能的应用！目前这个应用看起来是这样的：
- en: '![](img/B18444_07_02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_07_02.png)'
- en: 'Figure 7.2: AgGrid Example'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：AgGrid 示例
- en: 'If you click on each column it comes with an auto-filtering mechanism, the
    ability to sort by value, show and hide columns, etc. For example, we can filter
    the **species** column in our dataset to only include the **Chinstrap** value,
    and the DataFrame responds as shown in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击每一列，它会带有自动过滤机制、按值排序、显示和隐藏列等功能。例如，我们可以在数据集中过滤**species**列，仅包含**Chinstrap**值，DataFrame会如以下截图所示进行响应：
- en: '![](img/B18444_07_03.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_07_03.png)'
- en: 'Figure 7.3: First Filter'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：第一次过滤
- en: 'I would encourage you to play around with the features in `AgGrid` to see the
    full set of possibilities. One thing that you might notice is that it shows the
    entire DataFrame by default. I find this to be a little bit jarring for a Streamlit
    app, but luckily, there is a `height` parameter in `streamlit-aggrid` to force
    the DataFrame to fit within a specific height. See the following code for how
    to ensure this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你尝试`AgGrid`中的功能，看看它提供的完整功能集。有一点你可能会注意到的是，它默认显示整个DataFrame。我发现这对于Streamlit应用来说有点突兀，但幸运的是，`streamlit-aggrid`中有一个`height`参数，可以强制将DataFrame显示在特定高度内。请参见以下代码，了解如何确保这一点：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last feature that we have already discussed but have not shown off yet
    is the ability to edit DataFrames within AgGrid. Again, it is as easy as adding
    a parameter to the AgGrid function. The function returns the edited DataFrame,
    which we can use in the rest of our app. This means that the component is bidirectional,
    just like all the Streamlit input widgets we have already used. This next bit
    of code adds the edit functionality and also shows how we can access the edited
    DataFrame:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过但还没有展示的最后一个特性是能够在AgGrid中编辑DataFrame。同样，这和在AgGrid函数中添加一个参数一样简单。该函数返回编辑后的DataFrame，我们可以在应用的其余部分使用它。这意味着该组件是双向的，和我们已经使用过的所有Streamlit输入控件一样。接下来的这段代码添加了编辑功能，并展示了我们如何访问编辑后的DataFrame：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From this code, we can see the following app:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码，我们可以看到以下应用：
- en: '![](img/B18444_07_04.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_07_04.png)'
- en: 'Figure 7.4: Editable DataFrames'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：可编辑的DataFrame
- en: The above app is shown after I went in and edited a single row of the DataFrame,
    changing the value from `Adelie` to `Adelie_example`. We can then use that DataFrame
    in the rest of our app and can do anything from showing a graph based on the edited
    DataFrame to saving the DataFrame back to a CSV file; the possibilities here are
    enormous. `streamlit-aggrid` is one of the most popular Streamlit Components,
    and hopefully, you now see why! There are dozens of other features in the library;
    you can find more of them at [https://streamlit-aggrid.readthedocs.io/](https://streamlit-aggrid.readthedocs.io/).
    Now, onto drill-down graphs with the next component, `streamlit-plotly-events`!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的应用展示了我修改了数据框架（DataFrame）中的一行，将值从 `Adelie` 改为 `Adelie_example` 后的效果。我们可以在应用的其余部分中使用这个数据框架，并可以执行从基于编辑过的数据框显示图表到将数据框保存回
    CSV 文件等任何操作；这里的可能性是巨大的。`streamlit-aggrid` 是最受欢迎的 Streamlit 组件之一，希望你现在明白为什么了！该库中还有几十个其他功能，你可以在
    [https://streamlit-aggrid.readthedocs.io/](https://streamlit-aggrid.readthedocs.io/)
    查找更多。现在，继续介绍下一个组件 `streamlit-plotly-events` 进行钻取图表！
- en: Creating drill-down graphs with streamlit-plotly-events
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `streamlit-plotly-events` 创建钻取图表
- en: One of the most popular advanced features in any plotting library is the ability
    to drill down into sections or parts of graphs. The users of your apps will often
    have questions about your data that you have not anticipated in advance! Instead
    of creating new Streamlit inputs around graphs, users often will want to click
    on items in your graphs like points or bars, and get more information about that
    point. For example, in our penguins scatterplot graph, a user might want to see
    all the data available for a penguin, which is represented by a point being scrolled
    over in a DataFrame.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 任何绘图库中最受欢迎的高级功能之一是能够钻取图表的部分或区域。你的应用用户常常会对你的数据提出一些你没有预料到的问题！与其围绕图表创建新的 Streamlit
    输入，用户通常希望点击图表中的项目（如点或条形图），并获取该点的更多信息。例如，在我们的企鹅散点图中，用户可能希望查看与某只企鹅相关的所有数据，这些数据由鼠标悬停在数据框（DataFrame）中的某个点上表示。
- en: '`streamlit-plotly-events` turns the unidirectional `st.plotly_chart` function
    into a bidirectional one, where we can receive events like clicks or hovers back
    into our Streamlit app. To test this out, we will create another app inside the
    `pages` folder, this one called `plotly_events` and will create a graph based
    on the penguins dataset.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`streamlit-plotly-events` 将单向的 `st.plotly_chart` 函数转变为双向的函数，在其中我们可以接收像点击或悬停之类的事件，并将其返回到我们的
    Streamlit 应用中。为了测试这个功能，我们将在 `pages` 文件夹内创建另一个应用，这个应用名为 `plotly_events`，并将基于企鹅数据集创建一个图表。'
- en: 'To start out, we can import the libraries, read in the data, and make a familiar
    graph in Plotly:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以导入库，读取数据，并在 Plotly 中绘制一个常见的图表：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead of calling `st.plotly_chart`, we replaced it with the `plotly_events`
    function call instead. Other than that, there is no difference between this and
    our regular use of Plotly. At the moment, this does nothing special, and our app
    should look fairly standard:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有调用 `st.plotly_chart`，而是将其替换为 `plotly_events` 函数调用。除此之外，与我们常规使用 Plotly 的方式没有区别。目前，这不会做任何特别的事情，我们的应用应该看起来比较标准：
- en: '![](img/B18444_07_05.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_07_05.png)'
- en: 'Figure 7.5: Plotly Chart Original'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：Plotly 图表原始版本
- en: 'The `plotly_events` function takes an argument called `click_event`, which,
    if we set it to `true`, will return all the click events back to Streamlit as
    a variable. The next script uses this parameter and writes the click event back
    to Streamlit:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotly_events` 函数接受一个名为 `click_event` 的参数，如果我们将其设置为 `true`，将把所有点击事件作为变量返回给
    Streamlit。接下来的脚本使用了这个参数，并将点击事件写回 Streamlit：'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now when we run this app and click on points, we can see the clicked-on value!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这个应用并点击图表上的点时，我们可以看到被点击的值！
- en: '![](img/B18444_07_06.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_07_06.png)'
- en: 'Figure 7.6: Click Event'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：点击事件
- en: This is not incredibly special just yet, because Plotly has these points on
    hover already. We can improve on this by showing all the data we have on the clicked-on
    point, as shown in the following code (I removed the imports for brevity). We
    need to stop the app if there are no points selected; otherwise, the app will
    error out!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这还不是特别特别的，因为 Plotly 已经可以在悬停时显示这些点。我们可以通过显示点击的点的所有数据来改进这一点，以下是改进后的代码（为了简洁，我省略了导入部分）。如果没有选择任何点，我们需要停止应用，否则应用将报错！
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, our final app looks like the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的最终应用看起来如下：
- en: '![](img/B18444_07_07.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_07_07.png)'
- en: 'Figure 7.7: Drill-Down Dashboard'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：钻取仪表盘
- en: It really is that easy to turn Plotly charts into drill-down, bidirectional
    dashboards! In this example, users can see info like the sex and flipper length
    of the penguins they have selected, and we theoretically could use this selection
    event however we’d like in the rest of the app.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将Plotly图表轻松转换为钻取式、双向仪表板真的很容易！在此示例中，用户可以查看所选择企鹅的性别和鳍长度等信息，理论上我们可以在应用程序的其余部分中随意使用此选择事件。
- en: The `streamlit-plotly-events` library has two other events (`select_event` and
    `hover_event`), which can be useful as well and are returned in the same fashion.
    If you’ve used one of them, you can easily pick up the others when it is necessary.
    With drill-down dashboards done, let’s move over to adding beautiful animations
    to our app using `streamlit-lottie`!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`streamlit-plotly-events`库还有另外两个事件（`select_event`和`hover_event`），这些事件也同样有用，并以相同方式返回。如果你使用了其中一个，当需要时你可以轻松地使用另一个。随着钻取式仪表板的完成，让我们转而使用`streamlit-lottie`向我们的应用程序添加美丽的动画！'
- en: Using Streamlit Components – streamlit-lottie
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Streamlit组件 - streamlit-lottie
- en: '**Lottie** is a web-native, open-source library created by *Airbnb* to make
    putting animations on your website just as easily as putting static images on
    it. It is very common for large, profitable tech companies to put out open-source
    software as a way of giving back to the developer community (or, more likely,
    to recruit developers who think their software is cool), and this is no exception.
    In this case, `streamlit-lottie` wraps around `lottie` files and places them directly
    into our Streamlit apps.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lottie** 是由*Airbnb*创建的一种网页原生开源库，使得在您的网站上放置动画与放置静态图像一样简单。大型、盈利的技术公司将开源软件发布给开发者社区是一种非常普遍的做法，这样做不仅是回馈开发者社区（或者更可能是为了招募那些认为他们的软件很酷的开发者），这个库也不例外。在这种情况下，`streamlit-lottie`封装了`lottie`文件，并直接将它们放入我们的Streamlit应用程序中。'
- en: Before we try this out for ourselves, we first need to import the `streamlit-lottie`
    library, and then point the `st_lottie()` function to our `lottie` file. We can
    either import a local `lottie` file or, more likely, we can find a useful animation
    file on the free site ([https://lottiefiles.com/](https://lottiefiles.com/)) and
    load it from there into our app.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试之前，我们首先需要导入`streamlit-lottie`库，然后将`st_lottie()`函数指向我们的`lottie`文件。我们可以导入本地的`lottie`文件，或者更可能的是，我们可以在免费网站（[https://lottiefiles.com/](https://lottiefiles.com/)）上找到一个有用的动画文件，并从那里加载到我们的应用程序中。
- en: 'To test this out, we can add a cute penguin animation ([https://lottiefiles.com/39646-cute-penguin](https://lottiefiles.com/39646-cute-penguin))
    to the top of the Penguins app that we created earlier in this chapter. To keep
    everything organized, let’s copy the `plotly_events.py` file in its current state
    to a new file called `penguin_animated.py`, also in the `pages` folder. We can
    run the following code from the `components_example` folder, or just copy the
    file over manually:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个功能，我们可以将一个可爱的企鹅动画（[https://lottiefiles.com/39646-cute-penguin](https://lottiefiles.com/39646-cute-penguin)）添加到我们在本章早些时候创建的企鹅应用程序的顶部。为了保持一切井然有序，让我们将`plotly_events.py`文件的当前状态复制到名为`penguin_animated.py`的新文件中，同样放在`pages`文件夹中。我们可以从`components_example`文件夹运行以下代码，或者手动复制文件：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, in this new file, we can make some changes to the older app. The following
    code block makes a function, as shown in the example from the `streamlit-lottie`
    library ([https://github.com/andfanilo/streamlit-lottie](https://github.com/andfanilo/streamlit-lottie)),
    which allows us to load `lottie` files from the URL and then loads this animation
    at the top of the application:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在这个新文件中，我们可以对旧应用程序进行一些更改。以下代码块创建了一个函数，如`streamlit-lottie`库的示例所示（[https://github.com/andfanilo/streamlit-lottie](https://github.com/andfanilo/streamlit-lottie)），允许我们从URL加载`lottie`文件，然后在应用程序顶部加载此动画：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The remainder of the app will stay the same as with the Plotly events library
    section. Now when we run the Streamlit app, we see the animation at the top:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的其余部分与Plotly事件库部分保持一致。现在当我们运行Streamlit应用程序时，我们在顶部看到动画：
- en: '![](img/B18444_07_08.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_07_08.png)'
- en: 'Figure 7.8: Cute Penguin'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：可爱的企鹅
- en: The previous section of code uses the `requests` library to define a function
    that we can use to load `lottie` files from a link. In this case, I have pre-filled
    a link that takes us to a cute penguin animation. We then loaded our file and
    called that file using the `st_lottie()` function we imported from our `streamlit-lottie`
    library. And as you can see, we have an animation at the top!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节的代码使用了`requests`库来定义一个函数，我们可以用它从链接加载`lottie`文件。在这个例子中，我已经预填了一个链接，指向一个可爱的企鹅动画。然后我们加载了这个文件，并使用从`streamlit-lottie`库中导入的`st_lottie()`函数来调用该文件。正如你所看到的，我们在顶部有一个动画！
- en: '`streamlit-lottie` also allows us to change the animation speed, width, and
    height through the `speed`, `width`, and `height` parameters, respectively. If
    the animation goes too slowly for your taste, increase the speed to a number such
    as `1.5` or `2`, which will increase the speed by 50% or 100%. The `height` and
    `width` parameters, however, are the pixel height/width of the animation and default
    to the native size of the animation.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`streamlit-lottie`还允许我们通过`speed`、`width`和`height`参数分别改变动画的速度、宽度和高度。如果动画的速度太慢，可以将速度增大到例如`1.5`或`2`，这将分别使速度增加50%或100%。然而，`height`和`width`参数是动画的像素高度/宽度，默认为动画的原生大小。'
- en: I would strongly encourage running this app, as the penguin animation is really
    quite adorable. And that completes our tour of `streamlit-lottie`! I have started
    getting into the habit of putting a nice animation at the top of each and every
    Streamlit app I create—it creates a sense of design that makes Streamlit apps
    feel more purposeful, and immediately alerts the user to the fact that this is
    not a static document but instead a dynamic and interactive application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议运行这个应用，因为企鹅动画实在是非常可爱。这也标志着我们对`streamlit-lottie`的介绍已经完成！我已经养成了在每个我创建的 Streamlit
    应用顶部加入一个精美动画的习惯——它创造了一种设计感，使得 Streamlit 应用显得更有目的性，并且立即提醒用户，这不是一个静态文档，而是一个动态交互式应用。
- en: Using Streamlit Components – streamlit-pandas-profiling
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Streamlit 组件 – streamlit-pandas-profiling
- en: '`pandas-profiling` is a very powerful Python library that automates some of
    the EDA, which is often the first step in any data analysis, modeling, or even
    data engineering task. Before a data scientist begins almost any data work, they
    want to start with a good understanding of the distributions of their underlying
    data, the number of missing rows, correlations between variables, and many other
    basic pieces of information. As we mentioned before, this library automates the
    process and then places this interactive analytics document into a Streamlit app
    for the user.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas-profiling`是一个非常强大的 Python 库，它自动化了一些 EDA（探索性数据分析），这是任何数据分析、建模甚至数据工程任务的第一步。在数据科学家开始几乎所有数据工作之前，他们都希望首先了解他们数据的分布情况、缺失行的数量、变量之间的相关性，以及许多其他基本信息。正如我们之前提到的，这个库自动化了这个过程，然后将这个交互式分析文档放入
    Streamlit 应用中供用户使用。'
- en: Behind the Streamlit component called `pandas-profiling`, there is a full Python
    library with the same name, which the component imports its functions from. The
    Streamlit component here actually renders the output from the `pandas-profiling`
    Python library in a way that becomes very easy to integrate. For this segment,
    we will first learn how to implement the library, and then explore the generated
    output.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为`pandas-profiling`的 Streamlit 组件背后，有一个相同名称的完整 Python 库，组件从中导入其函数。这个 Streamlit
    组件实际上将来自`pandas-profiling` Python 库的输出渲染为一种非常容易集成的方式。在这一部分中，我们将首先学习如何实现这个库，然后探索生成的输出。
- en: 'For our example, we will continue with our code from the previous section on
    Palmer Penguins and add our automatically generated profile to the bottom of the
    app. The code for this is only a few lines—we need to generate a report for our
    dataset and then use the Streamlit component to add the generated report to our
    app. Again, as we did before, copy the code from the `streamlit-lottie` section
    into a new file called `penguin_profiled.py`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将继续使用上一节关于企鹅的代码，并将自动生成的个人资料添加到应用程序的底部。这段代码只有几行——我们需要为数据集生成报告，然后使用
    Streamlit 组件将生成的报告添加到应用程序中。同样，像之前一样，将`streamlit-lottie`部分的代码复制到一个新文件中，命名为`penguin_profiled.py`：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The next code block imports the necessary libraries for our profiling!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码导入了我们分析所需的库！
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The middle section of the app stays the same, so we will not copy all the code
    here. The end, however, uses the functions that we imported earlier to get a profile
    of the DataFrame:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的中间部分保持不变，因此我们不会在这里复制所有代码。然而，最后使用了我们之前导入的函数来获取DataFrame的概况：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we get an entire profile of the penguins dataset, which looks like the
    following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们得到了整个企鹅数据集的概况，内容如下所示：
- en: '![](img/B18444_07_09.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_07_09.png)'
- en: 'Figure 7.9: The penguin dataset profile'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：企鹅数据集概况
- en: This has an overview section that warns us about variables that are highly correlated
    or missing data, and even allows us to drill down into specific columns incredibly
    easily. We could remake this entire library in Streamlit (I’ll leave that as a
    very advanced exercise to the reader!), but it is nice to have an automated exploratory
    analysis like this.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个概述部分，警告我们关于高度相关的变量或缺失数据，甚至允许我们非常轻松地深入查看特定列。我们可以在Streamlit中重新制作整个库（我将这一点作为非常高级的练习留给读者！），但拥有这样的自动化探索分析也是非常不错的。
- en: This is also a good lesson about composability—we can treat Streamlit Components
    as unique Lego blocks, combining them at will to create new and interesting Streamlit
    applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个关于组合性的重要课程——我们可以将Streamlit组件视为独特的乐高积木，随意组合它们来创建新的、有趣的Streamlit应用。
- en: This is another component that you should try out on your own, to see all the
    information that it can show the user. Now on to bidirectional apps with `st-folium`!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个你应该自己尝试的组件，看看它能向用户展示哪些信息。接下来，我们将介绍使用`st-folium`的双向应用！
- en: Interactive maps with st-folium
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用st-folium的互动地图
- en: Earlier in this chapter, we learned how critical it could be to add bidirectionality
    to visualizations through `streamlit-plotly-events`. Drilling down into graphs
    is an oft requested feature by business users, and maps are no exception to that!
    `st-folim` is very similar to `streamlit-plotly-events`, but for geospatial maps.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们学到了通过`streamlit-plotly-events`为可视化添加双向功能的重要性。深入分析图表是商业用户经常要求的功能，地图也不例外！`st-folium`非常类似于`streamlit-plotly-events`，但它是针对地理空间地图的。
- en: 'This example focuses on the trees dataset that we have used time and time again
    in this book, so go ahead and create a new file in the `pages` folder called `folium_map.py`,
    and we can get started. The following section of code loads the libraries, adds
    the data, creates a `folium` map, and adds that map to our Streamlit app. This
    is mostly a repeat of our previous graph, which maps the trees in SF but adds
    the Folium library:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例重点使用了我们在本书中一再使用的树木数据集，所以请创建一个新的文件`folium_map.py`，并将其放入`pages`文件夹中，然后我们可以开始。以下代码段加载库，添加数据，创建`folium`地图，并将该地图添加到我们的Streamlit应用中。这基本上是我们之前图表的重复，映射了旧金山的树木数据，但增加了Folium库：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code will create the following app, which, as of now, is just a map of
    San Fransisco! But you will notice that we can scroll around, zoom in and out,
    and make use of all the normal features we would expect from a map:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将创建如下应用，目前它只是旧金山的一个地图！但你会注意到，我们可以滚动、缩放，使用地图的所有正常功能：
- en: '![](img/B18444_07_10.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_07_10.png)'
- en: 'Figure 7.10: Our first Folium map'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：我们的第一个Folium地图
- en: On top of this, we want to add a little marker for each of the points that we
    have in our trees dataset, to replicate the trees map we have already created.
    We can use a basic `for` loop to do this!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们希望为每个树木数据集中的点添加一个小标记，以复制我们已经创建的树木地图。我们可以使用一个基本的`for`循环来实现这一点！
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, our app will have our 100 trees as markers, like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用将拥有100棵树的标记，像这样：
- en: '![](img/B18444_07_11.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_07_11.png)'
- en: 'Figure 7.11: Adding points to Folium'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：向Folium添加点
- en: 'This is not that special just yet! Cool, but is not that different from any
    other map that we can make. The interesting part comes when we realize that the
    `st_folium` function returns the click events made on the map by default! So now,
    we can receive those events and print them back to the Streamlit app with the
    following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不算特别！很酷，但与我们可以制作的其他地图并没有太大区别。真正有趣的部分是，当我们意识到`st_folium`函数默认返回地图上的点击事件时！所以现在，我们可以接收这些事件，并通过以下代码将其打印到Streamlit应用中：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our app now prints out the click events to our Streamlit app, and we can then
    use them programmatically in the same way as in `streamlit-plotly-events`!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用将点击事件打印到Streamlit应用中，然后我们可以像在`streamlit-plotly-events`中那样以编程方式使用它们！
- en: '![](img/B18444_07_12.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_07_12.png)'
- en: 'Figure 7.12: Bidirectional Maps'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：双向地图
- en: This is the magic of Streamlit, and of `st-folium`! Interactivity is straightforward,
    and dynamic apps that delight users are just around each corner.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Streamlit 的魔力，以及 `st-folium`！交互性非常直观，动态的应用程序就在每一个转角处，给用户带来惊喜。
- en: Now for our last library of this chapter, a library created by the Streamlit
    data product team called `streamlit-extras`!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是本章的最后一个库，它是由 Streamlit 数据产品团队创建的名为 `streamlit-extras` 的库！
- en: Helpful mini-functions with streamlit-extras
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: streamlit-extras 中的有用迷你函数
- en: I have personally been a part of the Streamlit data product team since the beginning
    of 2022, and that work unsurprisingly centers around creating Streamlit apps about
    the business that is Streamlit. The team creates dozens of apps for dozens of
    business partners, and as a part of that work has created dozens of helper functions
    that make it more fun and efficient to create Streamlit apps.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2022 年初以来，我一直是 Streamlit 数据产品团队的一员，毫无意外地，我们的工作围绕着为 Streamlit 这家公司创建 Streamlit
    应用程序展开。团队为众多商业伙伴创建了几十个应用程序，在这项工作中，我们还创造了几十个辅助函数，使得创建 Streamlit 应用程序变得更加有趣和高效。
- en: Every team has functions like these. At Streamlit, it is encouraged to open-source
    as much of your work as possible, so we decided to turn these functions into a
    Python package and release it out to the community.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个团队都有类似的功能。在 Streamlit，我们鼓励尽可能多地将你的工作开源，因此我们决定将这些功能做成一个 Python 包并发布到社区。
- en: 'For example, we had a problem where users of our apps would accidentally just
    select one date in a date range, and then the entire app would not run correctly.
    In response to this, we built a mandatory date range picker that will not run
    the app until two dates are selected! It can be used like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们曾遇到一个问题，应用程序的用户不小心在日期范围中只选择了一个日期，结果整个应用无法正常运行。为了解决这个问题，我们构建了一个强制性的日期范围选择器，只有在选择了两个日期后，应用才会运行！它可以这样使用：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or for another example, we wanted to have an input that looked like the toggles
    in our favorite document management software, Notion. So we built a small one!
    It can be used like so:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，我们希望有一个输入框，看起来像我们最喜欢的文档管理软件 Notion 中的切换开关。所以我们构建了一个小的版本！它可以这样使用：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we can create toggles that look like this!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建像这样的切换开关！
- en: '![](img/B18444_07_13.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_07_13.png)'
- en: 'Figure 7.13: Toggle!'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13：切换！
- en: All of these features, and dozens more, exist in one little library. A huge
    percent of this work can be attributed to my teammates Arnaud Miribel ([https://github.com/arnaudmiribel](https://github.com/arnaudmiribel))
    and Zachary Blackwood ([https://github.com/blackary](https://github.com/blackary))!
    They built and released this library and are great Streamlit developers to follow
    on GitHub. You can find the rest of Streamlit extras at ([https://extras.streamlit.app/](https://extras.streamlit.app/)),
    so `pip` `install` and give it a shot!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能，以及更多的功能，都存在于一个小小的库中。这个工作中的很大一部分要归功于我的队友 Arnaud Miribel ([https://github.com/arnaudmiribel](https://github.com/arnaudmiribel))
    和 Zachary Blackwood ([https://github.com/blackary](https://github.com/blackary))！他们构建并发布了这个库，是值得在
    GitHub 上关注的优秀 Streamlit 开发者。你可以在 ([https://extras.streamlit.app/](https://extras.streamlit.app/))
    找到其余的 Streamlit extras，赶紧用 `pip` `install` 安装并尝试一下吧！
- en: Finding more Components
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找更多组件
- en: These Components are a tiny percentage of all the Components the Streamlit community
    has created, and by the time you may be reading this, I am sure the number of
    Components out there will be dramatically higher. The best place to find new and
    interesting Components is on either the Streamlit website at [https://streamlit.io/gallery?type=components&category=featured](https://streamlit.io/gallery?type=components&category=featured)
    or the discussion forums at [https://discuss.streamlit.io/c/streamlit-components/18](https://discuss.streamlit.io/c/streamlit-components/18).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件只是 Streamlit 社区创建的所有组件中的一小部分，而在你读到这篇文档时，我相信已有的组件数量会大幅增加。寻找新的、有趣的组件的最佳地方是
    Streamlit 网站的[https://streamlit.io/gallery?type=components&category=featured](https://streamlit.io/gallery?type=components&category=featured)
    或讨论论坛[https://discuss.streamlit.io/c/streamlit-components/18](https://discuss.streamlit.io/c/streamlit-components/18)。
- en: When you find a Component that you think is interesting, try it out by downloading
    it with `pip` as we did earlier, and read enough documentation to get started!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你找到一个你觉得有趣的组件时，可以像我们之前做的那样，通过 `pip` 下载并试用，并阅读足够的文档以开始使用！
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At this point, I hope you feel very comfortable downloading and using Streamlit
    Components, which you have learned about here, as well as comfortable with finding
    new Streamlit Components created by the community. You should really understand
    how to find, download, and use Streamlit Components to bolster the apps that you
    build.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我希望你已经非常熟练地下载并使用了在这里学习到的 Streamlit 组件，也能轻松地找到社区创建的其他 Streamlit 组件。你应该真正理解如何找到、下载和使用
    Streamlit 组件，以增强你构建的应用程序。
- en: In the next chapter, we will dive more deeply into deploying your own Streamlit
    apps with a cloud provider such as **Heroku** or **Hugging Face**!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨如何通过 **Heroku** 或 **Hugging Face** 等云服务提供商部署你自己的 Streamlit 应用！
- en: Learn more on Discord
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——你可以在这里分享反馈、向作者提问、并了解最新的发布——请扫描下面的二维码：
- en: '[https://packt.link/sl](https://packt.link/sl)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/sl](https://packt.link/sl)'
- en: '![](img/QR_Code13440134443835796.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code13440134443835796.png)'
