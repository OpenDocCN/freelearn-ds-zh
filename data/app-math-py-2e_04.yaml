- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Working with Randomness and Probability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与随机性和概率打交道
- en: In this chapter, we will discuss randomness and probability. We will start by
    briefly exploring the fundamentals of probability by selecting elements from a
    set of data. Then, we will learn how to generate (pseudo) random numbers using
    Python and NumPy, and how to generate samples according to a specific probability
    distribution. We will conclude the chapter by looking at a number of advanced
    topics covering random processes and Bayesian techniques and using **Markov Chain
    Monte Carlo** (**MCMC**) methods to estimate the parameters of a simple model.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论随机性和概率。我们将从简要探索概率的基本概念开始，通过从数据集中选择元素来学习概率。然后，我们将学习如何使用Python和NumPy生成（伪）随机数，并如何根据特定的概率分布生成样本。最后，我们将通过讨论一些高级主题，涵盖随机过程和贝叶斯技术，并使用**马尔科夫链蒙特卡洛**（**MCMC**）方法来估计简单模型的参数，来结束本章。
- en: Probability is a quantification of the likelihood of a specific event occurring.
    We use probabilities intuitively all of the time, although sometimes the formal
    theory can be quite counterintuitive. Probability theory aims to describe the
    behavior of *random variables* whose value is not known, but where the probabilities
    of the value of this random variable take some (range of) values that are known.
    These probabilities are usually in the form of one of several probability distributions.
    Arguably, the most famous probability distribution of this kind is normal distribution,
    which, for example, can describe the spread of a certain characteristic over a
    large population.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 概率是对特定事件发生的可能性进行量化。我们经常直观地使用概率，尽管有时正式的理论可能相当违反直觉。概率论旨在描述*随机变量*的行为，随机变量的值未知，但该随机变量的值的概率会在已知的某些（范围的）值中取值。这些概率通常呈现为几种概率分布之一。可以说，最著名的概率分布之一是正态分布，它例如可以描述某一特征在一个大群体中的分布情况。
- en: We will see probability again in a more applied setting in [*Chapter 6*](B19085_06.xhtml#_idTextAnchor226),
    *Working with Data and Statistics*, where we will discuss statistics. Here, we
    will put probability theory to use to quantify errors and build a systematic theory
    of analyzing data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第六章*](B19085_06.xhtml#_idTextAnchor226)《数据与统计学应用》中，我们将再次讨论概率，并且将介绍统计学。在这里，我们将应用概率论来量化误差，并构建分析数据的系统化理论。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下实例：
- en: Selecting items at random
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择项目
- en: Generating random data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机数据
- en: Changing the random number generator
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改随机数生成器
- en: Generating normally distributed random numbers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成正态分布的随机数
- en: Working with random processes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与随机过程打交道
- en: Analyzing conversion rates with Bayesian techniques
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用贝叶斯技术分析转化率
- en: Estimating parameters with Monte Carlo simulations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蒙特卡洛模拟估计参数
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we require the standard scientific Python packages: NumPy,
    Matplotlib, and SciPy. We will also require the PyMC package for the final recipe.
    You can install this using your favorite package manager, such as `pip`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用标准的科学Python包：NumPy、Matplotlib和SciPy。我们还需要PyMC包来完成最终的实例。你可以通过你喜欢的包管理工具安装，比如`pip`：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command will install the most recent version of PyMC, which, at the time
    of writing, is 4.0.1\. This package provides facilities for probabilistic programming,
    which involves performing many calculations driven by randomly generated data
    to understand the likely distribution of a solution to a problem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将安装最新版本的PyMC，目前版本为4.0.1\。此包提供了概率编程功能，涉及通过随机生成的数据进行多次计算，以了解解决方案的可能分布。
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the previous edition, the current version of PyMC was 3.9.2, but since then,
    PyMC version 4.0 was released and the name reverted to PyMC with this update rather
    than PyMC3\.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一版中，当前版本的PyMC是3.9.2，但自那时以来，PyMC 4.0版本已经发布，并且在此更新中名称恢复为PyMC，而不是PyMC3\。
- en: The code for this chapter can be found in the `Chapter 04` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2004](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2004).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub仓库的`Chapter 04`文件夹中找到，链接：[https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2004](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2004)。
- en: Selecting items at random
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机选择项目
- en: At the core of probability and randomness is the idea of selecting an item from
    some kind of collection. As we know, the probability of selecting an item from
    a collection quantifies the likelihood of that item being selected. Randomness
    describes the selection of items from a collection according to probabilities
    without any additional bias. The opposite of a random selection might be described
    as a *deterministic* selection. In general, it is very difficult to replicate
    a purely random process using a computer because computers and their processing
    are inherently deterministic. However, we can generate sequences of pseudorandom
    numbers that, when properly constructed, demonstrate a reasonable approximation
    of randomness.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 概率和随机性的核心思想是从某种集合中选择一个项目。正如我们所知道的，从集合中选择一个项目的概率量化了该项目被选择的可能性。随机性描述了根据概率从集合中选择项目，而没有任何额外的偏差。随机选择的对立面可以被描述为*确定性*选择。一般来说，使用计算机复制一个纯随机过程是非常困难的，因为计算机及其处理本质上是确定性的。然而，我们可以生成伪随机数序列，当这些序列正确构造时，能够展示出一个合理的随机性近似。
- en: In this recipe, we will select items from a collection and learn about some
    of the key terminology associated with probability and randomness that we will
    need throughout this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将从一个集合中选择项目，并学习一些与概率和随机性相关的关键术语，这些术语将在本章中贯穿始终。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The Python Standard Library contains a module for generating (pseudo) random
    numbers called `random`, but in this recipe and throughout this chapter, we will
    use the NumPy `random` module instead. The routines in the NumPy `random` module
    can be used to generate arrays of random numbers and are slightly more flexible
    than their standard library counterparts. As usual, we import NumPy under the
    `np` alias.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库包含一个用于生成（伪）随机数的模块，叫做 `random`，但在本配方和整个章节中，我们将使用NumPy的 `random` 模块。NumPy
    `random` 模块中的例程可以用于生成随机数数组，并且比标准库中的相应模块更具灵活性。像往常一样，我们会使用 `np` 别名导入NumPy。
- en: Before we can proceed, we need to fix some terminology. A **sample space** is
    a set (a collection with no repeated elements) and an **event** is a subset of
    the sample space. The **probability** that an event, ![](img/Formula_04_001.png),
    occurs is denoted as ![](img/Formula_04_002.png), and is a number between 0 and
    1\. A probability of 0 indicates that the event can never occur, while a probability
    of 1 indicates that an event will certainly occur. The probability of the whole
    sample space must be 1.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要固定一些术语。**样本空间**是一个集合（一个没有重复元素的集合），**事件**是样本空间的一个子集。**事件**发生的**概率**用
    ![](img/Formula_04_001.png) 表示，记作 ![](img/Formula_04_002.png)，它是一个介于0和1之间的数字。概率为0表示事件永远不会发生，而概率为1表示事件肯定会发生。整个样本空间的概率必须为1。
- en: When the sample space is discrete, then probabilities are just numbers between
    0 and 1 associated with each of the elements, where the sum of all these numbers
    is 1\. This gives meaning to the probability of selecting a single item (an event
    consisting of a single element) from a collection. We will consider methods for
    selecting items from a discrete collection here and deal with the *continuous*
    case in the *Generating normally distributed random* *numbers* recipe.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当样本空间是离散的时，概率只是介于 0 和 1 之间的数字，关联到每个元素，其中所有这些数字的总和为 1。这样就给出了从一个集合中选择单个项目（一个包含单一元素的事件）的概率的意义。我们将在这里考虑从离散集合中选择项目的方法，并将在*生成正态分布的随机*
    *数*的配方中处理*连续*的情况。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to select items at random from a container:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤从容器中随机选择项目：
- en: 'The first step is to set up the random number generator. For the moment, we
    will use the default random number generator for NumPy, which is recommended in
    most cases. We can do this by calling the `default_rng` routine from the NumPy
    `random` module, which will return an instance of a random number generator. We
    will usually call this function without a seed, but for this recipe, we will add
    a `12345` seed so that our results are repeatable:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是设置随机数生成器。此时，我们将使用NumPy的默认随机数生成器，这在大多数情况下都是推荐的。我们可以通过调用NumPy `random` 模块中的
    `default_rng` 例程来实现，这将返回一个随机数生成器实例。我们通常在不指定种子的情况下调用这个函数，但在本配方中，我们将添加一个 `12345`
    种子，以便使我们的结果具有可重复性：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we need to create the data and probabilities that we will select from.
    This step can be skipped if you already have the data stored or if you want to
    select elements with equal probabilities:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建要选择的数据和概率。如果你已经存储了数据，或者希望选择具有相等概率的元素，可以跳过此步骤：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As a quick sanity test, we can use an assertion to check that these probabilities
    do indeed sum to 1:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速的基本检查，我们可以使用断言来检查这些概率的和确实为 1：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can use the `choice` method on the random number generator, `rng`,
    to select the samples from `data` according to the probabilities just created.
    For this selection, we want to turn the replacement on, so calling the method
    multiple times can select from the entire `data`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在随机数生成器 `rng` 上使用 `choice` 方法，根据刚才创建的概率从 `data` 中选择样本。对于这个选择，我们希望开启替换，因此多次调用该方法可以从整个
    `data` 中进行选择：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To select multiple items from `data`, we can also supply the `size` argument,
    which specifies the shape of the array to be selected. This plays the same role
    as the `shape` keyword argument with many of the other NumPy array creation routines.
    The argument given to `size` can be either an integer or a tuple of integers:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 `data` 中选择多个项目，我们还可以提供 `size` 参数，指定要选择的数组形状。这个参数和其他 NumPy 数组创建函数中的 `shape`
    关键字参数起到相同的作用。提供给 `size` 的参数可以是一个整数，也可以是一个整数元组：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see that there appear to be more 0s and 1s in the sampled data, for which
    we assigned probabilities of 0.3 and 0.2 respectively. Interestingly, only one
    2 appears, and yet we have two 12s, despite the probability of a 12 appearing
    being half that of a 2\. This is not a problem; a larger probability does not
    guarantee that individual numbers will appear in a sample, only that we’d expect
    to see roughly twice as many 2s as 12s in a large number of samples.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在采样数据中，0 和 1 的出现次数似乎更多，我们分别为其分配了 0.3 和 0.2 的概率。有趣的是，尽管 12 出现的概率是 2 的一半，结果我们只看到了一个
    2，而出现了两个 12。这并不是问题；较大的概率并不保证某个特定数字在样本中出现的次数，只有在大量样本中，我们才会预期大约看到两倍于 12 的 2。
- en: How it works...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `default_rng` routine creates a new `random` module. However, it is generally
    advisable to create the generator explicitly, using `default_rng`, or create a
    `Generator` instance yourself. Being more explicit in this way is more Pythonic
    and should lead to more reproducible results (in some sense).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`default_rng` 函数创建了一个新的 `random` 模块。然而，通常建议显式地使用 `default_rng` 创建生成器，或者自己创建一个
    `Generator` 实例。以这种方式更加明确，这也更符合 Python 的风格，并且应该能产生更可重复的结果（在某种程度上）。'
- en: A **seed** is a value that is passed to a random number generator in order to
    generate the values. The generator generates a sequence of numbers in a completely
    deterministic way based only on the seed. This means that two instances of the
    same PRNGs provided with the same seed will generate the same sequence of random
    numbers. If no seed is provided, the generators typically produce a seed that
    depends on the user’s system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**种子**是传递给随机数生成器的一个值，用于生成随机值。生成器基于种子以完全确定的方式生成数字序列。这意味着，如果提供相同的种子，两个相同的 PRNG
    实例将生成相同的随机数序列。如果没有提供种子，生成器通常会生成一个依赖于用户系统的种子。'
- en: The `Generator` class from NumPy is a wrapper around a low-level pseudorandom
    bit generator, which is where the random numbers are actually generated. In recent
    versions of NumPy, the default PRNG algorithm is the 128-bit *permuted congruential
    generator.* By contrast, Python’s built-in `random` module uses a Mersenne Twister
    PRNG. More information about the different options for PRNG algorithms is given
    in the *Changing the random number* *generator* recipe.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Generator` 类是 NumPy 中一个对低级伪随机比特生成器的封装，实际的随机数就是在这里生成的。在 NumPy 的最新版本中，默认的 PRNG
    算法是 128 位的*置换同余生成器*。相比之下，Python 内置的 `random` 模块使用的是梅森旋转算法 PRNG。有关不同 PRNG 算法选项的更多信息，请参阅*更改随机数*
    *生成器*的食谱。'
- en: The `choice` method on a `Generator` instance performs selections according
    to random numbers generated by the underlying `BitGenerator`. The optional `p`
    keyword argument specifies the probability associated with each item from the
    data provided. If this argument isn’t provided, then a *uniform probability* is
    assumed, where each item has an equal probability of being selected. The `replace`
    keyword argument specifies whether selections should be made with or without a
    replacement. We turned replacement on so that the same element can be selected
    more than once. The `choice` method uses the random numbers given by the generator
    to make the selections, which means that two PRNGs of the same type using the
    same seed will select the same items when using the `choice` method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Generator`实例上的`choice`方法根据底层`BitGenerator`生成的随机数进行选择。可选的`p`关键字参数指定了与提供的数据中每个项目相关的概率。如果没有提供此参数，则假定*均匀概率*，即每个项目被选中的概率相等。`replace`关键字参数指定选择是否应有放回或无放回。我们启用了放回选项，以便同一个元素可以被选中多次。`choice`方法使用生成器提供的随机数来进行选择，这意味着两个使用相同种子并且类型相同的伪随机数生成器（PRNG）在使用`choice`方法时会选中相同的项目。'
- en: This process of choosing points from a *bag* of possible choices is a good way
    to think about **discrete probability**. This is where we assign a certain weight
    – for example, 1 over the number of points – to each of a finite number of points,
    where the sum of these weights is 1\. Sampling is the process of choosing points
    at random according to the weights assigned by the probability (we can assign
    discrete probabilities to infinite sets too, but this is more complicated because
    of the constraint that the weights must sum to 1 and this is also impractical
    for computation).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从*袋子*中选择可能的点是理解**离散概率**的一个好方法。在这里，我们为每个有限数量的点分配一个特定的权重——例如，点数的倒数——这些权重的总和为1。采样是根据概率分配的权重随机选择点的过程（我们也可以为无限集合分配离散概率，但这会更复杂，因为权重必须总和为1，并且这在计算上也不实用）。
- en: There’s more...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `choice` method can also be used to create random samples of a given size
    by passing `replace=False` as an argument. This guarantees the selection of distinct
    items from the data, which is good for generating a random sample. This might
    be used, for example, to select users to test a new version of an interface from
    the whole group of users; most sample statistical techniques rely on randomly
    selected samples.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`choice`方法还可以通过传递`replace=False`参数来创建指定大小的随机样本。这可以确保从数据中选择不同的项目，这对于生成随机样本非常有用。例如，可能会用它来从整个用户组中选择用户来测试新版本的界面；大多数样本统计技术依赖于随机选择的样本。'
- en: Generating random data
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成随机数据
- en: Many tasks involve generating large quantities of random numbers, which, in
    their most basic form, are either integers or floating-point numbers (double-precision)
    lying within the range ![](img/Formula_04_003.png). Ideally, these numbers should
    be selected uniformly, so that if we draw a large number of these numbers, they
    are distributed roughly evenly across the range ![](img/Formula_04_004.png).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 许多任务涉及生成大量的随机数，这些随机数在最基本的形式下，可能是整数或浮动精度（双精度）的浮点数，范围在 ![](img/Formula_04_003.png)
    之间。理想情况下，这些数字应该均匀选择，这样如果我们绘制大量这些数字，它们将在范围 ![](img/Formula_04_004.png) 内大致均匀分布。
- en: In this recipe, we will see how to generate large quantities of random integers
    and floating-point numbers using NumPy, and show the distribution of these numbers
    using a histogram.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将展示如何使用NumPy生成大量随机整数和浮点数，并通过直方图展示这些数字的分布。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we start, we need to import the `default_rng` routine from the NumPy
    `random` module and create an instance of the default random number generator
    to use in the recipe:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要从NumPy的`random`模块导入`default_rng`方法，并创建一个默认的随机数生成器实例来在食谱中使用：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have discussed this process in the *Selecting items at* *random* recipe.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*随机选择项目*食谱中已经讨论过这个过程。
- en: We also import the Matplotlib `pyplot` module under the `plt` alias.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过`plt`别名导入了Matplotlib的`pyplot`模块。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to generate uniform random data and plot a histogram
    to understand its distribution:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以生成均匀的随机数据并绘制直方图以理解其分布：
- en: 'To generate random floating-point numbers between 0 and 1, including 0 but
    not 1, we use the `random` method on the `rng` object:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要生成介于0和1之间的随机浮点数（包括0但不包括1），我们使用`rng`对象上的`random`方法：
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To generate random integers, we use the `integers` method on the `rng` object.
    This will return integers in the specified range:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要生成随机整数，我们使用 `rng` 对象上的 `integers` 方法。这样会返回指定范围内的整数：
- en: '[PRE18]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To examine the distribution of the random floating-point numbers, we first
    need to generate a large array of random numbers, just as we did in *step 1*.
    While this is not strictly necessary, a larger sample will be able to show the
    distribution more clearly. We generate these numbers as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查随机浮点数的分布，我们首先需要生成一个大数组的随机数，正如我们在*步骤 1*中所做的那样。虽然这并不是严格必要的，但较大的样本能更清楚地显示分布。我们按以下方式生成这些数字：
- en: '[PRE20]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To show the distribution of the numbers we have generated, we plot a *histogram*
    of the data:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了显示我们生成的数字的分布，我们绘制了数据的*直方图*：
- en: '[PRE21]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The resulting plot is shown in *Figure 4**.1*. As we can see, the data is roughly
    evenly distributed across the whole range:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的图形如*图 4.1*所示。正如我们所看到的，数据在整个范围内大致均匀分布：
- en: '![Figure 4.1 – Histogram of randomly generated random numbers between 0 and
    1'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 随机生成的介于 0 和 1 之间的随机数的直方图](img/4.2.jpg)'
- en: '](img/4.1.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/4.2.jpg)'
- en: Figure 4.1 – Histogram of randomly generated random numbers between 0 and 1
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 随机生成的介于 0 和 1 之间的随机数的直方图
- en: 'As the number of sampled points increases, we would expect these bars to “even
    out” and look more and more like the flat line that we expect from a uniform distribution.
    Compare this to the same histogram with 10,000 random points in *Figure* *4**.2*
    here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随着采样点数量的增加，我们预计这些条形图会“平整”并越来越像我们期望的均匀分布的平线。可以将其与*图 4.2*中的 10,000 个随机点的直方图进行比较：
- en: '![Figure 4.2 – Histogram of 10,000 uniformly distributed random numbers'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – 10,000 个均匀分布的随机数的直方图](img/4.2.jpg)'
- en: '](img/4.2.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/4.1.jpg)'
- en: Figure 4.2 – Histogram of 10,000 uniformly distributed random numbers
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 10,000 个均匀分布的随机数的直方图
- en: We can see here that, although not totally flat, the distribution is much more
    even across the whole range.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，尽管分布并不是完全平坦的，但在整个范围内分布更加均匀。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Generator` interface provides three simple methods for generating basic
    random numbers, not including the `choice` method that we discussed in the *Selecting
    items at random* recipe. In addition to the `random` method for generating random
    floating-point numbers and the `integers` method for generating random integers,
    there is also a `bytes` method for generating raw random bytes. Each of these
    methods calls a relevant method on the underlying `BitGenerator` instance. Each
    of these methods also enables the data type of the generated numbers to be changed,
    for example, from double- to single-precision floating-point numbers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Generator` 接口提供了三个简单的方法来生成基本的随机数，但不包括我们在*随机选择项目*一节中讨论的 `choice` 方法。除了用于生成随机浮点数的
    `random` 方法和用于生成随机整数的 `integers` 方法外，还有一个用于生成原始随机字节的 `bytes` 方法。这些方法都会调用底层 `BitGenerator`
    实例的相关方法。每个方法还可以改变生成的数字的数据类型，例如，从双精度浮点数变为单精度浮点数。'
- en: There’s more...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `integers` method on the `Generator` class combines the functionality of
    the `randint` and `random_integers` methods on the old `RandomState` interface
    through the addition of the `endpoint` optional argument (in the old interface,
    the `randint` method excluded the upper endpoint, whereas the `random_integers`
    method included the upper endpoint). All of the random data generating methods
    on `Generator` allow the data type of the data they generate to be customized,
    which was not possible using the old interface (this interface was introduced
    in NumPy 1.17).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Generator` 类上的 `integers` 方法通过添加 `endpoint` 可选参数，结合了旧版 `RandomState` 接口中的
    `randint` 和 `random_integers` 方法的功能（在旧版接口中，`randint` 方法排除了上限，而 `random_integers`
    方法包括了上限）。`Generator` 上的所有随机数据生成方法都允许定制生成数据的数据类型，这在旧接口中是无法做到的（该接口在 NumPy 1.17 中引入）。'
- en: In *Figure 4**.1*, we can see that the histogram of the data that we generated
    is approximately uniform over the range ![](img/Formula_04_005.png). That is,
    all of the bars are approximately level (they are not completely level due to
    the random nature of the data). This is what we expect from uniformly distributed
    random numbers, such as those generated by the `random` method. We will explain
    distributions of random numbers in greater detail in the *Generating normally
    distributed random numbers* recipe.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4.1*中，我们可以看到我们生成的数据的直方图在范围内大致均匀分布 ![](img/Formula_04_005.png)。也就是说，所有的条形图大致平齐（由于数据的随机性质，它们不会完全平齐）。这是我们期望的均匀分布随机数的特征，比如通过`random`方法生成的随机数。我们将在*生成正态分布随机数*的食谱中更详细地解释随机数的分布。
- en: Changing the random number generator
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更换随机数生成器
- en: The `random` module in NumPy provides several alternatives to the default PRNG,
    which uses a 128-bit permutation congruential generator. While this is a good
    general-purpose random number generator, it might not be sufficient for your particular
    needs. For example, this algorithm is very different from the one used in Python’s
    internal random number generator. We will follow the guidelines for best practice
    set out in the NumPy documentation for running repeatable but suitably random
    simulations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy中的`random`模块提供了多个备用的伪随机数生成器，它们的默认PRNG使用128位置换同余生成器。虽然这是一个很好的通用随机数生成器，但它可能不足以满足你的特定需求。例如，这种算法与Python内部随机数生成器使用的算法差异很大。我们将遵循NumPy文档中设定的最佳实践指南，进行可重复但适当随机的仿真运行。
- en: In this recipe, we will show you how to change to an alternative PRNG and how
    to use seeds effectively in your programs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将向你展示如何切换到备用的伪随机数生成器（PRNG），以及如何在程序中有效地使用种子。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As usual, we import NumPy under the `np` alias. Since we will be using multiple
    items from the `random` package, we import that module from NumPy, too, using
    the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们通过`np`别名导入NumPy。由于我们将使用`random`包中的多个项目，我们也通过以下代码从NumPy导入该模块：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You will need to select one of the alternative random number generators that
    are provided by NumPy (or define your own; refer to the *There’s more...* section
    in this recipe). For this recipe, we will use the `MT19937` random number generator,
    which uses a Mersenne Twister-based algorithm like the one used in Python’s internal
    random number generator.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要选择NumPy提供的一个备用随机数生成器（或者定义你自己的；请参阅本食谱中的*还有更多...*部分）。在这个食谱中，我们将使用`MT19937`随机数生成器，它使用基于梅森旋转算法的生成器，类似于Python内部的随机数生成器所使用的算法。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps show how to generate seeds and different random number
    generators in a reproducible way:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何以可重复的方式生成种子和不同的随机数生成器：
- en: 'We will generate a `SeedSequence` object that can reproducibly generate new
    seeds from a given source of entropy. We can either provide our own entropy as
    an integer, very much like how we provide the seed for `default_rng`, or we can
    let Python gather entropy from the operating system. We will pick the latter method
    here to demonstrate its use. For this, we do not provide any additional arguments
    to create the `SeedSequence` object:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将生成一个`SeedSequence`对象，该对象可以从给定的熵源可重复地生成新的种子。我们可以像提供`default_rng`的种子一样，提供我们自己的整数作为熵，或者我们也可以让Python从操作系统收集熵。这里我们选择后一种方法来演示它的使用。为此，我们在创建`SeedSequence`对象时不提供任何额外的参数：
- en: '[PRE27]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we have the means to generate the seeds for random number generators
    for the rest of the session, we log the entropy next so that we can reproduce
    this session later if necessary. The following is an example of what the entropy
    should look like; your results will inevitably differ somewhat:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了为整个会话生成随机数生成器种子的手段，接下来记录熵，以便以后在必要时能够重现这个会话。以下是熵的示例；你的结果可能会有所不同：
- en: '[PRE28]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can create the underlying `BitGenerator` instance that will provide
    the random numbers for the wrapping `Generator` object:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建底层的`BitGenerator`实例，它将为包装的`Generator`对象提供随机数：
- en: '[PRE30]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we create the wrapping `Generator` object around this `BitGenerator`
    instance to create a usable random number generator:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们围绕这个`BitGenerator`实例创建一个包装的`Generator`对象，从而生成一个可用的随机数生成器：
- en: '[PRE31]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once created, you can use this random number generator as we have seen in any
    of the previous recipes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，你就可以像我们在之前的食谱中看到的那样使用这个随机数生成器。
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As mentioned in the *Selecting items at random* recipe, the `Generator` class
    is a wrapper around an underlying `BitGenerator` that implements a given pseudorandom
    number algorithm. NumPy provides several implementations of pseudorandom number
    algorithms through the various subclasses of the `BitGenerator` class: `PCG64`
    (default); `MT19937` (as seen in this recipe); `Philox`; and `SFC64`. These bit
    generators are implemented in Cython.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 *随机选择项* 食谱中提到的，`Generator` 类是一个封装底层 `BitGenerator` 的类，后者实现了给定的伪随机数算法。NumPy
    通过 `BitGenerator` 类的各种子类提供了几种伪随机数算法的实现：`PCG64`（默认）；`MT19937`（如本食谱所示）；`Philox`；和
    `SFC64`。这些位生成器是在 Cython 中实现的。
- en: The `PCG64` generator should provide high-performance random number generation
    with good statistical quality (this might not be the case on 32-bit systems).
    The `MT19937` generator is slower than more modern PRNGs and does not produce
    random numbers with good statistical properties. However, this is the random number
    generator algorithm that is used by the Python Standard Library `random` module.
    The `Philox` generator is relatively slow but produces random numbers of very
    high quality while the `SFC64` generator is fast and of reasonably good quality,
    but doesn’t have as good statistical properties as other generators.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`PCG64` 生成器应提供高性能的随机数生成，并且具有良好的统计质量（在 32 位系统上可能不是这样）。`MT19937` 生成器比更现代的伪随机数生成器要慢，并且生成的随机数不具有良好的统计属性。然而，这是
    Python 标准库 `random` 模块使用的随机数生成算法。`Philox` 生成器相对较慢，但生成的随机数质量非常高，而 `SFC64` 生成器速度较快，质量也相对较好，但其统计属性不如其他生成器。'
- en: The `SeedSequence` object created in this recipe is a means to create seeds
    for random number generators in an independent and reproducible manner. In particular,
    this is useful if you need to create independent random number generators for
    several parallel processes, but still need to be able to reconstruct each session
    later to debug or inspect results. The entropy stored on this object is a 128-bit
    integer that was gathered from the operating system and serves as a source of
    random seeds.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中创建的 `SeedSequence` 对象是一种以独立且可重复的方式为随机数生成器创建种子的方法。特别是，如果你需要为多个并行进程创建独立的随机数生成器，但仍需要能够在稍后重建每个会话以调试或检查结果时，这非常有用。该对象上存储的熵是一个
    128 位整数，来自操作系统，并作为随机种子的来源。
- en: The `SeedSequence` object allows us to create a separate random number generator
    for each independent process or thread, which eliminates any data race problems
    that might make results unpredictable. It also generates seed values that are
    very different from one another, which can help avoid problems with some PRNGs
    (such as `MT19937`, which can produce very similar streams with two similar 32-bit
    integer seed values). Obviously, having two independent random number generators
    producing the same or very similar values will be problematic when we are depending
    on the independence of these values.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`SeedSequence` 对象允许我们为每个独立的进程或线程创建一个独立的随机数生成器，从而消除可能导致结果不可预测的数据竞争问题。它还生成彼此非常不同的种子值，这有助于避免一些伪随机数生成器（例如
    `MT19937`，它可能会使用两个相似的 32 位整数种子值生成非常相似的流）的问题。显然，当我们依赖这些值的独立性时，拥有两个生成相同或非常相似值的独立随机数生成器会导致问题。'
- en: There’s more...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `BitGenerator` class serves as a common interface for generators of raw
    random integers. The classes mentioned previously are those that are implemented
    in NumPy with the `BitGenerator` interface. You can also create your own `BitGenerator`
    subclasses, although this needs to be implemented in Cython.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitGenerator` 类作为生成原始随机整数的生成器的通用接口。前面提到的类是在 NumPy 中实现的，并采用 `BitGenerator`
    接口。你也可以创建自己的 `BitGenerator` 子类，尽管这需要在 Cython 中实现。'
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to the NumPy documentation at [https://numpy.org/devdocs/reference/random/extending.html#new-bit-generators](https://numpy.org/devdocs/reference/random/extending.html#new-bit-generators)
    for more information.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参考 NumPy 文档 [https://numpy.org/devdocs/reference/random/extending.html#new-bit-generators](https://numpy.org/devdocs/reference/random/extending.html#new-bit-generators)。
- en: Generating normally distributed random numbers
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成正态分布的随机数
- en: In the *Generating random data* recipe, we generated random floating-point numbers
    following a uniform distribution between 0 and 1, but not including 1\. However,
    in most cases where we require random data, we need to follow one of several different
    **distributions** instead. Roughly speaking, a **distribution function** is a
    function, ![](img/Formula_04_006.png), that describes the probability that a random
    variable has a value that is below ![](img/Formula_04_007.png). In practical terms,
    the distribution describes the spread of the random data over a range. In particular,
    if we create a histogram of data that follows a particular distribution, then
    it should roughly resemble the graph of the distribution function. This is best
    seen by example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*生成随机数据*的示例中，我们生成了遵循均匀分布（在0和1之间，但不包括1）的随机浮点数。然而，在大多数需要随机数据的情况下，我们需要遵循几种不同的**分布**之一。粗略来说，**分布函数**是一个函数，![](img/Formula_04_006.png)，它描述了一个随机变量的值小于![](img/Formula_04_007.png)的概率。从实际应用上讲，分布描述了随机数据在一个范围内的分布情况。特别地，如果我们绘制一个遵循特定分布的数据的直方图，那么它应该大致与该分布函数的图形相似。通过实例来看，这一点最为明显。
- en: One of the most common distributions is **normal distribution**, which appears
    frequently in statistics and forms the basis for many statistical methods that
    we will see in [*Chapter 6*](B19085_06.xhtml#_idTextAnchor226), *Working with
    Data and Statistics*. In this recipe, we will demonstrate how to generate data
    following normal distribution, and plot a histogram of this data to see the shape
    of the distribution.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的分布之一是**正态分布**，它在统计学中经常出现，并且是我们在[*第六章*](B19085_06.xhtml#_idTextAnchor226)《与数据和统计一起工作》中的许多统计方法的基础。在这个示例中，我们将展示如何生成遵循正态分布的数据，并绘制该数据的直方图，以查看分布的形态。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As in the *Generating random data* recipe, we import the `default_rng` routine
    from the NumPy `random` module and create a `Generator` instance with a seeded
    generator for demonstration purposes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与*生成随机数据*示例一样，我们从NumPy的`random`模块中导入`default_rng`函数，并创建一个带有种子生成器的`Generator`实例用于演示：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As usual, we import the Matplotlib `pyplot` module as `plt`, and NumPy as `np`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们导入Matplotlib的`pyplot`模块为`plt`，并导入NumPy为`np`。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In the following steps, we generate random data that follows a normal distribution:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们生成遵循正态分布的随机数据：
- en: 'We use the `normal` method on our `Generator` instance to generate the random
    data according to the `normal` distribution. The normal distribution has two *parameters*:
    *location* and *scale*. There is also an optional `size` argument that specifies
    the shape of the generated data (see the *Generating random data* recipe for more
    information on the `size` argument). We generate an array of 10,000 values to
    get a reasonably sized sample:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Generator`实例上的`normal`方法生成符合`normal`分布的随机数据。正态分布有两个*参数*：*位置*和*尺度*。还有一个可选的`size`参数，用于指定生成数据的形状（有关`size`参数的更多信息，请参阅*生成随机数据*示例）。我们生成一个包含10,000个值的数组，以获得一个合理大小的样本：
- en: '[PRE33]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we plot a histogram of this data. We have increased the number of `bins`
    in the histogram. This isn’t strictly necessary, as the default number (10) is
    perfectly adequate, but it does show the distribution slightly better:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们绘制这个数据的直方图。我们增加了直方图中的`bins`数量。这并非严格必要，因为默认数量（10）已经足够，但它确实能稍微更好地展示数据分布：
- en: '[PRE36]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we create a function that will generate the expected density for a range
    of values. This is given by multiplying the probability density function for normal
    distribution by the number of samples (10,000):'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个函数，生成一系列值的预期密度。这是通过将正态分布的概率密度函数与样本数量（10,000）相乘来实现的：
- en: '[PRE41]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we plot our expected distribution over the histogram of our data:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将预期分布与数据的直方图一起绘制：
- en: '[PRE44]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The result is shown in *Figure 4**.3*. We can see here that the distribution
    of our sampled data closely follows the expected distribution from a normal distribution
    curve:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如*图 4.3*所示。我们可以看到，样本数据的分布与正态分布曲线预期的分布非常接近：
- en: '![Figure 4.3 – Histogram of data drawn from a normal distribution, with the
    expected density overlaid'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – 从正态分布中抽取的数据的直方图，叠加了预期密度'
- en: '](img/4.3.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/4.3.jpg)'
- en: Figure 4.3 – Histogram of data drawn from a normal distribution, with the expected
    density overlaid
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 从正态分布中抽取的数据的直方图，叠加了预期密度
- en: Again, if we took larger and larger samples, we’d expect that the roughness
    of the sample would begin to smooth out and approach the expected density (shown
    as the dashed line in *Figure 4**.3*).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果我们取更大更大的样本，我们会预期样本的粗糙度会开始平滑并接近预期的密度（如*图 4.3*中的虚线所示）。
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Normal distribution has a probability density function defined by the following
    formula:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布的概率密度函数由以下公式定义：
- en: '![](img/Formula_04_008.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_008.png)'
- en: 'This is related to the normal distribution function, ![](img/Formula_04_009.png),
    according to the following formula:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这与正态分布函数相关，![](img/Formula_04_009.png)，根据以下公式：
- en: '![](img/Formula_04_010.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_010.png)'
- en: This probability density function peaks at the mean value, which coincides with
    the location parameter, and the width of the *bell shape* is determined by the
    scale parameter. We can see in *Figure 4**.3* that the histogram of the data generated
    by the `normal` method on the `Generator` object fits the expected distribution
    very closely.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概率密度函数在均值处达到峰值，该均值与位置参数一致，而*钟形曲线*的宽度由尺度参数决定。我们可以在*图 4.3*中看到，`Generator`对象上使用`normal`方法生成的数据的直方图与预期分布非常吻合。
- en: The `Generator` class uses a 256-step ziggurat method to generate normally distributed
    random data, which is fast compared to the Box-Muller or inverse CDF implementations
    that are also available in NumPy.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Generator`类使用256步锯齿法生成正态分布的随机数据，这比NumPy中其他可用的Box-Muller或逆CDF实现要快。'
- en: There’s more...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The normal distribution is one example of a *continuous* probability distribution,
    in that it is defined for real numbers and the distribution function is defined
    by an integral (rather than a sum). An interesting feature of normal distribution
    (and other continuous probability distributions) is that the probability of selecting
    any given real number is 0\. This is reasonable because it only makes sense to
    measure the probability that a value selected in this distribution lies within
    a given range.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布是*连续*概率分布的一个例子，因为它是为实数定义的，且分布函数由积分（而非求和）定义。正态分布（以及其他连续概率分布）的一个有趣特性是，选择任何给定实数的概率为0。这是合理的，因为只有在测量一个值是否位于给定范围内时，才有意义去计算这个分布中选中该值的概率。
- en: Normal distribution is important in statistics, mostly due to the *central limit
    theorem*. Roughly speaking, this theorem states that sums of **Independent and
    Identically Distributed** (**IID**) random variables, with a common mean and variance,
    are eventually like normal distribution with a common mean and variance. This
    holds, regardless of the actual distribution of these random variables. This allows
    us to use statistical tests based on normal distribution in many cases even if
    the actual distribution of the variables is not necessarily normal (we do, however,
    need to be extremely cautious when appealing to the central limit theorem).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布在统计学中非常重要，主要得益于*中心极限定理*。简而言之，这个定理指出，具有共同均值和方差的**独立同分布**（**IID**）随机变量的和，最终将趋近于一个具有共同均值和方差的正态分布。无论这些随机变量的实际分布如何，这一结论始终成立。这使得我们在许多情况下，即使变量的实际分布不一定是正态分布，仍然可以使用基于正态分布的统计检验（但我们在引用中心极限定理时需要非常谨慎）。
- en: 'There are many other continuous probability distributions aside from normal
    distribution. We have already encountered *uniform* distribution over a range
    of 0 to 1\. More generally, uniform distribution over the range ![](img/Formula_04_011.png)
    has a probability density function given by the following equation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正态分布之外，还有许多其他连续概率分布。我们已经遇到过0到1范围内的*均匀*分布。更一般地，均匀分布在范围![](img/Formula_04_011.png)内，其概率密度函数由以下方程给出：
- en: '![](img/Formula_04_012.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_012.png)'
- en: Other common examples of continuous probability density functions include *exponential*
    distribution, *beta* distribution, and *gamma* distribution. Each of these distributions
    has a corresponding method on the `Generator` class that generates random data
    from that distribution. These are typically named according to the name of the
    distribution, all in lowercase letters, so for the aforementioned distributions,
    the corresponding methods are `exponential`, `beta`, and `gamma`. These distributions
    each have one or more *parameters*, such as location and scale for normal distribution,
    that determine the final shape of the distribution. You may need to consult the
    NumPy documentation ([https://numpy.org/doc/1.18/reference/random/generator.html#numpy.random.Generator](https://numpy.org/doc/1.18/reference/random/generator.html#numpy.random.Generator))
    or other sources to see what parameters are required for each distribution. The
    NumPy documentation also lists the probability distributions from which random
    data can be generated.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见的连续概率密度函数包括*指数*分布、*贝塔*分布和*伽马*分布。每种分布在`Generator`类中都有对应的方法，用来从该分布生成随机数据。这些方法通常根据分布的名称命名，全部使用小写字母，因此对于上述分布，对应的方法是`exponential`、`beta`和`gamma`。这些分布每个都有一个或多个*参数*，例如正态分布的地点和尺度参数，它们决定了分布的最终形状。你可能需要查阅NumPy文档（[https://numpy.org/doc/1.18/reference/random/generator.html#numpy.random.Generator](https://numpy.org/doc/1.18/reference/random/generator.html#numpy.random.Generator)）或其他资料，以了解每种分布所需的参数。NumPy文档还列出了可以生成随机数据的概率分布。
- en: Working with random processes
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理随机过程
- en: 'In this recipe, we will examine a simple example of a random process that models
    the number of bus arrivals at a stop over time. This process is called a **Poisson
    process**. A Poisson process, ![](img/Formula_04_013.png), has a single parameter,
    ![](img/Formula_04_014.png), which is usually called the *intensity* or *rate*,
    and the probability that ![](img/Formula_04_015.png) takes the value ![](img/Formula_04_016.png)
    at a given time ![](img/Formula_04_017.png) is given by the following formula:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将探讨一个简单的随机过程示例，它模拟了公交车到达一个站点的数量随时间的变化。这个过程被称为**泊松过程**。泊松过程，![](img/Formula_04_013.png)，有一个单一的参数，![](img/Formula_04_014.png)，通常被称为*强度*或*速率*，且在给定时间![](img/Formula_04_017.png)，![](img/Formula_04_015.png)取值![](img/Formula_04_016.png)的概率由以下公式给出：
- en: '![](img/Formula_04_018.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_018.png)'
- en: 'This equation describes the probability that ![](img/Formula_04_016.png) buses
    have arrived by time ![](img/Formula_04_020.png). Mathematically, this equation
    means that ![](img/Formula_04_021.png) has a Poisson distribution with the parameter
    ![](img/Formula_04_022.png). There is, however, an easy way to construct a Poisson
    process by taking sums of inter-arrival times that follow an exponential distribution.
    For instance, let ![](img/Formula_04_023.png) be the time between the (![](img/Formula_04_024.png))-st
    arrival and the ![](img/Formula_04_025.png)-th arrival, which are exponentially
    distributed with parameter ![](img/Formula_04_026.png). Now, we take the following
    equation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程描述了到时间![](img/Formula_04_020.png)为止，![](img/Formula_04_016.png)辆公交车已经到达的概率。从数学上讲，这个方程意味着![](img/Formula_04_021.png)服从参数为![](img/Formula_04_022.png)的泊松分布。然而，有一种简单的方法可以通过对服从指数分布的到达间隔时间求和来构建泊松过程。例如，设![](img/Formula_04_023.png)为第(![](img/Formula_04_024.png))-次到达和第![](img/Formula_04_025.png)-次到达之间的时间，这些时间服从参数为![](img/Formula_04_026.png)的指数分布。现在，我们得到以下方程：
- en: '![](img/Formula_04_027.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_027.png)'
- en: Here, the number ![](img/Formula_04_028.png) is the maximum ![](img/Formula_04_029.png)
    such that ![](img/Formula_04_030.png). This is the construction that we will work
    through in this recipe. We will also estimate the intensity of the process by
    taking the mean of the inter-arrival times.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，数字![](img/Formula_04_028.png)是最大值![](img/Formula_04_029.png)，使得![](img/Formula_04_030.png)。这是我们将在这个教程中逐步构建的内容。我们还将通过取到达间隔时间的均值来估计这个过程的强度。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we start, we import the `default_rng` routine from NumPy’s `random`
    module and create a new random number generator with a seed for the purpose of
    demonstration:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们从NumPy的`random`模块中导入`default_rng`函数，并创建一个新的随机数生成器，并为演示目的设置种子：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In addition to the random number generator, we also import NumPy as `np` and
    the Matplotlib `pyplot` module as `plt`. We also need to have the SciPy package
    available.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了随机数生成器外，我们还导入了NumPy库作为`np`，并将Matplotlib的`pyplot`模块导入为`plt`。我们还需要确保安装了SciPy库。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following steps show how to model the arrival of buses using a Poisson
    process:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何使用泊松过程模拟公交车的到达：
- en: 'Our first task is to create the sample inter-arrival times by sampling data
    from an exponential distribution. The `exponential` method on the NumPy `Generator`
    class requires a `scale` parameter, which is ![](img/Formula_04_031.png), where
    ![](img/Formula_04_032.png) is the rate. We choose a rate of 4, and create 50
    sample inter-arrival times:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一项任务是通过从指数分布中采样数据来创建样本到达时间间隔。NumPy `Generator`类中的`exponential`方法需要一个`scale`参数，公式为
    ![](img/Formula_04_031.png)，其中 ![](img/Formula_04_032.png) 是速率。我们选择速率为4，并创建50个样本到达时间间隔：
- en: '[PRE48]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we compute the actual arrival times by using the `accumulate` method
    of the NumPy `add` universal function. We also create an array containing the
    integers 0 to 49, representing the number of arrivals at each point:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用NumPy `add`通用函数的`accumulate`方法计算实际到达时间。我们还创建了一个包含整数0到49的数组，表示每个时刻的到达次数：
- en: '[PRE51]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we plot the arrivals over time using the `step` plotting method:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`step`绘图方法绘制到达次数随时间变化的图：
- en: '[PRE53]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The result is shown in *Figure 4**.4*, where the length of each horizontal
    line represents the inter-arrival times:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如*图4.4*所示，在图中每条水平线的长度表示到达时间间隔：
- en: '![Figure 4.4 – Arrivals over time where inter-arrival times are exponentially
    distributed'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – 随时间变化的到达次数，且时间间隔服从指数分布'
- en: '](img/4.4.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/4.4.jpg)'
- en: Figure 4.4 – Arrivals over time where inter-arrival times are exponentially
    distributed
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 随时间变化的到达次数，且时间间隔服从指数分布
- en: 'Next, we define a function that will evaluate the probability distribution
    of the counts at a time, which we will take as `1` here. This uses the formula
    for the Poisson distribution that we gave in the introduction to this recipe:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个函数，用于评估单位时间内的计数概率分布，这里我们取`1`作为单位时间。这个函数使用了我们在本配方介绍中给出的泊松分布公式：
- en: '[PRE58]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, we plot the probability distribution over the count per unit of time,
    since we chose `time=1` in the previous step. We will add to this plot later:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们绘制单位时间内的计数概率分布，因为在之前的步骤中我们选择了`time=1`。我们将在后续的步骤中继续完善这个图：
- en: '[PRE61]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, we move on to estimate the rate from our sample data. We do this by computing
    the mean of the inter-arrival times, which, for exponential distribution, is an
    estimator of the scale ![](img/Formula_04_033.png):'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们继续通过样本数据估计速率。我们通过计算到达时间间隔的均值来实现这一点，对于指数分布来说，均值是尺度参数 ![](img/Formula_04_033.png)
    的估计值：
- en: '[PRE66]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Finally, we plot the probability distribution with this estimated rate for the
    counts per unit of time. We plot this on top of the true probability distribution
    that we produced in *step 5:*
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们绘制基于这个估计速率的单位时间内计数的概率分布。我们将其绘制在我们在*步骤5*中得到的真实概率分布之上：
- en: '[PRE68]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The resulting plot is given in *Figure 4**.5*, where we can see that, apart
    from a small discrepancy, the estimated distribution is very close to the true
    distribution:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图如*图4.5*所示，在图中我们可以看到，除了一个小的偏差，估计的分布与真实分布非常接近：
- en: '![Figure 4.5 – Distribution of the number of arrivals per time unit, estimated
    and true'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 – 每单位时间到达次数的分布，估计值与真实值'
- en: '](img/4.5.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/4.5.jpg)'
- en: Figure 4.5 – Distribution of the number of arrivals per time unit, estimated
    and true
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 每单位时间到达次数的分布，估计值与真实值
- en: The distribution shown in *Figure 4**.5* follows the Poisson distribution as
    described in the introduction to this recipe. You can see that moderate numbers
    of arrivals per unit of time are more likely than large numbers. The most likely
    counts are determined by the rate parameter ![](img/Formula_04_034.png), which
    is 4.0 in this example.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.5*中展示的分布遵循了本配方介绍中描述的泊松分布。你可以看到，单位时间内的适中到达次数比大量到达次数更为常见。最可能的到达次数由速率参数 ![](img/Formula_04_034.png)
    确定，在这个例子中速率为4.0。'
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Random processes exist everywhere. Roughly speaking, a random process is a system
    of related random variables, usually indexed with respect to time ![](img/Formula_04_035.png)
    for a continuous random process, or by natural numbers ![](img/Formula_04_036.png)
    for a discrete random process. Many (discrete) random processes satisfy the **Markov
    property**, which makes them a **Markov chain**. The Markov property is the statement
    that the process is *memoryless*, in that only the current value is important
    for the probabilities of the next value.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 随机过程无处不在。大致来说，随机过程是相关随机变量的系统，通常根据时间对连续随机过程进行索引 ![](img/Formula_04_035.png)，或根据自然数对离散随机过程进行索引
    ![](img/Formula_04_036.png)。许多（离散）随机过程满足**马尔可夫性质**，这使它们成为**马尔可夫链**。马尔可夫性质的表述是，过程是*无记忆的*，即只有当前值对于下一个值的概率是重要的。
- en: A Poisson process is a counting process that counts the number of events (bus
    arrivals) that occur in an amount of time if the events are randomly spaced (in
    time) with an exponential distribution with a fixed parameter. We constructed
    the Poisson process by sampling inter-arrival times from exponential distribution,
    following the construction we described in the introduction. However, it turns
    out that this fact (that the inter-arrival times are exponentially distributed)
    is a property of all Poisson processes when they are given their formal definition
    in terms of probabilities.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 泊松过程是一种计数过程，用于计算在一段时间内发生的事件（例如公交车到达）的数量，前提是事件在时间上是随机分布的，并且具有固定参数的指数分布。我们通过从指数分布中抽样到达间隔时间来构建泊松过程，遵循我们在介绍中描述的构建方法。然而，事实证明，这一特性（即到达间隔时间是指数分布的）是所有泊松过程的属性，当它们按照概率的正式定义给出时。
- en: In this recipe, we sampled 50 points from an exponential distribution with a
    given `rate` parameter. We had to do a small conversion because the NumPy `Generator`
    method for sampling from an exponential distribution uses a related `scale` parameter,
    which is `1` over the `rate` parameter. Once we have these points, we create an
    array that contains cumulative sums of these exponentially distributed numbers.
    This creates our arrival times. The actual Poisson process is the one displayed
    in *Figure 4**.4* and is a combination of the arrival times with the corresponding
    number of events that have occurred at that time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们从具有给定`rate`参数的指数分布中抽取了50个点。我们必须做一个小的转换，因为 NumPy 的`Generator`方法用于从指数分布中抽样时，使用的是相关的`scale`参数，它是`1`除以`rate`参数。拿到这些点后，我们创建一个包含这些指数分布数值的累积和的数组。这就生成了我们的到达时间。实际的泊松过程是*图
    4**.4*中显示的过程，它是到达时间与在该时间点发生的事件数量的组合。
- en: The mean (expected value) of an exponential distribution coincides with the
    scale parameter, so the mean of a sample drawn from an exponential distribution
    is one way to estimate the scale (`rate`) parameter. This estimate will not be
    perfect since our sample is relatively small. This is why there is a small discrepancy
    between the two plots in *Figure 4**.5*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 指数分布的均值（期望值）与尺度参数相同，因此从指数分布中抽取样本的均值是一种估计尺度（`rate`）参数的方法。这个估计不会是完美的，因为我们的样本相对较小。这就是为什么在*图
    4**.5*中的两幅图之间存在小的偏差。
- en: There’s more...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: There are many types of random processes describing a wide variety of real-world
    scenarios. In this recipe, we modeled arrival times using a Poisson process. A
    Poisson process is a continuous random process, meaning that it is parameterized
    by a continuous variable, ![](img/Formula_04_037.png), rather than a discrete
    variable, ![](img/Formula_04_038.png). Poisson processes are actually Markov chains,
    under a suitably generalized definition of a Markov chain, and also an example
    of a *renewal process*. A renewal process is a process that describes the number
    of events that occur within a period of time. The Poisson process described here
    is an example of a renewal process.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 随机过程有很多种类型，用于描述各种各样的现实场景。在这个方法中，我们使用泊松过程对到达时间进行了建模。泊松过程是一个连续随机过程，这意味着它是由一个连续变量
    ![](img/Formula_04_037.png) 参数化的，而不是由一个离散变量 ![](img/Formula_04_038.png) 参数化的。泊松过程实际上是马尔可夫链，按照对马尔可夫链的适当推广定义，也是一种*更新过程*的例子。更新过程是描述在一段时间内发生的事件数量的过程。这里描述的泊松过程就是更新过程的一个例子。
- en: 'Many Markov chains also satisfy some properties in addition to their defining
    Markov property. For example, a Markov chain is *homogeneous* if the following
    equality holds for all ![](img/Formula_04_029.png), ![](img/Formula_04_025.png),
    and ![](img/Formula_04_041.png) values:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 许多马尔可夫链除了满足其定义的马尔可夫性质外，还满足一些其他性质。例如，如果下列等式对所有![](img/Formula_04_029.png)、![](img/Formula_04_025.png)和![](img/Formula_04_041.png)值成立，则该马尔可夫链是*齐次的*：
- en: '![](img/Formula_04_042.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_042.png)'
- en: In simple terms, this means that the probabilities of moving from one state
    to another over a single step do not change as we increase the number of steps.
    This is extremely useful for examining the long-term behavior of a Markov chain.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这意味着随着我们增加步骤数，从一个状态到另一个状态的单步转移概率不会改变。这对于检查马尔可夫链的长期行为非常有用。
- en: 'It is very easy to construct simple examples of homogeneous Markov chains.
    Suppose that we have two states, ![](img/Formula_04_043.png) and ![](img/Formula_04_044.png).
    At any given step, we could be either at state ![](img/Formula_04_045.png) or
    state ![](img/Formula_04_044.png). We move between states according to a certain
    probability. For instance, let’s say that the probability of transitioning from
    state ![](img/Formula_04_047.png) to state ![](img/Formula_04_045.png) is 0.4
    and the probability of transitioning from ![](img/Formula_04_045.png) to ![](img/Formula_04_044.png)
    is 0.6\. Similarly, let’s say that the probability of transitioning from ![](img/Formula_04_044.png)
    to ![](img/Formula_04_052.png) is 0.2, and transitioning from ![](img/Formula_04_053.png)
    to ![](img/Formula_04_054.png) is 0.8\. Notice that both the probability of switching
    and the probability of staying the same sum 1 in both cases. We can represent
    the probability of transitioning from each state in matrix form given, in this
    case, with the following equation:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 构建简单的均匀马尔可夫链非常容易。假设我们有两个状态，![](img/Formula_04_043.png)和![](img/Formula_04_044.png)。在任何给定的步骤中，我们可以处于状态![](img/Formula_04_045.png)或状态![](img/Formula_04_044.png)之一。我们根据一定的概率在这些状态之间移动。例如，假设从状态![](img/Formula_04_047.png)到状态![](img/Formula_04_045.png)的转移概率为0.4，从状态![](img/Formula_04_045.png)到状态![](img/Formula_04_044.png)的转移概率为0.6。同样，假设从状态![](img/Formula_04_044.png)到状态![](img/Formula_04_052.png)的转移概率为0.2，从状态![](img/Formula_04_053.png)到状态![](img/Formula_04_054.png)的转移概率为0.8。请注意，在这两种情况下，转移的概率和保持相同状态的概率之和都为1。我们可以用矩阵形式表示从每个状态转移的概率，在这种情况下，使用以下方程：
- en: '![](img/Formula_04_055.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_055.png)'
- en: 'This matrix is called the *transition matrix*. The idea here is that the probability
    of being in a particular state after a step is given by multiplying the vector
    containing the probability of being in state ![](img/Formula_04_056.png) and ![](img/Formula_04_044.png)
    (position 0 and 1, respectively). For example, if we start in state ![](img/Formula_04_045.png),
    then the probability vector will contain a 1 at index 0 and 0 at index 1\. Then,
    the probability of being in state ![](img/Formula_04_056.png) after 1 step is
    given by 0.4, and the probability of being in state ![](img/Formula_04_044.png)
    is 0.6\. This is what we expect given the probabilities we outlined previously.
    However, we could also write this calculation using the matrix formula:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵叫做*转移矩阵*。这里的思路是，经过一步后处于特定状态的概率是通过将包含状态![](img/Formula_04_056.png)和![](img/Formula_04_044.png)（分别是位置0和1）的概率的向量相乘得到的。例如，如果我们从状态![](img/Formula_04_045.png)开始，则概率向量在索引0处为1，在索引1处为0。那么，经过一步后处于状态![](img/Formula_04_056.png)的概率为0.4，处于状态![](img/Formula_04_044.png)的概率为0.6。这是我们之前概述的概率所预期的结果。然而，我们也可以使用矩阵公式来写出这个计算：
- en: '![](img/Formula_04_061.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_061.png)'
- en: 'To get the probability of being in either state after two steps, we multiply
    the right-hand side vector again by the transition matrix, ![](img/Formula_04_062.png),
    to obtain the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取经过两步后处于任一状态的概率，我们再次将右侧向量与转移矩阵![](img/Formula_04_062.png)相乘，得到如下结果：
- en: '![](img/Formula_04_063.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_063.png)'
- en: We can continue this process *ad infinitum* to obtain a sequence of state vectors,
    which constitute our Markov chain. This construction can be applied, with more
    states if necessary, to model many simple, real-world problems.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个过程继续进行*无限次*，以获得一系列状态向量，这些向量构成了我们的马尔可夫链。如果需要，可以通过增加更多的状态来应用这一构建方法，用以建模许多简单的现实世界问题。
- en: Analyzing conversion rates with Bayesian techniques
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用贝叶斯技术分析转化率
- en: Bayesian probability allows us to systematically update our understanding (in
    a probabilistic sense) of a situation by considering data. In more technical language,
    we update the *prior* distribution (our current understanding) using data to obtain
    a *posterior* distribution. This is particularly useful, for example, when examining
    the proportion of users who go on to buy a product after viewing a website. We
    start with our prior belief distribution. For this, we will use the *beta* distribution,
    which models the probability of success given a number of observed successes (completed
    purchases) against failures (no purchases). For this recipe, we will assume that
    our prior belief is that we expect 25 successes from 100 views (75 fails). This
    means that our prior belief follows a beta (25, 75) distribution. Let’s say that
    we wish to calculate the probability that the true rate of success is at least
    33%.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 贝叶斯概率允许我们通过考虑数据系统地更新我们对情况的理解（从概率的角度）。用更技术化的语言来说，我们使用数据更新*先验*分布（我们的当前理解），以获得*后验*分布。例如，在研究用户浏览网站后购买产品的比例时，这非常有用。我们从先验信念分布开始。为此，我们将使用*beta*分布，它根据观察到的成功次数（完成购买）与失败次数（未购买）来模拟成功的概率。在这个示例中，我们假设我们的先验信念是我们期望在100次浏览中有25次成功（75次失败）。这意味着我们的先验信念遵循beta(25,
    75)分布。假设我们想计算真实成功率至少为33%的概率。
- en: Our method is roughly divided into three steps. First, we need to understand
    our prior belief for the conversion rate, which we have decided follows a beta
    (25, 75) distribution. We compute the probability that the conversion rate is
    at least 33% by integrating (numerically) the probability density function for
    the prior distribution from 0.33 to 1\. The next step is to apply Bayesian reasoning
    to update our prior belief with new information. Then, we can perform the same
    integration with the posterior (updated) belief to examine the probability that
    the conversion rate is at least 33% given this new information.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法大致分为三个步骤。首先，我们需要理解我们对转化率的先验信念，我们已经决定它遵循beta(25, 75)分布。通过对先验分布的概率密度函数从0.33到1进行数值积分，我们计算出转化率至少为33%的概率。接下来的步骤是应用贝叶斯推理，通过新的信息更新我们的先验信念。然后，我们可以对后验（更新后的）信念进行相同的积分，查看在此新信息下转化率至少为33%的概率。
- en: In this recipe, we will see how to use Bayesian techniques to update a prior
    belief based on new information for our hypothetical website.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将展示如何使用贝叶斯技术基于新信息更新我们假设网站的先验信念。
- en: Getting ready
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As usual, we will need the NumPy and Matplotlib packages imported as `np` and
    `plt`, respectively. We will also require the SciPy package, imported as `sp`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们需要导入NumPy和Matplotlib包，分别命名为`np`和`plt`。我们还需要导入SciPy包，命名为`sp`。
- en: How to do it...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps show how to estimate and update conversion rate estimations
    using Bayesian reasoning:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何使用贝叶斯推理估算和更新转化率估算：
- en: 'The first step is to set up the prior distribution. For this, we use the `beta`
    distribution object from the SciPy `stats` module, which has various methods for
    working with beta distribution. We import the `beta` distribution object from
    the `stats` module under a `beta_dist` alias and then create a convenience function
    for the probability density function:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是设置先验分布。为此，我们使用来自 SciPy `stats` 模块的`beta`分布对象，该对象提供了多种处理贝塔分布的方法。我们从`stats`模块导入`beta`分布对象，并将其命名为`beta_dist`，然后创建一个便捷函数，用于计算概率密度函数：
- en: '[PRE72]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Next, we need to compute the probability, under the prior belief distribution,
    that the success rate is at least 33%. To do this, we use the `quad` routine from
    the SciPy `integrate` module, which performs numerical integration of a function.
    We use this to integrate the probability density function for the beta distribution,
    imported in *step 1*, with our prior parameters. We print the probability according
    to our prior distribution to the console:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要计算在先验信念分布下，成功率至少为33%的概率。为此，我们使用SciPy `integrate`模块中的`quad`例程，该例程执行函数的数值积分。我们使用它来对先前步骤中导入的贝塔分布的概率密度函数进行积分，结合我们的先验参数。我们根据先验分布将概率打印到控制台：
- en: '[PRE74]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, suppose we have received some information about successes and failures
    over a new period of time. For example, we observed 122 successes and 257 failures
    over this period. We create new variables to reflect these values:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，假设我们收到了关于新时间段内成功和失败的信息。例如，在这段时间内，我们观察到122次成功和257次失败。我们创建新的变量来反映这些值：
- en: '[PRE81]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To obtain the parameter values for the posterior distribution with a beta distribution,
    we simply add the observed successes and failures to the `prior_alpha` and `prior_beta`
    parameters, respectively:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获得使用贝塔分布的后验分布的参数值，我们只需将观察到的成功次数和失败次数分别加到`prior_alpha`和`prior_beta`参数中：
- en: '[PRE83]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, we repeat our numerical integration to compute the probability that the
    success rate is now above 33% using the posterior distribution (with our new parameters
    computed earlier). Again, we print this probability to the terminal:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们重复数值积分，以计算使用后验分布（使用我们先前计算的参数）成功率现在是否超过33%的概率。我们再次将此概率输出到终端：
- en: '[PRE85]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We can see here that the new probability, given the updated posterior distribution,
    is 14% as opposed to the prior 4%. This is a significant difference, although
    we are still not confident that the conversion rate is above 33% given these values.
    Now, we plot the prior and posterior distribution to visualize this increase in
    probability. To start with, we create an array of values and evaluate our probability
    density function based on these values:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到，更新后的后验分布给出的新概率是14%，而先验分布给出的概率是4%。这是一个显著的差异，尽管根据这些值，我们仍然无法确信转化率超过33%。现在，我们将先验和后验分布绘制出来，以可视化这种概率的增加。首先，我们创建一个值的数组，并基于这些值评估我们的概率密度函数：
- en: '[PRE90]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Finally, we plot the two probability density functions computed in *step 6*
    onto a new plot:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将*第 6 步*中计算的两个概率密度函数绘制到新的图表上：
- en: '[PRE94]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The resulting plot is shown in *Figure 4**.6*, where we can see that the posterior
    distribution is much more narrow and centered to the right of the prior:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图如*图 4**.6*所示，我们可以看到后验分布比先验分布更加狭窄，并且集中在先验分布的右侧：
- en: '![Figure 4.6 – Prior and posterior distributions of a success rate following
    a beta distribution'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – 成功率的先验和后验分布，遵循贝塔分布'
- en: '](img/4.6.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/4.6.jpg)'
- en: Figure 4.6 – Prior and posterior distributions of a success rate following a
    beta distribution
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 成功率的先验和后验分布，遵循贝塔分布
- en: We can see that the posterior distribution peaks at around 0.3, but most of
    the mass of the distribution lies close to this peak.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，后验分布在约0.3处达到峰值，但分布的大部分质量都集中在这个峰值附近。
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Bayesian techniques work by taking a prior belief (probability distribution)
    and using *Bayes’ theorem* to combine the prior belief with the likelihood of
    our data given this prior belief to form a posterior (updated) belief. This is
    similar to how we might understand things in real life. For example, when you
    wake up on a given day, you might have the belief (from a forecast or otherwise)
    that there is a 40% chance of rain outside. Upon opening the blinds, you see that
    it is very cloudy outside, which might indicate that rain is more likely, so we
    update our belief according to this new data to say a 70% chance of rain.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 贝叶斯技术通过采取一个先验信念（概率分布），然后利用*贝叶斯定理*将先验信念与在该先验信念下我们的数据的可能性结合起来，从而形成一个后验（更新后的）信念。这类似于我们在现实生活中的理解方式。例如，当你在某天早上醒来时，可能会有一个信念（来自天气预报或其他途径），认为外面有40%的机会下雨。打开窗帘后，你看到外面非常多云，这可能表明雨水的可能性更大，因此我们根据这个新数据更新我们的信念，认为下雨的机会是70%。
- en: 'To understand how this works, we need to understand *conditional probability*.
    Conditional probability deals with the probability that one event will occur *given
    that* another event has already occurred. In symbols, the probability of event
    ![](img/Formula_04_045.png) given that event ![](img/Formula_04_044.png) has occurred
    is written as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个过程，我们需要了解*条件概率*。条件概率处理的是给定另一个事件已经发生的情况下，一个事件发生的概率。用符号表示，事件 ![](img/Formula_04_045.png)
    在事件 ![](img/Formula_04_044.png) 已经发生的条件下发生的概率可以写作：
- en: '![](img/Formula_04_066.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_066.png)'
- en: 'Bayes’ theorem is a powerful tool that can be written (symbolically) as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 贝叶斯定理是一个强大的工具，可以用以下方式（符号化）表示：
- en: '![](img/Formula_04_067.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_067.png)'
- en: 'The probability ![](img/Formula_04_068.png) represents our prior belief. The
    event ![](img/Formula_04_044.png) represents the data that we have gathered, so
    that ![](img/Formula_04_070.png) is the likelihood that our data arose given our
    prior belief. The probability ![](img/Formula_04_071.png) represents the probability
    that our data arose, and ![](img/Formula_04_072.png) represents our posterior
    belief given the data. In practice, the probability ![](img/Formula_04_073.png)
    can be difficult to calculate or otherwise estimate, so it is quite common to
    replace the strong equality above with a proportional version of Bayes’ theorem:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 概率 ![](img/Formula_04_068.png) 代表我们的先验信念。事件 ![](img/Formula_04_044.png) 代表我们已收集的数据，因此
    ![](img/Formula_04_070.png) 是在我们的先验信念下，数据产生的可能性。概率 ![](img/Formula_04_071.png)
    代表我们的数据产生的概率，![](img/Formula_04_072.png) 代表在给定数据后，我们的后验信念。实际上，概率 ![](img/Formula_04_073.png)
    可能很难计算或估计，因此通常会将上面的强等式替换为贝叶斯定理的比例版本：
- en: '![](img/Formula_04_074.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_074.png)'
- en: 'In the recipe, we assumed that our prior belief was beta-distributed. The beta
    distribution has a probability density function given by the following equation:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设我们的先验信念服从贝塔分布。贝塔分布的概率密度函数由以下公式给出：
- en: '![](img/Formula_04_075.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_075.png)'
- en: 'Here, ![](img/Formula_04_076.png) is the gamma function. The likelihood is
    binomially distributed, which has a probability density function given by the
    following equation:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_04_076.png) 是伽马函数。该似然性呈二项分布，其概率密度函数由以下公式给出：
- en: '![](img/Formula_04_077.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_077.png)'
- en: Here, ![](img/Formula_04_078.png) is the number of observations, and ![](img/Formula_04_079.png)
    is one of those that were successful. In the recipe, we observed ![](img/Formula_04_080.png)
    successes and ![](img/Formula_04_081.png) failures, which gives ![](img/Formula_04_082.png)
    and ![](img/Formula_04_083.png). To calculate the posterior distribution, we can
    use the fact that the beta distribution is a conjugate prior for the binomial
    distribution to see that the right-hand side of the proportional form of Bayes’
    theorem is beta-distributed with parameters of ![](img/Formula_04_084.png) and
    ![](img/Formula_04_085.png). This is what we used in the recipe. The fact that
    the beta distribution is a conjugate prior for binomial random variables makes
    them useful in Bayesian statistics.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_04_078.png) 是观察次数，![](img/Formula_04_079.png) 是成功的次数之一。在这个例子中，我们观察到
    ![](img/Formula_04_080.png) 次成功和 ![](img/Formula_04_081.png) 次失败，这给出了 ![](img/Formula_04_082.png)
    和 ![](img/Formula_04_083.png)。为了计算后验分布，我们可以利用贝塔分布是二项分布的共轭先验这一事实，来观察贝叶斯定理的比例形式右侧是一个贝塔分布，参数为
    ![](img/Formula_04_084.png) 和 ![](img/Formula_04_085.png)。这就是我们在例子中使用的内容。贝塔分布作为二项随机变量的共轭先验，使其在贝叶斯统计中非常有用。
- en: The method we demonstrated in this recipe is a rather basic example of using
    a Bayesian method, but it is still useful for updating our prior beliefs when
    systematically given new data.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个例子中展示的方法是使用贝叶斯方法的一个相对基础的示例，但它仍然对我们在系统地获取新数据时更新先验信念非常有用。
- en: There’s more...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Bayesian methods can be used for a wide variety of tasks, making it a powerful
    tool. In this recipe, we used a Bayesian approach to model the success rate of
    a website based on our prior belief of how it performs and additional data gathered
    from users. This is a rather complex example since we modeled our prior belief
    on a beta distribution. Here is another example of using Bayes’ theorem to examine
    two competing hypotheses using only simple probabilities (numbers between 0 and
    1).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 贝叶斯方法可以用于各种任务，成为一个强大的工具。在这个例子中，我们使用贝叶斯方法根据我们对网站表现的先验信念和用户收集的额外数据来建模网站的成功率。这个例子比较复杂，因为我们将先验信念建模为贝塔分布。这里是另一个使用贝叶斯定理的例子，用简单的概率（介于0和1之间的数字）来检验两个竞争的假设。
- en: 'Suppose you place your keys in the same place every day when you return home,
    but one morning you wake up to find that they are not in this place. After searching
    for a short time, you cannot find them and so conclude that they must have vanished
    from existence. Let’s call this hypothesis ![](img/Formula_04_086.png). Now, ![](img/Formula_04_087.png)
    certainly explains the data, ![](img/Formula_04_088.png), that you cannot find
    your keys – hence, the likelihood ![](img/Formula_04_089.png) (if your keys vanished
    from existence, then you could not possibly find them). An alternative hypothesis
    is that you simply placed them somewhere else when you got home the night before.
    Let’s call this hypothesis ![](img/Formula_04_090.png). Now, this hypothesis also
    explains the data, so ![](img/Formula_04_091.png), but in reality, ![](img/Formula_04_092.png)
    is far more plausible than ![](img/Formula_04_093.png). Let’s say that the probability
    that your keys completely vanished from existence is 1 in 1 million – this is
    a huge overestimation, but we need to keep the numbers reasonable – while you
    estimate that the probability that you placed them elsewhere the night before
    is 1 in 100\. Computing the posterior probabilities, we have the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你每天回家时都会把钥匙放在同一个地方，但有一天早晨你醒来发现钥匙不在这个地方。经过短暂的寻找后，你找不到它们，于是得出它们一定已经从这个世界消失的结论。我们称这个假设为![](img/Formula_04_086.png)。现在，![](img/Formula_04_087.png)无疑解释了数据，![](img/Formula_04_088.png)，即你找不到钥匙——因此，![](img/Formula_04_089.png)的可能性（如果你的钥匙消失了，那么你根本不可能找到它们）。另一个假设是你回家时把钥匙放到了别的地方。我们称这个假设为![](img/Formula_04_090.png)。现在，这个假设同样能解释数据，所以![](img/Formula_04_091.png)，但实际上，![](img/Formula_04_092.png)比![](img/Formula_04_093.png)更为可信。假设你的钥匙完全消失的概率是百万分之一——这显然是个过高的估计，但我们需要保持数字的合理性——而你估计你把它们放到别处的概率是千分之一。计算后验概率，我们得到如下结果：
- en: '![](img/Formula_04_094.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_094.png)'
- en: This highlights the reality that it is 10,000 times more likely that you simply
    misplaced your keys as opposed to the fact that they simply vanished. Sure enough,
    you soon find your keys already in your pocket because you had picked them up
    earlier that morning.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这突显了这样一个现实：你丢失钥匙的可能性比它们消失的可能性要大10,000倍。果不其然，你很快就发现钥匙已经在你的口袋里，因为你早晨曾把它放进过那里。
- en: Estimating parameters with Monte Carlo simulations
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蒙特卡洛模拟估计参数
- en: Monte Carlo methods broadly describe techniques that use random sampling to
    solve problems. These techniques are especially powerful when the underlying problem
    involves some kind of uncertainty. The general method involves performing large
    numbers of simulations, each sampling different inputs according to a given probability
    distribution, and then aggregating the results to give a better approximation
    of the true solution than any individual sample solution.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛方法广泛描述了利用随机抽样来解决问题的技术。当问题涉及某种不确定性时，这些技术尤其强大。一般方法包括执行大量模拟，每次根据给定的概率分布抽取不同的输入，然后汇总结果，从而比任何单一的样本解提供更好的真实解近似。
- en: MCMC is a specific kind of Monte Carlo simulation in which we construct a Markov
    chain of successively better approximations of the true distribution that we seek.
    This works by accepting or rejecting a proposed state, sampled at random, based
    on carefully selected *acceptance probabilities* at each stage, with the aim of
    constructing a Markov chain whose unique stationary distribution is precisely
    the unknown distribution that we wish to find.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: MCMC（马尔可夫链蒙特卡洛）是一种特定类型的蒙特卡洛模拟，在这种方法中，我们构造一个马尔可夫链，逐步得到我们所寻求的真实分布的更好的近似。这个过程通过基于精心选择的*接受概率*，在每个阶段接受或拒绝一个随机采样的拟议状态，目的是构造一个其唯一平稳分布恰好是我们想要找到的未知分布的马尔可夫链。
- en: In this recipe, we will use the PyMC package and MCMC methods to estimate the
    parameters of a simple model. The package will deal with most of the technical
    details of running simulations, so we don’t need to go any further into the details
    of how the different MCMC algorithms actually work.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用PyMC包和MCMC方法来估计一个简单模型的参数。该包将处理运行模拟的大部分技术细节，因此我们无需进一步深入了解不同MCMC算法的实际工作原理。
- en: Getting ready
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As usual, we import the NumPy package and Matplotlib `pyplot` module as `np`
    and `plt`, respectively. We also import and create a default random number generator,
    with a seed for the purpose of demonstration, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，我们导入 NumPy 包和 Matplotlib 的 `pyplot` 模块，分别命名为 `np` 和 `plt`。我们还导入并创建一个默认的随机数生成器，使用种子来进行演示，代码如下：
- en: '[PRE101]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We will also need a module from the SciPy package for this recipe as well as
    the PyMC package, which is a package for probabilistic programming. We import
    the PyMC package under the `pm` alias:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要 SciPy 包中的一个模块，以及 PyMC 包，它是一个用于概率编程的包。我们将 PyMC 包导入，并命名为 `pm`：
- en: '[PRE102]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Let’s see how to use the PyMC package to estimate the parameters of a model
    given an observed, noisy sample.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何使用 PyMC 包来估计给定观测到的噪声样本的模型参数。
- en: How to do it...
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Perform the following steps to use MCMC simulations to estimate the parameters
    of a simple model using sample data:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，使用 MCMC 模拟来估计简单模型的参数，基于样本数据：
- en: 'Our first task is to create a function that represents the underlying structure
    that we wish to identify. In this case, we will be estimating the coefficients
    of a quadratic (a polynomial of degree 2). This function takes two arguments,
    which are the points in the range, which is fixed, and the variable parameters
    that we wish to estimate:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一个任务是创建一个表示我们希望识别的基础结构的函数。在本例中，我们将估计一个二次方程（一个二次多项式）的系数。该函数接受两个参数，一个是固定的范围内的点，另一个是我们希望估计的变量参数：
- en: '[PRE103]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Next, we set up the `true` parameters and a `size` parameter that will determine
    how many points are in the sample that we generate:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置 `true` 参数和 `size` 参数，这将决定我们生成的样本中有多少个点：
- en: '[PRE105]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We generate the sample that we will use to estimate the parameters. This will
    consist of the underlying data, generated by the `underlying` function we defined
    in *step 1*, plus some random noise that follows a normal distribution. We first
    generate a range of ![](img/Formula_04_095.png) values, which will stay constant
    throughout the recipe, and then use the `underlying` function and the `normal`
    method on our random number generator to generate the sample data:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们生成将用于估计参数的样本数据。这个样本由基础数据组成，基础数据是由我们在*步骤 1*中定义的 `underlying` 函数生成的，再加上一些符合正态分布的随机噪声。我们首先生成一个范围的
    ![](img/Formula_04_095.png) 值，这些值在整个过程里保持不变，然后使用 `underlying` 函数和随机数生成器的 `normal`
    方法来生成样本数据：
- en: '[PRE107]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'It is a good idea to plot the sample data, with the underlying data overlaid,
    before we begin the analysis. We use the `scatter` plotting method to plot only
    the data points (without connecting lines), and then plot the underlying quadratic
    structure using a dashed line:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始分析之前，最好先绘制采样数据，并将基础数据叠加在其上。我们使用 `scatter` 绘图方法仅绘制数据点（不连接线条），然后用虚线绘制基础的二次结构：
- en: '[PRE111]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The result is *Figure 4**.7*, where we can see that the shape of the underlying
    model is still visible even with the noise, although the exact parameters of this
    model are no longer obvious:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 *图 4.7*，在图中可以看到，即使存在噪声，基础模型的形状仍然可见，尽管该模型的确切参数已不再明显：
- en: '![Figure 4.7 – Sampled data with the underlying model overlaid'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – 采样数据与基础模型叠加'
- en: '](img/4.7.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/4.7.jpg)'
- en: Figure 4.7 – Sampled data with the underlying model overlaid
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 采样数据与基础模型叠加
- en: 'The basic object of PyMC programming is the `Model` class, which is usually
    created using the context manager interface. We also create our prior distributions
    for the parameters. In this case, we will assume that our prior parameters are
    normally distributed with a mean of 1 and a standard deviation of 1\. We need
    three parameters, so we provide the `shape` argument. The `Normal` class creates
    random variables that will be used in the Monte Carlo simulations:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyMC 编程的基本对象是 `Model` 类，通常使用上下文管理器接口来创建。我们还为参数创建了先验分布。在本例中，我们假设我们的先验参数服从均值为
    1、标准差为 1 的正态分布。我们需要三个参数，因此提供了 `shape` 参数。`Normal` 类创建将用于蒙特卡洛模拟的随机变量：
- en: '[PRE120]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We create a model for the underlying data, which can be done by passing the
    random variable, `param`, that we created in *step 6* into the `underlying` function
    that we defined in *step 1*. We also create a variable that handles our observations.
    For this, we use the `Normal` class since we know that our noise is normally distributed
    around the underlying data, `y`. We set a standard deviation of `2` and pass our
    observed `sample` data into the `observed` keyword argument (this is also inside
    the `Model` context):'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为基础数据创建一个模型，可以通过将我们在*步骤 6*中创建的随机变量`param`传递给*步骤 1*中定义的`underlying`函数来完成。我们还创建了一个处理我们观测值的变量。为此，我们使用`Normal`类，因为我们知道我们的噪声在基础数据`y`周围呈正态分布。我们设置标准差为`2`，并将我们的观测`sample`数据传递给`observed`关键字参数（这也在`Model`上下文中）：
- en: '[PRE123]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'To run the simulations, we need only call the `sample` routine inside the `Model`
    context. We pass the `cores` argument to speed up the calculations, but leave
    all of the other arguments as the default values:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行模拟，我们只需要在`Model`上下文中调用`sample`例程。我们传递`cores`参数来加速计算，但保留所有其他参数为默认值：
- en: '[PRE126]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: These simulations should take a short time to execute.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模拟应该执行起来很快。
- en: 'Next, we plot the posterior distributions that use the `plot_posterior` routine
    from PyMC. This routine takes the `trace` result from the sampling step that performed
    the simulations. We create our own figures and axes using the `plt.subplots` routine
    in advance, but this isn’t strictly necessary. We are using three subplots on
    a single figure, and we pass the `axs2` tuple of `Axes` to the plotting routing
    under the `ax` keyword argument:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用来自PyMC的`plot_posterior`例程绘制后验分布。该例程使用从采样步骤中获得的`trace`结果，我们已提前使用`plt.subplots`例程创建了自己的图形和坐标轴，但这不是严格必要的。我们在一个图形上使用了三个子图，并将`axs2`元组的`Axes`传递给绘图例程的`ax`关键字参数：
- en: '[PRE127]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The resulting plot is shown in *Figure 4**.8*, where you can see that each
    of these distributions is approximately normal, with a mean that is similar to
    the true parameter values:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的图示显示在*图 4**.8*中，您可以看到这些分布大致是正态分布，均值与真实参数值相似：
- en: '![Figure 4.8 – Posterior distributions of estimated parameters'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – 估计参数的后验分布'
- en: '](img/4.8.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/4.8.jpg)'
- en: Figure 4.8 – Posterior distributions of estimated parameters
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 估计参数的后验分布
- en: 'Now, retrieve the mean of each of the estimated parameters from the `trace`
    result. We access the estimated parameters from the posterior attribute on `trace`
    and then use the `mean` method on the `params` item (with `axes=(0,1)` to average
    over all chains and all samples) and convert this into a NumPy array. We print
    these estimated parameters in the terminal:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`trace`结果中提取每个估计参数的均值。我们通过访问`trace`上的后验属性来获取估计的参数，然后对`params`项目使用`mean`方法（使用`axes=(0,1)`在所有链和所有样本上进行平均），并将其转换为NumPy数组。我们在终端中打印这些估计的参数：
- en: '[PRE129]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Finally, we use our estimated parameters to generate our estimated underlying
    data by passing the ![](img/Formula_04_096.png) values and the estimated parameters
    to the `underlying` function defined in *step 1*. We then plot this estimated
    underlying data together with the true underlying data on the same axes:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用估计的参数生成我们的估计基础数据，通过将![](img/Formula_04_096.png)的值和估计的参数传递给*步骤 1*中定义的`underlying`函数。然后，我们将这个估计的基础数据与真实的基础数据一起绘制在同一坐标轴上：
- en: '[PRE133]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The resulting plot is in *Figure 4**.9*, where there is only a small difference
    between these two models in this range:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的图示显示在*图 4**.9*中，在这个范围内，这两个模型之间只有一个小的差异：
- en: '![Figure 4.9 – True model and estimated model plotted on the same axes'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – 真实模型和估计模型绘制在同一坐标轴上'
- en: '](img/4.9.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/4.9.jpg)'
- en: Figure 4.9 – True model and estimated model plotted on the same axes
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 真实模型和估计模型绘制在同一坐标轴上
- en: In *Figure 4**.9* we can see that there is a small discrepancy between the true
    model and the estimated model.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 4**.9*中，我们可以看到真实模型和估计模型之间存在一个小的差异。
- en: How it works...
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The interesting part of the code in this recipe can be found in the `Model`
    context manager. This object keeps track of the random variables, orchestrates
    the simulations, and keeps track of the state. The context manager gives us a
    convenient way to separate the probabilistic variables from the surrounding code.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中有趣的部分可以在`Model`上下文管理器中找到。这个对象跟踪随机变量，协调模拟并保持状态。上下文管理器为我们提供了一种方便的方式来将概率变量与周围的代码分离。
- en: We start by proposing a prior distribution for the distribution of the random
    variables representing our parameters, of which there are three. We proposed a
    normal distribution since we know that the parameters cannot stray too far from
    the value 1 (we can tell this by looking at the plot that we generated in *step
    4*, for example). Using a normal distribution will give a higher probability to
    the values that are close to the current values. Next, we add the details relating
    to the observed data, which is used to calculate the acceptance probabilities
    that are used to either accept or reject a state. Finally, we start the sampler
    using the `sample` routine. This constructs the Markov chain and generates all
    of the step data.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从为表示参数的随机变量（共有三个）的分布提出先验分布开始。我们提出了正态分布，因为我们知道这些参数不能偏离值1太远（例如，通过查看我们在*步骤 4*中生成的图形，我们可以看出这一点）。使用正态分布将给那些接近当前值的数值更高的概率。接下来，我们加入与观察数据相关的细节，这些数据用于计算接受概率，决定是接受还是拒绝某个状态。最后，我们使用`sample`例程启动采样器。这将构建马尔可夫链并生成所有的步长数据。
- en: The `sample` routine sets up the sampler based on the types of variables that
    will be simulated. Since the normal distribution is a continuous variable, the
    `sample` routine selected the **No U-turn Sampler** (**NUTS**). This is a reasonable
    general-purpose sampler for continuous variables. A common alternative to the
    NUTS is the Metropolis sampler, which is less reliable but faster than the NUTS
    in some cases. The PyMC documentation recommends using the NUTS whenever possible.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample`例程根据将要模拟的变量类型设置采样器。由于正态分布是一个连续变量，`sample`例程选择了**无转弯采样器**（**NUTS**）。这是一种适用于连续变量的通用采样器。NUTS的常见替代方法是Metropolis采样器，后者虽然在某些情况下比NUTS速度更快，但可靠性较差。PyMC文档建议尽可能使用NUTS。'
- en: Once the sampling is complete, we plotted the posterior distribution of the
    trace (the states given by the Markov chain) to see the final shape of the approximations
    we generated. We can see here that all three of our random variables (parameters)
    are normally distributed around approximately the correct value.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦采样完成，我们绘制了马尔可夫链给出的状态（即后验分布）的图形，以查看我们生成的近似值的最终形态。我们可以看到，所有三个随机变量（参数）都呈现出大致正确值附近的正态分布。
- en: Under the hood, PyMC uses Aesara – the successor to Theano used by PyMC3 – to
    speed up its calculations. This makes it possible for PyMC to perform computations
    on a **Graphics Processing Unit** (**GPU**) rather than on the **Central Processing
    Unit** (**CPU**) for a considerable boost to computation speed.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在背后，PyMC使用Aesara——PyMC3中Theano的继任者——来加速计算。这使得PyMC可以在**图形处理单元**（**GPU**）上进行计算，而不是在**中央处理单元**（**CPU**）上，从而大大提升计算速度。
- en: There’s more...
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: The Monte Carlo method is very flexible and the example we gave here is one
    particular case where it can be used. A more typical basic example of where the
    Monte Carlo method is applied is for estimating the value of integrals – commonly,
    Monte Carlo integration. A really interesting case of Monte Carlo integration
    is estimating the value of ![](img/Formula_04_097.png). Let’s briefly look at
    how this works.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡罗方法非常灵活，我们这里给出的例子是它可以应用的一种特定情况。蒙特卡罗方法的一个更典型的基本应用例子是估算积分的值——通常被称为蒙特卡罗积分。一个非常有趣的蒙特卡罗积分应用是估算！[](img/Formula_04_097.png)的值。让我们简要看一下这是如何实现的。
- en: First, we take the unit disk, whose radius is 1 and therefore has an area of
    ![](img/Formula_04_098.png). We can enclose this disk inside a square with vertices
    at the points ![](img/Formula_04_099.png), ![](img/Formula_04_100.png), ![](img/Formula_04_101.png),
    and ![](img/Formula_04_102.png). This square has an area of 4 since the edge length
    is 2\. Now, we can generate random points uniformly over this square. When we
    do this, the probability that any one of these random points lies inside a given
    region is proportional to the area of that region. Thus, the area of a region
    can be estimated by multiplying the proportion of randomly generated points that
    lie within the region by the total area of the square. In particular, we can estimate
    the area of the disk (when the radius is 1, this is ![](img/Formula_04_103.png))
    by simply multiplying the number of randomly generate points that lie within the
    disk by 4 and dividing by the total number of points we generated.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们取一个单位圆，其半径为 1，因此面积为 ![](img/Formula_04_098.png)。我们可以将这个圆形放置在一个边长为 2 的正方形内部，其顶点分别位于
    ![](img/Formula_04_099.png)、![](img/Formula_04_100.png)、![](img/Formula_04_101.png)
    和 ![](img/Formula_04_102.png)。该正方形的面积为 4，因为边长为 2。现在，我们可以在这个正方形上均匀生成随机点。当我们这样做时，任何一个随机点位于给定区域内的概率与该区域的面积成正比。因此，可以通过将位于该区域内的随机生成点的比例乘以正方形的总面积来估算区域的面积。特别地，我们可以通过将位于圆内的随机生成点的数量乘以
    4，并除以我们生成的点的总数，来估算该圆的面积（当半径为 1 时，这个面积是 ![](img/Formula_04_103.png)）。
- en: 'We can easily write a function in Python that performs this calculation, which
    might be the following:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地用 Python 编写一个执行此计算的函数，可能如下所示：
- en: '[PRE141]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Running this function just once will give a reasonable approximation of π:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 仅运行一次此函数即可给出π的合理近似值：
- en: '[PRE142]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'We can improve the accuracy of our estimation by using more points, but we
    could also run this a number of times and average the results. Let’s run this
    simulation 100 times and average the results (we’ll use concurrent futures to
    parallelize this so that we can run larger numbers of samples if we want):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用更多的点来提高估计的准确性，但我们也可以多次运行这个过程并对结果进行平均。我们来运行这个模拟 100 次，并计算结果的平均值（我们将使用并发未来（concurrent
    futures）来并行化这个过程，这样如果需要，我们可以运行更大数量的样本）：
- en: '[PRE143]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Running this code once prints the estimated value of ![](img/Formula_04_104.png)
    as 3.1415752, which is an even better estimate of the true value.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一次此代码会打印出估计值 ![](img/Formula_04_104.png)，其值为 3.1415752，这是对真实值的一个更精确估计。
- en: See also
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The PyMC package has many features that are documented by numerous examples
    ([https://docs.pymc.io/](https://docs.pymc.io/)). There is also another probabilistic
    programming library based on TensorFlow ([https://www.tensorflow.org/probability](https://www.tensorflow.org/probability)).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: PyMC 包含许多功能，这些功能通过大量示例进行了文档说明（[https://docs.pymc.io/](https://docs.pymc.io/)）。还有另一个基于
    TensorFlow 的概率编程库（[https://www.tensorflow.org/probability](https://www.tensorflow.org/probability)）。
- en: Further reading
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'A good, comprehensive reference for probability and random processes is the
    following book:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 一本关于概率和随机过程的好书是：
- en: '*Grimmett, G. and Stirzaker, D. (2009). Probability and random processes. 3rd
    ed. Oxford: Oxford* *Univ. Press.*'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Grimmett, G. 和 Stirzaker, D. (2009). Probability and random processes. 第3版.
    牛津：牛津* *大学出版社。*'
- en: 'An easy introduction to Bayes’ theorem and Bayesian statistics is the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 贝叶斯定理和贝叶斯统计的简单介绍如下：
- en: '*Kurt, W. (2019). Bayesian statistics the fun way. San Francisco, CA: No Starch*
    *Press, Inc.*'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kurt, W. (2019). Bayesian statistics the fun way. San Francisco, CA: No Starch*
    *Press, Inc.*'
