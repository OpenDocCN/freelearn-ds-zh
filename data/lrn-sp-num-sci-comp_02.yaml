- en: Chapter 2. Working with the NumPy Array As a First Step to SciPy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用NumPy数组作为SciPy的第一步
- en: At the top level, SciPy is basically NumPy, since both the object creation and
    basic manipulation of these objects are performed by functions of the latter library.
    This assures much faster computations, since the memory handling is done internally
    in an optimal way. For instance, if an operation must be made on the elements
    of a big multidimensional array, a novice user might be tempted to go over columns
    and rows with as many for loops as necessary. Loops run much faster when they
    access each consecutive element in the same order in which they are stored in
    memory. We should not be bothered with considerations of this kind when coding.
    The NumPy/SciPy operations assure that this is the case. As an added advantage,
    the names of operations in NumPy/SciPy are intuitive and self explanatory. Code
    written in this fashion is extremely easy to understand and maintain, faster to
    correct or change in case of need.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶层，SciPy基本上是NumPy，因为这两个对象创建和基本操作都是由后者的函数执行的。这保证了计算速度更快，因为内存处理是在内部以最佳方式进行的。例如，如果必须在大型多维数组的元素上执行操作，一个新手用户可能会被诱惑使用尽可能多的for循环来遍历列和行。当循环以与它们在内存中存储的相同顺序访问每个连续元素时，循环运行得更快。在编码时，我们不应该被这类考虑所困扰。NumPy/SciPy操作确保了这一点。作为一个额外的优势，NumPy/SciPy中操作的名字直观且易于理解。以这种方式编写的代码非常容易理解和维护，在需要时更快地纠正或更改。
- en: Let's illustrate this point with an introductory example.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个入门示例来说明这一点。
- en: The `scipy.misc` module in the SciPy package contains a classical image called
    `lena`, used in the image processing community for testing and comparison purposes.
    This is a 512 x 512 pixel standard test image, which has been in use since 1973,
    and was originally cropped from the centerfold of the November 1972 issue of the
    Playboy magazine. It is a picture of Lena Söderberg, a Swedish model, shot by
    photographer Dwight Hooker. The image is probably the most widely used test image
    for all sorts of image processing algorithms (such as compression and noise reduction)
    and related scientific publications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy包中的`scipy.misc`模块包含一个经典图像`lena`，该图像在图像处理社区中被用于测试和比较目的。这是一个512 x 512像素的标准测试图像，自1973年以来一直被使用，最初是从1972年11月《花花公子》杂志的封底裁剪而来。这是一张由摄影师Dwight
    Hooker拍摄的瑞典模特Lena Söderberg的照片。这张图像可能是所有各种图像处理算法（如压缩和降噪）和相关科学出版物中最广泛使用的测试图像。
- en: 'This image is stored as a two-dimensional array. Note that the number in the
    *n^(th)* column and *m^(th)* row of this array measures the grayscale value at
    the pixel position (*n+1*, *m+1*) of the image. In the following, we access this
    picture and store it in the `img` variable, by issuing the following commands:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图像存储为一个二维数组。请注意，该数组第*n*列和*m*行的数字测量图像像素位置(*n+1*, *m+1*)的灰度值。在以下内容中，我们通过以下命令访问这张图片并将其存储在`img`变量中：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The image can be displayed by issuing the following command:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下命令显示图像：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Working with the NumPy Array As a First Step to SciPy](img/7702OS_02_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![使用NumPy数组作为SciPy的第一步](img/7702OS_02_01.jpg)'
- en: 'We may take a peek at some of these values; say the 7 x 3 upper corner of the
    image (7 columns, 3 rows). Instead of issuing for loops, we could *slice* the
    corresponding portion of the image. The `img[0:3,0:7]` command gives us the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看一些这些值；比如说图像的7 x 3上角（7列，3行）。我们不必使用for循环，我们可以*切片*图像的相应部分。`img[0:3,0:7]`命令给出了以下内容：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can use the same strategy to populate arrays or change their values. For
    instance, let''s change all entries of the previous array to hold zeros on the
    second row between columns 2 to 6:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的策略来填充数组或更改它们的值。例如，让我们将上一个数组的所有条目更改为在第二行第2到第6列之间持有零：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is shown as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Object essentials
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象基础
- en: 'We have been introduced to NumPy''s main object—the homogeneous multidimensional
    array, also referred to as `ndarray`. All elements of the array are casted to
    the same datatype (homogeneous). We obtain the datatype by the `dtype` attribute,
    its dimension by the `shape` attribute, the total number of elements in the array
    by the `size` attribute, and elements by referring to their positions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了NumPy的主要对象——同构的多维数组，也称为`ndarray`。数组的所有元素都被转换为相同的数据类型（同构）。我们通过`dtype`属性获得数据类型，通过`shape`属性获得其维度，通过`size`属性获得数组中的元素总数，通过引用它们的位位置来引用元素：
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is shown as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s compute the grayscale values now:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们计算灰度值：
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is shown as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's interpret the outputs. The elements of `img` are 64-bit integer values
    ('int64'). This may vary depending on the system, the Python installation, and
    the computer specifications. The shape of the array (note it comes as a Python
    tuple) is 512 x 512, and the number of elements 262144\. The grayscale value of
    the image in the 33^(rd) column and 68^(th) row is `87` (note that in NumPy, as
    in Python or C, all indices are zero-based).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下输出。`img`的元素是64位整数值（'int64'）。这可能会根据系统、Python安装和计算机规格而变化。数组的形状（注意它以Python元组的形式出现）是512
    x 512，元素数量为262144。图像在第33列和第68行的灰度值是`87`（请注意，在NumPy中，就像在Python或C中一样，所有索引都是从0开始的）。
- en: We will now introduce the basic property and methods of NumPy/SciPy objects—datatype
    and indexing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍NumPy/SciPy对象的基本属性和方法——数据类型和索引。
- en: Using datatypes
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据类型
- en: 'There are several approaches to impose the datatype. For instance, if we want
    all entries of an already created array to be 32-bit floating point values, we
    may cast it as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 强制数据类型的方法有多种。例如，如果我们想将已创建数组的所有条目都设置为32位浮点值，我们可以按照以下方式转换：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also use an optional argument, `dtype` through the command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过命令使用可选参数`dtype`：
- en: '[PRE10]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is shown as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE11]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This can be simplified even further with a third clever method (although this
    practice offers code that are not so easy to interpret):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过第三种巧妙的方法进一步简化（尽管这种做法提供的代码不易理解）：
- en: '[PRE12]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is shown as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE13]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The choice of datatypes for NumPy arrays is very flexible; we may choose the
    basic Python types (including `bool`, `dict`, `list`, `set`, `tuple`, `str`, and
    `unicode`), although for numerical computations we focus on `int`, `float`, `long`,
    and `complex`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组的类型选择非常灵活；我们可以选择基本的Python类型（包括`bool`、`dict`、`list`、`set`、`tuple`、`str`和`unicode`），尽管在数值计算中我们专注于`int`、`float`、`long`和`complex`。
- en: 'NumPy has its own set of datatypes optimized to use with instances of `ndarray`,
    and with the same precision as the previously given native types. We distinguish
    them with a trailing underscore (`_`). For instance, `ndarray` of strings could
    be initialized, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy有一组针对`ndarray`实例优化的数据类型，并且与之前给出的原生类型具有相同的精度。我们通过尾部下划线（`_`）来区分它们。例如，字符串的`ndarray`可以初始化如下：
- en: '[PRE14]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is shown as follows (it depends on your Python version):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示（这取决于您的Python版本）：
- en: '[PRE15]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note two things; unlike it's purely Python counterpart, the usage of the `'str_'`
    datatype requires the name to be quoted; we could use the longer unquoted version,
    `numpy.str_`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两点；与它的纯Python对应物不同，使用`'str_'`数据类型需要将名称引号括起来；我们可以使用较长的未引号版本，即`numpy.str_`。
- en: 'When prompted for datatype, the system returns its C-derived equivalent: `''<U7''`
    (''`<U` for strings, and `7`'' to indicate the largest size of any of its elements).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统提示数据类型时，它会返回其C派生的等效类型：`'<U7'`（`<U`表示字符串，`7`表示其元素的最大大小）。
- en: 'The most common way to address numerical types is with the bit width nomenclature:
    `boolXX`, `intXX`, `uintXX`, `floatXX`, or `complexXX`, where `XX` indicates the
    bit size (for example, `uint32` for 32-bit unsigned integers).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的处理数值类型的方法是使用位宽命名法：`boolXX`、`intXX`、`uintXX`、`floatXX`或`complexXX`，其中`XX`表示位大小（例如，`uint32`表示32位无符号整数）。
- en: 'It is also possible to design our own datatypes, and this is where the full
    potential of the flexibility of NumPy datatypes arise. For instance, a datatype
    to indicate the name and grades of a student could be created, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以设计自己的数据类型，这正是NumPy数据类型灵活性的全部潜力所在。例如，可以创建一个数据类型来表示学生的姓名和成绩，如下所示：
- en: '[PRE16]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is shown as follows (it depends on your Python version):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示（这取决于您的Python版本）：
- en: '[PRE17]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This means that the `dt` datatype has two parts: the first part, the `name`,
    that must be a `numpy.str_` string with 16 characters. The second part, the `grades`,
    is a subarray of dimension 2 with scores as 64-bit floating point values. A valid
    array with elements in this datatype would then look like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`dt`数据类型有两个部分：第一部分是`name`，它必须是一个16个字符的`numpy.str_`字符串。第二部分是`grades`，它是一个维度为2的子数组，其中的分数是64位浮点值。具有此数据类型元素的数组将如下所示：
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is shown as follows (it depends on your Python version):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示（这取决于您的Python版本）：
- en: '[PRE19]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Indexing and slicing arrays
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引和切片数组
- en: There are two basic methods to access the data in a NumPy array; let's call
    that array for `A`. Both methods use the same syntax, `A[obj]`, where `obj` is
    a Python object that performs the selection. We are already familiar with the
    first method of accessing a single element. The second method is the subject of
    this section, namely **slicing**. This concept is exactly what makes NumPy and
    SciPy so incredibly easy to manage.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 访问NumPy数组中的数据有两种基本方法；让我们称这个数组为`A`。两种方法都使用相同的语法，`A[obj]`，其中`obj`是一个Python对象，它执行选择。我们已经熟悉了访问单个元素的第一种方法。第二种方法是本节的主题，即**切片**。这个概念正是使NumPy和SciPy如此易于管理的根本原因。
- en: The basic slice method is a Python object of the form `slice(start,stop,step)`,
    or in a more compact notation, `start:stop:step`. Initially, the three variables,
    `start`, `stop`, and `step` are non-negative integer values, with `start` less
    than or equal to `stop`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基本切片方法是一个形式为`slice(start,stop,step)`的Python对象，或者在一个更紧凑的表示法中，`start:stop:step`。最初，三个变量`start`，`stop`和`step`是非负整数值，其中`start`小于或等于`stop`。
- en: 'This represents the sequence of indices *k = start + (i * step)*, where *k*
    runs from `start` to the largest integer *k_max = start + step*int((stop-start)/step)*,
    or *i* from `0` to the largest integer equal to *int((stop - start) / step)*.
    When a slice method is invoked on any of the dimensions of `ndarray`, it selects
    all elements in that dimension indexed by the corresponding sequence of indices.
    The simple example next illustrates this point:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示索引序列*k = start + (i * step)*，其中*k*从`start`运行到最大的整数*k_max = start + step*int((stop-start)/step)*，或者*i*从`0`运行到最大的整数等于*int((stop
    - start) / step)*。当在`ndarray`的任何维度上调用切片方法时，它选择该维度中由相应索引序列索引的所有元素。下面的简单示例说明了这一点：
- en: '[PRE20]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is shown as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE21]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If `start` is greater than `stop`, a negative value of `step` is used to traverse
    the sequence backwards:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`start`大于`stop`，则使用负值的`step`来反向遍历序列：
- en: '[PRE22]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is shown as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE23]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Negative values of `start` and `stop` are interpreted as `n-start` and `n-stop`
    (respectively), where `n` is the size of the corresponding dimension. The `A[0:2,-1:0:-2]`
    command gives exactly the same output as the previous example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`和`stop`的负值被解释为`n-start`和`n-stop`（分别），其中`n`是相应维度的尺寸。`A[0:2,-1:0:-2]`命令给出与前面示例完全相同的输出。'
- en: The slice objects can be shortened by the absence of `start` (which implies
    a zero if `step` is positive, or the size of the dimension if `step` is negative),
    absence of `stop` (which implies the size of the corresponding dimension in case
    of positive `step`, or zero in case of negative `step`). Absence of `step` implies
    `step` is equal to 1\. The `::` object can be shortened simply as `:` for an easier
    syntax. The `A[:,::-2]` command then offers, yet again, the same output as the
    previous two.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 切片对象可以通过省略`start`（如果`step`为正，则表示零，如果`step`为负，则表示该维度的尺寸）来缩短，省略`stop`（在`step`为正的情况下，表示相应维度的尺寸，在`step`为负的情况下，表示零）。省略`step`意味着`step`等于1。`::`对象可以简单地缩短为`:`，以便于语法。然后`A[:,::-2]`命令再次提供与前面两个相同的输出。
- en: 'The first nonbasic method of accessing data from an array is based on the idea
    of collecting several indices and requesting the elements in the array with those
    indices. For example, from our previous array `A`, we would like to construct
    a new array with the elements on locations (0, 0), (0, 3), (1, 2), and (1, 5).
    We do so by gathering the *x* and *y* values of the indices in respective lists,
    `[0,0,1,1]` and `[0,3,2,5]`, and feeding these lists to `A` as an indexing object,
    as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从数组中访问数据的第一个非基本方法基于收集多个索引并请求具有这些索引的数组元素的思路。例如，从我们之前的数组`A`中，我们希望构建一个新的数组，包含位置(0,
    0)，(0, 3)，(1, 2)和(1, 5)的元素。我们通过收集索引的*x*和*y*值，分别在列表`[0,0,1,1]`和`[0,3,2,5]`中，并将这些列表作为索引对象传递给`A`，如下所示：
- en: '[PRE24]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is shown as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE25]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note how the result loses the dimension of the primitive array, and offers
    a one-dimensional array. If we desire to capture a subarray of `A` with indices
    in the **Cartesian** product of two sets of indices, respecting the row and column
    choice and creating a new array with the dimensions of the Cartesian product,
    we use the `ix_` command. For instance, if in our previous array we would like
    to obtain the subarray of dimension 2 x 2 with indices in the Cartesian product
    of indices (0, 1) by (0,3) (these are the locations (0, 0), (0, 3), (1, 0), and
    (1, 3), we do so as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意结果丢失了原始数组的维度，并提供了一个一维数组。如果我们希望捕获`A`的子数组，其索引位于两个索引集的笛卡尔积中，尊重行和列的选择，并创建一个具有笛卡尔积维度的新数组，我们使用`ix_`命令。例如，如果我们想从之前的数组中获取维度为2
    x 2的子数组，其索引位于索引（0, 1）和（0,3）的笛卡尔积中（这些位置是（0, 0）、（0, 3）、（1, 0）和（1, 3），我们可以这样做：
- en: '[PRE26]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is shown as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE27]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The array object
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组对象
- en: At this point, we are ready for a thorough study of all interesting attributes
    of `ndarray` for scientific computing purposes. We have already covered a few,
    such as `dtype`, `shape`, and `size`. Other useful attributes are `ndim` (to compute
    the number of dimensions in the array), `real`, and `imag` (to obtain the real
    and imaginary parts of the data, should this be formed by complex numbers) or
    `flat` (which creates a one-dimensional indexable iterator from the data).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已准备好对所有有趣的`ndarray`属性进行彻底研究，以用于科学计算目的。我们已经涵盖了几个，例如`dtype`、`shape`和`size`。其他有用的属性包括`ndim`（用于计算数组中的维度数量）、`real`和`imag`（如果数据由复数组成，则用于获取数据的实部和虚部）或`flat`（它从数据创建一个一维可索引迭代器）。
- en: 'For instance, if we desired to add all the values of an array together, we
    could use the `flat` attribute to run over all the elements sequentially, and
    accumulate all the values in a variable. A possible code to perform this task
    should look like the following code snippet (compare this code with the `ndarray.sum()`
    method, which will be explained in object calculation ahead):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想将数组中的所有值相加，我们可以使用`flat`属性按顺序遍历所有元素，并将所有值累积到一个变量中。执行此任务的可能的代码片段如下（将此代码与稍后解释的`ndarray.sum()`方法进行比较）：
- en: '[PRE28]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output is shown as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE29]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will also explore some of the methods applied to arrays. These are tools
    used to modify objects; let it be their datatypes, their shape, or their structure
    through conversion. These methods can be classified in three big categories—**array**
    **conversion**, **shape** **selection**/**manipulation**, and **object calculation**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探索应用于数组的一些方法。这些是用于修改对象的工具；无论是它们的数据类型、形状还是通过转换的结构。这些方法可以分为三大类——**数组转换**、**形状选择/操作**和**对象计算**。
- en: Array conversions
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组转换
- en: The `astype()` method returns a copy of the array converted to a specific type;
    the `copy` method returns a copy of the array. Finally, the `tofile()`, `tolist()`,
    or `tostring()` method writes the binary data of the array into a file, returns
    a hierarchical python list version of the same array, or returns a string representation
    of the array data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`astype()`方法返回数组的副本，转换为特定类型；`copy`方法返回数组的副本。最后，`tofile()`、`tolist()`或`tostring()`方法将数组的二进制数据写入文件，返回相同数组的分层Python列表版本，或返回数组数据的字符串表示。'
- en: 'For instance, to write the contents of the `img` array to a text file making
    sure that each entry of the array is printed as an integer and that every two
    integers are separated by a white space, we can issue the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将`img`数组的内容写入文本文件，确保数组中的每个条目都按整数打印，并且每两个整数之间用空格分隔，我们可以发出以下命令：
- en: '[PRE30]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note how the formatting string follows the C language conventions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意格式化字符串遵循C语言约定。
- en: Shape selection/manipulations
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形状选择/操作
- en: These are used not only when we need to rearrange (`swapaxes` and `transpose`)
    or sort (`argsort` and `sort`) an array, but also when we need to reshape (`reshape`),
    resize (`flatten`, `ravel`, `resize`, and `squeeze`), or select (`choose`, `compress`,
    `diagonal`, `nonzero`, `searchsorted`, and `take`) arrays. Note that these methods
    are very powerful when combined with slicing operations; as a matter of fact,
    many of them can replace slicing to offer more readability.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法不仅在我们需要重新排列（`swapaxes`和`transpose`）或排序（`argsort`和`sort`）数组时使用，而且在我们需要重塑（`reshape`）、调整大小（`flatten`、`ravel`、`resize`和`squeeze`）或选择（`choose`、`compress`、`diagonal`、`nonzero`、`searchsorted`和`take`）数组时也使用。请注意，当与切片操作结合使用时，这些方法非常强大；事实上，许多方法可以替代切片以提供更好的可读性。
- en: 'We need to say a word about the attributes `flat`, `ravel`, and `flatten`,
    which offer very similar outputs, but very different memory management. The first
    attribute, `flat`, creates an iterator over an array. Once used, it disappears
    from memory. The attribute `ravel` returns a one-dimensional flattened array of
    the input; a copy is made only if needed. Finally, `flatten` creates a one-dimensional
    array of the input, and always allocates memory for it. We use it only when we
    need to change the values of flattened arrays. We will highlight the power of
    the sorting methods in the following code snippets. When sorting an array of integers,
    what would be the order of their indices? We may obtain this information with
    the `argsort()` method. We may even impose which sorting algorithm is to be used
    (rather than coding it ourselves)—`quicksort`, `mergesort`, or `heapsort`. We
    can even sort the array in place, using the `sort()` method. Let''s take a look
    at the following set of commands:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要谈谈`flat`、`ravel`和`flatten`这些属性，它们提供非常相似的结果，但在内存管理方面却大不相同。第一个属性`flat`创建一个数组迭代器。一旦使用，它就会从内存中消失。属性`ravel`返回一个一维展平的输入数组；只有在需要时才会创建副本。最后，`flatten`创建一个一维输入数组，并且总是为它分配内存。我们只在需要更改展平数组的值时使用它。我们将在以下代码片段中强调排序方法的力量。当对一个整数数组进行排序时，它们的索引顺序会是什么？我们可以使用`argsort()`方法获得这些信息。我们甚至可以指定要使用的排序算法（而不是自己编写代码）——`quicksort`、`mergesort`或`heapsort`。我们甚至可以使用`sort()`方法就地排序。让我们看一下以下一系列命令：
- en: '[PRE31]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is shown as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE32]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we apply the `sort()` method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应用`sort()`方法：
- en: '[PRE33]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is shown as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE34]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Object calculations
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象计算
- en: Array calculation methods are used to perform computations or extract information
    from our data. Python supplies a range of statistical methods to compute, for
    instance, maximum and minimum values of the data (`max` and `min`) with their
    corresponding indices (`argmax` and `argmin`) methods to compute the sum, cumulative
    sums, product, or cumulative products (`sum`, `cumsum`, `prod`, and `cumprod`),
    and to calculate the average (`mean`), point spread (`ptp`), variance (`var`),
    and standard deviation (`std`) of our data. Other methods allow us to compute
    complex conjugate of complex-valued arrays (`conj`), the trace of the array (`trace`,
    which is the sum of the elements in the diagonal), and even clipping the matrix
    (`clip`) by forcing a minimum and maximum value below and above certain thresholds.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 数组计算方法用于执行计算或从我们的数据中提取信息。Python提供了一系列统计方法来计算，例如，数据的最大值和最小值（`max`和`min`），以及它们的对应索引方法（`argmax`和`argmin`）来计算总和、累计总和、乘积或累计乘积（`sum`、`cumsum`、`prod`和`cumprod`），以及计算我们的数据的平均值（`mean`）、点扩散（`ptp`）、方差（`var`）和标准差（`std`）。其他方法允许我们计算复数值数组的复共轭（`conj`）、数组的迹（`trace`，即对角线元素的总和），甚至可以通过强制设置低于和高于某些阈值的最低和最高值来剪切矩阵（`clip`）。
- en: 'Note, that most of these methods can act on the entire array and each of their
    dimension:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些方法中的大多数都可以作用于整个数组及其每个维度：
- en: '[PRE35]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is shown as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE36]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s apply the `mean()` method with `axis=0`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`axis=0`应用`mean()`方法：
- en: '[PRE37]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is shown as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE38]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Similarly, we perform the same command with `axis=1`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们使用相同的命令并设置`axis=1`：
- en: '[PRE39]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is shown as:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE40]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s also illustrate the `clip` command with an easy exercise based on the
    Lena image. Compute the maximum and minimum values of Lena (`img`), and contrast
    them with the point spread (it should be equal to the difference between those
    two values). Now, create a new array `A` by clipping Lena so that the minimum
    is maintained, but the point spread is reduced to only 100 values. Let''s illustrate
    the effect of `min()`, `max()`, and `ptp()` commands on Lena (`img`):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也通过基于Lena图像的简单练习来说明`clip`命令。计算Lena（`img`）的最大值和最小值，并将它们与点扩散（它应该等于这两个值之间的差）进行对比。现在，通过剪切Lena创建一个新的数组`A`，保持最小值不变，但将点扩散减少到仅100个值。让我们说明`min()`、`max()`和`ptp()`命令对Lena（`img`）的影响：
- en: '[PRE41]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is shown as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE42]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Further, we illustrate the effect of `clip()` command on `img` in the following
    lines of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将在以下代码行中说明`clip()`命令对`img`的影响：
- en: '[PRE43]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is shown as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE44]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Array routines
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组例程
- en: 'In this section, we will deal with most operations on arrays. We will classify
    them into four main categories:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将处理数组的大部分操作。我们将它们分为四个主要类别：
- en: Routines to create new arrays
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新数组的例程
- en: Routines to manipulate a single array
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作单个数组的例程
- en: Routines to combine two or more arrays
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合两个或更多数组的例程
- en: Routines to extract information from arrays
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数组中提取信息的例程
- en: The reader will surely realize that some operations of this kind can be carried
    out by methods, which once again shows the flexibility of Python and NumPy.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 读者肯定会意识到，这类操作可以通过方法来实现，这再次显示了Python和NumPy的灵活性。
- en: Routines to create arrays
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数组的例程
- en: 'We have previously seen the command to create an array and store it to a variable
    `A`. Let''s take a look at it again:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到了创建数组并将其存储到变量`A`中的命令。让我们再次看看它：
- en: '[PRE45]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The complete syntax, however, writes as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，完整的语法如下所示：
- en: '[PRE46]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s go over the options: `object` is simply the data we use to initialize
    the array. In the previous example, the object is a 2 x 2 square matrix; we may
    impose a datatype with the `dtype` option. The result is stored in the variable
    `A`. If `copy` is `True`, the returned object will be a copy of the array, if
    `False`, the returned object will only be a copy, if `dtype` is different from
    the datatype of `object`. The arrays are stored following a C-style ordering of
    rows and columns. If the user prefers to store the array following the memory
    style of FORTRAN, the `order=''Fortran''` option should be used. The `subok` option
    is very subtle; if `True`, the array may be passed as a subclass of the object,
    if `False`, then only `ndarray` arrays are passed. And finally, the `ndmin` option
    indicates the smallest dimension returned by the array. If not offered, this is
    computed from `object`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看选项：`object`只是我们用来初始化数组的原始数据。在先前的例子中，该对象是一个2 x 2的方阵；我们可以使用`dtype`选项来指定数据类型。结果存储在变量`A`中。如果`copy`为`True`，返回的对象将是数组的副本，如果`False`，则返回的对象将仅是副本，如果`dtype`与对象的类型不同。数组按照C风格的行和列顺序存储。如果用户希望按照FORTRAN的内存风格存储数组，应使用`order='Fortran'`选项。`subok`选项非常微妙；如果为`True`，数组可以作为对象的子类传递，如果为`False`，则只能传递`ndarray`数组。最后，`ndmin`选项表示数组返回的最小维度。如果没有提供，这将从`object`中计算得出。
- en: 'A set of special arrays can be obtained with commands such as `zeros`, `ones`,
    `empty`, `identity`, and `eye`. The names of these commands are quite informative:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`zeros`、`ones`、`empty`、`identity`和`eye`等命令获得一组特殊数组。这些命令的名称非常有信息性：
- en: '`zeros` creates an array filled with zeros.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zeros`创建一个填充有零的数组。'
- en: '`ones` creates an array filled with ones.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ones`创建一个填充有1的数组。'
- en: '`empty` returns an array of required shape without initializing its entries.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`empty`返回所需形状的数组，但不初始化其条目。'
- en: '`identity` creates a square matrix with dimensions indicated by a single positive
    integer *n*. The entries are filled with zeros, except the diagonal, which is
    filled with ones.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identity`创建一个由单个正整数*n*指定的维度的方阵。除了对角线外，所有条目都填充为零，对角线填充为1。'
- en: 'The `eye` command is very similar to `identity`. It also constructs diagonal
    arrays, but unlike `identity`, `eye` allows specifying diagonals offset the traditional
    centered, as it can operate on rectangular arrays as well. In the following lines
    of code, we use zeros, ones, and identity commands:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`eye`命令与`identity`非常相似。它也构建对角数组，但与`identity`不同，`eye`允许指定偏离传统居中对齐的对角线，因为它还可以在矩形数组上操作。在以下代码行中，我们使用zeros、ones和identity命令：'
- en: '[PRE47]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the first two cases, we indicated the shape of the array (as a Python tuple
    of positive integers) and the optional datatype imposition.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两种情况下，我们指明了数组的形状（作为正整数的 Python 元组）和可选的数据类型指定。
- en: 'The syntax for `eye` is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`eye` 的语法如下：'
- en: '[PRE48]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The integers, `N` and `M` indicate the shape of the array, and the integer `k`
    indicates the index of the diagonal to populate.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 整数 `N` 和 `M` 表示数组的形状，整数 `k` 表示要填充的对角线索引。
- en: 'An index `k=0` (the default) points to the traditional diagonal; a positive
    index refers to upper diagonals and negative to lower diagonals. To illustrate
    this point, the following example shows how to create a 4 x 4 sparse matrix with
    nonzero elements on the first upper and subdiagonals:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 索引 `k=0`（默认值）指向传统的对角线；正索引指向上对角线，负索引指向下对角线。为了说明这一点，以下示例展示了如何创建一个 4 x 4 的稀疏矩阵，其非零元素位于第一上对角线和次对角线上：
- en: '[PRE49]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output is shown as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE50]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Using the previous four commands together with basic slicing, it is possible
    to create even more complex arrays very simply. We propose the following challenge.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将前四个命令与基本切片结合使用，可以非常简单地创建更复杂的数组。我们提出以下挑战。
- en: 'Use exclusively, the previous definitions of `U` and `I` together with an `eye`
    array. How would the reader create a 5 x 5 array `A` of values, type float with
    *fives* at the four entries (0, 0), (0, 1), (1, 0), and (1, 1); *sixes* along
    the remaining entries of the diagonal; and *threes* in the two other corners ?
    The solution to this question can be addressed by issuing the following set of
    commands:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用之前定义的 `U` 和 `I` 以及 `eye` 数组。读者将如何创建一个 5 x 5 的数组 `A`，其值为浮点数，在四个条目（0, 0）、（0,
    1）、（1, 0）和（1, 1）处为 *fives*；在剩余的对角线条目处为 *sixes*；在两个其他角落处为 *threes*？此问题的解决方案可以通过以下命令集来解决：
- en: '[PRE51]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output is shown as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The flexibility of creating an array in NumPy is even more clear using the
    `fromfunction` command. For instance, if we require a 4 x 4 array where each entry
    reflects the product of its indices, we may use the `lambda` function `(lambda
    i,j: i*j)` in the `fromfunction` command, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 NumPy 创建数组的灵活性通过 `fromfunction` 命令表现得更加清晰。例如，如果我们需要一个 4 x 4 的数组，其中每个条目都反映了其索引的乘积，我们可以在
    `fromfunction` 命令中使用 `lambda` 函数 `(lambda i,j: i*j)`，如下所示：'
- en: '[PRE53]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output is shown as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE54]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'A very important tool dealing with arrays is the concept of masking. **Masking**
    is based on the idea of selecting or masking those indices for which their corresponding
    entries satisfy a given condition. For example, in the array `B` shown in the
    previous example, we can mask all zero-valued entries with the `B==0` command,
    as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数组的一个非常重要的工具是掩码的概念。**掩码**基于选择或掩码那些满足给定条件的索引条目的想法。例如，在前面示例中显示的数组 `B` 中，我们可以使用
    `B==0` 命令掩码所有零值条目，如下所示：
- en: '[PRE55]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output is shown as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE56]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, how would the reader update `B` so that all zero's would be replaced by
    the sum of the squares of their corresponding indices?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，读者将如何更新 `B`，以便将所有零替换为它们对应索引的平方和？
- en: 'Multiplying a mask by a second array of the same shape offers a new array in
    which each entry is either zero (if the corresponding entry in the mask is `False`),
    or the entry of the second array (if the corresponding entry in the mask is `True`):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个掩码与形状相同的第二个数组相乘，会得到一个新的数组，其中每个条目要么是零（如果掩码中相应的条目是 `False`），要么是第二个数组的条目（如果掩码中相应的条目是
    `True`）：
- en: '[PRE57]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is shown as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE58]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that we have created a new array filled with Boolean values as the size
    of the original array and in each step. This isn't a big deal in these toy examples,
    but when handling large datasets, allocating too much memory could seriously slow
    down our computations and exhaust the memory of our system. Among the commands
    to create arrays, there are two in particular `putmask` and `where`, which facilitate
    the management of resources internally, thus speeding up the process.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们创建了一个新数组，其中填充了布尔值，其大小与原始数组相同，并在每个步骤中。在这些玩具示例中，这并不是什么大问题，但在处理大型数据集时，分配过多的内存可能会严重减慢我们的计算速度并耗尽系统的内存。在创建数组的命令中，有两个命令特别重要，即
    `putmask` 和 `where`，它们有助于内部资源管理，从而加快处理过程。
- en: 'Note, for example, when we look for all odd-valued entries in `B`, the resulting
    mask has size of 16, although the interesting entries are only eight:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们寻找 `B` 中所有奇数值条目时，生成的掩码大小为 16，尽管有趣的条目只有八个：
- en: '[PRE59]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output is shown as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE60]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `numpy.where()` command helps us gather those entries more efficiently.
    Let''s take a look at the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.where()`命令帮助我们更有效地收集这些条目。让我们看看以下命令：'
- en: '[PRE61]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output is shown as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE62]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If we desire to change those entries (all odd), to, say they are *squares plus
    one*, we can use the `numpy.putmask()` command instead, and better manage the
    memory at the same time. The following is a sample code for the `numpy.putmask()`
    command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望将这些条目（所有奇数）改为，比如说，它们是*squares plus one*，我们可以使用`numpy.putmask()`命令，同时更好地管理内存。以下是对`numpy.putmask()`命令的示例代码：
- en: '[PRE63]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output is shown as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE64]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note how the `putmask` procedure updates the values of `B`, without the explicit
    need to make a new assignment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`putmask`过程如何更新`B`的值，而不需要显式地进行新的赋值。
- en: There are three additional commands that create arrays in the form of meshes.
    The `arange` and `linspace` commands create uniformly spaced values between two
    numbers. In `arange`, we specify the spacing between elements; in `linspace`,
    we specify the desired number of elements in the mesh. The `logspace` command
    creates uniformly spaced values in a logarithmic scale between the logarithms
    of two numbers to the base 10\. The user could think of these outputs as the support
    of univariate functions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个额外的命令可以创建网格形式的数组。`arange`和`linspace`命令在两个数字之间创建均匀分布的值。在`arange`中，我们指定元素之间的间隔；在`linspace`中，我们指定网格中所需的元素数量。`logspace`命令在以10为底的两个数字的对数之间创建对数刻度的均匀分布值。用户可以将这些输出视为单变量函数的支持。
- en: 'The following is a sample code for the `numpy.arrange()` command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`numpy.arrange()`命令的示例代码：
- en: '[PRE65]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output for the preceding lines of code is shown as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下所示：
- en: '[PRE66]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following is a sample code for the `numpy.linspace()` command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`numpy.linspace()`命令的示例代码：
- en: '[PRE67]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The output is shown as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE68]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following is an example for the `numpy.logspace()` command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`numpy.logspace()`命令的示例：
- en: '[PRE69]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The output for the preceding lines of code is shown as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下所示：
- en: '[PRE70]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Finally, `meshgrid`, `mgrid`, and `ogrid` create two two-dimensional arrays
    of dimensions *n x m*, containing the elements of two given one-dimensional arrays
    of dimensions *n* and *m*. It accomplished this by repeating the values of each
    array as necessary. The user could think of these outputs as the support of functions
    of two variables.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`meshgrid`、`mgrid`和`ogrid`创建了两个二维数组，维度为*n x m*，包含两个给定的一维数组（维度为*n*和*m*）的元素。它是通过重复每个数组的值来实现的。用户可以将这些输出视为二元函数的支持。
- en: The first of these routines, `meshgrid`, accepts only arrays as input. The other
    two routines, `mgrid` and `ogrid`, accept only indexing objects (for example,
    slices). The difference between these last two is a matter of memory allocation;
    while `mgrid` allocates full arrays with all the data, `ogrid` only creates enough
    sets so that the corresponding `mgrid` command could be obtained by a proper Cartesian
    product.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序中的第一个，`meshgrid`，只接受数组作为输入。其他两个程序，`mgrid`和`ogrid`，只接受索引对象（例如，切片）。这两个最后之间的区别是内存分配的问题；`mgrid`分配包含所有数据的完整数组，而`ogrid`只创建足够的集合，以便可以通过适当的笛卡尔积获得相应的`mgrid`命令。
- en: 'Let''s take a look at the following `meshgrid` command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下`meshgrid`命令：
- en: '[PRE71]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output is shown as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE72]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s take a look at the following `mgrid` command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下`mgrid`命令：
- en: '[PRE73]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output is shown as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE74]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let''s take a look at the following `ogrid` command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下`ogrid`命令：
- en: '[PRE75]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output is shown as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE76]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We would like to finish the subsection on creations of arrays by showing one
    of the most useful routines for image processing and differential equations—the
    `tile` command. Its syntax is very simple, and is shown as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过展示图像处理和微分方程中最有用的程序之一——`tile`命令，来完成关于数组创建的小节。它的语法非常简单，如下所示：
- en: '[PRE77]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This routine presents a very effective method of tiling an array `A` following
    some repetition pattern `reps` (a `tuple`, a `list`, or another `array`) to create
    larger arrays. The following checkerboards exercise shows its potential.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序提供了一个非常有效的方法，通过重复模式`reps`（一个元组、一个列表或另一个数组）来对数组`A`进行平铺，从而创建更大的数组。以下棋盘练习展示了它的潜力。
- en: Start with two small binary arrays—`B=numpy.ones((3,3))` and `checker2by2=numpy.zeros((6,6))`
    and create a checkerboard using `tile` and as few operations as possible.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从两个小的二进制数组开始——`B=numpy.ones((3,3))` 和 `checker2by2=numpy.zeros((6,6))`，并使用 `tile`
    和尽可能少的操作创建一个棋盘。
- en: 'Let''s perform some operations using these commands:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些命令执行一些操作：
- en: '[PRE78]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The output is too long to be shown here. Please refer to the *How to open IPython
    Notebooks* section in [Chapter 1](ch01.html "Chapter 1. Introduction to SciPy"),
    *Introduction to SciPy*, to run the IPython Notebook corresponding to this chapter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 输出太长，无法在此显示。请参阅[第1章](ch01.html "第1章。SciPy简介")中“如何打开IPython笔记本”部分，*SciPy简介*，以运行与本章对应的IPython笔记本。
- en: Routines for the combination of two or more arrays
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合两个或更多数组的常规操作
- en: On occasion, we need to combine the data of two or more arrays together to solve
    a specific problem. The core NumPy libraries contain extremely efficient routines
    to carry out these computations, and we urge the reader to get familiar with them.
    They are constructed with state-of-the-art algorithms, and they make sure that
    usage of memory is minimum and the complexity optimal. Most relevant are the routines
    that operate on arrays as if they were matrices. These include matrix products
    (`outer`, `inner`, `dot`, `vdot`, `tensordot`, `cross`, and `kron`), array correlations
    (`correlate` and `convolve`), array stacking (`concatenate`, `vstack`, `hstack`,
    `column_stack`, `row_stack`, and `dstack`), and array comparison (`allclose`).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要将两个或更多数组的数据组合起来以解决特定问题。核心NumPy库包含执行这些计算的高效常规操作，我们敦促读者熟悉它们。它们使用最先进的算法构建，并确保内存使用最小化，复杂度最优化。最相关的是将数组作为矩阵操作的常规操作。这包括矩阵乘法（`outer`、`inner`、`dot`、`vdot`、`tensordot`、`cross`
    和 `kron`）、数组相关性（`correlate` 和 `convolve`）、数组堆叠（`concatenate`、`vstack`、`hstack`、`column_stack`、`row_stack`
    和 `dstack`）以及数组比较（`allclose`）。
- en: If you are well-versed in linear algebra, you will surely enjoy the matrix products
    included in NumPy. We will postpone their usage and analysis until we cover the
    SciPy module on linear algebra in [Chapter 3](ch03.html "Chapter 3. SciPy for
    Linear Algebra"), *SciPy for Linear Algebra*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你精通线性代数，你一定会喜欢NumPy中包含的矩阵乘法。我们将推迟它们的用法和分析，直到我们在[第3章](ch03.html "第3章。SciPy线性代数")中介绍SciPy模块的线性代数部分，*SciPy线性代数*。
- en: An excellent use for correlation of arrays is basic pattern-matching. For instance,
    the image in the following example (the `text` array) contains an image of a paragraph
    extracted from the Wikipedia page about Don Quixote, while the second array, `letterE`,
    contains an image of the letter *e*, which is actually a subarray obtained from
    the `text` array and represents the pattern to be matched.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 数组相关性的一个很好的用途是基本的模式匹配。例如，以下示例（`text` 数组）中的图像是从维基百科关于堂吉诃德的页面中提取的段落图像，而第二个数组 `letterE`
    包含字母 *e* 的图像，实际上是从 `text` 数组中获得的子数组，代表要匹配的模式。
- en: 'First, we load the text image and performs some preprocessing on it in order
    to bring the image to the right format (as close as possible to the grayscale
    approximation) to have better performance on this naive approach of pattern matching.
    We do this by executing the following lines of code in a Python console:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载文本图像并在其上进行一些预处理，以便将图像转换为正确的格式（尽可能接近灰度近似），以便在此简单模式匹配方法上获得更好的性能。我们通过在Python控制台中执行以下代码行来完成此操作：
- en: '[PRE79]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Second, the pattern for the letter *e* is identified:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，识别字母 *e* 的模式：
- en: '[PRE80]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next, a fraction of the maximum value of the correlation of both arrays offers
    the location of all the *e* letters contained in the array `text`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，两个数组相关性的最大值的一部分提供了数组 `text` 中包含的所有 *e* 字母的位置：
- en: '[PRE81]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The positions in the image of the pattern found for `x` are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 找到的模式在图像中 `x` 的位置如下：
- en: '[PRE82]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output is shown as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE83]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The positions in the image of the found pattern for `y` are as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 找到的模式在图像中 `y` 的位置如下：
- en: '[PRE84]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output is shown as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE85]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'There are 86 elements, which are in fact the total number of the occurrence
    of the letter *e* in the text image, as can be verified by counting them. Whether
    the matching has been done correctly can be verified graphically, superposing
    each pair `(x,y)` of the pattern on the text image, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有86个元素，实际上是在文本图像中字母 *e* 出现的总数，可以通过计数来验证。是否正确匹配可以通过图形验证，将每个模式 `(x,y)` 对的图案叠加到文本图像上，如下所示：
- en: '[PRE86]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output for `plt.axis()` is shown as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`plt.axis()`的输出如下所示：'
- en: '[PRE87]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, let''s move further in the code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在代码中进一步深入：
- en: '[PRE88]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output for `plt.axis()` is shown as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`plt.axis()`的输出如下所示：'
- en: '[PRE89]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Finally, in the following `show()` command, we display a figure that superposes
    each pair `(x,y)` of the pattern on the text image:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在下面的`show()`命令中，我们显示一个图像，该图像将图案中的每个`(x,y)`对叠加到文本图像上：
- en: '[PRE90]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This results in the following screenshot (the first image is the text and the
    next is the text where all occurrences of letter *e* have been crossed out):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下截图（第一幅图像是文本，下一幅图像是所有出现字母*e*的文本都被划掉的文本）：
- en: '![Routines for the combination of two or more arrays](img/7702OS_02_02.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![两个或多个数组合并的程序](img/7702OS_02_02.jpg)'
- en: A few words about stacking operations; we have a basic concatenation routine,
    `concatenate`, which joins a sequence of arrays together along a pre-determined
    axis. Of course, all arrays in the sequence must have the same dimensions, otherwise
    it obviously doesn't work. The rest of the stack operations are syntactic sugar
    for special cases of `concatenate`—`vstack` to glue arrays vertically, `hstack`
    to glue arrays horizontally, `dstack` to glue arrays in the third dimension, and
    so on.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 关于堆叠操作的一些话；我们有一个基本的连接程序，`concatenate`，它沿着预定的轴将一系列数组连接在一起。当然，序列中的所有数组都必须具有相同的维度，否则显然不起作用。其余的堆叠操作是`concatenate`的特殊情况的语法糖——`vstack`用于垂直连接数组，`hstack`用于水平连接数组，`dstack`用于在第三个维度上连接数组，等等。
- en: Another impressive set of routines are set operations. They allow the user to
    handle one-dimensional arrays as if they were sets and perform the Boolean operations
    of intersection (`intersect1d`), union (`union1d`), set difference (`setdiff1d`),
    and set exclusive or (`setxor1d`). The results of these set operations return
    sorted arrays. Note that it is also possible to test whether all the elements
    in one array belong to a second array (`in1d`).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组令人印象深刻的程序是集合操作。它们允许用户将一维数组视为集合，并执行交集（`intersect1d`）、并集（`union1d`）、集合差（`setdiff1d`）和集合异或（`setxor1d`）的布尔运算。这些集合操作的输出返回排序后的数组。请注意，也可以测试一个数组中的所有元素是否属于第二个数组（`in1d`）。
- en: Routines for array manipulation
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组操作的相关程序
- en: 'There is a sequence of splitting routines, designed to break up arrays into
    smaller arrays, in any given dimension—`array_split`, `split` (both are basic
    splitting along the indicated axis), `hsplit` (horizontal split), `vsplit` (vertical
    split), and `dsplit` (in the third axis). Let''s illustrate these with a simple
    example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个分割程序序列，旨在将数组分割成更小的数组，在任何给定维度上——`array_split`、`split`（两者都是沿指示轴的基本分割）、`hsplit`（水平分割）、`vsplit`（垂直分割）和`dsplit`（在第三个轴上）。让我们用一个简单的例子来说明这些：
- en: '[PRE91]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output is shown as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE92]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now, let''s perform the vertical split:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行垂直分割：
- en: '[PRE93]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The output is shown as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE94]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Applying a Python function on an array *usually* means applying the function
    to each element of the array. Note how the NumPy function `sin` works on an array,
    for example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组上应用Python函数*通常*意味着将函数应用于数组的每个元素。注意NumPy函数`sin`是如何在数组上工作的，例如：
- en: '[PRE95]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output is shown as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE96]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Note that the `sin` function was computed on each element of the array.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sin`函数是在数组的每个元素上计算的。
- en: 'This works provided the function has been properly vectorized (which is the
    case with `numpy.sin`). Notice the behavior with non-vectorized Python functions.
    Let''s define such a function for computing, for each value of `x`, the maximum
    between `x` and 100 without using any routine from the NumPy libraries:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这只有在函数已经被正确向量化（例如`numpy.sin`）的情况下才会工作。注意非向量化Python函数的行为。让我们定义一个函数，用于计算对于每个`x`值，`x`和100之间的最大值，而不使用NumPy库中的任何程序：
- en: '[PRE97]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'If we try to apply this function to the preceding array, the system raises
    an error, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将此函数应用于前面的数组，系统将引发错误，如下所示：
- en: '[PRE98]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The output is an error which is shown as:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个错误，显示如下：
- en: '[PRE99]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We need to explicitly indicate to the system when we desire to apply one of
    our functions to arrays, as well as scalars. We do that with the `vectorize` routine,
    as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要明确告诉系统，当我们想要将我们的函数应用于数组以及标量时。我们通过`vectorize`程序来完成，如下所示：
- en: '[PRE100]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The output is shown as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE101]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: For our benefit, the NumPy libraries provide a great deal of already-vectorized
    mathematical functions. Some examples are `round_`, `fix` (to round the elements
    of an array to a desired number of decimal places), and `angle` (to provide the
    angle of the elements of an array, provided they are complex numbers) and any
    basic trigonometric (`sin`, `cos`, `tan`, `sic`), exponential (`exp`, `exp2`,
    `sinh`, `cosh`), and logarithmic functions (`log`, `log10`, `log2`).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的便利，NumPy库提供了一大堆已经向量化了的数学函数。一些例子包括`round_`、`fix`（将数组元素四舍五入到所需的十进制位数），以及`angle`（提供数组元素的角，前提是它们是复数）和任何基本三角函数（`sin`、`cos`、`tan`、`sec`）、指数函数（`exp`、`exp2`、`sinh`、`cosh`）和对数函数（`log`、`log10`、`log2`）。
- en: We also have mathematical functions that treat the array as an output of multidimensional
    functions, and offer relevant computations. Some useful examples are `diff` (to
    emulate differentiation along any specified dimension, by performing discrete
    differences), `gradient` (to compute the gradient of the corresponding function),
    or `cov` (for the covariance of the array).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有将数组视为多维函数输出的数学函数，并提供相关计算。一些有用的例子包括`diff`（通过执行离散差分来模拟任何指定维度的微分），`gradient`（计算相应函数的梯度），或者`cov`（用于数组的协方差）。
- en: Sorting the whole array according to the values of the first axis is also possible
    with the `msort` and `sort_complex` routines.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`msort`和`sort_complex`例程可以根据第一轴的值对整个数组进行排序。
- en: Routines to extract information from arrays
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数组中提取信息的例程
- en: 'Most of the routines to extract information are statistical in nature, which
    include `average` (which acts exactly as the `mean` method), `median` (to compute
    the statistical median of the array on any of its dimensions, or the array as
    a whole), and computation of histograms (`histogram`, `histogram2d`, and `histogramdd`,
    depending on the dimensions of the array). The other important set of routines
    in this category deal with the concept of bins for arrays of dimension one. This
    is more easily explained by means of examples. Take the array `A=numpy.array([5,1,1,2,1,1,2,2,10,3,3,4,5])`,
    the `unique` command finds the unique values in the array and presents them as
    sorted:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数提取信息的例程都具有统计性质，包括`average`（与`mean`方法作用相同），`median`（计算数组在其任何维度上的统计中位数，或整个数组），以及直方图的计算（`histogram`、`histogram2d`和`histogramdd`，取决于数组的维度）。在这个类别中，另一组重要的例程处理一维数组的bin概念。这可以通过例子更容易地解释。以数组`A=numpy.array([5,1,1,2,1,1,2,2,10,3,3,4,5])`为例，`unique`命令找到数组中的唯一值，并以排序的方式呈现：
- en: '[PRE102]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The output is shown as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE103]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'For arrays such as `A`, in which all the entries are nonnegative integers,
    we can visualize the array `A` as a sequence of eleven bins labeled with numbers
    from 0 to 10 (the maximum value in the array). Each bin with label *n* contains
    the number of *n*''s in the array:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有条目都是非负整数的数组，如`A`，我们可以将数组`A`可视化为从0到10（数组中的最大值）的数字标签的十一个bin序列（bin）。每个标签为*n*的bin包含数组中*n*的数量：
- en: '[PRE104]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The output is shown as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE105]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'For arrays where some of the elements are not numbers (`nan`), NumPy has a
    set of routines that mimic methods to extract information, but disregard the conflicting
    elements—`nanmax`, `nanmin`, `nanargmax`, `nanargmin`, `nansum`, and so on:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些元素不是数字（`nan`）的数组，NumPy提供了一套模拟提取信息但忽略冲突元素的例程——`nanmax`、`nanmin`、`nanargmax`、`nanargmin`、`nansum`等等：
- en: '[PRE106]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The output is shown as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE107]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Let''s see the effect of `log2` on array `A`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`log2`对数组`A`的影响：
- en: '[PRE108]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The output is shown as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE109]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Let''s take a look at the `sum` and `nansum` commands in the following line
    of code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码行中的`sum`和`nansum`命令：
- en: '[PRE110]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The output is shown as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE111]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored in depth the creation and basic manipulation
    of the object array used by SciPy, as an overview of the NumPy libraries. In particular,
    we have seen the principles of slicing and masking, which simplify the coding
    of algorithms to the point of transforming an otherwise unreadable sequence of
    loops and primitive commands into an intuitive and self-explanatory set of object
    calls and methods. You also learned that the nonbasic modules in NumPy are replicated
    as modules in SciPy itself. The chapter roughly followed the same structure as
    the official NumPy reference (which the reader can access at the SciPy pages [http://docs.scipy.org/doc/numpy/reference/](http://docs.scipy.org/doc/numpy/reference/)).
    There are other good sources that cover NumPy with rigor, and we refer you to
    any of that material for a more detailed coverage of this topic.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了SciPy使用的对象数组的创建和基本操作，作为对NumPy库的概述。特别是，我们看到了切片和掩码的原则，这些原则简化了算法的编码，以至于将原本难以阅读的循环和原始命令序列转换成直观且自解释的对象调用和方法集。你还了解到，NumPy中的非基本模块在SciPy自身中也作为模块进行了复制。本章的结构大致与官方NumPy参考（读者可以在SciPy页面[http://docs.scipy.org/doc/numpy/reference/](http://docs.scipy.org/doc/numpy/reference/)上访问）相同。还有其他一些严谨地覆盖NumPy的优质资源，我们建议您查阅这些材料以获得对该主题更详细的了解。
- en: In the next five chapters, we will be accessing the commands that make SciPy
    a powerful tool in numerical computing. The structure of those chapters is basically
    a reflection of the different SciPy modules structured in an order that allows
    building applications on top of each other.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的五章中，我们将探讨使SciPy成为数值计算强大工具的命令。这些章节的结构基本上反映了SciPy中不同模块的结构，这些模块按照允许在彼此之上构建应用程序的顺序排列。
