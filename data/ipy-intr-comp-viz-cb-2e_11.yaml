- en: Chapter 11. Image and Audio Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 图像与音频处理
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Manipulating the exposure of an image
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作图像的曝光度
- en: Applying filters on an image
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对图像应用滤波器
- en: Segmenting an image
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对图像进行分割
- en: Finding points of interest in an image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像中找到兴趣点
- en: Detecting faces in an image with OpenCV
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenCV检测图像中的人脸
- en: Applying digital filters to speech sounds
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用数字滤波器于语音声音
- en: Creating a sound synthesizer in the notebook
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在笔记本中创建一个声音合成器
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we covered signal processing techniques for one-dimensional,
    time-dependent signals. In this chapter, we will see signal processing techniques
    for images and sounds.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了针对一维时间依赖信号的信号处理技术。在本章中，我们将看到针对图像和声音的信号处理技术。
- en: Generic signal processing techniques can be applied to images and sounds, but
    many image or audio processing tasks require specialized algorithms. For example,
    we will see algorithms for segmenting images, detecting points of interest in
    an image, or detecting faces. We will also hear the effect of linear filters on
    speech sounds.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通用信号处理技术可以应用于图像和声音，但许多图像或音频处理任务需要专门的算法。例如，我们将看到用于图像分割、检测图像中的兴趣点或检测人脸的算法。我们还将听到线性滤波器对语音声音的影响。
- en: '**scikit-image** is one of the main image processing packages in Python. We
    will use it in most of the image processing recipes in this chapter. For more
    on scikit-image, refer to [http://scikit-image.org](http://scikit-image.org).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**scikit-image**是Python中的主要图像处理包之一。在本章的大多数图像处理实例中，我们将使用它。有关scikit-image的更多信息，请参阅[http://scikit-image.org](http://scikit-image.org)。'
- en: We will also use **OpenCV** ([http://opencv.org](http://opencv.org)), a C++
    computer vision library that has a Python wrapper. It implements algorithms for
    specialized image and video processing tasks, but it can be a bit difficult to
    use. An interesting (and simpler) alternative is **SimpleCV** ([http://simplecv.org](http://simplecv.org)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用**OpenCV**（[http://opencv.org](http://opencv.org)），这是一个C++计算机视觉库，具有Python包装器。它实现了专门的图像和视频处理任务的算法，但使用起来可能有些困难。一个有趣的（且更简单的）替代方案是**SimpleCV**（[http://simplecv.org](http://simplecv.org)）。
- en: In this introduction, we will discuss the particularities of images and sounds
    from a signal processing point of view.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本介绍中，我们将从信号处理的角度讨论图像和声音的特点。
- en: Images
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像
- en: A **grayscale** image is a bidimensional signal represented by a function, *f*,
    that maps each pixel to an **intensity**. The intensity can be a real value between
    0 (dark) and 1 (light). In a colored image, this function maps each pixel to a
    triplet of intensities, generally, the **red**, **green**, and **blue** (**RGB**)
    components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**灰度**图像是一个二维信号，由一个函数*f*表示，该函数将每个像素映射到一个**强度**。强度可以是一个在0（暗）和1（亮）之间的实数值。在彩色图像中，该函数将每个像素映射到强度的三元组，通常是**红色**、**绿色**和**蓝色**（**RGB**）分量。'
- en: On a computer, images are digitally sampled. The intensities are no longer real
    values, but integers or floating point numbers. On one hand, the mathematical
    formulation of continuous functions allows us to apply analytical tools such as
    derivatives and integrals. On the other hand, we need to take into account the
    digital nature of the images we deal with.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机上，图像是数字化采样的。其强度不再是实数值，而是整数或浮动点数。一方面，连续函数的数学公式使我们能够应用诸如导数和积分之类的分析工具。另一方面，我们需要考虑我们处理的图像的数字特性。
- en: Sounds
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声音
- en: From a signal processing perspective, a sound is a time-dependent signal that
    has sufficient power in the hearing frequency range (about 20 Hz to 20 kHz). Then,
    according to the Nyquist-Shannon theorem (introduced in [Chapter 10](ch10.html
    "Chapter 10. Signal Processing"), *Signal Processing*), the sampling rate of a
    digital sound signal needs to be at least 40 kHz. A sampling rate of 44100 Hz
    is frequently chosen.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从信号处理的角度来看，声音是一个时间依赖的信号，在听觉频率范围内（约20 Hz到20 kHz）具有足够的功率。然后，根据奈奎斯特-香农定理（在[第10章](ch10.html
    "第10章 信号处理")，*信号处理*中介绍），数字声音信号的采样率需要至少为40 kHz。44100 Hz的采样率是常选的采样率。
- en: References
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Here are a few references:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: Image processing on Wikipedia, available at [http://en.wikipedia.org/wiki/Image_processing](http://en.wikipedia.org/wiki/Image_processing)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的图像处理，网址：[http://en.wikipedia.org/wiki/Image_processing](http://en.wikipedia.org/wiki/Image_processing)
- en: Advanced image processing algorithms, by Gabriel Peyré, available at [https://github.com/gpeyre/numerical-tours](https://github.com/gpeyre/numerical-tours)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 Gabriel Peyré 撰写的高级图像处理算法，网址为[https://github.com/gpeyre/numerical-tours](https://github.com/gpeyre/numerical-tours)
- en: Audio signal processing on Wikipedia, available at [http://en.wikipedia.org/wiki/Audio_signal_processing](http://en.wikipedia.org/wiki/Audio_signal_processing)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的音频信号处理，网址为[http://en.wikipedia.org/wiki/Audio_signal_processing](http://en.wikipedia.org/wiki/Audio_signal_processing)
- en: Particularities of the 44100 Hz sampling rate explained at [http://en.wikipedia.org/wiki/44,100_Hz](http://en.wikipedia.org/wiki/44,100_Hz)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 44100 Hz 采样率的特殊性解释在[http://en.wikipedia.org/wiki/44,100_Hz](http://en.wikipedia.org/wiki/44,100_Hz)
- en: Manipulating the exposure of an image
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操纵图像的曝光
- en: The **exposure** of an image tells us whether the image is too dark, too light,
    or balanced. It can be measured with a histogram of the intensity values of all
    pixels. Improving the exposure of an image is a basic image-editing operation.
    As we will see in this recipe, that can be done easily with scikit-image.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的**曝光**告诉我们图像是太暗、太亮还是平衡的。可以通过所有像素的强度值直方图来衡量。改善图像的曝光是一项基本的图像编辑操作。正如我们将在本篇中看到的，使用
    scikit-image 可以轻松实现。
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need scikit-image for this recipe. You will find the installation instructions
    at [http://scikit-image.org/download.html](http://scikit-image.org/download.html).
    With Anaconda, you can just type `conda install scikit-image` in a terminal.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要 scikit-image 来完成这个步骤。您可以在[http://scikit-image.org/download.html](http://scikit-image.org/download.html)找到安装说明。使用
    Anaconda，您只需在终端中输入`conda install scikit-image`。
- en: You also need to download the *Beach* dataset from the book's GitHub repository
    at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要从该书的 GitHub 仓库下载*Beach*数据集，网址为[https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Let''s import the packages:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入包：
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We open an image with matplotlib. We only take a single RGB component to have
    a grayscale image (there are better ways to convert a colored image to a grayscale
    image):'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 matplotlib 打开一幅图像。我们只取一个 RGB 分量，以获得灰度图像（有更好的方法将彩色图像转换为灰度图像）：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We create a function that displays the image along with its **histogram** of
    the intensity values (that is, the exposure):'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个函数，显示图像及其**强度值直方图**（即曝光）：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s display the image along with its histogram:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们显示图像及其直方图：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![How to do it...](img/4818OS_11_01.jpg)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作步骤...](img/4818OS_11_01.jpg)'
- en: An image and its histogram
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一幅图像及其直方图
- en: The histogram is unbalanced and the image appears overexposed (many pixels are
    too bright).
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直方图不平衡，图像看起来过曝（许多像素太亮）。
- en: 'Now, we rescale the intensity of the image using scikit-image''s `rescale_intensity`
    function. The `in_range` and `out_range` parameters define a linear mapping from
    the original image to the modified image. The pixels that are outside `in_range`
    are clipped to the extremal values of `out_range`. Here, the darkest pixels (intensity
    less than 100) become completely black (0), whereas the brightest pixels (>240)
    become completely white (255):'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用 scikit-image 的`rescale_intensity`函数重新调整图像的强度。`in_range`和`out_range`参数定义了从原始图像到修改后图像的线性映射。超出`in_range`范围的像素被剪切到`out_range`的极值。在这里，最暗的像素（强度小于100）变为完全黑色（0），而最亮的像素（>240）变为完全白色（255）：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![How to do it...](img/4818OS_11_02.jpg)'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作步骤...](img/4818OS_11_02.jpg)'
- en: A crude exposure manipulation technique
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个粗糙的曝光操作技术
- en: Many intensity values seem to be missing in the histogram, which reflects the
    poor quality of this basic exposure correction technique.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直方图中似乎缺少许多强度值，这反映了这种基本曝光校正技术的质量较差。
- en: 'We now use a more advanced exposure correction technique called **Contrast
    Limited Adaptive Histogram Equalization** (**CLAHE**):'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用一种更高级的曝光校正技术，称为**对比有限自适应直方图均衡化**（**CLAHE**）：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![How to do it...](img/4818OS_11_03.jpg)'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作步骤...](img/4818OS_11_03.jpg)'
- en: Result of the Contrast Limited Adaptive Histogram Equalization method for exposure
    correction
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对曝光校正的对比有限自适应直方图均衡化方法的结果
- en: The histogram seems more balanced, and the image now appears more contrasted.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直方图看起来更平衡，图像现在显得更加对比。
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: An image's histogram represents the distribution of the pixels' intensity values.
    It is a central tool in image editing, image processing, and computer vision.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的直方图代表像素强度值的分布。它是图像编辑、图像处理和计算机视觉中的一个核心工具。
- en: The `rescale_intensity()` function stretches or shrinks the intensity levels
    of the image. One use case is to ensure that the whole range of values allowed
    by the data type is used by the image.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`rescale_intensity()` 函数可以伸缩图像的强度级别。一个使用案例是确保图像使用数据类型允许的整个值范围。'
- en: The `equalize_adapthist()` function works by splitting the image into rectangular
    sections and computing the histogram for each section. Then, the intensity values
    of the pixels are redistributed to improve the contrast and enhance the details.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`equalize_adapthist()` 函数的工作原理是将图像分割成矩形区域，并计算每个区域的直方图。然后，像素的强度值被重新分配，以改善对比度并增强细节。'
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Here are some references:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些参考资料：
- en: Image histogram on Wikipedia, available at [http://en.wikipedia.org/wiki/Image_histogram](http://en.wikipedia.org/wiki/Image_histogram)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[图像直方图](http://en.wikipedia.org/wiki/Image_histogram) 相关内容可以在 Wikipedia 上找到。'
- en: Histogram equalization on Wikipedia, available at [http://en.wikipedia.org/wiki/Histogram_equalization](http://en.wikipedia.org/wiki/Histogram_equalization)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[直方图均衡化](http://en.wikipedia.org/wiki/Histogram_equalization) 相关内容可以在 Wikipedia
    上找到。'
- en: Adaptive histogram equalization on Wikipedia, available at [http://en.wikipedia.org/wiki/Adaptive_histogram_equalization](http://en.wikipedia.org/wiki/Adaptive_histogram_equalization)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自适应直方图均衡化](http://en.wikipedia.org/wiki/Adaptive_histogram_equalization) 相关内容可以在
    Wikipedia 上找到。'
- en: Contrast on Wikipedia, available at [http://en.wikipedia.org/wiki/Contrast_(vision)](http://en.wikipedia.org/wiki/Contrast_(vision))
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[对比度](http://en.wikipedia.org/wiki/Contrast_(vision)) 相关内容可以在 Wikipedia 上找到。'
- en: See also
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Applying filters on an image* recipe
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在图像上应用滤波器* 示例'
- en: Applying filters on an image
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图像上应用滤波器
- en: 'In this recipe, we apply filters on an image for various purposes: blurring,
    denoising, and edge detection.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们对图像应用了多种滤波器，以实现不同的目的：模糊、去噪和边缘检测。
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何运作...
- en: 'Let''s import the packages:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入相关包：
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We create a function that displays a grayscale image:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个函数来显示灰度图像：
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we load the Lena image (bundled in scikit-image). We select a single RGB
    component to get a grayscale image:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们加载 Lena 图像（包含在 scikit-image 中）。我们选择一个单一的 RGB 组件以获取灰度图像：
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![How it works...](img/4818OS_11_04.jpg)'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何运作...](img/4818OS_11_04.jpg)'
- en: 'Let''s apply a blurring **Gaussian filter** to the image:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对图像应用模糊的**高斯滤波器**：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![How it works...](img/4818OS_11_05.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何运作...](img/4818OS_11_05.jpg)'
- en: 'We now apply a **Sobel filter** that enhances the edges in the image:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应用一个**Sobel滤波器**，它增强了图像中的边缘：
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![How it works...](img/4818OS_11_06.jpg)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何运作...](img/4818OS_11_06.jpg)'
- en: We can threshold the filtered image to get a *sketch effect*. We obtain a binary
    image that only contains the edges. We use a notebook widget to find an adequate
    thresholding value; by adding the `@interact` decorator, we display a slider on
    top of the image. This widget lets us control the threshold dynamically.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以对过滤后的图像进行阈值处理，得到*素描效果*。我们得到一个只包含边缘的二值图像。我们使用笔记本小部件来找到适当的阈值值；通过添加 `@interact`
    装饰器，我们在图像上方显示一个滑块。这个小部件让我们可以动态控制阈值。
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![How it works...](img/4818OS_11_07.jpg)'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何运作...](img/4818OS_11_07.jpg)'
- en: 'Finally, we add some noise to the image to illustrate the effect of a denoising
    filter:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们向图像中添加一些噪声，以展示去噪滤波器的效果：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![How it works...](img/4818OS_11_08.jpg)'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何运作...](img/4818OS_11_08.jpg)'
- en: 'The `denoise_tv_bregman()` function implements total-variation denoising using
    the Split Bregman method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`denoise_tv_bregman()` 函数实现了使用 Split Bregman 方法的全变差去噪：'
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![How it works...](img/4818OS_11_09.jpg)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何运作...](img/4818OS_11_09.jpg)'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何运作...
- en: Many filters used in image processing are linear filters. These filters are
    very similar to those seen in [Chapter 10](ch10.html "Chapter 10. Signal Processing"),
    *Signal Processing*; the only difference is that they work in two dimensions.
    Applying a linear filter to an image amounts to performing a discrete **convolution**
    of the image with a particular function. The Gaussian filter applies a convolution
    with a Gaussian function to blur the image.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理中使用的许多滤波器都是线性滤波器。这些滤波器与[第10章](ch10.html "第10章. 信号处理")中的滤波器非常相似，*信号处理*；唯一的区别是它们在二维中工作。对图像应用线性滤波器等同于对图像与特定函数进行离散**卷积**。高斯滤波器通过与高斯函数卷积来模糊图像。
- en: The Sobel filter computes an approximation of the gradient of the image. Therefore,
    it can detect fast-varying spatial changes in the image, which generally correspond
    to edges.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Sobel滤波器计算图像梯度的近似值。因此，它能够检测图像中快速变化的空间变化，通常这些变化对应于边缘。
- en: '**Image denoising** refers to the process of removing noise from an image.
    **Total variation denoising** works by finding a *regular* image close to the
    original (noisy) image. Regularity is quantified by the **total variation** of
    the image:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像去噪**是指从图像中去除噪声的过程。**总变差去噪**通过找到一个与原始（有噪声）图像接近的*规则*图像来工作。规则性由图像的**总变差**来量化：'
- en: '![How it works...](img/4818OS_11_10.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4818OS_11_10.jpg)'
- en: The **Split Bregman method** is a variant based on the L¹ norm. It is an instance
    of **compressed sensing**, which aims to find regular and sparse approximations
    of real-world noisy measurements.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**Split Bregman方法**是基于L¹范数的变种。它是**压缩感知**的一个实例，旨在找到真实世界中有噪声测量的规则和稀疏近似值。'
- en: There's more...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Here are a few references:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: API reference of the skimage.filter module available at [http://scikit-image.org/docs/dev/api/skimage.filter.html](http://scikit-image.org/docs/dev/api/skimage.filter.html)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: skimage.filter模块的API参考，链接：[http://scikit-image.org/docs/dev/api/skimage.filter.html](http://scikit-image.org/docs/dev/api/skimage.filter.html)
- en: Noise reduction on Wikipedia, available at [http://en.wikipedia.org/wiki/Noise_reduction](http://en.wikipedia.org/wiki/Noise_reduction)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 噪声去除，Wikipedia上有介绍，链接：[http://en.wikipedia.org/wiki/Noise_reduction](http://en.wikipedia.org/wiki/Noise_reduction)
- en: Gaussian filter on Wikipedia, available at [http://en.wikipedia.org/wiki/Gaussian_filter](http://en.wikipedia.org/wiki/Gaussian_filter)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia上的高斯滤波器，链接：[http://en.wikipedia.org/wiki/Gaussian_filter](http://en.wikipedia.org/wiki/Gaussian_filter)
- en: Sobel filter on Wikipedia, available at [http://en.wikipedia.org/wiki/Sobel_operator](http://en.wikipedia.org/wiki/Sobel_operator)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sobel滤波器，Wikipedia上有介绍，链接：[http://en.wikipedia.org/wiki/Sobel_operator](http://en.wikipedia.org/wiki/Sobel_operator)
- en: Image denoising on Wikipedia, available at [http://en.wikipedia.org/wiki/Noise_reduction](http://en.wikipedia.org/wiki/Noise_reduction)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像去噪，Wikipedia上有介绍，链接：[http://en.wikipedia.org/wiki/Noise_reduction](http://en.wikipedia.org/wiki/Noise_reduction)
- en: Total variation denoising on Wikipedia, available at [http://en.wikipedia.org/wiki/Total_variation_denoising](http://en.wikipedia.org/wiki/Total_variation_denoising)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总变差去噪，Wikipedia上有介绍，链接：[http://en.wikipedia.org/wiki/Total_variation_denoising](http://en.wikipedia.org/wiki/Total_variation_denoising)
- en: The Split Bregman algorithm explained at [www.ece.rice.edu/~tag7/Tom_Goldstein/Split_Bregman.html](http://www.ece.rice.edu/~tag7/Tom_Goldstein/Split_Bregman.html)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Split Bregman算法的解释，链接：[www.ece.rice.edu/~tag7/Tom_Goldstein/Split_Bregman.html](http://www.ece.rice.edu/~tag7/Tom_Goldstein/Split_Bregman.html)
- en: See also
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Manipulating the exposure of an image* recipe
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图像曝光调整*的配方'
- en: Segmenting an image
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像分割
- en: Image segmentation consists of partitioning an image into different regions
    that share certain characteristics. This is a fundamental task in computer vision,
    facial recognition, and medical imaging. For example, an image segmentation algorithm
    can automatically detect the contours of an organ in a medical image.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图像分割包括将图像分割成具有某些特征的不同区域。这是计算机视觉、面部识别和医学成像中的一项基本任务。例如，图像分割算法可以自动检测医学图像中器官的轮廓。
- en: scikit-image provides several segmentation methods. In this recipe, we will
    demonstrate how to segment an image containing different objects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: scikit-image提供了几种分割方法。在这个配方中，我们将演示如何分割包含不同物体的图像。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s import the packages:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入相关包：
- en: '[PRE14]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We create a function that displays a grayscale image:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个显示灰度图像的函数：
- en: '[PRE15]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We get a test image bundled in scikit-image, showing various coins on a plain
    background:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用scikit-image中捆绑的测试图像，展示了几枚硬币放置在简单背景上的样子：
- en: '[PRE16]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![How to do it...](img/4818OS_11_11.jpg)'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_11_11.jpg)'
- en: The first step to segment the image is finding an intensity threshold separating
    the (bright) coins from the (dark) background. **Otsu's method** defines a simple
    algorithm to automatically find such a threshold.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分割图像的第一步是找到一个强度阈值，将（明亮的）硬币与（暗色的）背景分开。**Otsu方法**定义了一个简单的算法来自动找到这个阈值。
- en: '[PRE17]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![How to do it...](img/4818OS_11_12.jpg)'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_11_12.jpg)'
- en: The thresholded image using Otsu's method
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Otsu方法得到的阈值图像
- en: 'There appears to be a problem in the top-left corner of the image, with part
    of the background being too bright. Let''s use a notebook widget to find a better
    threshold:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像的左上角似乎存在问题，背景的一部分过于明亮。让我们使用一个笔记本小部件来找到更好的阈值：
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![How to do it...](img/4818OS_11_13.jpg)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_11_13.jpg)'
- en: The thresholded image using a manually selected threshold
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用手动选择的阈值的阈值化图像
- en: The threshold 120 looks better. The next step consists of cleaning the binary
    image by smoothing the coins and removing the border. scikit-image contains a
    few functions for these purposes.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阈值120看起来更好。下一步是通过平滑硬币并去除边界来清理二值图像。scikit-image 提供了一些功能来实现这些目的。
- en: '[PRE19]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![How to do it...](img/4818OS_11_14.jpg)'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_11_14.jpg)'
- en: The thresholded image with cleared borders
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 清理过边界的阈值化图像
- en: 'Next, we perform the segmentation task itself with the `label()` function.
    This function detects the connected components in the image and attributes a unique
    label to every component. Here, we color code the labels in the binary image:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`label()`函数执行分割任务。此函数检测图像中的连接组件，并为每个组件分配唯一标签。在这里，我们在二值图像中为标签上色：
- en: '[PRE20]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![How to do it...](img/4818OS_11_15.jpg)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_11_15.jpg)'
- en: The segmented image
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分割后的图像
- en: 'Small artifacts in the image result in spurious labels that do not correspond
    to coins. Therefore, we only keep components with more than 100 pixels. The `regionprops()`
    function allows us to retrieve specific properties of the components (here, the
    area and the bounding box):'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像中的小伪影会导致虚假的标签，这些标签并不对应硬币。因此，我们只保留大于100像素的组件。`regionprops()`函数允许我们检索组件的特定属性（在这里是面积和边界框）：
- en: '[PRE21]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we show the label number on top of each component in the original
    image:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在原始图像中每个组件上方显示标签号：
- en: '[PRE22]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![How to do it...](img/4818OS_11_16.jpg)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_11_16.jpg)'
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To clean up the coins in the thresholded image, we used **mathematical morphology**
    techniques. These methods, based on set theory, geometry, and topology, allow
    us to manipulate shapes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理阈值化图像中的硬币，我们使用了**数学形态学**技术。这些方法基于集合理论、几何学和拓扑学，使我们能够操控形状。
- en: 'For example, let''s explain **dilation** and **erosion**. First, if *A* is
    a set of pixels in an image, and *b* is a 2D vector, we denote *A[b]* the set
    *A* translated by *b* as:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，首先让我们解释**膨胀**和**腐蚀**。假设 *A* 是图像中的一组像素，*b* 是一个二维向量，我们表示 *A[b]* 为通过 *b* 平移的
    *A* 集合，如下所示：
- en: '![How it works...](img/4818OS_11_17.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4818OS_11_17.jpg)'
- en: 'Let *B* be a set of vectors with integer components. We call *B* the **structuring
    element** (here, we used a square). This set represents the neighborhood of a
    pixel. The dilation of *A* by *B* is:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *B* 为一个整数分量的向量集合。我们称 *B* 为**结构元素**（在这里我们使用了方形结构元素）。此集合表示一个像素的邻域。*A* 通过 *B*
    的膨胀操作是：
- en: '![How it works...](img/4818OS_11_18.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4818OS_11_18.jpg)'
- en: 'The erosion of *A* by *B* is:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*A*通过 *B* 的腐蚀操作是：'
- en: '![How it works...](img/4818OS_11_19.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4818OS_11_19.jpg)'
- en: A dilation extends a set by adding pixels close to its boundaries. An erosion
    removes the pixels of the set that are too close to the boundaries. The **closing**
    of a set is a dilation followed by an erosion. This operation can remove small
    dark spots and connect small bright cracks. In this recipe, we used a square structuring
    element.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 膨胀操作通过在边界附近添加像素来扩展集合。腐蚀操作移除集合中与边界过于接近的像素。**闭合**操作是先膨胀后腐蚀。这一操作可以去除小的黑点并连接小的亮裂缝。在本配方中，我们使用了一个方形结构元素。
- en: There's more...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Here are a few references:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: SciPy lecture notes on image processing available at [http://scipy-lectures.github.io/packages/scikit-image/](http://scipy-lectures.github.io/packages/scikit-image/)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关图像处理的SciPy讲义，链接：[http://scipy-lectures.github.io/packages/scikit-image/](http://scipy-lectures.github.io/packages/scikit-image/)
- en: Image segmentation on Wikipedia, available at [http://en.wikipedia.org/wiki/Image_segmentation](http://en.wikipedia.org/wiki/Image_segmentation)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的图像分割，链接：[http://en.wikipedia.org/wiki/Image_segmentation](http://en.wikipedia.org/wiki/Image_segmentation)
- en: Otsu's method to find a threshold explained at [http://en.wikipedia.org/wiki/Otsu's_method](http://en.wikipedia.org/wiki/Otsu's_method)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Otsu方法用于寻找阈值，详细解释见：[http://en.wikipedia.org/wiki/Otsu's_method](http://en.wikipedia.org/wiki/Otsu's_method)
- en: Segmentation tutorial with scikit-image (which inspired this recipe) available
    at [http://scikit-image.org/docs/dev/user_guide/tutorial_segmentation.html](http://scikit-image.org/docs/dev/user_guide/tutorial_segmentation.html)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用scikit-image进行分割教程（本配方的灵感来源）可见：[http://scikit-image.org/docs/dev/user_guide/tutorial_segmentation.html](http://scikit-image.org/docs/dev/user_guide/tutorial_segmentation.html)
- en: Mathematical morphology on Wikipedia, available at [http://en.wikipedia.org/wiki/Mathematical_morphology](http://en.wikipedia.org/wiki/Mathematical_morphology)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的数学形态学，查看 [http://en.wikipedia.org/wiki/Mathematical_morphology](http://en.wikipedia.org/wiki/Mathematical_morphology)
- en: API reference of the `skimage.morphology` module available at [http://scikit-image.org/docs/dev/api/skimage.morphology.html](http://scikit-image.org/docs/dev/api/skimage.morphology.html)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skimage.morphology`模块的API参考，查看 [http://scikit-image.org/docs/dev/api/skimage.morphology.html](http://scikit-image.org/docs/dev/api/skimage.morphology.html)'
- en: See also
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Computing connected components in an image* recipe in [Chapter 14](ch14.html
    "Chapter 14. Graphs, Geometry, and Geographic Information Systems"), *Graphs,
    Geometry, and Geographic Information Systems*
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第14章](ch14.html "第14章 图形、几何学与地理信息系统")中的*计算图像的连通分量*食谱，*图形、几何学与地理信息系统*'
- en: Finding points of interest in an image
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图像中找到兴趣点
- en: In an image, **points of interest** are positions where there might be edges,
    corners, or interesting objects. For example, in a landscape picture, points of
    interest can be located near a house or a person. Detecting points of interest
    is useful in image recognition, computer vision, or medical imaging.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像中，**兴趣点**是可能包含边缘、角点或有趣物体的位置。例如，在一幅风景画中，兴趣点可能位于房屋或人物附近。检测兴趣点在图像识别、计算机视觉或医学影像中非常有用。
- en: In this recipe, we will find points of interest in an image with scikit-image.
    This will allow us to crop an image around the subject of the picture, even when
    this subject is not in the center of the image.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用scikit-image在图像中找到兴趣点。这将使我们能够围绕图像中的主题裁剪图像，即使该主题不在图像的中心。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Download the *Child* dataset from the book's GitHub repository at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data),
    and extract it into the current directory.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的GitHub仓库下载*Child*数据集，链接：[https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)，并将其解压到当前目录。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s import the packages:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入所需的包：
- en: '[PRE23]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We create a function to display a colored or grayscale image:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个函数来显示彩色或灰度图像：
- en: '[PRE24]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We load an image:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们加载一张图像：
- en: '[PRE25]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![How to do it...](img/4818OS_11_20.jpg)'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_11_20.jpg)'
- en: 'Let''s find salient points in the image with the Harris corner method. The
    first step consists of computing the **Harris corner measure response image**
    with the `corner_harris()` function (we will explain this measure in *How it works...*).
    This function requires a grayscale image, thus we select the first RGB component:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用哈里斯角点法在图像中找到显著点。第一步是使用`corner_harris()`函数计算**哈里斯角点响应图像**（我们将在*如何工作...*中解释这个度量）。该函数需要一个灰度图像，因此我们选择第一个RGB分量：
- en: '[PRE26]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![How to do it...](img/4818OS_11_21.jpg)'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_11_21.jpg)'
- en: We see that the patterns in the child's coat are well detected by this algorithm.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们看到这个算法能很好地检测到孩子外套上的图案。
- en: 'The next step is to detect corners from this measure image, using the `corner_peaks()`
    function:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用`corner_peaks()`函数从这个度量图像中检测角点：
- en: '[PRE27]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![How to do it...](img/4818OS_11_22.jpg)'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_11_22.jpg)'
- en: 'Finally, we create a box around the corner points to define our region of interest:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在角点周围创建一个框，定义我们的兴趣区域：
- en: '[PRE28]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![How to do it...](img/4818OS_11_23.jpg)'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_11_23.jpg)'
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'Let''s explain the method used in this recipe. The first step consists of computing
    the **structure tensor** (or **Harris matrix**) of the image:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释本食谱中使用的方法。第一步是计算图像的**结构张量**（或**哈里斯矩阵**）：
- en: '![How it works...](img/4818OS_11_24.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4818OS_11_24.jpg)'
- en: Here, *I(x,y)* is the image, *I[x]* and *I[y]* are the partial derivatives,
    and the brackets denote the local spatial average around neighboring values.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*I(x,y)*是图像，*I[x]*和*I[y]*是偏导数，括号表示围绕邻近值的局部空间平均。
- en: This tensor associates a *(2,2)* positive symmetric matrix at each point. This
    matrix is used to calculate a sort of autocorrelation of the image at each point.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个张量在每个点上关联一个*(2,2)*的正对称矩阵。该矩阵用于计算图像在每个点上的自相关。
- en: 'Let ![How it works...](img/4818OS_11_31.jpg) and ![How it works...](img/4818OS_11_32.jpg)
    be the two eigenvalues of this matrix (the matrix is diagonalizable because it
    is real and symmetric). Roughly, a corner is characterized by a large variation
    of the autocorrelation in all directions, or in large positive eigenvalues ![How
    it works...](img/4818OS_11_31.jpg) and ![How it works...](img/4818OS_11_32.jpg).
    The corner measure image is defined as:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让 ![它是如何工作的...](img/4818OS_11_31.jpg) 和 ![它是如何工作的...](img/4818OS_11_32.jpg)
    成为这个矩阵的两个特征值（该矩阵是可对角化的，因为它是实数且对称的）。大致上，角点是通过各个方向的自相关变化很大来表征的，或者通过较大的正特征值 ![它是如何工作的...](img/4818OS_11_31.jpg)
    和 ![它是如何工作的...](img/4818OS_11_32.jpg)。角点度量图像定义为：
- en: '![How it works...](img/4818OS_11_25.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4818OS_11_25.jpg)'
- en: Here, *k* is a tunable parameter. *M* is large when there is a corner. Finally,
    `corner_peaks()` finds corner points by looking at local maxima in the corner
    measure image.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*k* 是一个可调节的参数。当存在角点时，*M* 会很大。最后，`corner_peaks()` 通过查找角点度量图像中的局部最大值来找到角点。
- en: There's more...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Here are a few references:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: A corner detection example with scikit-image available at [http://scikit-image.org/docs/dev/auto_examples/plot_corner.html](http://scikit-image.org/docs/dev/auto_examples/plot_corner.html)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用 scikit-image 进行角点检测的示例，链接地址：[http://scikit-image.org/docs/dev/auto_examples/plot_corner.html](http://scikit-image.org/docs/dev/auto_examples/plot_corner.html)
- en: An image processing tutorial with scikit-image available at [http://blog.yhathq.com/posts/image-processing-with-scikit-image.html](http://blog.yhathq.com/posts/image-processing-with-scikit-image.html)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用 scikit-image 进行图像处理的教程，链接地址：[http://blog.yhathq.com/posts/image-processing-with-scikit-image.html](http://blog.yhathq.com/posts/image-processing-with-scikit-image.html)
- en: Corner detection on Wikipedia, available at [http://en.wikipedia.org/wiki/Corner_detection](http://en.wikipedia.org/wiki/Corner_detection)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的角点检测，链接地址：[http://en.wikipedia.org/wiki/Corner_detection](http://en.wikipedia.org/wiki/Corner_detection)
- en: Structure tensor on Wikipedia, available at [http://en.wikipedia.org/wiki/Structure_tensor](http://en.wikipedia.org/wiki/Structure_tensor)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的结构张量，链接地址：[http://en.wikipedia.org/wiki/Structure_tensor](http://en.wikipedia.org/wiki/Structure_tensor)
- en: Interest point detection on Wikipedia, available at [http://en.wikipedia.org/wiki/Interest_point_detection](http://en.wikipedia.org/wiki/Interest_point_detection)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的兴趣点检测，链接地址：[http://en.wikipedia.org/wiki/Interest_point_detection](http://en.wikipedia.org/wiki/Interest_point_detection)
- en: API reference of the `skimage.feature` module available at [http://scikit-image.org/docs/dev/api/skimage.feature.html](http://scikit-image.org/docs/dev/api/skimage.feature.html)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skimage.feature` 模块的 API 参考，链接地址：[http://scikit-image.org/docs/dev/api/skimage.feature.html](http://scikit-image.org/docs/dev/api/skimage.feature.html)'
- en: Detecting faces in an image with OpenCV
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenCV 检测图像中的人脸
- en: '**OpenCV** (**Open Computer Vision**) is an open source C++ library for computer
    vision. It features algorithms for image segmentation, object recognition, augmented
    reality, face detection, and other computer vision tasks.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenCV**（**开放计算机视觉**）是一个开源的 C++ 库，用于计算机视觉。它包含图像分割、物体识别、增强现实、人脸检测以及其他计算机视觉任务的算法。'
- en: In this recipe, we will use OpenCV in Python to detect faces in a picture.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用 Python 中的 OpenCV 来检测图片中的人脸。
- en: Getting ready
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need OpenCV and the Python wrapper. You can find installation instructions
    on OpenCV's website, [http://docs.opencv.org/trunk/doc/py_tutorials/py_tutorials.html](http://docs.opencv.org/trunk/doc/py_tutorials/py_tutorials.html).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装 OpenCV 和 Python 的包装器。你可以在 OpenCV 的官方网站找到安装说明：[http://docs.opencv.org/trunk/doc/py_tutorials/py_tutorials.html](http://docs.opencv.org/trunk/doc/py_tutorials/py_tutorials.html)。
- en: On Windows, you can install Chris Gohlke's package, available at [www.lfd.uci.edu/~gohlke/pythonlibs/#opencv](http://www.lfd.uci.edu/~gohlke/pythonlibs/#opencv).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你可以安装 Chris Gohlke 的包，链接地址：[www.lfd.uci.edu/~gohlke/pythonlibs/#opencv](http://www.lfd.uci.edu/~gohlke/pythonlibs/#opencv)。
- en: You also need to download the *Family* dataset from the book's GitHub repository
    at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要从书本的 GitHub 仓库下载 *Family* 数据集，链接地址：[https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OpenCV is not compatible with Python 3 at the time of this writing. Therefore,
    this recipe requires Python 2.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这篇文章时，OpenCV 尚不兼容 Python 3。因此，本教程要求使用 Python 2。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we import the packages:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的包：
- en: '[PRE29]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We open the JPG image with OpenCV:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用 OpenCV 打开 JPG 图像：
- en: '[PRE30]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then, we convert it to a grayscale image using OpenCV's `cvtColor()` function.
    For face detection, it is sufficient and faster to use grayscale images.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用 OpenCV 的 `cvtColor()` 函数将其转换为灰度图像。对于人脸检测，使用灰度图像已经足够且更快速。
- en: '[PRE31]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To detect faces, we will use the **Viola–Jones object detection framework**.
    A cascade of Haar-like classifiers has been trained on many images to detect faces
    (more details are given in the next section). The result of the training is stored
    in an XML file (part of the *Family* dataset available on the book''s GitHub repository).
    We load this cascade from this XML file with OpenCV''s `CascadeClassifier` class:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检测人脸，我们将使用**Viola–Jones物体检测框架**。一个Haar-like分类器级联已经在大量图像上训练，以检测人脸（更多细节将在下一节提供）。训练的结果存储在一个XML文件中（该文件属于*Family*数据集，数据集可在本书的GitHub仓库中找到）。我们使用OpenCV的`CascadeClassifier`类从这个XML文件中加载该级联：
- en: '[PRE32]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, the `detectMultiScale()` method of the classifier detects the objects
    on a grayscale image and returns a list of rectangles around these objects:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，分类器的`detectMultiScale()`方法在灰度图像上检测物体，并返回围绕这些物体的矩形框列表：
- en: '[PRE33]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![How to do it...](img/4818OS_11_26.jpg)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![How to do it...](img/4818OS_11_26.jpg)'
- en: We see that, although all detected objects are indeed faces, one face out of
    four is not detected. This is probably due to the fact that this face is not perfectly
    facing the camera, whereas the faces in the training set were. This shows that
    the efficacy of this method is limited by the quality and generality of the training
    set.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，尽管所有检测到的物体确实是人脸，但每四张脸中就有一张没有被检测到。这可能是因为这张脸并没有完全正对摄像头，而训练集中的人脸则都是正对着摄像头的。这表明该方法的有效性受限于训练集的质量和通用性。
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Viola–Jones object detection framework works by training a cascade of boosted
    classifiers with Haar-like features. First, we consider a set of features:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Viola–Jones物体检测框架通过训练一系列使用Haar-like特征的提升分类器来工作。首先，我们考虑一组特征：
- en: '![How it works...](img/4818OS_11_27.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![How it works...](img/4818OS_11_27.jpg)'
- en: Haar-like features
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Haar-like特征
- en: A feature is positioned at a particular location and size in the image. It covers
    a small window in the image (for example, 24 x 24 pixels). The sum of all pixels
    in the black area is subtracted to the sum of the pixels in the white area. This
    operation can be done efficiently with integral images.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特征被定位在图像中的特定位置和大小。它覆盖了图像中的一个小窗口（例如24 x 24像素）。黑色区域的所有像素和白色区域的所有像素之和相减。这一操作可以通过积分图像高效地完成。
- en: Then, the set of all classifiers is trained with a boosting technique; only
    the best features are kept for the next stage during training. The training set
    contains positive and negative images (with and without faces). Although the classifiers
    yield poor performance *individually*, the cascade of boosted classifiers is both
    efficient and fast. This method is therefore well-adapted to real-time processing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，所有分类器集通过提升技术进行训练；在训练过程中，只有最好的特征会被保留下来进入下一阶段。训练集包含正负图像（有脸和没有脸的图像）。尽管每个分类器单独的表现*较差*，但是这些提升分类器的级联方式既高效又快速。因此，这种方法非常适合实时处理。
- en: The XML file has been obtained in OpenCV's package. There are multiple files
    corresponding to different training sets. You can also train your own cascade
    with your own training set.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: XML文件已从OpenCV包中获得。该文件对应多个训练集。你也可以使用自己的训练集训练自己的级联分类器。
- en: There's more...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here are a few references:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: A cascade tutorial with OpenCV (C++) available at [http://docs.opencv.org/doc/tutorials/objdetect/cascade_classifier/cascade_classifier.html](http://docs.opencv.org/doc/tutorials/objdetect/cascade_classifier/cascade_classifier.html)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个关于级联教程的OpenCV (C++)教程可在[http://docs.opencv.org/doc/tutorials/objdetect/cascade_classifier/cascade_classifier.html](http://docs.opencv.org/doc/tutorials/objdetect/cascade_classifier/cascade_classifier.html)找到
- en: Documentation to train a cascade, available at [http://docs.opencv.org/doc/user_guide/ug_traincascade.html](http://docs.opencv.org/doc/user_guide/ug_traincascade.html)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练级联的文档可在[http://docs.opencv.org/doc/user_guide/ug_traincascade.html](http://docs.opencv.org/doc/user_guide/ug_traincascade.html)找到
- en: Haar cascades library, available at [https://github.com/Itseez/opencv/tree/master/data/haarcascades](https://github.com/Itseez/opencv/tree/master/data/haarcascades)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haar级联库可在[https://github.com/Itseez/opencv/tree/master/data/haarcascades](https://github.com/Itseez/opencv/tree/master/data/haarcascades)找到
- en: OpenCV's cascade classification API reference available at [http://docs.opencv.org/modules/objdetect/doc/cascade_classification.html](http://docs.opencv.org/modules/objdetect/doc/cascade_classification.html)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV的级联分类API参考可在[http://docs.opencv.org/modules/objdetect/doc/cascade_classification.html](http://docs.opencv.org/modules/objdetect/doc/cascade_classification.html)找到
- en: The Viola–Jones object detection framework on Wikipedia, available at [http://en.wikipedia.org/wiki/Viola%E2%80%93Jones_object_detection_framework](http://en.wikipedia.org/wiki/Viola%E2%80%93Jones_object_detection_framework)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的Viola–Jones目标检测框架，网址为[http://en.wikipedia.org/wiki/Viola%E2%80%93Jones_object_detection_framework](http://en.wikipedia.org/wiki/Viola%E2%80%93Jones_object_detection_framework)
- en: Boosting or how to create one strong classifier from many weak classifiers,
    explained at [http://en.wikipedia.org/wiki/Boosting_(machine_learning)](http://en.wikipedia.org/wiki/Boosting_(machine_learning))
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升或如何从许多弱分类器创建一个强分类器，解释在[http://en.wikipedia.org/wiki/Boosting_(machine_learning)](http://en.wikipedia.org/wiki/Boosting_(machine_learning))
- en: Applying digital filters to speech sounds
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数字滤波器应用于语音
- en: In this recipe, we will show how to play sounds in the notebook. We will also
    illustrate the effect of simple digital filters on speech sounds.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将展示如何在笔记本中播放声音。我们还将说明简单数字滤波器对语音的影响。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need the **pydub** package. You can install it with `pip install pydub`
    or download it from [https://github.com/jiaaro/pydub/](https://github.com/jiaaro/pydub/).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要**pydub**包。您可以使用`pip install pydub`安装它，或从[https://github.com/jiaaro/pydub/](https://github.com/jiaaro/pydub/)下载。
- en: This package requires the open source multimedia library FFmpeg for the decompression
    of MP3 files, available at [www.ffmpeg.org](http://www.ffmpeg.org).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 该软件包需要开源多媒体库FFmpeg来解压缩MP3文件，网址为[www.ffmpeg.org](http://www.ffmpeg.org)。
- en: The code given here works with Python 3\. You will find the Python 2 version
    in the book's GitHub repository.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出的代码适用于Python 3。您可以在书的GitHub存储库中找到Python 2版本。
- en: How to do it…
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s import the packages:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入这些包：
- en: '[PRE34]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We create a Python function to generate a sound from an English sentence. This
    function uses Google''s **Text-To-Speech** (**TTS**) API. We retrieve the sound
    in the MP3 format, and convert it to the Wave format with pydub. Finally, we retrieve
    the raw sound data by removing the wave header with NumPy:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个Python函数，从英文句子生成声音。这个函数使用Google的**文本转语音**（**TTS**）API。我们以MP3格式检索声音，并用pydub将其转换为Wave格式。最后，我们通过删除NumPy中的波形头检索原始声音数据：
- en: '[PRE35]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We create a function that plays a sound (represented by a NumPy vector) in
    the notebook, using IPython''s `Audio` class:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个函数，在笔记本中播放声音（由NumPy向量表示），使用IPython的`Audio`类：
- en: '[PRE36]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s play the sound "Hello world." We also display the waveform with matplotlib:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们播放声音“Hello world.”，并使用matplotlib显示波形：
- en: '[PRE37]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![How to do it…](img/4818OS_11_28.jpg)'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/4818OS_11_28.jpg)'
- en: 'Now, we will hear the effect of a Butterworth low-pass filter applied to this
    sound (500 Hz cutoff frequency):'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将听到应用于此声音的Butterworth低通滤波器的效果（500 Hz截止频率）：
- en: '[PRE38]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![How to do it…](img/4818OS_11_29.jpg)'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/4818OS_11_29.jpg)'
- en: We hear a muffled voice.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们听到了一个沉闷的声音。
- en: 'Now, with a high-pass filter (1000 Hz cutoff frequency):'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用高通滤波器（1000 Hz截止频率）：
- en: '[PRE39]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![How to do it…](img/4818OS_11_30.jpg)'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/4818OS_11_30.jpg)'
- en: It sounds like a phone call.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 听起来像一个电话。
- en: 'Finally, we can create a simple widget to quickly test the effect of a high-pass
    filter with an arbitrary cutoff frequency:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以创建一个简单的小部件，快速测试高通滤波器的效果，带有任意截止频率：
- en: '[PRE40]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We get a slider that lets us change the cutoff frequency and hear the effect
    in real-time.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们得到一个滑块，让我们改变截止频率并实时听到效果。
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The human ear can hear frequencies up to 20 kHz. The human voice frequency band
    ranges from approximately 300 Hz to 3000 Hz.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 人耳可以听到高达20 kHz的频率。人声频带范围大约从300 Hz到3000 Hz。
- en: Digital filters were described in [Chapter 10](ch10.html "Chapter 10. Signal
    Processing"), *Signal Processing*. The example given here allows us to hear the
    effect of low- and high-pass filters on sounds.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 数字滤波器在[第10章](ch10.html "第10章。信号处理")中有描述，*信号处理*。这里给出的示例允许我们听到低通和高通滤波器对声音的影响。
- en: There's more...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Here are a few references:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: Audio signal processing on Wikipedia, available at [http://en.wikipedia.org/wiki/Audio_signal_processing](http://en.wikipedia.org/wiki/Audio_signal_processing)
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的音频信号处理，网址为[http://en.wikipedia.org/wiki/Audio_signal_processing](http://en.wikipedia.org/wiki/Audio_signal_processing)
- en: Audio filters on Wikipedia, available at [http://en.wikipedia.org/wiki/Audio_filter](http://en.wikipedia.org/wiki/Audio_filter)
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的音频滤波器，网址为[http://en.wikipedia.org/wiki/Audio_filter](http://en.wikipedia.org/wiki/Audio_filter)
- en: Voice frequency on Wikipedia, available at [http://en.wikipedia.org/wiki/Voice_frequency](http://en.wikipedia.org/wiki/Voice_frequency)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的声音频率，网址为[http://en.wikipedia.org/wiki/Voice_frequency](http://en.wikipedia.org/wiki/Voice_frequency)
- en: '**PyAudio**, an audio Python package that uses the PortAudio library, available
    at [http://people.csail.mit.edu/hubert/pyaudio/](http://people.csail.mit.edu/hubert/pyaudio/)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyAudio**，一个使用 PortAudio 库的音频 Python 包，链接在[http://people.csail.mit.edu/hubert/pyaudio/](http://people.csail.mit.edu/hubert/pyaudio/)'
- en: See also
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating a sound synthesizer in the notebook* recipe
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在笔记本中创建声音合成器*食谱'
- en: Creating a sound synthesizer in the notebook
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在笔记本中创建声音合成器
- en: In this recipe, we will create a small electronic piano in the notebook. We
    will synthesize sinusoidal sounds with NumPy instead of using recorded tones.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将在笔记本中创建一个小型电子钢琴。我们将使用 NumPy 合成正弦声音，而不是使用录制的音频。
- en: How to do it...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We import the modules:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入模块：
- en: '[PRE41]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We define the sampling rate and the duration of the notes:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义音符的采样率和持续时间：
- en: '[PRE42]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We create a function that generates and plays the sound of a note (sine function)
    at a given frequency, using NumPy and IPython''s `Audio` class:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个函数，使用 NumPy 和 IPython 的 `Audio` 类生成并播放指定频率的音符（正弦函数）声音：
- en: '[PRE43]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is the fundamental 440 Hz note:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是基础的 440 Hz 音符：
- en: '[PRE44]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we generate the note frequencies of our piano. The chromatic scale is
    obtained by a geometric progression with the common ratio *2^(1/12)*:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们生成钢琴的音符频率。十二平均律是通过一个公比为 *2^(1/12)* 的几何级数得到的：
- en: '[PRE45]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Finally, we create the piano with the notebook widgets. Each note is a button,
    and all buttons are contained in a horizontal box container. Clicking on one note
    plays a sound at the corresponding frequency. The piano layout is the same as
    the one used in the *Using interactive widgets – a piano in the notebook* recipe
    of [Chapter 3](ch03.html "Chapter 3. Mastering the Notebook"), *Mastering the
    Notebook*.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用笔记本小部件创建钢琴。每个音符是一个按钮，所有按钮都包含在一个水平框容器中。点击某个音符会播放对应频率的声音。钢琴布局与[《第 3 章》](ch03.html
    "Chapter 3. Mastering the Notebook")中的*使用交互式小部件——笔记本中的钢琴*食谱相同，*掌握笔记本*一书中的布局相同。
- en: '[PRE46]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The IPython API used here to design the layout is based on IPython 2.x; it will
    be slightly different in IPython 3.0.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此处使用的 IPython API 设计布局基于 IPython 2.x；在 IPython 3.0 中会有所不同。
- en: How it works...
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A **pure tone** is a tone with a sinusoidal waveform. It is the simplest way
    of representing a musical note. A note generated by a musical instrument is typically
    much more complex. Although the sound contains many frequencies, we generally
    perceive a musical tone (**fundamental frequency**).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯音**是具有正弦波形的音调。它是表示音乐音符的最简单方式。由乐器发出的音符通常更加复杂，尽管声音包含多个频率，但我们通常感知到的是音乐音调（**基频**）。'
- en: By generating another periodic function instead of a sinusoidal waveform, we
    would hear the same tone, but a different **timbre**. Electronic music synthesizers
    are based on this idea.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通过生成另一个周期性函数代替正弦波形，我们会听到相同的音调，但音色（**timbre**）不同。电子音乐合成器基于这个原理。
- en: There's more...
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here are a few references:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: Synthesizer on Wikipedia, available at [http://en.wikipedia.org/wiki/Synthesizer](http://en.wikipedia.org/wiki/Synthesizer)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的合成器，链接在[http://en.wikipedia.org/wiki/Synthesizer](http://en.wikipedia.org/wiki/Synthesizer)
- en: Equal temperament on Wikipedia, available at [http://en.wikipedia.org/wiki/Equal_temperament](http://en.wikipedia.org/wiki/Equal_temperament)
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的均等律，链接在[http://en.wikipedia.org/wiki/Equal_temperament](http://en.wikipedia.org/wiki/Equal_temperament)
- en: Chromatic scale on Wikipedia, available at [http://en.wikipedia.org/wiki/Chromatic_scale](http://en.wikipedia.org/wiki/Chromatic_scale)
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的音阶，链接在[http://en.wikipedia.org/wiki/Chromatic_scale](http://en.wikipedia.org/wiki/Chromatic_scale)
- en: Pure tone on Wikipedia, available at [http://en.wikipedia.org/wiki/Pure_tone](http://en.wikipedia.org/wiki/Pure_tone)
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的纯音，链接在[http://en.wikipedia.org/wiki/Pure_tone](http://en.wikipedia.org/wiki/Pure_tone)
- en: Timbre on Wikipedia, available at [http://en.wikipedia.org/wiki/Timbre](http://en.wikipedia.org/wiki/Timbre)
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的音色，链接在[http://en.wikipedia.org/wiki/Timbre](http://en.wikipedia.org/wiki/Timbre)
- en: See also
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Applying digital filters to speech sounds* recipe
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用数字滤波器于语音声音*食谱'
- en: The *Using interactive widgets – a piano in the notebook* recipe in [Chapter
    3](ch03.html "Chapter 3. Mastering the Notebook"), *Mastering the Notebook*
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[《第 3 章》](ch03.html "Chapter 3. Mastering the Notebook")中的*使用交互式小部件——笔记本中的钢琴*食谱，*掌握笔记本*。'
