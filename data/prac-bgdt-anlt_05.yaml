- en: Big Data Mining with NoSQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NoSQL进行大数据挖掘
- en: The term **NoSQL** was first used by Carlo Strozzi, who, in 1998, released the
    Strozzi NoSQL opensource relational database. In the late 2000s, new paradigms
    in database architecture emerged, many of which did not adhere to the strict constraints
    required of relational database systems. These databases, due to their non-conformity
    with standard database conventions such as ACID compliance, were soon grouped
    under a broad category known as NoSQL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**NoSQL**最初是由Carlo Strozzi使用的，他在1998年发布了Strozzi NoSQL开源关系数据库。在2000年代末，数据库架构中出现了新的范式，其中许多范式不符合关系数据库系统所需的严格约束。由于这些数据库不符合ACID兼容性等标准数据库约定，它们很快被归为一个称为NoSQL的广泛类别。
- en: Each NoSQL database claims to be optimal for certain use cases. Although few
    of them would fit the requirements to be a general-purpose database management
    system, they all leverage a few common themes across the spectrum of NoSQL systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个NoSQL数据库都声称对某些用例最优。虽然其中很少有适合成为通用数据库管理系统的要求，但它们都在整个NoSQL系统范围内利用了一些共同的主题。
- en: In this chapter, we will visit some of the broad categories of NoSQL database
    management systems. We will discuss the primary drivers that initiated the migration
    to NoSQL database systems and how such databases solved specific business needs
    that led to their widespread adoption, and conclude with a few hands-on NoSQL
    exercises.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论NoSQL数据库管理系统的一些广泛类别。我们将讨论引发迁移到NoSQL数据库系统的主要驱动因素，以及这些数据库如何解决导致它们广泛采用的特定业务需求，并最后进行一些NoSQL实际练习。
- en: 'The topics covered in this chapter include:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括：
- en: Why NoSQL?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择NoSQL？
- en: NoSQL databases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL数据库
- en: In-memory databases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存数据库
- en: Columnar databases
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列式数据库
- en: Document-oriented databases
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向文档的数据库
- en: Key-value databases
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值数据库
- en: Graph databases
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据库
- en: Other NoSQL types and summary
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他NoSQL类型和总结
- en: Hands-on exercise on NoSQL systems
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL系统的实际练习
- en: Why NoSQL?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择NoSQL？
- en: 'The term NoSQL generally means *Not Only SQL*: that is, the underlying database
    has properties that are different to those of common and traditional database
    systems. As such, there is no clear distinction that qualifies a database as NoSQL,
    other than the fact that they do not provide the characteristics of ACID compliance.
    As such, it would be helpful to understand the nature of ACID properties that
    have been the mainstay of database systems for many decades, as well as discuss,
    in brief, the significance of BASE and CAP, two other terminologies central to
    databases today.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 术语NoSQL通常意味着*不仅仅是SQL*：也就是说，底层数据库具有与常见和传统数据库系统不同的属性。因此，除了它们不提供ACID兼容性的特征之外，没有明确的区分资格数据库作为NoSQL的标准。因此，了解ACID属性的性质将有助于理解数据库系统多年来的主要特点，以及简要讨论BASE和CAP的重要性，这两个术语是当今数据库的核心术语。
- en: The ACID, BASE, and CAP properties
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ACID、BASE和CAP属性
- en: Let's first proceed with ACID and SQL.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论ACID和SQL。
- en: ACID and SQL
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ACID和SQL
- en: 'ACID stands for atomicity, consistency, isolation, and durability:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ACID代表原子性、一致性、隔离性和持久性：
- en: '**Atomicity**: This indicates that database transactions either execute in
    full or do not execute at all. In other words, either all transactions should
    be committed, that is, persisted in their entirety, or not committed at all. There
    is no scope for a partial execution of a transaction.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：这表示数据库事务要么完全执行，要么根本不执行。换句话说，要么所有事务都应该被提交，即完全持久化，要么根本不提交。没有部分执行事务的余地。'
- en: '**Consistency**: The constraints on the data, that is, the rules that determine
    data management within a database, will be consistent throughout the database.
    Different instances will not abide by rules that are any different to those in
    other instances of the database.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：对数据的约束，即确定数据库内数据管理的规则，将在整个数据库中保持一致。不同的实例不会遵守与数据库其他实例不同的规则。'
- en: '**Isolation**: This property defines the rules of how concurrent operations
    (transactions) will read and write data. For example, if a certain record is being
    updated while another process reads the same record, the isolation level of the
    database system will determine which version of the data would be returned back
    to the user.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：此属性定义了并发操作（事务）如何读取和写入数据的规则。例如，如果某个记录正在被更新，而另一个进程读取同一条记录，数据库系统的隔离级别将决定返回给用户的数据版本。'
- en: '**Durability**: The durability of a database system generally indicates that
    committed transactions will remain persistent even in the event of a system failure.
    This is generally managed by the use of transaction logs that databases can refer
    to during recovery.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：数据库系统的持久性通常表示已提交的事务即使在系统故障的情况下也将保持持久。这通常通过数据库可以在恢复期间参考的事务日志来管理。'
- en: 'The reader may observe that all the properties defined here relate primarily
    to database transactions. A **transaction** is a unit of operation that abides
    by the aforementioned rules and makes a change to the database. For example, a
    typical cash withdrawal from an ATM may have the following logical pathway:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能会注意到这里定义的所有属性主要与数据库事务有关。**事务**是遵守上述规则并对数据库进行更改的操作单元。例如，从ATM机中典型的取款可能有以下逻辑路径：
- en: User withdraws cash from an ATM
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户从ATM机中取款
- en: The bank checks the current balance of the user
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 银行检查用户的当前余额
- en: The database system deducts the corresponding amount from the user's account
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库系统从用户的账户中扣除相应的金额
- en: The database system updates the amount in the user's account to reflect the
    change
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库系统更新用户账户中的金额以反映变化
- en: As such, most databases in popular use prior to the mid-1990s, such as Oracle,
    Sybase, DB2, and others, were optimized for recording and managing transactional
    data. Until this time, most databases were responsible for managing transactional
    data. The rapid growth of the internet in the mid-90s led to new types of data
    that did not necessarily require the strict ACID compliance requirements. Videos
    on YouTube, music on Pandora, and corporate email records are all examples of
    use cases where a a transactional database does not add value beyond simply functioning
    as a technology layer for storing data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在1990年代中期之前广泛使用的大多数数据库，如Oracle、Sybase、DB2等，都针对记录和管理事务数据进行了优化。直到这个时候，大多数数据库都负责管理事务数据。90年代中期互联网的快速增长导致出现了新类型的数据，这些数据不一定需要严格的ACID兼容性要求。YouTube上的视频、Pandora上的音乐和企业电子邮件记录都是事务数据库不会增加价值的用例的例子，除了作为存储数据的技术层之外。
- en: The BASE property of NoSQL
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL的BASE属性
- en: By the late 2000s, data volume had surged and it was apparent that a new alternative
    model was required in order to manage the data. This new model, called BASE, became
    a foundational topic that replaced ACID as the preferred model of database management
    systems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到了2000年代末，数据量激增，显然需要一种新的替代模型来管理数据。这种新模型称为BASE，成为取代ACID成为首选数据库管理系统模型的基础主题。
- en: '**BASE** stands for **B**asically **A**vailable **S**oft-state **E**ventually
    consistency. This implies that the database is *basically* available for use most
    of the time; that is, there can be periods during which the services are unavailable
    (and hence additional redundancy measures should be implemented). *Soft-state*
    means that the state of the system cannot be guaranteed - different instances
    of the same data might have different content as it may not have yet captured
    recent updates in another part of the cluster. Finally, *eventually* consistent
    implies that although the database might not be in the same state at all times,
    it will eventually get to the same state; that is, become *consistent*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**BASE**代表**B**asically **A**vailable **S**oft-state **E**ventually consistency。这意味着数据库基本上大部分时间都可以使用；也就是说，可能会有一段时间服务不可用（因此应该实施额外的冗余措施）。*Soft-state*意味着系统的状态不能保证
    - 相同数据的不同实例可能具有不同的内容，因为它可能还没有捕获集群另一部分的最新更新。最后，*eventually* consistent意味着尽管数据库可能并非始终处于相同状态，但最终会达到相同状态；也就是说，变得*consistent*。'
- en: The CAP theorem
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CAP定理
- en: 'First introduced in the late 1990s by Eric Allen Brewer, the CAP theorem categorizes
    the constraints, or more generally the characteristics, of distributed database
    systems. In brief, the CAP theorem postulates that strictly speaking, database
    systems can guarantee only two of the three properties defined by CAP, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: CAP定理由Eric Allen Brewer于1990年代末首次提出，它对分布式数据库系统的约束或更一般地说特征进行了分类。简而言之，CAP定理假设严格来说，数据库系统只能保证CAP定义的三个属性中的两个。
- en: '**Consistency**: The data should be consistent across all instances of the
    database and hence, when queried, should provide a coherent result across all
    nodes'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：数据应该在数据库的所有实例中保持一致，因此，在查询时应该在所有节点上提供一致的结果'
- en: '**Availability**: Irrespective of the state of any individual node, the system
    will always respond with a result upon a query being executed (whether or not
    it is the most recent commit)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：无论任何单个节点的状态如何，系统在执行查询时始终会响应结果（无论是否是最新提交）'
- en: '**Partition tolerance**: This implies that when nodes are separated across
    a network, the system should continue to function normally even if any node loses
    interconnectivity to another node'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区容错性**：这意味着当节点在网络上分离时，系统应该继续正常运行，即使任何节点失去与另一个节点的互联性'
- en: It might be evident from this that, since in a cluster nodes will be connected
    over a *network* which, by nature can be disrupted, partition tolerance has to
    be guaranteed in order for the system to continue performing normally. In this
    case, the contention lies with choosing between consistency and availability.
    For example, if the system has to be consistent; that is, show the most recent
    commit across all nodes, all the nodes cannot be *available* all at the same time
    as some nodes might not have the most recent commit. In this case, a query on
    a new update will not execute until all nodes have been updated with the new data.
    In case of availability, in similar terms, we cannot guarantee consistency, since
    to be available at all times means that some nodes will not have the same data
    as another node if a new update has not been written onto the respective node.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点可以看出，在集群中，节点将通过*网络*连接，而网络本质上是可以中断的，因此必须保证分区容错性，以便系统能够继续正常运行。在这种情况下，争议在于选择一致性和可用性之间。例如，如果系统必须保持一致；也就是说，在所有节点上显示最新的提交，所有节点不能同时*可用*，因为一些节点可能没有最新的提交。在这种情况下，对新更新的查询将不会执行，直到所有节点都已更新为新数据。在可用性的情况下，以类似的术语，我们无法保证一致性，因为始终可用意味着一些节点将不具有与另一个节点相同的数据，如果新的更新尚未写入到相应的节点上。
- en: There is a great deal of confusion as well as contention between deciding on
    whether to ensure consistency or to ensure availability, and as such databases
    have been categorized as being either **CP** or **AP**. For the purpose of this
    exercise, we need not get caught up in the terminologies as that would lead to
    a rather abstract and philosophical discussion. The information on the aforementioned
    terminologies has been primarily provided to reflect upon some of the foundational
    theories driving the development of databases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是确保一致性还是确保可用性之间存在很大的混乱和争议，因此数据库被分类为**CP**或**AP**。对于这个练习，我们不需要陷入术语，因为那将导致一场相当抽象和哲学的讨论。上述术语的信息主要是为了反映一些驱动数据库开发的基础理论。
- en: The need for NoSQL technologies
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL技术的需求
- en: While most database systems were initially designed to manage transactions,
    the growth of internet-related technologies and new types of data that did not
    require the strict puritan nature of transactional systems necessitated the development
    of alternative frameworks.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数数据库系统最初是为了管理事务而设计的，但互联网相关技术的增长和不需要事务系统严格净化性质的新类型数据的增长，促使了替代框架的发展。
- en: 'For instance, storing the following types of data does not necessarily require
    a complex *transactional database*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，存储以下类型的数据不一定需要复杂的*事务性数据库*：
- en: Emails
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件
- en: Media such as audio/video files
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体文件，如音频/视频文件
- en: Social network messages
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交网络消息
- en: Website HTML pages
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站HTML页面
- en: Many others
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多其他类型的数据
- en: 'Additionally, the increase in users, and as a consequence, data volume, signaled
    the need for developing more robust architectures with the following characteristics:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用户数量的增加，以及因此而产生的数据量，表明需要开发具有以下特点的更加健壮的架构：
- en: Scalable to manage ever increasing data volume
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展以管理不断增加的数据量
- en: Leverage commodity hardware to decrease dependency on expensive hardware
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用商品硬件减少对昂贵硬件的依赖
- en: Provide distributed processing capability across multiple nodes to process large-scale
    datasets
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供跨多个节点的分布式处理能力，以处理大规模数据集
- en: Be fault-tolerant/provide high availability to handle node and site failures
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有容错能力/提供高可用性以处理节点和站点故障
- en: Scalable implies that the system can accommodate the increase in data volume
    by increasing the number of nodes, namely, by scaling horizontally. Further, increasing
    the number of nodes should have minimal impact on the performance of the system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展意味着系统可以通过增加节点数量（即横向扩展）来容纳数据量的增加。此外，增加节点数量对系统性能的影响应该最小。
- en: Fault-tolerant implies that the system should be able to handle node failures,
    which won't be uncommon in a large distributed system with hundreds if not thousands
    of nodes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 容错意味着系统应该能够处理节点故障，在一个拥有数百甚至数千个节点的大型分布式系统中，这种情况并不罕见。
- en: This led to the development of various groundbreaking and influential systems,
    of which perhaps the most notable were Google Bigtable and Amazon Dynamo.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了各种具有突破性和影响力的系统的发展，其中最显著的可能是Google Bigtable和Amazon Dynamo。
- en: Google Bigtable
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Bigtable
- en: 'Bigtable was a project that was initiated in 2004 to manage both scalability
    and performance of the data used for various projects at Google. The seminal paper
    that describes the characteristics of the system was released in 2006 ([https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf](https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf)) titled
    *Bigtable: A Distributed Storage System for Structured Data*. In essence, Bigtable
    was a *column-store* (more on this later) where each value could be uniquely identified
    using a row key, a column key, and a timestamp. It was one of the first mainstream
    databases that epitomized the benefits of storing data in a columnar format rather
    than using the more common row-based layout. Although columnar databases such
    as kdb+ and Sybase IQ existed prior to Bigtable, the use of the method by an industry
    leader to manage petabyte-scale information brought the concept into the limelight.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'Bigtable是一个于2004年启动的项目，旨在管理Google各种项目中使用的数据的可扩展性和性能。描述该系统特性的开创性论文于2006年发布（[https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf](https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf)），标题为*Bigtable:
    A Distributed Storage System for Structured Data*。实质上，Bigtable是一个*列存储*（稍后详述），其中每个值可以使用行键、列键和时间戳唯一标识。它是最早体现将数据存储在列格式而不是使用更常见的基于行的布局的数据库之一。尽管在Bigtable之前存在诸如kdb+和Sybase
    IQ之类的列式数据库，但行业领先者使用该方法来管理PB级别信息的概念将该概念推上了舞台。'
- en: 'The official site of Bigtable summarizes the key-value proposition:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Bigtable的官方网站总结了键值主张：
- en: Bigtable is designed to handle massive workloads at consistent low latency and
    high throughput, so it's a great choice for both operational and analytical applications,
    including IoT, user analytics, and financial data analysis.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Bigtable旨在以一致的低延迟和高吞吐量处理大规模工作负载，因此它是操作和分析应用的绝佳选择，包括物联网、用户分析和金融数据分析。
- en: Since the introduction of Bigtable, several other NoSQL databases adopted the
    convention of columnar data layout; most notably HBase and Accumulo, which are
    both Apache projects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Bigtable推出以来，其他几个NoSQL数据库也采用了列式数据布局的惯例；其中最著名的是HBase和Accumulo，它们都是Apache项目。
- en: The Bigtable solution is today available for use at [https://cloud.google.com/bigtable/](https://cloud.google.com/bigtable/)
    where it can be purchased on a subscription basis. The fee for smaller amounts
    of data is quite nominal and reasonable, whereas larger installations would require
    more extensive implementations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Bigtable解决方案如今可以在[https://cloud.google.com/bigtable/](https://cloud.google.com/bigtable/)上使用，并可以按订阅方式购买。较小数据量的费用相当低廉和合理，而更大的安装则需要更广泛的实施。
- en: Amazon Dynamo
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Amazon Dynamo
- en: Shortly after Google announced Bigtable, Amazon followed with the announcement
    of its internal Dynamo database at the 21st ACM Symposium on Operating Systems
    Principles held in October, 2007 ([http://www.sosp2007.org](http://www.sosp2007.org)).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 就在Google宣布Bigtable不久之后，亚马逊在2007年10月举办的第21届操作系统原理研讨会上宣布了其内部Dynamo数据库（[http://www.sosp2007.org](http://www.sosp2007.org)）。
- en: In the paper, now available on Werner Vogels' site at [http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf](http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf),
    Amazon described a key-value store called Dynamo that was used to power some of
    Amazon's most critical internal services such as S3 on AWS. The paper brought
    to bear some key concepts such as key-value storage, consistent hashing, and vector
    clocks, among others, that were implemented in Dynamo.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇论文中，亚马逊描述了一种名为Dynamo的键值存储，该论文现在可以在Werner Vogels的网站上找到[http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf](http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf)，Dynamo被用于支持亚马逊AWS上的一些最关键的内部服务，如S3。该论文提出了一些关键概念，如键值存储、一致性哈希和向量时钟等，这些概念在Dynamo中得到了实现。
- en: Thus, Dynamo offered an alternative to Bigtable's columnar storage for large-scale
    datasets by introducing a fundamentally different method that leveraged key-value
    associations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Dynamo为大规模数据集的列存储提供了一种替代方案，引入了一种基本不同的方法，利用了键值关联。
- en: In the next few sections, we will discuss the various types of NoSQL technologies
    and how each of them has characteristics that make them optimal for certain use
    cases. NoSQL has ushered in a paradigm shift in how we treat databases, and has
    provided a much-needed alternative view to data management at a scale that was
    not feasible previously.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论各种类型的NoSQL技术，以及它们各自具有使它们对某些用例最优的特性。NoSQL已经引领了我们对待数据库的范式转变，并为以前不可行的规模提供了急需的数据管理替代视图。
- en: NoSQL databases
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL数据库
- en: 'In our discussion of NoSQL types and databases, we will primarily focus on
    the following characteristics of NoSQL databases:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论NoSQL类型和数据库时，我们将主要关注NoSQL数据库的以下特性：
- en: In-memory databases
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存数据库
- en: Columnar databases
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列式数据库
- en: Document-oriented databases
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向文档的数据库
- en: Key-value databases
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值数据库
- en: Graph databases
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据库
- en: Other NoSQL types and summary
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他NoSQL类型和总结
- en: Most types of NoSQL used in the industry today fall into one or more of these
    categories. The next few sections will discuss the high-level properties of each
    of these NoSQL offerings, their main advantages, and products in the market that
    fall into the respective categories.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 今天在行业中使用的大多数NoSQL类型都属于这些类别中的一个或多个。接下来的几节将讨论每种NoSQL产品的高级特性、它们的主要优势以及市场上属于各自类别的产品。
- en: In-memory databases
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存数据库
- en: '**In-memory databases**, as the name implies, leverage the computer memory;
    that is, the RAM, to store datasets. Before we look into how in-memory databases
    work, it would be worthwhile to recollect how data transfer happens in a typical
    computer:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存数据库**，顾名思义，利用计算机内存，即RAM，来存储数据集。在我们研究内存数据库如何工作之前，值得回顾一下典型计算机中数据传输是如何发生的：'
- en: '![](img/6a7357ec-76ba-4ba4-a9b8-957b76539cb5.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a7357ec-76ba-4ba4-a9b8-957b76539cb5.png)'
- en: Simple Data Flow Computer Hierarchy
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 简单数据流计算机层次结构
- en: As shown in the preceding image, data traverses from disk to memory to the CPU.
    This is a very high-level generalization of the exact process as there are conditions
    under which the CPU does not need to send an instruction to read data from memory
    (such as when the data is already present in the CPU L2 Cache - a part of the
    CPU that contains memory reserved for caching data), but fundamentally the process
    is linear between the CPU, RAM, and disk.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，数据从磁盘到内存到CPU。这是对确切过程的非常高级的概括，因为在CPU不需要发送指令从内存读取数据的条件下（例如当数据已经存在于CPU L2缓存中
    - 这是CPU中包含用于缓存数据的内存的一部分），但从根本上讲，CPU、RAM和磁盘之间的过程是线性的。
- en: Data that is stored on disk can be transferred to the memory at a certain rate
    that is dependent on the I/O (Input/Output) throughput of the disk. It takes approximately
    10-20 milliseconds (ms) to access data from disk. While the exact number varies
    depending on the size of the data, the minimum seek time (time for the disk to
    find the location of the data) in itself is approximately 10-15 ms. Compare this
    with the time it takes to fetch data from memory, which is approximately 100 nanoseconds.
    Finally, it takes approximately 7 ns to read data from the CPU L2 Cache.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在磁盘上的数据可以以取决于磁盘的I/O（输入/输出）吞吐量的一定速率转移到内存。从磁盘访问数据大约需要10-20毫秒（ms）。虽然确切的数字取决于数据的大小，但最小的寻道时间（磁盘找到数据位置所需的时间）本身大约是10-15毫秒。将这与从内存获取数据所需的时间相比，大约是100纳秒。最后，从CPU
    L2缓存读取数据大约需要7纳秒。
- en: To put this into perspective, the disk access time of 15 milliseconds, namely,
    15,000,000 nanoseconds is 150,000 times *slower* than the time it takes to access
    data from memory. In other words, data that is already present in memory can be
    read at an astounding 150 thousand times faster relative to disk. This is essentially
    true of reading random data. The time to read sequential data is arguably less
    sensational, but still nearly an order of magnitude faster.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形象地说明这一点，15毫秒的磁盘访问时间，即15,000,000纳秒，比从内存访问数据所需的时间慢150,000倍。换句话说，相对于磁盘，已经存在于内存中的数据可以以惊人的速度读取，快150,000倍。这基本上是读取随机数据的情况。读取顺序数据的时间可能不那么引人注目，但仍然快近一个数量级。
- en: If the disk and RAM were represented as cars, the RAM *car* would have gone
    all the way to the moon and be on its way back in the time it would take the disk
    car to go barely two miles. That is how large the difference is.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将磁盘和RAM表示为汽车，RAM *汽车*在磁盘汽车只能勉强行驶两英里的时间内已经到达月球并且正在返回的路上。这就是差距有多大。
- en: Hence, it is natural to conclude from this that if the data were stored in RAM,
    especially in the case of larger datasets, the access time would be dramatically
    lower, and consequently the time to process the data (at least on the I/O level)
    would be significantly reduced.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从这个自然地得出结论，如果数据存储在RAM中，特别是在较大数据集的情况下，访问时间将大大降低，因此数据处理的时间（至少在I/O级别上）将显着减少。
- en: Traditionally, all data in terms of databases was stored on disk. With the advent
    of the internet, the industry started leveraging *memcached,* which provided a
    means to store data in key-value pairs in memory via an API. For example, it was,
    and still is, common for MySQL databases to leverage the memcached API to cache
    objects in memory to optimize read speeds as well as reduce the load on the primary
    (MySQL) database.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，所有数据库数据都存储在磁盘上。随着互联网的出现，行业开始利用*memcached*，它提供了一种通过API将数据以键值对的形式存储在内存中的方法。例如，MySQL数据库通常使用memcached
    API来将对象缓存在内存中，以优化读取速度并减少对主要（MySQL）数据库的负载。
- en: However, as data volumes started to increase, the complexity of using the database
    and memcached method started to take it's toll, and databases that were exclusively
    designed to store data in memory (and sometimes both on disk and in memory) were
    being developed at a rapid pace.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着数据量的增加，使用数据库和memcached方法的复杂性开始显现，专门设计用于在内存中存储数据（有时同时存储在磁盘和内存中）的数据库正在迅速发展。
- en: As a result, in-memory databases such as Redis started replacing memcached as
    the fast cache store for driving websites. In the case of Redis, although the
    data would be held in memory as key-value pairs, there was an option to persist
    the data on disk. This differentiated it from solutions such as memcached that
    were strictly memory caches.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，内存数据库（如Redis）开始取代memcached成为驱动网站的快速缓存存储。在Redis的情况下，尽管数据将以键值对的形式存储在内存中，但也有选项将数据持久化到磁盘上。这使其与严格的内存缓存解决方案（如memcached）有所区别。
- en: 'The primary drivers of the move towards in-memory databases can be summarized
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 推动向内存数据库转变的主要因素可以总结如下：
- en: Complexity of managing increasing volumes of data such as web traffic by the
    traditional, for example, MySQL + memcached combination
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过传统的MySQL + memcached组合等方式来管理不断增加的数据量的复杂性，例如网站流量
- en: Reduced RAM costs, making it more affordable to purchase larger sizes
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低了RAM成本，使购买更大容量的内存更加经济
- en: Overall industry drive towards NoSQL technologies that led to increased focus
    and community participation towards the development of newer, innovative database
    platforms
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个行业都在朝着NoSQL技术发展，这导致了对新型创新数据库平台的增加关注和社区参与。
- en: Faster data manipulation in memory provided a means to reduce I/O overhead in
    situations that demanded ultra-fast, low-latency processing of data
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存中更快的数据操作提供了一种减少I/O开销的方法，这在需要超快速、低延迟处理数据的情况下非常重要
- en: 'Today, some of the leading options for databases that provide in-memory capabilities
    in the industry include:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，行业中提供内存功能的数据库的主要选择包括：
- en: '| **Open source** | **Commercial** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **开源** | **商业** |'
- en: '| Redis | Kdb+ |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| Redis | Kdb+ |'
- en: '| memcacheDB | Oracle TimesTen |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| memcacheDB | Oracle TimesTen |'
- en: '| Aerospike | SAP HANA |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| Aerospike | SAP HANA |'
- en: '| VoltDB | HP Vertica |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: VoltDB | HP Vertica
- en: '| Apache Ignite | Altibase |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| Apache Ignite | Altibase |'
- en: '| Apache Geode | Oracle Exalytics |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| Apache Geode | Oracle Exalytics |'
- en: '| MonetDB | MemSQL |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| MonetDB | MemSQL |'
- en: Note that some of these support hybrid architectures whereby data can reside
    in memory as well as on disk. In general, data would be transferred from memory
    to disk for persistence. Also, note that some commercial in-memory databases offer
    community editions that can be downloaded and used at no charge within the terms
    of the licenses applicable to the respective solution. In these cases, they are
    both open source as well as commercial.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，其中一些支持混合架构，数据可以同时存储在内存和磁盘中。一般来说，数据会从内存传输到磁盘以实现持久化。此外，一些商业内存数据库提供可以根据各自解决方案适用的许可证条款免费下载和使用的社区版本。在这些情况下，它们既是开源的，也是商业的。
- en: Columnar databases
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列式数据库
- en: Columnar databases have existed since the 90s, but came to prominence after
    the release of Google Bigtable as mentioned earlier. They are, in essence, a method
    of storing data that is optimized for querying very large volumes of data in a
    fast and efficient manner relative to row-based/tuple-based storage.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列式数据库自90年代以来就存在，但在谷歌Bigtable发布后变得更加突出。它们本质上是一种存储数据的方法，可以以相对于基于行/元组的存储方式更快速和高效地查询非常大量的数据。
- en: The benefits of columnar databases, or more concretely storing each column of
    data independently, can be illustrated with a simple example.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列式数据库的好处，或者更具体地说，独立存储每列数据，可以通过一个简单的例子来说明。
- en: Consider a table consisting of 100 million household addresses and phone numbers.
    Consider also a simple query that requires the user to find the number of households
    in the state of New York, in the city of Albany, built after 1990\. We'll create
    a hypothetical table to illustrate the difference in querying the data row by
    row versus column by column.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含1亿个家庭地址和电话号码的表。同时考虑一个简单的查询，要求用户找到纽约州Albany市中1990年后建造的家庭数量。我们将创建一个假设的表来说明按行和按列查询数据的差异。
- en: '**Hardware characteristics**:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬件特性**：'
- en: 'Average disk read speed: 200 MB per second'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 平均磁盘读取速度：每秒200 MB
- en: '**Database characteristics**:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库特性**：'
- en: 'Table name: `housedb`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表名：`housedb`
- en: Total rows = 100 million
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总行数=1亿
- en: Total rows with State NY = Two million
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纽约州的总行数=两百万
- en: Total rows with State NY and City Albany = 10,000
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有纽约州Albany市的总行数=10,000
- en: Total rows with State NY and City Albany and YearBuilt > 1990 = 500
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有纽约州Albany市和YearBuilt > 1990的总行数= 500
- en: '**Data size**:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据大小**：'
- en: 'Let us assume that the size of each of the data of each row is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每行数据的大小如下：
- en: PlotNumber, YearBuilt each = 8 bytes = total 16 bytes
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PlotNumber，YearBuilt各= 8字节=总共16字节
- en: Owner, Address, State and City each = 12 bytes = Total 48 bytes
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有者，地址，州和城市各= 12字节=总共48字节
- en: Net size in bytes of each row = 16 + 48 = 64 bytes
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行的净大小（字节）= 16 + 48 = 64字节
- en: Note that the actual size will be higher, as there are several other considerations
    such as indexing and other table optimizations and related overheads that we won't
    consider here for the sake of simplicity.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，实际大小将更大，因为还有其他考虑因素，如索引和其他表优化以及相关的开销，出于简单起见，我们不会在这里考虑。
- en: We will also assume that the columnar database maintains an implicit row index
    that permits querying the data at certain indices in each column *vector*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将假设列式数据库维护了一个隐式的行索引，允许在每个列*向量*中的特定索引处查询数据。
- en: 'The following table shows the first 4 records:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表显示了前4条记录：
- en: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    |'
- en: '| 1 | John | 1 Main St. | WA | Seattle | 1995 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 1 | John | 1 Main St. | WA | Seattle | 1995 |'
- en: '| 2 | Mary | 20 J. Ave. | NY | Albany | 1980 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Mary | 20 J. Ave. | NY | Albany | 1980 |'
- en: '| 3 | Jane | 5 45^(th) St. | NY | Rye Brook | 2001 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Jane | 5 45^(th) St. | NY | Rye Brook | 2001 |'
- en: '| 4 | John | 10 A. Blvd. | CT | Stamford | 2010 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 4 | John | 10 A. Blvd. | CT | Stamford | 2010 |'
- en: 'In total, the table has 100 million records. The last few are shown as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这张表有1亿条记录。最后几条记录如下所示：
- en: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    |'
- en: '| 99999997 | Jim | 23 B. Lane | NC | Cary | 1995 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 99999997 | Jim | 23 B. Lane | NC | Cary | 1995 |'
- en: '| 99999998 | Mike | 5 L. Street | NY | Syracuse | 1993 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 99999998 | Mike | 5 L. Street | NY | Syracuse | 1993 |'
- en: '| 99999999 | Tim | 10 A. Blvd. | NY | Albany | 2001 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 99999999 | Tim | 10 A. Blvd. | NY | Albany | 2001 |'
- en: '| 100000000 | Jack | 10 A. Blvd. | CT | Stamford | 2010 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 100000000 | Jack | 10 A. Blvd. | CT | Stamford | 2010 |'
- en: 'The query we will run against this dataset is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对这个数据集运行以下查询：
- en: '[PRE0]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Scenario A: Searching row by row**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景A：逐行搜索**'
- en: 'In the first scenario, if we did a naïve row-by-row search, since the data
    for each column is not stored separately, but the data for each row is scanned,
    we would have to query across:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，如果我们进行天真的逐行搜索，由于每列的数据并未分开存储，而是扫描了每行的数据，我们将不得不查询以下内容：
- en: 100 million * 64 bytes (size of each row in bytes) = 6,400 million bytes = approximately
    6000 MB of data
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 1亿 * 64字节（每行的大小）= 6,400万字节=大约6000 MB的数据
- en: At a disk read speed of say, 200 MBps, this means it would take approximately
    6000 / 200 = 30 seconds to read all the records to find the matching entries.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以200 MBps的磁盘读取速度来说，这意味着大约需要6000 / 200 = 30秒来读取所有记录以找到匹配的条目。
- en: '**Scenario B: Searching column by column**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景B：逐列搜索**'
- en: 'Assuming each column of data resides in individual files representing the respective
    columns, we will look each where clause individually:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设数据的每一列都存储在代表各自列的单独文件中，我们将逐个查找每个where子句：
- en: '[PRE1]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Where clause part 1**: `where State like ''NY''`'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Where clause part 1**: `where State like ''NY''`'
- en: The State column, as described earlier, has 100 million entries each of size
    12 bytes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，州列有1亿条记录，每条记录大小为12字节。
- en: 'In this case, we only need to search across:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需要搜索以下内容：
- en: 100 million * 12 bytes = 1,200 million bytes = 1,000 MB of data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 1亿 * 12字节= 12亿字节= 1000 MB的数据。
- en: At a data read rate of 200 MBps, this would take 200 MB, and it would take 1000
    / 200 = 5 seconds to read the column of data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以200 MBps的数据读取速率，这将花费200 MB，读取列数据将花费1000 / 200 = 5秒。
- en: This returns two million records (as noted earlier database characteristics)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了两百万条记录（如前面所述的数据库特性）
- en: '**Where clause part 2**: `City like ''Albany''`'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Where clause part 2**: `City like ''Albany''`'
- en: In the preceding step, we had narrowed our window of search to two million records
    that satisfied the criteria of State NY. In the second where clause step, now,
    we need not query across all 100 million records. Instead, we can simply look
    at the two million records that satisfied the criteria to determine which ones
    belong to City Albany.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们已经将搜索范围缩小到满足NY州条件的两百万条记录。在第二个where子句步骤中，现在，我们不需要查询所有1亿条记录。相反，我们只需查看满足条件的两百万条记录，以确定哪些属于Albany市。
- en: 'In this case, we only need to search across:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需要搜索以下内容：
- en: '*2 million * 12 bytes = 24 million bytes = approximately 20 MB of data*.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*2百万 * 12字节= 2400万字节=大约20 MB的数据*。'
- en: At a data read rate of 200 MBps, this would take 0.1 seconds.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以200 MBps的数据读取速率，这将花费0.1秒。
- en: This returns 10,000 records (as noted earlier in Database Characteristics).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了1万条记录（如前面在数据库特性中提到的）。
- en: '**Where clause part 3**: `YearBuilt > 1990`'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Where clause part 3**: `YearBuilt > 1990`'
- en: In the preceding step, we further narrowed our window of search to 10,000 records
    fulfilling both the criteria of State NY and City Albany. In this step, we will
    query 10,000 records in the YearBuilt column to find which ones fulfil the criteria
    of YearBuilt > 1990.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们进一步将搜索范围缩小到满足NY州和Albany市两个条件的1万条记录。在这一步中，我们将查询1万条YearBuilt列的记录，以确定哪些满足YearBuilt
    > 1990的条件。
- en: 'In this case, we only need to search across:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需要搜索以下内容：
- en: '*10,000 * 16 bytes = 160,000 bytes = approximately 150 KB of data*.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*10,000 * 16字节= 160,000字节=大约150 KB的数据*。'
- en: At a data read rate of 200 MBps, this would take 0.00075 seconds, which we can
    round to zero seconds.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以200 MBps的数据读取速率，这将花费0.00075秒，我们可以四舍五入为零秒。
- en: 'Hence, the net time spent in querying across the data was:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在查询数据时花费的净时间为：
- en: 'Where clause part 1: `where State like ''NY''` - five seconds'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Where clause part 1: `where State like ''NY''` - 五秒'
- en: 'Where clause part 2: `City like ''Albany''` - 0.1 seconds'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Where clause part 2: `City like ''Albany''` - 0.1秒'
- en: 'Where clause part 3: `YearBuilt > 1990` - zero seconds'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Where clause part 3: `YearBuilt > 1990` - 零秒'
- en: Net time taken to read the data = 5.1 seconds.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据所花费的净时间= 5.1秒。
- en: 'Important: Note that the actual read or more specifically, scan performance,
    depends on various other factors. The **size of the tuple** (row), the time to
    reconstruct the tuple (**tuple reconstruction**), **bandwidth of memory** (how
    fast data can be read into the CPU from Main Memory, and so on), **cache line
    size** and other factors. In practice, there would be various levels of abstractions
    due to which the actual performance may be slower. Further there are other considerations
    such as hardware architecture and parallel operations that can affect positively
    or otherwise the overall performance. These topics are more advanced and require
    dedicated reading. The analysis here focuses exclusively on the disk I/O, which
    is one of the critical aspects of overall performance at a high-level.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：实际的读取或更具体地说，扫描性能取决于各种其他因素。元组（行）的大小，重建元组的时间（元组重建），内存带宽（数据从主存储器读入CPU的速度等），缓存行大小和其他因素。在实践中，由于各种抽象级别，实际性能可能会较慢。此外，还有其他考虑因素，如硬件架构和并行操作，可以积极或否定地影响整体性能。这些主题更加深入，需要专门阅读。这里的分析专注于磁盘I/O，这是整体性能的关键方面之一。
- en: The preceding example demonstrates the benefits of querying data that has been
    stored in columns from a query performance or efficiency perspective based on
    the size of the data. There is also another benefit offered by columnar data,
    which is that it allows storage of tables that may have arbitrary schema in columns.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例演示了查询以列存储的数据的好处，从查询性能或效率的角度来看，这取决于数据的大小。列式数据还提供了另一个好处，即它允许以列的形式存储可能具有任意模式的表。
- en: 'Consider the first four rows of the prior table. If, for example, we had missing
    information in some of the rows, that would lead to sparse columns:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前表的前四行。例如，如果某些行中有缺失信息，那将导致稀疏列：
- en: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    |'
- en: '| 1 | John | 1 Main St. | *NULL* | Seattle | 1995 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 1 | John | 1 Main St. | *NULL* | 西雅图 | 1995 |'
- en: '| 2 | Mary | 20 J. Ave. | NY | *NULL* | *NULL* |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Mary | 20 J. Ave. | 纽约 | *NULL* | *NULL* |'
- en: '| 3 | Jane | *NULL* | NY | Rye Brook | *NULL* |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Jane | *NULL* | 纽约 | 莱布鲁克 | *NULL* |'
- en: '| 4 | John | 10 A. Blvd. | CT | *NULL* | *NULL* |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 4 | John | 10 A. Blvd. | 康涅狄格 | *NULL* | *NULL* |'
- en: 'Instead of populating NULL values, we can instead create a `Column Family`
    called `Complete_Address` that can contain an arbitrary number of key-value pairs
    corresponding to only those fields that have corresponding data:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个名为`Complete_Address`的`列族`，而不是填充NULL值，该列族可以包含与仅具有相应数据的字段对应的任意数量的键值对：
- en: '| **PlotNumber** | **Owner** | **Complete_Address** |  | **YearBuilt** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **PlotNumber** | **Owner** | **Complete_Address** |  | **YearBuilt** |'
- en: '| 1 | John | Address: 1 Main St. | City: Seattle | 1995 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 1 | John | 地址：1 Main St. | 城市：西雅图 | 1995 |'
- en: '| 2 | Mary | Address: 20 J. Ave. | State: NY | *NULL* |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Mary | 地址：20 J. Ave. | 州：纽约 | *NULL* |'
- en: '| 3 | Jane | State: NY | City: Rye Brook | *NULL* |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Jane | 州：纽约 | 城市：莱布鲁克 | *NULL* |'
- en: '| 4 | John | Address: 10 A. Blvd. | State: CT | *NULL* |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 4 | John | 地址：10 A. Blvd. | 州：康涅狄格 | *NULL* |'
- en: 'A third and very important benefit offered by columnar databases is the ability
    to retrieve data based on three keys: a row key, a column key, and a timestamp
    that uniquely identifies each record, permitting very fast access to the data
    in question.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列式数据库提供的第三个非常重要的好处是能够根据三个键检索数据：行键、列键和时间戳，这些键可以唯一标识每条记录，从而可以非常快速地访问所需的数据。
- en: 'For example, since the Owner field can change when the property (PlotNumber)
    is sold, we can add another field that denotes the date of the record; that is,
    the date that the record corresponds to. This would allow us to distinguish among
    properties that had a change of ownership whilst all the other data remained the
    same:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于所有权字段在财产（PlotNumber）出售时可能会更改，因此我们可以添加另一个字段，表示记录的日期；即记录对应的日期。这将允许我们区分在所有其他数据保持不变的情况下发生所有权变更的属性：
- en: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    | **RecordDate** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    | **RecordDate** |'
- en: '| 1 | John | 1 Main St. | WA | Seattle | 1995 | 2001.04.02 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 1 | John | 1 Main St. | 华盛顿 | 西雅图 | 1995 | 2001.04.02 |'
- en: '| 2 | Mary | 20 J. Ave. | NY | Albany | 1980 | 2007.05.30 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Mary | 20 J. Ave. | 纽约 | 奥尔巴尼 | 1980 | 2007.05.30 |'
- en: '| 3 | Jane | 5 45^(th) St. | NY | Rye Brook | 2001 | 2001.10.24 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Jane | 5 45^(th) St. | 纽约 | 莱布鲁克 | 2001 | 2001.10.24 |'
- en: '| 4 | John | 10 A. Blvd. | CT | Stamford | 2010 | 2003.07.20 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 4 | John | 10 A. Blvd. | 康涅狄格 | 斯坦福 | 2010 | 2003.07.20 |'
- en: 'Since there can be multiple records for each PlotNumber to accommodate change
    of ownership, we can now define three keys that could uniquely identify each cell
    of data in each record, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个PlotNumber可以有多条记录以适应所有权的变更，我们现在可以定义三个键，可以唯一标识每条记录中每个数据单元，如下所示：
- en: 'Row key: `PlotNumber`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行键：`PlotNumber`
- en: 'Column key: The column name'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列键：列名
- en: 'Timestamp key: `RecordDate`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳键：`RecordDate`
- en: Each cell in each record in the table will thus have a unique three-value pair
    that distinguishes it from the other cells.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 表中每条记录中的每个单元格都将具有一个唯一的三值对，用于将其与其他单元格区分开来。
- en: Databases such as Bigtable, Cassandra, and others employ this method to perform
    data analysis at scale both expeditiously and efficiently.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Bigtable、Cassandra等数据库采用这种方法，以便迅速高效地进行大规模数据分析。
- en: 'Some of the popular columnar databases are listed as follows. Note that there
    may be repetitions as databases can have multiple NoSQL properties (such as both
    in-memory and columnar):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些流行的列式数据库。请注意，由于数据库可以具有多个NoSQL属性（例如内存和列式），因此可能会有重复：
- en: '| **Open source** | **Commercial** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **开源** | **商业** |'
- en: '| Apache Parquet | Kdb+ |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| Apache Parquet | Kdb+ |'
- en: '| MonetDB | Teradata |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| MonetDB | Teradata |'
- en: '| MariaDB | SAP HANA |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| MariaDB | SAP HANA |'
- en: '| Druid | HP Vertica |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| Druid | HP Vertica |'
- en: '| HBase | Oracle Exadata |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| HBase | Oracle Exadata |'
- en: '| Apache Kudu | ParAccel |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| Apache Kudu | ParAccel |'
- en: '| Apache Arrow | Actian Vector |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| Apache Arrow | Actian Vector |'
- en: Document-oriented databases
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向文档的数据库
- en: '**Document-based or document-oriented** databases became prominent as a means
    of storing data that had variable structures; that is, there was no fixed schema
    that each record would fit into all the time. Additionally, the document may have
    both a structured as well as an *unstructured* part.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于文档或面向文档**的数据库作为存储具有可变结构的数据的手段变得突出；也就是说，每条记录不一定总是符合固定模式。此外，文档可能既有结构化部分，也有*非结构化*部分。'
- en: Structured data is, in essence, data that can be stored in a tabular format
    such as in a spreadsheet. Data stored in Excel spreadsheets or MySQL tables all
    belong to the class of structured datasets. Data that cannot be represented in
    a strict tabular format such as books, audio files, video files, or social network
    messages are considered unstructured data. As such, in document-oriented databases,
    we will primarily work with structured and unstructured text data.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化数据本质上是可以以表格格式存储的数据，比如电子表格中的数据。存储在Excel电子表格或MySQL表中的数据都属于结构化数据集的类别。无法以严格的表格格式表示的数据，比如书籍、音频文件、视频文件或社交网络消息，被视为非结构化数据。因此，在面向文档的数据库中，我们将主要处理结构化和非结构化文本数据。
- en: 'An intuitive explanation of data that can contain both structured and unstructured
    text can be found in the example of a **phone diary**. Although these have become
    increasingly rare with the growth of digital data storage, many of us would remember
    a time when phone numbers were written in pocketbooks. The following image shows
    how we store data in a phone diary:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一个直观的解释是，数据可以包含结构化和非结构化文本，可以在电话日记的例子中找到。尽管随着数字数据存储的增长，这些已经越来越少见，但我们中的许多人可能还记得电话号码写在口袋本上的时候。下面的图片展示了我们如何在电话日记中存储数据：
- en: '![](img/1c2e56c2-7734-46a1-9bf9-4e35cd49d90a.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c2e56c2-7734-46a1-9bf9-4e35cd49d90a.png)'
- en: Address Book (Semi-Structured Dataset)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 地址簿（半结构化数据集）
- en: 'In the preceding example, the following fields can be considered as structured:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，以下字段可以被视为结构化的：
- en: Name
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓名
- en: Address
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址
- en: Tel and Fax
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话和传真
- en: There is a line underneath the Address field where the user can enter arbitrary
    information, for example, met at a conference in 2015, works at company abc. This
    is essentially a note that the diary keeper wrote when entering the specific information.
    Since there is no defining characteristic of a free-form field such as this, it
    could also contain information such as a second phone number, or an alternative
    address and other information. This would qualify as an unstructured text.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在地址字段下面有一行，用户可以输入任意信息，例如，在2015年的一次会议上见面，就职于ABC公司。这本质上是日记记录者在输入具体信息时写下的一条注释。由于这样的自由格式字段没有明确定义的特征，它也可能包含第二个电话号码，或者备用地址和其他信息。这将被视为非结构化文本。
- en: Further, since the other fields are not interdependent, a user may write the
    address but not the phone number, or the name and phone number but not the address.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于其他字段之间没有相互依赖，用户可以填写地址但不填写电话号码，或者填写姓名和电话号码但不填写地址。
- en: A document-oriented database, by virtue of its ability to store schema-free
    data; that is, data that does not conform to any fixed schema such as fixed columns
    with fixed datatypes, would hence be an appropriate platform to store this information.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 面向文档的数据库，凭借其存储无模式数据的能力；也就是说，不符合任何固定模式的数据，比如固定列和固定数据类型，因此是存储这些信息的合适平台。
- en: As such, since a phone diary contains a much smaller volume of data, in practice,
    we could store it in other formats, but the necessity for document-oriented datasets
    becomes apparent when we are working with large-scale data containing both structured
    and unstructured information.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于电话日记包含的数据量要小得多，在实践中，我们可以以其他格式存储它，但是当我们处理包含结构化和非结构化信息的大规模数据时，面向文档的数据集的必要性就变得明显起来。
- en: 'Using the example of a phone diary, the data could be stored in a document-oriented
    dataset in JSON format, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以电话日记为例，数据可以以JSON格式存储在面向文档的数据集中，如下所示：
- en: '[PRE2]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**JSON**, which stands for **J**ava**S**cript **O**bject **N**otation, provides
    a means of representing data in a portable text-based key-value pair format. Today,
    data in JSON is ubiquitous across the industry and has become the standard in
    storing data that does not have a fixed schema. It is also a great medium to exchange
    structured data, and as such is used for such datasets frequently.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**，全称**J**ava**S**cript **O**bject **N**otation，提供了一种以可移植的基于文本的键值对格式表示数据的方法。如今，JSON格式的数据在整个行业中无处不在，并已成为存储没有固定模式的数据的标准。它也是一个很好的交换结构化数据的媒介，因此经常用于这样的数据集。'
- en: The preceding illustration provides a basic example to convey how document-oriented
    databases work. As such, it is a very simple and hopefully intuitive example.
    In practice, document-oriented databases such as MongoDB and CouchDB are used
    to store gigabytes and terabytes of information.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例提供了一个基本的例子，以传达面向文档的数据库是如何工作的。因此，这是一个非常简单且直观的例子。在实践中，像MongoDB和CouchDB这样的面向文档的数据库被用来存储吉字节和太字节的信息。
- en: For example, consider a website that stores data on users and their movie preferences.
    Each user may have multiple movies they have watched, rated, recommended, movies
    that they have added to their wishlist, and other such artifacts. In such a case,
    where there are various arbitrary elements in the dataset, many of which are optional
    and many of which might contain multiple values (for example, multiple movies
    recommended by a user), a JSON format to capture information becomes optimal.
    This is where document-oriented databases provide a superior and optimal platform
    to store and exchange data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个网站，它存储用户及其电影偏好的数据。每个用户可能有多部他们观看过的电影，评分过的电影，推荐的电影，他们愿望清单中添加的电影，以及其他类似的物品。在这种情况下，数据集中有各种任意的元素，其中许多是可选的，许多可能包含多个值（例如，用户推荐的多部电影），使用JSON格式来捕获信息变得最优。这就是面向文档的数据库提供了一个优越和最佳的平台来存储和交换数据的地方。
- en: More concretely, databases such as MongoDB store information in BSON format
    - a binary version of JSON documents that have additional optimizations to accommodate
    datatypes, Unicode characters, and other features to improve upon the performance
    of basic JSON documents.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，诸如MongoDB之类的数据库以BSON格式存储信息，这是JSON文档的二进制版本，具有额外的优化以适应数据类型、Unicode字符和其他功能，以提高基本JSON文档的性能。
- en: 'A more comprehensive example of a JSON document stored in MongoDB could be
    data stored about airline passengers that contains information on numerous attributes
    specific to individual passengers, for example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 更全面的一个存储在MongoDB中的JSON文档的例子可能是关于航空乘客的数据，其中包含了关于个别乘客的许多属性的信息，例如：
- en: '[PRE3]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each entry is uniquely identified by the `_id` field, which allows us to directly
    query information relevant to the specific user and retrieve data without having
    to query across millions of records.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每个条目都由`_id`字段唯一标识，这使我们能够直接查询与特定用户相关的信息，并在不必查询数百万条记录的情况下检索数据。
- en: 'Today, document-oriented databases are used to store a diverse range of datasets.
    Examples include the use of such  the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，面向文档的数据库被用来存储各种各样的数据集。例如包括以下用法：
- en: Log files and log file-related information
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志文件和与日志文件相关的信息
- en: Articles and other text-based published materials
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章和其他基于文本的出版物
- en: Geolocation data
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理位置数据
- en: User/user account-related information
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户/用户账户相关信息
- en: Many more use cases that are optimal for document/JSON based storage
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多更适合基于文档/JSON的存储的用例
- en: 'Well-known document-oriented databases include the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 知名的面向文档的数据库包括以下内容：
- en: '| **Open source** | **Commercial** |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| **开源** | **商业** |'
- en: '| MongoDB | Azure Cosmos DB |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| MongoDB | Azure Cosmos DB |'
- en: '| CouchDB | OrientDB |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| CouchDB | OrientDB |'
- en: '| Couchbase Server | Marklogic |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| Couchbase Server | Marklogic |'
- en: Key-value databases
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键值数据库
- en: '**Key-value databases** operate on the principle of structuring data as pairs
    of values corresponding to keys. To highlight the benefits of key-value databases,
    it would help to revisit the significance of hash maps, a common term prevalent
    in computer science to specify a unique data-structure that provides a constant-time
    lookup for key pairs.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**键值数据库**的操作原则是将数据结构化为与键对应的值对。为了突出键值数据库的好处，有必要重新审视哈希映射的重要性，哈希映射是计算机科学中常见的术语，用于指定一种独特的数据结构，为键对提供常数时间查找。'
- en: 'An intuitive example for a hash table is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表的一个直观例子如下：
- en: Consider a collection of 500 books and five bookcases. Each bookcase has five
    shelves. The books can be placed in an arbitrary order, but that would make it
    incredibly difficult to find a specific book and you may need to go through hundreds
    of books before locating the one you need. One method of categorizing the books
    would be to assign ranges of letters to each of the bookshelves, for example,
    A-E, F-J, K-O, P-T, U-Z, and use the first letter of the name of the book to assign
    it to a specific shelf. However, suppose you have a disproportionate number of
    books that start with the letters A-E. This means that the case assigned for A-E
    would have a much higher number of books relative to the other ones.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一组500本书和五个书架。每个书架有五层。书可以以任意顺序放置，但这将使查找特定书籍变得非常困难，您可能需要在找到所需的书之前浏览数百本书。对书籍进行分类的一种方法是为每个书架分配字母范围，例如A-E，F-J，K-O，P-T，U-Z，并使用书名的第一个字母将其分配到特定的书架上。然而，假设您有大量以A-E字母开头的书。这意味着为A-E分配的书架相对于其他书架有更多的书。
- en: 'A more elegant alternative could be to assign a value to each of the books
    and use the respective value to determine which bookcase or bookshelf the book
    belongs to. To assign a number, a specific value to each book, we could sum up
    the numbers corresponding to each letter of the title of the book using a range
    of 1-26 for the letters A-Z respectively:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更优雅的替代方案可能是为每本书分配一个值，并使用相应的值来确定书屋或书架属于哪本书。为了为每本书分配一个数字，我们可以使用书名中每个字母对应的数字之和，分别使用1-26的范围来对A-Z的字母进行编号：
- en: '![](img/57f7faff-1435-44a3-978a-116c059ef15e.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57f7faff-1435-44a3-978a-116c059ef15e.png)'
- en: Our Simple Hash Map
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单哈希映射
- en: Since we have five bookcases, each with five shelves, we have a total of 25
    shelves. One method of allocating a book to a specific shelf would be to take
    the numeric value of the book obtained by summing the letters in the title and
    dividing the value by 26\. Any number, when divided by 25, will yield a remainder
    between 0-25; that is, 26 unique values. We can use this value then to assign
    the book to a particular shelf. This then becomes our self-created hash function.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有五个书架，每个书架有五层，所以我们总共有25个书架。将书分配到特定书架的一种方法是取书名中字母的数字值，将其相加并除以26得到书的数字值。任何数字除以25都会得到0-25之间的余数；也就是说，26个唯一的值。然后我们可以使用这个值来将书分配到特定的书架上。这就成为我们自己创建的哈希函数。
- en: Of the 25 shelves, each of them is now assigned a numeric value corresponding
    to the values 0-25 respectively, with the last shelf being assigned the values
    24 and 25\. For example, shelf zero is assigned to store books whose numeric value
    divided by 26 yields zero, shelf one is assigned to store books whose numeric
    value divided by 26 yields one, and shelf 25 is assigned to store books whose
    numeric value divided by 26 yields 24 or 25.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这25个书架中，每个书架现在分配了一个与值0-25相对应的数字值，最后一个书架分配了值24和25。例如，书架零被分配用于存储其数字值除以26得到零的书籍，书架一被分配用于存储其数字值除以26得到一的书籍，书架25被分配用于存储其数字值除以26得到24或25的书籍。
- en: An example will help to illustrate this concept more concretely.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子将有助于更具体地说明这个概念。
- en: 'Book name: **HAMLET**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 书名：**哈姆雷特**
- en: 'Numeric value of title:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 标题的数字值：
- en: '![](img/eb17fd9d-b49f-409b-989b-963f5b7f7594.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb17fd9d-b49f-409b-989b-963f5b7f7594.png)'
- en: Hash values
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值
- en: Sum total of the numeric value = 8 + 1 + 13 + 12 + 5 + 20 = 59
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 数字值的总和 = 8 + 1 + 13 + 12 + 5 + 20 = 59
- en: Divide number by 26 = 2, remainder seven
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字除以26 = 2，余数为7
- en: Hence, the book is assigned to shelf number seven.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这本书被分配到第七个书架上。
- en: We have essentially found a way to methodically assign a shelf to each individual
    book, and because we have a fixed rule, when a new request for a book arrives,
    we can find it almost instantaneously since we will know the shelf corresponding
    to the book.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上找到了一种有条不紊地为每本书分配书架的方法，因为我们有一个固定的规则，所以当新的书籍请求到达时，我们几乎可以立即找到它，因为我们将知道与书籍对应的书架。
- en: The preceding method illustrates the concept of hashing, and in practice, we
    would use a hash function that would find a unique value for each book, and assuming
    we could get an arbitrary number of bookshelves and slots in which we can place
    the books, we could simply use the plain numeric value of the book to identify
    which shelf it would belong to.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法说明了哈希的概念，在实践中，我们将使用一个哈希函数为每本书找到一个唯一的值，假设我们可以获得任意数量的书架和槽，我们可以简单地使用书的纯数值来确定它应该属于哪个书架。
- en: There would be cases where two books would have the same numeric value, and
    in those cases we could stack the books in the slot corresponding to the number.
    In computer science, this effect of multiple values corresponding to a key is
    known as a collision, and in those cases we would assign multiple items by means
    of a list or similar datatype.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，两本书可能具有相同的数值，这种情况下，我们可以将书籍堆叠在相应的槽中。在计算机科学中，多个值对应一个键的这种效果被称为碰撞，在这种情况下，我们将通过列表或类似的数据类型分配多个项目。
- en: In real-life use cases, we have much more complex items to work with than the
    simple example of books. Generally, we'd use more complex hash functions that
    lower the chance of collision and accordingly assign the key-value pair. The data
    would be stored in a contiguous array in memory and hence, when a request for
    a certain key arrived, we could instantaneously find the value by using the hash
    function to identify the location in memory where the data resides.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们要处理的项目比书籍的简单示例要复杂得多。通常，我们会使用更复杂的哈希函数，以降低碰撞的几率，并相应地分配键值对。数据将存储在内存中的连续数组中，因此，当请求某个键时，我们可以通过使用哈希函数来立即找到数据所在的内存位置。
- en: Hence, using key-value pairs to store data can be immensely powerful because
    the time to retrieve information corresponding to a key can be very fast as there
    is no need to search through a long list to identify a matching key.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用键值对存储数据可能非常强大，因为检索与键对应的信息的时间可以非常快，因为无需搜索长列表以识别匹配的键。
- en: Key-value databases employ the same principle of assigning unique keys to each
    record, and the data corresponding to each key is stored in the corresponding
    location. In our discussion of MongoDB, we saw that records were assigned a certain
    key identified by the `_id` value in each record. In practice, we could use this
    value to retrieve the corresponding data in constant time.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 键值数据库采用相同的原则为每个记录分配唯一的键，并且与每个键对应的数据存储在相应的位置。在我们讨论MongoDB时，我们看到记录被分配了一个特定的键，该键在每个记录中由`_id`值标识。在实践中，我们可以使用这个值以恒定时间检索相应的数据。
- en: As mentioned before, memcached used to be the preferred method to store data
    in key-value pairs for web services that required very fast access to frequently
    used data. In essence, it served as a memory cache to store temporary information.
    With the advent of NoSQL databases, new platforms that extended the limited use
    case of memcached became prominent. Solutions such as Redis offered not only the
    ability to store data in key-value pairs in memory, but also the ability to persist
    the data on disk. In addition, these key-value stores supported horizontal scaling,
    which permitted the distribution of key-value pairs across hundreds of nodes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，memcached曾经是存储键值对数据的首选方法，用于需要对频繁使用的数据进行非常快速访问的网络服务。实质上，它作为一个内存缓存，用于存储临时信息。随着NoSQL数据库的出现，扩展了memcached有限用例的新平台变得突出起来。诸如Redis之类的解决方案不仅提供了在内存中存储数据的能力，还提供了将数据持久化到磁盘的能力。此外，这些键值存储支持水平扩展，允许将键值对分布在数百个节点上。
- en: The disadvantage of key-value storage was that the data could not be queried
    with the same flexibility as standard databases, which supported multiple levels
    of indexing and a more richer set of SQL commands. Nevertheless, the benefits
    of constant time lookup implied that for use cases that required a key-value structure,
    there were few other solutions that were comparable in both performance and efficiency.
    For instance, a shopping website with thousands of users could store user profile
    information in a key-value database and be able to look up individual information
    by simply applying a hash function corresponding to, for example, the user ID.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 键值存储的缺点是，无法像标准数据库那样灵活地查询数据，后者支持多级索引和更丰富的SQL命令集。然而，恒定时间查找的好处意味着对于需要键值结构的用例，几乎没有其他解决方案在性能和效率上可以与之媲美。例如，一个拥有成千上万用户的购物网站可以将用户配置文件信息存储在键值数据库中，并能够通过简单应用与用户ID相对应的哈希函数来查找个别信息。
- en: 'Today, key-value databases use a variety of methods to store data:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，键值数据库使用各种方法来存储数据：
- en: '**SSTables**: A file of sorted key-value pairs represented as strings (and
    directly mapped to the **Google File System** (**GFS**)).'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSTables**：以字符串形式表示的排序键值对文件（直接映射到**Google文件系统**（**GFS**））。'
- en: '**B-trees**: Balanced trees where values are identified by traversing along
    leaves/nodes.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B-树**：平衡树，通过遍历叶子/节点来识别值。'
- en: '**Bloom filters**: A more optimal key-value method used when the number of
    keys is high. It uses multiple hash functions to set the bit-value to one in an
    array corresponding to keys.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布隆过滤器**：当键的数量很大时使用的更优化的键值方法。它使用多个哈希函数将位值设置为数组中对应的键。'
- en: '**Shards**: A process involving partitioning data across multiple nodes.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分片**：涉及将数据分区到多个节点。'
- en: 'Well known key-value databases include:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知的键值数据库包括：
- en: '| **Open source** | **Commercial** |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **开源** | **商业** |'
- en: '| Redis | Amazon DynamoDB |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| Redis | 亚马逊DynamoDB |'
- en: '| Cassandra | Riak |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| Cassandra | Riak |'
- en: '| Aerospike | Oracle NoSQL |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| Aerospike | Oracle NoSQL |'
- en: '| Apache Ignite | Azure Cosmos DB |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| Apache Ignite | Azure Cosmos DB |'
- en: '| Apache Accumulo | Oracle Berkeley DB |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| Apache Accumulo | Oracle Berkeley DB |'
- en: Graph databases
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形数据库
- en: '**Graph databases** provide an efficient representation of data with records
    that have inter-relationships. Typical examples are your social network friend
    list, LinkedIn contacts, Netflix movie subscribers. By leveraging optimized algorithms
    for searching on tree-based/graph data structures, graph databases can locate
    information in a novel manner relative to other NoSQL solutions. In such a structure,
    discrete information and properties are represented as leaves, edges, and nodes.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图形数据库提供了一种高效的数据表示，其中记录之间存在相互关系。典型的例子包括您的社交网络好友列表、LinkedIn联系人、Netflix电影订阅者。通过利用基于树形/图形数据结构的优化算法进行搜索，图形数据库可以以一种新颖的方式定位信息，相对于其他NoSQL解决方案。在这样的结构中，离散信息和属性被表示为叶子、边和节点。
- en: 'The following image shows an atypical representation of a network that can
    be queried to discover or find complex inter-relationships using a graph database.
    In practice, production graph databases contain millions of nodes:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个可以查询的网络的非典型表示，可以使用图形数据库发现或查找复杂的相互关系。在实践中，生产图形数据库包含数百万个节点：
- en: '![](img/9586b4cb-0fb0-4d1d-9a3b-71c89696d7f5.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9586b4cb-0fb0-4d1d-9a3b-71c89696d7f5.png)'
- en: Graph Database
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图形数据库
- en: Although they are not as prevalent as other types of NoSQL database, graph-based
    platforms are used for business-critical areas. For instance, credit card companies
    use graph databases to find new products that an individual cardholder may be
    interested in by querying across millions of datapoints to assess purchasing behavior
    of other cardholders with similar purchasing patterns. Social network websites
    use graph databases to compute similarity scores, provide friend suggestions,
    and other related metrics.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们不像其他类型的NoSQL数据库那样普遍，基于图形的平台被用于业务关键领域。例如，信用卡公司使用图形数据库通过查询数百万数据点来评估其他具有类似购买模式的持卡人的购买行为，以发现个体持卡人可能感兴趣的新产品。社交网络网站使用图形数据库来计算相似度分数，提供好友建议和其他相关指标。
- en: 'Well-known graph databases include the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 知名的图形数据库包括以下：
- en: '| **Open source** | **Commercial** |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| **开源** | **商业** |'
- en: '| Apache Giraph | Datastax Enterprise Graph |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| Apache Giraph | Datastax Enterprise Graph |'
- en: '| Neo4j | Teradata Aster |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| Neo4j | Teradata Aster |'
- en: '| JanusGraph | Oracle Spatial and Graph |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| JanusGraph | Oracle Spatial and Graph |'
- en: '| Apache Ignite |  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| Apache Ignite |  |'
- en: Other NoSQL types and summary of other types of databases
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他NoSQL类型和其他类型的数据库
- en: 'This section described some of the commonly known NoSQL paradigms in use today.
    There are several other emerging platforms that have their own strengths and unique
    characteristics. A brief overview of some of them is given here:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了当今使用的一些常见NoSQL范式。还有一些新兴平台具有自己的优势和独特特点。这里简要概述了其中一些：
- en: '| **Type** | **Feature** |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **特性** |'
- en: '| Object-oriented databases | Databases that leverage concepts in object-oriented
    programming to store data represented as objects. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 面向对象数据库 | 这些数据库利用面向对象编程中的概念来存储以对象表示的数据。 |'
- en: '| Cloud databases | Databases offered by cloud vendors such as Amazon, Microsoft,
    and Google that are only available on their respective cloud platforms such as
    Amazon Redshift, Azure SQL Database, and Google BigQuery. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 云数据库 | 由云供应商提供的数据库，如亚马逊、微软和谷歌，仅在其各自的云平台上提供，如亚马逊Redshift、Azure SQL数据库和谷歌BigQuery。
    |'
- en: '| GPU databases | A more recent entrant in the world of databases that leverage
    GPU (graphic processing unit) cards to process data. Examples include MapD, Kinetica,
    and others. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| GPU数据库 | 这是数据库世界中的一个较新的参与者，利用GPU（图形处理单元）卡来处理数据。例如MapD、Kinetica等。 |'
- en: '| FPGA-accelerated databases | With Intel soon announcing the release of new
    chips that would have embedded FPGAs, companies such as Baidu have started developing
    FPGA-accelerated systems that leverage FPGA processing power to improve SQL query
    performance. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| FPGA加速数据库 | 随着英特尔即将宣布发布搭载FPGA的新芯片，百度等公司已开始开发利用FPGA处理能力来提高SQL查询性能的FPGA加速系统。
    |'
- en: '| Stream processing/IoT databases | Databases, or more generally platforms,
    that are optimized for processing streaming data such as from medical devices
    and sensors. One of the most popular examples of such a system is Apache Storm.
    |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 流处理/IoT数据库 | 优化用于处理来自医疗设备和传感器等流数据的数据库，或更一般的平台。其中最流行的一个例子是Apache Storm。 |'
- en: A question often asked is whether there is one NoSQL database that is optimal
    for all use cases. While the databases can have multiple features that support
    numerous elements of NoSQL systems (generally known as multi-modal databases),
    in practice, a single solution that performs universally well across a broad set
    of use cases is rare. In real-world use cases, companies generally implement more
    than one solution to meet data mining needs. In the next section, we will complete
    a few hands-on exercises with real-world datasets using NoSQL solutions discussed
    in this chapter.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 经常被问到的一个问题是是否有一个NoSQL数据库适用于所有用例。虽然数据库可以具有支持NoSQL系统多个元素的多个特性（通常被称为多模数据库），但在实践中，一个能够在广泛的用例集中表现良好的单一解决方案是罕见的。在实际应用中，公司通常实施多个解决方案来满足数据挖掘需求。在下一节中，我们将使用本章讨论的NoSQL解决方案完成一些真实数据集的实际练习。
- en: Analyzing Nobel Laureates data with MongoDB
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB分析诺贝尔奖获得者的数据
- en: In the first exercise, we will use **MongoDB**, one of the leading document-oriented
    databases, to analyze Nobel Laureates from 1902-present. MongoDB provides a simple
    and intuitive interface to work with JSON files. As discussed earlier, JSON is
    a flexible format that allows representing data using a structured approach.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个练习中，我们将使用**MongoDB**，这是一种领先的面向文档的数据库，来分析1902年至今的诺贝尔奖获得者。MongoDB提供了一个简单直观的界面，用于处理JSON文件。正如之前讨论的，JSON是一种灵活的格式，允许使用结构化方法表示数据。
- en: JSON format
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON格式
- en: 'Consider the following table:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下表：
- en: '| **Firstname** | **Lastname** | **Information** |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| **名字** | **姓氏** | **信息** |'
- en: '| John | 15 | Subject: History, Grade B |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 约翰 | 15 | 主题：历史，等级B |'
- en: '| Jack | 18 | Subject: Physics, Grade A |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 杰克 | 18 | 主题：物理，等级A |'
- en: '| Jill | 17 | Subject: Physics, Grade A+ |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 吉尔 | 17 | 主题：物理，等级A+ |'
- en: The Information field contains a column containing multiple values categorized
    under Subject and Grade. Such columns that contain multiple data are also known
    as columns with nested data.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 信息字段包含一个包含在主题和等级下分类的多个值的列。包含多个数据的列也称为包含嵌套数据的列。
- en: Portability has been an important aspect of transferring data from one system
    to another. In general, ODBC connectors are used to transfer data between database
    systems. Another common format is CSV files with the data represented as comma-separated
    values. CSV files are optimal for structured data that doesn't contain more complex
    data structures such as nested values. In such cases, JSON provides an optimal
    and structured way to capture and preserve information using a key-value pair
    syntax.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植性一直是将数据从一个系统转移到另一个系统的重要方面。通常情况下，ODBC连接器用于在数据库系统之间传输数据。另一种常见的格式是CSV文件，其中数据表示为逗号分隔的值。CSV文件适用于不包含更复杂数据结构（如嵌套值）的结构化数据。在这种情况下，JSON提供了一种最佳和结构化的方式，使用键值对语法捕获和保留信息。
- en: 'In JSON representation, the table can be defined as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON表示中，表可以定义如下：
- en: '[PRE4]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the `Information` key contains two keys, `Subject` and `Grade`,
    with each having a corresponding value.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`信息`键包含两个键，`主题`和`等级`，每个键都有相应的值。
- en: Today, most product developers and vendors accommodate the ingestion of JSON-formatted
    data. Also, due to the simple manner in which complex relationships can be expressed
    as well as exchanged in text format, JSON has become immensely popular across
    the world in the developer community.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数产品开发人员和供应商都能够接受JSON格式的数据。此外，由于复杂关系可以以简单的方式在文本格式中表达和交换，JSON在全球开发者社区中变得非常流行。
- en: MongoDB captures data in JSON format. It internally stores them in BSON—an optimized
    binary representation of the JSON data.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB以JSON格式捕获数据。它在内部以BSON的形式存储数据，这是JSON数据的优化二进制表示。
- en: Installing and using MongoDB
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和使用MongoDB
- en: MongoDB is supported on all major platforms such as Windows, Linux, and OS X
    platforms.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB支持Windows、Linux和OS X等所有主要平台。
- en: The details for installing MongoDB can be found on their official website at
    [https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/).
    Note that we will be using the MongoDB Community Edition.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 有关安装MongoDB的详细信息可以在官方网站[https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)上找到。请注意，我们将使用MongoDB社区版。
- en: For our exercise, we will re-use the Linux CentOS environment from our Cloudera
    Hadoop Distribution VM.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的练习，我们将重复使用我们的Cloudera Hadoop分发VM中的Linux CentOS环境。
- en: The exercise is however not dependent on the platform on which you install MongoDB.
    Once the installation has been completed, you can execute the commands indicated
    in this chapter on any other supported platform. If you have access to a separate
    Linux machine, you can use that as well.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个练习并不依赖于您安装MongoDB的平台。安装完成后，您可以在任何其他支持的平台上执行本章中指示的命令。如果您有一个独立的Linux机器，您也可以使用它。
- en: 'We will visit some of the common semantics of MongoDB and also download two
    datasets to compute the highest number of Nobel Prizes grouped by continent. The
    complete dump of the Nobel Prize data on Nobel Laureates is available from [nobelprize.org](https://www.nobelprize.org).
    The data contains all the primary attributes of Laureates. We wish to integrate
    this data with demographic information on the respective countries to extract
    more interesting analytical information:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论MongoDB的一些常见语义，并下载两个数据集来计算按大陆分组的诺贝尔奖获得者数量。诺贝尔奖获得者的完整数据转储可从[nobelprize.org](https://www.nobelprize.org)获取。数据包含所有获奖者的主要属性。我们希望将这些数据与各国的人口统计信息整合，以提取更有趣的分析信息：
- en: '**Download MongoDB**: MongoDB can be downloaded from [https://www.mongodb.com/download-center#community](https://www.mongodb.com/download-center#community).'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下载MongoDB**：MongoDB可以从[https://www.mongodb.com/download-center#community](https://www.mongodb.com/download-center#community)下载。'
- en: 'To determine which version is applicable for us, we checked the version of
    Linux installed on the CDH VM:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定适用于我们的版本，我们检查了CDH VM上安装的Linux版本：
- en: '[PRE5]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Based on the information, we have to use the CentOS version of MongoDB, and
    accordingly, following the instructions at [https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/),
    we installed the software, shown as follows:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据信息，我们必须使用MongoDB的CentOS版本，并根据[https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/)上的说明安装软件，如下所示：
- en: '[PRE6]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the contents of the file:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了文件的内容：
- en: '![](img/aa4ee91d-8d97-4306-bea2-00886989948f.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa4ee91d-8d97-4306-bea2-00886989948f.png)'
- en: Setting up MongoDB repository
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 设置MongoDB仓库
- en: 'As seen in the following screenshot, type `Y` for Yes:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，输入`Y`表示是：
- en: '![](img/9dcc8115-8f1b-44fa-99d6-a48a5e7e1455.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9dcc8115-8f1b-44fa-99d6-a48a5e7e1455.png)'
- en: Saving the .repo file
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 保存.repo文件
- en: 'Save the file as shown in the image as follows. This will now allow us to install
    `mongo-db`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 按照图像所示保存文件如下。这将允许我们安装`mongo-db`：
- en: '![](img/73965396-a01a-47ff-9c5b-dcfda1f44c1b.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/73965396-a01a-47ff-9c5b-dcfda1f44c1b.png)
- en: Writing and Saving the .repo file
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 编写和保存.repo文件
- en: '[PRE7]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open a new terminal and download the JSON data files as shown in the following
    screenshot:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端，并按照以下截图中所示下载JSON数据文件：
- en: '![](img/79111799-378b-41db-b833-2ed975307233.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/79111799-378b-41db-b833-2ed975307233.png)
- en: Selecting Open Terminal from Terminal App on Mac OS X
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 从Mac OS X的终端应用程序中选择“打开终端”
- en: '[PRE10]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that the file needs to be slightly modified. The code is shown in the
    following image:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，文件需要稍作修改。代码如下图所示：
- en: '![](img/89ea74b9-5871-4841-91b6-66b3003aaee8.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/89ea74b9-5871-4841-91b6-66b3003aaee8.png)
- en: Modifying the .json file for our application
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 修改我们应用程序的.json文件
- en: '[PRE11]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In order to combine the data in `laureate.json` with country-specific information,
    we need to download the `countryInfo.txt` from [geonames.org](http://geonames.org) 
    We will now download the second file that we need for the exercise, `country.json`.
    We will use both `laureates.json` and `country.json` for the exercise.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`laureate.json`中的数据与特定国家的信息相结合，我们需要从[geonames.org](http://geonames.org)下载`countryInfo.txt`。我们现在将下载练习所需的第二个文件`country.json`。我们将使用`laureates.json`和`country.json`进行练习。
- en: '`### country.json`: Download it from [http://www.geonames.org](http://www.geonames.org)
    (license: [https://creativecommons.org/licenses/by/3.0/](https://creativecommons.org/licenses/by/3.0/)).
    Modify the start and end of the JSON string to import into MongoDB as shown as
    follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`### country.json`：从[http://www.geonames.org](http://www.geonames.org)下载（许可证：[https://creativecommons.org/licenses/by/3.0/](https://creativecommons.org/licenses/by/3.0/)）。修改JSON字符串的开头和结尾，以便导入MongoDB，如下所示：'
- en: '[PRE12]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Query a field - find all Nobel Laureates who were born in the US and received
    a Nobel Prize in Physics. Note that here we have a nested field (category is under
    prizes as shown). Hence, we will use the dot notation as shown in the coming image.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 查询一个字段 - 查找所有在美国出生并获得诺贝尔物理学奖的诺贝尔奖获得者。请注意，这里有一个嵌套字段（如所示，类别在奖项下）。因此，我们将使用点表示法，如下图所示。
- en: 'Image illustrating `category`, one of the nested fields:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 说明`category`，一个嵌套字段的图像：
- en: '![](img/aad94718-e2e9-47dc-9789-3c79f0eb94ba.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/aad94718-e2e9-47dc-9789-3c79f0eb94ba.png)
- en: Nested JSON Fields
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的JSON字段
- en: '[PRE13]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are many other operations that can be performed, but the intention of
    the prior section was to introduce MongoDB at a high level with a simple use case.
    The URLs given in this chapter contain more in-depth information on using MongoDB.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他操作可以执行，但前一节的目的是以简单的用例高层次介绍MongoDB。本章中提供的URL包含有关使用MongoDB的更深入信息。
- en: There are also several visualization tools in the industry that are used to
    interact with and visualize data stored in MongoDB collections using a point-and-click
    interface. A simple yet powerful tool called MongoDB Compass is available at [https://www.mongodb.com/download-center?filter=enterprise?jmp=nav#compass.](https://www.mongodb.com/download-center?filter=enterprise?jmp=nav#compass)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 行业中还有几种可视化工具用于与MongoDB集合中存储的数据进行交互和可视化，使用点对点界面。一个简单但功能强大的工具叫做MongoDB Compass，可以在[https://www.mongodb.com/download-center?filter=enterprise?jmp=nav#compass.](https://www.mongodb.com/download-center?filter=enterprise?jmp=nav#compass)下载。
- en: 'Navigate to the previously mentioned URL and download the version of Compass
    that is appropriate for your environment:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到前面提到的URL，并下载适合您环境的Compass版本：
- en: '![](img/8a0c6779-586c-43e0-b01a-1218f24f78ec.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/8a0c6779-586c-43e0-b01a-1218f24f78ec.png)
- en: Downloading MongoDB Compass
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 下载MongoDB Compass
- en: 'After installation, you''ll see a welcome screen. Click on Next until you see
    the main dashboard:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您将看到欢迎屏幕。点击“下一步”直到看到主仪表板：
- en: '![](img/4e5fdace-8e95-40e7-a0d8-5e2af7313798.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/4e5fdace-8e95-40e7-a0d8-5e2af7313798.png)
- en: MongoDB Compass Screenshot
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB Compass截图
- en: 'Click on Performance to view the current status of MongoDB:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“性能”以查看MongoDB的当前状态：
- en: '![](img/c0f2af9b-958b-4ee4-ab32-1168f5ccd99e.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/c0f2af9b-958b-4ee4-ab32-1168f5ccd99e.png)
- en: MongoDB Performance Screen
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB性能屏幕
- en: 'Expand the nobel database by clicking on the arrow next to the word on the
    left sidebar. You can click and drag on different parts of the bar charts and
    run ad hoc queries. This is very useful if you want to get an overall understanding
    of the dataset without necessarily having to run all queries by hand, as shown
    in the following screenshot:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 单击左侧边栏上单词旁边的箭头，扩展诺贝尔数据库。您可以单击并拖动条形图的不同部分，并运行临时查询。如果您想要对数据集有一个整体的了解，而不必手动运行所有查询，这非常有用，如下图所示：
- en: '![](img/ef06d694-d31f-458a-9c50-d9da40944e0a.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/ef06d694-d31f-458a-9c50-d9da40944e0a.png)
- en: Viewing our file in MongoDB Compass
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB Compass中查看我们的文件
- en: Tracking physician payments with real-world data
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用真实世界数据跟踪医生的付款
- en: Physicians and hospitals alike receive payments from various external organizations,
    such as pharmaceutical companies who engage sales representatives to not only
    educate practitioners on their products, but also provide gifts or payments in
    kind or otherwise. In theory, gifts or payments made to physicians are not intended
    to influence their prescribing behavior, and pharmaceutical companies adopt careful
    measures to maintain checks and balances on payments being made to healthcare
    providers.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 医生和医院都会收到来自各种外部组织的付款，例如从从事销售代表的制药公司，这些代表不仅教育从业者使用他们的产品，还提供礼物或以其他方式提供支付。理论上，给医生的礼物或付款并不意味着要影响他们的处方行为，制药公司采取谨慎措施来对向医疗保健提供者支付的款项进行核查和平衡。
- en: In 2010, President Obama's signature **Affordable Care Act** (**ACA**), also
    known in popular parlance as Obamacare, went into effect. Alongside the ACA, a
    separate legislation known as the Sunshine Act made reporting items of monetary
    value (directly or indirectly) mandatory for pharmaceutical companies and other
    organizations. While such rules existed in the past, rarely were such rules available
    in the public domain. By making detailed payment records made to all physicians
    available publicly, the Sunshine Act introduced an unprecedented level of transparency
    in monetary dealings involving healthcare providers.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，奥巴马总统的标志性**平价医疗法案**（**ACA**），在民间俗称为奥巴马医改，生效。与ACA同时生效的是一项名为阳光法案的单独立法，该法案规定了制药公司和其他组织必须报告以货币价值（直接或间接）支付的物品。尽管过去存在这样的规定，但很少有这样的规定可以公开获取。通过公开提供向所有医生支付的详细付款记录，阳光法案在涉及医疗保健提供者的货币交易中引入了前所未有的透明度。
- en: The data is freely available on the website of CMS Open Payments at [https://openpaymentsdata.cms.gov](https://openpaymentsdata.cms.gov).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以在CMS Open Payments的网站[https://openpaymentsdata.cms.gov](https://openpaymentsdata.cms.gov)上免费获取。
- en: The site provides an interface to query the data, but does not have any means
    to perform large-scale data aggregation. For example, if a user wanted to find
    the total payments made in the state of CT, there is no simple and easy way to
    run the query through the default web-based tool. An API that provides the functionality
    is available, but requires a degree of familiarity and technical knowledge to
    use effectively. There are third-party products that provide such facilities,
    but in most cases they are expensive, and end users cannot modify the software
    to their particular needs.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站提供了一个查询数据的接口，但没有任何手段进行大规模数据聚合。例如，如果用户想要找到康涅狄克州的总付款金额，通过默认的基于Web的工具运行查询没有简单和容易的方法。提供了提供此功能的API，但需要一定的熟悉度和技术知识才能有效使用。有第三方产品提供这样的设施，但在大多数情况下它们是昂贵的，并且最终用户无法根据自己的特定需求修改软件。
- en: In this tutorial, we will develop a fast, highly efficient web-based application
    to analyze tens of millions of records that capture payments made to physicians
    in 2016\. We will be using a combination of a NoSQL database, R, and RStudio to
    create the final product - the web-based portal through which end users can query
    the database in real time.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将开发一个快速、高效的基于Web的应用程序，用于分析2016年向医生支付的数千万条记录。我们将使用NoSQL数据库、R和RStudio的组合来创建最终产品
    - 基于Web的门户，通过该门户最终用户可以实时查询数据库。
- en: 'The technologies we will use to develop the application are as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下技术来开发应用程序：
- en: 'Kdb+ NoSQL database: [http://www.kx.com](http://www.kx.com)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kdb+ NoSQL数据库：[http://www.kx.com](http://www.kx.com)
- en: R
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R
- en: RStudio
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RStudio
- en: For the tutorial, I will be using the VM image we downloaded for our Hadoop
    exercise. The tools can also be installed on Windows, Mac, and other Linux machines.
    The choice of the VM is mainly to provide a consistent and local OS independent
    platform.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我将使用我们为Hadoop练习下载的VM镜像。这些工具也可以安装在Windows、Mac和其他Linux机器上。选择VM主要是为了提供一个一致的、本地的、与操作系统无关的平台。
- en: Installing kdb+, R, and RStudio
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装kdb+、R和RStudio
- en: A Packt Data Science VM download has been provided, which contains all the necessary
    software required for this chapter. However, if you prefer to install the software
    on your local machine instead, instructions, have been provided in the following
    sections. You can skip the installation sections and proceed directly to the section
    on *Developing the Open Payment Application.*
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了Packt Data Science VM下载，其中包含本章所需的所有必要软件。但是，如果您更喜欢在本地计算机上安装软件，可以在以下部分提供的说明中进行。您可以跳过安装部分，直接进入*开发开放支付应用程序*部分。
- en: Installing kdb+
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装kdb+
- en: '**kdb+** is a time-series, in-memory, columnar database that has been used
    in the financial industry for almost 20 years. It is one of the fastest database
    platforms available for performing large-scale data mining, but one that is not
    as well-known as other NoSQL tools due to the fact that it has been used almost
    exclusively by hedge funds and investment banks for most of its existence. In
    particular, due to its speed and low overhead in processing vast amounts of data,
    it is used by algorithmic trading desks that engage in high-frequency trading.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**kdb+**是一个时间序列、内存中的列式数据库，已经在金融行业使用了近20年。它是可用于进行大规模数据挖掘的最快数据库平台之一，但由于几乎一直被对冲基金和投资银行专门使用，因此并不像其他NoSQL工具那样为人所知。特别是由于其速度和在处理大量数据时的低开销，它被进行高频交易的算法交易台使用。'
- en: With kdb+, it is fairly simple to analyze tens of millions and even hundreds
    of millions of records on a laptop. The main constraints would be at a hardware
    level - such as the amount of memory, disk space, and CPU that is available to
    process the data. In this tutorial, we will install the free 32-bit edition of
    kdb+ available for non-commercial use.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用kdb+，在笔记本电脑上分析数千万甚至数亿条记录相当简单。主要的约束将在硬件层面 - 例如可用于处理数据的内存、磁盘空间和CPU的数量。在本教程中，我们将安装可供非商业使用的免费32位版本的kdb+。
- en: kdb+ is not open source, but academic institutes can use the 64-bit license
    at no charge by writing to `academic@kx.com`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: kdb+不是开源的，但学术机构可以通过写信至`academic@kx.com`免费使用64位许可证。
- en: 'There are certain key characteristics of kdb+ that make it very well suited
    to large-scale data analysis:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: kdb+具有某些关键特征，使其非常适合大规模数据分析：
- en: '**Low-level implementation**: The database is written in C, thus reducing common
    causes of performance issues with most contemporary NoSQL databases that rely
    heavily on Java, which implements multiple layers of abstraction to provide processing
    capabilities'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低级实现**：数据库是用C编写的，因此减少了大多数当代NoSQL数据库的性能问题，这些数据库严重依赖于Java，后者实现了多层抽象以提供处理能力。'
- en: '**Architectural simplicity**: The entire binary for the kdb+ database is about
    500-600 KB. This is a fraction of the size of an MP3 song and can be easily downloaded
    even on a dial-up connection'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**架构简单**：kdb+数据库的整个二进制文件大小约为500-600 KB。这只是MP3歌曲大小的一小部分，即使在拨号连接上也可以轻松下载'
- en: '**MapReduce**: The database implements an internal MapReduce process that allows
    queries to execute across multiple cores simultaneously'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MapReduce**：该数据库实现了一个内部MapReduce过程，允许查询同时在多个核心上执行'
- en: '**No installation**: The database requires no system-level privileges and users
    can start using kdb+ with their user account on most systems'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无需安装**：该数据库不需要系统级别的特权，用户可以在大多数系统上使用他们的用户帐户开始使用kdb+'
- en: '**Enterprise-ready**: The database has been used for nearly 20 years and is
    a very mature product used in global enterprise environments for analysis of high-frequency
    trading data among other applications'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业就绪**：该数据库已经使用了近20年，是一个非常成熟的产品，用于全球企业环境中分析高频交易数据等应用'
- en: '**Wide availability of interfaces**: The database has a wide range of interfaces
    for languages such as C, C++,C#, Java, R, Python, MATLAB, and others to allow
    easy integration with existing software'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口广泛可用**：该数据库具有广泛的接口，可用于诸如C、C++、C#、Java、R、Python、MATLAB等语言，以便与现有软件轻松集成'
- en: The steps to install kdb+ are given as follows. Please note that if you are
    using the Packt Data Science VM, no additional installation is necessary. The
    instructions have been provided primarily for users who would like to install
    the software afresh.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 安装kdb+的步骤如下。请注意，如果您使用Packt数据科学VM，则无需进行额外安装。这些说明主要是为了那些想要全新安装软件的用户提供的。
- en: Although the instructions are for Linux, the installation process is also quite
    simple for both Windows and Macs. The instructions herein are geared towards the
    Packt Data Science VM. The instructions for downloading the Packt Data Science
    VM was provided in [Chapter 3](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml), *The
    Analytics Toolkit*
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管说明是针对Linux的，但对于Windows和Mac来说，安装过程也非常简单。这些说明主要是针对Packt数据科学VM的。有关下载Packt数据科学VM的说明，请参阅[第3章](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml)，*分析工具包*
- en: 'Visit [www.kx.com](http://www.kx.com) and click on the **Download** drop-down
    option from the Connect with us menu item. You may also directly go to the download
    page located at [https://kx.com/download/](https://kx.com/download/):'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[www.kx.com](http://www.kx.com)，并从“Connect with us”菜单中点击**Download**下拉选项。您也可以直接访问位于[https://kx.com/download/](https://kx.com/download/)的下载页面：
- en: '![](img/e9289227-5a28-4ab9-904b-c657bd510ec5.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9289227-5a28-4ab9-904b-c657bd510ec5.png)'
- en: Kx Systems Homepage
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Kx Systems首页
- en: 'The download page is as shown in the following screenshot:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 下载页面如下截图所示：
- en: '![](img/9b9d30ed-0252-4ce2-a401-54f17703e792.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b9d30ed-0252-4ce2-a401-54f17703e792.png)'
- en: Downloading KDB+
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 下载KDB+
- en: Click on Download on the next page.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页上点击下载。
- en: You'll be taken to [https://kx.com/download/](https://kx.com/download/) where
    you can select the respective download of your choice after agreeing to the terms.
    If you are using the VM, download the *Linux-86 version*.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击[https://kx.com/download/](https://kx.com/download/)，同意条款后，您可以选择您需要的下载。如果您使用VM，请下载*Linux-86版本*。
- en: 'Select Save File to save the downloaded ZIP file in your Downloads folder:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“保存文件”以将下载的ZIP文件保存在您的下载文件夹中：
- en: '![](img/d2c2ea7a-99f1-4c01-8108-f1c3022ad91a.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2c2ea7a-99f1-4c01-8108-f1c3022ad91a.png)'
- en: KDB+ 32-bit license terms
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: KDB+ 32位许可条款
- en: 'Go to the folder where the file was downloaded and copy the ZIP file under
    your home directory:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 转到下载文件所在的文件夹，并将ZIP文件复制到您的主目录下：
- en: '![](img/579d8cf0-22ad-4b55-8b29-c28309916eaa.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](img/579d8cf0-22ad-4b55-8b29-c28309916eaa.png)'
- en: KDB+ Zip file download
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: KDB+ Zip文件下载
- en: 'For Mac or Linux systems, this will be the `~/` folder. In Windows, copy the
    ZIP file under `C:\` and unzip to extract the `q` folder. The following instructions
    are mainly for Linux-based systems:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Mac或Linux系统，这将是`~/`文件夹。在Windows中，将ZIP文件复制到`C:\`并解压以提取`q`文件夹。以下说明主要适用于基于Linux的系统：
- en: '[PRE14]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Installing R
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装R
- en: 'The frontend of the application will be developed using R. There are three
    options for installing R to complete the tutorial:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的前端将使用R开发。有三种选项可供安装R以完成本教程：
- en: If you have installed Microsoft R from [Chapter 3](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml), *The
    Analytics Toolkit*, and will be using your local machine for the tutorial, no
    further installation is necessary.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经从[第3章](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml)，*分析工具包*中安装了Microsoft
    R，并且将在本教程中使用您的本地机器，则无需进行进一步安装。
- en: Alternatively, if you will be using the Packt Data Science Virtualbox VM, no
    further installation will be needed.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，如果您将使用Packt数据科学Virtualbox VM，则无需进行进一步安装。
- en: 'If you plan to install R from the official R website, the binary can be downloaded
    from any of the download sites (mirrors) listed at [https://cran.r-project.org/mirrors.html](https://cran.r-project.org/mirrors.html):'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您计划从官方R网站安装R，则可以从列在[https://cran.r-project.org/mirrors.html](https://cran.r-project.org/mirrors.html)的下载站点（镜像）中下载二进制文件：
- en: '![](img/7f9ebd70-ea4f-476f-b714-919b06cc8d90.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f9ebd70-ea4f-476f-b714-919b06cc8d90.png)'
- en: Installing Open Source R
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 安装开源R
- en: Installing RStudio
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装RStudio
- en: We will use RStudio in order to build our web-based application. You can either
    download the binary for RStudio from the website or install it from the terminal.
    RStudio is available in two versions - RStudio Desktop and RStudio Server. Both
    versions can be used to build the application. The Server version provides an
    interface that can be used by multiple users, whereas the Desktop version is generally
    used locally on the user's machine.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用RStudio来构建我们的基于Web的应用程序。您可以从网站上下载RStudio的二进制文件，也可以从终端安装。RStudio有两个版本-RStudio桌面版和RStudio服务器版。这两个版本都可以用于构建应用程序。服务器版提供了一个可以供多个用户使用的界面，而桌面版通常在用户的本地机器上使用。
- en: The instructions also appear in [Chapter 3](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml), *The
    Analytics Toolkit*. They have been provided here for reference.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这些说明也出现在[第3章](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml)，*分析工具包*中。它们已在此提供供参考。
- en: 'There are two methods to complete the installation for the R tutorial:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以完成R教程的安装：
- en: If you will be using the Packt Data Science VM, no further installation is necessary.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您将使用Packt数据科学VM，则无需进行进一步安装。
- en: If you will be using your local machine for the tutorial, you can download RStudio
    Desktop from [https://www.rstudio.com/products/rstudio/download/#download](https://www.rstudio.com/products/rstudio/download/#download)
    or RStudio Server (only for Linux users) from [https://www.rstudio.com/products/rstudio/download-server/](https://www.rstudio.com/products/rstudio/download-server/).
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您将在本教程中使用本地计算机，您可以从[https://www.rstudio.com/products/rstudio/download/#download](https://www.rstudio.com/products/rstudio/download/#download)下载RStudio桌面，或者从[https://www.rstudio.com/products/rstudio/download-server/](https://www.rstudio.com/products/rstudio/download-server/)下载RStudio服务器（仅适用于Linux用户）。
- en: 'The following instructions have been provided for users wishing to download
    RStudio from the vendor''s website and perform a fresh installation:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明是为希望从供应商网站下载RStudio并进行全新安装的用户提供的：
- en: 'Go to the website of [https://www.rstudio.com](https://www.rstudio.com) and
    click on **Products** | **RStudio**:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 转到[https://www.rstudio.com](https://www.rstudio.com)的网站，然后点击**产品** | **RStudio**：
- en: '![](img/e837fc9d-1779-490c-b54c-b67d629a5459.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e837fc9d-1779-490c-b54c-b67d629a5459.png)'
- en: Open Source R Studio Desktop Versions
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 开源R Studio桌面版本
- en: 'On the RStudio page, click on **Download RStudio Desktop**:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在RStudio页面上，点击**下载RStudio桌面**：
- en: '![](img/b5f21797-de0a-45d2-9ccc-60f722008cee.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5f21797-de0a-45d2-9ccc-60f722008cee.png)'
- en: Selecting RStudio Desktop
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 选择RStudio桌面
- en: 'Select the free version of RStudio Desktop:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 选择RStudio桌面的免费版本：
- en: '![](img/84689f5f-ffdb-45d6-a79c-c82d51286f1d.png)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84689f5f-ffdb-45d6-a79c-c82d51286f1d.png)'
- en: Selecting Open Source R Studio Desktop
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 选择开源R Studio桌面
- en: RStudio is available for Windows, Mac, and Linux.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio适用于Windows、Mac和Linux。
- en: 'Download the appropriate executable for your system and proceed to perform
    the installation:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 下载适合您系统的可执行文件，然后进行安装：
- en: '![](img/28deddcd-3a2f-41fd-9a98-f972e2431336.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28deddcd-3a2f-41fd-9a98-f972e2431336.png)'
- en: RStudio Binaries (Versions)
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio二进制文件（版本）
- en: The CMS Open Payments Portal
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMS Open Payments门户
- en: In this section, we will begin developing our application for CMS Open Payments.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将开始为CMS Open Payments开发我们的应用程序。
- en: The Packt Data Science VM contains all the necessary software for this tutorial.
    To download the VM, please refer to [Chapter 3](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml), *The
    Analytics Toolkit*.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Packt数据科学VM包含本教程所需的所有软件。要下载VM，请参考[第3章](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml)，*分析工具包*。
- en: Downloading the CMS Open Payments data
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载CMS Open Payments数据
- en: 'The CMS Open Payments data is available directly as a web-based download from
    the CMS website. We''ll download the data using the Unix wget utility, but first
    we have to register with the CMS website to get our own API key:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: CMS Open Payments数据可以直接从CMS网站作为基于Web的下载获得。我们将使用Unix wget实用程序下载数据，但首先我们必须在CMS网站上注册，以获得我们自己的API密钥：
- en: 'Go to [https://openpaymentsdata.cms.gov](https://openpaymentsdata.cms.gov)
    and click on the Sign In link at the top-right of the page:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[https://openpaymentsdata.cms.gov](https://openpaymentsdata.cms.gov)，然后点击页面右上角的登录链接：
- en: '![](img/bbfb3158-5088-41d9-b493-9e5a32e32215.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbfb3158-5088-41d9-b493-9e5a32e32215.png)'
- en: Homepage of CMS OpenPayments
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: CMS OpenPayments的主页
- en: 'Click on **Sign Up**:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**注册**：
- en: '![](img/fe7d94fb-fb98-4fa3-8c90-8985828bfdd3.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe7d94fb-fb98-4fa3-8c90-8985828bfdd3.png)'
- en: Sign-Up Page on CMS OpenPayments
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: CMS OpenPayments的注册页面
- en: 'Enter your information and click on the **Create My Account** button:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 输入您的信息，然后点击**创建我的帐户**按钮：
- en: '![](img/57d32c92-42e6-4e9c-a8b7-dcdde3218f79.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57d32c92-42e6-4e9c-a8b7-dcdde3218f79.png)'
- en: Sign-Up Form for CMS OpenPayments
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: CMS OpenPayments的注册表格
- en: '**Sign In** to your account:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**登录**到您的帐户：'
- en: '![](img/3b96353c-5ee6-41a9-86d9-73976eb3c805.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b96353c-5ee6-41a9-86d9-73976eb3c805.png)'
- en: Signing into CMS OpenPayments
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到CMS OpenPayments
- en: 'Click on **Manage** under **Packt Developer''s Applications**. Note that Applications
    here refers to apps that you may create that will query data available on the
    CMS website:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**管理**下的**Packt开发者应用程序**。请注意，这里的“应用程序”是指您可能创建的应用程序，该应用程序将查询CMS网站上可用的数据：
- en: '![](img/f7312ecd-95c0-4b9e-8a99-d3fc66d3d842.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7312ecd-95c0-4b9e-8a99-d3fc66d3d842.png)'
- en: Creating 'Applications'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 创建“应用程序”
- en: 'Assign a name for the application (examples are shown in the following image):'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 为应用程序指定一个名称（示例显示在下图中）：
- en: '![](img/936b7e4a-ffa6-4c41-96ca-a5e6d695f7e5.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](img/936b7e4a-ffa6-4c41-96ca-a5e6d695f7e5.png)'
- en: Defining an application
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个应用程序
- en: 'You''ll get a notification that the **Application Token** has been created:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到通知，**应用程序令牌**已创建：
- en: '![](img/457be983-e31e-4bd4-9435-8509fdb84e4f.png)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![](img/457be983-e31e-4bd4-9435-8509fdb84e4f.png)'
- en: Creating the Application Token
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序令牌
- en: 'The system will generate an **App Token**. Copy the **App Token**:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将生成一个**应用程序令牌**。复制**应用程序令牌**：
- en: '![](img/0db9fc01-86f3-4a94-bb24-b8aed05f5c32.png)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0db9fc01-86f3-4a94-bb24-b8aed05f5c32.png)'
- en: The Application Token
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序令牌
- en: Now, log in to the Packt Data Science VM as user packt and execute the following
    shell command after replacing the term `YOURAPPTOKEN` with the one that you were
    assigned (it will be a long string of characters/numbers). Note that for the tutorial,
    we will only download a few of the columns and restrict the data to only physicians
    (the other option is hospitals).
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，以packt用户的身份登录到Packt数据科学VM，并在用您被分配的术语`YOURAPPTOKEN`替换为以下shell命令后执行（它将是一长串字符/数字）。请注意，对于本教程，我们将仅下载一些列并将数据限制为仅医生（另一个选项是医院）。
- en: You can reduce the volume of the data downloaded by reducing the value of the
    limit specified at the end of the command to a lower number. In the command, we
    have used `12000000` (12 million), which would let us download the entire 2016
    dataset representing physician payments. The application will still work if, for
    example, you were to download only one million entries instead of the approximately
    11-12 million records.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过减少命令末尾指定的限制值来减少下载的数据量。在命令中，我们使用了`12000000`（1200万），这将允许我们下载代表医生支付的整个2016年数据集。例如，如果您只下载了一百万条记录，而不是大约1100万到1200万条记录，应用程序仍将正常工作。
- en: 'Note: Two approaches are shown below. One using the Token and the other without
    using the Token. Application Tokens allow users to have a higher throttling limit.
    More information can be found at [https://dev.socrata.com/docs/app-tokens.html](https://dev.socrata.com/docs/app-tokens.html)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：下面显示了两种方法。一种使用令牌，另一种不使用令牌。应用程序令牌允许用户具有更高的限流限制。更多信息请参阅[https://dev.socrata.com/docs/app-tokens.html](https://dev.socrata.com/docs/app-tokens.html)
- en: '[PRE15]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Important**: It is possible to also download the file without using an app
    token. However, the method should be used sparingly. The URL to download the file
    without using an application token is shown as follows:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**：也可以在不使用应用程序令牌的情况下下载文件。但是，应该谨慎使用该方法。可以在以下显示的URL中下载文件，而无需使用应用程序令牌：'
- en: '[PRE16]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating the Q application
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Q应用程序
- en: This section describes the process of creating the kdb+/Q application, beginning
    with the process of loading data from the database and creating the scripts that
    will serve as the backend for the application.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了创建kdb+/Q应用程序的过程，从数据库加载数据并创建将作为应用程序后端的脚本开始。
- en: Loading the data
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载数据
- en: 'Log in to the VM using the ID `packt` (password: `packt`):'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ID `packt`（密码：`packt`）登录VM：
- en: '![](img/7a4e6913-3fe7-45d7-8d12-6b2bdb2f5699.png)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a4e6913-3fe7-45d7-8d12-6b2bdb2f5699.png)'
- en: Logging into the Packt VM
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 登录Packt VM
- en: '[PRE17]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The backend code
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后端代码
- en: Once the script completes, exit from the Q prompt by typing in `\\` and pressing
    *Enter*.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本完成后，通过键入`\\`并按*Enter*退出Q提示。
- en: 'Copy the following text into a file called `cms.q`:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下文本复制到名为`cms.q`的文件中：
- en: '[PRE18]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating the frontend web portal
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建前端Web门户
- en: '**R Shiny**, a package intended to make development of web-based applications
    simple, started gaining traction since it was introduced in around 2012-2013\.
    In general, R developers tend not to be very frontend development savvy as their
    main areas of work would be related to statistics or similar disciplines.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '**R Shiny**是一个旨在简化基于Web的应用程序开发的软件包，自2012-2013年左右推出以来一直备受关注。一般来说，R开发人员往往不太擅长前端开发，因为他们的主要工作领域与统计学或类似学科相关。'
- en: As data science, as a profession and a mainstream activity became popular, the
    need to create sophisticated web-based applications became necessary as a means
    of delivering results to end users in a dynamic environment.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据科学作为一种职业和主流活动的普及，创建复杂的基于Web的应用程序成为必要手段，以便在动态环境中向最终用户提供结果。
- en: JavaScript, which had all but lost its original appeal, made a surprise comeback
    and soon enough the web world was abuzz with the release of various leading JavaScript
    packages for web development and visualization, such as D3, Angular, Ember, and
    others ever since 2010-2011.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 自2010-2011年以来，JavaScript几乎失去了原有的吸引力，却又意外地卷土重来，很快，Web世界就因发布各种领先的JavaScript软件包（如D3、Angular、Ember等）而沸腾起来。
- en: But these were mostly used by seasoned JavaScript developers, few of whom were
    also proficient in R. Developing a solution that would help bridge the gap between
    JavaScript web-based application development and R programming became a necessity
    for R developers to showcase and share their work with a broader audience.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些主要是由经验丰富的JavaScript开发人员使用的，其中很少有人也精通R。开发一个解决方案，可以帮助弥合JavaScript基础应用程序开发和R编程之间的差距，成为R开发人员展示和与更广泛的受众分享他们的工作的必要性。
- en: R Shiny platform for developers
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R Shiny开发人员平台
- en: R Shiny introduced a platform for R developers to create JavaScript-based web
    applications without having to get involved, or, for that, matter even be proficient
    in JavaScript.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: R Shiny为R开发人员引入了一个平台，可以创建基于JavaScript的Web应用程序，而无需涉及JavaScript，或者即使精通JavaScript也无需涉及。
- en: In order to build our application, we will leverage R Shiny and create an interface
    to connect to the CMS Open Payments data we set up in the prior section.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的应用程序，我们将利用R Shiny，并创建一个接口来连接我们在前一节中设置的CMS Open Payments数据。
- en: 'If you are using your own R installation (locally), you''ll need to install
    a few R packages. Note that if you are using a Linux workstation, you may need
    to install some additional Linux packages. For example, in Ubuntu Linux, you''ll
    need to install the following. You may already have some of the packages, in which
    case you''ll receive a message indicating that no further changes were needed
    for the respective package:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用自己的R安装（本地），您需要安装一些R软件包。请注意，如果您使用的是Linux工作站，可能需要安装一些额外的Linux软件包。例如，在Ubuntu
    Linux中，您需要安装以下软件包。您可能已经安装了其中一些软件包，如果是这样，您将收到一条消息，指示对应软件包不需要进一步更改：
- en: '[PRE19]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you are using the Packt Data Science VM, you can proceed directly to developing
    the application as these Linux packages have already been installed for you.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Packt数据科学VM，您可以直接进行应用程序开发，因为这些Linux软件包已经为您安装好了。
- en: The Shiny application requires a few additional R packages to provide all its
    functionalities. Note that R packages are different from the Linux packages described
    previously. R packages, which number in the thousands, provide specialized functions
    for specific subject areas. For the web application, we will install a few R packages
    that will let us leverage some of the features in the web-based application.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny应用程序需要一些额外的R软件包来提供其所有功能。请注意，R软件包与前面描述的Linux软件包不同。数以千计的R软件包为特定学科领域提供专门的功能。对于Web应用程序，我们将安装一些R软件包，以便利用Web应用程序中的一些功能。
- en: 'The following steps outline the process of creating the web portal:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了创建Web门户的过程：
- en: Log in to RStudio. If you are using the Packt Data Science VM, go to `http://localhost:8787/auth-sign-in`.
    Log in with the user ID **packt** and password **packt** (same as user ID).
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到RStudio。如果您使用Packt Data Science VM，请转到`http://localhost:8787/auth-sign-in`。使用用户ID
    **packt** 和密码 **packt**（与用户ID相同）登录。
- en: 'Note that if you had installed RStudio locally, you''ll not have a separate
    login screen. The instruction is purely for the Packt Data Science VM:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您已在本地安装了RStudio，则不会有单独的登录屏幕。该说明纯粹适用于Packt Data Science VM：
- en: '![](img/12c68685-ff73-4579-a21c-98849e8b3b39.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12c68685-ff73-4579-a21c-98849e8b3b39.png)'
- en: Logging into RStudio Server (Only for Packt VM)
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到RStudio服务器（仅适用于Packt VM）
- en: 'If you receive an error message stating that the site cannot be loaded, it
    may be due to the fact that the port forwarding has not been set up. To fix the
    issue, make the following changes:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到错误消息，说明无法加载该站点，可能是因为端口转发尚未设置。要解决此问题，请进行以下更改：
- en: In VirtualBox, right-click on the VM and select Settings.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VirtualBox中，右键单击VM并选择设置。
- en: 'Click on Network under Settings and expand the arrow next to **Advanced**:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击设置下的网络，并展开**高级**旁边的箭头：
- en: '![](img/06f21a60-4570-4f94-899f-56ac4a3252c7.png)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06f21a60-4570-4f94-899f-56ac4a3252c7.png)'
- en: Setting up the VM parameters
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 设置VM参数
- en: 'Click on Port Forwarding and add a rule to forward port 8787 from the VM to
    the host. The rule marked as Packt Rule has to be added, shown as follows:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击端口转发并添加规则，将端口8787从VM转发到主机。必须添加标记为Packt Rule的规则，如下所示：
- en: '![](img/6b314a56-7f40-446f-91be-e897722d4fd5.png)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b314a56-7f40-446f-91be-e897722d4fd5.png)'
- en: Configuring Port Forwarding
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 配置端口转发
- en: 'After logging in, you''ll see the following screen. This is the interface for
    RStudio, which you''ll be using to complete the exercise. We''ll discuss R and
    RStudio in much more detail in later chapters, and this section illustrates the
    process to create the basic web application:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，您将看到以下屏幕。这是RStudio的界面，您将使用它来完成练习。我们将在后面的章节中更详细地讨论R和RStudio，本节说明了创建基本Web应用程序的过程：
- en: '![](img/c1d7dd91-08c0-4587-beff-d4778a0b216b.png)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1d7dd91-08c0-4587-beff-d4778a0b216b.png)'
- en: The RStudio Console
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio控制台
- en: Install the necessary R packages. Click on File | R Script and copy and paste
    the code below.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装必要的R包。点击文件|R脚本并复制并粘贴以下代码。
- en: 'Then, click on Source to execute the following lines:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击源以执行以下行：
- en: '[PRE20]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/c6b69841-8844-46fc-8402-ce3d0ce6b64c.png)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6b69841-8844-46fc-8402-ce3d0ce6b64c.png)'
- en: Installing required packages in R via RStudio
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 通过RStudio在R中安装所需的包
- en: 'Click on File|New File|Shiny Web App:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文件|新建文件|Shiny Web App：
- en: '>![](img/c8c2361f-3059-4d7b-a1cf-b050cac17ceb.png)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/c8c2361f-3059-4d7b-a1cf-b050cac17ceb.png)'
- en: Creating a new RShiny Application
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的RShiny应用程序
- en: 'Type in `cmspackt` under application name and click on Create:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“应用程序名称”下键入`cmspackt`，然后点击“创建”：
- en: '![](img/1ae74872-4594-43a0-8ced-0261aee782cf.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ae74872-4594-43a0-8ced-0261aee782cf.png)'
- en: Assigning a name to the RShiny Application
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 为RShiny应用程序指定名称
- en: 'This will create a `cmspackt` folder in the home directory, shown as follows:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在主目录中创建一个`cmspackt`文件夹，如下所示：
- en: '![](img/1d1c3d4f-f324-4da0-b296-a15bd122852f.png)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d1c3d4f-f324-4da0-b296-a15bd122852f.png)'
- en: The app.R file for the R Shiny Application
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: R Shiny应用程序的app.R文件
- en: 'Copy and paste the following code into the `app.R` section:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码复制并粘贴到`app.R`部分中：
- en: '[PRE21]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Click on New Folder in the lower-right box:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右下角的新文件夹：
- en: '![](img/a039acf3-9819-4b74-928f-9e1cd6368a76.png)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a039acf3-9819-4b74-928f-9e1cd6368a76.png)'
- en: Creating a folder for CSS files
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 创建CSS文件夹
- en: 'Rename the new folder to `cmspackt/www`, shown as follows:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件夹重命名为`cmspackt/www`，如下所示：
- en: '![](img/607404fd-4ad4-4764-a04c-e27d0ebff3a3.png)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![](img/607404fd-4ad4-4764-a04c-e27d0ebff3a3.png)'
- en: Assigning a name to the folder
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 为文件夹指定名称
- en: 'Click on File | New File |Text File:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文件|新建文件|文本文件：
- en: '![](img/27544c53-5a66-4238-ae1a-8ae9de529128.png)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27544c53-5a66-4238-ae1a-8ae9de529128.png)'
- en: Creating the CSS File
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 创建CSS文件
- en: 'Copy and paste the following code:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴以下代码：
- en: '[PRE22]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Click on File | Save As to save the file, as follows:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文件|另存为以保存文件，如下所示：
- en: '![](img/3cb929de-b700-4f88-b88e-124f2689ec3b.png)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cb929de-b700-4f88-b88e-124f2689ec3b.png)'
- en: Select Save As for the CSS File
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 为CSS文件选择另存为
- en: 'Save as `/home/packt/cmspackt/www/packt.css`, shown as follows:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另存为`/home/packt/cmspackt/www/packt.css`，如下所示：
- en: '![](img/1ed14459-0a0a-4fc0-aaea-c89a574cf876.png)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ed14459-0a0a-4fc0-aaea-c89a574cf876.png)'
- en: Saving the CSS File
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 保存CSS文件
- en: Your application is now ready for use!
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序现在已准备就绪！
- en: Putting it all together - The CMS Open Payments application
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容放在一起- CMS Open Payments应用程序
- en: 'In the prior sections, we have learned how to:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的部分中，我们已经学习了如何：
- en: Download the datasets
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载数据集
- en: Create the backend database
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建后端数据库
- en: Create the code for the backend database
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为后端数据库创建代码
- en: Set up RStudio
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置RStudio
- en: Create the R Shiny application
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建R Shiny应用程序
- en: 'To start the application, complete the following steps:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动应用程序，请完成以下步骤：
- en: Start the Q application, make sure you are in the home directory. Type pwd and
    hit Enter. This will show the present working directory of `/home/packt` as shown
    in the coming image.
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Q应用程序，确保您在主目录中。键入pwd并按Enter。这将显示`/home/packt`的当前工作目录，如下图所示。
- en: Next, type `q` and hit Enter.
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，键入`q`并按Enter。
- en: At the `q` prompt, type in `\l cms.q`.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`q`提示符下，键入`\l cms.q`。
- en: Note that `cms.q` is the file we created in our earlier section when developing
    the Q application.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`cms.q`是我们在开发Q应用程序时在早期部分创建的文件。
- en: 'The script will load the database and return back to the `q)` prompt:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将加载数据库并返回到`q)`提示：
- en: '![](img/21059576-46c9-4666-bdb7-d8b5c1c04210.png)'
  id: totrans-551
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21059576-46c9-4666-bdb7-d8b5c1c04210.png)'
- en: 'Putting it all together: Loading the CMS KDB+ Q Script in KDB+ Session'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放在一起：在KDB+会话中加载CMS KDB+ Q脚本
- en: Launch the CMS Open Payment application
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动CMS Open Payment应用程序
- en: 'In RStudio, open the `app.R` file (which contains the R Code) and click on
    Run App at the top-right, shown as follows:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在RStudio中打开包含R代码的`app.R`文件，并点击右上角的Run App，如下所示：
- en: '![](img/58e42772-85d4-407f-af98-f324ec235ade.png)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58e42772-85d4-407f-af98-f324ec235ade.png)'
- en: Running the RShiny Application
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 运行RShiny应用程序
- en: 'This will launch the web application, shown as follows:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Web应用程序，如下所示：
- en: '![](img/63e5338e-1ad6-4996-94ff-b1eff05d1ba9.png)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63e5338e-1ad6-4996-94ff-b1eff05d1ba9.png)'
- en: The RShiny Application
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: RShiny应用程序
- en: 'We have now finished developing a complete CMS Open Payments application that
    allows the end user to filter, aggregate, and analyze the data. Now, you can run
    queries by selecting various options on the screen. There are two functionalities
    in the app:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了开发一个完整的CMS Open Payments应用程序，允许最终用户过滤、聚合和分析数据。现在，您可以通过在屏幕上选择各种选项来运行查询。应用程序有两个功能：
- en: Filtering data (default view)
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤数据（默认视图）
- en: Aggregating data (you can switch to this option by selecting Aggregate Data
    from the Display Type menu)
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合数据（您可以通过从显示类型菜单中选择聚合数据切换到此选项）
- en: Applications
  id: totrans-563
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序
- en: '**A filtering example**: To see payments made by a company for a certain drug
    in the state of NY:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '**过滤示例**：查看某家公司在纽约州为某种药物支付的款项：'
- en: '![](img/3be31cd1-a953-4cc6-a6ad-2e29e2071aeb.png)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3be31cd1-a953-4cc6-a6ad-2e29e2071aeb.png)'
- en: Using the RShiny Application
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RShiny应用程序
- en: Note that the system processed 11 million records in 21 milliseconds, as shown
    in the header message. The name of the company and the product has been blanked
    out in the screenshot for privacy, but you are free to try out different options
    for both fields.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，系统在标题消息中显示处理了1100万条记录，用时21毫秒。出于隐私原因，屏幕截图中的公司名称和产品名称已被隐藏，但您可以自由尝试不同的选项。
- en: Note that in the default VM, we are using only one core with very limited memory,
    and the speed with which the data is processed using kdb+ even on a laptop with
    very limited resources easily exceeds the performance of many well-to-do commercial
    solutions.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在默认的虚拟机中，我们只使用了一个内核和非常有限的内存，即使在具有非常有限资源的笔记本电脑上，使用kdb+处理数据的速度也轻松超过了许多富裕的商业解决方案的性能。
- en: '**An aggregation example**: To see total payments grouped by state, payment
    category, and payment nature for a specific company and product, select the options
    for the fields *Aggregate Data* and *Calculate Metrics*. Please note that the
    name of the company and the product have been hidden in the screenshot for privacy
    reasons only.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚合示例**：选择*聚合数据*和*计算指标*字段的选项，以查看按州、支付类别和支付性质分组的总付款额，针对特定公司和产品。请注意，出于隐私原因，屏幕截图中的公司名称和产品名称已被隐藏。'
- en: 'Note the message at the top that states:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意顶部的消息，其中说明：
- en: '![](img/5abd0a19-3bf8-45ff-a9aa-9d41ab2e3125.png)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5abd0a19-3bf8-45ff-a9aa-9d41ab2e3125.png)'
- en: Log message indicating query and application performance
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 记录指示查询和应用程序性能
- en: This indicates the speed with which the underlying kdb+ database processed the
    data. In this case, it filtered and *aggregated 11 million records in 22 milliseconds*
    for the given options.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明了底层kdb+数据库处理数据的速度。在这种情况下，它使用给定的选项在22毫秒内过滤和聚合了1100万条记录。
- en: '![](img/5d5b097a-918a-4613-a01d-8572efd32706.png)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d5b097a-918a-4613-a01d-8572efd32706.png)'
- en: CMS OpenPayments Application Screenshot
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: CMS OpenPayments应用程序截图
- en: Summary
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced the concept of NoSQL. The term has gained popularity
    in recent years, especially due to its relevance and direct application to **big
    data** analytics. We discussed the core terminologies in NoSQL, their various
    types, and popular software used in the industry for such capabilities. We concluded
    with a couple of tutorials using MongoDB and kdb+.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了NoSQL的概念。这个术语近年来变得越来越流行，特别是由于它与**大数据**分析的相关性和直接应用。我们讨论了NoSQL中的核心术语、它们的各种类型以及行业中用于这些功能的流行软件。最后，我们通过使用MongoDB和kdb+进行了几个教程。
- en: We also built an application using R and R Shiny to create a dynamic web interface
    to interact with the data loaded in kdb+.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用R和R Shiny构建了一个应用程序，以创建一个动态的Web界面，与加载在kdb+中的数据进行交互。
- en: The next chapter will introduce another common technology in data science today,
    known as Spark. It is yet another toolkit that empowers data scientists across
    the world today.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍当今数据科学中另一个常见的技术，即Spark。这是另一个工具包，如今赋予全球数据科学家们力量。
