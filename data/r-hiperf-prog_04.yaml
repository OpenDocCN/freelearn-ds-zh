- en: Chapter 4. Using Compiled Code for Greater Speed
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 使用编译型代码以获得更高的速度
- en: So far, we have looked at how to optimize the computational performance of an
    R code. What if, after optimizing the code, it still runs too slowly? In this
    chapter, we will look at how to overcome the performance limitations caused by
    on-the-fly interpretation of an R code using a compiled code. Many CRAN packages
    use compiled code to offer optimum performance, so a simple way to take advantage
    of a compiled code is to use these packages. Sometimes, however, a specific task
    needs to be performed for which no package exists. It is useful to know how to
    write a compiled code for R in order to make R programs run faster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何优化R代码的计算性能。如果在优化代码之后，它仍然运行得太慢怎么办？在本章中，我们将探讨如何通过使用编译型代码来克服由R代码即时解释引起的性能限制。许多CRAN包使用编译型代码以提供最佳性能，因此利用编译型代码的一个简单方法就是使用这些包。然而，有时需要执行一个特定的任务，而这个任务没有现成的包。了解如何为R编写编译型代码，以便使R程序运行得更快是有用的。
- en: We will first see how to compile R code before its execution, then we will explore
    how to integrate compiled languages like C/C++ into R so that we can run R programs
    at native CPU speed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解如何在执行之前编译R代码，然后我们将探讨如何将C/C++等编译型语言集成到R中，以便我们可以以本地CPU速度运行R程序。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Compiling an R code before execution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行之前编译R代码
- en: Using compiled languages in R
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在R中使用编译型语言
- en: Compiling R code before execution
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在执行之前编译R代码
- en: In [Chapter 1](ch01.html "Chapter 1. Understanding R's Performance – Why Are
    R Programs Sometimes Slow?"), *Understanding R's Performance – Why Are R Programs
    Sometimes Slow?* we saw how R, being an interpreted language, has to parse and
    evaluate code every time an R program is run. This takes a lot of CPU time and
    slows down the execution of R programs. R provides the `compiler` package to somewhat
    reduce this issue. The functions in this package allow us to compile R code beforehand
    and save R a step or two when we execute the code. Let's see how this works.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 理解R的性能 – 为什么R程序有时运行得慢？")中，*理解R的性能 – 为什么R程序有时运行得慢？* 我们看到了R作为一个解释型语言，每次运行R程序时都必须解析和评估代码。这需要大量的CPU时间，并减慢了R程序的执行速度。R提供了`compiler`包来在一定程度上减少这个问题。该包中的函数允许我们在执行代码之前预先编译R代码，并在执行代码时为R节省一步或两步。让我们看看这是如何工作的。
- en: Compiling functions
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译函数
- en: 'Let''s define a `mov.avg()` function that calculates the moving average of
    a numeric series:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个`mov.avg()`函数，该函数用于计算数值序列的移动平均：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Given a numeric vector `x` and period `n`, we first calculate the `n` element's
    window sum of the elements of `x`. For example, if `x` is `[1, 2, 1, 3, 5]` and
    `n` is `2`, then we calculate `total` as `[1+2, 2+1, 1+3, 3+5] = [3, 3, 4, 8]`.
    We do this by looping `n` times over `x`, selecting a moving window of the elements
    of `x`, and adding those elements to `total`. Finally, we compute the moving average
    by dividing `total` by `n`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个数值向量`x`和周期`n`，我们首先计算`x`中`n`个元素的窗口总和。例如，如果`x`是`[1, 2, 1, 3, 5]`且`n`是`2`，那么我们计算`total`为`[1+2,
    2+1, 1+3, 3+5] = [3, 3, 4, 8]`。我们通过在`x`上循环`n`次，选择`x`的元素移动窗口，并将这些元素加到`total`上来实现这一点。最后，我们通过将`total`除以`n`来计算移动平均。
- en: To compile the function, we will use the `cmpfun()` function in the `compiler`
    package. The compilation functions provided by the `compiler` package operate
    on four different levels of optimization, numbered 0 to 3; the higher the number,
    the more the compiled code is optimized for performance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译函数，我们将使用`compiler`包中的`cmpfun()`函数。`compiler`包提供的编译函数在四个不同的优化级别上操作，编号为0到3；数字越高，编译型代码对性能的优化程度就越高。
- en: 'Let''s compile `mov.avg()` at different levels to see the differences in execution
    time. Here, we create four copies of the `mov.avg()` function compiled at different
    levels of optimization by passing the `optimize` argument to `cmpfun()`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译不同级别的`mov.avg()`函数，以查看执行时间的差异。在这里，我们通过将`optimize`参数传递给`cmpfun()`函数，创建了四个在不同优化级别编译的`mov.avg()`函数副本：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we benchmark the performance of the original `mov.avg()` function and
    the four compiled versions by computing the 20-period moving average of a numeric
    vector with `100` elements:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过计算包含`100`个元素的数值向量的20期移动平均，来基准测试原始的`mov.avg()`函数和四个编译版本的性能：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Looking at the median execution times, the original function took 41.4 μs. The
    compiled functions at optimization levels 0 and 1 took about the same time, coming
    in at 42.0 μs and 41.1 μs respectively. However those at optimization levels 2
    and 3 performed well, at 28.3 μs and 27.8 μs. They reduced the execution time
    by 32 percent and 33 percent respectively.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从中位执行时间来看，原始函数需要 41.4 μs。优化级别 0 和 1 的编译函数耗时大致相同，分别为 42.0 μs 和 41.1 μs。然而，优化级别
    2 和 3 的表现良好，分别为 28.3 μs 和 27.8 μs。它们分别将执行时间减少了 32% 和 33%。
- en: The minimum lower quartile and upper quartile statistics shows a similar pattern
    with `mov.avg.compiled2()` and `mov.avg.compiled3()` executing in less time than
    `mov.avg()`, `mov.avg.compiled0()`, and `mov.avg.compiled1()`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最小下四分位数和最大上四分位数的统计量显示与 `mov.avg.compiled2()` 和 `mov.avg.compiled3()` 执行时间少于
    `mov.avg()`、`mov.avg.compiled0()` 和 `mov.avg.compiled1()` 相似。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We should not rely on the maximum statistics because it can be unstable, producing
    a wide range of values every time we run `microbenchmark()`. This is due to the
    outliers when R's garbage collection takes place, or when the execution of the
    functions are slowed down by other processes competing for CPU time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该依赖于最大统计量，因为它可能是不稳定的，每次运行 `microbenchmark()` 时都会产生广泛的价值范围。这是由于 R 的垃圾回收时的异常值，或者当函数的执行因与其他进程竞争
    CPU 时间而减慢时。
- en: The following chart shows the distributions of the benchmarking results in an
    intuitive visual form.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表以直观的视觉形式显示了基准测试结果的分布。
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Generate an intuitive visualization of the benchmarking results by using the
    `autoplot()` function. The `ggplot2` package is needed for this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `autoplot()` 函数生成基准测试结果的直观可视化。为此需要 `ggplot2` 包：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Compiling functions](img/9263OS_04_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![编译函数](img/9263OS_04_01.jpg)'
- en: Autoplot of microbenchmark() results for moving average functions
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均函数的微基准测试结果的自动绘图
- en: The performance gain when R code is compiled depends on what kinds of R expressions
    are contained in the code. In our example, we achieved modest performance gains
    because the `for` loop and the arithmetic operations in the `mov.avg()` function
    could be optimized. However, compiling code that mostly calls other functions
    that have already been optimized for performance (such as `sum()`) would not result
    in significant performance gains.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当 R 代码编译时的性能提升取决于代码中包含的 R 表达式的类型。在我们的例子中，我们实现了适度的性能提升，因为 `mov.avg()` 函数中的 `for`
    循环和算术运算可以被优化。然而，编译主要调用已经为性能优化过的其他函数（如 `sum()`）的代码不会导致显著的性能提升。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The `compiler` package provides different functions to compile different types
    of R code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`compiler` 包提供了不同的函数来编译不同类型的 R 代码：'
- en: '`cmpfun()` compiles an R function.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmpfun()` 编译 R 函数。'
- en: '`compile()` compiles an R expression.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile()` 编译 R 表达式。'
- en: '`cmpfile()` compiles an R expression stored in a file.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmpfile()` 编译存储在文件中的 R 表达式。'
- en: Just-in-time (JIT) compilation of R code
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: R 代码的即时（JIT）编译
- en: R also supports **just-in-time** (**JIT**) **compilation**. When JIT compilation
    is enabled, R will automatically compile any code that is executed without explicitly
    having called one of the `compile` functions. This is convenient, as any existing
    R code can enjoy the performance gains of code compilation without any modification.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: R 也支持**即时**（**JIT**）**编译**。当启用 JIT 编译时，R 将自动编译任何执行而未显式调用 `compile` 函数之一的代码。这是方便的，因为任何现有的
    R 代码都可以享受代码编译的性能提升，而无需任何修改。
- en: 'To activate JIT compilation, use the `enableJIT()` function in the `compiler`
    package:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活 JIT 编译，请使用 `compiler` 包中的 `enableJIT()` 函数：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `level` argument tells R how much code to compile before execution. Valid
    values for `level` are:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`level` 参数告诉 R 在执行前编译多少代码。`level` 的有效值包括：'
- en: '`0`: It disables JIT.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：它禁用 JIT。'
- en: '`1`: It compiles functions before their first use.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：它在首次使用之前编译函数。'
- en: '`2`: In addition, it compiles functions before they are duplicated. This is
    useful for some packages like lattice that store functions in lists.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：此外，它还在函数被复制之前编译函数。这对于像 lattice 这样的存储函数在列表中的包很有用。'
- en: '`3`: It compiles loops before they are executed.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：它在执行之前编译循环。'
- en: 'Let''s benchmark the (uncompiled) `mov.avg()` function with the JIT compilation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用即时编译（JIT）来基准测试（未编译的）`mov.avg()` 函数：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The JIT compilation reduced the median execution time of `mov.avg()` from 41.4
    μs to 24.5 μs—a 41 percent improvement!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JIT 编译将 `mov.avg()` 的中位执行时间从 41.4 μs 降低到 24.5 μs——提高了 41%！
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: JIT compilation can also be enabled by setting the `R_ENABLE_JIT` environment
    in the operating system before starting R. The value of `R_ENABLE_JIT` should
    be set to the value of the `level` argument.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在启动 R 之前在操作系统中设置`R_ENABLE_JIT`环境变量，也可以启用 JIT 编译。`R_ENABLE_JIT`的值应设置为`level`参数的值。
- en: Using compiled languages in R
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 R 中使用编译型语言
- en: Code compilation can provide modest gains in computational performance, but
    there are limits to these gains because the compiled code still needs to be evaluated
    by R in a dynamic fashion. For example, we explained in [Chapter 3](ch03.html
    "Chapter 3. Simple Tweaks to Make R Run Faster"), *Simple Tweaks to Make R Run
    Faster*, how R, being a **dynamically typed** language, needs to check the type
    of an object before applying any operations. In the case of `mov.avg()`, every
    time R encounters the `+` operator, it needs to check that `x` is a numeric vector,
    as it could have been modified between each iteration of the `for` loop. In contrast,
    a **statically typed** language performs these checks at compile time, resulting
    in much faster run time performance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编译可以在计算性能上提供一定的提升，但这些提升是有限的，因为编译后的代码仍然需要以动态方式由 R 进行评估。例如，我们在[第 3 章](ch03.html
    "第 3 章。简化 R 运行速度的方法")中解释了*简化 R 运行速度的方法*，说明了 R 作为一种**动态类型**的语言，在应用任何操作之前需要检查对象类型。在`mov.avg()`的情况下，每次
    R 遇到`+`运算符时，都需要检查`x`是否为数值向量，因为它可能在`for`循环的每次迭代中都被修改。相比之下，一种**静态类型**的语言在编译时执行这些检查，从而实现更快的运行时性能。
- en: For this and many other reasons, R's dynamic nature poses barriers to computational
    performance. The only way to break through these barriers is to turn to compiled
    languages such as C and use them from within R. This section assumes that you
    have some basic knowledge of compiled languages such as C/C++, including pointers
    and arrays.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 R 的动态特性以及许多其他原因，R 的动态特性对计算性能构成了障碍。突破这些障碍的唯一方法是转向 C 等编译型语言，并在 R 中使用它们。本节假设您对
    C/C++等编译型语言有一些基本了解，包括指针和数组。
- en: Prerequisites
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: In order to compile the examples in this chapter, a set of development tools,
    including a C/C++ compiler are needed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译本章中的示例，需要一套开发工具，包括 C/C++ 编译器。
- en: Windows users should download and install `Rtools` from [http://cran.r-project.org/bin/windows/Rtools/](http://cran.r-project.org/bin/windows/Rtools/).
    Pick the version of `Rtools` that corresponds to your version of R. Be sure to
    select the **Package authoring installation** and **Edit the system PATH** options
    in the installation wizard.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户应从[http://cran.r-project.org/bin/windows/Rtools/](http://cran.r-project.org/bin/windows/Rtools/)下载并安装`Rtools`。请选择与您的
    R 版本相对应的`Rtools`版本。在安装向导中，务必选择**包作者安装**和**编辑系统 PATH**选项。
- en: On Mac OS X, download and install the *Xcode Command Line Tools*. If you are
    using Mac OS X 10.9 Mavericks or a later version, simply run `xcode-select –install`
    in terminal. For earlier versions of Mac OS X, create a developer account at [http://developer.apple.com/](http://developer.apple.com/).
    Then sign in, go to [https://developer.apple.com/downloads/index.action](https://developer.apple.com/downloads/index.action)
    and search for command-line tools for Xcode for your OS version.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X 上，下载并安装 *Xcode 命令行工具*。如果您使用的是 Mac OS X 10.9 Mavericks 或更高版本，只需在终端中运行`xcode-select
    –install`即可。对于更早版本的 Mac OS X，请在 [http://developer.apple.com/](http://developer.apple.com/)
    创建一个开发者账户。然后登录，转到 [https://developer.apple.com/downloads/index.action](https://developer.apple.com/downloads/index.action)
    并搜索适用于您操作系统版本的 Xcode 命令行工具。
- en: Most Linux distributions offer an easy way to install the standard development
    tools; consult the documentation of your distribution for instructions. If you
    are using Debian or Ubuntu, you can just install `r-base-dev` to get all the tools
    you need.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Linux 发行版都提供了一种简单的方法来安装标准开发工具；请查阅您发行版的文档以获取说明。如果您使用的是 Debian 或 Ubuntu，只需安装`r-base-dev`即可获得您需要的所有工具。
- en: Including compiled code inline
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联包含编译代码
- en: The `inline` CRAN package allows us to embed C, C++, Objective-C, Objective-C++,
    and Fortran code within R. This is handy for speeding up small R functions with
    a bit of compiled code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`inline` CRAN 包允许我们在 R 中嵌入 C、C++、Objective-C、Objective-C++ 和 Fortran 代码。这对于使用少量编译代码加速小的
    R 函数非常有用。'
- en: 'Here is an example of how to implement `mov.avg()`in C using the `inline` package:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用`inline`包在 C 中实现`mov.avg()`的示例：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We load the `inline` package and define `mov.avg.inline()` using `cfunction()`.
    A number of arguments are taken by `cfunction()`(look up the documentation for
    more details), but we need only three here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们加载 `inline` 包，并使用 `cfunction()` 定义 `mov.avg.inline()`。`cfunction()` 接受许多参数（更多细节请查阅文档），但这里我们只需要三个：
- en: '`sig=signature(x="numeric", n="integer")`: This defines the signature of the
    function. In this case, it will look like `mov.avg.inline(x, n)`, where `x` has
    the numeric class and the n has integer class.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sig=signature(x="numeric", n="integer")`: 这定义了函数的签名。在这种情况下，它将看起来像 `mov.avg.inline(x,
    n)`，其中 `x` 具有数值类，而 `n` 具有整数字类。'
- en: '`body`: The `body` argument contains the code for the function''s body in the
    programming language of your choice.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`: `body` 参数包含函数主体的代码，使用你选择的编程语言。'
- en: '`language="C"`: This specifies the programming language of the code in body.
    Valid values are `C,` `C++`, `Fortran`, `F95`, `ObjectiveC`, and `ObjectiveC++`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`language="C"`: 这指定了代码主体中的编程语言。有效的值有 `C,` `C++`, `Fortran`, `F95`, `ObjectiveC`,
    和 `ObjectiveC++`。'
- en: The first step of the function is to make sure that the arguments supplied to
    the function are of the correct type by calling `coerceVector()`. This function
    returns an `SEXP` (s-expression) pointer, which is how all R objects are represented
    in C and C++. These pointers point to `SEXPREC` (s-expression) record structures
    that store the data along with some header information. The first two lines of
    code define two new `SEXP` variables, `x2` and `n2`, that store pointers to new
    R objects created by coercing the function arguments.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一步是通过调用 `coerceVector()` 确保提供给函数的参数是正确的类型。这个函数返回一个 `SEXP`（s表达式）指针，这是在 C
    和 C++ 中表示所有 R 对象的方式。这些指针指向存储数据的 `SEXPREC`（s表达式）记录结构，并包含一些头部信息。代码的前两行定义了两个新的 `SEXP`
    变量 `x2` 和 `n2`，它们存储了通过强制转换函数参数创建的新 R 对象的指针。
- en: Because `coerceVector()` creates new data structures in memory to store the
    data in the specified types, we wrap the calls to `coerceVector()` in the macro
    function `PROTECT()`, which protects the newly created data structures from R's
    garbage collection mechanisms. This is necessary because R does not know when
    variables are no longer needed in C, and might be overzealous in freeing memory
    for objects that are still needed. `PROTECT()` needs to be called every time memory
    is allocated for a new R object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `coerceVector()` 在内存中创建新的数据结构来存储指定类型的数据，所以我们用宏函数 `PROTECT()` 包裹对 `coerceVector()`
    的调用，以保护新创建的数据结构免受 R 的垃圾回收机制的影响。这是必要的，因为 R 不会知道在 C 中何时变量不再需要，并且可能会过于积极地为仍然需要的对象释放内存。每次为新的
    R 对象分配内存时都需要调用 `PROTECT()`。
- en: Now `x2` and `n2` contain `SEXP` pointers of R objects that represent the coerced
    arguments. Because `x2` and `n2` point to `SEXPREC` structures, we still do not
    have direct access to the C arrays that store the data. There are a couple of
    ways to get access to the data. In `double *x_p = REAL(x2);`, the `REAL()` macro
    returns a `double*` pointing to the first element of the double array. The `int
    n_val = asInteger(n2);` declaration takes a different approach by calling the
    `asInteger()` convenience function to return the first integer value in the array
    pointed to by `n2`. Notice the difference here; `x_p` is a pointer to a double
    array while `n_val` is an integer containing the actual value of the argument.
    Both styles of access to the R data can be used depending on which is more convenient.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `x2` 和 `n2` 包含了 R 对象的 `SEXP` 指针，这些对象代表了强制转换后的参数。因为 `x2` 和 `n2` 指向 `SEXPREC`
    结构，所以我们仍然无法直接访问存储数据的 C 数组。有几种方法可以获取对数据的访问权限。在 `double *x_p = REAL(x2);` 中，`REAL()`
    宏返回一个指向双精度浮点数组第一个元素的 `double*` 指针。`int n_val = asInteger(n2);` 声明通过调用 `asInteger()`
    便利函数以不同的方式返回由 `n2` 指向的数组中的第一个整数值。注意这里的区别；`x_p` 是指向双精度数组的指针，而 `n_val` 是包含参数实际值的整数。根据哪种方式更方便，可以使用这两种方式访问
    R 数据。
- en: Next, we compute the length `res_len` of the numeric vector in which we will
    store the results, and create the vector using `allocVector()`. Again, this is
    wrapped in `PROTECT()` because memory is being allocated for a new object. The
    result of this expression is a `SEXP` pointing to the new R numeric vector. `REAL(res)`
    provides access to the underlying C double array, as before.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算将要存储结果的数值向量的长度 `res_len`，并使用 `allocVector()` 创建该向量。同样，这也被 `PROTECT()`
    包裹起来，因为正在为新的对象分配内存。这个表达式的结果是指向新 R 数值向量的 `SEXP`。`REAL(res)` 提供了对之前提到的底层 C 双精度浮点数组的访问。
- en: The next pair of nested `for` loops computes the window sum with the `n_val`
    period. Then, the moving average is computed by dividing each element of the results
    array by `n_val`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个嵌套的`for`循环对`n_val`周期内的窗口和进行计算。然后，通过将结果数组中的每个元素除以`n_val`来计算移动平均。
- en: Before returning the results, there is some housekeeping that is required. `UNPROTECT(3)`
    tells R that the three objects for which memory was allocated in C, do not need
    protection from garbage collection anymore. The argument to `UNPROTECT()` must
    match the number of calls to `PROTECT()` in the function. In this case, it is
    likely that the the garbage collector will free the memory for `x2` and `n2`.
    The `res` object, however, is passed back to R, where the normal garbage collection
    mechanisms apply.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回结果之前，需要进行一些清理工作。`UNPROTECT(3)`告诉R，为C中分配内存的三个对象不再需要垃圾收集保护。`UNPROTECT()`的参数必须与函数中`PROTECT()`调用的次数相匹配。在这种情况下，垃圾收集器可能会释放`x2`和`n2`的内存。然而，`res`对象被返回到R，其中适用正常的垃圾收集机制。
- en: 'Let''s do a simple test to ensure that our code works correctly by calling
    the original `mov.avg()` function alongside `mov.avg.inline()` and ensuring that
    the values match:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过调用原始的`mov.avg()`函数和`mov.avg.inline()`，并确保值匹配来进行一个简单的测试，以确保我们的代码工作正常：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'How much quicker will the C code run than the original uncompiled R function?
    This is shown, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: C代码将比原始未编译的R函数快多少？这如下所示：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The C code took an average of just 1.55 μs compared with 34.8 μs for the R
    code—a 96 percent reduction in execution time! Even the maximum execution time
    in C (14.2 μs) is less than half of the minimum execution time in R (32.9 μs).
    These savings of a few microseconds might not seem like much, but the difference
    becomes significant when we have to process larger datasets or compute moving
    averages with larger periods:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: C代码的平均执行时间仅为1.55 μs，而R代码为34.8 μs——执行时间减少了96！即使是C代码的最大执行时间（14.2 μs）也小于R代码的最小执行时间（32.9
    μs）的一半。这些微秒的节省可能看起来不多，但当我们需要处理更大的数据集或计算较大周期的移动平均时，这种差异变得非常显著：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the data contains 10 million numbers, the difference is more pronounced;
    over 2 seconds in R and only 0.28 seconds in C. In some business contexts, every
    millisecond counts, and a latency of 2 seconds is not acceptable. In such situations,
    writing key pieces of data processing code in a compiled language like C or Fortran
    and embedding them into R using `inline` will give a huge boost to computational
    performance.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据包含1000万个数字时，差异更为明显；在R中超过2秒，而在C中仅为0.28秒。在某些商业环境中，每一毫秒都很重要，2秒的延迟是不可接受的。在这种情况下，将关键的数据处理代码编写为C或Fortran等编译语言，并通过`inline`将其嵌入到R中，将极大地提高计算性能。
- en: Calling external compiled code
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用外部编译代码
- en: We have seen how to use a compiled language to define functions in R. When we
    want to implement more complex functionality using compiled code, such as creating
    entire R packages or linking to external libraries, it might be easier to develop
    the code externally and to call it from R.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用编译语言在R中定义函数。当我们想要使用编译代码实现更复杂的功能时，例如创建整个R包或链接到外部库，从外部开发代码并从R中调用它可能更容易。
- en: 'R provides a few interfaces to call the external compiled code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: R提供了一些接口来调用外部编译代码：
- en: '`.C()`: This calls C or C++ code with a maximum of 65 arguments. Type checking
    and coercion must be done in R before calling the C function. Functions called
    by `.C()` should not return any values; instead, when the function is called,
    the results stored by data structures should be supplied to the function. For
    example, if we were to implement `mov.avg()` using the `.C()` interface, the function
    call might look like `.C("mov_avg_C", as.numeric(x), as.integer(n), numeric(length(x)
    - n + 1))`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.C()`: 这将调用最多65个参数的C或C++代码。在调用C函数之前，必须在R中进行类型检查和强制转换。由`.C()`调用的函数不应返回任何值；相反，当函数被调用时，应该将数据结构中存储的结果提供给函数。例如，如果我们使用`.C()`接口实现`mov.avg()`，函数调用可能看起来像`.C("mov_avg_C",
    as.numeric(x), as.integer(n), numeric(length(x) - n + 1))`。'
- en: '`.Fortran()`: This is similar to `.C()` except it calls `Fortran` code.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Fortran()`: 这与`.C()`类似，但它调用Fortran代码。'
- en: '`.Call()`: This also calls C or C++ code with a maximum of 65 arguments. Type
    checking and coercion can be done in R or in C/C++ (as in the `mov.avg.inline()`
    example). Functions called by `.Call()` can return an R object. If multiple return
    values are needed, an R list can be returned. For example, `ma <- .Call("mov_avg_C",
    x, n)`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Call()`：这也调用C或C++代码，最多65个参数。类型检查和强制转换可以在R或C/C++（如`mov.avg.inline()`示例中）中进行。由`.Call()`调用的函数可以返回R对象。如果需要多个返回值，可以返回R列表。例如，`ma
    <- .Call("mov_avg_C", x, n)`。'
- en: '`.External()`: This is similar to `.Call()` except all arguments are passed
    in a single `SEXP`. As a result, functions called with `.External()` can accept
    a variable number of arguments and a practically unlimited number of arguments.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.External()`：这与`.Call()`类似，除了所有参数都通过单个`SEXP`传递。因此，使用`.External()`调用的函数可以接受可变数量的参数和几乎无限数量的参数。'
- en: The functions provided by the `inline` package are actually wrappers for some
    of the lower-level interfaces that make it easier for developers to embed a compiled
    code in R.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`inline`包提供的函数实际上是某些低级接口的包装器，这使得开发人员更容易将编译代码嵌入R中。'
- en: It is beyond the scope of this book to explain in detail how to use these interfaces.
    To learn more, read the *System and foreign language interfaces* and *The R API*
    sections of the *Writing R Extensions* manual (for more information visit [http://cran.r-project.org/doc/manuals/r-release/R-exts.html](http://cran.r-project.org/doc/manuals/r-release/R-exts.html)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本书范围之外，无法详细解释如何使用这些接口。要了解更多信息，请阅读《编写R扩展》手册中的“系统与外语接口”和“R API”部分（更多信息请访问[http://cran.r-project.org/doc/manuals/r-release/R-exts.html](http://cran.r-project.org/doc/manuals/r-release/R-exts.html))。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For Java programmers, the `rJava` package on CRAN provides an interface to Java
    code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java程序员，CRAN上的`rJava`包提供了对Java代码的接口。
- en: 'Instead, we would like to introduce the `Rcpp` package that provides a convenient,
    higher-level API to the `.Call()` interface for C++ code. Here is the moving average
    function implemented using `Rcpp`. Save this code in the `mov_avg_Rcpp.cpp` file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们想介绍`Rcpp`包，它提供了一个方便的、高级的API来访问`.Call()`接口，用于C++代码。以下是使用`Rcpp`实现的移动平均函数：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first line `#include <Rcpp.h>` imports the headers required to use `Rcpp`
    classes and functions. The comment `// [[Rcpp::export]]` is an `Rcpp` attribute.
    It tells `Rcpp` that the following function should be exported to R.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行`#include <Rcpp.h>`导入使用`Rcpp`类和函数所需的头文件。注释`// [[Rcpp::export]]`是`Rcpp`属性。它告诉`Rcpp`以下函数应该导出到R。
- en: '`SEXP` pointers are not used in `mov_avg_Rcpp()`. Instead, `Rcpp` provides
    classes that represent the standard R classes. We can even specify that `n` is
    a single integer and not an integer vector. Whenever `mov_avg_Rcpp()` is called
    from R, `Rcpp` will automatically check that the supplied arguments are of the
    correct type.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mov_avg_Rcpp()`中不使用`SEXP`指针。相反，`Rcpp`提供了表示标准R类的类。我们甚至可以指定`n`是一个单个整数而不是整数向量。每当从R调用`mov_avg_Rcpp()`时，`Rcpp`将自动检查提供的参数是否为正确的类型。
- en: Notice that there are no calls to `PROTECT()` or `UNPROTECT()` here. When `Rcpp::NumericVector
    res(res_len);` creates a new numeric vector for the results, `Rcpp` takes care
    of the memory allocation and protection from garbage collection. It even initializes
    the values of the new vector to zeroes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里没有调用`PROTECT()`或`UNPROTECT()`。当`Rcpp::NumericVector res(res_len);`创建一个新的结果数值向量时，`Rcpp`负责内存分配和防止垃圾回收。它甚至将新向量的值初始化为零。
- en: '`Rcpp` also provides direct access to the data in the `x` argument and the
    results vector `res` without having to ask for pointers to the data.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rcpp`还提供了直接访问`x`参数中的数据和结果向量`res`的功能，而无需请求数据的指针。'
- en: Using `Rcpp`, we can write more succinct and readable code than possible using
    the native `.C()` or `.Call()` interfaces.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Rcpp`，我们可以编写比使用本地的`.C()`或`.Call()`接口更简洁、更易读的代码。
- en: 'Let''s now see how to call this function from within R. Besides loading the
    `Rcpp` library, the only other thing to do is to call `sourceCpp()`, which will
    compile the C++ code and export the function to R:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在R中调用此函数。除了加载`Rcpp`库之外，还需要做的一件事是调用`sourceCpp()`，这将编译C++代码并将函数导出到R：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can call `mov_avg_Rcpp()` and benchmark it against our previous versions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以调用`mov_avg_Rcpp()`并对其进行基准测试，与之前的版本进行比较：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Rcpp` version runs a little slower than the inline version, but it is still
    much faster than our pure R code. It provides a good level of performance with
    a much simpler API than the other interfaces provided by R.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rcpp` 版本比内联版本运行得稍慢，但仍然比我们的纯 R 代码快得多。它提供了一个良好的性能水平，API 比其他 R 提供的接口简单得多。'
- en: '`Rcpp` provides many more features than we can cover in this book such as package
    authoring tools, the `sugar` functions for common operations such as vector operations,
    and more. For more details, code examples, and resources, look up the `Rcpp` website
    at [http://www.rcpp.org/](http://www.rcpp.org/). One of the creators of `Rcpp`,
    Dirk Eddelbuettel, has also written the *Seamless R and C++ Integration with Rcpp
    (use R!)* book that provides a comprehensive guide.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rcpp` 提供了许多本书无法涵盖的功能，例如包作者工具、常见操作（如向量操作）的 `sugar` 函数等。更多详情、代码示例和资源，请查阅 `Rcpp`
    网站 [http://www.rcpp.org/](http://www.rcpp.org/)。`Rcpp` 的创作者之一，Dirk Eddelbuettel，还撰写了
    *Seamless R and C++ Integration with Rcpp (use R!)* 一书，提供了全面的指南。'
- en: Considerations for using compiled code
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用编译代码时，有一些注意事项需要记住。我们将在下面解释一些常见的；*Writing R Extensions* 手册对这些主题提供了全面的处理。
- en: There are a few things to bear in mind while using compiled code in R. We will
    explain the common ones here; the *Writing R Extensions* manual provides a comprehensive
    treatment of these topics.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中使用编译代码时，有一些事情需要记住。我们将在下面解释一些常见的；*Writing R Extensions* 手册对这些主题提供了全面的处理。
- en: R APIs
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: R API
- en: 'The C functions and macros used so far are from the header file `Rinternals.h`,
    found in `R_INCLUDE_DIR` which defaults to `R_HOME/include` in any standard R
    installation. This file, together with `R.h` and other header files in `R_INCLUDE_DIR`,
    provides various APIs for C/C++ code to interface with R. Together they provide
    a rich set of functions for:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止使用的 C 函数和宏来自头文件 `Rinternals.h`，该文件位于 `R_INCLUDE_DIR`，在标准 R 安装中默认为 `R_HOME/include`。此文件，连同
    `R.h` 和 `R_INCLUDE_DIR` 中的其他头文件，为 C/C++ 代码提供了与 R 交互的各种 API。它们一起提供了一组丰富的函数，用于：
- en: Manipulating R objects (for example, sorting vectors)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作 R 对象（例如，排序向量）
- en: Managing memory allocation and deallocation
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理内存分配和释放
- en: Math (for example, trigonometric functions)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学（例如，三角函数）
- en: Mathematical constants
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学常数
- en: Random number generation
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机数生成
- en: Statistical distributions (for example, `rnorm` and `punif`)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计分布（例如，`rnorm` 和 `punif`）
- en: BLAS, LAPACK, and LINPACK linear algebra routines
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BLAS、LAPACK 和 LINPACK 线性代数例程
- en: And much more
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及更多
- en: It is worthwhile to explore these files in order to see which functionality
    is available for C/C++ code. Some of these can be called from Fortran as well.
    The *Organization of header files* section of *Writing R Extensions* describes
    each header file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 值得探索这些文件，以了解哪些功能可用于 C/C++ 代码。其中一些也可以从 Fortran 调用。*Writing R Extensions* 中的 *Organization
    of header files* 部分描述了每个头文件。
- en: R data types versus native data types
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: R 数据类型与本地数据类型
- en: 'While working in compiled languages, it is useful to know how R types map to
    different native data types, as shown in the following table:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用编译语言工作时，了解 R 类型如何映射到不同的本地数据类型是有用的，如下表所示：
- en: '| R storage mode | C type | Fortran type |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| R 存储模式 | C 类型 | Fortran 类型 |'
- en: '| --- | --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `logical` | `int *` | `INTEGER` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `logical` | `int *` | `INTEGER` |'
- en: '| `integer` | `int *` | `INTEGER` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `integer` | `int *` | `INTEGER` |'
- en: '| `double` | `double *` | `DOUBLE PRECISION` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `double *` | `DOUBLE PRECISION` |'
- en: '| `complex` | `Rcomplex *` | `DOUBLE COMPLEX` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `complex` | `Rcomplex *` | `DOUBLE COMPLEX` |'
- en: '| `character` | `char **` | `CHARACTER*255` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `character` | `char **` | `CHARACTER*255` |'
- en: '| `raw` | `unsigned char *` | `none` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `raw` | `unsigned char *` | `none` |'
- en: 'When dealing with `SEXP` pointers in C/C++ or type classes in `Rcpp`, here
    are the most commonly used types (look up the documentation for R or `Rcpp` for
    a complete list):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 C/C++ 中的 `SEXP` 指针或在 `Rcpp` 中的类型类时，以下是最常用的类型（查阅 R 或 `Rcpp` 的文档以获取完整列表）：
- en: '| R type | SEXP Type | Rcpp type |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| R 类型 | SEXP 类型 | Rcpp 类型 |'
- en: '| --- | --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `numeric` | `REALSXP` | `NumericVector / NumericMatrix` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `numeric` | `REALSXP` | `NumericVector / NumericMatrix` |'
- en: '| `integer` | `INTSXP` | `IntegerVector / IntegerMatrix` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `integer` | `INTSXP` | `IntegerVector / IntegerMatrix` |'
- en: '| `complex` | `CPLXSXP` | `ComplexVector / ComplexMatrix` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `complex` | `CPLXSXP` | `ComplexVector / ComplexMatrix` |'
- en: '| `logical` | `LGLSXP` | `LogicalVector / LogicalMatrix` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `logical` | `LGLSXP` | `LogicalVector / LogicalMatrix` |'
- en: '| `character` | `STRSXP` | `CharacterVector / CharacterMatrix` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `character` | `STRSXP` | `CharacterVector / CharacterMatrix` |'
- en: '| `list` | `VECSXP` | `List` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `list` | `VECSXP` | `List` |'
- en: '| `data.frame` | `none` | `DataFrame` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `data.frame` | `none` | `DataFrame` |'
- en: Creating R objects and garbage collection
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 R 对象和垃圾回收
- en: We have seen how R objects can be created and memory can be allocated for them
    by calling `allocVector()` and `coerceVector()`. `Rinternals.h` defines other
    memory allocation functions as well, such as `allocList()` and `allocArray()`.
    Any call to the `alloc*()` functions or `coerceVector()` needs to be wrapped in
    `PROTECT()`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，可以通过调用`allocVector()`和`coerceVector()`来创建R对象并为它们分配内存。`Rinternals.h`定义了其他内存分配函数，例如`allocList()`和`allocArray()`。对`alloc*()`函数或`coerceVector()`的任何调用都需要用`PROTECT()`包装。
- en: In the `mov.avg.inline()` example, `UNPROTECT()` is used to remove garbage collection
    protection right before returning the results. `UNPROTECT()` can also be called
    at any point in a function to allow the garbage collector to release R objects
    that are no longer needed. The protection mechanism is stack-based, so `UNPROTECT(n)`
    removes the protection from the last `n` objects that were protected. Alternatively,
    `UNPROTECT_PTR(p)` can be used to unprotect the specific object that `SEXP` `p`
    points to, even if it is not at the top of the stack.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mov.avg.inline()`示例中，`UNPROTECT()`用于在返回结果之前立即移除垃圾收集保护。`UNPROTECT()`也可以在任何函数点调用，以允许垃圾收集器释放不再需要的R对象。保护机制是基于堆栈的，因此`UNPROTECT(n)`移除了最后被保护的`n`个对象的保护。或者，可以使用`UNPROTECT_PTR(p)`来解除`SEXP`
    `p`指向的特定对象的保护，即使它不在堆栈的顶部。
- en: In complex C/C++ code that creates many R objects, it is good practice to unprotect
    them once they are not needed, so that the garbage collector can do its job efficiently.
    However, it is the programmer's responsibility to make sure that those unprotected
    objects are never used again in the code, to prevent any memory errors.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建许多R对象的复杂C/C++代码中，一旦它们不再需要，就解除保护它们是一种良好的实践，这样垃圾收集器就可以高效地工作。然而，确保那些未受保护的对象在代码中不再被使用是程序员的职责，以防止任何内存错误。
- en: Finally, always remember to match the number of the `PROTECT()` calls with the
    total number of objects unprotected by `UNPROTECT()` or `UNPROTECT_PTR()`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，始终记得将`PROTECT()`调用的数量与`UNPROTECT()`或`UNPROTECT_PTR()`未解除保护的对象总数相匹配。
- en: Allocating memory for non-R objects
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为非R对象分配内存
- en: Sometimes, memory is needed to store the results of intermediate computations
    that do not need to be accessed from R. R provides two ways of allocating memory
    like this in C/C++.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，需要内存来存储中间计算的结果，这些结果不需要从R中访问。R提供了两种在C/C++中分配这种内存的方法。
- en: 'The first method, **transient storage allocation**, allows you to allocate
    memory that is automatically reclaimed by R at the end of the call to `.C()`,
    `.Call()` or `.External()`. To do this, use the `char *R_alloc(size_t n, int size)`
    function, which allocates `n` units of `size` bytes each and returns a pointer
    to the allocated memory. A typical usage might look like:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法，**瞬态存储分配**，允许您分配在`.C()`、`.Call()`或`.External()`调用结束时由R自动回收的内存。为此，使用`char
    *R_alloc(size_t n, int size)`函数，该函数分配每个`size`字节的`n`个单元，并返回指向分配内存的指针。典型的用法可能如下所示：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is no need to free the allocated memory within the C/C++ function, as
    R will take care of that when the function execution ends.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在C/C++函数内不需要释放分配的内存，因为当函数执行结束时，R会负责处理。
- en: 'The **user-controlled memory** mechanism provides more control over the allocation
    and freeing of memory. This allows memory to be freed between different parts
    of C/C++ code. For example, in an iterative algorithm where each stage of computation
    produces large amounts of intermediate data, memory from previous iterations can
    be freed to ensure that there is sufficient free memory to complete future iterations.
    There are three functions in this interface:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户控制的内存**机制提供了对内存分配和释放的更多控制。这允许在C/C++代码的不同部分之间释放内存。例如，在一个迭代算法中，每个计算阶段都会产生大量中间数据，可以释放之前迭代的内存，以确保有足够的空闲内存来完成未来的迭代。此接口中有三个函数：'
- en: '`type* Calloc(size_t n, type)`: This allocates memory of the specified size
    and type'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type* Calloc(size_t n, type)`: 这会分配指定大小和类型的内存'
- en: '`type* Realloc(any *p, size_t n, type)`: This changes the size of the memory
    allocated at `*p` to the specified size and type'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type* Realloc(any *p, size_t n, type)`: 这会将`*p`处分配的内存的大小更改为指定的大小和类型'
- en: '`void Free(any *p)`: This frees the memory at `*p`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Free(any *p)`: 这会释放`*p`处的内存'
- en: These functions are analogous to the C functions `calloc()`, `realloc()`, and
    `free()`, with additional error handling by R. If they return, then the memory
    has been successfully allocated or freed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数类似于C函数`calloc()`、`realloc()`和`free()`，但R增加了额外的错误处理。如果它们返回，则表示内存已成功分配或释放。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a variety of techniques to leverage code in compiled
    languages for a near-native CPU performance. While the examples focused on C and
    C++, similar approaches can be used with Fortran or Java.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一系列技术，用于在编译型语言中利用代码以实现接近原生CPU的性能。虽然示例主要集中在C和C++上，但类似的策略也可以用于Fortran或Java。
- en: We first saw how compiling an R code before its execution by using the `compile`
    package can provide modest performance gains, especially for code with many loops
    and basic operations. JIT compilation does the same automatically for executing
    any R code. There is a limit, however, to how much an R code can be optimized
    because R is a dynamic language at its core.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看到，通过使用`compile`包在执行R代码之前对其进行编译，可以提供适度的性能提升，特别是对于包含许多循环和基本操作的代码。JIT编译对执行任何R代码也自动执行相同的操作。然而，由于R在核心上是动态语言，R代码的优化程度是有限的。
- en: Looking beyond R, we used C and C++ to achieve dramatic performance improvements.
    We learned how to define a C function from within R, using the `inline` package,
    and how to use `Rcpp` to call an external C++ function from R.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 超越R语言，我们使用了C和C++来实现显著的性能提升。我们学习了如何在R中使用`inline`包定义C函数，以及如何使用`Rcpp`从R中调用外部C++函数。
- en: In the process, we learned about how R represents different types of data in
    C/C++ using `SEXP` pointers and `SEXPREC` record structures, and how to manipulate
    R objects using these constructs. We also learned about the intricacies of allocating
    memory, freeing memory, and garbage collection while working in C/C++.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们了解了R如何使用`SEXP`指针和`SEXPREC`记录结构在C/C++中表示不同类型的数据，以及如何使用这些结构来操作R对象。我们还学习了在C/C++中工作时的内存分配、释放和垃圾回收的复杂性。
- en: Finally, we took a quick tour of the R APIs that provide rich R functionality
    from within C, C++, or Fortran.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要介绍了R API，这些API可以从C、C++或Fortran中提供丰富的R功能。
- en: This chapter covered advanced techniques to achieve optimized computational
    performance in R, using compiled languages. These techniques allow R programmers
    to tap into the power and speed of compiled languages while enjoying the simplicity
    and flexibility of R as a data processing environment. The huge performance gains
    from using compiled languages come with an equally huge responsibility to understand
    in detail how these techniques work, so that they can be used safely and effectively.
    Whole books could be written on this topic; we encourage you to look up other
    resources including the *Writing R Extensions* manual for a deeper and more comprehensive
    treatment.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在R中使用编译型语言实现优化计算性能的高级技术。这些技术允许R程序员利用编译型语言的力量和速度，同时享受R作为数据处理环境的简单性和灵活性。使用编译型语言带来的巨大性能提升伴随着同样巨大的责任，即详细了解这些技术的工作原理，以确保它们可以安全有效地使用。关于这个主题，可以写出整本书；我们鼓励您查阅其他资源，包括*编写R扩展*手册，以获得更深入和更全面的处理。
- en: In the next chapter, we will look at how to leverage the computing power of
    **Graphics Processing Units** (**GPUs**) for certain types of computations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何利用**图形处理单元**（**GPU**）的计算能力来处理某些类型的计算。
