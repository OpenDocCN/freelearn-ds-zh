- en: Chapter 3. Mastering the Notebook
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章：掌握笔记本
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Teaching programming in the notebook with IPython blocks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在笔记本中使用IPython块教授编程
- en: Converting an IPython notebook to other formats with nbconvert
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用nbconvert将IPython笔记本转换为其他格式
- en: Adding custom controls in the notebook toolbar
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在笔记本工具栏中添加自定义控件
- en: Customizing the CSS style in the notebook
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义笔记本中的CSS样式
- en: Using interactive widgets – a piano in the notebook
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用交互式小部件——笔记本中的钢琴
- en: Creating a custom JavaScript widget in the notebook – a spreadsheet editor for
    pandas
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在笔记本中创建自定义JavaScript小部件——一个用于pandas的电子表格编辑器
- en: Processing webcam images in real time from the notebook
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从笔记本实时处理网络摄像头图像
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will see many features of the notebook, including the interactive
    widgets that have been brought by IPython 2.0\. As we have only seen basic features
    in the previous chapters, we will dive deeper into the architecture of the notebook
    here.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解笔记本的许多功能，包括IPython 2.0带来的交互式小部件。由于在前几章中我们仅了解了基本功能，这里将深入探讨笔记本的架构。
- en: What is the notebook?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是笔记本？
- en: The notebook was released in 2011, ten years after the creation of IPython.
    Its development has a long and complex history that is nicely summarized by Fernando
    Perez on his blog, [http://blog.fperez.org/2012/01/ipython-notebook-historical.html](http://blog.fperez.org/2012/01/ipython-notebook-historical.html).
    Inspired by mathematical software such as Maple, Mathematica, or Sage, the notebook
    really fostered the popularity of IPython.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本于2011年发布，比IPython创建晚了十年。它的发展有着悠久且复杂的历史，费尔南多·佩雷斯在他的博客上对其进行了很好的总结，[http://blog.fperez.org/2012/01/ipython-notebook-historical.html](http://blog.fperez.org/2012/01/ipython-notebook-historical.html)。受到数学软件如Maple、Mathematica或Sage的启发，笔记本极大地推动了IPython的流行。
- en: By mixing together code, text, images, plots, hypertext links, and mathematical
    equations in a single document, the notebook brings reproducibility to interactive
    computing. The notebook, when used correctly, can radically change workflows in
    scientific computing. Prior to the notebook, one had to juggle between a text
    editor and an interactive prompt; now, one can stay focused within a single unified
    environment.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将代码、文本、图像、图表、超链接和数学方程式混合在一个文档中，笔记本为交互式计算带来了可复现性。正确使用笔记本时，它能够彻底改变科学计算中的工作流程。在笔记本出现之前，人们不得不在文本编辑器和交互式提示之间来回切换；而现在，人们可以在一个统一的环境中保持专注。
- en: The notebook is not only a tool but also a powerful and robust architecture.
    Furthermore, this architecture is mostly language independent, so it's no longer
    tied to Python. The notebook defines a set of messaging protocols, APIs, and JavaScript
    code that can be used by other languages. In effect, we are now seeing non-Python
    kernels that can interact with the notebook such as IJulia, IHaskell, IRuby, and
    others.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本不仅是一个工具，还是一个强大且健壮的架构。此外，这个架构大多是语言独立的，因此它不再仅限于Python。笔记本定义了一套消息传递协议、API和JavaScript代码，其他语言也可以使用这些协议和代码。实际上，我们现在已经看到非Python内核能够与笔记本进行交互，如IJulia、IHaskell、IRuby等。
- en: 'At the SciPy conference in July 2014, the IPython developers even announced
    their decision to split the project into the following two parts:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年7月的SciPy大会上，IPython开发者甚至宣布他们决定将项目拆分为以下两部分：
- en: 'The new **Project** **Jupyter** will implement all language-independent parts:
    the notebook, the messaging protocol, and the overall architecture. For more details,
    visit [http://jupyter.org](http://jupyter.org).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的**Jupyter项目**将实现所有语言独立部分：笔记本、消息传递协议和整体架构。欲了解更多详情，请访问[http://jupyter.org](http://jupyter.org)。
- en: IPython will be the name of the Python kernel.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPython将作为Python内核的名称。
- en: In this book, we do not make that semantic distinction, and we will use the
    term IPython to refer to the project as a whole (language-independent parts and
    Python kernel).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们并不做语义上的区分，而是使用IPython一词来指代整个项目（包括语言独立部分和Python内核）。
- en: The notebook ecosystem
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 笔记本生态系统
- en: Notebooks are represented as **JavaScript Object** **Notation** (**JSON**) documents.
    JSON is a language-independent, text-based file format for representing structured
    documents. As such, notebooks can be processed by any programming language, and
    they can be converted to other formats such as Markdown, HTML, LaTeX/PDF, and
    others.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本被表示为**JavaScript对象** **表示法**（**JSON**）文档。JSON是一种语言独立的、基于文本的文件格式，用于表示结构化文档。因此，笔记本可以被任何编程语言处理，并且可以转换为其他格式，如Markdown、HTML、LaTeX/PDF等。
- en: An ecosystem is being built around the notebook, and we can expect to see more
    and more usage in the near future. For example, Google is working on bringing
    the IPython notebook to Google Drive for collaborative data analytics. Also, notebooks
    are being used to create slides, teaching materials, blog posts, research papers,
    and even books. In fact, this very book is entirely written in the notebook.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个围绕笔记本的生态系统正在建立，我们可以期待在不久的将来看到越来越多的使用案例。例如，Google 正在努力将 IPython 笔记本引入 Google
    Drive，以实现协作数据分析。此外，笔记本还被用来创建幻灯片、教学材料、博客文章、研究论文，甚至是书籍。实际上，本书完全是用笔记本写成的。
- en: IPython 2.0 introduced interactive widgets in the notebook. These widgets bring
    Python and the browser even closer. We can now create applications that implement
    bidirectional communication between the IPython kernel and the browser. Also,
    any JavaScript interactive library can be, in principle, integrated within the
    notebook. For example, the `D3.js` JavaScript visualization library is now being
    used by several Python projects to enable interactive visualization capabilities
    to the notebook. We are probably going to see many interesting uses of these interactive
    features in the near future.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 2.0 引入了交互式小部件（widgets）。这些小部件使 Python 和浏览器之间的联系更加紧密。我们现在可以创建实现 IPython
    内核与浏览器之间双向通信的应用程序。此外，任何 JavaScript 交互式库原则上都可以集成到笔记本中。例如，`D3.js` JavaScript 可视化库现在被多个
    Python 项目使用，以便为笔记本提供交互式可视化功能。我们可能会在不久的将来看到这些交互式功能的许多有趣应用。
- en: Architecture of the IPython notebook
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPython 笔记本的架构
- en: IPython implements a two-process model, with a **kernel** and a **client**.
    The client is the interface offering the user the ability to send Python code
    to the kernel. The kernel executes the code and returns the result to the client
    for display. In the **Read-Evaluate-Print Loop** (**REPL**) terminology, the kernel
    implements the *Evaluate*, whereas the client implements the *Read* and the *Print*
    of the process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 实现了一个双进程模型，包含一个**内核**和一个**客户端**。客户端是提供给用户发送 Python 代码到内核的接口。内核执行代码并将结果返回给客户端以供显示。在**读-评估-打印循环**（**REPL**）术语中，内核实现了*评估*，而客户端则实现了*读取*和*打印*过程。
- en: The client can be a Qt widget if we run the Qt console, or a browser if we run
    the notebook. In the notebook, the kernel receives entire cells at once, and thus
    has no notion of a notebook. There is a strong decoupling between the linear document
    containing the notebook, and the underlying kernel. This is a very strong constraint
    that may limit the possibilities, but that nevertheless leads to great simplicity
    and flexibility.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以是 Qt 控件（如果我们运行 Qt 控制台），也可以是浏览器（如果我们运行笔记本）。在笔记本中，内核一次接收完整的单元，因此并不认识笔记本的存在。包含笔记本的线性文档与底层内核之间有很强的解耦。这是一个很强的限制，可能会限制某些可能性，但它仍然带来了极大的简洁性和灵活性。
- en: Another fundamental assumption in the whole architecture is that there can be
    at most one kernel connected to a notebook. However, IPython 3.0 offers the possibility
    of choosing the language kernel for any notebook.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 整个架构中的另一个基本假设是，每个笔记本至多只能连接一个内核。然而，IPython 3.0 提供了选择任何笔记本的语言内核的可能性。
- en: It is important to keep these points in mind when thinking about new use-case
    scenarios for the notebook.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑笔记本的新使用场景时，牢记这些要点非常重要。
- en: In the notebook, in addition to the Python kernel and the browser client, there
    is a Python server based on **Tornado** ([www.tornadoweb.org](http://www.tornadoweb.org)).
    This process serves the HTML-based notebook interface.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本中，除了 Python 内核和浏览器客户端外，还有一个基于**Tornado**的 Python 服务器（[www.tornadoweb.org](http://www.tornadoweb.org)）。该进程为
    HTML 基础的笔记本界面提供服务。
- en: All communication procedures between the different processes are implemented
    on top of the **ZeroMQ** (or **ZMQ**) messaging protocol ([http://zeromq.org](http://zeromq.org)).
    The notebook communicates with the underlying kernel using **WebSocket**, a TCP-based
    protocol implemented in modern web browsers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不同进程之间的所有通信过程都建立在**ZeroMQ**（或**ZMQ**）消息协议之上（[http://zeromq.org](http://zeromq.org)）。笔记本通过**WebSocket**（一种基于
    TCP 的协议，现代浏览器中已实现）与底层内核进行通信。
- en: 'The browsers that officially support the notebook in IPython 2.x are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 官方支持 IPython 2.x 笔记本的浏览器如下：
- en: Chrome ≥ 13
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome ≥ 13
- en: Safari ≥ 5
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Safari ≥ 5
- en: Firefox ≥ 6
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firefox ≥ 6
- en: The notebook should also work on Internet Explorer ≥ 10\. These requirements
    are essentially those for WebSocket.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该笔记本还应在 Internet Explorer ≥ 10 上运行。这些要求本质上是 WebSocket 的要求。
- en: Connecting multiple clients to one kernel
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将多个客户端连接到一个内核
- en: 'In a notebook, typing `%connect_info` in a cell gives the information we need
    to connect a new client (such as a Qt console) to the underlying kernel:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本中，在一个单元格输入 `%connect_info` 会显示我们连接新客户端（例如 Qt 控制台）到底层内核所需的信息：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `<app>` is `console`, `qtconsole`, or `notebook`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<app>` 是 `console`、`qtconsole` 或 `notebook`。
- en: It is even possible to have the kernel and the client running on different machines.
    You will find the instructions to run a public notebook server in the IPython
    documentation, available at [http://ipython.org/ipython-doc/dev/notebook/public_server.html#running-a-public-notebook-server](http://ipython.org/ipython-doc/dev/notebook/public_server.html#running-a-public-notebook-server).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以让内核和客户端运行在不同的机器上。你可以在 IPython 文档中找到运行公共笔记本服务器的说明，详见 [http://ipython.org/ipython-doc/dev/notebook/public_server.html#running-a-public-notebook-server](http://ipython.org/ipython-doc/dev/notebook/public_server.html#running-a-public-notebook-server)。
- en: Security in notebooks
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 笔记本中的安全性
- en: It is possible for someone to put malicious code in an IPython notebook. Since
    notebooks may contain hidden JavaScript code in a cell output, it is theoretically
    possible for malicious code to execute surreptitiously when the user opens a notebook.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能有人在 IPython 笔记本中插入恶意代码。由于笔记本中可能包含单元格输出中的隐藏 JavaScript 代码，因此理论上，当用户打开笔记本时，恶意代码有可能在不被察觉的情况下执行。
- en: For this reason, IPython 2.0 introduced a security model where HTML and JavaScript
    code in a notebook can be either trusted or untrusted. Outputs generated by the
    user are always trusted. However, outputs that were already there when the user
    first opened an existing notebook are untrusted.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，IPython 2.0 引入了一个安全模型，在该模型中，笔记本中的 HTML 和 JavaScript 代码可以被标记为受信任或不受信任。用户生成的输出始终是受信任的。然而，当用户首次打开一个现有笔记本时，已存在的输出被视为不受信任。
- en: The security model is based on a cryptographic signature present in every notebook.
    This signature is generated using a secret key owned by every user.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 安全模型基于每个笔记本中的加密签名。这个签名是通过每个用户拥有的私钥生成的。
- en: You can find further references on the security model in the following section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在接下来的部分中找到有关安全模型的更多参考资料。
- en: References
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'The following are some references about the notebook architecture:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于笔记本架构的参考资料：
- en: The IPython two-process model, explained at [http://ipython.org/ipython-doc/stable/overview.html#decoupled-two-process-model](http://ipython.org/ipython-doc/stable/overview.html#decoupled-two-process-model)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPython 双进程模型，详见 [http://ipython.org/ipython-doc/stable/overview.html#decoupled-two-process-model](http://ipython.org/ipython-doc/stable/overview.html#decoupled-two-process-model)
- en: Documentation of the notebook, available at [http://ipython.org/ipython-doc/stable/interactive/notebook.html](http://ipython.org/ipython-doc/stable/interactive/notebook.html)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该笔记本的文档，请参阅 [http://ipython.org/ipython-doc/stable/interactive/notebook.html](http://ipython.org/ipython-doc/stable/interactive/notebook.html)
- en: Security in the notebook, described at [http://ipython.org/ipython-doc/dev/notebook/security.html](http://ipython.org/ipython-doc/dev/notebook/security.html)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记本中的安全性，详见 [http://ipython.org/ipython-doc/dev/notebook/security.html](http://ipython.org/ipython-doc/dev/notebook/security.html)
- en: The notebook server, described at [http://ipython.org/ipython-doc/dev/interactive/public_server.html](http://ipython.org/ipython-doc/dev/interactive/public_server.html)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记本服务器，详见 [http://ipython.org/ipython-doc/dev/interactive/public_server.html](http://ipython.org/ipython-doc/dev/interactive/public_server.html)
- en: The IPython messaging protocol, at [http://ipython.org/ipython-doc/dev/development/messaging.html](http://ipython.org/ipython-doc/dev/development/messaging.html)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPython 消息协议，详见 [http://ipython.org/ipython-doc/dev/development/messaging.html](http://ipython.org/ipython-doc/dev/development/messaging.html)
- en: Tutorial about how to write a custom kernel for the notebook, at [http://andrew.gibiansky.com/blog/ipython/ipython-kernels/](http://andrew.gibiansky.com/blog/ipython/ipython-kernels/)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何为笔记本编写自定义内核的教程，详见 [http://andrew.gibiansky.com/blog/ipython/ipython-kernels/](http://andrew.gibiansky.com/blog/ipython/ipython-kernels/)
- en: 'Here are a few (mostly experimental) kernels in non-Python languages for the
    notebook:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些（主要是实验性的）非 Python 语言内核，用于笔记本：
- en: IJulia, available at [https://github.com/JuliaLang/IJulia.jl](https://github.com/JuliaLang/IJulia.jl)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IJulia，请参阅 [https://github.com/JuliaLang/IJulia.jl](https://github.com/JuliaLang/IJulia.jl)
- en: IRuby, available at [https://github.com/isotope11/iruby](https://github.com/isotope11/iruby)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IRuby，请参阅 [https://github.com/isotope11/iruby](https://github.com/isotope11/iruby)
- en: IHaskell, available at [https://github.com/gibiansky/IHaskell](https://github.com/gibiansky/IHaskell)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IHaskell，请参阅 [https://github.com/gibiansky/IHaskell](https://github.com/gibiansky/IHaskell)
- en: IGo, available at [https://github.com/takluyver/igo](https://github.com/takluyver/igo)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IGo，可在[https://github.com/takluyver/igo](https://github.com/takluyver/igo)找到
- en: IScala, available at [https://github.com/mattpap/IScala](https://github.com/mattpap/IScala)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IScala，可在[https://github.com/mattpap/IScala](https://github.com/mattpap/IScala)找到
- en: Teaching programming in the notebook with IPython blocks
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在IPython块中进行编程教学
- en: 'The IPython notebook is not only a tool for scientific research and data analysis
    but also a great tool for teaching. In this recipe, we show a simple and fun Python
    library for teaching programming notions: **IPython Blocks** (available at [http://ipythonblocks.org](http://ipythonblocks.org)).
    This library allows you or your students to create grids of colorful blocks. You
    can change the color and size of individual blocks, and you can even animate your
    grids. There are many basic technical notions you can illustrate with this tool.
    The visual aspect of this tool makes the learning process more effective and engaging.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: IPython笔记本不仅是科学研究和数据分析的工具，还是一款很棒的教学工具。在这个示例中，我们展示了一个简单有趣的Python库，用于教授编程概念：**IPython
    Blocks**（可在[http://ipythonblocks.org](http://ipythonblocks.org)找到）。这个库允许你或你的学生创建五颜六色的方块网格。你可以改变每个方块的颜色和大小，甚至可以让网格动起来。通过这个工具，你可以演示许多基本的技术概念。这个工具的可视化特点使得学习过程更加高效且富有吸引力。
- en: 'In this recipe, we will notably perform the following tasks:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将主要执行以下任务：
- en: Illustrate matrix multiplication with an animation
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用动画演示矩阵乘法
- en: Display an image as a block grid
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像显示为方块网格
- en: This recipe is partly inspired by the example at [http://nbviewer.ipython.org/gist/picken19/b0034ba7ec690e89ea79](http://nbviewer.ipython.org/gist/picken19/b0034ba7ec690e89ea79).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例部分灵感来源于[http://nbviewer.ipython.org/gist/picken19/b0034ba7ec690e89ea79](http://nbviewer.ipython.org/gist/picken19/b0034ba7ec690e89ea79)中的一个例子。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install IPython Blocks for this recipe. You can just type in a terminal
    `pip install ipythonblocks`. Note that you can also execute this shell command
    from the IPython notebook by prefixing this command with `!`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为这个示例安装IPython Blocks。你只需在终端中输入`pip install ipythonblocks`即可。请注意，你也可以通过在IPython笔记本中在命令前加上`!`来执行这个命令。
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the last part of this recipe, you also need to install Pillow, available
    at [http://pillow.readthedocs.org/en/latest/](http://pillow.readthedocs.org/en/latest/);
    you will find more instructions in [Chapter 11](ch11.html "Chapter 11. Image and
    Audio Processing"), *Image and Audio Processing*. With Anaconda, you can execute
    `conda install pillow` in a terminal.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的最后部分，你还需要安装Pillow，相关文档可在[http://pillow.readthedocs.org/en/latest/](http://pillow.readthedocs.org/en/latest/)找到；更多说明请参见[第11章](ch11.html
    "第11章 图像和音频处理")，*图像和音频处理*。如果你使用Anaconda，可以在终端执行`conda install pillow`。
- en: Finally, you need to download the *Portrait* dataset from the book's website
    ([https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data))
    and extract it in the current directory. You can also play with your own images!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要从本书网站下载*Portrait*数据集（[https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)）并在当前目录下解压。你也可以使用你自己的图像进行实验！
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we import some modules as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入一些模块，代码如下：
- en: '[PRE2]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we create a block grid with five columns and five rows, and we fill each
    block in purple:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个五列五行的方块网格，并将每个方块填充为紫色：
- en: '[PRE3]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![How to do it...](img/4818OS_03_01.jpg)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_03_01.jpg)'
- en: 'We can access individual blocks with 2D indexing. This illustrates the indexing
    syntax in Python. We can also access an entire row or line with a `:` (colon).
    Each block is represented by an RGB color. The library comes with a handy dictionary
    of colors, assigning RGB tuples to standard color names as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过二维索引来访问单独的方块。这演示了Python中的索引语法。我们还可以用`:`（冒号）来访问整个行或列。每个方块都是由RGB颜色表示的。这个库附带了一个便捷的颜色字典，将RGB元组分配给标准颜色名称，如下所示：
- en: '[PRE4]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![How to do it...](img/4818OS_03_02.jpg)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_03_02.jpg)'
- en: Now, we are going to illustrate matrix multiplication, a fundamental notion
    in linear algebra. We will represent two (`n,n`) matrices, `A` (in cyan) and `B`
    (lime) aligned with `C = A B` (yellow). To do this, we use a small trick of creating
    a big white grid of size (`2n+1,2n+1`). The matrices `A`, `B`, and `C` are just
    views on parts of the grid.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将演示矩阵乘法，这是线性代数中的一个基本概念。我们将表示两个（`n,n`）矩阵，`A`（青色）和`B`（青柠色），并与`C = A B`（黄色）对齐。为了实现这一点，我们采用一个小技巧，创建一个大小为（`2n+1,2n+1`）的大白网格。矩阵`A`、`B`和`C`只是网格部分的视图。
- en: '[PRE5]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![How to do it...](img/4818OS_03_03.jpg)'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_03_03.jpg)'
- en: 'Let''s turn to matrix multiplication itself. We perform a loop over all rows
    and columns, and we highlight the corresponding rows and columns in A and B that
    are multiplied together during the matrix product. We combine IPython''s `clear_output()`
    method with `grid.show()` and `time.sleep()` (pause) to implement the animation
    as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转向矩阵乘法本身。我们对所有行和列进行循环，并突出显示在矩阵乘法过程中相乘的 A 和 B 中对应的行和列。我们结合使用 IPython 的 `clear_output()`
    方法与 `grid.show()` 和 `time.sleep()`（暂停）来实现动画，如下所示：
- en: '[PRE6]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![How to do it...](img/4818OS_03_04.jpg)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_03_04.jpg)'
- en: 'Finally, we will display an image with IPython Blocks. We import the JPG image
    with `Image.open()` and we retrieve the data with `getdata()` as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用 IPython Blocks 显示一张图片。我们使用 `Image.open()` 导入 JPG 图片，并通过 `getdata()`
    获取数据，具体如下：
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we create a `BlockGrid` instance with the appropriate number of rows and
    columns, and we set each block''s color to the corresponding pixel''s color in
    the image. We use a small block size, and we remove the lines between the blocks
    as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个 `BlockGrid` 实例，设置适当的行数和列数，并将每个块的颜色设置为图片中相应像素的颜色。我们使用较小的块大小，并去除块之间的线条，如下所示：
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![How to do it...](img/4818OS_03_05.jpg)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_03_05.jpg)'
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As demonstrated in this recipe, the notebook is an ideal platform for education
    activities at all levels.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本食谱中所演示的，笔记本是一个理想的教育平台，适用于所有层次的教育活动。
- en: This library has been developed prior to the interactive notebook features brought
    by IPython 2.0\. We can now expect even more interactive developments.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 该库是在 IPython 2.0 引入交互式笔记本功能之前开发的。现在，我们可以期待更多交互式的发展。
- en: Converting an IPython notebook to other formats with nbconvert
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 nbconvert 将 IPython 笔记本转换为其他格式
- en: 'An IPython notebook is saved in a JSON text file. This file contains the entire
    contents of the notebook: text, code, and outputs. The matplotlib figures are
    encoded as base64 strings within the notebooks, resulting in standalone, but sometimes
    big, notebook files.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPython 笔记本会以 JSON 文本文件的形式保存。该文件包含笔记本的所有内容：文本、代码和输出。matplotlib 图形会以 base64
    字符串的形式编码在笔记本内，导致笔记本文件既独立又可能较大。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: JSON is a human-readable, text-based, open standard format that can represent
    structured data. Although derived from JavaScript, it is language independent.
    Its syntax bears some resemblance with Python dictionaries. JSON can be parsed
    in many languages including JavaScript and Python (the `json` module in Python's
    standard library).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是一种人类可读、基于文本的开放标准格式，可以表示结构化数据。尽管源自 JavaScript，它是语言独立的。其语法与 Python 字典有一些相似之处。JSON
    可以在多种语言中解析，包括 JavaScript 和 Python（Python 标准库中的 `json` 模块）。
- en: 'IPython comes with a tool called **nbconvert** that can convert notebooks to
    other formats: raw text, Markdown, HTML, LaTeX/PDF, and even slides with the `reveal.js`
    library. You will find more information about the different supported formats
    on the nbconvert documentation.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 提供了一个名为 **nbconvert** 的工具，可以将笔记本转换为其他格式：纯文本、Markdown、HTML、LaTeX/PDF，甚至是使用
    `reveal.js` 库的幻灯片。你可以在 nbconvert 文档中找到有关不同支持格式的更多信息。
- en: In this recipe, we will see how to manipulate the contents of a notebook and
    how to convert it to other formats.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将了解如何操作笔记本的内容，并将其转换为其他格式。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install pandoc, available at [http://johnmacfarlane.net/pandoc/](http://johnmacfarlane.net/pandoc/),
    which is a tool for converting files from one markup language to another.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装 pandoc，可以在 [http://johnmacfarlane.net/pandoc/](http://johnmacfarlane.net/pandoc/)
    获取，这是一个用于将文件从一种标记语言转换为另一种标记语言的工具。
- en: To convert a notebook to PDF, you need a LaTeX distribution, which is available
    at [http://latex-project.org/ftp.html](http://latex-project.org/ftp.html). You
    also need to download the *Notebook* dataset from the book's website ([https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)),
    and extract it in the current directory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要将笔记本转换为 PDF，你需要一个 LaTeX 发行版，可以在 [http://latex-project.org/ftp.html](http://latex-project.org/ftp.html)
    找到。你还需要从本书网站下载 *Notebook* 数据集（[https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)），并将其解压到当前目录中。
- en: On Windows, you may need the `pywin32` package. If you use Anaconda, you can
    install it with `conda install pywin32`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你可能需要安装 `pywin32` 包。如果你使用 Anaconda，可以通过 `conda install pywin32`
    来安装它。
- en: How to do it...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s open the `test` notebook in the `data` folder. A notebook is just a
    plain text file (JSON), so we open it in the text mode (`r` mode) as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开 `data` 文件夹中的 `test` 笔记本。笔记本只是一个普通的文本文件（JSON），所以我们以文本模式（`r`模式）打开它，如下所示：
- en: '[PRE9]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is an excerpt of the `test.ipynb` file:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是`test.ipynb`文件的摘录：
- en: '[PRE10]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have loaded the notebook in a string, let''s parse it with the
    `json` module as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将笔记本加载为字符串，让我们使用 `json` 模块进行解析，如下所示：
- en: '[PRE11]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s have a look at the keys in the notebook dictionary:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看看笔记本字典中的键：
- en: '[PRE12]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The version of the notebook format is indicated in `nbformat` and `nbformat_minor`.
    Backwards-incompatible changes in the notebook format are to be expected in future
    versions of IPython. This recipe has been tested with the IPython 2.x branch and
    the notebook format v3.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 笔记本格式的版本在`nbformat`和`nbformat_minor`中指示。笔记本格式的向后不兼容更改预计将在未来的 IPython 版本中出现。此食谱已在
    IPython 2.x 分支和笔记本格式 v3 中进行测试。
- en: 'The main field is `worksheets`; there is only one by default. A worksheet contains
    a list of cells and some metadata. The `worksheets` field may disappear in a future
    version of the notebook format. Let''s have a look at the contents of a worksheet:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要字段是`worksheets`，默认情况下只有一个。一个工作表包含单元格列表和一些元数据。`worksheets`字段在未来版本的笔记本格式中可能会消失。让我们来看看一个工作表的内容：
- en: '[PRE13]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Each cell has a type, optional metadata, some contents (text or code), possibly
    one or several outputs, and other information. Let''s look at a Markdown cell
    and a code cell:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个单元格都有类型、可选的元数据、一些内容（文本或代码）、可能有一个或多个输出以及其他信息。让我们看看一个 Markdown 单元格和一个代码单元格：
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once parsed, the notebook is represented as a Python dictionary. Manipulating
    it is therefore quite convenient in Python. Here, we count the number of Markdown
    and code cells as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦被解析，笔记本将表示为一个 Python 字典。因此，在 Python 中操作它是非常方便的。在这里，我们按照如下方式计算 Markdown 和代码单元格的数量：
- en: '[PRE15]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s have a closer look at the image output of the cell with the matplotlib
    figure:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们仔细看看包含 matplotlib 图形的单元格的图像输出：
- en: '[PRE16]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In general, there can be zero, one, or multiple outputs. Additionally, each
    output can have multiple representations. Here, the matplotlib figure has a PNG
    representation (the base64-encoded image) and a text representation (the internal
    representation of the figure).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，可以有零个、一个或多个输出。此外，每个输出可以有多个表示。在这里，matplotlib 图形有 PNG 表示（base64 编码的图像）和文本表示（图形的内部表示）。
- en: 'Now, we are going to use nbconvert to convert our text notebook to other formats.
    This tool can be used from the command line. Note that the API of nbconvert may
    change in future versions. Here, we convert the notebook to an HTML document as
    follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用 nbconvert 将我们的文本笔记本转换为其他格式。此工具可以从命令行使用。请注意，nbconvert 的 API 在未来版本中可能会发生变化。在这里，我们将笔记本转换为
    HTML 文档，如下所示：
- en: '[PRE17]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s display this document in an `<iframe>` (a small window showing an external
    HTML document within the notebook):'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `<iframe>` 中显示此文档（这是一个在笔记本中显示外部 HTML 文档的小窗口）：
- en: '[PRE18]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![How to do it...](img/4818OS_03_06.jpg)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_03_06.jpg)'
- en: 'We can also convert the notebook to LaTeX and PDF. In order to specify the
    title and author of the document, we need to extend the default LaTeX template.
    First, we create a file called `mytemplate.tplx` that extends the default `article.tplx`
    template provided by nbconvert. We specify the contents of the author and title
    blocks as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以将笔记本转换为 LaTeX 和 PDF。为了指定文档的标题和作者，我们需要扩展默认的 LaTeX 模板。首先，我们创建一个名为`mytemplate.tplx`的文件，扩展
    nbconvert 提供的默认`article.tplx`模板。我们指定作者和标题块的内容如下：
- en: '[PRE19]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we can run nbconvert by specifying our custom template as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以通过指定自定义模板来运行 nbconvert，如下所示：
- en: '[PRE20]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We used nbconvert to convert the notebook to LaTeX, and `pdflatex` (coming
    with our LaTeX distribution) to compile the LaTeX document to PDF. The following
    screenshot shows the PDF version of the notebook:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 nbconvert 将笔记本转换为 LaTeX，然后使用`pdflatex`（随 LaTeX 发行版一起提供）将 LaTeX 文档编译为 PDF。以下截图展示了笔记本的
    PDF 版本：
- en: '![How to do it...](img/4818OS_03_07.jpg)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_03_07.jpg)'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we have seen in this recipe, an `.ipynb` file contains a structured representation
    of the notebook. This JSON file can be easily parsed and manipulated in Python.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这个食谱中看到的，`.ipynb`文件包含了笔记本的结构化表示。这种 JSON 文件可以在 Python 中轻松解析和操作。
- en: nbconvert is a tool for converting a notebook to another format. The conversion
    can be customized in several ways. Here, we extended an existing template using
    `jinja2`, a templating package. You will find more information in the documentation
    of nbconvert.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: nbconvert 是一个用于将笔记本转换为其他格式的工具。转换可以通过多种方式进行自定义。在这里，我们使用 `jinja2` 模板包扩展了现有模板。你可以在
    nbconvert 的文档中找到更多信息。
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is a free online service, **nbviewer**, that lets us render IPython notebooks
    in HTML dynamically in the cloud. The idea is that we provide to nbviewer a URL
    to a raw notebook (in JSON), and we get a rendered HTML output. The main page
    of nbviewer ([http://nbviewer.ipython.org](http://nbviewer.ipython.org)) contains
    a few examples.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个免费的在线服务，**nbviewer**，它允许我们在云中动态地将 IPython 笔记本渲染为 HTML。其理念是，我们提供一个原始笔记本（JSON
    格式）的 URL 给 nbviewer，便可获得一个渲染后的 HTML 输出。nbviewer 的主页（[http://nbviewer.ipython.org](http://nbviewer.ipython.org)）包含了一些示例。
- en: This service is maintained by the IPython developers and is hosted on Rackspace
    ([www.rackspace.com](http://www.rackspace.com)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务由 IPython 开发者维护，并托管在 Rackspace（[www.rackspace.com](http://www.rackspace.com)）上。
- en: 'Here are some more references:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的参考资料：
- en: Documentation of nbconvert, at [http://ipython.org/ipython-doc/dev/interactive/nbconvert.html](http://ipython.org/ipython-doc/dev/interactive/nbconvert.html)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nbconvert 的文档，参见 [http://ipython.org/ipython-doc/dev/interactive/nbconvert.html](http://ipython.org/ipython-doc/dev/interactive/nbconvert.html)
- en: A list of conversion examples with nbconvert, at [https://github.com/ipython/nbconvert-examples](https://github.com/ipython/nbconvert-examples)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 nbconvert 转换示例的列表，参见 [https://github.com/ipython/nbconvert-examples](https://github.com/ipython/nbconvert-examples)
- en: JSON on Wikipedia, available at [http://en.wikipedia.org/wiki/JSON](http://en.wikipedia.org/wiki/JSON)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia 上的 JSON 文章，网址为 [http://en.wikipedia.org/wiki/JSON](http://en.wikipedia.org/wiki/JSON)
- en: Adding custom controls in the notebook toolbar
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在笔记本工具栏中添加自定义控件
- en: The CSS and JavaScript of the HTML notebook can be customized through the files
    in `~/.ipython/profile_default/static/custom`, where `~` is your home directory,
    and `default` is your IPython profile.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 笔记本的 CSS 和 JavaScript 可以通过`~/.ipython/profile_default/static/custom`目录中的文件进行自定义，其中`~`代表你的主目录，`default`是你的
    IPython 配置文件。
- en: In this recipe, we will use these customization options to add a new button
    in the notebook toolbar that linearly renumbers all code cells.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用这些自定义选项在笔记本工具栏中添加一个新的按钮，能够线性地重新编号所有代码单元。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we are going to inject JavaScript code directly in the notebook. This
    is useful for testing purposes, or if we don''t want the changes to be permanent.
    The JavaScript code will be loaded with that notebook only. To do this, we can
    just use the `%%javascript` cell magic as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将直接在笔记本中注入 JavaScript 代码。这对于测试目的很有用，或者如果我们不希望更改是永久性的，JavaScript 代码将仅在该笔记本中加载。为了做到这一点，我们可以使用如下的
    `%%javascript` 单元魔法：
- en: '[PRE21]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Running the preceding code cell adds a button in the toolbar as shown in the
    following screenshot. Clicking on this button automatically updates the prompt
    numbers of all code cells.![How to do it...](img/4818OS_03_08.jpg)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上述代码单元将在工具栏中添加一个按钮，如下图所示。点击此按钮会自动更新所有代码单元的提示编号。 ![How to do it...](img/4818OS_03_08.jpg)
- en: Adding a Renumber toolbar button
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加重新编号工具栏按钮
- en: 'To make these changes permanent, that is, to add this button on every notebook
    in the current profile, we can open the `~/.ipython/profile_default/static/custom/custom.js`
    file and add the following lines of code:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这些更改成为永久性的，也就是说，要在当前配置文件下的每个笔记本中添加此按钮，我们可以打开 `~/.ipython/profile_default/static/custom/custom.js`
    文件，并添加以下代码：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code will be automatically loaded in the notebook, and the renumber
    button will appear on top of every notebook in the current profile.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将自动加载到笔记本中，并且重新编号按钮将出现在当前配置文件下每个笔记本的顶部。
- en: There's more...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The IPython notebook JavaScript API that allowed us to add a button to the
    notebook toolbar is still unstable at the time of writing. It may change at any
    time, and it is not well documented. This recipe has only been tested with IPython
    2.0\. You may nevertheless find a not-so-official and partial API documentation
    on this page: [http://ipjsdoc.herokuapp.com](http://ipjsdoc.herokuapp.com).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 允许我们将按钮添加到笔记本工具栏的 IPython 笔记本 JavaScript API 在撰写本文时仍不稳定。它可能随时发生变化，且文档不完整。本食谱仅在
    IPython 2.0 中测试过。你仍然可以在此页面找到一个非正式且部分的 API 文档：[http://ipjsdoc.herokuapp.com](http://ipjsdoc.herokuapp.com)。
- en: We should expect a more stable API in the future.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应当期待未来会有更稳定的 API。
- en: See also
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Customizing the CSS style in the notebook* recipe
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在笔记本中自定义CSS样式*配方'
- en: Customizing the CSS style in the notebook
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在笔记本中自定义CSS样式
- en: In this recipe, we show how to customize the CSS in the notebook interface and
    in an exported HTML notebook.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们展示了如何在笔记本界面和导出的HTML笔记本中自定义CSS。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You are expected to know a bit of CSS3 for this recipe. You can find many tutorials
    online (see the references at the end of this recipe).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要对CSS3有一定了解才能进行此配方。你可以在网上找到许多教程（参见本配方末尾的参考资料）。
- en: You also need to download the *Notebook* dataset from the book's website ([http://ipython-books.github.io](http://ipython-books.github.io)),
    and extract it in the current directory.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要从书籍网站下载*Notebook*数据集（链接：[http://ipython-books.github.io](http://ipython-books.github.io)），并将其解压到当前目录。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we create a new IPython profile to avoid cluttering our default profile
    as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的IPython配置文件，以避免使默认配置文件杂乱无章，具体步骤如下：
- en: '[PRE23]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In Python, we retrieve the path to this profile (`~/.ipython`) and to the `custom.css`
    file (empty by default).
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python中，我们检索此配置文件（`~/.ipython`）的路径以及`custom.css`文件的路径（默认为空）。
- en: '[PRE24]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can now edit this file here. We change the background color, the font size
    of code cells, the border of some cells, and we highlight the selected cells in
    edit mode.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在这里编辑此文件。我们更改背景颜色、代码单元的字体大小、某些单元的边框，并在编辑模式中突出显示选定的单元。
- en: '[PRE25]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Opening a notebook with the `custom_css` profile (with the `ipython notebook
    --profile=custom_css` command) leads to a custom style as follows:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`custom_css`配置文件打开笔记本（使用`ipython notebook --profile=custom_css`命令）会得到如下的自定义样式：
- en: '![How to do it...](img/4818OS_03_09.jpg)'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_03_09.jpg)'
- en: Custom CSS in the interactive notebook interface
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 交互式笔记本界面中的自定义CSS
- en: 'We can also use this style sheet with nbconvert. We just have to convert a
    notebook to a static HTML document, and copy the `custom.css` file in the current
    directory. Here, we use a test notebook that has been downloaded from the book''s
    website (see *Getting ready*):'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以将此样式表与nbconvert一起使用。只需将笔记本转换为静态HTML文档，并将`custom.css`文件复制到当前目录。在这里，我们使用的是从书籍网站下载的测试笔记本（参见*准备工作*）：
- en: '[PRE26]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is what this HTML document looks like:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是该HTML文档的显示效果：
- en: '[PRE27]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![How to do it...](img/4818OS_03_10.jpg)'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_03_10.jpg)'
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here are a few tutorials and references about CSS:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于CSS的教程和参考资料：
- en: CSS tutorial on w3schools, at [www.w3schools.com/css/DEFAULT.asp](http://www.w3schools.com/css/DEFAULT.asp)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: w3schools上的CSS教程，链接：[www.w3schools.com/css/DEFAULT.asp](http://www.w3schools.com/css/DEFAULT.asp)
- en: CSS tutorial on Mozilla Developer Network, at [https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started)
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mozilla开发者网络上的CSS教程，链接：[https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started)
- en: Blog post by Matthias Bussonnier about how to customize the notebook CSS, at
    [http://nbviewer.ipython.org/github/Carreau/posts/blob/master/Blog1.ipynb](http://nbviewer.ipython.org/github/Carreau/posts/blob/master/Blog1.ipynb)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matthias Bussonnier撰写的关于如何自定义笔记本CSS的博客文章，链接：[http://nbviewer.ipython.org/github/Carreau/posts/blob/master/Blog1.ipynb](http://nbviewer.ipython.org/github/Carreau/posts/blob/master/Blog1.ipynb)
- en: See also
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Adding custom controls in the notebook toolbar* recipe
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在笔记本工具栏中添加自定义控件*配方'
- en: Using interactive widgets – a piano in the notebook
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用交互式小部件——笔记本中的钢琴
- en: Starting with IPython 2.0, we can put interactive widgets in notebooks to create
    rich GUI applications that interact with our Python kernel. IPython comes with
    a rich set of graphical controls such as buttons, sliders, and drop-down menus.
    We have full control of their placement and appearance. We can combine different
    widgets to form complex layouts. We can even create our own interactive widgets
    from scratch as we will see in the next recipe, *Creating a custom Javascript
    widget in the notebook – a spreadsheet editor for pandas*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从IPython 2.0开始，我们可以将交互式小部件放入笔记本中，以创建与Python内核交互的丰富GUI应用程序。IPython提供了一组丰富的图形控件，如按钮、滑块和下拉菜单。我们可以完全控制它们的位置和外观。我们可以将不同的小部件组合成复杂的布局。我们甚至可以像在下一个配方中所展示的那样，从头开始创建我们自己的交互式小部件——*在笔记本中创建自定义Javascript小部件——一个用于pandas的电子表格编辑器*。
- en: In this recipe, we will show many possibilities offered by the interactive widget
    API in IPython 2.0+. We will create a very basic piano in the notebook.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将展示IPython 2.0+交互式小部件API提供的多种可能性。我们将在笔记本中创建一个非常基础的钢琴。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to download the *Piano* dataset from the book's website (http://[ipython-books.github.io](http://ipython-books.github.io)).
    This dataset contains synthetic sounds of piano notes obtained on `archive.org`
    (CC0 1.0 Universal license). It is available at [https://archive.org/details/SynthesizedPianoNotes](https://archive.org/details/SynthesizedPianoNotes).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从本书网站下载 *Piano* 数据集（http://[ipython-books.github.io](http://ipython-books.github.io)）。该数据集包含在
    `archive.org` 上获得的合成钢琴音符（CC0 1.0 公共领域授权）。它可以在 [https://archive.org/details/SynthesizedPianoNotes](https://archive.org/details/SynthesizedPianoNotes)
    下载。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s import a few modules as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入一些模块，如下所示：
- en: '[PRE28]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To create a piano, we will draw one button per note. The corresponding note
    plays when the user clicks on the button. This is implemented by displaying an
    `<audio>` element as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个钢琴，我们将为每个音符绘制一个按钮。用户点击按钮时，播放相应的音符。这是通过如下方式显示 `<audio>` 元素来实现的：
- en: '[PRE29]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We are going to place all buttons within a container widget. In IPython 2.0,
    widgets can be organized hierarchically. One common use case is to organize several
    widgets in a given layout. Here, `piano` will contain 12 buttons for the 12 notes:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把所有按钮放置在一个容器小部件内。在 IPython 2.0 中，小部件可以按层次结构组织。一个常见的使用场景是将多个小部件组织在一个特定的布局中。在这里，`piano`
    将包含 12 个按钮，代表 12 个音符：
- en: '[PRE30]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The API for creating container widgets such as horizontal or vertical boxes
    has changed in IPython 3.0\. Refer to IPython's documentation for more details.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于创建容器小部件（如水平或垂直框）的 API 在 IPython 3.0 中发生了变化。有关更多详细信息，请参考 IPython 的文档。
- en: 'We create our first widget: a slider control that specifies the octave (0 or
    1 here):'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建第一个小部件：一个滑块控件，用于指定音阶（此处为 0 或 1）：
- en: '[PRE31]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![How to do it...](img/4818OS_03_11.jpg)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现...](img/4818OS_03_11.jpg)'
- en: Now, we create the buttons. There are several steps. First, we instantiate a
    `ButtonWidget` object for each note. Then, we specify a `callback()` function
    that plays the corresponding note (given by an index) at a given octave (given
    by the current value of the octave slider). Finally, we set the CSS of each button,
    notably the white or black color.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建按钮。有几个步骤。首先，我们为每个音符实例化一个 `ButtonWidget` 对象。然后，我们指定一个 `callback()` 函数，用于在给定的音阶（由当前的音阶滑块值决定）上播放相应的音符（由索引给出）。最后，我们设置每个按钮的
    CSS，特别是白色或黑色的颜色。
- en: '[PRE32]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we arrange all widgets within the containers. The `piano` container
    contains the buttons, and the main container (`container`) contains the slider
    and the piano. This can be implemented:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将所有小部件安排在容器内。`piano` 容器包含按钮，而主容器（`container`）包含滑块和钢琴。这可以通过以下方式实现：
- en: '[PRE33]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'By default, widgets are organized vertically within a container. Here, the
    octave slider will be above the piano. Within the piano, we want all notes to
    be arranged horizontally. We do this by replacing the default `vbox` CSS class
    by the `hbox` class. The following screenshot shows the piano in the IPython notebook:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，小部件在容器内垂直组织。在这里，音阶滑块将位于钢琴上方。在钢琴中，我们希望所有音符水平排列。我们通过将默认的 `vbox` CSS 类替换为
    `hbox` 类来实现这一点。下图显示了 IPython 笔记本中的钢琴：
- en: '[PRE34]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![How to do it...](img/4818OS_03_13.jpg)'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现...](img/4818OS_03_13.jpg)'
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The IPython widgets are represented by rich objects that are shared between
    the Python kernel and the browser. A widget contains special attributes called
    **trait attributes**. For example, the `value` trait attribute of `SliderWidget`
    is dynamically and automatically linked to the value that is selected by the user
    in the notebook's slider.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 小部件由丰富的对象表示，这些对象在 Python 内核和浏览器之间共享。一个小部件包含特殊的属性，称为 **trait 属性**。例如，`SliderWidget`
    的 `value` trait 属性动态且自动地与用户在笔记本滑块中选择的值相关联。
- en: This link is bidirectional. Changing this attribute in Python updates the slider
    in the notebook.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个链接是双向的。在 Python 中更改这个属性会更新笔记本中的滑块。
- en: The placement of the widgets is controlled by container widgets and with CSS
    classes. You will find more information in the documentation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件的位置由容器小部件和 CSS 类控制。你可以在文档中找到更多信息。
- en: This architecture enables the creation of rich graphical applications in the
    notebook that are backed by Python code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构使得在笔记本中创建丰富的图形应用程序成为可能，且这些应用程序由 Python 代码支持。
- en: There's more...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Widget examples at [http://nbviewer.ipython.org/github/ipython/ipython/blob/master/examples/Interactive%20Widgets/Index.ipynb](http://nbviewer.ipython.org/github/ipython/ipython/blob/master/examples/Interactive%20Widgets/Index.ipynb)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件示例在 [http://nbviewer.ipython.org/github/ipython/ipython/blob/master/examples/Interactive%20Widgets/Index.ipynb](http://nbviewer.ipython.org/github/ipython/ipython/blob/master/examples/Interactive%20Widgets/Index.ipynb)
- en: See also
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating a custom JavaScript widget in the notebook – a spreadsheet editor
    for pandas* recipe
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在笔记本中创建自定义的 JavaScript 小部件——一个用于 pandas 的电子表格编辑器* 食谱'
- en: Creating a custom JavaScript widget in the notebook – a spreadsheet editor for
    pandas
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在笔记本中创建自定义的 JavaScript 小部件——一个用于 pandas 的电子表格编辑器
- en: We have previously introduced the new interactive features of the IPython notebook
    2.0\. In this recipe, we dive deeper into the subject by showing how to go beyond
    the existing widgets provided by IPython 2.0\. Specifically, we will create a
    custom JavaScript-based widget that communicates with the Python kernel.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前介绍了 IPython 笔记本 2.0 的新交互式功能。在这个食谱中，我们通过展示如何超越 IPython 2.0 提供的现有小部件，深入探讨了这个主题。具体来说，我们将创建一个自定义的基于
    JavaScript 的小部件，它与 Python 内核进行通信。
- en: Specifically, we will create a basic interactive Excel-like data grid editor
    in the IPython notebook, compatible with pandas' `DataFrame`. Starting from a
    `DataFrame` object, we will be able to edit it within a GUI in the notebook. The
    editor is based on the `Handsontable` JavaScript library ([http://handsontable.com](http://handsontable.com)).
    Other JavaScript data grid editors could be used as well.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将在 IPython 笔记本中创建一个基本的交互式类 Excel 数据网格编辑器，兼容 pandas 的 `DataFrame`。从一个
    `DataFrame` 对象开始，我们将能够在笔记本中的 GUI 内进行编辑。该编辑器基于 `Handsontable` JavaScript 库（[http://handsontable.com](http://handsontable.com)）。也可以使用其他
    JavaScript 数据网格编辑器。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need both IPython 2.0+ and the Handsontable JavaScript library for
    this recipe. The following are the instructions to load this Javascript library
    in the IPython notebook:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要 IPython 2.0+ 和 Handsontable JavaScript 库才能执行此食谱。以下是将此 JavaScript 库加载到 IPython
    笔记本中的说明：
- en: First, go to [https://github.com/handsontable/jquery-handsontable/tree/master/dist](https://github.com/handsontable/jquery-handsontable/tree/master/dist).
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，访问 [https://github.com/handsontable/jquery-handsontable/tree/master/dist](https://github.com/handsontable/jquery-handsontable/tree/master/dist)。
- en: Then, download `jquery.handsontable.full.css` and `jquery.handsontable.full.js`,
    and put these two files in `~\.ipython\profile_default\static\custom\`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，下载 `jquery.handsontable.full.css` 和 `jquery.handsontable.full.js`，并将这两个文件放入
    `~\.ipython\profile_default\static\custom\`。
- en: 'In this folder, add the following line in `custom.js`:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中，在 `custom.js` 中添加以下行：
- en: '[PRE35]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this folder, add the following line in `custom.css`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中，在 `custom.css` 中添加以下行：
- en: '[PRE36]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, refresh the notebook!
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，刷新笔记本！
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s import a few functions and classes as follows:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入以下几个函数和类：
- en: '[PRE37]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We create a new widget. The `value` trait will contain the JSON representation
    of the entire table. This trait will be synchronized between Python and JavaScript,
    thanks to the IPython 2.0's widget machinery.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新小部件。`value` 特性将包含整个表格的 JSON 表示。由于 IPython 2.0 的小部件机制，这个特性将在 Python 和
    JavaScript 之间进行同步。
- en: '[PRE38]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we write the JavaScript code for the widget. The three important functions
    that are responsible for the synchronization are as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们为小部件编写 JavaScript 代码。负责同步的三个重要函数如下：
- en: '`render` is for the widget initialization'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render` 用于小部件初始化'
- en: '`update` is for Python to JavaScript update'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update` 用于 Python 到 JavaScript 的更新'
- en: '`handle_table_change` is for JavaScript to Python update'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle_table_change` 用于 JavaScript 到 Python 的更新'
- en: '[PRE39]'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we have a synchronized table widget that we can already use. However,
    we would like to integrate it with pandas. To do this, we create a light wrapper
    around a `DataFrame` instance. We create two callback functions for synchronizing
    the pandas object with the IPython widget. Changes in the GUI will automatically
    trigger a change in `DataFrame`, but the converse is not true. We''ll need to
    re-display the widget if we change the `DataFrame` instance in Python:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有了一个已经可以使用的同步表格小部件。然而，我们希望将其与 pandas 集成。为此，我们在 `DataFrame` 实例周围创建一个轻量级的包装器。我们创建了两个回调函数，用于将
    pandas 对象与 IPython 小部件同步。GUI 中的更改将自动触发 `DataFrame` 的更改，但反之则不行。如果我们在 Python 中更改了
    `DataFrame` 实例，我们需要重新显示小部件：
- en: '[PRE40]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s test all that! We first create a random `DataFrame` instance:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下所有这些！我们首先创建一个随机的 `DataFrame` 实例：
- en: '[PRE41]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We wrap it in `HandsonDataFrame` and show it as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将其包装在 `HandsonDataFrame` 中，并显示如下：
- en: '[PRE42]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![How to do it...](img/4818OS_03_14.jpg)'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_03_14.jpg)'
- en: 'We can now change the values interactively, and they will be changed in Python
    accordingly:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以交互式地更改值，它们将在 Python 中相应地改变：
- en: '[PRE43]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Let's explain briefly the architecture underlying the interactive Python-JavaScript
    communication in IPython 2.0+.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要解释一下 IPython 2.0+ 中交互式 Python-JavaScript 通信的架构。
- en: The implementation follows the **Model-View-Controller** (**MVC**) design pattern,
    which is popular in GUI applications. There is a model in the backend (Python
    kernel) that holds some data. In the frontend (browser), there are one or several
    views of that model. Those views are dynamically synchronized with the model.
    When an attribute of the model changes on Python's side, it also changes on JavaScript's
    side, and vice versa. We can implement Python and JavaScript functions to respond
    to model changes. These changes are generally triggered by a user action.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现遵循**模型-视图-控制器**（**MVC**）设计模式，这是图形界面应用程序中常用的模式。在后端（Python 内核）有一个模型，保存一些数据。在前端（浏览器），有一个或多个该模型的视图。视图与模型动态同步。当
    Python 端的模型属性发生变化时，JavaScript 端的视图也会发生变化，反之亦然。我们可以实现 Python 和 JavaScript 函数来响应模型的变化。这些变化通常是由用户操作触发的。
- en: In Python, dynamic attributes are implemented as traits. These special class
    attributes automatically trigger callback functions when they are updated. In
    JavaScript, the `Backbone.js` MVC library is used. The communication between Python
    and the browser is done via **Comms**, a special communication protocol in IPython.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，动态属性实现为特性（traits）。这些特殊的类属性在更新时会自动触发回调函数。在 JavaScript 中，使用的是 `Backbone.js`
    MVC 库。Python 和浏览器之间的通信是通过**Comms**完成的，这是一种在 IPython 中的特殊通信协议。
- en: 'To create a new widget, we need to create a class deriving from `DOMWidget`.
    Then, we define trait attributes that can be synchronized between Python and JavaScript
    if `sync=True` is passed to the trait constructors. We can register callback functions
    that react to trait changes (from either Python or JavaScript), using `widget.on_trait_change(callback,
    trait_name)`. The `callback()` function can have one of the following signatures:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的小部件，我们需要创建一个继承自 `DOMWidget` 的类。然后，我们定义可以在 Python 和 JavaScript 之间同步的特性属性，如果传递
    `sync=True` 给特性构造函数。我们可以注册回调函数来响应特性变化（无论是来自 Python 还是 JavaScript），使用 `widget.on_trait_change(callback,
    trait_name)`。`callback()` 函数可以具有以下签名之一：
- en: '`callback()`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback()`'
- en: '`callback(trait_name)`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback(trait_name)`'
- en: '`callback(trait_name, new_value)`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback(trait_name, new_value)`'
- en: '`callback(trait_name, old_value, new_value)`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback(trait_name, old_value, new_value)`'
- en: 'In JavaScript, the `render()` function creates the HTML elements in the cell''s
    widget area upon initialization. The `update()` method allows us to react to changes
    in the model in the backend side (Python). In addition, we can use `Backbone.js`
    to react to changes in the frontend (browser). By extending the widget with the
    `{"change": "callback"}` events, we tell `Backbone.js` to call the `callback()`
    JavaScript function as soon as the HTML input controls change. This is how we
    react to user-triggered actions here.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '在 JavaScript 中，`render()` 函数会在初始化时创建单元格小部件区域的 HTML 元素。`update()` 方法允许我们响应后端（Python）中模型的变化。此外，我们还可以使用
    `Backbone.js` 来响应前端（浏览器）中的变化。通过用 `{"change": "callback"}` 事件扩展小部件，我们告诉 `Backbone.js`
    在 HTML 输入控件变化时，调用 `callback()` JavaScript 函数。这就是我们在这里响应用户触发的操作的方式。'
- en: There's more...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'The following are the ways this proof-of-concept could be improved:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此概念验证的改进方式：
- en: Synchronizing only changes instead of synchronizing the whole array every time
    (the method used here would be slow on large tables)
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只同步变化，而不是每次都同步整个数组（这里使用的方法在大型表格上会比较慢）
- en: Avoiding recreating a new `DataFrame` instance upon every change, but updating
    the same `DataFrame` instance in-place
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在每次更改时重新创建一个新的 `DataFrame` 实例，而是在原地更新相同的 `DataFrame` 实例
- en: Supporting named columns
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持命名列
- en: Hiding the wrapper, that is, make it so that the default rich representation
    of `DataFrame` in the notebook is `HandsonDataFrame`
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏包装器，即使得 `DataFrame` 在 notebook 中的默认丰富表示为 `HandsonDataFrame`
- en: Implementing everything in an easy-to-use extension
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一切实现为一个易于使用的扩展
- en: 'Here are a few references about the widget architecture in the IPython notebook
    2.0+:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于 IPython notebook 2.0+ 中小部件架构的一些参考资料：
- en: Official example about custom widgets, available at [http://nbviewer.ipython.org/github/ipython/ipython/tree/master/examples/Interactive%20Widgets](http://nbviewer.ipython.org/github/ipython/ipython/tree/master/examples/Interactive%20Widgets)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于自定义小部件的官方示例，网址：[http://nbviewer.ipython.org/github/ipython/ipython/tree/master/examples/Interactive%20Widgets](http://nbviewer.ipython.org/github/ipython/ipython/tree/master/examples/Interactive%20Widgets)
- en: MVC pattern in Wikipedia, at [https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia上的MVC模式，网址：[https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)
- en: Backbone.js, available at [http://backbonejs.org/](http://backbonejs.org/)
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Backbone.js，网址：[http://backbonejs.org/](http://backbonejs.org/)
- en: Course on `Backbone.js`, available at [www.codeschool.com/courses/anatomy-of-backbonejs](http://www.codeschool.com/courses/anatomy-of-backbonejs)
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backbone.js`课程，网址：[www.codeschool.com/courses/anatomy-of-backbonejs](http://www.codeschool.com/courses/anatomy-of-backbonejs)'
- en: 'IPEP 21: Widget Messages (comms), available at [https://github.com/ipython/ipython/wiki/IPEP-21%3A-Widget-Messages](https://github.com/ipython/ipython/wiki/IPEP-21%3A-Widget-Messages)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPEP 21：小部件消息（comms），网址：[https://github.com/ipython/ipython/wiki/IPEP-21%3A-Widget-Messages](https://github.com/ipython/ipython/wiki/IPEP-21%3A-Widget-Messages)
- en: 'IPEP 23: IPython widgets, available at [https://github.com/ipython/ipython/wiki/IPEP-23%3A-Backbone.js-Widgets](https://github.com/ipython/ipython/wiki/IPEP-23%3A-Backbone.js-Widgets)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPEP 23：IPython小部件，网址：[https://github.com/ipython/ipython/wiki/IPEP-23%3A-Backbone.js-Widgets](https://github.com/ipython/ipython/wiki/IPEP-23%3A-Backbone.js-Widgets)
- en: See also
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Processing webcam images in real time from the notebook* recipe
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实时处理笔记本中的摄像头图像*教程'
- en: Processing webcam images in real time from the notebook
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从笔记本实时处理摄像头图像
- en: In this recipe, we show how to let the notebook and the Python kernel communicate
    in both directions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们展示了如何让笔记本与Python内核进行双向通信。
- en: Specifically, we will retrieve the webcam feed from the browser using HTML5's
    `<video>` element, and pass it to Python in real time using the interactive capabilities
    of the IPython notebook 2.0+. Then, we will process the image in Python with an
    edge detector (implemented in scikit-image), and display it in the notebook in
    real time.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将使用HTML5的`<video>`元素从浏览器获取摄像头视频流，并通过IPython notebook 2.0+的交互功能实时传递给Python。然后，我们将在Python中使用边缘检测器（在scikit-image中实现）处理图像，并实时在笔记本中显示它。
- en: Most of the code for this recipe comes from Jason Grout's example, available
    at [https://github.com/jasongrout/ipywidgets](https://github.com/jasongrout/ipywidgets).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程的大部分代码来自Jason Grout的示例，网址：[https://github.com/jasongrout/ipywidgets](https://github.com/jasongrout/ipywidgets)。
- en: Getting ready
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need Pillow and scikit-image for this recipe. (For more information, refer
    to [Chapter 11](ch11.html "Chapter 11. Image and Audio Processing"), *Image and
    Audio Processing*.)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装Pillow和scikit-image库来实现这个教程。（更多信息，请参见[第11章](ch11.html "第11章：图像和音频处理")，*图像和音频处理*。）
- en: You also need a recent browser supporting the HTML5 capture API. You can find
    the specification at [http://dev.w3.org/2011/webrtc/editor/getusermedia.html](http://dev.w3.org/2011/webrtc/editor/getusermedia.html).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个支持HTML5捕获API的现代浏览器。你可以在[http://dev.w3.org/2011/webrtc/editor/getusermedia.html](http://dev.w3.org/2011/webrtc/editor/getusermedia.html)找到规范。
- en: How to do it...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We need to import several modules as follows:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导入几个模块，如下所示：
- en: '[PRE44]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We define two functions to convert images from and to base64 strings. This
    conversion is a common way to pass binary data between processes (in our case,
    the browser and Python):'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了两个函数，用于将图像转换为和从base64字符串转换。这种转换是进程之间传递二进制数据的常见方法（在我们的案例中是浏览器和Python之间）：
- en: '[PRE45]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We define a Python function that will process the webcam image in real time.
    It accepts and returns a NumPy array. This function applies an edge detector with
    the `roberts()` function in scikit-image as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个Python函数，它将在实时处理网络摄像头图像时工作。它接受并返回一个NumPy数组。这个函数应用了一个边缘检测器，使用的是scikit-image中的`roberts()`函数，如下所示：
- en: '[PRE46]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we create a custom widget to handle the bidirectional communication of
    the video flow between the browser and Python:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个自定义小部件来处理浏览器和Python之间视频流的双向通信：
- en: '[PRE47]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The next step is to write the JavaScript code for the widget. The code is long,
    so we just highlight the important parts here. The full code is on the book''s
    website:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是为小部件编写JavaScript代码。由于代码较长，这里仅突出重要部分。完整代码可以在本书网站上找到：
- en: '[PRE48]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we create and display the widget as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建并显示小部件，如下所示：
- en: '[PRE49]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![How to do it...](img/4818OS_03_15.jpg)'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现...](img/4818OS_03_15.jpg)'
- en: How it works...
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s explain the principle of this implementation. The model has two attributes:
    the incoming (raw) image from the browser and the outgoing (processed) image from
    Python. Every 100 milliseconds, JavaScript makes a capture of the webcam feed
    (in the `<video>` HTML element) by copying it to a first canvas. The canvas image
    is serialized in base64 and assigned to the first model attribute. Then, the Python
    function `_imageurl_changed()` is called. The image is deserialized, processed
    by scikit-image, and reserialized. The second attribute is then modified by Python,
    and is set to the serialized processed image. Finally, the `update()` function
    in JavaScript deserializes the processed image and displays it in a second canvas.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这个实现的原理。该模型有两个属性：从浏览器传入的（原始）图像和从Python传出的（处理后的）图像。每100毫秒，JavaScript都会捕获网络摄像头画面（在`<video>`HTML元素中），并将其复制到第一个画布上。画布图像被序列化为base64格式，并赋值给第一个模型属性。然后，Python函数`_imageurl_changed()`被调用。图像被反序列化，通过scikit-image进行处理，并重新序列化。接着，第二个属性由Python修改，并设置为序列化后的处理图像。最后，JavaScript中的`update()`函数会反序列化处理后的图像，并将其显示在第二个画布中。
- en: There's more...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The speed of this example could be greatly improved by capturing the webcam
    image from Python rather than from the browser. Here, the bottleneck probably
    stems from the two transfers that occur at every time step from the browser to
    Python and conversely.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从Python而非浏览器捕获网络摄像头图像，可以大大提高这个例子的速度。在这里，瓶颈可能来自于每次时间步长中从浏览器到Python以及反向传输的两次操作。
- en: It would be more efficient to capture the webcam's image from Python using a
    library such as `OpenCV` or `SimpleCV`. However, since these libraries may be
    difficult to install, it is much simpler to let the browser access the webcam
    device.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用诸如`OpenCV`或`SimpleCV`等库从Python捕获网络摄像头图像会更高效。然而，由于这些库可能难以安装，因此让浏览器直接访问网络摄像头设备要简单得多。
- en: See also
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating a custom JavaScript widget in the notebook – a spreadsheet editor
    for pandas* recipe
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在笔记本中创建自定义JavaScript小部件——用于pandas的电子表格编辑器*配方'
