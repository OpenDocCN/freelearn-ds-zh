- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Using the Protein Data Bank
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蛋白质数据银行
- en: Proteomics is the study of proteins, including their function and structure.
    One of the main objectives of this field is to characterize the three-dimensional
    structure of proteins. One of the most widely known computational resources in
    the proteomics field is the **Protein Data Bank** (**PDB**), a repository with
    the structural data of large biomolecules. Of course, many databases focus on
    protein primary structure instead; these are somewhat similar to the genomic databases
    that we saw in [*Chapter 2*](B17942_02.xhtml#_idTextAnchor040), *Getting to Know
    NumPy, pandas, Arrow, and Matplotlib*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 蛋白质组学是研究蛋白质的学科，包括蛋白质的功能和结构。该领域的主要目标之一是表征蛋白质的三维结构。在蛋白质组学领域，最广为人知的计算资源之一是**蛋白质数据银行**（**PDB**），这是一个包含大分子生物体结构数据的数据库。当然，也有许多数据库专注于蛋白质的初级结构；这些数据库与我们在[*第二章*](B17942_02.xhtml#_idTextAnchor040)中看到的基因组数据库有些相似，*了解NumPy、pandas、Arrow和Matplotlib*。
- en: In this chapter, we will mostly focus on processing data from the PDB. We will
    look at how to parse PDB files, perform some geometric computations, and visualize
    molecules. We will use the old PDB file format because, conceptually, it allows
    you to perform most necessary operations within a stable environment. Having said
    that, the newer mmCIF slated to replace the PDB format will also be presented
    in the *Parsing the mmCIF files with Biopython* recipe. We will use Biopython
    and introduce PyMOL for visualization. We will not discuss molecular docking here
    because that is probably more suited to a book about chemoinformatics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要关注如何处理来自PDB的数据。我们将学习如何解析PDB文件，执行一些几何计算，并可视化分子。我们将使用旧的PDB文件格式，因为从概念上讲，它允许你在一个稳定的环境中执行大多数必要的操作。话虽如此，新的mmCIF格式计划取代PDB格式，在*使用Biopython解析mmCIF文件*的食谱中也会介绍它。我们将使用Biopython并介绍PyMOL用于可视化。我们不会在这里讨论分子对接，因为那更适合一本关于化学信息学的书。
- en: 'Throughout this chapter, we will use a classic example of a protein: the tumor
    protein p53, a protein involved in the regulation of the cell cycle (for example,
    apoptosis). This protein is highly related to cancer. There is plenty of information
    available about this protein on the web.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个经典的蛋白质例子：肿瘤蛋白p53，它参与细胞周期的调节（例如，凋亡）。该蛋白质与癌症关系密切。网上有大量关于该蛋白质的信息。
- en: 'Let’s start with something that you should be more familiar with by now: accessing
    databases, especially for a protein’s primary structure (as in, sequences of amino
    acids).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从你现在应该更熟悉的内容开始：访问数据库，特别是获取蛋白质的初级结构（即氨基酸序列）。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Finding a protein in multiple databases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个数据库中查找蛋白质
- en: Introducing Bio.PDB
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Bio.PDB
- en: Extracting more information from a PDB file
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从PDB文件中提取更多信息
- en: Computing molecular distances on a PDB file
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PDB文件中计算分子距离
- en: Performing geometric operations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行几何操作
- en: Animating with PyMOL
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyMOL进行动画制作
- en: Parsing the mmCIF files with Biopython
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Biopython解析mmCIF文件
- en: Finding a protein in multiple databases
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个数据库中查找蛋白质
- en: Before we start performing some more structural biology, we will look at how
    we can access existing proteomic databases, such as UniProt. We will query UniProt
    for our gene of interest, *TP53*, and take it from there.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始进行更多的结构生物学工作之前，我们将看看如何访问现有的蛋白质组学数据库，比如UniProt。我们将查询UniProt以查找我们感兴趣的基因，*TP53*，并从那里开始。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: To access the data, we will use Biopython and the REST API (we used a similar
    approach in [*Chapter 5*](B17942_05.xhtml#_idTextAnchor122), *Working with Genomes*)
    with the `requests` library to access web APIs. The `requests` API is an easy-to-use
    wrapper for web requests that can be installed using standard Python mechanisms
    (for example, `pip` and `conda`). You can find this content in the `Chapter08/Intro.py`
    Notebook file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问数据，我们将使用Biopython和REST API（我们在[*第五章*](B17942_05.xhtml#_idTextAnchor122)中使用了类似的方法，*基因组学工作*）以及`requests`库来访问Web
    API。`requests` API是一个易于使用的Web请求封装库，可以通过标准的Python机制（例如，`pip`和`conda`）安装。你可以在`Chapter08/Intro.py`笔记本文件中找到这部分内容。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Take a look at the following steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下步骤：
- en: 'First, let’s define a function to perform REST queries on UniProt, as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们来定义一个函数来执行对UniProt的REST查询，代码如下：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now query all the `p53` genes that have been reviewed:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以查询所有已审阅的`p53`基因：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will query the `p53` gene and request to see all entries that are reviewed
    (as in, manually curated). The output will be in a tabular format. We will request
    a maximum of 50 results, specifying the desired columns.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查询`p53`基因，并请求查看所有已审核的条目（即，手动校对过的）。输出将以表格格式显示。我们将请求最多50个结果，并指定所需的列。
- en: We could have restricted the output to just human data, but for this example,
    let’s include all available species.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以将输出限制为仅包含人类数据，但为了这个示例，我们将包括所有可用的物种。
- en: 'Let’s check the results, as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们查看结果，内容如下：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We use `pandas` for easy processing of the tab-delimited list and pretty printing.
    The abridged output of the Notebook is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`pandas`来轻松处理制表符分隔的列表并进行美观打印。笔记本的简化输出如下：
- en: '![Figure 8.1 - An abridged list of species for which there is a TP53 protein
    ](img/B17942_08_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 - 一个简化的TP53蛋白物种列表](img/B17942_08_01.jpg)'
- en: Figure 8.1 - An abridged list of species for which there is a TP53 protein
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 - 一个简化的TP53蛋白物种列表
- en: 'Now, we can get the human `p53` ID and use Biopython to retrieve and parse
    the `SwissProt` record:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以获取人类`p53`基因ID，并使用Biopython检索并解析`SwissProt`记录：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We then use Biopython’s `SwissProt` module to parse the record. `9606` is the
    NCBI taxonomic code for humans.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用Biopython的`SwissProt`模块来解析记录。`9606`是人类的NCBI分类代码。
- en: As usual, if there is an error with your network services, it may be a network
    or server problem. If this is the case, just retry at a later date.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，如果网络服务出现错误，可能是网络或服务器问题。如果是这样，请稍后再试。
- en: 'Let’s take a look at the `p53` record, as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看一下`p53`记录，内容如下：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A deeper look at the preceding record reveals a lot of really interesting information,
    especially on features, `cross_references`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更深入地查看前面的记录会发现许多非常有趣的信息，特别是在特征、`cross_references`方面：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that we are not even printing all of the information here, just a summary
    of it. We print a number of features of the sequence with one example per type,
    a number of external database references, plus databases that are referred to,
    and a number of GO entries, along with three examples. Currently, there are 1,509
    features, 923 external references, and 173 GO terms just for this protein. Here
    is a highly abridged version of the output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们这里并没有打印所有的信息，仅仅是一个摘要。我们打印了序列的多个特征，每种类型展示一个例子，还有一些外部数据库的引用，以及提到的数据库，还有一些GO条目，并附上了三个例子。目前，仅这个蛋白质就有1,509个特征、923个外部引用和173个GO术语。以下是输出的高度简化版本：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There’s more
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容
- en: There are many more databases with information on proteins – some of these are
    referred to in the preceding record. You can explore its result to try and find
    data elsewhere. For detailed information about UniProt’s REST interface, refer
    to [http://www.uniprot.org/help/programmatic_access](http://www.uniprot.org/help/programmatic_access).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多关于蛋白质的信息数据库——其中一些在前面的记录中已有提到。你可以探索其结果，尝试在其他地方查找数据。有关UniProt REST接口的详细信息，请参考[http://www.uniprot.org/help/programmatic_access](http://www.uniprot.org/help/programmatic_access)。
- en: Introducing Bio.PDB
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Bio.PDB
- en: Here, we will introduce Biopython’s `PDB` module for working with the PDB. We
    will use three models that represent part of the `p53` protein. You can read more
    about these files and `p53` at [http://www.rcsb.org/pdb/101/motm.do?momID=31](http://www.rcsb.org/pdb/101/motm.do?momID=31).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍Biopython的`PDB`模块，用于处理PDB文件。我们将使用三个模型，这些模型代表`p53`蛋白的部分结构。你可以在[http://www.rcsb.org/pdb/101/motm.do?momID=31](http://www.rcsb.org/pdb/101/motm.do?momID=31)了解更多关于这些文件和`p53`的信息。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should already be aware of the basic `PDB` data model of model, chain, residue,
    and atom objects. A good explanation of *Biopython’s Structural Bioinformatics
    FAQ* can be found at [http://biopython.org/wiki/The_Biopython_Structural_Bioinformatics_FAQ](http://biopython.org/wiki/The_Biopython_Structural_Bioinformatics_FAQ).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经了解了基本的`PDB`数据模型，包括模型、链、残基和原子对象。关于*Biopython的结构生物信息学FAQ*的详细解释可以在[http://biopython.org/wiki/The_Biopython_Structural_Bioinformatics_FAQ](http://biopython.org/wiki/The_Biopython_Structural_Bioinformatics_FAQ)找到。
- en: You can find this content in the `Chapter08/PDB.py` Notebook file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter08/PDB.py`笔记本文件中找到这些内容。
- en: Of the three models that we will download, the `1TUP` model is the one that
    will be used in the remainder of the recipes. Take some time to study this model,
    as it will help you later on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将要下载的三个模型中，`1TUP`模型将用于接下来的所有示例。花点时间研究这个模型，它将在后续帮助你。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Take a look at the following steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下步骤：
- en: 'First, let’s retrieve our models of interest, as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们检索我们感兴趣的模型，如下所示：
- en: '[PRE8]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that `Bio.PDB` will take care of downloading files for you. Moreover, these
    downloads will only occur if no local copy is already present.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Bio.PDB`会为您下载文件。此外，只有在没有本地副本的情况下才会进行这些下载。
- en: 'Let’s parse our records, as shown in the following code:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们解析我们的记录，如下所示的代码：
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You may get some warnings about the content of the file. These are usually not
    problematic.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会收到有关文件内容的一些警告。这些通常不会有问题。
- en: 'Let’s inspect our headers, as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查我们的头文件，如下所示：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Headers are parsed as a dictionary of dictionaries. As such, we will use a
    recursive function to parse them. This function will increase the indentation
    for ease of reading and annotate lists of elements with the `->` prefix. For an
    example of recursive functions, refer to the previous chapter, [*Chapter 7*](B17942_07.xhtml#_idTextAnchor183),
    *Phylogenetics*. For an advanced discussion on recursion in Python, go to the
    last chapter, [*Chapter 12*](B17942_12.xhtml#_idTextAnchor294), *Functional Programming
    for Bioinformatics*. The abridged output is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件被解析为字典的字典。因此，我们将使用递归函数来解析它们。此函数将增加缩进以便于阅读，并使用`->`前缀注释元素列表。有关递归函数的示例，请参见前一章，[*第7章*](B17942_07.xhtml#_idTextAnchor183)，*系统发生学*。有关Python中递归的高级讨论，请转到最后一章，[*第12章*](B17942_12.xhtml#_idTextAnchor294)，*生物信息学的函数式编程*。简化后的输出如下所示：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We want to know the content of each chain on these files; for this, let’s take
    a look at the `COMPND` records:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要知道这些文件中每条链的内容；为此，让我们看一下`COMPND`记录：
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will return all the compound headers printed in the preceding code. Unfortunately,
    this is not the best way to get information on chains. An alternative would be
    to get `DBREF` records, but Biopython’s parser is currently not able to access
    these. Having said that, using a tool such as `grep` will easily extract this
    information.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出在前面的代码中列出的所有化合物头文件。不幸的是，这不是获取链信息的最佳方式。另一种方法是获取`DBREF`记录，但Biopython的解析器目前无法访问这些记录。话虽如此，使用诸如`grep`之类的工具将轻松提取这些信息。
- en: Note that for the `1TUP` model, chains `A`, `B`, and `C` are from the protein,
    while chains `E` and `F` are from the DNA. This information will be useful in
    the future.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于`1TUP`模型，链`A`、`B`和`C`来自蛋白质，而链`E`和`F`来自DNA。这些信息将在未来很有用。
- en: 'Let’s do a top-down analysis of each `PDB` file. For now, let’s just get all
    of the chains, the number of residues, and atoms per chain, as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对每个`PDB`文件进行自上而下的分析。现在，让我们只获取所有的链、残基数和每条链中的原子数，如下所示：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will perform a bottom-up approach in a later recipe. Here is the output
    for `1TUP`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍后的配方中，我们将采用自下而上的方法。以下是`1TUP`的输出：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s get all non-standard residues (`HETATM`), with the exception of water,
    in the `1TUP` model, as shown in the following code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取所有非标准残基（`HETATM`），除了水，在`1TUP`模型中，如下所示的代码：
- en: '[PRE15]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have three zincs, one in each of the protein chains.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个锌原子，每个蛋白链一个。
- en: 'Let’s take a look at a residue:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看一个残基：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will print all the atoms in a certain residue:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出某个残基中的所有原子：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note the last statement. It is there just to show you that you can directly
    access an atom by resolving the model, chain, residue, and finally, the atom.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一句话。它只是为了向您展示，您可以通过解析模型、链、残基和最终原子来直接访问一个原子。
- en: 'Finally, let’s export the protein fragment to a FASTA file, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将蛋白质片段导出到一个FASTA文件中，如下所示：
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you inspect the protein chain, you will see that they are equal in each model,
    so we export a single one. In the case of `1YCQ`, we export the smallest one,
    because the biggest one is not `p53`-related. As you can see, here, we are using
    `Bio.SeqIO`, not `Bio.PDB`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查蛋白质链，您会发现它们在每个模型中都是相等的，因此我们导出一个单独的链。在`1YCQ`的情况下，我们导出最小的一个，因为最大的一个与`p53`无关。正如您在这里看到的，我们使用的是`Bio.SeqIO`，而不是`Bio.PDB`。
- en: There’s more
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: The PDB parser is incomplete. It’s not very likely that a complete parser will
    be seen soon, as the community is migrating to the mmCIF format.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: PDB解析器不完整。很可能不会很快见到完整的解析器，因为社区正在迁移到mmCIF格式。
- en: Although the future is the mmCIF format ([http://mmcif.wwpdb.org/](http://mmcif.wwpdb.org/)),
    PDB files are still around. Conceptually, many operations are similar after you
    have parsed the file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管未来是mmCIF格式（[http://mmcif.wwpdb.org/](http://mmcif.wwpdb.org/)），PDB文件仍然存在。从概念上讲，文件解析后的许多操作是类似的。
- en: Extracting more information from a PDB file
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从PDB文件中提取更多信息
- en: Here, we will continue our exploration of the record structure produced by `Bio.PDB`
    from PDB files.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将继续探索`Bio.PDB`从PDB文件生成的记录结构。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For general information about the PDB models that we are using, refer to the
    previous recipe.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有关我们正在使用的PDB模型的详细信息，请参见前面的章节。
- en: You can find this content in the `Chapter08/Stats.py` Notebook file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter08/Stats.py` Notebook文件中找到这些内容。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We’ll get started, using the following steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下步骤开始：
- en: 'First, let’s retrieve `1TUP`, as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们提取`1TUP`，如下所示：
- en: '[PRE19]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, extract some atom-related statistics:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，提取一些与原子相关的统计信息：
- en: '[PRE20]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will print information on the atom’s residue type, the number of atoms
    per chain, and the quantity per element, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出原子残基类型、每条链的原子数量和每种元素的数量，如下所示：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the preceding number of residues is not the proper number of residues,
    but the amount of times that a certain residue type is referred to (it adds up
    to the number of atoms, not residues).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面提到的残基数不是正确的残基数，而是某个残基类型被引用的次数（它加起来等于原子数，而不是残基数）。
- en: Notice the water (`W`), nucleotide (`DA`, `DC`, `DG`, and `DT`), and zinc (`ZN`)
    residues, which add to the amino acid ones.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意水（`W`）、核苷酸（`DA`，`DC`，`DG`，`DT`）和锌（`ZN`）残基，它们与氨基酸残基一起出现。
- en: 'Now, let’s count the instance per residue and the number of residues per chain:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们统计每个残基的实例数量和每条链的残基数量：
- en: '[PRE22]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following is the output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can also get the bounds of a set of atoms:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以获取一组原子的边界：
- en: '[PRE24]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A set of atoms can be a whole model, a chain, a residue, or any subset that
    you are interested in. In this case, we will print boundaries for all the chains
    and the whole model. Numbers don’t convey it so intuitively, so we will get a
    little bit more graphical.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一组原子可以是整个模型、一条链、一种残基或任何你感兴趣的子集。在这种情况下，我们将打印所有链条和整个模型的边界。数字表达不太直观，因此我们将采用更具图形化的方式。
- en: 'To get a notion of the size of each chain, a plot is probably more informative
    than the numbers in the preceding code:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了了解每条链的大小，绘图可能比前面代码中的数字更具信息量：
- en: '[PRE25]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There are plenty of molecular visualization tools. Indeed, we will discuss PyMOL
    later. However, `matplotlib` is enough for simple visualization. The most important
    point about `matplotlib` is that it’s stable and very easy to integrate into reliable
    production code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有很多分子可视化工具。实际上，我们稍后会讨论PyMOL。不过，`matplotlib`对于简单的可视化已经足够了。关于`matplotlib`最重要的一点是它非常稳定，且容易集成到可靠的生产代码中。
- en: 'In the following chart, we performed a three-dimensional plot of chains, with
    the DNA in grey and the protein chains in different colors. We also plot planar
    projections (**X/Y**, **X/Z**, and **Z/Y**) on the left-hand side of the following
    graph:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们对链条进行了三维绘制，DNA部分为灰色，蛋白质链条用不同颜色表示。我们还在下图的左侧绘制了平面投影（**X/Y**，**X/Z**，和**Z/Y**）：
- en: '![Figure 8.2 - The spatial distribution of the protein chains – the main figure
    is a 3D plot and the left subplots are planar views (X/Y, X/Z, and Z/Y) ](img/B17942_08_02.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 - 蛋白质链的空间分布——主图是一个3D图，左侧子图是平面视图（X/Y，X/Z，和Z/Y）](img/B17942_08_02.jpg)'
- en: Figure 8.2 - The spatial distribution of the protein chains – the main figure
    is a 3D plot and the left subplots are planar views (X/Y, X/Z, and Z/Y)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 - 蛋白质链的空间分布——主图是一个3D图，左侧子图是平面视图（X/Y，X/Z，和Z/Y）
- en: Computing molecular distances on a PDB file
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算PDB文件中的分子距离
- en: Here, we will find atoms closer to three zincs in the `1TUP` model. We will
    consider several distances to these zincs. We will take this opportunity to discuss
    the performance of algorithms.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将找到与`1TUP`模型中三个锌原子接近的原子。我们将考虑这些锌原子之间的几种距离，并借此机会讨论算法的性能。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can find this content in the `Chapter08/Distance.py` Notebook file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter08/Distance.py` Notebook文件中找到这些内容。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Take a look at the following steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下步骤：
- en: 'Let’s load our model, as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载我们的模型，如下所示：
- en: '[PRE26]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will now get our zincs, against which we will perform comparisons later:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们来提取锌原子，后续我们将以这些原子为基准进行比较：
- en: '[PRE27]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You should see three zinc atoms.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到三个锌原子。
- en: 'Now, let’s define a function to get the distance between one atom and a set
    of other atoms, as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个函数来获取一个原子与一组其他原子之间的距离，如下所示：
- en: '[PRE28]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We get coordinates for our reference atom and then iterate over our desired
    comparison list. If an atom is close enough, it’s added to the `return` list.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取参考原子的坐标，然后遍历我们希望比较的原子列表。如果某个原子足够接近，它会被添加到`return`列表中。
- en: 'We now compute the atoms near our zincs, the distance of which can be up to
    4 Ångströms for our model:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们计算接近锌原子的原子，距离在我们的模型中可以达到 4 埃（Å）：
- en: '[PRE29]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we show the result for the first zinc, including the element, distance,
    and coordinates:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们展示了第一个锌原子的结果，包括元素、距离和坐标：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We only have three zincs, so the number of computations is quite significantly
    reduced. However, imagine that we had more, or that we were doing a pairwise comparison
    among all the atoms in the set (remember that the number of comparisons grows
    quadratically with the number of atoms in a pairwise case). Although our case
    is small, it’s not difficult to forecast use cases, while more comparisons take
    a lot of time. We will get back to this soon.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有三个锌原子，因此计算量大大减少。然而，假设我们有更多原子，或者我们在整个原子集之间进行成对比较（记住，在成对比较的情况下，比较次数是随着原子数量的平方增长的）。虽然我们的案例较小，但预测使用案例并不难，更多的比较会消耗大量时间。我们很快会回到这个问题。
- en: 'Let’s see how many atoms we get as we increase the distance:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看随着距离增加，我们会得到多少原子：
- en: '[PRE31]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The result is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we have seen previously, this specific case is not very expensive, but let’s
    time it anyway:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们之前所见，这个特定的情况并不太昂贵，但我们还是计时看看：
- en: '[PRE33]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we will use the `timeit` module to execute this function 10 times and
    then print the result in milliseconds. We pass the function as a string and pass
    yet another string with the necessary imports to make this function work. On a
    Notebook, you are probably aware of the `%timeit` magic and how it makes your
    life much easier in this case. This takes roughly 40 milliseconds on the machine
    where the code was tested. Obviously, on your computer, you will get somewhat
    different results.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`timeit`模块执行这个函数 10 次，然后以毫秒为单位打印结果。我们将函数作为字符串传递，并传递另一个包含必要导入的字符串以使函数正常工作。在Notebook中，你可能知道`%timeit`魔法命令，它能让你的生活变得更加轻松。在测试代码的机器上，这大约需要
    40 毫秒。显然，在你的电脑上，你会得到稍有不同的结果。
- en: 'Can we do better? Let’s consider a different `distance` function, as shown
    in the following code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能做得更好吗？让我们考虑一个不同的`distance`函数，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So, we take the original function and add a very simplistic `if` with the distances.
    The rationale for this is that the computational cost of the square root, and
    maybe the float power operation, is very expensive, so we will try to avoid it.
    However, for all atoms that are closer than the target distance in any dimension,
    this function will be more expensive.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们对原始函数进行修改，加入一个非常简单的`if`条件来处理距离。这样做的理由是，平方根计算和可能的浮点幂运算非常昂贵，因此我们将尽量避免它。然而，对于任何维度中距离小于目标距离的原子，这个函数会变得更加昂贵。
- en: 'Now, let’s time against it:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来计时：
- en: '[PRE35]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: On the same machine that we used in the preceding example, it takes 16 milliseconds,
    which means that it is roughly three times faster.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前使用的同一台机器上，它需要 16 毫秒，这意味着它大约快了三倍。
- en: 'However, is this always better? Let’s compare the cost with different distances,
    as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，这总是更好吗？让我们比较不同距离下的成本，如下所示：
- en: '[PRE36]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The result is shown in the following output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在以下输出中：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that the cost of the Standard version is mostly constant, whereas the Optimized
    version varies depending on the distance of the closest atoms; the larger the
    distance, the more cases that will be computed using the extra `if`, plus the
    square root, making the function more expensive.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，标准版本的成本大致是恒定的，而优化版本的成本则取决于最近原子的距离；距离越大，使用额外`if`和平方根进行计算的情况就越多，从而使得函数变得更昂贵。
- en: The larger point here is that you can probably code functions that are more
    efficient using smart computation shortcuts, but the complexity cost may change
    qualitatively. In the preceding case, I suggest that the second function is more
    efficient for all realistic and interesting cases when you’re trying to find the
    closest atoms. However, you have to be careful while designing your own versions
    of optimized algorithms.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键点是，你可能可以通过聪明的计算捷径编写更高效的函数，但复杂度成本可能会发生质的变化。在前面的例子中，我建议第二个函数在所有现实且有趣的情况下更高效，特别是在你尝试找到最接近的原子时。然而，在设计你自己的优化算法时，你必须小心。
- en: Performing geometric operations
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行几何操作
- en: We will now perform computations with geometry information, including computing
    the center of the mass of chains and whole models.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用几何信息进行计算，包括计算链条和整个模型的质心。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can find this content in the `Chapter08/Mass.py` Notebook file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `Chapter08/Mass.py` 笔记本文件中找到这些内容。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let’s take a look at the following steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下步骤：
- en: 'First, let’s retrieve the data:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们获取数据：
- en: '[PRE38]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, let’s recall the type of residues that we have with the following code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下代码回顾我们拥有的残基类型：
- en: '[PRE39]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, we have `H_ ZN` (zinc) and `W` (water), which are `HETATM` types; the vast
    majority are standard PDB atoms.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有 `H_ ZN`（锌）和 `W`（水），它们是 `HETATM` 类型；绝大多数是标准 PDB 原子。
- en: 'Let’s compute the masses for all chains, zincs, and waters using the following
    code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码计算所有链条、锌和水的质量：
- en: '[PRE40]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `get_mass` function returns the mass of all atoms in the list that pass
    an acceptance criterion function. Here, the default acceptance criterion involves
    not being a water residue.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_mass` 函数返回通过接收标准函数筛选的列表中所有原子的质量。这里，默认的接收标准是排除水分子残基。'
- en: 'We then compute the mass for all chains. We have three versions: just amino
    acids, zincs, and water. Zinc does nothing more than detect a single atom per
    chain in this model. The output is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们计算所有链条的质量。我们有三个版本：只有氨基酸、锌和水。锌仅在此模型中检测每条链中的单个原子。输出结果如下：
- en: '![Figure 8.3 - The mass for all protein chains ](img/B17942_08_03.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 - 所有蛋白质链的质量](img/B17942_08_03.png)'
- en: Figure 8.3 - The mass for all protein chains
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 - 所有蛋白质链的质量
- en: 'Let’s compute the geometric center and the center of mass of the model, as
    follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们计算模型的几何中心和质心，如下所示：
- en: '[PRE41]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, we define a weighted function to get the coordinates of the center. The
    default function will treat all atoms as equal, as long as they are not a water
    residue.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个加权函数来获取质心的坐标。默认的函数会将所有原子视为相等，只要它们不是水分子残基。
- en: We then compute the geometric center and the center of mass by redefining the
    `weight` function with a value of each atom equal to its mass. The geometric center
    is computed, irrespective of its molecular weights.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过重新定义 `weight` 函数，将每个原子的值设置为其质量，来计算几何中心和质心。几何中心的计算不考虑分子量。
- en: For example, you may want to compute the center of mass of the protein without
    DNA chains.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能想要计算没有 DNA 链的蛋白质的质心。
- en: 'Let’s compute the center of mass and the geometric center of each chain, as
    follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们计算每个链条的质心和几何中心，如下所示：
- en: '[PRE42]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The result is shown here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如图所示：
- en: '![Figure 8.4 - The center of mass and the geometric center of each protein
    chain ](img/B17942_08_04.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 - 每个蛋白质链的质心和几何中心](img/B17942_08_04.jpg)'
- en: Figure 8.4 - The center of mass and the geometric center of each protein chain
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 - 每个蛋白质链的质心和几何中心
- en: There’s more
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: Although this is not a book based on the protein structure determination technique,
    it’s important to remember that X-ray crystallography methods cannot detect hydrogens,
    so computing the mass of residues might be based on very inaccurate models; refer
    to [http://www.umass.edu/microbio/chime/pe_beta/pe/protexpl/help_hyd.htm](http://www.umass.edu/microbio/chime/pe_beta/pe/protexpl/help_hyd.htm)
    for more information.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书不是基于蛋白质结构解析技术的，但需要记住的是，X 射线晶体学方法无法检测氢原子，因此残基的质量计算可能基于非常不准确的模型；有关更多信息，请参阅
    [http://www.umass.edu/microbio/chime/pe_beta/pe/protexpl/help_hyd.htm](http://www.umass.edu/microbio/chime/pe_beta/pe/protexpl/help_hyd.htm)。
- en: Animating with PyMOL
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PyMOL 动画
- en: Here, we will create a video of the p53 `1TUP` model. For that, we will use
    the PyMOL visualization library. We will start our animation by moving around
    the p53 `1TUP` model and then zooming in; as we zoom in, we change the rendering
    strategy so that you can see deeper into the model. You can find a version of
    the video that you will generate at [https://odysee.com/@Python:8/protein_video:8](https://odysee.com/@Python:8/protein_video:8%20).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个关于 p53 `1TUP` 模型的视频。为此，我们将使用 PyMOL 可视化库。我们将通过移动 p53 `1TUP` 模型开始动画，然后进行缩放；随着缩放，我们改变渲染策略，以便可以更深入地观察模型。你可以在
    [https://odysee.com/@Python:8/protein_video:8](https://odysee.com/@Python:8/protein_video:8%20)
    找到你将生成的视频版本。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will be presented as a Python script, not as a Notebook. This is
    mostly because the output is not interactive, but a set of image files that will
    need further post-processing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将以Python脚本的形式呈现，而不是以Notebook的形式。这主要是因为输出不是交互式的，而是一组需要进一步后期处理的图像文件。
- en: You will need to install PyMOL ([http://www.pymol.org](http://www.pymol.org)).
    On Debian, Ubuntu, or Linux, you can use the `apt-get install pymol` command.
    If you are on Conda, I suggest not using it, as the dependencies will be easy
    to resolve – furthermore, you will be installing a 30-day-trial-only version requiring
    a license, whereas the version above is fully open source. If you are not on Debian
    or Linux, I suggest that you install the open source version available for your
    operating system.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装PyMOL（[http://www.pymol.org](http://www.pymol.org)）。在Debian、Ubuntu或Linux系统中，你可以使用`apt-get
    install pymol`命令。如果你使用的是Conda，我建议不要使用它，因为依赖项会很容易解决——而且你将安装一个仅限30天试用的版本，需要许可证，而上述版本是完全开源的。如果你不是使用Debian或Linux，我建议你安装适用于你操作系统的开源版本。
- en: PyMOL is more of an interactive program than a Python library, so I strongly
    encourage you to play with it before moving on to the recipe. This can be fun!
    The code for this recipe is available on the GitHub repository as a script, along
    with this chapter’s Notebook file, at `Chapter08`. We will use the `PyMol_Movie.py`
    file in this recipe.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: PyMOL更多是一个交互式程序，而非Python库，因此我强烈建议你在继续操作前先进行一些探索。这可以是很有趣的！这个配方的代码可以在GitHub仓库中找到，作为脚本文件以及本章的Notebook文件，位于`Chapter08`。我们将在这个配方中使用`PyMol_Movie.py`文件。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Take a look at the following steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下步骤：
- en: 'Let’s initialize and retrieve our PDB model and prepare the rendering, as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们初始化并获取我们的PDB模型，并准备渲染，如下所示：
- en: '[PRE43]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that the `pymol_argv` line makes the code silent. In your first execution,
    you may want to comment this out and see the user interface.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`pymol_argv`这一行会使代码保持静默。在第一次执行时，你可能想要注释掉这行代码，看看用户界面。
- en: For movie rendering, this will come in handy (as we will see soon). As a library,
    PyMOL is quite tricky to use. For instance, after the import, you have to call
    `finish_launching`. We then fetch our PDB file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电影渲染，这将非常有用（如我们将很快看到的）。作为一个库，PyMOL的使用相当复杂。例如，导入后，你需要调用`finish_launching`。接着，我们获取我们的PDB文件。
- en: What then follows is a set of PyMOL commands. Many web guides for interactive
    usage can be quite useful for understanding what is going on. Here, we will enable
    all of the models for viewing purposes, hiding all (because the default view is
    of lines and this is not good enough), then making the zincs visible as spheres.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一些PyMOL命令。许多关于交互式使用的网页指南对于理解发生的事情非常有帮助。在这里，我们将启用所有模型以供查看，隐藏所有模型（因为默认视图是线条表示，这样不够好），然后将锌渲染为球体。
- en: At this stage, bar zinc, everything else is invisible.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，除锌外，其他都不可见。
- en: 'To render our model, we will use three scenes, as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了渲染我们的模型，我们将使用以下三个场景：
- en: '[PRE44]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We need to define two scenes. One scene corresponds to us moving around the
    protein (surface-based, thus opaque) and the other corresponds to us diving in
    (cartoon-based). The DNA is always rendered as a cartoon.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义两个场景。一个场景对应于我们围绕蛋白质移动（基于表面，因此是透明的），另一个场景则对应于我们深入观察（基于卡通式）。DNA始终以卡通形式渲染。
- en: We also define a third scene for when we zoom out at the end. The protein will
    be rendered as sticks, and we add a mesh to chain A so that the relationship with
    the DNA becomes clearer.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了第三个场景，当我们在最后进行缩小时使用。蛋白质将被渲染为棒状，并且我们将给A链添加一个网格，以便更清楚地展示它与DNA的关系。
- en: 'Let’s define the basic parameter of our video, as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义视频的基本参数，如下所示：
- en: '[PRE45]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We define the default ray-tracing algorithm. This line does not need to be there,
    but try to increase the number to `1`, `2`, or `3` and be ready to wait a lot.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了默认的光线追踪算法。这一行并非必需，但请尝试将数字增加到`1`、`2`或`3`，并准备好等待很长时间。
- en: You can only use `0` if you have the OpenGL interface on (with the GUI), so,
    for this fast version, you will need to have the GUI on (`pymol_argv` should be
    commented as it is).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开了OpenGL接口（即图形界面），那么只能使用`0`，因此对于这个快速版本，你需要打开GUI（`pymol_argv`应该保持注释状态）。
- en: We then inform PyMOL that we will have 500 frames.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通知PyMOL我们将使用500帧。
- en: 'In the first 150 frames, we move around using the initial scene. We move around
    the model a bit and then move nearer to the DNA using the following code:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前150帧中，我们使用初始场景围绕蛋白质移动。我们稍微环绕模型，然后使用以下代码接近DNA。
- en: '[PRE46]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We define three points; the first two align with the DNA and the last point
    goes in. We get coordinates (all of these numbers) by using PyMOL in interactive
    mode, navigating using the mouse and keyboard, and using the `get_view` command,
    which will return coordinates that you can cut and paste.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个点；前两个点与 DNA 对齐，最后一个点进入其中。我们通过在交互模式下使用 PyMOL，使用鼠标和键盘导航，并使用 `get_view`
    命令来获取坐标（所有这些数字），然后可以剪切并粘贴。
- en: 'The first frame is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个帧如下所示：
- en: '![Figure 8.5 - Frame 0 and scene DS0 ](img/B17942_08_05.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 - 第 0 帧和场景 DS0 ](img/B17942_08_05.jpg)'
- en: Figure 8.5 - Frame 0 and scene DS0
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 - 第 0 帧和场景 DS0
- en: 'We now change the scene, in preparation for going inside the protein:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在更改场景，为进入蛋白质内部做准备：
- en: '[PRE47]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following screenshot shows the current position:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当前的位置：
- en: '![Figure 8.6 - Frame 200 near the DNA molecule and scene S1 ](img/B17942_08_06.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 - DNA 分子附近的第 200 帧和场景 S1 ](img/B17942_08_06.jpg)'
- en: Figure 8.6 - Frame 200 near the DNA molecule and scene S1
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 - DNA 分子附近的第 200 帧和场景 S1
- en: 'We move inside the protein and change the scene at the end using the following
    code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们进入蛋白质内部，并在结束时使用以下代码更改场景：
- en: '[PRE48]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We are now fully inside, as shown in the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完全进入其中，如以下截图所示：
- en: '![Figure 8.7 - Frame 350 – scene S1 on the verge of changing to S2 ](img/B17942_08_07.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 - 第 350 帧 - 场景 S1 即将更改为 S2 ](img/B17942_08_07.jpg)'
- en: Figure 8.7 - Frame 350 – scene S1 on the verge of changing to S2
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 - 第 350 帧 - 场景 S1 即将更改为 S2
- en: 'Finally, we let PyMOL return to its original position, and then play, save,
    and quit:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们让 PyMOL 返回到原始位置，然后播放、保存并退出：
- en: '[PRE49]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will generate 500 PNG files with the `p53_1tup` prefix.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成 500 个以 `p53_1tup` 为前缀的 PNG 文件。
- en: 'Here is a frame approaching the end (450):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接近结束的帧（450）：
- en: '![Figure 8.8 - Frame 450 and scene S2 ](img/B17942_08_08.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 - 第 450 帧和场景 S2 ](img/B17942_08_08.jpg)'
- en: Figure 8.8 - Frame 450 and scene S2
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 - 第 450 帧和场景 S2
- en: There’s more
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'The YouTube video was generated using `ffmpeg` on Linux at `15` frames per
    second, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 该 YouTube 视频是在 Linux 上使用 `ffmpeg` 以每秒 `15` 帧的速度生成的，如下所示：
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There are plenty of applications that you can use to generate videos from images.
    PyMOL can generate a MPEG, but it requires the installation of extra libraries.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多应用程序可以用来从图像生成视频。PyMOL 可以生成 MPEG 格式的视频，但需要安装额外的库。
- en: PyMOL was created to be used interactively from its console (which can be extended
    in Python). Using it the other way around (importing from Python with no GUI)
    can be complicated and frustrating. PyMOL starts a separate thread to render images
    that work asynchronously.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: PyMOL 是为从其控制台交互式使用而创建的（可以在 Python 中扩展）。反向使用（从 Python 导入且没有图形界面）可能会变得复杂且令人沮丧。PyMOL
    启动一个单独的线程来渲染图像，这些图像异步工作。
- en: For example, this means that your code may be in a different position from where
    the renderer is. I have put another script called `PyMol_Intro.py` in the GitHub
    repository; you will see that the second PNG call will start before the first
    one has finished. Try the script code, see how you expect it to behave, and how
    it actually behaves.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这意味着你的代码可能与渲染器的位置不同。我已经在 GitHub 仓库中放了另一个名为 `PyMol_Intro.py` 的脚本；你会看到第二个 PNG
    调用将在第一个还没有完成之前就开始。试试这个脚本代码，看看它应该如何运行，以及它实际是如何运行的。
- en: There is plenty of good documentation for PyMOL from a GUI perspective at [http://www.pymolwiki.org/index.php/MovieSchool](http://www.pymolwiki.org/index.php/MovieSchool).
    This is a great starting point if you want to make movies, and [http://www.pymolwiki.org](http://www.pymolwiki.org)
    is a treasure trove of information.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从 GUI 角度来看，PyMOL 有很多优秀的文档，访问 [http://www.pymolwiki.org/index.php/MovieSchool](http://www.pymolwiki.org/index.php/MovieSchool)
    可以获得。 如果你想制作电影，这是一个很好的起点，[http://www.pymolwiki.org](http://www.pymolwiki.org)
    是一个信息的宝库。
- en: Parsing mmCIF files using Biopython
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Biopython 解析 mmCIF 文件
- en: The mmCIF file format is probably the future. Biopython doesn’t have full functionality
    to work with it yet, but we will take a look at what currently exists.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: mmCIF 文件格式可能是未来的趋势。Biopython 目前还没有完全支持它的功能，但我们将看看当前有哪些功能。
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正在准备
- en: As `Bio.PDB` is not able to automatically download mmCIF files, you need to
    get your protein file and rename it to `1tup.cif`. This can be found at [https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-Edition/blob/master/Datasets.py](https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-Edition/blob/master/Datasets.py)
    under `1TUP.cif`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Bio.PDB`不能自动下载 mmCIF 文件，你需要获取你的蛋白质文件并将其重命名为`1tup.cif`。它可以在[https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-Edition/blob/master/Datasets.py](https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-Edition/blob/master/Datasets.py)中的`1TUP.cif`找到。
- en: You can find this content in the `Chapter08/mmCIF.py` Notebook file.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter08/mmCIF.py`笔记本文件中找到这些内容。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Take a look at the following steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下步骤：
- en: 'Let’s parse the file. We just use the MMCIF parser instead of the PDB parser:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们解析文件。我们只需使用 MMCIF 解析器，而不是 PDB 解析器：
- en: '[PRE51]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let’s inspect the following chains:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查以下链条：
- en: '[PRE52]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output will be as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Many of the fields are not available in the parsed structure, but the fields
    can still be retrieved by using a lower-level dictionary, as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 许多字段在解析的结构中不可用，但可以通过使用更低级别的字典来检索这些字段，如下所示：
- en: '[PRE54]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Unfortunately, this list is large and requires some post-processing to make
    sense of it, but it is available.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个列表很大，需要一些后处理才能理解它，但它是可以获得的。
- en: There’s more
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: You still have all the model information from the mmCIF file made available
    by Biopython, so the parser is still quite useful. We can expect more developments
    with the `mmCIF` parser than with the `PDB` parser.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以获取来自 Biopython 提供的 mmCIF 文件的所有模型信息，因此解析器仍然非常有用。我们可以预期`mmCIF`解析器会有更多的开发，而不是`PDB`解析器。
- en: There is a Python library for this that’s been made available by the developers
    of PDB at [http://mmcif.wwpdb.org/docs/sw-examples/python/html/index.xhtml](http://mmcif.wwpdb.org/docs/sw-examples/python/html/index.xhtml).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个 Python 库，由 PDB 的开发者提供，网址为[http://mmcif.wwpdb.org/docs/sw-examples/python/html/index.xhtml](http://mmcif.wwpdb.org/docs/sw-examples/python/html/index.xhtml)。
