- en: Loops, Functions, and String Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环、函数和字符串处理
- en: Sometimes, magic one-liners are insufficient for manipulating data. Loops and
    conditionals enable us to iterate over data in interesting ways without sticking
    to default behavior.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，魔法般的单行代码不足以处理数据。循环和条件语句使我们能够以有趣的方式遍历数据，而无需坚持默认行为。
- en: Bash views non-binary files and streams as collections of characters. We commonly
    think of these characters as groups of strings separated by some kind of whitespace.
    It makes sense that some of the most useful and common tools in the command-line
    universe are the ones that search and manipulate these strings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Bash将非二进制文件和流视为字符的集合。我们通常认为这些字符是由某种空白字符分隔的字符串组。可以理解，命令行世界中一些最有用和最常见的工具正是那些用来搜索和操作这些字符串的工具。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: '`for` loops'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: '`while` loops'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: File test conditionals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件测试条件
- en: Numeric comparisons
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字比较
- en: String case statements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串案例语句
- en: Using regular expressions and `grep` to search and filter
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式和`grep`进行搜索和过滤
- en: String transformations using `awk`, `sed`, and `tr`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`awk`、`sed`和`tr`进行字符串转换
- en: Sorting lists of strings with `sort` and `uniq`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sort`和`uniq`对字符串列表进行排序
- en: Along the way, we'll see how we can pipe the results of one program into another
    to get the results we want.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们将看到如何将一个程序的结果通过管道传递给另一个程序，从而获得我们想要的结果。
- en: Once, twice, three times a lady loops
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次，两次，三次女士循环
- en: Few command-line tools have implicit looping and conditionals built into them.
    Often, tasks will only operate on each line of an input stream and then terminate.
    The shell provides just enough control flow and conditionals to solve many complex
    problems, making up for any deficiencies that command-line tools have for operating
    on data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有命令行工具内置了隐式的循环和条件判断。通常，任务只会在输入流的每一行上操作，然后终止。Shell提供了足够的控制流和条件语句来解决许多复杂问题，弥补了命令行工具在数据操作上的不足。
- en: 'The almighty `for` loop is a common loop idiom, however bash''s `for` loop
    might feel a little unfamiliar to users of more traditional languages. The `for` loop
    allows you to iterate over a list of words, and assign each one to a variable
    for processing. For example, (pun intended):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 万能的`for`循环是一种常见的循环惯用法，然而，Bash的`for`循环对于习惯传统语言的用户来说可能有些陌生。`for`循环允许你遍历一个单词列表，并将每个单词赋值给一个变量进行处理。例如，（言外之意）：
- en: '![](img/ada257e1-0797-4f71-b0f6-a8b281d81153.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ada257e1-0797-4f71-b0f6-a8b281d81153.png)'
- en: Often, we want a more traditional range of numbers in our `for` loops. The `POSIX`
    method of generating a number range is to use the `seq` command, as in `seq --
    $(seq 1 1 5)`, which will generate numbers from 1 (the first argument) to 5 (the
    third argument) in steps of 1 increment (the second argument).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望在`for`循环中使用更传统的数字范围。生成数字范围的`POSIX`方法是使用`seq`命令，像这样`seq -- $(seq 1 1 5)`，它将生成从1（第一个参数）到5（第三个参数）的数字，步长为1（第二个参数）。
- en: In the following examples, you'll notice we are using bracket expansions, `{}`,
    and parentheses, `()`. For more information about both, check out [https://ss64.com/bash/syntax-brackets.html](https://ss64.com/bash/syntax-brackets.html).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，您会注意到我们使用了括号扩展`{}`和圆括号`()`。有关更多信息，请查看[https://ss64.com/bash/syntax-brackets.html](https://ss64.com/bash/syntax-brackets.html)。
- en: 'Modern versions of `bash` provide an easy shorthand for this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现代版本的`bash`提供了一个简便的缩写：
- en: '![](img/17774fa8-f1c3-44c6-b4fd-fdf1f1f63607.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17774fa8-f1c3-44c6-b4fd-fdf1f1f63607.png)'
- en: 'We can also set the amount that the sequence is incremented by:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以设置序列递增的步长：
- en: '![](img/2ed52b37-5d53-40ba-878d-a7ab14d4cf4d.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ed52b37-5d53-40ba-878d-a7ab14d4cf4d.png)'
- en: 'Alternatively, we can use the `bash` supported C-like syntax:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用Bash支持的类似C语言的语法：
- en: '![](img/b4aa359d-7e15-48f5-a7de-fba201b5b3f7.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4aa359d-7e15-48f5-a7de-fba201b5b3f7.png)'
- en: 'Looping for a specified number of times may be what we need, but we can also
    pass in the result of a sub-command to generate the list of things to loop over.
    For example, we may want to do something to each file in the current directory:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可能我们需要进行指定次数的循环，但我们也可以传递一个子命令的结果来生成要循环的列表。例如，我们可能想对当前目录中的每个文件执行某些操作：
- en: '![](img/f8cf46e8-8f49-4489-9544-1512e3610085.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8cf46e8-8f49-4489-9544-1512e3610085.png)'
- en: 'Often, we may want to test one or more conditionals, especially in loops. Bash
    has an `if-then` construct, like most languages:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可能需要测试一个或多个条件，特别是在循环中。Bash有一个`if-then`结构，像大多数语言一样：
- en: '![](img/bc85b83b-d991-43b1-b387-add64e2200f9.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc85b83b-d991-43b1-b387-add64e2200f9.png)'
- en: 'The statement inside the brackets is a test, and bash contains a set of special
    tests, such as `-f` for common tasks. Here''s a list of some of the most common
    ones:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的语句是一个测试，bash包含一组特殊测试，例如`-f`用于常见任务。以下是一些最常见的测试：
- en: '| **Test type** | **Parameter** | **Description** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **测试类型** | **参数** | **描述** |'
- en: '| Filesystem | `-O` | `True` if file exists and is owned by the effective user
    ID |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 文件系统 | `-O` | 如果文件存在并且由有效的用户ID所有，则为`True` |'
- en: '| Filesystem | `-f` | `True` if file exists and is a regular file |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 文件系统 | `-f` | 如果文件存在并且是常规文件，则为`True` |'
- en: '| Filesystem | `-G` | `True` if file exists and is owned by the effective group
    ID |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 文件系统 | `-G` | 如果文件存在并且由有效的组ID所有，则为`True` |'
- en: '| Filesystem | `-r` | `True` if file exists and is readable |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 文件系统 | `-r` | 如果文件存在并且可读，则为`True` |'
- en: '| Filesystem | `-w` | `True` if file exists and is writable |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 文件系统 | `-w` | 如果文件存在并且可写，则为`True` |'
- en: '| Filesystem | `-x` | `True` if file exists and is executable |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 文件系统 | `-x` | 如果文件存在并且可执行，则为`True` |'
- en: '| Filesystem | `-s` | `True` if file exists and has a size greater than zero
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 文件系统 | `-s` | 如果文件存在并且大小大于零，则为`True` |'
- en: '| Filesystem | `-h` | `True` if file exists and is a symbolic link |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 文件系统 | `-h` | 如果文件存在并且是符号链接，则为`True` |'
- en: '| Arithmetic | `<=` | Less than equal |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 算术 | `<=` | 小于等于 |'
- en: '| Arithmetic | `>=` | Greater than equal |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 算术 | `>=` | 大于等于 |'
- en: '| Arithmetic | `<`  | Less than |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 算术 | `<` | 小于 |'
- en: '| Arithmetic | `>`  | Greater than |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 算术 | `>` | 大于 |'
- en: '| Arithmetic | `!=` | Not equal |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 算术 | `!=` | 不等于 |'
- en: '| Arithmetic | `=` | Equal |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 算术 | `=` | 等于 |'
- en: 'Like other languages, we can also include `else-if` tests, and finally an `else
    if` nothing else matches:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他语言一样，我们也可以包括`else-if`测试，最后是`else`，当没有其他条件匹配时：
- en: '![](img/48ae89f3-e5f2-4ffd-93e3-75e7711430ff.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48ae89f3-e5f2-4ffd-93e3-75e7711430ff.png)'
- en: 'Even though the `if-else` construct exists, most shell scripts use the pipeline
    semantics of `&& (AND)` and `|| (OR)`. We briefly mentioned this in [Chapter 3](ea035d0b-e34a-481c-87f4-53c45869e4a3.xhtml), *Obtaining
    and Working with Data and Detached Processing and Terminal Multiplexers*, but
    here''s a more detailed example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在`if-else`构造，大多数Shell脚本使用`&& (AND)`和`|| (OR)`的管道语义。我们在[第3章](ea035d0b-e34a-481c-87f4-53c45869e4a3.xhtml)中简要提到过这个内容，*获取和处理数据以及分离处理和终端复用器*，但这里有一个更详细的例子：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's the end of the world as we know it while and until
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这是我们所知的世界末日，使用`while`和`until`。
- en: 'Let''s explore two more options for assisting with iteration. The `while` construct
    allows for the repetitive execution of a list or set of commands as long as the
    command that controls the `while` loop exits successfully. Let''s see an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索另外两种帮助迭代的选项。`while`构造允许在控制`while`循环的命令成功退出的前提下，反复执行一个命令列表或一组命令。来看一个例子：
- en: 'Let''s say I wanted to print the `"hello!"` string four times in a script—no
    more and no less. We can do so with the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想在脚本中打印`"hello!"`字符串四次——既不多也不少。我们可以通过以下方式做到：
- en: '![](img/88518703-1714-4788-904c-b7a3ba02a38d.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88518703-1714-4788-904c-b7a3ba02a38d.png)'
- en: Let's save and run this script to see what happens.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存并运行这个脚本，看看会发生什么。
- en: Don't forget to `chmod -x` these scripts to make them executable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了用`chmod -x`让这些脚本可执行。
- en: 'Executing the script produces the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本后会产生以下输出：
- en: '![](img/00080cc2-726b-4440-98c5-a1d875db5c32.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080cc2-726b-4440-98c5-a1d875db5c32.png)'
- en: Notice that, in the script, we created a variable called `i="0"`. This sets
    the `i` variable to zero. Do you see the `while [ $i -lt 4 ]` block? This allows
    us to run the loop as the `i` variable is less than the `4` integer. Go ahead
    and play around with this code for a bit to get a better understanding. Also,
    you can `man [` for more information.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在脚本中，我们创建了一个名为`i="0"`的变量。这将`i`变量设置为零。你看到了`while [ $i -lt 4 ]`块吗？这使得我们可以在`i`变量小于整数`4`时执行循环。试着玩一下这个代码，帮助你更好地理解。还有，你可以通过`man
    [`获取更多信息。
- en: 'In our while script, we counted up until four for our output. Let''s use the `until` construct
    to count down and provide the `goodbye!` output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`while`脚本中，我们将输出计数到四。现在让我们使用`until`构造倒计时并提供`goodbye!`输出：
- en: '![](img/be4e8256-218b-4c48-a3bd-5a219b2650fc.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be4e8256-218b-4c48-a3bd-5a219b2650fc.png)'
- en: 'Let''s save and run this script to see what happens:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存并运行这个脚本，看看会发生什么：
- en: '![](img/bbc9c002-41c4-481c-b557-1878fe92d685.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbc9c002-41c4-481c-b557-1878fe92d685.png)'
- en: The simple case
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的情况
- en: 'Frequently, string comparison is done using the test operator, `[`. This is
    ill-advised in bash, as there''s a much more convenient format for string comparison,
    using the `case` statement. Here''s a simple example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串比较通常使用测试操作符`[`。在bash中不推荐这样做，因为有更方便的字符串比较格式，使用`case`语句。下面是一个简单的例子：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `testcase` function lets us test the `case` statement by wrapping it in
    a `for` loop that assigns each function argument to the `VAR` variable, then executes
    the `case` statement. With the `foo a bar b c d` arguments, we can expect the
    following output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`testcase`函数允许我们通过将其包装在`for`循环中，测试`case`语句。该循环将每个函数参数分配给`VAR`变量，然后执行`case`语句。对于`foo
    a bar b c d`这些参数，我们可以预期以下输出：'
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pay no heed to the magician redirecting your attention
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不必理会那个将你注意力引开的魔术师
- en: 'Looping is great for working over sequences of data in an iterative fashion,
    but sometimes, when you''re doing all that work, you get lots of irrelevant output.
    Enter our little magician: the output redirection operator, `*>*`. This operator
    directs output to a specified file or file descriptor. We''ve talked about file
    descriptors, they are integers that the OS uses to identify a file handle that
    has been opened, and by default there are three opened for every process: `stdin`,
    `stdout`, and `stderr`. The default file descriptors, denoted by `fd#`, are `fd0`
    for standard input, `fd1` for standard output, and `fd2` for standard error. The `*>*` operator
    by default, redirects `stdout`, the equivalent of `1>`, unless it''s preceded
    by an integer file-descriptor. Let''s see some examples of output redirection,
    before we get lost in what we''re referring to:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 循环对于按迭代方式处理数据序列非常有用，但有时在做这些工作的同时，会得到大量无关的输出。这时，轮到我们的魔术师登场：输出重定向操作符`*>*`。该操作符将输出定向到指定的文件或文件描述符。我们之前谈过文件描述符，它们是操作系统用来标识已打开文件句柄的整数，默认情况下，每个进程都有三个已打开的文件描述符：`stdin`、`stdout`
    和 `stderr`。默认的文件描述符，通常用`fd#`表示，`fd0`是标准输入，`fd1`是标准输出，`fd2`是标准错误。`*>*`操作符默认将`stdout`重定向，相当于`1>`，除非它前面跟着一个整数文件描述符。让我们看一些输出重定向的例子，避免在理解我们所说的内容时迷失：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Normal messaging is sent to standard output, and is rendered as text in your
    Terminal window. This is how `ls /` will show the contents of the root filesystem
    to your Terminal. In the second invocation, we use `>` to indicate that `stdout`
    should be redirected to `/dev/null`, which will discard the output. The third
    sends error messages to `dev/null`, so they don't render to the Terminal. The
    fourth example redirects `stdout` to a file named `stdout_and_stderr.log` and
    then copies `stderr` to the same location as `stdout` with `&1`. The fifth example
    splits `stdout` to `stdout.log` and `stderr` to `stderr.log`. The sixth example
    doesn'tredirect `stderr` to `/dev/null`, rather it redirects `stderr` to where
    `stdout` is pointing at the time of the assignment—the Terminal and then `stdout`
    is redirected to `/dev/null`. This shows that the order of operators matters and
    diligence should be paid to ensure that assignments occur in definition order.
    The last point to make is that because `stdout` is a file descriptor, and not
    the Terminal, it's possible to direct other output to the Terminal, and have `stdout`
    directed to another file descriptor that won't result in Terminal output.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 普通消息会发送到标准输出，并在终端窗口中以文本形式呈现。比如，`ls /`会将根文件系统的内容显示在终端中。在第二次调用时，我们使用`>`表示`stdout`应被重定向到`/dev/null`，这样就会丢弃输出。第三个示例将错误消息发送到`dev/null`，使它们不会显示在终端中。第四个示例将`stdout`重定向到名为`stdout_and_stderr.log`的文件，然后使用`&1`将`stderr`复制到与`stdout`相同的位置。第五个示例将`stdout`重定向到`stdout.log`，并将`stderr`重定向到`stderr.log`。第六个示例没有将`stderr`重定向到`/dev/null`，而是将`stderr`重定向到`stdout`当时所指向的位置——终端，然后`stdout`被重定向到`/dev/null`。这表明操作符的顺序非常重要，在定义顺序中要小心确保赋值操作的顺序正确。最后要提到的一点是，因为`stdout`是文件描述符，而不是终端，所以可以将其他输出定向到终端，并将`stdout`定向到另一个文件描述符，这样就不会导致终端输出。
- en: 'There are three less-frequently-used redirection operators: `<` for input redirection, `>>` for
    output append redirection, and `<<` for `HEREDOC`. Input redirection is used to
    feed data into a pipeline, like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个不常用的重定向操作符：`<`用于输入重定向，`>>`用于输出追加重定向，`<<`用于`HEREDOC`。输入重定向用于将数据输入到管道中，示例如下：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will read `stdout.log` into the standard input of the `cat` command, which
    will write its output to the pipe operator. There''s really not much more to input
    redirection, as pipelines implicitly set the `stdout` of the previous command
    to the standard input of the next command. We also mentioned the append operator, `>>` ,
    and it''s necessary to point out that the `>` redirection operator truncates files
    to zero content before writing. This behavior isn''t desired if data needs to
    be preserved between runs. To clarify, this truncates data in `keys.log`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`stdout.log`读入`cat`命令的标准输入，`cat`命令会将其输出写入管道操作符。输入重定向实际上没有太多复杂的内容，因为管道操作符会隐式地将前一个命令的`stdout`设置为下一个命令的标准输入。我们也提到了追加操作符`>>`，需要指出的是，`>`重定向操作符会将文件内容截断为零再写入。如果数据需要在多次运行间保留，这种行为是不希望出现的。为了明确，`>`会将`keys.log`中的数据截断：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The other option is appending the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是追加以下内容：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, the `heredoc` operator, `<<`, it replaces standard input with a predefined
    text-stream book ended by a keyword that follows `<< KEYWORD`. For example, the
    following example can be used to truncate an `options.conf` file and write the
    three option values into the file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`heredoc`操作符`<<`，它通过一个关键字`<< KEYWORD`来替换标准输入，输入流是由预定义的文本流组成的。这种方式可以用来截断一个`options.conf`文件，并将三个选项值写入文件：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Regular expressions and grep
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式与grep
- en: One key task you will face over and over is matching particular patterns of
    text. The match might be as simple as finding one instance of a specific string
    in a body of text, or it could be much more complicated. A great tool for matching
    text is the language of regular expressions. A regular expression is an abstract
    way of expressing certain types of string-matching patterns.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你将反复面对的一个关键任务是匹配特定的文本模式。匹配可能像在文本中找到特定字符串的一个实例那样简单，或者可能复杂得多。一个非常适合匹配文本的工具就是正则表达式语言。正则表达式是一种抽象的方式，用来表达某些类型的字符串匹配模式。
- en: 'Contrary to popular belief, regular expressions can''t match everything you
    might want to match. They''re limited to certain types of matches, and depending
    on the particular flavor of regular expression implementation, they could have
    a little more or a little less power. As an academic exercise, one might try to
    characterize exactly what you can match and what you can''t. It''s a very interesting
    endeavor that cuts to the very core of theoretical computer science. But we won''t
    be doing that here: we are here to do practical things!'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与人们普遍的看法相反，正则表达式不能匹配你可能想匹配的所有内容。它们仅限于某些类型的匹配，并且根据正则表达式实现的具体版本，它们的功能可能会稍多或稍少。作为一个学术练习，人们可以尝试精确地描述你可以匹配的内容和不能匹配的内容。这是一个非常有趣的课题，涉及计算机科学的核心理论。但我们在这里不讨论这些：我们是来做实际操作的！
- en: First up, you'll want to find a way to test your regular expressions. There
    are several tools available on the web that allow you to interactively test your
    matches. A couple of good ones are listed at the end of this section. Of course,
    this is a command-line book, and you can test matches yourself just by putting
    test text in a file and using `grep`. Grep is a program that takes a regular expression
    and emits the lines in the input stream that match that regular expression (by
    default, it emits lines where any substring of the line matches the regular expression).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要找到一种测试正则表达式的方法。网络上有几种工具可以让你互动式地测试匹配结果。本节末尾列出了几个不错的工具。当然，这是一本命令行书籍，你也可以自己通过将测试文本放入文件并使用`grep`来测试匹配结果。Grep是一个程序，它接受正则表达式并输出与该正则表达式匹配的输入流中的行（默认情况下，它会输出任何子字符串与正则表达式匹配的行）。
- en: Exact matches
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精确匹配
- en: A regular expression is a string itself. Several characters are reserved, that
    is, when they're present in the string, they have a special meaning. Any non-reserved
    character in the `regex` must be matched exactly, in the exact order that it appears.
    Notably, a `regex` that's nothing but a normal character must be an exact match
    on the entire string.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式本身就是一个字符串。某些字符是保留的，也就是说，当它们出现在字符串中时，它们具有特殊含义。在`regex`中，任何非保留字符必须精确匹配，且顺序必须与出现的顺序完全一致。值得注意的是，一个仅由普通字符组成的`regex`必须与整个字符串进行精确匹配。
- en: You do multiple things with a `regex`. Sometimes, you may require that the entire
    target strings match. Other times, you may want to find if and where a substring
    of the target string matches.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`regex`你可以做很多事情。有时，你可能需要整个目标字符串完全匹配。其他时候，你可能只想找出目标字符串的某个子字符串是否以及在哪里匹配。
- en: 'Here''s a table of `regex` pattern matches:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`regex`模式匹配的表格：
- en: '| **Regex** | **String** | **Matches?** | **Matches substring?** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **正则表达式** | **字符串** | **匹配？** | **匹配子串？** |'
- en: '| abc | abc | Yes | Yes |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| abc | abc | 是 | 是 |'
- en: '| abc | abcd | No | Yes (abcd) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| abc | abcd | 否 | 是（abcd） |'
- en: '| abc | def | No | No |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| abc | def | 否 | 否 |'
- en: 'Let''s look for an exact match on the `aardvark` string in the review titles
    of our test dataset:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查找一下在测试数据集的回顾标题中是否有精确匹配的`aardvark`字符串：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The red-highlighted content is the matched content:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 红色高亮的内容是匹配的内容：
- en: '![](img/23b0669d-2c44-4eab-93c6-9d9d9315f664.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23b0669d-2c44-4eab-93c6-9d9d9315f664.png)'
- en: Character sets
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符集
- en: After an exact string, you might want to match one of a couple of characters
    instead of one exactly. To do this, we use the `characters []` bracket to enclose
    the list of characters that we might want to match. We can only match one of the
    possible characters inside the brackets.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在精确匹配一个字符串后，您可能想要匹配几个字符中的一个，而不是一个精确的字符。为此，我们使用`字符[]`方括号将可能匹配的字符列表括起来。我们只能匹配方括号内的其中一个字符。
- en: 'Here''s a table of `regex` pattern matches:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`regex`模式匹配的表格：
- en: '| **Regex** | **String** | **Matches?** | **Matches substring?** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **正则表达式** | **字符串** | **匹配？** | **匹配子串？** |'
- en: '| `ab[cd]` | `abc` | Yes | Yes |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `ab[cd]` | `abc` | 是 | 是 |'
- en: '| `ab[cd]` | `abcd` | No | Yes (abcd) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `ab[cd]` | `abcd` | 否 | 是（abcd） |'
- en: '| `ab[cd]` | `abe` | No | No |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `ab[cd]` | `abe` | 否 | 否 |'
- en: 'Let''s see whether there are any examples of a capitalized `aardvark` in our
    review data:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看一下回顾数据中是否有大写的`aardvark`实例：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The red-highlighted content is the matched content:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 红色高亮的内容是匹配的内容：
- en: '![](img/c901a393-5b7d-40c3-b4d0-fe629d6545c9.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c901a393-5b7d-40c3-b4d0-fe629d6545c9.png)'
- en: Dot the i (or anything else)
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点中i（或任何其他字符）
- en: 'The dot character, `.`, is a one-character wildcard character. It will match
    anything. There are also restricted wildcards that only match certain types of
    characters: `\d` matches a digit, `\w` matches any alphanumeric character or an
    underscore, and `\s` matches whitespace.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 点字符，`.`，是一个单字符的通配符。它可以匹配任何字符。也有一些限制性的通配符，只匹配某些类型的字符：`\d` 匹配数字，`\w` 匹配任何字母数字字符或下划线，`\s`
    匹配空白字符。
- en: 'Here''s a table of `regex` pattern matches:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`regex`模式匹配的表格：
- en: '| **Regex** | **String** | **Matches?** | **Matches substring?** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **正则表达式** | **字符串** | **匹配？** | **匹配子串？** |'
- en: '| `\s..ick` | The trick | Yes | Yes |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `\s..ick` | 这个技巧 | 是 | 是 |'
- en: '| `...` | `abcd` | No | Yes (abcd) |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `...` | `abcd` | 否 | 是（abcd） |'
- en: '| `abc\ddef` | `abc_def` | No | No |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `abc\ddef` | `abc_def` | 否 | 否 |'
- en: 'We could have done the last search for a capital A (or anything else starting
    our `ardvark` string) using a dot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用点字符，来查找以大写A（或任何其他字符）开头的`ardvark`字符串的匹配：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The red-highlighted content is the matched content:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 红色高亮的内容是匹配的内容：
- en: '![](img/d292d85e-ddff-49c1-a060-c797d3556100.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d292d85e-ddff-49c1-a060-c797d3556100.png)'
- en: Capture groups
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获组
- en: We can set apart groups of characters with parentheses. While not terribly useful
    on their own, these groups can be combined with other operators to do very useful
    things. We call these groups capture groups because the `regex` engine captures
    what was matched inside the group. Later on, you can use what was captured to
    match something else.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过圆括号将字符组隔开。尽管这些组本身并不非常有用，但它们可以与其他操作符结合使用，执行非常有用的操作。我们称这些组为捕获组，因为`regex`引擎会捕获组内匹配到的内容。稍后，您可以使用捕获的内容来匹配其他内容。
- en: We will show some examples of using capture groups later, in the section on
    `awk`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的`awk`章节中展示一些使用捕获组的例子。
- en: Either or, neither nor
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 或者都不，既不也不
- en: 'The pipe character, `|`, lets us match one or the other of something. We can
    delineate where the pair starts by using a capture group. Invoke the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 管道字符，`|`，允许我们匹配其中一个或另一个。我们可以通过使用捕获组来划定成对内容的起始位置。调用以下内容：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The red-highlighted content is the matched content:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 红色高亮的内容是匹配的内容：
- en: '![](img/6480d26b-d9f3-4f7e-addb-5041be827137.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6480d26b-d9f3-4f7e-addb-5041be827137.png)'
- en: Repetition
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复
- en: There are three heavily-used operators that let us match repetitions. They are
    the question mark, `?`, the plus, `+`, and the asterisk, `*`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个常用的操作符，可以让我们匹配重复。这些操作符是问号，`?`，加号，`+`，和星号，`*`。
- en: 'The question mark, `?`, matches exactly `0` or `1` instances of the thing it''s
    applied to (a character, set, or group). Invoke the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 问号，`?`，精确匹配`0`次或`1`次其应用的内容（字符、字符集或组）。调用以下内容：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The red-highlighted content is the matched content:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 红色高亮的内容是匹配的内容：
- en: '![](img/4a31491c-6988-4137-b270-b5205d76d60e.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a31491c-6988-4137-b270-b5205d76d60e.png)'
- en: 'The plus operator, `+`, matches one or more things, and the asterisk operator, `*`,
    matches `0` or more things. Invoke the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 加号操作符`+`匹配一次或多次，星号操作符`*`匹配`0`次或多次。调用以下内容：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It produces this output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它生成以下输出：
- en: '![](img/df2cda4b-b1c1-4a2a-8a76-b78999c0c692.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df2cda4b-b1c1-4a2a-8a76-b78999c0c692.png)'
- en: Other operators
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他操作符
- en: 'You can match many things with `regex`, and each implementation of `regex`
    is a little different. I suggest looking at these resources for a full treatment
    of each kind of `regex` and what you can do with them:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`regex`匹配许多内容，而每种`regex`的实现略有不同。我建议查看这些资源，以全面了解每种类型的`regex`及其功能：
- en: A great, comprehensive site with many examples: [https://www.regular-expressions.info/](https://www.regular-expressions.info/)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个很棒、综合性的站点，提供许多例子：[https://www.regular-expressions.info/](https://www.regular-expressions.info/)
- en: A site to test and debug different types of `regex`: [https://regex101.com/](https://regex101.com/)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于测试和调试不同类型`regex`的站点：[https://regex101.com/](https://regex101.com/)
- en: Another `regex` test site: [https://www.regexpal.com/](https://www.regexpal.com/)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个`regex`测试站点：[https://www.regexpal.com/](https://www.regexpal.com/)
- en: A library of `regex` instances that others have created: [http://www.regexlib.com](http://www.regexlib.com)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`regex`库，其他人创建的实例：[http://www.regexlib.com](http://www.regexlib.com)
- en: Putting it all together
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将它们组合起来
- en: 'As a recap, we have the following operators:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们有以下操作符：
- en: '| **Operator** | **Use** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **用途** |'
- en: '| `Brackets []` | Specifies sets of characters to match |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `方括号 []` | 指定要匹配的字符集 |'
- en: '| `Capture Group ()` | Groups characters, and pulls out what was matched later
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `捕获组 ()` | 组合字符，并在稍后提取匹配内容 |'
- en: '| Or `&#124;` | Matches one of two things |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 或者`&#124;` | 匹配两个选项中的一个 |'
- en: '| `?` | Matches zero or one times |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 匹配零次或一次 |'
- en: '| `+` | Matches one or more times |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 匹配一次或多次 |'
- en: '| `*` | Matches zero or more times |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 匹配零次或多次 |'
- en: awk, sed, and tr
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: awk、sed和tr
- en: In this section, we will be looking at `awk`, `sed`, and `tr`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下`awk`、`sed`和`tr`。
- en: awk
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: awk
- en: '`awk` (including the `gnu` implementation, `gawk`) is designed for streaming
    text processing, data extraction, and reporting. An `awk` program is structured
    as a set of patterns that are matched, and actions to take when those patterns
    are matched:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`（包括`gnu`实现的`gawk`）专为流式文本处理、数据提取和报告设计。一个`awk`程序结构化为一组匹配模式和这些模式匹配时的操作：'
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For each record (usually each line of text passed to `awk`), each pattern is
    tested to see whether the record matches, and if so, the action is taken. Additionally,
    each record is automatically split into a list of fields by a delimiter (any run
    of whitespace by default). The default action, if none is given, is to print the
    record. The default pattern is to match everything. There are two special patterns, `BEGIN`
    and `END`, which are matched only before any records are processed, or after,
    respectively.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个记录（通常是传递给`awk`的每一行文本），会测试每个模式以查看记录是否匹配，如果匹配，则执行相应的操作。此外，每个记录会自动通过分隔符（默认为任何连续的空白）分割为字段列表。如果没有给出默认操作，则默认操作是打印记录。默认模式是匹配所有内容。还有两个特殊模式，`BEGIN`和`END`，它们只在处理任何记录之前或之后匹配。
- en: '`awk` is very good at doing certain kinds of math on input streams, which we''ll
    discuss later in the book. For strings, `awk` is great at filtering an input stream
    on complex conditions, doing transformations on input data, and combinations of
    these things.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`非常擅长对输入流进行某些类型的数学运算，这将在本书后面讨论。对于字符串，`awk`在复杂条件下过滤输入流、对输入数据进行转换以及这些操作的组合方面表现出色。'
- en: 'Filtering on a complex condition is as easy as supplying the filter condition
    as a pattern and the default action (which is to say, nothing). `awk` will then,
    by default, print out the whole line. As an example, we might want to simulate
    grep by matching on a regular expression:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在模式中提供过滤条件作为模式以及默认操作（即不做任何操作），以复杂条件进行过滤就像是提供过滤条件。`awk`然后会默认打印整行。例如，我们可能想通过匹配正则表达式来模拟grep：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code produces this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成了这个：
- en: '![](img/ebf9e265-3ffd-4e1d-aba3-bcd60ea6c6e7.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebf9e265-3ffd-4e1d-aba3-bcd60ea6c6e7.png)'
- en: 'Here, the forward slashes indicate that the string inside is a `regex`. We
    can even get rid of `cut` here, as `awk` itself can look for the tab field separators.
    If we do this, we need to tell `awk` that we''re looking for substrings of the
    appropriate field. The special variables, `$1`, `$2`, and so on, represent the
    fields of each record. `$0` is the entire record. Invoke the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，斜杠表示内部字符串是一个`regex`。我们甚至可以在这里去掉`cut`，因为`awk`本身可以查找制表符字段分隔符。如果我们这样做，我们需要告诉`awk`我们正在查找适当字段的子字符串。特殊变量`$1`、`$2`等表示每个记录的字段。`$0`是整个记录。调用以下内容：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code produces this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了这个：
- en: '![](img/0be2ce9f-7e36-44b3-867a-a8707bba9734.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0be2ce9f-7e36-44b3-867a-a8707bba9734.png)'
- en: 'We printed the entire record here since we didn''t cut it in advance, and we
    told `awk` to do the default, which is printing the entire record. Maybe we want
    to just print out the title, field `6`, when we match `aardvark` in the review
    description. We have to add a non-default action to our filter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里打印了整个记录，因为我们没有提前切割它，并且我们告诉`awk`执行默认操作，即打印整个记录。也许我们只想在匹配评论描述中的`aardvark`时打印出标题，即第`6`字段。我们必须向我们的过滤器添加一个非默认操作：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code generates this output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成了这个输出：
- en: '![](img/64f4b185-df59-4540-bebc-9e24b7817197.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64f4b185-df59-4540-bebc-9e24b7817197.png)'
- en: 'We can also do things such as picking out the fields we want, re-ordering them,
    and printing them out with a different field separator which we define in the
    `BEGIN` pattern:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以做一些事情，比如挑选我们想要的字段，重新排序它们，并使用我们在`BEGIN`模式中定义的不同字段分隔符打印它们：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code looks like this in the Terminal:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在终端中看起来是这样的：
- en: '![](img/dd9317e4-7700-4761-9633-b0b38182733b.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd9317e4-7700-4761-9633-b0b38182733b.png)'
- en: More information on `awk` can be found at [https://www.gnu.org/software/gawk/manual/gawk.html](https://www.gnu.org/software/gawk/manual/gawk.html).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`awk`的信息可以在[https://www.gnu.org/software/gawk/manual/gawk.html](https://www.gnu.org/software/gawk/manual/gawk.html)找到。
- en: sed
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sed
- en: '`sed` is an alternative to `awk` for line-by-line stream editing. One of the
    most common uses of `sed` is for easy `regex` replacement. For example, we can
    pipe the strings that contain `aardvark` that we found in the review descriptions
    and replace them with `giraffe`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`是逐行流编辑的替代品。`sed`最常见的用途之一是进行简单的`regex`替换。例如，我们可以将包含在评论描述中的包含`aardvark`的字符串管道化，并用`giraffe`替换它们：'
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code should output the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码应该输出以下内容：
- en: '![](img/567245f3-acb2-4465-be62-ceb3e62cd023.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/567245f3-acb2-4465-be62-ceb3e62cd023.png)'
- en: '`sed` can also delete lines matching a pattern:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`还可以删除匹配模式的行：'
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code produces this output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了以下输出：
- en: '![](img/b3975028-dff4-4139-81e5-bb8425379ce7.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3975028-dff4-4139-81e5-bb8425379ce7.png)'
- en: Sed has almost 30 commands in addition to more complex stream processing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更复杂的流处理外，`sed`还有近30个命令。
- en: More information on sed can be found at [https://www.gnu.org/software/sed/manual/sed.html](https://www.gnu.org/software/sed/manual/sed.html).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`sed`的信息可以在[https://www.gnu.org/software/sed/manual/sed.html](https://www.gnu.org/software/sed/manual/sed.html)找到。
- en: tr
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tr
- en: 'The `tr` command is somewhat simpler than `awk` or `sed`, but sometimes it''s
    just what''s needed: `tr` translates or deletes characters from a stream.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`命令比`awk`或`sed`稍微简单一些，但有时候它正是所需的：`tr`从流中翻译或删除字符。'
- en: 'Say we really hate the letter `a` and we''d like to replace all of them with `b`.
    With `tr`, this is simple:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们真的讨厌字母`a`，我们想用`b`替换所有的`a`。用`tr`来做这件事很简单：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code produces this output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了这个输出：
- en: '![](img/825ec6c8-1621-4d4a-ac2f-33f2484ad312.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/825ec6c8-1621-4d4a-ac2f-33f2484ad312.png)'
- en: sort and uniq
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sort和uniq
- en: After `awk`, `sed`, and `tr`, `sort`, and `uniq` are going to be a breeze.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`awk`、`sed`和`tr`之后，`sort`和`uniq`会变得很容易。
- en: sort
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sort
- en: '`sort`, well, sorts a stream of strings (or numbers). It won''t remove duplicates,
    it keeps them. By default, `sort` puts things in alphabetical order.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`可以对字符串（或数字）流进行排序。它不会删除重复项，而是保留它们。默认情况下，`sort`按字母顺序排列事物。'
- en: 'We can see `sort` in action by piping one column of data (using `cut`) from
    a few lines (using head) from our example data:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从我们的示例数据中使用`head`来从数据的一个列（使用`cut`）传递管道来看`sort`的操作：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code produces this output:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了以下输出：
- en: '![](img/2f690674-0a78-4f50-84ab-1212b346b303.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f690674-0a78-4f50-84ab-1212b346b303.png)'
- en: 'If you pass `sort` the `-n` flag, it will `sort` numerically instead:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给`sort`传递`-n`标志，它将按数字顺序进行排序：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code produces this output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了以下输出：
- en: '![](img/43d738f9-6aa3-461a-8045-84dedd6a3871.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43d738f9-6aa3-461a-8045-84dedd6a3871.png)'
- en: 'Sometimes, you might want to sort on just a part of the data. In this way,
    you can start to treat these streams of data more like a database. You can use
    the `-k` option to sort data by columns, along with the `-t` option if your data
    is delimited by something other than tabs. We can use this, for example, to find
    the review with the most helpful votes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能只想对部分数据进行排序。通过这种方式，你可以开始把这些数据流当作数据库来处理。如果你的数据使用了除了制表符以外的其他分隔符，你可以使用`-t`选项，并结合`-k`选项按列排序。例如，我们可以用这个来查找获得最多有用投票的评论：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code produces lots of output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码产生了大量的输出：
- en: '![](img/9673d4fc-1004-47d1-95fc-e623312d4002.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9673d4fc-1004-47d1-95fc-e623312d4002.png)'
- en: Here, we pass the `-k9n`, `9` option to sort from column `9` to column `9` (just
    the one column), and we pass `n` to sort numerically.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递了`-k9n`，即从第`9`列排序到第`9`列（只有这一列），并传递了`n`选项来按数字排序。
- en: 'You can also sort on more than one column. Say we wanted to sort first by column
    `9` descending, but them by column `10` ascending:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以对多个列进行排序。假设我们首先按列`9`降序排序，然后按列`10`升序排序：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code produces the following output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码会产生以下输出：
- en: '![](img/91fb911a-2eca-48e5-b168-92f0ee848968.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91fb911a-2eca-48e5-b168-92f0ee848968.png)'
- en: In this example, we found the review with the least helpful votes but the most
    total votes as a tiebreak.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们找到了获得最少有用投票但总投票最多的评论，作为平局打破者。
- en: uniq
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: uniq
- en: '`uniq` is a funny little program that usually just removes adjacent identical
    lines in a stream of data. We put it in with `sort` because, usually, you see
    it used with data piped from `sort` to count the unique values in a stream of
    data:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniq`是一个有趣的小程序，通常用来删除数据流中相邻的相同行。我们将它与`sort`一起使用，因为通常你会看到它与来自`sort`的数据一起使用，以计算数据流中的唯一值：'
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It produces this counting sequence:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 它会产生这个计数序列：
- en: '![](img/076eac1e-ac25-49aa-ae3e-8ee71e2f8056.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/076eac1e-ac25-49aa-ae3e-8ee71e2f8056.png)'
- en: We can see the only possible star ratings are `1` through `5`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到唯一可能的评分是`1`到`5`。
- en: '`uniq` has some other uses, but this is by far the main use of `uniq`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniq`还有其他一些用途，但这无疑是`uniq`的主要用途。'
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the breadth of bash's control structures and dived
    into input/output redirection. These features can be leveraged to enhance your
    command-line functions and enable small scripts that process data in loops without
    having to resort to a full-fledged programming language for some simple data processing.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们介绍了bash控制结构的广度，并深入探讨了输入/输出重定向。这些功能可以被用来增强你的命令行功能，并使得一些小脚本能够在不依赖完整编程语言的情况下，使用循环处理数据，完成简单的数据处理任务。
- en: We also looked at a lot of ways to slice and dice characters and strings. While
    many use cases may be covered using string manipulation alone, often we'll want
    to delve a little deeper into the data represented by these streams to extract
    useful information.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了许多处理字符和字符串的方式。虽然许多使用案例可以仅通过字符串操作来解决，但通常我们希望深入探索这些数据流所表示的数据，以提取有用的信息。
- en: In the next chapter, we'll look at doing this by using the command line and
    data streams as a database.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用命令行和数据流将这些操作当作一个数据库来处理。
