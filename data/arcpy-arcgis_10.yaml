- en: Chapter 10. Advanced Geometry Object Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。高级几何对象方法
- en: In this chapter, we will discuss advanced Geometry object methods, previously
    discussed in [Chapter 6](ch06.html "Chapter 6. Working with ArcPy Geometry Objects"),
    *Working with ArcPy Geometry Objects*. The goal of this book is to give an introduction
    to ArcPy and its modules, while also demonstrating how to apply these tools when
    creating enduring GIS workflows. Performing an analysis once is good, but doing
    it over and over, with the click of a button, is better. Making the analysis results
    sharable in an industry standard format is also desirable. In the ArcGIS world,
    the best way to do this is with ArcPy and script tools that take advantage of
    Geometry object methods.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论之前在[第6章](ch06.html "第6章。使用ArcPy几何对象")中讨论过的高级几何对象方法，即*使用ArcPy几何对象*。本书的目标是介绍ArcPy及其模块，同时展示如何在创建持久的GIS工作流程时应用这些工具。进行一次分析是好的，但反复进行，只需点击一下按钮，就更好了。使分析结果以行业标准格式共享也是理想的选择。在ArcGIS世界中，实现这一目标最佳的方式是使用ArcPy和利用几何对象方法的脚本工具。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Adding common functions to a module in the Python path
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将常用函数添加到Python路径中的模块
- en: Making the analysis more advanced by adding point generation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加点生成使分析更高级
- en: Advanced Polygon object methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级多边形对象方法
- en: Using the XLWT to create Excel spreadsheets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XLWT创建Excel电子表格
- en: Creating a Python module
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Python模块
- en: An important step towards creating reusable code is to package its component
    functions into a module that can be called from the Python path by any script.
    To start, we need to create a folder in the `site-packages` folder where Python
    modules are placed when downloaded and extracted using the Python module process,
    or when running the `setup.py` script included with shared modules.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可重用代码的重要一步是将组件函数打包成一个模块，这样任何脚本都可以从Python路径中调用它。首先，我们需要在`site-packages`文件夹中创建一个文件夹，Python模块在下载并使用Python模块过程提取时放置在这个文件夹中，或者当运行包含在共享模块中的`setup.py`脚本时。在Windows资源管理器中打开`site-packages`文件夹，导航到`C:\Python27\ArcGIS10.2\Lib\site-packages`（如果你使用的是标准Python
    2.7安装，则为`C:\Python27\Lib\site-packages`）。一旦进入文件夹，创建一个名为**common**的新文件夹，如图所示：
- en: Modules package together functions in one or more scripts into a folder that
    can be shared with others (though they often depend on other modules to run).
    We have used some of the built-in modules such as the `csv` module and third-party
    modules such as ArcPy. Let's explore their construction to get a feel of how a
    module is packaged for use and sharing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 模块将一个或多个脚本中的函数打包到一个文件夹中，以便与他人共享（尽管它们通常依赖于其他模块才能运行）。我们已经使用了一些内置模块，如`csv`模块和第三方模块如ArcPy。让我们探索它们的构建，以了解模块是如何打包以供使用和共享的。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many modules are not placed within the site-packages folder, but they require
    the Python path to be modified to make them **importable**. Placing modules within
    the site-packages folder eliminates this requirement.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 许多模块并没有放置在`site-packages`文件夹中，但它们需要修改Python路径才能使它们**可导入**。将模块放置在`site-packages`文件夹中可以消除这一要求。
- en: 'Open up the site-packages folder in Windows Explorer by navigating to `C:\Python27\ArcGIS10.2\Lib\site-packages`
    (or `C:\Python27\Lib\site-packages` if you''re using the standard Python 2.7 installation)
    folder. Once in the folder, create a new folder called **common**, as shown in
    the following screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows资源管理器中打开`site-packages`文件夹，导航到`C:\Python27\ArcGIS10.2\Lib\site-packages`（如果你使用的是标准Python
    2.7安装，则为`C:\Python27\Lib\site-packages`）文件夹。一旦进入文件夹，创建一个名为**common**的新文件夹，如图所示：
- en: '![Creating a Python module](img/8662OS_10_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![创建Python模块](img/8662OS_10_01.jpg)'
- en: The __init__.py file
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: __init__.py文件
- en: Within this folder, a special file needs to be added to let Python recognize
    the folder as a module. This file, called `__init__.py`, takes advantage of the
    special property of Python called `magic` objects or attributes that are built
    into Python. These `magic` objects use the leading and trailing double underscore
    to avoid any confusion with custom functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹中，需要添加一个特殊文件，以便Python能够识别该文件夹为模块。这个文件称为`__init__.py`，它利用Python的一个特殊属性，即`magic`对象或属性，这些属性是内置到Python中的。这些`magic`对象使用前导和尾随的双下划线来避免与自定义函数混淆。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that these are *double* underscores; single underscores are usually used
    for so-called private functions within custom Python classes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些是**双下划线**；单下划线通常用于自定义Python类中的所谓私有函数。
- en: The `__init__.py` file is used to indicate that the folder is a module (making
    it importable using the `import` keyword), and to initiate the module by calling
    any modules that it may in turn rely on. However, there is no requirement to add
    import commands to the `__init__.py` file; it can be an empty file and will still
    perform the module recognition functionality that we require.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py` 文件用于指示该文件夹是一个模块（使其可以通过 `import` 关键字导入），并通过调用它可能依赖的任何模块来初始化该模块。然而，没有要求在
    `__init__.py` 文件中添加导入命令；它可以是空文件，并且仍然会执行我们所需的模块识别功能。'
- en: Open up **IDLE** or **Aptana** or your favorite IDE, and in the folder called
    **common**, add a new `Python` file and call it `__init__.py`. This file will
    remain empty for now.![The __init__.py file](img/8662OS_10_02.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **IDLE** 或 **Aptana** 或您喜欢的 IDE，在名为 **common** 的文件夹中添加一个新的 `Python` 文件，并将其命名为
    `__init__.py`。这个文件现在将保持为空。![__init__.py 文件](img/8662OS_10_02.jpg)
- en: Now that we have initiated the module, we need to create a script that will
    hold our common functions. Let's call it `useful.py` because these functions will
    be most useful for this analysis and others.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了模块，我们需要创建一个脚本，用于存放我们的公共函数。让我们称它为 `useful.py`，因为这些函数将在这个分析和其他分析中非常有用。
- en: The next step is to transfer functions that we had created in earlier chapters.
    These valuable functions are locked into those scripts, so by adding them to `useful.py`,
    we will make them available to all other scripts we craft.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将我们在早期章节中创建的函数转移过来。这些宝贵的函数被锁定在这些脚本中，所以通过将它们添加到 `useful.py`，我们将使它们对所有其他我们编写的脚本可用。
- en: Note
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One important function is the `formatSQLMultiple` from [Chapter 4](ch04.html
    "Chapter 4. Complex ArcPy Scripts and Generalizing Functions"), *Complex ArcPy
    Scripts and Generalizing Functions,* which generates SQL statements using a template
    and a list of data. By adding it to `useful.py`, we will be able to call the function
    anytime a SQL statement is required.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个重要的函数是来自 [第 4 章](ch04.html "第 4 章。复杂的 ArcPy 脚本和泛化函数") 的 `formatSQLMultiple`
    函数，它使用模板和数据列表生成 SQL 语句。通过将其添加到 `useful.py`，我们将在需要 SQL 语句时随时可以调用该函数。
- en: Open the script `Chapter4Modified2.py` and copy the function, and then paste
    it into `useful.py`. It has no dependencies, so it does not have to be modified.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本 `Chapter4Modified2.py`，复制函数，然后将其粘贴到 `useful.py` 中。它没有依赖项，因此不需要修改。
- en: Another useful function from that script is the `formatIntersect` function that
    generates a string of file paths that are used when running the ArcToolbox Intersect
    tool. While we have reached deeper into ArcPy since that function was designed,
    and no longer need to call the Intersect tool in our bus stop analysis, it does
    not mean that we will never need to call it in the future. It is still useful
    and should be added to `useful.py`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那个脚本中另一个有用的函数是 `formatIntersect` 函数，它生成在运行 ArcToolbox Intersect 工具时使用的文件路径字符串。虽然自从该函数设计以来我们已经深入到
    ArcPy 中，并且不再需要在我们的公交车站分析中调用 Intersect 工具，但这并不意味着我们将来永远不会需要调用它。它仍然很有用，应该添加到 `useful.py`
    中。
- en: 'The last function that we can raid is the `createCSV()` function. Copy and
    paste it from `Chapter4Modified.py` into `useful.py`. However, to avoid the need
    to import the CSV module separately, we will need to modify the function slightly.
    Here is how it should look:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以访问的最后一个函数是 `createCSV()` 函数。从 `Chapter4Modified.py` 复制并粘贴到 `useful.py` 中。但是，为了避免需要单独导入
    CSV 模块，我们需要稍微修改该函数。以下是它应该看起来像什么：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By importing and then deleting the `csv` module, we are able to use it to generate
    the `csv` file and then remove the module from memory using the `del` keyword.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入然后删除 `csv` 模块，我们能够使用它来生成 `csv` 文件，并使用 `del` 关键字从内存中移除该模块。
- en: 'Now that we have the functions we will be reusing saved in the `useful.py`
    script, inside the common module, let''s explore how to call them using Python''s
    `import` method. Open up a Python executable, using either `Python.exe` or IDLE,
    or the built-in terminal in Aptana. At the triple chevron prompt (**>>>**), write
    the following line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将将要重用的函数保存在 `useful.py` 脚本中，在公共模块内部，让我们探索如何使用 Python 的 `import` 方法调用它们。打开
    Python 可执行文件，使用 `Python.exe` 或 IDLE，或者在 Aptana 中的内置终端。在三个箭头提示符（**>>>**）中，输入以下行：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the second triple chevron-shaped prompt appears, the function was correctly
    imported from the module. To import the functions in this module in a script,
    use the same import structure and list the functions desired, separating them
    using a comma:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现第二个三重箭头形状的提示，则表示函数已正确从模块中导入。要在脚本中导入此模块中的函数，请使用相同的导入结构，并列出所需的函数，使用逗号分隔：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The functions in the script `useful.py` were called using Python dot notation.
    This is made possible because the `__init__.py` file indicates to Python that
    the folder `common` is now a module, and that it should expect a method called
    `useful` to be present, with the functions `createCSV` and `formatSQLMultiple`
    inside it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本`useful.py`中的函数使用Python点符号调用。这是由于`__init__.py`文件告诉Python，文件夹`common`现在是一个模块，并且它应该期望存在一个名为`useful`的方法，其中包含`createCSV`和`formatSQLMultiple`函数。
- en: Adding advanced analysis components
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加高级分析组件
- en: The bus stop analysis we have used to introduce ArcPy can be further extended
    to generate more refined results. To better estimate the true number of people
    that each bus stop serves, let's add a function that will generate random points
    within the blocks considered, while eliminating parks and other areas that do
    not contain housing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来介绍ArcPy的公交车站分析可以进一步扩展以生成更精确的结果。为了更好地估计每个公交车站服务的真实人数，让我们添加一个函数，该函数将在考虑的区块内生成随机点，同时消除公园和其他不含住宅的区域。
- en: To do this, we need to introduce a new data set from the `San Francisco` geodatabase,
    the `RPD_Parks` feature class. By using this feature class to reduce the area
    considered for our analysis, we can generate a more realistic assessment of the
    service area population for each bus stop.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要从`San Francisco`地理数据库中引入一个新的数据集，即`RPD_Parks`要素类。通过使用这个要素类来减少我们分析考虑的区域，我们可以为每个公交车站生成一个更现实的客运服务区人口评估。
- en: While using the **ArcToolbox Erase tool** to erase the area represented in the
    `RPD_Parks` polygons would be a usual step when running a spatial analysis, there
    are drawbacks to this option. The first is that the **Erase** tool is only available
    with the ArcGIS for Desktop Advanced license level, making it available only to
    certain users. The second drawback is that the tool produces an intermediate data
    set, something to be avoided wherever possible.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行空间分析时，使用**ArcToolbox擦除工具**擦除`RPD_Parks`多边形所表示的区域通常是一个常规步骤，但这个选项存在一些缺点。第一个缺点是**擦除**工具仅在ArcGIS
    for Desktop高级许可证级别下可用，这使得它仅对某些用户可用。第二个缺点是工具会产生一个中间数据集，在可能的情况下应尽量避免。
- en: Using ArcPy will give us the ability to avoid both of these drawbacks. We can
    create a script that will generate random points only within the fraction of the
    census block polygons that do not intersect with the `RPD_Parks` feature class.
    To do this, we will reach deeper into the methods of the ArcPy `Polygon` object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ArcPy将使我们能够避免这两个缺点。我们可以创建一个脚本，该脚本将仅在未与`RPD_Parks`要素类相交的普查区块多边形的一部分内生成随机点。为此，我们将深入到ArcPy
    `Polygon`对象的方法中。
- en: Advanced Polygon object methods
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级多边形对象方法
- en: In [Chapter 6](ch06.html "Chapter 6. Working with ArcPy Geometry Objects"),
    *Working with ArcPy Geometry Objects* we started exploring the ArcPy Geometry
    objects and how to use their methods to perform in-memory spatial analysis. The
    **Buffer** and **Intersect** methods of these objects were introduced and used
    to generate analysis results. Next, we will discuss more of these methods and
    show how they can help improve in-memory spatial analysis.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。使用ArcPy几何对象")*使用ArcPy几何对象*中，我们开始探索ArcPy几何对象以及如何使用它们的方法来执行内存中的空间分析。介绍了**缓冲区**和**交集**方法，并使用这些方法生成分析结果。接下来，我们将讨论更多这些方法，并展示它们如何有助于改进内存中的空间分析。
- en: The `Polygon` object has a method called `Difference` that allows us to find
    the area of non-intersection when two polygons intersect. Passing a `census block
    polygon` and a `park polygon` as parameters will return (as a polygon object)
    the fraction of the first parameter where no overlap occurs. Another important
    method is called `Overlaps`, which is called to test whether two Geometry objects
    (points, lines, or polygons) intersect. If there is an overlap, the `Overlaps`
    method will return **True**, while returning **False** if there is no overlap
    between the two objects. `Union` is also an important method that will be used
    within this chapter, it allows for two Geometry objects to be **unioned** into
    one object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polygon` 对象有一个名为 `Difference` 的方法，允许我们找到两个多边形相交时的非相交区域。将 `census block polygon`
    和 `park polygon` 作为参数传递将返回（作为多边形对象）第一个参数中不发生重叠的部分。另一个重要的方法是 `Overlaps`，它用于测试两个几何对象（点、线或多边形）是否相交。如果存在重叠，则
    `Overlaps` 方法将返回 **True**，如果没有重叠，则返回 **False**。`Union` 也是一个重要的方法，将在本章中使用，它允许将两个几何对象
    **合并** 成一个对象。'
- en: 'Let''s explore these important methods. To find the non-intersect area of two
    polygon objects, the following function combines the `Overlaps` and `Difference`
    methods:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些重要的方法。为了找到两个多边形对象的非相交区域，以下函数结合了 `Overlaps` 和 `Difference` 方法：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The function `nonIntersect` accepts two `Polygon` objects as parameters. The
    first parameter, `poly1`, is the polygon of intersect (the census block polygon)
    and the second parameter, `poly2`, is the polygon to be checked for overlap. The
    if conditional uses the `Overlaps` method and returns **True** if there is an
    overlap between the two parameters. If there is any overlap, the `difference()`
    method returns the non-intersect area as a polygon object. However, this function
    should be extended to cover situations where the `Overlaps()` method returns False:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `nonIntersect` 接受两个 `Polygon` 对象作为参数。第一个参数，`poly1`，是相交的多边形（人口普查区块多边形），第二个参数，`poly2`，是要检查重叠的多边形。if
    条件语句使用 `Overlaps` 方法，如果两个参数之间存在重叠，则返回 **True**。如果存在任何重叠，则 `difference()` 方法将返回非相交区域作为多边形对象。然而，这个函数应该扩展以涵盖
    `Overlaps()` 方法返回 False 的情况：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The function will now return the first parameter when the `Overlaps` method
    returns `False`, indicating that there is no overlap between the two polygon objects.
    This function is now complete and available to be used in an analysis. Because
    `nonIntersect()` is a function that can be used in other spatial analyses, copy
    it and add it to `useful.py`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Overlaps` 方法返回 `False` 时，函数现在将返回第一个参数，这表明两个多边形对象之间没有重叠。现在这个函数已经完成，可以在分析中使用。因为
    `nonIntersect()` 是一个可以在其他空间分析中使用的函数，所以复制它并将其添加到 `useful.py` 中。
- en: Generating random points to represent population
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成随机点以表示人口
- en: The next step to improve the bus stop analysis is to generate points to represent
    the population of each census block. While random points will not provide a perfect
    representation of the population, it will serve as a good model of the population
    and allow us to avoid area averaging to find the rough population of each census
    block served by a bus stop. The `CreateRandomPoints` tool in the ArcToolbox Data
    Management toolset makes it simple to generate the points.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 改进公交车站分析的下一步是生成点以表示每个人口普查区块的人口。虽然随机点不能完美地表示人口，但它将作为良好的人口模型，并允许我们避免对每个由公交车站服务的区块进行面积平均以找到粗略的人口。ArcToolbox
    数据管理工具集中的 `CreateRandomPoints` 工具使生成点变得简单。
- en: The `CreateRandomPoints` tool accepts a number of required and optional parameters.
    As the tool generates a feature class, the required parameters are the workspace
    where the feature class will be placed and the name of the feature class. The
    optional parameters of interest are the constraining feature class and the number
    of points to be generated. As we are looking to avoid creating new feature classes
    in the intermediate steps of our analysis, we can utilize the `in_memory` workspace,
    which allows feature classes to be generated in memory, meaning they are not written
    to the hard drive.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 工具 `CreateRandomPoints` 接受一系列必需和可选参数。由于该工具生成要素类，必需参数是要素类将被放置的工作空间和要素类的名称。感兴趣的可选参数是约束要素类和要生成的点数。由于我们希望在分析的中途步骤中避免创建新的要素类，我们可以利用
    `in_memory` 工作空间，这意味着要素类将在内存中生成，这意味着它们不会被写入硬盘。
- en: 'Because there is a need to generate a specific number of random points for
    each census block, we should create a function that will accept a constraining
    polygon and population figure that represents each census block. The `in_memory`
    workspace won''t work for every situation, however, so we''ll provide the workspace
    parameter with a default value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要为每个普查区生成特定数量的随机点，我们应该创建一个函数，该函数将接受一个约束多边形和表示每个普查区的总人口数。然而，`in_memory`工作空间并不适用于所有情况，因此我们将提供工作空间参数的默认值：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function will create the feature class in the workspace desired and will
    return the path (joined using the `os` module) to the feature class for use in
    the rest of the script. This function is also reusable and should be copied into
    `useful.py`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将在所需的工作空间中创建要素类，并将返回要素类的路径（使用`os`模块连接），以便在脚本的其他部分中使用。此函数也可重用，应将其复制到`useful.py`文件中。
- en: Using the functions within a script
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在脚本中使用函数
- en: 'Now that we have created the functions that will help us to run a more advanced
    spatial analysis, let''s add them to a script along with some `SearchCursors`
    to iterate through the data:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了帮助我们在脚本中运行更高级空间分析的函数，让我们将它们添加到脚本中，并添加一些`SearchCursors`来遍历数据：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's review the code, section by section, as that is a lot to take in at first.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐节回顾代码，因为一开始要吸收的内容很多。
- en: 'The import portion is where we call the usual modules, arcpy and os, along
    with our custom functions in the common module:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 导入部分是我们调用常规模块，如arcpy和os，以及`common`模块中的自定义函数：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As discussed previously, the functions in the `common` module's `useful` method
    are called using the Python dot notation and the `from … import ...` importation
    style, making them available directly. Many functions can be imported on one line,
    separated by commas, or individually as shown here.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`common`模块的`useful`方法中的函数使用Python点符号和`from … import ...`导入风格调用，使它们直接可用。许多函数可以在一行中导入，用逗号分隔，或者像这里一样单独导入。
- en: 'The next line, which sets the ArcPy Environment `overwrite` property to `True`,
    is very important because it allows us to overwrite the results of the Create
    random points operation. If the results were not overwritten, the function results,
    which otherwise would use all available memory and cause the script to fail:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个设置ArcPy环境`overwrite`属性为`True`的行非常重要，因为它允许我们覆盖创建随机点操作的结果。如果不覆盖，函数结果将使用所有可用内存并导致脚本失败：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to be careful with this overwrite setting because it will allow
    for any feature class to be overwritten. All of our output is in memory and only
    generated for the analysis, so there is little need to worry here, but take care
    to make sure that nothing important is overwritten when running a script.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在此覆盖设置上要小心，因为它将允许覆盖任何要素类。我们所有的输出都在内存中，并且只为分析生成，所以这里几乎不需要担心，但运行脚本时要确保没有重要内容被覆盖。
- en: 'The next portion is the set of variables that will be used in this script,
    and will initiate the spreadsheet that will be used to collect the results of
    the analysis:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是将在脚本中使用的一组变量，并将初始化用于收集分析结果的电子表格：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The file paths assigned to variables here could be replaced with ArcPy parameters
    if we were to turn this into a script tool, but for now, the hard-coded paths
    are fine. Below the variables, the results spreadsheet is created and the column
    field headers are added.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里分配给变量的文件路径如果要将此转换为脚本工具，可以替换为ArcPy参数，但到目前为止，硬编码的路径是可行的。在变量下方，创建结果电子表格并添加列字段标题。
- en: It is worth noting that the spreadsheet is created using the `wb` mode. This
    mode of binary file opening, known as `wb` (write binary), is used for creating
    a new file. It must be explicitly passed into the `createCSV()` function as the
    default mode parameter is `ab` (append binary), which will create a new file if
    it does not exist, or add to one that already exists (a third binary mode is **rb**
    or **read binary**, which is used for opening an existing file).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，电子表格是使用`wb`模式创建的。这种以二进制文件打开的模式称为`wb`（写二进制），用于创建新文件。必须显式传递给`createCSV()`函数作为默认模式参数是`ab`（追加二进制），如果不存在将创建新文件，或者添加到已存在的文件中（第三种二进制模式是**rb**或**read
    binary**，用于打开现有文件）。
- en: 'The next few lines make data in the feature classes available in memory. The
    census block data is converted into a `Feature Layer`, while the `RPD_Parks` data
    is read into memory as a list of `Polygon` objects that is then unioned into a
    single, unified `Polygon` object called `parkUnion`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行代码使特征类中的数据在内存中可用。人口普查区块数据被转换为`Feature Layer`，而`RPD_Parks`数据则被读取到内存中，作为一系列`Polygon`对象，然后这些对象被合并成一个单一的、统一的`Polygon`对象，称为`parkUnion`：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By using the `CopyFeatures` tool in the **Data Management** toolset, the `parkGeoms`
    variable is passed a list of the geometries for each row of data in the `RPD_Parks`
    feature class. However, we don't want to have to iterate through the park geometries
    to compare them to each census block, so the `Union` method is invoked to create
    one `Polygon` object from the entire list. By assigning the first member of the
    list to the `parkUnion` variable, and then iterating through the `parkGeoms` list
    to union the other geometries one by one, the result is one `Polygon` object that
    represents all parks within the `RPD_Parks` dataset.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**数据管理**工具集中的`CopyFeatures`工具，`parkGeoms`变量接收`RPD_Parks`特征类中每行数据的几何形状列表。然而，我们不想必须遍历公园几何形状来与每个区块进行比较，因此调用`Union`方法从整个列表创建一个`Polygon`对象。通过将列表的第一个成员分配给`parkUnion`变量，然后遍历`parkGeoms`列表逐个合并其他几何形状，最终得到一个代表`RPD_Parks`数据集中所有公园的`Polygon`对象。
- en: 'Once all of the modules have been imported and the variables have been assigned,
    we can enter the `for` loop of the data access `SearchCursor` to begin the analysis.
    However, we don''t want to run this for all of the bus stops, so we will use a
    SQL statement `where` clause, to limit the analysis to a single bus line:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有模块都已导入并且变量已分配，我们就可以进入数据访问`SearchCursor`的`for`循环以开始分析。然而，我们不想对所有公交车站进行分析，因此我们将使用SQL语句的`where`子句来限制分析范围到单条公交线：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first portion of the iteration involves entering the `for` loop and assigning
    the values of each row to a variable. A `Polygon` object buffer of `400` feet
    is created around the `PointGeometry` object returned by the `SearchCursor`. This
    buffer is then used to intersect with the census blocks `Feature Layer` to find
    and select all of the census blocks that intersect the buffer. To tally the population
    served by each buffer, the variable `totalPopulation` is created.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代的第一部分涉及进入`for`循环并将每行的值分配给一个变量。在`SearchCursor`返回的`PointGeometry`对象周围创建一个`400`英尺的`Polygon`对象缓冲区。然后，使用这个缓冲区与人口普查区块的`Feature
    Layer`相交，以找到并选择所有与缓冲区相交的区块。为了统计每个缓冲区服务的人口总数，创建了变量`totalPopulation`。
- en: 'Once the selection has been performed, a second `SearchCursor` can be used
    to iterate through the selected blocks to retrieve their population values and
    `Polygon` objects for random point generation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了选择操作，就可以使用第二个`SearchCursor`遍历所选区块，以检索它们的 人口值和用于随机点生成的`Polygon`对象：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this iteration, once each census block has been retrieved (in the form of
    a Polygon object), the block is then checked against the **unioned** park geometry
    using the `nonIntersect` function created previously. This ensures that the points
    will only be created within areas that are not parks, that is, more likely to
    represent where people would live. The population values are also retrieved.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个迭代过程中，一旦检索到每个区块（以`Polygon`对象的形式），就使用之前创建的`nonIntersect`函数将该区块与合并的公园几何形状进行比对。这确保了点只会在非公园区域内创建，即更有可能代表人们居住的地方。同时也会检索人口值。
- en: 'Once the constraining polygon (for example the census block) has been evaluated
    and any potential park portion has been removed, and the population value is available,
    the random points can be generated using the `generatePoints()` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦评估了约束多边形（例如人口普查区块），移除了任何潜在的公园部分，并且获得了人口值，就可以使用`generatePoints()`函数生成随机点：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `generatePoints()` function requires three parameters. The first is the
    name of the feature class to be generated; this will be overwritten each time
    it is generated, thus avoiding the overuse of memory by creating an `in_memory`
    feature class for each census block. The other two parameters are the population
    value and the constraining Polygon object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`generatePoints()`函数需要三个参数。第一个是要生成的特征类的名称；每次生成时都会覆盖，从而避免为每个区块创建一个`in_memory`特征类，以避免过度使用内存。其他两个参数是人口值和约束多边形对象。'
- en: Once these have been passed to the function, it returns a file path to the newly
    created feature class and assigns the file path to the variable points. The geometries
    in points are then extracted using the `CopyFeatures` tool and assigned to the
    variable `points`. The `Union` method is again used to create a single, unified
    population `PointGeometry` object that will be intersected with the bus stop buffer.
    Once this intersection has been run, the resulting geometries are assigned to
    the `pointsInBuffer` variable and the `pointCount` method is used to find the
    number of points that were generated within the buffered area. This is our estimate
    of population within the census block, and this value is added to the `totalPopulation`
    variable to eventually yield the total estimated population within 400 feet of
    the bus stop.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些参数传递给函数，它将返回新创建的特征类的文件路径，并将该文件路径分配给变量points。然后使用`CopyFeatures`工具从points中提取几何形状，并将其分配给变量`points`。再次使用`Union`方法创建一个单一的、统一的`PointGeometry`对象，该对象将与公交车站缓冲区相交。一旦运行了此交集，结果几何形状将被分配给`pointsInBuffer`变量，并使用`pointCount`方法找到在缓冲区域内生成的点的数量。这是我们估计的人口普查区块内的人口，该值被添加到`totalPopulation`变量中，最终得出距离公交车站400英尺内的总估计人口。
- en: 'The final lines of the script demonstrate how the data is collected into a
    tuple and passed to the `createCSV()` module to be written to our final spreadsheet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后几行演示了如何将数据收集到一个元组中，并将其传递给`createCSV()`模块以写入我们的最终电子表格：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The last line, `os.startfile(csvName)`, uses the `startfile` method of the `os`
    module to automatically open the spreadsheet once the analysis is completed. In
    this case, the spreadsheet `C:\Projects\Output\Chapter10Analysis.csv` has been
    populated with the results of the analysis and is opened to display these results.
    However, the user may have to indicate that the lines are comma separated values
    to open the script.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行，`os.startfile(csvName)`，使用`os`模块的`startfile`方法在分析完成后自动打开电子表格。在这种情况下，电子表格`C:\Projects\Output\Chapter10Analysis.csv`已填充了分析结果，并打开以显示这些结果。然而，用户可能需要指示这些行是逗号分隔值，才能打开脚本。
- en: '![Using the functions within a script](img/8662OS_10_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![在脚本中使用函数](img/8662OS_10_03.jpg)'
- en: Instead of creating a comma separated value, we can take advantage of another
    Python module that is installed when ArcGIS 10.2 and ArcPy is installed. This
    module, called `XLWT`, is used to generate Excel spreadsheets, and along with
    the Excel spreadsheet reading module `XLRD`, is one of the most useful modules
    available to users of Python.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是创建逗号分隔值，我们可以利用ArcGIS 10.2和ArcPy安装时安装的另一个Python模块。这个模块被称为`XLWT`，用于生成Excel电子表格，并且与Excel电子表格读取模块`XLRD`一起，是Python用户可用最有用的模块之一。
- en: Creating an XLS using XLWT
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用XLWT创建XLS
- en: 'XLWT is a powerful module that allows for a multitude of styling options. However,
    for our purposes we can ignore those options and create a function that will generate
    a spreadsheet with the results of our spatial analysis. This function can of course
    be added to `common.useful`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: XLWT是一个功能强大的模块，允许多种样式选项。然而，对于我们的目的，我们可以忽略这些选项，创建一个将生成我们的空间分析结果的电子表格的函数。当然，此函数可以添加到`common.useful`中：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function requires three parameters, `indatas`- a list containing rows of
    iterable data, a string sheet name, and a string file name that ends with the
    `.xls` extension.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数需要三个参数，`indatas`-一个包含可迭代数据行的列表，一个字符串工作表名称，以及一个以`.xls`扩展名结尾的字符串文件名。
- en: 'To use this function, add it to `common.useful`. Once it has been added, copy
    and rename the older analysis script so that it can be adjusted:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此函数，将其添加到`common.useful`中。一旦添加，复制并重命名较旧的脚本分析，以便进行调整：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can now generate Excel spreadsheets just as easily as we have generated `CSV`
    files while employing a reusable function. We now have the ability to perform
    repeatable spatial analysis fast and can produce results in industry standard
    formats.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像生成`CSV`文件一样轻松地生成Excel电子表格，同时使用可重用的函数。我们现在能够快速执行可重复的空间分析，并以行业标准格式生成结果。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored how to create modules and reusable functions
    that will save scripting time in the future by allowing us to avoid rewriting
    these useful functions. We further explored the methods available through ArcPy
    Geometry objects, including the `Intersect`, `Overlaps`, and `Union` methods.
    We created a spatial analysis that writes no feature classes to disk, making it
    so that the analysis time is reduced and unnecessary files are avoided. Finally,
    we explored how to generate Excel spreadsheets using the `XLWT` module so that
    analysis results can be shared in industry standard formats.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何创建模块和可重用的函数，这些函数将节省未来的脚本编写时间，使我们能够避免重写这些有用的函数。我们还进一步探讨了通过 ArcPy
    几何对象可用的方法，包括 `Intersect`（交集）、`Overlaps`（重叠）和 `Union`（并集）方法。我们创建了一个不将要素类写入磁盘的空间分析，这样分析时间就减少了，并且避免了不必要的文件。最后，我们探讨了如何使用
    `XLWT` 模块生成 Excel 电子表格，以便分析结果可以以行业标准格式共享。
- en: In the next chapter, we will explore how to use ArcPy to interact with the ArcGIS
    for desktop extensions such as Network Analyst and Spatial Analyst. By incorporating
    their functionality within a script, we further increase our ability to create
    fast and repeatable spatial analysis workflows.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用 ArcPy 与 ArcGIS for Desktop 的扩展程序如网络分析师和空间分析师进行交互。通过在脚本中整合它们的功能，我们进一步增强了创建快速且可重复的空间分析工作流程的能力。
