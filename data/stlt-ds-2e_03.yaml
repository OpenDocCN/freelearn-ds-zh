- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Data Visualization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据可视化
- en: Visualization is a fundamental tool for the modern data scientist. It is often
    the central lens used to understand items such as statistical models (for example,
    via an AUC chart), the distribution of a crucial variable (via a histogram), or
    even important business metrics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化是现代数据科学家的一项基本工具。它通常是理解诸如统计模型（例如，通过 AUC 图表）、关键变量的分布（通过直方图）或甚至重要商业指标的核心方式。
- en: In the last two chapters, we used two popular Python graphing libraries (**Matplotlib**
    and **Altair**) in our examples. This chapter will focus on extending that ability
    to a broad range of Python graphing libraries, including some graphing functions
    native to Streamlit.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们在示例中使用了两个流行的 Python 绘图库（**Matplotlib** 和 **Altair**）。本章将重点介绍如何将这一能力扩展到更多种类的
    Python 绘图库，包括 Streamlit 原生的一些绘图函数。
- en: By the end of this chapter, you should feel comfortable using Streamlit’s native
    graphing functions and visualization functions to place graphs made from major
    Python visualization libraries in your own Streamlit app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你应该能够自如地使用 Streamlit 的原生绘图函数和可视化函数，将主要 Python 可视化库制作的图表嵌入到你自己的 Streamlit
    应用中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: '**San Francisco** (**SF**) Trees – a new dataset'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旧金山**（**SF**）树木 —— 一个新的数据集'
- en: Streamlit’s built-in graphing functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Streamlit 内置的绘图函数
- en: Streamlit’s built-in visualization options
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Streamlit 内置的可视化选项
- en: 'Using Python visualization libraries in Streamlit. In this section, we will
    cover the following libraries:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Streamlit 中使用 Python 可视化库。在本节中，我们将介绍以下库：
- en: '**Plotly** (for interactive visualizations)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Plotly**（用于互动可视化）'
- en: '**Seaborn** and **Matplotlib** (for classic statistical visualizations)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Seaborn** 和 **Matplotlib**（用于经典统计可视化）'
- en: '**Bokeh** (for interactive visualization in web browsers)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bokeh**（用于在 Web 浏览器中进行互动可视化）'
- en: '**Altair** (for declarative, interactive visualizations)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Altair**（用于声明式互动可视化）'
- en: '**PyDeck** (for interactive map-based visualizations)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyDeck**（用于基于地图的互动可视化）'
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be working with a new dataset that can be found at
    [https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv](https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv).
    A further explanation of the dataset can be found in the following section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个新的数据集，数据集可以在 [https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv](https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv)
    找到。数据集的进一步说明将在以下部分中介绍。
- en: San Francisco Trees – a new dataset
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旧金山树木 —— 一个新的数据集
- en: 'We’re going to be working with all sorts of graphs in this chapter, so we’re
    going to need a new dataset that has much more info, especially dates and locations.
    Enter **SF Trees**. The department of public works in SF has a dataset (cleaned
    by the wonderful folks in the R community who run Tidy Tuesday, a weekly event
    where people publish interesting visualizations of new data each week) of every
    tree planted and maintained in the city of SF. They cleverly call this dataset
    **EveryTreeSF – Urban Forest Map** and update it every day. I have selected a
    random set of 10,000 trees with complete info and placed this data in the main
    GitHub repository under the **trees** folder (I’m not as clever as the data engineer
    in SF’s DPW, I know). The GitHub repo can be found at [https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps).
    If you would like to download the full dataset, the link is here: [https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq](https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理各种类型的图表，因此需要一个包含更多信息、特别是日期和位置的新数据集。引入 **SF Trees** 数据集。旧金山市公共工程部有一个数据集（由
    R 社区中的优秀成员清理，这些成员运营着 Tidy Tuesday 这一每周活动，发布有趣的数据可视化），包含了旧金山市所有种植和维护的树木的信息。该数据集巧妙地命名为
    **EveryTreeSF – 城市森林地图**，并每天更新。我已随机选择了 10,000 棵树的完整信息，并将此数据存放在主 GitHub 仓库中的 **trees**
    文件夹下（我并不像旧金山市公共工程部的数据工程师那么聪明，我知道）。GitHub 仓库链接为 [https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps)。如果你想下载完整数据集，可以通过此链接：
    [https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq](https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq)。
- en: 'From the main `streamlit_apps` folder that we’ve been using throughout this
    book, start by creating a new folder, creating a new Python file, and then downloading
    our data into that folder, the same thing we did in *Chapter 2*, *Uploading, Downloading,
    and Manipulating Data*, but with some new data! You can run the following code
    in your terminal to set this up:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们在本书中一直使用的 `streamlit_apps` 主文件夹开始，创建一个新文件夹，创建一个新的 Python 文件，然后将数据下载到该文件夹中，这与我们在*第
    2 章*《上传、下载和操作数据》中所做的相同，不过这次用的是一些新数据！你可以在终端中运行以下代码来设置：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I’ll note here that if this does not work, or if you are on an operating system
    without these commands (such as Windows, for example), you can always go and download
    the CSV file directly by going to the GitHub repo mentioned in the preceding paragraph
    ([https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里要指出的是，如果这种方法不起作用，或者你使用的是没有这些命令的操作系统（例如 Windows），你总是可以直接通过访问前面段落中提到的 GitHub
    仓库 ([https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps))
    来下载 CSV 文件。
- en: Now that we have our setup, our next step is to open our `trees.py` file in
    our favorite editor and start making our Streamlit app.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了设置，接下来的步骤是打开我们最喜欢的编辑器中的 `trees.py` 文件，开始制作我们的 Streamlit 应用。
- en: We will follow these exact same steps at the beginning of the rest of the chapters,
    so in the future, we will not cover these explicitly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书接下来的章节一开始时遵循完全相同的步骤，因此未来我们将不会明确地涵盖这些内容。
- en: 'Let’s start by titling our app and printing out some example rows using the
    following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为应用设置标题，并使用以下代码打印一些示例行：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can then run the following command in our terminal and see the resulting
    Streamlit app in our browser:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在终端中运行以下命令，并在浏览器中查看生成的 Streamlit 应用：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that this is neither the easiest nor the best way to see the first few
    rows of a dataset, but we can do this purely because we already know that we’re
    going to build a Streamlit app using this data. The general workflow usually begins
    with some data exploration outside of Streamlit (in Jupyter notebooks, through
    SQL queries, or whatever the preferred workflow is for you as a data scientist
    or analyst). With that said, let’s continue our exploration of the dataset by
    looking at the output of the preceding code in the new Streamlit app in our browser:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这既不是查看数据集前几行的最简单方法，也不是最好的方法，但我们之所以这样做，是因为我们已经知道将使用这些数据构建一个 Streamlit 应用。一般的工作流程通常始于在
    Streamlit 之外对数据的探索（比如在 Jupyter Notebook 中，或通过 SQL 查询，或者任何你作为数据科学家或分析师所偏好的工作流程）。话虽如此，让我们继续通过在浏览器中的新
    Streamlit 应用查看前面代码的输出，来进一步探索数据集：
- en: '![](img/B18444_03_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_03_01.png)'
- en: 'Figure 3.1: The first few rows of trees'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：树木数据集的前几行
- en: This dataset contains a huge amount of info about the trees in SF, from their
    width (**dbh**) to the longitude and latitude points, the species, their address,
    and even the date they were planted. Before we get started with graphing, let’s
    talk a bit about the visualization options in front of us.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据集包含了关于旧金山树木的大量信息，从树木的宽度（**dbh**）到经纬度、物种、地址，甚至是它们的种植日期。在我们开始绘图之前，先谈谈我们面前的可视化选项。
- en: Streamlit visualization use cases
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Streamlit 可视化使用案例
- en: Some Streamlit users are relatively experienced Python developers with well-tested
    workflows in visualization libraries of their choice. For these users, the best
    path forward is the one we’ve taken so far, which is to create graphs in our library
    of choice (Seaborn, Matplotlib, Bokeh, and so on) and then use the appropriate
    Streamlit function to write this to the app.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Streamlit 用户是相对经验丰富的 Python 开发者，他们在自己选择的可视化库中有着经过充分测试的工作流程。对于这些用户，最好的前进路径就是我们目前所采用的方式，那就是在我们选择的库（如
    Seaborn、Matplotlib、Bokeh 等）中创建图表，然后使用适当的 Streamlit 函数将其写入应用程序。
- en: Other Streamlit users will have less experience in Pythonic graphing, and especially
    for these users, Streamlit offers a few built-in functions. We’ll start with built-in
    libraries and move on to learning how to import the most popular and powerful
    libraries for our Streamlit apps.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 Streamlit 用户在 Python 图形绘制方面经验较少，尤其是对于这些用户，Streamlit 提供了一些内建函数。我们将从内建库开始，接着学习如何为我们的
    Streamlit 应用导入最流行和最强大的库。
- en: Streamlit’s built-in graphing functions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Streamlit 的内建图形功能
- en: 'There are four built-in functions for graphing – `st.line_chart()`, `st.bar_chart()`,
    `st.area_chart()`, and `st.map()`. They all work similarly by trying to figure
    out what variables you’re already trying to graph and then putting them into a
    line, bar, map, or area chart, respectively. In our dataset, we have a variable
    called `dbh`, which is the width of the tree at chest height. First, we can group
    our DataFrame by `dbh`, and then push that directly to the line chart, bar chart,
    and area chart. The following code should group our dataset by width, count the
    unique trees of each width, and then make a line, bar, and area chart of each:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个内置的图表函数——`st.line_chart()`、`st.bar_chart()`、`st.area_chart()` 和 `st.map()`。它们的工作原理相似，都是尝试识别你已经在尝试绘制的变量，然后将它们分别放入折线图、条形图、地图图或区域图。在我们的数据集中，有一个叫做
    `dbh` 的变量，表示树木胸高的直径。首先，我们可以根据 `dbh` 对 DataFrame 进行分组，然后将其直接推送到折线图、条形图和区域图。以下代码将根据宽度对数据集进行分组，统计每个宽度的独特树木数量，然后绘制每个图表：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code should show our three graphs one right after another, as
    shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应按顺序显示我们的三个图表，如下截图所示：
- en: '![](img/B18444_03_02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_03_02.png)'
- en: 'Figure 3.2: Lines, bars, area, and tree height'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：折线、条形图、区域图和树木高度
- en: We gave the function nothing except for the DataFrame, and it was able to guess
    correctly which items should be on the *x* and *y* axes and plot those to our
    Streamlit chart. Each of these charts is also interactive by default! We can zoom
    in or out, roll the mouse over points/bars/lines to see each data point, and even
    view the full screen out of the box. These Streamlit functions call a popular
    graphing library called **Altair** (the same one we used before in *Chapter 2*!).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给这个函数提供的唯一参数就是 DataFrame，而它能够正确地猜测出应该放在 *x* 轴和 *y* 轴上的项目，并将它们绘制到我们的 Streamlit
    图表上。每个图表默认都是交互式的！我们可以放大或缩小，鼠标悬停在点/条形/线条上查看每个数据点，甚至可以直接查看全屏。这些 Streamlit 函数调用了一个流行的图表库叫做
    **Altair**（就是我们之前在 *第2章* 中使用的那个！）。
- en: 'Now that we see the basics of the built-in (it’s clear that the term *built-in*
    is fairly loose here, as Streamlit is built to be a great and convenient web application
    library, not a great visualization library) functions, let’s push these functions
    to see how they handle more data. First, we’re going to make a new column of random
    numbers between -500 and 500 in our `df_dbh_grouped` DataFrame, using the `numpy`
    library, and use the same plotting code that we used before. The following code
    plots two line charts, one before we added the new column, and one after:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到了内置函数的基础知识（显然，“内置”一词在这里的定义比较宽泛，因为 Streamlit 是为了成为一个很棒且便捷的 Web 应用程序库，而不是一个专门的可视化库），让我们把这些函数用到更多数据上，看看它们如何处理。首先，我们将在
    `df_dbh_grouped` DataFrame 中生成一个介于 -500 和 500 之间的随机数新列，使用 `numpy` 库，并使用之前相同的绘图代码。以下代码绘制了两个折线图，一个是添加新列之前的，另一个是添加之后的：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code should produce an app that looks like the following screenshot, with
    the two separate line charts vertically adjacent to each other.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该生成一个看起来像下面截图的应用，两个单独的折线图垂直排列在一起。
- en: '![](img/B18444_03_03.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_03_03.png)'
- en: 'Figure 3.3: Two sequential line charts'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：两个连续的折线图
- en: 'Again, these functions put whatever is on the index on the *x* axis and use
    all the columns they can as variables on the *y* axis. These built-in functions
    are very useful if we have an incredibly straightforward graphing problem in front
    of us (as in the example). If we want, we can also explicitly tell Streamlit the
    variables that we want to plot on the *x*and *y* axes; the following bit of code
    turns the index into its own column and then graphs a line chart:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，这些函数将索引上的内容放在 *x* 轴上，并将它们能找到的所有列作为 *y* 轴上的变量。如果我们遇到一个非常简单的绘图问题（如示例中所示），这些内置函数非常有用。如果我们愿意，还可以显式地告诉
    Streamlit 我们想要在 *x* 和 *y* 轴上绘制的变量；以下代码段将索引转换为单独的列，然后绘制一个折线图：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When you run this code, you’ll see the same line chart we created before! These
    built-in functions are great but less flexible when compared to libraries with
    the sole purpose of visualization, and it may be difficult to debug the behavior
    behind these functions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你会看到之前创建的相同折线图！这些内置函数非常棒，但与专注于可视化的库相比，它们的灵活性较差，而且可能很难调试这些函数背后的行为。
- en: The recommendation here is that if you want a fairly basic visualization, these
    functions will probably work just fine for you. But if you want something more
    complicated, you should use other graphing libraries (my personal favorite is
    Altair).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的建议是，如果你只需要一个相对基础的可视化，这些函数可能完全适合你。但如果你想要更复杂的东西，应该使用其他图形库（我个人最喜欢的是 Altair）。
- en: 'There is one more built-in Streamlit graphing function that we should discuss
    here, `st.map()`. Just like the preceding functions, this wraps around another
    Python graphing library, this time PyDeck instead of Altair, and finds columns
    that it thinks are longitude and latitude points by searching the DataFrame for
    columns with titles such as **longitude**, **long**, **latitude**, or **lat**.
    Then, it plots each row as its own point on a map, auto-zooms and focuses the
    map, and writes it to our Streamlit app. We should note that visualizing detailed
    maps is much more computationally intensive in comparison to the other forms of
    visualization that we have used so far, so we are going to sample 1,000 random
    rows from our DataFrame, remove `null` values, and try out `st.map()` using the
    following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个内置的 Streamlit 图形函数我们需要讨论，`st.map()`。就像前面的函数一样，这个函数封装了另一个 Python 图形库，这次使用的是
    PyDeck，而不是 Altair，它通过搜索 DataFrame 中标题为 **longitude**、**long**、**latitude** 或 **lat**
    等的列来识别认为是经度和纬度的列。然后，它将每一行作为一个点绘制在地图上，自动缩放并聚焦地图，最后将其写入我们的 Streamlit 应用。我们需要注意的是，与我们迄今使用的其他可视化形式相比，详细地图的可视化计算量要大得多，因此我们将从
    DataFrame 中随机抽取 1,000 行，移除 `null` 值，并使用以下代码尝试 `st.map()`：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This works perfectly well, right out of the box! We get a beautiful interactive
    map of trees in SF, as we can see in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常完美，开箱即用！我们得到了一个漂亮的交互式旧金山树木地图，如下图所示：
- en: '![Figure 3.4 – Default SF map of trees ](img/B18444_03_04.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 默认的旧金山树木地图 ](img/B18444_03_04.png)'
- en: 'Figure 3.4: Default SF map of trees'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：默认的旧金山树木地图
- en: As with other functions, we don’t have many options for customization here other
    than an optional zoom parameter, but this works very well for quick visualization.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他函数一样，我们在这里的定制选项并不多，除了一个可选的缩放参数，但这个功能非常适合快速可视化。
- en: As we’ve seen, these built-in functions can be useful to make Streamlit apps
    quickly, but we trade off speed for customizability. In practice, I rarely use
    these functions when I produce Streamlit apps, but I often use these when doing
    quick visualizations of data already in Streamlit. In production, more powerful
    libraries, such as Matplotlib, Seaborn, and PyDeck, would be able to give us the
    flexibility and customizability we want. The rest of this chapter will provide
    a walk-through of six different popular Python visualization libraries.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，这些内置函数对于快速创建 Streamlit 应用非常有用，但我们在速度和可定制性之间做了权衡。在实际应用中，我很少在制作 Streamlit
    应用时使用这些函数，但在进行快速可视化时，我经常使用这些函数。在生产环境中，更强大的库，如 Matplotlib、Seaborn 和 PyDeck，将能够提供我们所需的灵活性和可定制性。本章的剩余部分将提供六种不同流行
    Python 可视化库的详细介绍。
- en: Streamlit’s built-in visualization options
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Streamlit 内置的可视化选项
- en: For the rest of this chapter, we’re going to run through the rest of the Streamlit
    visualization options, which are Plotly, Matplotlib, Seaborn, Bokeh, Altair, and
    PyDeck.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将介绍 Streamlit 的其他可视化选项，包括 Plotly、Matplotlib、Seaborn、Bokeh、Altair
    和 PyDeck。
- en: Plotly
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Plotly
- en: Plotly is an interactive visualization library that many data scientists use
    to visualize data in a Jupyter notebook, either locally in the browser or even
    hosted on a web platform such as **Dash** (the creator of Plotly). This library
    is very similar to Streamlit in its intent and is primarily used for internal
    or external dashboards (hence, the name Dash).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Plotly 是一个交互式可视化库，许多数据科学家用它在 Jupyter notebook 中可视化数据，无论是在本地浏览器中，还是托管在像 **Dash**（Plotly
    的创建者）这样的 Web 平台上。这个库与 Streamlit 在目标上非常相似，主要用于内部或外部的仪表板（因此，才有了 Dash 这个名字）。
- en: 'Streamlit allows us to call plotly graphs from within Streamlit apps using
    the `st.plotly_chart()` function, which makes it a breeze to port any Plotly or
    Dash dashboards. We’ll test this out by making a histogram of the height of trees
    in SF, essentially the same graph that we’ve made before. The following code makes
    our Plotly histogram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 允许我们通过 `st.plotly_chart()` 函数在 Streamlit 应用中调用 Plotly 图表，这使得移植任何 Plotly
    或 Dash 仪表板变得非常轻松。我们将通过绘制旧金山树木的身高直方图来测试这一点，这基本上是我们之前制作的图表。以下代码生成我们的 Plotly 直方图：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we’ll notice, all the interactivity native to Plotly works by default in
    Streamlit. Particularly, the user can scroll over histogram bars and get the exact
    info about each bar. There are a few other useful built-in features in Plotly
    that readily port over to Streamlit, such as the ability to zoom in and out, download
    the plot as a .**png**, and select a group of data points/bars/lines. The full
    features can be seen in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所注意到的，所有 Plotly 的原生交互性在 Streamlit 中默认可以使用。特别是，用户可以滚动直方图的条形图，并获取每个条形图的确切信息。Plotly
    中还有一些其他有用的内置功能，可以直接移植到 Streamlit 中，例如放大缩小、下载图表为 .**png** 文件，以及选择一组数据点/条形图/线条。以下截图显示了完整功能：
- en: '![](img/B18444_03_05.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_03_05.png)'
- en: 'Figure 3.5: Our first Plotly chart'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：我们的第一个 Plotly 图表
- en: Now that we’re comfortable with Plotly, we can move on to other popular visualization
    libraries, Matplotlib and Seaborn.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 Plotly，我们可以继续学习其他流行的可视化库，Matplotlib 和 Seaborn。
- en: Matplotlib and Seaborn
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Matplotlib 和 Seaborn
- en: 'Earlier in this book, we learned how to use the Matplotlib and Seaborn visualization
    libraries inside Streamlit, so we will just go over them briefly here. There is
    a column called **date** in the trees dataset that corresponds to the date that
    the tree was planted. We can use the `datetime` library to figure out the age
    of each tree in days, and plot that histogram using Seaborn and Matplotlib, respectively.
    The following code creates a new column called `age`, which is the difference
    in days between the tree planting date and today’s date, and then graphs the histogram
    of the age using both Seaborn and Matplotlib:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前面部分，我们学习了如何在 Streamlit 中使用 Matplotlib 和 Seaborn 可视化库，因此我们在这里将简单地回顾它们。树木数据集中有一个名为**date**的列，表示树木种植的日期。我们可以使用
    `datetime` 库来计算每棵树的年龄（以天为单位），并分别使用 Seaborn 和 Matplotlib 绘制该直方图。以下代码创建了一个名为 `age`
    的新列，表示树木种植日期和今天日期之间的天数差异，然后使用 Seaborn 和 Matplotlib 绘制该年龄的直方图：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we defined unique subplots for each graph, created a
    Seaborn or Matplotlib graph for each, and then used the `st.pyplot()` function
    to insert each graph in successive order right inside our Streamlit app. The preceding
    code should show an app similar to the following screenshot (I say similar because,
    depending on when you run this, the age of the trees will be different, as `pd.to_datetime`
    (`''today''`) will return your current date):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为每个图表定义了独立的子图，为每个图表创建了一个 Seaborn 或 Matplotlib 图表，然后使用 `st.pyplot()`
    函数按顺序将每个图表插入到我们的 Streamlit 应用中。前面的代码应该会显示一个类似于以下截图的应用（我说“类似”是因为，根据你运行的时间，树木的年龄会有所不同，因为
    `pd.to_datetime`（`'today'`）会返回你当前的日期）：
- en: '![Figure 3.6 – Seaborn and Matplotlib histograms ](img/B18444_03_06.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – Seaborn 和 Matplotlib 直方图](img/B18444_03_06.png)'
- en: 'Figure 3.6: Seaborn and Matplotlib histograms'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：Seaborn 和 Matplotlib 直方图
- en: Whether you use Seaborn or Matplotlib, you’ll use the `st.pyplot()` function
    in the same way. Now that we’re more comfortable with these libraries, we can
    learn about another interactive visualization library – **Bokeh**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是使用 Seaborn 还是 Matplotlib，你都会以相同的方式使用 `st.pyplot()` 函数。现在我们已经更加熟悉这些库，我们可以学习另一种交互式可视化库
    —— **Bokeh**。
- en: Bokeh
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bokeh
- en: Bokeh is another web-based interactive visualization library that also has dashboarding
    products built on top of it. It is a direct competitor to Plotly and is, frankly,
    incredibly similar in use, but it has some stylistic differences. Either way,
    Bokeh is an extremely popular Python visualization package that Python users may
    be very comfortable using.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Bokeh 是另一个基于 Web 的交互式可视化库，也有基于其构建的仪表板产品。它是 Plotly 的直接竞争对手，坦白说，在使用上非常相似，但在样式上有所不同。不管怎样，Bokeh
    是一个非常流行的 Python 可视化包，Python 用户可能非常熟悉使用它。
- en: 'We can call Bokeh graphs using the same format as Plotly. First, we create
    the Bokeh graph, and then we use the `st.bokeh_chart()` function to write the
    app to Streamlit. In Bokeh, we have to first instantiate a Bokeh figure object,
    and then change aspects of that figure before we can plot it out. The important
    lesson here is that if we change an aspect of the Bokeh figure object after we
    call the `st.bokeh_chart()` function, we will not change the graph shown on the
    Streamlit app. For example, when we run the following code, we will not see a
    new **x** axis title at all:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像使用Plotly一样调用Bokeh图表。首先，我们创建Bokeh图表，然后使用`st.bokeh_chart()`函数将应用写入Streamlit。在Bokeh中，我们必须首先实例化一个Bokeh图形对象，然后在绘制之前修改该图形的各个方面。这里的重要教训是，如果我们在调用`st.bokeh_chart()`函数之后修改Bokeh图形对象的某个方面，我们将不会改变Streamlit应用中显示的图表。例如，当我们运行以下代码时，完全看不到新的**x**轴标题：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Instead, we’ll have to switch the order of the last two lines, which will now
    show up on our app. We’ll add a **y** axis for good measure as well:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要交换最后两行的顺序，这样它们就会出现在我们的应用中。我们还将添加一个**y**轴作为补充：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code will create a Bokeh chart of `dbh` versus `site_order`,
    as shown in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建一个`dbh`与`site_order`的Bokeh图表，如下图所示：
- en: '![Figure 3.7 – Bokeh scatterplot ](img/B18444_03_07.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – Bokeh散点图](img/B18444_03_07.png)'
- en: 'Figure 3.7: Bokeh scatterplot'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：Bokeh散点图
- en: Now that we have our basic Bokeh plot of `dbh` by site order, on to our next
    visualization library – Altair!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了基本的`dbh`按地点顺序绘制的Bokeh图表，接下来是我们要使用的下一个可视化库——Altair！
- en: Altair
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Altair
- en: We’ve already used Altair in this chapter through Streamlit functions such as
    `st.line_chart()` and `st.map()`, and directly through `st.altair_chart()`, so
    again we’ll cover this one briefly for completeness.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经通过Streamlit函数如`st.line_chart()`和`st.map()`，以及直接通过`st.altair_chart()`使用了Altair，所以为了完整性，我们将简要覆盖这个部分。
- en: Because we’ve made quite a few graphs with this dataset already, why don’t we
    explore a new column, the `caretaker` column? This bit of data defines who is
    in charge of the tree (public or private) and, if public, what government organization
    is responsible for upkeep. Thrilling!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经使用这个数据集做了不少图表，为什么不探索一个新列——`caretaker`列呢？这一列数据定义了谁负责这棵树（公共或私人），如果是公共的，负责养护的政府机构是哪个。真是令人兴奋！
- en: 'The following code groups our DataFrame by caretaker, and then uses that grouped
    DataFrame from within Altair:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将我们的DataFrame按caretaker分组，然后在Altair中使用该分组的DataFrame：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Altair also allows us to summarize our data directly within the **y** value
    of `mark_bar()`, so we can simplify this by instead using the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Altair也允许我们直接在`mark_bar()`的**y**值中总结数据，因此我们可以通过使用以下代码简化此过程：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code will create a Streamlit app showing the count of trees by
    caretaker in SF, which is shown in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建一个Streamlit应用，显示SF地区按照caretaker分类的树木数量，如下图所示：
- en: '![](img/B18444_03_08.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_03_08.png)'
- en: 'Figure 3.8: Altair bar chart'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8：Altair条形图
- en: This should be it for traditional visualization libraries, but Streamlit also
    allows us to use more complex visualization libraries such as PyDeck for geographical
    mapping. In fact, we have already used PyDeck through the native `st.map()` function
    and will explore this in more depth in the following section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该就是传统的可视化库，但Streamlit还允许我们使用更复杂的可视化库，比如PyDeck进行地理映射。事实上，我们已经通过原生的`st.map()`函数使用了PyDeck，并将在接下来的章节中更深入地探讨它。
- en: PyDeck
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyDeck
- en: PyDeck is a visualization library that plots visualizations as layers on top
    of **Mapbox** (a mapping company with a truly exceptional free tier) maps. Both
    Streamlit and PyDeck have a base set of limited features available without signing
    up for a Mapbox account, but they greatly expand their free features when we get
    a **Mapbox** token, which we will do in the next section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: PyDeck是一个可视化库，它将可视化作为图层绘制在**Mapbox**（一家提供卓越免费服务的地图公司）地图上。Streamlit和PyDeck都有一套基本的功能，可以在没有注册Mapbox账户的情况下使用，但如果我们获得了**Mapbox**令牌，它们的免费功能将大大扩展，我们将在下一节中获取该令牌。
- en: Configuration options
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置选项
- en: 'In order to set up your own **Mapbox** token, which is optional, first go to
    [www.Mapbox.com](http://www.Mapbox.com) and sign up for an account. Once you have
    verified your account, you can find your token at [https://www.Mapbox.com/install/](https://www.Mapbox.com/install/).
    We will not pass our token directly to Streamlit because, otherwise, we might
    accidentally push it to a public GitHub repository. Instead, Streamlit has a global
    configuration file called `config.toml`. To view our current settings, we can
    run the following command anywhere in the terminal:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置你自己的 **Mapbox** 令牌（这是可选的），首先前往 [www.Mapbox.com](http://www.Mapbox.com) 并注册一个账户。一旦验证了账户，你可以在
    [https://www.Mapbox.com/install/](https://www.Mapbox.com/install/) 找到你的令牌。我们不会将令牌直接传递给
    Streamlit，因为否则我们可能会不小心将其推送到公共的 GitHub 仓库中。相反，Streamlit 有一个全局配置文件，名为 `config.toml`。要查看我们当前的设置，我们可以在终端中运行以下命令：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are four methods that Streamlit offers to change our default configuration
    settings; I’ll show you my recommended option and one of the other options, which
    should provide you with the majority of the use cases. If you find these options
    insufficient, the Streamlit documentation ([https://docs.streamlit.io/library/advanced-features/configuration](https://docs.streamlit.io/library/advanced-features/configuration))
    goes over all four options in great detail.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 提供了四种方法来更改我们的默认配置设置；我将展示我推荐的选项和另外一个选项，它们应该能够满足大部分使用场景。如果你觉得这些选项不够，Streamlit
    文档（[https://docs.streamlit.io/library/advanced-features/configuration](https://docs.streamlit.io/library/advanced-features/configuration)）会详细讲解所有四种选项。
- en: 'The first option is to set global configuration options by directly editing
    the `config.toml` file. We can edit the file directly by opening it in our text
    editor. The following command will open the file in VSCode. For other text editors
    (such as Vim and Atom), replace `code` with the appropriate command or open the
    file directly from the text editor:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择是通过直接编辑 `config.toml` 文件来设置全局配置选项。我们可以通过在文本编辑器中打开该文件直接进行编辑。以下命令将在 VSCode
    中打开该文件。对于其他文本编辑器（如 Vim 和 Atom），将 `code` 替换为相应的命令，或者直接从文本编辑器中打开文件：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If this fails, it likely means that we do not have the file generated already.
    To create our own file, we can run the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果失败了，可能意味着我们还没有生成该文件。为了创建自己的文件，我们可以运行以下命令：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside this file, you can either copy and paste the contents of `''streamlit
    config show''`, or choose to start from scratch. Either one should be fine! Now,
    open the file in VS Code so that we can view and edit any of the config options
    directly. Make sure that there is a section in your config file that has your
    Mapbox token, which looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，你可以选择复制并粘贴 `'streamlit config show'` 的内容，或者从头开始。两种方法都可以！现在，在 VSCode 中打开文件，以便我们可以直接查看和编辑任何配置选项。确保在你的配置文件中有一部分包含你的
    Mapbox 令牌，格式如下：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, your token will look different than the one I clearly made up! This
    option is great for a config option such as a Mapbox token, as I will never have
    multiple Mapbox accounts with multiple tokens.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你的令牌会与我明显编造的那个不同！这个选项对于像 Mapbox 令牌这样的配置选项非常好，因为我不可能有多个 Mapbox 账户和多个令牌。
- en: However, some Streamlit apps may want to use, for example, different ports than
    the default **8501 serverPort**. It would not make sense to change a global option
    for a project-specific change, which leads us to the second option for configuration
    changes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些 Streamlit 应用可能想要使用与默认的 **8501 serverPort** 不同的端口。例如，改变一个项目特定的设置就不适合修改全局选项，这也是我们需要第二种配置更改选项的原因。
- en: The second option is to create and edit a project-specific `config.toml` file.
    Our previous config sets our default config options, while this option is specific
    to each Streamlit app. Here is where our individual project folders within the
    `streamlit_apps` folder come in handy!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是创建并编辑一个项目特定的 `config.toml` 文件。我们之前的配置设置了默认的配置选项，而这个选项是针对每个 Streamlit 应用的。这里就是我们在
    `streamlit_apps` 文件夹中的各个项目文件夹派上用场的时候！
- en: 'Broadly speaking, we will do the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从大致的角度来看，我们将进行以下操作：
- en: Check our current working directory.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查当前工作目录。
- en: Make a config file for our project.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的项目创建一个配置文件。
- en: Use the config file within PyDeck.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyDeck 中使用配置文件。
- en: Our first step is to make sure our current working directory is the `trees_app`
    folder by running the `pwd` command in our terminal, which will show our current
    working directory and should end with `trees_app` (for example, mine looks like
    `Users/tyler/Documents/streamlit_apps/trees_app`).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是确保当前工作目录是`trees_app`文件夹，可以在终端中运行`pwd`命令，它将显示当前工作目录，并且应该以`trees_app`结尾（例如，我的目录是`Users/tyler/Documents/streamlit_apps/trees_app`）。
- en: 'Now, we need to make a config file just for our project. First, we will make
    a folder called `.streamlit`, and then we will repeat the Mac/Linux shortcut we
    used above:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为我们的项目创建一个配置文件。首先，我们将创建一个名为`.streamlit`的文件夹，然后重复我们之前在Mac/Linux上使用的快捷操作：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can then edit our config options just as we did before, but this will only
    be applicable to our Streamlit apps when we run Streamlit from our directory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像之前一样编辑我们的配置选项，但这仅适用于当我们从目录运行Streamlit时的Streamlit应用程序。
- en: 'Now, finally, we can go back to PyDeck graphing. Our first effort is going
    to be getting a base map of SF, which has a city center of `37.77, -122.4`. We
    can do this using the following code, which first defines the initial state (where
    we want to start viewing the map), and then calls `st.pydeck_chart()` using that
    initial state:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后我们可以回到PyDeck图表绘制。我们的第一个任务是获取SF的基础地图，城市中心坐标为`37.77, -122.4`。我们可以使用如下代码来完成，首先定义初始状态（我们希望开始查看地图的位置），然后使用该初始状态调用`st.pydeck_chart()`：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code will produce a map of SF, which we can use to layer on data points.
    Notice a couple of things here. First, the black default map may be difficult
    to see, and second, we need to spend time zooming into SF to get the view that
    we need. We can fix both these items by using the defaults suggested in the Streamlit
    documentation ([https://docs.streamlit.io/](https://docs.streamlit.io/)), as seen
    in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将生成一个SF的地图，我们可以用它来叠加数据点。这里有几点需要注意。首先，黑色的默认地图可能不容易看清，其次，我们需要花时间缩放到SF的区域，以便获得我们需要的视图。我们可以通过使用Streamlit文档中建议的默认值来解决这两个问题（[https://docs.streamlit.io/](https://docs.streamlit.io/)），如下代码所示：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code should create a map that looks like the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码应该生成一张如下截图所示的地图：
- en: '![Figure 3.9 – PyDeck mapping: SF base map ](img/B18444_03_09.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – PyDeck映射：SF基础地图](img/B18444_03_09.png)'
- en: 'Figure 3.9: PyDeck mapping: SF base map'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：PyDeck映射：SF基础地图
- en: 'This is exactly what we want! We can see the entire **SF Bay Area**, and now
    we need to add our layer of trees. The PyDeck library has tooltips for interactivity,
    which do not deal well with `null` values in our dataset, so we will remove `null`
    values before we map these points in the following code. We’ll also increase the
    `zoom` value to `11` so that we can see each point better:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的！我们可以看到整个**SF湾区**，接下来我们需要添加树木的层。PyDeck库有交互功能的工具提示，但这些工具对于数据集中的`null`值处理不太好，因此我们将在接下来的代码中，在映射这些点之前移除`null`值。我们还会将`zoom`值增加到`11`，这样可以更清楚地看到每个点：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The best values for both the `zoom` and `radius` parameters are dependent on
    your visualization preferences. Try a few options out to see what looks the best.
    The preceding code will make the following map:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`zoom`和`radius`参数的最佳值取决于你的可视化偏好。尝试几种选项，看看哪个效果最好。前面的代码将生成以下地图：'
- en: '![Figure 3.10 – Mapping SF trees  ](img/B18444_03_10.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 映射SF树木](img/B18444_03_10.png)'
- en: 'Figure 3.10: Mapping SF trees'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：SF树木映射
- en: As with previous maps, this is interactive by default, so we can zoom into different
    parts of SF to see where the places with the highest tree density are. For our
    next change to this map, we are going to add another layer, this time hexagons,
    which will be colored based on the density of the trees in SF. We can use the
    same code as above but change the scatterplot layer to a hexagon layer. We also
    will include the option to have the hexagon extrude vertically, making this graph
    more three-dimensional, which isn’t necessary but is certainly a fun visualization
    style.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的地图一样，默认情况下这是交互式的，因此我们可以缩放到SF的不同区域，查看树木密度最高的地方。接下来，我们将对这张地图进行修改，添加另一个层，这次是六边形层，根据SF中树木的密度进行着色。我们可以使用上面的相同代码，但将散点图层改为六边形层。我们还将包含将六边形沿垂直方向挤压的选项，使图表更具三维效果，虽然这不是必须的，但绝对是一个有趣的可视化风格。
- en: 'Our last change is to change the pitch or the angle at which we are viewing
    the map. The default pitch, as we can see, is nearly directly down on the city,
    which will not work if we try to view vertical hexagons on our map. The following
    code implements each one of these changes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的修改是改变我们查看地图的视角或角度。正如我们所看到的，默认的视角几乎是直接俯视城市，如果我们尝试在地图上查看垂直的六边形，这样的视角就无法使用。以下代码实现了这些更改：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As with the previous map, the optimal radius and pitch parameters will change
    based on your visualizations. Try changing each one of these around a few times
    to see whether you can get the hang of it! The preceding code will produce the
    following app:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一张地图一样，最佳的半径和视角参数将根据你的可视化效果有所不同。尝试改变这些参数几次，看看你是否能掌握它！前面的代码将生成以下应用：
- en: '![Figure 3.11 – Final San Francisco Trees map ](img/B18444_03_11.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 最终的旧金山树木地图](img/B18444_03_11.png)'
- en: 'Figure 3.11: Final SF Trees map'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11：最终的 SF 树木地图
- en: From this screenshot, we can see that PyDeck creates darker circles where there
    exists a higher density of trees in SF. We can observe from this many interesting
    details, such as the fact that the dataset seems to be missing trees from the
    famous Golden Gate Park on the west side of the city, and that the area around
    the Golden Gate Bridge also seems to have very few trees in the dataset.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张截图中，我们可以看到 PyDeck 在树木密度较高的地方创建了较深的圆圈。从中我们可以观察到很多有趣的细节，比如数据集中似乎缺少了位于城市西侧的著名金门公园的树木，而且金门大桥周围的区域似乎在数据集中也缺少树木。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After this chapter, you hopefully have a solid understanding of how to leverage
    several incredible open-source Python visualization libraries from within Streamlit.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章之后，希望你能对如何在 Streamlit 中利用几个令人惊叹的开源 Python 可视化库有一个扎实的理解。
- en: Let’s recap. First, we learned how to use the default visualization options,
    such as `st.line_chart()` and `st.map()`, and then we dove into interactive libraries
    such as Plotly, mapping libraries such as PyDeck, and everything in between.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下。首先，我们学习了如何使用默认的可视化选项，例如 `st.line_chart()` 和 `st.map()`，然后我们深入了解了交互式库，如
    Plotly，地图库，如 PyDeck，以及其中的一切。
- en: In our next chapter, we will move on to cover how to use machine learning and
    AI with Streamlit.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续介绍如何使用机器学习和 AI 与 Streamlit 配合使用。
- en: Learn more on Discord
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——你可以在这里分享反馈、向作者提问并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/sl](https://packt.link/sl)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/sl](https://packt.link/sl)'
- en: '![](img/QR_Code13440134443835796.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code13440134443835796.png)'
