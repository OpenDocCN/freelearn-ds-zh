- en: Working with Databases and Remote Data Sources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据库和远程数据源的工作
- en: Large-scale model organism sequencing projects, such as the **Human Genome Project**
    (**HGP**), or the 1,001 plant genomes sequencing projects have made a huge amount
    of genomics data publicly available. Likewise, open access data sharing by individual
    laboratories has made the raw sequencing data of genomes and transcriptomes widely
    available, too. Working with this data programmatically can mean having to parse
    or bring locally some seriously large or complicated files. As such, much effort
    has gone into making these resources as accessible as possible through APIs and
    other queryable interfaces, such as BioMart. In this chapter, we'll look at some
    recipes that will allow us to search for annotations without having to download
    whole genome files and find relevant information across databases. We'll look
    at how to pull raw reads from experiments from within your code and take the opportunity
    to look at how to apply quality control to this downloaded data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大规模模式生物有机体测序项目，如**人类基因组计划**（**HGP**）或1001植物基因组测序项目，已经使大量基因组数据公开可用。同样，个别实验室的开放数据共享也使基因组和转录组的原始测序数据得到了广泛的共享。通过编程处理这些数据意味着可能需要解析或本地存储一些非常庞大或复杂的文件。因此，许多努力已投入使这些资源通过
    API 和其他可查询接口（如 BioMart）尽可能易于访问。在本章中，我们将介绍一些食谱，帮助我们在不下载整个基因组文件的情况下搜索注释，并能够在数据库中找到相关信息。我们还将了解如何在代码中提取实验的原始读取数据，并借此机会研究如何对下载的数据进行质量控制。
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将覆盖以下食谱：
- en: Retrieving gene and genome annotations from BioMart
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 BioMart 检索基因和基因组注释
- en: Retrieving and working with SNPs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索和处理SNP
- en: Getting gene ontology information
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取基因本体信息
- en: Finding experiments and reads from SRA/ENA
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 SRA/ENA 查找实验和读取数据
- en: Performing quality control and filtering on high-throughput sequence reads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对高通量测序读取进行质量控制和过滤
- en: Completing read-to-reference alignment with external programs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成使用外部程序的读到参考比对
- en: Visualizing quality control plots of read-to-reference alignments
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化读到参考比对的质量控制图
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample data you'll need is available from this book's GitHub repository
    at [https://github.com/PacktPublishing/R-Bioinformatics-Cookbook](https://github.com/PacktPublishing/R-Bioinformatics-Cookbook)[.](https://github.com/danmaclean/R_Bioinformatics_Cookbook) If
    you want to use the code examples as they are written, then you will need to make
    sure that this data is in a sub-directory of whatever your working directory is.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你所需的示例数据可以在本书的 GitHub 仓库中找到，地址为 [https://github.com/PacktPublishing/R-Bioinformatics-Cookbook](https://github.com/PacktPublishing/R-Bioinformatics-Cookbook)[.](https://github.com/danmaclean/R_Bioinformatics_Cookbook)
    如果你想按原样使用代码示例，你需要确保这些数据位于你的工作目录的子目录中。
- en: 'Here are the R packages that you''ll need. In general, you can install these
    with `install.packages("package_name")`. The packages listed under `Bioconductor`
    need to be installed with the dedicated installer. That''s described as follows
    in this section. If you need to do anything further, installation will be described
    in the recipes in which the packages are used:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你需要的 R 包。一般来说，你可以使用`install.packages("package_name")`来安装这些包。在`Bioconductor`下列出的包需要使用专用的安装器进行安装。具体安装方法将在本节中描述。如果需要进一步操作，安装过程将在包使用的食谱中进行描述：
- en: '`Bioconductor`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bioconductor`'
- en: '`biomaRt`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`biomaRt`'
- en: '`ramwas`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ramwas`'
- en: '`ShortRead`'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShortRead`'
- en: '`SRAdb`'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRAdb`'
- en: 'Bioconductor is huge and has its own installation manager. You can install
    the manager with the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Bioconductor 非常庞大，并且拥有自己的安装管理器。你可以使用以下代码来安装管理器：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, you can install the packages with this code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下代码安装这些包：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Further information is available at [https://www.bioconductor.org/install/](https://www.bioconductor.org/install/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参见 [https://www.bioconductor.org/install/](https://www.bioconductor.org/install/)。
- en: Normally, in R, a user will load a library and use the functions directly by
    name. This is great in interactive sessions but it can cause confusion when many
    packages are loaded. To clarify which package and function I'm using at a given
    moment, I will occasionally use the `packageName::functionName()` convention.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在 R 中，用户会加载一个库并直接通过名称使用其中的函数。这在交互式会话中非常方便，但在加载多个包时可能会导致混淆。为了明确我在某一时刻使用的是哪个包和函数，我会偶尔使用`packageName::functionName()`的惯例。
- en: 'Sometimes, in the middle of a recipe, I''ll interrupt the code so you can see
    some intermediate output or the structure of an object that''s important to understand.
    Whenever that happens, you''ll see a code block where each line begins with `##` (double
    hash) symbols. Consider the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在配方中间，我会中断代码，这样您就可以看到一些中间输出或者重要对象的结构。每当这种情况发生时，您将看到每行以`##`（双重井号）符号开头的代码块。考虑以下命令：
- en: '`letters[1:5]`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`letters[1:5]`'
- en: 'This will give us the following output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下输出：
- en: '`## a b c d e`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`## a b c d e`'
- en: Note that the output lines are prefixed with `##`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出行前缀为`##`。
- en: Retrieving gene and genome annotation from BioMart
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从`BioMart`检索基因和基因组注释
- en: Once a draft of a genome sequence is prepared, a lot of bioinformatics work
    goes into finding the genes and other functional features or important loci that
    are in a genome. These annotations are numerous, difficult to perform and verify,
    typically take lots of expertise and time, and are not something we would want
    to repeat. So, genome project consortia will typically share their annotations
    in some way, often through public databases of some sort. BioMart is a common
    data structure and API through which annotation data is made available. In this
    recipe, we'll look at how to programmatically access such databases so we can
    get annotations for genes that we are interested in.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备好了某个基因组序列的草稿，就会进行大量的生物信息学工作，以找到基因和其他功能特征或重要的基因座。这些注释很多，执行和验证都很困难，通常需要大量的专业知识和时间，并且不希望重复。因此，基因组项目联合体通常会通过某种方式共享他们的注释，通常是通过一些公共数据库。`BioMart`是一种常见的数据结构和API，通过它可以获取注释数据。在这个配方中，我们将看看如何以编程方式访问这些数据库，以获取我们感兴趣的基因的注释信息。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need the `Bioconductor` package called `biomaRt` and a working
    internet connection. We'll also need to know the BioMart server to connect to—there
    are about 40 worldwide, providing information about all sorts of things. The most
    widely accessed are the Ensembl databases and these are the default in these packages.
    You can see a list of all of the BioMarts here: [http://www.biomart.org/notice.html](http://www.biomart.org/notice.html).
    The code we'll develop will apply to any of these BioMarts with a little modification
    of table names and URLs, as appropriate.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要名为`biomaRt`的`Bioconductor`包以及一个可用的互联网连接。我们还需要知道要连接的`BioMart`服务器 ——
    全球约有40个这样的服务器，提供各种信息。最常访问的是`Ensembl`数据库，这些是这些包的默认设置。您可以在这里查看所有`BioMart`的列表：[http://www.biomart.org/notice.html](http://www.biomart.org/notice.html)。我们将开发的代码将适用于这些`BioMart`中的任何一个，只需稍微修改表名和URL。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Retrieving gene and genome annotation from BioMart can be done using the following
    steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下步骤从`BioMart`检索基因和基因组注释：
- en: 'List marts in the selected example database—`gramene`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所选示例数据库`gramene`中的`mart`列表：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a connection to the selected mart:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建到所选`mart`的连接：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'List datasets in that mart:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出该`mart`中的数据集：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'List the datatypes we can actually retrieve:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出我们实际可以检索的数据类型：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Get a vector of all chromosome names:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有染色体名称的向量：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create some filters to query data:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些用于查询数据的过滤器：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Get gene IDs on the first chromosome:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取第一个染色体上的基因ID：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The recipe revolves around doing a series of different lookups on the database,
    each time receiving a little more information to work with.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方围绕对数据库进行一系列不同的查找操作，每次获取一些更多信息来处理。
- en: In *Step 1*, we use the `listMarts()` function to get a list of all of the BioMarts
    available at the specified host URL. Change the URL as appropriate when you want
    to connect to a different server. We get a dataframe of the available marts and
    use that information.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第一步*中，我们使用`listMarts()`函数获取指定主机URL上所有可用的`BioMart`列表。在需要连接到不同服务器时，请根据需要更改URL。我们得到一个可用`mart`的数据框，并使用该信息。
- en: In *Step 2*, we create a connection object called `gramene_connection` with
    the `useMart()` function, passing in the server URL and the specific BioMart from
    *Step 1*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第二步*中，我们使用`useMart()`函数创建一个名为`gramene_connection`的连接对象，传入服务器URL和*第一步*中的具体`BioMart`。
- en: In *Step* *3*, we pass `gramene_connection` to the `listDatasets()` function
    to retrieve the datasets in this `biomart`. Having selected one of the datasets
    (`atrichopda_eg_gene`), we can run the `useMart()` function to create a connection
    to the datasets in that `biomart`, naming the object `data_set_connection`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤* *3*中，我们将`gramene_connection`传递给`listDatasets()`函数，以检索该`biomart`中的数据集。选择其中一个数据集（`atrichopda_eg_gene`）后，我们可以运行`useMart()`函数来创建一个到该`biomart`中数据集的连接，并将对象命名为`data_set_connection`。
- en: In *Step 4*, we're nearly done working out which datasets we can use. Here,
    we use `data_set_connection`, which we created in the `listAttributes()` function,
    to get a list of the types of information we can retrieve from this dataset.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 4*中，我们几乎完成了确定可以使用哪些数据集的工作。在这里，我们使用在`listAttributes()`函数中创建的`data_set_connection`，获取我们可以从该数据集中检索的各种信息类型的列表。
- en: At *Step 5*, we finally get some actual information with the main function, `getBM()`.
    We set the `attributes` argument to the names of the data we want to get back;
    here, we get all values for `chromosome_name` and save them in a vector, `chrom_names`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 5*中，我们最终通过主要函数`getBM()`获取一些实际信息。我们将`attributes`参数设置为我们希望返回的数据的名称；在这里，我们获取`chromosome_name`的所有值，并将它们保存到一个向量`chrom_names`中。
- en: In *Step 6*, we set up filters—the restrictions on which values to receive.
    We first ask the `data_set_connection` object which filters we can use with the
    `listFilters()` function. Notice from the returned `filters` object that we can
    filter on `chromosome_name`, so we'll use that.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 6*中，我们设置过滤器——即接收哪些值的限制。我们首先询问`data_set_connection`对象，使用`listFilters()`函数查看我们可以使用哪些过滤器。从返回的`filters`对象中可以看到，我们可以在`chromosome_name`上进行过滤，所以我们将使用这个。
- en: 'In *Step 7*, we set up a full query. Here, we intend to get all genes on the
    first chromosome. Note that we already have a list of chromosomes from *Step 5*,
    so we take the first element of the `chrom_names` object to use in the filter,
    saving it in `first_chr`. To perform the query, we use the `getBM()` function,
    with the `ensembl_gene_id` and `description` attributes. We set the `filter` argument
    to the data type we wish to filter on and set the `values` argument to the value
    of the filter we wish to keep. We also pass the `data_set_connection` object as
    the BioMart to use. The resulting `genes` object contains `ensembl_gene_id` and
    descriptions on the first chromosome, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 7*中，我们设置一个完整的查询。在这里，我们打算获取第一个染色体上的所有基因。请注意，我们已经在*步骤 5*中获得了一个染色体列表，因此我们将使用`chrom_names`对象中的第一个元素作为过滤器，并将其保存在`first_chr`中。为了执行查询，我们使用`getBM()`函数，并指定`ensembl_gene_id`和`description`属性。我们将`filter`参数设置为我们希望过滤的数据类型，并将`values`参数设置为我们希望保留的过滤器值。我们还将`data_set_connection`对象作为要使用的BioMart传递。最终生成的`genes`对象包含了第一个染色体上的`ensembl_gene_id`和描述信息，如下所示：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Retrieving and working with SNPs
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和处理SNP
- en: SNPs and other polymorphisms are important genomic features and we often want
    to retrieve known SNPs in particular genomic regions. Here, we'll look at doing
    that in two different BioMarts that hold different types of data for their SNPs.
    In the first part, we'll use Gramene again to look at retrieving plant SNPs. In
    the second part, we'll look at how to find information on human SNPs in the main
    Ensembl database.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: SNP和其他多态性是重要的基因组特征，我们通常希望在特定基因组区域内检索已知的SNP。在这里，我们将介绍如何在两个不同的BioMart中执行此操作，这些BioMart存储了不同类型的SNP数据。在第一部分中，我们将再次使用Gramene来查看如何获取植物SNP。在第二部分中，我们将了解如何在主要的Ensembl数据库中查找人类SNP的信息。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As before, we'll need only the `biomaRt` package from `Bioconductor` and a working
    internet connection.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们只需要`biomaRt`包，它来自`Bioconductor`，并且需要一个正常工作的互联网连接。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Retrieving and working with SNPs can be done using the following steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 获取和处理SNP可以通过以下步骤完成：
- en: 'Get the list of datasets, attributes, and filters from Gramene:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Gramene获取数据集、属性和过滤器列表：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Query for the actual SNP information:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询实际的SNP信息：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: '*Step 1* will be familiar from the previous recipe''s *steps 1* to *6*, in
    which we make the initial connections and get them to list the datasets, attributes,
    and filters we can use in this BioMart; it''s the same pattern and is repeated
    every time we use the BioMart (until we get to know it by heart).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 1*将与之前的食谱中的*步骤 1*到*6*类似，我们将建立初始连接并让它列出我们可以在此BioMart中使用的数据集、属性和过滤器；这是相同的模式，每次使用BioMart时都会重复（直到我们能熟记它）。'
- en: In *Step 2*, we use the information gathered to pull the SNPs in the region
    of interest. Again, we use the `getBM()` function and use a `chromosomal_region` filter. This
    allows us to specify a value describing a particular locus on the genome. The
    `value` argument gets a `Chromosome:Start:Stop:Strand` formatted string; specifically, `1:200:20000:1`,
    which will return all SNPs on chromosome 1, between nucleotide 200 and 20,000
    on the positive strand (note that the positive DNA strand identifier is `1`, and
    the negative DNA strand identifier is `-1`).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，我们利用收集到的信息提取目标区域的SNP。同样，我们使用`getBM()`函数并设置`chromosomal_region`过滤器。这允许我们指定一个描述基因组中特定位点的值。`value`参数采用`Chromosome:Start:Stop:Strand`格式的字符串；具体而言，`1:200:20000:1`，这将返回染色体1上从第200到20000个碱基的所有SNP，且位于正链上（注意，正链DNA的标识符为`1`，负链DNA的标识符为`-1`）。
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Finding human SNPs from Ensembl follows pretty much the same pattern. The only
    difference is that, because Ensembl is the default server, we can omit the server
    information from the `useMart()` functions. A similar query for humans would look
    like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从Ensembl中查找人类SNP的步骤基本相同。唯一的区别是，由于Ensembl是默认服务器，我们可以在`useMart()`函数中省略服务器信息。对于人类的类似查询会像这样：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See also
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: If you have the `dbSNP refsnp ID` numbers, it is possible to query these directly
    using the `rnsps` package and the `ncbi_snp_query()` function. Simply pass this
    function a vector of valid `refsnp` IDs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有`dbSNP refsnp ID`编号，可以通过`rnsps`包和`ncbi_snp_query()`函数直接查询这些ID。只需将有效的`refsnp`
    ID向量传递给该函数。
- en: Getting gene ontology information
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取基因本体论信息
- en: The **Gene Ontology** (**GO**) is a very useful restricted vocabulary of annotation
    terms for genes and gene products that describe the biological process, molecular
    function, or cellular component of an annotated entity. As such, the terms are
    extremely useful as data in such things as gene-set enrichment analysis and other
    functional -omics approaches. In this recipe, we'll look at how we can prepare
    a list of gene IDs in a genomic region and get the GO IDs and descriptions for
    them all.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**基因本体论**（**GO**）是一个非常有用的受限词汇，包含用于基因和基因产物的注释术语，描述了注释实体的生物过程、分子功能或细胞成分。因此，这些术语在基因集富集分析和其他功能-组学方法中非常有用。在本节中，我们将看看如何准备一个基因ID列表，并为它们获取GO
    ID和描述信息。'
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we're still using the `biomaRt` package, we'll just need that and a working
    internet connection.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们仍在使用`biomaRt`包，所以只需要该包以及一个有效的互联网连接。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Getting gene ontology information can be done using the following steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 获取基因本体论信息的步骤如下：
- en: 'Make connections to the Ensembl BioMart and find the appropriate attributes
    and filters:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到Ensembl BioMart并找到适当的属性和过滤器：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Get a list of genes and, using their IDs, get their GO annotations:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取基因列表，并使用它们的ID获取GO注释：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As in the previous two recipes, *Step 1* involves finding the right values for
    the biomart, datasets, attributes, and filters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如同前两个步骤，*步骤 1* 包括找到适合的biomart、数据集、属性和过滤器的值。
- en: In *Step 2*, we use the `getBM()` function to get `ensembl_gene_id` attributes
    in a particular chromosome region, saving the result in the `genes` object. We
    then use that function again using `ensembl_gene_id` as a filter and `go_id` and
    `goslim_goa_description` to get the actual GO annotation for just the selected
    genes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，我们使用`getBM()`函数获取特定染色体区域中的`ensembl_gene_id`属性，将结果保存在`genes`对象中。然后我们再次使用该函数，使用`ensembl_gene_id`作为过滤器，`go_id`和`goslim_goa_description`来获取仅选定基因的GO注释。
- en: Finding experiments and reads from SRA/ENA
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找SRA/ENA中的实验和读取数据
- en: The **Short Read Archive** (**SRA**) and the **European Nucleotide Archive**
    (**ENA**) are databases of records of raw high-throughput-DNA sequence data. Each
    is a mirrored version of the same sets of high-throughput sequence data, submitted
    by scientists in all fields of biology from all over the world. The free availability
    of high-throughput sequence data through these databases means that we can conceive
    of and execute new analyses on existing datasets. By performing searches on the
    databases, we can identify sequence data that we may wish to work with. In this
    recipe, we'll look at using the `SRAdb` package to query the datasets on SRA/ENA
    and retrieve the data for selected sets programmatically.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**短序列数据归档**（**SRA**）和**欧洲核苷酸库**（**ENA**）是记录原始高通量 DNA 序列数据的数据库。每个数据库都是相同高通量序列数据集的镜像版本，这些数据集是来自世界各地各个生物学领域的科学家提交的。通过这些数据库免费获取高通量序列数据意味着我们可以设想并执行对现有数据集的新分析。通过对数据库进行搜索，我们可以识别出我们可能想要处理的序列数据。在本配方中，我们将研究如何使用`SRAdb`包查询
    SRA/ENA 上的数据集，并以编程方式检索选定数据集的数据。'
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The two essential items for this recipe are the `SRAdb` package from `Bioconductor`
    and a working internet connection.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的两个关键元素是来自`Bioconductor`的`SRAdb`包和一个有效的互联网连接。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Finding experiments and reads from SRA/ENA can be done using the following
    steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 查找来自 SRA/ENA 的实验和数据读取可以通过以下步骤完成：
- en: 'Download the SQL database and make the connection:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 SQL 数据库并建立连接：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Get the study information:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取研究信息：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Get information on what is contained in that study:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取关于该研究包含内容的信息：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Get a list of the files available:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取可用文件的列表：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Download the sequence files:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载序列文件：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After loading the library, the first step sets up a local SQL file, called `sqlfile`.
    The file contains all of the information about the studies on SRA. In our example,
    we are using a small version from within the package itself (hence, we're extracting
    it with the `system.file()` function); the real file is >50GB in size so we won't
    use it now but it can be retrieved using this replacement code: `sqlfile <- getSRAdbfile()`.
    Once we have a `sqlfile` object, we can create a connection to the database with
    the `dbConnect()` function. We save the connection in the object named `sra_con`
    for reuse.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 加载库后，第一步是设置一个本地的 SQL 文件，名为`sqlfile`。该文件包含了关于 SRA 上研究的所有信息。在我们的示例中，我们使用的是包内的一个小版本（因此，我们通过`system.file()`函数提取它）；真实的文件大小超过
    50GB，因此我们暂时不会使用它，但可以通过以下替换代码获取：`sqlfile <- getSRAdbfile()`。一旦我们拥有一个`sqlfile`对象，就可以使用`dbConnect()`函数创建与数据库的连接。我们将连接保存在名为`sra_con`的对象中，以便重用。
- en: 'We then perform a query on the `sqlfile` database using the `dbGetQuery()` function.
    The first argument to this is the database file, and the second is a full query
    in SQL format. The query written is pretty self-explanatory; we''re looking to
    return `study_accession` and `study_description` when the description contains
    the term `coli`. Much more complicated queries are possible—if you''re prepared
    to write them in SQL. A tutorial on that is far beyond the scope of this recipe
    but there are numerous books dedicated to the subject; you should try *SQL for
    Data Analytics* by Upom Malik, Matt Goldwasser, and Benjamin Johnston, Packt Publishing: [https://www.packtpub.com/big-data-and-business-intelligence/sql-data-analysis](https://www.packtpub.com/big-data-and-business-intelligence/sql-data-analysis).
    The query returns a dataframe object that looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`dbGetQuery()`函数对`sqlfile`数据库执行查询。该函数的第一个参数是数据库文件，第二个参数是一个完整的 SQL 格式的查询。写出的查询非常直观；我们希望返回包含`coli`一词的描述时的`study_accession`和`study_description`。更复杂的查询是可能的——如果你准备好用
    SQL 编写它们。关于这方面的教程超出了本配方的范围，但有许多书籍专门介绍这个主题；你可以尝试阅读 Upom Malik、Matt Goldwasser 和
    Benjamin Johnston 合著的《SQL for Data Analytics》，由 Packt Publishing 出版：[https://www.packtpub.com/big-data-and-business-intelligence/sql-data-analysis](https://www.packtpub.com/big-data-and-business-intelligence/sql-data-analysis)。该查询返回一个类似于以下内容的
    dataframe 对象：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Step 3* uses the accession number we extracted to get all of the related submission,
    sample, and experiment and run information related to the study with the `sraConvert()` function.
    This returns something like the following table—we can see the run IDs for this
    study, showing the actual files containing the sequence:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 3* 使用我们提取的访问号，利用`sraConvert()`函数获取与该研究相关的所有提交、样本、实验和运行信息。这将返回如下表格，我们可以看到该研究的运行
    ID，展示了包含序列的实际文件：'
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In *Step 4*, we use the `listSRAfile()` function to get the actual FTP address
    on the server for the specific sequences in a run. This provides the address of
    the SRA format file, a compressed and convenient format should you wish to know
    that:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 4*中，我们使用 `listSRAfile()` 函数获取运行中特定序列的实际 FTP 地址。这将提供 SRA 格式文件的地址，这是一个压缩且方便的格式，如果你希望了解的话：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: But in *Step 5*, we use the `getSRAfile()` function, setting the `fileType`
    argument to `fastq` to get the data in the standard `fastq` format. The files
    are downloaded into the folder specified in the `destDir` argument.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在*步骤 5*中，我们使用 `getSRAfile()` 函数，并将 `fileType` 参数设置为 `fastq`，以便以标准的 `fastq`
    格式获取数据。文件将下载到 `destDir` 参数指定的文件夹中。
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Don't forget to refresh the local SQL database regularly and to use the full
    version with this code: `sqlfile <- getSRAdbfile()`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记定期刷新本地的 SQL 数据库，并使用以下代码获取完整版本：`sqlfile <- getSRAdbfile()`。
- en: Performing quality control and filtering on high-throughput sequence reads
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对高通量序列读取进行质量控制和过滤
- en: When we have a new set of sequence reads to work with, whether that be from
    a new experiment or a database, we need to perform a quality control step that
    will remove any sequence adapters, remove reads with a poor sequence, or trim
    down a poor sequence, as appropriate. In this recipe, we'll look at doing that
    within R using the `Bioconductor ShortRead` package.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一组新的序列读取需要处理时，无论是来自新实验还是数据库，我们都需要执行质量控制步骤，去除任何序列接头、去除质量差的读取，或者根据需要修剪质量差的序列。在这个配方中，我们将介绍如何在
    R 中使用 `Bioconductor ShortRead` 包来实现这一点。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'll need the `ShortRead` package and you'll need to run the code for the
    *Finding experiments and reads from SRA/ENA* recipe in this chapter. Two files
    are created in the last step of that recipe and we'll use one of those. Once that
    code is run, the file should be in `datasets/ch8/ERRR019652.fastq.gz` of this
    book's repository.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装 `ShortRead` 包，并且需要运行本章中 *查找 SRA/ENA 中的实验和读取* 这一配方的代码。在该配方的最后一步，会创建两个文件，我们将使用其中一个。运行该代码后，文件应该位于本书的
    `datasets/ch8/ERRR019652.fastq.gz` 目录中。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'Performing quality control and filtering on high-throughput sequence reads
    can be done using the following steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对高通量序列读取进行质量控制和过滤可以通过以下步骤完成：
- en: 'Load the library and connect to a file:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载库并连接到文件：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Filter reads with any nucleotide with quality lower than 20:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤掉质量低于 20 的任何核苷酸的读取：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Trim the right-hand side of the read:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修剪读取的右侧：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Set up a custom filter to remove *N* and homomeric runs:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置自定义过滤器以移除 *N* 和同源重复序列：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Write out the retained reads:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出保留的读取：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first step loads in the reads to a `ShortReadQ` object that represents the
    DNA read and its associated quality scores; this special object allows us to work
    on the sequence and qualities in one go.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步将读取加载到 `ShortReadQ` 对象中，该对象表示 DNA 读取及其相关的质量评分；这个特殊的对象使我们能够在一次操作中处理序列和质量。
- en: The second step lets us find any reads where all quality scores are above 20\.
    The code here is a little idiomatic so take some time to unpack it. First, we
    use the `quality()` function on `fastq_file` to extract the qualities alone, then
    pass that to the `as()` function, asking for a matrix. On that resultant matrix,
    we calculate the sum of each row with `rowSums()` and finally get a logical vector,
    `qualities`, from a comparison to see which of the `rowSums()` values is less
    than 20\. In the next line, we use the `qualities` vector to subset `fastq_file`
    and remove the lower quality reads.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步让我们找到所有质量分数都高于 20 的读取。这里的代码有点特殊，所以请花时间理解它。首先，我们在 `fastq_file` 上使用 `quality()`
    函数提取质量值，然后将其传递给 `as()` 函数，要求返回一个矩阵。接着，我们对该矩阵使用 `rowSums()` 计算每行的总和，最终通过比较得到一个逻辑向量
    `qualities`，它指示哪些 `rowSums()` 的值小于 20。在下一行中，我们使用 `qualities` 向量来对 `fastq_file`
    进行子集筛选，去除低质量的读取。
- en: 'In *Step 3*, we trim the right-hand side of a read (to correct places where
    the read quality falls below a threshold). The main function here is `trimTails()`, which
    takes two arguments: `k`, the number of failing letters required to start trimming,
    and `a`, the letter to start trimming at. This, of course, means that the Phred
    numeric quality score we think of (such as in *Step 2*, where we just used 20)
    needs to be converted into its ASCII equivalent as per the text encoding of the
    quality score. That''s what happens in the first line; the number 40 is converted
    into raw bytes with `as.raw()` and then into a character in `rawToChar()`. The
    resulting text can be used by storing it in the `cut_off_txt` variable.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 3*中，我们修剪读取的右侧（以纠正读取质量低于阈值的地方）。这里的主要功能是`trimTails()`，它接受两个参数：`k`，开始修剪所需的失败字母数，以及`a`，开始修剪的字母。这当然意味着我们所认为的Phred数值质量分数（如*步骤
    2*中，我们仅使用了20）需要根据质量分数的文本编码转换为其ASCII等价物。这就是第一行发生的事情；数字40通过`as.raw()`转换为原始字节，然后通过`rawToChar()`转换为字符。生成的文本可以通过将其存储在`cut_off_txt`变量中来使用。
- en: '*Step 4* applies some custom filters. The first line, `custom_filter_1`, creates
    a filter for sequences containing bases called *N*, the threshold argument allowing
    sequences to contain zero *N*s. The second, `custom_filter_2`, creates a filter
    for homopolymeric reads of homopolymers of length equal or longer than the threshold.
    The `nuc` argument specifies which nucleotides are to be considered. Once the
    filters are specified, we must join them into a single filter using the `compose()` function,
    which returns a filter function we call `custom_filter()` and then call on the
    trimmed object. It returns an `SRFFilterResult` object that can be used to subset
    the reads.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 4*应用了一些自定义过滤器。第一行，`custom_filter_1`，为包含名为*N*的碱基的序列创建过滤器，阈值参数允许序列包含零个*N*。第二行，`custom_filter_2`，为长度等于或大于阈值的同质聚合物读取创建过滤器。`nuc`参数指定要考虑的核苷酸。一旦指定了过滤器，我们必须使用`compose()`函数将它们合并成一个单一的过滤器，该函数返回一个我们称之为`custom_filter()`的过滤器函数，然后对修剪后的对象进行调用。它返回一个`SRFFilterResult`对象，可以用来对读取进行子集化。'
- en: Finally, in *Step 5*, we use the `writeFastQ()` function to write the retained
    reads to a file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*步骤 5*中，我们使用`writeFastQ()`函数将保留的读取写入文件。
- en: Completing read-to-reference alignment with external programs
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部程序完成读取到参考的比对
- en: The alignment of high-throughput reads is an important prerequisite for a lot
    of the recipes in this book, including RNAseq and SNP/INDEL calling. We looked
    at them in depth in [Chapter 1](ff091bc9-a002-4a63-b0fe-c0b9f9baf7d1.xhtml), *Performing
    Quantitative RNAseq*, and [Chapter 2](951477d3-d812-45e7-a324-0ffb1dc3ebf4.xhtml),
    *Finding Genetic Variants with HTS Data*, but we didn't cover how to actually
    perform alignment. We wouldn't normally do this within R; the programs needed
    to make these alignments are powerful and run from the command line as independent
    processes. But R can control these external processes, so we'll look at how to
    run an external process so you can control them from within an R wrapper script,
    ultimately allowing you to develop end-to-end analysis pipelines.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 高通量读取的比对是本书中许多方法的一个重要前提，包括RNAseq和SNP/INDEL调用。在[第1章](ff091bc9-a002-4a63-b0fe-c0b9f9baf7d1.xhtml)，*执行定量RNAseq*，以及[第2章](951477d3-d812-45e7-a324-0ffb1dc3ebf4.xhtml)，*使用HTS数据查找遗传变异*中我们对其进行了深入讨论，但我们没有涉及如何实际执行比对。我们通常不会在R中执行此操作；进行这些比对所需的程序是强大的，并且作为独立进程从命令行运行。但R可以控制这些外部进程，因此我们将探讨如何运行外部进程，以便你可以从R包装脚本中控制它们，最终使你能够开发端到端的分析管道。
- en: Getting ready...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中...
- en: We'll use base R only in this recipe, so you don't need to install any packages.
    You will need the reference genome FASTA file in `datasets/ch8/ecoli_genome.fa`
    and the `datasets/ch8/ERR019653.fastq,gz` file that we created in the *Finding
    experiments and reads from SRA/ENA* recipe. This recipe also requires a working
    copy of BWA and `samtools` on your system. The web pages for these pieces of software
    are at [http://samtools.sourceforge.net/](http://samtools.sourceforge.net/) and [http://bio-bwa.sourceforge.net/](http://bio-bwa.sourceforge.net/).
    If you have `conda` installed, you can install it with `conda install -c bioconda
    bwa` and `conda install -c bioconda samtools`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程仅使用基础的R语言，因此你无需安装任何额外的包。你需要准备参考基因组FASTA文件`datasets/ch8/ecoli_genome.fa`，以及我们在*寻找SRA/ENA实验和读取数据*教程中创建的`datasets/ch8/ERR019653.fastq,gz`文件。本教程还需要系统中安装BWA和`samtools`的可执行文件。相关软件的网页可以在[http://samtools.sourceforge.net/](http://samtools.sourceforge.net/)和[http://bio-bwa.sourceforge.net/](http://bio-bwa.sourceforge.net/)找到。如果你已经安装了`conda`，可以通过`conda
    install -c bioconda bwa`和`conda install -c bioconda samtools`来安装它们。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Complete read-to-reference alignment with external programs using the following
    steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤完成读取到参考的比对，借助外部程序：
- en: 'Set up the files and executable paths:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置文件和可执行文件路径：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Prepare the `index` command and run:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备`index`命令并执行：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Prepare the `alignment` command and run:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备`alignment`命令并执行：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The first step is simple: we just create a few variables that hold directory
    paths to the programs and files we will use. `bwa` and `samtools` hold the path
    to those programs on the system. Note that the paths on your system are almost
    definitely different. On Linux and macOS systems, you can find the path using
    the `which` command in the Terminal, on Windows machines, you can try the `where`
    command or equivalent.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步非常简单：我们仅仅创建了几个变量来保存程序和文件所在目录的路径。`bwa`和`samtools`分别保存了这些程序在系统中的路径。请注意，你的系统上的路径可能与此不同。在Linux和macOS系统中，你可以通过`which`命令在终端中查找路径；在Windows机器上，你可以使用`where`命令或等效命令。
- en: In *Step 2*, we outline the basic pattern for running a system command. First,
    with the `paste()` function, we create the command as a string and save it in
    a variable called `command`. Here, we're preparing a command line that creates
    the index we need before performing read alignment with BWA. Then, we use the
    command as the first argument in the `system()` function, which actually executes
    the command. The command is started as a brand new process in the background and,
    by default, control is returned to the R script as soon as the process begins.
    If you intend to work immediately within R upon output from the background process,
    then you need to set the `system()` argument wait to `TRUE`, so that the R process
    only continues once the background process is complete.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们概述了运行系统命令的基本模式。首先，通过`paste()`函数，我们将命令作为字符串创建，并保存在一个名为`command`的变量中。在这里，我们正在准备一个命令行，在执行BWA进行读取比对之前创建所需的索引。然后，我们将该命令作为第一个参数传递给`system()`函数，后者会实际执行该命令。命令作为一个全新的进程在后台启动，默认情况下，一旦进程开始，控制权会立即返回给R脚本。如果你打算在后台进程输出后立即在R中继续工作，你需要将`system()`函数中的`wait`参数设置为`TRUE`，这样R进程将在后台进程完成后才继续。
- en: In *Step 3*, we extend the pattern, creating reads and output variables and
    putting together a much longer command line, showing that any valid command line
    can be composed. We then repeat the `system` command. This process results in
    a final BAM file in `datasets/ch8/aln.bam`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们扩展了模式，创建了读取和输出变量，并组合了一个更长的命令行，展示了如何构建一个有效的命令行。然后我们重复执行`system`命令。此过程将生成一个最终的BAM文件，位于`datasets/ch8/aln.bam`。
- en: Visualizing the quality control of read-to-reference alignments
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化读取到参考比对的质量控制
- en: Once the alignment of reads has been performed, it is usually wise to check
    the quality of the alignment and ensure that there is nothing unexpected about
    the pattern of reads and things such as expected insert distances. This can be
    especially useful in draft reference genomes where unusual alignments of high-throughput
    reads can reveal misassemblies of the reference or other structural rearrangements.
    In this recipe, we'll use a package called `ramwas`, which has some easily accessed
    plots we can create to assess alignment.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成读取的比对，通常建议检查比对的质量，确保读取的模式和期望的插入距离等没有异常。这在草拟参考基因组中尤其有用，因为高通量读取的异常比对可能会揭示参考基因组的拼接错误或其他结构重排。在本教程中，我们将使用一个名为`ramwas`的包，它有一些易于访问的图形，可以帮助我们评估比对的质量。
- en: Getting ready...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在准备中...
- en: For this recipe, we'll need the prepared `bam_list.txt` and `sample_list.txt` information
    files in the `datasets/ch8` directory of this book's repository. We'll need the
    small `ERR019652.small.bam` and `ERR019653.small.bam` files from the same place.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要准备好的 `bam_list.txt` 和 `sample_list.txt` 信息文件，位于本书的 `datasets/ch8`
    目录下。我们还需要来自同一位置的小文件 `ERR019652.small.bam` 和 `ERR019653.small.bam`。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'Visualizing the quality control of read-to-reference alignments can be done
    using the following steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 可通过以下步骤可视化读取到参考基因组的比对质量控制：
- en: 'Set up the parameters for the run:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置运行的参数：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Perform the QC:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行质量控制：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'View the plots:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看图表：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '*Step 1* sets up a parameter-containing object using the `ramwasParameters()` function.
    We simply provide information files (`bam_list.txt` and `sample_list.txt`) saying
    where the BAM files to be used are and the samples they contain, respectively.
    The `dirproject` argument specifies the place on the system to which the results
    should be written. Note the results from this are written to disk; they don''t
    come directly back to memory.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 1* 使用 `ramwasParameters()` 函数设置一个包含参数的对象。我们只需提供信息文件（`bam_list.txt` 和 `sample_list.txt`），分别指定要使用的
    BAM 文件及其包含的样本位置。`dirproject` 参数指定结果应该写入系统的路径。请注意，这些结果会被写入磁盘，而不是直接返回内存。'
- en: '*Step 2* uses the parameters to run the QC with the `ramwas1scanBams()` function.
    The results are written to disk so we load the resulting RDS file back in using
    the base R `readRDS()` function. The `qc` object has a lot of members that represent
    different quality control aspects of alignment.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 2* 使用参数通过 `ramwas1scanBams()` 函数运行质量控制（QC）。结果被写入磁盘，因此我们使用基本的 R `readRDS()`
    函数加载返回的 RDS 文件。`qc` 对象包含许多成员，代表了不同的比对质量控制方面。'
- en: '*Step 3* uses the generic `plot` function to create graphs of some of the QC
    statistics in the `qc` object.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 3* 使用通用的 `plot` 函数来创建一些 `qc` 对象中的质量控制统计图。'
