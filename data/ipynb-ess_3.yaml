- en: Chapter 3. Graphics with matplotlib
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章 matplotlib 图形
- en: 'This chapter explores matplotlib, an IPython library for production of publication-quality
    graphs. In this chapter, the following topics will be discussed:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 matplotlib，这是一个用于生成出版质量图形的 IPython 库。在本章中，将讨论以下主题：
- en: Two-dimensional plots using the `plot` function and setting up line widths,
    colors, and styles
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `plot` 函数绘制二维图，并设置线宽、颜色和样式
- en: Plot configuration and annotation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘图配置和注释
- en: Three-dimensional plots
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三维图形
- en: Animations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画
- en: Being an IPython library, matplotlib consists of a hierarchy of classes, and
    it is possible to code using it in the usual object-oriented style. However, matplotlib
    also supports an **interactive** mode. In this mode, the graphs are constructed
    step-by-step, thus adding and configuring each component at a time. We lay emphasis
    on the second approach since it is designed for the rapid production of graphs.
    The object-oriented style will be explained whenever it is needed or leads to
    better results.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个 IPython 库，matplotlib 由一系列类构成，且可以按照常规面向对象的方式进行编码。然而，matplotlib 也支持**交互式**模式。在这种模式下，图形是一步步构建的，每次添加和配置一个组件。我们强调第二种方法，因为它旨在快速生成图形。当面向对象的方式能提供更好的效果时，我们会在必要时进行解释。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The sense in which the word *interactive* is used in this context is somewhat
    different from what is understood today. Graphs produced by matplotlib are not
    interactive in the sense that the user can manipulate the graphs once they have
    been rendered in the notebook. Instead, the terminology comes from the time when
    matplotlib was used mostly in command-line mode, and each new line of code modified
    the existing plots. Curiously, the software that was the original inspiration
    for matplotlib still uses a command line-based interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，*交互式* 一词的含义与今天的理解略有不同。由 matplotlib 绘制的图形并不具备交互式特性，即用户不能在图形渲染到笔记本后进行操作。相反，这一术语源于
    matplotlib 最初主要用于命令行模式时，每一行新代码都会修改已有的图形。有趣的是，最初启发 matplotlib 的软件仍然使用基于命令行的界面。
- en: The plot function
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘图函数
- en: The `plot()` function is the workhorse of the matplotlib library. In this section,
    we will explore the line-plotting and formatting capabilities included in this
    function.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()` 函数是 matplotlib 库的主力功能。在这一部分，我们将探讨该函数包含的线条绘制和格式化功能。'
- en: 'To make things a bit more concrete, let''s consider the formula for **logistic
    growth**, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情更具具体性，我们来看看**逻辑增长**的公式，如下所示：
- en: '![The plot function](img/8341OS_03_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![绘图函数](img/8341OS_03_01.jpg)'
- en: This model is frequently used to represent growth that shows an initial exponential
    phase, and then is eventually limited by some factor. The examples are the population
    in an environment with limited resources and new products and/or technological
    innovations, which initially attract a small and quickly growing market but eventually
    reach a saturation point.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型常用于表示经历初期指数增长阶段后，最终受某种因素限制的增长。例如，有限资源环境中的人口增长、新产品和/或技术创新的市场，最初吸引一个小而迅速增长的市场，但最终会达到饱和点。
- en: A common strategy to understand a mathematical model is to investigate how it
    changes as the parameters defining it are modified. Let's say, we want to see
    what happens to the shape of the curve when the parameter *b* changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 理解数学模型的一个常见策略是研究当定义模型的参数发生变化时，模型如何变化。假设我们想看看当参数 *b* 变化时，曲线的形状会发生什么变化。
- en: 'To be able to do what we want more efficiently, we are going to use a **function
    factory**. This way, we can quickly create logistic models with arbitrary values
    for *r*, *a*, *b*, and *c*. Run the following code in a cell:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更高效地实现我们的目标，我们将使用**函数工厂**。这样，我们可以快速创建具有任意 *r*、*a*、*b* 和 *c* 值的逻辑模型。在一个单元格中运行以下代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The function factory pattern takes advantage of the fact that functions are
    **first-class objects** in Python. This means that functions can be treated as
    regular objects: they can be assigned to variables, stored in lists in dictionaries,
    and play the role of arguments and/or return values in other functions.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函数工厂模式利用了函数在 Python 中是**一等对象**的事实。这意味着函数可以像普通对象一样被处理：它们可以赋值给变量、存储在列表或字典中，并且可以作为参数或/和返回值传递给其他函数。
- en: In our example, we define the `make_logistic()` function, whose output is itself
    a Python function. Notice how the `f_logistic()` function is defined *inside*
    the body of `make_logistic()` and then returned in the last line.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们定义了`make_logistic()`函数，其输出本身是一个Python函数。注意，`f_logistic()`函数是在`make_logistic()`的函数体内定义的，然后在最后一行返回。
- en: 'Let''s now use the function factory to create three functions representing
    logistic curves, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用函数工厂创建三个表示逻辑曲线的函数，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we first fix the values of `r`, `a`, and `c`, and define
    three logistic curves for different values of *b*. The important point to notice
    is that `logistic1`, `logistic2`, and `logistic3` are functions. So, for example,
    we can use `logistic1(2.5)` to compute the value of the first logistic curve at
    the time 2.5.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先固定了`r`、`a`和`c`的值，并为不同的*b*值定义了三条逻辑曲线。需要注意的重要点是，`logistic1`、`logistic2`和`logistic3`是函数。因此，例如，我们可以使用`logistic1(2.5)`来计算时间为2.5时的第一个逻辑曲线值。
- en: 'We can now plot the functions using the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下代码绘制函数图像：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first line in the preceding code sets the maximum time value, `tmax`, to
    be `40`. Then, we define the set of times at which we want the functions evaluated
    with the assignment, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的第一行将最大时间值`tmax`设置为`40`。接着，我们通过赋值定义了希望评估函数的时间集合，如下所示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `linspace()` function is very convenient to generate points for plotting.
    The preceding code creates an array of 300 equally spaced points in the interval
    from `0` to `tmax`. Note that, contrary to other functions, such as `range()`
    and `arange()`, the right endpoint of the interval is included by default. (To
    exclude the right endpoint, use the `endpoint=False` option.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`linspace()`函数非常方便用来生成绘图的点。上述代码创建了一个包含300个均匀分布点的数组，区间从`0`到`tmax`。注意，与`range()`和`arange()`等其他函数不同，区间的右端点默认是包括的。（要排除右端点，请使用`endpoint=False`选项。）'
- en: 'After defining the array of time values, the `plot()` function is called to
    graph the curves. In its most basic form, it plots a single curve in a default
    color and line style. In this usage, the two arguments are two arrays. The first
    array gives the horizontal coordinates of the points being plotted, and the second
    array gives the vertical coordinates. A typical example will be the following
    function call:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了时间值的数组后，调用`plot()`函数来绘制曲线。在最基本的形式中，它绘制一条默认颜色和线型的单条曲线。在此用法中，两个参数是两个数组。第一个数组提供被绘制点的横坐标，第二个数组提供纵坐标。一个典型的例子是以下函数调用：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The variables `x` and `y` must refer to `NumPy` arrays (or any Python iterable
    values that can be converted into an array) and must have the same dimensions.
    The points plotted have coordinates as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`x`和`y`必须是`NumPy`数组（或任何可以转换为数组的Python可迭代值），并且必须具有相同的维度。绘制的点具有以下坐标：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding command will produce the following plot, displaying the three
    logistic curves:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将产生以下图形，显示三条逻辑曲线：
- en: '![The plot function](img/8341OS_03_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![绘图函数](img/8341OS_03_02.jpg)'
- en: 'You may have noticed that before the graph is displayed, there is a line of
    text output that looks like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在显示图形之前，会有一行看起来像这样的文本输出：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the return value of the last call to the `plot()` function, which is
    a list (or with a single element) of objects of the `Line2D` type. One way to
    prevent the output from being shown is to enter `None` as the last row in the
    cell. Alternatively, we can assign the return value of the last call in the cell
    to a dummy variable:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一次调用`plot()`函数的返回值，它是一个包含`Line2D`类型对象的列表（或者只有一个元素）。阻止输出显示的一种方式是，在单元格的最后一行输入`None`。另外，我们还可以将单元格中最后一次调用的返回值赋值给一个虚拟变量：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `plot()` function supports plotting several curves in the same function
    call. We need to change the contents of the cell that are shown in the following
    code and run it again:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()`函数支持在同一个函数调用中绘制多条曲线。我们需要更改下面代码单元格中的内容，并再次运行它：'
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This form saves some typing but turns out to be a little less flexible when
    it comes to customizing line options. Notice that the text output produced now
    is a list with three elements:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式可以节省一些输入，但在定制线条选项时，灵活性稍差。请注意，现在产生的文本输出是一个包含三个元素的列表：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This output can be useful in some instances. For now, we will stick with using
    one call to `plot()` for each curve, since it produces code that is clearer and
    more flexible.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种输出在某些情况下可能有用。目前，我们将继续为每条曲线使用一次`plot()`调用，因为它生成的代码更清晰且更灵活。
- en: 'Let''s now change the line options in the plot and set the plot bounds. Change
    the contents of the cell to read as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更改图中的线条选项并设置图形的边界。将单元格内容更改为如下所示：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Running the preceding command lines will produce the following plots:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令行将生成以下图形：
- en: '![The plot function](img/8341OS_03_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![The plot function](img/8341OS_03_03.jpg)'
- en: 'The options set in the preceding code are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中设置的选项如下：
- en: The first curve is plotted with a line width of `1.5`, with the HTML color of
    `DarkGreen`, and a filled-line style
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一条曲线的线宽为`1.5`，颜色为HTML颜色`DarkGreen`，并且使用实线样式。
- en: The second curve is plotted with a line width of `2.0`, colored with the RGB
    value given by the hexadecimal string `#8B0000`, and a dotted-line style
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二条曲线的线宽为`2.0`，颜色由十六进制字符串`#8B0000`指定，并采用点线样式。
- en: The third curve is plotted with a line width of `3.0`, colored with the RGB
    components, `(0.0, 0.0, 0.5)`, and a dashed-line style
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三条曲线的线宽为`3.0`，颜色由RGB组件`(0.0, 0.0, 0.5)`指定，且采用虚线样式。
- en: 'Notice that there are different ways of specifying a fixed color: a HTML color
    name, a hexadecimal string, or a tuple of floating-point values. In the last case,
    the entries in the tuple represent the intensity of the red, green, and blue colors,
    respectively, and must be floating-point values between `0.0` and `1.0`. A complete
    list of HTML name colors can be found at [http://www.w3schools.com/html/html_colornames.asp](http://www.w3schools.com/html/html_colornames.asp).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有不同的方式来指定固定颜色：HTML颜色名称、十六进制字符串或浮点值元组。在最后一种情况下，元组中的条目分别代表红色、绿色和蓝色的强度，并且必须是介于`0.0`和`1.0`之间的浮点值。完整的HTML颜色名称列表可以在[http://www.w3schools.com/html/html_colornames.asp](http://www.w3schools.com/html/html_colornames.asp)找到。
- en: 'Line styles are specified by a symbolic string. The allowed values are shown
    in the following table:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 线条样式由符号字符串指定。允许的值如下表所示：
- en: '| Symbol string | Line style |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 符号字符串 | 线条样式 |'
- en: '| --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ''`-`'' | Solid (the default) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| ''`-`'' | 实线（默认） |'
- en: '| ''`--`'' | Dashed |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| ''`--`'' | 虚线 |'
- en: '| ''`:`'' | Dotted |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| ''`:`'' | 点线 |'
- en: '| ''`-.`'' | Dash-dot |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| ''`-.`'' | 虚线点线 |'
- en: '| ''`None`'', '''', `or` '''' | Not displayed |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| ''`None`''、'''' 或 '''' | 不显示 |'
- en: 'After the calls to `plot()`, we set the graph bounds with the function call:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`plot()`之后，我们使用以下函数来设置图形的边界：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The argument to `axis()` is a four-element list that specifies, in this order,
    the maximum and minimum values of the horizontal coordinates, and the maximum
    and minimum values of the vertical coordinates.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`axis()`的参数是一个包含四个元素的列表，按照顺序指定水平坐标的最大值和最小值，以及垂直坐标的最大值和最小值。'
- en: It may seem non-intuitive that the bounds for the variables are set after the
    plots are drawn. In the interactive mode, matplotlib remembers the state of the
    graph being constructed, and graphics objects are updated in the background after
    each command is issued. The graph is only rendered when all computations in the
    cell are done so that all previously specified options take effect. Note that
    starting a new cell clears all the graph data. This interactive behavior is part
    of the `matplotlib.pyplot` module, which is one of the components imported by
    `pylab`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来在绘制图形之后再设置变量的边界似乎不直观。在交互模式下，matplotlib会记住正在构建的图形的状态，并且在每次发出命令后，图形对象会在后台更新。图形仅在单元格中的所有计算完成后才会渲染，以便所有先前指定的选项生效。请注意，开始一个新单元格会清除所有图形数据。这种交互行为是`matplotlib.pyplot`模块的一部分，而`pylab`会导入该模块。
- en: 'Besides drawing a line connecting the data points, it is also possible to draw
    markers at specified points. Change the graphing commands indicated in the following
    code snippet, and then run the cell again:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了绘制连接数据点的线条外，还可以在指定的点上绘制标记。更改以下代码片段中所示的绘图命令，然后重新运行该单元格：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, the graph will look as shown in the following figure:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，图形将如下面的图所示：
- en: '![The plot function](img/8341OS_03_04.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![The plot function](img/8341OS_03_04.jpg)'
- en: 'The only difference from the previous code is that now we added options to
    draw markers. The following are the options we use:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的代码唯一的区别是，现在我们添加了绘制标记的选项。以下是我们使用的选项：
- en: The `marker` option specifies the shape of the marker. Shapes are given as symbolic
    strings. In the preceding examples, we use `'o'` for a circular marker, `'s'`
    for a square, and `'*'` for a star. A complete list of available markers can be
    found at [http://matplotlib.org/api/markers_api.html#module-matplotlib.markers](http://matplotlib.org/api/markers_api.html#module-matplotlib.markers).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`marker`选项指定了标记的形状。形状由符号字符串表示。在之前的示例中，我们使用`''o''`表示圆形标记，`''s''`表示方形标记，`''*''`表示星形标记。可用标记的完整列表可以在[http://matplotlib.org/api/markers_api.html#module-matplotlib.markers](http://matplotlib.org/api/markers_api.html#module-matplotlib.markers)查看。'
- en: The `markevery` option specifies a stride within the data points for the placement
    of markers. In our example, we place a marker after every 50 data points.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`markevery`选项指定了数据点之间标记的间隔。在我们的示例中，我们每50个数据点放置一个标记。'
- en: The `markercolor` option specifies the color of the marker.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`markercolor`选项指定了标记的颜色。'
- en: The `markersize` option specifies the size of the marker. The size is given
    in pixels.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`markersize`选项指定了标记的大小，大小以像素为单位。'
- en: There are a large number of other options that can be applied to lines in matplotlib.
    A complete list is available at [http://matplotlib.org/api/artist_api.html#module-matplotlib.lines](http://matplotlib.org/api/artist_api.html#module-matplotlib.lines).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: matplotlib中有大量其他选项可以应用于线条。完整的列表可以在[http://matplotlib.org/api/artist_api.html#module-matplotlib.lines](http://matplotlib.org/api/artist_api.html#module-matplotlib.lines)查看。
- en: Adding a title, labels, and a legend
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加标题、标签和图例
- en: 'The next step is to add a title and labels for the axes. Just before the `None`
    line, add the following three lines of code to the cell that creates the graph:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加标题和坐标轴标签。在`None`行之前，向创建图表的代码单元格中添加以下三行代码：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the first line, we call the `title()` function to set the title of the plot.
    The argument can be any Python string. In our example, we use a formatted string:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们调用`title()`函数来设置图表的标题。参数可以是任何Python字符串。在我们的示例中，我们使用了格式化字符串：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We use the `format()` method of the string class. The formats are placed between
    braces, as in `{:5.2f}`, which specifies a floating-point format with five spaces
    and two digits of precision. Each of the format specifiers is then associated
    sequentially with one of the data arguments of the method. Some of the details
    of string formatting are covered in [Appendix B](apb.html "Appendix B. A Brief
    Review of Python"), *A Brief Review of Python*, and the full documentation is
    available at [https://docs.python.org/2/library/string.html](https://docs.python.org/2/library/string.html).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用字符串类的`format()`方法。格式放置在大括号之间，例如`{:5.2f}`，它指定一个浮点格式，具有五个空间和两位精度。每个格式说明符依次与方法的一个数据参数关联。字符串格式化的部分细节可以在[附录B](apb.html
    "附录B. Python 简要回顾")中查看，完整的文档可以在[https://docs.python.org/2/library/string.html](https://docs.python.org/2/library/string.html)查看。
- en: 'The axis labels are set in the calls:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标轴标签通过以下调用设置：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As in the `title()` functions, the `xlabel()` and `ylabel()` functions accept
    any Python string. Note that in the '`$t$`' and '`$N(t)=a/(b+ce^{-rt}$`' strings,
    we use LaTeX to format the mathematical formulas. This is indicated by the dollar
    signs, `$...$`, in the string.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与`title()`函数一样，`xlabel()`和`ylabel()`函数接受任何Python字符串。注意，在'`$t$`'和'`$N(t)=a/(b+ce^{-rt}$`'字符串中，我们使用LaTeX格式化数学公式。公式中的美元符号`$...$`表示LaTeX格式。
- en: 'After the addition of a title and labels, our graph looks like the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 添加标题和标签后，我们的图表如下所示：
- en: '![Adding a title, labels, and a legend](img/8341OS_03_05.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![添加标题、标签和图例](img/8341OS_03_05.jpg)'
- en: 'Next, we need a way to identify each of the curves in the picture. One way
    to do that is to use a `legend`, which is indicated as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法来识别图中的每条曲线。一种方法是使用`legend`，如下面所示：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `legend()` function accepts a list of strings. Each string is associated
    with a curve in the order they are added to the plot. Notice that we are again
    using formatted strings.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`legend()`函数接受一个字符串列表。每个字符串与曲线相关联，顺序是根据它们添加到图表的顺序。注意，我们再次使用了格式化字符串。'
- en: 'Unfortunately, the preceding code does not produce great results. The legend,
    by default, is placed in the top-right corner of the plot, which, in this case,
    hides part of the graph. This is easily fixed using the `loc` option in the `legend`
    function, as shown in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，之前的代码并没有产生很好的效果。图例默认放置在图表的右上角，这在此情况下会遮挡图表的一部分。我们可以通过在`legend`函数中使用`loc`选项来轻松修复，如下所示：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running this code, we obtain the final version of our logistic growth plot,
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，我们得到了最终版本的逻辑增长图，如下所示：
- en: '![Adding a title, labels, and a legend](img/8341OS_03_06.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![添加标题、标签和图例](img/8341OS_03_06.jpg)'
- en: 'The legend location can be any of the strings: `''best''`, `''upper right''`,
    `''upper left''`, `''lower left''`, `''lower right''`, `''right''`, `''center
    left''`, `''center right''`, `''lower center''`, `''upper center''`, and `''center''`.
    It is also possible to specify the location of the legend precisely with the `bbox_to_anchor`
    option. To see how this works, modify the code for the legend as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图例位置可以是以下字符串中的任何一个：`'best'`、`'upper right'`、`'upper left'`、`'lower left'`、`'lower
    right'`、`'right'`、`'center left'`、`'center right'`、`'lower center'`、`'upper center'`
    和 `'center'`。还可以通过`bbox_to_anchor`选项精确指定图例的位置。为了查看其工作原理，请按如下方式修改图例的代码：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that the `bbox_to_anchor` option, by default, uses a coordinate system
    that is not the same as the one we specified for the plot. The *x* and *y* coordinates
    of the box in the preceding example are interpreted as a fraction of the width
    and height, respectively, of the whole figure. A little trial-and-error is necessary
    to place the legend box precisely where we want it. Note that the legend box can
    be placed outside the plot area. For example, try the coordinates `(1.32,1.02)`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`bbox_to_anchor`选项默认使用的坐标系统与我们为绘图指定的坐标系统不同。在前面的例子中，框的*x*和*y*坐标分别被解释为整个图形宽度和高度的比例。为了精确地放置图例框，需要做一些反复试验。请注意，图例框可以放置在绘图区域之外。例如，可以尝试坐标`(1.32,1.02)`。
- en: The `legend()` function is quite flexible and has quite a few other options
    that are documented at [http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.legend](http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.legend).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`legend()`函数非常灵活，具有许多其他选项，相关文档可以参考[http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.legend](http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.legend)。'
- en: Text and annotations
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本和注释
- en: 'In this subsection, we will show how to add annotations to plots in matplotlib.
    We will build a plot demonstrating the fact that the tangent to a curve must be
    horizontal at the highest and lowest points. We start by defining the function
    associated with the curve and the set of values at which we want the curve to
    be plotted, which is shown in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一小节中，我们将展示如何在matplotlib中向图形添加注释。我们将构建一个图形，演示曲线的切线在最高点和最低点必须是水平的这一事实。我们首先定义与曲线相关的函数，以及我们希望绘制该曲线的一组值，具体代码如下：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first line in the preceding code uses a lambda expression to define the
    `f()` function. We use this approach here because the formula for the function
    is a simple, one-line expression. The general form of a lambda expression is as
    follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的第一行使用lambda表达式定义了`f()`函数。我们在这里采用这种方法，因为函数的公式是简单的一行表达式。lambda表达式的一般形式如下：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This expression by itself creates an anonymous function that can be used in
    any place that a function object is expected. Note that the return value must
    be a single expression and cannot contain any statements.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式本身创建了一个匿名函数，可以在任何需要函数对象的地方使用。请注意，返回值必须是单一的表达式，不能包含任何语句。
- en: The formula for the function may seem unusual, but it was chosen by trial-and-error
    and a little bit of calculus so that it produces a nice graph in the interval
    from `0` to `5`. The `xvalues` array is defined to contain 200 equally spaced
    points on this interval.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的公式看起来可能有些不寻常，但它是通过试错法和一些微积分选择的，以便在区间`0`到`5`内生成一个漂亮的图形。`xvalues`数组被定义为包含该区间内200个均匀分布的点。
- en: 'Let''s create an initial plot of our curve, as shown in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个初始的曲线图，如下所示的代码：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Most of the code in this segment is explained in the previous section. The only
    new bit is that we use the `grid()` function to draw a grid. Used with no arguments,
    the grid coincides with the tick marks on the plot. As everything else in matplotlib,
    grids are highly customizable. Check the documentation at [http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.grid](http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.grid).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这一段代码中的大部分内容在前一节已经解释过。唯一新增的部分是我们使用`grid()`函数来绘制网格。没有参数时，网格与图中的刻度线重合。与matplotlib中的其他内容一样，网格是高度可定制的。请参阅文档[http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.grid](http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.grid)。
- en: 'When the preceding code is executed, the following plot is produced:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码时，会生成如下图形：
- en: '![Text and annotations](img/8341OS_03_07.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![文本与注释](img/8341OS_03_07.jpg)'
- en: 'Note that the curve has a highest point (*maximum*) and a lowest point (*minimum*).
    These are collectively called the *extreme values* of the function (on the displayed
    interval, this function actually grows without bounds as *x* becomes large). We
    would like to locate these on the plot with annotations. We will first store the
    relevant points as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，曲线有一个最高点（*最大值*）和一个最低点（*最小值*）。这些点合称为函数的*极值*（在所显示的区间内，实际上当*x*变大时，函数会无限增大）。我们希望在图表上标出这些点并添加注释。首先，我们将相关点存储如下：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The variables, `x_min` and `f_min`, are defined to be (approximately) the coordinates
    of the lowest point in the graph. Analogously, `x_max` and `f_max` represent the
    highest point. Don''t be concerned with how these points were found. For the purposes
    of graphing, even a rough approximation by trial-and-error would suffice. In [Chapter
    5](ch05.html "Chapter 5. Advanced Computing with SciPy, Numba, and NumbaPro"),
    *Advanced Computing with SciPy, Numba, and NumbaPro*, we will see how to solve
    this kind of problem accurately via SciPy. Now, add the following code to the
    cell that draws the plot, right below the `title()` command, as shown in the following
    code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `x_min` 和 `f_min` 定义为图表中最低点的（大约）坐标。类似地，`x_max` 和 `f_max` 代表最高点。无需关心这些点是如何找到的。对于绘图而言，即使是通过试错法得到的粗略近似值也足够了。在[第5章](ch05.html
    "第5章：使用 SciPy、Numba 和 NumbaPro 的高级计算")中，我们将看到如何通过 SciPy 精确地解决这类问题。现在，在绘制图表的单元格中，紧接着
    `title()` 命令，添加以下代码，如下所示：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the cell to produce the plot shown in the following diagram:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行单元格以生成下图所示的图表：
- en: '![Text and annotations](img/8341OS_03_08.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![文本与注释](img/8341OS_03_08.jpg)'
- en: 'In the code, start by assigning the variables `arrow_props`, `delta`, and `offset`,
    which will be used to set the arguments in the calls to `annotate()`. The `annotate()`
    function adds a textual annotation to the graph with an optional arrow indicating
    the point being annotated. The first argument of the function is the text of the
    annotation. The next two arguments give the locations of the arrow and the text:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，首先赋值变量 `arrow_props`、`delta` 和 `offset`，它们将用于设置 `annotate()` 函数的参数。`annotate()`
    函数将文本注释添加到图表上，箭头可选地指示被注释的点。该函数的第一个参数是注释文本。接下来的两个参数给出了箭头和文本的位置：
- en: '`xy`: This is the point being annotated and will correspond to the tip of the
    arrow. We want this to be the maximum/minimum points, `p_min` and `p_max`, but
    we add/subtract the `delta` vector so that the tip is a bit removed from the actual
    point.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xy`：这是被注释的点，并将对应于箭头的尖端。我们希望这个点是最大值/最小值点 `p_min` 和 `p_max`，但我们会加上/减去 `delta`
    向量，以便箭头的尖端略微偏离实际点。'
- en: '`xytext`: This is the point where the text will be placed as well as the base
    of the arrow. We specify this as offsets from `p_min` and `p_max` using the `offset`
    vector.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xytext`：这是文本的位置和箭头的基点。我们通过 `offset` 向量指定该点相对于 `p_min` 和 `p_max` 的偏移量。'
- en: 'All other arguments of `annotate()` are formatting options:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`annotate()` 的所有其他参数都是格式化选项：'
- en: '`arrowprops`: This is a Python dictionary containing the arrow properties.
    We predefine the dictionary, `arrow_props`, and use it here. Arrows can be quite
    sophisticated in matplotlib, and you are directed to the documentation for details.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrowprops`：这是一个包含箭头属性的 Python 字典。我们预定义了字典 `arrow_props` 并在此使用它。箭头在 matplotlib
    中可以非常复杂，具体细节请参考文档。'
- en: '`verticalalignment` and `horizontalalignment`: These specify how the arrow
    should be aligned with the text.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verticalalignment` 和 `horizontalalignment`：这些指定了箭头与文本的对齐方式。'
- en: '`fontsize`: This signifies the size of the text. Text is also highly configurable,
    and the reader is directed to the documentation for details.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fontsize`：这表示文本的大小。文本也可以高度自定义，读者可参考文档获取详细信息。'
- en: The `annotate()` function has a huge number of options; for complete details
    of what is available, users should consult the documentation at [http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.annotate](http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.annotate)
    for the full details.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`annotate()` 函数有大量的选项；欲了解所有可用的详细信息，用户应参考文档 [http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.annotate](http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.annotate)
    获取完整资料。'
- en: 'We now want to add a comment for what is being demonstrated by the plot by
    adding an explanatory textbox. Add the following code to the cell right after
    the calls to `annotate()`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要通过添加一个解释性文本框来对图形展示的内容进行注释。在调用`annotate()`之后，向单元格中添加以下代码：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `text()`function is used to place text at an arbitrary position of the plot.
    The first two arguments are the position of the textbox, and the third argument
    is a string containing the text to be displayed. Notice the use of `'\n'` to indicate
    a line break. The other arguments are configuration options. The `bbox` argument
    is a dictionary with the options for the box. If omitted, the text will be displayed
    without any surrounding box. In the example code, the box is a rectangle with
    rounded corners, with a border width of 2 pixels and the face color, beige.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`text()`函数用于将文本放置在图形的任意位置。前两个参数是文本框的位置，第三个参数是一个包含要显示文本的字符串。注意使用`''\n''`表示换行。其他参数是配置选项。`bbox`参数是一个字典，用于设置文本框的选项。如果省略，文本将不显示任何边框。在示例代码中，文本框是一个具有圆角的矩形，边框宽度为2像素，面色为米色。'
- en: 'As a final detail, let''s add the tangent lines at the extreme points. Add
    the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的细节，让我们在极端点处添加切线。添加以下代码：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since the tangents are segments of straight lines, we simply give the coordinates
    of the endpoints. The reason to add the code for the tangents at the top of the
    cell is that this causes them to be plotted first so that the graph of the function
    is drawn at the top of the tangents. This is the final result:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于切线是直线段，我们只需要给出端点的坐标。之所以将切线的代码放在单元格顶部，是因为这样可以确保切线先被绘制，从而使得函数图形绘制在切线之上。以下是最终结果：
- en: '![Text and annotations](img/8341OS_03_09.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![文本和注释](img/8341OS_03_09.jpg)'
- en: The examples we have seen so far only scratch the surface of what is possible
    with matplotlib. The reader should read the matplotlib documentation for more
    examples.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的例子仅仅触及了matplotlib的冰山一角。读者应查阅matplotlib文档以获得更多示例。
- en: Three-dimensional plots
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三维图形
- en: In this section, we present methods to display three-dimensional plots, that
    is, plots of mathematical objects in space. Examples include surfaces and lines
    that are not confined to a plate.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了展示三维图形的方法，即空间中数学对象的图形。示例包括不局限于平面上的曲面和线条。
- en: 'matplotlib has excellent support for three-dimensional plots. In this section,
    we will present an example of a surface plot and corresponding contour plot. The
    types of plot available in the three-dimensional library include wireframe plots,
    line plots, scatterplots, triangulated surface plots, polygon plots, and several
    others. The following link will help you to understand the types of plots that
    are not treated here: [http://matplotlib.org/1.3.1/mpl_toolkits/mplot3d/tutorial.html#mplot3d-tutorial](http://matplotlib.org/1.3.1/mpl_toolkits/mplot3d/tutorial.html#mplot3d-tutorial)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: matplotlib对三维图形提供了出色的支持。在本节中，我们将展示一个表面图和相应的等高线图的示例。三维库中可用的图形类型包括框架图、线图、散点图、三角形网格表面图、多边形图等。以下链接将帮助你了解这里没有介绍的图形类型：[http://matplotlib.org/1.3.1/mpl_toolkits/mplot3d/tutorial.html#mplot3d-tutorial](http://matplotlib.org/1.3.1/mpl_toolkits/mplot3d/tutorial.html#mplot3d-tutorial)
- en: 'Before we start, we need to import the three-dimensional library objects we
    need using the following command line:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要使用以下命令行导入所需的三维库对象：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s draw our surface plot by running the following code in a cell:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在单元格中运行以下代码来绘制表面图：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We start by specifying the `fsurface()` function, which defines the surface.
    The details of the function definition are not relevant; we will just note that
    this is a surface of revolution that has a dip at the center, surrounded by a
    ridge. We then start setting up the figure with the following lines of code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从指定`fsurface()`函数开始，该函数定义了表面。函数定义的细节并不重要；我们只需要注意这是一个旋转曲面，中心有一个低点，四周被一个高峰包围。然后，我们开始通过以下几行代码来设置图形：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This time, we specifically construct the `Figure` object because we want to
    specify its size explicitly. The size here is defined as an `8` x `8` inch square,
    but this is not quite accurate since the actual size of the figure will depend
    on the resolution of the display and the magnification factor of the browser.
    We then create a subplot and set its projection type to `'3d'`. The `subplot()`
    function will be treated with more detail later in this section.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们特别构造`Figure`对象，因为我们想要明确指定其大小。这里的大小定义为一个`8` x `8`英寸的正方形，但实际图形的大小取决于显示的分辨率和浏览器的放大倍数。然后我们创建一个子图并将其投影类型设置为`'3d'`。`subplot()`函数将在本节中详细介绍。
- en: 'Next, we will define the grid of points where the function is computed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义计算函数的点网格：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The most important point here is the use of the `meshgrid()` function, which
    is a part of the `NumPy` package. This function takes two one-dimensional arrays,
    with *x* and *y* values and computes two matrices that define the corresponding
    grid of points on the plane. To understand how this works, run the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的一点是使用`meshgrid()`函数，它是`NumPy`包的一部分。此函数接受两个一维数组，带有*x*和*y*值，并计算定义平面上相应点的网格的两个矩阵。要理解其工作原理，请运行以下代码：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The two matrices produced, `XX` and `YY`, are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的两个矩阵，`XX`和`YY`，如下所示：
- en: 'The `XX` matrix:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XX`矩阵：'
- en: '[PRE31]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `YY` matrix:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YY`矩阵：'
- en: '[PRE32]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that, if we take the elements of `XX` and the corresponding entries in
    `YY`, we get the set of points (1,4), (1,5), (1,6), (2,4),…, (3,5), (3,6), which
    are on a regularly spaced grid on the plane.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们取`XX`的元素和`YY`中对应的条目，我们得到一组点(1,4)、(1,5)、(1,6)、(2,4)...、(3,5)、(3,6)，这些点在平面上是规则间隔的网格。
- en: 'We are now ready to call the function that computes the surface and plot it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用计算表面并绘制它的函数：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first line computes the `Z` array, containing the *z* coordinates of the
    surface. This call makes heavy use of a feature of `NumPy` called **broadcasting**
    in the background. This is a set of rules that tells us how `NumPy` deals with
    operations for arrays with different sizes. For more information, see [http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行计算`Z`数组，其中包含表面的*z*坐标。这个调用在背景中大量使用了`NumPy`称为**广播**的特性。这是一组规则，告诉我们`NumPy`如何处理具有不同大小的数组的操作。更多信息请参见[http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)。
- en: The next step is to call the `plot_surface()` method, which does the actual
    plotting. The first three arguments define the data being plotted, that is, the
    arrays `X`, `Y`, and `Z`. The `cstride` and `rstride` options can be used to skip
    points in the data arrays. Set these to values greater than 1 to skip points in
    the grid, in the event the data set is too large.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是调用`plot_surface()`方法，它实际上进行绘图。前三个参数定义了正在绘制的数据，即数组`X`、`Y`和`Z`。`cstride`和`rstride`选项可用于跳过数据数组中的点。将这些值设置为大于1的值以跳过网格中的点，以防数据集过大。
- en: 'We are using a **colormap** feature specified by the `cmap=cm.coolwarm` option.
    The colormap feature tells matplotlib how to assign a color to each height in
    the plot. A large number of built-in colormaps are available. To see a complete
    list, run the following lines of code in a cell:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一个由`cmap=cm.coolwarm`选项指定的**色彩映射**特性。色彩映射功能告诉matplotlib如何为绘图中的每个高度分配颜色。提供了大量内置的色彩映射。要查看完整列表，请在单元格中运行以下代码：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that three-dimensional surface plots are, by default, not antialiased,
    so we set the `antialiased=True` option in the code to produce a better image.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，三维表面图不是抗锯齿的，因此我们在代码中设置了`antialiased=True`选项以生成更好的图像。
- en: 'Let''s now add a contour plot to the graph. We want the three-dimensional surface
    plot and the contour graph to appear side-by-side. To achieve that, modify the
    code in the cell to the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在图中添加等高线图。我们希望三维表面图和等高线图并排显示。为了实现这一点，请将单元格中的代码修改如下：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result of running the code is shown in the following figure:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码的结果如下图所示：
- en: '![Three-dimensional plots](img/8341OS_03_10.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![三维图](img/8341OS_03_10.jpg)'
- en: Let's first concentrate on the `contours()` method. The first argument, `levels`,
    specifies the values (heights) for which the contours are plotted. This argument
    can be left out, and matplotlib will try to choose the heights in a way that makes
    sense. The other arguments are options for how to display the contours. We specify
    the colormap and line width in this example.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们集中讨论`contours()`方法。第一个参数`levels`指定了绘制等高线的值（高度）。这个参数可以省略，matplotlib会尝试选择合适的高度。其他参数是控制如何显示等高线的选项。我们在这个示例中指定了色图和线宽。
- en: The `clabel()` method adds labels to the contours. The first argument, `levels[1::2]`,
    specifies that every second contour is to be labeled.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`clabel()`方法为等高线添加标签。第一个参数`levels[1::2]`指定每隔一个等高线就添加标签。'
- en: 'Note the code that is used to place two axes in the same figure. The axes are
    defined by the following command lines:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意用于将两个坐标轴放置在同一图形中的代码。坐标轴通过以下命令行定义：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The general form of the `subplot()` function is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`subplot()`函数的一般形式如下：'
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This specifies an `Axes` object in an array with `nrows` rows and `ncols` columns.
    The position of the axis is an integer from 1 to `nrows*ncols`. The following
    figure illustrates how the axes are numbered in the case of a 3 x 2 array:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了一个具有`nrows`行和`ncols`列的数组中的`Axes`对象。坐标轴的位置是一个从1到`nrows*ncols`的整数。下图演示了在3
    x 2数组情况下坐标轴的编号方式：
- en: '![Three-dimensional plots](img/8341OS_03_11.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![三维图](img/8341OS_03_11.jpg)'
- en: 'The preceding image was generated with the help of the following command lines:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上图是通过以下命令行生成的：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After defining the figure size in the usual way, we set the number of rows and
    columns of the grid of axes we want to generate. Then, each of the `Axes` objects
    is created and configured in the loop. Look carefully at how the positions of
    the axes are identified. Note also that we show how to set the background color
    of the axes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在按照常规方式定义图形大小后，我们设置了我们希望生成的坐标轴网格的行数和列数。然后，在循环中创建并配置每个`Axes`对象。仔细查看如何确定坐标轴的位置。还请注意，我们展示了如何设置坐标轴的背景颜色。
- en: Animations
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画
- en: We will finish the chapter with a more complex example that illustrates the
    power that matplotlib gives us. We will create an animation of a forced pendulum,
    a well-known and much studied example of a dynamic system exhibiting deterministic
    chaos.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章结束时给出一个更复杂的示例，展示matplotlib的强大功能。我们将创建一个强迫摆锤的动画，这是一个著名且广泛研究的动态系统示例，表现出确定性混沌。
- en: Since this section involves more sophisticated code, we will refrain from using
    `pylab` and adopt the generally recommended way of importing modules. This makes
    the code easier to export to a script if we so wish. We also give samples of some
    of the object-oriented features of matplotlib.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本节涉及更复杂的代码，我们将避免使用`pylab`，并采用通常推荐的模块导入方式。这使得代码在我们需要时更容易导出为脚本。我们还给出了matplotlib的一些面向对象功能的示例。
- en: 'The process of animating a pendulum (or any physical process) is actually very
    simple: we compute the position of the pendulum at a finite number of times and
    display the corresponding images in quick succession. So, the code will naturally
    break down into the following three pieces:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 动画摆锤（或任何物理过程）的过程实际上非常简单：我们在有限的时间点计算摆锤的位置，并快速展示相应的图像。因此，代码自然会分解为以下三部分：
- en: A function that displays a pendulum in an arbitrary position
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个显示摆锤在任意位置的函数
- en: Setting up the computation of the position of the pendulum at an arbitrary time
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置在任意时刻计算摆锤位置的代码
- en: The code that actually computes the position of the pendulum and displays the
    corresponding images
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际计算摆锤位置并显示相应图像的代码
- en: 'We start by importing all the modules and functions we need to set up the animation:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入设置动画所需的所有模块和函数：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the following code, we will define a function that draws a simple sketch
    of a pendulum:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将定义一个绘制简单摆锤草图的函数：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This function takes as the first argument an `Axes` object. The other arguments
    are as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的第一个参数是一个`Axes`对象。其他参数如下：
- en: The angle, `theta`, of the pendulum with the vertical surface
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摆锤与垂直面之间的角度`theta`
- en: The `length` of the rod
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杆的`length`
- en: The `radius` of the bob
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摆锤的`radius`
- en: 'The preceding quantities are indicated in the following figure:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述量在下图中进行了指示：
- en: '![Animations](img/8341OS_03_12.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![动画](img/8341OS_03_12.jpg)'
- en: 'Then, we define a `NumPy` vector, `v`, which holds the position of the pendulum
    relative to the origin. The following statements define the objects to be drawn:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个`NumPy`向量`v`，它表示摆锤相对于原点的位置。以下语句定义了要绘制的对象：
- en: '`ax.axhline()`: This function draws a horizontal line across the plot'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax.axhline()`：此函数在图中绘制一条水平线'
- en: '`rod`: This is a `lines.Line2D` object (incidentally, this is the object that
    is used to draw most plots in matplotlib)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rod`：这是一个`lines.Line2D`对象（顺便提一下，这是用于绘制大多数matplotlib图表的对象）'
- en: '`bob` and `peg`: These are objects of the `patches.Circle` type; matplotlib
    patches represent essentially any kind of object that can be placed in a figure'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bob`和`peg`：这些是`patches.Circle`类型的对象；matplotlib的patches代表任何可以放置在图中的对象'
- en: 'The following lines of code can be used to test the drawing code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行可用于测试绘图代码：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Running the code in the previous cell will produce the following image:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上一单元格中的代码将生成以下图像：
- en: '![Animations](img/8341OS_03_13.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![动画](img/8341OS_03_13.jpg)'
- en: 'The following comments indicate how the code in the preceding example works:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下注释说明了前面示例中代码的工作原理：
- en: The first two lines define the variables, `fig` and `ax`, that hold the `Figure`
    and `Axes` objects, respectively. In matplotlib, a `Figure` object is a container
    that holds all other plotting objects. Each `Figure` can contain several `Axes`,
    which contain individual plots. Note the use of the `figsize=(5,5)` argument to
    set the size of the figure.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前两行定义了保存`Figure`和`Axes`对象的变量`fig`和`ax`。在matplotlib中，`Figure`对象是一个容器，包含所有其他绘图对象。每个`Figure`可以包含多个`Axes`，每个`Axes`包含单独的图表。注意使用`figsize=(5,5)`参数来设置图表的大小。
- en: Next, we set the axis limits. The `set_aspect()` method of the `ax` object is
    used to set the aspect ratio to be the same in both directions. Without this,
    the circles will be drawn as ellipses. Then, the `set_xlim()` and `set_ylim()`
    methods specify the bounds for the axes.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置坐标轴的限制。`ax`对象的`set_aspect()`方法用于将纵横比设置为相同。如果没有这个设置，圆形会被绘制成椭圆。然后，`set_xlim()`和`set_ylim()`方法分别指定坐标轴的范围。
- en: We then call the `draw_pendulum()` function, which does all the drawing.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调用`draw_pendulum()`函数，它完成所有的绘制工作。
- en: Finally, we use `ax.set_xticks([])` and `set_yticks([])` to remove the tick
    marks from the axes.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`ax.set_xticks([])`和`set_yticks([])`从坐标轴中去除刻度标记。
- en: 'The next step is to set up what is needed to find the trajectory to the pendulum.
    The dynamics of a pendulum are given by a system of differential equations, which
    is defined in the following lines of code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置所需内容，以找到摆锤的轨迹。摆锤的动力学由一组微分方程给出，定义在以下代码行中：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code starts by defining the `pendulum_eq()` function, which stipulates
    the differential equations for a pendulum. The derivation of the equations is
    beyond the scope of this book. The remaining code in the cell configures an object
    of the `ode()` type, which is a part of the `scipy.integrate` module. We will
    not discuss the details here, but this module is discussed in [Chapter 5](ch05.html
    "Chapter 5. Advanced Computing with SciPy, Numba, and NumbaPro"), *Advanced Computing
    with SciPy, Numba, and NumbaPro*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先定义了`pendulum_eq()`函数，该函数规定了摆锤的微分方程。方程的推导超出了本书的范围。单元格中的其余代码配置了一个`ode()`类型的对象，这是`scipy.integrate`模块的一部分。我们在这里不讨论细节，但该模块在[第5章](ch05.html
    "第5章：使用SciPy、Numba和NumbaPro的高级计算")中有介绍，*使用SciPy、Numba和NumbaPro的高级计算*。
- en: 'We are now ready to run the animation by executing the following code in a
    cell:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备通过在单元格中执行以下代码来运行动画：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is probably the most complex code segment in the book so far, but most
    of it has already been covered. The variables `tmax` and `dt` hold the maximum
    time for the animation and the time increment, respectively. We then set the `Figure`
    and `Axes` objects for the plot.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是到目前为止书中最复杂的代码段，但大部分内容已经涉及。变量`tmax`和`dt`分别保存动画的最大时间和时间增量。然后，我们设置绘图的`Figure`和`Axes`对象。
- en: 'Then comes a `while` loop, where the animation is actually executed. This is
    the general skeleton of the loop:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个`while`循环，在这个循环中，动画实际上被执行。以下是循环的一般框架：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will not discuss in detail the code used to solve the differential equation
    since it will be presented in detail in [Chapter 5](ch05.html "Chapter 5. Advanced
    Computing with SciPy, Numba, and NumbaPro"), *Advanced Computing with SciPy, Numba,
    and NumbaPro*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细讨论用来解微分方程的代码，因为它将在[第五章](ch05.html "第五章. 使用SciPy、Numba和NumbaPro进行高级计算")中详细介绍，*使用SciPy、Numba和NumbaPro进行高级计算*。
- en: 'The loop has `True` as the looping condition so this is potentially an infinite
    loop. However, inside the loop, we check if the current time is larger than the
    maximum time for the animation, and if that is the case, we break from the loop:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 循环条件是`True`，因此这可能是一个无限循环。然而，在循环内，我们检查当前时间是否大于动画的最大时间，如果是这种情况，则退出循环：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The first thing we do in the loop is to call the `clear_output()` function.
    This function, as the name indicates, removes the output of the current cell and
    is at the heart of doing simple animations in the notebook. The `wait=True` argument
    tells the function to wait until the next image is fully drawn before clearing
    the output, which prevents flickering.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，我们做的第一件事是调用`clear_output()`函数。正如函数名所示，它会移除当前单元格的输出，这是在笔记本中进行简单动画的核心。`wait=True`参数告诉该函数在下一个图像完全绘制完毕后再清除输出，从而防止闪烁。
- en: The `time.sleep(1./20)` argument pauses the computation for a brief period of
    time to prevent the animation from running too fast. Then, a new position of the
    pendulum is computed and plotted. Then, `display(fig)` is called to show the figure.
    This is needed here because, contrary to the case of static graphs, we don't want
    the plot to be shown only at the end of the cell.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.sleep(1./20)`参数将计算暂停一段短时间，以防止动画运行过快。然后，计算并绘制摆的当前位置。接着，调用`display(fig)`显示图形。这里需要这样做，因为与静态图形不同，我们不希望图形仅在单元格的最后显示出来。'
- en: The final detail is to call `plt.close()` at the end of the loop. This prevents
    the pendulum image from being drawn one extra time when the loop is exited. Placing
    this call inside the loop also helps to avoid flicker.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的细节是在循环结束时调用`plt.close()`。这可以防止在退出循环时绘制摆的图像多绘制一次。将此调用放在循环内还帮助避免闪烁现象。
- en: The reader is encouraged to play with the parameters of the animation, specially
    the time interval, `dt`; the maximum time, `tmax`; and the `time.sleep()` parameter.
    A bit of trial-and-error is needed to get satisfactory animation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励读者调整动画的参数，特别是时间间隔`dt`、最大时间`tmax`和`time.sleep()`参数。需要一些反复试验才能获得令人满意的动画效果。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use matplotlib to produce presentation-quality
    plots. We covered two-dimensional plots and how to set plot options, and annotate
    and configure plots. You also learned how to add labels, titles, and legends.
    We also learned how to draw three-dimensional surface plots and how to create
    simple animations.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用matplotlib制作演示质量的图形。我们介绍了二维图形，如何设置图形选项、注释以及配置图形。你还学习了如何添加标签、标题和图例。我们还学习了如何绘制三维曲面图以及如何创建简单的动画。
- en: In the next chapter, we will explore how to work with data in the notebook using
    the pandas library.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索如何使用pandas库处理笔记本中的数据。
