- en: Chapter 2. Fundamentals – Formats, Types, and Encodings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。基础知识 - 格式、类型和编码
- en: 'A few years ago, I received a very interesting present at my family''s annual
    holiday gift exchange. It was a *garde manger* kitchen toolset that included a
    bunch of different knives as well as peelers, scoops, and zesters used to prepare
    vegetables and fruits. I learned to use each of the tools, and over time, I developed
    a special fondness for the channel knife and the tomato shark. This chapter is
    like your introductory data cleaning toolset. We will review:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，在我家每年一度的节日礼物交换活动中，我收到了一件非常有趣的礼物。那是一个*garde manger*厨房工具套装，包括各种不同的刀具以及削皮器、勺子和去皮器，用于准备蔬菜和水果。我学会了使用每一个工具，随着时间的推移，我对槽刀和番茄刀特别喜爱。本章就像是你的入门数据清理工具集。我们将审视：
- en: File formats, including compression standards
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件格式，包括压缩标准
- en: The fundamentals of data types (including different types of missing data)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型的基础知识（包括不同类型的缺失数据）
- en: Character encodings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符编码
- en: We will need all these fundamentals as we progress to later chapters. Some of
    the concepts that we'll cover are so basic that you'll encounter them nearly every
    day, such as compression and file formats. These are so common; they are like
    a chef's knife. But some of these concepts, like character encodings, are more
    special-purpose and exotic, like a tomato shark!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入后面的章节，我们将需要所有这些基础知识。我们将覆盖一些概念，它们如此基础，以至于你几乎每天都会遇到，例如压缩和文件格式。这些是如此常见，就像厨师的刀一样。但是一些概念，如字符编码，更具特殊用途和异国情调，就像番茄刀一样！
- en: File formats
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件格式
- en: This section describes the different file formats any data scientist is likely
    to encounter when dealing with data found in the wild—in other words, the kind
    of data you will *not* find in those carefully constructed datasets that so many
    books rely on. Here, we encounter some strategies and limitations to interacting
    with the most common file formats, and then we review the various compression
    and archiving formats you are likely to run into.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了数据科学家在处理野外数据时可能遇到的不同文件格式，换句话说，那些精心构建的数据集中不会出现的数据类型。在这里，我们遇到了与最常见的文件格式交互的一些策略和限制，然后我们回顾了各种压缩和存档格式。
- en: Text files versus binary files
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本文件与二进制文件的区别
- en: 'When collecting data from online sources, you are likely to encounter data
    in one of these ways:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当从在线来源收集数据时，你可能会以以下一种方式遇到数据：
- en: The data will be downloadable in a file
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据将以文件形式可供下载
- en: The data will be available via an interactive frontend to a storage system,
    for example, via a database system with a query interface
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据将通过交互式前端提供给存储系统，例如通过带有查询接口的数据库系统
- en: The data will be available through a continuous stream
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据将通过连续流的形式提供
- en: The data will be available through an **Application Programming Interface**
    (**API**).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据将通过**应用程序编程接口**（**API**）提供。
- en: In any case, you may find yourself needing to create data files later on in
    order to share with others. Therefore, a solid foundation of the various data
    formats and their strengths and weaknesses is important.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，你可能会发现自己需要稍后创建数据文件以便与他人分享。因此，对各种数据格式及其优缺点有坚实的基础是很重要的。
- en: First, we can think of computer files as belonging to two broad groups, commonly
    called **text files** and **binary files**. As all files consist of a sequence
    of bytes, one right after the other, strictly speaking, all files are binary.
    But if the bytes in the file are all text characters (for example, letters, numbers,
    and some control characters such as newlines, carriage returns, or tabs), then
    we say the file is a text file. In contrast, binary files are those files that
    contain bytes made up of mostly non-human-readable characters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以将计算机文件视为属于两大类，通常称为**文本文件**和**二进制文件**。严格来说，所有文件都由一系列字节组成，依次排列，因此严格地说，所有文件都是二进制的。但是如果文件中的字节全部都是文本字符（例如字母、数字以及一些控制字符，如换行符、回车符或制表符），那么我们称该文件为文本文件。相反，二进制文件则是那些包含大多数非人类可读字符的字节的文件。
- en: Opening and reading files
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开和读取文件
- en: Text files can be read and written by a program called a text editor. If you
    try to open a file in a text editor and you can read it successfully (even if
    you do not understand it), then it is probably a text file. However, if you open
    the file in a text editor and it just looks like a jumble of garbled characters
    and weird illegible symbols, then it is probably a binary file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件可以通过叫做文本编辑器的程序进行读取和写入。如果你尝试在文本编辑器中打开一个文件并成功读取（即使你不理解它），那么它可能是一个文本文件。然而，如果你在文本编辑器中打开文件，看到的只是一些杂乱无章的字符和难以辨认的符号，那么它很可能是一个二进制文件。
- en: Binary files are intended to be opened or edited with a particular application,
    not by a text editor. For example, a Microsoft Excel spreadsheet is intended to
    be opened and read by Microsoft Excel, and a photograph taken by a digital camera
    can be read by a graphics program, such as Photoshop or Preview. Sometimes, binary
    files can be read by multiple compatible software packages, for example, many
    different graphics programs can read and edit photos and even binary files designed
    for a proprietary format, such as Microsoft Excel or Microsoft Word files, can
    be read and edited by compatible software, such as Apache OpenOffice. There are
    also programs called binary editors, which will let you peek inside a binary file
    and edit it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件是为了通过特定的应用程序打开或编辑，而不是通过文本编辑器。例如，Microsoft Excel 表格是为了在 Microsoft Excel
    中打开和读取的，数字相机拍摄的照片可以通过图形程序读取，如 Photoshop 或 Preview。有时，二进制文件可以通过多个兼容的软件包读取，例如，许多不同的图形程序可以读取和编辑照片，甚至为专有格式设计的二进制文件，例如
    Microsoft Excel 或 Microsoft Word 文件，也可以通过兼容的软件读取和编辑，如 Apache OpenOffice。还有一些程序叫做二进制编辑器，可以让你查看二进制文件内部并进行编辑。
- en: Sometimes, text files are also intended to be read by an application, yet you
    can still read them in a text editor. For example, web pages and computer source
    code consist of only text characters and can easily be edited in a text editor,
    yet they are difficult to understand without some training in the particular format,
    or layout, of the text itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，文本文件也旨在被应用程序读取，但你仍然可以在文本编辑器中读取它们。例如，网页和计算机源代码仅由文本字符组成，可以轻松在文本编辑器中编辑，但没有一定的格式或布局训练，很难理解。
- en: 'It is usually possible to know what type of file you have even without opening
    it in an editor. For example, most people look for clues about the file, starting
    with the file''s own name. Three-letter and four-letter file extensions are a
    common way to indicate the type of file it is. Common extensions that many people
    know include:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，即使不在编辑器中打开文件，也可以知道你拥有的是什么类型的文件。例如，大多数人会根据文件名寻找线索。三位数和四位数的文件扩展名是指示文件类型的常见方式。许多人都知道的常见扩展名包括：
- en: '`.xlsx` for Excel files, `.docx` for Word files, `.pptx` for Powerpoint files'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.xlsx` 用于 Excel 文件，`.docx` 用于 Word 文件，`.pptx` 用于 PowerPoint 文件'
- en: '`.png`, `.jpg`, and `.gif` for image files'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.png`、`.jpg` 和 `.gif` 用于图像文件'
- en: '`.mp3`, `.ogg`, `.wmv`, and `.mp4` for music and video files'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.mp3`、`.ogg`、`.wmv` 和 `.mp4` 用于音乐和视频文件'
- en: '`.txt` for text files'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.txt` 用于文本文件'
- en: There are also several websites that list file extensions and the programs that
    are affiliated with these particular extensions. One such popular site is [fileinfo.com](http://fileinfo.com),
    and Wikipedia also has an alphabetical list of file extensions available at [https://en.wikipedia.org/wiki/List_of_filename_extensions_(alphabetical)](https://en.wikipedia.org/wiki/List_of_filename_extensions_(alphabetical)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些网站列出了文件扩展名以及与这些特定扩展名关联的程序。一个受欢迎的网站是 [fileinfo.com](http://fileinfo.com)，维基百科也提供了一个按字母顺序排列的文件扩展名列表，链接为
    [https://en.wikipedia.org/wiki/List_of_filename_extensions_(alphabetical)](https://en.wikipedia.org/wiki/List_of_filename_extensions_(alphabetical))。
- en: Peeking inside files
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看文件内容
- en: If you must open an unknown file to peek inside, there are several command-line
    options you can use to see the first few bytes of the file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须打开一个未知文件以查看其内容，有几种命令行选项可以让你查看文件的前几个字节。
- en: On OSX or Linux
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 OSX 或 Linux 系统上
- en: 'On an OSX Mac or in Linux, go to your terminal window (on Mac, you can find
    the standard terminal application available by navigating to **Applications**
    | **Utilities** | **Terminal**), navigate to the location of your file using a
    combination of the print working directory (`pwd`) and change directory (`cd`)
    commands, and then use the `less` command to view the file page by page. Here
    is what my commands to perform this task looked like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OSX Mac 或 Linux 中，打开终端窗口（在 Mac 中，你可以通过导航到 **应用程序** | **实用工具** | **终端** 来找到标准的终端应用程序），使用打印当前工作目录（`pwd`）和更改目录（`cd`）命令导航到文件所在位置，然后使用
    `less` 命令逐页查看文件。以下是我执行此操作时的命令：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you are prompted to "view anyway", then the file is binary and you should
    prepare yourself to see garbled characters. You can type `y` to see the file or
    just type `n` to run in the other direction. The next figure shows you the result
    of viewing a file called `OlympicAthletes_0.xlsx` using the `less` command, as
    shown in the dialogue. What a mess!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统提示你“仍然查看”，那么该文件是二进制文件，你应该做好看到乱码的准备。你可以输入 `y` 来查看文件，或者输入 `n` 来退出。下图展示了使用
    `less` 命令查看名为 `OlympicAthletes_0.xlsx` 的文件的结果，如对话框所示。真是一团乱麻！
- en: '![On OSX or Linux](img/image00233.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![在 OSX 或 Linux 上](img/image00233.jpeg)'
- en: When you are done looking at it, you can type `q` to quit the `less` program.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 查看完后，你可以输入 `q` 来退出 `less` 程序。
- en: On Windows
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Windows 上
- en: Windows has the `more` program available in its Command Prompt application as
    well. It works similarly to the `less` command described earlier (after all, *less
    is more*). You can access the Windows Command Prompt with **cmd** from the **Start**
    menu in Windows 7\. In Windows 8, navigate to **Apps** | **Windows System** |
    **Command Prompt**. You can use `cd` and `pwd` to navigate to your file the same
    way as we did in the preceding example.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 的命令提示符中也有 `more` 程序。它的功能与前面描述的 `less` 命令类似（毕竟，*less is more*）。你可以通过
    **开始** 菜单中的 **cmd** 访问 Windows 命令提示符。在 Windows 8 中，导航到 **应用程序** | **Windows 系统**
    | **命令提示符**。你可以像前面的示例中那样使用 `cd` 和 `pwd` 来导航到你的文件。
- en: Common formats for text files
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的文本文件格式
- en: In this book, we are mostly concerned with text files rather than binary files.
    (Some special exceptions include compressed and archived files, which we will
    cover in the next section, and Excel and PDF files, each of which have their own
    chapters later in this book.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中，我们主要关注的是文本文件，而不是二进制文件。（一些特殊例外包括压缩文件和归档文件，我们将在下一节讨论；Excel 和 PDF 文件，它们各自有独立的章节讨论。）
- en: 'The three main types of text files we will be concerned with in this book are:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们关注的三种主要文本文件类型是：
- en: The delimited format (structured data)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分隔符格式（结构化数据）
- en: The JSON format (semi-structured data)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 格式（半结构化数据）
- en: The HTML format (unstructured data)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML 格式（非结构化数据）
- en: These files differ in layout (they just look different when we read them), and
    also in terms of how predictable their structures are. In other words, how much
    of the file is organized and has structured data? And how much of the data in
    the file is irregular or unstructured? Here, we discuss each of these text file
    formats individually.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件在布局上有所不同（它们在我们阅读时看起来不同），在结构的可预测性方面也有所差异。换句话说，文件中有多少部分是有组织且结构化的数据？文件中的数据有多少是无规律或非结构化的？在这里，我们将逐一讨论这些文本文件格式。
- en: The delimited format
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分隔符格式
- en: Delimited files are extremely common as a way to share and transfer data. Delimited
    format files are just text files in which each data attribute (each *column*)
    and each instance of the data (each *row*) are separated by a consistent character
    symbol. We call the separator characters **delimiters**. The two most common delimiters
    are tabs and commas. These two common choices are reflected in the **Tab Separated
    Values** (**TSV**) and **Comma Separated Values** (**CSV**) file extensions, respectively.
    Sometimes, delimited files are also called **record-oriented** files, as the assumption
    is that each row represents a record.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符文件是非常常见的一种数据共享和传输方式。分隔符格式文件就是每个数据属性（每个 *列*）和每个数据实例（每个 *行*）通过一个一致的字符符号进行分隔的文本文件。我们称这些分隔符为
    **分隔符**。最常见的两个分隔符是制表符和逗号。这两种常见选择分别反映在 **制表符分隔值**（**TSV**）和 **逗号分隔值**（**CSV**）的文件扩展名中。有时，分隔符文件也被称为
    **面向记录** 文件，因为假设每一行代表一个记录。
- en: 'Below are three instances of some data (three rows describing people), with
    data values separated by commas. The first row lists the names of the columns.
    This first row is also called the **header row**, and it has been highlighted
    in the data to show it more clearly:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是三组数据实例（三行描述人名），数据值由逗号分隔。第一行列出了列名，这一行也被称为**表头行**，它在数据中被突出显示以便更清晰地查看：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that with this example of delimited data, there is no *non-data* information.
    Everything is either a row or a data value. And the data is highly structured.
    Yet, there are still some options that can differentiate one delimited format
    from another. The first differentiator is how each instance of the data (each
    row) is separated. Usually at the end of a line, a new line, or a carriage return,
    or both are used depending on the operating environment in use during the creation
    of the file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个分隔数据的例子中，*没有非数据*的信息。每一项内容都是一行或一个数据值，而且数据高度结构化。然而，仍然有一些选项可以区分不同的分隔格式。第一个区分点是数据的每一实例（每一行）是如何分隔的。通常，在行末使用换行符、回车符，或者两者结合，这取决于在创建文件时使用的操作环境。
- en: Seeing invisible characters
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看不可见字符
- en: In the preceding example, the new line or carriage return is invisible. How
    do you see the invisible characters? We will read the same file in Text Wrangler
    on a Mac (similar full-featured editors such as Notepad++ are available for Windows),
    where we can use the **Show invisibles** option (located by navigating to **View**
    | **Text Display**).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，换行符或回车符是不可见的。如何查看这些不可见字符呢？我们将在Mac上的Text Wrangler中读取相同的文件（类似的功能强大的编辑器如Notepad++也适用于Windows），在这里我们可以使用**显示不可见字符**选项（通过导航到**查看**
    | **文本显示**来启用）。
- en: '![Seeing invisible characters](img/image00234.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![查看不可见字符](img/image00234.jpeg)'
- en: 'Another way to view the invisible characters is to use `vi` (a command-line
    text editor) on a Linux system or in the Terminal window on a Mac (this is not
    available on a Windows machine, by default). The process to view the invisible
    characters in a file using `vi` is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 查看不可见字符的另一种方法是在Linux系统或Mac的终端窗口中使用`vi`（在Windows机器上默认不可用）。使用`vi`查看文件中不可见字符的过程如下：
- en: 'First, use the command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令：
- en: '`vi <filename>`'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`vi <filename>`'
- en: Then, type `:` to enter the `vi` edit mode.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，输入`:`进入`vi`编辑模式。
- en: Then, type `set list` and press *Enter* to view the invisible characters.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，输入`set list`并按*回车*查看不可见字符。
- en: The following screenshot shows the end-of-line characters that are revealed
    by `set list` in `vi`, showing line termination symbol $.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`vi`中通过`set list`揭示的行结束符，显示了行终止符号$。
- en: '![Seeing invisible characters](img/image00235.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![查看不可见字符](img/image00235.jpeg)'
- en: Enclosing values to trap errant characters
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用符号括起来的值以防止字符错误
- en: 'Another important option with delimited files is what character to use to enclose
    each value being separated. For example, comma-separated values are great unless
    you have numeric values with commas as the thousands separator. Consider the following
    example, where the salaries were given commas as their thousands separator, but
    commas are also the delimiter:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔文件的另一个重要选项是使用什么字符来括住每个被分隔的值。例如，逗号分隔值非常好，但如果你的数字值中包含逗号作为千位分隔符呢？考虑以下例子，其中薪资值的千位分隔符用了逗号，而逗号又是分隔符：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'How can this be fixed at the point of file creation? Well, we have two options:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在文件创建时修复这个问题？好吧，我们有两个选项：
- en: '**Option 1**: The person creating the delimited file would need to remove the
    commas in the final column before creating this table (in other words, no commas
    in salary amounts)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项 1**：创建分隔文件的人需要在创建表格之前移除最后一列中的逗号（换句话说，薪资金额中不能有逗号）。'
- en: '**Option 2**: The person creating this file would need to use an additional
    symbol to enclose the data values themselves.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项 2**：创建这个文件的人需要使用额外的符号来括起数据值。'
- en: If option 2 is chosen, typically, a double quote separator is then added to
    enclose data values. So, `129,000` on the first line would become `"129,000"`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择了选项2，通常会添加双引号分隔符来括住数据值。所以，第一行的`129,000`会变成`"129,000"`。
- en: Escaping characters
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转义字符
- en: 'What if the data itself has quotation marks in it? What if Sally''s favorite
    color were listed and shown as `light "Carolina" blue`? Take a look:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据本身包含引号呢？比如Sally最喜欢的颜色是`light "Carolina" blue`？看看这个例子：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Internal quotation marks will have to be escaped through the use of another
    special character, the backslash `\`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 内部引号必须通过使用另一个特殊字符——反斜杠 `\` 来转义：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Or, we could try encapsulating with a single quote instead of double quotes,
    but then we might have issues with possessives such as "it's" or names such as
    O'Malley. There's always something!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以尝试用单引号来替代双引号进行封装，但那样我们可能会遇到拥有所有格的情况，比如“it's”或者像O'Malley这样的名字。总是会有些问题！
- en: Delimited files are very convenient in that they are easy to understand and
    easy to access in a simple text editor. However, as we have seen, they also require
    a bit of planning in advance in order to ensure that the data values are truly
    separated properly and everything is formatted the way it was intended.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔文件非常方便，因为它们容易理解，并且可以在简单的文本编辑器中轻松访问。然而，正如我们所见，它们也需要提前进行一些规划，以确保数据值能够正确地分隔，并且一切格式都按照预期进行。
- en: If you find yourself the unlucky recipient of a file with delimiting errors
    such as the preceding ones, we'll give you some tricks and tips in [Chapter 3](part0024.xhtml#aid-MSDG2
    "Chapter 3. Workhorses of Clean Data – Spreadsheets and Text Editors"), *Workhorses
    of Clean Data – Spreadsheets and Text Editors*, for how to clean them up.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不幸收到一个包含分隔错误的文件，就像前面那些错误一样，我们将在[第 3 章](part0024.xhtml#aid-MSDG2 "第 3 章。清洁数据的工作马——电子表格和文本编辑器")中为你提供一些技巧和窍门，*清洁数据的工作马——电子表格和文本编辑器*，帮助你清理这些问题。
- en: The JSON format
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 格式
- en: '**JavaScript Object Notation** (**JSON**), pronounced *JAY-sahn*, is one of
    the more popular formats for what is sometimes called semi-structured data. Contrary
    to the implications in its name, JSON is not dependent upon JavaScript to be useful.
    The name refers to the fact that it was designed to serialize JavaScript objects.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript 对象表示法**（**JSON**），发音为 *JAY-sahn*，是用于所谓的半结构化数据的流行格式之一。与其名字中的含义相反，JSON
    并不依赖于 JavaScript 才能使用。这个名字指的是它最初是为了序列化 JavaScript 对象而设计的。'
- en: 'A collection of data can be called semi-structured when its data values are
    labeled, but their order does not matter, and in fact, some of the data values
    may even be missing. A JSON file is just a collection of attribute-value pairs,
    such as this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当一组数据的值被标记，但其顺序不重要，甚至某些数据值可能缺失时，这组数据可以称为半结构化数据。一个 JSON 文件就是一组属性-值对，像这样：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The attributes are on the left-hand side of the colon, and the values are on
    the right-hand side. Each attribute is separated by a comma. The entire entity
    is enclosed in curly braces.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 属性位于冒号的左边，值位于右边。每个属性之间用逗号分隔。整个实体被大括号包围。
- en: A few things about JSON are similar to delimited files, and a few things are
    different. First, string values must be double-quoted, and therefore, any double
    quotes internal to a string must be escaped with a backslash. (The escape character
    \ , when used as a regular character, must also be escaped!)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些关于 JSON 的特点与分隔文件相似，也有一些不同。首先，字符串值必须用双引号括起来，因此字符串内部的任何双引号必须用反斜杠转义。（当反斜杠作为普通字符使用时，也必须进行转义！）
- en: In JSON, commas cannot be included in numeric values unless the values are treated
    as strings and properly quoted. (Be careful when stringifying numbers, though—are
    you sure you want to do that? Then, refer to the *Data types* section in this
    chapter, which can help you with these issues.)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 中，数字值不能包含逗号，除非这些值被当作字符串处理并正确地用引号括起来。（不过，在将数字转换为字符串时要小心——你确定要这么做吗？那么，请参考本章的
    *数据类型* 部分，它可以帮助你解决这些问题。）
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Multivalue attributes are acceptable, as are hierarchical values (neither of
    these are available very easily with delimited files). Here is an example of a
    JSON file with a multivalue attribute for `pet` and a hierarchy of data for `jobTitle`.
    Note that we''ve moved the `salary` data inside this new `job` hierarchy:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 多值属性是可以接受的，层次结构值也可以使用（这些在分隔文件中很难做到）。这里有一个 JSON 文件的示例，包含一个 `pet` 的多值属性和一个 `jobTitle`
    的层次数据。请注意，我们已将 `salary` 数据移入这个新的 `job` 层次结构中：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Experimenting with JSON
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JSON 实验
- en: JSON is an extremely popular choice of data exchange format because of its extensibility,
    simplicity, and its support for multivalue attributes, missing attributes, and
    nested attributes / hierarchies of attributes. The increasing popularity of APIs
    for distributing datasets has also contributed to JSON's usefulness.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是一种非常流行的数据交换格式，因其可扩展性、简洁性以及对多值属性、缺失属性和嵌套属性/层次结构属性的支持而受到青睐。API 在分发数据集方面的日益流行也推动了
    JSON 的实用性。
- en: 'To see an example of how an API uses a search term to produce a **dataset**
    encoded in JSON, we can experiment with the iTunes API. iTunes is a music service
    run by Apple. Anyone can query the iTunes service for details about songs, artists,
    and albums. Search terms can be appended onto the iTunes API URL as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看API如何使用搜索词生成以JSON编码的**数据集**示例，我们可以尝试使用iTunes API。iTunes是由Apple运营的音乐服务。任何人都可以查询iTunes服务，获取有关歌曲、艺术家和专辑的详细信息。搜索词可以附加到iTunes
    API的URL上，如下所示：
- en: '[https://itunes.apple.com/search?term=the+growlers](https://itunes.apple.com/search?term=the+growlers)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://itunes.apple.com/search?term=the+growlers](https://itunes.apple.com/search?term=the+growlers)'
- en: In this URL, everything after the `=` sign is a search term. In this case, I
    searched for a band I like, called The Growlers. Note that there is a + sign to
    represent the space character, as URLs do not allow spaces.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个URL中，`=`符号后面的部分是搜索词。在这种情况下，我搜索了一个我喜欢的乐队，叫做The Growlers。请注意，`+`符号代表空格字符，因为URL不允许使用空格。
- en: The iTunes API returns 50 results from its music database for my search keywords.
    The entire set is formatted as a JSON object. As with all JSON objects, it is
    formatted as a collection of **name-value** pairs. The JSON returned in this example
    appears very long, because there are 50 results returned, but each result is actually
    very simplistic—there are no multivalue attributes or even any hierarchical data
    in the iTunes data shown in this URL.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: iTunes API根据我的搜索关键词从其音乐数据库返回50个结果。整个结果集被格式化为一个JSON对象。与所有JSON对象一样，它被格式化为一组**名称-值**对。由于返回了50个结果，因此此示例中的JSON看起来非常长，但每个结果实际上非常简单——iTunes数据中没有多值属性或任何层次结构的数据，显示在此URL中的数据也是如此。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more details on how to use the iTunes API, visit the Apple iTunes developer
    documentation at [https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html](https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于如何使用iTunes API的信息，请访问Apple iTunes开发者文档：[https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html](https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html)。
- en: The HTML format
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML格式
- en: HTML files, or web page files, are another type of text file that often have
    a lot of juicy data in them. How many times have you seen an interesting table,
    or list of information on a website, and wanted to save the data? Sometimes, copying
    and pasting works to try to create a delimited file from the web page, but most
    of the time, copying and pasting does not work effectively. HTML files can be
    terribly messy and thus, are a potentially painful way to extract data. For this
    reason, sometimes, we refer to web files as unstructured data. Even though web
    pages may have some HTML tags that could be used to attempt a delimiting type
    of pattern-based organization of data, they don't always. And there is also a
    lot of room for error in how these various HTML tags are applied, both across
    different websites and even within the same website.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文件，或者说网页文件，是另一种文本文件，通常包含很多有用的数据。你是否曾在网站上看到过有趣的表格或信息列表，想要保存这些数据？有时，复制和粘贴可以用来尝试从网页创建分隔文件，但大多数时候，复制和粘贴并不能有效工作。HTML文件可能非常混乱，因此，它们可能是提取数据的痛苦方式。出于这个原因，有时我们称网页文件为非结构化数据。尽管网页可能有一些HTML标签，可以尝试基于模式的分隔数据组织，但它们并不总是这么做。而且这些HTML标签的应用也有很多出错的空间，无论是在不同的网站之间，还是在同一个网站内。
- en: The following figure shows just a small portion of the [http://weather.com](http://weather.com)
    website. Even though there are pictures and colors and other non-text things in
    this screenshot, at its base level, this web page is written in HTML, and if we
    want to pull text data out of this page, we can do that.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了[http://weather.com](http://weather.com)网站的一小部分。即使截图中有图片、颜色和其他非文本元素，但在其基本层面，这个网页是用HTML编写的，如果我们想从这个页面提取文本数据，我们是可以做到的。
- en: '![The HTML format](img/image00236.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![HTML格式](img/image00236.jpeg)'
- en: 'If we view the HTML source for the web page, we can locate a few lines of the
    nearly 1,000 lines of HTML code that comprise the data and layout instructions
    for the browser to show that particular weather table:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看网页的HTML源代码，我们可以找到包含约1,000行HTML代码的几行，这些代码包含了数据和布局指令，供浏览器显示该特定天气表格：
- en: '![The HTML format](img/image00237.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![HTML格式](img/image00237.jpeg)'
- en: Unstructured indeed! Of course, it is technically possible to pull the data
    value `43` (for the temperature in Fahrenheit) from this page, but it's not going
    to be a fun process, and we have no guarantee that our method to do that will
    be the same tomorrow or the day after that, as [http://weather.com](http://weather.com)
    could change the source code for the site at any moment. Nonetheless, there is
    a ton of data on the Web, so in [Chapter 5](part0033.xhtml#aid-VF2I1 "Chapter 5. Collecting
    and Cleaning Data from the Web"), *Collecting and Cleaning Data from the Web*,
    we cover a few strategies to extract data from web-based, unstructured files.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 确实是无结构的！当然，从技术上讲，可以从这个页面提取数据值 `43`（例如华氏温度），但这将不是一个愉快的过程，而且我们无法保证明天或后天我们的方法仍然有效，因为
    [http://weather.com](http://weather.com) 随时可能更改该站点的源代码。尽管如此，网上有大量的数据，因此在[第5章](part0033.xhtml#aid-VF2I1
    "第5章 收集和清理来自网络的数据")，*收集和清理来自网络的数据*，我们讨论了几种从基于 Web 的非结构化文件中提取数据的策略。
- en: Archiving and compression
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归档和压缩
- en: When is a text file also a binary file? When it's been compressed or archived,
    of course. What are archiving and compression? In this section, we'll learn what
    file archives and compressed files are, how archiving and compression work, and
    the various standards for each.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 什么情况下文本文件也会是二进制文件？当然是在它被压缩或归档之后。什么是归档和压缩？在这一节中，我们将学习什么是文件归档和压缩文件，归档和压缩是如何工作的，以及它们各自的不同标准。
- en: This is an important section as a lot of real-world data (especially, delimited
    data) will be compressed when you find it out in the real world. What are the
    most common compression formats that you as a data scientist are likely to run
    into? We will definitely find the answer to this question. You might also want
    to compress your data when you share it with others. How can you figure out which
    compression method is the best choice?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分非常重要，因为在实际应用中，许多真实世界的数据（尤其是分隔符数据）都会在您找到它时被压缩。作为数据科学家，您最常遇到的压缩格式是什么？我们一定会找到这个问题的答案。您可能还想在与他人共享数据时对其进行压缩。如何确定哪种压缩方法是最适合的选择？
- en: Archive files
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归档文件
- en: An archive file is simply a single file that contains many files inside it.
    The files inside can be either text or binary or a mixture of both. Archive files
    are created by a special program that takes a list of files and changes them into
    a single file. Of course, the archive files are created in such a way that they
    can be expanded back into many files.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 归档文件只是一个包含多个文件的单一文件。文件内部可以是文本文件、二进制文件，或者两者的混合。归档文件是由一个特殊程序创建的，该程序会将文件列表转化为一个单一的文件。当然，归档文件的创建方式使得它们可以被展开回多个文件。
- en: tar
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tar
- en: The most common archived files that you are likely to encounter when doing data
    science work are so-called **Tape ARchive** (**TAR**) files, created using the
    tar program and usually given a `.tar` extension. Their original purpose was to
    create archives of magnetic tapes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行数据科学工作时，您最常遇到的归档文件是所谓的**磁带归档**（**TAR**）文件，它们是通过 tar 程序创建的，通常以 `.tar` 为扩展名。它们的最初用途是创建磁带的归档。
- en: The tar program is available on Unix-like operating systems, and we can access
    it in the Mac OSX Terminal as well.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: tar 程序在类 Unix 操作系统上可用，我们也可以在 Mac OSX 终端中访问它。
- en: To create a tar file, you simply instruct the tar program which files you want
    included and what the output file name should be. (Program option `c` is used
    to indicate that we're creating a new archive file, and option `v` prints the
    filenames as they are extracted. The `f` option lets us specify the name of the
    output file.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 tar 文件，您只需指示 tar 程序包含哪些文件以及输出文件的名称是什么。（程序选项`c`用于指示我们正在创建一个新的归档文件，选项`v`会在提取文件时打印文件名。`f`选项让我们指定输出文件的名称。）
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To "untar" a file (or expand it into the full listing of all the files), you
    just direct the tar program to the file you want expanded. The `x` letter in `xvf`
    stands for eXtract:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要“解开”一个文件（或将其扩展为所有文件的完整列表），您只需将 tar 程序指向您想要展开的文件。`x` 字母在 `xvf` 中代表 eXtract：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, a `.tar` archive file includes multiple files, but how many and what are
    the files? You''ll want to make sure that before you start extracting files, you
    have enough available disk space and that the files are really what you wanted
    to begin with. The `t` option in the tar command will show a list of the files
    inside a tar file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`.tar` 归档文件包含多个文件，但有多少个文件？这些文件是什么？在开始提取文件之前，您需要确保有足够的磁盘空间，并且这些文件确实是您一开始想要的。tar
    命令中的 `t` 选项会显示 tar 文件中包含的文件列表：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are many more archive programs apart from tar, but some of the interesting
    ones (for example, the built-in archiving ZIP compressor on OSX and the various
    ZIP and RAR utilities on Windows) also perform compression on the files, in addition
    to archiving, so we should probably discuss this concept next.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 tar，还有许多其他归档程序，但一些有趣的程序（例如，OSX 上内置的 ZIP 压缩工具，以及 Windows 上的各种 ZIP 和 RAR 工具）不仅可以归档文件，还能对文件进行压缩，所以我们接下来应该讨论这个概念。
- en: Compressed files
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩文件
- en: Compressed files are those files that have been made smaller so that they will
    take up less space. Smaller files mean less storage space on the disk and a faster
    transfer time if the file needs to be shared over the network. In the case of
    data files, like the ones we are interested in, the assumption is that the compressed
    file can be easily uncompressed back to the original.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩文件是指那些已经被压缩以减少空间占用的文件。较小的文件意味着更少的磁盘存储空间，并且如果文件需要通过网络共享，传输时间也会更快。对于数据文件而言，像我们关注的文件，假设压缩文件可以很容易地解压回原始状态。
- en: How to compress files
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何压缩文件
- en: 'There are numerous ways of creating compressed files, and which one you choose
    will depend on the operating system you are using and what compression software
    you have installed. On OSX, for example, any file or folder (or group) can easily
    be compressed by selecting it in **Finder**, right-clicking on it, and choosing
    **Compress** from the menu. This action will create a compressed (`.zip` extension)
    file in the same directory as the original file. This is shown in the following
    image:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建压缩文件的方法有很多，选择哪种方法取决于你使用的操作系统以及你安装了什么压缩软件。例如，在 OSX 上，任何文件或文件夹（或组）都可以通过在 **Finder**
    中选择它，右键单击并从菜单中选择 **压缩** 来轻松压缩。此操作将在与原始文件相同的目录中创建一个压缩（`.zip` 扩展名）文件。下图展示了这一过程：
- en: '![How to compress files](img/image00238.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![如何压缩文件](img/image00238.jpeg)'
- en: How to uncompress files
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何解压文件
- en: The collection step of the data science process will often include downloading
    compressed files. These might be delimited text files, such as the ones we described
    earlier in this chapter, or they might be files containing multiple types of data
    files, such as spreadsheets or SQL commands used to build a database.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学过程中的收集步骤通常会包括下载压缩文件。这些文件可能是带有分隔符的文本文件，就像我们在本章前面描述的那样，或者可能是包含多种数据文件的文件，例如电子表格或用于构建数据库的
    SQL 命令。
- en: In any case, uncompressing a file returns the data to a state where we can use
    it to accomplish our goals. How do we know which program to use to uncompress
    the file? The first and biggest clue is the file's extension. This is a key tip-off
    as to what compression program created the file. Knowing how to uncompress the
    file is dependent on knowing how it was compressed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，解压文件会将数据恢复到我们可以用来实现目标的状态。我们如何知道使用哪个程序来解压文件呢？最大的线索是文件的扩展名。这是识别压缩文件所用程序的重要提示。知道如何解压文件取决于知道它是如何被压缩的。
- en: In Windows, you can see the installed program that is associated with your file
    extension by right-clicking on the file and choosing **Properties**. Then, look
    for the **Open With** option to see which program Windows thinks will uncompress
    the file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，你可以通过右键单击文件并选择 **属性** 来查看与文件扩展名关联的已安装程序。然后，查找 **打开方式** 选项，看看 Windows
    认为哪个程序可以解压该文件。
- en: The remainder of this section will outline how to use command-line programs
    on OSX or a Linux system.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分将概述如何在 OSX 或 Linux 系统上使用命令行程序。
- en: Compression with zip, gzip, and bzip2
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 zip、gzip 和 bzip2 进行压缩
- en: zip, gzip and bzip2 are the most common compression programs. Their uncompression
    partners are called Unzip, Gunzip, and Bunzip2, respectively.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: zip、gzip 和 bzip2 是最常见的压缩程序。它们的解压程序分别称为 Unzip、Gunzip 和 Bunzip2。
- en: The following table shows a sample command-line for compressing and uncompressing
    in each of these programs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了在这些程序中压缩和解压的示例命令行。
- en: '|   | Compress | Uncompress |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|   | 压缩 | 解压 |'
- en: '| --- | --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Zip** | **zip filename.csv filename.zip** | **unzip filename.zip** |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **Zip** | **zip filename.csv filename.zip** | **unzip filename.zip** |'
- en: '| **gzip** | **gzip filename.csv filename.gz** | **gunzip filename.gz** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **gzip** | **gzip filename.csv filename.gz** | **gunzip filename.gz** |'
- en: '| **bzip2** | **bzip2 filename.csv filename.bz2** | **bunzip2 filename.bz2**
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **bzip2** | **bzip2 filename.csv filename.bz2** | **bunzip2 filename.bz2**
    |'
- en: 'Sometimes, you will see a file that includes both a `.tar` and a `.gz` extension
    or a `.bz2` extension like this: `somefile.tar.gz`. Other combinations that are
    common include: `.tgz` and `.tbz2`, as in `somefile.tgz`. These are files that
    have been tarred (archived) first and then compressed using gzip or bzip2\. The
    reason for this is that gzip and bzip2 are not archiving programs; they are only
    compressors. Therefore, they can only compress a single file (or file archive)
    at a time. As tar''s job is to make multiple files into single files, these programs
    are found together very often.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会看到一个文件同时包含`.tar`和`.gz`扩展名，或者是`.bz2`扩展名，比如：`somefile.tar.gz`。其他常见的组合包括：`.tgz`和`.tbz2`，例如`somefile.tgz`。这些是首先使用tar进行归档（打包）后，再用gzip或bzip2进行压缩的文件。之所以这样，是因为gzip和bzip2并不是归档程序，它们只是压缩程序。因此，它们只能压缩单个文件（或文件归档）。而tar的作用是将多个文件合并成一个文件，所以这两种程序通常会一起使用。
- en: 'The tar program even has a built-in option that will gzip or bzip2 a file immediately
    after tarring it. To gzip the newly created `.tar` file, we can simply add `z`
    to the preceding tar command, and modify the filename:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: tar程序甚至有一个内置选项，可以在归档后立即gzip或bzip2文件。要对新创建的`.tar`文件进行gzip压缩，我们只需在之前的tar命令中添加`z`选项，并修改文件名：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or, you can do this in two steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以分两步进行操作：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This sequence of commands will create the `fileArchive.tar.gz` file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令序列将创建`fileArchive.tar.gz`文件：
- en: 'To uncompress a tar.gz file, use two steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要解压tar.gz文件，可以使用两步：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These steps also work for bzip2 files:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤同样适用于bzip2文件：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To uncompress a tar.bz2 file, use two steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要解压tar.bz2文件，可以使用两步：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compression options
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 压缩选项
- en: 'When compressing and uncompressing, there are many other options you should
    take into consideration in order to make your data cleaning job easier:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在压缩和解压缩时，有许多其他选项你应该考虑，以便让你的数据清理工作更轻松：
- en: Do you want to compress a file and also keep the original? By default, most
    compression and archiving programs will remove the original file. If you want
    to keep the original file and also create a compressed version of it, you can
    usually specify this.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要压缩文件并保留原文件吗？默认情况下，大多数压缩和归档程序会删除原文件。如果你想保留原文件并同时创建压缩版本，通常可以指定这一点。
- en: Do you want to add new files to an existing compressed file? There are options
    for this in most archiving and compression programs. Sometimes, this is called
    **updating** or **replacing**.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要向现有的压缩文件中添加新文件吗？大多数归档和压缩程序都提供了这个选项。有时，这个操作被称为**更新**或**替换**。
- en: Do you want to encrypt the compressed file and require a password to open it?
    Many compression programs provide an option for this.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想加密压缩文件并要求打开时输入密码吗？许多压缩程序提供了这个选项。
- en: When uncompressing, do you want to overwrite files in the directory with the
    same name? Look for a **force** option.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在解压时，你想要覆盖目录中同名的文件吗？可以寻找**强制**选项。
- en: Depending on which compression software you are using and what its options are,
    you can use many of these options to make the job of dealing with files easier.
    This is especially true with large files—either large in size or large in number!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的压缩软件以及其选项，你可以使用这些选项中的许多来简化文件处理的工作。尤其是在处理大文件时——无论是文件本身很大，还是文件数量很多！
- en: Which compression program should I use?
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我应该使用哪个压缩程序？
- en: The concepts in this section on archiving and compression are widely applicable
    for any operating system and any type of compressed data files. Most of the time,
    we will be downloading compressed files from somewhere, and our main concern will
    be uncompressing these files efficiently.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本节关于归档和压缩的概念在任何操作系统和任何类型的压缩数据文件中都有广泛的适用性。大多数情况下，我们将从某处下载压缩文件，我们的主要任务是高效地解压这些文件。
- en: 'However, what if you are creating compressed files yourself? What if you need
    to uncompress a data file, clean it, then recompress it and send it to a coworker?
    Or what if you are given a choice of files to download, each in a different compression
    format: zip, bz2, or gz? Which format should you choose?'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你自己创建压缩文件呢？如果你需要解压一个数据文件，清理它，然后重新压缩并发送给同事呢？或者如果你需要从多个压缩格式的文件中选择下载：zip、bz2或者gz格式？你该选择哪个格式？
- en: Assuming that we are in an operating environment that allows you to work with
    multiple compression types, there are a few rules of thumb for what the various
    strengths and weaknesses of the different compression types are.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们处在一个允许使用多种压缩类型的操作环境中，那么对于不同压缩类型的优缺点，有一些通用的经验法则。
- en: 'Some of the factors we use when making a compression decision are:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在做压缩决策时，我们使用的一些因素有：
- en: The speed of compressing and uncompressing
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩和解压缩的速度
- en: The compression ratio (how much smaller did the file get?)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩比率（文件缩小了多少？）
- en: The interoperability of the compression solution (can my audience easily decompress
    this file?)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩解决方案的互操作性（我的受众能轻松解压这个文件吗？）
- en: Rules of thumb
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 经验法则
- en: Gzip is faster to compress and decompress, and it is readily available on every
    OSX and Linux machine. However, some Windows users will not have a gunzip program
    readily available.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Gzip 在压缩和解压缩速度上更快，并且在每台 OSX 和 Linux 机器上都可以轻松使用。然而，一些 Windows 用户可能没有准备好使用 gunzip
    程序。
- en: Bzip2 makes smaller files than gzip and zip, but it takes longer to do so. It
    is widespread on OSX and Linux. Windows users will probably struggle to handle
    bzip2 files if they have not already installed special software.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Bzip2 压缩出的文件比 gzip 和 zip 小，但需要更长时间。它在 OSX 和 Linux 上使用广泛。如果 Windows 用户没有安装特殊软件，可能会遇到处理
    bzip2 文件的困难。
- en: Zip is readily available on Linux, OSX, and Windows, and its speed to compress
    and decompress is not terrible. However, it does not create very favorable compression
    ratios (other compressors make smaller files). Still, its ubiquity and relative
    speed (compared to bzip2, for example) are strong points in its favor.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Zip 在 Linux、OSX 和 Windows 上都很常见，压缩和解压缩的速度也不差。然而，它的压缩比率并不理想（其他压缩工具能压缩出更小的文件）。不过，Zip
    的普及度和相对较快的速度（与 bzip2 相比）是它的优势所在。
- en: RAR is a widely available archiving and compression solution for Windows; however,
    its availability for OSX and Linux requires special software, and its compression
    speed is not as good as some of the other solutions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: RAR 是一种广泛可用的 Windows 压缩和归档解决方案；然而，在 OSX 和 Linux 上使用时需要特殊软件，并且其压缩速度不如其他一些解决方案。
- en: Ultimately, you will have to decide on a compression standard based on the particular
    project you are working on and the needs of your audience or user, whether that
    is yourself, a customer, or a client.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你将不得不根据你正在从事的特定项目和受众或用户的需求来决定采用哪种压缩标准，无论这个用户是你自己、客户还是委托人。
- en: Data types, nulls, and encodings
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型、空值和编码
- en: This section provides an overview of the most common data types that data scientists
    must deal with on a regular basis and some of the variations between these types.
    We also talk about converting between data types and how to safely convert without
    losing information (or at least understanding the risks beforehand).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了数据科学家日常需要处理的最常见的数据类型，以及这些类型之间的一些差异。我们还讨论了数据类型之间的转换，以及如何安全地进行转换而不丢失信息（或至少提前了解风险）。
- en: This section also covers the mysterious world of empties, nulls, and blanks.
    We explore the various types of missing data and describe how missing data can
    negatively affect results of data analysis. We will compare choices and trade-offs
    for handling the missing data and some of the pros and cons of each method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本节还涵盖了空值、空对象和空白的神秘世界。我们探讨了缺失数据的各种类型，并描述了缺失数据如何负面影响数据分析结果。我们将比较处理缺失数据的不同选择和权衡，以及每种方法的优缺点。
- en: As much of our data will be stored as strings, we will learn to identify different
    character encodings and some of the common formats you will encounter with real-world
    data. We will learn how to identify character encoding problems and how to determine
    the proper type of character encoding for a particular dataset. We will write
    some Python code to convert from one encoding scheme to another. We will also
    cover the limitations of this strategy.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的大部分数据将以字符串形式存储，我们将学习如何识别不同的字符编码及一些你在实际数据中常遇到的格式。我们将学习如何识别字符编码问题，以及如何确定适合特定数据集的字符编码类型。我们还将编写一些
    Python 代码，将一种编码方案转换为另一种编码方案。我们还将讨论这种策略的局限性。
- en: Data types
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'Whether we are cleaning data stored in a text file, a database system, or in
    some other format, we will start to recognize the same types of data make an appearance
    over and over: numbers of various kinds, dates, times, characters, strings of
    characters, and more. The upcoming sections describe a few of the most common
    data types, along with some examples of each.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是在清理存储在文本文件、数据库系统还是其他格式中的数据，我们将开始识别出反复出现的相同类型的数据：各种各样的数字、日期、时间、字符、字符字符串等等。接下来的章节将描述一些最常见的数据类型，并给出每种类型的示例。
- en: Numeric data
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值数据
- en: In this section, we will discover that there are many ways to store a number,
    and some of them are easier to clean and manage than others. Still, numbers are
    fairly straightforward compared to strings and dates, so we will start with these
    before moving on to trickier data types.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将发现存储数字的方式有很多种，其中一些比其他方式更容易清理和管理。不过，相较于字符串和日期，数字的处理相对简单，因此我们将在处理更复杂的数据类型之前，先从数字开始。
- en: Integers
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 整数
- en: Integers, or whole numbers, can be positive or negative, and just like the name
    implies, they do not have decimal points or fractions. Depending on what kind
    of storage system the integers are stored in, for example, in a **Database Management
    System** (**DBMS**), we may also have additional information about how large an
    integer can be stored as well as whether it is allowed to be signed (positive
    or negative values) or only unsigned (all positive values).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 整数，或称为自然数，可以是正数或负数，正如名称所示，它们没有小数点或分数。根据整数存储的系统不同，例如在**数据库管理系统**（**DBMS**）中，我们还可能获得有关整数可以存储的最大大小，以及是否允许存储有符号（正负值）或仅无符号（全正值）的额外信息。
- en: Numbers with decimals
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带小数的数字
- en: In our data cleaning work, numbers with a fractional component—such as prices,
    averages, measurements, and the like—are typically expressed using a decimal point
    (rather than a numerator/denominator). Sometimes, the particular storage system
    in place also has rules specifying the number of digits that are allowed to come
    after the decimal point (**scale**) as well as the total number of digits allowed
    in the number (**precision**). For example, we say that the number 34.984 has
    a precision of 3 and a scale of 5.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据清理工作中，带有小数部分的数字——例如价格、平均值、测量值等——通常使用小数点表示（而不是分子/分母）。有时，所使用的存储系统也会规定小数点后允许的位数（**小数位数**）以及数字总位数的限制（**精度**）。例如，我们说数字34.984的精度为3，小数位数为5。
- en: Different data storage systems will also allow for different types of decimal
    numbers. For example, a DBMS may allow us to declare whether we will be storing
    floating-point numbers, decimal numbers, and currency/money numbers at the time
    we set up our database. Each of these will act slightly differently—in math problems,
    for instance. We will need to read the guidance provided by the DBMS for each
    data type and stay on top of changes. Many times, the DBMS provider will change
    the specifications for a particular data type because of memory concerns or the
    like.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的数据存储系统也允许不同类型的小数。例如，数据库管理系统（DBMS）可能允许我们在设置数据库时声明是否存储浮动点数字、小数数字以及货币/金额数字。每种类型的处理方式可能略有不同——例如在数学问题中。我们需要阅读DBMS为每种数据类型提供的指导，并密切关注变化。许多时候，DBMS提供商会因为内存问题或其他原因而改变特定数据类型的规格。
- en: Spreadsheet applications, on the other hand, unlike DBMS applications, are designed
    to display data in addition to just storing it. Therefore, we may actually be
    able to store a number in one format and display it in another. This can cause
    some confusion if formatting has been applied to data cells in a spreadsheet.
    The following figure shows an example of some decimal display properties being
    set for a cell. The formula bar shows the full number 34.984, but the cell shows
    that the number appears to have been rounded down.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，与DBMS应用程序不同，电子表格应用程序除了存储数据外，还设计用于显示数据。因此，我们可能会在一种格式下存储数字并以另一种格式显示它。如果在电子表格中的数据单元格应用了格式，这可能会引起一些困惑。以下图例显示了为某个单元格设置小数显示属性的示例。公式栏显示了完整的数字34.984，但单元格显示该数字似乎已被四舍五入。
- en: '![Numbers with decimals](img/image00239.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![带小数的数字](img/image00239.jpeg)'
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In many locations around the world, the comma character separates the decimal
    from the nondecimal portion of a number rather than a dot or period character.
    This is a good reminder that it is always worth inspecting the localization settings
    of the system you are on and making sure that they match the expectations of the
    data you are working with. For example, in OSX, there is a **Language & Region**
    dialogue located in the **Systems Preferences** menu. From here, you can change
    your localization settings if you need to.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在世界许多地方，逗号字符用于将数字的小数部分与非小数部分分开，而不是使用点或句点字符。这提醒我们，始终检查你所在系统的本地化设置，并确保它们符合你正在处理的数据的预期。例如，在OSX中，有一个**语言与地区**对话框，位于**系统偏好设置**菜单中。从这里，你可以根据需要更改本地化设置。
- en: Unlike in a DBMS, a raw text file has no options to specify the size or expectations
    of a number field, and unlike a spreadsheet, the text file has no display options
    for a given data value either. If a text file shows a value of 34.98, then that
    may be all we know about that number.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与DBMS不同，原始文本文件没有选项来指定数字字段的大小或期望，且与电子表格不同，文本文件对给定数据值也没有显示选项。如果一个文本文件显示了值34.98，那么这可能是我们对该数字的全部了解。
- en: When numbers are not numeric
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 当数字不是数字时
- en: 'Numeric data is first and foremost comprised of sequences of digits 0-9 and,
    sometimes, a decimal point. But a key point about true numeric data is that it
    is primarily designed to have calculations performed on it. We should choose numeric
    storage for our data when we expect to be able to *do math* on a data value, when
    we expect to compare one value to another numerically, or when we want items to
    be sorted in numeric order. In these cases, the data values need to be stored
    as numbers. Consider the following list of numbers sorted by their number value,
    low to high:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 数字数据首先由0-9的数字序列以及有时的十进制点组成。但关于真正的数字数据的一个关键点是，它主要是为了执行计算而设计的。当我们期望能够对数据值进行*数学运算*，期望对一个值与另一个值进行数值比较，或者当我们希望按数字顺序排序项目时，我们应选择数字存储方式。在这些情况下，数据值需要存储为数字。考虑以下按数值大小排序的数字列表，从小到大：
- en: '1'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1'
- en: '10'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '10'
- en: '11'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '11'
- en: '123'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '123'
- en: '245'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '245'
- en: '1016'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1016'
- en: 'Now, consider the same list sorted as if they are text values in an address
    field:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑将相同的列表按文本值排序，就像它们在地址字段中的表现一样：
- en: 1 Elm Lane
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Elm Lane
- en: 10 Pine Cir.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10 Pine Cir.
- en: 1016 Pine Cir.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1016 Pine Cir.
- en: 11 Front St.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 11 Front St.
- en: 123 Main St.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 123 Main St.
- en: 245 Oak Ave.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 245 Oak Ave.
- en: Telephone numbers and postal codes (and house numbers in street addresses as
    in the previous example) are often comprised of numeric digits, but when we think
    of them as data values, do they have more in common with text or with numeric
    data? Do we plan to add them, subtract them, or take their averages or standard
    deviations? If not, they may more appropriately be stored as text values.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 电话号码和邮政编码（以及街道地址中的房号，如前面的例子所示）通常由数字组成，但当我们将它们视为数据值时，它们更像是文本数据还是数字数据？我们计划对它们进行加法、减法，还是计算它们的平均数或标准差？如果没有，它们可能更适合存储为文本值。
- en: Dates and time
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期和时间
- en: 'You are probably familiar with many different ways of writing the same date,
    and you probably have some that you prefer over others. For instance, here are
    a few common ways of writing the same date:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉许多不同的日期书写方式，并且可能有一些你偏好的方式。例如，以下是几种常见的写法：
- en: 11-23-14
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 11-23-14
- en: 11-23-2014
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 11-23-2014
- en: 23-11-2014
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 23-11-2014
- en: '2014-11-23'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '2014-11-23'
- en: 23-Nov-14
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 23-Nov-14
- en: November 23, 2014
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2014年11月23日
- en: 23 November 2014
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2014年11月23日
- en: Nov. 23, 2014
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2014年11月23日
- en: 'Regardless of our preference for writing dates, a complete date is made up
    of three parts: month, day, and year. Any date should be able to be parsed into
    these component parts. Areas of confusion with dates are usually in two areas:
    lack of clarity about the month signifier and a day signifier for numbers below
    12, and confusion about specifying years. For example, if we only see "11-23",
    we can assume November 23, as there is no month abbreviated "23", but what year
    is it? If we see a date of "11-12", is that the 12th of November or the 11th of
    December? And in what year? Does a year of 38 signify 1938 or 2038?'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们如何偏好书写日期，完整的日期由三部分组成：月份、日期和年份。任何日期都应该能够解析为这些组成部分。日期中的困惑通常集中在两个方面：关于月份符号的模糊性，和对于12以下日期数字的日子符号不明确，以及关于年份指定的困惑。例如，如果我们只看到“11-23”，我们可以假设这是11月23日，因为没有“23”这个月份的缩写，但它是哪一年呢？如果我们看到一个“11-12”的日期，那是11月12日还是12月11日？而是哪一年呢？38年是指1938年还是2038年？
- en: 'Most DBMSes have a particular way you should import data if you have specified
    it as a date, and if you export data, you will get it back in that date format
    too. However, these systems also have many functions that you can apply to reformat
    dates or pull out just the pieces you want. For example, MySQL has many interesting
    date functions that allow us to pull out just the month or day, as well as more
    complicated functions that allow us to find out what week in the year a particular
    date falls in or what day of the week it was. For example, the following SQL counts
    the messages in the Enron dataset from [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Why
    Do You Need Clean Data?"), *Why Do You Need Clean Data?*, that were sent on May
    12 each year, and it also prints the day of the week:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据库管理系统（DBMS）都有特定的方式来导入日期数据，如果你将其指定为日期格式，当你导出数据时，也会以这种日期格式返回数据。然而，这些系统还提供了许多可以用来重新格式化日期或提取你需要的部分的功能。例如，MySQL有许多有趣的日期函数，可以让我们仅提取月份或日期，以及更复杂的函数，帮助我们找出某个特定日期是年份中的第几周，或者它是星期几。例如，以下SQL语句统计了在[第1章](part0014.xhtml#aid-DB7S1
    "Chapter 1. 为什么你需要清洁数据?")，*为什么你需要清洁数据？* 中， 每年5月12日发送的Enron数据集中的消息，并且还打印了该日期的星期几：
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Some spreadsheet programs, such as Excel, internally store dates as numbers
    but then allow the user to display the values in any format that they like using
    either built-in or custom formats. Excel stores a given date value as a fractional
    number of days since Dec 31, 1899\. You can see the internal representation of
    a date in Excel by entering a date and asking for **General** formatting, as shown
    in the following figure. Excel stores May 21, 1986 as **31553**.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一些电子表格程序，如Excel，内部将日期存储为数字，但允许用户使用内置格式或自定义格式将其显示为任何喜欢的形式。Excel将给定日期的值存储为自1899年12月31日以来的日期的分数。你可以通过输入日期并选择**常规**格式，查看Excel中日期的内部表示，如下图所示。Excel将1986年5月21日存储为**31553**。
- en: '![Dates and time](img/image00240.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![日期和时间](img/image00240.jpeg)'
- en: So, when you convert back and forth between different formats, switching the
    slashes to dashes, or swapping the order of months and days, Excel is just applying
    a different *look* to the date as you see it, but underneath, its internal representation
    of the date value has not changed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当你在不同格式之间来回转换时，切换斜杠为破折号，或者交换月份和日期的顺序，Excel实际上只是改变了你看到的日期“外观”，但在其内部，日期值的表示方式并没有改变。
- en: Why does Excel need a fractional number to store the date since 1899? Isn't
    the number of days a whole number? It turns out that the fraction part is the
    way Excel stores time.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Excel需要使用分数形式来存储自1899年以来的日期？难道日期的天数不应该是整数吗？原来，小数部分是Excel存储时间的方式。
- en: '![Dates and time](img/image00241.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![日期和时间](img/image00241.jpeg)'
- en: In the preceding figure, we can see how an internal date of 31553 is mapped
    to midnight, but 31553.5 (halfway through the day) is noon, and 31553.75 is 6
    p.m. The greater precision we add to the decimal points, the greater time specificity
    we will get in the internal representation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到一个内部日期值31553是如何映射到午夜的，但31553.5（一天的中间）是中午，31553.75是晚上6点。我们在小数点后添加的精度越高，内部表示的时间细节就越具体。
- en: But not all data storage systems store dates and time as fractions, and they
    do not all start at the same spot. Some systems store dates and time as a number
    of seconds since the Unix epoch (00:00:00, January 1, 1970, universal time), and
    a negative number is used to store time before the epoch.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但并不是所有的数据存储系统都将日期和时间存储为小数形式，而且它们的起始时间也不相同。有些系统将日期和时间存储为自Unix纪元（1970年1月1日00:00:00，协调世界时）以来的秒数，而负数则用于存储纪元之前的时间。
- en: Both DBMS and spreadsheet applications allow for some date math, just like with
    numbers. In both types of systems, there are functions that allow dates to be
    subtracted to find a difference, or other calculations, such as adding a number
    of weeks to a day and getting a new day value.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库管理系统和电子表格应用程序都允许进行类似于数字的日期计算。在这两种系统中，都有函数可以让日期相减以找到差异，或进行其他计算，比如将若干周添加到某个日期上并得到一个新的日期值。
- en: Strings
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings represent sequences of any character data, including alphabetic letters,
    numbers, spaces and punctuation, characters in hundreds of languages, and all
    kinds of special purpose symbols. Strings are very flexible, and this makes them
    the most common way to store data. Plus, as they can store nearly any other type
    of data (not necessarily efficiently), strings become the lowest common denominator
    to communicate data or move it from one system to another.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串表示任何字符数据的序列，包括字母、数字、空格和标点符号、数百种语言的字符以及各种特殊符号。字符串非常灵活，这使得它们成为最常见的数据存储方式。此外，字符串可以存储几乎所有其他类型的数据（不一定高效），因此它们成为传输数据或将数据从一个系统移到另一个系统的最低公分母。
- en: As with numeric data, the storage mechanism we are using at the moment may have
    some guidelines we are expected to use with strings. For example, a DBMS or spreadsheet
    may require that we state in advance what size we expect our strings to be or
    what types of characters we are expecting. Character encoding is an interesting
    and important area on its own, so we have a whole section on it coming up later
    in this chapter.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与数字数据一样，我们目前使用的存储机制可能有一些我们需要遵循的字符串使用指南。例如，一个数据库管理系统（DBMS）或电子表格可能要求我们提前声明字符串的预期大小或我们预期的字符类型。字符编码是一个非常有趣且重要的领域，因此我们在本章稍后有一节专门讨论它。
- en: Or, there may be guidelines for the size of the data we are allowed to work
    with in a particular environment. In the world of databases, there are fixed and
    variable width character columns, which are designed to hold shorter strings,
    and some DBMS vendors have designed a text type that is intended to hold longer
    strings.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可能会有关于我们在特定环境中可以处理的数据大小的指南。在数据库的世界里，有定长和变长字符列，这些列设计用于存储较短的字符串，一些数据库管理系统（DBMS）厂商还设计了一种文本类型，用于存储更长的字符串。
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Generically, many data scientists extend this terminology. As string data gets
    bigger and more unwieldy, it is referred to as text data, and its analysis becomes
    text analysis or text mining.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，许多数据科学家会扩展这一术语。当字符串数据变得更大、更难以处理时，它通常被称为文本数据，其分析就成为了文本分析或文本挖掘。
- en: String (or text) data can be found in any of the file formats we talked about
    earlier in the chapter (delimited files, JSON, or web pages) and can be stored
    in or accessed by many of the storage solutions we talked about (APIs, DBMS, spreadsheets,
    and flat files). But no matter what the storage and delivery mechanism, it seems
    as though strings are most often discussed in same breath as big, messy, unstructured
    data. An Excel expert will be unfazed if asked to parse out the pieces of a few
    hundred street addresses or sort a few thousand book titles into categories. No
    statistician or programmer is going to blink if asked to count the character frequency
    in a word list. But when string manipulation turns into "extract the source code
    found embedded in 90 million e-mail messages written in Russian" or "calculate
    the lexical diversity of the entire contents of the Stack Overflow website", things
    get a lot more interesting.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串（或文本）数据可以出现在我们在本章前面讨论的任何文件格式中（如分隔符文件、JSON 或网页），并且可以存储在或通过我们讨论的许多存储解决方案访问（如
    API、DBMS、电子表格和文本文件）。但无论存储和传输机制如何，似乎字符串总是与“大型、杂乱、无结构数据”一起讨论。一个 Excel 专家在被要求解析几百个街道地址或将几千本书名分类时毫不犹豫。如果被要求计算一个单词列表中的字符频率，统计学家或程序员也不会感到惊讶。但当字符串操作变成“提取嵌入在9000万封用俄语写的电子邮件消息中的源代码”或“计算整个
    Stack Overflow 网站内容的词汇多样性”时，事情就变得更加有趣了。
- en: Other data types
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他数据类型
- en: 'Numbers, dates/times, and strings are the *big three* data types, but there
    are many other types of exotic data that we will run into depending on what environment
    we are working in. Here is a quick rundown of some of the more interesting ones:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 数字、日期/时间和字符串是*三大*数据类型，但根据我们所处的环境，还有许多其他类型的特殊数据。在这里，我们简单列出一些更有趣的类型：
- en: '**Sets/enums**: If your data seems to only have a few choices for possible
    data values, you may be looking at a set or enumerated (enum) type. An example
    of enumerated data might be the set of possible final grades in a college course:
    {A, A-, B+, B, B-, C+, C, C-, D+, D, D-, F, W}.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合/枚举**：如果你的数据似乎只有几个可能的值，那么你可能正面对一个集合或枚举（enum）类型。枚举数据的一个例子可能是大学课程的可能最终成绩集合：{A,
    A-, B+, B, B-, C+, C, C-, D+, D, D-, F, W}。'
- en: '**Booleans**: If your data is limited to one of just two selections, and they
    evaluate to 0/1 or true/false, you may be looking at Boolean data. A database
    column called `package_shipped` might have values of either yes or no, indicating
    whether a package has been shipped out.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔值**：如果你的数据仅限于两个选项之一，并且它们的值为0/1或真/假，那么你可能正在处理布尔数据。一个名为`package_shipped`的数据库列可能只有“是”或“否”的值，用来表示包裹是否已经发出。'
- en: '**Blobs (binary large objects)**: If your data is binary, for example, you
    are storing the actual bytes for a picture file (not just the link to it) or the
    actual bytes for an mp3 music file, then you are probably looking at blob data.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BLOBs（二进制大对象）**：如果你的数据是二进制数据，例如，你存储的是图片文件的实际字节（而不仅仅是文件的链接）或者是MP3音乐文件的实际字节，那么你可能正在处理BLOB数据。'
- en: Converting between data types
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型转换
- en: Conversions between data types are an inevitable part of the cleaning job. You
    may be given string data, but you know that you need to perform math on it, so
    you wish to store it as a number. You may be given a date string in one format
    but you want it in a different date format. Before we go any further, though,
    we need to discuss a potential problem with conversions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型之间的转换是数据清理工作中不可避免的一部分。你可能会得到字符串数据，但你知道你需要对其进行数学运算，因此希望将其存储为数字。你可能会得到一种日期字符串，格式为某种形式，但你希望它以不同的日期格式显示。不过，在继续之前，我们需要讨论转换过程中的潜在问题。
- en: Data loss
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据丢失
- en: 'There is a risk of losing data when converting from one data type to another.
    Usually, this happens when the target data type is not capable of storing as much
    detail as the original data type. Sometimes, we are not upset by data loss (in
    fact, there may even be times when a cleaning procedure will warrant some intentional
    loss), but if we are not expecting the data loss, it can be devastating. Risk
    factors include:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在从一种数据类型转换到另一种数据类型时，可能会丢失数据。通常，这发生在目标数据类型无法存储与原始数据类型一样多的详细信息时。有时，我们并不会因为数据丢失而感到不安（事实上，有时清理过程中可能故意丢失一些数据），但如果我们没有预料到数据丢失，它可能会带来灾难性的后果。风险因素包括：
- en: '**Converting between different sizes of the same data type**: Suppose you have
    a string column that is 200 characters long and you decide to move the data to
    a column that is only 100 characters long. Any data that exceeds 100 characters
    might be chopped off or truncated. This can also happen when switching between
    different sizes of numeric columns, for example, when going from big integers
    to regular integers or from regular integers to tiny integers.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同一数据类型之间的不同大小转换**：假设你有一个200个字符的字符串列，你决定将数据移到一个只有100个字符长的列中。那么，超过100个字符的任何数据可能会被截断或削减。这种情况也可能发生在数字列大小转换时，比如从大整数转换为普通整数，或者从普通整数转换为小整数时。'
- en: '**Converting between different levels of precision**: Suppose you have a list
    of decimal numbers that are precise to four digits, and then you convert them
    to two digits of precision, or even worse, to integers. Each number will be rounded
    off or truncated, and you will lose the precision that you had.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在不同精度级别之间的转换**：假设你有一个精确到四位数字的十进制数字列表，然后你将它们转换为精度为两位的数字，或者更糟的是，转换为整数。每个数字都会被四舍五入或截断，从而失去原有的精度。'
- en: Strategies for conversion
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换策略
- en: There are many strategies to handle data type conversions, and which one you
    use depends on where the data is being stored at the moment. We are going to cover
    two of the most common ways in which we encounter data type conversions in the
    data science cleaning process.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据类型转换有许多策略，具体使用哪种方法取决于数据当前存储的位置。我们将讨论两种在数据科学清理过程中最常见的数据类型转换方法。
- en: The first strategy, SQL-based manipulation, will apply if we have data in a
    database. We can use database functions, available in nearly every database system,
    to slice and dice the data into a different format, suitable for either exporting
    as a query result or for storing in another column.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种策略，基于SQL的操作，适用于当我们有数据库中的数据时。我们可以使用几乎所有数据库系统中的数据库函数，将数据切割并转换成不同的格式，以便导出为查询结果或存储在另一列中。
- en: The second strategy, file-based manipulation, comes into play when we have been
    given a flat file of data—for example, a spreadsheet or JSON file—and we need
    to manipulate the data types in some way after reading them out of the file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种策略是基于文件的操作，适用于我们已经获得了一个平面数据文件——例如，一个电子表格或JSON文件——并且在从文件中读取数据后，需要以某种方式操作数据类型。
- en: Type conversion at the SQL level
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL层级的数据类型转换
- en: Here, we will walk through a few common cases when SQL can be used to manipulate
    data types.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍几个常见的案例，展示如何使用SQL来操作数据类型。
- en: Example one – parsing MySQL date into a formatted string
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例一 - 解析MySQL日期并转换为格式化字符串
- en: For this example, we will return to the Enron e-mail dataset we used in [Chapter
    1](part0014.xhtml#aid-DB7S1 "Chapter 1. Why Do You Need Clean Data?"), *Why Do
    You Need Clean Data?*. As with the previous example, we are going to look in the
    message table, where we have been using the date column, which is stored as a
    `datetime` MySQL data type. Suppose we want to print a full date with spelled-out
    months (as opposed to numbers) and even the day of the week and time of day. How
    can we best achieve this?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将回到我们在[第 1 章](part0014.xhtml#aid-DB7S1 "第 1 章. 为什么需要清理数据？")中使用的Enron电子邮件数据集，*为什么需要清理数据？*。和之前的例子一样，我们将查看消息表，其中包含我们之前使用过的日期列，这些日期列存储为`datetime`
    MySQL 数据类型。假设我们想打印一个完整的日期，包括拼写出来的月份（而非数字），甚至是星期几和一天中的时间。我们应该如何做到这一点？
- en: 'For the record with the message ID (mid) of 52, we have:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于消息ID（mid）为52的记录，我们得到：
- en: '[PRE17]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We want is this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是这样：
- en: '[PRE18]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Option 1: Use `concat()` and individual date and time functions, as shown in
    the following code sample. The weakness of this option is that the a.m./p.m. is
    not printed easily:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项 1：使用`concat()`和单独的日期与时间函数，如下所示的代码示例。这个选项的弱点是无法轻松打印出上午/下午（a.m./p.m.）：
- en: '[PRE19]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Result:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果：
- en: '[PRE20]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we decided that we really wanted the a.m./p.m., we could use an if statement
    that tests the hour and prints "a.m". if the hour is less than 12 and "pm" otherwise:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们决定真的需要上午/下午（a.m./p.m.），我们可以使用一个if语句，测试小时数，并在小时小于12时打印"a.m."，否则打印"pm"：
- en: '[PRE21]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Result:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果：
- en: '[PRE22]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'MySQL date and time functions, such as `day()` and `year()`, are described
    in their documentation: [http://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html](http://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html),
    and their string functions, such as `concat()`, can be found here: [http://dev.mysql.com/doc/refman/5.7/en/string-functions.html](http://dev.mysql.com/doc/refman/5.7/en/string-functions.html).
    Other database management systems will have similar versions of these functions.'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MySQL的日期和时间函数，如`day()`和`year()`，在它们的文档中有详细描述：[http://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html](http://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html)，它们的字符串函数，如`concat()`，可以在这里找到：[http://dev.mysql.com/doc/refman/5.7/en/string-functions.html](http://dev.mysql.com/doc/refman/5.7/en/string-functions.html)。其他数据库管理系统也会有类似的函数版本。
- en: 'Option 2: Use the more sophisticated `date_format()` MySQL function. This function
    takes a series of string specifiers for how you want the date to be formatted.
    There is a very long list of these specifiers in the MySQL documentation. A completed
    example to convert the date into our desired format is shown in the following
    code:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项 2：使用更复杂的`date_format()` MySQL 函数。该函数接受一系列字符串说明符，用于指定日期格式化方式。在MySQL文档中有一个非常长的说明符列表。为了将日期转换为我们需要的格式，下面是一个完成的示例代码：
- en: '[PRE23]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Result:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果：
- en: '[PRE24]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is pretty close to what we said we wanted, and it is much shorter than
    Option 1\. The only difference is that the a.m./p.m. is capitalized. If we really
    want it lowercased, we can do this:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这已经很接近我们想要的结果，而且比选项1更简短。唯一的区别是上午/下午（a.m./p.m.）是大写的。如果我们真的希望它是小写的，可以这样做：
- en: '[PRE25]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Result:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果：
- en: '[PRE26]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Example two – converting a string into MySQL's date type
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例二 - 将字符串转换为MySQL的日期类型
- en: 'For this example, let''s look at a new table in the Enron schema: the table
    called `referenceinfo`. This table shows the messages to which the other messages
    refer. For example, the first entry in that table, with a `rfid` `2`, contains
    the text of the e-mail to which message 79 refers. The column is a string, and
    its data looks like this (in part):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们看看Enron模式中的一个新表：名为`referenceinfo`的表。这个表展示了其他消息所引用的消息。例如，表中的第一个条目，`rfid`为`2`，包含了消息79所引用的电子邮件的文本。该列是一个字符串，数据部分如下所示（部分内容）：
- en: '[PRE27]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is a very messy string! Let's take on the job of extracting the date shown
    on the top line and converting it into a MySQL date type, suitable for inserting
    into another table or for performing some date math.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一串非常混乱的字符串！让我们来处理一下，提取出第一行显示的日期，并将其转换为MySQL日期类型，适合插入到另一个表中，或者进行日期计算。
- en: 'To do this, we will use the built-in `str_to_date()`MySQL function. This function
    is a bit like `date_format()` that we saw earlier, except that it''s backwards.
    Here is a working example that will look for the word `Sent:` and extract the
    following characters up to the `>` symbol and then turn these characters into
    a real MySQL datetime data type:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用内置的 `str_to_date()` MySQL 函数。这个函数有点像我们之前看到的 `date_format()`，不过它是反向的。下面是一个工作示例，它会查找单词
    `Sent:` 并提取紧跟其后的字符，直到 `>` 符号，然后将这些字符转换为真实的 MySQL 日期时间数据类型：
- en: '[PRE28]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Result:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 结果：
- en: '[PRE29]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now we have a datetime value that is ready for inserting into a new MySQL column
    or for performing more date functions or calculations on it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个准备好插入到新的 MySQL 列中或进行更多日期函数或计算的日期时间值。
- en: Example three – casting or converting MySQL string data to a decimal number
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例三 – 将 MySQL 字符串数据转换为十进制数字
- en: In this example, let's consider how to convert numbers hiding inside a text
    column into a format suitable for calculations.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将讨论如何将隐藏在文本列中的数字转换为适合计算的格式。
- en: Suppose we were interested in extracting the price for a barrel of oil (abbreviated
    *bbl*) from some e-mail messages sent to Enron from a mailing list. We could write
    a query such that every time we see the `/bbl` string in an e-mail message from
    a certain sender, we look for the preceding dollar sign and extract the attached
    numeric value as a decimal number.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有兴趣从 Enron 接收到的某些邮件中提取油桶的价格（简称 *bbl*）。我们可以编写一个查询，每当我们在某个发件人的邮件中看到 `/bbl`
    字符串时，查找前面的美元符号并提取后面的数字值，将其转换为十进制数字。
- en: 'Here is a sample snippet from an e-mail message in the Enron message table
    with a message ID (`mid`) of 270516, showing how the number looks inside the string:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自 Enron 消息表中一条电子邮件消息的示例片段，消息 ID（`mid`）为 270516，展示了数字在字符串中的样子：
- en: '[PRE30]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The MySQL command to perform this string extraction and conversion to a decimal
    is as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此字符串提取并转换为十进制的 MySQL 命令如下：
- en: '[PRE31]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `WHERE` clause restrictions are added so that we make sure we are only getting
    messages that have bbl oil prices in them.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了 `WHERE` 子句的限制，以确保我们只获取包含 bbl 油价的消息。
- en: The `convert()` function is similar to `cast()` in MySQL. Most modern database
    systems will have a way of converting data types into numbers like this.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`convert()` 函数类似于 MySQL 中的 `cast()`。大多数现代数据库系统都有类似的方式将数据类型转换为数字。'
- en: Type conversion at the file level
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件级别的类型转换
- en: In this section, we will show some common cases when data types will need to
    be manipulated at the file level.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示一些常见的情况，当数据类型需要在文件级别进行处理时。
- en: Tip
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This material really only applies to file types where there is an implicit typing
    structure, for example, spreadsheets and semi-structured data like JSON. We have
    no examples here that use delimited (text-only) flat files, as in a text file,
    all data is text data!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容实际上只适用于具有隐式类型结构的文件类型，例如电子表格和类似 JSON 的半结构化数据。我们这里没有使用分隔符（仅文本）平面文件的示例，因为在文本文件中，所有数据都是文本数据！
- en: Example one – type detection and converting in Excel
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例一 – Excel 中的类型检测和转换
- en: You may be familiar with type converting in Excel and similar spreadsheet applications
    via the cell formatting menu options. The typical procedure involves selecting
    the cells you want to change and using the drop-down menu located on the ribbon.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉在 Excel 和类似的电子表格应用程序中通过单元格格式化菜单选项进行类型转换。典型的操作流程包括选择你想要更改的单元格，并使用位于功能区的下拉菜单。
- en: '![Example one – type detection and converting in Excel](img/image00242.jpeg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![示例一 – Excel 中的类型检测和转换](img/image00242.jpeg)'
- en: Or, if that does not offer enough options, there is also the **Format Cells**
    dialogue, located in the format menu, which offers more granular control over
    the output of the conversion process.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果这些选项不够，可以使用 **格式单元格** 对话框，该对话框位于格式菜单中，提供了对转换过程输出的更细粒度的控制。
- en: '![Example one – type detection and converting in Excel](img/image00243.jpeg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![示例一 – Excel 中的类型检测和转换](img/image00243.jpeg)'
- en: The lesser-known `istext()` and `isnumber()` functions may also be useful in
    formatting data in Excel.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 较不为人知的 `istext()` 和 `isnumber()` 函数在 Excel 中也可能在格式化数据时非常有用。
- en: '![Example one – type detection and converting in Excel](img/image00244.jpeg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![示例一 – Excel 中的类型检测和转换](img/image00244.jpeg)'
- en: These functions can be applied to any cell, and they return **TRUE** or **FALSE**
    depending on whether the data is text or not, or in the case of `isnumber()`,
    whether the number is really a number or not. Paired with a feature like conditional
    formatting, these two formulas can help you locate bad values or incorrectly typed
    values in small amounts of data.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以应用于任何单元格，返回 **TRUE** 或 **FALSE**，取决于数据是否为文本，或者在 `isnumber()` 的情况下，数字是否真的为数字。结合条件格式等功能，这两个公式可以帮助你在少量数据中定位错误值或输入错误的值。
- en: Excel also has a few simple functions for manipulating strings into other data
    types, other than using the menus. The following figure shows the `TEXT()` function
    being used to convert a numeric date to a string version of that date in the yyyy-mm-dd
    format. In the formula bar, we type `=TEXT(A4,"yyyy-mm-dd")`, and the `36528`
    number is converted into `2000-01-03`. The date string now appears in the format
    we specified.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Excel 也有一些简单的函数可以将字符串转换为其他数据类型，除了使用菜单。下图展示了 `TEXT()` 函数用于将数字日期转换为 yyyy-mm-dd
    格式的字符串版本。在公式栏中，我们输入 `=TEXT(A4,"yyyy-mm-dd")`，`36528` 这个数字被转换为 `2000-01-03`。日期字符串现在以我们指定的格式显示。
- en: '![Example one – type detection and converting in Excel](img/image00245.jpeg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![示例一——Excel 中的类型检测和转换](img/image00245.jpeg)'
- en: Example two – type converting in JSON
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例二——JSON 中的类型转换
- en: JSON, as a semi-structured text-based format, does not offer a lot of options
    in the way of formatting and data types. Recall from the JSON description earlier
    in this chapter that JSON objects are constructed as name-value pairs. The only
    options for formatting the value part of a name-value pair are a text string,
    a number, or a list. While it is possible to build JSON objects by hand—for example,
    by typing them out in a text editor—usually, we build JSON objects programmatically,
    either by exporting JSON from a database or by writing a small program to convert
    a flat text file into JSON.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 作为一种半结构化的文本格式，并未提供很多关于格式化和数据类型的选项。回顾本章前面对 JSON 的描述，JSON 对象是由名称-值对构建的。构成名称-值对的值部分格式化选项仅限于文本字符串、数字或列表。虽然可以手动构建
    JSON 对象——例如，通过在文本编辑器中输入——通常我们是通过编程的方式来构建 JSON 对象，无论是从数据库导出 JSON，还是通过编写一个小程序将一个平面文本文件转换为
    JSON。
- en: What happens if our program that is designed to generate JSON is flawed? Suppose
    the program gives us strings instead of numbers. This happens occasionally and
    it can have unintended consequences for any program designed to consume JSON.
    The following is an example showing some simple PHP code that is designed to generate
    JSON, which will later be read into D3 to build a graph.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设计用于生成 JSON 的程序出现缺陷，会发生什么呢？假设程序给我们的是字符串而不是数字。这种情况偶尔会发生，并且可能对任何设计来消费 JSON
    的程序产生意想不到的后果。以下是一个例子，展示了一些简单的 PHP 代码，旨在生成 JSON，之后将其读取到 D3 中构建图表。
- en: 'The PHP code to generate a JSON representation of a dataset from a database
    is straightforward. The sample code, as shown in the following example, connects
    to the Enron database, builds a query, runs the query, puts each part of the query
    result into an array, and then encodes the array values as JSON name-value pairs.
    Here is the code to build a list of dates and counts, just like the dates and
    counts we used in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Why Do You
    Need Clean Data?"), *Why Do You Need Clean Data?*:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从数据库生成数据集的 JSON 表示的 PHP 代码是直接的。如下所示的示例代码连接到 Enron 数据库，构建查询，执行查询，将查询结果的每个部分放入数组中，然后将数组值编码为
    JSON 名称-值对。以下是构建日期和计数列表的代码，和我们在 [第 1 章](part0014.xhtml#aid-DB7S1 "第 1 章。为什么你需要干净的数据？")
    中使用的日期和计数一样，*为什么你需要干净的数据？*：
- en: '[PRE32]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that the `json_encode()` function requires PHP version 5.3 or higher, and
    this example relies on the same working Enron database that we built in [Chapter
    1](part0014.xhtml#aid-DB7S1 "Chapter 1. Why Do You Need Clean Data?"), *Why Do
    You Need Clean Data?*.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`json_encode()` 函数要求 PHP 版本为 5.3 或更高，本示例依赖于我们在 [第 1 章](part0014.xhtml#aid-DB7S1
    "第 1 章。为什么你需要干净的数据？") 中构建的相同的 Enron 数据库，*为什么你需要干净的数据？*。
- en: 'The problem here is that the result is stringified—PHP has placed the numeric
    values for `numMsg` in quotation marks, which in JSON means string values:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，结果被转换成了字符串——PHP 已将 `numMsg` 的数字值放在了引号中，这在 JSON 中表示字符串值：
- en: '[PRE33]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To nudge the PHP function to be really careful about numeric values and not
    just assume that everything is a string, we will need to specifically convert
    the values to numbers before printing them to the screen. Simply change the way
    we call `json_encode()` so that it looks like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让PHP函数更加小心地处理数字值，而不是单纯地假设所有内容都是字符串，我们需要在将它们打印到屏幕之前，专门将这些值转换为数字。只需要改变我们调用`json_encode()`的方式，让它看起来像这样：
- en: '[PRE34]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now the JSON result includes actual numbers for `numMsg`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，JSON结果中已经包含了`numMsg`的实际数字：
- en: '[PRE35]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: PHP includes similar functions for converting big integers to strings as well.
    This can be useful when you have extremely large numbers but you need them to
    be stored as string data for some reason, for example, when storing session values
    or Facebook or Twitter user ID values.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: PHP还包括类似的函数，用于将大整数转换为字符串。当你有极其大的数字，但出于某种原因需要将其存储为字符串数据时，这个功能很有用，例如，在存储会话值或Facebook、Twitter用户ID值时。
- en: 'If we do not control the PHP code that is generating the JSON output—for example,
    if we are accessing the JSON via an API and we don''t have any control over its
    generation—then we''ll have to perform a conversion after the JSON has already
    been built. In this case, we need to ask our D3 JavaScript code to coerce the
    strings into numbers using a `+` operator on that data value. In this example,
    we have read the JSON output and are preparing to build a graph. The `numMsg`
    value has been coerced from a string to a number:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法控制生成JSON输出的PHP代码——例如，如果我们通过API访问JSON而无法控制它的生成——那么我们就需要在JSON已经构建完成后进行转换。在这种情况下，我们需要请求我们的D3
    JavaScript代码使用`+`操作符将字符串强制转换为数字。 在这个例子中，我们已经读取了JSON输出，并准备构建图表。`numMsg`值已经从字符串强制转换为数字：
- en: '[PRE36]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If a null falls in a forest…
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果一个null掉进了森林……
- en: In this section, we are going to dip our chef's ladle into the mysterious stew
    of zeroes, empties, and nulls.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将把厨师的勺子伸进充满零、空值和null的神秘炖菜中。
- en: 'What is the difference between these? Well, as I mentioned stew, consider this
    illustration first. Imagine you have a top-of-the-line stove in your fancy chef''s
    kitchen, and on that stove, you are going to prepare a pot of thick, hearty stew.
    Your sous chef asks you, "How much stew is in the pot?". Take a look at these
    options:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这些有什么区别呢？好吧，既然我提到了炖菜，先看这个例子。假设你有一台顶级炉灶，位于你豪华的厨师厨房里，在那台炉子上，你要准备一锅浓厚、丰富的炖菜。你的副厨师问你：“锅里有多少炖菜？”看看这些选项：
- en: At the beginning of the day, you observe that there is no pot on the stove.
    The question "how much stew is in the pot?" is unanswerable. There is no pot!
    The answer is not a positive value, it is not a zero value, and it is not even
    empty. The value is **NULL**.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一天开始时，你发现炉子上没有锅。问题“锅里有多少炖菜？”是无法回答的。没有锅！答案既不是正值，也不是零值，甚至不为空。值是**NULL**。
- en: A few hours later, after much cleaning and chopping, you look in the pot and
    see three liters of delicious stew. Great; you now have an answer to the question.
    In this case, our answer is a **data value of 3**.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几个小时后，在经过大规模的清洗和切割之后，你看着锅里，发现有三升美味的炖菜。太棒了；你现在有了问题的答案。在这种情况下，我们的答案是**数据值为3**。
- en: After the lunch rush, you look in the pot again and discover that there is no
    more stew. Every last drop has been sold. You looked, you measured, and you found
    the answer to "how much stew is in the pot?" is a **zero** value. You send the
    pot to be washed at the sink.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 午餐高峰过后，你再次查看锅，发现炖菜已经没有了。每一滴都已经卖完了。你看了，看了量，发现“锅里有多少炖菜？”的答案是**零**。你把锅送去水槽清洗。
- en: Just before the evening meal, you grab the clean pot from the sink. As you walk
    across the kitchen, the sous chef asks, "What's in the pot?" Currently, the pot
    is **empty**. There is nothing in the pot. Note that the answer is not zero, because
    the question he asked was not a numeric one. The answer is also not NULL because
    we *DO* have a pot, and we *DID* look inside it, but there was just no answer.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在晚餐前，你从水槽拿起干净的锅。走过厨房时，副厨师问：“锅里有什么？”目前，锅是**空的**。锅里什么都没有。注意，这个答案不是零，因为他问的问题并不是数字问题。答案也不是NULL，因为我们*确实*有锅，我们*确实*看过锅，但只是没有找到答案。
- en: Different data and programming environments (DBMS, storage systems, and programming
    languages) treat these zero, empty, and NULL concepts slightly differently. Not
    all of them clearly distinguish between all four cases. Therefore, this chapter
    is written somewhat generically, and when examples are given, we try to point
    out which environment we are applying them to. It is important to be aware of
    what *you* mean in each environment when you say that something is null, empty,
    or zero. And when you see these values in real-world datasets, it is important
    to be clear about what you can (and cannot) assume about each.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的数据和编程环境（如数据库管理系统、存储系统和编程语言）对这些零、空值和NULL的处理略有不同。并非所有系统都会清晰地区分这四种情况。因此，本章内容写得比较通用，给出示例时，我们尽量指出这些示例应用于哪些环境。了解在每个环境中当你说某样东西是NULL、空值或零时的具体含义非常重要。当你在实际数据集中看到这些值时，明确你可以（或不能）对每个值做出什么假设也非常重要。
- en: Tip
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'A special caveat for those dealing with Oracle databases: empty, blank, and
    NULL are different in Oracle when compared to many other systems. Proceed with
    caution through this section and consult your database documentation for details
    specific to Oracle.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 处理Oracle数据库时有一个特别的注意事项：空值、空白和NULL在Oracle中与许多其他系统不同。在此部分处理时请小心，并查阅Oracle的数据库文档，以了解特定的细节。
- en: Zero
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 零
- en: First things first. Of the zeroes, empties, and NULLs, the easiest to deal with
    is the zero value. Zero is a measurable quantity and has meaning in a numeric
    system. We can sort zeroes (they come before 1, 2, 3…), and we can compare other
    numbers to zero using the handy number line (-2, -1, 0, 1, 2, 3…). We can also
    perform math on zeroes (except for division by zero, which is always awkward).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最重要的一点。在零、空值和NULL值中，最容易处理的是零值。零是一个可测量的量，并且在数字系统中有意义。我们可以对零进行排序（它排在1, 2, 3…之前），也可以使用方便的数轴（-2,
    -1, 0, 1, 2, 3…）来与其他数字进行比较。我们还可以对零进行数学运算（除零以外，除零运算总是很麻烦）。
- en: As a legitimate value, zero works best as numeric data. A string value of zero
    does not make much sense as it would end up just needing to be interpreted as
    0, or the character of 0, which is probably not really the spirit of what we intended.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个合法的值，零作为数字数据最为合适。零的字符串值意义不大，因为它最终只会被解读为0，或者是字符0，这可能并不是我们最初的意图。
- en: Empties
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空值
- en: 'Empties are a bit more tricky to work with than zeroes, but they make a lot
    of sense in some cases, for instance, when working with strings. For example,
    suppose we have an attribute called middle name. Well, I have no middle name so
    I would always like to leave this field empty. (Fun fact: my mother still tells
    the story of how my Kindergarten graduation certificate shows a middle name that
    I made up on the spot, too shy to admit to my teacher that I lacked a middle name.)
    Filling in a space or a hyphen (or making up something) for a value that is truly
    empty does not make a lot of sense. Space is not the same thing as empty. The
    correct value in the case of an empty string may, in fact, be "empty".'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 空值比零稍微难处理一些，但在某些情况下它们很有意义，特别是处理字符串时。例如，假设我们有一个名为“中间名”的属性。嗯，我没有中间名，因此我总是希望将此字段留空。（有趣的事实：我母亲至今还讲述我幼儿园毕业证书上有一个临时编造的中间名的故事，因为我太害羞，不敢告诉老师我没有中间名。）对一个真正为空的值填充空格或连字符（或编造一些内容）是没有意义的。空格不同于空值。在空字符串的情况下，正确的值可能实际上是“空”。
- en: 'In a CSV or delimited file, an empty value can look like this—here, we have
    emptied out the favorite color values for the second two records:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个CSV或分隔符文件中，空值可能看起来像这样——在这里，我们已经将第二和第三条记录的最爱颜色值清空：
- en: '[PRE37]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In an `INSERT` database, for example, to put the `Manu` record into a MySQL
    system, we would use some code like this:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`INSERT`数据库中，要将`Manu`记录插入MySQL系统，我们可以使用如下代码：
- en: '[PRE38]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Sometimes, semi-structured data formats, such as JSON, will allow a blank object
    and blank strings. Consider this example:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，半结构化数据格式（如JSON）会允许空对象和空字符串。请看这个例子：
- en: '[PRE39]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we have taken away Sally's pets and made her favorite color an empty string.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经去掉了Sally的宠物，并将她的最爱颜色设置为空字符串。
- en: Blanks
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 空白
- en: 'Be aware that `" "` (two double quotes with a space in between, sometimes called
    a blank but more appropriately called a **space**) is not necessarily the same
    thing as "" (two double quotes right next to each other, sometimes also called
    a blank but more appropriately called **empty**). Consider the difference between
    these two MySQL INSERT statements:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`" "`（两个双引号之间有一个空格，有时称为空白，但更恰当地称为空格）不一定等同于""（两个紧挨在一起的双引号，有时也称为空白，但更恰当地称为空）。考虑这两个MySQL
    INSERT语句之间的区别：
- en: '[PRE40]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In addition to spaces, other invisible characters that sometimes get accidentally
    interpreted as empty or blank include tabs and carriage returns / line feeds.
    Be careful of these, and when in doubt, use some of the tricks introduced earlier
    in this chapter to uncover invisible characters.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 除了空格外，有时还会误将其他不可见字符（如制表符和换行符）误解为空或空白。要小心这些情况，当有疑问时，可以使用本章前面介绍的一些技巧来查找不可见字符。
- en: 'Null'
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空值
- en: I know that if you look up **null** in the dictionary, it might say that it
    means zero. But do not be fooled. In computing, we have a whole host of special
    definitions for NULL. To us, NULL is not nothing; in fact, it is the absence of
    even nothing.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，如果你在字典中查找**null**，可能会说它的意思是零。但不要被愚弄了。在计算机中，我们对NULL有一整套特殊的定义。对我们来说，NULL不是什么都没有；事实上，它甚至不是空的缺席。
- en: How is this different than empty? First, empty can be equal to empty, as the
    length of the empty string will be 0\. So, we can imagine a value existing, against
    which we can perform comparisons. However, NULL cannot be equal to NULL, and NOT
    NULL will not be equal to NOT NULL either. I have heard it suggested that we should
    all repeat as a mantra that *NULL is not equal to anything, even itself*.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这与空有什么不同呢？首先，空可以等于空，因为空字符串的长度为0。因此，我们可以想象一个存在的值，可以进行比较。然而，NULL不能等于NULL，NOT NULL也不会等于NOT
    NULL。我听说过有人建议我们应该把“NULL不等于任何东西，甚至不等于自己”作为口头禅。
- en: We use NULL when we legitimately want no entry of any kind for the data value.
    We do not even want to put the pot on the stove!
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们确实希望某个数据值不要有任何输入时，我们使用NULL。我们甚至不想把锅放在火上！
- en: Why is the middle name example "empty" and not NULL?
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么中间名示例是“empty”，而不是NULL？
- en: Good question. Recall from the stew pot analogy that if we ask the question
    and the answer is empty, it is different from never getting an answer (NULL).
    If you asked me what my middle name was and I told you I did not have one, then
    the data value is empty. But if you just do not know whether I have a middle name
    or not, then the data value is NULL.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 好问题。回想一下从炖锅类比中，如果我们问了问题而答案是空的，这与永远得不到答案（NULL）是不同的。如果你问我我的中间名是什么，而我告诉你我没有中间名，那么数据值就是空的。但是如果你只是不知道我是否有中间名，那么数据值就是NULL。
- en: Is it ever useful to clean data using a zero instead of an empty or null?
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用零而不是空或null来清理数据有时是有用的吗？
- en: Maybe. Remember in the e-mail example from [Chapter 1](part0014.xhtml#aid-DB7S1
    "Chapter 1. Why Do You Need Clean Data?"), *Why Do You Need Clean Data?*, when
    we discussed adding missing dates to our line graph and how the various spreadsheet
    programs automatically filled in a count of zero when creating a line graph with
    missing dates? Even though we had not counted the e-mails on those dates, our
    graphs interpolated the missing values as if they were zeroes. Are we OK with
    this? Well, it depends. If we can confirm the fact that the e-mail system was
    live and working on these dates, and we are confident that we have the full collection
    of e-mails sent, then the count for these dates could truly be inferred to be
    zero. However, in the case of the Enron e-mails we were using in [Chapter 1](part0014.xhtml#aid-DB7S1
    "Chapter 1. Why Do You Need Clean Data?"), *Why Do You Need Clean Data?*, we were
    pretty sure that was *not* the case.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 或许吧。还记得在[第1章](part0014.xhtml#aid-DB7S1 "第1章。为什么需要清理数据？")中的电子邮件示例中，*为什么需要清理数据？*，我们讨论了如何在我们的折线图中添加缺失的日期，并且各种电子表格程序在创建具有缺失日期的折线图时自动填充了零的计数吗？即使我们没有在这些日期计算电子邮件，我们的图表也会插值出缺失值，就好像它们是零一样。我们对此满意吗？嗯，这取决于情况。如果我们可以确认电子邮件系统在这些日期上是活动的，并且我们确信我们收集了所有发送的电子邮件，那么这些日期的计数确实可以推断为零。然而，在我们在[第1章](part0014.xhtml#aid-DB7S1
    "第1章。为什么需要清理数据？")中使用的安然电子邮件中，我们相当确定这种情况是*不*对的。
- en: Another case where it might be useful to store a zero-type data instead of empty
    is when we have a dummy date or only part of a date, for example, if you know
    the month and year, but not the day, and you have to insert data into a full date
    column. Filling in 2014-11-00 might be the way to go in that instance. But you
    should, of course, document this action (refer to the *Communicating about data
    cleaning* section in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Why Do You
    Need Clean Data?"), *Why Do You Need Clean Data?*) because what you did and why
    is probably not going to be obvious to you looking at this data six months from
    now!
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个情况可能有用的地方是在存储零类型数据而不是空数据时，例如，如果您知道月份和年份，但不知道日期，而且必须将数据插入到完整的日期列中。在这种情况下，填入
    2014-11-00 可能是一个不错的选择。但当然，您应该记录此操作（参见 [第 1 章](part0014.xhtml#aid-DB7S1 "第 1 章。为什么需要清洁数据？")
    中关于 *数据清理沟通* 的部分，*为什么需要清洁数据？*），因为您六个月后再查看这些数据时，您所做的和原因可能并不明显！
- en: Character encodings
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符编码
- en: In the olden days of computing, every string value had to be constructed from
    only 128 different symbols. This early encoding system, called **American Standard
    Code for Information Exchange** (**ASCII**), was largely based on the English
    alphabet, and it was set in stone. The 128 characters included a-z, A-Z, 0-9,
    some punctuation and spaces, as well as some now-useless Teletype codes. In our
    data science kitchen, using this type of encoding system today would be like cooking
    a frozen dinner. Yes, it is cheap, but it also lacks variety and nutrition, and
    you really cannot expect to serve it to a guest.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机的早期，每个字符串值都必须由仅有的 128 个不同符号构成。这种早期的编码系统被称为**美国信息交换标准代码**（**ASCII**），主要基于英文字母，并且一成不变。这
    128 个字符包括 a-z、A-Z、0-9、一些标点符号和空格，以及现在无用的电传代码。在我们的数据科学厨房里，今天使用这种编码系统就像是做冷冻晚餐。是的，它便宜，但也缺乏多样性和营养，你真的不能指望招待客人。
- en: In the early 1990s, a variable length encoding system, now called **UTF-8**,
    was proposed and standardized. This variable length scheme allows many more natural
    language symbols to be encoded properly as well as all the mathematical symbols
    and provides plenty of room to grow in the future. (The list of all these symbols
    is called **Unicode**. The encoding for the Unicode symbols is called UTF-8.)
    There is also now a UTF-16 encoding, where each character takes a minimum of two
    bytes to encode. At the time of writing this, UTF-8 is the predominant encoding
    for the Web.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 20 世纪 90 年代初，提出并标准化了一种可变长度编码系统，现在称为**UTF-8**。这种可变长度方案允许更多的自然语言符号以及所有数学符号得到适当编码，并提供了丰富的未来扩展空间。（所有这些符号的列表称为**Unicode**。Unicode
    符号的编码称为 UTF-8。）现在还有 UTF-16 编码，其中每个字符至少需要两个字节来编码。在撰写本文时，UTF-8 是 Web 的主要编码方式。
- en: 'For our purposes in this book, we are mostly concerned with what to do with
    data that exists in one encoding and must be cleaned by converting it to another
    encoding. Some example scenarios where this could be relevant include:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的目的，在大多数情况下，我们主要关注的是如何处理存在一种编码的数据，必须通过转换为另一种编码来进行清洁。一些可能相关的示例情景包括：
- en: You have a MySQL database that has been created using a simple encoding (such
    as one of the 256-bit Latin-1 character sets that are the default on MySQL), and
    which stores UTF-8 data as Latin-1, but you would now like to convert the entire
    table to UTF-8.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有一个 MySQL 数据库，使用简单的编码（如 MySQL 默认的一种 256 位 Latin-1 字符集）创建，并且将 UTF-8 数据存储为 Latin-1，但现在您希望将整个表转换为
    UTF-8。
- en: You have a Python 2.7 program that uses functions designed for ASCII but must
    now handle UTF-8 files or strings.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有一个使用 ASCII 设计的 Python 2.7 程序，但现在必须处理 UTF-8 文件或字符串。
- en: In this section, we will work through a few basic examples based on these scenarios.
    There are many more equally likely situations where you will encounter character
    encoding issues, but this will be a starting point.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将根据这些场景的几个基本示例进行工作。有许多同样可能的情况会导致您遇到字符编码问题，但这将是一个起点。
- en: Example one – finding multibyte characters in MySQL data
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例一 - 在 MySQL 数据中查找多字节字符
- en: Suppose we have a column of data and we are curious about how many values in
    that column actually have multibyte encoding. Characters that appear as a single
    character but take multiple bytes to encode can be discovered by comparing their
    length in bytes (using the `length()` function) to their length in characters
    (using the `char_length()` function).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个数据列，并且我们想知道该列中有多少值实际上使用了多字节编码。通过将字符的字节长度（使用 `length()` 函数）与字符的字符长度（使用
    `char_length()` 函数）进行比较，我们可以发现那些看似只有一个字符但实际上需要多个字节来编码的字符。
- en: Tip
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The following example uses the MyISAM version of the MySQL World database that
    is available as part of the MySQL documentation at [http://dev.mysql.com/doc/index-other.html](http://dev.mysql.com/doc/index-other.html)
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用的是 MyISAM 版本的 MySQL 世界数据库，该数据库作为 MySQL 文档的一部分可以在[http://dev.mysql.com/doc/index-other.html](http://dev.mysql.com/doc/index-other.html)找到。
- en: 'By default, the MyISAM version of the MySQL World test database uses the `latin1_swedish_ci`
    character encoding. So, if we run a query on a country name that has a special
    character in it, we might see something like the following for Côte d''Ivoire:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，MyISAM 版本的 MySQL 世界测试数据库使用 `latin1_swedish_ci` 字符编码。因此，如果我们查询一个国家名称中包含特殊字符的记录，我们可能会看到类似科特迪瓦（Côte
    d'Ivoire）这样的编码问题：
- en: '[PRE41]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This shows the length of 15 for the country, and the name of the country Côte
    d''Ivoire is encoded as CÃ™te dÃ­Ivoire. There are several other entries in various
    columns that are encoded strangely as well. To fix this, we can change the default
    collation of the name column to `utf8` with the following SQL command:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例显示了国家名称的长度为 15，而科特迪瓦（Côte d'Ivoire）的名称被编码为 CÃ™te dÃ­Ivoire。还有一些其他列中的条目也被奇怪地编码。为了修复这个问题，我们可以使用以下
    SQL 命令将名称列的默认排序规则更改为 `utf8`：
- en: '[PRE42]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we can empty the table and insert the 239 Country rows again:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以清空表格并再次插入 239 行国家数据：
- en: '[PRE43]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we have `Country` names that use UTF-8 encoding. We can test to see whether
    any of the countries are using a multibyte character representation for their
    name now by running the following SQL:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了使用 UTF-8 编码的 `Country` 名称。我们可以通过运行以下 SQL 来测试是否有任何国家名称使用了多字节字符表示：
- en: '[PRE44]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It shows that the Côte d'Ivoire and the French island Réunion both have multibyte
    character representations.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示科特迪瓦（Côte d'Ivoire）和法国岛屿留尼汪（Réunion）都有多字节字符表示。
- en: 'Here is another example if you do not have access to the world dataset, or
    in fact, any dataset at all. You can run a comparison of multibyte characters
    as a MySQL select command:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个示例，假设你没有世界数据集，或者实际上没有任何数据集。你可以运行一个 MySQL 查询命令来比较多字节字符：
- en: '[PRE45]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this example, the Japanese characters have a length of 27 but a character
    length of 9.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，日语字符的长度为 27，但字符长度为 9。
- en: This technique is used when we want to test the character set of our data—maybe
    you have too many rows to look one at a time, and you simply want a SQL statement
    that can show you all the multibyte entries at once so that you can make a plan
    for how to clean them. This command shows us the data that currently has a multibyte
    format.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧用于测试我们数据的字符集—也许你有太多的行无法逐一查看，你只想要一个 SQL 语句来一次性显示所有多字节条目，以便你能够规划如何清理它们。这个命令会显示当前具有多字节格式的数据。
- en: Example two – finding the UTF-8 and Latin-1 equivalents of Unicode characters
    stored in MySQL
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例二——查找 MySQL 中存储的 Unicode 字符的 UTF-8 和 Latin-1 等效字符
- en: The following code will use the `convert()` function and the `RLIKE` operator
    to print the UTF-8 equivalent of Unicode strings that have been saved to MySQL
    using Latin-1\. This is useful if you have multibyte data that has been stored
    in Latin-1 encoded text columns in MySQL, an unfortunately common occurrence as
    Latin-1 is still the default (as of MySQL 5).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将使用 `convert()` 函数和 `RLIKE` 运算符，打印出使用 Latin-1 保存到 MySQL 中的 Unicode 字符的 UTF-8
    等效字符。这对于你有多字节数据且该数据已存储在 MySQL 中使用 Latin-1 编码的文本列中时非常有用，这是一个不幸的常见情况，因为 Latin-1
    仍然是默认字符集（截至 MySQL 5）。
- en: 'This code uses the publicly available and widely used Movielens database of
    movies and their reviews. The entire movielens dataset is widely available on
    many websites, including from the original project site: [http://grouplens.org/datasets/movielens/](http://grouplens.org/datasets/movielens/).
    Another SQL-friendly link is here: [https://github.com/ankane/movielens.sql](https://github.com/ankane/movielens.sql).
    To make it easier to work through these examples, the `CREATE` and `INSERT` statements
    for just a small subset of the relevant rows have been made available on the author''s
    GitHub site for this book: [https://github.com/megansquire/datacleaning/blob/master/ch2movies.sql](https://github.com/megansquire/datacleaning/blob/master/ch2movies.sql).
    This way, if you prefer, you can simply create this one table using that code
    and work through the following example.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了公开且广泛使用的 Movielens 数据库，包括电影及其评论。整个 Movielens 数据集在许多网站上都有广泛提供，包括原始项目网站：[http://grouplens.org/datasets/movielens/](http://grouplens.org/datasets/movielens/)。另一个
    SQL 友好的链接是：[https://github.com/ankane/movielens.sql](https://github.com/ankane/movielens.sql)。为了方便您进行示例操作，作者在本书的
    GitHub 网站上提供了只包含相关行子集的 `CREATE` 和 `INSERT` 语句：[https://github.com/megansquire/datacleaning/blob/master/ch2movies.sql](https://github.com/megansquire/datacleaning/blob/master/ch2movies.sql)。这样，如果您愿意，您可以直接使用该代码创建这一张表并进行后续的示例操作。
- en: '[PRE46]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following screenshot shows the results for the first three movies after
    running this command in phpMyAdmin on the Latin-1 encoded title column in the
    movies table within the Movielens database:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在 Movielens 数据库的电影表中的 Latin-1 编码标题列上运行此命令后，前3部电影的结果：
- en: '![Example two – finding the UTF-8 and Latin-1 equivalents of Unicode characters
    stored in MySQL](img/image00246.jpeg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![示例二 - 查找 MySQL 中存储的 Unicode 字符的 UTF-8 和 Latin-1 等价字符](img/image00246.jpeg)'
- en: Note
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any advice for converting an existing database to UTF-8?
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 有关将现有数据库转换为 UTF-8 的建议吗？
- en: Because of the ubiquity of UTF-8 on the Web and its importance in accurately
    conveying information written in natural languages from around the world, we strongly
    recommend that you create new databases in a UTF-8 encoding scheme. It will be
    far easier to start off in a UTF-8 encoding than not.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 UTF-8 在网页上的普及以及它在准确传达全球各地自然语言书写的信息中的重要性，我们强烈建议您使用 UTF-8 编码方案创建新的数据库。从一开始就使用
    UTF-8 编码要比以后再做转换容易得多。
- en: However, if you have the tables already created in a non-UTF-8 encoding, but
    they are not yet populated with data, you will have to alter the table to a UTF-8
    encoding and change the character set of each column to a UTF-8 encoding. Then,
    you will be ready to insert UTF-8 data.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您已经创建了非 UTF-8 编码的表格，但它们尚未填充数据，您需要将表格更改为 UTF-8 编码，并将每一列的字符集更改为 UTF-8 编码。然后，您就可以准备插入
    UTF-8 数据了。
- en: The hardest case is when you have a large amount of data already in a non-UTF-8
    encoding, and you want to convert it in place in the database. In this case, you
    have some planning to do. You'll have to take a different approach depending on
    whether you can get away with running commands on a few tables and/or a few columns
    or whether you have a very long list of columns and tables to adjust. In planning
    this conversion, you should consult the documentation specific to your database
    system. For example, when performing MySQL conversions, there are solutions that
    use either the `mysqldump` utility or those that use a combination of `SELECT`,
    `convert()`, and `INSERT`. You will have to determine which of these is right
    for your database system.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 最困难的情况是，当您已有大量数据采用非 UTF-8 编码，并且希望在数据库中就地转换时。在这种情况下，您需要进行一些规划。根据您是否能够仅在少量表格和/或列上运行命令，或者是否需要调整非常长的列和表格列表，您将采取不同的方法。在规划此转换时，您应参考与您的数据库系统相关的文档。例如，在执行
    MySQL 转换时，有些解决方案使用 `mysqldump` 工具，或者结合使用 `SELECT`、`convert()` 和 `INSERT`。您需要确定这些方法中的哪一种最适合您的数据库系统。
- en: Example three – handling UTF-8 encoding at the file level
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例三 – 处理文件级别的 UTF-8 编码
- en: 'Sometimes, you will need to adjust your code to deal with UTF-8 data at file
    level. Imagine a simple program designed to collect and print web content. If
    the majority of web content is now UTF-8 encoded, then our program internals need
    to be ready to handle that. Unfortunately, many programming languages still need
    a little bit of coaxing in order to handle UTF-8 encoded data cleanly. Consider
    the following example of a Python 2.7 program designed to connect to Twitter using
    its API and write 10 tweets to a file:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要调整代码以便在文件层面处理UTF-8数据。假设有一个简单的程序用于收集并打印网页内容。如果大部分网页内容现在是UTF-8编码的，那么我们的程序内部就需要准备好处理这些内容。不幸的是，许多编程语言仍然需要一些调整才能干净地处理UTF-8编码的数据。考虑以下这个Python
    2.7程序的示例，它旨在通过API连接Twitter并将10条推文写入文件：
- en: '[PRE47]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Tip
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are worried about setting up Twitter authentication in order to get the
    keys and tokens used in this script, do not worry. You can either work your way
    through the simple setup procedure at [https://dev.twitter.com/apps/new](https://dev.twitter.com/apps/new),
    or we have a much longer, in-depth example of Twitter mining in [Chapter 10](part0067.xhtml#aid-1VSLM1
    "Chapter 10. Twitter Project"), *Twitter Project*. In that chapter, we walk through
    the entire setup of a Twitter developer account and go over the tweet collection
    procedure in much more detail.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心设置Twitter认证以获取脚本中使用的密钥和令牌，请不要担心。你可以通过[https://dev.twitter.com/apps/new](https://dev.twitter.com/apps/new)上的简单设置流程，或者我们在[第10章](part0067.xhtml#aid-1VSLM1
    "Chapter 10. Twitter Project")中提供了一个更长、更深入的Twitter数据挖掘示例，*Twitter项目*。在那一章中，我们详细介绍了Twitter开发者账户的整个设置过程，并且更深入地讲解了推文收集的过程。
- en: 'This little program finds 10 recent tweets that use the keyword **DataCleaning**.
    (I chose this keyword because I recently posted several tweets full of emojis
    and UTF-8 characters using this hashtag, I was pretty sure it would quickly generate
    some nice results characters within the first 10 tweets.) However, asking Python
    to save these tweets to a file using this code results in the following error
    message:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小程序查找使用**DataCleaning**关键词的10条最近推文。（我选择这个关键词是因为我最近发布了几条包含表情符号和UTF-8字符的推文，使用了这个标签，我确信它会在前10条推文中快速生成一些不错的结果字符。）然而，当请求Python将这些推文保存到文件时，代码会抛出如下错误信息：
- en: '[PRE48]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The issue is that `open()` is not prepared to handle UTF-8 characters. We have
    two choices for a fix: strip out UTF-8 characters or change the way we write files.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`open()`函数没有准备好处理UTF-8字符。我们有两种解决方法：去除UTF-8字符或改变写入文件的方式。
- en: Option one – strip out the UTF-8 characters
  id: totrans-394
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选项一 – 去除UTF-8字符
- en: 'If we take this route, we need to understand that by stripping out characters,
    we have lost data that could be meaningful. As we discussed earlier in this chapter,
    data loss is generally an undesirable thing. Still, if we did want to strip these
    characters, we could make the following changes to the original `for` loop:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择这种方法，我们需要理解，通过去除字符，我们失去了可能有意义的数据。正如我们在本章早些时候讨论的那样，数据丢失通常是不希望发生的事情。然而，如果我们确实希望去除这些字符，我们可以对原始的`for`循环进行如下更改：
- en: '[PRE49]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This new code changes an original tweet written in Icelandic like this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码将一条原本是冰岛语的推文更改为：
- en: '[PRE50]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To this:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 对此：
- en: '[PRE51]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For text analysis purposes, this sentence no longer makes any sense as g and
    ggn are not words. This is probably not our best option for cleaning the character
    encoding of these tweets.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本分析而言，这句话已经没有任何意义，因为g和ggn不是词汇。这可能不是清理这些推文字符编码的最佳选择。
- en: Option two – write the file in a way that can handle UTF-8 characters
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选项二 – 以能够处理UTF-8字符的方式写入文件
- en: 'Another option is to just use the `codecs` or `io` libraries, which allow UTF-8
    encoding to be specified at the time the file is opened. Add an import codec line
    at the top of the file, and then change the line where you open the file like
    this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用`codecs`或`io`库，这些库允许在打开文件时指定UTF-8编码。在文件顶部添加`import codec`行，然后像这样更改打开文件的行：
- en: '[PRE52]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `a+` parameter states we want to append the data to the file if it has already
    been created.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`a+`参数表示如果文件已经存在，我们希望将数据附加到文件中。'
- en: 'Another option is to include the `io` library at the top of your program and
    then use its version of `open()`, which can be passed a particular encoding, as
    follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是在程序顶部包含`io`库，然后使用它的`open()`版本，可以传递特定的编码，如下所示：
- en: '[PRE53]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Can we just use Python 3? Why are you still using 2.7?
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能直接使用Python 3吗？为什么你还在使用2.7？
- en: It is true that Python 3 handles UTF-8 encodings more easily than Python 2.7\.
    Feel free to use Python 3 if the rest of your development environment can handle
    it. In my world, I prefer to use Enthought Canopy to work in data analysis and
    data mining and to teach my students. Many distributions of Python—Enthought included—are
    written for 2.7 and will not be moved to Python 3 for quite some time. The reason
    for this is that Python 3 made some major changes to the internals of the language
    (for example, in supporting UTF-8 encodings naturally, as we just discussed),
    and this means that there were a lot of important and useful packages that still
    have to be rewritten to work with it. This rewriting process takes a long time.
    For more on this issue, visit [https://wiki.python.org/moin/Python2orPython3](https://wiki.python.org/moin/Python2orPython3)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，Python 3比Python 2.7更容易处理UTF-8编码。如果你的开发环境能够支持，尽管使用Python 3。在我的工作中，我更倾向于使用Enthought
    Canopy进行数据分析和数据挖掘，并且用它来教学。许多Python的发行版——包括Enthought——仍然是为2.7版本编写的，并且在相当长的一段时间内不会迁移到Python
    3。原因在于，Python 3对语言的内部机制做了一些重大改动（例如，如我们刚刚讨论的那样，自然支持UTF-8编码），这意味着很多重要且有用的包仍然需要重写才能兼容。这一重写过程需要很长时间。想了解更多关于此问题的信息，请访问[https://wiki.python.org/moin/Python2orPython3](https://wiki.python.org/moin/Python2orPython3)。
- en: Summary
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'This chapter covered a whirlwind of fundamental topics that we will need in
    order to clean data in the rest of this book. Some of the techniques we learned
    here were simple, and some were exotic. We learned about file formats, compression,
    data types, and character encodings at both the file level and database level.
    In the next chapter, we will tackle two more workhorses of clean data: the spreadsheet
    and the text editor.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了许多我们在本书后续章节中清理数据时需要用到的基本主题。我们在这里学到的技术中，有些简单，有些则比较复杂。我们学习了文件格式、压缩、数据类型和字符编码，这些都涉及到文件层级和数据库层级。在下一章，我们将讨论清理数据的另两个重要工具：电子表格和文本编辑器。
