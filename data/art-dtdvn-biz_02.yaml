- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Using Machine Learning in Business Operations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在业务操作中使用机器学习
- en: Machine learning is an area of research focused on comprehending and developing
    “learning” processes, or processes that use data to enhance performance on a given
    set of tasks. It is considered to be a component of artificial intelligence. Among
    them, machine learning is a technology that enables companies to efficiently extract
    knowledge from unstructured data. With little to no programming, machine learning—and
    more precisely, machine learning algorithms—can be used to iteratively learn from
    a given dataset and comprehend patterns, behaviors, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习是一个研究领域，专注于理解和开发“学习”过程，或使用数据来提高在特定任务集上的表现。它被认为是人工智能的一个组成部分。其中，机器学习是一项技术，使企业能够高效地从非结构化数据中提取知识。在几乎不需要编程的情况下，机器学习——更准确地说，机器学习算法——可以用来从给定的数据集进行迭代学习，理解模式、行为等。
- en: 'In this chapter, we will learn how to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何做到以下几点：
- en: Validate the difference of observed effects with statistical analysis
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用统计分析验证观察到的效果差异
- en: Analyze the correlation and causation as well as model relationships between
    variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析变量之间的相关性和因果关系，并建立模型
- en: Prepare the data for clustering and machine learning models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为聚类和机器学习模型准备数据
- en: Develop machine learning models for regression and classification
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发用于回归和分类的机器学习模型
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to be able to follow the steps in this chapter, you will need to meet
    the next requirements:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够跟随本章的步骤，你需要满足以下要求：
- en: Have a Jupyter notebook instance running Python 3.7 and above. You can use the
    Google Colab notebook to run the steps as well if you have a Google Drive account.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Python 3.7及以上版本的Jupyter Notebook实例。如果你有Google Drive账户，也可以使用Google Colab Notebook运行这些步骤。
- en: Have an understanding of basic math and statistical concepts.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具备基本的数学和统计概念知识。
- en: Download the example datasets provided in the book’s GitHub page, and the original
    source is [https://python.cogsci.nl/numerical/statistics/](https://python.cogsci.nl/numerical/statistics/).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载书中GitHub页面提供的示例数据集，原始来源是[https://python.cogsci.nl/numerical/statistics/](https://python.cogsci.nl/numerical/statistics/)。
- en: Validating the effect of changes with the t-test
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用t检验验证变化的效果
- en: When measuring the effects of certain actions applied to a given population
    of users, we need to validate that these actions have actually affected the target
    groups in a significant manner. To be able to do this, we can use the t-test.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当衡量某些操作对特定用户群体的影响时，我们需要验证这些操作是否已经显著影响了目标群体。为了做到这一点，我们可以使用t检验。
- en: A t-test is a statistical test that is used to compare the means of two groups
    to ascertain whether a method or treatment has an impact on the population of
    interest or whether two groups differ from one another; it is frequently employed
    in hypothesis testing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: t检验是一种统计检验，用于比较两组的均值，以确定某种方法或治疗是否对感兴趣的人群产生影响，或者两个组是否存在差异；它通常用于假设检验。
- en: When the datasets in the two groups don’t relate to identical values, separate
    t-test samples are chosen independently of one another. They might consist of
    two groups of randomly selected, unrelated patients to study the effects of a
    medication, for example. While the other group receives the prescribed treatment,
    one of the groups serves as the control group and is given a placebo. This results
    in two separate sample sets that are unpaired and unconnected from one another.
    Simply put, the t-test is employed to compare the means of two groups. It is frequently
    employed in hypothesis testing to establish whether a procedure or treatment truly
    affects the population of interest or whether two groups differ from one another.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个组中的数据集不涉及相同的值时，独立地选择不同的t检验样本。这些样本可能包括两组随机选择的、不相关的患者群体，用来研究药物的效果。例如，其中一组接受处方治疗，另一组则作为对照组，接受安慰剂。这会产生两个独立的、无关的样本集。简单来说，t检验用于比较两组的均值。它通常用于假设检验，以确定一个方法或治疗是否真正影响了感兴趣的人群，或者两个组之间是否存在差异。
- en: The t-test is used in the context of businesses to compare two different means
    and determine whether they represent the exact same population, and it’s especially
    useful in validating the effects of promotions applied in the uplift of sales.
    Additionally, it enables firms to comprehend the likelihood that their outcomes
    are the product of chance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: t 检验在商业背景下用于比较两个不同的均值，并确定它们是否代表相同的总体，尤其在验证促销活动对销售提升的影响时非常有用。此外，它还使企业能够理解其结果是否为偶然现象的概率。
- en: We will learn how to make an independent-samples t-test using the SciPy package
    and the Matzke et al. dataset (2015). Participants in this dataset underwent a
    memory challenge in which they had to recollect a list of words. One group of
    participants focused on a central fixation dot on a display during the retention
    interval. Another group of volunteers continuously moved their eyes horizontally,
    which some people think helps with memory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用 SciPy 包和 Matzke 等人（2015）数据集进行独立样本 t 检验。该数据集中的参与者经历了一项记忆挑战，需回忆出一组单词。在保持间隔期间，一组参与者专注于显示屏上的中央固定点，而另一组志愿者则不断地水平移动眼睛，有些人认为这有助于记忆。
- en: 'To determine whether memory performance (`CriticalRecall`) was better for the
    horizontal eye movement group than the fixation group, we can utilize the `ttest_ind`
    function from the SciPy library:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了判断横向眼动组的记忆表现（`CriticalRecall`）是否优于注视组，我们可以使用 SciPy 库中的 `ttest_ind` 函数：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Figure 2.1: T-test result ](img/B19026_02_1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1：T 检验结果](img/B19026_02_1.jpg)'
- en: 'Figure 2.1: T-test result'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：T 检验结果
- en: 'The test’s p-value, which may be found on the output, is all you need to evaluate
    the t-test findings. Simply compare the output’s p-value to the selected alpha
    level to conduct a hypothesis test at the desired alpha (significance) level:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: t 检验的 p 值可以在输出结果中找到，它是你评估 t 检验结果所需的全部信息。只需将输出的 p 值与所选的 alpha 水平进行比较，即可在所需的 alpha（显著性）水平上进行假设检验：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can reject the null hypothesis if the p-value is less than your threshold
    for significance (for example, 0.05). The two means’ difference is statistically
    significant. The data from your sample is convincing enough to support the conclusion
    that the two population means are not equal:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 p 值小于设定的显著性阈值（例如 0.05），你可以拒绝原假设。两个均值之间的差异在统计上具有显著性。你的样本数据足够有说服力，支持两个总体均值不相等的结论：
- en: '![Figure 2.2: Population distribution ](img/B19026_02_2.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2：总体分布](img/B19026_02_2.jpg)'
- en: 'Figure 2.2: Population distribution'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：总体分布
- en: A high t-score, also known as a t-value, denotes that the groups are distinct,
    whereas a low t-score denotes similarity. Degrees of freedom, or the values in
    a study that can fluctuate, are crucial for determining the significance and veracity
    of the null hypothesis.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 高 t 值（也称为 t 值）表示组间差异明显，而低 t 值则表示组间相似。自由度，或研究中可能变化的值，对于确定原假设的显著性和真实性至关重要。
- en: In our example, the results indicate a noteworthy difference (p =.0066). The
    fixation group, however, outperformed the other groups, where the effect is in
    the opposite direction from what was anticipated.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，结果表明存在显著差异（p = 0.0066）。然而，固定注视组表现优于其他组，且其效果与预期方向相反。
- en: Another way to test the difference between two populations is using the paired-samples
    t-test, which compares a single group’s means for two variables. To determine
    whether the average deviates from 0, the process computes the differences between
    the values of the two variables for each occurrence. The means of two independent
    or unrelated groups are compared using an unpaired t-test. An unpaired t-test
    makes the assumption that the variance in the groups is equal. The variance is
    not expected to be equal in a paired t-test. The process also automates the calculation
    of the t-test effect size. The paired t-test is used when data are in the form
    of matched pairs, while the two-sample t-test is used when data from two samples
    are statistically independent.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种测试两个总体差异的方法是配对样本 t 检验，它比较同一组的两个变量均值。为确定平均值是否偏离 0，该过程计算每次出现时两个变量之间的差异。独立或不相关组的均值使用非配对
    t 检验进行比较。非配对 t 检验假设组间的方差相等，而配对 t 检验则不要求方差相等。该过程还自动计算 t 检验的效应量。配对 t 检验用于数据为匹配对的情况，而两样本
    t 检验用于两个样本在统计上独立的数据。
- en: Let’s use the Moore, McCabe, and Craig datasets. Here, aggressive conduct in
    dementia patients was assessed during the full moon and another lunar phase. This
    was a within-subject design because measurements were taken from every participant
    at both times.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Moore、McCabe 和 Craig 的数据集。在这里，评估了痴呆症患者在满月和其他月相期间的攻击行为。这是一个被试内设计，因为在两个时间点对每位参与者进行了测量。
- en: 'You can use the `ttest_rel` SciPy function to test whether aggression differed
    between the full moon and the other lunar phase:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `ttest_rel` SciPy 函数来检验攻击性在满月和其他月相之间是否有所不同：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see in the figure below, there was an interesting effect that was
    substantial, as the p values are never 0 as the output implies. This effect was
    such that people were indeed most violent during full moons:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，有一个有趣且显著的效应，因为 p 值从不为 0，正如输出所示。这一效应表明，人们确实在满月期间最为暴力：
- en: '![Figure 2.3: T-test result of the aggression dataset ](img/B19026_02_3.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3：攻击性数据集的 T 检验结果](img/B19026_02_3.jpg)'
- en: 'Figure 2.3: T-test result of the aggression dataset'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：攻击性数据集的 T 检验结果
- en: Another way in which we can compare the difference between two groups is the
    statistical method known as **analysis of variance** (**ANOVA**), which is used
    to examine how different means differ from one another. Ronald Fisher created
    this statistical test in 1918, and it has been in use ever since. Simply put,
    an ANOVA analysis determines whether the means of three or more independent groups
    differ statistically. So does ANOVA replace the t-test, then? Not really. ANOVA
    is used to compare the means among three or more groups, while the t-test is used
    to compare the means between two groups.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种比较两个组之间差异的方法是统计方法**方差分析**（**ANOVA**），该方法用于检查不同均值之间的差异。罗纳德·费舍尔于 1918 年创立了这一统计检验方法，并一直沿用至今。简而言之，ANOVA
    分析可以确定三个或更多独立组的均值是否在统计上存在差异。那么，ANOVA 会取代 t 检验吗？其实不会。ANOVA 用于比较三个或更多组之间的均值，而 t
    检验则用于比较两个组之间的均值。
- en: When employed in a business setting, ANOVA can be used to manage budgets by,
    for instance, comparing your budget against costs to manage revenue and inventories.
    ANOVA can also be used to manage budgets by, for instance, comparing your budget
    against costs to manage revenue and inventories. For example, in order to better
    understand how sales will perform in the future, ANOVA can also be used to forecast
    trends by examining data patterns. When assessing the multi-item scales used frequently
    in market research, ANOVA is especially helpful. Using ANOVA might assist you
    as a market researcher in comprehending how various groups react. You can start
    the test by accepting the null hypothesis, or that the means of all the groups
    that were observed are equal.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业环境中，ANOVA 可以用于预算管理，例如，将预算与成本进行比较，以管理收入和库存。ANOVA 还可以用于通过比较预算与成本来管理收入和库存。例如，为了更好地了解未来的销售表现，ANOVA
    还可以用于通过检查数据模式来预测趋势。在评估市场研究中经常使用的多项量表时，ANOVA 尤其有用。使用 ANOVA 可能会帮助你作为市场研究员理解不同群体的反应。你可以通过接受零假设开始测试，即观察到的所有组的均值是相等的。
- en: For our next example, let’s revisit the heart rate information provided by Moore,
    McCabe, and Craig. Gender and group are two subject-specific factors in this dataset,
    along with one dependent variable (heart rate). You need the following code to
    see if gender, group, or their interactions have an impact on heart rate.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，让我们重新审视 Moore、McCabe 和 Craig 提供的心率信息。性别和组别是该数据集中两个与主题相关的因素，还有一个因变量（心率）。你需要以下代码来检查性别、组别或它们的交互作用是否对心率产生影响。
- en: 'We will use a combination of `anova_lm`), which isn’t very elegant, but the
    important part is the formula:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `anova_lm` 的组合，这并不是非常优雅，但关键部分是公式：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The results show us that heart rate is related to all factors: gender (F =
    185.980, p < .001), group (F = 695.647, p < .001), and the gender-by-group interaction
    (F = 7.409, p = .006).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示心率与所有因素相关：性别（F = 185.980，p < .001）、组别（F = 695.647，p < .001）以及性别与组别的交互作用（F
    = 7.409，p = .006）。
- en: '![Figure 2.4: ANOVA test results ](img/B19026_02_4.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4：ANOVA 检验结果](img/B19026_02_4.jpg)'
- en: 'Figure 2.4: ANOVA test results'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：ANOVA 检验结果
- en: Now that we have validated that there is in fact difference between multiple
    groups, we can start to model these relationships.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了多个组之间确实存在差异，接下来可以开始对这些关系进行建模。
- en: Modeling relationships with multiple linear regression
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多元线性回归建模关系
- en: The statistical method known as multiple linear regression employs two or more
    independent variables to forecast the results of a dependent variable. Using this
    method, analysts may calculate the model’s variance and the relative contributions
    of each independent variable to the overall variance. Regressions involving numerous
    explanatory variables, both linear and nonlinear, fall under the category of multiple
    regression.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为多元线性回归的统计方法利用两个或更多的自变量来预测因变量的结果。通过这种方法，分析师可以计算模型的方差以及每个自变量对整体方差的相对贡献。涉及多个解释变量的回归，无论是线性还是非线性的，都属于多元回归范畴。
- en: The purpose of multiple regression analysis is so that researchers can evaluate
    the strength of the relationship between an outcome (the dependent variable) and
    a number of predictor variables, as well as the significance of each predictor
    to the relationship using multiple regression analysis frequently with the effect
    of other predictors statistically eliminated.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 多元回归分析的目的是让研究人员能够评估结果（因变量）与多个预测变量之间关系的强度，以及每个预测变量在关系中的重要性，通常是通过消除其他预测变量的统计效应来实现。
- en: Multiple regression includes multiple independent variables, whereas linear
    regression only takes into account one independent variable to affect the relationship’s
    slope.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 多元回归包含多个自变量，而线性回归只考虑一个自变量来影响关系的斜率。
- en: Businesses can use linear regressions to analyze trends and generate estimates
    or forecasts. For instance, if a firm’s sales have been rising gradually each
    month for the previous several years, the corporation may anticipate sales in
    the months to come by doing a linear analysis of the sales data with monthly sales.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 企业可以使用线性回归分析趋势并生成估算或预测。例如，如果一家公司的销售额在过去几年中每月逐渐上升，该公司可以通过对销售数据和每月销售额进行线性分析，预测未来几个月的销售额。
- en: Let’s use the dataset from Moore, McCabe, and Craig, which contains grade point
    averages and SAT scores for mathematics and verbal knowledge for high-school students.
    We can use the following code to test whether `satm` and `satv` are (uniquely)
    related to `gpa`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Moore、McCabe和Craig的数据集，其中包含高中生的平均绩点（GPA）和数学及语言知识的SAT成绩。我们可以使用以下代码来测试`satm`和`satv`是否与`gpa`（独立）相关。
- en: 'We will use the `OLS` SciPy function to evaluate this relationship, which is
    passed as a combination of the variables in question, and then fitted to the data:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`OLS`的SciPy函数来评估这个关系，该关系作为相关变量的组合传递，然后拟合到数据上：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Figure 2.5: OLS results ](img/B19026_02_5.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5：OLS 结果](img/B19026_02_5.jpg)'
- en: 'Figure 2.5: OLS results'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：OLS 结果
- en: The result shows us that only SAT scores for mathematics, but not for verbal
    knowledge, are uniquely related to the grade point average.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，仅数学科目的SAT成绩与平均绩点（GPA）有独特的关系，而语言科目的SAT成绩则没有。
- en: In the next section, we will look at the concepts of correlation, which is when
    variables behave in a similar manner, and causation, which is when a variable
    affects another one.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨相关性的概念，即当变量以相似的方式变化时，称为相关；而因果关系则是指一个变量影响另一个变量。
- en: Establishing correlation and causation
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立相关性和因果关系
- en: The statistical measure known as correlation expresses how closely two variables
    are related linearly, which can be understood graphically as how close two curves
    overlap. It’s a typical technique for describing straightforward connections without
    explicitly stating cause and consequence.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为相关性的统计量表示了两个变量之间线性关系的紧密程度，可以通过图形方式理解为两个曲线重叠的程度。这是一种描述简单关系的典型方法，而不明确指出因果关系。
- en: The correlation matrix displays the correlation values, which quantify how closely
    each pair of variables is related linearly. The correlation coefficients have
    a range of -1 to +1\. The correlation value is positive if the two variables tend
    to rise and fall together.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 相关矩阵显示了相关值，用于量化每一对变量之间的线性关系的紧密程度。相关系数的范围是-1到+1。如果两个变量有相似的上升和下降趋势，相关值为正。
- en: The four types of correlations that are typically measured in statistics are
    the Spearman correlation, Pearson correlation, Kendall rank correlation, and the
    point-biserial correlation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 统计中通常测量的四种相关性类型是斯皮尔曼相关系数、皮尔逊相关系数、肯达尔秩相关系数和点二列相关系数。
- en: In order for organizations to make data-driven decisions based on forecasting
    the result of events, correlation and regression analysis are used to foresee
    future outcomes. The two main advantages of correlation analysis are that it enables
    quick hypothesis testing and assists businesses in deciding which variables they
    wish to look into further. To determine the strength of the linear relationship
    between two variables, the primary type of correlation analysis applies Pearson’s
    `r` formula.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使组织能够根据预测事件结果做出数据驱动的决策，通常使用相关性和回归分析来预测未来的结果。相关性分析的两个主要优点是它能够快速进行假设检验，并帮助企业决定要进一步探究哪些变量。为了确定两个变量之间线性关系的强度，相关性分析的主要方法是应用
    Pearson 的 `r` 公式。
- en: Using the `corr` method in a pandas data frame, we can calculate the pairwise
    correlation of columns while removing NA/null values. The technique can be passed
    as a parameter with the `pearson` or `kendall` values for the standard correlation
    coefficient, `spearman` for the Spearman rank correlation, or `kendall` for the
    Kendall Tau correlation coefficient.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pandas 数据框中的 `corr` 方法，我们可以计算列的成对相关性，并删除 NA/null 值。该技术可以作为参数传递，`pearson`
    或 `kendall` 为标准相关系数，`spearman` 为斯皮尔曼等级相关性，或者 `kendall` 为 Kendall Tau 相关系数。
- en: 'The `corr` method in a pandas data frame returns a matrix of floats from 1
    along the diagonals and symmetric regardless of the callable’s behavior:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 数据框中的 `corr` 方法返回一个浮动矩阵，对角线上为 1，并且无论调用函数的行为如何，都是对称的：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can plot the results correlation matrix using a seaborn heatmap:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 seaborn 热图来绘制结果的相关性矩阵：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Figure 2.6: Correlation matrix ](img/B19026_02_6.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6: 相关性矩阵](img/B19026_02_6.jpg)'
- en: 'Figure 2.6: Correlation matrix'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '图 2.6: 相关性矩阵'
- en: Finding groups of highly correlated features and only maintaining one of them
    is the main goal of employing pairwise correlation for feature selection, which
    aims to maximize the predictive value of your model by using the fewest number
    of features possible.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 利用成对相关性进行特征选择的主要目标是找到高度相关的特征组，并仅保留其中一个，这样可以通过尽可能少的特征来最大化模型的预测值。
- en: 'Pairwise correlation is calculated between rows or columns of a DataFrame and
    rows or columns of a Series or DataFrame. The correlations are calculated after
    DataFrames have been aligned along both axes. Next, we can see an example that
    might make it more clear:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 成对相关性是在 DataFrame 的行或列与 Series 或 DataFrame 的行或列之间计算的。相关性是在对齐了 DataFrame 的两个轴之后计算的。接下来，我们可以看到一个例子，可能会更清楚一些：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use `corr` to compare numerical columns within the same data frame. Non-numerical
    columns will automatically be skipped:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `corr` 来比较同一数据框内的数值型列。非数值型列将自动被跳过：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Figure 2.7: Correlation matrix ](img/B19026_02_7.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7: 相关性矩阵](img/B19026_02_7.jpg)'
- en: 'Figure 2.7: Correlation matrix'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '图 2.7: 相关性矩阵'
- en: 'We can also compare the columns of `df1` and `df2` with `corrwith`. Note that
    only columns with the same names are compared:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `corrwith` 比较 `df1` 和 `df2` 的列。请注意，只有具有相同名称的列才会被比较：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To make things easier, we can rename the columns of `df2` to match the columns
    of `df1` if we would like for pandas to disregard the column names and only compare
    the first row of `df1` to the first row of `df2`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化操作，如果我们希望 pandas 忽略列名并仅比较 `df1` 的第一行与 `df2` 的第一行，可以将 `df2` 的列名重命名为与 `df1`
    匹配：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s important to note that `df1` and `df2` need to have the same number of
    columns in that case.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在这种情况下，`df1` 和 `df2` 必须具有相同的列数。
- en: 'Last but not least, you could also just horizontally combine the two datasets
    and utilize `corr`. The benefit is that this essentially functions independently
    of the quantity and naming conventions of the columns, but the drawback is that
    you can receive more output than you require or want:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你也可以将这两个数据集水平合并，并使用 `corr`。其优点在于，它基本上独立于列的数量和命名规则，但缺点是你可能会得到超出需要或想要的输出：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Figure 2.8: Correlation heatmap ](img/B19026_02_8.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8: 相关性热图](img/B19026_02_8.jpg)'
- en: 'Figure 2.8: Correlation heatmap'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '图 2.8: 相关性热图'
- en: Now that we have established the fact that two variables can be correlated using
    correlation analysis, we can seek to validate whether the variables are actually
    impacting one another using causation analysis.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认了通过相关性分析可以找出两个变量之间的相关性，我们可以尝试通过因果分析验证这些变量是否真正相互影响。
- en: The ability of one variable to impact another is known as causality. The first
    variable might create the second or might change the incidence of the second variable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量对另一个变量的影响能力被称为因果关系。第一个变量可能会产生第二个变量，或者可能会改变第二个变量的发生频率。
- en: Causality is the process by which one event, process, state, or object influences
    the development of another event, process, condition, or object, where the cause
    and effect are both partially reliant on each other. So what distinguishes correlation
    from causation? Correlation does not automatically imply causation, even if causality
    and correlation might coexist. In situations where action A results in outcome
    B, causation is expressly applicable. Correlation, on the other hand, is just
    a relationship.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因果关系是一个事件、过程、状态或对象影响另一个事件、过程、条件或对象发展的过程，其中原因和结果是相互依赖的。那么，相关性与因果关系有什么区别呢？相关性并不自动意味着因果关系，即使因果关系和相关性可能同时存在。在
    A 行动导致 B 结果的情况下，因果关系明确适用。另一方面，相关性只是两者之间的关系。
- en: 'We can use the next dataset to study the causation between variables:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下数据集来研究变量之间的因果关系：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To study the causation, we can seek to estimate the difference in means between
    two groups. The absolute difference between the mean values in two different groups
    is measured by the mean difference, often known as the difference in means. It
    offers you a sense of how much the averages of the experimental group and control
    groups differ from one another in clinical studies.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了研究因果关系，我们可以尝试估算两组之间的均值差异。两组之间均值的绝对差异被称为均值差异，通常称为均值之差。它让你了解在临床研究中，实验组和对照组的平均值有多大差异。
- en: 'In the next example, we will estimate the uplift as a quantified difference
    in means along with the determined standard error. We will use 90 as the confidence
    interval in the range of the normal, which yields a z-score of 1.96:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将估算提升量作为均值差异的量化值，并计算确定的标准误差。我们将使用 90 作为正态分布范围内的置信区间，这将得到一个 z 值为 1.96：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Figure 2.9: Estimated differences between populations ](img/B19026_02_9.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9: 人群之间的估计差异](img/B19026_02_9.jpg)'
- en: 'Figure 2.9: Estimated differences between populations'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '图 2.9: 人群之间的估计差异'
- en: We can also use the contingency `chi-square` for the comparison of two groups
    with a dichotomous dependent variable. For example, we might contrast males and
    females using a yes/no response scale. The contingency chi-square is built on
    the same ideas as the straightforward chi-square analysis, which compares the
    anticipated and actual outcomes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用列联 `卡方` 检验来比较具有二分依赖变量的两组。例如，我们可以使用是/否响应尺度对男性和女性进行对比。列联卡方检验基于与简单卡方分析相同的原理，该分析比较预期结果与实际结果。
- en: 'This statistical technique is used to compare actual outcomes with predictions.
    The goal of this test is to establish whether a discrepancy between observed and
    expected data is the result of chance or a correlation between the variables you
    are researching. The results create a contingency matrix from which we can infer
    that your variables are independent of one another and have no association with
    one another if C is close to zero (or equal to zero). There is a relationship
    if C is not zero; C can only take on positive values:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种统计技术用于将实际结果与预测结果进行比较。此测试的目的是确定观察到的数据与预期数据之间的差异是否是偶然的，还是研究变量之间的相关性。结果会生成一个列联矩阵，从中我们可以推断，如果
    C 接近零（或等于零），则变量之间相互独立且没有关联。如果 C 不为零，则存在某种关系；C 只能取正值：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we will just seek to interpret the p-values:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将仅尝试解释 p 值：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Figure 2.10: Resulting p-value ](img/B19026_02_10.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10: 结果 p 值](img/B19026_02_10.jpg)'
- en: 'Figure 2.10: Resulting p-value'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '图 2.10: 结果 p 值'
- en: 'Now we will use a set of datasets that were synthetically generated:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用一组合成生成的数据集：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Figure 2.11: Plot of data distribution ](img/B19026_02_11.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11: 数据分布图](img/B19026_02_11.jpg)'
- en: 'Figure 2.11: Plot of data distribution'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '图 2.11: 数据分布图'
- en: 'The probability density function of a continuous random variable can be estimated
    using the **kernel density estimation** (**KDE**) seaborn method. The area under
    the depicted curve serves as a representation of the probability distribution
    of the data values:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 连续随机变量的概率密度函数可以通过 **核密度估计**（**KDE**）seaborn 方法来估计。图中曲线下方的区域代表了数据值的概率分布：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Figure 2.12: Density graph ](img/B19026_02_12.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12: 密度图](img/B19026_02_12.jpg)'
- en: 'Figure 2.12: Density graph'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：密度图
- en: To study causation, the researcher must build a model to describe the connections
    between ideas connected to a particular phenomenon in causal modeling.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了研究因果关系，研究人员必须建立一个模型，以描述在因果建模中与特定现象相关的思想之间的联系。
- en: Multiple causality—the idea that any given outcome may have more than one cause—is
    incorporated into causal models. For instance, social status, age, sex, ethnicity,
    and other factors may influence someone’s voting behavior. In addition, some of
    the independent or explanatory factors might be connected.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 多重因果性——即任何给定结果可能有多个原因——被纳入因果模型。例如，社会地位、年龄、性别、种族和其他因素可能会影响一个人的投票行为。此外，一些独立或解释变量可能是相互关联的。
- en: External validity can be addressed using causal models (whether results from
    one study apply to unstudied populations). In some cases, causal models can combine
    data to provide answers to questions that no single dataset alone is able to address.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 外部效度可以通过因果模型来解决（即一个研究的结果是否适用于未研究的群体）。在某些情况下，因果模型可以结合数据提供一些单一数据集无法解决的问题的答案。
- en: We can use the `est_via_ols` function of the `causalinference` package to estimate
    average treatment effects using least squares.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`causalinference`包中的`est_via_ols`函数，通过最小二乘法估计平均处理效应。
- en: Here, *y* is the potential outcome when treated, D is the treatment status,
    and X is a vector of covariates or individual characteristics.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*y*是处理后的潜在结果，D是处理状态，X是协变量或个体特征的向量。
- en: The parameter to control is `adj`, an int which can be either 0, 1, or 2\. This
    parameter indicates how covariate adjustments are to be performed. Setting `adj`
    to 0 will not include any covariates. Set `adj` to 1 to include treatment indicator
    D and covariates X separately, or set `adj` to 2 to additionally include interaction
    terms between D and X. The default is 2.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 控制的参数是`adj`，一个整数，可以是0、1或2。该参数指示如何执行协变量调整。将`adj`设置为0时，将不包括任何协变量。将`adj`设置为1时，分别包括处理指示变量D和协变量X，或者将`adj`设置为2时，还包括D与X之间的交互项。默认值是2。
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Figure 2.13: Causal model results ](img/B19026_02_13.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13：因果模型结果](img/B19026_02_13.jpg)'
- en: 'Figure 2.13: Causal model results'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：因果模型结果
- en: The estimates show us that there is a negative relationship between the variables.
    The negative estimate might be an indication that the application of D reduces
    the probability of Y by 48%. It’s really important to look at the entire set of
    estimate distributions to draw any conclusions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 估计结果显示，变量之间存在负相关关系。负估计可能表明，D的应用使Y的概率降低了48%。观察所有估计分布以得出结论非常重要。
- en: 'The analysis of a hypothetical or counterfactual reality is causal analysis,
    because we must make claims about the counterfactual result that we did not witness
    in order to assess the treatment effect:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设或反事实现实的分析是因果分析，因为我们必须对我们没有目睹的反事实结果做出假设，以评估处理效应：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The data previously loaded will show us different values in the causal model:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 之前加载的数据将向我们展示因果模型中的不同值：
- en: '![Figure 2.14: Data distribution ](img/B19026_02_14.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14：数据分布](img/B19026_02_14.jpg)'
- en: 'Figure 2.14: Data distribution'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：数据分布
- en: 'We will build the new causal model using the new loaded values:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用新加载的值构建新的因果模型：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can print the treatment effect estimates to validate whether our causal
    model is valid:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印处理效应估计值，以验证我们的因果模型是否有效：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Figure 2.15: Causal model results with new data ](img/B19026_02_15.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15：使用新数据的因果模型结果](img/B19026_02_15.jpg)'
- en: 'Figure 2.15: Causal model results with new data'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：使用新数据的因果模型结果
- en: The estimates inform us that the relationship has become positive.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 估计结果告诉我们，关系已经变为正相关。
- en: Causal models are a great way to validate the modeling and direction of relationships
    between the variables in data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因果模型是验证数据中变量关系建模和方向的好方法。
- en: In the next section, we will dive into how we can use scaling to prepare our
    data for machine learning, depending on the distribution that it has.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨如何使用缩放方法准备我们的数据，以适应机器学习，具体取决于数据的分布情况。
- en: Scaling features to a range
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征缩放到一个范围
- en: When working with machine learning models, it is important to preprocess data
    so certain problems such as an explosion of gradients or lack of proper distribution
    representation can be solved.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用机器学习模型时，数据预处理非常重要，以便解决诸如梯度爆炸或分布不均等问题。
- en: To transform raw feature vectors into a representation that is better suited
    for the downstream estimators, the `sklearn.preprocessing` package offers a number
    of common utility functions and transformer classes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将原始特征向量转换为更适合下游估算器的表示，`sklearn.preprocessing`包提供了多个常用的实用函数和转换器类。
- en: 'Many machine learning estimators used in `scikit-learn` frequently require
    dataset standardization; if the individual features do not more or less resemble
    standard normally distributed data, they may behave poorly: Gaussian with a mean
    of 0 and a variation of 1.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 许多在`scikit-learn`中使用的机器学习估算器通常需要数据集标准化；如果单个特征不大致符合标准正态分布，它们的表现可能很差：均值为0，方差为1的高斯分布。
- en: In general, standardizing the dataset is advantageous for learning algorithms.
    Robust scalers or transformers are preferable if there are any outliers in the
    collection. On a dataset with marginal outliers, the actions of several scalers,
    transformers, and normalizers are highlighted in the analysis of the impact of
    various scalers on data containing outliers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，标准化数据集对学习算法是有利的。如果数据集中存在异常值，建议使用鲁棒的缩放器或转换器。在包含边际异常值的数据集上，分析不同缩放器对包含异常值的数据影响时，突出显示了多个缩放器、转换器和归一化器的作用。
- en: In reality, we frequently ignore the distribution’s shape and simply adapt the
    data to scale by dividing non-constant features by their standard deviation and
    centering it by subtracting each feature’s mean value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们通常忽略分布的形状，简单地通过将非恒定特征除以其标准差并通过减去每个特征的均值来使数据适应缩放。
- en: For instance, several components of a learning algorithm’s objective function
    (such as the RBF kernel of SVMs or the l1 and l2 regularizers of linear models)
    may make the assumption that all features are centered around zero or have variance
    in the same order. A feature may dominate the objective function and prevent the
    estimator from successfully inferring from other features as expected if its variance
    is orders of magnitude greater than that of other features.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，学习算法的目标函数的多个组件（如支持向量机的RBF核函数或线性模型的l1和l2正则化项）可能假设所有特征都围绕零居中，或者它们的方差在相同数量级上。如果一个特征的方差比其他特征大几个数量级，它可能主导目标函数，阻止估算器根据其他特征进行正确推断。
- en: 'The `StandardScaler` utility class, which the preprocessing module offers,
    makes it quick and simple to carry out the following operation on an array-like
    dataset:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`StandardScaler`实用程序类，作为预处理模块的一部分，能够快速简单地对类数组数据集执行以下操作：'
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following code will fit the scaler to the data, assuming that our distribution
    is standard:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将拟合缩放器到数据，假设我们的分布是标准的：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can visualize now the mean of the data:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以可视化数据的均值：
- en: '![Figure 2.16: Mean of the data ](img/B19026_02_16.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16：数据的均值](img/B19026_02_16.jpg)'
- en: 'Figure 2.16: Mean of the data'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16：数据的均值
- en: 'We can visualize the scale as well:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以可视化缩放：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The data is shown as an array of values:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 数据显示为一组值：
- en: '![Figure 2.17: Scale of the columns ](img/B19026_02_17.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17：列的缩放](img/B19026_02_17.jpg)'
- en: 'Figure 2.17: Scale of the columns'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17：列的缩放
- en: 'Finally, we can scale the data using the `transform` method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`transform`方法来缩放数据：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A different method of standardization is to scale each feature’s maximum absolute
    value to one unit, or to a value between a predetermined minimum and maximum value,
    usually zero and one. `MaxAbsScaler` or `MinMaxScaler` can be used to do this.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种标准化方法是将每个特征的最大绝对值缩放到单位一，或缩放到一个预定的最小值和最大值之间，通常是零和一。可以使用`MaxAbsScaler`或`MinMaxScaler`来实现这一点。
- en: The robustness to very small standard deviations of features and the preservation
    of zero entries in sparse data are two reasons to employ this scaling.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对非常小的特征标准差的鲁棒性以及在稀疏数据中保留零值是使用这种缩放的两个原因。
- en: 'To scale a toy data matrix to the [0, 1] range, consider the following example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个玩具数据矩阵缩放到[0, 1]范围，请参考以下示例：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In case our distribution differs from the standard Gaussian, we can use non-linear
    transformations. There are two different kinds of transformations: power and quantile
    transform. The rank of the values along each feature is preserved by both quantile
    and power transforms because they are based on monotonic transformations of the
    features.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的分布与标准高斯分布不同，可以使用非线性变换。变换有两种不同的类型：幂变换和分位数变换。分位数和幂变换都通过单调变换保持每个特征的值的秩，因此它们可以保留特征的秩。
- en: 'Based on the formula, which is the cumulative distribution function of the
    feature and the quantile function of the desired output distribution, quantile
    transformations place all features into the same desired distribution. These two
    facts are used in this formula: it is uniformly distributed if it is a random
    variable with a continuous cumulative distribution function, and it has distribution
    if it is a random variable with a uniform distribution on. A quantile transform
    smoothes out atypical distributions using a rank transformation and is less susceptible
    to outliers than scaling techniques. Correlations and distances within and between
    features are, however, distorted by it.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 基于公式，它是特征的累积分布函数与所需输出分布的分位数函数，分位数变换将所有特征转换为相同的目标分布。这两个事实被应用于该公式：如果是具有连续累积分布函数的随机变量，则均匀分布；如果是具有均匀分布的随机变量，则具有分布。分位数变换通过排名变换平滑掉不典型的分布，相比缩放技术，它对异常值的敏感性较低。然而，它会扭曲特征内部和特征之间的相关性和距离。
- en: Sklearn provides a series of parametric transformations called power transforms
    that aim to translate data from any distribution to one that resembles a Gaussian
    distribution as closely as possible.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Sklearn 提供了一系列称为幂变换的参数变换，旨在将数据从任何分布转换为尽可能接近高斯分布的分布。
- en: 'We can map our data to a uniform distribution using `QuantileTransformer`,
    which provides a non-parametric transformation to map the data to a uniform distribution
    with values between 0 and 1:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `QuantileTransformer` 将数据映射到均匀分布，它提供了一种非参数变换，将数据映射到一个值介于 0 和 1 之间的均匀分布：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can see the resulting array:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到得到的数组：
- en: '![Figure 2.18: Transformed data ](img/B19026_02_18.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18：转换后的数据](img/B19026_02_18.jpg)'
- en: 'Figure 2.18: Transformed data'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18：转换后的数据
- en: 'It is also possible to map data to a normal distribution using `QuantileTransformer`
    by setting `output_distribution=''normal''`. The following example uses the earlier
    example with the `iris` dataset:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过设置 `output_distribution='normal'`，使用 `QuantileTransformer` 将数据映射到正态分布。以下示例使用了之前的
    `iris` 数据集：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Figure 2.19: Transformed data through the quantiles method ](img/B19026_02_19.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.19：通过分位数方法转换的数据](img/B19026_02_19.jpg)'
- en: 'Figure 2.19: Transformed data through the quantiles method'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19：通过分位数方法转换的数据
- en: The preceding code will scale the data using a quantile transformation, defining
    five quantiles and looking to have a normal distribution in the output.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将使用分位数变换对数据进行缩放，定义五个分位数，并期望输出具有正态分布。
- en: To determine the proper distribution to be utilized, we need to analyze in depth
    the distribution of our variables, as the wrong transformation can make us lose
    details that might be important to take into account.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定要使用的适当分布，我们需要深入分析我们变量的分布，因为错误的变换可能会导致我们丧失可能需要考虑的重要细节。
- en: In the next section, we will dive into unsupervised learning by looking at clustering
    algorithms using scikit-learn.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过使用 scikit-learn 的聚类算法深入探讨无监督学习。
- en: Clustering data and reducing the dimensionality
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚类数据与降维
- en: The process of clustering involves grouping the population or data points into
    a number of groups so that the data points within each group are more similar
    to one another than the data points within other groups. Simply said, the goal
    is to sort any groups of people who share similar characteristics into clusters.
    It is frequently used in business analytics. How to arrange the enormous volumes
    of available data into useful structures is one of the issues that organizations
    are currently confronting.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类过程涉及将总体或数据点分成若干组，使得每组内的数据点彼此之间比其他组的数据点更相似。简单来说，目标是将具有相似特征的人群排序成簇。它在商业分析中常常被使用。如何将大量可用数据整理成有用的结构，是当前组织面临的一个问题。
- en: Image segmentation, grouping web pages, market segmentation, and information
    retrieval are four examples of how clustering can help firms better manage their
    data. Data clustering is beneficial for retail firms since it influences sales
    efforts, customer retention, and customer shopping behavior.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图像分割、网页分组、市场细分和信息检索是聚类如何帮助企业更好地管理数据的四个例子。数据聚类对于零售公司非常有益，因为它影响销售努力、客户保持和客户购物行为。
- en: The goal of the vector quantization technique known as “K-means clustering,”
    which has its roots in signal processing, is to divide a set of n observations
    into k clusters, each of which has as its prototype in the observation with the
    closest mean. K-means clustering is an unsupervised technique that uses the input
    data as is and doesn’t require a labeled response. A popular method for clustering
    is K-means clustering. Typically, practitioners start by studying the dataset’s
    architecture. Data points are grouped by K-means into distinct, non-overlapping
    groups.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 向量量化技术“**K-means聚类**”的目标，起源于信号处理，是将n个观测值划分为k个簇，每个簇的原型是与其均值最接近的观测值。K-means聚类是一种无监督的技术，它使用输入数据本身，并且不需要标签化的响应。K-means聚类是一种流行的聚类方法。通常，实践者首先研究数据集的结构。数据点被K-means分为不同的、不重叠的组。
- en: 'In the next code, we can use `KMeans` to fit the data in order to label each
    data point to a given cluster:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码中，我们可以使用`KMeans`来拟合数据，以便将每个数据点标记为某个给定的簇：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Figure 2.20: Cluster data ](img/B19026_02_20.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20：聚类数据](img/B19026_02_20.jpg)'
- en: 'Figure 2.20: Cluster data'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20：聚类数据
- en: 'We can predict to which cluster each new instance of data belongs:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以预测每个新的数据实例属于哪个聚类：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Figure 2.21: Predicted data ](img/B19026_02_21.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.21：预测数据](img/B19026_02_21.jpg)'
- en: 'Figure 2.21: Predicted data'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21：预测数据
- en: 'We can also visualize the cluster centers:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以可视化聚类中心：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Figure 2.22: Cluster centers ](img/B19026_02_22.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.22：聚类中心](img/B19026_02_22.jpg)'
- en: 'Figure 2.22: Cluster centers'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22：聚类中心
- en: '`KMeans` allows us to find the characteristics in common data when the number
    of variables is too high and it’s useful for segmentation. But sometimes, there
    is the need to reduce the number of dimensions to a set of grouped variables with
    common traits.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`KMeans` 使我们能够在变量过多时找到共同数据的特征，并且对分割很有帮助。但有时需要将维度减少到一组具有共同特征的变量。'
- en: In order to project the data into a lower dimensional environment, we can use
    `TruncatedSVD` class.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据投影到一个低维环境中，我们可以使用`TruncatedSVD`类。
- en: 'Up next, we fit data into two components in order to reduce the dimensionality:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将数据拟合到两个组件中，以减少维度：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We should strive to account for the maximum amount of variance possible, which
    in simple terms can be understood as the degree to which our model can explain
    the whole dataset:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该努力解释尽可能多的方差，简单来说，就是我们模型能够解释整个数据集的程度：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Figure 2.23: PCA singular values ](img/B19026_02_23.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.23：PCA奇异值](img/B19026_02_23.jpg)'
- en: 'Figure 2.23: PCA singular values'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23：PCA奇异值
- en: After we have worked our data to preprocess it, reducing the number of dimensions
    and clustering, we can now build machine learning models to make predictions of
    future behavior.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对数据进行预处理、减少维度并进行聚类之后，现在可以构建机器学习模型，预测未来的行为。
- en: In the next section, we will build machine learning models that we can use to
    predict new data labels for regression and classification tasks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将构建机器学习模型，用于预测回归和分类任务中的新数据标签。
- en: Building machine learning models
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建机器学习模型
- en: One of the most simple machine learning models we can construct to make a forecast
    of future behaviors is linear regression, which reduces the residual sum of squares
    between the targets observed in the dataset and the targets anticipated by the
    linear approximation, fitting a linear model using coefficients.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建的最简单的机器学习模型之一是线性回归，它通过最小化数据集中观察到的目标与线性近似预测目标之间的残差平方和，拟合一个线性模型，并使用系数。
- en: This is simply ordinary least squares or non-negative least squares wrapped
    in a predictor object from the implementation perspective.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从实现角度来看，这实际上是普通最小二乘法或非负最小二乘法，通过预测器对象进行封装。
- en: 'We can implement this really simply by using the `LinearRegression` class in
    Sklearn:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用Sklearn中的`LinearRegression`类来非常简单地实现这一点：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![Figure 2.24: Model regression score ](img/B19026_02_24.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.24：模型回归得分](img/B19026_02_24.jpg)'
- en: 'Figure 2.24: Model regression score'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.24：模型回归得分
- en: The preceding code will fit a linear regression model to our data and print
    the score of our data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将为我们的数据拟合一个线性回归模型，并打印出数据的得分。
- en: 'We can also print the coefficients, which give us a great estimation of the
    contribution of each variable to explain the variable we are trying to predict:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以打印出系数，这可以很好地估计每个变量对解释我们要预测的变量的贡献：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![Figure 2.25: Regression coefficients ](img/B19026_02_25.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.25：回归系数](img/B19026_02_25.jpg)'
- en: 'Figure 2.25: Regression coefficients'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.25：回归系数
- en: 'We can also print the intercept variables:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以打印截距变量：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![Figure 2.26: Regression intercepts ](img/B19026_02_26.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.26：回归截距](img/B19026_02_26.jpg)'
- en: 'Figure 2.26: Regression intercepts'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.26：回归截距
- en: 'Finally, we can use the model to make predictions:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用模型进行预测：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Figure 2.27: Predicted regression values ](img/B19026_02_27.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.27：预测的回归值](img/B19026_02_27.jpg)'
- en: 'Figure 2.27: Predicted regression values'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.27：预测的回归值
- en: Here we are predicting a continuous variable, but we can also predict categorical
    variables using a classifier instead of a regression.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们预测的是一个连续变量，但我们也可以使用分类器而非回归来预测分类变量。
- en: Sklearn gives us the option of using the logistic regression (`logit` and `MaxEnt`)
    classifier, in which in the multiclass case, the training algorithm uses the one-vs-rest
    (`OvR`) scheme if the `'multi_class'` option is set to ‘`ovr'` and uses the cross-entropy
    loss if the `'multi_class'` option is set to `'multinomial'`. This class uses
    the `'liblinear'` library, `'newton-cg','sag','saga'`, and the `'lbfgs'` solvers
    to implement regularized logistic regression. Keep in mind that regularization
    is used by default. Both dense and sparse input can be handled by it. For best
    speed, only use matrices with 64-bit floats; all other input formats will be transformed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Sklearn 让我们可以选择使用逻辑回归（`logit` 和 `MaxEnt`）分类器，在多类情况下，如果将 `'multi_class'` 选项设置为
    '`ovr`'，训练算法会使用一对多（`OvR`）方案；如果将 `'multi_class'` 选项设置为 `'multinomial'`，则会使用交叉熵损失。该类使用
    `'liblinear'` 库，`'newton-cg'`、`'sag'`、`'saga'` 和 `'lbfgs'` 求解器来实现正则化逻辑回归。请记住，正则化是默认启用的。它可以处理稠密和稀疏输入。为了获得最佳速度，仅使用
    64 位浮动矩阵；所有其他输入格式将会转换。
- en: The sole regularization supported by the `"newton-cg,"` `"sag,"` and `"lbfgs"`
    solvers is the L2 regularization with the primal formulation. The `"liblinear"`
    solver supports both the L1 and L2 regularizations, however, only the L2 penalty
    has a dual formulation. The only solver that supports the elastic net regularization
    is the `"``saga"` solver.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`"newton-cg"`、`"sag"` 和 `"lbfgs"` 求解器唯一支持的正则化是具有原始公式的 L2 正则化。`"liblinear"`
    求解器支持 L1 和 L2 正则化，但只有 L2 惩罚项具有对偶公式。唯一支持弹性网正则化的求解器是 `"saga"` 求解器。'
- en: 'When fitting the model, the underlying C program chooses features using a random
    number generator. Thus, slightly varied outputs for the same input data are common.
    Try using a smaller `tol` parameter if it occurs:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在拟合模型时，底层的 C 程序通过随机数生成器选择特征。因此，对于相同的输入数据，稍有不同的输出是常见的。如果发生这种情况，可以尝试使用较小的 `tol`
    参数：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![Figure 2.28: Logistic regression results ](img/B19026_02_28.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.28：逻辑回归结果](img/B19026_02_28.jpg)'
- en: 'Figure 2.28: Logistic regression results'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.28：逻辑回归结果
- en: 'We can also score the model to assess the precision of our predictions:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对模型进行评分，以评估预测的精度：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![Figure 2.29: User data ](img/B19026_02_29.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.29：用户数据](img/B19026_02_29.jpg)'
- en: 'Figure 2.29: User data'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.29：用户数据
- en: In order to validate the model, we can use cross-validation, which allows us
    to evaluate the estimator’s performance. This is a methodological error in learning
    the parameters of a prediction function and evaluating it on the same set of data.
    A model that simply repeats the labels of the samples it has just seen would score
    well but be unable to make any predictions about data that has not yet been seen.
    Overfitting is the term for this circumstance. It is customary to reserve a portion
    of the available data as a test set (x test, y test) when conducting a (supervised)
    machine learning experiment in order to avoid this problem.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证模型，我们可以使用交叉验证，这允许我们评估估算器的性能。这是学习预测函数参数并在同一数据集上评估它的一个方法学错误。一个仅仅重复它刚刚看到的样本标签的模型会得分较高，但无法对尚未见过的数据做出预测。过拟合是这种情况的术语。为了避免这个问题，在进行（有监督的）机器学习实验时，通常会预留一部分可用数据作为测试集（x
    测试，y 测试）。
- en: It should be noted that the term “experiment” does not just refer to academic
    purposes because machine learning experiments sometimes begin in commercial contexts
    as well. Grid search methods can be used to find the optimal parameters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，“实验”一词不仅仅指学术目的，因为机器学习实验有时也始于商业环境。网格搜索方法可用于寻找最优参数。
- en: 'In `scikit-learn`, a random split into training and test sets can be quickly
    computed with the `train_test_split` helper function. Let’s load the `iris` dataset
    to fit a linear support vector machine on it:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`scikit-learn`中，可以使用`train_test_split`辅助函数快速将数据随机划分为训练集和测试集。我们加载`iris`数据集，并在其上训练一个线性支持向量机：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![Figure 2.30: Data shape ](img/B19026_02_30.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图2.30：数据形状](img/B19026_02_30.jpg)'
- en: 'Figure 2.30: Data shape'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.30：数据形状
- en: 'We can now quickly sample a training set while holding out 40% of the data
    for testing (evaluating) our classifier:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以快速采样一个训练集，同时保留40%的数据用于测试（评估）我们的分类器：
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can validate the shape of the generated train dataset by looking at the
    `numpy` array shape:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看`numpy`数组的形状来验证生成的训练数据集的形状：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![Figure 2.31: Train data shape ](img/B19026_02_31.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图2.31：训练数据形状](img/B19026_02_31.jpg)'
- en: 'Figure 2.31: Train data shape'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.31：训练数据形状
- en: 'We can repeat the same with the `test` dataset:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对`test`数据集执行相同操作：
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![Figure 2.32: Test data shape ](img/B19026_02_32.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图2.32：测试数据形状](img/B19026_02_32.jpg)'
- en: 'Figure 2.32: Test data shape'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.32：测试数据形状
- en: 'Finally, we can train our machine learning model on the training data and score
    it using the `test` dataset, which holds data points not seen by the model during
    training:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在训练数据上训练我们的机器学习模型，并使用`test`数据集对其进行评分，该数据集包含模型在训练过程中未见过的数据点：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![Figure 2.33: Logistic regression scores ](img/B19026_02_33.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图2.33：逻辑回归评分](img/B19026_02_33.jpg)'
- en: 'Figure 2.33: Logistic regression scores'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.33：逻辑回归评分
- en: 'There is still a chance of overfitting on the test set when comparing various
    settings of hyperparameters for estimators, such as the C setting that must be
    manually selected for an SVM. This is because the parameters can be adjusted until
    the estimator performs at its best. In this method, the model may “leak” information
    about the test set, and evaluation measures may no longer reflect generalization
    performance. This issue can be resolved by holding out a further portion of the
    dataset as a “validation set”: training is conducted on the training set, followed
    by evaluation on the validation set, and when it appears that the experiment has
    succeeded, a final evaluation can be conducted on the test set.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较不同超参数设置时，仍然有可能出现过拟合现象，例如SVM中必须手动选择的C参数。这是因为参数可以调整直到估计器的表现最佳。在这种方法中，模型可能会“泄漏”测试集的信息，从而导致评估度量无法准确反映泛化性能。这个问题可以通过进一步从数据集中留出一部分作为“验证集”来解决：首先在训练集上进行训练，然后在验证集上进行评估，当实验成功时，最后可以在测试集上进行最终评估。
- en: However, by dividing the available data into three sets, we dramatically cut
    down on the number of samples that can be used to train the model, and the outcomes
    can vary depending on the randomization of the pair of (train and validation)
    sets.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过将可用数据划分为三组，我们大幅减少了可用于训练模型的样本数量，且根据训练集和验证集的随机化，结果可能有所不同。
- en: 'Cross-validation is an approach that can be used to address this issue (CV
    for short). When doing CV, the validation set is no longer required, but a test
    set should still be kept aside for final assessment. The fundamental strategy,
    known as a k-fold CV, divides the training set into k smaller sets (other approaches
    are described below, but generally follow the same principles). Every single one
    of the k “folds” is done as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉验证（简称CV）是一种可以用来解决这个问题的方法。在进行交叉验证时，不再需要验证集，但仍应保留一个测试集以供最终评估。其基本策略，称为k折交叉验证，将训练集划分为k个较小的子集（其他方法见下文，但通常遵循相同的原则）。每一个k个“折”操作如下进行：
- en: The folds are used as training data for a model, and the resulting model is
    validated using the remaining portion of the data (as in, it is used as a test
    set to compute a performance measure such as accuracy).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 各个折叠被用作模型的训练数据，随后使用剩余的部分数据进行验证（即，用作测试集来计算准确度等性能指标）。
- en: The average of the numbers calculated in the loop is then the performance indicator
    supplied by k-fold cross-validation. Although this method can be computationally
    expensive, it does not waste a lot of data (unlike fixing an arbitrary validation
    set), which is a significant benefit in applications such as inverse inference
    where there are few samples.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中计算的数字的平均值就是由k折交叉验证提供的性能指标。尽管这种方法计算开销较大，但它不会浪费大量数据（不像固定一个任意的验证集），这是在样本较少的应用中，如逆推断，的一个显著优势。
- en: 'We can compute the cross-validated metrics by calling the `cross_val` score
    helper function on the estimator and the dataset is the simplest approach to apply
    cross-validation. The example that follows shows how to split the data, develop
    a model, and calculate the score five times in a row (using various splits each
    time) to measure the accuracy of a linear kernel support vector machine on the
    `iris` dataset:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在估计器上调用`cross_val`得分帮助函数来计算交叉验证指标，并且该数据集是应用交叉验证的最简单方法。以下示例展示了如何拆分数据，开发模型，并连续五次计算得分（每次使用不同的拆分）以衡量线性核支持向量机在`iris`数据集上的准确性：
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The mean score and the standard deviation are hence given by the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，平均得分和标准差由以下公式给出：
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The estimator’s scoring technique is by default used to calculate the score
    at each CV iteration:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 估计器的评分技术默认用于计算每次 CV 迭代时的得分：
- en: '![Figure 2.34: CV mean scores ](img/B19026_02_34.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.34：CV 平均得分](img/B19026_02_34.jpg)'
- en: 'Figure 2.34: CV mean scores'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.34：CV 平均得分
- en: 'This can be altered by applying the `scoring` parameter:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用`scoring`参数可以更改此设置：
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Since the samples in the iris dataset are distributed evenly throughout the
    target classes, the accuracy and F1 score are nearly equal:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`iris`数据集中的样本在目标类别中均匀分布，准确率和 F1 分数几乎相等：
- en: '![Figure 2.35: CV scores ](img/B19026_02_35.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.35：CV 得分](img/B19026_02_35.jpg)'
- en: 'Figure 2.35: CV scores'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.35：交叉验证（CV）得分
- en: The CV score defaults to using the `KFold` or `StratifiedKFold` strategies when
    the `cv` parameter is an integer, with the latter being utilized if the estimator
    comes from `ClassifierMixin`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当`cv`参数是整数时，CV 得分默认使用`KFold`或`StratifiedKFold`策略，如果估计器来自`ClassifierMixin`，则使用后者。
- en: 'It is also possible to use other CV strategies by passing a CV iterator using
    the `ShuffleSplit` Sklearn class instead:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过传递一个使用`ShuffleSplit` Sklearn 类的 CV 迭代器来使用其他 CV 策略：
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding code will show us the CV scores on multiple folds of test samples,
    which can be used to prevent the overfitting problem:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将向我们展示在多个测试样本折叠上的 CV 得分，这可以用来防止过拟合问题：
- en: '![Figure 2.36: Results using shuffle split ](img/B19026_02_36.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.36：使用洗牌拆分的结果](img/B19026_02_36.jpg)'
- en: 'Figure 2.36: Results using shuffle split'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.36：使用洗牌拆分的结果
- en: The preceding results show us the results of the CV score.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结果向我们展示了 CV 得分的结果。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have learned how descriptive statistics and machine learning
    models can be used to quantify the difference between populations, which can later
    be used to validate business hypotheses as well as to assess the lift of certain
    marketing activities. We have also learned how to study the relationship of variables
    with the use of correlation and causation analysis, and how to model these relationships
    with linear models. Finally, we have built machine learning models to predict
    and classify variables.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用描述性统计和机器学习模型量化群体之间的差异，这些差异可以用来验证商业假设以及评估某些营销活动的效果提升。我们还学习了如何通过相关性和因果分析研究变量之间的关系，并如何使用线性模型对这些关系进行建模。最后，我们构建了机器学习模型来预测和分类变量。
- en: In the next chapter, we will learn how to use results from web searches and
    how to apply this in the context of market research.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何利用网络搜索结果，并将其应用于市场研究的背景下。
- en: 'Part 2: Market and Customer Insights'
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：市场与客户洞察
- en: In this part, you will learn how to obtain and analyze market data by leveraging
    certain tools. This part will teach you how to obtain search trends, enrich trends
    with similar queries, use scraping tools to obtain data, and structure the results
    to drive better decisions using effective visualizations to monitor key business
    performance KPIs.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，您将学习如何通过利用某些工具获取并分析市场数据。本部分将教您如何获取搜索趋势，使用相似查询丰富趋势，使用抓取工具获取数据，并通过有效的可视化监控关键业务绩效KPI来构建结果，从而做出更好的决策。
- en: 'This part covers the following chapters:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分涵盖以下章节：
- en: '[*Chapter 3*](B19026_03.xhtml#_idTextAnchor291), *Finding Business Opportunities
    with Market Insights*'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 3 章*](B19026_03.xhtml#_idTextAnchor291)，*通过市场洞察寻找商业机会*'
- en: '[*Chapter 4*](B19026_04.xhtml#_idTextAnchor442), *Understanding Customer Preferences
    with Conjoint Analysis*'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 4 章*](B19026_04.xhtml#_idTextAnchor442)，*通过联合分析理解客户偏好*'
- en: '[*Chapter 5*](B19026_05.xhtml#_idTextAnchor574), *Selecting the Optimal Price
    with Price Demand Elasticity*'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 5 章*](B19026_05.xhtml#_idTextAnchor574)，*通过价格需求弹性选择最优价格*'
- en: '[*Chapter 6*](B19026_06.xhtml#_idTextAnchor703), *Product Recommendation*'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19026_06.xhtml#_idTextAnchor703)，*产品推荐*'
