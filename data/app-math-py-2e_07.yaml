- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Using Regression and Forecasting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用回归和预测
- en: One of the most important tasks that a statistician or data scientist has is
    to generate a systematic understanding of the relationship between two sets of
    data. This can mean a *continuous* relationship between two sets of data, where
    one value depends directly on the value of another variable. Alternatively, it
    can mean a categorical relationship, where one value is categorized according
    to another. The tool for working with these kinds of problems is *regression*.
    In its most basic form, regression involves fitting a straight line through a
    scatter plot of the two sets of data and performing some analysis to see how well
    this line *fits* the data. Of course, we often need something more sophisticated
    to model more complex relationships that exist in the real world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学家或数据科学家的一个最重要的任务是生成关于两组数据之间关系的系统理解。这可能意味着两组数据之间的*连续*关系，其中一个值直接依赖于另一个变量的值。或者，这也可能意味着类别关系，其中一个值根据另一个值进行分类。处理这些问题的工具是*回归*。回归在最基本的形式下，涉及将一条直线拟合到两组数据的散点图中，并进行一些分析，以查看这条直线如何*拟合*数据。当然，我们通常需要更复杂的模型来模拟现实世界中存在的复杂关系。
- en: 'Forecasting typically refers to learning trends in time series data with the
    aim of predicting values in the future. Time series data is data that evolves
    over a period of time, and usually exhibits a high degree of noise and oscillatory
    behavior. Unlike more simple data, time series data usually has complex dependencies
    between consecutive values; for instance, a value may depend on both of the previous
    values, and perhaps even on the previous *noise*. Time series modeling is important
    across science and economics, and there are a variety of tools for modeling time
    series data. The basic technique for working with time series data is called **autoregressive
    integrated moving average** (**ARIMA**). This model incorporates two underlying
    components: an **autoregressive** (**AR**) component and a **moving average**
    (**MA**) component, to construct a model for the observed data.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 预测通常是指通过学习时间序列数据中的趋势，以预测未来的值。时间序列数据是指在一段时间内不断变化的数据，通常具有较高的噪声和振荡行为。与更简单的数据不同，时间序列数据通常在连续值之间具有复杂的依赖关系；例如，一个值可能依赖于前两个值，甚至可能依赖于前面的*噪声*。时间序列建模在科学和经济学中非常重要，且有多种工具可用于建模时间序列数据。处理时间序列数据的基本技术称为**自回归积分滑动平均**（**ARIMA**）。该模型包含两个基本组成部分：**自回归**（**AR**）成分和**滑动平均**（**MA**）成分，用以构建观察数据的模型。
- en: In this chapter, we will learn how to model the relationship between two sets
    of data, quantify how strong this relationship is, and generate forecasts about
    other values (the future). Then, we will learn how to use logistic regression,
    which is a variation of a simple linear model, in classification problems. Finally,
    we will build models for time series data using ARIMA and build on these models
    for different kinds of data. We will finish this chapter by using a library called
    Prophet to automatically generate a model for time series data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将学习如何建模两组数据之间的关系，量化这种关系的强度，并生成关于其他值（未来）的预测。接着，我们将学习如何在分类问题中使用逻辑回归，这是一种简单线性模型的变体。最后，我们将使用ARIMA构建时间序列数据的模型，并在这些模型的基础上，针对不同种类的数据进行扩展。本章的最后，我们将使用一个名为Prophet的库，自动生成时间序列数据的模型。
- en: In the first three recipes, we will learn how to perform various kinds of regression
    to simple data. In the next four recipes, we will learn about various techniques
    for working with time series data. The final recipe deals with an alternative
    means of summarizing time series data for various purposes using signature methods.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三个食谱中，我们将学习如何对简单数据执行各种回归方法。在接下来的四个食谱中，我们将学习处理时间序列数据的各种技术。最后一个食谱介绍了使用签名方法总结时间序列数据的替代手段，用于不同目的。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Using basic linear regression
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基础线性回归
- en: Using multilinear regression
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多元线性回归
- en: Classifying using logarithmic regression
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对数回归进行分类
- en: Modeling time series data with ARMA
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ARMA建模时间序列数据
- en: Forecasting from time series data using ARIMA
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ARIMA从时间序列数据进行预测
- en: Forecasting seasonal data using ARIMA
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ARIMA预测季节性数据
- en: Using Prophet to model time series data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Prophet建模时间序列数据
- en: Using signatures to summarize time series data
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用签名法总结时间序列数据
- en: Let’s get started!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开始吧！
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, as usual, we will need the NumPy package imported under the
    `np` alias, the Matplotlib `pyplot` module imported as `plt`, and the Pandas package
    imported as `pd`. We can do this using the following commands:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，和往常一样，我们需要导入NumPy包并命名为`np`，导入Matplotlib的`pyplot`模块并命名为`plt`，以及导入Pandas包并命名为`pd`。我们可以通过以下命令来实现：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will also need some new packages in this chapter. The `statsmodels` package
    is used for regression and time series analysis, the `scikit-learn` package (`sklearn`)
    provides general data science and machine learning tools, and the Prophet package
    (`prophet`) is used for automatically modeling time series data. These packages
    can be installed using your favorite package manager, such as `pip`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们还需要一些新包。`statsmodels`包用于回归分析和时间序列分析，`scikit-learn`包（`sklearn`）提供了一般的数据科学和机器学习工具，而Prophet包（`prophet`）用于自动建模时间序列数据。这些包可以通过你喜欢的包管理器安装，如`pip`：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Prophet package can prove difficult to install on some operating systems
    because of its dependencies. If installing `prophet` causes a problem, you might
    want to try using the Anaconda distribution of Python and its package manager,
    `conda`, which handles the dependencies more rigorously:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于依赖关系的原因，Prophet包在某些操作系统上安装可能会遇到困难。如果安装`prophet`时出现问题，你可以尝试使用Python的Anaconda发行版及其包管理器`conda`，它更严格地处理依赖关系：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Previous versions of the Prophet library (prior to version 1.0) were called
    `fbprophet`, whereas the newer versions of Prophet are just `prophet`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet库的早期版本（1.0版本之前）被称为`fbprophet`，而较新的Prophet版本仅称为`prophet`。
- en: Finally, we also need a small module called `tsdata` that is contained in the
    repository for this chapter. This module contains a series of utilities for producing
    sample time series data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要一个名为`tsdata`的小模块，它包含在本章的仓库中。该模块包含一系列用于生成示例时间序列数据的工具。
- en: The code for this chapter can be found in the `Chapter 07` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2007](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2007).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub仓库的`Chapter 07`文件夹中找到，链接为[https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2007](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2007)。
- en: Using basic linear regression
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基础的线性回归
- en: Linear regression is a tool for modeling the dependence between two sets of
    data so that we can eventually use this model to make predictions. The name comes
    from the fact that we form a linear model (straight line) of one set of data based
    on a second. In the literature, the variable that we wish to model is frequently
    called the *response* variable, and the variable that we are using in this model
    is the *predictor* variable.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归是一种用于建模两个数据集之间依赖关系的工具，从而最终能够利用这个模型进行预测。这个名称来源于我们基于第二组数据对第一组数据形成一个线性模型（直线）。在文献中，我们希望建模的变量通常被称为*响应*变量，而我们在这个模型中使用的变量则被称为*预测*变量。
- en: In this recipe, we’ll learn how to use the `statsmodels` package to perform
    simple linear regression to model the relationship between two sets of data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用`statsmodels`包来执行简单线性回归，以建模两个数据集之间的关系。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the `statsmodels.api` module imported under the
    `sm` alias, the NumPy package imported as `np`, the Matplotlib `pyplot` module
    imported as `plt`, and an instance of a NumPy default random number generator.
    All this can be achieved with the following commands:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的这个配方，我们需要导入`statsmodels.api`模块，并命名为`sm`，导入NumPy包并命名为`np`，导入Matplotlib的`pyplot`模块并命名为`plt`，以及一个NumPy默认的随机数生成器实例。所有这些可以通过以下命令实现：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s see how to use the `statsmodels` package to perform basic linear regression.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`statsmodels`包进行基础的线性回归。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps outline how to use the `statsmodels` package to perform
    a simple linear regression on two sets of data:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了如何使用`statsmodels`包对两个数据集执行简单线性回归：
- en: 'First, we generate some example data that we can analyze. We’ll generate two
    sets of data that will illustrate a good fit and a less good fit:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们生成一些可以分析的示例数据。我们将生成两组数据，展示一个良好的拟合和一个不太好的拟合：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A good first step in performing regression analysis is to create a scatter
    plot of the datasets. We’ll do this on the same set of axes:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行回归分析的一个好起点是绘制数据集的散点图。我们将在同一坐标轴上进行此操作：
- en: '[PRE10]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to use the `sm.add_constant` utility routine so that the modeling step
    will include a constant value:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用`sm.add_constant`实用程序例程，以便建模步骤包含常数值：
- en: '[PRE19]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can create an `OLS` model for our first set of data and use the `fit`
    method to fit the model. We then print a summary of the data using the `summary`
    method:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们的第一组数据创建一个`OLS`模型，并使用`fit`方法来拟合模型。然后，我们使用`summary`方法打印数据的摘要：
- en: '[PRE20]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We repeat the model fitting for the second set of data and print the summary:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对第二组数据重复进行模型拟合，并打印摘要：
- en: '[PRE22]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we create a new range of ![](img/Formula_07_001.png) values using `linspace`
    that we can use to plot the trend lines on our scatter plot. We need to add the
    `constant` column to interact with the models that we have created:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`linspace`创建一个新的![](img/Formula_07_001.png)值范围，这些值可以用来在散点图上绘制趋势线。我们需要添加`constant`列，以便与我们已经创建的模型交互：
- en: '[PRE24]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we use the `predict` method on the model objects so that we can use the
    model to predict the response value at each of the ![](img/Formula_07_002.png)
    values we generated in the previous step:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们对模型对象使用`predict`方法，这样我们就可以使用模型预测在之前步骤中生成的每个![](img/Formula_07_002.png)值对应的响应值：
- en: '[PRE25]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we plot the model data computed in the previous two steps on top of
    the scatter plot:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将之前两步中计算的模型数据绘制在散点图上：
- en: '[PRE27]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The scatter plot, along with the best fit lines (the models) we added, can
    be seen in the following figure:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图以及我们添加的最佳拟合线（模型）可以在下图中看到：
- en: '![Figure 7.1 - Scatter plot of data with lines of best fit computed using least
    squares regression.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 - 使用最小二乘回归计算的最佳拟合线的散点图。'
- en: '](img/7.1.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.1.jpg)'
- en: Figure 7.1 - Scatter plot of data with lines of best fit computed using least
    squares regression.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 - 使用最小二乘回归计算的最佳拟合线的散点图。
- en: The solid line indicates the line fitted to the well-correlated data (marked
    by **x** symbols) and the dashed line indicates the line fitted to the poorly
    correlated data (marked by dots). We can see in the plot that the two best-fit
    lines are fairly similar, but the line fitted (dashed) to the data with lots of
    noise has drifted away from the true model ![](img/Formula_07_003.png) defined
    in *step 1*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实线表示拟合到相关性较好的数据（由**x**符号标记）的线，而虚线表示拟合到相关性较差的数据（由点标记）的线。从图中可以看出，两个最佳拟合线非常相似，但拟合到噪音较多的数据的线（虚线）已经偏离了在*步骤
    1*中定义的真实模型![](img/Formula_07_003.png)。
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Elementary mathematics tells us that the equation of a straight line is given
    by the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 初等数学告诉我们，直线方程由以下公式给出：
- en: '![](img/Formula_07_004.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_004.png)'
- en: 'Here, ![](img/Formula_07_005.png) is the value at which the line meets the
    ![](img/Formula_07_006.png)-axis, usually called the ![](img/Formula_07_007.png)-intercept,
    and ![](img/Formula_07_008.png) is the gradient of the line. In the linear regression
    context, we are trying to find a relationship between the response variable, ![](img/Formula_07_009.png),
    and the predictor variable, ![](img/Formula_07_010.png), which has the form of
    a straight line so that the following occurs:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_07_005.png)是直线与![](img/Formula_07_006.png)-轴的交点，通常称为![](img/Formula_07_007.png)-截距，![](img/Formula_07_008.png)是直线的斜率。在线性回归的背景下，我们试图找到响应变量![](img/Formula_07_009.png)和预测变量![](img/Formula_07_010.png)之间的关系，其形式为一条直线，从而实现以下情况：
- en: '![](img/Formula_07_011.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_011.png)'
- en: 'Here, ![](img/Formula_07_012.png) and ![](img/Formula_07_013.png) are now parameters
    that are to be found. We can write this in a different way, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_07_012.png)和![](img/Formula_07_013.png)是现在需要求解的参数。我们可以用另一种方式写出这个公式，如下所示：
- en: '![](img/Formula_07_014.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_014.png)'
- en: 'Here, ![](img/Formula_07_015.png) is an error term, which, in general, depends
    on ![](img/Formula_07_016.png). To find the “best” model, we need to find values
    for the ![](img/Formula_07_017.png) and ![](img/Formula_07_018.png) parameters
    for which the error term, ![](img/Formula_07_019.png), is minimized (in an appropriate
    sense). The basic method for finding the values of the parameters such that this
    error is minimized is the method of least squares, which gives its name to the
    type of regression used here: *ordinary least squares*. Once we have used this
    method to establish some relationship between a response variable and a predictor
    variable, our next task is to assess how well this model actually represents this
    relationship. For this, we form the *residuals* given by the following equation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![](img/Formula_07_015.png)是一个误差项，一般来说，它依赖于![](img/Formula_07_016.png)。为了找到“最佳”模型，我们需要找到![](img/Formula_07_017.png)和![](img/Formula_07_018.png)参数的值，使得误差项![](img/Formula_07_019.png)最小化（在适当的意义上）。找到使得误差最小化的参数值的基本方法是最小二乘法，这也为这里使用的回归类型命名为：*普通最小二乘法*。一旦我们使用此方法建立了响应变量与预测变量之间的关系，接下来的任务是评估这个模型到底多么准确地表示了这种关系。为此，我们根据以下方程形成*残差*：
- en: '![](img/Formula_07_020.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_020.png)'
- en: We do this for each of the data points, ![](img/Formula_07_021.png) and ![](img/Formula_07_022.png).
    In order to provide a rigorous statistical analysis of how well we have modeled
    the relationship between the data, we need the residuals to satisfy certain assumptions.
    First, we need them to be independent in the sense of probability. Second, we
    need them to be normally distributed about 0 with a common variance (in practice,
    we can relax these slightly and still make reasonable comments about the accuracy
    of the model).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对每个数据点都做了相同的处理，![](img/Formula_07_021.png) 和 ![](img/Formula_07_022.png)。为了对我们建模数据之间关系的准确性进行严格的统计分析，我们需要残差满足某些假设。首先，我们需要它们在概率上是独立的。其次，我们需要它们围绕0呈正态分布，并且具有相同的方差（在实践中，我们可以稍微放宽这些假设，仍然可以对模型的准确性做出合理的评估）。
- en: In this recipe, we generated response data from the predictor data using a linear
    relationship. The difference between the two response datasets we created is the
    “size” of the error at each value. For the first dataset, `y1`, the residuals
    were normally distributed with a standard deviation of 0.5, whereas for the second
    dataset, `y2`, the residuals have a standard deviation of 5.0\. We can see this
    variability in the scatter plot shown in *Figure 7**.1*, where the data for `y1`
    is generally very close to the best fit line – which closely matches the actual
    relationship that was used to generate the data – whereas the `y2` data is much
    further from the best-fit line.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，我们通过线性关系从预测数据生成了响应数据。我们创建的两个响应数据集之间的差异是每个值的误差“大小”。对于第一个数据集`y1`，残差呈正态分布，标准差为0.5；而对于第二个数据集`y2`，残差的标准差为5.0。我们可以在*图
    7.1*的散点图中看到这种变化，其中`y1`的数据通常非常接近最佳拟合线——这与生成数据时使用的实际关系非常相符——而`y2`的数据则远离最佳拟合线。
- en: The `OLS` object from the `statsmodels` package is the main interface for ordinary
    least squares regression. We provide the response data and the predictor data
    as arrays. In order to have a constant term in the model, we need to add a column
    of ones in the predictor data. The `sm.add_constant` routine is a simple utility
    for adding this constant column. The `fit` method of the `OLS` class computes
    the parameters for the model and returns a results object (`model1` and `model2`)
    that contains the parameters for the best fit model. The `summary` method creates
    a string containing information about the model and various statistics about the
    goodness of fit. The `predict` method applies the model to new data. As the name
    suggests, it can be used to make predictions using the model.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`statsmodels`包的`OLS`对象是普通最小二乘回归的主要接口。我们将响应数据和预测数据作为数组提供。为了在模型中有一个常数项，我们需要在预测数据中添加一列1。`sm.add_constant`函数是一个用于添加常数列的简单工具。`OLS`类的`fit`方法计算模型的参数，并返回一个结果对象（`model1`和`model2`），该对象包含最佳拟合模型的参数。`summary`方法创建一个包含有关模型的信息和拟合优度统计的字符串。`predict`方法将模型应用于新数据。顾名思义，它可以用来基于模型进行预测。
- en: 'There are two basic statistics reported in the summary that give us information
    about the fit. The first is the ![](img/Formula_07_023.png) value, or the adjusted
    version, which measures the variability explained by the model against the total
    variability. This number is defined as follows. First, define the following quantities:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在摘要中报告了两个基本统计量，它们为我们提供了拟合情况的信息。第一个是 ![](img/Formula_07_023.png) 值，或其调整版本，用来衡量模型解释的变异性与总变异性的比值。该数字定义如下。首先，定义以下量：
- en: '![](img/Formula_07_024.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_024.png)'
- en: 'Here, ![](img/Formula_07_025.png) are the residuals defined previously and
    ![](img/Formula_07_026.png) is the mean of the data. We then define ![](img/Formula_07_027.png)
    and its adjusted counterpart:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![](img/Formula_07_025.png) 是之前定义的残差，![](img/Formula_07_026.png) 是数据的均值。然后我们定义了
    ![](img/Formula_07_027.png) 及其调整后的对应值：
- en: '![](img/Formula_07_028.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_028.png)'
- en: In the latter equation, ![](img/Formula_07_029.png) is the size of the sample
    and ![](img/Formula_07_030.png) is the number of variables in the model (including
    the ![](img/Formula_07_031.png)-intercept ![](img/Formula_07_032.png)). A higher
    value indicates a better fit, with a best possible value of 1\. Note that the
    ordinary ![](img/Formula_07_033.png) value tends to be overly optimistic, especially
    when the model contains more variables, so it is usually better to look at the
    adjusted version.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的方程中，![](img/Formula_07_029.png) 是样本的大小，![](img/Formula_07_030.png) 是模型中的变量数（包括
    ![](img/Formula_07_031.png)-截距 ![](img/Formula_07_032.png)）。更高的值表示更好的拟合，最佳值为 1。请注意，普通的
    ![](img/Formula_07_033.png) 值往往过于乐观，特别是当模型包含更多变量时，因此通常更好地查看调整后的版本。
- en: The second is the F statistic p-value. This is a hypothesis test that at least
    one of the coefficients of the model is non-zero. As with ANOVA testing (see *Testing
    Hypotheses with ANOVA*, [*Chapter 6*](B19085_06.xhtml#_idTextAnchor226)), a small
    p-value indicates that the model is significant, meaning that the model is more
    likely to accurately model the data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是 F 统计量的 p 值。这是一个假设检验，检验模型中至少有一个系数不为零。与 ANOVA 检验类似（见 *使用 ANOVA 检验假设*，[*第
    6 章*](B19085_06.xhtml#_idTextAnchor226)），一个小的 p 值表明模型显著，意味着该模型更有可能准确地描述数据。
- en: In this recipe, the first model, `model1`, has an adjusted ![](img/Formula_07_034.png)
    value of 0.986, indicating that the model very closely fits the data, and a p-value
    of 6.43e-19, indicating high significance. The second model has an adjusted ![](img/Formula_07_035.png)
    value of 0.361, which indicates that the model less closely fits the data, and
    a p-value of 0.000893, which also indicates high significance. Even though the
    second model less closely fits the data, in terms of statistics, that is not to
    say that it is not useful. The model is still significant, although less so than
    the first model, but it doesn’t account for all of the variability (or at least
    a significant portion of it) in the data. This could be indicative of additional
    (non-linear) structures in the data, or that the data is less correlated, which
    means there is a weaker relationship between the response and predictor data (due
    to the way we constructed the data, we know that the latter is true).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，第一个模型 `model1` 的调整后 ![](img/Formula_07_034.png) 值为 0.986，表明该模型与数据拟合得非常紧密，且
    p 值为 6.43e-19，表明具有很高的显著性。第二个模型的调整后 ![](img/Formula_07_035.png) 值为 0.361，表示该模型与数据的拟合度较低，且
    p 值为 0.000893，也表明具有较高的显著性。尽管第二个模型与数据的拟合度较低，但在统计学上，这并不意味着它没有用。该模型依然是显著的，虽然其显著性不如第一个模型，但它并没有解释数据中所有的变异性（或者至少没有解释其中的显著部分）。这可能表明数据中存在额外的（非线性）结构，或者数据之间的相关性较弱，这意味着响应数据与预测数据之间的关系较弱（由于我们构造数据的方式，我们知道后者是正确的）。
- en: There’s more...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Simple linear regression is a good general-purpose tool in a statistician’s
    toolkit. It is excellent for finding the nature of the relationship between two
    sets of data that are known (or suspected) to be connected in some way. The statistical
    measurement of how much one set of data depends on another is called *correlation*.
    We can measure correlation using a correlation coefficient, such as *Spearman’s
    rank correlation coefficient*. A high positive correlation coefficient indicates
    a strong positive relationship between the data, such as that seen in this recipe,
    while a high negative correlation coefficient indicates a strong negative relationship,
    where the slope of the best-fit line through the data is negative. A correlation
    coefficient of 0 means that the data is not correlated: there is no relationship
    between the data.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 简单线性回归是统计学家工具箱中一个很好的通用工具。它非常适合用于发现两个已知（或怀疑）以某种方式相关的数据集之间的关系。统计学上衡量一个数据集依赖于另一个数据集的程度被称为*相关性*。我们可以使用相关系数来衡量相关性，如*斯皮尔曼等级相关系数*。一个高的正相关系数表示数据之间存在强的正相关关系，例如在这个示例中的情况，而高的负相关系数则表示强的负相关关系，在这种情况下，拟合数据的最佳直线的斜率为负值。相关系数为0表示数据不相关：数据之间没有关系。
- en: If the sets of data are clearly related but not in a linear (straight line)
    relationship, then it might follow a polynomial relationship where, for example,
    one value is related to the other squared. Sometimes, you can apply a transformation,
    such as a logarithm, to one set of data and then use linear regression to fit
    the transformed data. Logarithms are especially useful when there is a power-law
    relationship between the two sets of data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据集之间有明显的关系，但不是线性（直线）关系，那么它可能遵循多项式关系，例如，一个值与另一个值的平方相关。有时，你可以对其中一个数据集进行变换，比如使用对数变换，然后使用线性回归来拟合变换后的数据。当两个数据集之间存在幂律关系时，对数尤其有用。
- en: The `scikit-learn` package also provides facilities for performing ordinary
    least squares regression. However, their implementation does not offer an easy
    way to generate goodness-of-fit statistics, which are often useful when performing
    a linear regression in isolation. The `summary` method on the `OLS` object is
    very convenient for producing all the required fitting information, along with
    the estimated coefficients.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-learn`包也提供了执行普通最小二乘回归的功能。然而，它们的实现没有提供一种生成拟合优度统计量的简便方法，而这些统计量在单独进行线性回归时通常非常有用。`OLS`对象的`summary`方法非常方便，可以生成所有所需的拟合信息，并提供估计的系数。'
- en: Using multilinear regression
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多元线性回归
- en: Simple linear regression, as seen in the previous recipe, is excellent for producing
    simple models of a relationship between one response variable and one predictor
    variable. Unfortunately, it is far more common to have a single response variable
    that depends on many predictor variables. Moreover, we might not know which variables
    from a collection make good predictor variables. For this task, we need multilinear
    regression.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例中所见，简单线性回归非常适合用来建立一个响应变量与一个预测变量之间的简单模型。不幸的是，通常我们会有一个单一的响应变量，它依赖于多个预测变量。此外，我们可能并不知道哪些变量能够作为好的预测变量。为此，我们需要多元线性回归。
- en: In this recipe, we will learn how to use multilinear regression to explore the
    relationship between a response variable and several predictor variables.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用多元线性回归来探索响应变量与多个预测变量之间的关系。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy package imported as `np`, the Matplotlib
    `pyplot` module imported as `plt`, the Pandas package imported as `pd`, and an
    instance of the NumPy default random number generator created using the following
    commands:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，我们将需要导入NumPy包并命名为`np`，导入Matplotlib的`pyplot`模块并命名为`plt`，导入Pandas包并命名为`pd`，以及使用以下命令创建一个NumPy默认的随机数生成器实例：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will also need the `statsmodels`.`api` module imported as `sm`, which can
    be imported using the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要导入`statsmodels`.`api`模块并将其命名为`sm`，可以使用以下命令导入：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s see how to fit a multilinear regression model to some data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将多元线性回归模型拟合到一些数据上。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps show you how to use multilinear regression to explore the
    relationship between several predictors and a response variable:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何使用多元线性回归来探索多个预测变量与响应变量之间的关系：
- en: 'First, we need to create the predictor data to analyze. This will take the
    form of a Pandas DataFrame with four terms. We will add the constant term at this
    stage by adding a column of ones:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，我们需要创建要分析的预测数据。这将采用一个具有四个项的Pandas DataFrame的形式。在这个阶段，我们将通过添加一个包含1的列来添加常数项:'
- en: '[PRE31]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we will generate the response data using only the first two variables:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，我们将仅使用前两个变量生成响应数据:'
- en: '[PRE37]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we’ll produce scatter plots of the response data against each of the predictor
    variables:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，我们将生成响应数据与每个预测变量的散点图:'
- en: '[PRE39]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we’ll add axis labels and titles to each scatter plot since this is good
    practice:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，我们将为每个散点图添加坐标轴标签和标题，因为这是一个好的做法:'
- en: '[PRE44]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The resulting plots can be seen in the following figure:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '结果图可以在以下图中看到:'
- en: '![Figure 7.2 - Scatter plots of the response data against each of the predictor
    variables'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 - 响应数据与每个预测变量的散点图'
- en: '](img/7.2.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.2.jpg)'
- en: Figure 7.2 - Scatter plots of the response data against each of the predictor
    variables
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - 响应数据与每个预测变量的散点图
- en: As we can see, there appears to be some correlation between the response data
    and the first two predictor columns, `X1` and `X2`. This is what we expect, given
    how we generated the data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，响应数据与前两个预测列`X1`和`X2`之间似乎存在一些相关性。这是我们预期的，考虑到我们生成数据的方式。
- en: 'We use the same `OLS` class to perform multilinear regression; that is, providing
    the response array and the predictor DataFrame:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们使用相同的`OLS`类执行多元线性回归; 即，提供响应数组和预测器DataFrame:'
- en: '[PRE51]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The first half of the output of the `print` statement is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`语句的输出的前半部分如下:'
- en: '[PRE53]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This gives us a summary of the model, various parameters, and various goodness-of-fit
    characteristics such as the `R-squared` values (0.77 and 0.762), which indicate
    that the fit is reasonable but not very good. The second half of the output contains
    information about the estimated coefficients:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '这给我们提供了模型摘要、各种参数以及各种拟合度特征，如`R-squared`值（0.77和0.762），这表明拟合是合理的但不是非常好的。输出的后半部分包含有关估计系数的信息:'
- en: '[PRE54]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the summary data, we can see that the `X3` variable is not significant since
    it has a p-value of 0.66.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在摘要数据中，我们可以看到`X3`变量不显著，因为其p值为0.66。
- en: 'Since the third predictor variable is not significant, we eliminate this column
    and perform the regression again:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '由于第三个预测变量不显著，我们消除了这一列并再次进行回归:'
- en: '[PRE55]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This results in a small increase in the goodness-of-fit statistics.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致拟合度统计数据略微增加。
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Multilinear regression works in much the same way as simple linear regression.
    We follow the same procedure here as in the previous recipe, where we use the
    `statsmodels` package to fit a multilinear model to our data. Of course, there
    are some differences behind the scenes. The model we produce using multilinear
    regression is very similar in form to the simple linear model from the previous
    recipe. It has the following form:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '多元线性回归的工作方式与简单线性回归基本相同。我们在这里遵循与上一个示例相同的步骤，使用`statsmodels`包将多元模型拟合到我们的数据中。当然，在幕后有一些差异。我们使用多元线性回归生成的模型在形式上与上一个示例中的简单线性模型非常相似。它具有以下形式:'
- en: '![](img/Formula_07_036.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_036.png)'
- en: 'Here, ![](img/Formula_07_037.png) is the response variable, ![](img/Formula_07_038.png)
    represents the predictor variables, ![](img/Formula_07_039.png) is the error term,
    and ![](img/Formula_07_040.png) is the parameters to be computed. The same requirements
    are also necessary for this context: residuals must be independent and normally
    distributed with a mean of 0 and a common standard deviation.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_07_037.png) 是响应变量，![](img/Formula_07_038.png) 代表预测变量，![](img/Formula_07_039.png)
    是误差项，![](img/Formula_07_040.png) 是要计算的参数。对于这个背景，同样需要满足以下要求：残差必须是独立的，并且服从均值为0和公共标准差的正态分布。
- en: In this recipe, we provided our predictor data as a Pandas DataFrame rather
    than a plain NumPy array. Notice that the names of the columns have been adopted
    in the summary data that we printed. Unlike the first recipe, *Using basic linear
    regression*, we included the constant column in this DataFrame, rather than using
    the `add_constant` utility from `statsmodels`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将预测数据提供为Pandas DataFrame，而不是普通的NumPy数组。请注意，在我们打印的摘要数据中采用了列名。与第一个示例不同，*使用基本线性回归*，我们在这个DataFrame中包含了常数列，而不是使用`statsmodels`中的`add_constant`实用程序。
- en: In the output of the first regression, we can see that the model is a reasonably
    good fit with an adjusted ![](img/Formula_07_041.png) value of 0.762, and is highly
    significant (we can see this by looking at the regression F statistic p-value).
    However, looking closer at the individual parameters, we can see that both of
    the first two predictor values are significant, but the constant and the third
    predictor are less so. In particular, the third predictor parameter, `X3`, is
    not significantly different from 0 and has a p-value of 0.66\. Given that our
    response data was constructed without using this variable, this shouldn’t come
    as a surprise. In the final step of the analysis, we repeat the regression without
    the predictor variable, `X3`, which is a mild improvement to the fit.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次回归的输出中，我们可以看到模型拟合得相当好，调整后的![](img/Formula_07_041.png)值为0.762，并且显著性很高（我们可以通过查看回归F统计量的p值来判断）。然而，仔细查看各个参数，我们可以发现前两个预测值是显著的，但常数项和第三个预测变量则不太显著。特别是，第三个预测变量`X3`与0没有显著差异，p值为0.66。由于我们的响应数据在构建时没有使用该变量，这一点并不意外。在分析的最后一步，我们重复回归分析，去除预测变量`X3`，这对拟合结果略有改进。
- en: Classifying using logarithmic regression
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对数回归进行分类
- en: Logarithmic regression solves a different problem from ordinary linear regression.
    It is commonly used for classification problems where, typically, we wish to classify
    data into two distinct groups, according to a number of predictor variables. Underlying
    this technique is a transformation that’s performed using logarithms. The original
    classification problem is transformed into a problem of constructing a model for
    the **log-odds**. This model can be completed with simple linear regression. We
    apply the inverse transformation to the linear model, which leaves us with a model
    of the probability that the desired outcome will occur, given the predictor data.
    The transform we apply here is called the **logistic function**, which gives its
    name to the method. The probability we obtain can then be used in the classification
    problem we originally aimed to solve.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对数回归解决的问题与普通线性回归不同。它通常用于分类问题，通常我们希望根据多个预测变量将数据分类为两个不同的组。该技术背后进行的是一个通过对数运算实现的转换。原始的分类问题被转化为构建**对数几率**模型的问题。这个模型可以通过简单的线性回归完成。我们对线性模型应用逆转换，最终得到一个模型，表示给定预测数据的情况下，期望结果发生的概率。我们在这里应用的转换被称为**逻辑函数**，它为该方法命名。然后，我们获得的概率可以用于解决我们最初想要解决的分类问题。
- en: In this recipe, we will learn how to perform logistic regression and use this
    technique in classification problems.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何执行逻辑回归，并在分类问题中使用这种技术。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy package imported as `np`, the Matplotlib
    `pyplot` module imported as `plt`, the Pandas package imported as `pd`, and an
    instance of the NumPy default random number generator to be created using the
    following commands:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们需要导入NumPy包作为`np`，导入Matplotlib的`pyplot`模块作为`plt`，导入Pandas包作为`pd`，并使用以下命令创建NumPy默认的随机数生成器实例：
- en: '[PRE58]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We also need several components from the `scikit-learn` package to perform
    logistic regression. These can be imported as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从`scikit-learn`包中导入几个组件，以执行逻辑回归。可以按如下方式导入：
- en: '[PRE59]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to use logistic regression to solve a simple classification
    problem:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用逻辑回归解决简单的分类问题：
- en: 'First, we need to create some sample data that we can use to demonstrate how
    to use logistic regression. We start by creating the predictor variables:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一些样本数据，用来演示如何使用逻辑回归。我们从创建预测变量开始：
- en: '[PRE60]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we use two of our three predictor variables to create our response variable
    as a series of Boolean values:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用三个预测变量中的两个，创建一个响应变量，作为一系列布尔值：
- en: '[PRE69]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we scatterplot the points, styled according to the response variable,
    of the `var3` data against the `var1` data, which are the variables used to construct
    the response variable:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将根据响应变量的样式，在散点图中绘制`var3`数据与`var1`数据的关系，这些变量用于构造响应变量：
- en: '[PRE71]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The resulting plot can be seen in the following figure:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表可以在下图中看到：
- en: '![Figure 7.3 – Scatter plot of the var3 data against var1, with classification
    marked'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – `var3`数据与`var1`数据的散点图，分类已标注'
- en: '](img/7.3.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.3.jpg)'
- en: Figure 7.3 – Scatter plot of the var3 data against var1, with classification
    marked
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – var3 数据与 var1 数据的散点图，分类结果已标注
- en: 'Next, we create a `LogisticRegression` object from the `scikit-learn` package
    and fit the model to our data:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从`scikit-learn`包中创建一个`LogisticRegression`对象，并将模型拟合到我们的数据上：
- en: '[PRE80]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next, we prepare some extra data, different from what we used to fit the model,
    to test the accuracy of our model:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们准备一些与用于拟合模型的数据不同的额外数据，以测试我们模型的准确性：
- en: '[PRE82]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Then, we generate predicted results based on our logistic regression model:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们基于逻辑回归模型生成预测结果：
- en: '[PRE93]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Finally, we use the `classification_report` utility from `scikit-learn` to
    print a summary of predicted classification against known response values to test
    the accuracy of the model. We print this summary to the Terminal:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`scikit-learn`中的`classification_report`工具，打印预测分类与已知响应值的摘要，以测试模型的准确性。我们将这个摘要打印到终端：
- en: '[PRE94]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The report that’s generated by this routine looks as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序生成的报告如下所示：
- en: '[PRE95]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The report here contains information about the performance of the classification
    model on the test data. We can see that the reported precision and recall are
    good, indicating that there were relatively few false positive and false negative
    identifications.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的报告包含了分类模型在测试数据上的表现信息。我们可以看到报告的精确度和召回率都很好，表明假阳性和假阴性识别相对较少。
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Logistic regression works by forming a linear model of the *log-odds* ratio
    (or *logit*), which, for a single predictor variable, ![](img/Formula_07_042.png),
    has the following form:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归通过形成*对数几率*比率（或*logit*）的线性模型来工作，对于单一预测变量，![](img/Formula_07_042.png)，其形式如下：
- en: '![](img/Formula_07_043.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_043.png)'
- en: 'Here, ![](img/Formula_07_044.png) represents the probability of a true outcome
    in response to the given predictor, ![](img/Formula_07_045.png). Rearranging this
    gives a variation of the logistic function for the probability:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![](img/Formula_07_044.png)表示给定预测变量！[](img/Formula_07_045.png)下，真实结果的概率。重新排列后，这给出了概率的逻辑函数变体：
- en: '![](img/Formula_07_046.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_046.png)'
- en: The parameters for the log-odds are estimated using a maximum likelihood method.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对数几率的参数是通过最大似然法估计的。
- en: The `LogisticRegression` class from the `linear_model` module in `scikit-learn`
    is an implementation of logistic regression that is very easy to use. First, we
    create a new model instance of this class, with any custom parameters that we
    need, and then use the `fit` method on this object to fit (or train) the model
    to the sample data. Once this fitting is done, we can access the parameters that
    have been estimated using the `get_params` method.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-learn`中`linear_model`模块的`LogisticRegression`类是一个非常易于使用的逻辑回归实现。首先，我们创建这个类的新模型实例，并根据需要设置任何自定义参数，然后使用`fit`方法将此对象拟合（或训练）到样本数据上。一旦拟合完成，我们可以使用`get_params`方法访问已估计的参数。'
- en: The `predict` method on the fitted model allows us to pass in new (unseen) data
    and make predictions about the classification of each sample. We could also get
    the probability estimates that are actually given by the logistic function using
    the `predict_proba` method.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在拟合模型上使用`predict`方法允许我们传入新的（未见过的）数据，并对每个样本的分类进行预测。我们还可以使用`predict_proba`方法获取逻辑函数实际给出的概率估计。
- en: Once we have built a model for predicting the classification of data, we need
    to validate the model. This means we have to test the model with some previously
    unseen data and check whether it correctly classifies the new data. For this,
    we can use `classification_report`, which takes a new set of data and the predictions
    generated by the model and computes several summary values about the performance
    of the model. The first reported value is the **precision**, which is the ratio
    of the number of true positives to the number of predicted positives. This measures
    how well the model avoids labeling values as positive when they are not. The second
    reported value is the **recall**, which is the ratio of the number of true positives
    to the number of true positives plus the number of false negatives. This measures
    the ability of the model to find positive samples within the collection. A related
    score (not included in the report) is the **accuracy**, which is the ratio of
    the number of correct classifications to the total number of classifications.
    This measures the ability of the model to correctly label samples.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了一个预测数据分类的模型，就需要对模型进行验证。这意味着我们需要用一些之前未见过的数据来测试模型，并检查它是否能正确分类新数据。为此，我们可以使用`classification_report`，它接受一组新数据和模型生成的预测值，并计算几个关于模型性能的总结值。第一个报告的值是**精确度**，它是正确预测的正例数与预测为正的总数之比。它衡量模型在避免错误标记为正例时的表现。第二个报告的值是**召回率**，它是正确预测的正例数与所有正例（正确预测的正例加上错误预测的负例）的总和之比。它衡量模型在数据集内找到正样本的能力。一个相关的评分（报告中未包含）是**准确度**，它是正确分类的样本数与总分类数之比。它衡量模型正确标记样本的能力。
- en: The classification report we generated using the `scikit-learn` utility performs
    a comparison between the predicted results and the known response values. This
    is a common method for validating a model before using it to make actual predictions.
    In this recipe, we saw that the reported precision for each of the categories
    (`True` and `False`) was `1.00`, indicating that the model performed perfectly
    in predicting the classification with this data. In practice, it is unlikely that
    the precision of a model will be 100%.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`scikit-learn`工具生成的分类报告执行了预测结果与已知响应值之间的比较。这是一种常见的验证模型的方法，在实际预测之前进行使用。在这个教程中，我们看到每个类别（`True`和`False`）的报告精确度为`1.00`，表明模型在用这些数据预测分类时表现得非常完美。实际上，模型的精确度达到100%是非常不可能的。
- en: There’s more...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are lots of packages that offer tools for using logistic regression for
    classification problems. The `statsmodels` package has the `Logit` class for creating
    logistic regression models. We used the `scikit-learn` package in this recipe,
    which has a similar interface. `scikit-learn` is a general-purpose machine learning
    library and has a variety of other tools for classification problems.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工具包提供用于分类问题的逻辑回归工具。`statsmodels`包提供了`Logit`类用于创建逻辑回归模型。在这个教程中，我们使用了`scikit-learn`包，它有一个类似的接口。`scikit-learn`是一个通用的机器学习库，并且为分类问题提供了多种其他工具。
- en: Modeling time series data with ARMA
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ARMA建模时间序列数据
- en: Time series, as the name suggests, track a value over a sequence of distinct
    time intervals. They are particularly important in the finance industry, where
    stock values are tracked over time and used to make predictions – known as forecasting
    – of the value at some point in the future. Good predictions coming from this
    kind of data can be used to make better investments. Time series also appear in
    many other common situations, such as weather monitoring, medicine, and any places
    where data is derived from sensors over time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列，顾名思义，是在一系列不同时间间隔内跟踪一个值。它们在金融行业中特别重要，因为股票价值随着时间的推移被追踪，并用来做出对未来某个时点值的预测——这被称为预测。来自这种数据的良好预测可以用于做出更好的投资决策。时间序列也出现在许多其他常见的情况中，如天气监测、医学以及任何从传感器中随时间获取数据的地方。
- en: Time series, unlike other types of data, do not usually have independent data
    points. This means that the methods that we use for modeling independent data
    will not be particularly effective. Thus, we need to use alternative techniques
    to model data with this property. There are two ways in which a value in a time
    series can depend on previous values. The first is where there is a direct relationship
    between the value and one or more previous values. This is the *autocorrelation*
    property and is modeled by an *AR* model. The second is where the noise that’s
    added to the value depends on one or more previous noise terms. This is modeled
    by an *MA* model. The number of terms involved in either of these models is called
    the *order* of the model.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型的数据不同，时间序列的数据点通常不是独立的。这意味着我们用于建模独立数据的方法可能效果不佳。因此，我们需要使用替代技术来建模具有这种属性的数据。时间序列中的一个值可以依赖于前一个或多个值，依赖的方式有两种。第一种是值与一个或多个前值之间存在直接关系。这是*自相关*属性，并通过*AR*模型进行建模。第二种是加到值上的噪声依赖于一个或多个前噪声项。这通过*MA*模型进行建模。涉及到的项数称为模型的*阶数*。
- en: In this recipe, we will learn how to create a model for stationary time series
    data with ARMA terms.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何为平稳时间序列数据创建一个包含ARMA项的模型。
- en: Getting ready
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we need the Matplotlib `pyplot` module imported as `plt` and
    the `statsmodels` package `api` module imported as `sm`. We also need to import
    the `generate_sample_data` routine from the `tsdata` package from this book’s
    repository, which uses NumPy and Pandas to generate sample data for analysis:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要导入Matplotlib的`pyplot`模块（命名为`plt`），以及`statsmodels`包中的`api`模块（命名为`sm`）。我们还需要从本书的仓库中的`tsdata`包导入`generate_sample_data`函数，该函数使用NumPy和Pandas生成用于分析的样本数据：
- en: '[PRE96]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'To avoid repeatedly setting colors in plotting functions, we do some one-time
    setup to set the plotting color here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在绘图函数中反复设置颜色，我们在这里做一些一次性的设置来设置绘图颜色：
- en: '[PRE97]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: With this set up, we can now see how to generate an ARMA model for some time
    series data.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一设置，我们现在可以看到如何为一些时间序列数据生成ARMA模型。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Follow these steps to create an ARMA model for stationary time series data:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为平稳时间序列数据创建一个ARMA模型：
- en: 'First, we need to generate the sample data that we will analyze:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要生成我们将分析的样本数据：
- en: '[PRE98]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'As always, the first step in the analysis is to produce a plot of the data
    so that we can visually identify any structure:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，分析的第一步是绘制数据图，以便我们可以直观地识别任何结构：
- en: '[PRE99]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The resulting plot can be seen in the following figure:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图可以在下图中看到：
- en: '![Figure 7.4 - Plot of the time series data that we will analyze (there doesn’t
    appear to be a trend in this data)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 - 我们将分析的时间序列数据图（这些数据似乎没有趋势）'
- en: '](img/7.4.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.4.jpg)'
- en: Figure 7.4 - Plot of the time series data that we will analyze (there doesn’t
    appear to be a trend in this data)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 - 我们将分析的时间序列数据图（这些数据似乎没有趋势）
- en: Here, we can see that there doesn’t appear to be an underlying trend, which
    means that the data is likely to be stationary (a time series is said to be **stationary**
    if its statistical properties do not vary with time. This often manifests in the
    form of an upward or downward trend).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到似乎没有明显的趋势，这意味着数据可能是平稳的（如果一个时间序列的统计特性不随时间变化，则称该序列为**平稳**的。这通常表现为上升或下降的趋势）。
- en: 'Next, we compute the augmented Dickey-Fuller test. This is a hypothesis test
    for whether a time series is stationary or not. The null hypothesis is that the
    time series is not stationary:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们计算扩展的Dickey-Fuller检验。这是一个检验时间序列是否平稳的假设检验。原假设是时间序列不是平稳的：
- en: '[PRE105]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The reported `adf_pvalue` is 0.000376 in this case, so we reject the null hypothesis
    and conclude that the series is stationary.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，报告的`adf_pvalue`为0.000376，因此我们拒绝原假设，得出结论：该序列是平稳的。
- en: 'Next, we need to determine the order of the model that we should fit. For this,
    we’ll plot the **autocorrelation function** (**ACF**) and the **partial autocorrelation
    function** (**PACF**) for the time series:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定应该拟合的模型阶数。为此，我们将绘制时间序列的**自相关函数**（**ACF**）和**偏自相关函数**（**PACF**）：
- en: '[PRE109]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The plots of the ACF and PACF for our time series can be seen in the following
    figure. These plots suggest the existence of both AR and MA processes:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的时间序列的ACF和PACF图可以在下图中看到。这些图表明存在AR和MA过程：
- en: '![Figure 7.5 - The ACF and PACF for the sample time series data'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 - 样本时间序列数据的ACF和PACF图'
- en: '](img/7.5.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.5.jpg)'
- en: Figure 7.5 - The ACF and PACF for the sample time series data
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 - 样本时间序列数据的ACF和PACF
- en: 'Next, we create an ARMA model for the data, using the `ARIMA` class from the
    `tsa` module. This model will have an order 1 AR component and an order 1 MA component:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为数据创建一个ARMA模型，使用`tsa`模块中的`ARIMA`类。这个模型将包含1阶AR组件和1阶MA组件：
- en: '[PRE119]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now, we fit the model to the data and get the resulting model. We print a summary
    of these results to the Terminal:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将模型拟合到数据上并得到结果模型。我们将这些结果的汇总打印到终端：
- en: '[PRE120]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The summary data given for the fitted model is as follows:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对拟合模型给出的汇总数据如下：
- en: '[PRE122]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Here, we can see that both of the estimated parameters for the AR and MA components
    are significantly different from 0\. This is because the value in the `P >|z|`
    column is 0 to 3 decimal places.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到AR和MA组件的估计参数都显著不同于0。这是因为`P >|z|`列中的值精确到小数点后3位。
- en: 'Next, we need to verify that there is no additional structure remaining in
    the residuals (error) of the predictions from our model. For this, we plot the
    ACF and PACF of the residuals:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要验证模型预测的残差（误差）中没有额外的结构。为此，我们绘制残差的ACF和PACF：
- en: '[PRE148]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The ACF and PACF of the residuals can be seen in the following figure. Here,
    we can see that there are no significant spikes at lags other than 0, so we conclude
    that there is no structure remaining in the residuals:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 残差的ACF和PACF可以在下图中看到。在这里，我们可以看到除了滞后0之外，没有显著的峰值，因此我们可以得出结论，残差中没有剩余的结构：
- en: '![Figure 7.6 - The ACF and PACF for the residuals from our model'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 - 我们模型残差的ACF和PACF'
- en: '](img/7.6.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.6.jpg)'
- en: Figure 7.6 - The ACF and PACF for the residuals from our model
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 - 我们模型残差的ACF和PACF
- en: 'Now that we have verified that our model is not missing any structure, we plot
    the values that are fitted to each data point on top of the actual time series
    data to see whether the model is a good fit for the data. We plot this model in
    the plot we created in *step 2*:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经验证了我们的模型没有缺失任何结构，我们将拟合的每个数据点的值绘制到实际的时间序列数据上，以查看该模型是否适合数据。我们在*步骤2*中创建的图表中绘制了这个模型：
- en: '[PRE159]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'The updated plot can be seen in the following figure:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的图可以在下图中看到：
- en: '![Figure 7.7 – Plot of the fitted time series data over the observed time series
    data'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 - 拟合的时间序列数据与观察到的时间序列数据的对比图'
- en: '](img/7.7.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.7.jpg)'
- en: Figure 7.7 – Plot of the fitted time series data over the observed time series
    data
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 - 拟合的时间序列数据与观察到的时间序列数据的对比图
- en: The fitted values give a reasonable approximation of the behavior of the time
    series but reduce the noise from the underlying structure.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 拟合值合理地近似了时间序列的行为，但减少了潜在结构中的噪声。
- en: How it works...
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The ARMA model that we used in this recipe is a basic means of modeling the
    behavior of stationary time series. The two parts of an ARMA model are the AR
    and MA parts, which model the dependence of the terms and noise, respectively,
    on previous terms and noise. In practice, time series are usually not stationary,
    and we have to perform some kind of transformation to make this the case before
    we can fit an ARMA model.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个示例中使用的ARMA模型是建模平稳时间序列行为的一种基本方法。ARMA模型的两部分分别是AR部分和MA部分，分别建模项和噪声对前一项和前一噪声的依赖关系。在实践中，时间序列通常不是平稳的，我们必须进行某种转化使其平稳，才能拟合ARMA模型。
- en: 'An order 1 AR model has the following form:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 1阶AR模型具有以下形式：
- en: '![](img/Formula_07_047.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_047.png)'
- en: Here, ![](img/Formula_07_048.png) represents the parameters and ![](img/Formula_07_049.png)
    is the noise at a given step. The noise is usually assumed to be normally distributed
    with a mean of 0 and a standard deviation that is constant across all the time
    steps. The ![](img/Formula_07_050.png) value represents the value of the time
    series at the time step, ![](img/Formula_07_051.png). In this model, each value
    depends on the previous value, although it can also depend on some constants and
    some noise. The model will give rise to a stationary time series precisely when
    the ![](img/Formula_07_052.png) parameter lies strictly between -1 and 1.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_07_048.png)代表参数，![](img/Formula_07_049.png)是给定步骤的噪声。噪声通常假设服从均值为0、标准差在所有时间步骤中保持不变的正态分布。![](img/Formula_07_050.png)值表示在时间步骤![](img/Formula_07_051.png)时的时间序列值。在这个模型中，每个值依赖于前一个值，尽管它也可以依赖于一些常数和噪声。当![](img/Formula_07_052.png)参数严格介于-1和1之间时，模型将产生平稳的时间序列。
- en: 'An order 1 MA model is very similar to an AR model and is given by the following
    equation:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 阶数为 1 的 MA 模型与 AR 模型非常相似，形式如下：
- en: '![](img/Formula_07_053.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_053.png)'
- en: 'Here, the variants of ![](img/Formula_07_054.png) are parameters. Putting these
    two models together gives us an ARMA(1,1) model, which has the following form:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_07_054.png) 的变体是参数。将这两个模型结合起来，我们得到了一个 ARMA(1,1) 模型，其形式如下：
- en: '![](img/Formula_07_055.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_055.png)'
- en: In general, we can have an ARMA(p,q) model that has an order ![](img/Formula_07_056.png)
    AR component and an order q MA component. We usually refer to the quantities,
    ![](img/Formula_07_057.png) and ![](img/Formula_07_058.png), as the orders of
    the model.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以拥有一个 ARMA(p, q) 模型，其中有一个阶数为 p 的 AR 组件和一个阶数为 q 的 MA 组件。我们通常将量 ![](img/Formula_07_057.png)
    和 ![](img/Formula_07_058.png) 称为模型的阶数。
- en: Determining the orders of the AR and MA components is the most tricky aspect
    of constructing an ARMA model. The ACF and PACF give some information about this,
    but even then, it can be quite difficult. For example, an AR process will show
    some kind of decay or oscillating pattern on the ACF as lag increases, and a small
    number of peaks on the PACF and values that are not significantly different from
    zero beyond that. The number of peaks that appear on the PAF plot can be taken
    as the order of the process. For an MA process, the reverse is true. There is
    usually a small number of significant peaks on the ACF plot, and a decay or oscillating
    pattern on the PACF plot. Of course, sometimes, this isn’t obvious.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 确定 AR 和 MA 组件的阶数是构建 ARMA 模型时最棘手的部分。自相关函数（ACF）和偏自相关函数（PACF）提供了一些信息，但即便如此，仍然可能相当困难。例如，AR
    过程会在自相关图上表现出某种衰减或振荡模式，随着滞后增加，PACF 会显示出少数几个峰值，并且在此之后的值与零没有显著差异。PACF 图上的峰值数量可以视为过程的阶数。对于
    MA 过程，情况正好相反。自相关图上通常会有少数几个显著的峰值，而偏自相关图则表现出衰减或振荡模式。当然，有时这并不显而易见。
- en: In this recipe, we plotted the ACF and PACF for our sample time series data.
    In the autocorrelation plot in *Figure 7**.5* (top), we can see that the peaks
    decay rapidly until they lie within the confidence interval of zero (meaning they
    are not significant). This suggests the presence of an AR component. On the partial
    autocorrelation plot in *Figure 7**.5* (bottom), we can see that there are only
    two peaks that can be considered not zero, which suggests an AR process of order
    1 or 2\. You should try to keep the order of the model as small as possible. Due
    to this, we chose an order 1 AR component. With this assumption, the second peak
    on the partial autocorrelation plot is indicative of decay (rather than an isolated
    peak), which suggests the presence of an MA process. To keep the model simple,
    we try an order 1 MA process. This is how the model that we used in this recipe
    was decided on. Notice that this is not an exact process, and you might have decided
    differently.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们绘制了样本时间序列数据的 ACF 和 PACF。在自相关图的*图 7.5*（上方）中，我们可以看到，峰值迅速衰减，直到它们落入零的置信区间内（意味着它们不显著）。这表明存在
    AR 组件。在偏自相关图的*图 7.5*（下方）中，我们可以看到，只有两个峰值被认为不是零，这表明存在一个阶数为 1 或 2 的 AR 过程。你应该尽量保持模型的阶数尽可能小。因此，我们选择了阶数为
    1 的 AR 组件。在这个假设下，偏自相关图中的第二个峰值表明衰减（而不是孤立的峰值），这表明存在 MA 过程。为了简化模型，我们尝试了阶数为 1 的 MA
    过程。这就是我们在这个示例中使用的模型的决定过程。请注意，这不是一个精确的过程，你可能做出不同的决定。
- en: We use the augmented Dickey-Fuller test to test the likelihood that the time
    series that we have observed is stationary. This is a statistical test, such as
    those seen in [*Chapter 6*](B19085_06.xhtml#_idTextAnchor226), *Working with Data
    and Statistics*, that generates a test statistic from the data. This test statistic,
    in turn, determines a p-value that is used to determine whether to accept or reject
    the null hypothesis. For this test, the null hypothesis is that a unit root is
    present in the time series that’s been sampled. The alternative hypothesis – the
    one we are really interested in – is that the observed time series is (trend)
    stationary. If the p-value is sufficiently small, then we can conclude with the
    specified confidence that the observed time series is stationary. In this recipe,
    the p-value was 0.000 to 3 decimal places, which indicates a strong likelihood
    that the series is stationary. Stationarity is an essential assumption for using
    the ARMA model for the data.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用扩展的Dickey-Fuller检验来测试我们观察到的时间序列是否平稳。这是一个统计检验，类似于[*第6章*](B19085_06.xhtml#_idTextAnchor226)中看到的，*数据和统计处理*，它通过数据生成一个检验统计量。这个检验统计量进一步生成一个p值，用于决定是否接受或拒绝原假设。对于这个检验，原假设是所采样的时间序列中存在单位根。备择假设——我们真正关心的是——是观察到的时间序列是（趋势）平稳的。如果p值足够小，那么我们可以在指定的置信度下得出结论，认为观察到的时间序列是平稳的。在这个步骤中，p值为0.000（精确到小数点后三位），这表明序列平稳的可能性很高。平稳性是使用ARMA模型处理数据时的一个基本假设。
- en: Once we have determined that the series is stationary, and decided on the orders
    of the model, we have to fit the model to the sample data that we have. The parameters
    of the model are estimated using a maximum likelihood estimator. In this recipe,
    the learning of the parameters is done using the `fit` method, in *step 6*.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定序列是平稳的，并决定了模型的阶数，我们就需要将模型拟合到我们所拥有的样本数据中。模型的参数通过最大似然估计量来估算。在这个步骤中，参数的学习通过`fit`方法完成，在*第6步*中。
- en: The `statsmodels` package provides various tools for working with time series,
    including utilities for calculating – and plotting – ACF and PACF of time series
    data, various test statistics, and creating ARMA models for time series. There
    are also some tools for automatically estimating the order of the model.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`statsmodels`包提供了用于处理时间序列的各种工具，包括计算和绘制时间序列数据的自相关函数（ACF）和偏自相关函数（PACF）、各种统计检验量，以及为时间序列创建ARMA模型的工具。还有一些工具用于自动估算模型的阶数。'
- en: We can use the **Akaike information criterion** (**AIC**), **Bayesian information
    criterion** (**BIC**), and **Hannan-Quinn Information Criterion** (**HQIC**) quantities
    to compare this model to other models to see which model best describes the data.
    A smaller value is better in each case.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**赤池信息量准则**（**AIC**）、**贝叶斯信息量准则**（**BIC**）和**汉南-奎因信息量准则**（**HQIC**）来将这个模型与其他模型进行比较，看看哪个模型最好地描述了数据。在每种情况下，较小的值表示更好。
- en: Note
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When using ARMA to model time series data, as in all kinds of mathematical modeling
    tasks, it is best to pick the simplest model that describes the data to the extent
    that is needed. For ARMA models, this usually means picking the smallest order
    model that describes the structure of the observed data.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ARMA模型对时间序列数据建模时，就像在所有类型的数学建模任务中一样，最好选择最简单的模型来描述数据，达到所需的精度。对于ARMA模型，这通常意味着选择最小阶数的模型来描述观察到的数据结构。
- en: There’s more...
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Finding the best combination of orders for an ARMA model can be quite difficult.
    Often, the best way to fit a model is to test multiple different configurations
    and pick the order that produces the best fit. For example, we could have tried
    ARMA(0,1) or ARMA(1, 0) in this recipe, and compared it to the ARMA(1,1) model
    we used to see which produced the best fit by considering the AIC statistic reported
    in the summary. In fact, if we build these models, we will see that the AIC value
    for ARMA(1,1) – the model we used in this recipe – is the “best” of these three
    models.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 找到ARMA模型的最佳阶数组合可能相当困难。通常，拟合模型的最佳方法是测试多种不同的配置，选择能够产生最佳拟合的阶数。例如，我们可以在这个步骤中尝试ARMA(0,1)或ARMA(1,
    0)，并与我们使用的ARMA(1,1)模型进行比较，看看哪个模型产生了最好的拟合，通过考虑摘要中报告的AIC统计量。事实上，如果我们构建这些模型，就会看到ARMA(1,1)的AIC值——我们在这个步骤中使用的模型——是这三种模型中“最好的”。
- en: Forecasting from time series data using ARIMA
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ARIMA进行时间序列预测
- en: In the previous recipe, we generated a model for a stationary time series using
    an ARMA model, which consists of an AR component and an MA component. Unfortunately,
    this model cannot accommodate time series that have some underlying trend; that
    is, they are not stationary time series. We can often get around this by *differencing*
    the observed time series one or more times until we obtain a stationary time series
    that can be modeled using ARMA. The incorporation of differencing into an ARMA
    model is called an ARIMA model.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一教程中，我们使用ARMA模型为平稳时间序列生成了一个模型，该模型由AR成分和MA成分组成。不幸的是，这个模型无法处理具有某些潜在趋势的时间序列；也就是说，它们不是平稳时间序列。我们通常可以通过对观测到的时间序列进行一次或多次差分，直到得到一个可以通过ARMA建模的平稳时间序列。将差分纳入ARMA模型中称为ARIMA模型。
- en: Differencing is the process of computing the difference between consecutive
    terms in a sequence of data – so, applying first-order differencing amounts to
    subtracting the value at the current step from the value at the next step (![](img/Formula_07_059.png)).
    This has the effect of removing the underlying upward or downward linear trend
    from the data. This helps to reduce an arbitrary time series to a stationary time
    series that can be modeled using ARMA. Higher-order differencing can remove higher-order
    trends to achieve similar effects.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 差分是计算数据序列中连续项之间差异的过程——因此，应用一阶差分相当于从下一个步骤的值中减去当前步骤的值（![](img/Formula_07_059.png)）。这可以去除数据中的上升或下降的线性趋势。这样有助于将任意时间序列转换为一个平稳的时间序列，这个平稳序列可以通过ARMA模型进行建模。更高阶的差分可以去除更高阶的趋势，从而达到类似的效果。
- en: An ARIMA model has three parameters, usually labeled ![](img/Formula_07_060.png),
    ![](img/Formula_07_061.png), and ![](img/Formula_07_062.png). The ![](img/Formula_07_063.png)
    and ![](img/Formula_07_064.png) order parameters are the order of the AR component
    and the MA component, respectively, just as they are for the ARMA model. The third
    order parameter, ![](img/Formula_07_065.png), is the order of differencing to
    be applied. An ARIMA model with these orders is usually written as ARIMA (![](img/Formula_07_066.png),
    ![](img/Formula_07_067.png), ![](img/Formula_07_068.png)). Of course, we will
    need to determine what order differencing should be included before we start fitting
    the model.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA模型有三个参数，通常标记为 ![](img/Formula_07_060.png)，![](img/Formula_07_061.png)，和![](img/Formula_07_062.png)。![](img/Formula_07_063.png)
    和 ![](img/Formula_07_064.png) 这两个顺序参数分别是AR成分和MA成分的阶数，就像ARMA模型一样。第三个参数，![](img/Formula_07_065.png)，是要应用的差分阶数。具有这些阶数的ARIMA模型通常写作ARIMA
    (![](img/Formula_07_066.png)，![](img/Formula_07_067.png)，![](img/Formula_07_068.png))。当然，在我们开始拟合模型之前，需要确定差分应该采用什么阶数。
- en: In this recipe, we will learn how to fit an ARIMA model to a non-stationary
    time series and use this model to generate forecasts about future values.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何将ARIMA模型拟合到非平稳时间序列，并利用该模型生成未来值的预测。
- en: Getting ready
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy package imported as `np`, the Pandas
    package imported as `pd`, the Matplotlib `pyplot` module as `plt`, and the `statsmodels.api`
    module imported as `sm`. We will also need the utility for creating sample time
    series data from the `tsdata` module, which is included in this book’s repository:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们需要导入NumPy包，命名为`np`，导入Pandas包，命名为`pd`，导入Matplotlib的`pyplot`模块，命名为`plt`，以及导入`statsmodels.api`模块，命名为`sm`。我们还需要使用`tsdata`模块中的实用工具来生成样本时间序列数据，该模块包含在本书的代码库中：
- en: '[PRE162]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'As in the previous recipe, we use the Matplotlib `rcparams` to set the color
    for all plots in the recipe:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 和前面的教程一样，我们使用Matplotlib的`rcparams`来设置本教程中所有图表的颜色：
- en: '[PRE163]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: How to do it...
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'The following steps show you how to construct an ARIMA model for time series
    data and use this model to make forecasts:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何为时间序列数据构建ARIMA模型，并利用该模型进行预测：
- en: 'First, we load the sample data using the `generate_sample_data` routine:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`generate_sample_data`例程加载样本数据：
- en: '[PRE164]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'As usual, the next step is to plot the time series so that we can visually
    identify the trend of the data:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，下一步是绘制时间序列图，以便我们可以直观地识别数据的趋势：
- en: '[PRE166]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The resulting plot can be seen in the following figure. As we can see, there
    is a clear upward trend in the data, so the time series is certainly not stationary:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图可以在下图中看到。如我们所见，数据中存在明显的上升趋势，因此时间序列肯定不是平稳的：
- en: '![Figure 7.8 – Plot of the sample time series'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8 – 样本时间序列图'
- en: '](img/7.8.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.8.jpg)'
- en: Figure 7.8 – Plot of the sample time series
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 样本时间序列图
- en: There is an obvious positive trend in the data.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 数据中存在明显的正趋势。
- en: 'Next, we difference the series to see whether one level of differencing is
    sufficient to remove the trend:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们对序列进行差分，以查看一次差分是否足以去除趋势：
- en: '[PRE171]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Now, we plot the ACF and PACF for the differenced time series:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们绘制差分时间序列的ACF和PACF：
- en: '[PRE172]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'The ACF and PACF can be seen in the following figure. We can see that there
    do not appear to be any trends left in the data and that there appears to be both
    an AR component and an MA component:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 自相关函数（ACF）和偏自相关函数（PACF）可以在下图中看到。我们可以看到数据中似乎没有剩余趋势，并且似乎同时存在AR组件和MA组件：
- en: '![Figure 7.9 - ACF and PACF for the differenced time series'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.9 - 差分时间序列的自相关函数（ACF）和偏自相关函数（PACF）'
- en: '](img/7.9.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.9.jpg)'
- en: Figure 7.9 - ACF and PACF for the differenced time series
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 - 差分时间序列的ACF和PACF
- en: 'Now, we construct the ARIMA model with order 1 differencing, an AR component,
    and an MA component. We fit this to the observed time series and print a summary
    of the model:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们构建一个ARIMA模型，使用1阶差分、AR组件和MA组件，并将其拟合到观察到的时间序列中，然后打印模型摘要：
- en: '[PRE180]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The summary information that’s printed looks as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出的摘要信息如下所示：
- en: '[PRE183]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Here, we can see that all 3 of our estimated coefficients are significantly
    different from 0 since all three have 0 to 3 decimal places in the `P>|z|` column.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，我们估计的所有 3 个系数都显著不同于 0，因为它们在`P>|z|`列中都有 0 到 3 位小数。
- en: 'Now, we can use the `get_forecast` method to generate predictions of future
    values and generate a summary DataFrame from these predictions. This also returns
    the standard error and confidence intervals for predictions:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`get_forecast`方法生成未来值的预测，并从这些预测中生成摘要数据框。此方法还会返回预测的标准误差和置信区间：
- en: '[PRE184]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Next, we plot the forecast values and their confidence intervals on the figure
    containing the time series data:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在包含时间序列数据的图中绘制预测值及其置信区间：
- en: '[PRE185]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Finally, we add the actual future values to generate, along with the sample
    in *step 1*, to the plot (it might be easier if you repeat the plot commands from
    *step 1* to regenerate the whole plot here):'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将实际的未来值与*步骤 1*中的样本一起添加到图中进行生成（如果你从*步骤 1*重新执行绘图命令来重新生成整个图表，可能会更容易）：
- en: '[PRE191]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'The final plot containing the time series with the forecast and the actual
    future values can be seen in the following figure:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 最终包含时间序列、预测值和实际未来值的图表如下所示：
- en: '![Figure 7.10 - Sample time series with forecast values and actual future values
    for comparison'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.10 - 包含预测值和实际未来值进行比较的示例时间序列'
- en: '](img/7.10.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.10.jpg)'
- en: Figure 7.10 - Sample time series with forecast values and actual future values
    for comparison
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 - 包含预测值和实际未来值进行比较的示例时间序列
- en: Here, we can see that the actual future values are within the confidence interval
    for the forecast values.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，实际的未来值位于预测值的置信区间内。
- en: How it works...
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The ARIMA model – with orders ![](img/Formula_07_069.png), ![](img/Formula_07_070.png),
    and ![](img/Formula_07_071.png) – is simply an ARMA (![](img/Formula_07_072.png),![](img/Formula_07_073.png))
    model that’s applied to a time series. This is obtained by applying differencing
    of order ![](img/Formula_07_074.png) to the original time series data. It is a
    fairly simple way to generate a model for time series data. The `statsmodels`
    `ARIMA` class handles the creation of a model, while the `fit` method fits this
    model to the data.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA模型——其阶数为![](img/Formula_07_069.png)，![](img/Formula_07_070.png)，和![](img/Formula_07_071.png)——实际上是一个应用于时间序列的ARMA模型（![](img/Formula_07_072.png)，![](img/Formula_07_073.png)）。这是通过对原始时间序列数据应用阶数为![](img/Formula_07_074.png)的差分得到的。这是一种相对简单的生成时间序列数据模型的方法。`statsmodels`中的`ARIMA`类用于创建模型，而`fit`方法则将此模型拟合到数据中。
- en: The model is fit to the data using a maximum likelihood method and the final
    estimates for the parameters – in this case, one parameter for the AR component,
    one for the MA component, the constant trend parameter, and the variance of the
    noise. These parameters are reported in the summary. From this output, we can
    see that the estimates for the AR coefficient (`0.9567`) and the MA constant (`-0.6407`)
    are very good approximations of the true estimates that were used to generate
    the data, which were `0.8` for the AR coefficient and `-0.5` for the MA coefficient.
    These parameters are set in the `generate_sample_data` routine from the `tsdata.py`
    file in the code repository for this chapter. This generates the sample data in
    *step 1*. You might have noticed that the constant parameter (`1.0101`) is not
    `0.2`, as specified in the `generate_sample_data` call in *step 1*. In fact, it
    is not so far from the actual drift of the time series.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型通过最大似然法拟合数据，最终估计参数——在此情况下，AR组件的一个参数、MA组件的一个参数、常数趋势参数和噪声的方差。这些参数在汇总中报告。从输出中可以看到，AR系数（`0.9567`）和MA常数（`-0.6407`）的估计值与用于生成数据的真实估计值非常接近，真实值分别为AR系数的`0.8`和MA系数的`-0.5`。这些参数在代码库中的`tsdata.py`文件的`generate_sample_data`例程中设置。这在*步骤1*中生成了样本数据。你可能注意到，常数参数（`1.0101`）并非在*步骤1*中`generate_sample_data`调用中指定的`0.2`。实际上，它与时间序列的实际漂移值并不远。
- en: The `get_forecast` method on the fitted model (the output of the `fit` method)
    uses the model to make predictions about the value after a given number of steps.
    In this recipe, we forecast for up to 50 time steps beyond the range of the sample
    time series. The output of the command in *step 6* is a DataFrame containing the
    forecast values, the standard error for the forecasts, and the upper and lower
    bounds for the confidence interval (by default, 95% confidence) of the forecasts.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 拟合模型上的`get_forecast`方法（即`fit`方法的输出）使用该模型对给定步数后的值进行预测。在本食谱中，我们对样本时间序列范围之外的最多50个时间步进行预测。在*步骤6*中的命令输出是一个DataFrame，包含预测值、预测的标准误差以及预测的置信区间的上下界（默认情况下为95%的置信度）。
- en: When you construct an ARIMA model for time series data, you need to make sure
    you use the smallest order differencing that removes the underlying trend. Applying
    more differencing than is necessary is called *over-differencing* and can lead
    to problems with the model.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 当为时间序列数据构建ARIMA模型时，您需要确保使用最小的差分阶数来去除基础趋势。应用过多的差分被称为*过度差分*，可能会导致模型出现问题。
- en: Forecasting seasonal data using ARIMA
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ARIMA预测季节性数据
- en: Time series often display periodic behavior so that peaks or dips in the value
    appear at regular intervals. This behavior is called *seasonality* in the analysis
    of time series. The methods we have used thus far in this chapter to model time
    series data obviously do not account for seasonality. Fortunately, it is relatively
    easy to adapt the standard ARIMA model to incorporate seasonality, resulting in
    what is sometimes called a SARIMA model.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列通常表现出周期性行为，使得数值的峰值或谷值出现在规律的时间间隔。这种行为在时间序列分析中称为*季节性*。到目前为止，我们在本章中使用的建模方法显然没有考虑季节性。幸运的是，将标准ARIMA模型调整为考虑季节性相对简单，结果就是有时被称为SARIMA模型。
- en: In this recipe, we will learn how to model time series data that includes seasonal
    behavior and use this model to produce forecasts.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何对包含季节性行为的时间序列数据进行建模，并使用该模型进行预测。
- en: Getting ready
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy package imported as `np`, the Pandas
    package imported as `pd`, the Matplotlib `pyplot` module as `plt`, and the `statsmodels`
    `api` module imported as `sm`. We will also need the utility for creating sample
    time series data from the `tsdata` module, which is included in this book’s repository:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，我们需要导入NumPy包作为`np`，导入Pandas包作为`pd`，导入Matplotlib的`pyplot`模块作为`plt`，导入`statsmodels`的`api`模块作为`sm`。我们还需要从本书的代码库中包含的`tsdata`模块中获取创建样本时间序列数据的工具：
- en: '[PRE193]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Let’s see how to produce an ARIMA model that takes seasonal variations into
    account.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何生成一个考虑季节性变动的ARIMA模型。
- en: How to do it...
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to produce a seasonal ARIMA model for sample time series
    data and use this model to produce forecasts:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤，生成适用于样本时间序列数据的季节性ARIMA模型，并使用该模型进行预测：
- en: 'First, we use the `generate_sample_data` routine to generate a sample time
    series to analyze:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`generate_sample_data`例程生成一个样本时间序列进行分析：
- en: '[PRE194]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'As usual, our first step is to visually inspect the data by producing a plot
    of the sample time series:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如往常一样，我们的第一步是通过生成样本时间序列的绘图来直观检查数据：
- en: '[PRE196]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'The plot of the sample time series data can be seen in the following figure.
    Here, we can see that there seem to be periodic peaks in the data:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 样本时间序列数据的绘图可以在下图中看到。在这里，我们可以看到数据中似乎存在周期性的峰值：
- en: '![Figure 7.11 - Plot of the sample time series data'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.11 - 样本时间序列数据的绘图'
- en: '](img/7.11.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.11.jpg)'
- en: Figure 7.11 - Plot of the sample time series data
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 - 样本时间序列数据的绘图
- en: 'Next, we plot the ACF and PACF for the sample time series:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们绘制样本时间序列的ACF和PACF：
- en: '[PRE201]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'The ACF and PACF for the sample time series can be seen in the following figure:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 样本时间序列的ACF和PACF可以在下图中看到：
- en: '![Figure 7.12 - The ACF and PACF for the sample time series'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.12 - 样本时间序列的ACF和PACF'
- en: '](img/7.12.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.12.jpg)'
- en: Figure 7.12 - The ACF and PACF for the sample time series
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 - 样本时间序列的ACF和PACF
- en: These plots possibly indicate the existence of AR components, but also a significant
    spike in the PACF with lag **7**.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图可能表明存在AR成分，但也存在PACF在滞后**7**时的显著峰值。
- en: 'Next, we difference the time series and produce plots of the ACF and PACF for
    the differenced series. This should make the order of the model clearer:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们对时间序列进行差分，并生成差分序列的ACF和PACF图。这应该能让模型的阶数更加清晰：
- en: '[PRE209]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'The ACF and PACF for the differenced time series can be seen in the following
    figure. We can see that there is definitely a seasonal component with lag 7:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 差分时间序列的ACF和PACF可以在下图中看到。我们可以看到，确实存在一个季节性成分，滞后为7：
- en: '![Figure 7.13 -  Plot of the ACF and PACF for the differenced time series'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.13 - 差分时间序列的ACF和PACF绘图'
- en: '](img/7.13.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.13.jpg)'
- en: Figure 7.13 - Plot of the ACF and PACF for the differenced time series
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 - 差分时间序列的ACF和PACF绘图
- en: 'Now, we need to create a `SARIMAX` object that holds the model, with an ARIMA
    order of `(1, 1, 1)` and a SARIMA order of `(1, 0, 0, 7)`. We fit this model to
    the sample time series and print summary statistics. We plot the predicted values
    on top of the time series data:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个包含模型的`SARIMAX`对象，ARIMA阶数为`(1, 1, 1)`，SARIMA阶数为`(1, 0, 0, 7)`。我们将此模型拟合到样本时间序列并打印摘要统计信息。然后，我们将预测值绘制在时间序列数据的顶部：
- en: '[PRE220]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'The first half of the summary statistics that are printed to the terminal are
    as follows:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 打印到终端的摘要统计的前半部分如下：
- en: '[PRE224]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'As before, the first half contains some information about the model, parameters,
    and fit. The second half of the summary (here) contains information about the
    estimated model coefficients:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，摘要的前半部分包含有关模型、参数和拟合的一些信息。摘要的后半部分（此处）包含关于估计模型系数的信息：
- en: '[PRE225]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'This model appears to be a reasonable fit, so we move ahead and forecast `50`
    time steps into the future:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个模型似乎是合理的拟合，所以我们继续预测`50`个时间步的未来值：
- en: '[PRE226]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'Finally, we add the forecast values to the plot of the sample time series,
    along with the confidence interval for these forecasts:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将预测值添加到样本时间序列的绘图中，并加上这些预测的置信区间：
- en: '[PRE229]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'The final plot of the time series, along with the predictions and the confidence
    interval for the forecasts, can be seen in the following figure:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的时间序列绘图，包含预测值和预测的置信区间，可以在下图中看到：
- en: '![Figure 7.14 - Plot of the sample time series, along with the forecasts and
    confidence interval'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.14 - 样本时间序列的绘图，包含预测值和置信区间'
- en: '](img/7.14.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.14.jpg)'
- en: Figure 7.14 - Plot of the sample time series, along with the forecasts and confidence
    interval
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 - 样本时间序列的绘图，包含预测值和置信区间
- en: As we can see, the forecast evolution follows roughly the same upward trajectory
    as the final portion of observed data, and the confidence region for predictions
    expands quickly. We can see that the actual future values dip down again after
    the end of the observed data but do stay within the confidence interval.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，预测演变大致遵循观察数据最后部分的上升轨迹，且预测的置信区间迅速扩展。我们可以看到，实际的未来值在观察数据结束后再次下降，但仍保持在置信区间内。
- en: How it works...
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Adjusting an ARIMA model to incorporate seasonality is a relatively simple
    task. A seasonal component is similar to an AR component, where the lag starts
    at some number larger than 1\. In this recipe, the time series exhibits seasonality
    with period 7 (weekly), which means that the model is approximately given by the
    following equation:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 调整 ARIMA 模型以纳入季节性成分是一个相对简单的任务。季节性成分类似于自回归（AR）成分，其中滞后开始时是一个大于 1 的数值。在这个例子中，时间序列展示了周期为
    7（每周）的季节性，这意味着该模型大致由以下方程给出：
- en: '![](img/Formula_07_075.png)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_075.png)'
- en: Here, ![](img/Formula_07_076.png) and ![](img/Formula_07_077.png) are the parameters
    and ![](img/Formula_07_078.png) is the noise at time step ![](img/Formula_07_079.png).
    The standard ARIMA model is easily adapted to include this additional lag term.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![](img/Formula_07_076.png) 和 ![](img/Formula_07_077.png) 是参数，![](img/Formula_07_078.png)
    是时间步长 ![](img/Formula_07_079.png) 时的噪声。标准的 ARIMA 模型可以轻松调整，以包括这个额外的滞后项。
- en: The SARIMA model incorporates this additional seasonality into the ARIMA model.
    It has four additional order terms on top of the three for the underlying ARIMA
    model. These four additional parameters are the seasonal AR, differencing, and
    MA components, along with the period of seasonality. In this recipe, we took the
    seasonal AR as order 1, with no seasonal differencing or MA components (order
    0), and a seasonal period of 7\. This gives us the additional parameters (1, 0,
    0, 7) that we used in *step 5* of this recipe.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: SARIMA 模型将额外的季节性因素纳入 ARIMA 模型中。它在原有的 ARIMA 模型的三个阶数基础上，增加了四个额外的阶数。这四个额外的参数包括季节性自回归（AR）、差分和移动平均（MA）成分，以及季节周期。在这个例子中，我们将季节性自回归设为阶数
    1，没有季节性差分或 MA 成分（阶数为 0），季节周期为 7。这样，我们得到了额外的参数（1, 0, 0, 7），并在本食谱的*步骤 5*中使用了这些参数。
- en: Seasonality is clearly important in modeling time series data that is measured
    over a period of time covering days, months, or years. It usually incorporates
    some kind of seasonal component based on the time frame that they occupy. For
    example, a time series of national power consumption measured hourly over several
    days would probably have a 24-hour seasonal component since power consumption
    will likely fall during the night hours.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 季节性在建模跨越天数、月份或年份的时间序列数据时显然非常重要。它通常包含基于所占时间框架的某种季节性成分。例如，测量几天内按小时记录的国家电力消耗的时间序列，可能会有一个
    24 小时的季节性成分，因为电力消耗在夜间时间段内可能会下降。
- en: Long-term seasonal patterns might be hidden if the time series data that you
    are analyzing does not cover a sufficiently large time period for the pattern
    to emerge. The same is true for trends in the data. This can lead to some interesting
    problems when trying to produce long-term forecasts from a relatively short period
    represented by observed data.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你分析的时间序列数据没有覆盖足够长的时间段，以便让长期季节性模式显现出来，那么长期季节性模式可能会被隐藏。同样，数据中的趋势也存在这种情况。当你试图从相对较短的观察数据所代表的时间段中生成长期预测时，这可能会导致一些有趣的问题。
- en: The `SARIMAX` class from the `statsmodels` package provides the means of modeling
    time series data using a seasonal ARIMA model. In fact, it can also model external
    factors that have an additional effect on the model, sometimes called *exogenous
    regressors* (we will not cover these here). This class works much like the `ARMA`
    and `ARIMA` classes that we used in the previous recipes. First, we create the
    model object by providing the data and orders for both the ARIMA process and the
    seasonal process, and then use the `fit` method on this object to create a fitted
    model object. We use the `get_forecasts` method to generate an object holding
    the forecasts and confidence interval data that we can then plot, thus producing
    *Figure 7**.14*.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`SARIMAX` 类来自 `statsmodels` 包，提供了使用季节性 ARIMA 模型建模时间序列数据的方法。事实上，它还可以建模对模型有额外影响的外部因素，这些因素有时被称为*外生回归量*（我们在这里不进行介绍）。这个类的工作方式与我们在之前的例子中使用的
    `ARMA` 和 `ARIMA` 类非常相似。首先，我们通过提供数据以及 ARIMA 过程和季节性过程的阶数来创建模型对象，然后使用 `fit` 方法对该对象进行拟合，从而创建一个拟合的模型对象。我们使用
    `get_forecasts` 方法生成一个包含预测值和置信区间数据的对象，然后可以对其进行绘图，从而生成*图 7.14*。'
- en: There’s more...
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is a small difference in the interface between the `SARIMAX` class used
    in this recipe and the `ARIMA` class used in the previous recipe. At the time
    of writing, the `statsmodels` package (v0.11) includes a second `ARIMA` class
    that builds on top of the `SARIMAX` class, thus providing the same interface.
    However, at the time of writing, this new `ARIMA` class does not offer the same
    functionality as that used in this recipe.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中使用的`SARIMAX`类与之前食谱中使用的`ARIMA`类的接口略有不同。在写这篇文章时，`statsmodels`包（v0.11）包含了一个基于`SARIMAX`类的第二个`ARIMA`类，因此提供了相同的接口。然而，在写作时，这个新的`ARIMA`类并不提供与本食谱中使用的相同功能。
- en: Using Prophet to model time series data
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Prophet对时间序列数据进行建模
- en: The tools we have seen so far for modeling time series data are very general
    and flexible methods, but they require some knowledge of time series analysis
    in order to be set up. The analysis needed to construct a good model that can
    be used to make reasonable predictions for the future can be intensive and time-consuming,
    and may not be viable for your application. The Prophet library is designed to
    automatically model time series data quickly, without the need for input from
    the user, and make predictions for the future.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的用于建模时间序列数据的工具是非常通用和灵活的方法，但它们需要一定的时间序列分析知识才能设置。构建一个能够用来做出合理未来预测的好模型所需的分析可能非常繁琐且耗时，可能不适用于您的应用。Prophet库的设计是为了快速自动建模时间序列数据，无需用户输入，并能够做出未来的预测。
- en: In this recipe, we will learn how to use Prophet to produce forecasts from a
    sample time series.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使用Prophet从一个示例时间序列中生成预测。
- en: Getting ready
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the Pandas package imported as `pd`, the Matplotlib
    `pyplot` package imported as `plt`, and the `Prophet` object from the Prophet
    library, which can be imported using the following command:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要导入Pandas包作为`pd`，Matplotlib的`pyplot`包作为`plt`，以及从Prophet库中导入`Prophet`对象，可以使用以下命令导入：
- en: '[PRE235]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: Prior to version 1.0, the `prophet` library was called `fbprophet`.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.0版本之前，`prophet`库被称为`fbprophet`。
- en: 'We also need to import the `generate_sample_data` routine from the `tsdata`
    module, which is included in the code repository for this book:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从`tsdata`模块中导入`generate_sample_data`例程，该模块包含在本书的代码库中：
- en: '[PRE236]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Let’s see how to use the Prophet package to quickly generate models of time
    series data.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Prophet包来快速生成时间序列数据模型。
- en: How to do it...
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps show you how to use the Prophet package to generate forecasts
    for a sample time series:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将向您展示如何使用Prophet包为示例时间序列生成预测：
- en: 'First, we use `generate_sample_data` to generate the sample time series data:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`generate_sample_data`生成示例时间序列数据：
- en: '[PRE237]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'We need to convert the sample data into a DataFrame that Prophet expects:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将示例数据转换为Prophet期望的DataFrame格式：
- en: '[PRE239]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Next, we make a model using the `Prophet` class and fit it to the sample time
    series:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`Prophet`类创建一个模型，并将其拟合到示例时间序列上：
- en: '[PRE243]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'Now, we create a new DataFrame that contains the time intervals for the original
    time series, plus the additional periods for the forecasts:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个新的DataFrame，其中包含原始时间序列的时间间隔，以及预测的额外时间段：
- en: '[PRE245]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'Then, we use the `predict` method to produce the forecasts along the time periods
    we just created:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`predict`方法来生成沿着我们刚创建的时间段的预测：
- en: '[PRE246]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'Finally, we plot the predictions on top of the sample time series data, along
    with the confidence interval and the true future values:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将预测结果绘制在示例时间序列数据上，并包含置信区间和真实的未来值：
- en: '[PRE247]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'The plot of the time series, along with forecasts, can be seen in the following
    figure:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列的图，以及预测，可以在下图中看到：
- en: '![Figure 7.15 - Plot of sample time series data, along with forecasts and a
    confidence interval'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.15 - 示例时间序列数据的图，包含预测和置信区间'
- en: '](img/7.15.jpg)'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.15.jpg)'
- en: Figure 7.15 - Plot of sample time series data, along with forecasts and a confidence
    interval
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 - 示例时间序列数据的图，包含预测和置信区间
- en: We can see that the fit of the data up to (approximately) October 2020 is pretty
    good, but then a sudden dip in the observed data causes an abrupt change in the
    predicted values, which continues into the future. This can probably be rectified
    by tuning the settings of the Prophet prediction.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，数据到（大约）2020年10月的拟合效果很好，但接着观测数据出现突然而剧烈的下降，导致预测值发生了剧烈变化，并一直持续到未来。这个问题可能通过调整Prophet预测的设置来修正。
- en: How it works...
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Prophet is a package that’s used to automatically produce models for time series
    data based on sample data, with little extra input needed from the user. In practice,
    it is very easy to use; we just need to create an instance of the `Prophet` class,
    call the `fit` method, and then we are ready to produce forecasts and understand
    our data using the model.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 是一个用于基于样本数据自动生成时间序列数据模型的包，几乎不需要额外的用户输入。实际上，它非常易于使用；我们只需要创建 `Prophet`
    类的实例，调用 `fit` 方法，然后就可以准备好使用模型进行预测并理解我们的数据。
- en: 'The `Prophet` class expects the data in a specific format: a DataFrame with
    columns named `ds` for the date/time index, and `y` for the response data (the
    time series values). This DataFrame should have integer indices. Once the model
    has been fit, we use `make_future_dataframe` to create a DataFrame in the correct
    format, with appropriate date intervals, and with additional rows for future time
    intervals. The `predict` method then takes this DataFrame and produces values
    using the model to populate these time intervals with predicted values. We also
    get other information, such as the confidence intervals, in this forecast’s DataFrame.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`Prophet` 类期望数据以特定格式呈现：一个包含名为 `ds` 的日期/时间索引列和名为 `y` 的响应数据列（即时间序列值）的 DataFrame。该
    DataFrame 应该具有整数索引。一旦模型拟合完成，我们可以使用 `make_future_dataframe` 方法创建一个正确格式的 DataFrame，其中包含适当的日期间隔，并为未来的时间间隔添加额外的行。接着，`predict`
    方法会接受这个 DataFrame，并利用模型填充这些时间间隔的预测值。我们还可以从这个预测的 DataFrame 中获得其他信息，如置信区间。'
- en: There’s more...
  id: totrans-555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Prophet does a fairly good job of modeling time series data without any input
    from the user. However, the model can be customized using various methods from
    the `Prophet` class. For example, we could provide information about the seasonality
    of the data using the `add_seasonality` method of the `Prophet` class, prior to
    fitting the model.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 在不需要用户输入的情况下，能相当好地建模时间序列数据。然而，模型可以通过 `Prophet` 类中的各种方法进行自定义。例如，我们可以在拟合模型之前，使用
    `Prophet` 类的 `add_seasonality` 方法提供关于数据季节性的相关信息。
- en: There are alternative packages for automatically generating models for time
    series data. For example, popular machine learning libraries such as TensorFlow
    can be used to model time series data.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些替代的包可以自动生成时间序列数据的模型。例如，流行的机器学习库如 TensorFlow 可以用来建模时间序列数据。
- en: Using signatures to summarize time series data
  id: totrans-558
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用签名方法总结时间序列数据
- en: Signatures are a mathematical construction that arises from rough path theory
    – a branch of mathematics established by Terry Lyons in the 1990s. The signature
    of a path is an abstract description of the variability of the path and, up to
    “tree-like equivalence,” the signature of a path is unique (for instance, two
    paths that are related by a translation will have the same signature). The signature
    is independent of parametrization and, consequently, signatures handle irregularly
    sampled data effectively.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 签名是源于粗糙路径理论的数学构造——这是由 Terry Lyons 在 1990 年代建立的数学分支。路径的签名是该路径变动性的抽象描述，并且根据“树状等价”的定义，路径的签名是唯一的（例如，两条通过平移相关的路径将具有相同的签名）。签名与参数化无关，因此签名能够有效处理不规则采样的数据。
- en: Recently, signatures have found their way into the data science world as a means
    of summarizing time series data to be passed into machine learning pipelines (and
    for other applications). One of the reasons this is effective is because the signature
    of a path (truncated to a particular level) is always a fixed size, regardless
    of how many samples are used to compute the signature. One of the easiest applications
    of signatures is for classification (and outlier detection). For this, we often
    compute the **expected signature** – the component-wise mean of signatures – of
    a family of sampled paths that have the same underlying signal, and then compare
    the signatures of new samples to this expected signature to see whether they are
    “close.”
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，签名方法已逐渐进入数据科学领域，作为总结时间序列数据并传递给机器学习管道（以及其他应用）的手段。之所以有效，是因为路径的签名（截断到特定层级）始终是固定大小的，无论用于计算签名的样本数量有多少。签名的一个最简单的应用是分类（以及异常值检测）。为此，我们通常会计算**期望签名**——一个具有相同基本信号的采样路径族的分量均值，然后将新样本的签名与这个期望签名进行比较，以判断它们是否“接近”。
- en: In terms of practical use, there are several Python packages for computing signatures
    from sampled paths. We’ll be using the `esig` package in this recipe, which is
    a reference package developed by Lyons and his team – the author is the maintainer
    of this package at the time of writing. There are alternative packages such as
    `iisignature` and `signatory` (based on PyTorch, but not actively developed).
    In this recipe, we will compute signatures for a collection of paths constructed
    by adding noise to two known signals and compare the expected signatures of each
    collection to the signature of the true signal and one another.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际使用的角度来看，有几个Python包可以计算从采样路径获得的签名。我们将在这个配方中使用`esig`包，它是由Lyons及其团队开发的参考包——作者在写作时是该包的维护者。还有其他包，如`iisignature`和`signatory`（基于PyTorch，但未积极开发）。在这个配方中，我们将计算一个包含噪声的路径集合的签名，将噪声添加到两个已知信号中，并将每个集合的预期签名与真实信号的签名以及彼此的签名进行比较。
- en: Getting ready
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will make use of the NumPy package (imported as `np` as
    usual) and the Matplotlib `pyplot` interface imported as `plt`. We will also need
    the `esig` package. Finally, we will create an instance of the default random
    number generator from the NumPy `random` library created as follows:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用NumPy包（照常导入为`np`）和Matplotlib的`pyplot`接口，导入为`plt`。我们还需要`esig`包。最后，我们将创建NumPy
    `random`库的默认随机数生成器实例，如下所示：
- en: '[PRE257]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: The seed will ensure that the data generated will be reproducible.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 种子将确保生成的数据是可复现的。
- en: How to do it…
  id: totrans-566
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow the steps below to compute signatures for two signals and use these
    signatures to distinguish observed data from each signal:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤计算两个信号的签名，并使用这些签名区分每个信号的观察数据：
- en: 'To start, let’s define some parameters that we will use in the recipe:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义一些我们将在配方中使用的参数：
- en: '[PRE258]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'Next, we define a utility function that we can use to add noise to each signal.
    The noise we add is simply Gaussian noise with mean 0 and variance defined previously:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个工具函数，用于向每个信号添加噪声。我们添加的噪声只是均值为0、方差如前所定义的高斯噪声：
- en: '[PRE261]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Now, we define functions that describe the true signals over the interval ![](img/Formula_07_080.png)
    with irregular parameter values that are defined by taking drawing increments
    from an exponential distribution:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义描述真实信号的函数，这些信号在![](img/Formula_07_080.png)区间内，并且具有通过从指数分布中提取增量来定义的不规则参数值：
- en: '[PRE263]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'Let’s generate a sample signal and plot these to see what our true signals
    look like on the plane:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们生成一个示例信号并绘制这些图形，以查看我们的真实信号在平面上的样子：
- en: '[PRE273]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE296]'
- en: 'The resulting plot is shown in *Figure 7**.16*. On the first row, we can see
    the plots of each component of the signal over the parameter interval. On the
    second row, we can see the ![](img/Formula_07_081.png) component plotted against
    the ![](img/Formula_07_082.png) component:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图如*图 7.16*所示。在第一排，我们可以看到每个信号成分在参数区间内的图形。在第二排，我们可以看到将![](img/Formula_07_081.png)成分与![](img/Formula_07_082.png)成分绘制出来的图形：
- en: '![Figure 7.16 - Components (top row) of signals a and b and the signals on
    the plane (bottom row)'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.16 - 信号 a 和 b 的组成部分（上排）以及平面上的信号（下排）'
- en: '](img/7.16.jpg)'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7.16.jpg)'
- en: Figure 7.16 - Components (top row) of signals a and b and the signals on the
    plane (bottom row)
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 - 信号 a 和 b 的组成部分（上排）以及平面上的信号（下排）
- en: 'Now, we use the `stream2sig` routine from the `esig` package to compute the
    signature of the two signals. This routine takes the stream data as the first
    argument and the depth (which determines the level at which the signature is truncated)
    as the second argument. We use the depth set in *step 1* for this argument:'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`esig`包中的`stream2sig`例程来计算两个信号的签名。这个例程将流数据作为第一个参数，深度（决定签名截断的级别）作为第二个参数。我们使用*步骤
    1*中设置的深度作为这个参数：
- en: '[PRE297]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'This will print the two signatures (as NumPy arrays) as follows:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出两个签名（作为NumPy数组），如下所示：
- en: '[PRE300]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'Now, we generate several noisy signals using our `make_noisy` routine from
    *step 2*. Not only do we randomize the parametrization of the interval but also
    the number of samples:'
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`步骤 2`中的`make_noisy`例程生成几个带噪声的信号。我们不仅随机化了区间的参数化，还随机化了样本数量：
- en: '[PRE301]'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE308]'
- en: 'Now, we compute the mean of each collection of signatures component by component
    to generate an “expected signature.” We can compare these to the true signal signatures
    and one another to illustrate the ability of signatures to discriminate between
    the two signals:'
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们计算每一组签名分量的均值，逐个分量生成一个“期望签名”。我们可以将这些与真实的信号签名以及彼此进行比较，以说明签名在区分这两种信号方面的能力：
- en: '[PRE309]'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE311]'
- en: 'This will print out the two expected signatures, as follows:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出两个期望签名，如下所示：
- en: '[PRE312]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'Finally, we print the maximum difference (in absolute value) between each expected
    signature and the corresponding true signal signature and between the two expected
    signatures:'
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们打印每个期望签名与相应的真实信号签名之间的最大差异（绝对值），以及两个期望签名之间的最大差异：
- en: '[PRE313]'
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE318]'
- en: 'The results are shown here:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE319]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: We can see that the difference between the expected signature and the true signature
    in each case is relatively small, whereas the difference between the two expected
    signatures is relatively large.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，每种情况下期望签名与真实签名之间的差异相对较小，而两个期望签名之间的差异则相对较大。
- en: How it works…
  id: totrans-646
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The signature of a path ![](img/Formula_07_083.png) (taking values in the ![](img/Formula_07_084.png)-dimensional
    real space) over an interval ![](img/Formula_07_085.png) is an element of the
    **free tensor algebra** over ![](img/Formula_07_086.png) (in this notation, ![](img/Formula_07_087.png)
    denotes the value of the path at time ![](img/Formula_07_088.png). You may prefer
    to think of this as ![](img/Formula_07_089.png)). We denote this signature as
    ![](img/Formula_07_090.png). Formality aside, we realize the signature as a sequence
    of elements as follows:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 路径的签名 ![](img/Formula_07_083.png)（取值于 ![](img/Formula_07_084.png) 维实数空间）在区间
    ![](img/Formula_07_085.png) 上是**自由张量代数**中的一个元素，作用在 ![](img/Formula_07_086.png)
    上（在这个符号中，![](img/Formula_07_087.png) 表示路径在时间 ![](img/Formula_07_088.png) 时的值。你也可以理解为
    ![](img/Formula_07_089.png)）。我们将这个签名表示为 ![](img/Formula_07_090.png)。不拘泥于形式，我们可以将签名理解为以下的一系列元素：
- en: '![](img/Formula_07_091.png)'
  id: totrans-648
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_091.png)'
- en: 'The superscripts denote the index within the free tensor. For example, the
    indices with two terms ![](img/Formula_07_092.png) (degree 2) are like the rows
    and columns of a matrix. The first term of the signature is always 1\. The following
    ![](img/Formula_07_093.png)-terms are given by the increments in each of the component
    directions: if we write the path ![](img/Formula_07_094.png) as a vector ![](img/Formula_07_095.png),
    then these terms are given by the following formula:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 上标表示自由张量中的索引。例如，两个项的索引 ![](img/Formula_07_092.png)（二阶）就像是矩阵的行和列。签名的第一个项总是 1。接下来的
    ![](img/Formula_07_093.png) 项由每个分量方向的增量给出：如果我们将路径 ![](img/Formula_07_094.png)
    写作一个向量 ![](img/Formula_07_095.png)，那么这些项由以下公式给出：
- en: '![](img/Formula_07_096.png)'
  id: totrans-650
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_096.png)'
- en: 'The higher order terms are given by iterated integrals of these component functions:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶项由这些分量函数的迭代积分给出：
- en: '![](img/Formula_07_097.png)'
  id: totrans-652
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_097.png)'
- en: The full signature of a path is an infinite sequence – so for practical uses,
    we usually truncate at a particular *depth* that determines the maximum size of
    indices, such as ![](img/Formula_07_098.png) here.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 一个路径的完整签名是一个无限序列——因此在实际应用中，我们通常会在特定的*深度*上截断，这个深度决定了索引的最大大小，例如这里的 ![](img/Formula_07_098.png)。
- en: 'This iterated integral definition is not especially useful in practice. Fortunately,
    when we sample a path and make the modest assumption that the path is linear between
    successive samples, then we can compute the signature by computing the product
    of tensor exponentials of increments. Concretely, if ![](img/Formula_07_099.png)
    are sample values taken from our path ![](img/Formula_07_100.png) at ![](img/Formula_07_101.png),
    respectively, all lying between ![](img/Formula_07_102.png) and ![](img/Formula_07_103.png),
    then (assuming ![](img/Formula_07_104.png) is linear between ![](img/Formula_07_105.png)
    and ![](img/Formula_07_106.png)) the signature is given by the following:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代积分定义在实际中并不特别有用。幸运的是，当我们对路径进行采样并作出一个适度的假设，即假设路径在连续采样点之间是线性的时，我们可以通过计算增量的张量指数的乘积来计算签名。具体地说，如果
    ![](img/Formula_07_099.png) 是从我们的路径 ![](img/Formula_07_100.png) 在 ![](img/Formula_07_101.png)
    处采样得到的值，它们分别位于 ![](img/Formula_07_102.png) 和 ![](img/Formula_07_103.png) 之间，那么（假设
    ![](img/Formula_07_104.png) 在 ![](img/Formula_07_105.png) 和 ![](img/Formula_07_106.png)
    之间是线性的）签名由以下公式给出：
- en: '![](img/Formula_07_107.png)'
  id: totrans-655
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_107.png)'
- en: 'Here, the ![](img/Formula_07_108.png) symbol denotes multiplication in the
    free tensor algebra (this multiplication is defined by the concatenation of indices
    – so, for instance, the ![](img/Formula_07_109.png)-th value on the left and the
    ![](img/Formula_07_110.png)-th value on the right will contribute to the ![](img/Formula_07_111.png)-th
    value in the result). Remember that these are exponents of free tensor objects
    – not the usual exponential function – which are defined using the familiar power
    series:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，符号![](img/Formula_07_108.png)表示自由张量代数中的乘法（这种乘法是由指标的连接定义的 - 因此，例如，左边的第![](img/Formula_07_109.png)个值和右边的第![](img/Formula_07_110.png)个值将贡献给结果中的第![](img/Formula_07_111.png)个值）。请记住，这些是自由张量对象的指数
    - 不是通常的指数函数 - 它们是使用熟悉的幂级数定义的：
- en: '![](img/Formula_07_112.png)'
  id: totrans-657
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_112.png)'
- en: When the constant term of a tensor ![](img/Formula_07_113.png) is zero and we
    truncate the tensor algebra to depth ![](img/Formula_07_114.png), then the value
    of ![](img/Formula_07_115.png) is exactly equal to the sum of the first ![](img/Formula_07_116.png)
    terms of this sum, which is a finite sum that can be computed efficiently.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个张量![](img/Formula_07_113.png)的常数项为零，并且我们将张量代数截断到深度![](img/Formula_07_114.png)时，那么![](img/Formula_07_115.png)的值恰好等于这个和的前![](img/Formula_07_116.png)项之和，这是一个有限和，可以高效计算。
- en: The importance of the signature of a path in a data science context is from
    the fact that the signature is representative of the path from the perspective
    of functions. Any continuous function defined on the path ![](img/Formula_07_117.png)
    is approximately (in a very precise sense) a linear function defined on the signature.
    Thus, anything that can be learned about a path can also be learned from the signature.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学领域，路径的签名的重要性在于签名代表了从函数的角度看路径。在路径![](img/Formula_07_117.png)上定义的任何连续函数都近似（在非常精确的意义上）是在签名上定义的线性函数。因此，任何关于路径的信息也可以从签名中学习到。
- en: 'The `esig` package is built on top of the `libalgebra` C++ library for computations
    involving the free tensor algebra (and other kinds of algebraic objects). The
    `stream2sig` routine from `esig` takes a sequence of path samples in the form
    of an `N` (number of samples) x `d` (number of dimensions) NumPy array and returns
    a flat NumPy array containing the components of the signature, laid out in sequence
    as described here. The second argument to `stream2sig` is the depth parameter
    ![](img/Formula_07_118.png), which we have chosen to be 2 in this recipe. The
    size of the signature array is determined only by the dimension of the space and
    the depth, and is given by the following formula:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '`esig`软件包是建立在用于涉及自由张量代数（和其他类型的代数对象）计算的`libalgebra` C++库之上的。`esig`中的`stream2sig`例程接受一个形式为`N`（样本数量）x`d`（维度数量）的NumPy数组的路径样本序列，并返回一个包含签名组件的平坦NumPy数组，按照这里描述的顺序排列。`stream2sig`的第二个参数是深度参数![](img/Formula_07_118.png)，在这个公式中我们选择为2。签名数组的大小仅由空间的维度和深度确定，并由以下公式给出：'
- en: '![](img/Formula_07_119.png)'
  id: totrans-661
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_119.png)'
- en: In the recipe, both of our paths were 2-dimensional, and signatures were computed
    to depth 2 so the signature has ![](img/Formula_07_120.png) elements (notice that
    the number of samples varied in each case and were generated randomly and irregularly,
    yet the signature was the same size in each case).
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，我们的路径都是二维的，签名计算到深度为2，因此签名有![](img/Formula_07_120.png)个元素（请注意，每种情况下样本数量不同，是随机和不规则生成的，但签名在每种情况下都是相同大小）。
- en: Now that the theory is out of the way, let’s look at the recipe. We define two
    true paths (signals), which we called *signal a* and *signal b*. We draw samples
    from each signal by drawing parameter values ![](img/Formula_07_121.png) with
    differences taken from an exponential distribution so that (on average) ![](img/Formula_07_122.png).
    Then, we feed these parameter values into the formula for the path (see *step
    3*). In the latter steps, we also add Gaussian noise to generated paths with mean
    0 and variance 0.1\. This guarantees that our 2 signals are irregularly sampled
    and noisy – to demonstrate the robustness of signature calculations.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 现在理论已经讲完，让我们看看这个公式。我们定义了两条真实路径（信号），我们称之为*信号a*和*信号b*。我们从每个信号中抽取样本，通过从指数分布中取参数值![](img/Formula_07_121.png)，使得（平均）![](img/Formula_07_122.png)。然后，我们将这些参数值输入到路径的公式中（参见*步骤3*）。在后续步骤中，我们还向生成的路径添加均值为0、方差为0.1的高斯噪声。这确保我们的2个信号是不规则采样和嘈杂的
    - 以展示签名计算的稳健性。
- en: 'Signal a is defined by the following formula:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 信号a由以下公式定义：
- en: '![](img/Formula_07_123.png)'
  id: totrans-665
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_123.png)'
- en: 'Because this is a nice (smooth) path over the interval ![](img/Formula_07_124.png),
    we can compute the signature precisely using the iterated integrals to (approximately)
    get the sequence:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个在区间 ![](img/Formula_07_124.png) 上平滑（光滑）的路径，我们可以使用迭代积分精确计算签名，以(近似)得到序列：
- en: '![](img/Formula_07_125.png)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_125.png)'
- en: 'This is remarkably close to the computed signature for the signal as given
    here:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果与这里给出的信号计算签名非常接近：
- en: '[PRE320]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: We expect a reasonable amount of error because our sampling is fairly coarse
    (only 100 points) and our parameter values might finish before ![](img/Formula_07_126.png)
    because of the way we randomized.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预期会有合理的误差，因为我们的采样相对粗糙（只有100个点），并且由于随机化的方式，我们的参数值可能在 ![](img/Formula_07_126.png)
    之前就结束了。
- en: 'Signal b is defined by the following formula:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 信号b由以下公式定义：
- en: '![](img/Formula_07_127.png)'
  id: totrans-672
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_127.png)'
- en: 'The component functions for this signal are also smooth, so we can compute
    the signature by computing the iterated integrals. Following this procedure, we
    see that the signature of the true signal is the following:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 该信号的组件函数也是平滑的，因此我们可以通过计算迭代积分来计算签名。按照这个过程，我们发现真实信号的签名如下：
- en: '![](img/Formula_07_128.png)'
  id: totrans-674
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_128.png)'
- en: 'Comparing this to the compute value, we see that we’re fairly close:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与计算值进行比较，我们可以看到我们非常接近：
- en: '[PRE321]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: Again, we expect some error because of coarse sampling and not covering the
    parameter interval exactly (in *Figure 7**.16*, you can see that there are some
    substantial “straight sections” indicating that the parameter values are spaced
    far apart in some places on the plots for signal b).
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于采样粗糙且没有精确覆盖参数区间，我们预计会有一些误差（在*图7.16*中，您可以看到某些地方的图表上有明显的“直线段”，这表示信号b的参数值在某些地方间隔较大）。
- en: In *step 6*, we generate a number of signatures for noisy samples taken from
    both signals, all with different and irregular time steps (the count of which
    is also randomly drawn between 50 and 100) and Gaussian noise. These are stacked
    into an array with `N = 50` rows and 7 columns (the size of the signature). We
    compute the row-wise mean of each array of signatures using the `np.mean` routine
    with `axis=0`. This produces an *expected signature* for each signal. We then
    compare these expected signatures to the “true signature” computed in *step 5*
    and one another. We can see that the difference between the two expected signatures
    is significantly larger (not in the statistical sense) than the difference between
    the expected and true signatures for each signal. This illustrates the discriminative
    power of the signature for classifying time series data.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们为从两个信号中提取的噪声样本生成多个签名，这些样本具有不同且不规则的时间步长（其数量也是在50到100之间随机抽取的），并加入高斯噪声。这些签名被堆叠成一个数组，具有`N
    = 50`行和7列（即签名的大小）。我们使用`np.mean`函数按`axis=0`计算每个签名数组的行均值。这样为每个信号生成了一个*期望签名*。接着，我们将这些期望签名与*步骤5*中计算的“真实签名”以及彼此之间进行比较。我们可以看到，这两个期望签名之间的差异显著大于每个信号的期望签名和真实签名之间的差异（这里的差异不是统计意义上的）。这说明签名在分类时间序列数据时具有辨别能力。
- en: There’s more…
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: The example problem we addressed in the recipe is extremely simple. Signatures
    have been used in a wide variety of contexts, including sepsis detection, handwriting
    recognition, natural language processing, human action recognition, and drone
    identification. Usually, signatures are used in tandem with a selection of “preprocessing
    steps” that address various deficiencies in the sampled data. For example, in
    the recipe, we deliberately chose signals that are bounded (and relatively small)
    on the interval in question. In practice, data will likely be spread more widely
    and in this case, the higher order terms in the signature can grow quite rapidly,
    which can have important consequences for numerical stability. These preprocessing
    steps include lead-lag transformations, pen-on-pen-off transformations, the missing
    data transformation, and time integration. Each of these has a specific role in
    making data more amenable to signature based methods.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本食谱中解决的示例问题非常简单。签名已被广泛应用于多个领域，包括败血症检测、手写识别、自然语言处理、人类动作识别和无人机识别。通常，签名与一系列“预处理步骤”结合使用，这些步骤解决了采样数据中的各种缺陷。例如，在本食谱中，我们故意选择了在相关区间内是有界的（并且相对较小的）信号。在实际应用中，数据很可能会更加分散，在这种情况下，签名中的高阶项会迅速增长，这可能对数值稳定性产生重要影响。这些预处理步骤包括领先滞后转换、笔上笔下转换、缺失数据转换和时间积分。每个步骤在使数据更适合基于签名的方法中都扮演了特定角色。
- en: Signatures contain a large amount of redundancy. Many of the higher order terms
    can be computed from the others because of the geometry. This means that we can
    reduce the number of terms we need without discarding any information about the
    path. This reduction involves projecting the signature (in the free tensor algebra)
    onto the log signature (in the free Lie algebra). The log signature is an alternative
    representation of the path that has fewer terms than the signature. Many of the
    properties remain true for log signatures, except that we lose linearity in the
    approximation of functions (this may or may not be important for specific applications).
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 签名包含大量冗余信息。许多高阶项可以通过几何关系从其他项中计算出来。这意味着我们可以在不丢失路径信息的情况下减少所需的项数。这种减少涉及将签名（在自由张量代数中）投影到对数签名（在自由李代数中）。对数签名是一种替代路径表示方式，比签名包含的项数更少。许多性质在对数签名中仍然成立，除了我们在函数逼近的线性性上有所损失（这对于特定应用可能重要，也可能不重要）。
- en: See also
  id: totrans-682
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The theory of rough paths and signature methods is obviously too broad – and
    rapidly expanding – to cover in such a short space. Here are some sources where
    you can find additional information about signatures:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 粗糙路径和签名方法的理论显然过于广泛——且迅速扩展——无法在如此短的篇幅中涵盖。以下是一些可以找到有关签名的更多信息的资源：
- en: Lyons, T. and McLeod, A., 2022\. *Signature Methods in Machine* *Learning* [https://arxiv.org/abs/2206.14674](https://arxiv.org/abs/2206.14674)
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lyons, T. 和 McLeod, A., 2022\. *机器学习中的签名方法* [https://arxiv.org/abs/2206.14674](https://arxiv.org/abs/2206.14674)
- en: Lyons, T., Caruana, M., and Lévy, T., 2004\. *Differential Equations Driven
    by Rough Paths*, Springer, Ecole d’Eté de Probabilités de Saint-Flour XXXIV
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lyons, T., Caruana, M., 和 Lévy, T., 2004\. *由粗糙路径驱动的微分方程*, Springer，圣弗卢尔概率暑期学校
    XXXIV
- en: 'Several Jupyter notebooks walking through analyzing time series data using
    signatures on the Datasig website: [https://datasig.ac.uk/examples](https://datasig.ac.uk/examples).'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Datasig网站上，有几个Jupyter笔记本展示了使用签名分析时间序列数据的过程：[https://datasig.ac.uk/examples](https://datasig.ac.uk/examples)。
- en: Further reading
  id: totrans-687
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'A good textbook on regression in statistics is the book *Probability and Statistics*
    by Mendenhall, Beaver, and Beaver, as mentioned in [*Chapter 6*](B19085_06.xhtml#_idTextAnchor226),
    *Working with Data and Statistics*. The following books provide a good introduction
    to classification and regression in modern data science:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 一本关于回归统计学的好教材是Mendenhall, Beaver和Beaver所著的《*概率与统计*》，如在[*第6章*](B19085_06.xhtml#_idTextAnchor226)《与数据和统计打交道》中所提到的。以下几本书为现代数据科学中的分类与回归提供了良好的入门：
- en: 'James, G. and Witten, D., 2013\. *An Introduction To Statistical Learning:
    With Applications In R*. New York: Springer.'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: James, G. 和 Witten, D., 2013\. *统计学习导论：R语言应用*. 纽约：Springer。
- en: 'Müller, A. and Guido, S., 2016\. *Introduction To Machine Learning With Python*.
    Sebastopol: O’Reilly Media.'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Müller, A. 和 Guido, S., 2016\. *Python机器学习导论*. Sebastopol: O’Reilly Media。'
- en: 'A good introduction to time series analysis can be found in the following book:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 一本很好的时间序列分析入门书籍可以在以下书籍中找到：
- en: 'Cryer, J. and Chan, K., 2008\. *Time Series Analysis*. New York: Springer.'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cryer, J. 和 Chan, K., 2008年。*时间序列分析*。纽约：Springer。
