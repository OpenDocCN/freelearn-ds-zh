- en: <st c="0">11</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">11</st>
- en: <st c="3">Landscape of Data Structures</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">数据结构的概貌</st>
- en: <st c="32">The relationship between algorithms and data is fundamental to designing
    efficient software programs.</st> <st c="135">The choice of data structures directly
    impacts the performance of algorithms, as basic data structures might require
    resource-intensive operations such as search, insertion, and deletion, potentially
    leading to inefficiencies in software execution.</st> <st c="384">In contrast,
    more advanced data structures can simplify these operations, reducing complexity
    and significantly enhancing overall algorithm performance.</st> <st c="537">Understanding
    this relationship is key to optimizing both the speed and resource usage of</st>
    <st c="627">software programs.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32">算法与数据之间的关系是设计高效软件程序的基础。</st> <st c="135">数据结构的选择直接影响算法的性能，因为基础的数据结构可能需要资源密集型的操作，如搜索、插入和删除，从而可能导致软件执行效率低下。</st>
    <st c="384">相比之下，更高级的数据结构可以简化这些操作，降低复杂性，并显著提升整体算法性能。</st> <st c="537">理解这种关系是优化软件程序速度和资源使用的关键。</st>
    <st c="627">软件程序。</st>
- en: <st c="645">In this chapter, we will explore various aspects of data structures,
    including their classifications as linear and non-linear types, as well as the
    distinctions between static and dynamic data allocations.</st> <st c="852">We
    also discuss the fundamental operations supported by data structures, such as
    searching, insertion, and deletion, and discuss how the efficiency of these operations
    varies with different data structures.</st> <st c="1059">By examining these characteristics,
    this chapter aims to provide a comprehensive understanding of how to select and
    implement data structures that best meet the needs of specific algorithms, ultimately
    leading to more efficient and effective</st> <st c="1301">software design.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="645">在本章中，我们将探索数据结构的各个方面，包括它们作为线性和非线性类型的分类，以及静态和动态数据分配之间的区别。</st> <st
    c="852">我们还将讨论数据结构所支持的基本操作，例如搜索、插入和删除，并探讨不同数据结构下这些操作的效率差异。</st> <st c="1059">通过研究这些特性，本章旨在提供一个全面的理解，帮助选择和实现最符合特定算法需求的数据结构，从而实现更高效、更有效的</st>
    <st c="1301">软件设计。</st>
- en: <st c="1317">We’ll cover the following main topics in</st> <st c="1359">this
    chapter:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1317">我们将在</st> <st c="1359">本章中涵盖以下主要内容：</st>
- en: <st c="1372">Taxonomy of</st> <st c="1385">data structures</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1372">数据结构的分类</st> <st c="1385">数据结构</st>
- en: <st c="1400">Abstract</st> <st c="1410">data types</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1400">抽象</st> <st c="1410">数据类型</st>
- en: <st c="1420">Dictionaries</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1420">字典</st>
- en: <st c="1433">Taxonomy of data structures</st>
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1433">数据结构的分类</st>
- en: <st c="1461">Understanding</st> <st c="1476">and designing algorithms without
    considering the data they operate on is an incomplete endeavor.</st> <st c="1573">In</st>
    [*<st c="1576">Chapter 1</st>*](B22248_01.xhtml#_idTextAnchor014)<st c="1585">,
    we explored the unique relationship between computing hardware and algorithms.</st>
    <st c="1666">Similarly, there is a significant connection between algorithms and
    data.</st> <st c="1740">An efficient algorithm relies heavily on the use of an
    appropriate and efficient data structure.</st> <st c="1837">For this reason, in
    this chapter and the next two, we will focus on data structures from the perspective
    of algorithm design.</st> <st c="1963">While data structures are a broad and complex
    field that warrants detailed study, our focus here and in the next two chapters
    will be on their critical role in</st> <st c="2123">algorithm efficiency.</st>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1461">理解</st> <st c="1476">并设计算法而不考虑它们操作的数据是一个不完整的过程。</st> <st c="1573">在</st>
    [*<st c="1576">第1章</st>*](B22248_01.xhtml#_idTextAnchor014)<st c="1585">中，我们探讨了计算硬件与算法之间的独特关系。</st>
    <st c="1666">同样，算法与数据之间也存在着重要的联系。</st> <st c="1740">一个高效的算法在很大程度上依赖于使用合适且高效的数据结构。</st>
    <st c="1837">因此，在本章及接下来的两章中，我们将从算法设计的角度，专注于数据结构。</st> <st c="1963">虽然数据结构是一个广泛且复杂的领域，值得详细研究，但我们在这里以及接下来的两章中的重点将是它们在</st>
    <st c="2123">算法效率中的关键作用。</st>
- en: <st c="2144">First, it is crucial</st> <st c="2166">to grasp the key aspects
    used to evaluate and assess the efficiency and characteristics of data structures.</st>
    <st c="2274">Understanding these aspects is important, as the choice of an appropriate
    data structure directly impacts the performance and effectiveness of an algorithm.</st>
    <st c="2431">When designing an algorithm, selecting the right data structure is
    not merely a matter of preference but also a necessity dictated by the algorithm’s</st>
    <st c="2581">specific requirements.</st>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2144">首先，理解评估和衡量数据结构效率与特征的关键要素至关重要。</st> <st c="2166">了解这些要素很重要，因为选择合适的数据结构直接影响算法的性能和有效性。</st>
    <st c="2274">当设计一个算法时，选择合适的数据结构不仅仅是个人喜好问题，而是算法</st> <st c="2431">特定需求所决定的必要条件。</st>
- en: <st c="2603">Let’s begin by defining what a data structure is within the context
    of algorithms.</st> <st c="2687">A data structure is a systematic way of organizing,
    managing, and storing data in a computer so that it can be accessed and modified
    efficiently.</st> <st c="2833">The organization of data is not arbitrary; it is
    intentionally designed to support specific types of operations that are critical
    for the performance of algorithms and</st> <st c="3001">computer programs.</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2603">让我们首先定义一下，在算法的背景下什么是数据结构。</st> <st c="2687">数据结构是一种系统化的方式，用于组织、管理和存储计算机中的数据，以便高效地访问和修改。</st>
    <st c="2833">数据的组织并非随意的；它是专门设计来支持特定类型的操作，这些操作对算法和</st> <st c="3001">计算机程序的性能至关重要。</st>
- en: <st c="3019">In the domain of algorithms, a data structure serves as the foundation
    upon which algorithms operate.</st> <st c="3122">It determines how data is stored,
    how it is retrieved, and how it can be manipulated during the execution of a program.</st>
    <st c="3242">The efficiency of an algorithm often hinges on the effectiveness
    of the underlying data structure.</st> <st c="3341">Whether the task involves
    searching, sorting, inserting, or deleting data, the choice of data structure
    can dramatically impact the speed and resource usage of</st> <st c="3501">the
    algorithm.</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3019">在算法领域，数据结构是算法运行的基础。</st> <st c="3122">它决定了数据如何存储、如何检索，以及如何在程序执行过程中进行操作。</st>
    <st c="3242">算法的效率通常取决于底层数据结构的有效性。</st> <st c="3341">无论任务涉及搜索、排序、插入还是删除数据，数据结构的选择都可能极大地影响算法的速度和资源消耗。</st>
- en: <st c="3515">In essence, a data structure is more than just a method of data
    organization; it is a vital component that influences the efficiency, scalability,
    and overall performance of algorithms in</st> <st c="3704">computer science.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3515">本质上，数据结构不仅仅是数据组织的一种方法；它是影响算法效率、可扩展性和整体性能的关键组成部分，尤其是在</st> <st c="3704">计算机科学中。</st>
- en: <st c="3721">The key question now is, which data structure is best suited for
    specific computational tasks and algorithms?</st> <st c="3832">This section is
    dedicated to addressing that question.</st> <st c="3887">In this section, we will
    introduce the criteria that define the efficiency of data structures.</st> <st
    c="3982">These criteria will guide our exploration of various data structures
    and their suitability for different types of algorithms.</st> <st c="4108">Following
    this, the discussion will shift to a comprehensive examination of how data structures
    can be categorized.</st> <st c="4224">This categorization, or taxonomy, of data
    structures will help us understand the different types and their appropriate use
    cases, providing a structured approach to selecting the most suitable data structure
    for a given</st> <st c="4444">algorithmic challenge.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3721">现在的关键问题是，哪种数据结构最适合特定的计算任务和算法？</st> <st c="3832">本节将致力于解答这个问题。</st>
    <st c="3887">在本节中，我们将介绍定义数据结构效率的标准。</st> <st c="3982">这些标准将指导我们探索各种数据结构及其对不同类型算法的适用性。</st>
    <st c="4108">接下来，讨论将转向全面考察数据结构如何分类。</st> <st c="4224">这种数据结构的分类法将帮助我们理解不同类型的数据结构及其适用场景，为选择最合适的数据结构提供结构化的思路。</st>
    <st c="4444">从而应对特定的算法挑战。</st>
- en: <st c="4466">Physical versus logical data structures</st>
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="4466">物理数据结构与逻辑数据结构</st>
- en: <st c="4506">In data</st> <st c="4515">structures, it’s important to distinguish
    between physical and logical data structures.</st> <st c="4603">A</st> **<st c="4605">physical
    data structure</st>** <st c="4628">refers</st> <st c="4635">to the actual organization
    and arrangement of data in the memory of a computer.</st> <st c="4716">In this
    context, the data items are physically related to each other, based on their location
    in memory.</st> <st c="4821">When an algorithm is executed, the data it processes
    is stored in a computer’s memory in a manner that reflects its</st> <st c="4937">physical
    structure.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4506">在数据</st> <st c="4515">结构中，区分物理数据结构和逻辑数据结构非常重要。</st> <st c="4603">**<st
    c="4605">物理数据结构</st>** <st c="4628">指的是数据在计算机内存中的实际组织和排列。</st> <st c="4635">在这种情况下，数据项在内存中的物理位置决定了它们之间的物理关系。</st>
    <st c="4716">当算法执行时，它处理的数据以反映其</st> <st c="4821">物理结构的方式存储在计算机内存中。</st>
- en: <st c="4956">Physical data structures are directly concerned with how data is
    laid out in memory, including aspects such as memory allocation, pointers, and
    how data is retrieved or modified at the hardware lev</st><st c="5154">el.</st>
    <st c="5159">The way data is physically organized can significantly affect the
    performance of an algorithm, particularly in terms of speed and</st> <st c="5289">memory
    efficiency.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4956">物理数据结构直接关系到数据在内存中的布局方式，包括内存分配、指针以及硬件级别上数据的检索或修改方式。</st> <st c="5159">数据的物理组织方式可以显著影响算法的性能，特别是在速度和</st>
    <st c="5289">内存效率方面。</st>
- en: <st c="5307">Conversely, a</st> **<st c="5322">logical data structure</st>**
    <st c="5344">refers</st> <st c="5351">to the abstract organization of data as
    perceived by the algorithm or the programmer.</st> <st c="5438">This is a conceptual
    model that defines how data is related to each other, regardless of how it is
    physically stored.</st> <st c="5556">Examples of logical data structures include
    arrays, linked lists, trees, and graphs.</st> <st c="5641">These structures are
    defined by the operations that can be performed on them and the relationships
    between data items, rather than their physical location</st> <st c="5796">in memory.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5307">相反，**<st c="5322">逻辑数据结构</st>** <st c="5344">指的是算法或程序员所感知的数据的抽象组织。</st>
    <st c="5351">这是一个概念模型，定义了数据如何相关，而不考虑其物理存储方式。</st> <st c="5556">逻辑数据结构的例子包括数组、链表、树和图。</st>
    <st c="5641">这些结构由可以在其上执行的操作和数据项之间的关系来定义，而不是它们在内存中的物理位置。</st>
- en: <st c="5806">When an algorithm is executed, it operates on these logical data
    structu</st><st c="5879">res.</st> <st c="5885">However, in order for the algorithm
    to function, there must be a mapping between the logical structure and the physical
    memory where the data resides.</st> <st c="6036">This mapping is managed by a
    combination of system programs and the memory management subsystem, which are
    integral components of the operating system.</st> <st c="6188">These systems ensure
    that the logical data structures used by the algorithm are efficiently translated
    into the appropriate physical data structures</st> <st c="6337">in memory.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5806">当算法执行时，它操作这些逻辑数据结构。</st> <st c="5885">然而，为了使算法能够正常运行，必须在逻辑结构和存储数据的物理内存之间建立映射。</st>
    <st c="6036">这种映射由系统程序和内存管理子系统的组合管理，这些是操作系统的重要组成部分。</st> <st c="6188">这些系统确保算法使用的逻辑数据结构能够有效地转换为适当的物理数据结构</st>
    <st c="6337">在内存中。</st>
- en: <st c="6347">As we move to higher levels of abstraction in computer algorithms
    and models, the dependence on the physical representation of data diminishes.</st>
    <st c="6492">At these advanced levels, the focus shifts from how data is physically
    stored in memory to how it is logically structured and manipulated to achieve
    the</st> <st c="6645">desired outcomes.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6347">随着计算机算法和模型抽象层次的提高，对数据物理表示的依赖逐渐减少。</st> <st c="6492">在这些高级层次上，关注点从数据如何在内存中物理存储转移到如何在逻辑上结构化和操作数据以达到</st>
    <st c="6645">期望的结果。</st>
- en: <st c="6662">In essence, higher-level algorithms are designed to operate on
    data without needing to concern themselves with the underlying physical data representation.</st>
    <st c="6819">This abstraction allows for greater flexibility and generality in
    algorithm design, as the same logical structure can be implemented on various
    physical systems without altering the</st> <st c="7001">algorithm itself.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6662">本质上，高级算法的设计是为了处理数据，而无需关心底层的物理数据表示。</st> <st c="6819">这种抽象使得算法设计具有更大的灵活性和通用性，因为相同的逻辑结构可以在不同的物理系统上实现，而无需改变</st>
    <st c="7001">算法本身。</st>
- en: <st c="7018">In this book, we concentrate on studying data structures at the
    logical level.</st> <st c="7098">This approach allows us to focus on the abstract
    organization of data and the operations that can be performed on it, independent
    of the specifics of physical storage.</st> <st c="7266">By understanding</st>
    <st c="7282">data structures in this way, we can develop more versatile and robust
    algorithms that are applicable across different computing environments, regardless
    of the underlying hardware or</st> <st c="7466">memory architecture.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7018">在本书中，我们专注于在逻辑层面研究数据结构。</st> <st c="7098">这种方法使我们能够集中于数据的抽象组织和可以对其执行的操作，而不依赖于物理存储的具体细节。</st>
    <st c="7266">通过这种方式理解数据结构，我们可以开发出更具通用性和鲁棒性的算法，这些算法适用于不同的计算环境，无论底层硬件或</st> <st
    c="7466">内存架构如何。</st>
- en: <st c="7486">In summary, physical data structures are concerned with the actual
    storage of data in memory, while logical data structures provide an abstract way
    to organize and manipulate data.</st> <st c="7668">The efficiency of an algorithm
    can depend heavily on how well these two aspects are managed</st> <st c="7760">and
    aligned.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7486">总之，物理数据结构关注的是数据在内存中的实际存储，而逻辑数据结构则提供了一种抽象的方式来组织和操作数据。</st> <st c="7668">算法的效率往往取决于这两个方面的管理</st>
    <st c="7760">和协调。</st>
- en: <st c="7772">Primitive versus composite data structures</st>
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="7772">原始数据结构与复合数据结构</st>
- en: <st c="7815">When</st> <st c="7820">discussing data structures, it is essential
    to differentiate between primitive and composite data structures.</st> *<st c="7931">Primitive
    data structures</st>* <st c="7956">are</st> <st c="7960">the most basic forms
    of data representation.</st> <st c="8006">They include fundamental types, such
    as integers, floats, characters, and pointers.</st> <st c="8090">These structures
    are typically directly supported by computer hardware or the programming language,
    and they form the building blocks for more complex data structures.</st> <st c="8258">Primitive
    data structures are straightforward in terms of both their implementation and
    their operations, such as assigning values, performing arithmetic, and basic</st>
    <st c="8423">input/output operations.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7815">在</st> <st c="7820">讨论数据结构时，区分原始数据结构和复合数据结构至关重要。</st> *<st c="7931">原始数据结构</st>*
    <st c="7956">是</st> <st c="7960">最基本的数据表示形式。</st> <st c="8006">它们包括基本类型，如整数、浮点数、字符和指针。</st>
    <st c="8090">这些结构通常由计算机硬件或编程语言直接支持，并且它们是构建更复杂数据结构的基石。</st> <st c="8258">原始数据结构在实现和操作上都很简单，例如赋值、执行算术运算和基本的</st>
    <st c="8423">输入/输出操作。</st>
- en: <st c="8447">Conversely,</st> *<st c="8460">composite data structures</st>*
    <st c="8485">are</st> <st c="8490">more complex and are composed of multiple primitive
    data elements.</st> <st c="8557">They are designed to handle more sophisticated
    data organization and operations.</st> <st c="8638">Examples of composite data
    structures include arrays, linked lists, trees, and graphs.</st> <st c="8725">These
    structures allow you to group multiple primitive data types into a single, more
    powerful entity, enabling more complex operations such as searching, sorting,
    and</st> <st c="8893">hierarchical organization.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8447">相反，</st> *<st c="8460">复合数据结构</st>* <st c="8485">更为复杂，且由多个原始数据元素组成。</st>
    <st c="8557">它们被设计用来处理更复杂的数据组织和操作。</st> <st c="8638">复合数据结构的例子包括数组、链表、树和图。</st>
    <st c="8725">这些结构允许将多个原始数据类型组合成一个更强大的实体，从而实现更复杂的操作，如搜索、排序和</st> <st c="8893">层次化组织。</st>
- en: <st c="8919">Composite data structures are essential for implementing algorithms
    that require the handling of more complex data relationships.</st> <st c="9050">For
    instance, a tree structure can represent hierarchical relationships between data
    items, while a graph structure can represent more complex networks of relationships.</st>
    <st c="9220">Unlike primitive data structures, composite data structures require
    careful design and management to ensure efficient data processing.</st> <st c="9355">In
    this book (</st>[*<st c="9369">Chapter 12</st>*](B22248_12.xhtml#_idTextAnchor187)
    <st c="9380">and</st> [*<st c="9385">Chapter 13</st>*](B22248_13.xhtml#_idTextAnchor200)<st
    c="9395">), our focus is on understanding and utilizing composite data structures
    from a</st> <st c="9476">logical perspective.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8919">复合数据结构对于实现需要处理更复杂数据关系的算法至关重要。</st> <st c="9050">例如，树结构可以表示数据项之间的层次关系，而图结构可以表示更复杂的关系网络。</st>
    <st c="9220">与原始数据结构不同，复合数据结构需要精心设计和管理，以确保数据处理的高效性。</st> <st c="9355">在本书中（</st>[*<st
    c="9369">第12章</st>*](B22248_12.xhtml#_idTextAnchor187) <st c="9380">和</st> [*<st
    c="9385">第13章</st>*](B22248_13.xhtml#_idTextAnchor200)<st c="9395">），我们的重点是从</st>
    <st c="9476">逻辑角度理解和利用复合数据结构。</st>
- en: <st c="9496">Linear versus non-linear data structures</st>
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="9496">线性数据结构与非线性数据结构</st>
- en: <st c="9537">One important</st> <st c="9552">way to classify logical data structures
    is by their linearity.</st> <st c="9615">Logical data structures can be categorized
    as either linear or non-linear, with each type serving distinct purposes and enabling
    different types</st> <st c="9760">of operations.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9537">一种重要的</st> <st c="9552">逻辑数据结构分类方法是根据它们的线性性质进行区分。</st> <st c="9615">逻辑数据结构可以分为线性或非线性两种类型，每种类型都有不同的用途，并支持不同类型的</st>
    <st c="9760">操作。</st>
- en: '*<st c="9774">Linear data structures</st>* <st c="9797">are those in which
    data elements are arranged in a sequential order, where</st> <st c="9872">each
    element is connected to its previous and next elements, forming a straight line.</st>
    <st c="9959">Examples of linear data structures include arrays, linked lists,
    stacks, and queues.</st> <st c="10044">In a linear data structure, operations
    such as traversal, insertion, and deletion typically follow a straightforward,
    sequential pattern.</st> <st c="10182">This ordered nature makes linear data structures
    ideal for tasks where data needs to be processed in a specific order, such as
    in managing queues or performing</st> <st c="10342">simple searches.</st>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="9774">线性数据结构</st>* <st c="9797">是指数据元素按照顺序排列的结构，其中</st> <st c="9872">每个元素与其前后元素相连接，形成一条直线。</st>
    <st c="9959">线性数据结构的例子包括数组、链表、栈和队列。</st> <st c="10044">在一个线性数据结构中，诸如遍历、插入和删除等操作通常遵循简单的顺序模式。</st>
    <st c="10182">这种有序的特性使得线性数据结构非常适用于需要按特定顺序处理数据的任务，例如管理队列或执行</st> <st c="10342">简单搜索。</st>'
- en: <st c="10358">In terms of memory, linear data structure has the</st> <st c="10408">following
    advantages:</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10358">在内存方面，线性数据结构具有以下</st> <st c="10408">优势：</st>
- en: '**<st c="10430">Contiguous memory allocation</st>**<st c="10459">: Linear data
    structures, such as arrays, use contiguous blocks of memory, making memory access
    faster and more predictable due to the locality of reference.</st> <st c="10618">This
    results in efficient utilization of cache memory and reduces the overhead of</st>
    <st c="10700">accessing elements.</st>'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="10430">连续内存分配</st>**<st c="10459">：线性数据结构，如数组，使用连续的内存块，使得由于引用局部性，内存访问更快、更可预测。</st>
    <st c="10618">这使得缓存内存的利用更加高效，减少了访问</st> <st c="10700">元素的开销。</st>'
- en: '**<st c="10719">Memory management simplicity</st>**<st c="10748">: Because
    linear data structures often involve fixed sizes (e.g., arrays) or sequential
    pointers (e.g., linked lists), managing memory is straightforward.</st> <st c="10904">Memory
    allocation and deallocation are easier to implement compared to more</st> <st
    c="10980">complex structures.</st>'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="10719">内存管理简便</st>**<st c="10748">：因为线性数据结构通常涉及固定大小（如数组）或顺序指针（如链表），所以内存管理较为简单。</st>
    <st c="10904">与更复杂的结构相比，内存分配和释放更容易实现。</st>'
- en: '**<st c="10999">Low memory overhead</st>**<st c="11019">: For structures such
    as arrays, there is minimal memory overhead because no additional pointers or
    links are required to connect the elements, leading to lower memory usage compared
    to non-linear structures such as trees</st> <st c="11242">or graphs.</st>'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="10999">低内存开销</st>**<st c="11019">：对于如数组这样的结构，由于不需要额外的指针或链接来连接元素，因此内存开销很小，与非线性结构如树</st>
    <st c="11242">或图相比，内存使用较低。</st>'
- en: <st c="11252">Conversely, linear data structures come</st> <st c="11292">with
    limitations in terms</st> <st c="11319">of memory:</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11252">相反，线性数据结构存在</st> <st c="11292">在内存方面的</st> <st c="11319">局限性：</st>
- en: '**<st c="11329">Wasted memory (a fixed-size limitation)</st>**<st c="11369">:
    In structures such as arrays, memory is allocated for a fixed number of elements
    at the time of creation.</st> <st c="11478">If the number of elements is fewer
    than the allocated size, there will be unused memory space, leading to</st> <st
    c="11584">inefficient utilization.</st>'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="11329">内存浪费（固定大小限制）</st>**<st c="11369">：在如数组等结构中，内存在创建时为固定数量的元素分配。</st>
    <st c="11478">如果元素数量少于分配的大小，就会有未使用的内存空间，从而导致</st> <st c="11584">效率低下。</st>'
- en: '**<st c="11608">Memory reallocation</st>**<st c="11628">: Expanding a linear
    data structure such as an array requires reallocation of memory and copying of
    elements to a new, larger memory block, which is costly in terms of time and space.</st>
    <st c="11813">This reallocation can lead to memory fragmentation</st> <st c="11864">and
    inefficiency.</st>'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="11608">内存重新分配</st>**<st c="11628">：扩展如数组这样的线性数据结构需要重新分配内存并将元素复制到新的、更大的内存块中，这在时间和空间上都代价高昂。</st>
    <st c="11813">这种重新分配可能导致内存碎片化</st> <st c="11864">和低效。</st>'
- en: '**<st c="11881">Pointer overhead in linked lists</st>**<st c="11914">: In linked
    lists, each element stores an additional pointer to the next element, which increases
    the overall memory usage, especially when dealing with a large number of elements.</st>
    <st c="12096">This overhead can negate some of the memory advantages gained by</st>
    <st c="12161">dynamic sizing.</st>'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="11881">链表中的指针开销</st>**<st c="11914">：在链表中，每个元素存储一个额外的指针指向下一个元素，这增加了总体的内存使用，特别是在处理大量元素时。</st>
    <st c="12096">这种开销可能抵消通过</st> <st c="12161">动态大小调整获得的一些内存优势。</st>'
- en: '**<st c="12176">Sequential memory allocation for contiguous structures</st>**<st
    c="12231">: Linear structures such as arrays require contiguous blocks of memory.</st>
    <st c="12304">If sufficient contiguous space is not available, memory allocation
    may fail or become inefficient, leading to potential</st> <st c="12424">performance
    bottlenecks.</st>'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12176">顺序内存分配用于连续结构</st>**<st c="12231">：线性结构如数组需要连续的内存块。</st> <st
    c="12304">如果没有足够的连续空间可用，内存分配可能会失败或变得低效，从而导致潜在的</st> <st c="12424">性能瓶颈。</st>'
- en: <st c="12448">The</st> <st c="12453">simplicity of linear data structures often
    leads to ease of implementation and predictability in performance.</st> <st c="12563">However,
    they may not always be the most efficient choice to represent more complex relationships
    between data elements, as their sequential nature can limit flexibility in</st>
    <st c="12736">certain scenarios.</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12448">线性数据结构的</st> <st c="12453">简洁性通常导致实现上的简便性和性能的可预测性。</st> <st c="12563">然而，它们可能并不总是最有效的选择来表示数据元素之间更复杂的关系，因为它们的顺序性质在</st>
    <st c="12736">某些场景中可能限制灵活性。</st>
- en: '*<st c="12754">Non-linear data structures</st>*<st c="12781">, conversely,
    do</st> <st c="12797">not organize data in a linear sequence.</st> <st c="12838">Instead,
    the data elements are connected in a more complex way, forming structures such
    as trees, graphs, and heaps.</st> <st c="12955">In non-linear data structures,
    each element may be connected to multiple elements, allowing for the representation
    of hierarchical or networked relationships between</st> <st c="13121">data points.</st>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="12754">非线性数据结构</st>*<st c="12781">相反，</st> <st c="12797">它们并不以线性顺序组织数据。</st>
    <st c="12838">相反，数据元素以更复杂的方式连接，形成如树、图和堆等结构。</st> <st c="12955">在非线性数据结构中，每个元素可能与多个元素连接，从而能够表示数据点之间的层次或网络关系。</st>
    <st c="13121">。</st>'
- en: <st c="13133">Non-linear data structures are particularly powerful for representing
    data that has an inherent hierarchical organization, such as a family tree or
    a file directory, or for modeling networks, such as social connections or transportation
    routes.</st> <st c="13379">They offer greater flexibility and efficiency for tasks
    that require managing and querying complex relationships between data items.</st>
    <st c="13512">However, their complexity also requires more sophisticated</st>
    <st c="13570">algorithms for traversal, searching,</st> <st c="13608">and manipulation.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13133">非线性数据结构特别适合表示具有固有分层结构的数据，例如家谱或文件目录，或者建模网络，例如社交连接或交通路线。</st> <st
    c="13379">它们为需要管理和查询数据项之间复杂关系的任务提供了更大的灵活性和效率。</st> <st c="13512">然而，它们的复杂性也需要更复杂的</st>
    <st c="13570">遍历、搜索</st> <st c="13608">和操作算法。</st>
- en: <st c="13625">In this book, we will examine both linear (</st>[*<st c="13669">Chapter
    12</st>*](B22248_12.xhtml#_idTextAnchor187)<st c="13680">) and non-linear data
    structures (</st>[*<st c="13715">Chapter 13</st>*](B22248_13.xhtml#_idTextAnchor200)<st
    c="13726">) from a logical standpoint, focusing on how they can be utilized to
    support different types</st> <st c="13820">of algorithms.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13625">在本书中，我们将从逻辑角度讨论线性（</st>[*<st c="13669">第12章</st>*](B22248_12.xhtml#_idTextAnchor187)<st
    c="13680">）和非线性数据结构（</st>[*<st c="13715">第13章</st>*](B22248_13.xhtml#_idTextAnchor200)<st
    c="13726">）的使用，重点是它们如何支持不同类型</st> <st c="13820">的算法。</st>
- en: <st c="13834">Static versus dynamic memory allocation</st>
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="13834">静态与动态内存分配</st>
- en: <st c="13874">Another</st> <st c="13883">important classification is based on
    how memory is allocated to store data.</st> <st c="13959">This classification
    divides data structures into those with static data allocation and those with
    dynamic</st> <st c="14065">data allocation.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13874">另一种</st> <st c="13883">重要的分类基于内存分配数据的方式。</st> <st c="13959">这种分类将数据结构分为静态数据分配和动态数据分配。</st>
- en: '*<st c="14081">Static data structures</st>* <st c="14104">are</st> <st c="14109">those
    where the size of the data structure is fixed at the time of its creation.</st>
    <st c="14190">This means that the amount of memory allocated for the data structure
    remains constant throughout its lifetime.</st> <st c="14302">An example of a static
    data structure is an array.</st> <st c="14353">When we declare an array, we specify
    the number of elements it can hold, and this size cannot be changed during runtime.</st>
    <st c="14474">Static data structures are generally simpler to implement and access
    because their memory layout is predetermined, which can lead to efficient memory
    usage when the data size is known</st> <st c="14658">in advance.</st>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="14081">静态数据结构</st>* <st c="14104">是</st> <st c="14109">在创建时大小固定的数据结构。</st>
    <st c="14190">这意味着为数据结构分配的内存量在其生命周期内保持不变。</st> <st c="14302">静态数据结构的一个例子是数组。</st>
    <st c="14353">当我们声明一个数组时，我们指定它可以容纳的元素数量，这个大小在运行时不能更改。</st> <st c="14474">静态数据结构通常更容易实现和访问，因为它们的内存布局是预先确定的，当数据大小已知时可以实现有效的内存使用</st>
    <st c="14658">。</st>'
- en: <st c="14669">However, the main drawback of static data structures is their
    inflexibility.</st> <st c="14747">If the actual data size exceeds the predefined
    capacity, there is no way to expand the structure without reallocating memory
    and potentially moving data, which can be inefficient</st> <st c="14926">and cumbersome.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14669">然而，静态数据结构的主要缺点是其缺乏灵活性。</st> <st c="14747">如果实际数据大小超过预定义容量，没有办法在不重新分配内存且潜在移动数据的情况下扩展结构，这可能是低效</st>
    <st c="14926">和繁琐的。</st>
- en: '*<st c="14941">Dynamic data structures</st>*<st c="14965">, conversely, allow
    memory allocation to be adjusted at runtime.</st> <st c="15030">This</st> <st
    c="15034">means that the size of the data structure can grow or shrink as needed,
    depending on the operations being performed.</st> <st c="15152">Examples of dynamic
    data structures include linked lists, trees, and graphs.</st> <st c="15229">In
    a dynamic data structure, memory is allocated as elements are added and deallocated
    as they are removed, providing greater flexibility and efficient use of memory
    when dealing with data of unpredictable size or varying</st> <st c="15451">over
    time.</st>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="14941">动态数据结构</st>*<st c="14965">则允许在运行时调整内存分配。</st> <st c="15030">这意味着数据结构的大小可以根据需要增长或缩小，具体取决于正在执行的操作。</st>
    <st c="15152">动态数据结构的例子包括链表、树和图。</st> <st c="15229">在动态数据结构中，随着元素的增加，内存会被分配，随着元素的删除，内存会被回收，从而在处理大小不确定或随时间变化的数据时，提供了更大的灵活性和内存使用的高效性。</st>'
- en: <st c="15461">Dynamic data structures are especially useful in scenarios where
    the amount of data cannot be determined beforehand, or when the data structure
    needs to accommodate varying amounts of data efficiently.</st> <st c="15664">However,
    this flexibility comes at the cost of additional overhead in managing memory allocation
    and pointers, which can lead to more complex implementations and potentially slower
    access times compared to static data structures.</st> <st c="15894">In</st> *<st
    c="15897">Chapters 12</st>* <st c="15908">and</st> *<st c="15913">13</st>*<st
    c="15915">, we will explore both static and dynamic data structures, focusing
    on their characteristics, advantages,</st> <st c="16021">and trade-offs.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15461">动态数据结构在无法事先确定数据量或需要高效处理变动数据量的场景中尤其有用。</st> <st c="15664">然而，这种灵活性也意味着在内存分配和指针管理上需要额外的开销，这可能导致实现更加复杂，并且与静态数据结构相比，访问速度可能较慢。</st>
    <st c="15894">在</st> *<st c="15897">第12章</st>* <st c="15908">和</st> *<st c="15913">第13章</st>*<st
    c="15915">中，我们将探讨静态与动态数据结构，重点分析它们的特点、优势</st> <st c="16021">及其权衡。</st>
- en: <st c="16036">Sequential versus random access</st>
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="16036">顺序访问与随机访问</st>
- en: <st c="16068">The</st> <st c="16072">final classification of data structures
    is based on how data elements are accessed and retrieved.</st> <st c="16171">This
    classification divides data structures into those with sequential access and those
    with</st> <st c="16264">random access.</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16068">数据结构的最终分类基于数据元素的访问和检索方式。</st> <st c="16072">这种分类将数据结构分为顺序访问和</st>
    <st c="16264">随机访问两类。</st>
- en: '*<st c="16278">Sequential access data structures</st>* <st c="16312">are</st>
    <st c="16317">those where data elements are accessed in a specific, linear order.</st>
    <st c="16385">To retrieve a particular element, you must first traverse through
    the preceding elements.</st> <st c="16475">Examples of sequential access data
    structures include linked lists and queues.</st> <st c="16554">In these structures,
    accessing a specific element often requires iterating through a sequence of nodes
    or elements, which can make retrieval times longer, especially if the desired
    element is deep within</st> <st c="16758">a structure.</st>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="16278">顺序访问数据结构</st>* <st c="16312">是指那些数据元素按特定线性顺序访问的数据结构。</st> <st
    c="16317">要检索特定元素，必须首先遍历前面的元素。</st> <st c="16385">顺序访问数据结构的例子包括链表和队列。</st> <st
    c="16475">在这些结构中，访问特定元素通常需要迭代一系列节点或元素，这可能导致检索时间变长，特别是当所需元素位于结构较深的位置时</st> <st
    c="16758">。</st>'
- en: <st c="16770">Sequential access is often used in scenarios where the order of
    data elements is important or where data is processed in a linear fashion, such
    as in streaming applications or when data needs to be processed one element at
    a time.</st> <st c="17002">However, the primary limitation is that direct access
    to a specific element is not possible without traversing the sequence, which can
    be inefficient for</st> <st c="17156">large datasets.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16770">顺序访问通常用于数据元素顺序重要或数据需要按线性方式处理的场景，例如在流应用程序中，或当数据需要逐个元素处理时。</st>
    <st c="17002">然而，主要的限制是无法直接访问特定元素，必须遍历整个序列，这对于</st> <st c="17156">大数据集来说可能效率低下。</st>
- en: '*<st c="17171">Random access data structures</st>*<st c="17201">, conversely,
    allow</st> <st c="17220">direct access to any data element without needing to
    traverse through others.</st> <st c="17299">This means that you can instantly
    retrieve or modify any element if you know its index or key.</st> <st c="17394">Examples
    of random-access data structures include arrays and hash tables.</st> <st c="17468">In
    an array, for instance, you can access any element directly by its index, making
    operations such as retrieval and updating</st> <st c="17594">very fast.</st>'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="17171">随机访问数据结构</st>*<st c="17201">则允许</st> <st c="17220">直接访问任何数据元素，而无需遍历其他元素。</st>
    <st c="17299">这意味着如果你知道元素的索引或键值，就可以立即检索或修改任何元素。</st> <st c="17394">随机访问数据结构的例子包括数组和哈希表。</st>
    <st c="17468">例如，在数组中，你可以通过索引直接访问任何元素，从而使得检索和更新等操作</st> <st c="17594">非常快速。</st>'
- en: <st c="17604">Random access is highly beneficial when you need quick access
    to individual elements, especially in applications where speed is critical, such
    as in databases or real-time systems.</st> <st c="17786">However, this convenience
    comes with trade-offs, such as the need for continuous memory allocation in the
    case of arrays, which can lead to inefficient memory usage if the data structure
    is</st> <st c="17976">sparsely populated.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17604">当需要快速访问单个元素时，随机访问特别有益，尤其是在速度至关重要的应用中，如数据库或实时系统。</st> <st c="17786">然而，这种便利性伴随着一些权衡，比如数组需要连续的内存分配，如果数据结构较为稀疏，可能导致内存使用效率低下。</st>
- en: <st c="17995">In</st> [*<st c="17999">Chapter 12</st>*](B22248_12.xhtml#_idTextAnchor187)<st
    c="18009">, we will examine both sequential and random-access data structures,
    focusing on their use cases, advantages, and limitations.</st> <st c="18136">Understanding
    the access patterns of different data structures is crucial for designing algorithms
    that are both efficient and appropriate for the specific type of data they handle.</st>
    <st c="18318">The choice between sequential and random access can significantly
    impact the performance of an algorithm, particularly in terms of speed and</st>
    <st c="18459">resource utilization.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17995">在</st> [*<st c="17999">第12章</st>*](B22248_12.xhtml#_idTextAnchor187)<st
    c="18009">中，我们将探讨顺序访问和随机访问数据结构，重点关注它们的使用场景、优势和局限性。</st> <st c="18136">理解不同数据结构的访问模式对设计既高效又适合其处理数据类型的算法至关重要。</st>
    <st c="18318">在选择顺序访问和随机访问时，这一决定可能会显著影响算法的性能，特别是在速度和</st> <st c="18459">资源利用率方面。</st>
- en: <st c="18480">Abstract data types</st>
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="18480">抽象数据类型</st>
- en: <st c="18500">An</st> **<st c="18504">Abstract Data Type</st>** <st c="18522">(</st>**<st
    c="18524">ADT</st>**<st c="18527">) is</st> <st c="18533">a mathematical model
    for data types where the data type is defined by its behavior (operations), rather
    than its implementation.</st> <st c="18662">An ADT encapsulates data and the operations
    that can be performed on that data, abstracting away the implementation details.</st>
    <st c="18787">In other words, an ADT specifies what operations are possible and
    what their behavior is, but not how these operations</st> <st c="18906">are implemented.</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18500">一个</st> **<st c="18504">抽象数据类型</st>** <st c="18522">(</st>**<st
    c="18524">ADT</st>**<st c="18527">)是</st> <st c="18533">一种数据类型的数学模型，数据类型由其行为（操作）定义，而非其实现方式。</st>
    <st c="18662">ADT封装了数据和可以对该数据执行的操作，抽象化了实现细节。</st> <st c="18787">换句话说，ADT指定了哪些操作是可能的，以及这些操作的行为，但并不说明这些操作是如何</st>
    <st c="18906">实现的。</st>
- en: <st c="18922">ADTs are fundamental in computer science because they allow developers
    to work with data in a more flexible and modular way.</st> <st c="19048">By defining
    operations without specifying implementation details, ADTs enable code to be more
    maintainable and adaptable to</st> <st c="19172">different contexts.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18922">抽象数据类型（ADT）是计算机科学中的基础概念，因为它们允许开发人员以更灵活和模块化的方式操作数据。</st> <st c="19048">通过定义操作而不具体说明实现细节，ADT使得代码更易于维护，并能适应</st>
    <st c="19172">不同的应用场景。</st>
- en: <st c="19191">ADTs can be broadly categorized into several types, based on the
    operations they support and the use cases they address.</st> <st c="19313">Here
    are some</st> <st c="19327">common types:</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19191">ADT可以根据它们支持的操作和所解决的使用场景分为几种类型。</st> <st c="19313">以下是一些</st> <st
    c="19327">常见的类型：</st>
- en: '**<st c="19340">List</st>**<st c="19345">: A</st> <st c="19350">list is an
    ADT that represents an ordered collection of elements, where each element has
    a specific position within the sequence.</st> <st c="19480">The primary operations
    for lists include insertion, deletion, access, and traversal of elements.</st>
    <st c="19577">Common examples of list implementations are arrays and linked lists.</st>
    <st c="19646">An array is a straightforward implementation in which elements are
    stored in contiguous memory locations, providing fast access by index.</st> <st
    c="19784">In contrast, a linked list is a more flexible implementation where each
    element (or node) points to the next, allowing dynamic resizing and easier insertion
    or deletion of elements.</st> <st c="19966">Lists are often used to manage ordered
    collections of items, such as a list of students, tasks in a to-do list, or a
    playlist of songs.</st> <st c="20102">Both arrays and linked lists will be discussed
    in</st> [*<st c="20152">Chapter 12</st>*](B22248_12.xhtml#_idTextAnchor187)<st
    c="20162">.</st>'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="19340">列表</st>**<st c="19345">：列表是</st> <st c="19350">一种表示有序元素集合的抽象数据类型（ADT），其中每个元素在序列中都有一个特定的位置。</st>
    <st c="19480">列表的主要操作包括插入、删除、访问和遍历元素。</st> <st c="19577">常见的列表实现方式有数组和链表。</st>
    <st c="19646">数组是一种直接的实现方式，其中元素存储在连续的内存位置中，能够通过索引快速访问。</st> <st c="19784">与此不同，链表是一种更灵活的实现方式，每个元素（或节点）指向下一个元素，允许动态调整大小，并且更容易进行元素的插入或删除。</st>
    <st c="19966">列表常用于管理有序的项集合，例如学生名单、待办事项列表或歌曲播放列表。</st> <st c="20102">数组和链表将会在</st>
    [*<st c="20152">第12章</st>*](B22248_12.xhtml#_idTextAnchor187)<st c="20162">中讨论。</st>'
- en: '**<st c="20163">Stack</st>**<st c="20169">: A stack is</st> <st c="20183">an
    ADT that operates on the</st> **<st c="20211">Last-In-First-Out</st>** <st c="20228">(</st>**<st
    c="20230">LIFO</st>**<st c="20234">) principle, where</st> <st c="20254">the most
    recently added element is the first to be removed.</st> <st c="20314">The primary
    operations associated with a stack are</st> **<st c="20365">push</st>** <st c="20369">(adding
    an element to the top of the stack) and</st> **<st c="20418">pop</st>** <st c="20421">(removing
    the top element).</st> <st c="20450">One common example of a stack is the call
    stack, used by programming languages to track function calls and returns.</st>
    <st c="20566">Another prevalent use case is the undo mechanism in text editors,
    where a stack is used to revert to previous states.</st> <st c="20684">Stacks
    are also essential in parsing expressions in compilers, implementing backtracking
    algorithms such as solving mazes or puzzles, and managing nested function calls
    in recursion.</st> <st c="20867">Stacks will be reviewed in</st> [*<st c="20894">Chapter
    12</st>*](B22248_12.xhtml#_idTextAnchor187)<st c="20904">.</st>'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="20163">栈</st>**<st c="20169">：栈是</st> <st c="20183">一种基于</st> **<st
    c="20211">后进先出</st>** <st c="20228">(</st>**<st c="20230">LIFO</st>**<st c="20234">)原则的抽象数据类型（ADT），其中</st>
    <st c="20254">最近添加的元素是第一个被移除的。</st> <st c="20314">栈的主要操作包括</st> **<st c="20365">压栈</st>**
    <st c="20369">(将元素添加到栈顶)和</st> **<st c="20418">弹栈</st>** <st c="20421">(移除栈顶元素)。</st>
    <st c="20450">栈的一个常见示例是调用栈，编程语言通过调用栈来跟踪函数的调用与返回。</st> <st c="20566">另一个常见的使用案例是文本编辑器中的撤销机制，其中栈用于回退到先前的状态。</st>
    <st c="20684">栈在编译器中用于解析表达式、实现回溯算法（例如解决迷宫或谜题），以及管理递归中的嵌套函数调用等方面也至关重要。</st> <st
    c="20867">栈将在</st> [*<st c="20894">第12章</st>*](B22248_12.xhtml#_idTextAnchor187)<st
    c="20904">中进行回顾。</st>'
- en: '**<st c="20905">Queue</st>**<st c="20911">: A</st> <st c="20916">queue is an
    ADT that operates on</st> <st c="20949">the</st> **<st c="20953">First-In-First-Out</st>**
    <st c="20971">(</st>**<st c="20973">FIFO</st>**<st c="20977">) principle, meaning
    the first element added is the first one to be removed.</st> <st c="21055">The
    primary operations associated with queues are</st> **<st c="21105">enqueue</st>**
    <st c="21112">(adding an element to the queue) and</st> **<st c="21150">dequeue</st>**
    <st c="21157">(removing an element from the queue).</st> <st c="21196">Queues
    have numerous applications in software programming and computer systems, such
    as managing print jobs in a print queue, where documents are processed in the
    order they are received, and in task scheduling within operating systems, where
    processes are handled in the order they are queued for execution.</st> <st c="21505">In</st>
    [*<st c="21508">Chapter 12</st>*](B22248_12.xhtml#_idTextAnchor187)<st c="21518">,
    we will review the major characteristics</st> <st c="21561">of Queues.</st>'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="20905">队列（Queue）</st>**<st c="20911">：一个</st> <st c="20916">队列是一个抽象数据类型（ADT），它遵循</st>
    <st c="20949">先进先出（</st> **<st c="20953">FIFO</st>** <st c="20971">）原则，意味着最先加入的元素是最先被移除的。</st>
    <st c="21055">队列的主要操作是</st> **<st c="21105">入队</st>** <st c="21112">（将元素添加到队列中）和</st>
    **<st c="21150">出队</st>** <st c="21157">（从队列中移除元素）。</st> <st c="21196">队列在软件编程和计算机系统中有广泛的应用，比如在打印队列中管理打印任务，文档按照接收的顺序进行处理，以及操作系统中的任务调度，进程按队列顺序执行。</st>
    <st c="21505">在</st> [*<st c="21508">第12章</st>*](B22248_12.xhtml#_idTextAnchor187)<st
    c="21518">中，我们将回顾队列的主要特性。</st>'
- en: '**<st c="21571">Deque (Double-Ended Queue</st>**<st c="21597">): A</st> <st
    c="21603">deque is an ADT that allows elements to be inserted and deleted from
    both ends of the sequence, effectively generalizing both stacks and queues.</st>
    <st c="21748">For example, the deque implementation in the</st> **<st c="21793">Standard
    Template Library</st>** <st c="21818">(</st>**<st c="21820">STL</st>**<st c="21823">)
    of</st> <st c="21829">C++ provides a flexible sequence container that can dynamically
    grow and shrink at either end.</st> <st c="21924">Another example is the circular
    buffer, a deque implementation commonly used in scenarios where data is cyclically
    added and removed.</st> <st c="22058">Deques are particularly useful in implementing
    features such as undo/redo in software applications such as text editors.</st>
    <st c="22179">They also play a crucial role in more advanced applications, such
    as managing sliding window problems in algorithms.</st> <st c="22296">Deque will
    be reviewed in detail in</st> [*<st c="22332">Chapter 12</st>*](B22248_12.xhtml#_idTextAnchor187)<st
    c="22342">.</st>'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21571">双端队列（Deque）</st>**<st c="21597">：一个</st> <st c="21603">双端队列是一个抽象数据类型（ADT），允许元素从序列的两端插入和删除，实际上是对栈和队列的通用化。</st>
    <st c="21748">例如，</st> **<st c="21793">标准模板库（STL）</st>** <st c="21818">中C++的双端队列实现提供了一个灵活的序列容器，可以在两端动态增长和缩小。</st>
    <st c="21829">另一个例子是循环缓冲区，它是一个常用于数据周期性添加和删除的双端队列实现。</st> <st c="21924">双端队列在实现诸如文本编辑器中的撤销/重做功能等软件应用中特别有用。</st>
    <st c="22058">它们在更复杂的应用中也发挥着重要作用，例如在算法中管理滑动窗口问题。</st> <st c="22179">双端队列将在</st>
    [*<st c="22332">第12章</st>*](B22248_12.xhtml#_idTextAnchor187)<st c="22342">中详细讨论。</st>'
- en: '**<st c="22343">Set</st>**<st c="22347">: A set</st> <st c="22355">is an ADT
    that represents a collection of unique elements, where the order of elements is
    not important.</st> <st c="22461">The key operations associated with sets include
    insertion, deletion, membership checks, and set operations such as union, intersection,
    and difference.</st> <st c="22613">Examples of set implementations include</st>
    **<st c="22653">HashSet</st>** <st c="22660">in Java, which ensures that a collection
    contains no duplicate elements, and</st> **<st c="22738">Set</st>** <st c="22741">in
    Python, which supports various mathematical operations such as union and intersection.</st>
    <st c="22832">Sets are widely used in scenarios such as managing collections of
    unique items (e.g., a list of students enrolled in a course), implementing operations
    that require uniqueness (e.g., removing duplicates from a list), and performing
    mathematical</st> <st c="23077">set operations.</st>'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22343">集合</st>**<st c="22347">：集合</st> <st c="22355">是一个抽象数据类型（ADT），表示一组唯一元素，其中元素的顺序不重要。</st>
    <st c="22461">集合的主要操作包括插入、删除、成员检查以及集合运算，如并集、交集和差集。</st> <st c="22613">集合实现的例子包括</st>
    **<st c="22653">HashSet</st>** <st c="22660">，它在Java中确保集合中没有重复元素，以及</st> **<st
    c="22738">集合</st>** <st c="22741">，它在Python中支持多种数学运算，如并集和交集。</st> <st c="22832">集合广泛应用于诸如管理唯一项目集合（例如，某课程注册学生名单）、实现要求唯一性的操作（例如，从列表中删除重复项）以及进行数学</st>
    <st c="23077">集合运算等场景。</st>'
- en: '**<st c="23092">Dictionary</st>**<st c="23103">: A dictionary, also</st> <st
    c="23125">referred to as a map or associative array, is an ADT that stores data
    as key-value pairs, with each key being unique and associated with a specific
    value.</st> <st c="23280">The primary operations include inserting new key-value
    pairs, deleting pairs, looking up values based on keys, and sometimes iterating
    over keys or values.</st> <st c="23436">Examples of dictionary implementations
    include</st> **<st c="23483">HashMap</st>** <st c="23490">in Java, which enables
    fast retrieval of values using unique keys, and</st> **<st c="23562">Dictionary</st>**
    <st c="23572">in Python, which offers a versatile way to map keys to values.</st>
    <st c="23636">Dictionaries are widely used in various applications, such as implementing
    lookup tables, managing configuration settings where each one is identified by
    a unique key, and storing and retrieving data by key, such as user profiles indexed
    by user ID.</st> <st c="23886">Detailed discussions on dictionaries are found
    in the</st> <st c="23940">next section.</st>'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="23092">字典</st>**<st c="23103">：字典，也</st> <st c="23125">称为映射或关联数组，是一种将数据存储为键值对的抽象数据类型（ADT），其中每个键都是唯一的，并与特定的值相关联。</st>
    <st c="23280">主要操作包括插入新的键值对、删除键值对、根据键查找值，有时还包括遍历键或值。</st> <st c="23436">字典实现的例子包括</st>
    **<st c="23483">HashMap</st>** <st c="23490">，它在Java中使用唯一键快速检索值，以及</st> **<st
    c="23562">字典</st>** <st c="23572">，它在Python中提供了一种将键映射到值的多功能方式。</st> <st c="23636">字典广泛应用于各种场景，例如实现查找表、管理配置设置（每个设置通过唯一键标识）以及通过键存储和检索数据，例如通过用户ID索引的用户个人资料。</st>
    <st c="23886">关于字典的详细讨论请参见</st> <st c="23940">下一节。</st>'
- en: '**<st c="23953">Graph</st>**<st c="23959">: A graph is</st> <st c="23973">an
    ADT that represents a collection of nodes, known as vertices, which are connected
    by edges.</st> <st c="24068">Graphs can be either directed, where edges have a
    specific direction, or undirected, where edges have no direction.</st> <st c="24184">They
    can also contain cycles.</st> <st c="24214">Common operations on graphs include
    adding vertices, adding edges, and traversing the structure.</st> <st c="24311">Graphs
    are typically implemented using an adjacency list, where each node has a list
    of its neighboring nodes, or an adjacency matrix, a 2D array that indicates the
    presence or absence of edges between nodes.</st> <st c="24520">Graphs are</st>
    <st c="24531">widely used in various fields of science and engineering, including
    modeling networks such as social networks, communication networks, and transportation
    systems.</st> <st c="24694">Graphs are discussed further in</st> [*<st c="24726">Chapter
    13</st>*](B22248_13.xhtml#_idTextAnchor200)<st c="24736">.</st>'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="23953">图</st>**<st c="23959">: 图是</st> <st c="23973">一种抽象数据类型（ADT），表示由节点（称为顶点）组成的集合，节点之间通过边连接。</st>
    <st c="24068">图可以是有向图，其中边具有特定方向，或者是无向图，其中边没有方向。</st> <st c="24184">图也可以包含环。</st>
    <st c="24214">图的常见操作包括添加顶点、添加边和遍历结构。</st> <st c="24311">图通常使用邻接表实现，其中每个节点都有一个邻居节点的列表，或者使用邻接矩阵，这是一种二维数组，表示节点之间是否存在边。</st>
    <st c="24520">图是</st> <st c="24531">广泛应用于各种科学和工程领域，包括建模社交网络、通信网络和交通系统等网络。</st>
    <st c="24694">图将在</st> [*<st c="24726">第13章</st>*](B22248_13.xhtml#_idTextAnchor200)<st
    c="24736">中进一步讨论。</st>'
- en: '**<st c="24737">Tree</st>**<st c="24742">: A tree</st> <st c="24751">is a hierarchical
    ADT where elements are arranged in nodes, starting with a single root node that
    branches out into child nodes, forming subtrees.</st> <st c="24899">Trees can
    be of various types, such as binary trees, where each node has at most two children,
    or more complex structures such as B-trees.</st> <st c="25038">Examples include</st>
    <st c="25054">the</st> **<st c="25059">Binary Search Tree</st>** <st c="25077">(</st>**<st
    c="25079">BST</st>**<st c="25082">) and the Heap.</st> <st c="25099">In a BST,
    each node can have up to two children, with the left child being smaller than
    the parent and the right child being larger.</st> <st c="25232">The Heap is a
    specialized tree structure that adheres to the</st> **<st c="25293">heap</st>**
    <st c="25297">property, commonly used to implement priority queues.</st> <st c="25352">We
    will discuss trees in</st> [*<st c="25377">Chapter 13</st>*](B22248_13.xhtml#_idTextAnchor200)<st
    c="25387">.</st>'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="24737">树</st>**<st c="24742">: 树</st> <st c="24751">是一种层次结构的抽象数据类型（ADT），其中元素以节点的形式排列，从一个根节点开始，根节点向外分支成子节点，形成子树。</st>
    <st c="24899">树可以有多种类型，例如二叉树，其中每个节点最多有两个子节点，或者更复杂的结构，如B树。</st> <st c="25038">示例包括</st>
    <st c="25054">**<st c="25059">二叉搜索树</st>**</st> <st c="25077">(</st>**<st c="25079">BST</st>**<st
    c="25082">) 和堆。</st> <st c="25099">在二叉搜索树中，每个节点最多有两个子节点，左子节点小于父节点，右子节点大于父节点。</st>
    <st c="25232">堆是一种专门的树结构，遵循</st> **<st c="25293">堆</st>** <st c="25297">属性，通常用于实现优先队列。</st>
    <st c="25352">我们将在</st> [*<st c="25377">第13章</st>*](B22248_13.xhtml#_idTextAnchor200)<st
    c="25387">中讨论树。</st>'
- en: <st c="25388">ADTs allow programmers to focus on what operations can be performed
    on data, rather than how these operations are implemented.</st> <st c="25516">This
    abstraction leads to more flexible, maintainable, and reusable code.</st> <st
    c="25590">ADTs such as lists, stacks, queues, sets, maps, graphs, and trees are
    foundational to computer science, each serving specific use cases based on the
    nature o</st><st c="25747">f the data and</st> <st c="25763">operations required.</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="25388">抽象数据类型（ADT）使程序员能够专注于可以对数据执行哪些操作，而不是如何实现这些操作。</st> <st c="25516">这种抽象化导致了更加灵活、可维护和可重用的代码。</st>
    <st c="25590">像列表、栈、队列、集合、映射、图和树等ADT是计算机科学的基础，每种ADT根据数据的性质和所需操作的不同，服务于特定的用例。</st> '
- en: <st c="25783">Now that we have an understanding of data structure classifications
    and abstract data types, the next section will focus on the major operations that
    can be performed on data structures.</st> <st c="25971">We will begin by introducing
    an abstract data structure known as</st> <st c="26036">a</st> *<st c="26038">dictionary</st>*<st
    c="26048">.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25783">现在我们已经了解了数据结构分类和抽象数据类型，下一部分将重点介绍可以对数据结构执行的主要操作。</st> <st c="25971">我们将从介绍一种抽象数据结构开始，称为</st>
    <st c="26036">*字典*</st> <st c="26048">。</st>
- en: <st c="26049">Dictionaries</st>
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="26049">字典</st>
- en: <st c="26062">Dictionaries</st> <st c="26076">are abstract data structures designed
    to store data in a key-value format.</st> <st c="26151">In a dictionary, each
    element consists of a key that is unique and used to access the associated value.</st>
    <st c="26255">The key-value pairing allows for rapid lookups, which is one of
    the prima</st><st c="26328">ry advantages of using dictionaries.</st> <st c="26366">Dictionaries
    are also commonly referred to as maps, associative arrays, or</st> <st c="26441">symbol
    tables.</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26062">字典</st> <st c="26076">是一种抽象数据结构，旨在以键值对的形式存储数据。</st> <st c="26151">在字典中，每个元素由一个唯一的键组成，该键用于访问关联的值。</st>
    <st c="26255">键值对使得查找变得快速，这是使用字典的主要</st><st c="26328">优势之一。</st> <st c="26366">字典也常被称为映射、关联数组或</st>
    <st c="26441">符号表。</st>
- en: <st c="26455">While our focus</st> <st c="26471">has been on logical data structures,
    it’s worth noting that dictionaries can also be implemented directly in hardware
    through what is known as associative</st> <st c="26627">memory, or</st> **<st
    c="26638">Content-Addressable</st>** **<st c="26658">Memory</st>** <st c="26664">(</st>**<st
    c="26666">CAM</st>**<st c="26669">).</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26455">尽管我们的重点</st> <st c="26471">主要放在逻辑数据结构上，但值得注意的是，字典也可以通过所谓的关联</st>
    <st c="26627">存储器，或者</st> **<st c="26638">内容寻址</st>** **<st c="26658">存储器</st>**
    <st c="26664">(</st>**<st c="26666">CAM</st>**<st c="26669">)直接在硬件中实现。</st>
- en: <st c="26672">Associative memories are used for ultra-high-speed search operations.</st>
    <st c="26743">As you might expect, with associative memory, any search operation
    can be executed in constant time,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1790.png)<st
    c="26844"><st c="26845">. Although employing associative memories may seem costly
    and impractical for general algorithmic use, a more feasible approach in software
    is the use of hashing.</st> <st c="27008">Hashing, which was discussed in</st>
    [*<st c="27040">Chapter 7</st>*](B22248_07_split_000.xhtml#_idTextAnchor103)<st
    c="27049">, provides an algorithmic method to implement a content-addressable
    data structure, allowing for efficient lookups and</st> <st c="27168">other operations.</st></st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26672">关联存储器用于超高速搜索操作。</st> <st c="26743">正如你所料，使用关联存储器时，任何搜索操作都可以在恒定时间内执行，</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1790.png)<st
    c="26844"><st c="26845">。尽管使用关联存储器可能在通用算法应用中显得昂贵且不切实际，但在软件中更可行的做法是使用哈希。</st> <st
    c="27008">哈希，在</st> [*<st c="27040">第7章</st>*](B22248_07_split_000.xhtml#_idTextAnchor103)<st
    c="27049">中有所讨论，提供了一种实现内容寻址数据结构的算法方法，允许高效的查找和</st> <st c="27168">其他操作。</st></st>
- en: <st c="27185">The key</st> <st c="27194">properties of dictionaries include</st>
    <st c="27229">the following:</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27185">字典的主要</st> <st c="27194">特性包括</st> <st c="27229">以下几点：</st>
- en: <st c="27243">In most implementa</st><st c="27262">tions, dictionaries do not
    maintain any particular order of the key-value pairs.</st> <st c="27344">The elements
    are stored in an arbitrary order based on the</st> **<st c="27403">hash</st>**
    <st c="27407">function</st> <st c="27417">used internally.</st>
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27243">在大多数实现中，字典不会维护键值对的特定顺序。</st> <st c="27344">元素是根据内部使用的</st> **<st
    c="27403">哈希</st>** <st c="27407">函数以任意顺序存储的。</st>
- en: <st c="27433">Each key in a dictionary is unique.</st> <st c="27470">If you
    attempt to insert a new key-value pair with a key that already exists in the dictionary,
    the existing value is typically overwritten with the</st> <st c="27619">new value.</st>
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27433">字典中的每个键都是唯一的。</st> <st c="27470">如果你试图插入一个新键值对，且其键在字典中已存在，现有的值通常会被</st>
    <st c="27619">新值覆盖。</st>
- en: <st c="27629">The primary operations on a dictionary – such as inserting, deleting,
    and accessing elements – are typically performed in average-case</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1791.png)
    <st c="27765"><st c="27766">time due to the underlying hash table implementation.</st>
    <st c="27821">This makes dictionaries extremely efficient for large datasets where
    fast lookups</st> <st c="27903">are required.</st></st>
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27629">字典的主要操作——如插入、删除和访问元素——通常在平均情况下以</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1791.png)
    <st c="27765"><st c="27766">时间完成，这得益于底层哈希表的实现。</st> <st c="27821">这使得字典在需要快速查找的大型数据集上非常高效。</st>
- en: <st c="27916">The question is how</st> <st c="27937">to implement and maintain
    dictionaries.</st> <st c="27977">Fortunately, many programming languages provide
    built-in support for dictionaries.</st> <st c="28060">Here’s a simple example
    of how dictionaries can be used</st> <st c="28116">in Python:</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27916">问题是如何</st> <st c="27937">实现和维护字典。</st> <st c="27977">幸运的是，许多编程语言都提供了对字典的内置支持。</st>
    <st c="28060">这是一个简单的例子，展示了字典如何在 Python 中使用：</st>
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="28976">This example</st> <st c="28990">demonstrates the basic operations
    of a dictionary in Python, showcasing how easy it is to create, manipulate, and
    access data using this powerful data structure.</st> <st c="29152">Let’s briefly
    explain</st> <st c="29174">the code:</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28976">这个例子</st> <st c="28990">展示了字典在 Python 中的基本操作，展示了如何轻松创建、操作和访问数据，充分发挥这种强大数据结构的优势。</st>
    <st c="29152">让我们简要解释一下</st> <st c="29174">代码：</st>
- en: '**<st c="29183">Creating a dictionary</st>**<st c="29205">: We define a dictionary,</st>
    **<st c="29232">student_info</st>**<st c="29244">, with key-value pairs representing
    various attributes of</st> <st c="29302">a student.</st>'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="29183">创建字典</st>**<st c="29205">：我们定义一个字典</st> **<st c="29232">student_info</st>**<st
    c="29244">，其中包含表示学生各种属性的键值对。</st>'
- en: '**<st c="29312">Accessing values</st>**<st c="29329">: We access the values
    associated with the</st> **<st c="29373">name</st>** <st c="29377">and</st> **<st
    c="29382">age</st>** <st c="29385">keys using</st> <st c="29397">square brackets.</st>'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="29312">访问值</st>**<st c="29329">：我们使用</st> **<st c="29373">name</st>**
    <st c="29377">和</st> **<st c="29382">age</st>** <st c="29385">键，通过方括号访问对应的值。</st>'
- en: '**<st c="29413">Adding a key-value pair</st>**<st c="29437">: We add a new
    key,</st> **<st c="29458">graduation_year</st>**<st c="29473">, with its</st>
    <st c="29484">corresponding value.</st>'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="29413">添加键值对</st>**<st c="29437">：我们添加一个新的键</st> **<st c="29458">graduation_year</st>**<st
    c="29473">，并为其指定相应的值。</st>'
- en: '**<st c="29504">Updating a value</st>**<st c="29521">: We update the value
    associated with the</st> **<st c="29564">GPA</st>** <st c="29567">key.</st>'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="29504">更新值</st>**<st c="29521">：我们更新与</st> **<st c="29564">GPA</st>**
    <st c="29567">键相关联的值。</st>'
- en: '**<st c="29572">Deleting a key-value pair</st>**<st c="29598">: We remove the</st>
    **<st c="29615">major</st>** <st c="29620">key and its value using the</st> **<st
    c="29649">del</st>** <st c="29652">statement.</st>'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="29572">删除键值对</st>**<st c="29598">：我们使用</st> **<st c="29615">del</st>**
    <st c="29620">语句删除</st> **<st c="29649">主要</st>** <st c="29652">键及其值。</st>'
- en: '**<st c="29663">Iterating over the dictionary</st>**<st c="29693">: We iterate
    over the dictionary using a</st> **<st c="29735">for</st>** <st c="29738">loop,
    printing each</st> <st c="29759">key-value pair.</st>'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="29663">遍历字典</st>**<st c="29693">：我们使用</st> **<st c="29735">for</st>**
    <st c="29738">循环遍历字典，打印每个</st> <st c="29759">键值对。</st>'
- en: <st c="29774">As we</st> <st c="29781">illustrated in the previous example,
    dictionaries are more than just collections of key-value pairs; they also support
    a range of fundamental operations that allow for efficient data management.</st>
    <st c="29976">These basic operations include insertion, search, update (or edit),
    and deletion.</st> <st c="30058">Let’s explore each of these functions in detail
    with examples</st> <st c="30120">in Python.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29774">正如我们在前面的例子中所展示的，字典不仅仅是键值对的集合；它们还支持一系列基本操作，允许高效的数据管理。</st> <st
    c="29976">这些基本操作包括插入、查找、更新（或编辑）和删除。</st> <st c="30058">让我们通过 Python 示例详细探索每个操作的实现。</st>
- en: <st c="30130">Insertion</st>
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="30130">插入</st>
- en: '*<st c="30140">Insertion</st>* <st c="30150">involves</st> <st c="30159">adding
    a new key-value pair to the dictionary.</st> <st c="30207">If the key already
    exists, the value associated with that key is updated; otherwise, a new entry
    is created.</st> <st c="30316">The following is an insertion function for a simple
    dictionary</st> <st c="30379">in Python:</st>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="30140">插入</st>* <st c="30150">涉及</st> <st c="30159">将一个新的键值对添加到字典中。</st>
    <st c="30207">如果键已经存在，则更新该键所关联的值；否则，创建一个新的条目。</st> <st c="30316">以下是一个简单字典的插入函数，</st>
    <st c="30379">用 Python 编写：</st>'
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<st c="30601">In this example, we create an empty dictionary called</st> `<st
    c="30656">student_grades</st>` <st c="30670">and insert two key-value pairs –</st>
    `<st c="30704">Alice: 85</st>` <st c="30713">and</st> `<st c="30718">Bob: 90</st>`<st
    c="30725">. The dictionary now holds these values, and new</st> <st c="30773">entries
    can be</st> <st c="30789">added similarly.</st>'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="30601">在此示例中，我们创建一个空字典，名为</st> `<st c="30656">student_grades</st>` <st
    c="30670">并插入两个键值对 –</st> `<st c="30704">Alice: 85</st>` <st c="30713">和</st>
    `<st c="30718">Bob: 90</st>`<st c="30725">。字典现在包含这些值，新的</st> <st c="30773">条目可以通过类似方式</st>
    <st c="30789">添加。</st>'
- en: <st c="30805">Search</st>
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="30805">搜索</st>
- en: '*<st c="30812">Search</st>* <st c="30819">is the</st> <st c="30827">operation
    of retrieving a value associated with a specific key.</st> <st c="30891">This
    is one of the most common and efficient operations on a dictionary, typically
    performed in constant time.</st> <st c="31002">Let’s look at a simple search function
    in</st> <st c="31044">a dictionary:</st>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="30812">搜索</st>* <st c="30819">是</st> <st c="30827">从字典中检索与特定键相关联的值的操作。</st>
    <st c="30891">这是字典中最常见且高效的操作之一，通常在常数时间内执行。</st> <st c="31002">让我们看一个简单的搜索函数，</st>
    <st c="31044">它用于字典中：</st>'
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="31371">Here, the</st> `<st c="31382">get</st>` <st c="31385">method is
    used to search for the value associated with the</st> `<st c="31445">Alice</st>`
    <st c="31450">key.</st> <st c="31456">If the key exists, the corresponding value
    is returned.</st> <st c="31512">If the key is not found, as in the case of</st>
    `<st c="31555">Charlie</st>`<st c="31562">, a default value (</st>`<st c="31581">"Not
    Found"</st>`<st c="31593">) can be</st> <st c="31603">returned instead.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31371">在这里，</st> `<st c="31382">get</st>` <st c="31385">方法被用来搜索与</st>
    `<st c="31445">Alice</st>` <st c="31450">键关联的值。</st> <st c="31456">如果键存在，则返回对应的值。</st>
    <st c="31512">如果未找到键，例如</st> `<st c="31555">Charlie</st>`<st c="31562">，可以返回一个默认值（</st>`<st
    c="31581">"未找到"</st>`<st c="31593">）。</st> <st c="31603">替代返回。</st>
- en: <st c="31620">Update</st>
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="31620">更新</st>
- en: '*<st c="31627">Update</st>* <st c="31634">involves</st> <st c="31644">changing
    the value associated with an existing key in the dictionary.</st> <st c="31714">If
    the key exists, its value is modified; if the key does not exist, a new key-value
    pair is added.</st> <st c="31814">The following is one example</st> <st c="31843">of
    updating:</st>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="31627">更新</st>* <st c="31634">涉及</st> <st c="31644">更改字典中现有键所关联的值。</st>
    <st c="31714">如果键存在，则其值会被修改；如果键不存在，则会添加一个新的键值对。</st> <st c="31814">以下是一个更新的例子：</st>
    <st c="31843">例如：</st>'
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<st c="32127">In this example, the</st> <st c="32148">value associated with
    the</st> `<st c="32175">Alice</st>` <st c="32181">key is updated from 85 to 88\.</st>
    <st c="32211">Additionally, a new key-value pair,</st> `<st c="32247">Charlie:
    92</st>`<st c="32258">, is added to</st> <st c="32272">the dictionary.</st>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="32127">在此示例中，</st> <st c="32148">与</st> `<st c="32175">Alice</st>` <st
    c="32181">键相关联的值从 85 更新为 88。</st> <st c="32211">此外，一个新的键值对，</st> `<st c="32247">Charlie:
    92</st>`<st c="32258">，被添加到</st> <st c="32272">字典中。</st>'
- en: <st c="32287">Deletion</st>
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="32287">删除</st>
- en: '*<st c="32296">Deletion</st>* <st c="32305">removes</st> <st c="32314">a key-value
    pair from the dictionary.</st> <st c="32352">Once removed, the key and its associated
    value no longer exist in the dictionary.</st> <st c="32434">Take a look at the</st>
    <st c="32453">following example:</st>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="32296">删除</st>* <st c="32305">移除</st> <st c="32314">字典中的一个键值对。</st>
    <st c="32352">一旦移除，键及其关联的值将不再存在于字典中。</st> <st c="32434">看看下面的</st> <st c="32453">例子：</st>'
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="32761">In this example, the</st> `<st c="32783">del</st>` <st c="32786">statement
    is used to remove the</st> `<st c="32819">"Bob"</st>` <st c="32824">key and its
    associated value from the dictionary.</st> <st c="32875">Additionally, the</st>
    `<st c="32893">pop</st>` <st c="32896">method is used to attempt to remove the</st>
    `<st c="32937">David</st>` <st c="32942">key, which does not exist in the dictionary,
    returning a default message,</st> `<st c="33017">Key</st>` `<st c="33021">not
    found</st>`<st c="33030">.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32761">在这个例子中，</st> `<st c="32783">del</st>` <st c="32786">语句用于从字典中删除</st>
    `<st c="32819">"Bob"</st>` <st c="32824">键及其相关的值。</st> <st c="32875">此外，</st>
    `<st c="32893">pop</st>` <st c="32896">方法用于尝试删除</st> `<st c="32937">David</st>`
    <st c="32942">键，而该键并不存在于字典中，返回默认消息：</st> `<st c="33017">键</st>` `<st c="33021">未找到</st>`<st
    c="33030">。</st>
- en: <st c="33031">These basic operations – insertion, search, update, and deletion
    – are essential for working with dictionaries in any programming language.</st>
    <st c="33172">They allow efficient management of data and enable you to create
    dynamic and adaptable programs.</st> <st c="33269">Whether we are adding new data,
    retrieving existing information, modifying values, or removing entries, these
    functions make dictionaries a versatile and powerful tool in algorithm design
    and everyday</st> <st c="33470">programming tasks.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33031">这些基本操作——插入、查找、更新和删除——对于在任何编程语言中使用字典至关重要。</st> <st c="33172">它们允许高效地管理数据，并使你能够创建动态且适应性强的程序。</st>
    <st c="33269">无论是添加新数据、检索已有信息、修改值，还是删除条目，这些功能都使字典成为算法设计和日常编程任务中一个多功能且强大的工具。</st>
    <st c="33470">程序任务。</st>
- en: <st c="33488">In</st> *<st c="33492">Chapters 12</st>* <st c="33503">and</st>
    *<st c="33508">13</st>*<st c="33510">, as we introduce various data structures,
    we will evaluate their performance as they relate to these fundamental operations.</st>
    <st c="33636">Additionally, some data structures include extended functions and
    specific operations, such as finding successor and predecessor</st> <st c="33765">in
    BSTs.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33488">在</st> *<st c="33492">第12章</st>* <st c="33503">和</st> *<st c="33508">第13章</st>*<st
    c="33510">中，我们将介绍各种数据结构，并评估它们在这些基本操作中的表现。</st> <st c="33636">此外，某些数据结构包括扩展功能和特定操作，如在二叉搜索树（BST）中查找后继和前驱。</st>
- en: <st c="33773">Summary</st>
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="33773">总结</st>
- en: <st c="33781">In this chapter, the foundational concepts of data structures
    were explored, with a focus on their classification and the ess</st><st c="33907">ential
    operations that can be performed on them.</st> <st c="33957">The chapter discussed
    the distinctions between physical and logical data structures, as well as between
    primitive and composite structures.</st> <st c="34097">It also covered the differences
    between linear and non-linear data structures, along with the implications of
    static versus dynamic data allocation, and sequential versus random access.</st>
    <st c="34283">Through these discussions, the importance of selecting the appropriate
    data structure for specific algorithmic tasks</st> <st c="34400">was emphasized.</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33781">本章探讨了数据结构的基础概念，重点讨论了它们的分类及可执行的基本操作。</st> <st c="33907">本章讨论了物理数据结构和逻辑数据结构之间的区别，以及原始数据结构和复合数据结构之间的区别。</st>
    <st c="33957">它还涵盖了线性数据结构与非线性数据结构之间的差异，以及静态与动态数据分配、顺序访问与随机访问的影响。</st> <st c="34283">通过这些讨论，强调了为特定算法任务选择合适数据结构的重要性。</st>
    <st c="34400">。</st>
- en: <st c="34415">The chapter also provided insights into the workings of dictionaries,
    highlighting their key operations, such as insertion, search, update, and deletion,
    with examples to demonstrate their practical usage.</st> <st c="34622">The discussion
    underscored the role of dictionaries as a versatile and efficient tool in</st>
    <st c="34711">algorithm design.</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34415">本章还提供了关于字典的工作原理的见解，重点介绍了它们的关键操作，如插入、查找、更新和删除，并通过示例演示它们的实际应用。</st>
    <st c="34622">讨论强调了字典作为一个多功能且高效的工具，在</st> <st c="34711">算法设计中的作用。</st>
- en: <st c="34728">As we move forward, the next chapter will delve into linear data
    structures, including arrays and linked lists, and we will examine their properties
    and use cases in</st> <st c="34895">greater detail.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34728">随着我们继续前进，下一章将深入探讨线性数据结构，包括数组和链表，并详细分析它们的属性和应用场景。</st>
- en: <st c="34910">References and further reading</st>
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="34910">参考资料与进一步阅读</st>
- en: '*<st c="34941">Introduction to Algorithms</st>* <st c="34968">by Thomas H.</st>
    <st c="34982">Cormen, Charles E.</st> <st c="35001">Leiserson, Ronald L.</st>
    <st c="35022">Rivest, and Clifford Stein.</st> <st c="35050">Fourth Edition.</st>
    <st c="35066">MIT</st> <st c="35070">Press.</st> <st c="35077">2022:</st>'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="34941">算法导论</st>* <st c="34968">作者：Thomas H.</st> <st c="34982">Cormen，Charles
    E.</st> <st c="35001">Leiserson，Ronald L.</st> <st c="35022">Rivest，和Clifford
    Stein。</st> <st c="35050">第四版。</st> <st c="35066">MIT</st> <st c="35070">出版社。</st>
    <st c="35077">2022：</st>'
- en: '*<st c="35082">Chapter 10</st>*<st c="35093">,</st> *<st c="35095">Elementary</st>*
    *<st c="35106">Data Structures</st>*'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="35082">第10章</st>*<st c="35093">，</st> *<st c="35095">基础</st>* *<st
    c="35106">数据结构</st>*'
- en: '*<st c="35121">Algorithms</st>* <st c="35132">by R.</st> <st c="35139">Sedgewick,
    K.</st> <st c="35153">Wayne.</st> <st c="35160">Fourth Edition.</st> <st c="35176">Addison-Wesley.</st>
    <st c="35192">2011:</st>'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="35121">算法</st>* <st c="35132">作者：R.</st> <st c="35139">Sedgewick，K.</st>
    <st c="35153">Wayne。</st> <st c="35160">第四版。</st> <st c="35176">Addison-Wesley。</st>
    <st c="35192">2011：</st>'
- en: '*<st c="35197">Chapter</st>* *<st c="35206">1</st>*<st c="35207">,</st> *<st
    c="35209">Fundamentals</st>*'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="35197">第1章</st>* *<st c="35206">，</st>* *<st c="35209">基础知识</st>*'
- en: '*<st c="35221">Data Structures and Algorithm Analysis in C++</st>* <st c="35267">by
    Mark A.</st> <st c="35279">Weiss.</st> <st c="35286">Fourth Edition.</st> <st
    c="35302">Pearson.</st> <st c="35311">2012:</st>'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="35221">C++中的数据结构与算法分析</st>* <st c="35267">作者：Mark A.</st> <st c="35279">Weiss。</st>
    <st c="35286">第四版。</st> <st c="35302">Pearson。</st> <st c="35311">2012：</st>'
- en: '*<st c="35316">Chapter 3</st>*<st c="35326">,</st> *<st c="35328">Lists, Stacks,</st>*
    *<st c="35343">and Queues</st>*'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="35316">第3章</st>*<st c="35326">，</st> *<st c="35328">列表、栈，</st>* *<st
    c="35343">队列</st>*'
