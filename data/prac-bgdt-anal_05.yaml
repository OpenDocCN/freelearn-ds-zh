- en: Big Data Mining with NoSQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NoSQL进行大数据挖掘
- en: The term **NoSQL** was first used by Carlo Strozzi, who, in 1998, released the
    Strozzi NoSQL opensource relational database. In the late 2000s, new paradigms
    in database architecture emerged, many of which did not adhere to the strict constraints
    required of relational database systems. These databases, due to their non-conformity
    with standard database conventions such as ACID compliance, were soon grouped
    under a broad category known as NoSQL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**NoSQL**这个术语最早由Carlo Strozzi于1998年使用，他发布了Strozzi NoSQL开源关系数据库。在2000年代末期，数据库架构出现了新的范式，其中许多并不遵循关系型数据库系统所要求的严格约束。这些数据库由于不符合标准数据库的约定（如ACID合规性），很快被归为一个统称为NoSQL的广泛类别。'
- en: Each NoSQL database claims to be optimal for certain use cases. Although few
    of them would fit the requirements to be a general-purpose database management
    system, they all leverage a few common themes across the spectrum of NoSQL systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个NoSQL数据库都声称在某些使用场景下最为优化。尽管其中很少有数据库能符合作为通用数据库管理系统的要求，但它们都在NoSQL系统的范围内利用了一些共同的主题。
- en: In this chapter, we will visit some of the broad categories of NoSQL database
    management systems. We will discuss the primary drivers that initiated the migration
    to NoSQL database systems and how such databases solved specific business needs
    that led to their widespread adoption, and conclude with a few hands-on NoSQL
    exercises.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章节中，我们将探讨一些广泛的NoSQL数据库管理系统的类别。我们将讨论促使迁移到NoSQL数据库系统的主要驱动因素，以及这些数据库如何解决特定的业务需求，这些需求促使了它们的广泛应用，并以一些NoSQL的实操练习作为结尾。
- en: 'The topics covered in this chapter include:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖的主题包括：
- en: Why NoSQL?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择NoSQL？
- en: NoSQL databases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL数据库
- en: In-memory databases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存数据库
- en: Columnar databases
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列式数据库
- en: Document-oriented databases
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向文档的数据库
- en: Key-value databases
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值数据库
- en: Graph databases
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据库
- en: Other NoSQL types and summary
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他NoSQL类型与总结
- en: Hands-on exercise on NoSQL systems
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL系统的实操练习
- en: Why NoSQL?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择NoSQL？
- en: 'The term NoSQL generally means *Not Only SQL*: that is, the underlying database
    has properties that are different to those of common and traditional database
    systems. As such, there is no clear distinction that qualifies a database as NoSQL,
    other than the fact that they do not provide the characteristics of ACID compliance.
    As such, it would be helpful to understand the nature of ACID properties that
    have been the mainstay of database systems for many decades, as well as discuss,
    in brief, the significance of BASE and CAP, two other terminologies central to
    databases today.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL一词通常表示*不仅仅是SQL*：即底层数据库具有与常见传统数据库系统不同的属性。因此，NoSQL数据库并没有明确的界定标准，唯一的区别就是它们不提供ACID合规性等特性。因此，了解ACID属性的性质是有帮助的，这些属性一直是数据库系统的核心，并简要讨论BASE和CAP这两个今天数据库领域中的核心术语。
- en: The ACID, BASE, and CAP properties
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ACID、BASE和CAP属性
- en: Let's first proceed with ACID and SQL.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来讲解ACID和SQL。
- en: ACID and SQL
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ACID和SQL
- en: 'ACID stands for atomicity, consistency, isolation, and durability:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ACID代表原子性、一致性、隔离性和持久性：
- en: '**Atomicity**: This indicates that database transactions either execute in
    full or do not execute at all. In other words, either all transactions should
    be committed, that is, persisted in their entirety, or not committed at all. There
    is no scope for a partial execution of a transaction.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：这表示数据库事务要么完全执行，要么根本不执行。换句话说，要么所有事务都应该被提交，即完全持久化，要么根本不提交。事务不能部分执行。'
- en: '**Consistency**: The constraints on the data, that is, the rules that determine
    data management within a database, will be consistent throughout the database.
    Different instances will not abide by rules that are any different to those in
    other instances of the database.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：数据管理中的约束条件，即决定数据库内数据管理规则的规则，将在整个数据库中保持一致。不同的实例不会遵循与其他数据库实例不同的规则。'
- en: '**Isolation**: This property defines the rules of how concurrent operations
    (transactions) will read and write data. For example, if a certain record is being
    updated while another process reads the same record, the isolation level of the
    database system will determine which version of the data would be returned back
    to the user.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：此属性定义了并发操作（事务）如何读取和写入数据的规则。例如，如果某个记录在更新时，另一个进程读取了同一记录，那么数据库系统的隔离级别将决定哪个版本的数据会返回给用户。'
- en: '**Durability**: The durability of a database system generally indicates that
    committed transactions will remain persistent even in the event of a system failure.
    This is generally managed by the use of transaction logs that databases can refer
    to during recovery.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：数据库系统的持久性通常意味着已提交的事务即使在系统故障的情况下也会保持持久性。这通常通过使用事务日志来管理，数据库在恢复过程中可以参考这些日志。'
- en: 'The reader may observe that all the properties defined here relate primarily
    to database transactions. A **transaction** is a unit of operation that abides
    by the aforementioned rules and makes a change to the database. For example, a
    typical cash withdrawal from an ATM may have the following logical pathway:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能会注意到，这里定义的所有特性主要与数据库事务相关。**事务**是遵循上述规则并对数据库进行更改的操作单元。例如，从ATM取款的典型逻辑流程如下：
- en: User withdraws cash from an ATM
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户从ATM机取款
- en: The bank checks the current balance of the user
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 银行检查用户当前的余额
- en: The database system deducts the corresponding amount from the user's account
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库系统从用户账户中扣除相应金额
- en: The database system updates the amount in the user's account to reflect the
    change
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库系统更新用户账户中的金额以反映变化
- en: As such, most databases in popular use prior to the mid-1990s, such as Oracle,
    Sybase, DB2, and others, were optimized for recording and managing transactional
    data. Until this time, most databases were responsible for managing transactional
    data. The rapid growth of the internet in the mid-90s led to new types of data
    that did not necessarily require the strict ACID compliance requirements. Videos
    on YouTube, music on Pandora, and corporate email records are all examples of
    use cases where a a transactional database does not add value beyond simply functioning
    as a technology layer for storing data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在1990年代中期之前，诸如Oracle、Sybase、DB2等流行的数据库大多被优化用于记录和管理事务数据。在此之前，大多数数据库都负责管理事务数据。90年代中期互联网的快速发展带来了新的数据类型，这些数据类型不一定要求严格遵守ACID一致性要求。YouTube上的视频、Pandora上的音乐以及公司邮件记录等，都是在这些用例中，事务型数据库除了作为存储数据的技术层外并没有带来更多的价值。
- en: The BASE property of NoSQL
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL的**BASE**特性
- en: By the late 2000s, data volume had surged and it was apparent that a new alternative
    model was required in order to manage the data. This new model, called BASE, became
    a foundational topic that replaced ACID as the preferred model of database management
    systems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到了2000年代末，数据量激增，显然需要一种新的替代模型来管理数据。这个新模型被称为BASE，成为一个基础性话题，取代了ACID作为首选的数据库管理系统模型。
- en: '**BASE** stands for **B**asically **A**vailable **S**oft-state **E**ventually
    consistency. This implies that the database is *basically* available for use most
    of the time; that is, there can be periods during which the services are unavailable
    (and hence additional redundancy measures should be implemented). *Soft-state*
    means that the state of the system cannot be guaranteed - different instances
    of the same data might have different content as it may not have yet captured
    recent updates in another part of the cluster. Finally, *eventually* consistent
    implies that although the database might not be in the same state at all times,
    it will eventually get to the same state; that is, become *consistent*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**BASE**代表**B**asically **A**vailable **S**oft-state **E**ventually一致性。这意味着数据库大多数时间是*基本*可用的；也就是说，可能会有一些服务不可用的时间段（因此需要实施额外的冗余措施）。*软状态*意味着系统的状态不能得到保证——同一数据的不同实例可能包含不同的内容，因为它可能尚未捕捉到集群其他部分的最新更新。最后，*最终*一致性意味着尽管数据库在任何时候可能不处于相同的状态，但它最终会达到相同的状态；也就是说，变得*一致*。'
- en: The CAP theorem
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**CAP定理**'
- en: 'First introduced in the late 1990s by Eric Allen Brewer, the CAP theorem categorizes
    the constraints, or more generally the characteristics, of distributed database
    systems. In brief, the CAP theorem postulates that strictly speaking, database
    systems can guarantee only two of the three properties defined by CAP, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAP定理**是由Eric Allen Brewer在1990年代末提出的，它对分布式数据库系统的约束，或者更广泛地说，是分布式数据库系统的特性进行了分类。简言之，CAP定理认为严格来说，数据库系统只能保证CAP定义的三个特性中的两个，具体如下：'
- en: '**Consistency**: The data should be consistent across all instances of the
    database and hence, when queried, should provide a coherent result across all
    nodes'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：数据在所有数据库实例中应该保持一致，因此，当查询时，应该在所有节点上提供一致的结果。'
- en: '**Availability**: Irrespective of the state of any individual node, the system
    will always respond with a result upon a query being executed (whether or not
    it is the most recent commit)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：无论任何单个节点的状态如何，系统在执行查询时总是会给出结果（无论是否为最新的提交）'
- en: '**Partition tolerance**: This implies that when nodes are separated across
    a network, the system should continue to function normally even if any node loses
    interconnectivity to another node'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区容忍性**：这意味着，当节点分布在网络上时，即使某个节点失去与另一个节点的连接，系统也应该继续正常运行。'
- en: It might be evident from this that, since in a cluster nodes will be connected
    over a *network* which, by nature can be disrupted, partition tolerance has to
    be guaranteed in order for the system to continue performing normally. In this
    case, the contention lies with choosing between consistency and availability.
    For example, if the system has to be consistent; that is, show the most recent
    commit across all nodes, all the nodes cannot be *available* all at the same time
    as some nodes might not have the most recent commit. In this case, a query on
    a new update will not execute until all nodes have been updated with the new data.
    In case of availability, in similar terms, we cannot guarantee consistency, since
    to be available at all times means that some nodes will not have the same data
    as another node if a new update has not been written onto the respective node.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点来看，可以明显看出，既然在集群中节点通过*网络*连接，而网络本身可能会发生中断，因此必须保证分区容忍性，以确保系统能够继续正常运行。在这种情况下，争论的焦点在于选择一致性还是可用性。例如，如果系统必须保证一致性；也就是说，在所有节点中显示最新的提交，那么所有节点就无法在同一时间内都是*可用的*，因为某些节点可能没有最新的提交。在这种情况下，新的更新查询将不会执行，直到所有节点都更新了新数据。而在保证可用性的情况下，类似地，我们无法保证一致性，因为为了始终可用，某些节点可能没有与其他节点相同的数据，如果某个节点未写入新更新的数据。
- en: There is a great deal of confusion as well as contention between deciding on
    whether to ensure consistency or to ensure availability, and as such databases
    have been categorized as being either **CP** or **AP**. For the purpose of this
    exercise, we need not get caught up in the terminologies as that would lead to
    a rather abstract and philosophical discussion. The information on the aforementioned
    terminologies has been primarily provided to reflect upon some of the foundational
    theories driving the development of databases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保一致性和确保可用性之间的选择中，存在着大量的困惑和争论，因此数据库被分类为**CP**或**AP**。为了本次讨论，我们不必纠结于这些术语，因为那样会引入一种相对抽象和哲学性的讨论。提供上述术语的主要目的是为了反映一些推动数据库发展的基础理论。
- en: The need for NoSQL technologies
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对NoSQL技术的需求
- en: While most database systems were initially designed to manage transactions,
    the growth of internet-related technologies and new types of data that did not
    require the strict puritan nature of transactional systems necessitated the development
    of alternative frameworks.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数数据库系统最初是为了管理事务而设计的，但互联网相关技术的增长以及新型数据的出现，这些数据并不需要事务系统的严格要求，因此需要开发替代的框架。
- en: 'For instance, storing the following types of data does not necessarily require
    a complex *transactional database*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，存储以下类型的数据并不一定需要复杂的*事务数据库*：
- en: Emails
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件
- en: Media such as audio/video files
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体文件，例如音频/视频文件
- en: Social network messages
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交网络消息
- en: Website HTML pages
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站HTML页面
- en: Many others
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多其他特性
- en: 'Additionally, the increase in users, and as a consequence, data volume, signaled
    the need for developing more robust architectures with the following characteristics:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用户数量的增加，以及由此带来的数据量增加，意味着需要开发更为强大的架构，具备以下特点：
- en: Scalable to manage ever increasing data volume
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性，以应对不断增长的数据量
- en: Leverage commodity hardware to decrease dependency on expensive hardware
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用普通硬件来减少对昂贵硬件的依赖
- en: Provide distributed processing capability across multiple nodes to process large-scale
    datasets
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供跨多个节点的分布式处理能力，以处理大规模数据集
- en: Be fault-tolerant/provide high availability to handle node and site failures
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具备容错能力/提供高可用性以应对节点和站点故障
- en: Scalable implies that the system can accommodate the increase in data volume
    by increasing the number of nodes, namely, by scaling horizontally. Further, increasing
    the number of nodes should have minimal impact on the performance of the system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性意味着系统能够通过增加节点数量来容纳数据量的增长，也就是通过横向扩展来实现。此外，增加节点数量应该对系统的性能影响最小。
- en: Fault-tolerant implies that the system should be able to handle node failures,
    which won't be uncommon in a large distributed system with hundreds if not thousands
    of nodes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 容错性意味着系统应该能够处理节点故障，这在拥有数百甚至数千个节点的大型分布式系统中并不罕见。
- en: This led to the development of various groundbreaking and influential systems,
    of which perhaps the most notable were Google Bigtable and Amazon Dynamo.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这促使了多种开创性和有影响力的系统的开发，其中最著名的可能是 Google Bigtable 和 Amazon Dynamo。
- en: Google Bigtable
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Bigtable
- en: 'Bigtable was a project that was initiated in 2004 to manage both scalability
    and performance of the data used for various projects at Google. The seminal paper
    that describes the characteristics of the system was released in 2006 ([https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf](https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf)) titled
    *Bigtable: A Distributed Storage System for Structured Data*. In essence, Bigtable
    was a *column-store* (more on this later) where each value could be uniquely identified
    using a row key, a column key, and a timestamp. It was one of the first mainstream
    databases that epitomized the benefits of storing data in a columnar format rather
    than using the more common row-based layout. Although columnar databases such
    as kdb+ and Sybase IQ existed prior to Bigtable, the use of the method by an industry
    leader to manage petabyte-scale information brought the concept into the limelight.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'Bigtable 是一个在 2004 年启动的项目，旨在管理 Google 各个项目中使用的数据的可扩展性和性能。描述该系统特性的开创性论文于 2006
    年发布 ([https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf](https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf))，标题为
    *Bigtable: A Distributed Storage System for Structured Data*。从本质上讲，Bigtable 是一个
    *列式存储*（稍后会详细介绍），其中每个值都可以通过行键、列键和时间戳唯一标识。它是首批主流数据库之一，体现了将数据存储在列式格式中的优势，而非使用更常见的行式布局。尽管在
    Bigtable 之前，像 kdb+ 和 Sybase IQ 这样的列式数据库已经存在，但行业领导者使用该方法管理 PB 级别的信息，使得这一概念备受关注。'
- en: 'The official site of Bigtable summarizes the key-value proposition:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Bigtable 官方网站总结了其关键价值主张：
- en: Bigtable is designed to handle massive workloads at consistent low latency and
    high throughput, so it's a great choice for both operational and analytical applications,
    including IoT, user analytics, and financial data analysis.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Bigtable 被设计用来处理大规模工作负载，保持一致的低延迟和高吞吐量，因此它是操作性和分析性应用的理想选择，包括物联网、用户分析和金融数据分析。
- en: Since the introduction of Bigtable, several other NoSQL databases adopted the
    convention of columnar data layout; most notably HBase and Accumulo, which are
    both Apache projects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Bigtable 推出以来，其他一些 NoSQL 数据库也采纳了列式数据布局的惯例；最著名的有 HBase 和 Accumulo，它们都是 Apache
    项目。
- en: The Bigtable solution is today available for use at [https://cloud.google.com/bigtable/](https://cloud.google.com/bigtable/)
    where it can be purchased on a subscription basis. The fee for smaller amounts
    of data is quite nominal and reasonable, whereas larger installations would require
    more extensive implementations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Bigtable 解决方案可以通过 [https://cloud.google.com/bigtable/](https://cloud.google.com/bigtable/)
    使用，并可按订阅方式购买。对于较小的数据量，费用非常低廉且合理，而较大的安装则需要更为复杂的实施方案。
- en: Amazon Dynamo
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Amazon Dynamo
- en: Shortly after Google announced Bigtable, Amazon followed with the announcement
    of its internal Dynamo database at the 21st ACM Symposium on Operating Systems
    Principles held in October, 2007 ([http://www.sosp2007.org](http://www.sosp2007.org)).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google 宣布 Bigtable 后不久，Amazon 在 2007 年 10 月举行的第 21 届 ACM 操作系统原理研讨会上宣布了其内部的
    Dynamo 数据库 ([http://www.sosp2007.org](http://www.sosp2007.org))。
- en: In the paper, now available on Werner Vogels' site at [http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf](http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf),
    Amazon described a key-value store called Dynamo that was used to power some of
    Amazon's most critical internal services such as S3 on AWS. The paper brought
    to bear some key concepts such as key-value storage, consistent hashing, and vector
    clocks, among others, that were implemented in Dynamo.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在论文中（现已在 Werner Vogels 的网站上发布，网址为 [http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf](http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf)），亚马逊描述了一种名为
    Dynamo 的键值存储，用于支撑亚马逊一些最关键的内部服务，如 AWS 上的 S3。论文提出了一些关键概念，如键值存储、一致性哈希和向量时钟等，这些概念都在
    Dynamo 中得到了实现。
- en: Thus, Dynamo offered an alternative to Bigtable's columnar storage for large-scale
    datasets by introducing a fundamentally different method that leveraged key-value
    associations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Dynamo 提供了一种替代 Bigtable 列式存储的大规模数据集存储方法，采用了一种根本不同的方法，利用了键值对的关联。
- en: In the next few sections, we will discuss the various types of NoSQL technologies
    and how each of them has characteristics that make them optimal for certain use
    cases. NoSQL has ushered in a paradigm shift in how we treat databases, and has
    provided a much-needed alternative view to data management at a scale that was
    not feasible previously.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论各种类型的 NoSQL 技术，以及它们各自具有的特点，使它们在某些用例中最为优化。NoSQL 引领了数据库处理方式的范式转变，为大规模数据管理提供了此前不可行的、迫切需要的替代视角。
- en: NoSQL databases
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL 数据库
- en: 'In our discussion of NoSQL types and databases, we will primarily focus on
    the following characteristics of NoSQL databases:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 NoSQL 类型和数据库时，我们将主要关注以下几个 NoSQL 数据库的特点：
- en: In-memory databases
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存数据库
- en: Columnar databases
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列式数据库
- en: Document-oriented databases
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向文档的数据库
- en: Key-value databases
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值数据库
- en: Graph databases
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据库
- en: Other NoSQL types and summary
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他 NoSQL 类型及总结
- en: Most types of NoSQL used in the industry today fall into one or more of these
    categories. The next few sections will discuss the high-level properties of each
    of these NoSQL offerings, their main advantages, and products in the market that
    fall into the respective categories.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 目前业界使用的大多数 NoSQL 类型都属于这些类别中的一种或多种。接下来的几节将讨论每种 NoSQL 提供的高级特性、主要优势，以及市场上符合这些类别的产品。
- en: In-memory databases
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存数据库
- en: '**In-memory databases**, as the name implies, leverage the computer memory;
    that is, the RAM, to store datasets. Before we look into how in-memory databases
    work, it would be worthwhile to recollect how data transfer happens in a typical
    computer:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存数据库**，顾名思义，利用计算机内存，也就是 RAM，来存储数据集。在深入了解内存数据库如何工作之前，回顾一下数据如何在典型计算机中传输是很有意义的：'
- en: '![](img/6a7357ec-76ba-4ba4-a9b8-957b76539cb5.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a7357ec-76ba-4ba4-a9b8-957b76539cb5.png)'
- en: Simple Data Flow Computer Hierarchy
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 简单数据流计算机层次结构
- en: As shown in the preceding image, data traverses from disk to memory to the CPU.
    This is a very high-level generalization of the exact process as there are conditions
    under which the CPU does not need to send an instruction to read data from memory
    (such as when the data is already present in the CPU L2 Cache - a part of the
    CPU that contains memory reserved for caching data), but fundamentally the process
    is linear between the CPU, RAM, and disk.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，数据从磁盘传输到内存，再到 CPU。这是对实际过程的高度概括，实际上，在某些情况下，CPU 不需要发送指令来从内存读取数据（例如，当数据已经存在于
    CPU L2 缓存中——CPU 内部用于缓存数据的内存区域时），但基本上，CPU、RAM 和磁盘之间的过程是线性的。
- en: Data that is stored on disk can be transferred to the memory at a certain rate
    that is dependent on the I/O (Input/Output) throughput of the disk. It takes approximately
    10-20 milliseconds (ms) to access data from disk. While the exact number varies
    depending on the size of the data, the minimum seek time (time for the disk to
    find the location of the data) in itself is approximately 10-15 ms. Compare this
    with the time it takes to fetch data from memory, which is approximately 100 nanoseconds.
    Finally, it takes approximately 7 ns to read data from the CPU L2 Cache.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在磁盘上的数据可以以一定的速率转移到内存中，这个速率取决于磁盘的 I/O（输入/输出）吞吐量。从磁盘访问数据大约需要 10-20 毫秒（ms）。虽然具体数字会根据数据的大小而有所不同，但磁盘寻址时间（磁盘找到数据位置的时间）大约为
    10-15 毫秒。与此相比，从内存中获取数据的时间大约为 100 纳秒。最后，从 CPU L2 缓存读取数据大约需要 7 纳秒。
- en: To put this into perspective, the disk access time of 15 milliseconds, namely,
    15,000,000 nanoseconds is 150,000 times *slower* than the time it takes to access
    data from memory. In other words, data that is already present in memory can be
    read at an astounding 150 thousand times faster relative to disk. This is essentially
    true of reading random data. The time to read sequential data is arguably less
    sensational, but still nearly an order of magnitude faster.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更直观地理解，磁盘访问时间 15 毫秒，即 15,000,000 纳秒，比从内存访问数据的时间要*慢*150,000 倍。换句话说，已经存在内存中的数据读取速度是磁盘的
    15 万倍。这对于读取随机数据来说尤其真实。虽然读取顺序数据的时间可能不那么震撼，但仍然快了将近一个数量级。
- en: If the disk and RAM were represented as cars, the RAM *car* would have gone
    all the way to the moon and be on its way back in the time it would take the disk
    car to go barely two miles. That is how large the difference is.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将磁盘和内存比作汽车，那么内存的*汽车*将一路飞到月球，并且在磁盘汽车仅行驶不到两英里的时间内已经返回。这就是差距的巨大。
- en: Hence, it is natural to conclude from this that if the data were stored in RAM,
    especially in the case of larger datasets, the access time would be dramatically
    lower, and consequently the time to process the data (at least on the I/O level)
    would be significantly reduced.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从这一点得出结论，如果数据存储在内存中，尤其是在处理更大数据集的情况下，访问时间将显著降低，因此处理数据的时间（至少在 I/O 层面上）将大幅减少。
- en: Traditionally, all data in terms of databases was stored on disk. With the advent
    of the internet, the industry started leveraging *memcached,* which provided a
    means to store data in key-value pairs in memory via an API. For example, it was,
    and still is, common for MySQL databases to leverage the memcached API to cache
    objects in memory to optimize read speeds as well as reduce the load on the primary
    (MySQL) database.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，所有数据库中的数据都存储在磁盘上。随着互联网的到来，业界开始利用*memcached*，它通过 API 提供了一种将数据以键值对形式存储在内存中的方式。例如，MySQL
    数据库通常使用 memcached API 将对象缓存到内存中，以优化读取速度并减少对主数据库（MySQL）的负载，这在过去和现在都很常见。
- en: However, as data volumes started to increase, the complexity of using the database
    and memcached method started to take it's toll, and databases that were exclusively
    designed to store data in memory (and sometimes both on disk and in memory) were
    being developed at a rapid pace.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着数据量的增加，使用数据库和 memcached 方法的复杂性开始显现，专门设计用于存储内存数据（有时是同时存储在磁盘和内存中的数据库）的解决方案也在迅速发展。
- en: As a result, in-memory databases such as Redis started replacing memcached as
    the fast cache store for driving websites. In the case of Redis, although the
    data would be held in memory as key-value pairs, there was an option to persist
    the data on disk. This differentiated it from solutions such as memcached that
    were strictly memory caches.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，像 Redis 这样的内存数据库开始取代 memcached，成为驱动网站的快速缓存存储。以 Redis 为例，尽管数据会作为键值对保存在内存中，但它提供了将数据持久化到磁盘的选项。这使其与像
    memcached 这样的仅限内存缓存解决方案有所不同。
- en: 'The primary drivers of the move towards in-memory databases can be summarized
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 向内存数据库迁移的主要驱动力可总结如下：
- en: Complexity of managing increasing volumes of data such as web traffic by the
    traditional, for example, MySQL + memcached combination
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理越来越多数据（如网页流量）的复杂性，例如，传统的 MySQL + memcached 组合
- en: Reduced RAM costs, making it more affordable to purchase larger sizes
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低了内存成本，使得购买更大内存成为可能
- en: Overall industry drive towards NoSQL technologies that led to increased focus
    and community participation towards the development of newer, innovative database
    platforms
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个行业向 NoSQL 技术的推动导致了更多的关注和社区参与，促进了新的创新数据库平台的发展。
- en: Faster data manipulation in memory provided a means to reduce I/O overhead in
    situations that demanded ultra-fast, low-latency processing of data
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存中更快速的数据操作为那些要求超高速、低延迟数据处理的场景提供了减少 I/O 开销的手段。
- en: 'Today, some of the leading options for databases that provide in-memory capabilities
    in the industry include:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，业内提供内存能力的领先数据库选项包括：
- en: '| **Open source** | **Commercial** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **开源** | **商业** |'
- en: '| Redis | Kdb+ |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| Redis | Kdb+ |'
- en: '| memcacheDB | Oracle TimesTen |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| memcacheDB | Oracle TimesTen |'
- en: '| Aerospike | SAP HANA |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| Aerospike | SAP HANA |'
- en: '| VoltDB | HP Vertica |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| VoltDB | HP Vertica |'
- en: '| Apache Ignite | Altibase |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| Apache Ignite | Altibase |'
- en: '| Apache Geode | Oracle Exalytics |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| Apache Geode | Oracle Exalytics |'
- en: '| MonetDB | MemSQL |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| MonetDB | MemSQL |'
- en: Note that some of these support hybrid architectures whereby data can reside
    in memory as well as on disk. In general, data would be transferred from memory
    to disk for persistence. Also, note that some commercial in-memory databases offer
    community editions that can be downloaded and used at no charge within the terms
    of the licenses applicable to the respective solution. In these cases, they are
    both open source as well as commercial.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些数据库有些支持混合架构，数据既可以驻留在内存中，也可以存储在磁盘上。一般来说，数据会从内存转移到磁盘中以实现持久化。另外，需要注意的是，一些商业内存数据库提供了社区版，可以在符合各自许可证的前提下免费下载并使用。在这些情况下，它们既是开源的，又是商业的。
- en: Columnar databases
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列式数据库
- en: Columnar databases have existed since the 90s, but came to prominence after
    the release of Google Bigtable as mentioned earlier. They are, in essence, a method
    of storing data that is optimized for querying very large volumes of data in a
    fast and efficient manner relative to row-based/tuple-based storage.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列式数据库自90年代以来就已经存在，但在Google Bigtable发布后（如前所述）才开始受到广泛关注。它们本质上是一种数据存储方式，相较于基于行/元组的存储方式，它优化了查询大量数据的速度和效率。
- en: The benefits of columnar databases, or more concretely storing each column of
    data independently, can be illustrated with a simple example.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列式数据库的好处，或者更具体地说，将每列数据独立存储，可以通过一个简单的例子来说明。
- en: Consider a table consisting of 100 million household addresses and phone numbers.
    Consider also a simple query that requires the user to find the number of households
    in the state of New York, in the city of Albany, built after 1990\. We'll create
    a hypothetical table to illustrate the difference in querying the data row by
    row versus column by column.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个包含1亿个家庭地址和电话号码的表。还假设有一个简单查询，要求用户找到纽约州、奥尔巴尼市且建造年份大于1990年的家庭数量。我们将创建一个假设的表来说明按行查询与按列查询数据之间的差异。
- en: '**Hardware characteristics**:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬件特性**：'
- en: 'Average disk read speed: 200 MB per second'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 平均磁盘读取速度：每秒200 MB
- en: '**Database characteristics**:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库特性**：'
- en: 'Table name: `housedb`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表名：`housedb`
- en: Total rows = 100 million
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总行数 = 1 亿
- en: Total rows with State NY = Two million
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态为纽约（State NY）的总行数 = 两百万
- en: Total rows with State NY and City Albany = 10,000
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态为纽约（State NY）且城市为奥尔巴尼（City Albany）的总行数 = 10,000
- en: Total rows with State NY and City Albany and YearBuilt > 1990 = 500
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态为纽约（State NY）、城市为奥尔巴尼（City Albany）且建造年份大于1990年的总行数 = 500
- en: '**Data size**:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据大小**：'
- en: 'Let us assume that the size of each of the data of each row is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每行数据的大小如下：
- en: PlotNumber, YearBuilt each = 8 bytes = total 16 bytes
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PlotNumber, YearBuilt 每个 = 8 字节 = 总计 16 字节
- en: Owner, Address, State and City each = 12 bytes = Total 48 bytes
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Owner、Address、State 和 City 每个 = 12 字节 = 总计 48 字节
- en: Net size in bytes of each row = 16 + 48 = 64 bytes
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行的净大小（字节）= 16 + 48 = 64 字节
- en: Note that the actual size will be higher, as there are several other considerations
    such as indexing and other table optimizations and related overheads that we won't
    consider here for the sake of simplicity.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，实际大小会更高，因为还有其他几个因素需要考虑，如索引、其他表的优化和相关的开销，我们为了简化起见这里不做考虑。
- en: We will also assume that the columnar database maintains an implicit row index
    that permits querying the data at certain indices in each column *vector*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设列式数据库维持一个隐式的行索引，允许在每个列的*向量*中查询某些索引的数据。
- en: 'The following table shows the first 4 records:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示前4条记录：
- en: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    |'
- en: '| 1 | John | 1 Main St. | WA | Seattle | 1995 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 1 | John | 1 Main St. | WA | Seattle | 1995 |'
- en: '| 2 | Mary | 20 J. Ave. | NY | Albany | 1980 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Mary | 20 J. Ave. | NY | Albany | 1980 |'
- en: '| 3 | Jane | 5 45^(th) St. | NY | Rye Brook | 2001 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Jane | 5 45^(th) St. | NY | Rye Brook | 2001 |'
- en: '| 4 | John | 10 A. Blvd. | CT | Stamford | 2010 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 4 | John | 10 A. Blvd. | CT | Stamford | 2010 |'
- en: 'In total, the table has 100 million records. The last few are shown as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，该表有1亿条记录。最后几条记录如下所示：
- en: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    |'
- en: '| 99999997 | Jim | 23 B. Lane | NC | Cary | 1995 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 99999997 | Jim | 23 B. Lane | NC | Cary | 1995 |'
- en: '| 99999998 | Mike | 5 L. Street | NY | Syracuse | 1993 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 99999998 | Mike | 5 L. Street | NY | Syracuse | 1993 |'
- en: '| 99999999 | Tim | 10 A. Blvd. | NY | Albany | 2001 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 99999999 | Tim | 10 A. Blvd. | NY | Albany | 2001 |'
- en: '| 100000000 | Jack | 10 A. Blvd. | CT | Stamford | 2010 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 100000000 | Jack | 10 A. Blvd. | CT | Stamford | 2010 |'
- en: 'The query we will run against this dataset is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此数据集上运行的查询如下：
- en: '[PRE0]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Scenario A: Searching row by row**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景A：按行搜索**'
- en: 'In the first scenario, if we did a naïve row-by-row search, since the data
    for each column is not stored separately, but the data for each row is scanned,
    we would have to query across:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个场景中，如果我们进行简单的逐行搜索，由于每列的数据并没有单独存储，而是扫描每行的数据，我们必须遍历以下内容：
- en: 100 million * 64 bytes (size of each row in bytes) = 6,400 million bytes = approximately
    6000 MB of data
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 1亿 * 64字节（每行数据的大小）= 64亿字节 = 约6000 MB的数据
- en: At a disk read speed of say, 200 MBps, this means it would take approximately
    6000 / 200 = 30 seconds to read all the records to find the matching entries.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设磁盘读取速度为200 MBps，这意味着读取所有记录找到匹配项大约需要6000 / 200 = 30秒。
- en: '**Scenario B: Searching column by column**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景B：逐列搜索**'
- en: 'Assuming each column of data resides in individual files representing the respective
    columns, we will look each where clause individually:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每列数据分别存储在代表各自列的单独文件中，我们将分别查看每个Where子句：
- en: '[PRE1]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Where clause part 1**: `where State like ''NY''`'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Where 子句部分 1**: `where State like ''NY''`'
- en: The State column, as described earlier, has 100 million entries each of size
    12 bytes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，State列有1亿条，每条记录大小为12字节。
- en: 'In this case, we only need to search across:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需要遍历以下内容：
- en: 100 million * 12 bytes = 1,200 million bytes = 1,000 MB of data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 1亿 * 12字节 = 12亿字节 = 1000 MB的数据。
- en: At a data read rate of 200 MBps, this would take 200 MB, and it would take 1000
    / 200 = 5 seconds to read the column of data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在200 MBps的数据读取速率下，这将读取200 MB数据，读取该数据列需要1000 / 200 = 5秒。
- en: This returns two million records (as noted earlier database characteristics)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回200万条记录（如前所述，数据库特性）
- en: '**Where clause part 2**: `City like ''Albany''`'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Where 子句部分 2**: `City like ''Albany''`'
- en: In the preceding step, we had narrowed our window of search to two million records
    that satisfied the criteria of State NY. In the second where clause step, now,
    we need not query across all 100 million records. Instead, we can simply look
    at the two million records that satisfied the criteria to determine which ones
    belong to City Albany.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一步中，我们已将搜索窗口缩小为符合State NY条件的200万条记录。在第二个Where子句步骤中，现在我们不需要遍历所有1亿条记录。相反，我们只需查看符合条件的200万条记录，确定哪些属于City
    Albany。
- en: 'In this case, we only need to search across:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需要遍历以下内容：
- en: '*2 million * 12 bytes = 24 million bytes = approximately 20 MB of data*.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*200万 * 12字节 = 2400万字节 = 约20 MB的数据*。'
- en: At a data read rate of 200 MBps, this would take 0.1 seconds.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在200 MBps的数据读取速率下，这将花费0.1秒。
- en: This returns 10,000 records (as noted earlier in Database Characteristics).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回1万条记录（如前所述，数据库特性）。
- en: '**Where clause part 3**: `YearBuilt > 1990`'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Where 子句部分 3**: `YearBuilt > 1990`'
- en: In the preceding step, we further narrowed our window of search to 10,000 records
    fulfilling both the criteria of State NY and City Albany. In this step, we will
    query 10,000 records in the YearBuilt column to find which ones fulfil the criteria
    of YearBuilt > 1990.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一步中，我们进一步将搜索窗口缩小为符合State NY和City Albany条件的1万条记录。在此步骤中，我们将查询YearBuilt列中的1万条记录，找出哪些记录符合YearBuilt
    > 1990的条件。
- en: 'In this case, we only need to search across:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需要遍历以下内容：
- en: '*10,000 * 16 bytes = 160,000 bytes = approximately 150 KB of data*.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*1万 * 16字节 = 16万字节 = 约150 KB的数据*。'
- en: At a data read rate of 200 MBps, this would take 0.00075 seconds, which we can
    round to zero seconds.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在200 MBps的数据读取速率下，这将花费0.00075秒，我们可以将其四舍五入为零秒。
- en: 'Hence, the net time spent in querying across the data was:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，查询数据的净时间为：
- en: 'Where clause part 1: `where State like ''NY''` - five seconds'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Where 子句部分 1: `where State like ''NY''` - 五秒'
- en: 'Where clause part 2: `City like ''Albany''` - 0.1 seconds'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Where 子句部分 2: `City like ''Albany''` - 0.1秒'
- en: 'Where clause part 3: `YearBuilt > 1990` - zero seconds'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Where 子句部分 3: `YearBuilt > 1990` - 零秒'
- en: Net time taken to read the data = 5.1 seconds.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据的净时间 = 5.1秒。
- en: 'Important: Note that the actual read or more specifically, scan performance,
    depends on various other factors. The **size of the tuple** (row), the time to
    reconstruct the tuple (**tuple reconstruction**), **bandwidth of memory** (how
    fast data can be read into the CPU from Main Memory, and so on), **cache line
    size** and other factors. In practice, there would be various levels of abstractions
    due to which the actual performance may be slower. Further there are other considerations
    such as hardware architecture and parallel operations that can affect positively
    or otherwise the overall performance. These topics are more advanced and require
    dedicated reading. The analysis here focuses exclusively on the disk I/O, which
    is one of the critical aspects of overall performance at a high-level.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：请注意，实际的读取或更具体地说，扫描性能，取决于其他多个因素。**元组的大小**（行）、重建元组的时间（**元组重建**）、**内存带宽**（数据从主内存读取到
    CPU 的速度，等等）、**缓存行大小**以及其他因素。在实践中，由于各种抽象层的存在，实际性能可能会更慢。此外，还有其他因素，如硬件架构和并行操作，这些也会影响整体性能，可能是积极的，也可能是负面的。这些话题属于更高级的内容，需要专门阅读。这里的分析仅专注于磁盘
    I/O，这是整体性能中的一个关键方面。
- en: The preceding example demonstrates the benefits of querying data that has been
    stored in columns from a query performance or efficiency perspective based on
    the size of the data. There is also another benefit offered by columnar data,
    which is that it allows storage of tables that may have arbitrary schema in columns.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例演示了从查询性能或效率角度，基于数据大小，从列中存储的数据进行查询的好处。列式数据还提供了另一个好处，即它允许以列的形式存储可能具有任意模式的表。
- en: 'Consider the first four rows of the prior table. If, for example, we had missing
    information in some of the rows, that would lead to sparse columns:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前表的前四行。例如，如果某些行缺少信息，这将导致列稀疏：
- en: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    |'
- en: '| 1 | John | 1 Main St. | *NULL* | Seattle | 1995 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 1 | John | 1 Main St. | *NULL* | Seattle | 1995 |'
- en: '| 2 | Mary | 20 J. Ave. | NY | *NULL* | *NULL* |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Mary | 20 J. Ave. | NY | *NULL* | *NULL* |'
- en: '| 3 | Jane | *NULL* | NY | Rye Brook | *NULL* |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Jane | *NULL* | NY | Rye Brook | *NULL* |'
- en: '| 4 | John | 10 A. Blvd. | CT | *NULL* | *NULL* |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 4 | John | 10 A. Blvd. | CT | *NULL* | *NULL* |'
- en: 'Instead of populating NULL values, we can instead create a `Column Family`
    called `Complete_Address` that can contain an arbitrary number of key-value pairs
    corresponding to only those fields that have corresponding data:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与其填充 NULL 值，不如创建一个名为 `Column Family` 的列族，名为 `Complete_Address`，其中可以包含任意数量的键值对，仅对应那些有数据的字段：
- en: '| **PlotNumber** | **Owner** | **Complete_Address** |  | **YearBuilt** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **PlotNumber** | **Owner** | **Complete_Address** |  | **YearBuilt** |'
- en: '| 1 | John | Address: 1 Main St. | City: Seattle | 1995 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 1 | John | 地址：1 Main St. | 城市：Seattle | 1995 |'
- en: '| 2 | Mary | Address: 20 J. Ave. | State: NY | *NULL* |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Mary | 地址：20 J. Ave. | 州：NY | *NULL* |'
- en: '| 3 | Jane | State: NY | City: Rye Brook | *NULL* |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Jane | 州：NY | 城市：Rye Brook | *NULL* |'
- en: '| 4 | John | Address: 10 A. Blvd. | State: CT | *NULL* |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 4 | John | 地址：10 A. Blvd. | 州：CT | *NULL* |'
- en: 'A third and very important benefit offered by columnar databases is the ability
    to retrieve data based on three keys: a row key, a column key, and a timestamp
    that uniquely identifies each record, permitting very fast access to the data
    in question.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列式数据库提供的第三个、也是非常重要的好处是，能够基于三个关键字来检索数据：行键、列键和唯一标识每条记录的时间戳，这使得我们可以非常快速地访问相关数据。
- en: 'For example, since the Owner field can change when the property (PlotNumber)
    is sold, we can add another field that denotes the date of the record; that is,
    the date that the record corresponds to. This would allow us to distinguish among
    properties that had a change of ownership whilst all the other data remained the
    same:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于业主字段在财产（PlotNumber）出售时可能会发生变化，我们可以添加另一个字段来表示记录的日期；即该记录对应的日期。这样我们就能区分那些发生过所有权变更的房产，尽管其他数据保持不变：
- en: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    | **RecordDate** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **PlotNumber** | **Owner** | **Address** | **State** | **City** | **YearBuilt**
    | **RecordDate** |'
- en: '| 1 | John | 1 Main St. | WA | Seattle | 1995 | 2001.04.02 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 1 | John | 1 Main St. | WA | Seattle | 1995 | 2001.04.02 |'
- en: '| 2 | Mary | 20 J. Ave. | NY | Albany | 1980 | 2007.05.30 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Mary | 20 J. Ave. | NY | Albany | 1980 | 2007.05.30 |'
- en: '| 3 | Jane | 5 45^(th) St. | NY | Rye Brook | 2001 | 2001.10.24 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Jane | 5 45^(th) St. | NY | Rye Brook | 2001 | 2001.10.24 |'
- en: '| 4 | John | 10 A. Blvd. | CT | Stamford | 2010 | 2003.07.20 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 4 | John | 10 A. Blvd. | CT | Stamford | 2010 | 2003.07.20 |'
- en: 'Since there can be multiple records for each PlotNumber to accommodate change
    of ownership, we can now define three keys that could uniquely identify each cell
    of data in each record, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个 PlotNumber 可能有多条记录来适应所有权变更，我们现在可以定义三个键来唯一标识每条记录中的每个数据单元，具体如下：
- en: 'Row key: `PlotNumber`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行键：`PlotNumber`
- en: 'Column key: The column name'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列键：列名
- en: 'Timestamp key: `RecordDate`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳键：`RecordDate`
- en: Each cell in each record in the table will thus have a unique three-value pair
    that distinguishes it from the other cells.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每个记录表中的每个单元格将具有唯一的三值对，这使其与其他单元格区别开来。
- en: Databases such as Bigtable, Cassandra, and others employ this method to perform
    data analysis at scale both expeditiously and efficiently.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Bigtable、Cassandra 等数据库采用这种方法，在大规模数据分析中既快速又高效。
- en: 'Some of the popular columnar databases are listed as follows. Note that there
    may be repetitions as databases can have multiple NoSQL properties (such as both
    in-memory and columnar):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些流行的列式数据库。请注意，可能会有重复项，因为数据库可以具有多种 NoSQL 属性（例如，既支持内存数据库也支持列式数据库）：
- en: '| **Open source** | **Commercial** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **开源** | **商业** |'
- en: '| Apache Parquet | Kdb+ |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| Apache Parquet | Kdb+ |'
- en: '| MonetDB | Teradata |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| MonetDB | Teradata |'
- en: '| MariaDB | SAP HANA |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| MariaDB | SAP HANA |'
- en: '| Druid | HP Vertica |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| Druid | HP Vertica |'
- en: '| HBase | Oracle Exadata |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| HBase | Oracle Exadata |'
- en: '| Apache Kudu | ParAccel |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| Apache Kudu | ParAccel |'
- en: '| Apache Arrow | Actian Vector |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| Apache Arrow | Actian Vector |'
- en: Document-oriented databases
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向文档的数据库
- en: '**Document-based or document-oriented** databases became prominent as a means
    of storing data that had variable structures; that is, there was no fixed schema
    that each record would fit into all the time. Additionally, the document may have
    both a structured as well as an *unstructured* part.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于文档或文档导向**的数据库成为了一种存储具有可变结构的数据的主要方式；也就是说，每条记录并不总是符合固定模式。此外，文档中可能同时包含结构化和*非结构化*部分。'
- en: Structured data is, in essence, data that can be stored in a tabular format
    such as in a spreadsheet. Data stored in Excel spreadsheets or MySQL tables all
    belong to the class of structured datasets. Data that cannot be represented in
    a strict tabular format such as books, audio files, video files, or social network
    messages are considered unstructured data. As such, in document-oriented databases,
    we will primarily work with structured and unstructured text data.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化数据本质上是可以以表格格式存储的数据，例如电子表格中的数据。存储在 Excel 电子表格或 MySQL 表中的数据都属于结构化数据集。无法以严格的表格格式表示的数据，如书籍、音频文件、视频文件或社交网络消息，都被视为非结构化数据。因此，在面向文档的数据库中，我们主要处理结构化和非结构化文本数据。
- en: 'An intuitive explanation of data that can contain both structured and unstructured
    text can be found in the example of a **phone diary**. Although these have become
    increasingly rare with the growth of digital data storage, many of us would remember
    a time when phone numbers were written in pocketbooks. The following image shows
    how we store data in a phone diary:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 解释数据的直观方式可以通过**电话日志**的例子来理解，数据可以同时包含结构化和非结构化文本。尽管随着数字数据存储的发展，这类日志变得越来越稀少，但我们中的许多人仍会记得曾经在口袋本上写下电话号码的时代。下图展示了我们如何在电话日志中存储数据：
- en: '![](img/1c2e56c2-7734-46a1-9bf9-4e35cd49d90a.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c2e56c2-7734-46a1-9bf9-4e35cd49d90a.png)'
- en: Address Book (Semi-Structured Dataset)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 地址簿（半结构化数据集）
- en: 'In the preceding example, the following fields can be considered as structured:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，以下字段可以被视为结构化字段：
- en: Name
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓名
- en: Address
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址
- en: Tel and Fax
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话和传真
- en: There is a line underneath the Address field where the user can enter arbitrary
    information, for example, met at a conference in 2015, works at company abc. This
    is essentially a note that the diary keeper wrote when entering the specific information.
    Since there is no defining characteristic of a free-form field such as this, it
    could also contain information such as a second phone number, or an alternative
    address and other information. This would qualify as an unstructured text.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在地址字段下方有一条空白线，用户可以在此输入任意信息，例如：2015年在会议上见过，现工作于abc公司。这本质上是日记维护者在输入具体信息时写下的注释。由于这种自由格式字段没有明确的特征，它也可以包含第二个电话号码、备用地址等信息，这类信息就属于非结构化文本。
- en: Further, since the other fields are not interdependent, a user may write the
    address but not the phone number, or the name and phone number but not the address.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于其他字段并不相互依赖，用户可以只填写地址而不填写电话号码，或者填写姓名和电话号码而不填写地址。
- en: A document-oriented database, by virtue of its ability to store schema-free
    data; that is, data that does not conform to any fixed schema such as fixed columns
    with fixed datatypes, would hence be an appropriate platform to store this information.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 文档型数据库凭借其存储无模式数据的能力；即，存储不符合任何固定模式的数据，如具有固定数据类型的固定列，因此成为存储此类信息的合适平台。
- en: As such, since a phone diary contains a much smaller volume of data, in practice,
    we could store it in other formats, but the necessity for document-oriented datasets
    becomes apparent when we are working with large-scale data containing both structured
    and unstructured information.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于电话日记包含的数据量要小得多，在实践中我们可以将其存储在其他格式中，但当我们处理包含结构化和非结构化信息的大规模数据时，文档型数据集的必要性变得显而易见。
- en: 'Using the example of a phone diary, the data could be stored in a document-oriented
    dataset in JSON format, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以电话日记为例，数据可以以JSON格式存储在文档型数据集中，具体如下：
- en: '[PRE2]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**JSON**, which stands for **J**ava**S**cript **O**bject **N**otation, provides
    a means of representing data in a portable text-based key-value pair format. Today,
    data in JSON is ubiquitous across the industry and has become the standard in
    storing data that does not have a fixed schema. It is also a great medium to exchange
    structured data, and as such is used for such datasets frequently.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**，即**J**ava**S**cript **O**bject **N**otation，是一种以便携文本格式表示数据的方式，采用键值对的形式。今天，JSON数据在整个行业中无处不在，并已成为存储没有固定模式的数据的标准。它也是交换结构化数据的理想媒介，因此在此类数据集的使用中非常常见。'
- en: The preceding illustration provides a basic example to convey how document-oriented
    databases work. As such, it is a very simple and hopefully intuitive example.
    In practice, document-oriented databases such as MongoDB and CouchDB are used
    to store gigabytes and terabytes of information.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的插图提供了一个基本示例，传达了文档型数据库是如何工作的。因此，这是一个非常简单且希望直观的示例。实际上，文档型数据库如MongoDB和CouchDB用于存储数千兆字节和数万兆字节的信息。
- en: For example, consider a website that stores data on users and their movie preferences.
    Each user may have multiple movies they have watched, rated, recommended, movies
    that they have added to their wishlist, and other such artifacts. In such a case,
    where there are various arbitrary elements in the dataset, many of which are optional
    and many of which might contain multiple values (for example, multiple movies
    recommended by a user), a JSON format to capture information becomes optimal.
    This is where document-oriented databases provide a superior and optimal platform
    to store and exchange data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个存储用户及其电影偏好的网站。每个用户可能有多个他们观看过的电影、评分、推荐的电影、添加到愿望清单的电影以及其他类似的条目。在这种情况下，数据集中的各个元素是任意的，其中许多是可选的，并且许多可能包含多个值（例如，用户推荐的多个电影），此时使用JSON格式来捕捉信息变得最为理想。这就是文档型数据库提供一个优越且理想的平台来存储和交换数据的原因。
- en: More concretely, databases such as MongoDB store information in BSON format
    - a binary version of JSON documents that have additional optimizations to accommodate
    datatypes, Unicode characters, and other features to improve upon the performance
    of basic JSON documents.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，像MongoDB这样的数据库以BSON格式存储信息——BSON是JSON文档的二进制版本，具有额外的优化，以适应数据类型、Unicode字符和其他功能，从而提高基本JSON文档的性能。
- en: 'A more comprehensive example of a JSON document stored in MongoDB could be
    data stored about airline passengers that contains information on numerous attributes
    specific to individual passengers, for example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在MongoDB中的JSON文档的一个更全面的例子可能是存储有关航空乘客的数据，包含与个人乘客相关的多个属性信息，例如：
- en: '[PRE3]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each entry is uniquely identified by the `_id` field, which allows us to directly
    query information relevant to the specific user and retrieve data without having
    to query across millions of records.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每条记录都由`_id`字段唯一标识，这使得我们能够直接查询与特定用户相关的信息，并无需跨数百万条记录进行查询即可检索数据。
- en: 'Today, document-oriented databases are used to store a diverse range of datasets.
    Examples include the use of such  the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，文档型数据库被用于存储各种各样的数据集。以下是一些例子：
- en: Log files and log file-related information
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志文件和与日志文件相关的信息
- en: Articles and other text-based published materials
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章和其他基于文本的出版物
- en: Geolocation data
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理定位数据
- en: User/user account-related information
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户/用户帐户相关信息
- en: Many more use cases that are optimal for document/JSON based storage
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多适合文档/JSON存储的用例
- en: 'Well-known document-oriented databases include the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 知名的文档导向数据库包括以下几种：
- en: '| **Open source** | **Commercial** |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| **开源** | **商业** |'
- en: '| MongoDB | Azure Cosmos DB |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| MongoDB | Azure Cosmos DB |'
- en: '| CouchDB | OrientDB |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| CouchDB | OrientDB |'
- en: '| Couchbase Server | Marklogic |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| Couchbase Server | Marklogic |'
- en: Key-value databases
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键值数据库
- en: '**Key-value databases** operate on the principle of structuring data as pairs
    of values corresponding to keys. To highlight the benefits of key-value databases,
    it would help to revisit the significance of hash maps, a common term prevalent
    in computer science to specify a unique data-structure that provides a constant-time
    lookup for key pairs.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**键值数据库**基于将数据结构化为与键对应的值对的原则。为了突显键值数据库的优势，回顾一下哈希映射的意义会很有帮助，哈希映射是计算机科学中常见的术语，用来指定一种独特的数据结构，该结构提供了常数时间查找键值对的能力。'
- en: 'An intuitive example for a hash table is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一个直观的哈希表示例如下：
- en: Consider a collection of 500 books and five bookcases. Each bookcase has five
    shelves. The books can be placed in an arbitrary order, but that would make it
    incredibly difficult to find a specific book and you may need to go through hundreds
    of books before locating the one you need. One method of categorizing the books
    would be to assign ranges of letters to each of the bookshelves, for example,
    A-E, F-J, K-O, P-T, U-Z, and use the first letter of the name of the book to assign
    it to a specific shelf. However, suppose you have a disproportionate number of
    books that start with the letters A-E. This means that the case assigned for A-E
    would have a much higher number of books relative to the other ones.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有500本书和五个书架，每个书架有五个书架层。书籍可以随意排列，但这样会使得找到特定的书籍变得极其困难，你可能需要翻阅数百本书才能找到你需要的那一本。一种分类书籍的方法是给每个书架分配字母范围，例如A-E、F-J、K-O、P-T、U-Z，并利用书籍名称的首字母将其分配到特定的书架。然而，假设有很多书籍的名称以A-E字母开头，那么A-E这一类书架的书籍数量将大大超过其他书架。
- en: 'A more elegant alternative could be to assign a value to each of the books
    and use the respective value to determine which bookcase or bookshelf the book
    belongs to. To assign a number, a specific value to each book, we could sum up
    the numbers corresponding to each letter of the title of the book using a range
    of 1-26 for the letters A-Z respectively:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 更优雅的替代方法是为每本书分配一个值，并利用该值来确定书籍属于哪个书架或书架层。为了给每本书分配一个数字值，我们可以通过将书名中每个字母的对应数字相加，使用1-26的范围表示A-Z字母：
- en: '![](img/57f7faff-1435-44a3-978a-116c059ef15e.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57f7faff-1435-44a3-978a-116c059ef15e.png)'
- en: Our Simple Hash Map
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单哈希映射
- en: Since we have five bookcases, each with five shelves, we have a total of 25
    shelves. One method of allocating a book to a specific shelf would be to take
    the numeric value of the book obtained by summing the letters in the title and
    dividing the value by 26\. Any number, when divided by 25, will yield a remainder
    between 0-25; that is, 26 unique values. We can use this value then to assign
    the book to a particular shelf. This then becomes our self-created hash function.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有五个书架，每个书架有五个书架层，因此我们总共有25个书架层。为书籍分配特定书架的一种方法是将书籍的数字值通过求和标题中的字母并除以26来获得。任何数字除以25后会得到0到25之间的余数；也就是说，26个独特的值。我们可以用这个值来为书籍分配一个特定的书架。这就变成了我们自创的哈希函数。
- en: Of the 25 shelves, each of them is now assigned a numeric value corresponding
    to the values 0-25 respectively, with the last shelf being assigned the values
    24 and 25\. For example, shelf zero is assigned to store books whose numeric value
    divided by 26 yields zero, shelf one is assigned to store books whose numeric
    value divided by 26 yields one, and shelf 25 is assigned to store books whose
    numeric value divided by 26 yields 24 or 25.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在25个书架中，每个书架现在都被分配了一个与数字值0-25相对应的数字值，最后一个书架被分配了24和25的值。例如，书架零分配给存储数字值除以26等于零的书籍，书架一分配给存储数字值除以26等于一的书籍，而书架25分配给存储数字值除以26等于24或25的书籍。
- en: An example will help to illustrate this concept more concretely.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子将有助于更具体地说明这一概念。
- en: 'Book name: **HAMLET**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 书名：**哈姆雷特**
- en: 'Numeric value of title:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 标题的数字值：
- en: '![](img/eb17fd9d-b49f-409b-989b-963f5b7f7594.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb17fd9d-b49f-409b-989b-963f5b7f7594.png)'
- en: Hash values
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值
- en: Sum total of the numeric value = 8 + 1 + 13 + 12 + 5 + 20 = 59
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 数字值的总和 = 8 + 1 + 13 + 12 + 5 + 20 = 59
- en: Divide number by 26 = 2, remainder seven
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字除以26 = 2，余数为7
- en: Hence, the book is assigned to shelf number seven.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这本书被分配到第七个书架层。
- en: We have essentially found a way to methodically assign a shelf to each individual
    book, and because we have a fixed rule, when a new request for a book arrives,
    we can find it almost instantaneously since we will know the shelf corresponding
    to the book.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本质上找到了一种有条理地为每本书分配书架的方法，由于我们有一个固定的规则，当新的借书请求到达时，我们几乎可以瞬间找到它，因为我们知道与书籍对应的书架。
- en: The preceding method illustrates the concept of hashing, and in practice, we
    would use a hash function that would find a unique value for each book, and assuming
    we could get an arbitrary number of bookshelves and slots in which we can place
    the books, we could simply use the plain numeric value of the book to identify
    which shelf it would belong to.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法展示了哈希的概念，实际上，我们会使用一个哈希函数来为每本书找到一个唯一的值，并且假设我们可以得到任意数量的书架和插槽来放置书籍，我们可以直接使用书本的数字值来识别它应该放在的书架上。
- en: There would be cases where two books would have the same numeric value, and
    in those cases we could stack the books in the slot corresponding to the number.
    In computer science, this effect of multiple values corresponding to a key is
    known as a collision, and in those cases we would assign multiple items by means
    of a list or similar datatype.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 会有这种情况，即两本书有相同的数字值，在这种情况下，我们可以将书堆叠在对应数字的槽位中。在计算机科学中，这种多个值对应一个键的现象称为冲突，在这种情况下，我们可以通过列表或类似的数据类型来分配多个项目。
- en: In real-life use cases, we have much more complex items to work with than the
    simple example of books. Generally, we'd use more complex hash functions that
    lower the chance of collision and accordingly assign the key-value pair. The data
    would be stored in a contiguous array in memory and hence, when a request for
    a certain key arrived, we could instantaneously find the value by using the hash
    function to identify the location in memory where the data resides.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们需要处理的项比简单的书本示例要复杂得多。通常，我们会使用更复杂的哈希函数，降低冲突的机会，并相应地分配键值对。数据会存储在内存中的连续数组中，因此，当某个键的请求到达时，我们可以通过使用哈希函数来确定数据所在内存位置，从而瞬间找到该值。
- en: Hence, using key-value pairs to store data can be immensely powerful because
    the time to retrieve information corresponding to a key can be very fast as there
    is no need to search through a long list to identify a matching key.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用键值对存储数据可以非常强大，因为检索与某个键对应的信息的时间非常快，因为不需要在长长的列表中查找匹配的键。
- en: Key-value databases employ the same principle of assigning unique keys to each
    record, and the data corresponding to each key is stored in the corresponding
    location. In our discussion of MongoDB, we saw that records were assigned a certain
    key identified by the `_id` value in each record. In practice, we could use this
    value to retrieve the corresponding data in constant time.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 键值数据库采用相同的原则，为每条记录分配唯一的键，并将与每个键对应的数据存储在相应的位置。在我们对 MongoDB 的讨论中，我们看到记录被分配了一个由每条记录中的
    `_id` 值标识的键。在实践中，我们可以使用这个值以常数时间检索对应的数据。
- en: As mentioned before, memcached used to be the preferred method to store data
    in key-value pairs for web services that required very fast access to frequently
    used data. In essence, it served as a memory cache to store temporary information.
    With the advent of NoSQL databases, new platforms that extended the limited use
    case of memcached became prominent. Solutions such as Redis offered not only the
    ability to store data in key-value pairs in memory, but also the ability to persist
    the data on disk. In addition, these key-value stores supported horizontal scaling,
    which permitted the distribution of key-value pairs across hundreds of nodes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，memcached 曾是用于存储键值对的首选方法，适用于需要非常快速访问频繁使用数据的 web 服务。实际上，它作为一个内存缓存，用于存储临时信息。随着
    NoSQL 数据库的出现，新平台扩展了 memcached 限制性用例的应用。像 Redis 这样的解决方案不仅提供了在内存中以键值对存储数据的能力，还提供了将数据持久化到磁盘的能力。此外，这些键值存储还支持水平扩展，使得可以将键值对分布到成百上千的节点上。
- en: The disadvantage of key-value storage was that the data could not be queried
    with the same flexibility as standard databases, which supported multiple levels
    of indexing and a more richer set of SQL commands. Nevertheless, the benefits
    of constant time lookup implied that for use cases that required a key-value structure,
    there were few other solutions that were comparable in both performance and efficiency.
    For instance, a shopping website with thousands of users could store user profile
    information in a key-value database and be able to look up individual information
    by simply applying a hash function corresponding to, for example, the user ID.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 键值存储的缺点是数据不能像标准数据库那样灵活地进行查询，后者支持多层次的索引和更丰富的 SQL 命令集。然而，常数时间查找的好处意味着，对于需要键值结构的使用场景，几乎没有其他解决方案能在性能和效率上与其相匹配。例如，一个拥有成千上万用户的购物网站可以将用户资料信息存储在键值数据库中，并通过应用一个与用户
    ID 相对应的哈希函数，轻松查找单个用户的信息。
- en: 'Today, key-value databases use a variety of methods to store data:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，键值数据库使用多种方法存储数据：
- en: '**SSTables**: A file of sorted key-value pairs represented as strings (and
    directly mapped to the **Google File System** (**GFS**)).'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSTables**：一种已排序的键值对文件，表示为字符串（并直接映射到**谷歌文件系统**（**GFS**））。'
- en: '**B-trees**: Balanced trees where values are identified by traversing along
    leaves/nodes.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B树**：平衡树，其中值是通过遍历叶子/节点来识别的。'
- en: '**Bloom filters**: A more optimal key-value method used when the number of
    keys is high. It uses multiple hash functions to set the bit-value to one in an
    array corresponding to keys.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布隆过滤器**：一种更优化的键值方法，适用于键数量较多的情况。它使用多个哈希函数将对应于键的数组中的位值设置为 1。'
- en: '**Shards**: A process involving partitioning data across multiple nodes.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分片**：一种将数据分布到多个节点上的过程。'
- en: 'Well known key-value databases include:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 知名的键值数据库包括：
- en: '| **Open source** | **Commercial** |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **开源** | **商业** |'
- en: '| Redis | Amazon DynamoDB |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| Redis | Amazon DynamoDB |'
- en: '| Cassandra | Riak |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| Cassandra | Riak |'
- en: '| Aerospike | Oracle NoSQL |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| Aerospike | Oracle NoSQL |'
- en: '| Apache Ignite | Azure Cosmos DB |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| Apache Ignite | Azure Cosmos DB |'
- en: '| Apache Accumulo | Oracle Berkeley DB |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| Apache Accumulo | Oracle Berkeley DB |'
- en: Graph databases
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形数据库
- en: '**Graph databases** provide an efficient representation of data with records
    that have inter-relationships. Typical examples are your social network friend
    list, LinkedIn contacts, Netflix movie subscribers. By leveraging optimized algorithms
    for searching on tree-based/graph data structures, graph databases can locate
    information in a novel manner relative to other NoSQL solutions. In such a structure,
    discrete information and properties are represented as leaves, edges, and nodes.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形数据库** 提供了一种高效的数据表示方式，记录之间具有相互关系。典型的例子有你的社交网络好友列表、LinkedIn 联系人、Netflix 电影订阅者。通过利用优化的算法在基于树/图的数据结构上进行搜索，图形数据库能够以一种与其他
    NoSQL 解决方案不同的方式定位信息。在这样的结构中，离散的信息和属性被表示为叶子、边缘和节点。'
- en: 'The following image shows an atypical representation of a network that can
    be queried to discover or find complex inter-relationships using a graph database.
    In practice, production graph databases contain millions of nodes:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个非典型的网络表示，可以使用图形数据库查询来发现或查找复杂的相互关系。在实际应用中，生产环境中的图形数据库包含数百万个节点：
- en: '![](img/9586b4cb-0fb0-4d1d-9a3b-71c89696d7f5.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9586b4cb-0fb0-4d1d-9a3b-71c89696d7f5.png)'
- en: Graph Database
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图形数据库
- en: Although they are not as prevalent as other types of NoSQL database, graph-based
    platforms are used for business-critical areas. For instance, credit card companies
    use graph databases to find new products that an individual cardholder may be
    interested in by querying across millions of datapoints to assess purchasing behavior
    of other cardholders with similar purchasing patterns. Social network websites
    use graph databases to compute similarity scores, provide friend suggestions,
    and other related metrics.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管图形数据库平台不像其他类型的 NoSQL 数据库那样普及，但它们在业务关键领域有广泛应用。例如，信用卡公司使用图形数据库，通过查询数百万个数据点来发现可能感兴趣的新产品，评估与其他拥有类似消费模式的持卡人的购买行为。社交网络网站使用图形数据库来计算相似度分数、提供好友推荐及其他相关指标。
- en: 'Well-known graph databases include the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 知名的图形数据库包括以下几种：
- en: '| **Open source** | **Commercial** |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| **开源** | **商业** |'
- en: '| Apache Giraph | Datastax Enterprise Graph |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| Apache Giraph | Datastax Enterprise Graph |'
- en: '| Neo4j | Teradata Aster |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| Neo4j | Teradata Aster |'
- en: '| JanusGraph | Oracle Spatial and Graph |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| JanusGraph | Oracle Spatial and Graph |'
- en: '| Apache Ignite |  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| Apache Ignite |  |'
- en: Other NoSQL types and summary of other types of databases
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他NoSQL类型和数据库类型总结
- en: 'This section described some of the commonly known NoSQL paradigms in use today.
    There are several other emerging platforms that have their own strengths and unique
    characteristics. A brief overview of some of them is given here:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了一些当前常见的NoSQL范式。还有一些新兴平台，具有其自身的优势和独特特征。以下是一些平台的简要概述：
- en: '| **Type** | **Feature** |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **特性** |'
- en: '| Object-oriented databases | Databases that leverage concepts in object-oriented
    programming to store data represented as objects. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 面向对象数据库 | 利用面向对象编程概念存储作为对象表示的数据的数据库。 |'
- en: '| Cloud databases | Databases offered by cloud vendors such as Amazon, Microsoft,
    and Google that are only available on their respective cloud platforms such as
    Amazon Redshift, Azure SQL Database, and Google BigQuery. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 云数据库 | 云服务商如亚马逊、微软和谷歌提供的数据库，只能在各自的云平台上使用，例如亚马逊Redshift、Azure SQL数据库和谷歌BigQuery。
    |'
- en: '| GPU databases | A more recent entrant in the world of databases that leverage
    GPU (graphic processing unit) cards to process data. Examples include MapD, Kinetica,
    and others. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| GPU数据库 | 数据库世界中较新的一个成员，利用GPU（图形处理单元）卡来处理数据。例子包括MapD、Kinetica等。 |'
- en: '| FPGA-accelerated databases | With Intel soon announcing the release of new
    chips that would have embedded FPGAs, companies such as Baidu have started developing
    FPGA-accelerated systems that leverage FPGA processing power to improve SQL query
    performance. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| FPGA加速数据库 | 随着英特尔即将发布带有嵌入式FPGA的新芯片，百度等公司已经开始开发利用FPGA处理能力的FPGA加速系统，以提升SQL查询性能。
    |'
- en: '| Stream processing/IoT databases | Databases, or more generally platforms,
    that are optimized for processing streaming data such as from medical devices
    and sensors. One of the most popular examples of such a system is Apache Storm.
    |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 流处理/物联网数据库 | 针对流数据处理进行优化的数据库，或更广泛地说是平台，通常用于处理来自医疗设备和传感器的数据。Apache Storm就是这种系统的一个非常流行的例子。
    |'
- en: A question often asked is whether there is one NoSQL database that is optimal
    for all use cases. While the databases can have multiple features that support
    numerous elements of NoSQL systems (generally known as multi-modal databases),
    in practice, a single solution that performs universally well across a broad set
    of use cases is rare. In real-world use cases, companies generally implement more
    than one solution to meet data mining needs. In the next section, we will complete
    a few hands-on exercises with real-world datasets using NoSQL solutions discussed
    in this chapter.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 经常有人问，是否存在一种NoSQL数据库，适用于所有使用场景。虽然一些数据库具有支持多个NoSQL系统元素的特性（通常称为多模式数据库），但在实际应用中，能够在广泛的使用场景中表现良好的单一解决方案是非常罕见的。在实际的使用案例中，公司通常会实施多个解决方案以满足数据挖掘的需求。在下一节中，我们将通过实际数据集进行一些动手练习，使用本章讨论的NoSQL解决方案。
- en: Analyzing Nobel Laureates data with MongoDB
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB分析诺贝尔奖得主数据
- en: In the first exercise, we will use **MongoDB**, one of the leading document-oriented
    databases, to analyze Nobel Laureates from 1902-present. MongoDB provides a simple
    and intuitive interface to work with JSON files. As discussed earlier, JSON is
    a flexible format that allows representing data using a structured approach.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个练习中，我们将使用**MongoDB**，这是领先的面向文档的数据库之一，用于分析从1902年至今的诺贝尔奖得主数据。MongoDB提供了一个简单直观的界面来处理JSON文件。正如之前所讨论的，JSON是一种灵活的格式，允许以结构化方式表示数据。
- en: JSON format
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON格式
- en: 'Consider the following table:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下表格：
- en: '| **Firstname** | **Lastname** | **Information** |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| **名** | **姓** | **信息** |'
- en: '| John | 15 | Subject: History, Grade B |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| John | 15 | 学科：历史，成绩B |'
- en: '| Jack | 18 | Subject: Physics, Grade A |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| Jack | 18 | 学科：物理，成绩A |'
- en: '| Jill | 17 | Subject: Physics, Grade A+ |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| Jill | 17 | 学科：物理，成绩A+ |'
- en: The Information field contains a column containing multiple values categorized
    under Subject and Grade. Such columns that contain multiple data are also known
    as columns with nested data.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 信息字段包含一个列，其中包含多项值，按学科和成绩分类。这种包含多重数据的列也称为具有嵌套数据的列。
- en: Portability has been an important aspect of transferring data from one system
    to another. In general, ODBC connectors are used to transfer data between database
    systems. Another common format is CSV files with the data represented as comma-separated
    values. CSV files are optimal for structured data that doesn't contain more complex
    data structures such as nested values. In such cases, JSON provides an optimal
    and structured way to capture and preserve information using a key-value pair
    syntax.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植性一直是将数据从一个系统转移到另一个系统的一个重要方面。通常，ODBC 连接器用于在数据库系统之间传输数据。另一个常见的格式是 CSV 文件，其中数据以逗号分隔值的形式表示。CSV
    文件最适合结构化数据，且不包含更复杂的数据结构，如嵌套值。在这种情况下，JSON 提供了一种最佳的结构化方式来捕捉和保存信息，使用键值对语法。
- en: 'In JSON representation, the table can be defined as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 表示中，表格可以按如下方式定义：
- en: '[PRE4]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the `Information` key contains two keys, `Subject` and `Grade`,
    with each having a corresponding value.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Information` 键包含两个键，`Subject` 和 `Grade`，每个键都有相应的值。
- en: Today, most product developers and vendors accommodate the ingestion of JSON-formatted
    data. Also, due to the simple manner in which complex relationships can be expressed
    as well as exchanged in text format, JSON has become immensely popular across
    the world in the developer community.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，大多数产品开发者和供应商都支持摄取 JSON 格式的数据。此外，由于复杂关系能够以简单的方式表达并以文本格式交换，JSON 在全球开发者社区中已经变得非常流行。
- en: MongoDB captures data in JSON format. It internally stores them in BSON—an optimized
    binary representation of the JSON data.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 以 JSON 格式捕捉数据。它内部将数据存储为 BSON——JSON 数据的优化二进制表示形式。
- en: Installing and using MongoDB
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和使用 MongoDB
- en: MongoDB is supported on all major platforms such as Windows, Linux, and OS X
    platforms.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 支持所有主要平台，如 Windows、Linux 和 OS X 平台。
- en: The details for installing MongoDB can be found on their official website at
    [https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/).
    Note that we will be using the MongoDB Community Edition.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 的安装细节可以在其官方网站上找到，网址是 [https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)。请注意，我们将使用
    MongoDB 社区版。
- en: For our exercise, we will re-use the Linux CentOS environment from our Cloudera
    Hadoop Distribution VM.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本练习，我们将重用来自 Cloudera Hadoop 发行版虚拟机的 Linux CentOS 环境。
- en: The exercise is however not dependent on the platform on which you install MongoDB.
    Once the installation has been completed, you can execute the commands indicated
    in this chapter on any other supported platform. If you have access to a separate
    Linux machine, you can use that as well.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本练习与安装 MongoDB 的平台无关。一旦安装完成，您可以在任何其他支持的平台上执行本章中指示的命令。如果您有一台独立的 Linux 机器，您也可以使用它。
- en: 'We will visit some of the common semantics of MongoDB and also download two
    datasets to compute the highest number of Nobel Prizes grouped by continent. The
    complete dump of the Nobel Prize data on Nobel Laureates is available from [nobelprize.org](https://www.nobelprize.org).
    The data contains all the primary attributes of Laureates. We wish to integrate
    this data with demographic information on the respective countries to extract
    more interesting analytical information:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将访问 MongoDB 的一些常见语义，并下载两个数据集，计算按大洲分组的诺贝尔奖最高得奖人数。关于诺贝尔奖得主的完整数据转储可以从 [nobelprize.org](https://www.nobelprize.org)
    获取。数据包含所有得主的主要属性。我们希望将这些数据与相应国家的人口统计信息结合，以提取更多有趣的分析信息：
- en: '**Download MongoDB**: MongoDB can be downloaded from [https://www.mongodb.com/download-center#community](https://www.mongodb.com/download-center#community).'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下载 MongoDB**：MongoDB 可以从 [https://www.mongodb.com/download-center#community](https://www.mongodb.com/download-center#community)
    下载。'
- en: 'To determine which version is applicable for us, we checked the version of
    Linux installed on the CDH VM:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定适用的版本，我们检查了 CDH 虚拟机上安装的 Linux 版本：
- en: '[PRE5]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Based on the information, we have to use the CentOS version of MongoDB, and
    accordingly, following the instructions at [https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/),
    we installed the software, shown as follows:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据这些信息，我们必须使用 MongoDB 的 CentOS 版本，并按照 [https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/)
    上的说明安装软件，如下所示：
- en: '[PRE6]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the contents of the file:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了文件的内容：
- en: '![](img/aa4ee91d-8d97-4306-bea2-00886989948f.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa4ee91d-8d97-4306-bea2-00886989948f.png)'
- en: Setting up MongoDB repository
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 MongoDB 仓库
- en: 'As seen in the following screenshot, type `Y` for Yes:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，输入`Y`表示是：
- en: '![](img/9dcc8115-8f1b-44fa-99d6-a48a5e7e1455.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9dcc8115-8f1b-44fa-99d6-a48a5e7e1455.png)'
- en: Saving the .repo file
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 保存 .repo 文件
- en: 'Save the file as shown in the image as follows. This will now allow us to install
    `mongo-db`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 按照图示保存文件。这将允许我们安装`mongo-db`：
- en: '![](img/73965396-a01a-47ff-9c5b-dcfda1f44c1b.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73965396-a01a-47ff-9c5b-dcfda1f44c1b.png)'
- en: Writing and Saving the .repo file
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 编写并保存 .repo 文件
- en: '[PRE7]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open a new terminal and download the JSON data files as shown in the following
    screenshot:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端并下载如以下截图所示的 JSON 数据文件：
- en: '![](img/79111799-378b-41db-b833-2ed975307233.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79111799-378b-41db-b833-2ed975307233.png)'
- en: Selecting Open Terminal from Terminal App on Mac OS X
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Mac OS X 的 Terminal 应用中选择 Open Terminal
- en: '[PRE10]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that the file needs to be slightly modified. The code is shown in the
    following image:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，文件需要稍作修改。代码如下图所示：
- en: '![](img/89ea74b9-5871-4841-91b6-66b3003aaee8.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89ea74b9-5871-4841-91b6-66b3003aaee8.png)'
- en: Modifying the .json file for our application
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 修改我们应用程序的 .json 文件
- en: '[PRE11]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In order to combine the data in `laureate.json` with country-specific information,
    we need to download the `countryInfo.txt` from [geonames.org](http://geonames.org) 
    We will now download the second file that we need for the exercise, `country.json`.
    We will use both `laureates.json` and `country.json` for the exercise.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`laureate.json`中的数据与特定国家的信息结合，我们需要从[geonames.org](http://geonames.org)下载`countryInfo.txt`。接下来，我们将下载本次练习所需的第二个文件`country.json`。我们将使用`laureates.json`和`country.json`来进行练习。
- en: '`### country.json`: Download it from [http://www.geonames.org](http://www.geonames.org)
    (license: [https://creativecommons.org/licenses/by/3.0/](https://creativecommons.org/licenses/by/3.0/)).
    Modify the start and end of the JSON string to import into MongoDB as shown as
    follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`### country.json`：从[http://www.geonames.org](http://www.geonames.org)下载（许可证：[https://creativecommons.org/licenses/by/3.0/](https://creativecommons.org/licenses/by/3.0/)）。修改
    JSON 字符串的开始和结束部分，以便按以下所示导入到 MongoDB：'
- en: '[PRE12]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Query a field - find all Nobel Laureates who were born in the US and received
    a Nobel Prize in Physics. Note that here we have a nested field (category is under
    prizes as shown). Hence, we will use the dot notation as shown in the coming image.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字段 - 查找所有出生在美国并获得诺贝尔物理奖的诺贝尔奖得主。注意，这里有一个嵌套字段（如所示，category 位于 prizes 下）。因此，我们将使用点符号（dot
    notation），如下面的图像所示。
- en: 'Image illustrating `category`, one of the nested fields:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图像说明了`category`，一个嵌套字段：
- en: '![](img/aad94718-e2e9-47dc-9789-3c79f0eb94ba.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aad94718-e2e9-47dc-9789-3c79f0eb94ba.png)'
- en: Nested JSON Fields
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套 JSON 字段
- en: '[PRE13]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are many other operations that can be performed, but the intention of
    the prior section was to introduce MongoDB at a high level with a simple use case.
    The URLs given in this chapter contain more in-depth information on using MongoDB.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他操作可以执行，但前一部分的目的是以简单的使用案例来高层次地介绍 MongoDB。本章中提供的网址包含有关使用 MongoDB 的更深入信息。
- en: There are also several visualization tools in the industry that are used to
    interact with and visualize data stored in MongoDB collections using a point-and-click
    interface. A simple yet powerful tool called MongoDB Compass is available at [https://www.mongodb.com/download-center?filter=enterprise?jmp=nav#compass.](https://www.mongodb.com/download-center?filter=enterprise?jmp=nav#compass)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 业界还有多个可视化工具，用于与 MongoDB 集合中的数据进行交互和可视化，采用的是点选式界面。一个简单而强大的工具 MongoDB Compass
    可以从 [https://www.mongodb.com/download-center?filter=enterprise?jmp=nav#compass.](https://www.mongodb.com/download-center?filter=enterprise?jmp=nav#compass)
    获取。
- en: 'Navigate to the previously mentioned URL and download the version of Compass
    that is appropriate for your environment:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到先前提到的网址并下载适合您环境的 Compass 版本：
- en: '![](img/8a0c6779-586c-43e0-b01a-1218f24f78ec.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a0c6779-586c-43e0-b01a-1218f24f78ec.png)'
- en: Downloading MongoDB Compass
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 MongoDB Compass
- en: 'After installation, you''ll see a welcome screen. Click on Next until you see
    the main dashboard:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您将看到欢迎屏幕。点击“Next”直到看到主控制面板：
- en: '![](img/4e5fdace-8e95-40e7-a0d8-5e2af7313798.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e5fdace-8e95-40e7-a0d8-5e2af7313798.png)'
- en: MongoDB Compass Screenshot
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB Compass 截图
- en: 'Click on Performance to view the current status of MongoDB:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“Performance”查看 MongoDB 的当前状态：
- en: '![](img/c0f2af9b-958b-4ee4-ab32-1168f5ccd99e.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0f2af9b-958b-4ee4-ab32-1168f5ccd99e.png)'
- en: MongoDB Performance Screen
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 性能屏幕
- en: 'Expand the nobel database by clicking on the arrow next to the word on the
    left sidebar. You can click and drag on different parts of the bar charts and
    run ad hoc queries. This is very useful if you want to get an overall understanding
    of the dataset without necessarily having to run all queries by hand, as shown
    in the following screenshot:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击左侧边栏单词旁边的箭头来扩展诺贝尔数据库。你可以点击并拖动条形图的不同部分，并运行临时查询。如果你想全面了解数据集，而不必手动运行所有查询，这非常有用，如下图所示：
- en: '![](img/ef06d694-d31f-458a-9c50-d9da40944e0a.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef06d694-d31f-458a-9c50-d9da40944e0a.png)'
- en: Viewing our file in MongoDB Compass
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB Compass中查看我们的文件
- en: Tracking physician payments with real-world data
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用真实数据追踪医生支付情况
- en: Physicians and hospitals alike receive payments from various external organizations,
    such as pharmaceutical companies who engage sales representatives to not only
    educate practitioners on their products, but also provide gifts or payments in
    kind or otherwise. In theory, gifts or payments made to physicians are not intended
    to influence their prescribing behavior, and pharmaceutical companies adopt careful
    measures to maintain checks and balances on payments being made to healthcare
    providers.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 医生和医院都接受来自各种外部组织的支付，例如制药公司雇佣销售代表不仅教育医生了解他们的产品，还提供礼品或现金等支付。理论上，支付给医生的礼品或款项并不旨在影响他们的处方行为，制药公司采取谨慎措施来确保支付给医疗服务提供者的款项受到监督和制衡。
- en: In 2010, President Obama's signature **Affordable Care Act** (**ACA**), also
    known in popular parlance as Obamacare, went into effect. Alongside the ACA, a
    separate legislation known as the Sunshine Act made reporting items of monetary
    value (directly or indirectly) mandatory for pharmaceutical companies and other
    organizations. While such rules existed in the past, rarely were such rules available
    in the public domain. By making detailed payment records made to all physicians
    available publicly, the Sunshine Act introduced an unprecedented level of transparency
    in monetary dealings involving healthcare providers.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，奥巴马总统签署的**平价医疗法案**（**ACA**），也被大众称为“奥巴马医改”，正式生效。与ACA一起，另一项名为阳光法案的立法也要求制药公司及其他组织必须报告所有具有货币价值的项目（无论是直接还是间接）。虽然过去也有类似规定，但这些规则极少公开可用。阳光法案通过公开所有支付给医生的详细记录，带来了前所未有的透明度，特别是在医疗服务提供者涉及金钱交易时。
- en: The data is freely available on the website of CMS Open Payments at [https://openpaymentsdata.cms.gov](https://openpaymentsdata.cms.gov).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据可以在CMS开放支付网站上自由获取，网址为[https://openpaymentsdata.cms.gov](https://openpaymentsdata.cms.gov)。
- en: The site provides an interface to query the data, but does not have any means
    to perform large-scale data aggregation. For example, if a user wanted to find
    the total payments made in the state of CT, there is no simple and easy way to
    run the query through the default web-based tool. An API that provides the functionality
    is available, but requires a degree of familiarity and technical knowledge to
    use effectively. There are third-party products that provide such facilities,
    but in most cases they are expensive, and end users cannot modify the software
    to their particular needs.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站提供了查询数据的接口，但没有任何用于进行大规模数据聚合的功能。例如，如果用户想查找康涅狄格州（CT）的总支付金额，默认的网页工具没有简单便捷的方式来运行此查询。提供该功能的API是可用的，但需要一定的熟悉程度和技术知识才能有效使用。有第三方产品提供这类功能，但大多数情况下它们价格昂贵，并且最终用户无法根据自己的需求修改软件。
- en: In this tutorial, we will develop a fast, highly efficient web-based application
    to analyze tens of millions of records that capture payments made to physicians
    in 2016\. We will be using a combination of a NoSQL database, R, and RStudio to
    create the final product - the web-based portal through which end users can query
    the database in real time.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将开发一个快速且高效的基于网页的应用程序，用于分析2016年支付给医生的数千万条记录。我们将结合使用NoSQL数据库、R和RStudio来创建最终产品——通过该产品，最终用户可以实时查询数据库。
- en: 'The technologies we will use to develop the application are as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下技术来开发该应用程序：
- en: 'Kdb+ NoSQL database: [http://www.kx.com](http://www.kx.com)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kdb+ NoSQL数据库：[http://www.kx.com](http://www.kx.com)
- en: R
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R
- en: RStudio
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RStudio
- en: For the tutorial, I will be using the VM image we downloaded for our Hadoop
    exercise. The tools can also be installed on Windows, Mac, and other Linux machines.
    The choice of the VM is mainly to provide a consistent and local OS independent
    platform.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我将使用我们为Hadoop练习下载的VM镜像。工具也可以安装在Windows、Mac和其他Linux机器上。选择虚拟机主要是为了提供一个一致且不依赖于操作系统的本地平台。
- en: Installing kdb+, R, and RStudio
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装kdb+、R和RStudio
- en: A Packt Data Science VM download has been provided, which contains all the necessary
    software required for this chapter. However, if you prefer to install the software
    on your local machine instead, instructions, have been provided in the following
    sections. You can skip the installation sections and proceed directly to the section
    on *Developing the Open Payment Application.*
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一个Packt Data Science VM下载，其中包含本章所需的所有必要软件。然而，如果你更喜欢在本地计算机上安装软件，可以参考以下部分的说明。你可以跳过安装部分，直接进入*开发开放支付应用*部分。
- en: Installing kdb+
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装kdb+
- en: '**kdb+** is a time-series, in-memory, columnar database that has been used
    in the financial industry for almost 20 years. It is one of the fastest database
    platforms available for performing large-scale data mining, but one that is not
    as well-known as other NoSQL tools due to the fact that it has been used almost
    exclusively by hedge funds and investment banks for most of its existence. In
    particular, due to its speed and low overhead in processing vast amounts of data,
    it is used by algorithmic trading desks that engage in high-frequency trading.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**kdb+** 是一个时间序列、内存中、列式数据库，已在金融行业使用近20年。它是执行大规模数据挖掘时最快的数据库平台之一，但由于它几乎仅被对冲基金和投资银行使用，因此不像其他NoSQL工具那样为人所知。特别是，由于其处理海量数据的速度和低开销，它被高频交易的算法交易部门广泛使用。'
- en: With kdb+, it is fairly simple to analyze tens of millions and even hundreds
    of millions of records on a laptop. The main constraints would be at a hardware
    level - such as the amount of memory, disk space, and CPU that is available to
    process the data. In this tutorial, we will install the free 32-bit edition of
    kdb+ available for non-commercial use.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用kdb+，在笔记本电脑上分析数千万甚至上亿条记录相对简单。主要的限制在硬件层面——例如可用的内存、磁盘空间和CPU，这些都是处理数据的关键因素。在本教程中，我们将安装可供非商业使用的免费32位版本kdb+。
- en: kdb+ is not open source, but academic institutes can use the 64-bit license
    at no charge by writing to `academic@kx.com`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: kdb+不是开源的，但学术机构可以通过写信至`academic@kx.com`免费使用64位许可证。
- en: 'There are certain key characteristics of kdb+ that make it very well suited
    to large-scale data analysis:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: kdb+有一些关键特性，使其非常适合大规模数据分析：
- en: '**Low-level implementation**: The database is written in C, thus reducing common
    causes of performance issues with most contemporary NoSQL databases that rely
    heavily on Java, which implements multiple layers of abstraction to provide processing
    capabilities'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低级实现**：该数据库使用C语言编写，因此减少了大多数现代NoSQL数据库常见的性能问题，这些数据库通常依赖Java，并实现了多个抽象层来提供处理能力。'
- en: '**Architectural simplicity**: The entire binary for the kdb+ database is about
    500-600 KB. This is a fraction of the size of an MP3 song and can be easily downloaded
    even on a dial-up connection'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**架构简单性**：整个kdb+数据库的二进制文件约为500-600KB，只有一首MP3歌曲的一小部分，即使在拨号连接下也能轻松下载。'
- en: '**MapReduce**: The database implements an internal MapReduce process that allows
    queries to execute across multiple cores simultaneously'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MapReduce**：该数据库实现了一个内部的MapReduce过程，允许查询在多个核心上同时执行。'
- en: '**No installation**: The database requires no system-level privileges and users
    can start using kdb+ with their user account on most systems'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无需安装**：该数据库不需要系统级权限，用户可以在大多数系统中直接使用其用户账户启动kdb+。'
- en: '**Enterprise-ready**: The database has been used for nearly 20 years and is
    a very mature product used in global enterprise environments for analysis of high-frequency
    trading data among other applications'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业级准备**：该数据库已经使用了近20年，是一个非常成熟的产品，广泛应用于全球企业环境中，分析高频交易数据等应用。'
- en: '**Wide availability of interfaces**: The database has a wide range of interfaces
    for languages such as C, C++,C#, Java, R, Python, MATLAB, and others to allow
    easy integration with existing software'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口广泛**：该数据库提供多种语言的接口，如C、C++、C#、Java、R、Python、MATLAB等，便于与现有软件集成。'
- en: The steps to install kdb+ are given as follows. Please note that if you are
    using the Packt Data Science VM, no additional installation is necessary. The
    instructions have been provided primarily for users who would like to install
    the software afresh.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 安装kdb+的步骤如下所示。请注意，如果你使用的是Packt Data Science虚拟机，则无需额外安装。以下说明主要是为那些希望全新安装该软件的用户提供的。
- en: Although the instructions are for Linux, the installation process is also quite
    simple for both Windows and Macs. The instructions herein are geared towards the
    Packt Data Science VM. The instructions for downloading the Packt Data Science
    VM was provided in [Chapter 3](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml), *The
    Analytics Toolkit*
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管说明是针对Linux的，但对于Windows和Mac，安装过程同样非常简单。这里的说明是针对Packt Data Science虚拟机的。关于如何下载Packt
    Data Science虚拟机的说明，已在[第3章](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml)，*The Analytics
    Toolkit*中提供。
- en: 'Visit [www.kx.com](http://www.kx.com) and click on the **Download** drop-down
    option from the Connect with us menu item. You may also directly go to the download
    page located at [https://kx.com/download/](https://kx.com/download/):'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[www.kx.com](http://www.kx.com)，并从“Connect with us”菜单项中点击**Download**下拉选项。你也可以直接访问下载页面[https://kx.com/download/](https://kx.com/download/)：
- en: '![](img/e9289227-5a28-4ab9-904b-c657bd510ec5.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9289227-5a28-4ab9-904b-c657bd510ec5.png)'
- en: Kx Systems Homepage
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Kx系统主页
- en: 'The download page is as shown in the following screenshot:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 下载页面如下所示：
- en: '![](img/9b9d30ed-0252-4ce2-a401-54f17703e792.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b9d30ed-0252-4ce2-a401-54f17703e792.png)'
- en: Downloading KDB+
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 下载KDB+
- en: Click on Download on the next page.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页面点击下载按钮。
- en: You'll be taken to [https://kx.com/download/](https://kx.com/download/) where
    you can select the respective download of your choice after agreeing to the terms.
    If you are using the VM, download the *Linux-86 version*.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将被带到[https://kx.com/download/](https://kx.com/download/)页面，那里你可以在同意条款后选择你需要的下载版本。如果你使用的是虚拟机，下载*Linux-86版本*。
- en: 'Select Save File to save the downloaded ZIP file in your Downloads folder:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“保存文件”将下载的ZIP文件保存在你的下载文件夹中：
- en: '![](img/d2c2ea7a-99f1-4c01-8108-f1c3022ad91a.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2c2ea7a-99f1-4c01-8108-f1c3022ad91a.png)'
- en: KDB+ 32-bit license terms
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: KDB+ 32位许可条款
- en: 'Go to the folder where the file was downloaded and copy the ZIP file under
    your home directory:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 转到文件下载的位置，将ZIP文件复制到你的主目录下：
- en: '![](img/579d8cf0-22ad-4b55-8b29-c28309916eaa.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](img/579d8cf0-22ad-4b55-8b29-c28309916eaa.png)'
- en: KDB+ Zip file download
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: KDB+ ZIP文件下载
- en: 'For Mac or Linux systems, this will be the `~/` folder. In Windows, copy the
    ZIP file under `C:\` and unzip to extract the `q` folder. The following instructions
    are mainly for Linux-based systems:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Mac或Linux系统，这将是`~/`文件夹。在Windows中，将ZIP文件复制到`C:\`下并解压以提取`q`文件夹。以下说明主要适用于基于Linux的系统：
- en: '[PRE14]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Installing R
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装R
- en: 'The frontend of the application will be developed using R. There are three
    options for installing R to complete the tutorial:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的前端将使用R开发。安装R有三种选择，以完成本教程：
- en: If you have installed Microsoft R from [Chapter 3](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml), *The
    Analytics Toolkit*, and will be using your local machine for the tutorial, no
    further installation is necessary.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经从[第3章](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml)安装了Microsoft R，并且将使用本地机器进行本教程，则无需进行进一步安装。
- en: Alternatively, if you will be using the Packt Data Science Virtualbox VM, no
    further installation will be needed.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，如果你将使用Packt Data Science Virtualbox虚拟机，则无需进行进一步安装。
- en: 'If you plan to install R from the official R website, the binary can be downloaded
    from any of the download sites (mirrors) listed at [https://cran.r-project.org/mirrors.html](https://cran.r-project.org/mirrors.html):'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你计划从官方R网站安装R，可以从列在[https://cran.r-project.org/mirrors.html](https://cran.r-project.org/mirrors.html)的任何下载站点（镜像站）下载二进制文件：
- en: '![](img/7f9ebd70-ea4f-476f-b714-919b06cc8d90.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f9ebd70-ea4f-476f-b714-919b06cc8d90.png)'
- en: Installing Open Source R
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 安装开源R
- en: Installing RStudio
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装RStudio
- en: We will use RStudio in order to build our web-based application. You can either
    download the binary for RStudio from the website or install it from the terminal.
    RStudio is available in two versions - RStudio Desktop and RStudio Server. Both
    versions can be used to build the application. The Server version provides an
    interface that can be used by multiple users, whereas the Desktop version is generally
    used locally on the user's machine.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用RStudio来构建我们的基于Web的应用程序。你可以从网站下载RStudio的二进制文件，或者通过终端安装它。RStudio有两个版本——RStudio桌面版和RStudio服务器版。两个版本都可以用于构建应用程序。服务器版提供一个可以供多个用户使用的接口，而桌面版通常在用户本地机器上使用。
- en: The instructions also appear in [Chapter 3](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml), *The
    Analytics Toolkit*. They have been provided here for reference.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 相关说明也出现在[第3章](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml)，*数据分析工具包*中，已在此处提供以供参考。
- en: 'There are two methods to complete the installation for the R tutorial:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 完成R教程安装有两种方法：
- en: If you will be using the Packt Data Science VM, no further installation is necessary.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将使用Packt数据科学虚拟机，则无需进一步安装。
- en: If you will be using your local machine for the tutorial, you can download RStudio
    Desktop from [https://www.rstudio.com/products/rstudio/download/#download](https://www.rstudio.com/products/rstudio/download/#download)
    or RStudio Server (only for Linux users) from [https://www.rstudio.com/products/rstudio/download-server/](https://www.rstudio.com/products/rstudio/download-server/).
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将在本地机器上进行教程，可以从[https://www.rstudio.com/products/rstudio/download/#download](https://www.rstudio.com/products/rstudio/download/#download)下载RStudio桌面版，或者从[https://www.rstudio.com/products/rstudio/download-server/](https://www.rstudio.com/products/rstudio/download-server/)下载RStudio服务器版（仅适用于Linux用户）。
- en: 'The following instructions have been provided for users wishing to download
    RStudio from the vendor''s website and perform a fresh installation:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明适用于希望从供应商网站下载RStudio并进行全新安装的用户：
- en: 'Go to the website of [https://www.rstudio.com](https://www.rstudio.com) and
    click on **Products** | **RStudio**:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://www.rstudio.com](https://www.rstudio.com)网站，并点击**产品** | **RStudio**：
- en: '![](img/e837fc9d-1779-490c-b54c-b67d629a5459.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e837fc9d-1779-490c-b54c-b67d629a5459.png)'
- en: Open Source R Studio Desktop Versions
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 开源RStudio桌面版版本
- en: 'On the RStudio page, click on **Download RStudio Desktop**:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在RStudio页面，点击**下载RStudio桌面版**：
- en: '![](img/b5f21797-de0a-45d2-9ccc-60f722008cee.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5f21797-de0a-45d2-9ccc-60f722008cee.png)'
- en: Selecting RStudio Desktop
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 选择RStudio桌面版
- en: 'Select the free version of RStudio Desktop:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 选择RStudio桌面版的免费版本：
- en: '![](img/84689f5f-ffdb-45d6-a79c-c82d51286f1d.png)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84689f5f-ffdb-45d6-a79c-c82d51286f1d.png)'
- en: Selecting Open Source R Studio Desktop
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 选择开源RStudio桌面版
- en: RStudio is available for Windows, Mac, and Linux.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio可用于Windows、Mac和Linux。
- en: 'Download the appropriate executable for your system and proceed to perform
    the installation:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 下载适合你系统的可执行文件并继续安装：
- en: '![](img/28deddcd-3a2f-41fd-9a98-f972e2431336.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28deddcd-3a2f-41fd-9a98-f972e2431336.png)'
- en: RStudio Binaries (Versions)
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio二进制文件（版本）
- en: The CMS Open Payments Portal
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMS Open Payments门户
- en: In this section, we will begin developing our application for CMS Open Payments.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始为CMS Open Payments开发应用程序。
- en: The Packt Data Science VM contains all the necessary software for this tutorial.
    To download the VM, please refer to [Chapter 3](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml), *The
    Analytics Toolkit*.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Packt数据科学虚拟机包含本教程所需的所有软件。要下载该虚拟机，请参考[第3章](5ca02405-8ab4-4274-8611-af003aab7c9f.xhtml)，*数据分析工具包*。
- en: Downloading the CMS Open Payments data
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载CMS Open Payments数据
- en: 'The CMS Open Payments data is available directly as a web-based download from
    the CMS website. We''ll download the data using the Unix wget utility, but first
    we have to register with the CMS website to get our own API key:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: CMS Open Payments数据可以通过CMS网站直接作为Web下载。我们将使用Unix的wget工具下载数据，但首先需要在CMS网站注册并获得自己的API密钥：
- en: 'Go to [https://openpaymentsdata.cms.gov](https://openpaymentsdata.cms.gov)
    and click on the Sign In link at the top-right of the page:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://openpaymentsdata.cms.gov](https://openpaymentsdata.cms.gov)，然后点击页面右上角的登录链接：
- en: '![](img/bbfb3158-5088-41d9-b493-9e5a32e32215.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbfb3158-5088-41d9-b493-9e5a32e32215.png)'
- en: Homepage of CMS OpenPayments
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: CMS OpenPayments主页
- en: 'Click on **Sign Up**:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**注册**：
- en: '![](img/fe7d94fb-fb98-4fa3-8c90-8985828bfdd3.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe7d94fb-fb98-4fa3-8c90-8985828bfdd3.png)'
- en: Sign-Up Page on CMS OpenPayments
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: CMS OpenPayments注册页面
- en: 'Enter your information and click on the **Create My Account** button:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 输入你的信息并点击**创建我的账户**按钮：
- en: '![](img/57d32c92-42e6-4e9c-a8b7-dcdde3218f79.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57d32c92-42e6-4e9c-a8b7-dcdde3218f79.png)'
- en: Sign-Up Form for CMS OpenPayments
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: CMS OpenPayments 注册表单
- en: '**Sign In** to your account:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**登录**到你的账户：'
- en: '![](img/3b96353c-5ee6-41a9-86d9-73976eb3c805.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b96353c-5ee6-41a9-86d9-73976eb3c805.png)'
- en: Signing into CMS OpenPayments
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到 CMS OpenPayments
- en: 'Click on **Manage** under **Packt Developer''s Applications**. Note that Applications
    here refers to apps that you may create that will query data available on the
    CMS website:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **Manage** 下的 **Packt Developer's Applications**。请注意，此处的“应用程序”指的是你可以创建的，用于查询
    CMS 网站上可用数据的应用程序：
- en: '![](img/f7312ecd-95c0-4b9e-8a99-d3fc66d3d842.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7312ecd-95c0-4b9e-8a99-d3fc66d3d842.png)'
- en: Creating 'Applications'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 创建“应用程序”
- en: 'Assign a name for the application (examples are shown in the following image):'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 为应用程序指定一个名称（以下图片中展示了示例）：
- en: '![](img/936b7e4a-ffa6-4c41-96ca-a5e6d695f7e5.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](img/936b7e4a-ffa6-4c41-96ca-a5e6d695f7e5.png)'
- en: Defining an application
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 定义应用程序
- en: 'You''ll get a notification that the **Application Token** has been created:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到通知，提示 **Application Token** 已创建：
- en: '![](img/457be983-e31e-4bd4-9435-8509fdb84e4f.png)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![](img/457be983-e31e-4bd4-9435-8509fdb84e4f.png)'
- en: Creating the Application Token
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用令牌
- en: 'The system will generate an **App Token**. Copy the **App Token**:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将生成一个 **App Token**。复制 **App Token**：
- en: '![](img/0db9fc01-86f3-4a94-bb24-b8aed05f5c32.png)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0db9fc01-86f3-4a94-bb24-b8aed05f5c32.png)'
- en: The Application Token
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 应用令牌
- en: Now, log in to the Packt Data Science VM as user packt and execute the following
    shell command after replacing the term `YOURAPPTOKEN` with the one that you were
    assigned (it will be a long string of characters/numbers). Note that for the tutorial,
    we will only download a few of the columns and restrict the data to only physicians
    (the other option is hospitals).
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，作为用户 packt 登录到 Packt 数据科学虚拟机，并在将 `YOURAPPTOKEN` 替换为分配给你的令牌（它将是一个很长的字符/数字字符串）后，执行以下
    shell 命令。请注意，对于本教程，我们将只下载部分列并将数据限制为仅包含医生（另一个选项是医院）。
- en: You can reduce the volume of the data downloaded by reducing the value of the
    limit specified at the end of the command to a lower number. In the command, we
    have used `12000000` (12 million), which would let us download the entire 2016
    dataset representing physician payments. The application will still work if, for
    example, you were to download only one million entries instead of the approximately
    11-12 million records.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将命令末尾的限制值设为较小的数字来减少下载的数据量。在该命令中，我们使用了 `12000000`（1200 万），这将允许我们下载整个 2016
    年的代表医生支付的数据集。如果你只下载大约 100 万条记录，而不是约 1100-1200 万条记录，应用程序仍然能够正常工作。
- en: 'Note: Two approaches are shown below. One using the Token and the other without
    using the Token. Application Tokens allow users to have a higher throttling limit.
    More information can be found at [https://dev.socrata.com/docs/app-tokens.html](https://dev.socrata.com/docs/app-tokens.html)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 注：以下展示了两种方法。一种是使用令牌，另一种是未使用令牌。应用令牌允许用户拥有更高的流量限制。更多信息请参考 [https://dev.socrata.com/docs/app-tokens.html](https://dev.socrata.com/docs/app-tokens.html)
- en: '[PRE15]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Important**: It is possible to also download the file without using an app
    token. However, the method should be used sparingly. The URL to download the file
    without using an application token is shown as follows:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要**：也可以在不使用应用令牌的情况下下载文件。但应谨慎使用此方法。未使用应用令牌下载文件的 URL 如下所示：'
- en: '[PRE16]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating the Q application
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Q 应用程序
- en: This section describes the process of creating the kdb+/Q application, beginning
    with the process of loading data from the database and creating the scripts that
    will serve as the backend for the application.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了创建 kdb+/Q 应用程序的过程，从加载数据库中的数据开始，然后创建将作为应用程序后端的脚本。
- en: Loading the data
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载数据
- en: 'Log in to the VM using the ID `packt` (password: `packt`):'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ID `packt` 登录虚拟机（密码：`packt`）：
- en: '![](img/7a4e6913-3fe7-45d7-8d12-6b2bdb2f5699.png)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a4e6913-3fe7-45d7-8d12-6b2bdb2f5699.png)'
- en: Logging into the Packt VM
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到 Packt 虚拟机
- en: '[PRE17]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The backend code
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后端代码
- en: Once the script completes, exit from the Q prompt by typing in `\\` and pressing
    *Enter*.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本完成，通过输入 `\\` 并按下 *Enter* 键退出 Q 提示符。
- en: 'Copy the following text into a file called `cms.q`:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下文本复制到名为 `cms.q` 的文件中：
- en: '[PRE18]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating the frontend web portal
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建前端 Web 门户
- en: '**R Shiny**, a package intended to make development of web-based applications
    simple, started gaining traction since it was introduced in around 2012-2013\.
    In general, R developers tend not to be very frontend development savvy as their
    main areas of work would be related to statistics or similar disciplines.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '**R Shiny** 是一个旨在简化基于Web的应用程序开发的包，自2012-2013年左右推出以来，逐渐获得了广泛关注。通常，R开发者并不擅长前端开发，因为他们的主要工作领域通常与统计学或类似学科相关。'
- en: As data science, as a profession and a mainstream activity became popular, the
    need to create sophisticated web-based applications became necessary as a means
    of delivering results to end users in a dynamic environment.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据科学作为一种职业和主流活动的流行，创建复杂的基于Web的应用程序变得必要，作为一种在动态环境中向最终用户交付结果的方式。
- en: JavaScript, which had all but lost its original appeal, made a surprise comeback
    and soon enough the web world was abuzz with the release of various leading JavaScript
    packages for web development and visualization, such as D3, Angular, Ember, and
    others ever since 2010-2011.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript几乎失去了其原有的吸引力，但它令人惊讶地复苏了，自2010-2011年起，Web世界便热烈讨论各种领先的JavaScript包，诸如D3、Angular、Ember等，用于Web开发和可视化。
- en: But these were mostly used by seasoned JavaScript developers, few of whom were
    also proficient in R. Developing a solution that would help bridge the gap between
    JavaScript web-based application development and R programming became a necessity
    for R developers to showcase and share their work with a broader audience.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些工具主要被经验丰富的JavaScript开发人员使用，而这些开发人员中只有少数人也精通R。开发一个能够弥合JavaScript Web应用程序开发和R编程之间差距的解决方案，成为了R开发者展示和分享他们工作的必要工具。
- en: R Shiny platform for developers
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R Shiny平台面向开发人员
- en: R Shiny introduced a platform for R developers to create JavaScript-based web
    applications without having to get involved, or, for that, matter even be proficient
    in JavaScript.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: R Shiny为R开发人员提供了一个平台，使他们能够创建基于JavaScript的Web应用程序，而无需参与或甚至精通JavaScript。
- en: In order to build our application, we will leverage R Shiny and create an interface
    to connect to the CMS Open Payments data we set up in the prior section.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的应用程序，我们将利用R Shiny并创建一个界面，以连接我们在前一部分中设置的CMS Open Payments数据。
- en: 'If you are using your own R installation (locally), you''ll need to install
    a few R packages. Note that if you are using a Linux workstation, you may need
    to install some additional Linux packages. For example, in Ubuntu Linux, you''ll
    need to install the following. You may already have some of the packages, in which
    case you''ll receive a message indicating that no further changes were needed
    for the respective package:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是本地R安装，你需要安装一些R包。请注意，如果你使用的是Linux工作站，可能还需要安装一些额外的Linux包。例如，在Ubuntu Linux中，你需要安装以下包。你可能已经安装了其中一些包，这种情况下你将收到一条消息，指示不需要对相应的包进行进一步更改：
- en: '[PRE19]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you are using the Packt Data Science VM, you can proceed directly to developing
    the application as these Linux packages have already been installed for you.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Packt数据科学虚拟机，你可以直接开始开发应用程序，因为这些Linux包已经为你安装好了。
- en: The Shiny application requires a few additional R packages to provide all its
    functionalities. Note that R packages are different from the Linux packages described
    previously. R packages, which number in the thousands, provide specialized functions
    for specific subject areas. For the web application, we will install a few R packages
    that will let us leverage some of the features in the web-based application.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny应用程序需要一些额外的R包来提供所有功能。请注意，R包与前面描述的Linux包不同。R包有成千上万种，提供特定领域的专用功能。对于Web应用程序，我们将安装一些R包，以便利用Web应用程序中的某些功能。
- en: 'The following steps outline the process of creating the web portal:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了创建Web门户的过程：
- en: Log in to RStudio. If you are using the Packt Data Science VM, go to `http://localhost:8787/auth-sign-in`.
    Log in with the user ID **packt** and password **packt** (same as user ID).
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录RStudio。如果你使用的是Packt数据科学虚拟机，请访问`http://localhost:8787/auth-sign-in`。使用用户ID
    **packt** 和密码 **packt**（与用户ID相同）登录。
- en: 'Note that if you had installed RStudio locally, you''ll not have a separate
    login screen. The instruction is purely for the Packt Data Science VM:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你在本地安装了RStudio，则不会有单独的登录界面。该说明仅适用于Packt数据科学虚拟机：
- en: '![](img/12c68685-ff73-4579-a21c-98849e8b3b39.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12c68685-ff73-4579-a21c-98849e8b3b39.png)'
- en: Logging into RStudio Server (Only for Packt VM)
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 登录RStudio Server（仅适用于Packt虚拟机）
- en: 'If you receive an error message stating that the site cannot be loaded, it
    may be due to the fact that the port forwarding has not been set up. To fix the
    issue, make the following changes:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到错误信息提示网站无法加载，可能是因为没有设置端口转发。要解决此问题，请进行以下更改：
- en: In VirtualBox, right-click on the VM and select Settings.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VirtualBox中，右键点击虚拟机并选择“设置”。
- en: 'Click on Network under Settings and expand the arrow next to **Advanced**:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置中点击“网络”，并展开**高级**旁边的箭头：
- en: '![](img/06f21a60-4570-4f94-899f-56ac4a3252c7.png)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06f21a60-4570-4f94-899f-56ac4a3252c7.png)'
- en: Setting up the VM parameters
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 设置虚拟机参数
- en: 'Click on Port Forwarding and add a rule to forward port 8787 from the VM to
    the host. The rule marked as Packt Rule has to be added, shown as follows:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击端口转发并添加一条规则，将端口8787从虚拟机转发到主机。必须添加标记为“Packt Rule”的规则，如下所示：
- en: '![](img/6b314a56-7f40-446f-91be-e897722d4fd5.png)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b314a56-7f40-446f-91be-e897722d4fd5.png)'
- en: Configuring Port Forwarding
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 配置端口转发
- en: 'After logging in, you''ll see the following screen. This is the interface for
    RStudio, which you''ll be using to complete the exercise. We''ll discuss R and
    RStudio in much more detail in later chapters, and this section illustrates the
    process to create the basic web application:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，你将看到以下界面。这是RStudio的界面，你将使用它来完成练习。我们将在后面的章节中更详细地讨论R和RStudio，而本节则展示了创建基本Web应用程序的过程：
- en: '![](img/c1d7dd91-08c0-4587-beff-d4778a0b216b.png)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1d7dd91-08c0-4587-beff-d4778a0b216b.png)'
- en: The RStudio Console
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio控制台
- en: Install the necessary R packages. Click on File | R Script and copy and paste
    the code below.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装必要的R包。点击“文件”|“R脚本”，然后复制并粘贴下面的代码。
- en: 'Then, click on Source to execute the following lines:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击“源”以执行以下代码：
- en: '[PRE20]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/c6b69841-8844-46fc-8402-ce3d0ce6b64c.png)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6b69841-8844-46fc-8402-ce3d0ce6b64c.png)'
- en: Installing required packages in R via RStudio
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 通过RStudio在R中安装所需的包
- en: 'Click on File|New File|Shiny Web App:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“文件”|“新建文件”|“Shiny Web App”：
- en: '>![](img/c8c2361f-3059-4d7b-a1cf-b050cac17ceb.png)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/c8c2361f-3059-4d7b-a1cf-b050cac17ceb.png)'
- en: Creating a new RShiny Application
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的RShiny应用程序
- en: 'Type in `cmspackt` under application name and click on Create:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`application name`下输入`cmspackt`并点击“创建”：
- en: '![](img/1ae74872-4594-43a0-8ced-0261aee782cf.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ae74872-4594-43a0-8ced-0261aee782cf.png)'
- en: Assigning a name to the RShiny Application
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 为RShiny应用程序命名
- en: 'This will create a `cmspackt` folder in the home directory, shown as follows:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在主目录中创建一个`cmspackt`文件夹，如下所示：
- en: '![](img/1d1c3d4f-f324-4da0-b296-a15bd122852f.png)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d1c3d4f-f324-4da0-b296-a15bd122852f.png)'
- en: The app.R file for the R Shiny Application
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: R Shiny应用程序的app.R文件
- en: 'Copy and paste the following code into the `app.R` section:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码复制并粘贴到`app.R`部分：
- en: '[PRE21]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Click on New Folder in the lower-right box:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右下角的“新建文件夹”：
- en: '![](img/a039acf3-9819-4b74-928f-9e1cd6368a76.png)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a039acf3-9819-4b74-928f-9e1cd6368a76.png)'
- en: Creating a folder for CSS files
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 为CSS文件创建一个文件夹
- en: 'Rename the new folder to `cmspackt/www`, shown as follows:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件夹重命名为`cmspackt/www`，如下所示：
- en: '![](img/607404fd-4ad4-4764-a04c-e27d0ebff3a3.png)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![](img/607404fd-4ad4-4764-a04c-e27d0ebff3a3.png)'
- en: Assigning a name to the folder
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 为文件夹命名
- en: 'Click on File | New File |Text File:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“文件”|“新建文件”|“文本文件”：
- en: '![](img/27544c53-5a66-4238-ae1a-8ae9de529128.png)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27544c53-5a66-4238-ae1a-8ae9de529128.png)'
- en: Creating the CSS File
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 创建CSS文件
- en: 'Copy and paste the following code:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴以下代码：
- en: '[PRE22]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Click on File | Save As to save the file, as follows:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“文件”|“另存为”保存文件，如下所示：
- en: '![](img/3cb929de-b700-4f88-b88e-124f2689ec3b.png)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cb929de-b700-4f88-b88e-124f2689ec3b.png)'
- en: Select Save As for the CSS File
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“另存为”CSS文件
- en: 'Save as `/home/packt/cmspackt/www/packt.css`, shown as follows:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存为`/home/packt/cmspackt/www/packt.css`，如下所示：
- en: '![](img/1ed14459-0a0a-4fc0-aaea-c89a574cf876.png)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ed14459-0a0a-4fc0-aaea-c89a574cf876.png)'
- en: Saving the CSS File
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 保存CSS文件
- en: Your application is now ready for use!
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序现在已准备好使用！
- en: Putting it all together - The CMS Open Payments application
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切整合在一起——CMS Open Payments应用程序
- en: 'In the prior sections, we have learned how to:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经学习了如何：
- en: Download the datasets
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载数据集
- en: Create the backend database
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建后端数据库
- en: Create the code for the backend database
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建后端数据库的代码
- en: Set up RStudio
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置RStudio
- en: Create the R Shiny application
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建R Shiny应用程序
- en: 'To start the application, complete the following steps:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动应用程序，请完成以下步骤：
- en: Start the Q application, make sure you are in the home directory. Type pwd and
    hit Enter. This will show the present working directory of `/home/packt` as shown
    in the coming image.
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Q应用程序，确保你在主目录中。输入pwd并按Enter键。这将显示当前工作目录`/home/packt`，如下图所示。
- en: Next, type `q` and hit Enter.
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输入`q`并按Enter键。
- en: At the `q` prompt, type in `\l cms.q`.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `q` 提示符下，键入 `\l cms.q`。
- en: Note that `cms.q` is the file we created in our earlier section when developing
    the Q application.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`cms.q` 是我们在前一部分开发 Q 应用程序时创建的文件。
- en: 'The script will load the database and return back to the `q)` prompt:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将加载数据库并返回到 `q)` 提示符：
- en: '![](img/21059576-46c9-4666-bdb7-d8b5c1c04210.png)'
  id: totrans-551
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21059576-46c9-4666-bdb7-d8b5c1c04210.png)'
- en: 'Putting it all together: Loading the CMS KDB+ Q Script in KDB+ Session'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容整合：在 KDB+ 会话中加载 CMS KDB+ Q 脚本
- en: Launch the CMS Open Payment application
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 CMS Open Payment 应用程序
- en: 'In RStudio, open the `app.R` file (which contains the R Code) and click on
    Run App at the top-right, shown as follows:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 RStudio 中，打开 `app.R` 文件（包含 R 代码），然后点击右上角的 Run App 按钮，如下所示：
- en: '![](img/58e42772-85d4-407f-af98-f324ec235ade.png)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58e42772-85d4-407f-af98-f324ec235ade.png)'
- en: Running the RShiny Application
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 RShiny 应用程序
- en: 'This will launch the web application, shown as follows:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动 Web 应用程序，如下所示：
- en: '![](img/63e5338e-1ad6-4996-94ff-b1eff05d1ba9.png)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63e5338e-1ad6-4996-94ff-b1eff05d1ba9.png)'
- en: The RShiny Application
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: RShiny 应用程序
- en: 'We have now finished developing a complete CMS Open Payments application that
    allows the end user to filter, aggregate, and analyze the data. Now, you can run
    queries by selecting various options on the screen. There are two functionalities
    in the app:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了完整的 CMS Open Payments 应用程序的开发，该程序允许最终用户筛选、聚合和分析数据。现在，您可以通过在屏幕上选择各种选项来运行查询。应用程序具有两种功能：
- en: Filtering data (default view)
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据筛选（默认视图）
- en: Aggregating data (you can switch to this option by selecting Aggregate Data
    from the Display Type menu)
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合数据（您可以通过从显示类型菜单中选择 Aggregate Data 切换到此选项）
- en: Applications
  id: totrans-563
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序
- en: '**A filtering example**: To see payments made by a company for a certain drug
    in the state of NY:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个筛选示例**：要查看某公司在纽约州为某种药物支付的费用：'
- en: '![](img/3be31cd1-a953-4cc6-a6ad-2e29e2071aeb.png)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3be31cd1-a953-4cc6-a6ad-2e29e2071aeb.png)'
- en: Using the RShiny Application
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RShiny 应用程序
- en: Note that the system processed 11 million records in 21 milliseconds, as shown
    in the header message. The name of the company and the product has been blanked
    out in the screenshot for privacy, but you are free to try out different options
    for both fields.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，系统在 21 毫秒内处理了 1100 万条记录，如头部消息所示。截图中公司和产品的名称已被隐去以保护隐私，但您可以自由尝试为这两个字段选择不同的选项。
- en: Note that in the default VM, we are using only one core with very limited memory,
    and the speed with which the data is processed using kdb+ even on a laptop with
    very limited resources easily exceeds the performance of many well-to-do commercial
    solutions.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在默认虚拟机中，我们仅使用一个核心且内存非常有限，即使是在资源极为有限的笔记本上，使用 kdb+ 处理数据的速度也轻松超过了许多商业解决方案的性能。
- en: '**An aggregation example**: To see total payments grouped by state, payment
    category, and payment nature for a specific company and product, select the options
    for the fields *Aggregate Data* and *Calculate Metrics*. Please note that the
    name of the company and the product have been hidden in the screenshot for privacy
    reasons only.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个聚合示例**：要查看某公司和产品按州、支付类别和支付性质分组的总支付金额，请选择 *Aggregate Data* 和 *Calculate
    Metrics* 字段的选项。请注意，截图中公司和产品的名称仅因隐私原因而被隐藏。'
- en: 'Note the message at the top that states:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意顶部的消息，显示如下：
- en: '![](img/5abd0a19-3bf8-45ff-a9aa-9d41ab2e3125.png)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5abd0a19-3bf8-45ff-a9aa-9d41ab2e3125.png)'
- en: Log message indicating query and application performance
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息，指示查询和应用程序的性能
- en: This indicates the speed with which the underlying kdb+ database processed the
    data. In this case, it filtered and *aggregated 11 million records in 22 milliseconds*
    for the given options.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示底层 kdb+ 数据库处理数据的速度。在这种情况下，它对给定选项进行了筛选并 *在 22 毫秒内聚合了 1100 万条记录*。
- en: '![](img/5d5b097a-918a-4613-a01d-8572efd32706.png)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d5b097a-918a-4613-a01d-8572efd32706.png)'
- en: CMS OpenPayments Application Screenshot
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: CMS OpenPayments 应用程序截图
- en: Summary
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced the concept of NoSQL. The term has gained popularity
    in recent years, especially due to its relevance and direct application to **big
    data** analytics. We discussed the core terminologies in NoSQL, their various
    types, and popular software used in the industry for such capabilities. We concluded
    with a couple of tutorials using MongoDB and kdb+.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 NoSQL 的概念。近年来，随着其与 **大数据** 分析的相关性和直接应用，NoSQL 一词变得越来越流行。我们讨论了 NoSQL 的核心术语、各种类型及其在行业中使用的流行软件。最后，我们通过几个
    MongoDB 和 kdb+ 的教程进行了总结。
- en: We also built an application using R and R Shiny to create a dynamic web interface
    to interact with the data loaded in kdb+.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用R和R Shiny构建了一个应用程序，创建了一个动态网页界面，用于与加载在kdb+中的数据进行交互。
- en: The next chapter will introduce another common technology in data science today,
    known as Spark. It is yet another toolkit that empowers data scientists across
    the world today.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍数据科学中另一种常见技术——Spark。它是当今全球数据科学家使用的又一工具包。
