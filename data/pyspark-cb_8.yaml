- en: GraphFrames – Graph Theory with PySpark
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphFrames - 使用PySpark进行图论
- en: 'In this chapter, we will cover how to work with GraphFrames for Apache Spark.
    You will learn the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何使用Apache Spark的GraphFrames。您将学习以下内容：
- en: A quick primer on graph theory and GraphFrames for Apache Spark
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Apache Spark的图论和GraphFrames的快速入门
- en: Installing GraphFrames
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装GraphFrames
- en: Preparing the data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备数据
- en: Building the graph
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建图
- en: Running queries against the graph
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对图运行查询
- en: Understanding the graph
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解图
- en: Using PageRank to determine airport ranks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PageRank确定机场排名
- en: Finding the fewest number of connections
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找最少的连接数
- en: Visualizing your graph
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化您的图
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'Graphs enable solving certain data problems more easily and intuitively. At
    the core of a graph lies concepts of edges, nodes (or vertices), and their properties.
    For example, the following are two seemingly disconnected graphs. The left one
    represents a social network and the relationship (the *edges* of the graph) between
    friends (the *vertices* of the graph), while the right one is a graph that represents
    restaurant recommendations. Note that the vertices for our restaurant recommendations
    are not only the restaurants themselves but also the cuisine type (for example,
    Ramen) and location (for example, Vancouver, B.C., Canada); these are the properties
    of the vertices. This ability to assign nodes to virtually anything and use edges
    to define the relationship between these nodes is the greatest virtue of graphs,
    that is, their flexibility:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图形使解决某些数据问题更加容易和直观。图的核心概念是边、节点（或顶点）及其属性。例如，以下是两个看似不相关的图。左边的图代表一个社交网络和朋友之间的关系（图的*边*），而右边的图代表餐厅推荐。请注意，我们的餐厅推荐的顶点不仅是餐厅本身，还包括美食类型（例如拉面）和位置（例如加拿大卑诗省温哥华）；这些是顶点的属性。将节点分配给几乎任何东西，并使用边来定义这些节点之间的关系的能力是图的最大优点，即它们的灵活性：
- en: '![](img/00168.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00168.jpeg)'
- en: 'This flexibility allows us to conceptually connect these two seemingly disparate
    graphs into one common graph. In this case, we can join the social network with
    restaurant recommendations, in which the edges (that is, connections) between
    the friends and the restaurants are through their ratings:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性使我们能够在概念上将这两个看似不相关的图连接成一个共同的图。在这种情况下，我们可以将社交网络与餐厅推荐连接起来，其中朋友和餐厅之间的边（即连接）是通过他们的评分进行的：
- en: '![](img/00169.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00169.jpeg)'
- en: 'For example, if Isabella wants to find a great ramen restaurant (vertex: cuisine
    type) in Vancouver (vertex: location), then traversing her friends'' reviews (edge:
    ratings), she will most likely choose Kintaro Ramen (vertex: restaurant) as both
    Samantha (vertex: friend) and Juliette (vertex: friend) have rated the restaurant
    favorably.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果Isabella想要在温哥华找到一家很棒的拉面餐厅（顶点：美食类型），然后遍历她朋友的评价（边：评分），她很可能会选择Kintaro Ramen（顶点：餐厅），因为Samantha（顶点：朋友）和Juliette（顶点：朋友）都对这家餐厅给出了好评。
- en: While graphs are intuitive and flexible, one of the key problems with a graph
    is that its traversal and computation of graph algorithms are often resource intensive
    and slow. With GraphFrames for Apache Spark, you are able to leverage the speed
    and performance of Apache Spark DataFrames to traverse and compute your graphs
    in a distributed and performant manner.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然图形直观且灵活，但图形的一个关键问题是其遍历和计算图形算法通常需要大量资源且速度缓慢。使用Apache Spark的GraphFrames，您可以利用Apache
    Spark DataFrames的速度和性能来分布式遍历和计算图形。
- en: Installing GraphFrames
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装GraphFrames
- en: 'Under the hood of GraphFrames are two Spark DataFrames: one for the vertices
    and other one for the edges. GraphFrames might be thought of as the next generation
    of Spark''s GraphX library, with some major improvements over the latter:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: GraphFrames的核心是两个Spark DataFrames：一个用于顶点，另一个用于边。GraphFrames可以被认为是Spark的GraphX库的下一代，相对于后者有一些重大改进：
- en: GraphFrames leverages the performance optimizations and simplicity of the DataFrame
    API.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphFrames利用了DataFrame API的性能优化和简单性。
- en: By using the DataFrame API, GraphFrames can be interacted with through Python,
    Java, and Scala APIs. In contrast, GraphX was only available through the Scala
    interface.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用DataFrame API，GraphFrames可以通过Python、Java和Scala API进行交互。相比之下，GraphX只能通过Scala接口使用。
- en: You can find the latest information on GraphFrames within the GraphFrames overview
    at [https://graphframes.github.io/](https://graphframes.github.io/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://graphframes.github.io/](https://graphframes.github.io/)的GraphFrames概述中找到GraphFrames的最新信息。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We require a working installation of Spark. This means that you would have
    followed the steps outlined in [Chapter 1](part0026.html#OPEK0-dc04965c02e747b9b9a057725c821827),
    *Installing and Configuring Spark*. As a reminder, to start the PySpark shell
    for your local Spark cluster, you can run the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个可用的Spark安装。这意味着您需要按照[第1章](part0026.html#OPEK0-dc04965c02e747b9b9a057725c821827)中概述的步骤进行操作，即*安装和配置Spark*。作为提醒，要启动本地Spark集群的PySpark
    shell，您可以运行以下命令：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Where `n` is the number of cores.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`n`是核心数。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: If you are running your job from a Spark CLI (for example, `spark-shell`, `pyspark`, `spark-sql`,
    or `spark-submit`), you can use the `–-packages` command, which will extract,
    compile, and execute the necessary code for you to use the GraphFrames package.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在从Spark CLI（例如`spark-shell`、`pyspark`、`spark-sql`或`spark-submit`）运行作业，您可以使用`--packages`命令，该命令将为您提取、编译和执行必要的代码，以便您使用GraphFrames包。
- en: 'For example, to use the latest GraphFrames package (which, at the time of writing
    this book, is version 0.5) with Spark 2.1 and Scala 2.11 with `spark-shell`, the
    command is:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在Spark 2.1和Scala 2.11与`spark-shell`一起使用最新的GraphFrames包（在撰写本书时为版本0.5），命令是：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, in order to use GraphFrames with Spark 2.3, you need to build the package
    from sources.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了在Spark 2.3中使用GraphFrames，您需要从源代码构建包。
- en: Check out the steps outlined here: [https://github.com/graphframes/graphframes/issues/267](https://github.com/graphframes/graphframes/issues/267).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 查看此处概述的步骤：[https://github.com/graphframes/graphframes/issues/267](https://github.com/graphframes/graphframes/issues/267)。
- en: If you are using a service such as Databricks, you will need to create a library
    with GraphFrames. For more information, please refer to how to create a library in
    Databricks at [https://docs.databricks.com/user-guide/libraries.html](https://docs.databricks.com/user-guide/libraries.html),
    and how to install a GraphFrames Spark package at [https://cdn2.hubspot.net/hubfs/438089/notebooks/help/Setup_graphframes_package.html](https://cdn2.hubspot.net/hubfs/438089/notebooks/help/Setup_graphframes_package.html).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用类似Databricks的服务，您将需要创建一个包含GraphFrames的库。有关更多信息，请参阅Databricks中如何创建库的信息，以及如何安装GraphFrames
    Spark包。
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can install a package such as GraphFrames by building it off the GraphFrames
    GitHub repository at [https://github.com/graphframes/graphframes](https://github.com/graphframes/graphframes),
    but an easier way is to utilize the GraphFrames Spark package which is available
    at [https://spark-packages.org/package/graphframes/graphframes](https://spark-packages.org/package/graphframes/graphframes).
    Spark Packages is a repository that contains an index of third-party packages
    for Apache Spark. By using Spark packages, PySpark will download the latest version
    of the GraphFrames Spark package, compile it, and then execute it within the context
    of your Spark job.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在GraphFrames GitHub存储库上构建来安装GraphFrames等包，但更简单的方法是使用可在[https://spark-packages.org/package/graphframes/graphframes](https://spark-packages.org/package/graphframes/graphframes)找到的GraphFrames
    Spark包。Spark Packages是一个包含Apache Spark第三方包索引的存储库。通过使用Spark包，PySpark将下载GraphFrames
    Spark包的最新版本，编译它，然后在您的Spark作业上下文中执行它。
- en: 'When you include the GraphFrames package using the following command, notice
    the call `graphframes` console output, denoting that the package is being pulled
    in from the `spark-packages` repository for compilation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用以下命令包含GraphFrames包时，请注意`graphframes`控制台输出，表示该包正在从`spark-packages`存储库中拉取进行编译：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Preparing the data
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备数据
- en: 'The example scenario we will use for the cookbook is on-time flight performance
    data (that is, flights scenario) that will make use of two sets of data:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在烹饪书中将使用的示例场景是准点飞行表现数据（即，航班场景），它将使用两组数据：
- en: Airline On-Time Performance and Causes of Flight Delays, available at [http://bit.ly/2ccJPPM](http://bit.ly/2ccJPPM).
    These datasets contain information about scheduled and actual departure and arrival
    times of flights, and the delay causes. The data is represented as reported by
    US air carriers and is collected by the Office of Airline Information, **Bureau
    of Transportation Statistics** (**BTS**).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 航空公司准点表现和航班延误原因可在[http://bit.ly/2ccJPPM](http://bit.ly/2ccJPPM)找到。这些数据集包含有关航班计划和实际起飞和到达时间以及延误原因的信息。数据由美国航空公司报告，并由交通统计局航空公司信息办公室收集。
- en: OpenFlights, airport and airline data available at [http://openflights.org/data.html](http://openflights.org/data.html).
    This dataset contains the list of US airport data, including the IATA code, airport
    name, and airport location.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenFlights，机场和航空公司数据可在[http://openflights.org/data.html](http://openflights.org/data.html)找到。该数据集包含美国机场数据列表，包括IATA代码、机场名称和机场位置。
- en: 'We will create two DataFrames: one for the airports and one for the flights.
    The `airports` DataFrame will make up our vertices and the `flights` DataFrames
    will represent all the edges of our GraphFrame.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个数据框：一个用于机场，一个用于航班。`airports`数据框将构成我们的顶点，而`flights`数据框将表示我们的GraphFrame的所有边。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'If you are running this locally, please copy the linked files to your local
    folder; for the purpose of this recipe, we''ll call the location `/data`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在本地运行此程序，请将链接的文件复制到本地文件夹；为了这个示例，我们将称位置为`/data`：
- en: Airline On-Time Performance and Causes at [http://bit.ly/2xs0XLH](http://bit.ly/2xs0XLH)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 航空公司准点表现和延误原因在[http://bit.ly/2xs0XLH](http://bit.ly/2xs0XLH)
- en: OpenFlights—Airports and airline data at [http://bit.ly/2J1CU7D](http://bit.ly/2J1CU7D)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenFlights-机场和航空公司数据在[http://bit.ly/2J1CU7D](http://bit.ly/2J1CU7D)
- en: If you are using Databricks, the data is already loaded into the `/databricks-datasets`
    folder; the location of the files can be found at `/databricks-datasets/flights/airport-codes-na.txt`
    and `/databricks-datasets/flights/departuredelays.csv` for airports and flights
    data, respectively.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Databricks，数据已经加载到`/databricks-datasets`文件夹中；文件的位置可以在`/databricks-datasets/flights/airport-codes-na.txt`和`/databricks-datasets/flights/departuredelays.csv`中找到，分别用于机场和航班数据。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To prepare our data for our graph, we will initially clean up the data and
    include only the airport codes that exist within the available flight data. That
    is, we exclude any airports that do not exist in the `DepartureDelays.csv` dataset.
    The upcoming recipe executes the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备我们的图数据，我们将首先清理数据，并仅包括存在于可用航班数据中的机场代码。也就是说，我们排除任何在`DepartureDelays.csv`数据集中不存在的机场。接下来的步骤执行以下操作：
- en: Sets the file paths to the files you had downloaded
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置文件路径为您下载的文件
- en: Creates the `apts` and `deptDelays` DataFrames by reading the CSV files and
    inferring the schema, configured with headers
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过读取CSV文件并推断架构，配置了标题，创建了`apts`和`deptDelays`数据框
- en: The `iata` contains only the airport codes (the `IATA` column) that exist in
    the `deptDelays` DataFrame
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`iata`仅包含存在于`deptDelays`数据框中的机场代码（`IATA`列）。'
- en: Joins the `iata` and `apts` DataFrames to create the `apts_df` DataFrame
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`iata`和`apts`数据框连接起来，创建`apts_df`数据框
- en: 'The reason we filter out the data to create the `airports` DataFrame is that
    when we create our GraphFrame in the following recipes, we will only have vertices
    with edges for our graph:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们过滤数据以创建`airports` DataFrame的原因是，当我们在下面的示例中创建我们的GraphFrame时，我们将只有图的边缘的顶点：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The two key concepts used for this code snippet are:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此代码片段的两个关键概念是：
- en: '`spark.read.csv`: This `SparkSession` method returns a `DataFrameReader` object
    that encompasses the classes and functions that will allow us to read CSV files
    from a filesystem'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spark.read.csv`：这个`SparkSession`方法返回一个`DataFrameReader`对象，它包含了从文件系统读取CSV文件的类和函数'
- en: '`spark.sql`: This allows us to execute Spark SQL statements'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spark.sql`：这允许我们执行Spark SQL语句'
- en: For more information, please refer to the preceding chapters on Spark DataFrames,
    or refer to the PySpark master documentation of the `pyspark.sql` module at [http://spark.apache.org/docs/2.3.0/api/python/pyspark.sql.html](http://spark.apache.org/docs/2.3.0/api/python/pyspark.sql.html).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参考Spark DataFrames的前几章，或者参考`pyspark.sql`模块的PySpark主文档，网址为[http://spark.apache.org/docs/2.3.0/api/python/pyspark.sql.html](http://spark.apache.org/docs/2.3.0/api/python/pyspark.sql.html)。
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Before we read the data into our GraphFrame, let''s create one more DataFrame:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数据读入我们的GraphFrame之前，让我们再创建一个DataFrame：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It creates a `tripid` column that allows us to uniquely identify each trip.
    Note that this is a bit of a hack as we had converted the date (each trip has
    a unique date in this dataset) into an int column.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个`tripid`列，允许我们唯一标识每次旅行。请注意，这有点像是一个黑客行为，因为我们已经将日期（数据集中每次旅行都有一个唯一日期）转换为int列。
- en: The `date` column isn't really a traditional date per se as it is in the format
    of `MMYYHHmm`. Therefore, we first apply a `udf` to convert it into a proper format
    (the `toDate(...)` method). We then convert it into an actual timestamp format.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`列实际上并不是传统意义上的日期，因为它的格式是`MMYYHHmm`。因此，我们首先应用`udf`将其转换为正确的格式（`toDate(...)`方法）。然后将其转换为实际的时间戳格式。'
- en: Re-casts the `delay` and `distance` columns into integer values as opposed to
    string.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`delay`和`distance`列重新转换为整数值，而不是字符串。
- en: In the following sections, we will be using the airport codes (the `iata` column)
    as our vertex. To create the edges for our graph, we will need to specify the
    IATA codes for the source (originating airport) and destination (destination airport).
    The `join` statement and renaming of `f.origin` as `src` and `f.destination` as
    `dst` are in preparation for creating the GraphFrame to specify the edges (they
    are explicitly looking for the `src` and `dst` columns).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将使用机场代码（`iata`列）作为我们的顶点。为了为我们的图创建边缘，我们需要指定源（起始机场）和目的地（目的机场）的IATA代码。`join`语句和将`f.origin`重命名为`src`以及将`f.destination`重命名为`dst`是为了准备创建GraphFrame以指定边缘（它们明确寻找`src`和`dst`列）。
- en: Building the graph
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建图
- en: In the preceding sections, you installed GraphFrames and built the DataFrames
    required for the graph; now, you can start building the graph itself.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您安装了GraphFrames并构建了图所需的DataFrame；现在，您可以开始构建图本身了。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first component of this recipe involves importing the necessary libraries,
    in this case, the PySpark SQL functions (`pyspark.sql.functions`) and GraphFrames
    (`graphframes`). In the previous recipe, we had created the `src` and `dst` columns
    as part of creating the `deptsDelays_geo` DataFrame. When creating edges within
    GraphFrames, it is specifically looking for the `src` and `dst` columns to create
    the edges as per `edges`. Similarly, GraphFrames is looking for the column `id` to
    represent the graph vertex (as well as join to the `src` and `dst` columns). Therefore,
    when creating the vertexes, `vertices`, we rename the `IATA` column to `id`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的第一个组件涉及到导入必要的库，这种情况下是PySpark SQL函数（`pyspark.sql.functions`）和GraphFrames（`graphframes`）。在上一个示例中，我们已经创建了`deptsDelays_geo`
    DataFrame的一部分，创建了`src`和`dst`列。在GraphFrames中创建边缘时，它专门寻找`src`和`dst`列来创建边缘，就像`edges`一样。同样，GraphFrames正在寻找`id`列来表示图的顶点（以及连接到`src`和`dst`列）。因此，在创建顶点`vertices`时，我们将`IATA`列重命名为`id`：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that `edges` and `vertices` are DataFrames containing the edges and vertices
    of the graph, respectively. You can check this by viewing the data as noted in
    the following screenshots (in this case, we're using the `display` command within
    Databricks).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`edges`和`vertices`是包含图的边缘和顶点的DataFrame。您可以通过查看数据来检查这一点，如下面的屏幕截图所示（在这种情况下，我们在Databricks中使用`display`命令）。
- en: 'For example, the command `display(vertices)` shows the `id` (IATA code), `City`,
    `State`, and `Country` columns of the `vertices` DataFrame:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，命令`display(vertices)`显示`vertices` DataFrame的`id`（IATA代码）、`City`、`State`和`Country`列：
- en: '![](img/00170.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00170.jpeg)'
- en: 'Meanwhile, the command `display(edges)` shows the `tripid`, `delay`, `src`,
    `dst`, `city_dst`, and `state_dst` of the `edges` DataFrame:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，命令`display(edges)`显示`edges` DataFrame的`tripid`、`delay`、`src`、`dst`、`city_dst`和`state_dst`：
- en: '![](img/00171.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00171.jpeg)'
- en: The final statement, `GraphFrame(vertices, edges)`, performs the task of merging
    the two DataFrames into our GraphFrame, `graph`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的语句`GraphFrame(vertices, edges)`执行将两个DataFrame合并到我们的GraphFrame `graph`中的任务。
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As noted in the previous section, when creating a GraphFrame, it specifically
    looks for the following columns:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，创建GraphFrame时，它专门寻找以下列：
- en: '`id`: This identifies the vertex and will join to the `src` and `dst` columns.
    In our example, the IATA code `LAX` (representing **Los Angeles Airport**) is
    one of many airports that make up the vertices in our graph (`graph`).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这标识了顶点，并将连接到`src`和`dst`列。在我们的示例中，IATA代码`LAX`（代表**洛杉矶机场**）是构成我们图的顶点之一。'
- en: '`src`: The source vertex of our graph''s edges; for example, a flight from
    Los Angeles to New York has `src = LAX`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：我们图的边的源顶点；例如，从洛杉矶到纽约的航班的`src = LAX`。'
- en: '`dst`: The destination vertex of our graph''s edges; for example, a flight
    from Los Angeles to New York has `dst = JFK`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dst`: 我们图的边的目的地顶点；例如，从洛杉矶到纽约的航班的`dst = JFK`。'
- en: By creating the two DataFrames (`vertices` and `edges`) where the attributes
    follow the previously noted naming convention, we can invoke the GraphFrame to
    create our graph, utilizing the performance optimizations of the two DataFrames
    underneath.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建两个数据框（`vertices`和`edges`），其中属性遵循先前提到的命名约定，我们可以调用GraphFrame来创建我们的图，利用两个数据框的性能优化。
- en: Running queries against the graph
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对图运行查询
- en: Now that you have created your graph, start off by creating and running some
    simple queries against your GraphFrame.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了图，可以开始对GraphFrame运行一些简单的查询。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you have created the `graph` GraphFrame (derived from the `vertices`
    and `edges` DataFrames) from the previous section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经从上一节的`vertices`和`edges`数据框中创建了`graph` GraphFrame。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s start with some simple count queries to determine the number of airports
    (nodes or vertices; remember?) and the number of flights (the edges), which can
    be determined by applying `count()`. The call to `count()` is similar to a DataFrame
    except that you also need to include whether you are counting `vertices` or `edges`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些简单的计数查询开始，以确定机场的数量（节点或顶点；记住吗？）和航班的数量（边），可以通过应用`count()`来确定。调用`count()`类似于数据框，只是您还需要包括您正在计数`vertices`还是`edges`：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of these queries should be similar to the following output, denoting
    the 279 vertices (that is, airports) and more than 1.3 million edges (that is,
    flights):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询的输出应该类似于以下输出，表示有279个顶点（即机场）和超过130万条边（即航班）：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similar to DataFrames, you can also execute the `filter` and `groupBy` clauses
    to better understand the number of delayed flights. To understand the number of
    on-time or early flights, we use the filter where `delay <= 0`; the delayed flights,
    on the other hand, show `delay > 0`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据框类似，您也可以执行`filter`和`groupBy`子句，以更好地了解延误航班的数量。要了解准点或提前到达的航班数量，我们使用`delay <=
    0`的过滤器；而延误航班则显示`delay > 0`：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Diving further, you can filter for delayed flights (`delay > 0`) departing
    from San Francisco (`src = ''SFO''`) grouped by the destination airports, sorting
    by average delay descending (`desc("avg(delay)")`):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步深入，您可以过滤出从旧金山出发的延误航班（`delay > 0`），并按目的地机场分组，按平均延误时间降序排序（`desc("avg(delay)")`）：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/00172.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00172.jpeg)'
- en: 'If you are using the Databricks notebooks, you can visualize the GraphFrame
    queries. For example, we can determine the destination states with `delay > 100`
    minutes departing from Seattle using the following query:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Databricks笔记本，可以可视化GraphFrame查询。例如，我们可以使用以下查询确定从西雅图出发延误超过100分钟的航班的目的地州：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code produces the following map. The darker the blue hue, the
    more the delay that the flights experienced. From the following graph, you can
    see that most of the delayed flights departing Seattle have their destination
    within the state of California:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了以下地图。蓝色越深，航班延误越严重。从下图可以看出，大部分从西雅图出发的延误航班的目的地在加利福尼亚州内：
- en: '![](img/00173.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00173.jpeg)'
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作原理...
- en: 'As noted in previous sections, GraphFrames are built on top of two DataFrames:
    one for vertices and one for edges. This simply means that GraphFrames take advantage
    of the same performance optimizations as DataFrames (unlike the older GraphX).
    Just as importantly, they also take on many components of the Spark SQL syntax.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，GraphFrames建立在两个数据框之上：一个用于顶点，一个用于边。这意味着GraphFrames利用了与数据框相同的性能优化（不像较旧的GraphX）。同样重要的是，它们还继承了许多Spark
    SQL语法的组件。
- en: Understanding the graph
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解图
- en: To easily understand the complex relationship of city airports and the flights
    between each of them, we can use the concept of **motifs** to find patterns of
    airports connected by flights. The result is a DataFrame in which the column names
    are given by the motif keys.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易理解城市机场之间的复杂关系以及它们之间的航班，我们可以使用**motifs**的概念来查找由航班连接的机场的模式。结果是一个数据框，其中列名由motif键给出。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To make it easier to view our data within the context of Motifs, let''s first
    create a smaller version of the `graph` GraphFrame called `graphSmall`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易在Motifs的上下文中查看我们的数据，让我们首先创建一个名为`graphSmall`的`graph` GraphFrame的较小版本：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To execute a Motif, execute the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行Motif，执行以下命令：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result of this query can be seen as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的结果如下：
- en: '![](img/00174.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00174.jpeg)'
- en: Output of the motif query
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Motif查询的输出
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作原理...
- en: 'There is a lot to unpack with this example motif query, so let''s start with
    the query itself.  The first part of the query is to establish what our Motif
    is, which is to establish that we are looking for the relationships between vertices
    `(a)`, `(b)`, and `(c)`. Specifically, we''re concerned with the edges between
    the two sets of vertices, between `(a)` and `(b)`, as represented by `[ab]`, and
    between vertices `(b)` and `(c)` as represented by `[bc]`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的查询有很多内容，让我们从查询本身开始。查询的第一部分是建立我们的Motif，即建立我们要查找顶点`(a)`、`(b)`和`(c)`之间的关系。具体来说，我们关心的是两组顶点之间的边，即`(a)`和`(b)`之间的边，表示为`[ab]`，以及顶点`(b)`和`(c)`之间的边，表示为`[bc]`：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For example, we are trying to determine all the flights between two different
    cities where Los Angeles is the layover city (for example, Seattle - Los Angeles
    -> New York, Portland - Los Angeles -> Atlanta, and so on):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们试图确定两个不同城市之间的所有航班，洛杉矶是中转城市（例如，西雅图 - 洛杉矶 -> 纽约，波特兰 - 洛杉矶 -> 亚特兰大，等等）：
- en: '`(b)`: This represents the city of Los Angeles'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(b)`: 这代表了洛杉矶市'
- en: '`(a)`: This represent the originating cities, such as Seattle and Portland
    in this example'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(a)`: 这代表了起始城市，例如本例中的西雅图和波特兰'
- en: '`[ab]`: This represents the flights, such as Seattle - Los Angeles and Portland
    - Los Angeles in this example'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ab]`：这代表了航班，比如西雅图-洛杉矶和波特兰-洛杉矶在这个例子中'
- en: '`(c)`: This represents the destination cities, such as New York and Atlanta
    in this example'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(c)`：这代表了目的地城市，比如纽约和亚特兰大在这个例子中'
- en: '`[bc]`: This represents the flights, such as Los Angeles -> New York and Los
    Angeles -> Atlanta in this example'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[bc]`：这代表了航班，比如洛杉矶->纽约和洛杉矶->亚特兰大在这个例子中'
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that this last statement is an oversimplification of flights because it
    isn''t taking into account which flights are valid connector flights. Also, recall
    that `tripid` was generated based on time in the format of `MMDDHHMM` converted
    to an integer:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个陈述是对航班的过度简化，因为它没有考虑哪些航班是有效的连接航班。还要记住，`tripid`是基于时间格式为`MMDDHHMM`转换为整数生成的：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output displayed in the preceding subsection denotes all the flights where
    the stopover was San Francisco and there were flight delays of greater than 500
    minutes for either flights arriving or leaving `SFO`. Digging further into a single
    flight, let''s review the output of the first row, though we have pivoted it to
    make it easier to review:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面小节中显示的输出表示了所有在旧金山中转并且航班延误超过500分钟的航班。进一步挖掘单个航班，让我们回顾第一行的输出，尽管我们已经对其进行了旋转以便更容易审查：
- en: '| **Vertices** | **Values** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **顶点** | **数值** |'
- en: '| `[ab]` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `[ab]` |'
- en: '`tripid: 2021900`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tripid: 2021900`'
- en: '`delay: 39`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay: 39`'
- en: '`src: STL`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src: STL`'
- en: '`dst: SFO`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dst: SFO`'
- en: '|'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `(a)` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `(a)` |'
- en: '`id: STL`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id: STL`'
- en: '`City: St. Louis`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`City: St. Louis`'
- en: '`State: MO`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`State: MO`'
- en: '`Country: USA`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Country: USA`'
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `(b)` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `(b)` |'
- en: '`id: SFO`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id: SFO`'
- en: '`City: San Francisco`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`City: San Francisco`'
- en: '`State: CA`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`State: CA`'
- en: '`Country: USA`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Country: USA`'
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `[bc]` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `[bc]` |'
- en: '`tripid: 2030906`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tripid: 2030906`'
- en: '`delay: 516`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay: 516`'
- en: '`src: SFO`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src: SFO`'
- en: '`dst: PHL`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dst: PHL`'
- en: '|'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `(c)` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `(c)` |'
- en: '`id: PHL`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id: PHL`'
- en: '`City: Philadelphia`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`City: Philadelphia`'
- en: '`State: PA`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`State: PA`'
- en: '`Country: USA`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Country: USA`'
- en: '|'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: As noted previously, `[ab]` and `[bc]` are the flights while `[a]`, `[b]`, and
    `[c]` are the airports. In this example, the flight departing from St. Louis (`STL`)
    to San Francisco had a delay of 39 minutes, but its potential connecting flight
    to Philadelphia (`PHL`) had a delay of 516 minutes. As you dig through the results,
    you can see a lot of different potential flight patterns between originating and
    final destination cities centered around San Francisco as the primary stop over.
    This query will become more complicated as you take on even larger hub cities
    such as Atlanta, Dallas, and Chicago.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`[ab]`和`[bc]`是航班，而`[a]`、`[b]`和`[c]`是机场。在这个例子中，从圣路易斯（`STL`）到旧金山的航班延误了39分钟，但它潜在的连接航班到费城（`PHL`）延误了516分钟。当您深入研究结果时，您可以看到围绕旧金山作为主要中转站的起始和最终目的地城市之间的许多不同的潜在航班模式。随着您接管更大的枢纽城市，如亚特兰大、达拉斯和芝加哥，这个查询将变得更加复杂。
- en: Using PageRank to determine airport ranking
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PageRank确定机场排名
- en: 'PageRank is an algorithm popularized by the Google Search Engine and created
    by Larry Page. Ian Rogers says (see [http://www.cs.princeton.edu/~chazelle/courses/BIB/pagerank.htm](http://www.cs.princeton.edu/~chazelle/courses/BIB/pagerank.htm)):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank是由谷歌搜索引擎推广并由拉里·佩奇创建的算法。Ian Rogers说（见[http://www.cs.princeton.edu/~chazelle/courses/BIB/pagerank.htm](http://www.cs.princeton.edu/~chazelle/courses/BIB/pagerank.htm)）：
- en: '"(...)PageRank is a “vote”, by all the other pages on the Web, about how important
    a page is. A link to a page counts as a vote of support. If there’s no link there’s
    no support (but it’s an abstention from voting rather than a vote against the
    page)."'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: “(...)PageRank是所有其他网页对页面重要性的“投票”。对页面的链接算作支持的投票。如果没有链接，就没有支持（但这是对页面的投票而不是反对的弃权）。”
- en: As you might imagine, this method can be applied to other problems and not only
    to ranking web pages. In our context, we can use it to determine airport ranking.
    To achieve this, we can use the number of flights and connections to and from
    various airports included that are in this departure delay dataset.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想象，这种方法不仅可以应用于排名网页，还可以应用于其他问题。在我们的情境中，我们可以用它来确定机场的排名。为了实现这一点，我们可以使用包括在这个出发延误数据集中的各种机场的航班数量和连接到各个机场的航班数量。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you have created the `graph` GraphFrame from the preceding subsections.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经从前面的小节中创建了`graph` GraphFrame。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute the following code snippet to determine the most important airport
    in our dataset via the PageRank algorithm:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码片段，通过PageRank算法确定我们数据集中最重要的机场：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see from the output in the following graph, Atlanta, Dallas, and
    Chicago are the top three most important cities (note that this dataset contains
    US data only):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下图表的输出中可以看出，亚特兰大、达拉斯和芝加哥是最重要的三个城市（请注意，此数据集仅包含美国数据）：
- en: '![](img/00175.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00175.jpeg)'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'At the time of writing this book,, the current version of GraphFrames is v0.5,
    which contains two implementations of PageRank:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，GraphFrames的当前版本是v0.5，其中包含了PageRank的两种实现：
- en: The one we are using utilizes the GraphFrame interface and runs PageRank for
    a fixed number of iterations by setting `maxIter`
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用的版本利用了GraphFrame接口，并通过设置`maxIter`运行了固定次数的PageRank。
- en: Another version uses the `org.apache.spark.graphx.Pregel` interface and runs
    PageRank until convergence by setting `tol`
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个版本使用`org.apache.spark.graphx.Pregel`接口，并通过设置`tol`运行PageRank直到收敛。
- en: For more information, please refer to the GraphFrames Scala documentation on
    PageRank at [https://graphframes.github.io/api/scala/index.html#org.graphframes.lib.PageRank](https://graphframes.github.io/api/scala/index.html#org.graphframes.lib.PageRank).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅[https://graphframes.github.io/api/scala/index.html#org.graphframes.lib.PageRank](https://graphframes.github.io/api/scala/index.html#org.graphframes.lib.PageRank)上的GraphFrames
    Scala文档中的PageRank。
- en: 'As noted previously, we are using the standalone GraphFrame version of PageRank
    by setting:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们正在使用独立的GraphFrame版本的PageRank，设置如下：
- en: '`resetProbability`: This is currently set to the default value of `0.15`, which represents
    the probability of resetting to a random vertex. If the value is too high, it
    means that it will take longer to complete its calculation, but if the value is
    too low, the calculations may overshoot and not converge.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resetProbability`：目前设置为默认值`0.15`，表示重置到随机顶点的概率。如果值太高，计算时间会更长，但如果值太低，计算可能会超出范围而无法收敛。'
- en: '`maxIter`: For this demo, we have set the value to `5`; the higher the number,
    the higher the probability of a more precise calculation.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxIter`：对于此演示，我们将该值设置为`5`；数字越大，计算的精度越高。'
- en: Finding the fewest number of connections
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找最少的连接
- en: When you're flying to many cities, one of the recurring problems is to determine
    either the shortest path between two cities or the shortest time of travel. From
    the viewpoint of the airline traveler, the aim is to find the shortest set of
    flights between two cities. From the viewpoint of the airline, determining how
    to route their passengers between cities as efficiently as possible increases
    customer satisfaction and lowers prices (less fuel, wear and tear on equipment,
    ease for the flight crew, and so on). Within the context of GraphFrames and graph
    algorithms, one approach would be to use the **breadth first search** (**BFS**)
    algorithm to help us find the shortest path between these airports.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当您飞往许多城市时，一个经常出现的问题是确定两个城市之间的最短路径或最短旅行时间。从航空旅客的角度来看，目标是找到两个城市之间最短的航班组合。从航空公司的角度来看，确定如何尽可能高效地将乘客路由到各个城市，可以提高客户满意度并降低价格（燃料消耗、设备磨损、机组人员的便利等）。在GraphFrames和图算法的背景下，一个方法是使用**广度优先搜索**（**BFS**）算法来帮助我们找到这些机场之间的最短路径。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you have created the `graph` GraphFrame from the preceding subsections.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经从前面的小节中创建了`graph` GraphFrame。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Let''s start using our BFS algorithm to determine whether there are any direct
    flights between `SFO` and `SEA`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用我们的BFS算法来确定`SFO`和`SEA`之间是否有直达航班：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can tell from the output, there are many direct flights between Seattle
    (`SEA`) and San Francisco (`SFO`):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，西雅图（`SEA`）和旧金山（`SFO`）之间有许多直达航班：
- en: '![](img/00176.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00176.jpeg)'
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'When calling the BFS algorithm, the key parameters are `fromExpr`, `toExpr`,
    and `maxPathLength`. As our vertices contain the airports, to understand the number
    of direct flights from Seattle to San Francisco, we will specify:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用BFS算法时，关键参数是`fromExpr`、`toExpr`和`maxPathLength`。由于我们的顶点包含了机场，为了了解从西雅图到旧金山的直达航班数量，我们将指定：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `maxPathLength` is the parameter used to specify the maximum number of edges
    between the two vertices. If `maxPathLength = 1`, it means that we have only one
    edge between the two vertices. That is, there is only one flight between the two
    airports or a direct flight between those two cities. Increasing this value means
    BFS will attempt to find multiple connections between your two cities. For example,
    if we were to specify `maxPathLength = 2`, this would mean two edges or two flights
    between Seattle and San Francisco. That indicates a layover city, for example,
    SEA - POR -> SFO, SEA - LAS -> SFO, SEA - DEN -> SFO, and so on.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxPathLength`是用来指定两个顶点之间的最大边数的参数。如果`maxPathLength = 1`，表示两个顶点之间只有一条边。也就是说，两个机场之间只有一次航班或者两个城市之间有一次直达航班。增加这个值意味着BFS将尝试找到两个城市之间的多个连接。例如，如果我们指定`maxPathLength
    = 2`，这意味着西雅图和旧金山之间有两条边或两次航班。这表示一个中转城市，例如，SEA - POR -> SFO，SEA - LAS -> SFO，SEA
    - DEN -> SFO等。'
- en: There's more...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'What if you want to find connections between two cities that typically do not
    have direct flights? For example, let''s find out the possible routes between
    San Francisco and Buffalo:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要找到通常没有直达航班的两个城市之间的连接，该怎么办？例如，让我们找出旧金山和水牛城之间的可能航线：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `OK` in this case indicates that there are no direct flights between San
    Francisco and Buffalo as we could not retrieve a single edge (at least from this
    dataset). But to find out whether there are any layover flights, just change `maxPathLength
    = 2` (to indicate a single stopover city):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`OK`表示旧金山和水牛城之间没有直达航班，因为我们无法检索到单个边缘（至少从这个数据集中）。但是，要找出是否有任何中转航班，只需更改`maxPathLength
    = 2`（表示一个中转城市）：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see here, there are many flights with a single stopover connecting
    San Francisco and Buffalo:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有许多带有一次中转的航班连接旧金山和水牛城：
- en: '![](img/00177.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00177.jpeg)'
- en: See also
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'But what is the most common layover between San Francisco and Buffalo? Looking
    at the preceding results, it seems like Minneapolis, but looks can be deceiving.
    Instead, run the following query:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但是旧金山和水牛城之间最常见的中转城市是哪个？从前面的结果来看，似乎是明尼阿波利斯，但外表可能具有欺骗性。相反，运行以下查询：
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see from the following graph, JFK is the most common transfer point
    between these two cities:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，JFK是这两个城市之间最常见的中转点：
- en: '![](img/00178.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00178.jpeg)'
- en: Visualizing the graph
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化图形
- en: In the preceding recipes, we have been visualizing our flights using Databrick
    notebook's native visualizations (for example, bar chart, line chart, maps, and
    so on). But we have not yet visualized our graph as a graph. In this section,
    we will leverage Mike Bostock's Airports D3.js visualization ([https://mbostock.github.io/d3/talk/20111116/airports.html](https://mbostock.github.io/d3/talk/20111116/airports.html))
    within our Databricks notebook.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们一直在使用Databrick笔记本的本地可视化功能来可视化我们的航班（例如，条形图、折线图、地图等）。但是我们还没有将我们的图形可视化为图形。在本节中，我们将利用Mike
    Bostock的Airports D3.js可视化工具（[https://mbostock.github.io/d3/talk/20111116/airports.html](https://mbostock.github.io/d3/talk/20111116/airports.html)）在我们的Databricks笔记本中进行可视化。
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you have created the `graph` GraphFrame and the source `deptsDelays_GEO`
    DataFrame from the preceding subsections.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经从前面的小节中创建了`graph` GraphFrame和源`deptsDelays_GEO` DataFrame。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will be leveraging our Python Databricks notebook, but we will include the
    following Scala cell. At the top level here''s the flow of the code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用我们的Python Databricks笔记本，但我们将包括以下Scala单元。在这里的顶层，代码的流程如下：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the next cell, you will call the following Scala cell:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个单元格中，您将调用以下Scala单元：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Which results in the following visualization:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下可视化效果：
- en: '![](img/00179.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00179.jpeg)'
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `force` function has the following definition:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`force`函数有以下定义：'
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Recall that we call this function in the next cell using the following code
    snippet:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们在下一个单元格中使用以下代码片段调用这个函数：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The height and width are readily apparent, but the key call out is that we use
    a Spark SQL query against the `deptsDelays_GEO` DataFrame to define the edges
    (that is, the source and destination IATA codes). As the IATA codes are already
    defined within the calls within `showGraph`, we already have the vertices of our
    visualization. Note that as we had already created the DataFrame `deptsDelays_GEO`,
    even though it was created using PySpark, it is accessible by Scala within the
    same Databricks notebook.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 高度和宽度是显而易见的，但关键的呼叫是我们使用Spark SQL查询来定义边缘（即源和目的地IATA代码）对`deptsDelays_GEO` DataFrame。由于IATA代码已经在`showGraph`的调用中定义，我们已经有了可视化的顶点。请注意，由于我们已经创建了DataFrame
    `deptsDelays_GEO`，即使它是使用PySpark创建的，它也可以在同一个Databricks笔记本中被Scala访问。
