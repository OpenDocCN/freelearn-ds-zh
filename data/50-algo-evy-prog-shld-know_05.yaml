- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4  '
- en: Designing Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '设计算法  '
- en: This chapter presents the core design concepts of various algorithms. It discusses
    the strengths and weaknesses of various techniques for designing algorithms. By
    understanding these concepts, we will learn how to design efficient algorithms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '本章介绍了各种算法的核心设计概念。讨论了设计算法的各种技术的优缺点。通过理解这些概念，我们将学习如何设计高效的算法。  '
- en: This chapter starts by discussing the different choices available to us when
    designing algorithms. Then, it discusses the importance of characterizing the
    particular problem that we are trying to solve. Next, it uses the famous **Traveling
    Salesperson Problem** (**TSP**) as a use case and applies the different design
    techniques that we will be presenting. Then, it introduces linear programming
    and discusses its applications. Finally, it presents how linear programming can
    be used to solve a real-world problem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '本章首先讨论我们在设计算法时可以选择的不同方案。然后，讨论了准确描述我们试图解决的具体问题的重要性。接下来，以著名的**旅行商问题**（**TSP**）为用例，应用我们将要介绍的不同设计技术。然后，引入线性规划并讨论其应用。最后，介绍如何利用线性规划解决一个现实世界问题。  '
- en: By the end of this chapter, you should be able to understand the basic concepts
    of designing an efficient algorithm.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '到本章结束时，你应该能够理解设计高效算法的基本概念。  '
- en: 'The following concepts are discussed in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '本章讨论了以下概念：  '
- en: The various approaches to designing an algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '设计算法的不同方法  '
- en: Understanding the trade-offs involved in choosing the correct design for an
    algorithm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解选择正确算法设计所涉及的权衡
- en: Best practices for formulating a real-world problem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '解决现实世界问题的最佳实践  '
- en: Solving a real-world optimization problem
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '解决一个现实世界中的优化问题  '
- en: Let’s first look at the basic concepts of designing an algorithm.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '首先让我们来看设计算法的基本概念。  '
- en: Introducing the basic concepts of designing an algorithm
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '介绍设计算法的基本概念  '
- en: 'An algorithm, according to the American Heritage Dictionary, is defined as
    follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '根据《美国传统词典》，算法被定义为：  '
- en: A finite set of unambiguous instructions that given some set of initial conditions
    can be performed in a prescribed sequence to achieve a certain goal and that has
    a recognizable set of end conditions.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '一组有限的明确指令，在给定初始条件下，可以按照规定的顺序执行，以实现某个特定目标，并且具有可识别的结束条件。  '
- en: 'Designing an algorithm is about coming up with this “*finite set of unambiguous
    instructions*” in the most efficient way to “*achieve a certain goal*.” For a
    complex real-world problem, designing an algorithm is a tedious task. To come
    up with a good design, we first need to fully understand the problem we are trying
    to solve. We start by figuring out what needs to be done (that is, understanding
    the requirements) before looking into how it will be done (that is, designing
    the algorithm). Understanding the problem includes addressing both the functional
    and non-functional requirements of the problem. Let’s look at what these are:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '设计算法是以最高效的方式提出这组“*有限的明确指令*”，以“*实现特定目标*”。对于一个复杂的现实世界问题，设计算法是一项繁琐的任务。为了提出一个好的设计，我们首先需要完全理解我们试图解决的问题。我们从弄清楚需要做什么（即理解需求）开始，再去思考如何做（即设计算法）。理解问题包括解决问题的功能性和非功能性需求。让我们来看看这些是什么：  '
- en: Functional requirements formally specify the input and output interfaces of
    the problem that we want to solve and the functions associated with them. Functional
    requirements help us understand data processing, data manipulation, and the calculations
    that need to be implemented to generate the result.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '功能性需求正式地指定了我们想要解决的问题的输入和输出接口及其相关功能。功能性需求帮助我们理解数据处理、数据操作和实现计算来生成结果所需的操作。  '
- en: Non-functional requirements set the expectations about the performance and security
    aspects of the algorithm.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '非功能性需求设定了关于算法性能和安全方面的期望。  '
- en: Note that designing an algorithm is about addressing both the functional and
    non-functional requirements in the best possible way under the given set of circumstances
    and keeping in mind the set of resources available to run the designed algorithm.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，设计算法是关于在给定的条件下，以最佳方式处理功能性和非功能性需求，并考虑到运行设计算法所需的资源。  '
- en: 'To come up with a good response that can meet the functional and non-functional
    requirements, our design should respect the following three concerns, as discussed
    in *Chapter 1*, *Overview of Algorithms*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得出一个既能满足功能要求又能满足非功能要求的良好响应，我们的设计应当关注以下三个方面，正如*第1章* *算法概述*中所讨论的：
- en: '**Correctness**: Will the designed algorithm produce the result we expect?'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确性**：设计的算法是否能产生我们预期的结果？'
- en: '**Performance**: Is this the optimal way to get these results?'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：这是获取这些结果的最佳方式吗？'
- en: '**Scalability**: How is the algorithm going to perform on larger datasets?'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：该算法在处理更大数据集时表现如何？'
- en: In this section, let’s look at these concerns one by one.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将逐一讨论这些关注点。
- en: 'Concern 1: correctness: will the designed algorithm produce the result we expect?'
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点1：正确性：设计的算法是否能产生我们预期的结果？
- en: 'An algorithm is a mathematical solution to a real-world problem. To be useful,
    it should produce accurate results. How to verify the correctness of an algorithm
    should not be an afterthought; instead, it should be baked into the design of
    the algorithm. Before strategizing how to verify an algorithm, we need to think
    about the following two aspects:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是解决现实问题的数学方法。为了有用，它应该产生准确的结果。如何验证算法的正确性不应是事后考虑的问题，而应该融入算法的设计中。在制定验证算法的策略之前，我们需要考虑以下两个方面：
- en: '**Defining the truth**: To verify the algorithm, we need some known correct
    results for a given set of inputs. These known correct results are called the
    truths, in the context of the problem we are trying to solve. The truth is important
    as it is used as a reference when we iteratively work on evolving our algorithm
    toward a better solution.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义真值**：为了验证算法，我们需要一组已知正确的结果作为输入的基准。这些已知正确的结果在我们试图解决的问题的上下文中被称为真值。真值非常重要，因为它是我们在迭代优化算法时用作参考的依据。'
- en: '**Choosing metrics**: We also need to think about how we are going to quantify
    the deviation from the defined truth. Choosing the correct metrics will help us
    to accurately quantify the quality of our algorithm.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择度量指标**：我们还需要考虑如何量化与定义真值之间的偏差。选择正确的度量指标将帮助我们准确地量化算法的质量。'
- en: For example, for supervised machine learning algorithms, we can use existing
    labeled data as the truth. We can choose one or more metrics, such as accuracy,
    recall, or precision, to quantify deviation from the truth. It is important to
    note that, in some use cases, the correct output is not a single value. Instead,
    the correct output is defined as the range for a given set of inputs. As we work
    on the design and development of our algorithm, the objective will be to iteratively
    improve the algorithm until it is within the range specified in the requirements.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，对于监督式机器学习算法，我们可以使用现有的标注数据作为真值。我们可以选择一个或多个度量指标，如准确率、召回率或精确度，来量化与真值之间的偏差。需要注意的是，在某些使用场景下，正确的输出不是单一值，而是给定输入集的一个范围。随着我们对算法进行设计和开发，目标将是通过迭代优化算法，直到其在需求中指定的范围内。
- en: '**Consideration of edge cases**: An edge case happens when our designed algorithm
    is operating at the extremes of operating parameters. An edge case is usually
    a scenario that is rare but needs to be well tested, as it can cause our algorithm
    to fail. The non-edge cases are called the “happy path” covering all the scenarios
    that usually happen when the operating parameters are within the normal range.
    The vast majority of the time, the algorithm will remain on the “happy path.”
    Unfortunately, there is no way to come up with all possible edge cases for a given
    algorithm, but we should consider as many edge cases as possible. But without
    consideration and thinking about the edge cases, problems may arise.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界情况考虑**：边界情况发生在我们设计的算法在操作参数的极限状态下运行时。边界情况通常是罕见的场景，但需要经过充分的测试，因为它可能导致我们的算法失败。非边界情况则被称为“正常路径”，涵盖了操作参数在正常范围内时通常会发生的所有场景。绝大多数情况下，算法会保持在“正常路径”上。不幸的是，无法列出所有可能的边界情况，但我们应尽可能多地考虑这些边界情况。如果没有考虑到边界情况，问题可能会发生。'
- en: 'Concern 2: performance: is this the optimal way to get these results?'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点2：性能：这是获取这些结果的最佳方式吗？
- en: 'The second concern is about finding the answer to the following question:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个关注点是关于回答以下问题：
- en: Is this the optimal solution and can we verify that no other solution exists
    for this problem that is better than our solution?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否是最优解决方案，我们能否验证没有比我们的解决方案更好的其他解决方案存在？
- en: At first glance, this question looks quite simple to answer. However, for a
    certain class of algorithms, researchers have unsuccessfully spent decades verifying
    whether a particular solution generated by an algorithm is also the best and that
    no other solution exists that can give better performance. So, it becomes important
    that we first understand the problem, its requirements, and the resources available
    to run the algorithm.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这个问题似乎很简单。然而，对于某些类别的算法，研究人员几十年来一直未能成功验证算法生成的特定解决方案是否为最佳解决方案，以及是否存在其他解决方案可以提供更好的性能。因此，首先理解问题、其需求以及运行算法所需的资源变得非常重要。
- en: To provide the best solution to a certain complex problem, we need to answer
    the fundamental question of whether we should even aim to find the optimal solution
    for this problem. If finding and verifying the optimal solution is a hugely time-consuming
    and complex task, then a workable solution may be our best bet. These approximate
    workable solutions are *heuristics*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要提供某个复杂问题的最佳解决方案，我们需要回答一个基本问题：我们是否应该致力于找到这个问题的最优解？如果找到和验证最优解非常耗时且复杂，那么一个可行的解决方案可能是最好的选择。这些近似的可行解决方案被称为*启发式*。
- en: So, understanding the problem and its complexities is important and helps us
    estimate the resource requirements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理解问题及其复杂性是重要的，并有助于我们估计运行算法所需的资源。
- en: 'Before we start looking deeper into this, first, let’s define a couple of terms
    here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨之前，让我们先定义几个术语：
- en: '**Polynomial algorithm**: If an algorithm has a time complexity of *O(n*^k*)*,
    we call it a polynomial algorithm, where *k* is a constant.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多项式算法**：如果一个算法的时间复杂度为*O(n*^k*)*，我们称之为多项式算法，其中*k*是一个常数。'
- en: '**Certificate**: A proposed candidate solution produced at the end of an iteration
    is called a certificate. As we progress iteratively in solving a particular problem,
    we typically generate a series of certificates. If the solution is moving toward
    convergence, each generated certificate will be better than the previous one.
    At some point, when our certificate meets the requirements, we will choose that
    certificate as the final solution.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书**：在迭代解决特定问题的过程中生成的建议候选解决方案称为证书。随着我们在解决问题时的逐步进展，通常会生成一系列证书。如果解决方案朝着收敛前进，每个生成的证书都将比前一个更好。在某个时刻，当我们的证书满足要求时，我们将选择该证书作为最终解决方案。'
- en: 'In *Chapter 1*, *Overview of Algorithms*, we introduced Big O notation, which
    can be used to analyze the time complexity of an algorithm. In the context of
    analyzing time complexity, we are looking at the following different time intervals:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第一章*，*算法概述*中，我们介绍了大O符号，它可以用来分析算法的时间复杂度。在分析时间复杂度的背景下，我们考虑以下不同的时间间隔：
- en: '**Candidate solution generation time**, *t*[r]: It is the time it takes for
    an algorithm to produce a candidate solution.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**候选解决方案生成时间**，*t*[r]：这是算法生成候选解决方案所需的时间。'
- en: '**Candidate solution verification time**, *t*[s]: It is the time it takes to
    verify the candidate solution (certificate).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**候选解决方案验证时间**，*t*[s]：这是验证候选解决方案（证书）所需的时间。'
- en: Characterizing the complexity of the problem
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表征问题的复杂性
- en: Over the years, the research community has divided problems into various categories
    according to their complexity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，研究界根据其复杂性将问题分为不同的类别。
- en: 'Before we attempt to design the solution to a problem, it makes sense to first
    try to characterize it. Generally, there are three types of problems:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试设计问题的解决方案之前，首先尝试对其进行特征化是有意义的。一般来说，问题可以分为三种类型：
- en: Problems for which we can guarantee that a polynomial algorithm exists that
    can be used to solve them
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们可以保证存在多项式算法来解决的问题
- en: Problems for which we can prove that they cannot be solved by a polynomial algorithm
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们可以证明无法通过多项式算法解决的问题
- en: Problems for which we are unable to find a polynomial algorithm to solve them,
    but we are also unable to prove that a polynomial solution for those problems
    is impossible to find
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们无法找到多项式算法来解决，但也无法证明对于这些问题不存在多项式解决方案
- en: 'Let’s look at the various classes of problems according to their complexity:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据其复杂性来看看各种类别的问题：
- en: '**Non-Deterministic Polynomial** (**NP**): Problems that can be solved in polynomial
    time by a non-deterministic computer. Broadly, it means that a reasonable solution
    to a problem can be found and verified in polynomial times by making a reasonable
    guess at every step without an effort to find the optimal solution. Formally,
    for a problem to be an **NP** problem, it must meet the following condition, named
    Condition A:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非确定性多项式时间** (**NP**)：可以通过非确定性计算机在多项式时间内解决的问题。广义上讲，这意味着通过在每一步做出合理的猜测，而不致力于找到最优解，可以在多项式时间内找到并验证问题的一个合理解。形式上，对于一个问题要成为
    **NP** 问题，它必须满足以下条件，称为条件 A：'
- en: '**Condition A**: It is guaranteed that there is a polynomial algorithm that
    can be used to verify that the candidate solution (certificate) is optimal.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件 A**：保证存在一个多项式时间算法，可以用来验证候选解（证书）是否最优。'
- en: '**Polynominal** (**P**): Problems that can be solved in polynomial time by
    a deterministic computer. These problems can be solved by some algorithm with
    runtime *O(N*^k*)* for some power *k*, no matter how large. These are types of
    problems that can be thought of as a subset of **NP**. In addition to meeting
    the condition of an NP problem, Condition A, P problems need to meet another condition,
    named Condition B:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多项式时间** (**P**)：可以通过确定性计算机在多项式时间内解决的问题。这些问题可以通过某些算法在运行时间为 *O(N*^k*)* 的情况下解决，无论
    *k* 的值有多大。这些问题可以被看作是 **NP** 的子集。除了满足 NP 问题的条件 A 外，P 类问题还需要满足另一个条件，称为条件 B：'
- en: '**Condition A**: It is guaranteed that there is a polynomial algorithm that
    can be used to verify that the candidate solution (certificate) is optimal.'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件 A**：保证存在一个多项式时间算法，可以用来验证候选解（证书）是否最优。'
- en: '**Condition B**: It is guaranteed that there is at least one polynomial algorithm
    that can be used to solve them.'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件 B**：保证至少存在一个多项式时间算法，可以用来解决该问题。'
- en: Exploring the relationship between P and NP
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索 P 类和 NP 类问题的关系
- en: Understanding the relationship between P and NP is still a work in progress.
    What we know for sure is that P is a subset of NP, i.e., ![](img/B18046_04_001.png).
    That is obvious from the above discussion where NP needs to meet only the first
    of the two conditions that P needs to meet.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 P 类和 NP 类问题的关系仍在进行中。我们已知的是，P 类问题是 NP 类问题的子集，即！[](img/B18046_04_001.png)。这一点从上述讨论中显而易见，因为
    NP 类问题只需满足 P 类问题需要满足的两个条件中的第一个条件。
- en: 'The relationship between P and NP problems is shown in *Figure 4.1*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: P 类问题与 NP 类问题之间的关系如*图 4.1*所示：
- en: '![Venn diagram  Description automatically generated with low confidence](img/B18046_04_01.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![维恩图 描述自动生成，置信度较低](img/B18046_04_01.png)'
- en: 'Figure 4.1: Relationship between P and NP problems'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：P 类问题与 NP 类问题的关系
- en: What we do not know for sure is that if a problem is NP, is it P as well? This
    is one of the greatest problems in computer science that remains unresolved. Millennium
    Prize Problems, selected by the Clay Mathematics Institute, has announced a 1-million-dollar
    prize for the solution to this problem as it will have a major impact on fields
    such as AI, cryptography, and theoretical computer sciences. There are certain
    problems, such as sorting, that are known to be in P. Others, such as the knapsack
    and TSP, are known to be in NP.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前不确定的问题是，如果一个问题是 NP 问题，它是否也是 P 问题？这是计算机科学中最伟大的未解问题之一。由克莱数学研究所选出的千年奖问题宣布，解决这个问题将获得一百万美元的奖金，因为它将在人工智能、密码学和理论计算机科学等领域产生重大影响。有些问题，比如排序，已知属于
    P 类。其他问题，如背包问题和旅行商问题（TSP），已知属于 NP 类。
- en: There is a lot of ongoing research effort to answer this question. As yet, no
    researcher has discovered a polynomial-time-deterministic algorithm to solve the
    knapsack or TSP. It is still a work in progress and no one has been able to prove
    that no such algorithm is possible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有大量的研究工作在努力解答这个问题。至今，没有研究人员发现能在多项式时间内确定性地解决背包问题或旅行商问题的算法。这个问题仍在进行中，且尚未有人能够证明不存在这样的算法。
- en: '![Venn diagram  Description automatically generated](img/B18046_04_02.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![维恩图 描述自动生成](img/B18046_04_02.png)'
- en: 'Figure 4.2: DoesP = NP? We do not know as yet'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：P 是否等于 NP？我们目前尚不知晓
- en: Introducing NP-complete and NP-hard
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入 NP 完全问题和 NP 难问题
- en: 'Let’s continue the list of various classes of problems:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续列举各种问题类别：
- en: '**NP-complete**: The NP-complete category contains the hardest problems of
    all NP problems. An NP-complete problem meets the following two conditions:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NP 完全问题**：NP 完全类别包含了所有 NP 问题中最难的问题。一个 NP 完全问题满足以下两个条件：'
- en: There are no known polynomial algorithms to generate a certificate.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尚未有已知的多项式算法可以生成证书。
- en: There are known polynomial algorithms to verify that the proposed certificate
    is optimal.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知的多项式算法可以验证所提出的证书是否最优。
- en: '**NP-hard**: The NP-hard category contains problems that are at least as hard
    as any problem in the NP category, but that do not themselves need to be in the
    NP category.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NP-hard**：NP-hard 类别包含的问题至少与 NP 类中的任何问题一样难，但这些问题不一定要属于 NP 类。'
- en: 'Now, let’s try to draw a diagram to illustrate these different classes of problems:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试绘制一个图示，来说明这些不同类别的问题：
- en: '![Diagram  Description automatically generated](img/B18046_04_03.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Diagram  Description automatically generated](img/B18046_04_03.png)'
- en: 'Figure 4.3: Relationship between P, NP, NP-complete, and NP-hard'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：P、NP、NP-complete 和 NP-hard 之间的关系
- en: Note that it is still to be proven by the research community whether P = NP.
    Although this has not yet been proven, it is extremely likely that P ≠ NP. In
    that case, no polynomial solution exists for NP-complete problems. Note that the
    preceding diagram is based on this assumption.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，是否 P = NP 仍需通过研究界来证明。尽管这一问题尚未被证明，但极有可能 P ≠ NP。在这种情况下，NP-complete 问题将不存在多项式解决方案。请注意，前面的图示是基于这一假设的。
- en: The distinction between P, NP, NP-complete, and NP-hard
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: P、NP、NP-complete 和 NP-hard 之间的区别
- en: 'Unfortunately, the distinction between P, NP, NP-compete, and NP-hard is not
    clear-cut. Let us summarize and study some examples to make better sense of the
    concepts discussed in this section:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，P、NP、NP-complete 和 NP-hard 之间的区别并不清晰。让我们总结并研究一些例子，以便更好地理解本节中讨论的概念：
- en: '**P**: It is the class of problems solvable in polynomial time. For example:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P**：这是可以在多项式时间内解决的问题类。例如：'
- en: Hashtable lookup
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表查找
- en: Shortest path algorithms like Djikstra’s algorithms
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像Djikstra算法这样的最短路径算法
- en: Linear and binary search algorithms
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性和二分查找算法
- en: '**NP-problem**: The problems are not solvable in polynomial time, but their
    solution can be verified in polynomial time. For example:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NP-problem**：这些问题不能在多项式时间内解决，但它们的解决方案可以在多项式时间内进行验证。例如：'
- en: RSA encryption algorithm
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSA 加密算法
- en: '**NP-hard**: These are complex problems that no one has come up with a solution
    for as yet, but if solved, would have a polynomial time solution. For example:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NP-hard**：这些是复杂的问题，目前尚未找到解决方案，但如果能够解决，将会有一个多项式时间的解决方案。例如：'
- en: Optimal clustering using the *K*-means algorithm
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *K* 均值算法进行最优聚类
- en: '**NP-complete**: The NP-complete problems are the “hardest” in NP. They are
    both NP-hard and NP. For example:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NP-complete**：NP-complete 问题是 NP 类中“最难”的问题。它们既是 NP-hard 也是 NP。例如：'
- en: Calculation of an optimal solution for the TSP
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算旅行商问题的最优解
- en: Finding a solution for one of either classes (NP-hard or NP-complete) would
    imply a solution for all NP-hard/NP-complete problems.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解决了其中一种类别（NP-hard 或 NP-complete）的问题，将意味着所有NP-hard/NP-complete问题的解决方案都可以得到解决。
- en: 'Concern 3 – scalability: how is the algorithm going to perform on larger datasets?'
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点 3 - 可扩展性：算法在处理更大数据集时的表现如何？
- en: 'An algorithm processes data in a defined way to produce a result. Generally,
    as the size of the data increases, it takes more and more time to process the
    data and calculate the required results. The term **big data** is sometimes used
    to roughly identify datasets that are expected to be challenging for the infrastructure
    and algorithms to work with due to their volume, variety, and velocity. A well-designed
    algorithm should be scalable, which means that it should be designed in a way
    that means, wherever possible, it should be able to run efficiently, making use
    of the available resources and generating the correct results in a reasonable
    timeframe. The design of the algorithm becomes even more important when dealing
    with big data. To quantify the scalability of an algorithm, we need to keep the
    following two aspects in mind:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 算法以定义的方式处理数据并生成结果。通常，随着数据量的增加，处理数据和计算所需结果所需的时间也会越来越长。**大数据**这一术语有时用来粗略标识由于数据集的体量、种类和流速而预计对基础设施和算法构成挑战的数据集。一个设计良好的算法应该具有可扩展性，这意味着它应该以一种方式设计，使其能够在可能的情况下高效运行，利用可用资源并在合理的时间框架内生成正确的结果。当处理大数据时，算法的设计变得尤为重要。为了量化算法的可扩展性，我们需要关注以下两个方面：
- en: '**The increase in resource requirements as the input data is increased**: Estimating
    a requirement such as this is called space complexity analysis.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随着输入数据增大，资源需求增加**：估算这种需求的过程被称为空间复杂度分析。'
- en: '**The increase in the time taken to run as the input data is increased**: Estimating
    this is called time complexity analysis.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随着输入数据增加，运行所需的时间也会增加**：估算这一点的过程叫做时间复杂度分析。'
- en: Note that we are living in an era that is defined by data explosion. The term
    big data has become mainstream, as it captures the size and complexity of the
    data that is typically required to be processed by modern algorithms.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正生活在一个数据爆炸的时代。大数据一词已成为主流，它能够捕捉现代算法通常需要处理的数据的规模和复杂性。
- en: While in the development and testing phase, many algorithms use only a small
    sample of data. When designing an algorithm, it is important to look into the
    scalability aspect of the algorithms. In particular, it is important to carefully
    analyze (that is, test or predict) the effect of an algorithm’s performance as
    datasets increase in size.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和测试阶段，许多算法仅使用少量数据样本。当设计算法时，考虑算法的可扩展性非常重要。特别是，必须仔细分析（即测试或预测）随着数据集增大，算法性能的变化。
- en: The elasticity of the cloud and algorithmic scalability
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云的弹性与算法可扩展性
- en: Cloud computing has made new options available to deal with the resource requirements
    of an algorithm. Cloud computing infrastructures are capable of provisioning more
    resources as the processing requirements increase. The ability of cloud computing
    is called the elasticity of the infrastructure and has now provided us with more
    options for designing an algorithm. When deployed on the cloud, an algorithm may
    demand additional CPUs or VMs based on the size of the data to be processed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算为应对算法的资源需求提供了新的选择。云计算基础设施能够在处理需求增加时提供更多的资源。云计算的这一能力被称为基础设施的弹性，现如今它为我们设计算法提供了更多的选择。当算法部署在云上时，可能会根据要处理的数据规模要求更多的
    CPU 或虚拟机（VM）。
- en: Typical deep learning algorithms are a good example. To train a good deep learning
    model, lots of labeled data is needed. For a well-designed deep learning algorithm,
    the processing required to train a deep learning model is directly proportional
    to the number of examples or close to it. When training a deep learning model
    in the cloud, as the size of data increases, we try to provision more resources
    to keep training time within manageable limits.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的深度学习算法就是一个很好的例子。要训练出一个优秀的深度学习模型，需要大量标注数据。对于一个设计良好的深度学习算法，训练深度学习模型所需的处理量与示例的数量是成正比的，或者说接近正比。当在云端训练深度学习模型时，随着数据量的增加，我们会尝试配置更多的资源，以保持训练时间在可管理的范围内。
- en: Understanding algorithmic strategies
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解算法策略
- en: A well-designed algorithm tries to optimize the use of the available resources
    most efficiently by dividing the problem into smaller subproblems wherever possible.
    There are different algorithmic strategies for designing algorithms. An algorithmic
    strategy deals with the following three aspects of an algorithm list containing
    aspects of the missing algorithm.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的算法会尽可能地通过将问题划分成更小的子问题来最有效地利用可用资源。设计算法时有不同的算法策略。一种算法策略涉及算法中的以下三个方面：
- en: 'We will present the following three strategies in this section:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍以下三种策略：
- en: The divide-and-conquer strategy
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分治策略
- en: The dynamic programming strategy
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态规划策略
- en: The greedy algorithm strategy
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪心算法策略
- en: Understanding the divide-and-conquer strategy
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解分治策略
- en: One of the strategies is to find a way to divide a larger problem into smaller
    problems that can be solved independently of each other. The subsolutions produced
    by these subproblems are then combined to generate the overall solution to the
    problem. This is called the divide-and-conquer strategy.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一种策略是找到一种方法，将较大的问题划分成可以独立解决的小问题。这些小问题的子解将被合并以生成问题的整体解决方案。这就是分治策略。
- en: Mathematically, if we are designing a solution for a problem (P) with *n* inputs
    that needs to process dataset *d*, we split the problem into *k* subproblems,
    *P1* to *Pk*. Each of the subproblems will process a partition of the dataset,
    *d*. Typically, we will have *P1* to *Pk* processing *d1* to *dk* respectively.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，如果我们正在为一个有 *n* 个输入的（P）问题设计解决方案，需要处理数据集 *d*，我们将问题划分为 *k* 个子问题，*P1* 到 *Pk*。每个子问题将处理数据集的一个分区
    *d*。通常，我们会让 *P1* 到 *Pk* 分别处理 *d1* 到 *dk*。
- en: Let’s look at a practical example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个实际的例子。
- en: A practical example – divide-and-conquer applied to Apache Spark
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个实际的例子——分治法应用于 Apache Spark
- en: Apache Spark ([https://spark.apache.org/](https://spark.apache.org/)) is an
    open-source framework that is used to solve complex distributed problems. It implements
    a divide-and-conquer strategy to solve problems. To process a problem, it divides
    the problem into various subproblems and processes them independently of each
    other. These subproblems can run on separate machines enabling horizontal scaling.
    We will demonstrate this by using a simple example of counting words from a list.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Spark ([https://spark.apache.org/](https://spark.apache.org/)) 是一个开源框架，用于解决复杂的分布式问题。它实现了一种分治策略来解决问题。为了处理一个问题，它将问题划分为多个子问题，并独立地处理这些子问题。这些子问题可以在不同的机器上运行，从而实现水平扩展。我们将通过一个简单的示例——从列表中统计单词来演示这一点。
- en: 'Let’s assume that we have the following list of words:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下单词列表：
- en: '`words_list = ["python", "java", "ottawa", "news", "java", "ottawa"]`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`words_list = ["python", "java", "ottawa", "news", "java", "ottawa"]`'
- en: We want to calculate the frequency of each word in this list. For that, we will
    apply the divide-and-conquer strategy to solve this problem in an efficient way.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要计算这个列表中每个单词的频率。为此，我们将应用分治策略以高效地解决这个问题。
- en: 'The implementation of divide-and-conquer is shown in the following diagram:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 分治法的实现如下面的示意图所示：
- en: '![Diagram  Description automatically generated](img/B18046_04_04.png)Figure
    4.4: Divide and conquer'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![Diagram  Description automatically generated](img/B18046_04_04.png)图 4.4：分治法'
- en: 'The preceding diagram shows the following phases into which a problem is divided:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示意图展示了一个问题分解的以下阶段：
- en: '**Splitting**: The input data is divided into partitions that can be processed
    independently of each other. This is called splitting. We have three splits in
    the preceding figure.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**拆分**：输入数据被划分为可以独立处理的分区，这叫做拆分（splitting）。在前面的示意图中，我们有三个分割。'
- en: '**Mapping**: Any operation that can run independently on a split is called
    a map. In the preceding diagram, the map operation converts each of the words
    in the partition in to key-value pairs. Corresponding to the three splits, there
    are three mappers that are run in parallel.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**映射**：任何可以在分割上独立运行的操作都叫做映射（map）。在前面的示意图中，映射操作将每个分区中的单词转换为键值对。对应于三个分割，三个映射器将并行运行。'
- en: '**Shuffling**: Shuffling is the process of bringing similar keys together.
    Once similar keys are brought together, aggregation functions can be run on their
    values. Note that shuffling is a performance-intensive operation, as similar keys
    need to be brought together that can be originally distributed across the network.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**洗牌**：洗牌是将相似的键聚集在一起的过程。一旦相似的键被聚集在一起，就可以对它们的值运行聚合函数。注意，洗牌是一个性能密集型操作，因为相似的键需要被聚集，而这些键原本可能分布在整个网络中。'
- en: '**Reducing**: Running an aggregation function on the values of similar keys
    is called reducing. In the preceding diagram, we have to count the number of words.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**归约**：对相似键的值运行聚合函数叫做归约（reducing）。在前面的示意图中，我们需要统计单词的数量。'
- en: 'Let’s see how we can write the code to implement this. To demonstrate the divide-and-conquer
    strategy, we need a distributed computing framework. We will run Python running
    on Apache Spark for this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写代码来实现这一点。为了演示分治策略，我们需要一个分布式计算框架。我们将使用 Apache Spark 上运行的 Python 来演示：
- en: 'First, in order to use Apache Spark, we will create a runtime context of Apache
    Spark:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为了使用 Apache Spark，我们将创建一个 Apache Spark 的运行时上下文：
- en: '[PRE0]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let’s create a sample list containing some words. We will convert this
    list into Spark’s native distributed data structure, called a **Resilient Distributed**
    **Dataset** (**RDD**):'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个包含一些单词的示例列表。我们将把这个列表转换为 Spark 的本地分布式数据结构，称为**弹性分布式数据集**（**RDD**）：
- en: '[PRE1]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It will print:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将打印：
- en: '[PRE2]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let’s use a `map` function to convert the words into a key-value pair:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用`map`函数将单词转换为键值对：
- en: '[PRE3]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It will print:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将打印：
- en: '[PRE4]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s use the `reduce` function to aggregate and get the result:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`reduce`函数来进行聚合并得到结果：
- en: '[PRE5]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It prints:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它打印：
- en: '[PRE6]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This shows how we can use the divide-and-conquer strategy to count the number
    of words. Note that divide-and-conquer is useful when a problem can be divided
    into subproblems and each subproblem can at least be partially solved independently
    of other subproblems. It is not the best choice for algorithms that require intensive
    iterative processing, such as optimization algorithms. For such algorithms, dynamic
    programming is suitable, which is presented in the next section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了我们如何使用分治策略来统计单词的数量。请注意，当一个问题可以被分解为子问题并且每个子问题至少可以在某种程度上独立地解决时，分治法是有用的。但对于需要大量迭代处理的算法，如优化算法，分治法并不是最佳选择。对于这类算法，适用的是动态规划，接下来将介绍这一内容。
- en: Modern cloud computing infrastructures, such as Microsoft Azure, Amazon Web
    Services, and Google Cloud, achieve scalability in a distributed infrastructure
    that uses several CPUs/GPUs in parallel by implementing a divide-and-conquer strategy
    either directly or indirectly behind the scenes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现代云计算基础设施，如Microsoft Azure、Amazon Web Services和Google Cloud，通过实现分治策略（无论是直接还是间接的方式）在分布式基础设施中实现了可扩展性，能够并行使用多个CPU/GPU。
- en: Understanding the dynamic programming strategy
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解动态规划策略
- en: In the previous section, we studied divide and conquer, which is a top-down
    method. In contrast, dynamic programming is a bottom-up strategy. We start with
    the smallest subproblem and keep on combining the solutions. We keep on combining
    until we reach the final solution. Dynamic programming, like the divide-and-conquer
    method, solves problems by combining the solutions with subproblems.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了分治法，它是一种自上而下的方法。与此相对，动态规划是一种自下而上的策略。我们从最小的子问题开始，不断地将解决方案组合起来，直到达到最终的解决方案。像分治法一样，动态规划通过将子问题的解决方案组合来解决问题。
- en: Dynamic programming is a strategy proposed in the 1950s by Richard Bellman to
    optimize certain classes of algorithms. Note that in dynamic programming, the
    word “programming” refers to the use of a tabular method and has nothing to do
    with writing code. In contrast to the divide and conquer strategy, dynamic programming
    is applicable when the subproblems are not independent. It is typically applied
    to optimization problems in which each subproblem’s solution has a value.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划是一种由理查德·贝尔曼（Richard Bellman）在1950年代提出的优化特定类别算法的策略。需要注意的是，在动态规划中，"编程"一词指的是使用表格方法，与编写代码无关。与分治策略相对，动态规划适用于子问题之间不独立的情况。它通常应用于优化问题，其中每个子问题的解决方案都有一个值。
- en: Our objective is to find a solution with optimal value. A dynamic programming
    algorithm solves every subproblem just once and then saves its answer in a table,
    thereby avoiding the work of recomputing the answer every time the subproblem
    is encountered.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找到一个具有最优值的解决方案。动态规划算法只对每个子问题求解一次，并将其结果保存在表格中，从而避免了每次遇到子问题时都重新计算答案。
- en: Components of dynamic programming
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态规划的组成部分
- en: 'Dynamic programming is based on two major components:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划基于两个主要组成部分：
- en: '**Recursion**: It solves subproblems recursively.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**递归**：它通过递归的方式解决子问题。'
- en: '**Memoization**: Memoization or caching. It is based on an intelligent caching
    mechanism that tries to reuse the results of heavy computations. This intelligent
    caching mechanism is called memoization. The subproblems partly involve a calculation
    that is repeated in those subproblems. The idea is to perform that calculation
    once (which is the time-consuming step) and then reuse it on the other subproblems.
    This is achieved using memoization, which is especially useful in solving recursive
    problems that may evaluate the same inputs multiple times.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记忆化**：记忆化或缓存。它基于一种智能缓存机制，尝试重用重计算的结果。这个智能缓存机制称为记忆化。子问题部分涉及到在多个子问题中重复的计算。这个思想是只进行一次计算（这是耗时的步骤），然后在其他子问题中重用它。这是通过记忆化来实现的，这在解决可能多次评估相同输入的递归问题时尤其有用。'
- en: Conditions for using dynamic programming
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用动态规划的条件
- en: The problem we are trying to solve with dynamic programming should have two
    characteristics.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试用动态规划解决的问题应具备两个特征。
- en: '**Optimal structure**: Dynamic programming gives good performance benefits
    when the problem we are trying to solve can be divided into subproblems.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最优结构**：当我们尝试解决的问题可以被分解成子问题时，动态规划能够带来良好的性能收益。'
- en: '**Overlapping subproblems**: Dynamic programming uses a **recursive** function
    that solves a particular problem by calling a copy of itself and solving smaller
    subproblems of the original problems. The computed solutions of the subproblems
    are stored in a table, so that these don’t have to be re-computed. Hence, this
    technique is needed where an overlapping sub-problem exists.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重叠子问题**：动态规划使用一个**递归**函数，通过调用自身并解决原问题的较小子问题来解决特定问题。子问题的计算结果会存储在一个表格中，避免重复计算。因此，在存在重叠子问题的情况下，需要使用这一技术。'
- en: Dynamic programming is a perfect fit for combinatorial optimization problems,
    which are problems that needs providing optimal combinations of input elements
    as a solution.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划非常适合组合优化问题，这类问题需要提供输入元素的最优组合作为解决方案。
- en: 'Examples include:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 示例包括：
- en: Finding the optimal way to deliver packages for a company like FedEx or UPS
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为像 FedEx 或 UPS 这样的公司寻找最优的包裹配送方式
- en: Finding the optimal airline routes and airports
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找最优的航空公司航线和机场
- en: Deciding how to assign drivers for an online food delivery system like Uber
    Eats
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定如何为像 Uber Eats 这样的在线外卖系统分配司机
- en: Understanding greedy algorithms
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解贪心算法
- en: As the name indicates, a greedy algorithm relatively quickly produces a good
    solution, but it cannot be the optimal solution. Like dynamic programming, greedy
    algorithms are mainly used to solve optimization problems where a divide-and-conquer
    strategy cannot be used. In the greedy algorithm, the solution is calculated following
    a sequence of steps. At each step, a locally optimal choice is made.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名字所示，贪心算法相对较快地产生一个好的解，但它不一定是最优解。与动态规划类似，贪心算法主要用于解决无法使用分治策略的优化问题。在贪心算法中，解决方案通过一系列步骤逐步计算。在每一步中，做出局部最优选择。
- en: Conditions for using greedy programming
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用贪心编程的条件
- en: 'Greedy is a strategy that works well on problems with the following two characteristics:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心算法是一种在具有以下两种特征的问题中表现良好的策略：
- en: '**Global from local**: A global optimum can be arrived at by selecting a local
    optimum.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从局部到全局**：通过选择局部最优解，可以达到全局最优解。'
- en: '**Optimal substructure**: An optimal solution to the problem is made from optimal
    solutions to subproblems.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最优子结构**：问题的最优解由其子问题的最优解组成。'
- en: 'To understand the greedy algorithm, let’s first define two terms:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解贪心算法，我们首先定义两个术语：
- en: '**Algorithmic overheads**: Whenever we try to find the optimal solution to
    a certain problem, it takes some time. As the problems that we are trying to optimize
    become more and more complex, the time it takes to find the optimal solution also
    increases. We represent algorithmic overheads with ![](img/B18046_04_002.png).'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法开销**：每当我们尝试找到某个问题的最优解时，都需要一些时间。随着我们要优化的问题变得越来越复杂，找到最优解所需的时间也会增加。我们用 ![](img/B18046_04_002.png)
    来表示算法开销。'
- en: '**Delta from optimal**: For a given optimization problem, there exists an optimal
    solution. Typically, we iteratively optimize the solution using our chosen algorithm.
    For a given problem, there always exists a perfect solution, called the optimal
    solution, to the current problem. As discussed, based on the classification of
    the problem we are trying to solve, it’s possible for the optimal solution to
    be unknown or for it to take an unreasonable amount of time to calculate and verify
    it. Assuming that the optimal solution is known, the difference from optimal for
    the current solution in the ith iteration is called delta from optimal and is
    represented by ![](img/B18046_04_003.png).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与最优解的差距**：对于一个给定的优化问题，存在一个最优解。通常我们通过迭代优化所选择的算法来逐步逼近最优解。对于某个问题，总是存在一个完美的解决方案，称为最优解。如前所述，基于我们尝试解决的问题的分类，最优解可能是未知的，或者计算和验证最优解可能需要不合理的时间。假设最优解是已知的，则当前解在第
    i 次迭代中的与最优解的差距被称为最优差距，表示为 ![](img/B18046_04_003.png)。'
- en: 'For complex problems, we have two possible strategies:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂问题，我们有两种可能的策略：
- en: Spend more time finding a solution nearest to optimal so that ![](img/B18046_04_004.png)
    is as small as possible.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花更多的时间寻找最接近最优解的解决方案，以便使得 ![](img/B18046_04_004.png) 尽可能小。
- en: Minimize the algorithmic overhead, ![](img/B18046_04_005.png). Use the quick-and-dirty
    approach and just use a workable solution.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化算法开销，![](img/B18046_04_005.png)。采用简单粗暴的方法，只求一个可行的解决方案。
- en: Greedy algorithms are based on the second strategy, where we do not make an
    effort to find a global optimal and choose to minimize the algorithm overheads
    instead.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心算法基于第二种策略，我们不努力寻找全局最优解，而是选择最小化算法开销。
- en: Using a greedy algorithm is a quick and simple strategy for finding the global
    optimal value for multistage problems. It is based on selecting the local optimal
    values without making an effort to verify whether local optimal values are globally
    optimal as well. Generally, unless we are lucky, a greedy algorithm will not result
    in a value that can be considered globally optimal. However, finding a global
    optimal value is a time-consuming task. Hence, the greedy algorithm is fast compared
    to the divide-and-conquer and dynamic programming algorithms.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用贪心算法是一种快速简便的策略，用于解决多阶段问题的全局最优值。它基于选择局部最优值，而不努力验证局部最优值是否也为全局最优。通常，除非我们运气好，贪心算法不会得到可以视为全局最优的值。然而，找到一个全局最优值是一个耗时的任务。因此，与分治法和动态规划算法相比，贪心算法的速度较快。
- en: 'Generally, a greedy algorithm is defined as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，贪心算法定义如下：
- en: Let’s assume that we have a dataset, *D*. In this dataset, choose an element,
    *k*.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个数据集 *D*。在这个数据集中，选择一个元素 *k*。
- en: Let’s assume the candidate solution or certificate is *S*. Consider including
    *k* in the solution, *S*. If it can be included, then the solution is *Union(S,
    e)*.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设候选解或证书是 *S*。考虑将 *k* 包含在解 *S* 中。如果可以包含，那么解就是 *Union(S, e)*。
- en: Repeat the process until *S* is filled up or *D* is exhausted.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复该过程，直到 *S* 填满或 *D* 耗尽。
- en: '**Example**:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**：'
- en: The **Classification And Regression Tree** (**CART**) algorithm is a greedy
    algorithm, which searches for an optimum split at the top level. It repeats the
    process at each subsequent level. Note that the CART algorithm does not calculate
    and check whether the split will lead to the lowest possible impurity several
    levels down. CART uses a greedy algorithm because finding the optimal tree is
    known to be an NP-complete problem. It has an algorithmic complexity of *O(exp(m))*
    time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**分类与回归树** (**CART**) 算法是一个贪心算法，它在顶层寻找最优划分。它在每个后续层次重复此过程。请注意，CART 算法并不计算并检查该划分是否会导致几层下的最低可能杂质。CART
    使用贪心算法，因为找到最优树被认为是一个 NP 完全问题。它的算法复杂度是 *O(exp(m))* 时间。'
- en: A practical application – solving the TSP
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个实际应用——解决 TSP 问题
- en: Let’s first look at the problem statement for the TSP, which is a well-known
    problem that was coined as a challenge in the 1930s. The TSP is an NP-hard problem.
    To start with, we can randomly generate a tour that meets the condition of visiting
    all of the cities without caring about the optimal solution. Then, we can work
    to improve the solution with each iteration. Each tour generated in an iteration
    is called a candidate solution (also called a certificate). Proving that a certificate
    is optimal requires an exponentially increasing amount of time. Instead, different
    heuristics-based solutions are used that generate tours that are near to optimal
    but are not optimal.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看一下 TSP 的问题陈述，这是一个众所周知的问题，最早在 1930 年代被提出作为挑战。TSP 是一个 NP-困难问题。首先，我们可以随机生成一个满足访问所有城市的条件的旅行路径，而不考虑最优解。然后，我们可以在每次迭代中努力改进解。每次迭代中生成的旅行路径称为候选解（也叫证书）。证明一个证书是最优的需要指数级的时间。相反，使用不同的启发式解决方案来生成接近最优但并非最优的路径。
- en: 'A traveling salesperson needs to visit a given list of cities to get their
    job done:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个旅行推销员需要访问给定的城市列表才能完成任务：
- en: '| **INPUT** | A list of *n* cities (denoted as *V*) and the distances between
    each pair of cities, *d ij (1 ≤ i, j ≤ n)* |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **输入** | 一个包含 *n* 个城市的列表（记作 *V*），以及每对城市之间的距离，*d ij (1 ≤ i, j ≤ n)* |'
- en: '| **OUTPUT** | The shortest tour that visits each city exactly once and returns
    to the initial city |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **输出** | 最短的旅行路径，访问每个城市一次并返回初始城市 |'
- en: 'Note the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下几点：
- en: The distances between the cities on the list are known
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 城市之间的距离是已知的
- en: Each city in the given list needs to be visited *exactly* once
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定列表中的每个城市需要*精确*访问一次
- en: Can we generate the travel plan for the salesperson? What will be the optimal
    solution that can minimize the total distance traveled by the traveling salesperson?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能为旅行推销员生成旅行计划吗？什么是能够最小化旅行推销员总行程的最优解？
- en: 'The following are the distances between five Canadian cities that we can use
    for the TSP:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以用于 TSP 的五个加拿大城市之间的距离：
- en: '|  | **Ottawa** | **Montreal** | **Kingston** | **Toronto** | **Sudbury** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|  | **渥太华** | **蒙特利尔** | **金斯顿** | **多伦多** | **萨德伯里** |'
- en: '| **Ottawa** | - | 199 | 196 | 450 | 484 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **渥太华** | - | 199 | 196 | 450 | 484 |'
- en: '| **Montreal** | 199 | - | 287 | 542 | 680 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| **蒙特利尔** | 199 | - | 287 | 542 | 680 |'
- en: '| **Kingston** | 196 | 287 | - | 263 | 634 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **金斯顿** | 196 | 287 | - | 263 | 634 |'
- en: '| **Toronto** | 450 | 542 | 263 | - | 400 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **多伦多** | 450 | 542 | 263 | - | 400 |'
- en: '| **Sudbury** | 484 | 680 | 634 | 400 | - |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **萨德伯里** | 484 | 680 | 634 | 400 | - |'
- en: Note that the objective is to get a tour that starts and ends in the initial
    city. For example, a typical tour can be Ottawa–Sudbury–Montreal–Kingston–Toronto–Ottawa
    with a cost of *484 + 680 + 287 + 263 + 450 = 2,164*. Is this the tour in which
    the salesperson has to travel the minimum distance? What will be the optimal solution
    that can minimize the total distance traveled by the traveling salesperson? I
    will leave this up to you to think about and calculate.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，目标是得到一条从起始城市出发并返回起始城市的路线。例如，一个典型的路线可能是渥太华–萨德伯里–蒙特利尔–金斯顿–多伦多–渥太华，总费用为 *484
    + 680 + 287 + 263 + 450 = 2,164*。这是销售员需要行走的最短路线吗？能够最小化销售员总行程的最优解是什么？我留给你自己去思考并计算。
- en: Using a brute-force strategy
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用暴力破解策略
- en: 'The first solution that comes to mind to solve the TSP is using brute force
    to come up with the shortest path in which the salesperson visits every city exactly
    once and returns to the initial city. So, the brute-force strategy works as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 解决旅行商问题（TSP）时，首先想到的解决方案是通过暴力破解方法找到最短路径，使得销售员恰好访问每座城市一次，并返回到起始城市。因此，暴力破解策略如下：
- en: Evaluate all possible tours.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估所有可能的路线。
- en: Choose the one for which we get the shortest distance.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择距离最短的那个。
- en: The problem is that for n number of cities, there are *(n-1)!* possible tours.
    That means that five cities will produce *4! = 24* tours, and we will select the
    one that corresponds to the lowest distance. It is obvious that this method will
    only work when we do not have too many cities. As the number of cities increases,
    the brute-force strategy becomes unsolvable due to the large number of permutations
    generated by using this approach.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，对于 *n* 个城市，有 *(n-1)!* 种可能的路线。这意味着五座城市会产生 *4! = 24* 种路线，我们会选择最短距离对应的那一条。显然，这种方法只适用于城市数量较少的情况。随着城市数量的增加，暴力破解策略因产生的排列组合数量过多而变得无法解决。
- en: Let’s see how we can implement the brute-force strategy in Python.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 Python 中实现暴力破解策略。
- en: First, note that a tour, {*1,2,3*}, represents a tour of the city from city
    1 to city 2 and city 3\. The total distance in a tour is the total distance covered
    in a tour. We will assume that the distance between the cities is the shortest
    distance between them (which is the Euclidean distance).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要注意，*{1,2,3}* 代表一条从城市 1 到城市 2 和城市 3 的路线。一个路线的总距离是该路线覆盖的总距离。我们假设城市之间的距离是它们之间的最短距离（即欧几里得距离）。
- en: 'Let’s first define three utility functions:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义三个实用函数：
- en: '`distance_points`: Calculates the absolute distance between two points'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distance_points`：计算两点之间的绝对距离'
- en: '`distance_tour`: Calculates the total distance the salesperson has to cover
    in a given tour'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distance_tour`：计算销售员在给定路线中需要覆盖的总距离'
- en: '`generate_cities`: Randomly generates a set of *n* cities located in a rectangle
    of width `500` and height `300`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate_cities`：随机生成一组位于宽度为 `500` 和高度为 `300` 的矩形区域内的 *n* 个城市'
- en: 'Let’s look at the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的代码：
- en: '[PRE7]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we implemented `alltours` from the `permutations` function
    of the `itertools` package. We have also represented the distance with a complex
    number. This means the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从 `itertools` 包的 `permutations` 函数实现了 `alltours`。我们还用复数表示了距离。这意味着以下内容：
- en: Calculating the distance between two cities, *a* and *b*, is as simple as `distance
    (a,b)`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 计算两座城市，*a* 和 *b*，之间的距离就像 `distance (a,b)` 一样简单。
- en: 'We can create *n* number of cities just by calling `generate_cities(n)`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `generate_cities(n)` 来创建 *n* 个城市：
- en: '[PRE8]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let’s define a function, `brute_force`, that generates all the possible
    tours of the cities. Once it has generated all possible tours, it will choose
    the one with the shortest distance:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个函数 `brute_force`，它会生成所有可能的城市路线。一旦生成了所有可能的路线，它将选择最短距离的那一条：
- en: '[PRE9]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let’s define the utility functions that can help us plot the cities. We
    will define the following functions:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一些有助于绘制城市图的实用函数。我们将定义以下函数：
- en: '`visualize_tour`: Plots all the cities and links in a particular tour. It also
    highlights the city from which the tour started.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visualize_tour`：绘制特定旅行路线中的所有城市和链接。它还会突出显示旅行开始的城市。'
- en: '`visualize_segment`: Used by `visualize_tour` to plot cities and links in a
    segment.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visualize_segment`：由`visualize_tour`使用，用于绘制一个段中的城市和链接。'
- en: 'Look at the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE10]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s implement a function, `tsp()`, that does the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个函数` tsp()`，它完成以下操作：
- en: Generates the tour based on the algorithm and number of cities requested.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据算法和所请求的城市数生成旅行路线。
- en: Calculates the time it took for the algorithm to run.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算算法运行所花费的时间。
- en: Generates a plot.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个图表。
- en: 'Once `tsp()` is defined, we can use it to create a tour:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了`tsp()`，我们就可以用它来创建旅行路线：
- en: '[PRE11]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Chart, line chart  Description automatically generated](img/B18046_04_05.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图表，折线图 描述自动生成](img/B18046_04_05.png)'
- en: 'Figure 4.5: Solution of TSP'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：TSP问题的解决方案
- en: Note that we have used it to generate the tour for 10 cities. As *n = 10*, it
    will generate *(10-1)! = 362,880* possible permutations. If n increases, the number
    of permutations sharply increases and the brute-force method cannot be used.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经用它生成了10个城市的旅行路线。由于*n = 10*，它将生成*(10-1)! = 362,880*种可能的排列组合。如果n增加，排列组合的数量急剧增加，暴力破解法将无法使用。
- en: Using a greedy algorithm
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用贪心算法
- en: If we use a greedy algorithm to solve the TSP, then, at each step, we can choose
    a city that seems reasonable, instead of finding a city to visit that will result
    in the best overall path. So, whenever we need to select a city, we just select
    the nearest city without bothering to verify that this choice will result in the
    globally optimal path.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用贪心算法来解决旅行商问题（TSP），那么在每一步，我们可以选择一个看起来合理的城市，而不是寻找一个能够导致最佳整体路径的城市。因此，每当我们需要选择一个城市时，我们只是选择离得最近的城市，而不考虑这个选择是否能导致全局最优路径。
- en: 'The approach of the greedy algorithm is simple:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心算法的方法很简单：
- en: Start from any city.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从任何城市开始。
- en: At each step, keep building the tour by moving to the next city where the nearest
    neighborhood has not been visited before.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每一步，通过移动到下一个城市来继续构建旅行路线，该城市是最近的未访问过的邻近城市。
- en: Repeat *step 2*.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤2*。
- en: 'Let’s define a function named `greedy_algorithm` that can implement this logic:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个名为`greedy_algorithm`的函数，它能够实现这一逻辑：
- en: '[PRE12]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let’s use `greedy_algorithm` to create a tour for 2,000 cities:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`greedy_algorithm`为2,000个城市创建一条旅行路线：
- en: '[PRE13]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Qr code  Description automatically generated with medium confidence](img/B18046_04_06.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![二维码 描述自动生成，信心中等](img/B18046_04_06.png)'
- en: 'Figure 4.6: Cities displayed in Jupyter Notebook'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：在Jupyter Notebook中显示的城市
- en: Note that it took only `0.514` seconds to generate the tour for 2,000 cities.
    If we had used the brute-force method, it would have generated *(2000-1)!* = 1.65*e*^(5732)
    permutations, which is almost infinite.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，生成2,000个城市的旅行路线仅用了`0.514`秒。如果我们使用暴力破解法，它将生成*(2000-1)!* = 1.65*e*^(5732)个排列组合，这几乎是无限的。
- en: Note that the greedy algorithm is based on heuristics and there is no proof
    that the solution will be optimal.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，贪心算法是基于启发式的，并且没有证明该解是最优的。
- en: Comparison of Three Strategies
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三种策略的比较
- en: To summarize, the outcome of the greedy algorithm is more efficient in terms
    of calculation time whereas the brute-force method provides the combination with
    the global optimum. This means the calculation time as well as the quality of
    the outcome differ. The proposed greedy algorithm may reach nearly as high outcomes
    as brute force does, with significantly less calculation time, but as it does
    not search for an optimal solution, it is based on a effort-based strategy and
    there are no guarantees.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，贪心算法的结果在计算时间上更为高效，而暴力破解法则提供了全局最优解的组合。这意味着计算时间和结果的质量有所不同。所提出的贪心算法可能会得到与暴力破解几乎相同的结果，但计算时间显著较少，但由于它不搜索最优解，因此它基于一种基于努力的策略，并且没有保证。
- en: Now, let’s look at the design of the **PageRank** algorithm.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下**PageRank**算法的设计。
- en: Presenting the PageRank algorithm
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示PageRank算法
- en: As a practical example, let’s look at the PageRank algorithm, which is used
    by Google to rank the search results of a user query. It generates a number that
    quantifies the importance of search results in the context of the query the user
    has executed. This was designed by two Ph.D. students, Larry Page and Sergey Brin,
    at Stanford in the late 1990s, who also went on to start Google. *The PageRank
    algorithm* was named after Larry Page.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实际示例，让我们来看一下 Google 用来对用户查询的搜索结果进行排名的 PageRank 算法。它生成一个数字，量化搜索结果在用户执行的查询背景下的重要性。这一算法由两位博士生，Larry
    Page 和 Sergey Brin，在 1990 年代末期的斯坦福大学设计，他们也随之创办了 Google。*PageRank 算法*是以 Larry Page
    的名字命名的。
- en: Let’s first formally define the problem for which PageRank was initially designed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们正式定义 PageRank 最初设计的目标问题。
- en: Problem definition
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题定义
- en: Whenever a user enters a query on a search engine on the web, it typically results
    in a large number of results. To make the results useful for the end user, it
    is important to rank the web pages using some criteria. The results that are displayed
    use this ranking to summarize the results for the user and are dependent on the
    criteria defined by the underlying algorithm being used.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户在网页搜索引擎中输入查询时，通常会返回大量的搜索结果。为了使结果对最终用户有用，使用某些标准对网页进行排名是很重要的。显示的结果使用此排名来总结展示给用户的结果，并且依赖于底层算法定义的标准。
- en: Implementing the PageRank algorithm
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 PageRank 算法
- en: 'First, while using the PageRank algorithm, the following representation is
    used:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在使用 PageRank 算法时，采用以下表示方法：
- en: Web pages are represented by nodes in a directed graph.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页在有向图中由节点表示。
- en: The graph edges correspond to hyperlinks.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图中的边代表超链接。
- en: 'The most important part of the PageRank algorithm is to come up with the best
    way to calculate the importance of each page that is returned by the query results.
    The rank of a particular web page in the network is calculated as the probability
    that a person randomly traversing the edges (i.e., clicking on links) will arrive
    at that page. Also, this algorithm is parametrized by the damping factor alpha,
    which has a default value of 0.85\. This damping factor is the probability that
    the user will continue clicking. Note that the page with the highest PageRank
    is the most attractive: regardless of where the person starts, this page has the
    highest probability of being the final destination.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank 算法中最重要的部分是找到计算查询结果中每个网页重要性的最佳方法。某一特定网页在网络中的排名是通过计算一个随机浏览边（即点击链接）的人到达该页面的概率来得出的。此外，该算法由阻尼因子
    alpha 参数化，默认值为 0.85。这个阻尼因子表示用户继续点击的概率。请注意，PageRank 最高的页面是最具吸引力的：无论用户从哪里开始，该页面都有最高的概率成为最终目标页面。
- en: The algorithm requires many iterations or passes through the collection of web
    pages to determine the right importance (or PageRank value) of each web page.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法需要多次迭代或遍历网页集合，以确定每个网页的正确重要性（或 PageRank 值）。
- en: 'To calculate a number from `0` to `1` that can quantify the importance of a
    particular page, the algorithm incorporates information from the following two
    components:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算一个从 `0` 到 `1` 的数字，用来量化某个特定网页的重要性，算法结合了以下两个组件的信息：
- en: '**Information that was specific to the query entered by the user**: This component
    estimates, in the context of the query entered by the user, how relevant the content
    of the web page is. The content of the page is directly dependent on the author
    of the page.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与用户输入的查询相关的信息**：这个组件在用户输入的查询背景下，评估网页内容的相关性。网页的内容直接依赖于页面的作者。'
- en: '**Information that was not relevant to the query entered by the user**: This
    component tries to quantify the importance of each web page in the context of
    its links, views, and neighborhood. The neighborhood of a web page is the group
    of web pages directly connected to a certain page. This component is difficult
    to calculate as web pages are heterogeneous, and coming up with criteria that
    can be applied across the web is difficult to develop.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与用户输入的查询无关的信息**：这个组件试图量化每个网页在其链接、浏览量和邻域中的重要性。一个网页的邻域是与该页面直接相连的网页群体。由于网页具有异质性，且很难制定适用于整个网页的标准，这一组件的计算非常困难。'
- en: 'In order to implement the PageRank algorithm in Python, first, let’s import
    the necessary libraries:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Python 中实现 PageRank 算法，首先让我们导入必要的库：
- en: '[PRE14]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that the network is from [https://networkx.org/](https://networkx.org/).
    For the purpose of this demonstration, let’s assume that we are analyzing only
    five web pages in the network. Let’s call this set of pages `my_pages` and together
    they are in a network named `my_web`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该网络来自 [https://networkx.org/](https://networkx.org/)。为了演示的目的，假设我们只分析网络中的五个网页。让我们称这组页面为
    `my_pages`，它们一起位于名为 `my_web` 的网络中：
- en: '[PRE15]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let’s connect them randomly to simulate an actual network:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们随机连接它们以模拟一个实际网络：
- en: '[PRE16]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let’s plot this graph:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们绘制这个图：
- en: '[PRE17]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It creates the visual representation of our network, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了我们网络的视觉表示，如下所示：
- en: '![Shape  Description automatically generated with medium confidence](img/B18046_04_07.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![Shape  Description automatically generated with medium confidence](img/B18046_04_07.png)'
- en: 'Figure 4.7: Visual representation of the network'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：网络的视觉表示
- en: In the PageRank algorithm, the patterns of a web page are contained in a matrix
    called the transition matrix. There are algorithms that constantly update the
    transition matrix to capture the constantly changing state of the web. The size
    of the transition matrix is n x n, where n is the number of nodes. The numbers
    in the matrix are the probability that a visitor will next go to that link due
    to the outbound link.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在PageRank算法中，网页的模式包含在一个称为转移矩阵的矩阵中。有算法不断更新转移矩阵，以捕捉网络不断变化的状态。转移矩阵的大小为 n x n，其中
    n 是节点的数量。矩阵中的数字是访问者由于出站链接而下次转到该链接的概率。
- en: 'In our case, the preceding graph shows the static web that we have. Let’s define
    a function that can be used to create the transition matrix:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，前面的图显示了我们拥有的静态网页。让我们定义一个可以用来创建转移矩阵的函数：
- en: '[PRE18]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that this function will return `G`, which represents the transition matrix
    for our graph.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该函数将返回 `G`，它代表我们图的转移矩阵。
- en: 'Let’s generate the transition matrix for our graph:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的图生成转移矩阵：
- en: '[PRE19]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Calendar  Description automatically generated with medium confidence](img/B18046_04_08.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![Calendar  Description automatically generated with medium confidence](img/B18046_04_08.png)'
- en: 'Figure 4.8: Transition matrix'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：转移矩阵
- en: Note that the transition matrix is 5 x 5 for our graph. Each column corresponds
    to each node in the graph. For example, column 2 is about the second node. There
    is a `0.5` probability that the visitor will navigate from node 2 to node 1 or
    node 3\. Note that the diagonal of the transition matrix is `0` as in our graph,
    there is no outbound link from a node to itself. In an actual network, it may
    be possible.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们图的转移矩阵是 5 x 5。每列对应图中的每个节点。例如，第二列是关于第二个节点的信息。访问者从节点2导航到节点1或节点3的概率为 `0.5`。请注意，在我们的图中，转移矩阵的对角线为
    `0`，因为没有节点自身到自身的出站链接。在实际网络中，这可能是可能的。
- en: 'Note that the transition matrix is a sparse matrix. As the number of nodes
    increases, most of its values will be `0`. Thus, the structure of a graph is extracted
    as a *transition matrix*. In a transaction matrix, nodes are represented in columns
    and rows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，转移矩阵是一个稀疏矩阵。随着节点数量的增加，其大部分值将为 `0`。因此，图的结构被提取为*转移矩阵*。在转移矩阵中，节点以列和行表示：
- en: '**Columns**: Indicates to the node that a web surfer is online'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列**：指示网络浏览者在线的节点'
- en: '**Rows**: Indicates the probability that the surfer will visit other nodes
    because of outbound links'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行**：指示浏览者因出站链接而访问其他节点的概率'
- en: In the real web, the transition matrix that feeds the PageRank algorithm is
    built by spiders’ continuous exploration of links.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实的网络中，PageRank算法所需的转移矩阵是由蜘蛛持续探索链接建立的。
- en: Understanding linear programming
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解线性规划
- en: Many real-world problems involve maximizing or minimizing an objective, with
    some given constraints. One approach is to specify the objective as a linear function
    of some variables. We also formulate the constraints on resources as equalities
    or inequalities on those variables. This approach is called the linear programming
    problem. The basic algorithm behind linear programming was developed by George
    Dantzig at the University of California at Berkeley in the early 1940s. Dantzig
    used this concept to experiment with logistical supply-and-capacity planning for
    troops while working for the US Air Force.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现实世界问题涉及最大化或最小化一个目标，并且有一些给定的约束条件。一种方法是将目标指定为某些变量的线性函数。我们还将资源约束条件表述为这些变量上的等式或不等式。这种方法被称为线性规划问题。线性规划背后的基本算法是由乔治·丹齐格（George
    Dantzig）在20世纪40年代初在加利福尼亚大学伯克利分校开发的。丹齐格在为美国空军工作时，利用这一概念进行部队物流供给与产能规划的实验。
- en: At the end of the Second World War, Dantzig started working for the Pentagon
    and matured his algorithm into a technique that he named linear programming. It
    was used for military combat planning.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次世界大战结束时，丹齐格开始为五角大楼工作，并将他的算法发展成了一种叫做线性规划的技术。这一技术被用于军事作战规划。
- en: 'Today, it is used to solve important real-world problems that relate to minimizing
    or maximizing a variable based on certain constraints. Some examples of these
    problems are as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，它被用于解决与基于某些约束条件最小化或最大化一个变量相关的重要现实世界问题。以下是一些此类问题的例子：
- en: Minimizing the time to repair a car at a mechanic shop based on the resources
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于资源最小化修车时间
- en: Allocating available distributed resources in a distributed computing environment
    to minimize response times
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分布式计算环境中分配可用的分布式资源，以最小化响应时间
- en: Maximizing the profit of a company based on the optimal assignment of resources
    within the company
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于公司内部资源的最优分配来最大化公司的利润
- en: Formulating a linear programming problem
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建线性规划问题
- en: 'The conditions for using linear programming are as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性规划的条件如下：
- en: We should be able to formulate the problem through a set of equations.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该能够通过一组方程来构建问题。
- en: The variables used in the equation must be linear.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方程中使用的变量必须是线性的。
- en: Defining the objective function
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义目标函数
- en: Note that the objective of each of the preceding three examples is about minimizing
    or maximizing a variable. This objective is mathematically formulated as a linear
    function of other variables and is called the objective function. The aim of a
    linear programming problem is to minimize or maximize the objective function while
    remaining within the specified constraints.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述三个例子的目标都是关于最小化或最大化一个变量。这个目标在数学上被表述为其他变量的线性函数，称为目标函数。线性规划问题的目标是最小化或最大化目标函数，同时保持在指定的约束条件内。
- en: Specifying constraints
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定约束条件
- en: When trying to minimize or maximize something, there are certain constraints
    in real-world problems that need to be respected. For example, when trying to
    minimize the time it takes to repair a car, we also need to consider that there
    is a limited number of mechanics available. Specifying each constraint through
    a linear equation is an important part of formulating a linear programming problem.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试最小化或最大化某个变量时，现实世界问题中往往会有一些需要遵守的约束条件。例如，在试图最小化修车时间时，我们还需要考虑到可用的机械师数量有限。通过线性方程来指定每个约束条件是构建线性规划问题的重要部分。
- en: A practical application – capacity planning with linear programming
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个实际应用——使用线性规划进行产能规划
- en: Let’s look at a practical use case where linear programming can be used to solve
    a real-world problem.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实际的用例，看看如何使用线性规划来解决现实世界中的问题。
- en: 'Let’s assume that we want to maximize the profits of a state-of-the-art factory
    that manufactures two different types of robots:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要最大化一家先进工厂的利润，该工厂生产两种不同类型的机器人：
- en: '**Advanced model** (**A**): This provides full functionality. Manufacturing
    each unit of the advanced model results in a profit of $4,200.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级模型**（**A**）：该模型提供完整的功能。制造每个高级模型单位的利润为$4,200。'
- en: '**Basic model** (**B**): This only provides basic functionality. Manufacturing
    each unit of the basic model results in a profit of $2,800.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本模型**（**B**）：该模型只提供基本功能。制造每个基本模型单位的利润为$2,800。'
- en: 'There are three different types of people needed to manufacture a robot. The
    exact number of days needed to manufacture a robot of each type is as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 制造一台机器人需要三种不同类型的人。每种类型机器人制造所需的具体天数如下：
- en: '| **Type of Robot** | **Technician** | **AI Specialist** | **Engineer** |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| **机器人类型** | **技术员** | **AI专家** | **工程师** |'
- en: '| **Robot A: advanced model** | 3 days | 4 days | 4 days |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| **机器人A：高级模型** | 3天 | 4天 | 4天 |'
- en: '| **Robot B: basic model** | 2 days | 3 days | 3 days |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| **机器人B：基础模型** | 2天 | 3天 | 3天 |'
- en: The factory runs on 30-day cycles. A single AI specialist is available for 30
    days in a cycle. Each of the two engineers will take 8 days off in 30 days. So,
    an engineer is available only for 22 days in a cycle. There is a single technician
    available for 20 days in a 30-day cycle.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂采用30天的周期运行。每个AI专家在一个周期内有30天的可用时间。每个工程师在30天内会休息8天，因此，工程师每个周期只能工作22天。一个技术员在30天的周期中有20天可用。
- en: 'The following table shows the number of people we have in the factory:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了我们工厂中有多少人：
- en: '|  | **Technician** | **AI Specialist** | **Engineer** |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '|  | **技术员** | **AI专家** | **工程师** |'
- en: '| **Number of people** | 1 | 1 | 2 |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| **人数** | 1 | 1 | 2 |'
- en: '| **Total number of days in a cycle** | 1 x 20 = 20 days | 1 x 30 = 30 days
    | 2 x 22 = 44 days |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| **周期总天数** | 1 x 20 = 20天 | 1 x 30 = 30天 | 2 x 22 = 44天 |'
- en: 'This can be modeled as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以按如下方式建模：
- en: Maximum profit = 4200A + 2800B
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大利润 = 4200A + 2800B
- en: 'This is subject to the following:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受以下限制：
- en: '`A ≥ 0`: The number of advanced robots produced can be 0 or more.'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A ≥ 0`：生产的高级机器人数量可以是0或更多。'
- en: '`B ≥` `0`: The number of basic robots produced can be 0 or more.'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`B ≥ 0`：生产的基础机器人数量可以是0或更多。'
- en: '`3A + 2B ≤ 20`: These are the constraints of the technician’s availability.'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3A + 2B ≤ 20`：这些是技术员可用时间的约束。'
- en: '`4A+3B ≤ 30`: These are the constraints of the AI specialist’s availability.'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4A+3B ≤ 30`：这些是AI专家可用时间的约束。'
- en: '`4A+ 3B ≤ 44`: These are the constraints of the engineers’ availability.'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4A + 3B ≤ 44`：这些是工程师可用时间的约束。'
- en: 'First, we import the Python package named `pulp`, which is used to implement
    linear programming:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入名为`pulp`的Python包，它用于实现线性规划：
- en: '[PRE20]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we call the `LpProblem` function in this package to instantiate the problem
    class. We name the instance `Profit maximising problem`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用此包中的`LpProblem`函数来实例化问题类，并将实例命名为`利润最大化问题`：
- en: '[PRE21]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we define two linear variables, `A` and `B`. Variable `A` represents
    the number of advanced robots that are produced and variable `B` represents the
    number of basic robots that are produced:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了两个线性变量`A`和`B`。变量`A`表示生产的高级机器人数量，变量`B`表示生产的基础机器人数量：
- en: '[PRE22]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We define the objective function and constraints as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按如下方式定义目标函数和约束条件：
- en: '[PRE23]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We use the solve function to generate a solution:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`solve`函数生成解决方案：
- en: '[PRE24]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we print the values of `A` and `B` and the value of the objective function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们打印出`A`和`B`的值以及目标函数的值：
- en: '[PRE25]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果是：
- en: '[PRE26]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It prints:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印出：
- en: '[PRE28]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Linear programming is extensively used in the manufacturing industry to find
    the optimal number of products that should be used to optimize the use of available
    resources.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 线性规划广泛应用于制造业，用于寻找应使用的最优产品数量，以优化现有资源的使用。
- en: And here we come to the end of this chapter! Let’s summarize what we have learned.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到此结束！让我们总结一下所学的内容。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we studied various approaches to designing an algorithm. We
    looked at the trade-offs involved in choosing the correct design of an algorithm.
    We looked at the best practices for formulating a real-world problem. We also
    learned how to solve a real-world optimization problem. The lessons learned from
    this chapter can be used to implement well-designed algorithms.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了设计算法的各种方法。我们考察了选择正确算法设计时的权衡。我们还讨论了制定现实世界问题的最佳实践，并学习了如何解决实际的优化问题。本章所学的内容可以用于实现设计良好的算法。
- en: In the next chapter, we will focus on graph-based algorithms. We will start
    by looking at different ways of representing graphs. Then, we will study the techniques
    to establish a neighborhood around various data points to conduct a particular
    investigation. Finally, we will study the optimal ways to search for information
    in graphs.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点介绍基于图的算法。我们将首先研究图的不同表示方式。接下来，我们将学习在各种数据点周围建立邻域的技术，以进行特定调查。最后，我们将研究在图中查找信息的最佳方法。
- en: Learn more on Discord
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在这里你可以分享反馈、向作者提问，并了解新版本的发布——请扫描下面的二维码：
- en: '[https://packt.link/WHLel](https://packt.link/WHLel)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/WHLel](https://packt.link/WHLel)'
- en: '![](img/QR_Code1955211820597889031.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1955211820597889031.png)'
