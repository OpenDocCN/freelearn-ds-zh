- en: '*Chapter 6*: Exploring Variables with Scatter Plots and Filtering Subsets with
    Sliders'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第六章*：通过散点图探索变量，并使用滑块过滤子集'
- en: 'We are now going to tackle one of the most versatile, useful, and ubiquitous
    types of charts, the **scatter plot**. As its name implies, we basically scatter
    markers (which can be points, squares, circles, bubbles, or other symbols) on
    the Cartesian plane, where mainly their horizontal and vertical distances express
    the values they represent. Other visual attributes, such as size, color, and symbol,
    might be used to express other attributes, as we saw in some previous examples.
    As most of the fundamentals regarding figures and creating charts have been covered,
    we won''t be spending much time on that, focusing instead on the particular details
    and options available to scatter plots. We will also explore and work with **sliders**
    as a new interactive component. Let''s start right away, but first, here are the
    topics that we will be covering:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨一种最通用、最有用且无处不在的图表类型——**散点图**。顾名思义，我们基本上是在笛卡尔平面上散布标记（可以是点、方块、圆圈、气泡或其他符号），其中它们的水平和垂直距离表达它们所代表的数值。其他视觉属性，如大小、颜色和符号，可能会用来表示其他属性，正如我们在一些前面的示例中看到的那样。由于大多数关于图形和创建图表的基础知识已经涵盖过，我们不会花太多时间在这方面，而是专注于散点图的具体细节和可用选项。我们还将探索并使用**滑块**这一新的交互式组件。我们现在就开始，但首先，以下是我们将要涵盖的主题：
- en: 'Learning about the different ways of using scatter plots: markers, lines, and
    text'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解使用散点图的不同方式：标记、线条和文本
- en: Creating multiple scatter traces in a single plot
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单个图表中创建多个散点图追踪
- en: Mapping and setting colors with scatter plots
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用散点图映射和设置颜色
- en: Handling over-plotting and outlier values by managing opacity, symbols, and
    scales
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过管理不透明度、符号和刻度来处理过度绘图和异常值
- en: Introducing sliders and range sliders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍滑块和范围滑块
- en: Customizing the marks and values of sliders
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义滑块的标记和值
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The same tools that we used in the previous chapter will be used here. We will
    also focus a little on Plotly's `graph_objects` module for creating scatter plots,
    because it provides other tools and is very useful when customizing our plots
    further. The packages to use are Plotly, Dash, Dash Core Components, Dash HTML
    Components, Dash Bootstrap Components, pandas, and JupyterLab.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用上一章中使用的相同工具。我们还会稍微关注一下Plotly的`graph_objects`模块来创建散点图，因为它提供了其他工具，并且在进一步自定义我们的图表时非常有用。需要使用的包有Plotly、Dash、Dash
    Core Components、Dash HTML Components、Dash Bootstrap Components、pandas和JupyterLab。
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_06](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_06).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上的[https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_06](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_06)找到。
- en: Check out the following video to see the Code in Action at [https://bit.ly/3ancblu](https://bit.ly/3ancblu).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，观看代码演示：[https://bit.ly/3ancblu](https://bit.ly/3ancblu)。
- en: We start by exploring the different ways, or the different things, if you want,
    that we can plot with scatter plots.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先探索使用散点图可以绘制的不同方式，或者说不同的内容。
- en: 'Learning about the different ways of using scatter plots: markers, lines, and
    text'
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解使用散点图的不同方式：标记、线条和文本
- en: 'We have a number of different options when using `graph_objects` to create
    scatter plots, as mentioned in the introduction, so we will be exploring it together
    with Plotly Express. To give you an idea of the versatility of the available scatter
    plots, the following code extracts all the `scatter` methods available to the
    `Figure` object, as well as those available in Plotly Express:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`graph_objects`创建散点图时，我们有很多不同的选择，正如在引言中提到的那样，因此我们将与Plotly Express一起进行探索。为了让你了解散点图的多样性，以下代码提取了`Figure`对象可用的所有`scatter`方法，以及Plotly
    Express中可用的那些方法：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, there are some overlaps in the available methods, and there
    are also some methods that aren't available in both modules. We won't go into
    all of them, but it's good to know them, because you can easily utilize your knowledge
    of regular scatter plots for the other types. Let's now take a look at some of
    the differences between using those options.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，可用方法之间存在一些重叠，也有一些方法在两个模块中并不适用。我们不会详细讨论所有这些方法，但知道它们是很有帮助的，因为你可以轻松地将散点图的常规知识应用于其他类型的图表。现在让我们看看使用这些选项时的一些区别。
- en: Markers, lines, and text
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记、线条和文本
- en: 'One interesting option that is available in the `go.Scatter` object is the
    `mode` parameter. This can take any combination of markers, lines, and/or text.
    You can specify one, two, or all three options together. When specifying more
    than one option, you have to specify them as a single string, where elements are
    separated by the plus sign, for example, `"markers+text"`. Let''s first get to
    know the indicators that we are going to focus on in this chapter, and immediately
    explore the plotting options:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`go.Scatter`对象中一个有趣的选项是`mode`参数。它可以包含标记、线条和/或文本的任意组合。你可以指定其中一个、两个或三个选项。当指定多个选项时，必须将它们作为一个单一字符串指定，其中各元素由加号分隔，例如`"markers+text"`。让我们首先了解一下我们将在本章中关注的指标，并立即探索绘图选项：'
- en: 'Run the required imports and create the `poverty` DataFrame:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所需的导入并创建`poverty`数据框：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our dataset contains three levels of daily income at which poverty is measured.
    They measure "the mean shortfall in income or consumption from the poverty line
    – $1.90 a day". They also have the same measure for two other levels, $3.20 and
    $5.50\. They are also available as absolute counts in different columns, but we
    will focus on the percentages in this chapter. Their columns start with Poverty
    gap, which we can use as a pattern to extract the columns that we want:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的数据集包含三个不同的日收入水平来衡量贫困。它们衡量的是“贫困线下的平均收入或消费不足——每天$1.90”。它们还针对其他两个水平（$3.20和$5.50）有相同的衡量标准。这些数据也可以在不同的列中以绝对数值呈现，但我们将在本章中重点关注百分比。它们的列名以贫困缺口（Poverty
    gap）开头，我们可以将其作为模式来提取我们需要的列：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To make things simple, we will be starting all related variable names and objects
    with `perc_pov_` to make it clear that we are dealing with the poverty percentages.
    Keep in mind that we now have several objects and functions in the app, and we
    want to make sure we keep things simple, clear, and consistent. We now use the
    list we just created to create three variables, one for each poverty level:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化问题，我们将所有相关的变量名和对象以`perc_pov_`开头，以明确我们正在处理贫困百分比。请记住，我们现在在应用中有几个对象和函数，我们希望确保保持简单、清晰和一致。我们现在使用刚刚创建的列表来创建三个变量，每个贫困水平一个：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As usual, we need to look at the description of those indicators and, most
    importantly, at the limitations that they may have:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，我们需要查看这些指标的描述，最重要的是，它们可能存在的限制：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The definitions are pretty much the same for the three indicators, and the
    limitations are also similar to what we saw in the previous chapter. Feel free
    to read the details, but keep in mind that these are not perfect numbers, and
    we have to be careful if we were to make any interpretations. We now create a
    variable for a country and use it to create a subset DataFrame containing the
    data for `country` and `perc_pov_19`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个指标的定义基本相同，限制条件也与上一章看到的相似。请随意阅读细节，但请记住，这些数字并不完美，如果我们要做出任何解释时需要小心。我们现在为一个国家创建一个变量，并利用它创建一个包含`country`和`perc_pov_19`数据的子集数据框：
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a `Figure` and then add a scatter plot to it, using the relevant method.
    The `mode` parameter should be given one of the options discussed previously,
    and it is shown here simply as `mode`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Figure`，然后使用相关方法添加一个散点图。`mode`参数应该给出之前讨论的选项之一，这里仅以`mode`显示：
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Figure 6.1* shows the effect of running the preceding code with each of the
    possible options for `mode`, with the figure titles showing how to set this option:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.1*展示了运行前述代码时对于`mode`的每个可能选项的效果，图表标题显示了如何设置该选项：'
- en: '![Figure 6.1 – Different ways of setting the mode parameter for scatter plots](img/B16780_06_1.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 设置散点图模式参数的不同方式](img/B16780_06_1.jpg)'
- en: Figure 6.1 – Different ways of setting the mode parameter for scatter plots
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 设置散点图模式参数的不同方式
- en: 'You can also see the other options in *Figure 6.2*:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到*图6.2*中的其他选项：
- en: '![Figure 6.2 – Other ways of setting the mode parameter for scatter plots](img/B16780_06_2.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 设置散点图模式参数的其他方法](img/B16780_06_2.jpg)'
- en: Figure 6.2 – Other ways of setting the mode parameter for scatter plots
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 设置散点图模式参数的其他方法
- en: Plotly Express has separate functions for scatter and line plots. You can plot
    text using the `scatter` function, which can be done by either choosing which
    column of your DataFrame contains the text to plot, or by providing a list of
    the text elements. The Plotly Express `scatter` function contains a `text` parameter
    that can be used for that.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Plotly Express 为散点图和线图提供了独立的函数。你可以使用 `scatter` 函数绘制文本，可以通过选择 DataFrame 中包含文本的列，或提供一个文本元素列表来实现。Plotly
    Express 的 `scatter` 函数包含一个 `text` 参数，可以用来处理这个任务。
- en: Let's now take a look at how we can utilize this code to create multiple scatter
    plot traces.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看一下如何利用这段代码创建多个散点图轨迹。
- en: Creating multiple scatter traces in a single plot
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在单个图表中创建多个散点轨迹
- en: We will mostly be focusing on using Plotly Express as much as possible, because
    of its convenience, and the other advantages previously discussed in [*Chapter
    4*](B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060), *Data Manipulation and Preparation
    - Paving the Way to Plotly Express*. It's still very important to know how to
    work with `Figure` objects as you will encounter many situations where you will
    need to work with them, especially when you have a lot of customizations to make.
    Also, keep in mind that although the most important chart types are supported
    by Plotly Express, not all of them are.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尽可能专注于使用 Plotly Express，因为它的便利性以及之前在[*第 4 章*](B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060)《数据处理与准备——为
    Plotly Express 铺路》中讨论过的其他优点。尽管如此，了解如何使用 `Figure` 对象仍然非常重要，因为你会遇到许多需要与之打交道的情况，特别是当你需要进行大量自定义时。此外，尽管
    Plotly Express 支持最重要的图表类型，但并非所有类型都得到支持。
- en: 'Let''s extend the preceding chart with traces of other countries and compare
    the two approaches. We start with the `graph_objects` module''s `Figure` object:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为其他国家添加轨迹来扩展前面的图表，并比较这两种方法。我们从 `graph_objects` 模块的 `Figure` 对象开始：
- en: 'Create a `countries` list to filter with:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `countries` 列表进行过滤：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a subset of `poverty`, which we will call `df`, where the values of
    the `Country Name` column are in the `countries` list (using the `isin` method).
    We then extract the `year`, `Country Name`, and `perc_pov_19` columns and drop
    the missing values:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `poverty` 的子集，我们称之为 `df`，其中 `Country Name` 列的值在 `countries` 列表中（使用 `isin`
    方法）。然后，我们提取 `year`、`Country Name` 和 `perc_pov_19` 列，并删除缺失值：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a `Figure` object, assigning it to a variable, `fig`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Figure` 对象，并将其分配给一个变量 `fig`：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We now want to add a trace for each country that we want to plot. This can
    be done by looping over the countries and creating a sub-DataFrame that contains
    only data for the current country:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想为每个要绘制的国家添加一个轨迹。可以通过遍历国家并创建一个仅包含当前国家数据的子 DataFrame 来完成：
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now add a new trace (within the same loop, and at the same level of indentation)
    by using the `add_scatter` method. Note that we set `mode=''markers+lines''` and
    we use the `name` attribute to set the title of this trace in the legend:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在在相同的循环中（且具有相同的缩进级别）通过使用 `add_scatter` 方法添加一个新轨迹。注意，我们设置了 `mode='markers+lines'`，并使用
    `name` 属性设置了该轨迹在图例中的标题：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also need to add a title for the *y*-axis, and then we can easily show the
    figure:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要为 *y* 轴添加标题，然后我们就可以轻松地显示图形：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running the preceding code produces the chart in *Figure 6.3*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将生成 *图 6.3* 中的图表：
- en: '![Figure 6.3 – Creating multiple scatter plots using the graph_objects module](img/B16780_06_3.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 使用 graph_objects 模块创建多个散点图](img/B16780_06_3.jpg)'
- en: Figure 6.3 – Creating multiple scatter plots using the graph_objects module
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 使用 graph_objects 模块创建多个散点图
- en: 'Now, let''s compare that to how we would do it with Plotly Express. The code
    to produce it is so short, clear, and intuitive that it barely warrants an explanation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其与使用 Plotly Express 的方法进行比较。生成图表的代码简洁明了，几乎不需要解释：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We chose the value for the `data_frame` parameter and selected which columns
    we want for the `x`, `y`, and `color` parameters from `df`. The code then produces
    the chart in *Figure 6.4*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `data_frame` 参数选择了值，并从 `df` 中选择了我们想要的 `x`、`y` 和 `color` 参数的列。然后，代码生成了 *图
    6.4* 中的图表：
- en: '![Figure 6.4 – Creating multiple scatter plots using Plotly Express](img/B16780_06_4.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 使用 Plotly Express 创建多个散点图](img/B16780_06_4.jpg)'
- en: Figure 6.4 – Creating multiple scatter plots using Plotly Express
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 使用 Plotly Express 创建多个散点图
- en: We also get the axes labeled automatically and the legend labeled properly,
    and we even have a title for the legend, using the column name that we selected
    for the `color` parameter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会自动给坐标轴加上标签，图例也会正确标注，甚至图例还会有标题，使用我们为`color`参数选择的列名。
- en: 'There is a minor issue though. The disconnected points are not as easy to read
    as in the previous chart. This is especially important in this case because we
    are expressing a sequence of events, and the lines make it much clearer. With
    interactive dashboards, we don''t know what our users are going to select, which
    means that they might produce charts that are even harder to read than this one.
    Plotly Express has separate functions for scatter and line plots, so in order
    to make it a "lines+markers" plot, we need to assign this to a `Figure` object
    and then add line traces. Here are the steps to do this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，有一个小问题。与前面的图表相比，断开的点并不像之前那样容易阅读。这在本例中尤其重要，因为我们正在表达一系列事件，而这些线条使得表达更加清晰。对于交互式仪表板，我们无法预测用户将选择什么，这意味着他们可能会生成比这个图表更难以阅读的图表。Plotly
    Express 为散点图和线图提供了独立的函数，因此，为了使其成为“线条+标记”图表，我们需要将其分配给一个`Figure`对象，然后添加线条轨迹。以下是执行此操作的步骤：
- en: 'Create a `Figure` object and assign it to a variable, `fig`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Figure`对象，并将其赋值给一个变量`fig`：
- en: '[PRE14]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create another `Figure` object, exactly like the previous one, with a different
    name and chart type:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个`Figure`对象，完全像上一个一样，只是名称和图表类型不同：
- en: '[PRE15]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'From `fig_lines`, we want to add its traces to `fig`. If you remember, the
    traces can be found under the `data` attribute of the `Figure` object. The `data`
    attribute is a tuple with each element corresponding to a trace. So, we need to
    loop over those traces (of the `data` attribute) and add them to `fig`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`fig_lines`中，我们希望将其轨迹添加到`fig`中。如果你记得，轨迹可以在`Figure`对象的`data`属性下找到。`data`属性是一个元组，每个元素对应一个轨迹。因此，我们需要遍历这些轨迹（即`data`属性中的轨迹），并将它们添加到`fig`中：
- en: '[PRE16]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that each new line trace will have its label on the legend. So we would
    have redundant line labels in the legend, which we had to remove. We handled that
    by setting the `showlegend` attribute to `False` for each of the traces. Running
    this code produces the chart in *Figure 6.5*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个新的线条轨迹都会在图例中有其标签。因此，我们会在图例中看到重复的线条标签，我们需要将它们去掉。我们通过将每个轨迹的`showlegend`属性设置为`False`来解决这个问题。运行这段代码会生成图*6.5*：
- en: '![Figure 6.5 – Creating multiple scatter and line plots using Plotly Express](img/B16780_06_5.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 使用 Plotly Express 创建多个散点图和线图](img/B16780_06_5.jpg)'
- en: Figure 6.5 – Creating multiple scatter and line plots using Plotly Express
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 使用 Plotly Express 创建多个散点图和线图
- en: Comparing the mental effort and amount of code required to produce the same
    chart in two different approaches, we can see that there wasn't that much of a
    difference. This is typical when you want to produce something customized and/or
    something good enough for publishing. Still, for exploration purposes, Plotly
    Express is clearly a great starting point, and once you get a good idea of the
    data, you can better decide on which approach to adopt.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 比较用两种不同方法生成相同图表所需的脑力和代码量，我们可以看到并没有太大区别。这是当你想要生成自定义的或足够适合发布的内容时的典型情况。不过，对于探索目的来说，Plotly
    Express 显然是一个很好的起点，一旦你对数据有了足够的了解，你可以更好地决定采用哪种方法。
- en: We have seen an example of implicitly managing color on scatter plots (the colors
    were automatically set or us), and we are now ready to explore more options for
    managing color. If you are reading this on the printed grayscale version, you
    will see different shades of colors that might be distinguishable, but as we did
    previously, we will also use symbols to make it explicit and easy to understand.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了如何在散点图中隐式地管理颜色（颜色是自动设置的），现在我们准备探索更多的颜色管理选项。如果你正在阅读打印的黑白版，你会看到不同的颜色阴影，这些阴影可能是可区分的，但正如我们之前所做的，我们还将使用符号来明确表示，使其易于理解。
- en: Let's now explore the different options that we have for managing color.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探索管理颜色的不同选项。
- en: Mapping and setting colors with scatter plots
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用散点图进行映射和设置颜色
- en: 'Colors are extremely important in conveying and expressing information about
    our charts. It is also a very big topic, and a full discussion is beyond the scope
    of this book. We will focus on colors for two types of variables – discrete and
    continuous. We will also tackle two ways of using colors in our charts: mapping
    variables to colors, and manually setting our colors.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色在传递和表达我们图表中的信息中至关重要。这也是一个非常大的话题，完整讨论超出了本书的范围。我们将重点讨论两种类型变量的颜色——离散和连续。我们还将处理在图表中使用颜色的两种方式：将变量映射到颜色和手动设置颜色。
- en: We start by exploring the differences between the two types of variables.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先探索这两种类型变量之间的差异。
- en: Discrete and continuous variables
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离散和连续变量
- en: Simply speaking, continuous variables are the ones that can take an infinite
    number of possible values in a certain range of numbers. For example, population
    is a number that can take any value, based on the number of people living in a
    certain country. Continuous variables are typically numbers (integers or real
    numbers). Height, weight, and speed are other examples as well.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，连续变量是指在一定范围内可以取无限多个可能值的变量。例如，人口是一个可以取任何值的数字，基于一个国家的人口数量。连续变量通常是数字（整数或实数）。身高、体重和速度也是其他示例。
- en: Discrete variables, on the other hand, are variables that can take the value
    of any one of a limited set of items. Most importantly, discrete variables cannot
    take values in between the items. Countries are one such example. A country can
    either be country A or country B, but can't be 10% A and 90% B. Discrete variables
    are typically text variables, and usually have a relatively small number of unique
    items.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，离散变量是可以取有限集合中任一项值的变量。最重要的是，离散变量不能取这些项之间的值。国家就是一个这样的例子。一个国家要么是国家A，要么是国家B，但不能是10%的A和90%的B。离散变量通常是文本变量，且通常具有相对较少的独特项。
- en: 'The way we use color to express the nature of our variables is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用颜色表达变量性质的方式如下：
- en: For continuous variables, we use a color scale that takes on colors that gradually
    change between two or more colors, as the values they represent change. For example,
    if our color scale starts as white for the lowest value, and ends up as blue at
    the highest value, all values in between would take on varying shades of white
    and blue. A marker that has a color that contains more blue than white means that
    its value is closer to the maximum value of that variable and vice versa. We will
    try this shortly.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于连续变量，我们使用一种颜色渐变，随着其代表的值变化，颜色会在两种或多种颜色之间逐渐变化。例如，如果我们的颜色渐变从最低值为白色，最高值为蓝色，那么其中的所有值将会呈现白色和蓝色的不同深浅。一个颜色中蓝色比白色多的标记，意味着它的值更接近该变量的最大值，反之亦然。我们稍后会尝试这个。
- en: Discrete variables are distinct items, and the colors we use for them need to
    be as distinct from each other as possible, especially the ones that appear next
    to each other. Examples will make this clear, and we start with continuous variables.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离散变量是不同的项，我们为它们使用的颜色需要尽可能地彼此区分，尤其是那些彼此相邻的颜色。通过一些示例可以更清楚地理解这一点，我们从连续变量开始。
- en: Using color with continuous variables
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用颜色表示连续变量
- en: 'Using the same metric we started with, we want to take an arbitrary year and
    plot the indicator value for each of the countries. We already know how to do
    this. We now want to add a new dimension to our chart. We want to use color to
    show another value, for example, population. This will allow us to see whether
    there is any correlation between population and the metric we are plotting (poverty
    at $1.90 in this case). Let''s prepare our variables and data:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们开始时的相同指标，我们希望选择一个任意年份，并绘制每个国家的指标值。我们已经知道如何做到这一点。现在，我们想为我们的图表添加一个新的维度。我们希望使用颜色来表示另一个值，例如人口。这将使我们能够看到人口和我们正在绘制的指标（此处为$1.90贫困线）之间是否存在相关性。让我们准备好我们的变量和数据：
- en: 'Create variables for the indicator and year of choice:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所选指标和年份的变量：
- en: '[PRE17]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using the indicator and year, we create a subset of `poverty` where the year
    column is equal to our variable, `year`, and the `is_country` column is `True`.
    We then drop the missing values and sort the values according to this column.
    The following code achieves this:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指标和年份，我们创建一个`poverty`子集，其中年份列等于我们的变量`year`，并且`is_country`列为`True`。然后我们删除缺失值并根据这一列对数据进行排序。以下代码实现了这一点：
- en: '[PRE18]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'All we have to do is select the column we want for mapping its values to the
    appropriate colors, and we do this as we usually do with Plotly Express:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要选择我们想要映射其值到适当颜色的列，然后像平时一样使用 Plotly Express：
- en: '[PRE19]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code produces the chart in *Figure 6.6*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了*图 6.6*中的图表：
- en: '![Figure 6.6 – Setting color for continuous variables with Plotly Express](img/B16780_06_6.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 使用 Plotly Express 设置连续变量的颜色](img/B16780_06_6.jpg)'
- en: Figure 6.6 – Setting color for continuous variables with Plotly Express
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 使用 Plotly Express 设置连续变量的颜色
- en: We basically added a new layer to our visualization with the column that we
    selected. Each visual attribute adds another dimension to the chart, and makes
    it richer, but adding too many dimensions might make it overwhelming and difficult
    to read. It's up to us to strike the right balance and make sure we are presenting
    something meaningful and readable to our audience.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上是为我们的可视化添加了一个新层次，即我们选择的那一列。每一个视觉属性都为图表添加了一个维度，使得图表更加丰富，但添加过多的维度可能会让图表显得过于复杂，难以阅读。我们需要找到一个合适的平衡，确保所展示的内容既有意义又易于阅读，适合我们的观众。
- en: 'We can immediately see that the country with the highest population in the
    chart (the United States, in bright yellow) has one of the lowest values for our
    indicator. We can also see that since most other markers are closer to purple
    in color, this shows that the country with the highest population has quite an
    extreme value for that metric compared to the others. It seems to be an outlier
    in population, but not so, with the poverty indicator. The popup that appears
    when we hover over a marker also takes the same color and, being much bigger than
    the marker, makes it very easy to relate the color to its relative position on
    the color bar. The color `color_scale_continuous`. We can see how to do that,
    as well as its effect, in *Figure 6.7*, where we chose the **cividis** scale:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立刻看到，图表中人口最多的国家（美国，亮黄色）在我们的指标中是最小的值之一。我们也可以看到，由于其他大多数标记的颜色更接近紫色，这表明人口最多的国家在该指标上的值相较于其他国家来说非常极端。虽然它在人口上看起来像是一个异常值，但在贫困指标上却不是如此。当我们将鼠标悬停在标记上时，弹出的信息框也采用相同的颜色，而且由于它比标记大得多，因此很容易将颜色与其在颜色条上的相对位置关联。颜色`color_scale_continuous`。我们可以在*图
    6.7*中看到如何做到这一点，并了解其效果，我们选择了**cividis**尺度：
- en: '![Figure 6.7 – Choosing a different continuous color scale](img/B16780_06_7.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 选择不同的连续颜色尺度](img/B16780_06_7.jpg)'
- en: Figure 6.7 – Choosing a different continuous color scale
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 选择不同的连续颜色尺度
- en: 'There is no additional information in this chart, only that we changed the
    color scale to a different one. It''s intuitive to understand this color scale,
    as it moves between dark blue and bright yellow, and all combinations of colors
    in between. The scale is also known as a "sequential" scale, because it shows
    how values move from a low to a high value. You can get a full list of named color
    scales by running `px.colors.named_colorscales()`, which will return the names
    of those scales. More interesting is the option to see all those scales and compare
    them, so you can choose which one you want. You can produce a chart with all available
    scales of a certain type by running `px.colors.sequential.swatches()`, and you
    can see part of the output in *Figure 6.8*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表没有额外的信息，唯一的变化是我们将颜色尺度更换成了不同的一个。这个颜色尺度很直观，颜色在深蓝色和亮黄色之间变化，并涵盖了所有介于两者之间的颜色组合。该尺度也被称为“顺序”尺度，因为它展示了从低值到高值的变化。你可以通过运行`px.colors.named_colorscales()`获取所有命名的颜色尺度列表，该命令将返回这些尺度的名称。更有趣的是，你可以查看并比较所有这些尺度，从而选择你想要的一个。你可以通过运行`px.colors.sequential.swatches()`生成一个包含所有可用顺序色阶的图表，部分输出如*图
    6.8*所示：
- en: '![Figure 6.8 – The first few sequential scales available in Plotly](img/B16780_06_8.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – Plotly 中可用的前几个顺序色阶](img/B16780_06_8.jpg)'
- en: Figure 6.8 – The first few sequential scales available in Plotly
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – Plotly 中可用的前几个顺序色阶
- en: 'Another interesting way of showing the color scales in action is by using the
    `swatches_continuous` functions. For example, *Figure 6.9* shows the result of
    running `px.colors.sequential.swatches_continuous()`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个展示颜色尺度效果的有趣方式是使用`swatches_continuous`函数。例如，*图 6.9*展示了运行`px.colors.sequential.swatches_continuous()`的结果：
- en: '![Figure 6.9 – The first few sequential scales available in Plotly as they
    would appear in a color bar](img/B16780_06_9.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – Plotly 中可用的前几个顺序色阶，显示在颜色条中](img/B16780_06_9.jpg)'
- en: Figure 6.9 – The first few sequential scales available in Plotly as they would
    appear in a color bar
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – Plotly 中的前几个连续比例尺，它们在色条中的显示效果
- en: This gives an even better idea of how they would actually look, and shows colors
    with smooth transitions in between.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好地展示了它们实际的外观，并展示了颜色之间的平滑过渡。
- en: 'You can use the `swatches` functions for other types of color scales and sequences.
    You simply run the previous command and replace `sequential` with any of the following:
    `carto`, `cmocean`, `colorbrewer`, `cyclical`, `diverging`, or `qualitative`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`swatches`功能来获取其他类型的颜色标度和序列。只需运行上一个命令，并用以下任何一个替换`sequential`：`carto`、`cmocean`、`colorbrewer`、`cyclical`、`diverging`或`qualitative`。
- en: So far, we have mapped the data values and colors automatically by choosing
    which column's values we want to use for that. There is also the option of manually
    setting the color scales.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过选择要使用的列的值自动映射了数据值和颜色。还有手动设置颜色标度的选项。
- en: Manually creating color scales
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动创建颜色标度
- en: 'One way of doing this is by providing a list of two or more colors to the `color_continuous_scale`
    parameter. By default, the first color you provide will be assigned to the minimum
    value and the last color to the maximum value. Values in between will take combinations,
    resulting in shades of the two colors. This shows how close the data point is
    to each of the extremes. We''ll see an example of using more than two colors shortly.
    Using the same code and setting `color_continuous_scale=["steelblue", "darkorange"]`
    produces the chart in *Figure 6.10*:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是通过为`color_continuous_scale`参数提供两种或更多颜色的列表来实现。默认情况下，您提供的第一种颜色将分配给最小值，最后一种颜色将分配给最大值。中间的值将采用这两种颜色的组合，产生两种颜色的阴影。这显示了数据点距离极端值有多近。稍后我们将看到使用两种以上颜色的示例。使用相同的代码并设置`color_continuous_scale=["steelblue",
    "darkorange"]`将生成 *图 6.10* 中的图表：
- en: '![Figure 6.10 – Manually setting continuous color scales](img/B16780_06_10.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 手动设置连续颜色标度](img/B16780_06_10.jpg)'
- en: Figure 6.10 – Manually setting continuous color scales
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 手动设置连续颜色标度
- en: This gives a glimpse of how granular the options are, and this is barely scratching
    the surface of what is available. Sometimes, you may want to rescale your data
    so the colors adopt a smoother progression from the minimum to the maximum. The
    charts we just created are a good candidate for this. We have one outlier when
    it comes to population, so it might be better to set the `color` parameter to
    a scaled version of our data if we want to do that. In general, because there
    are numerous scales that are well-established and tested, it is better to choose
    from them instead of manually setting your own colors. Another important consideration
    is color blindness, and trying to use scales that cater for people who have it.
    You don't want to use colors that are indistinguishable by some of your readers.
    You can run a simple check by searching online as to whether or not a color scale
    is colorblind-friendly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这让人一窥选项的精细程度，但这只是表面。有时，您可能希望重新调整数据，使颜色从最小值到最大值呈现更平滑的过渡。我们刚刚创建的图表是这样的一个好例子。在人口方面我们有一个离群值，所以如果我们想要这样做，最好将`color`参数设置为我们数据的一个经过缩放的版本。总的来说，因为有许多经过良好验证和测试的比例尺可供选择，所以最好从中选择，而不是手动设置您自己的颜色。另一个重要考虑因素是色盲，尝试使用适合患有色盲症的人群的比例尺。您不希望使用一些读者无法区分的颜色。您可以通过在线搜索来简单检查一个颜色标度是否适合色盲人群。
- en: 'Let''s now set a scale that uses three colors. The `RdBu` (red blue) scale
    goes from red to blue, with mid values taking white as their color. It is one
    of the default scales. Let''s quickly plot a simple chart with this scale:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们设置一个使用三种颜色的比例尺。`RdBu`（红蓝）比例尺从红色变到蓝色，中间值取白色作为它们的颜色。这是其中一个默认的比例尺。让我们用这个比例尺快速绘制一个简单的图表：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We created a list of integers in the range [-2, 6] and mapped their colors
    to the `RdBu` scale, which produces the chart in *Figure 6.11*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个在范围[-2, 6]内的整数列表，并将它们的颜色映射到`RdBu`比例尺，生成了 *图 6.11* 中的图表：
- en: '![Figure 6.11 – Manually setting a continuous diverging color scale](img/B16780_06_11.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – 手动设置连续的分歧颜色标度](img/B16780_06_11.jpg)'
- en: Figure 6.11 – Manually setting a continuous diverging color scale
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 手动设置连续的分歧颜色标度
- en: In this case, you can see the colors moving from red to white to blue, passing
    through the intermediate shades of each color. This is also known as a "diverging"
    scale. There is a midpoint (the white point in this case) where colors diverge,
    signifying two different types of values. Usually, we use this to show values
    above and below a certain value. In this case, we wanted to show negative values
    in red, zero values in white, and positive values in blue. But we didn't get that.
    The white midpoint was set as the midpoint of the data, which happens to be the
    fifth element of our list, and its value is 2\.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以看到颜色从红色到白色再到蓝色的过渡，经过每种颜色的中间色调。这也被称为“分歧”色标。这里有一个中点（在这个例子中是白色点），颜色在这个点分歧，表示两种不同类型的值。通常，我们用这个来显示高于和低于某个特定值的值。在这种情况下，我们想用红色表示负值，白色表示零值，蓝色表示正值。但我们没有得到这个结果。白色的中点被设置为数据的中点，而这个中点恰好是我们列表中的第五个元素，其值为2。
- en: 'This can be fixed by using the `color_continuous_midpoint` parameter, as you
    can see in *Figure 6.12*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用`color_continuous_midpoint`参数来修正，正如你在*图 6.12*中看到的那样：
- en: '![Figure 6.12 – Manually setting a midpoint for a continuous diverging color
    scale](img/B16780_06_12.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – 手动设置连续分歧颜色尺度的中点](img/B16780_06_12.jpg)'
- en: Figure 6.12 – Manually setting a midpoint for a continuous diverging color scale
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 手动设置连续分歧颜色尺度的中点
- en: We now have a more meaningful midpoint, where the divergence in color makes
    it easy to see positive and negative values. Another important thing this achieves
    is that it also shows us how skewed the data is. Note that we don't have any red
    markers in the chart. We have two pinkish ones, while we have more blue values.
    This perfectly corresponds to the list of numbers, which contains two negative,
    and six positive values. The color bar also makes it clear that we are only covering
    part of the red spectrum, while blue is fully covered.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个更有意义的中点，在这个中点上，颜色的分歧使得正负值一目了然。另一个重要的效果是，它还展示了数据的偏斜程度。请注意，图表中没有红色标记。我们有两个粉红色标记，而蓝色值则更多。这与数字列表完全对应，列表中包含两个负值和六个正值。颜色条也清楚地表明，我们只覆盖了红色光谱的一部分，而蓝色则完全覆盖。
- en: There are many other options for setting colors, scaling the data, and expressing
    different values. I encourage you to learn more about this topic, and the good
    news is that Plotly provides options to customize colors the way you want.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他选项可用于设置颜色、缩放数据以及表示不同的值。我鼓励你进一步了解这个主题，幸运的是，Plotly提供了许多选项，可以让你按自己的需求定制颜色。
- en: Let's now see how color works with discrete variables.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看颜色如何与离散变量一起使用。
- en: Using color with discrete variables
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用颜色与离散变量
- en: 'The objective now is not to visualize the degrees of difference between values.
    We now want to group values based on a criterion and see the differences across
    those groups of values. We can immediately see what happens if we simply set the
    `color` parameter to a column that has text values. For example, we can set `color="Income
    Group"` to get the chart in *Figure 6.13*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的目标不是可视化值之间的差异程度。我们现在想根据某个标准对值进行分组，并查看这些值组之间的差异。如果我们简单地将`color`参数设置为具有文本值的列，立刻就能看到结果。例如，我们可以设置`color="Income
    Group"`来获得*图 6.13*中的图表：
- en: '![Figure 6.13 – Using color with categorical variables](img/B16780_06_13.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13 – 使用颜色与分类变量](img/B16780_06_13.jpg)'
- en: Figure 6.13 – Using color with categorical variables
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 使用颜色与分类变量
- en: Everything was automatically handled for us. Simply because we chose a column
    with text values, Plotly Express grouped the data according to that column, and
    chose a sequence of colors that are distinct from one another, so we can see how
    values change across the groups. We also used symbols to make it easier to see,
    especially on a grayscale version of the chart. This was achieved by setting `symbol='Income
    Group'`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都自动为我们处理了。仅仅因为我们选择了一个具有文本值的列，Plotly Express就根据该列对数据进行了分组，并选择了一组彼此不同的颜色，使我们能够看到不同组之间值的变化。我们还使用了符号，使其在特别是灰度版本的图表中更易于查看。这是通过设置`symbol='Income
    Group'`实现的。
- en: 'As with continuous variables, we can also set our own discrete color sequence
    by providing one to the `color_discrete_sequence` parameter. *Figure 6.14* shows
    the effect of setting this parameter, by using one of the sequences provided by
    Plotly:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与连续变量一样，我们也可以通过提供一个颜色序列给`color_discrete_sequence`参数，来自定义自己的离散颜色序列。*图 6.14*展示了设置此参数后的效果，使用的是Plotly提供的其中一种颜色序列：
- en: '![Figure 6.14 – Setting a different color sequence for categorical variables](img/B16780_06_14.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.14 – 为分类变量设置不同的颜色序列](img/B16780_06_14.jpg)'
- en: Figure 6.14 – Setting a different color sequence for categorical variables
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 为分类变量设置不同的颜色序列
- en: Note that we have chosen a sequence by getting it from the available list, `px.colors.qualitative.G10`,
    and as you may have guessed, you can generate all the available sequences by running
    `px.colors.qualitative.swatches()`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过从可用列表中选择一个序列`px.colors.qualitative.G10`，并且正如你可能猜到的，你可以通过运行`px.colors.qualitative.swatches()`来生成所有可用的颜色序列。
- en: 'As we did with continuous variables, we can also manually set the colors of
    our discrete variables by providing a list of named colors. We can also use the
    colors'' hexadecimal representation, for example, `#aeae14`, or the RGB values,
    for example, `''rgb(25, 85, 125)''`. Passing our chosen colors to the `color_discrete_sequence`
    parameter, we get the chart in *Figure 6.15*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对待连续变量一样，我们也可以通过提供一个命名颜色的列表，手动设置离散变量的颜色。我们还可以使用颜色的十六进制表示，例如`#aeae14`，或RGB值，例如`'rgb(25,
    85, 125)'`。将我们选择的颜色传递给`color_discrete_sequence`参数后，我们得到的图表如*图 6.15*所示：
- en: '![Figure 6.15 – Manually setting the colors of a sequence for categorical variables](img/B16780_06_15.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.15 – 为分类变量手动设置颜色序列](img/B16780_06_15.jpg)'
- en: Figure 6.15 – Manually setting the colors of a sequence for categorical variables
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – 为分类变量手动设置颜色序列
- en: 'When you manually select the colors of your choice, you need to make sure that
    you provide a list of colors that has the same number of elements as the unique
    values of the variable you are trying to visualize. Otherwise, it will cycle through
    the colors you provided, and this might be misleading. Again, it''s usually better
    to select from the available established sequences, but you can set them manually
    if you want to. When we set the colors that we want, we didn''t specify which
    item should take which color. We simply stated that we want the unique values
    to take this set of colors. Sometimes, you may want to explicitly map certain
    colors to certain categories. Once you know the unique values, you can provide
    a dictionary to the `color_discrete_map` parameter, and then map each value to
    the color of your choice:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你手动选择所需颜色时，必须确保提供的颜色列表元素数量与你试图可视化的变量的唯一值数量相同。否则，它会循环使用你提供的颜色，这可能会导致误导。再次强调，通常最好选择可用的已建立的颜色序列，但如果你愿意，你也可以手动设置。当我们设置我们想要的颜色时，并没有指定哪一项应该使用哪个颜色。我们只是简单地声明我们希望唯一值使用这组颜色。有时，你可能希望明确地将某些颜色映射到特定类别。一旦知道了唯一值，你可以将字典提供给`color_discrete_map`参数，然后将每个值映射到你选择的颜色：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Setting this option produces the chart in *Figure 6.16*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 设置此选项会生成*图 6.16*中的图表：
- en: '![Figure 6.16 – Manually setting the colors for each value of a sequence for
    categorical variables](img/B16780_06_16.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16 – 为分类变量的每个值手动设置颜色](img/B16780_06_16.jpg)'
- en: Figure 6.16 – Manually setting the colors for each value of a sequence for categorical
    variables
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – 为分类变量的每个值手动设置颜色
- en: Note that most continuous variable parameters contains "scale," while the discrete
    ones contain "sequence." This can help in remembering and understanding the fundamental
    difference in the process of mapping colors to the two kinds of variables.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，大多数连续变量参数包含“scale”，而离散变量则包含“sequence”。这有助于记住并理解在将颜色映射到这两种变量时的基本区别。
- en: With continuous variables, we are giving the readers the ability to see the
    approximate value of the markers based on the color, as well as the relative position
    in the dataset. It is not clear cut, but you can tell that the population of a
    certain country is around twenty million, and that it looks like it's one of the
    highest countries in this dataset. Users can, of course, hover and get the exact
    value if they want. With discrete variables, we are basically more interested
    in grouping by those variables and seeing trends across those groups.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连续变量，我们使读者能够根据颜色大致看到标记的值以及在数据集中的相对位置。这并不是非常清晰，但你可以大致看出某个国家的人口约为两千万，而且它看起来是该数据集中人口最多的国家之一。当然，用户可以悬停并查看精确值。如果是离散变量，我们主要更关心通过这些变量进行分组，并查看这些组之间的趋势。
- en: We covered a small subset of what can be done with colors, and now we move to
    consider a few other issues that might arise with scatter plots, namely, outliers
    and having many data points to plot.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了颜色处理的一小部分内容，现在我们将考虑一些可能在散点图中出现的其他问题，即异常值和绘制大量数据点。
- en: Handling over-plotting and outlier values by managing opacity, symbols, and
    scales
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过管理不透明度、符号和尺度来处理重叠绘制和异常值
- en: Let's say we are now interested in seeing the relationship between our variable
    and population for the same year that we have been working on. We want to have
    `Population, total` on the *x*-axis, and `perc_pov_19` on the *y*-axis.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在对查看变量与人口之间的关系感兴趣，且我们仍然使用我们之前工作的年份。我们希望将`Population, total`放在* x *轴上，将`perc_pov_19`放在*
    y *轴上。
- en: 'We first create a subset of `poverty` where `year` is equal to 2010, and `is_country`
    is `True`, and sort the values using `Population, total`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`poverty`的子集，其中`year`等于2010，`is_country`为`True`，并使用`Population, total`对值进行排序：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s now see what it looks like when we plot those two variables. Here is
    the code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下当我们绘制这两个变量时，结果是什么样子的。下面是代码：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running this produces the chart in *Figure 6.17*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此操作将生成*图 6.17*：
- en: '![Figure 6.17 – Over-plotting and outliers in charts](img/B16780_06_17.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.17 – 图表中的重叠绘制和异常值](img/B16780_06_17.jpg)'
- en: Figure 6.17 – Over-plotting and outliers in charts
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – 图表中的重叠绘制和异常值
- en: The existence of one outlier, China, with a population close to 1.4 billion,
    forces all markers to be squeezed to a very narrow part of our chart. We also
    have a small cluster of values above 25 on the *y*-axis, but the difference is
    nowhere as extreme as the horizontal one. Another important issue is that there
    are many markers on top of one another. Having solid-colored markers means that
    if you plot one marker on top of another, it will not make any difference; not
    even a thousand markers will. The existence of the two issues together make it
    a very challenging chart to read.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个异常值——中国，其人口接近14亿，这迫使所有标记被压缩到图表的一个非常窄的部分。我们还看到*y*-轴上有一小群数值超过25，但差异远没有水平轴上的差异那样极端。另一个重要的问题是，许多标记彼此重叠。如果使用纯色标记，这意味着如果一个标记叠加在另一个标记上，结果不会有任何区别；即使是一千个标记也是如此。这两个问题同时存在，使得这个图表变得非常难以阅读。
- en: We are going to explore a few techniques that might help with these situations,
    and evaluate when and how they might be useful.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索一些可能有助于这些情况的技术，并评估它们何时以及如何可能有用。
- en: Since we have many points crowded on a very small part of the chart, we are
    likely to have several of them overlapping. Let's see the effect of changing the
    opacity and size of the markers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有许多点挤在图表的一个非常小的部分，我们很可能会有几个点重叠。让我们来看一下改变标记的不透明度和大小的效果。
- en: Controlling the opacity and size of markers
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制标记的不透明度和大小
- en: The `opacity` parameter takes values in the range [0, 1], inclusive. We can
    manually give it a number to control how opaque we want our markers to be. A value
    of `0` means completely transparent, which can also be thought of as a way to
    hide our markers (or a subset of them). A value of `1` means the markers will
    be fully opaque, taking whatever color they were assigned, and fully covering
    the area they are on. This also means that an `opacity` of `0.1` means that the
    marker will be 10% opaque. The practical implication for that is that it means
    that it will take 10 markers on top of one another to completely cover the area
    they are plotted on. If we set it to `0.5` (or 50%), this means that two markers
    would fully cover the area, and so on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`opacity`参数的取值范围是[0, 1]，包含0和1。我们可以手动指定一个数字来控制我们希望标记的透明度。值为`0`表示完全透明，这也可以看作是隐藏标记（或它们的一个子集）的一种方式。值为`1`表示标记将完全不透明，呈现分配给它们的颜色，并完全覆盖它们所在的区域。这也意味着`opacity`为`0.1`时，标记的透明度为10%。这意味着需要将10个标记叠加在一起，才能完全覆盖它们所在的区域。如果我们将其设置为`0.5`（或50%），这意味着两个标记将完全覆盖该区域，依此类推。'
- en: 'Since the markers are quite small, and we don''t have that many values, we
    can also increase their size for better visibility. The `size` parameter, just
    like all other parameters, can take the name of a column in our DataFrame, or
    a list of numbers. This is another visual attribute that we can use to express
    the values of a certain column where the relative sizes reflect the relative value
    that each marker represents. It is also sometimes called a bubble chart. For this
    case, we want to provide a fixed size. This can easily be done by providing a
    list having the same length as the DataFrame we are analyzing. This would give
    the markers a uniform default size, which might not be what we want, so we can
    control it with the `size_max` parameter. Reusing the same code and setting `opacity=0.1`,
    `size=[5]*len(df)`, and `size_max=15`, we get the chart in *Figure 6.18*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标记点较小，并且我们没有那么多的数值，我们也可以增加它们的大小，以便更好地观察。`size`参数，像其他所有参数一样，可以取我们DataFrame中某列的名称，或者是数字列表。这是我们用来表达某一列值的另一个视觉属性，其中相对大小反映了每个标记所代表的相对值。它有时也被称为气泡图。对于这种情况，我们希望提供一个固定的大小。这可以通过提供与我们分析的DataFrame长度相同的列表来轻松实现。这将给标记一个统一的默认大小，可能这不是我们想要的，所以我们可以通过`size_max`参数来控制它。重新使用相同的代码，并设置`opacity=0.1`、`size=[5]*len(df)`和`size_max=15`，我们可以得到*图
    6.18*中的图表：
- en: '![Figure 6.18 – Modifying the opacity and size of markers](img/B16780_06_18.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.18 – 修改标记的透明度和大小](img/B16780_06_18.jpg)'
- en: Figure 6.18 – Modifying the opacity and size of markers
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18 – 修改标记的透明度和大小
- en: This looks a little better. We have bigger markers, and with an `opacity` of
    `0.1`, we can better see that the majority of markers are concentrated very close
    to the origin. Most likely, there is more nuance than that, but because of the
    outlier that we have, those differences seem very small.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来稍微好一些。我们有了更大的标记，且`opacity`为`0.1`时，我们可以更清楚地看到大部分标记集中在原点附近。很可能还有更多的细节，但由于我们有异常值，那些差异看起来非常小。
- en: There will always be a trade-off between opacity and visibility. The more transparent
    your markers are, the clearer you can see, especially with hundreds or thousands
    of markers. But at the same time, they might become so transparent that you can't
    see anything. At `0.1` `opacity`, we are approaching that stage.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 透明度和可见性之间总是存在一个权衡。你的标记越透明，你就能越清楚地看到，特别是在有成百上千个标记的情况下。但与此同时，它们可能会变得如此透明，以至于你什么也看不见。在`0.1`的`opacity`下，我们正在接近那个阶段。
- en: Let's now take a look at another technique, which involves the use of logarithmic
    scales for the axes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下另一种技巧，它涉及到在坐标轴上使用对数刻度。
- en: Using logarithmic scales
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对数刻度
- en: Normal scales are intuitive and easy to understand. Just like physical objects,
    a piece of wood that is twice the length of another one contains twice as much
    wood, provided it is of the same width and depth. In the previous two figures,
    for example, the distance between 0 and 0.2 billion is the same as the distance
    between 0.2 and 0.4 billion. The "data distance" is also the same. On a normal
    scale, and in this example, every tick corresponds to an increase of a certain
    amount (0.2 billion in this case). On a logarithmic scale, every additional tick
    corresponds to a multiple of the previous one.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的刻度是直观且易于理解的。就像物理物体一样，一块木板的长度是另一块的两倍，它包含的木材也是两倍，前提是它们的宽度和深度相同。例如，在前面的两张图中，0和0.2亿之间的距离与0.2和0.4亿之间的距离是相同的。这个“数据距离”也是相同的。在正常刻度下，在这个例子中，每个刻度对应的是一定量的增加（在此例中是0.2亿）。而在对数刻度下，每增加一个刻度，就意味着前一个刻度的倍数。
- en: 'For example, the numbers 10, 20, 30, and 40 form a typical sequence that you
    might see on a normal scale. If the scale was logarithmic, we don''t add 10; we
    would `log_x=True`, we get the updated chart in *Figure 6.19*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，数字10、20、30和40形成了一个典型的序列，这是你在正常刻度上可能看到的。如果刻度是对数刻度，我们不会再加10，而是使用`log_x=True`，我们会得到更新后的图表，见*图
    6.19*：
- en: '![Figure 6.19 – Using a logarithmic scale](img/B16780_06_19.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.19 – 使用对数刻度](img/B16780_06_19.jpg)'
- en: Figure 6.19 – Using a logarithmic scale
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19 – 使用对数刻度
- en: Our chart now looks quite different, but it is still actually the same chart.
    Note that we have changed the `opacity` to `0.25`, because `0.1` was difficult
    to see, and because we now have the markers a lot more dispersed than previously.
    We now have a much more nuanced view of how the population is distributed. We
    can see that the most opaque part is around the ten million mark. Compared to
    1.4 billion, this is pretty much zero, which is what the previous chart told us,
    but now we have a better view.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的图表看起来有了很大不同，但实际上它仍然是相同的图表。请注意，我们已将`opacity`值改为`0.25`，因为`0.1`太难看清，而且由于标记现在比之前更分散，我们有了一个更加细致的视图，了解人口是如何分布的。我们可以看到，最不透明的部分是在一千万附近。与14亿相比，这几乎为零，这也是之前图表告诉我们的内容，但现在我们有了更好的视角。
- en: Note that the major ticks are each 10 times larger than the previous one (**10k**,
    **100k**, **1M**, **10M**, **100M**, and **1B**), or for every major tick we are
    adding a zero. At the same time, we can see minor ticks, **2** and **5**, meaning
    that these positions represent twice and five times, respectively, the value of
    the previous major tick.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，主要刻度每个都比前一个大10倍（**10k**、**100k**、**1M**、**10M**、**100M**和**1B**），或者每增加一个主要刻度就加一个零。同时，我们可以看到次要刻度，**2**和**5**，意味着这些位置分别表示前一个主要刻度值的两倍和五倍。
- en: Let's explore another option that we might consider in such situations. We will
    not use any opacity this time, but we will introduce a lot of space to our markers
    by changing the symbol that we use. Setting symbols can be managed exactly like
    setting discrete colors. `symbol_sequence` is the parameter responsible for that,
    it will cycle through the options that we provide, and then assign one for each
    unique discrete value in our column. We give it a list containing one value, so
    all markers will have the same symbol.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索另一种可能在这种情况下考虑的选项。这次我们不使用任何透明度，但我们通过更改使用的符号给标记引入了大量空间。设置符号的方式与设置离散颜色一样，可以通过`symbol_sequence`参数来管理，它将循环遍历我们提供的选项，并为列中的每个唯一离散值分配一个符号。我们为其提供一个包含单一值的列表，因此所有标记将使用相同的符号。
- en: 'We now remove the `opacity` argument and replace it with `symbol_sequence=[''circle_open'']`
    to get the new chart in *Figure 6.20*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们移除`opacity`参数，并将其替换为`symbol_sequence=['circle_open']`，得到如*图 6.20*所示的新图表：
- en: '![Figure 6.20 – Modifying the symbols of markers](img/B16780_06_20.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.20 – 修改标记的符号](img/B16780_06_20.jpg)'
- en: Figure 6.20 – Modifying the symbols of markers
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20 – 修改标记的符号
- en: This might be even better, as we are not sacrificing any visibility by changing
    the opacity. We achieved our objective of seeing where the markers are clustered,
    because it takes a lot of open circles to fully cover an area. The logarithmic
    scale spreads the markers horizontally, so it is easier to see how they are distributed.
    The tick labels clearly indicate the values, but we might need to make it very
    clear and explicit if our audience is not familiar with this kind of scale.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能更好，因为我们通过更改透明度并没有牺牲任何可见性。我们达到了查看标记集中的位置的目的，因为需要很多开放的圆圈才能完全覆盖一个区域。对数坐标轴使标记在水平方向上分布，这样就更容易看出它们的分布情况。刻度标签清楚地显示了数值，但如果我们的受众不熟悉这种尺度，我们可能需要使其非常明确和直观。
- en: We can imagine providing users with all the options that we just tried. We can
    think of having a component that allows users to modify the opacity, another component
    to toggle between normal and logarithmic scales, and maybe another to change the
    symbols. Ideally, we shouldn't make it that difficult for users to read our charts.
    It's best to do the work ourselves and provide sensible defaults after having
    explored the data. Based on what we have explored so far, let's consider what
    those defaults might be.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象为用户提供我们刚刚尝试的所有选项。我们可以考虑设置一个组件，允许用户修改透明度，另一个组件切换正常和对数坐标轴，或许还有一个组件用于更改符号。理想情况下，我们不应该让用户在阅读图表时感到困难。最好是我们自己做这项工作，探索数据后提供合理的默认值。根据我们目前所做的探索，我们来考虑这些默认值可能是什么。
- en: We know that this chart plots countries, and that they cannot be more than 200\.
    This means we can set a default opacity level that is appropriate for that number
    of markers. Having thousands of markers might require a much lower `opacity` level,
    such as `0.02`, for example. Open circles seem to have worked well for us by introducing
    space, so we might also choose that as the default symbol, and forget about opacity
    altogether. The same applies to the `size` parameter. Knowing that we are plotting
    population figures, and that it is most likely always going to contain outliers,
    as in this case, we might keep the logarithmic scale as the default.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这个图表绘制的是各个国家的数据，并且它们的数量不能超过200个。这意味着我们可以为这些标记设置一个适合的默认透明度级别。标记数量达到数千时，可能需要更低的`opacity`级别，比如`0.02`。空心圆似乎在引入空间方面对我们有很好的效果，所以我们也可以选择空心圆作为默认符号，完全忽略透明度问题。`size`参数也是如此。我们知道我们绘制的是人口数据，而且它很可能总是包含离群值，就像这个例子一样，因此我们可能会保持对数刻度作为默认值。
- en: A more general type of interactive chart might allow users to modify the indicators
    that they want to explore. In this case, we might give them those options. However,
    with more freedom and generality, our users will have to handle more of the data
    handling details themselves.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更通用的互动图表可能允许用户修改他们想要探索的指标。在这种情况下，我们可能会为他们提供这些选项。然而，随着自由度和通用性的增加，用户将需要自己处理更多的数据处理细节。
- en: We have established a good understanding of our metrics and seen many examples
    of many countries. This exploration is crucial for building a dashboard with sensible
    defaults, as we just saw. Let's now explore the new interactive components of
    this chapter – the `Slider` components.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对我们的指标有了很好的理解，并且看到了许多国家的示例。正如我们刚刚看到的，这个探索过程对于构建具有合理默认设置的仪表盘至关重要。现在让我们来探讨本章的新互动组件——`Slider`组件。
- en: Introducing sliders and range sliders
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入滑块和区间滑块
- en: 'The `Slider` and `RangeSlider` components are basically circles that users
    can drag horizontally or vertically to set or change a certain value. They are
    typically used for setting continuous values, as their appearance and dragging
    functionality are a natural fit for that. But this is not a requirement as we
    can use them for categorical/discrete values as well. We have seen that we have
    three levels of our `perc_pov_` metrics, and we know that we have all the years
    in our dataset to choose from. We now want to create two sliders. One allows users
    to select the level of poverty that they want to analyze, and the other allows
    them to select the year. Each combination of selections will create a different
    subset, and result in a different chart. *Figure 6.21* shows the top part of the
    end result that we will be working toward:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Slider`和`RangeSlider`组件基本上是用户可以水平或垂直拖动的圆形控件，用于设置或更改某个值。它们通常用于设置连续值，因为它们的外观和拖动功能非常适合这一用途。但这并不是强制要求，因为我们也可以将它们用于分类/离散值。我们已经看到`perc_pov_`指标有三个级别，并且我们知道可以从数据集中选择所有年份。现在，我们希望创建两个滑块。一个让用户选择他们想要分析的贫困水平，另一个让他们选择年份。每种选择组合将创建一个不同的子集，并生成不同的图表。*图
    6.21*显示了我们将要实现的最终结果的上部分：'
- en: '![Figure 6.21 – Two sliders controlling a chart](img/B16780_06_21.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.21 – 两个滑块控制图表](img/B16780_06_21.jpg)'
- en: Figure 6.21 – Two sliders controlling a chart
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21 – 两个滑块控制图表
- en: As you can see, the new functionality requires three main components – two `Slider`
    components and one `Graph` component. Of course, we have a few others to control
    the layout, as well as labels, but the focus is mainly going to be on how to create
    and incorporate this new functionality.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，新的功能需要三个主要组件——两个`Slider`组件和一个`Graph`组件。当然，我们还有其他一些组件来控制布局，以及标签，但重点主要是如何创建和集成这个新功能。
- en: Important note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `RangeSlider` component is almost identical to the `Slider` component. The
    main difference is that it contains more than one handle, so users can modify
    the maximum and minimum points within which they want to filter data. For now,
    we will focus on normal `Slider` components, and we will tackle the `RangeSlider`
    component in later chapters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`RangeSlider`组件几乎与`Slider`组件相同。主要的区别在于它包含多个滑块手柄，用户可以在其中调整他们希望筛选数据的最大值和最小值。现在，我们将重点关注普通的`Slider`组件，而`RangeSlider`组件将在后续章节中讨论。'
- en: As always, we will create this as a standalone app in JupyterLab, and once it
    is working fine, we will add it to the app. Let's start first by getting to know
    the `Slider` component, how it works, and then create the layout of our app.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将把这个创建为 JupyterLab 中的独立应用程序，一旦它正常工作，我们就将其添加到应用中。首先，让我们了解 `Slider` 组件，了解它是如何工作的，然后创建我们的应用布局。
- en: 'You can create a minimal app and, within the app''s layout, create the `Slider`
    component, just like you do with other components, by calling `dcc.Slider()`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个最小化的应用程序，并在应用的布局中创建 `Slider` 组件，就像你用其他组件一样，通过调用 `dcc.Slider()`：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will create a simple app with a single component, as you can see in *Figure
    6.22*:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含单个组件的简单应用，正如你在*图 6.22*中看到的那样：
- en: '![Figure 6.22 – A bare-bones slider component](img/B16780_06_22.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.22 – 一个简单的滑块组件](img/B16780_06_22.jpg)'
- en: Figure 6.22 – A bare-bones slider component
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22 – 一个简单的滑块组件
- en: 'This is visually easy to use, and it''s clear that users can slide the circle
    horizontally. There are no guides however, and users don''t know what values they
    are modifying, so let''s fix that. We will start by creating our first slider,
    containing the three poverty levels that we are analyzing. Let''s take a look
    at the parameters that we are going to use for this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这样视觉上很容易使用，用户可以清楚地看到他们可以水平滑动圆圈。然而，目前没有任何指导，用户也不知道他们在修改什么值，因此我们需要修复这一点。我们将从创建我们的第一个滑块开始，包含我们正在分析的三种贫困水平。让我们看看我们将要使用的参数：
- en: '`min`: As the name suggests, this is the minimum value of the slider.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min`：顾名思义，这是滑块的最小值。'
- en: '`max`: This also sets the upper limit for the values.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max`：这也设置了值的上限。'
- en: '`step`: As we go (slide) from `min` to `max`, what should the increment size
    be? By default, it is set to `1`, but you can set it to a higher or lower value.
    For example, if you wanted users to manage opacity, you can set `min=0`, `max=1`,
    and `step=0.01`. This would give users 100 options to choose from.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`step`：当我们从 `min` 滑动到 `max` 时，增量的大小应该是多少？默认情况下，它设置为 `1`，但你可以将其设置为更高或更低的值。例如，如果你希望用户调整透明度，你可以设置
    `min=0`、`max=1` 和 `step=0.01`。这将为用户提供 100 个选项可供选择。'
- en: '`dots`: Should the slider display dots or should it be a simple line? In our
    case, we want users to choose between three distinct values, so it makes sense
    to set this option to `True`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dots`：滑块是否应显示圆点，还是应该是简单的线条？在我们的例子中，我们希望用户从三个不同的值中选择，所以将此选项设置为 `True` 是有意义的。'
- en: '`included`: Note that the slider in *Figure 6.22* is light blue to the left
    of the handle, and gray to its right. As you slide, the blue part expands/contracts
    with the handle, which is the default behavior. In our case, we are giving the
    user three distinct options, so we want to remove this to emphasize this fact,
    so we set its value to `False`.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`included`：请注意，*图 6.22* 中滑块左侧的蓝色部分和右侧的灰色部分。在滑动过程中，蓝色部分会随着滑块的滑动而扩展/收缩，这是默认行为。在我们的例子中，我们提供了三个不同的选项，因此我们希望移除这种行为来强调这一点，因此我们将其值设置为
    `False`。'
- en: '`value`: This is the default value that the slider should take.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：这是滑块应取的默认值。'
- en: 'Here is an example of a `Slider` component that ranges from `0` to `10`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `Slider` 组件的示例，范围从 `0` 到 `10`：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This produces the new slider in *Figure 6.23*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了*图 6.23*中的新滑块：
- en: '![Figure 6.23 – A slider component with custom options](img/B16780_06_23.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.23 – 带有自定义选项的滑块组件](img/B16780_06_23.jpg)'
- en: Figure 6.23 – A slider component with custom options
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23 – 带有自定义选项的滑块组件
- en: The dots now guide users on where they can select, and it hints that the options
    are distinct from one another, especially that we set `included=False`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，圆点引导用户选择位置，并且提示选项彼此是不同的，特别是我们设置了 `included=False`。
- en: 'Another crucial parameter that `Slider` takes is the `marks` parameter. We
    need to show users what each dot corresponds to. In some cases, we might not have
    enough space to display all values, in which case we skip some of the values.
    We will do this in our years slider, but first let''s create the poverty indicator
    slider. We first do it without the `marks` parameter, and then add it after that:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Slider` 组件的另一个重要参数是 `marks` 参数。我们需要向用户展示每个圆点对应的值。在某些情况下，如果没有足够的空间显示所有值，我们会跳过一些值。在我们的年份滑块中会有这种情况，但首先让我们创建贫困指标滑块。我们首先不使用
    `marks` 参数创建它，然后再添加该参数：'
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For `id`, as with other variables, we followed the rule of starting with `perc_pov_`
    to be consistent with other related objects in the app. The values that the callback
    function will receive from this component are going to be `0`, `1`, and `2`, and
    this is based on the `min`, `max`, and `step` arguments we gave. Now, those values
    don't mean anything in our situation, because we actually want the full text of
    the name of the indicator. We can simply handle this by taking the value of the
    slider and using it as the index for the `perc_pov_cols` list that we created.
    In our callback function, we will use this integer value to extract the respective
    indicator. We will see this later when we construct our callback function. Let's
    now create the marks for our slider.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`id`，与其他变量一样，我们遵循了以`perc_pov_`开头的规则，以便与应用中的其他相关对象保持一致。回调函数将从这个组件接收到的值将是`0`、`1`和`2`，这是基于我们给出的`min`、`max`和`step`参数的。现在，这些值在我们的情况中没有实际意义，因为我们实际上希望得到指标名称的完整文本。我们可以通过获取滑块的值并将其用作我们创建的`perc_pov_cols`列表的索引来简化处理。在回调函数中，我们将使用这个整数值来提取相应的指标。稍后我们会在构建回调函数时看到这一点。现在，让我们来创建滑块的刻度标记。
- en: Customizing the marks and values of sliders
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义滑块的刻度标记和值
- en: 'The simplest way to create these is by using a dictionary: `{0: ''$1.9'', 1:
    ''$3.2'', 2: ''$5.5''}`. They keys will be used as the `value` attribute, and
    the values of the dictionary are what the user will see for each poverty level.
    This will suffice for our case, and we can use it as such.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '创建这些刻度标记的最简单方法是使用字典：`{0: ''$1.9'', 1: ''$3.2'', 2: ''$5.5''}`。字典的键将作为`value`属性使用，而字典的值将是用户在每个贫困水平上看到的内容。对于我们的情况，这就足够了，我们可以按此使用。'
- en: We optionally have the chance to customize the style of our labels, which can
    take any CSS attribute as a dictionary. If you look at *Figure 6.21*, you can
    see that the marks (numbers) of the two sliders have a very light color, and they
    might give the impression that they belong to the same slider. We can improve
    this by setting their colors to a dark color. We can also set a bold font for
    the indicator slider. This will help distinguish them from the years, and it will
    also emphasize their uniqueness. Years are easy to immediately grasp, but users
    are most likely not familiar with the levels of poverty tracked in the dataset.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以选择性地自定义标签的样式，这可以是任何CSS属性的字典。如果你查看*图6.21*，你会看到两个滑块的刻度（数字）颜色非常浅，可能会给人一种它们属于同一个滑块的印象。我们可以通过将它们的颜色设置为深色来改进这一点。我们还可以为指标滑块设置粗体字体。这有助于将它们与年份区分开来，并且也能突出它们的独特性。年份是容易立即理解的，但用户很可能不熟悉数据集中追踪的贫困水平。
- en: 'We want to get a color that is consistent with our charts. And since we will
    be using the cividis color scale, it''s a good opportunity to get to know how
    we can extract its colors. The `px.colors.sequential` module contains, among other
    things, lists of the colors of the sequential color scales. We can get cividis
    by running the following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望获得与我们的图表一致的颜色。由于我们将使用cividis色标，因此这是一个了解如何提取其颜色的好机会。`px.colors.sequential`模块包含了顺序色标的颜色列表，其中就包括了cividis。我们可以通过运行以下命令来获取cividis：
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The list we receive contains the 10 colors that are actually used to construct
    this scale. Recall that we tried this manually with 2 and 3 colors. It's also
    interesting to know that you can get the reversed version of a scale by appending
    `_r` to its name, for example, `px.colors.sequential.Cividis_r`. This would give
    us the same scale, but the yellow would correspond to the lower values in this
    case.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到的列表包含了实际上用于构建该色标的10种颜色。回想一下，我们之前尝试过手动使用2个和3个颜色。还值得注意的是，通过在色标名称后面添加`_r`，你可以获得色标的反转版本，例如，`px.colors.sequential.Cividis_r`。这将给我们相同的色标，但在这种情况下，黄色将对应较低的值。
- en: 'Now, the color that we want to use for the labels of the marks is going to
    be the darkest one in cividis, which we can easily extract and assign to a variable
    as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望为刻度标记的标签使用的颜色将是cividis色标中的最深色，我们可以很容易地提取并将其赋值给一个变量，如下所示：
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using this, we can now set our `marks` argument as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法后，我们现在可以按照以下方式设置`marks`参数：
- en: '[PRE29]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'What we did was basically extend the dictionary, where, instead of strings
    as values, we added dictionaries in the following form:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的基本上是扩展字典，其中，值不再是字符串，而是以以下形式出现的字典：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Important note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In general, CSS attributes such as `font-size` and `font-weight` are hyphen-separated,
    and written in lowercase. In Dash, you can use the same attributes, but you have
    to remove the hyphens, and use camelCase (`fontSize` and `fontWeight`), as you
    can see in the previous code snippet.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，CSS属性如`font-size`和`font-weight`是用连字符分隔的，并且是小写字母书写的。而在Dash中，您可以使用相同的属性，但必须去掉连字符，改用驼峰式命名法（如`fontSize`和`fontWeight`），正如前面的代码片段所示。
- en: 'Similar to what we just did, let''s now create the other slider with similar
    customizations. First, and in order to isolate our subset, we can create a special
    DataFrame for these variables:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于刚才所做的，现在让我们创建另一个具有类似自定义的滑块。首先，为了隔离我们的子集，我们可以为这些变量创建一个特殊的DataFrame：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The important thing is that we removed any missing values from `perc_pov_cols`,
    and we also created a sorted list of unique years, `perc_pov_years`, using `sorted`
    and `set`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是我们从`perc_pov_cols`中删除了任何缺失值，并且我们还通过使用`sorted`和`set`创建了一个排序后的唯一年份列表`perc_pov_years`。
- en: 'The following code creates our new slider for the years:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了我们的新滑块，用于选择年份：
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is pretty much the same as we did for the indicators. We set the default
    to 2018, which is the latest year for which we have data. If this was a dynamically
    updated app, we can also set this value to the maximum of `perc_pov_years`. Note
    that we set the marks to show only one in five years. Otherwise, the slider would
    be very difficult to use. With this, we can see the slight difference in fonts
    and colors in *Figure 6.24*:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们为指标所做的几乎相同。我们将默认值设置为2018年，这是我们拥有数据的最新年份。如果这是一个动态更新的应用程序，我们也可以将此值设置为`perc_pov_years`中的最大年份。请注意，我们将标记设置为每五年显示一个。如果不这样做，滑块将非常难以使用。通过这样设置，我们可以看到在*图
    6.24*中字体和颜色的细微差别：
- en: '![Figure 6.24 – Sliders with updated colors](img/B16780_06_24.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.24 – 更新颜色的滑块](img/B16780_06_24.jpg)'
- en: Figure 6.24 – Sliders with updated colors
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.24 – 更新颜色的滑块
- en: 'The final part of our layout is going to be the `Graph` component:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 布局的最后部分将是`Graph`组件：
- en: '[PRE33]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As I mentioned before, we also have `Label` components, as well as `Col` and
    `Row` components to better manage the layout, but they weren't discussed, as we
    have already created several examples using them.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所提到的，我们还拥有`Label`组件，以及`Col`和`Row`组件，用于更好地管理布局，但这些组件未被讨论，因为我们已经创建了多个使用它们的示例。
- en: 'We are now ready to create our callback function to link the three elements
    that we just created:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好创建回调函数，将我们刚才创建的三个元素链接起来：
- en: 'We first create the decorator of the function. This is straightforward, as
    we did with previous examples. The slight difference is that we have two inputs
    in this case. In the definition of the function, the order of the parameters will
    correspond to the order of the `Input` elements, so we will name them accordingly:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建函数的装饰器。这个过程与之前的示例一样简单。唯一的不同之处在于，这次我们有两个输入参数。在函数的定义中，参数的顺序将对应于`Input`元素的顺序，因此我们将根据顺序命名它们：
- en: '[PRE34]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the next part, we create the function''s signature, as well as the first
    few lines. The parameters are named `year` and `indicator`. We now use the indicator
    value (which is an integer) to get the corresponding element from `perc_pov_cols`.
    We then create the variable `df`, which filters `perc_pov_df` to only have values
    from `year`. Then, define we `dropna` and `sort_values`. There was a year that
    didn''t have any data, but had to be included in the values of the slider, so
    we need to handle the case when/if users select it. This is done using the simple
    check `if df.empty`, as you can see here:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们创建函数的签名，并写出前几行代码。参数名为`year`和`indicator`。我们现在使用`indicator`值（一个整数）来从`perc_pov_cols`中获取相应的元素。然后，我们创建变量`df`，它会过滤`perc_pov_df`，只保留`year`年份的数据。接着，我们定义`dropna`和`sort_values`。有一个年份没有任何数据，但它必须出现在滑块的值中，因此我们需要处理用户选择该年份的情况。我们通过简单的检查`if
    df.empty`来完成，如下所示：
- en: '[PRE35]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that we have our DataFrame ready, we can create the `Figure` and return
    it. Most of the code should now be familiar. The `hover_name` parameter is used
    to add a title to the popup when users hover over markers. Setting it to `Country
    Name` would cause the title to take the respective country''s name and display
    it in bold. We also utilized the same dynamic height trick that we used in the
    last chapter, where we set a fixed height, and added 20 pixels for each country.
    The `ticksuffix` option we added at the end should be self-explanatory, to make
    it clear that these are percentages:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了数据框（DataFrame），可以创建`Figure`并返回。大部分代码现在应该都很熟悉了。`hover_name` 参数用于在用户悬停在标记上时显示弹出框标题。将其设置为`Country
    Name`会使标题显示相应国家的名称并加粗。我们还使用了上一章中使用过的动态高度技巧，在这里我们设置了固定高度，并为每个国家增加了20像素。我们在最后添加的`ticksuffix`选项应该是显而易见的，用来表明这些值是百分比：
- en: '[PRE36]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Adding the layout elements and callback to our app, we finally get the additional
    functionality in the form of two sliders that can generate more than 130 charts
    through their combinations. *Figure 6.25* shows the final result:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的应用添加布局元素和回调后，我们最终获得了额外的功能，通过这两个滑块的组合可以生成超过130个图表。*图 6.25* 显示了最终结果：
- en: '![Figure 6.25 – Two sliders and a scatter plot – final result](img/B16780_06_25.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.25 – 两个滑块和一个散点图 – 最终结果](img/B16780_06_25.jpg)'
- en: Figure 6.25 – Two sliders and a scatter plot – final result
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.25 – 两个滑块和一个散点图 – 最终结果
- en: Congratulations on yet another addition to your app! This time, we created our
    first multiple input callback, which enriched the options that users can generate,
    without being complicated or overwhelming.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你又为你的应用增加了新功能！这一次，我们创建了第一个多输入回调，它丰富了用户可以生成的选项，而不会让人感到复杂或压倒性。
- en: From a functionality perspective, there is nothing really different between
    dropdowns and sliders. We could have implemented the same thing with dropdowns,
    and it would have worked fine. The advantage of dropdowns is that they are extremely
    efficient in terms of space utilization. A small rectangle can contain tens or
    even hundreds of hidden options that users can search. Those options can be very
    long strings that may be impossible to fit next to each other, on a slider, for
    example.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能角度来看，下拉框和滑块之间并没有本质上的区别。我们本来可以使用下拉框来实现同样的功能，并且它也会正常工作。下拉框的优势在于它们在空间利用方面极为高效。一个小矩形就可以容纳数十个甚至数百个隐藏选项，用户可以进行搜索。这些选项可以是很长的字符串，可能无法并排显示在例如滑块旁边。
- en: On the other hand, sliders give a better perspective. They implicitly contain
    metadata about the options. You can immediately see the minimum and maximum points,
    and how widely they are spread. When you select an option, you can easily tell
    how extreme your choice was relative to the other options that are available.
    In the case of the poverty level slider, users can see all available options immediately.
    And finally, sliders are more similar to how we interact with physical objects,
    so playing with them might be more engaging than other interactive components.
    So, space restrictions, the types of variables that we are analyzing, and how
    we want to display them are some considerations that affect our choice of interactive
    components that we decide to utilize.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，滑块提供了更好的视角。它们隐式地包含了关于选项的元数据。你可以立即看到最小值和最大值，以及它们的分布范围。当你选择一个选项时，你可以很容易地判断你的选择相对于其他可用选项的极端程度。在贫困水平滑块的情况下，用户可以立即看到所有可选项。最后，滑块更类似于我们与物理物品的互动方式，所以使用它们可能比其他互动组件更具吸引力。因此，空间限制、我们分析的变量类型以及我们希望展示的方式是影响我们选择使用哪些互动组件的因素。
- en: You probably noticed that we are focusing less on how to put things together
    in the app, and that's intentional. We have already covered these topics several
    times, and it is designed to also encourage you to do them yourself and experiment
    with other options. You can always refer back to the code repository to check
    your work and for the minor details.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到我们在如何将组件组合到应用中的讨论上减少了，这其实是有意为之。我们已经多次讨论过这些话题，设计上也希望鼓励你亲自去实践并尝试其他选项。你随时可以回到代码库，检查你的工作以及细节部分。
- en: Let's now recap what we have covered in this chapter.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回顾一下本章所涵盖的内容。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We introduced scatter plots and saw how to create them, both using the `graph_objects`
    module, and using Plotly Express. We saw how to create multiple traces and tried
    different approaches for that. We then discussed color mapping and setting and
    explored how different the process is for continuous and discrete (categorical)
    variables. We saw different scales – sequential, diverging, and qualitative. We
    also saw how we can set our own colors, sequences, and scales. We also tackled
    some issues that arise when we have outliers, and when we have over-plotting.
    We experimented with opacity, changing symbols, and marker sizes, as well as using
    logarithmic scales to make our charts more readable. We also introduced sliders
    and learned how they work, and created two sliders that work together to generate
    charts expressing three values (as opposed to two values previously). We then
    created a callback function that managed those interactions and integrated it
    into our app.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了散点图，并展示了如何使用`graph_objects`模块和Plotly Express来创建它们。我们学习了如何创建多个轨迹，并尝试了不同的方法。接着，我们讨论了颜色映射和设置，并探讨了连续变量和离散（分类）变量之间的处理差异。我们看到了不同的刻度——顺序型、发散型和定性型。我们还展示了如何设置自定义颜色、序列和刻度。我们还解决了一些问题，比如异常值和过度绘图。我们尝试了不透明度、改变符号和标记大小，并使用对数刻度来使我们的图表更易读。我们还介绍了滑块并学习了它们的工作原理，创建了两个可以协同工作、生成表达三个值的图表的滑块（而之前只有两个值）。然后，我们创建了一个回调函数来管理这些交互，并将其集成到我们的应用程序中。
- en: By now, and with all the examples and techniques covered, we are getting closer
    to the point of creating dashboards in the same way as we create slideshows and
    presentations. Once we master the layout elements, it's very easy to customize
    any size and position we want. And now that we are exploring different chart types
    and data visualization techniques, it will become easier to manage things and
    modify them the way we want.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，通过所有示例和技巧的讲解，我们已经接近于以创建幻灯片和演示文稿的方式来创建仪表板。一旦掌握了布局元素，定制任何我们想要的大小和位置就变得非常简单。现在，随着我们探索不同的图表类型和数据可视化技巧，管理和修改这些内容将变得更加容易。
- en: All the charts we have explored so far used regular geometric shapes, including
    circles, lines, and rectangles. In the next chapter, we will explore irregular
    shapes, and how to visualize them, in the form of maps. Maps are very engaging,
    and easily recognizable, yet not so straightforward to visualize, like simple
    regular shapes. This will be explored next.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所探索的所有图表都使用了常规的几何形状，包括圆形、线条和矩形。在下一章中，我们将探索不规则形状以及如何以地图的形式进行可视化。地图非常吸引人且容易识别，但不像简单的常规形状那样直接可视化。接下来，我们将探讨这一点。
