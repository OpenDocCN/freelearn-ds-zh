- en: Chapter 11. Web Analysis with GeoDjango
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章。使用 GeoDjango 进行网络分析
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up a GeoDjango web application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 GeoDjango 网络应用程序
- en: Creating an indoor web routing service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建室内网络路由服务
- en: Visualizing an indoor routing service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化室内路由服务
- en: Creating an indoor route-type service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建室内路线类型服务
- en: Creating an indoor route from room to room
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从房间到房间的室内路线创建
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Our final chapter is all about extending our analysis into a web application
    using the **Django** web framework. One of the standard Django contributed packages
    is known as **GeoDjango** and is found in the `django/contrib/gis` package. This
    is a feature-packed GIS toolset for geospatial web application development. The
    spatial libraries used here depend on the spatial database backend that you choose.
    For PostgreSQL the library requirements include GEOS, PROJ.4, and PostGIS.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一章完全关于将我们的分析扩展到使用 **Django** 网络框架的 Web 应用程序。一个标准的 Django 贡献包被称为 **GeoDjango**，位于
    `django/contrib/gis` 包中。这是一个功能丰富的 GIS 工具集，用于地理空间 Web 应用程序开发。这里使用的空间库取决于您选择的空间数据库后端。对于
    PostgreSQL，库需求包括 GEOS、PROJ.4 和 PostGIS。
- en: Django is known for its good documentation and the `gis contrib` package installation
    is no exception, having its own set of instructions for you to follow at [https://docs.djangoproject.com/en/dev/ref/contrib/gis/](https://docs.djangoproject.com/en/dev/ref/contrib/gis/).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Django 以其良好的文档而闻名，`gis contrib` 包的安装也不例外，它有一套您需要遵循的说明，网址为 [https://docs.djangoproject.com/en/dev/ref/contrib/gis/](https://docs.djangoproject.com/en/dev/ref/contrib/gis/)。
- en: Since GeoDjango is part of the standard Django installation, you will see that
    your first step is to install the Django framework. For any reference on installing
    GeoDjango, PostgreSQL, and PostGIS, take a look at [Chapter 1](ch01.html "Chapter 1. Setting
    Up Your Geospatial Python Environment"), *Setting Up Your Geospatial Python Environment*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 GeoDjango 是标准 Django 安装的一部分，您将看到第一步是安装 Django 框架。有关安装 GeoDjango、PostgreSQL
    和 PostGIS 的任何参考，请参阅 [第 1 章](ch01.html "第 1 章。设置您的地理空间 Python 环境")，*设置您的地理空间 Python
    环境*。
- en: Setting up a GeoDjango web application
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 GeoDjango 网络应用程序
- en: We need to get some basic Django groundwork done and this will be a very high-level
    fly over at setting up the required basics to start a Django web application.
    Check out the official Django tutorials for further information at [https://docs.djangoproject.com/en/dev/intro/tutorial01/](https://docs.djangoproject.com/en/dev/intro/tutorial01/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要完成一些基本的 Django 基础工作，这将是一个对设置所需基本以启动 Django 网络应用程序的非常高级的概述。有关更多信息，请查看官方 Django
    教程，网址为 [https://docs.djangoproject.com/en/dev/intro/tutorial01/](https://docs.djangoproject.com/en/dev/intro/tutorial01/)。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are not familiar with Django or GeoDjango, I would highly recommend that
    you read through and complete the online tutorials, starting with Django at [https://docs.djangoproject.com/en/dev/](https://docs.djangoproject.com/en/dev/)
    followed by the GeoDjango tutorial at [https://docs.djangoproject.com/en/dev/ref/contrib/gis/tutorial/](https://docs.djangoproject.com/en/dev/ref/contrib/gis/tutorial/).
    For this chapter, it is assumed that you are familiar with Django, have completed
    the entire online Django tutorial, and are, therefore, familiar with Django concepts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉 Django 或 GeoDjango，我强烈建议您阅读并完成在线教程，从 Django 开始，网址为 [https://docs.djangoproject.com/en/dev/](https://docs.djangoproject.com/en/dev/)，然后是
    GeoDjango 教程，网址为 [https://docs.djangoproject.com/en/dev/ref/contrib/gis/tutorial/](https://docs.djangoproject.com/en/dev/ref/contrib/gis/tutorial/)。对于本章，假设您熟悉
    Django，已完成整个在线 Django 教程，因此熟悉 Django 概念。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We are going to build a routing web service using the *Django REST framework*
    ([http://www.django-rest-framework.org/](http://www.django-rest-framework.org/)).
    All that we need to implement is a basic web service that you can install with
    the help of `pip`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 *Django REST 框架* ([http://www.django-rest-framework.org/](http://www.django-rest-framework.org/))
    构建一个路由网络服务。我们需要实现的是一个基本的网络服务，您可以使用 `pip` 来安装：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will install version 3.1.3, the latest version. If you want to install
    the newest version, simply enter the following command but, beware, it might not
    work with this example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装版本 3.1.3，即最新版本。如果您想安装最新版本，只需输入以下命令，但请注意，它可能不适用于此示例：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s now create a Django project using the `django-admin` tool as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 `django-admin` 工具创建一个 Django 项目，如下所示：
- en: 'From the command line, enter the `/ch11/code` directory and execute this command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，进入 `/ch11/code` 目录并执行此命令：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now you will have a `/ch11/code/web_analysis/web_analysis` directory and inside
    it, you'll find all the standard basic Django components.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将有一个 `/ch11/code/web_analysis/web_analysis` 目录，并在其中，您将找到所有标准的基本 Django 组件。
- en: 'To create our web service, we are going to place all the services into a Django
    App called `api`. This app will store all our services. Creating this `api` application
    is as easy as typing this code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建我们的网络服务，我们将把所有服务放置在一个名为 `api` 的 Django 应用程序中。此应用程序将存储所有服务。创建此 `api` 应用程序就像输入以下代码一样简单：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Change into the newly created `web_analysis` directory:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 切换到新创建的 `web_analysis` 目录：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now create your new application called "api".
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在创建一个名为 "api" 的新应用程序。
- en: 'This creates a new `/ch11/code/web_analysis/api` folder and inside it you will
    find the default installed Django app files. Next, we need to tell Django about
    the Django REST Framework, GeoDjango gis app, and our new `api` application; we
    do this in our `/ch11/code/web_analysis/web_analysis/settings.py` file. Let''s
    add the lines `''django.contrib.gis''`, `''rest_framework''`, and `''api''` to
    our `INSTALLED_APPS` variable as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在 `/ch11/code/web_analysis/api` 下创建一个新的文件夹，并在其中您将找到默认安装的 Django 应用程序文件。接下来，我们需要告诉
    Django 关于 Django REST 框架、GeoDjango gis 应用程序以及我们的新 `api` 应用程序；我们在 `/ch11/code/web_analysis/web_analysis/settings.py`
    文件中这样做。让我们将 `'django.contrib.gis'`、`'rest_framework'` 和 `'api'` 行添加到我们的 `INSTALLED_APPS`
    变量中，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To enable the GeoDjango spatial models and spatial capabilities, `''django.contrib.gis''`
    will allow us to access the rich geospatial framework. We have it commented out
    at this point since we are not going to use it until later, but feel free to uncomment
    it as this will do no harm. This spatial framework requires a spatial database
    and we will use PostgreSQL with PostGIS as our backend. Let''s go ahead and change
    the database connection now in our `settings.py` as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用 GeoDjango 空间模型和空间功能，`'django.contrib.gis'` 将允许我们访问丰富的地理空间框架。目前我们将其注释掉，因为我们不会在稍后使用它，但您可以随时取消注释，因为这不会造成任何伤害。此空间框架需要一个空间数据库，我们将使用带有
    PostGIS 的 PostgreSQL 作为我们的后端。现在让我们在 `settings.py` 中更改数据库连接，如下所示：
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The database here is referencing the same *PostgreSQL + PostGIS* database that
    we created earlier on in [Chapter 3](ch03.html "Chapter 3. Moving Spatial Data
    from One Format to Another"), *Moving Spatial Data from One Format to Another*.
    Visit the *Converting a Shapefile to a PostGIS table using ogr2ogr,* recipe in
    [Chapter 3](ch03.html "Chapter 3. Moving Spatial Data from One Format to Another"),
    *Moving Spatial Data from One Format to Another* where we created the `py_geoan_cb`
    database, if you are going to skip ahead to this section.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此处数据库引用的是我们在[第3章](ch03.html "第3章。将空间数据从一种格式转换为另一种格式")中创建的相同的 *PostgreSQL + PostGIS*
    数据库，即 *将空间数据从一种格式转换为另一种格式*。如果您要跳过到这一部分，请访问[第3章](ch03.html "第3章。将空间数据从一种格式转换为另一种格式")中的
    *使用 ogr2ogr 将 Shapefile 转换为 PostGIS 表* 菜单，我们在那里创建了 `py_geoan_cb` 数据库。
- en: 'Our final `settings.py` configuration is set up to log errors and exceptions
    to a log file, catching errors if any occur. First up, we''ll create a new folder
    called `/web_analysis/logs` and add two new files called `debug.log` and `verbose.log`.
    We will write any errors that occur into these two files and log a request or
    simply print out an error to these files. So, go ahead and copy this code into
    the bottom of your `/web_analysis/web_analysis/settings.py` file as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最终的 `settings.py` 配置设置为将错误和异常记录到日志文件中，如果发生错误，将捕获错误。首先，我们将创建一个名为 `/web_analysis/logs`
    的新文件夹，并添加两个新文件，分别命名为 `debug.log` 和 `verbose.log`。我们将把发生的任何错误写入这两个文件，并记录请求或简单地打印错误到这些文件。因此，请将以下代码复制到
    `/web_analysis/web_analysis/settings.py` 文件的底部，如下所示：
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next up, let''s create a new database user and a separate PostgreSQL schema
    to store all our Django-related tables; otherwise, all the new Django tables will
    automatically be created in the PostgreSQL default schema public. Our new user
    is called `saturn` and can log in with the `secret` password. To create a new
    user, you can use the command-line tool that''s run as the `postgres` user:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个新的数据库用户和一个单独的 PostgreSQL 模式来存储所有我们的 Django 相关表；否则，所有新的 Django 表将自动创建在
    PostgreSQL 默认模式 public 中。我们的新用户名为 `saturn`，可以使用 `secret` 密码登录。要创建新用户，您可以使用作为 `postgres`
    用户运行的命令行工具：
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can also use the PGAdmin free tool. On Ubuntu, don't forget to change to
    the `postgres` user that will allow you to create a new user on your database.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还可以使用免费的 PGAdmin 工具。在 Ubuntu 上，别忘了切换到 `postgres` 用户，这将允许您在数据库上创建新用户。
- en: 'Now, let''s create a new schema called `django` that will store all our Django
    application tables. Use PGAdmin or the SQL command to do this as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个新的模式名为`django`，它将存储我们所有的Django应用程序表。使用PGAdmin或SQL命令来完成此操作，如下所示：
- en: '[PRE9]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With this new schema in place, we only need to assign the PostgreSQL `search_path`
    variable order to set the `django` schema as the first priority. To accomplish
    this, we need to use the SQL `ALTER ROLE` command as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个新模式，我们只需要将PostgreSQL `search_path`变量顺序设置为将`django`模式作为第一优先级。为了完成这个任务，我们需要使用以下SQL
    `ALTER ROLE`命令：
- en: '[PRE10]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This sets the `search_path` order defining `django` as the first schema, `geodata`
    as the second, and so forth. This order is for all database connections for the
    `saturn` user. When we create our new Django tables, all of them will now automatically
    be created inside the `django` schema.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这设置了`search_path`的顺序，将`django`作为第一个模式，`geodata`作为第二个，以此类推。这个顺序适用于`saturn`用户的所有数据库连接。当我们创建新的Django表时，它们现在将自动创建在`django`模式内。
- en: 'Let''s go ahead now and initialize our Django project and create all the tables
    as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们继续初始化我们的Django项目并创建所有表，如下所示：
- en: '[PRE11]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The built-in Django `manage.py` command calls the `migrate` function and performs
    the sync in one go. Next, let''s create a superuser for our application who can
    login and have full control of the entire web application. Then, follow the command-line
    instructions to enter the username, e-mail, and password as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内置的Django `manage.py`命令调用`migrate`函数并一次性执行同步。接下来，让我们为我们的应用程序创建一个超级用户，该用户可以登录并完全控制整个网络应用程序。然后，按照命令行说明输入用户名、电子邮件和密码，如下所示：
- en: '[PRE12]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With all these steps now completed, we are ready to actually get something
    done and build our online routing application. To test whether everything is working,
    run this command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在这些步骤都已完成，我们准备好真正做一些事情并构建我们的在线路由应用程序。为了测试一切是否正常工作，运行此命令：
- en: '[PRE13]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Open up your local web browser and see the welcome Django default page.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的本地网络浏览器并查看Django默认欢迎页面。
- en: Creating an indoor web routing service
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建室内网络路由服务
- en: Let's take all the effort we put into [Chapter 8](ch08.html "Chapter 8. Network
    Routing Analysis"), *Network Routing Analysis*, out onto the World Wide Web. Our
    routing service will simply accept a starting point location, an *x*, *y* coordinate
    pair, a floor level, and a destination location. The indoor routing service will
    then calculate the shortest path and return a complete route in the form of a
    GeoJSON file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们在[第8章](ch08.html "第8章。网络路由分析")，*网络路由分析*中投入的所有努力都放到万维网上。我们的路由服务将简单地接受一个起点位置、一个
    *x*、*y* 坐标对、楼层级别和目的地位置。然后室内路由服务将计算最短路径，并以GeoJSON文件的形式返回完整的路线。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作。
- en: 'To layout the tasks ahead, let''s list out what we need to accomplish at a
    high level so that we''re clear about where we are going:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了规划前面的任务，让我们从高层次列出我们需要完成的内容，以便我们清楚我们的方向：
- en: Create a URL pattern to call a route service.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个URL模式来调用路由服务。
- en: 'Build a view to handle an incoming URL request and deliver the appropriate
    GeoJSON route web response:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个视图来处理传入的URL请求并返回适当的GeoJSON路由网络响应：
- en: Accept incoming request parameters.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受传入的请求参数。
- en: Start *x* coordinate.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 开始 *x* 坐标。
- en: Start *y* coordinate.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 开始 *y* 坐标。
- en: Start floor number.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 开始楼层编号。
- en: End *x* coordinate.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结束 *x* 坐标。
- en: End *y* coordinate.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结束 *y* 坐标。
- en: End floor number.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结束楼层编号。
- en: Return GeoJSON LineString.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回GeoJSON LineString。
- en: Route geometry.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路径几何形状。
- en: Route length.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路径长度。
- en: Route walk time.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路径步行时间。
- en: 'We also need to let our new database user named `saturn` in order to have access
    to the tables located in the PostgreSQL geodata schema created in [Chapter 8](ch08.html
    "Chapter 8. Network Routing Analysis"), *Network Routing Analysis*. Currently,
    only the user named `postgres` is the owner and almighty one. This needs to change
    so that we can keep on trucking without needing to recreate our tables as created
    in [Chapter 8](ch08.html "Chapter 8. Network Routing Analysis"), *Network Routing
    Analysis*. So, let''s go ahead and simply make the `saturn` user the owner of
    each of these tables as follows:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要让名为`saturn`的新数据库用户能够访问在[第8章](ch08.html "第8章。网络路由分析")，*网络路由分析*中创建的PostgreSQL
    geodata模式中的表。目前，只有名为`postgres`的用户是所有者和全能者。这需要改变，这样我们就可以继续前进，而无需重新创建我们在[第8章](ch08.html
    "第8章。网络路由分析")，*网络路由分析*中创建的表。所以，让我们继续，简单地让`saturn`用户成为这些表的每个所有者，如下所示：
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you are looking for a way to allow both the `saturn` user and any other
    user to gain access to these tables, you could create a PostgreSQL group role
    and assign the user to this role as follows:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想允许`saturn`用户和任何其他用户访问这些表，您可以创建一个PostgreSQL组角色，并将用户分配到该角色，如下所示：
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Our code is now in one folder in a structure that''s common to all Django web
    projects, so following these steps should be straightforward:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的代码在一个文件夹中，这种结构对所有Django Web项目都是通用的，因此遵循这些步骤应该是直截了当的：
- en: 'Let''s begin by wiring up our new URL. Go ahead and open up the `urls.py` file
    inside your `ch11/code/web_analysis/` folder. Inside the file, you will need to
    enter the main URL configuration for our new web page. This file was automatically
    created when we created the project. Django fills in some helper text, as you
    can see, that shows you some basic configuration options. We need to add the `admin`
    app, which we will use later, and the URL for our new API. The API application
    will have its very own URL configuration file as you can see in the `api.urls`
    references, which we will create next. The `/web_analysis/urls.py` file should
    look like this:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先连接我们的新URL。请打开位于`ch11/code/web_analysis/`文件夹中的`urls.py`文件。在文件中，您需要输入我们新网页的主要URL配置。当创建项目时，此文件会自动创建。如您所见，Django填充了一些辅助文本，显示了基本配置选项。我们需要添加我们稍后将要使用的`admin`应用，以及我们新API的URL。API应用将拥有它自己的URL配置文件，正如您在`api.urls`引用中看到的，我们将创建它。`/web_analysis/urls.py`文件应如下所示：
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next up, let''s create the `/web_analysis/api/urls.py` api URLs. This file
    is not automatically generated so we''ll create this file now. The content of
    this `/api/urls.py` file will be as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`/web_analysis/api/urls.py` API URL。此文件不是自动生成的，所以我们现在将创建此文件。`/api/urls.py`文件的内容将如下所示：
- en: '[PRE17]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The regular expression looks wild as most regular expressions do. If you need
    some help understanding it, try referring to [https://regex101.com/#python](https://regex101.com/#python).
    Go ahead and paste this regular expression in the regular expression field:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正则表达式看起来很复杂，就像大多数正则表达式一样。如果您需要一些帮助来理解它，请尝试参考[https://regex101.com/#python](https://regex101.com/#python)。请将此正则表达式粘贴到正则表达式字段中：
- en: '[PRE18]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To test your URL string, simply paste this text in the **TEST STRING** field:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试您的URL字符串，只需将此文本粘贴到**测试字符串**字段中：
- en: '[PRE19]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If it's lit up in some funky colors, you are good to go:![How to do it...](img/50790OS_11_01.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它以一些奇特的颜色亮起，那么您就可以开始了：![如何操作...](img/50790OS_11_01.jpg)
- en: 'Django''s use of regular expressions for URL configuration is quite handy but
    not always obvious and explicit to read. Our URL is explained in a textual manner
    and would read like this:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Django在URL配置中使用正则表达式非常方便，但并不总是容易阅读和明确。我们的URL以文本方式解释，如下所示：
- en: '[PRE20]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is a real example from your development machine. When calling the URL,
    it will look like this:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个来自您开发机器的真实示例。当调用URL时，它看起来是这样的：
- en: '[PRE21]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The start and end location information is separated with an `&` symbol, while
    the contents of each start parameter and end parameter are separated by a comma.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 起始和结束位置信息由一个`&`符号分隔，而每个起始参数和结束参数的内容由逗号分隔。
- en: Going forward, in terms of complexity, we now need to enter the logic part of
    our API. Django handles this in the views. Our `/web_analysis/api/views.py` code
    contains the code to handle the request and response.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从现在开始，在复杂性方面，我们需要输入我们API的逻辑部分。Django在视图中处理这一点。我们的`/web_analysis/api/views.py`代码包含了处理请求和响应的代码。
- en: 'The main `def create_route` function should look familiar as it is taken directly
    from [Chapter 8](ch08.html "Chapter 8. Network Routing Analysis"), *Network Routing
    Analysis,* with some modifications. A new `helper` function is created called
    `find_closest_network_node`. This new function is more robust and faster than
    our previous SQL that we used to find the node closest to any given *x*, *y* coordinate
    entered by a user:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要的`def create_route`函数应该看起来很熟悉，因为它直接来自[第8章](ch08.html "第8章。网络路由分析")，*网络路由分析*，并进行了一些修改。创建了一个新的`helper`函数，称为`find_closest_network_node`。这个新函数比我们之前用来找到用户输入的任何给定*x*，*y*坐标的节点所用的SQL更健壮、更快：
- en: '[PRE22]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The resulting API call has a nice web interface that's automatically generated
    by the **Django REST Framework** as shown in the following screenshot. The URL
    you need to call is also shown and should return a GeoJSON result.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果API调用有一个很好的Web界面，这是由**Django REST框架**自动生成的，如下面的截图所示。您需要调用的URL也显示出来，并应返回GeoJSON结果。
- en: '![How to do it...](img/50790OS_11_02.jpg)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/50790OS_11_02.jpg)'
- en: 'The following URL will return GeoJSON to your browser; in Chrome, it will normally
    just show up as simple text. IE users may download it as a file by simply opening
    it in Notepad++ or a local text editor to see the contents of GeoJSON:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下URL将返回GeoJSON到您的浏览器；在Chrome中，它通常只会显示为简单的文本。IE用户可以通过在Notepad++或本地文本编辑器中打开它来将其作为文件下载，以查看GeoJSON的内容：
- en: '[PRE23]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Our view handles the request and response using the Django REST Framework.
    There are two functions that do all the hard work without ever using the Django
    **Object Relational Mapper** (**ORM**). The reason for this is two-fold: first,
    to show you the basics of direct Database usage without too much abstraction and
    the inner workings of what is going on; second, because we are using functions
    of PostGIS that are not available directly through the ORM of GeoDjango, such
    as `ST_3DDistance` or `ST_PointFromText`. We could use some of the fancy Django
    helpers, such as `.extra()`, but this would confuse everyone but an experienced
    Django user.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的观点使用Django REST框架处理请求和响应。有两个函数执行所有艰苦的工作，而从未使用Django **对象关系映射器**（**ORM**）。这样做的原因有两个：首先，为了向您展示直接数据库使用的基本知识，而不需要太多的抽象和内部工作原理；其次，因为我们正在使用PostGIS的函数，这些函数不能直接通过GeoDjango的ORM直接使用，例如`ST_3DDistance`或`ST_PointFromText`。我们可以使用一些花哨的Django辅助函数，如`.extra()`，但这可能会让除了经验丰富的Django用户之外的所有人感到困惑。
- en: 'Let''s discuss the first `find_closest_network_node` function that takes three
    parameters: `x_coord`, `y_coord`, and `floor`. The *x* and *y* coordinates should
    be double precision float values, while the floor is an integer. Our regular expression
    URL limits any request to digits so there is no need to do any extra format checking
    in our code.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论第一个`find_closest_network_node`函数，它接受三个参数：`x_coord`、`y_coord`和`floor`。`x`和`y`坐标应该是双精度浮点值，而楼层是一个整数。我们的正则表达式URL将任何请求限制为数字，因此我们不需要在我们的代码中进行任何额外的格式检查。
- en: The SQL query that finds the nearest node and returns its ID limits the search
    radius to 200 m, which would equal one huge room or auditorium. Then, we order
    by the 3D distance between the points and `LIMIT` the result to one since we are
    not routing to multiple locations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 查找最近节点并返回其ID的SQL查询将搜索半径限制在200米，这相当于一个巨大的房间或礼堂。然后，我们根据点之间的3D距离进行排序，并使用`LIMIT`将结果限制为一条，因为我们不是路由到多个位置。
- en: This feeds our second function called `create_route` where we pass it the start
    coordinate, start floor integer, end coordinate, and end floor number. Our URL
    at `/web_analysis/api/urls.py` uses a regular expression named `groups` that corresponds
    to the same names used in the request parameters of our function. This keeps things
    more explicit so that you know what values belong where in a query.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将数据传递给我们的第二个函数`create_route`，我们向其传递起始坐标、起始楼层整数、结束坐标和结束楼层编号。我们的URL在`/web_analysis/api/urls.py`中使用了名为`groups`的正则表达式，这与我们的函数请求参数中使用的名称相对应。这样做可以使事情更加明确，以便你知道查询中哪些值属于哪里。
- en: We begin with parsing the incoming parameters to get the exact values as floats
    and integers to feed our routing query. The routing query itself is unchanged
    from [Chapter 8](ch08.html "Chapter 8. Network Routing Analysis"), *Network Routing
    Analysis,* so refer to this chapter for more details. The Django REST framework
    response sends the GeoJSON back to the client and has the ability to return it
    as raw text as well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先解析传入的参数，以获取精确的浮点数和整数值，以便为我们的路由查询提供数据。路由查询本身与[第8章](ch08.html "第8章. 网络路由分析")*网络路由分析*保持不变，因此请参阅本章以获取更多详细信息。Django
    REST框架的响应将GeoJSON发送回客户端，并且有将其作为纯文本返回的能力。
- en: Visualizing an indoor routing service
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化室内路由服务
- en: With our wonderful API created, it's time now to visualize this indoor route
    returned as GeoJSON on a map. We will now dive into the Django template components
    to create the HTML, JS, and CSS for our front-facing web page that displays a
    simple slippy web map using Openlayers 3.4.0\. and Bootstrap CSS.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了我们的精彩API之后，现在是时候在地图上可视化作为GeoJSON返回的室内路线了。我们将现在深入研究Django模板组件，以创建用于显示简单滑块网络地图的HTML、JS和CSS，该地图使用Openlayers
    3.4.0和Bootstrap CSS。
- en: Our new web map will display the GeoJSON on the map with a nice style alongside
    a menu bar where we will include later functionality.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新网络地图将在地图上以美观的样式显示GeoJSON，并附带一个菜单栏，我们将在其中包含后续功能。
- en: '![Visualizing an indoor routing service](img/50790OS_11_03.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![可视化室内路由服务](img/50790OS_11_03.jpg)'
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to build a few new folders and files to store new static and template
    content for our Django web application. Let's begin doing this by creating the
    `/web_analysis/templates` folder followed by the `/web_analysis/static` folder.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建一些新的文件夹和文件来存储我们Django网络应用的新静态和模板内容。让我们从创建 `/web_analysis/templates` 文件夹开始，然后是
    `/web_analysis/static` 文件夹。
- en: Inside our `/static/` folder, we will place the nondynamic content of the JavaScript
    and CSS files. The `/templates/` folder will store the HTML template files used
    to create our web pages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `/static/` 文件夹中，我们将放置JavaScript和CSS文件的非动态内容。`/templates/` 文件夹将存储用于创建我们网页的HTML模板文件。
- en: 'Next up, let''s tell Django `/web_analysis/settings.py` about the location
    of our new templates folder; add the `os.path.join(BASE_DIR, ''templates'')` value
    to the `''DIRS''` key shown here so that the `TEMPLATES` variable looks like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们告诉Django `/web_analysis/settings.py` 关于我们新模板文件夹的位置；将 `os.path.join(BASE_DIR,
    'templates')` 值添加到此处显示的 `'DIRS'` 键中，以便 `TEMPLATES` 变量看起来像这样：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To manage our maps, lets create a new Django application called `maps` where
    we can store all our map information as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理我们的地图，让我们创建一个名为 `maps` 的新Django应用，在那里我们可以存储所有我们的地图信息如下：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, register your new app in the `/web_analysis/web_analysis/settings.py INSTALLED
    APPS` variable by adding this under the `api` entry `'maps'`, under the entry
    `'api'`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `/web_analysis/web_analysis/settings.py INSTALLED APPS` 变量中注册您的新应用，通过在
    `api` 条目 `'maps'` 下方添加以下内容，在 `'api'` 条目下。
- en: 'The `/maps/urls.py` file is not automatically created so let''s do this now
    and fill in some content as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`/maps/urls.py` 文件不是自动创建的，所以现在让我们创建它并填充以下内容：'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We need to assign `maps/urls.py` within our main `/web_analysis/web_analysis/urls.py`
    so that we can freely create any URL for all our mapping needs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在主 `/web_analysis/web_analysis/urls.py` 中分配 `maps/urls.py`，这样我们就可以自由地为所有我们的映射需求创建任何URL。
- en: 'Add this line to the `/web_analysis/web_analysis/urls.py` file as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到 `/web_analysis/web_analysis/urls.py` 文件中，如下所示：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This means that all the URL's inside our `/maps/urls.py` will start with `http://localhost:8000/maps/`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们 `/maps/urls.py` 中的所有URL都将以 `http://localhost:8000/maps/` 开头。
- en: 'We are now ready to set up the static files and static contents inside `settings.py`
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好在 `settings.py` 中设置静态文件和静态内容，如下所示：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should have the following folders and files now in the `/static/` folder:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该在 `/static/` 文件夹中有以下文件夹和文件：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This should be enough to set up your Django project in order for it to serve
    up a static map.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足以设置您的Django项目，以便它能够提供静态地图。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Actually serving up the map requires us to create an HTML page. We use the built-in
    Django template engine to build two HTML pages. The first page template is `base.html`
    that will hold the basics of our web map page, making it a very important part
    of our frontend design. What's included in this page is a set of block tags, each
    for separate content place holders. This allows us to quickly create new map pages
    based on our base template, which sets up our basic template architecture.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上提供地图服务需要我们创建一个HTML页面。我们使用内置的Django模板引擎构建两个HTML页面。第一个页面模板是 `base.html`，它将包含我们网络地图页面的基本内容，使其成为我们前端设计的重要组成部分。这个页面包含一系列块标签，每个标签对应一个单独的内容占位符。这使我们能够根据基础模板快速创建新的地图页面，从而设置我们的基本模板架构。
- en: 'Here is the `/templates/base.html` file:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是 `/templates/base.html` 文件：
- en: '[PRE30]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s move on to the actual map. A new template called `/templates/route-map.html`
    contains all the actual Django template blocks that are filled with HTML content
    as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续实际地图的设置。一个名为 `/templates/route-map.html` 的新模板包含所有实际的Django模板块，这些块填充了以下HTML内容：
- en: '[PRE31]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For our application to actually show these templates, we need to create a view.
    The view handles the request and serves `route-map.html` in return. Now, our simple
    view is complete:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的应用实际上显示这些模板，我们需要创建一个视图。视图处理请求并返回 `route-map.html`。现在，我们的简单视图已经完成：
- en: '[PRE32]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Starting with the `base.html` template, we set out the basic building blocks
    for map making. The static files and resources were set up to handle serving our
    JavaScript and CSS code. The `base.html` file is designed to allow us to add elements
    that are shared between multiple HTML pages such as a master page in Microsoft
    PowerPoint. The more blocks, that is, place holders, the better your base.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `base.html` 模板开始，我们为地图制作设置了基本构建块。静态文件和资源被设置来处理我们的JavaScript和CSS代码的服务。`base.html`
    文件设计为允许我们添加多个HTML页面之间共享的元素，例如Microsoft PowerPoint中的主页面。块越多，即占位符越多，您的基准就越好。
- en: 'Our `route-map.html` contains the actual code referencing our `api` by calling
    it with a predefined, hardcoded from, `to URL`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`route-map.html`包含实际代码，通过调用它并使用预定义的、硬编码的`from`，`to URL`来引用我们的`api`：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `/maps/views.py` code is where any map logic, variables, or parameters are
    passed around to the template. In our code, we simply take in a request and return
    an HTML page. Now you have a rudimentary indoor routing service and visualization
    client to show off to your friends.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`/maps/views.py` 代码是任何地图逻辑、变量或参数传递到模板的地方。在我们的代码中，我们只是接收一个请求并返回一个HTML页面。现在你有一个基本的室内路由服务和可视化客户端，可以向你的朋友展示。'
- en: Creating an indoor route-type service
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建室内路线类型服务
- en: 'Building a route based on a specified type value, such as a **Barrier Free
    Route** or **Standard Pedestrian Route** value, is great for your users. How to
    build different route types is based on the available data connected to our indoor
    graph of ways. This example will allow a user to select the barrier-free route
    and our service will generate a path, avoiding obstacles such as stairs:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 基于指定的类型值构建路线，例如**无障碍路线**或**标准步行路线**值，对用户来说非常好。如何构建不同的路线类型取决于与我们室内图中的方式连接的可用数据。此示例将允许用户选择无障碍路线，我们的服务将生成一条路径，避开如楼梯等障碍物：
- en: '![Creating an indoor route-type service](img/50790OS_11_04.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![创建室内路线类型服务](img/50790OS_11_04.jpg)'
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need to access some more data on our network to allow routing types. The
    type of route is based on a network line type, which is stored as an attribute
    on each LineString. To classify our route types, we have the following lookup
    table schema:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要访问更多关于我们网络的数据，以便允许路由类型。路线类型基于网络线路类型，该类型存储在每个LineString上的属性。为了分类我们的路线类型，我们有以下查找表模式：
- en: '| Value | Route type |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 路线类型 |'
- en: '| --- | --- |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `0` | Indoor route |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 室内路线 |'
- en: '| `1` | Outdoor route |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `1` | 室外路线 |'
- en: '| `2` | Elevator |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `2` | 电梯 |'
- en: '| `3` | Stairs |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `3` | 楼梯 |'
- en: Therefore, we want to avoid any stairs segments, which technically means avoiding
    `type_id = 3`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们想要避免任何楼梯段，这在技术上意味着避免`type_id = 3`。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Optionally, you could create a lookup table to store all the possible types
    and their equivalent weights. These values could then be included in the calculation
    of the total cost value to influence the route outcome.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以创建一个查找表来存储所有可能的类型及其等效权重。这些值可以包含在总成本值的计算中，以影响路线结果。
- en: 'Now we can control how the route is generated based on certain preferences
    as well. A standard route search can now be set for preferences, such as taking
    the stairs over the elevator or vice versa, depending on your needs:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以根据某些偏好来控制路线的生成。现在可以为偏好设置标准路线搜索，例如，根据你的需要选择走楼梯还是电梯：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you update `geodata.networklines_3857`, make sure the user `saturn` is the
    owner or has access; otherwise, your API call will break.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更新`geodata.networklines_3857`，请确保用户`saturn`是所有者或有访问权限；否则，你的API调用将失败。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The least-cost path from any point is controlled by a basic property called
    `cost`. For a standard route, the cost is equal to the distance of a segment.
    We search for the least-cost path, which means finding the shortest path to our
    destination.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何点到最短路径由一个基本属性`cost`控制。对于标准路线，成本等于段落的距离。我们寻找最短路径，这意味着找到到达目的地的最短路径。
- en: To control the path, we set the cost values. Creating a barrier-free route involves
    setting all segment types equal to `stairs` at an extraordinarily high value so
    that the path, that is, the distance, is huge and is, therefore, excluded in the
    shortest path route finding process. Our other option is to add a `WHERE` clause
    to the query and only accept values where `type_id` is not equal to `3`, which
    means that it is not of the type `stairs`. We are going to use this option in
    our upcoming code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制路径，我们设置成本值。创建无障碍路线涉及将所有段类型设置为异常高的`stairs`值，从而使路径，即距离，变得非常大，因此被排除在最短路径路由查找过程中。我们的另一种选择是在查询中添加一个`WHERE`子句，并且只接受`type_id`不等于`3`的值，这意味着它不是楼梯类型。我们将在即将到来的代码中使用此选项。
- en: Therefore our data needs to be clean in order to allow us to assign specific
    costs to specific segment types in our network lines.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的数据需要保持清洁，以便我们可以为我们的网络线路中的特定段类型分配特定的成本。
- en: 'Now, we need to add a new parameter to capture the route type:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个新参数来捕获路线类型：
- en: 'We''ll update the `/api/views.py` function, `create route()`, and add a new
    parameter called `route_type`. Next up is the actual query that needs to accept
    this new parameter. We set up a new variable called `barrierfree_q` to hold the
    `WHERE` clause that we will add to our original query:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将更新 `/api/views.py` 函数，`create route()`，并添加一个名为 `route_type` 的新参数。接下来是实际需要接受这个新参数的查询。我们设置了一个名为
    `barrierfree_q` 的新变量来保存我们将添加到原始查询中的 `WHERE` 子句：
- en: '[PRE35]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We''ll update our `/api/urls.py` to input our new URL parameter, `route_type`.
    The newly added named group regular expression is naturally called `route_type`
    and only accepts numbers from 0 to 9\. This then, of course, also limits you to
    10 route types. So, if you want to add more types, you will need to update your
    `regex` as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将更新我们的 `/api/urls.py` 以输入新的 URL 参数 `route_type`。新添加的命名组正则表达式自然被称为 `route_type`，并且只接受从
    0 到 9 的数字。因此，这当然也限制了你有 10 种路由类型。所以，如果你想添加更多类型，你需要更新你的 `regex` 如下：
- en: '[PRE36]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `/maps/views.py` function needs a facelift too so that we can pass in the
    parameters. Now, it will accept `route_type` as defined in our `/api/urls.py`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/maps/views.py` 函数也需要进行改进，以便我们可以传递参数。现在，它将接受在 `/api/urls.py` 中定义的 `route_type`：'
- en: '[PRE37]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It''s time to update `route-map.html` to include radio buttons that allow a
    user to select either a **Standard Route** or **Barrier Free Route**. The map
    will then update the route as soon as you click on the route type radio button:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候更新 `route-map.html` 以包括单选按钮，允许用户选择 **标准路线** 或 **无障碍路线**。地图将在你点击路由类型单选按钮后立即更新路线：
- en: '[PRE38]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our results for `type = 0` or a route using stairs should look like this:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 `type = 0` 或使用楼梯的路线，我们的结果应该看起来像这样：
- en: '![How to do it...](img/50790OS_11_05.jpg)'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/50790OS_11_05.jpg)'
- en: 'The barrier-free route will use `type = 1`, which means forced elevator use
    and avoiding all stairs. Your result should then look like this:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无障碍路线将使用 `type = 1`，这意味着强制使用电梯并避免所有楼梯。你的结果应该看起来像这样：
- en: '![How to do it...](img/50790OS_11_06.jpg)'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/50790OS_11_06.jpg)'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The main part to understand here is that we need to add an option route type
    to our API call. This API call must accept a specific route type that we have
    defined as a number from 0 to 9\. This route type number is then passed to our
    URL as a parameter and `api/views.py` runs the call. The API then generates a
    new route based on the route type.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要理解的主要部分是，我们需要在我们的 API 调用中添加一个选项路由类型。这个 API 调用必须接受一个特定的路由类型，我们将其定义为从 0 到
    9 的数字。然后，这个路由类型数字被作为参数传递到我们的 URL 中，`api/views.py` 执行调用。然后 API 根据路由类型生成一个新的路线。
- en: All our changes are made inside the `/api/view.py` code that now includes a
    SQL `WHERE` clause and excludes `networklines` with a `type_id = 3`—that is, `stairs`.
    This query change keeps our app fast without actually increasing any Django middleware
    code in our views.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有更改都是在 `/api/view.py` 代码中进行的，现在包括一个 SQL `WHERE` 子句，并排除 `type_id = 3` 的 `networklines`——即楼梯。这个查询更改使我们的应用保持快速，实际上并没有增加任何
    Django 中间件代码在我们的视图中。
- en: The frontend needs the user to select a route type with the default route type
    set to a standard value, such as `0`, as in the case of `stairs`. This default
    type is used because in most indoor environments the stairs are usually shorter.
    You can, of course, change this default to whatever value or criteria you'd like
    at any time. A radio select box is used to restrain the choice to either a standard
    route or a barrier-free route. Upon selecting a route type, the map automatically
    removes the old route and creates a new route.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前端需要用户选择一个路由类型，默认路由类型设置为标准值，例如 `0`，就像楼梯的情况一样。这个默认类型被使用，因为在大多数室内环境中，楼梯通常更短。当然，你可以在任何时候将其默认值更改为任何值或标准。使用单选按钮来限制选择为标准路线或无障碍路线。选择路由类型后，地图会自动删除旧路线并创建新路线。
- en: Creating an indoor route from room to room
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从房间到房间创建室内路线
- en: Routing from room A to room B in an indoor routing web application over multiple
    floors with routing types brings together all our work up to this point. We will
    import some room data and utilize our network to then allow a user to select a
    room, route from one room to the next, and select a type of route.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在多层室内路由网络应用中，从房间 A 到房间 B 的路由类型将汇集我们到目前为止的所有工作。我们将导入一些房间数据并利用我们的网络，然后允许用户选择一个房间，从一个房间到下一个房间进行路由，并选择一种路由类型。
- en: '![Creating an indoor route from room to room](img/50790OS_11_07.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![从房间到房间创建室内路线](img/50790OS_11_07.jpg)'
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need to import a set of room polygons for both the first and second floor
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入一楼和二楼的一组房间多边形，如下所示：
- en: 'Import a Shapefile of the first floor room polygons as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式导入一楼房间多边形的Shapefile：
- en: '[PRE39]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Import a Shapefile of the second floor room polygons as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式导入二楼房间多边形的Shapefile：
- en: '[PRE40]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a new PostgreSQL view to merge all the new room data into one table
    so that we can query all the rooms at once:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的PostgreSQL视图以合并所有新的房间数据到一个表中，这样我们就可以一次性查询所有房间：
- en: '[PRE41]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To allow a user to route from A to B, we need to enable a route from a field
    and a route to a field, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户从A到B进行路由，我们需要启用从字段到字段的路线，如下所示：
- en: Create a new URL to accept the new parameter of the start and end room number.
    The first URL for example will look like `http://localhost:8000/api/directions/10010&20043&0`,
    which means that the route from room number `10010` to room number `20042` using
    the standard route type equals to zero.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的URL以接受起始和结束房间号的新参数。例如，第一个URL将看起来像 `http://localhost:8000/api/directions/10010&20043&0`，这意味着从房间号
    `10010` 到房间号 `20042` 使用标准路由类型等于零的路由。
- en: Note
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The second URL is an extra function that you can call to only return the center
    coordinate of a room when you pass in the room number like this: `http://localhost:8000/directions/10010`.'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个URL是一个额外的函数，您可以通过传入房间号来调用它，以仅返回房间中心坐标，例如：`http://localhost:8000/directions/10010`。
- en: This function in the view *does not exist* and is left for you to do as homework.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 视图中的此函数 *不存在*，留作您的作业。
- en: '[PRE42]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Build a new `/api/views.py` function to find a room center coordinate and return
    the nearest node on `networklines` to this coordinate:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `/api/views.py` 函数来查找房间中心坐标，并返回到 `networklines` 上最近的节点：
- en: '[PRE43]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Build the function inside `/api/views.py` to accept a start node ID, end node
    ID, and a route type that will then return a GeoJSON of the final route as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/api/views.py` 内部构建该函数以接受起始节点ID、结束节点ID和路由类型，然后返回最终路由的GeoJSON，如下所示：
- en: '[PRE44]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'At last, we can create a function that our API will call to generate a response:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以创建一个函数，我们的API将调用它来生成响应：
- en: '[PRE45]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add a URL to `/api/urls.py` to access a list of all available rooms:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/api/urls.py` 中添加一个URL以访问所有可用的房间列表：
- en: '[PRE46]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create an API service to return a JSON array of all room numbers. This array
    is used in autocomplete fields, `route-from`, and `route-to`. We use the Twitter
    `Typeahead.js` JavaScript library to handle our autocomplete dropdown type hinting.
    As a user, all you need to do is type 1, for example, and all the rooms beginning
    with 1 will show up as `10010` (check this out at [http://twitter.github.io/typeahead.js/examples/](http://twitter.github.io/typeahead.js/examples/)):'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个API服务以返回所有房间号的JSON数组。此数组用于自动完成字段、`route-from` 和 `route-to`。我们使用Twitter的
    `Typeahead.js` JavaScript库来处理我们的自动完成下拉类型提示。作为用户，您只需输入1，例如，所有以1开头的房间将显示为 `10010`（请在此处查看[http://twitter.github.io/typeahead.js/examples/](http://twitter.github.io/typeahead.js/examples/)）：
- en: '[PRE47]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our final `base.html` template is complete, containing all the spice needed
    for our final route from room to room as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最终的 `base.html` 模板已经完成，包含从房间到房间最终路由所需的所有调料，如下所示：
- en: '[PRE48]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we''ll create our final `route-map.html` template and the JavaScript that
    goes with it as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建最终的 `route-map.html` 模板及其相关的JavaScript，如下所示：
- en: '[PRE49]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Our `maps/templates/routing.js` contains the functions needed to call the routing
    API as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `maps/templates/routing.js` 包含调用路由API所需的函数，如下所示：
- en: '[PRE50]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, go ahead and enter `1` and see the autocomplete in action; then, select
    **Route To:** and enter `2` to see the second floor options. Finally, click on
    **GO!** and see the magic happen:![How to do it...](img/50790OS_11_08.jpg)
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入 `1` 并查看自动完成功能；然后，选择 **路由到** 并输入 `2` 以查看二楼选项。最后，点击 **GO!** 并见证魔法发生：![如何操作...](img/50790OS_11_08.jpg)
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The internal workings of each step are shown, so let's go through all of them
    one at a time. We start off with the data import of our new room dataset as the
    basic starting and ending points of our new indoor routing tool. We lay out the
    top-level structure of our API with some new URLs, defining how we will call the
    new routing service, and then define these variables. Our regular expressions
    handle the correct data types that are passed in the URL without any exceptions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步的内部工作原理都得到了展示，因此我们将逐一过一遍。我们首先从导入新的房间数据集开始，作为我们新的室内路由工具的基本起始点和结束点。我们使用一些新的
    URL 布局我们的 API 的顶层结构，定义了我们如何调用新的路由服务，并定义了这些变量。我们的正则表达式处理了在 URL 中传入的正确数据类型，没有任何异常。
- en: These URL patterns are then used by `api/views.py` to actually accept the incoming
    room numbers and route types to generate our new route. This generation is split
    up into a few functions to increase usability. The `get_room_centroid_node()`
    function is necessary so that we can find the middle point of the room and then
    find the next nearest node on a network. We could also simply use the polygon
    geometry to find the nearest node but this can lead to ambiguity if the rooms
    are large and the entrances are close to each other. The `centroid` method is
    much more reliable and does not add too much overhead.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 URL 模式随后被 `api/views.py` 使用，以接受传入的房间号和路由类型，生成我们的新路由。这一生成过程被拆分成几个函数以提高可用性。`get_room_centroid_node()`
    函数是必要的，这样我们就可以找到房间的中心点，然后在网络上找到下一个最近的节点。我们也可以简单地使用多边形几何来找到最近的节点，但如果房间很大且入口彼此靠近，这可能会导致歧义。`centroid`
    方法更加可靠，并且不会增加太多开销。
- en: The `run_route()` function actually then runs `find_closest_network_node()`,
    which we created earlier, making things work well together. The `run_route` function
    then generates our GeoJSON result as it is passed in the start node ID, end node
    ID, and the route type.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`run_route()` 函数实际上运行了我们之前创建的 `find_closest_network_node()` 函数，使得它们能够很好地协同工作。`run_route`
    函数随后根据传入的起始节点 ID、结束节点 ID 和路由类型生成我们的 GeoJSON 结果。'
- en: The `route_room_to_room()` function is small as the heavy lifting has already
    been completed by our other functions. It simply inputs the URL parameters called
    by our API call, as seen in `http://localhost:8000/api/directions/10010&20043&0`.
    The final steps after step 6 are for the user interface. We need to provide the
    user with a list of rooms that are available to route from and to. The /`api/rooms`
    URL provides exactly this, delivering a JSON array of room numbers. The input
    fields are bootstrap inputs with Twitter `Typeahead.js` and `Bloodhound.js` to
    prefetch remote data. As a user, you simply enter a number and, bingo, a list
    appears. More detailed instructions on the JavaScript side of things are a little
    beyond the scope of this book, but these are, thankfully, kept to a minimum.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`route_room_to_room()` 函数很小，因为其他函数已经完成了大部分工作。它只是输入由我们的 API 调用调用的 URL 参数，如 `http://localhost:8000/api/directions/10010&20043&0`
    中所见。第 6 步之后的最终步骤是用户界面。我们需要向用户提供一个可供路由的房间列表。`/api/rooms` URL 正好提供了这个功能，返回一个包含房间号的
    JSON 数组。输入字段是带有 Twitter `Typeahead.js` 和 `Bloodhound.js` 的 Bootstrap 输入，用于预取远程数据。作为用户，你只需输入一个数字，然后就会出现一个列表。关于
    JavaScript 方面的更详细说明超出了本书的范围，但幸运的是，这些内容被保持在最低限度。'
- en: All in all, you now have a fully functional indoor mapping web application with
    a basic set of indoor 3D routing functions that you can expand on at any time.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，你现在拥有了一个功能齐全的室内地图网络应用程序，它包含一组基本的室内 3D 路由功能，你可以随时扩展。
- en: Appendix A. Other Geospatial Python Libraries
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 其他地理空间 Python 库
- en: We have covered many libraries and examples but we haven't covered them all.
    This appendix is meant to quickly go over the other libraries out there that play
    a special role in the Python geospatial working environment. This list is definitely
    not complete and I have not had the pleasure of working with all these libraries
    at the time of writing.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了很多库和示例，但我们并没有涵盖所有内容。这个附录旨在快速浏览其他在 Python 地理空间工作环境中扮演特殊角色的库。这个列表绝对不完整，我在写作时还没有有幸与所有这些库合作。
- en: 'The listing is a resource for further reading and experiments that will, hopefully,
    provide you with a step in the right direction to solve your specific problems.
    Each description of a library starts with the official library name followed by
    a short description and a link to the web page:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一个进一步阅读和实验的资源，希望它能为你解决特定问题提供正确的方向。每个库的描述都以官方库名称开头，后面跟着简短描述和网页链接：
- en: '| Library name | Description | Website |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 库名称 | 描述 | 网站 |'
- en: '| --- | --- | --- |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Rtree | This is a Python wrapper of `libspatialindex` that provides advanced
    spatial indexing features | [http://toblerity.org/rtree](http://toblerity.org/rtree)
    |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| Rtree | 这是一个`libspatialindex`的Python包装器，提供了高级空间索引功能 | [http://toblerity.org/rtree](http://toblerity.org/rtree)
    |'
- en: '| rasterio | This is a Mapbox creation that aims at working with rasters in
    an easier manner | [https://github.com/mapbox/rasterio](https://github.com/mapbox/rasterio)
    |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| rasterio | 这是一个Mapbox创建工具，旨在以更简单的方式处理栅格数据 | [https://github.com/mapbox/rasterio](https://github.com/mapbox/rasterio)
    |'
- en: '| Fiona | This focuses on reading and writing data in the standard Python I/O
    style | [http://toblerity.org/fiona](http://toblerity.org/fiona) |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| Fiona | 这专注于以标准的Python I/O风格读取和写入数据 | [http://toblerity.org/fiona](http://toblerity.org/fiona)
    |'
- en: '| geopy | This helps geocoding in Python | [http://www.geopy.org](http://www.geopy.org)
    |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| geopy | 这有助于Python中的地理编码 | [http://www.geopy.org](http://www.geopy.org) |'
- en: '| PyQGIS | This is the Python interface to QGIS (formerly known as Quantum
    GIS) that helps extend QGIS and more | [http://pythongisbook.com](http://pythongisbook.com)
    |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| PyQGIS | 这是QGIS（以前称为Quantum GIS）的Python接口，有助于扩展QGIS等 | [http://pythongisbook.com](http://pythongisbook.com)
    |'
- en: '| GeoPandas | This is an extension of the pandas library and handles geospatial
    database | [http://geopandas.org/](http://geopandas.org/) |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| GeoPandas | 这是一个pandas库的扩展，用于处理地理空间数据库 | [http://geopandas.org/](http://geopandas.org/)
    |'
- en: '| MapFish | This is Python''s geospatial web framework | [http://mapfish.org](http://mapfish.org)
    |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| MapFish | 这是Python的地理空间Web框架 | [http://mapfish.org](http://mapfish.org) |'
- en: '| PyWPS | This client interacts with various open geospatial standard services
    | [http://pywps.wald.intevation.org](http://pywps.wald.intevation.org) |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| PyWPS | 这个客户端与各种开放地理空间标准服务进行交互 | [http://pywps.wald.intevation.org](http://pywps.wald.intevation.org)
    |'
- en: '| pycsw | This provides a metadata catalog interface | [http://pycsw.org](http://pycsw.org)
    |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| pycsw | 这提供了一个元数据目录接口 | [http://pycsw.org](http://pycsw.org) |'
- en: '| GeoNode | This provides Python geospatial content management for the Web
    and is built on the Django web framework and GeoServer | [http://geonode.org](http://geonode.org)
    |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| GeoNode | 这为Web提供Python地理空间内容管理，基于Django Web框架和GeoServer构建 | [http://geonode.org](http://geonode.org)
    |'
- en: '| mapnik | This is a map visualization library to create maps for web tile
    cache | [http://mapnik.org](http://mapnik.org) |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| mapnik | 这是一个用于创建网络瓦片缓存的地图可视化库 | [http://mapnik.org](http://mapnik.org) |'
- en: '| cartopy | This is mapping made easy in Python-shapely | [http://scitools.org.uk/cartopy](http://scitools.org.uk/cartopy)
    |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| cartopy | 这是在Python-shapely中简化地图制作的工具 | [http://scitools.org.uk/cartopy](http://scitools.org.uk/cartopy)
    |'
- en: '| Kartograph | This creates SVG maps or web maps | [http://kartograph.org](http://kartograph.org)
    |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| Kartograph | 这创建SVG地图或网络地图 | [http://kartograph.org](http://kartograph.org)
    |'
- en: '| basemap | This is an extension of matplotlib in combination with descartes
    | [http://matplotlib.org/basemap](http://matplotlib.org/basemap) |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| basemap | 这是matplotlib与descartes结合的扩展 | [http://matplotlib.org/basemap](http://matplotlib.org/basemap)
    |'
- en: '| SciPy | This is a collection of Python libraries for scientific data analysis
    that are bundled or available as individual installations | [http://www.scipy.org](http://www.scipy.org)
    |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| SciPy | 这是一个用于科学数据分析的Python库集合，可以捆绑安装或作为单独的安装提供 | [http://www.scipy.org](http://www.scipy.org)
    |'
- en: '| GeoAlchemy | This is a spatial extension to SQLAlchemy that works with the
    spatial database PostGIS | [http://geoalchemy.org](http://geoalchemy.org) |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| GeoAlchemy | 这是一个空间扩展到SQLAlchemy，与空间数据库PostGIS一起工作 | [http://geoalchemy.org](http://geoalchemy.org)
    |'
- en: '| pyspatialite | This helps you work with spatialite databases of geospatial
    data | [https://pypi.python.org/pypi/pyspatialite](https://pypi.python.org/pypi/pyspatialite)
    |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| pyspatialite | 这有助于您处理地理空间数据的spatialite数据库 | [https://pypi.python.org/pypi/pyspatialite](https://pypi.python.org/pypi/pyspatialite)
    |'
- en: '| gpxpy | This helps when working with GPS data in the standard GPX format
    in a Python - friendly format | [http://www.trackprofiler.com/gpxpy/index.html](http://www.trackprofiler.com/gpxpy/index.html)
    |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| gpxpy | 这有助于在Python友好的格式中处理标准GPX格式的GPS数据 | [http://www.trackprofiler.com/gpxpy/index.html](http://www.trackprofiler.com/gpxpy/index.html)
    |'
- en: '| ShaPy | This is a pure Python version of Shapely with no dependencies | [https://github.com/karimbahgat/Shapy](https://github.com/karimbahgat/Shapy)
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| ShaPy | 这是一个没有依赖项的Shapely的纯Python版本 | [https://github.com/karimbahgat/Shapy](https://github.com/karimbahgat/Shapy)
    |'
- en: '| pyshp | This reads and writes Shapefiles in pure Python | [https://github.com/GeospatialPython/pyshp](https://github.com/GeospatialPython/pyshp)
    |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| pyshp | 这使用纯Python读取和写入Shapefiles | [https://github.com/GeospatialPython/pyshp](https://github.com/GeospatialPython/pyshp)
    |'
- en: '| TileCache | This is an implementation of a WMS-C (catalog) **Tile Mapping
    Server** (**TMS**) server | [http://tilecache.org](http://tilecache.org) |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| TileCache | 这是一个WMS-C（目录）**瓦片映射服务器**（TMS）的实现 | [http://tilecache.org](http://tilecache.org)
    |'
- en: '| TileStache | This is a Python-based server application that can serve up
    map tiles based on rendered geographic data | [http://www.tilestache.org](http://www.tilestache.org)
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| TileStache | 这是一个基于Python的服务器应用程序，可以根据渲染的地理数据提供地图瓦片 | [http://www.tilestache.org](http://www.tilestache.org)
    |'
- en: '| FeatureServer | This is a restful feature service to easily get, edit, delete,
    and update features over the Web with the help of HTTP | [http://featureserver.org](http://featureserver.org)
    |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| FeatureServer | 这是一个RESTful功能服务，通过HTTP帮助轻松获取、编辑、删除和更新网络上的功能 | [http://featureserver.org](http://featureserver.org)
    |'
- en: '| GeoScript | This is an implementation of Python, giving spatial analysis
    functionality to other scripting languages and Python is one of them; it is similar
    to Shapely | [http://www.geoscript.org](http://www.geoscript.org) |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| GeoScript | 这是一个Python的实现，为其他脚本语言和Python提供空间分析功能；Python就是其中之一；它与Shapely类似
    | [http://www.geoscript.org](http://www.geoscript.org) |'
- en: '| karta | This is a Leatherman for geographic analyses | [http://ironicmtn.com/karta](http://ironicmtn.com/karta)
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| karta | 这是一个地理分析的瑞士军刀 | [http://ironicmtn.com/karta](http://ironicmtn.com/karta)
    |'
- en: Appendix B. Mapping Icon Libraries
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B. 地图图标库
- en: 'Finding the perfect mapping icon set is hard. The following list provides some
    of the better map symbols around, for your web map application:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找完美的地图图标集是困难的。以下列表提供了一些较好的地图符号，供您的网络地图应用程序使用：
- en: '| Library name | Description | Website |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| Library name | 描述 | 网站 |'
- en: '| --- | --- | --- |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| map-icons | This is an icon font that''s used with the Google Maps API and
    Google Places API using SVG markers and icon labels | [http://map-icons.com/](http://map-icons.com/)
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| map-icons | 这是一个与Google Maps API和Google Places API一起使用的图标字体，使用SVG标记和图标标签
    | [http://map-icons.com/](http://map-icons.com/) |'
- en: '| Maki | This creates Mapbox Pixel-perfect icons for web cartography | [https://www.mapbox.com/maki](https://www.mapbox.com/maki)
    |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| Maki | 这为网络制图创建Mapbox像素完美的图标 | [https://www.mapbox.com/maki](https://www.mapbox.com/maki)
    |'
- en: '| map icons | This focuses on reading and writing data in the standard Python
    IO style | [https://mapicons.mapsmarker.com/](https://mapicons.mapsmarker.com/)
    |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| map icons | 这专注于以标准的Python IO风格读取和写入数据 | [https://mapicons.mapsmarker.com/](https://mapicons.mapsmarker.com/)
    |'
- en: '| Integration and Application Network | This creates 2782 custom vector symbols
    | [http://ian.umces.edu/symbols/](http://ian.umces.edu/symbols/) |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| Integration and Application Network | 这创建了2782个自定义矢量符号 | [http://ian.umces.edu/symbols/](http://ian.umces.edu/symbols/)
    |'
- en: '| OSM icons | This is a set of free SVG icons that are used for OSM maps |
    [http://osm-icons.org/wiki/Icons](http://osm-icons.org/wiki/Icons) |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| OSM icons | 这是一个用于OSM地图的免费SVG图标集 | [http://osm-icons.org/wiki/Icons](http://osm-icons.org/wiki/Icons)
    |'
- en: '| OSGeo map symbol set | This is a collection of links to map icons | [http://wiki.osgeo.org/wiki/OSGeo_map_symbol_set](http://wiki.osgeo.org/wiki/OSGeo_map_symbol_set)
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| OSGeo地图符号集 | 这是一个地图图标链接的集合 | [http://wiki.osgeo.org/wiki/OSGeo_map_symbol_set](http://wiki.osgeo.org/wiki/OSGeo_map_symbol_set)
    |'
- en: '| SJJB collection | This is a set of PD/CC0 SVG map icons and tools to generate
    PNG icons | [https://github.com/twain47/Open-SVG-Map-Icons](https://github.com/twain47/Open-SVG-Map-Icons)
    and [http://www.sjjb.co.uk/mapicons/contactsheet](http://www.sjjb.co.uk/mapicons/contactsheet)
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| SJJB collection | 这是一个PD/CC0 SVG地图图标和生成PNG图标的工具集 | [https://github.com/twain47/Open-SVG-Map-Icons](https://github.com/twain47/Open-SVG-Map-Icons)
    和 [http://www.sjjb.co.uk/mapicons/contactsheet](http://www.sjjb.co.uk/mapicons/contactsheet)
    |'
- en: '| OSM map-icons | This creates an OpenStreetMap set of icons | [https://github.com/openstreetmap/map-icons/tree/master/svg](https://github.com/openstreetmap/map-icons/tree/master/svg)
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| OSM map-icons | 这创建了一个OpenStreetMap图标集 | [https://github.com/openstreetmap/map-icons/tree/master/svg](https://github.com/openstreetmap/map-icons/tree/master/svg)
    |'
- en: '| opensreetmap-carto | Andy Allan created these set of mapping icons in PNG
    | [https://github.com/gravitystorm/openstreetmap-carto/tree/master/symbols](https://github.com/gravitystorm/openstreetmap-carto/tree/master/symbols)
    |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| opensreetmap-carto | 安迪·艾伦创建了这些PNG格式的地图图标集 | [https://github.com/gravitystorm/openstreetmap-carto/tree/master/symbols](https://github.com/gravitystorm/openstreetmap-carto/tree/master/symbols)
    |'
