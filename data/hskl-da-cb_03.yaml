- en: Chapter 3. The Science of Words
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：文字的科学
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下食谱：
- en: Displaying a number in another base
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以另一种进制显示数字
- en: Reading a number from another base
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从另一种进制读取数字
- en: Searching for a substring using Data.ByteString
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Data.ByteString查找子字符串
- en: Searching a string using the Boyer–Moore–Horspool algorithm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boyer–Moore–Horspool算法搜索字符串
- en: Searching a string using the Rabin-Karp algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rabin-Karp算法搜索字符串
- en: Splitting a string on lines, words, or arbitrary tokens
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按行、单词或任意标记拆分字符串
- en: Finding the longest common subsequence
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找最长公共子序列
- en: Computing a phonetic code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算语音编码
- en: Calculating the edit distance between two strings
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算两个字符串之间的编辑距离
- en: Computing the Jaro–Winkler distance between two strings
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算两个字符串之间的Jaro–Winkler距离
- en: Finding strings within one-edit distance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找一个编辑距离内的字符串
- en: Fixing spelling mistakes using edit distance
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编辑距离修正拼写错误
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '![Introduction](img/ch03.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/ch03.jpg)'
- en: Many interesting analysis techniques can be used on a large corpus of words.
    Whether it be examining the structure of a sentence or the content of a book,
    these recipes will introduce us to some useful tools.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在大量单词的语料库上使用许多有趣的分析技术。无论是分析句子的结构还是书籍的内容，这些食谱将为我们介绍一些有用的工具。
- en: When manipulating strings for data analysis, some of the most common functions
    are among substring search and edit distance computations. Since numbers are often
    found in a corpus of text, this chapter will start by showing how to represent
    numbers in an arbitrary base as a string. We will cover a couple of string-searching
    algorithms and then focus on extracting text to study not only the words but also
    how the words are used together.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行数据分析时，处理字符串的最常见函数之一是子字符串查找和编辑距离计算。由于数字通常出现在文本语料库中，本章将首先展示如何将数字表示为字符串，以任意进制显示。接着我们将介绍几种字符串搜索算法，并专注于提取文本，研究单词的使用方式以及它们如何组合在一起。
- en: Many practical applications can be constructed given the simple set of tools
    provided in this section. For example, in the last recipe, we will demonstrate
    a way to correct spelling mistakes. How we use these algorithms is entirely up
    to our creativity, but at least having them at our disposal is an excellent start.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 给定本节提供的一组简单工具，可以构建许多实际应用。例如，在最后一个食谱中，我们将演示如何纠正拼写错误。我们如何使用这些算法完全取决于我们的创造力，但至少有这些工具可用是一个很好的开始。
- en: Displaying a number in another base
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以另一种进制显示数字
- en: Strings are a natural way to represent numbers in different bases due to the
    inclusion of letters as digits. This recipe will tell us how to convert a number
    to a string that can be printed as output.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是表示不同进制数字的一种自然方式，因为字母被当作数字使用。本食谱将告诉我们如何将数字转换为一个字符串，并作为输出打印出来。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'We will need to import the following two functions:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导入以下两个函数：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Define a function to represent a number in a particular base as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，以表示某个进制的数字，定义如下：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define the mapping between numbers and letters for digits larger than nine
    as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义数字和字母之间的映射，用于表示大于九的数字，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Print out the result using the following code snippet:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段打印结果：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the printed output when running the code:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是运行代码时打印的输出：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `showIntAtBase` function takes in a base, the desired number, and its mapping
    from number to printable digit. We order our digits in the following manner: 0,
    1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, and so on, up to 36 characters. Putting
    it all together, we get a convenient way to represent a decimal number in any
    base.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`showIntAtBase`函数接收一个进制、期望的数字和数字到可打印数字的映射。我们按照以下顺序排列数字：0, 1, 2, 3, 4, 5, 6,
    7, 8, 9, a, b, c, d, e, f，依此类推，直到36个字符。将这些组合在一起，我们就得到了一个方便的方式，可以将十进制数字表示为任意进制。'
- en: See also
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: To read a string representing a number from another base as a decimal integer,
    refer to the *Reading a number from another base* recipe.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要将表示数字的字符串从另一种进制读取为十进制整数，请参阅*从另一种进制读取数字*食谱。
- en: Reading a number from another base
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从另一个进制读取数字
- en: Decimal, binary, and hexadecimal are widely used numeral systems that are often
    represented using a string. This recipe will show how to convert a string representation
    of a number in an arbitrary base to its decimal integer. We use the `readInt`
    function, which is the dual of the `showIntAtBase` function described in the previous
    recipe.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制、二进制和十六进制是广泛使用的数字系统，通常使用字符串表示。此方法将展示如何将任意进制的数字字符串转换为十进制整数。我们使用`readInt`函数，它是前一个方法中描述的`showIntAtBase`函数的双重。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Import `readInt` and the following functions for character manipulation as
    follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`readInt`以及以下的字符操作函数，如下所示：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define a function to convert a string representing a number in a particular
    base to a decimal integer as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，将表示某一特定进制的字符串转换为十进制整数，如下所示：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define the mapping between letters and numbers for larger digits, as shown
    in the following code snippet:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义字母和数字之间的映射关系，以处理较大的数字，如以下代码片段所示：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Print out the result using the following line of codes:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行输出结果：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The printed output is as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `readInt` function reads an unsigned integral value and converts it to
    the specified base. It takes in the base as the first argument, valid characters
    as the second argument, and its mapping from character to number as the third
    argument. We order our digits in the following order: 0, 1, 2, 3, 4, 5, 6, 7,
    8, 9, a, b, c, d, e, f, and so on up to 36 characters. Putting it all together,
    we get a convenient way to convert a string representation of a number in an arbitrary
    base to a decimal number.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`readInt`函数读取一个无符号整数值并将其转换为指定的进制。它的第一个参数是进制，第二个参数是有效字符，第三个参数是字符到数字的映射。我们将数字按以下顺序排列：0，1，2，3，4，5，6，7，8，9，a，b，c，d，e，f，依此类推，直到36个字符。把这些结合起来，我们就得到了一种方便的方法，可以将任意进制的数字字符串转换为十进制数字。'
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This recipe assumes that a valid string is passed into the `base` function for
    conversion. Further error checks are necessary to ensure that erroneous input
    such as `"a" 'base' 4` should not result in an answer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法假定传入`base`函数的字符串有效以进行转换。进一步的错误检查是必要的，以确保错误输入（如`"a" 'base' 4`）不会产生结果。
- en: See also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: To do the reverse, refer to the *Displaying a number in another base* recipe.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行反向操作，请参阅*在另一进制中显示数字*的方法。
- en: Searching for a substring using Data.ByteString
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Data.ByteString`搜索子字符串
- en: There are many algorithms to search for a string within another string. This
    recipe will use an existing `breakSubstring` function in the `Data.ByteString`
    library to do most of the heavy lifting.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索一个字符串在另一个字符串中的位置有很多算法。这个方法将使用`Data.ByteString`库中的现有`breakSubstring`函数来完成大部分繁重的工作。
- en: 'The `ByteString` documentation establishes its merits by declaring the following
    claim:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ByteString`文档通过声明以下内容来确立其优点：'
- en: '*"[A ByteString is] a time- and space-efficient implementation of byte vectors
    using packed Word8 arrays, suitable for high performance use, both in terms of
    large data quantities, or high speed requirements. Byte vectors are encoded as
    strict Word8 arrays of bytes, held in a ForeignPtr, and can be passed between
    C and Haskell with little effort."*'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"[ByteString是]一种高效的字节向量实现，使用打包的Word8数组，适用于高性能用途，无论是大数据量，还是高速要求。字节向量被编码为严格的Word8字节数组，保存在ForeignPtr中，并可以在C和Haskell之间轻松传递。"*'
- en: More information and documentation can be obtained on the package web page at
    [http://hackage.haskell.org/package/bytestring/docs/Data-ByteString.html](http://hackage.haskell.org/package/bytestring/docs/Data-ByteString.html).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息和文档可以在[http://hackage.haskell.org/package/bytestring/docs/Data-ByteString.html](http://hackage.haskell.org/package/bytestring/docs/Data-ByteString.html)的包网页上获取。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Import the `breakSubstring` function as well as the `Data.ByteString.Char8`
    package as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`breakSubstring`函数以及`Data.ByteString.Char8`包，如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Pack the strings as a `ByteString` and feed them into `breakSubstring` which
    has the following type: `ByteString -> ByteString -> (ByteString, ByteString)`.
    Then determine whether the string is found:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串打包为`ByteString`，并将其传递给`breakSubstring`，其类型为：`ByteString -> ByteString ->
    (ByteString, ByteString)`。然后确定是否找到该字符串：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Try out some tests in `main` as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`中尝试以下测试：
- en: '[PRE12]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Executing `main` will print out the following results:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`main`将输出以下结果：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `breakSubstring` function recursively checks if the pattern is a prefix
    of the string. To lazily find the first occurrence of a string, we can call `snd
    (breakSubstring pat str)`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`breakSubstring` 函数递归地检查模式是否是字符串的前缀。为了懒惰地查找字符串的首次出现，我们可以调用 `snd (breakSubstring
    pat str)`。'
- en: There's more...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Another elegant way to quickly find a substring is by using the `isInfixOf`
    function provided by both `Data.List` and `Data.ByteString`. Moreover, we can
    also use the `OverloadedStrings` language extension to remove verbiage, as shown
    in the following code snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种优雅的快速查找子字符串的方法是使用 `Data.List` 和 `Data.ByteString` 提供的 `isInfixOf` 函数。此外，我们还可以使用
    `OverloadedStrings` 语言扩展来去除冗余，如下所示的代码片段所示：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Depending on the length of the pattern we're trying to find and the length of
    the whole string itself, other algorithms may provide better performance. Refer
    to the *Searching a string using the Boyer-Moore-Horspool algorithm* and *Searching
    a string using the Rabin-Karp algorithm* recipes for more details.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们要查找的模式的长度和整个字符串的长度，其他算法可能提供更好的性能。有关更多细节，请参阅 *使用 Boyer-Moore-Horspool 算法搜索字符串*
    和 *使用 Rabin-Karp 算法搜索字符串* 的食谱。
- en: Searching a string using the Boyer-Moore-Horspool algorithm
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Boyer-Moore-Horspool 算法搜索字符串
- en: 'When searching for a pattern in a string, we refer to the pattern as the **needle**
    and the whole corpus as the **haystack**. The Horspool string search algorithm
    implemented in this recipe performs well for almost all pattern lengths and alphabet
    sizes, but is ideal for large alphabet sizes and large needle sizes. Empirical
    benchmarks can be found by navigating to the following URL:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串中查找模式时，我们将模式称为 **针**，将整个文本称为 **干草堆**。本食谱中实现的 Horspool 字符串搜索算法对于几乎所有模式长度和字母表大小都表现良好，但对于大字母表大小和大针模式尺寸尤为理想。可以通过访问以下
    URL 查找到经验基准：
- en: '[http://orion.lcg.ufrj.br/Dr.Dobbs/books/book5/chap10.htm](http://orion.lcg.ufrj.br/Dr.Dobbs/books/book5/chap10.htm)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://orion.lcg.ufrj.br/Dr.Dobbs/books/book5/chap10.htm](http://orion.lcg.ufrj.br/Dr.Dobbs/books/book5/chap10.htm)'
- en: By preprocessing the query, the algorithm is able to efficiently skip redundant
    comparisons. In this recipe, we will implement a simplified version called Horspool's
    algorithm, which achieves the same average best case as the Boyer-Moore algorithm,
    benefits from having a smaller overhead cost, but may in very rare circumstances
    suffer the same worst-case running time as the naive search when the algorithm
    performs too many matches. The Boyer-Moore algorithms should only be used if the
    extra prepossessing time and space required are acceptable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对查询进行预处理，该算法能够有效地跳过冗余的比较。在本食谱中，我们将实现一个简化版的 Horspool 算法，它在平均最佳情况下与 Boyer-Moore
    算法相同，且由于开销较小，受益于更小的开销成本，但在极少数情况下，算法执行过多匹配时，可能会遇到与朴素搜索相同的最坏运行时间。只有在接受额外的预处理时间和空间时，才应使用
    Boyer-Moore 算法。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'We will be using a couple `Data.Map` functions as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用以下几个 `Data.Map` 函数：
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For convenience, define tuples representing character indices as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便，按如下方式定义表示字符索引的元组：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define the search algorithm to use the recursive `bmh''` function as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义搜索算法，使用递归的 `bmh'` 函数如下：
- en: '[PRE17]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Recursively find the pattern in the current index until the index moves past
    the length of the string, as shown in the following code snippet:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归地在当前索引中查找模式，直到索引超过字符串的长度，如下代码片段所示：
- en: '[PRE18]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Test out the function as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式测试该函数：
- en: '[PRE19]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following printed output displays the first index of the matching substring:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下打印输出显示匹配子字符串的第一个索引：
- en: '[PRE20]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: This algorithm compares the desired pattern to a moving window through the text.
    The efficiency comes from how quickly the moving window shifts left to right through
    this text. In the Horspool algorithm, the query is compared to the current window
    character by character from right to left, and the window shifts by the size of
    the query in the best case.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法通过一个移动窗口将目标模式与文本进行比较。效率来自于移动窗口如何快速地从左到右在文本中移动。在 Horspool 算法中，查询会从右到左逐个字符与当前窗口进行比较，且窗口在最佳情况下按查询的大小进行移动。
- en: Another version of the Horspool algorithm designed by Remco Niemeijer can be
    found at [http://bonsaicode.wordpress.com/2009/08/29/programming-praxis-string-search-boyer-moore](http://bonsaicode.wordpress.com/2009/08/29/programming-praxis-string-search-boyer-moore).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一版本的Horspool算法，由Remco Niemeijer设计，可以在[http://bonsaicode.wordpress.com/2009/08/29/programming-praxis-string-search-boyer-moore](http://bonsaicode.wordpress.com/2009/08/29/programming-praxis-string-search-boyer-moore)找到。
- en: There's more...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The Boyer-Moore algorithm ensures a faster worst case, but also endures slightly
    more initial overhead. Refer to the following commands to use the Boyer-Moore
    algorithm from the `Data.ByteString.Search` package:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Boyer-Moore算法确保在最坏情况下运行更快，但也会有稍微多一些的初始开销。请参考以下命令，使用`Data.ByteString.Search`包中的Boyer-Moore算法：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Import the following libraries:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 导入以下库：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Feed two `ByteString` types to the `indices` function to run the search as
    follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 向`indices`函数提供两个`ByteString`类型来运行搜索，方法如下：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will print out the following indices:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出以下索引：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'By benchmarking the performance of this library, we can see that longer search
    needles really improve runtime. We modify the code to search through a huge corpus
    of words from a file called `big.txt` to find multiple needles. Here, we use the
    `deepseq` function to force evaluation, so Haskell''s lazy nature won''t ignore
    it, as shown in the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过基准测试这个库的性能，我们可以看到较长的搜索针确实能提高运行时间。我们修改代码，通过一个名为`big.txt`的文件在巨大的单词语料库中搜索多个针。这里，我们使用`deepseq`函数强制评估，这样Haskell的惰性特性就不会忽略它，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can compile this code with special runtime system (RTS) control for easy
    profiling as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用特别的运行时系统（RTS）控制编译这段代码，以便轻松进行性能分析，方法如下：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We use the text from `norvig.com/big.txt` as our corpus. Searching for 25 long
    needles takes just about 0.06 seconds; however, searching for 25 short needles
    takes a sluggish 0.19 seconds.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用来自`norvig.com/big.txt`的文本作为我们的语料库。搜索25个长针大约需要0.06秒；然而，搜索25个短针则需要较慢的0.19秒。
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: For another efficient string searching algorithm, refer to the *Searching a
    string using the Rabin-Karp algorithm* recipe.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解另一种高效的字符串搜索算法，请参考*使用Rabin-Karp算法搜索字符串*的示例。
- en: Searching a string using the Rabin-Karp algorithm
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Rabin-Karp算法搜索字符串
- en: The Rabin-Karp algorithm finds a pattern in a body of text by matching a unique
    representation of the pattern against a moving window. The unique representation,
    or hash, is computed by considering a string as a number written in an arbitrary
    base of 26 or greater.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Rabin-Karp算法通过将模式的唯一表示与一个滑动窗口进行匹配，来在文本中查找模式。这个唯一表示或哈希值是通过将字符串视为一个数字，并用26或更大的任意进制表示来计算的。
- en: The advantage of Rabin-Karp is in searching for many needles in a haystack.
    It's not very efficient to search for just a single string. After the initial
    preprocessing of the corpus, the algorithm can quickly find matches.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Rabin-Karp的优势在于可以在干草堆中搜索多个针。仅搜索一个字符串效率并不高。经过初步的语料库预处理后，算法可以快速找到匹配项。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Install the `Data.ByteString.Search` library from Cabal as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从Cabal安装`Data.ByteString.Search`库，方法如下：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use the `OverloadedStrings` language extension to facilitate the `ByteString`
    manipulations in our code as follows. It essentially allows polymorphic behavior
    for strings so that the GHC compiler may infer it as a `ByteString` type when
    necessary:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`OverloadedStrings`语言扩展来便于我们代码中的`ByteString`操作，方法如下。它本质上允许字符串具有多态行为，因此当需要时，GHC编译器可以推断它为`ByteString`类型：
- en: '[PRE28]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Import the Rabin-Karp algorithms as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入Rabin-Karp算法，方法如下：
- en: '[PRE29]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define a couple of patterns to find and obtain the corpus from a `big.txt`
    file, as shown in the following code snippet:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义几个要查找的模式，并从`big.txt`文件中获取语料库，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the Rabin-Karp algorithm on all the search patterns as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Rabin-Karp算法，处理所有的搜索模式，方法如下：
- en: '[PRE31]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The code prints out all indices found for each needle as a list of tuples. The
    first element of the tuple is the position in the haystack that the needle was
    found. The second element of the tuple is a list of indices of the needles. In
    our recipe, we find one instance of "preparing to go away" and two instances of
    "is some letter of recommendation."
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将打印出每个针的所有索引，作为一个元组列表。元组的第一个元素是针在干草堆中的位置，第二个元素是针的索引列表。在我们的示例中，我们找到了“准备离开”的一个实例和“某封推荐信”的两个实例。
- en: '[PRE32]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In Rabin-Karp, a fixed window moves from left to right, comparing the unique
    hash values for efficient comparisons. The hash function converts a string to
    its numerical representation. Here''s an example of converting a string into base
    b equal to 256: *"hello" = h'' * b⁴ + e'' * b³ + l'' * b² + l'' * b¹ + o'' * b⁰*
    (which results in 448378203247), where each letter `h'' = ord h` (which results
    in 104), and so on.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rabin-Karp算法中，一个固定窗口从左到右移动，比较唯一的哈希值，以便高效比较。哈希函数将字符串转换为其数字表示。以下是将字符串转换为以256为底的数字的示例：*"hello"
    = h' * b⁴ + e' * b³ + l' * b² + l' * b¹ + o' * b⁰*（结果为448378203247），其中每个字母`h'
    = ord h`（结果为104），以此类推。
- en: See also
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: To see another efficient string searching algorithm, refer to the *Searching
    a string using the Boyer-Moore-Horspool algorithm* recipe.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解另一种高效的字符串搜索算法，请参见*使用Boyer-Moore-Horspool算法搜索字符串*的相关配方。
- en: Splitting a string on lines, words, or arbitrary tokens
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按行、按单词或按任意标记拆分字符串
- en: Useful data is often interspersed between delimiters, such as commas or spaces,
    making string splitting vital for most data analysis tasks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的数据通常被分隔符（如逗号或空格）夹杂其中，因此字符串拆分对于大多数数据分析任务至关重要。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Create an `input.txt` file similar to the following one:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类似下面的`input.txt`文件：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Install the `split` package using Cabal as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cabal按照如下方式安装`split`包：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The only function we will need is `splitOn`, which is imported as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们所需要的唯一函数是`splitOn`，它按如下方式导入：
- en: '[PRE35]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'First we split the string into lines, as shown in the following code snippet:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将字符串拆分成行，代码示例如下：
- en: '[PRE36]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The lines are printed in a list as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些行将按如下方式以列表形式打印：
- en: '[PRE37]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we separate a string on spaces as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们按照如下方式在空格处拆分字符串：
- en: '[PRE38]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The words are printed in a list as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单词将按如下方式以列表形式打印：
- en: '[PRE39]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we show how to split a string on an arbitrary value using the following
    lines of code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们展示如何使用以下代码行在任意值上拆分字符串：
- en: '[PRE40]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The values are split on the commas as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些值将按逗号分隔，具体如下：
- en: '[PRE41]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we show splitting on multiple letters as shown in the following code
    snippet:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们展示如何按照如下代码片段进行多字母拆分：
- en: '[PRE42]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE43]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finding the longest common subsequence
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找最长公共子序列
- en: One way to compare string similarity is by finding their longest common subsequence.
    This is useful in finding differences between mutations of data such as source
    code or genome sequences.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 比较字符串相似性的一种方法是找出它们的最长公共子序列。这在查找数据变异之间的差异时非常有用，例如源代码或基因组序列。
- en: 'A subsequence of a string is the same string with zero or more of the indices
    removed. So, some possible subsequences of "BITCOIN" could be "ITCOIN", "TON",
    "BIN", or even "BITCOIN" itself, as shown in the following figure:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的子序列是从原字符串中删除零个或多个索引后的字符串。因此，“BITCOIN”的一些可能子序列可以是“ITCOIN”，“TON”，“BIN”，甚至是“BITCOIN”本身，如下图所示：
- en: '![Finding the longest common subsequence](img/6331OS_03_01.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![查找最长公共子序列](img/6331OS_03_01.jpg)'
- en: The longest common subsequence is exactly what it sounds like. It is the longest
    subsequence common to both strings. For example, the longest common subsequence
    of "find the lights" and "there are four lights" is "the lights."
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最长公共子序列正如其名，是指两个字符串中最长的公共子序列。例如，"find the lights"和"there are four lights"的最长公共子序列是"the
    lights"。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Install the `data-memocombinators` package from Cabal. This allows us to minimize
    redundant computations to improve runtime as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从Cabal安装`data-memocombinators`包。这个包可以帮助我们最小化冗余计算，从而提升运行时效率，具体如下：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The only import we will need is this handy package to easily support memoization:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要的唯一导入包是这个方便的包，用于轻松支持记忆化：
- en: '[PRE45]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a convenience function to enable memoization of functions that take
    in two string arguments, as shown in the following code snippet:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方便的函数，以便对接收两个字符串参数的函数进行记忆化处理，代码示例如下：
- en: '[PRE46]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Define the largest common subsequence function as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义最大公共子序列函数，如下所示：
- en: '[PRE47]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Internally, define a function that returns the longer length string.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内部，定义一个返回较长字符串长度的函数。
- en: '[PRE48]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Run the function on two strings as follows.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照如下方式在两个字符串上运行该函数。
- en: '[PRE49]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following is the longest common subsequence between the two strings:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是两个字符串之间的最长公共子序列：
- en: '[PRE50]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The algorithm is implemented naively, with memoization added to the recursive
    calls. If the first two items of a list are the same, then the longest common
    subsequence is the `lcs` function applied to the remaining parts of the list.
    Otherwise, the longest common subsequence is the longer of the two possibilities.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法是初步实现的，已在递归调用中添加了记忆化。如果列表的前两个项相同，则最长公共子序列是对列表剩余部分应用的`lcs`函数。否则，最长公共子序列是两个可能性中较长的一个。
- en: Naively, this algorithm will stall when given two strings as small as 10 characters
    each. Since the code breaks down to multiple identical subproblems, we can easily
    use a simple `memoize` function that remembers already computed values, improving
    the runtime dramatically.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地说，当两个字符串的长度仅为10个字符时，这个算法会停滞不前。由于该代码分解为多个相同的子问题，我们可以轻松使用一个简单的`memoize`函数来记住已经计算过的值，从而大幅提高运行时间。
- en: Computing a phonetic code
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算语音编码
- en: If we're dealing with a corpus of English words, then we can categorize them
    into phonetic codes to see how similar they sound. Phonetic codes work for any
    alphabetical strings, not just actual words. We will use the `Text.PhoneticCode`
    package to compute the Soundex and Phoneix phonetic codes. The package documentation
    can be found on Hackage at [http://hackage.haskell.org/package/phonetic-code](http://hackage.haskell.org/package/phonetic-code).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的是英语单词的语料库，那么我们可以将它们按语音编码进行分类，以查看它们的发音有多相似。语音编码适用于任何字母字符串，而不仅仅是实际的单词。我们将使用`Text.PhoneticCode`包来计算Soundex和Phoneix语音编码。包文档可以在Hackage上找到，网址是[http://hackage.haskell.org/package/phonetic-code](http://hackage.haskell.org/package/phonetic-code)。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the phonetic code library from Cabal as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式从Cabal安装语音编码库：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Import the phonetic code functions as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式导入语音编码函数：
- en: '[PRE52]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Define a list of similar-sounding words as follows:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式定义一个相似发音的单词列表：
- en: '[PRE53]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Test out the phonetic codes on these words, as shown in the following code
    snippet:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码片段测试这些单词的语音编码：
- en: '[PRE54]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output will be printed as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将按以下方式打印：
- en: '[PRE55]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Notice how `phonix` produces a finer categorization than `soundex`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`phonix`如何比`soundex`产生更精细的分类。
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The algorithms perform simple string manipulations based on heuristic English-language-dependent
    patterns.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 算法基于启发式的英语语言相关模式执行简单的字符串操作。
- en: There's more...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Metaphone is an improvement over the Soundex algorithm and can be found at [http://aspell.net/metaphone](http://aspell.net/metaphone).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Metaphone算法是Soundex算法的改进版，您可以在[http://aspell.net/metaphone](http://aspell.net/metaphone)找到它。
- en: Computing the edit distance
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算编辑距离
- en: The edit distance or Levenshtein distance is the minimum number of simple string
    operations required to convert one string into another. In this recipe, we will
    compute the edit distance based on only insertions, deletions, and substitutions
    of characters.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑距离或Levenshtein距离是将一个字符串转换为另一个字符串所需的最少简单字符串操作次数。在这个方案中，我们将只基于字符的插入、删除和替换来计算编辑距离。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Review the equation shown in the following figure obtained from the Wikipedia
    article about the Levenshtein distance ([http://en.wikipedia.org/wiki/Levenshtein_distance](http://en.wikipedia.org/wiki/Levenshtein_distance)):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下图中的方程，该方程来自维基百科关于Levenshtein距离的文章（[http://en.wikipedia.org/wiki/Levenshtein_distance](http://en.wikipedia.org/wiki/Levenshtein_distance)）：
- en: '![Getting ready](img/6331OS_03_02.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6331OS_03_02.jpg)'
- en: Here, *a* and *b* are the two strings, and i and j are numbers representing
    their lengths.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*a*和*b*是两个字符串，而i和j是表示它们长度的数字。
- en: The Haskell code will be a direct translation of this mathematical formula.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell代码将直接翻译为这个数学公式。
- en: Also, install the `data-memocombinators` package from Cabal. This allows us
    to minimize redundant computations to improve runtime.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，从Cabal安装`data-memocombinators`包。这可以帮助我们减少冗余计算，从而提升运行时间。
- en: '[PRE56]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The only import we will need is the ability to easily memoize functions using
    the following line of code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要的唯一导入是能够轻松地使用以下代码行对函数进行记忆化：
- en: '[PRE57]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Define the Levenshtein distance function exactly as described in the formula
    using the following code snippet:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段精确地定义Levenshtein距离函数，正如公式中所描述的那样：
- en: '[PRE58]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Define the indicator function that returns 1 if the characters don't match.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个指示函数，如果字符不匹配则返回1。
- en: '[PRE59]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a convenience function to enable memoization of functions that take
    in two string arguments:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个便利函数，用于启用对接受两个字符串参数的函数进行记忆化：
- en: '[PRE60]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Print out the edit distance between two strings:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出两个字符串之间的编辑距离：
- en: '[PRE61]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The result is as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE62]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This algorithm recursively tries all deletions, insertions, and substitutions
    and finds the minimum distance from one string to another.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法递归地尝试所有的删除、插入和替换，并找到从一个字符串到另一个字符串的最小距离。
- en: See also
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Another measurement is described in the *Computing the Jaro-Winkler distance
    between two strings* recipe.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种衡量方法在 *计算两个字符串之间的 Jaro-Winkler 距离* 食谱中有所描述。
- en: Computing the Jaro-Winkler distance between two strings
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算两个字符串之间的 Jaro-Winkler 距离
- en: The Jaro-Winkler distance measures string similarity represented as a real number
    between 0 and 1\. The value 0 corresponds to no similarity, and 1 corresponds
    to an identical match.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Jaro-Winkler 距离衡量字符串相似度，表示为一个介于 0 和 1 之间的实数。值为 0 表示没有相似性，值为 1 表示完全匹配。
- en: Getting ready
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The algorithm behind the function comes from the following mathematical formula
    presented in the Wikipedia article about the Jaro-Winkler distance [http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance](http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数背后的算法来源于 Wikipedia 上关于 Jaro-Winkler 距离的文章中展示的以下数学公式：[http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance](http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance)：
- en: '![Getting ready](img/6331OS_03_03.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6331OS_03_03.jpg)'
- en: 'In the preceding formula, the following are the representations of the variables
    used:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的公式中，以下是所使用变量的表示形式：
- en: '*s1* is the first string.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*s1* 是第一个字符串。'
- en: '*s2* is the second string.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*s2* 是第二个字符串。'
- en: '*m* is the number of identical characters within a distance of at the most
    half the length of the longer string. These are called matching characters.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*m* 是在最大为较长字符串一半的距离内匹配的字符数量。这些称为匹配字符。'
- en: '*t* is half the number of matching characters that are not in the same index.
    In other words, it is half the number of transpositions.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t* 是不在同一索引处的匹配字符的一半。换句话说，它是交换位置的字符数的一半。'
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We will need access to the `elemIndices` function, which is imported as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要访问 `elemIndices` 函数，它被如下导入：
- en: '[PRE63]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Define the Jaro-Winkler function based on the following formula:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于以下公式定义 Jaro-Winkler 函数：
- en: '[PRE64]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Define the variables used, as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义所使用的变量，如下所示：
- en: '[PRE65]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Define a helper function to convert an integer to `Double` type:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个辅助函数，将整数转换为 `Double` 类型：
- en: '[PRE66]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Define a helper function to find the number of matching characters within a
    specified distance, as shown in the following code snippet:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个辅助函数，用于查找在指定距离内匹配的字符数量，如下所示的代码片段：
- en: '[PRE67]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Define a helper function to find the number of matching characters from a specific
    character at a specified index as follows.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个辅助函数，用于查找从指定索引处某个字符开始的匹配字符数量，如下所示：
- en: '[PRE68]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Test out the algorithm by printing out a couple of examples as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打印出一些示例来测试算法，如下所示：
- en: '[PRE69]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The similarities are printed out as such, implying "marisa" is closer to "magical"
    than "haskell" is to "hackage".
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相似度按如下方式打印，意味着 "marisa" 更接近 "magical" 而不是 "haskell" 接近 "hackage"。
- en: '[PRE70]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: See also
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Another way to compute string similarity is defined in the previous recipe entitled
    *Computing the Edit Distance*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种计算字符串相似度的方法，在之前的食谱 *计算编辑距离* 中有定义。
- en: Finding strings within one-edit distance
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找一个编辑距离内的字符串
- en: This recipe will demonstrate how to find strings that are one-edit distance
    away from a specified string. This function can be used to correct spelling.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将展示如何查找与指定字符串具有一个编辑距离的字符串。该函数可用于纠正拼写。
- en: Getting ready
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The algorithm in this recipe is based heavily on Peter Norvig's spell corrector
    algorithm described at [http://norvig.com/spell-correct.html](http://norvig.com/spell-correct.html).
    Take a look at and study the `edits1` Python function implemented there.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的算法在很大程度上基于 Peter Norvig 在 [http://norvig.com/spell-correct.html](http://norvig.com/spell-correct.html)
    上描述的拼写更正算法。查看并研究那里实现的 `edits1` Python 函数。
- en: How to do it...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Import a couple of character and list functions as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入如下所示的几个字符和列表函数：
- en: '[PRE71]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Define a function to return strings that are one-edit distance away, as shown
    in the following code snippet:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，用于返回与指定字符串只有一个编辑距离的字符串，如下所示的代码片段：
- en: '[PRE72]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Create a list of strings with one character deleted, as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个删除一个字符的字符串列表，如下所示：
- en: '[PRE73]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create a list of strings with two characters swapped, as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个交换两个字符的字符串列表，如下所示：
- en: '[PRE74]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Create a list of strings with one of the characters replaced by another letter
    in the alphabet, as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个字符串列表，其中一个字符被字母表中的另一个字母替换，如下所示：
- en: '[PRE75]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create a list of strings with one character inserted anywhere, as follows:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个字符串列表，其中一个字符在任何位置被插入，如下所示：
- en: '[PRE76]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Define the alphabet and a helper function to convert a string to lowercase
    as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义字母表和一个辅助函数将字符串转换为小写，如下所示：
- en: '[PRE77]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Define a helper function to obtain unique elements from a list, as follows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个辅助函数从列表中获取唯一元素，如下所示：
- en: '[PRE78]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Print out all possible strings that are one-edit distance away from the following
    string, as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出所有与以下字符串编辑距离为一的可能字符串，如下所示：
- en: '[PRE79]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The result is, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE80]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'More intuitively, we''ve created a neighborhood of words that are different
    by only 1 insertion, deletion, or substitution, or transpositions. The following
    figure tries to show this neighborhood:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 更直观地，我们创建了一个仅通过1次插入、删除、替换或交换不同的单词邻域。以下图试图展示这个邻域：
- en: '![How to do it...](img/6331OS_03_04.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/6331OS_03_04.jpg)'
- en: There's more...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can recursively apply `edit1` to find strings that are an arbitrary edit
    distance away. However, for values of *n* greater than three, this will take an
    unacceptably long time. In the following code, `edits1` `''` is a function that
    takes in a list of strings and produces all strings that are one-edit distance
    away from these. Then in `editsN`, we simply apply the `edits1''` function iteratively
    as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以递归地应用`edit1`来查找任意编辑距离的字符串。然而，对于* n *大于三的值，这将需要不可接受的长时间。在以下代码中，`edits1` `'`是一个函数，它接收字符串列表并生成所有编辑距离为一的字符串。然后在`editsN`中，我们简单地按如下方式迭代应用`edits1'`函数：
- en: '[PRE81]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: See also
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: This function is very useful in implementing a spell corrector described in
    the *Fixing spelling mistakes* recipe.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在实现*修正拼写错误*方法中非常有用。
- en: Fixing spelling mistakes
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修正拼写错误
- en: When gathering human-provided data, spelling mistakes may sneak in. This recipe
    will correct a misspelled word using Peter Norvig's simple heuristic spellchecker
    described at [http://norvig.com/spell-correct.html](http://norvig.com/spell-correct.html).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当收集人工提供的数据时，拼写错误可能悄悄进入。这个方法会使用Peter Norvig描述的简单启发式拼写检查器来纠正拼写错误，详情见[http://norvig.com/spell-correct.html](http://norvig.com/spell-correct.html)。
- en: This recipe is just one approach to a very difficult problem in machine learning.
    We can use it as a starting point or as an influence to implement a more powerful
    solution with better results.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只是机器学习中解决一个非常困难问题的一个思路。我们可以将其作为起点，或作为灵感去实现一个更强大的解决方案，取得更好的结果。
- en: Getting ready
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Refer to Norvig's spell-correction Python algorithm located at [http://norvig.com/spell-correct.html](http://norvig.com/spell-correct.html).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考Norvig的拼写纠正Python算法，位置在[http://norvig.com/spell-correct.html](http://norvig.com/spell-correct.html)。
- en: 'The core algorithm works as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 核心算法如下所示：
- en: Transform raw text into lowercase alphabetical words
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原始文本转换为小写字母单词
- en: Compute a frequency map of all the words
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算所有单词的频率图
- en: Define functions to produce all strings within an edit distance of one or two
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义函数来生成所有编辑距离为一或二的字符串
- en: Find all possible candidates of a misspelling by looking up valid words within
    this edit distance of one or two
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找拼写错误的所有可能候选项，通过查找在编辑距离为一或二以内的有效单词
- en: Finally, pick out the candidate with the highest frequency of occurrence in
    the trained corpus
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，挑选出在训练语料库中出现频率最高的候选项
- en: The Haskell algorithm below mimics this Python code.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Haskell算法模仿了这段Python代码。
- en: How to do it...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Import the following functions:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下函数：
- en: '[PRE82]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Define a function to automatically correct the spelling of each word in a sentence:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来自动修正句子中每个单词的拼写：
- en: '[PRE83]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Get the words from a body of text.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一段文本中提取单词。
- en: '[PRE84]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Compute a frequency map of the words provided, as follows:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算所提供单词的频率图，如下所示：
- en: '[PRE85]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Find strings one-edit distance away as follows:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找编辑距离为一的字符串，如下所示：
- en: '[PRE86]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Find words that are apart by an edit distance of two:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找编辑距离为二的单词：
- en: '[PRE87]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Define a helper function to obtain unique elements from a list, as follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个辅助函数从列表中获取唯一元素，如下所示：
- en: '[PRE88]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Find known words from a list of strings as follows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串列表中查找已知单词，如下所示：
- en: '[PRE89]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Correct a spelling mistake by returning the most common candidate as follows:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过返回最常见的候选项来纠正拼写错误，如下所示：
- en: '[PRE90]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Gather a list of known words used in common literature from `big.txt`. The
    file is available at [http://norvig.com/big.txt](http://norvig.com/big.txt), or
    we can make our own. Test out the spell corrector as follows:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`big.txt`中收集常见文学作品中使用的已知单词列表。该文件可通过[http://norvig.com/big.txt](http://norvig.com/big.txt)访问，或者我们也可以自己创建。然后，按照以下方式测试拼写校正器：
- en: '[PRE91]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The correct spellings are printed out as follows:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确的拼写将如下所示：
- en: '[PRE92]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: How it works...
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The algorithm assumes that spelling mistakes occur one- or two-edit distances
    away. It establishes a list of known words within one- or two-edit distances and
    returns the most commonly used word based on the frequency map generated by reading
    in a corpus of real-world text.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法假设拼写错误发生在一个或两个编辑距离之内。它建立了一个已知单词的列表，该列表包含一个或两个编辑距离内的单词，并根据通过读取现实世界文本语料库生成的频率图返回最常用的单词。
- en: There's more...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: This algorithm runs quickly, but it is very simplistic. This recipe provides
    a starting point to implement a spell corrector, but is certainly not state of
    the art. Some improvements that can be added to the code could involve parallelizing,
    caching, or designing better heuristics.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法运行速度很快，但它非常简单。这段代码为实现拼写校正器提供了一个起点，但绝对不是最先进的技术。可以添加的一些改进包括并行化、缓存或设计更好的启发式方法。
- en: See also
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: For more in-depth analysis about the `edit1` function, refer to the *Finding
    strings within one-edit distance* recipe.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更深入分析`edit1`函数，请参考*在一个编辑距离内查找字符串*的配方。
