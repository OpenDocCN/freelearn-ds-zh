- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Structuring Messy Data to Work Well in Tableau
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将混乱数据结构化以便与 Tableau 配合使用
- en: So far, most of the examples we've looked at in this book assume that data is
    structured well and is fairly clean. Data in the real world isn't always so pretty.
    Maybe it's messy or it doesn't have a good structure. It may be missing values
    or have duplicate values, or it might have the wrong level of detail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中的大多数示例假设数据结构良好且相对干净。现实世界中的数据并不总是如此完美。也许它很混乱，或者没有良好的结构。它可能缺失值或有重复值，或者可能具有错误的详细程度。
- en: How can you deal with this type of messy data? In the previous chapter, we considered
    how Tableau's data model can be used to relate data in different tables. We will
    consider Tableau Prep Builder as a robust way to clean and structure data in the
    next chapter. Much of the information in this chapter will be an essential foundation
    for working with Tableau Prep.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如何处理这种类型的混乱数据？在上一章中，我们考虑了如何使用 Tableau 的数据模型来关联不同表中的数据。在下一章中，我们将考虑将 Tableau Prep
    Builder 作为清理和结构化数据的有效方法。本章中的许多信息将为你使用 Tableau Prep 提供必要的基础。
- en: For now, let's focus on some of the basic data structures that work well in
    Tableau and some of the additional techniques you can use to get data into those
    structures. We'll keep our discussion limited to native Tableau features in this
    chapter, but much of what you learn will apply to Tableau Prep in the next. By
    the end of this chapter, you'll have a solid foundation of understanding what
    constitutes a good data structure. Knowing which data structures work well with
    Tableau is key to understanding how you will be able to resolve certain issues.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们关注一些在 Tableau 中效果良好的基本数据结构，以及你可以使用的一些额外技术，将数据转换为这些结构。在本章中，我们将讨论 Tableau
    的本地功能，但你学到的许多内容将在下一章的 Tableau Prep 中应用。到本章结束时，你将对什么构成良好的数据结构有一个坚实的基础。了解哪些数据结构与
    Tableau 配合良好是解决某些问题的关键。
- en: 'In this chapter, we''ll focus on some principles for structuring data to work
    well with Tableau, as well as some specific examples of how to address common
    data issues. This chapter will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点讨论一些有助于与 Tableau 配合良好的数据结构原则，以及如何解决常见数据问题的具体示例。本章将涵盖以下主题：
- en: Structuring data for Tableau
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Tableau 结构化数据
- en: The four basic data transformations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四种基本的数据转换
- en: Overview of advanced fixes for data problems
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据问题的高级修复概述
- en: We'll start by discussing which data structures work well for Tableau.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论哪些数据结构在 Tableau 中效果较好。
- en: Structuring data for Tableau
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Tableau 结构化数据
- en: We've already seen that Tableau can connect to nearly any data source. Whether
    it's a built-in direct connection, **Open Database Connectivity** (**ODBC**),
    or the use of the Tableau data extract API to generate an extract, no data is
    off limits. However, there are certain structures that make data easier to work
    with in Tableau.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，Tableau 可以连接几乎所有数据源。无论是内置的直接连接、**开放数据库连接**（**ODBC**），还是使用 Tableau 数据提取
    API 生成提取，数据都没有限制。然而，某些结构使得数据在 Tableau 中更容易使用。
- en: 'There are two keys to ensure a good data structure that works well with Tableau:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 确保良好数据结构的两个关键要素是：
- en: Every record of a source data connection should be at a meaningful level of detail
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个源数据连接的记录应处于有意义的详细程度
- en: Every measure contained in the source should match the level of detail of the data
    source or possibly be at a higher level of detail, but it should never be at a
    lower level of detail
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据源中包含的每个度量值应与数据源的详细程度匹配，或者可能处于更高的详细程度，但绝不应处于较低的详细程度。
- en: 'For example, let''s say you have a table of test scores with one record per
    classroom in a school. Within the record, you may have three measures: the average
    GPA for the classroom, the number of students in the class, and the average GPA
    of the school:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一张记录每个班级的测试成绩的表格，每条记录代表一个学校中的一个教室。在记录中，你可能会有三个度量值：该教室的平均 GPA、班级中的学生人数以及学校的平均
    GPA：
- en: '| **School** | **Classroom** | **Average GPA** | **Number of Students** | **Number
    of Students (School)** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **学校** | **教室** | **平均 GPA** | **学生人数** | **学校的学生人数** |'
- en: '| Pickaway Elementary | 4^(th) Grade | 3.78 | 153 | 1,038 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Pickaway 小学 | 4年级 | 3.78 | 153 | 1,038 |'
- en: '| Pickaway Elementary | 5^(th) Grade | 3.73 | 227 | 1,038 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Pickaway 小学 | 5年级 | 3.73 | 227 | 1,038 |'
- en: '| Pickaway Elementary | 6^(th) Grade | 3.84 | 227 | 1,038 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| Pickaway 小学 | 6年级 | 3.84 | 227 | 1,038 |'
- en: '| McCord Elementary | 4^(th) Grade | 3.82 | 94 | 915 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| McCord 小学 | 4年级 | 3.82 | 94 | 915 |'
- en: '| McCord Elementary | 5^(th) Grade | 3.77 | 89 | 915 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| McCord 小学 | 5^(年级) | 3.77 | 89 | 915 |'
- en: '| McCord Elementary | 6^(th) Grade | 3.84 | 122 | 915 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| McCord 小学 | 6^(年级) | 3.84 | 122 | 915 |'
- en: The first two measures (**Average GPA** and **Number of Students**) are at the
    same level of detail as the individual record of data (per classroom in the school).
    **Number of Students (School)** is at a higher level of detail (per school). As
    long as you are aware of this, you can do a careful analysis. However, you would
    have a data structure issue if you tried to store each student's GPA in the class
    record. If the data was structured in an attempt to store all of the students'
    GPAs per grade level (maybe with a column for each student or a single field containing
    a comma-separated list of student scores), we'd need to do some work to make the
    data more usable in Tableau.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个度量（**平均GPA**和**学生数量**）与数据的单个记录处于相同的详细级别（每个班级的记录）。**学生数量（学校）**则处于更高的详细级别（每个学校）。只要你意识到这一点，你就可以进行仔细的分析。然而，如果你尝试将每个学生的GPA存储在班级记录中，就会遇到数据结构问题。如果数据结构尝试存储每个年级的所有学生GPA（也许每个学生有一列，或者有一个字段包含一个以逗号分隔的学生成绩列表），那么我们需要做一些工作，以便让数据在Tableau中更易于使用。
- en: 'Understanding the level of detail of the source (often referred to as **granularity**)
    is vital. Every time you connect to a data source, the very first question you
    should ask and answer is: what does a single record represent? If, for example,
    you were to drag and drop the `Number of Records` (or the `Table (Count)` field
    in Tableau 2020.2 and later) field into the view and observed 1,000 records, then
    you should be able to complete the statement, `I have 1,000 _____.` It could be
    1,000 students, 1,000 test scores, or 1,000 schools. Having a good grasp of the
    granularity of the data will help you to avoid poor analysis and allow you to
    determine if you even have the data that''s necessary for your analysis.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 理解源数据的详细级别（通常称为**粒度**）至关重要。每次连接到数据源时，你应该问并回答的第一个问题是：一条记录代表什么？例如，如果你将`记录数量`（或在Tableau
    2020.2及更高版本中的`表格（计数）`字段）字段拖放到视图中并观察到1,000条记录，那么你应该能够完成这个陈述，`我有1,000个_____`。它可以是1,000个学生、1,000个考试成绩，或者1,000所学校。对数据粒度有良好的理解将帮助你避免做出错误的分析，并帮助你判断是否拥有进行分析所需的数据。
- en: A quick way to find the level of detail of your data is to put the `Number of
    Records` (or the `Table (Count)` field in Tableau 2020.2 and later) field on the
    **Text** shelf, and then try different dimensions on the **Rows** shelf. When
    all of the rows display a 1, and the total that's displayed in the lower-left
    status bar equals the number of records in the data, then that dimension (or combination
    of dimensions) uniquely identifies a record and defines the lowest level of detail
    of your data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 查找数据详细级别的快速方法是将`记录数量`（或者在Tableau 2020.2及更高版本中的`表格（计数）`字段）放到**文本**架上，然后尝试将不同的维度放到**行**架上。当所有行显示为1，并且在左下角状态栏中显示的总数等于数据中的记录数量时，那么该维度（或维度组合）就唯一标识了一条记录，并定义了数据的最低详细级别。
- en: With an understanding of the overarching principles regarding the granularity
    of data, let's move on and understand certain data structures that allow you to
    work seamlessly and efficiently in Tableau. Sometimes, it may be preferable to
    restructure the data at the source using tools such as `Alteryx` or Tableau Prep
    Builder. However, at times, restructuring the source data isn't possible or feasible.
    For example, you may not have write access to the database or it may be a cloud-based
    data source that has a predefined structure. We'll take a look at some options
    in Tableau for those cases. For now, let's consider what kinds of data structures
    work well with Tableau.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理解数据粒度的整体原则后，让我们继续了解某些数据结构，这些结构可以让你在Tableau中无缝且高效地工作。有时，最好在源头使用`Alteryx`或Tableau
    Prep Builder等工具重构数据。然而，在某些情况下，重构源数据是不可能的或不可行的。例如，你可能没有数据库的写入权限，或者它可能是一个具有预定义结构的基于云的数据源。对于这种情况，我们将在Tableau中看一些选项。目前，让我们考虑哪些类型的数据结构与Tableau的兼容性较好。
- en: Well-structured data in Tableau
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tableau中的良好结构化数据
- en: The two keys to a good structure, which we mentioned in the previous section,
    should result in a data structure where a single measure is contained in a single
    column. You may have multiple different measures, but any single measure should
    almost never be divided into multiple columns. Often, the difference is described
    as **wide data** versus **tall data**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中提到的构建良好结构的两个关键点应该能得出一种数据结构，其中单一的度量包含在单一列中。你可能有多个不同的度量，但任何单一的度量几乎不应被分布在多个列中。通常，这种差异被描述为**宽数据**与**高数据**。
- en: Wide data
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宽数据
- en: '*Wide data is not typically a good structure for visual analysis in Tableau*.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*宽数据通常不是Tableau中进行可视化分析的良好结构*。'
- en: '**Wide data** describes a structure in which a measure in a single row is spread
    over multiple columns. This data is often more **human-readable**. Wide data often
    results in fewer rows with more columns.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**宽数据**描述了一种结构，其中单行的度量分布在多个列中。这种数据通常更加**易于阅读**。宽数据往往会导致较少的行和更多的列。'
- en: 'Here is an example of what wide data looks like in a table of population numbers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是宽数据在表格中展示的人口数字示例：
- en: '| **Country Name** | **1960** | **1961** | **1962** | **1963** | **1964** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **国家名称** | **1960** | **1961** | **1962** | **1963** | **1964** |'
- en: '| Afghanistan | 8,774,440 | 8,953,544 | 9,141,783 | 9,339,507 | 9,547,131 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 8,774,440 | 8,953,544 | 9,141,783 | 9,339,507 | 9,547,131 |'
- en: '| Australia | 10,276,477 | 10,483,000 | 10,742,000 | 10,950,000 | 11,167,000
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 澳大利亚 | 10,276,477 | 10,483,000 | 10,742,000 | 10,950,000 | 11,167,000 |'
- en: Notice that the level of detail for this table is a row for every country. However,
    the single measure (population) is not stored in a single column. This data is
    wide because it has a single measure (population) that is being divided into multiple
    columns (a column for each year). The wide table violates the second key to a
    good structure since the measure is at a lower level of detail than the individual
    record (per country per year, instead of just per country).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个表格的详细层次是每个国家一行。然而，单一的度量（人口）并未存储在单一列中。这些数据是宽数据，因为它们有一个单一的度量（人口），但该度量被分布在多个列中（每个年份一个列）。这个宽数据表违反了构建良好结构的第二个关键点，因为度量的层次低于每条记录的层次（按国家和年份，而不是按国家）。
- en: Tall data
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高数据
- en: '*Tall data is typically a good structure for visual analysis in Tableau*.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*高数据通常是Tableau中进行可视化分析的良好结构*。'
- en: '**Tall data** describes a structure in which each distinct measure in a row
    is contained in a single column. Tall data often results in more rows and fewer
    columns.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**高数据**描述了一种结构，其中每个不同的度量在一行中包含在单一列中。高数据通常会导致更多的行和更少的列。'
- en: 'Consider the following table, which represents the same data as earlier but
    in a tall structure:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下表格，它代表了与之前相同的数据，但采用了高数据结构：
- en: '| **Country Name** | **Year** | **Population** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **国家名称** | **年份** | **人口** |'
- en: '| Afghanistan | 1960 | 8,774,440 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1960 | 8,774,440 |'
- en: '| Afghanistan | 1961 | 8,953,544 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1961 | 8,953,544 |'
- en: '| Afghanistan | 1962 | 9,141,783 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1962 | 9,141,783 |'
- en: '| Afghanistan | 1963 | 9,339,507 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1963 | 9,339,507 |'
- en: '| Afghanistan | 1964 | 9,547,131 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 阿富汗 | 1964 | 9,547,131 |'
- en: '| Australia | 1960 | 10,276,477 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 澳大利亚 | 1960 | 10,276,477 |'
- en: '| Australia | 1961 | 10,483,000 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 澳大利亚 | 1961 | 10,483,000 |'
- en: '| Australia | 1962 | 10,742,000 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 澳大利亚 | 1962 | 10,742,000 |'
- en: '| Australia | 1963 | 10,950,000 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 澳大利亚 | 1963 | 10,950,000 |'
- en: '| Australia | 1964 | 11,167,000 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 澳大利亚 | 1964 | 11,167,000 |'
- en: Now, we have more rows (a row for each year for each country). Individual years
    are no longer separate columns and population measurements are no longer spread
    across those columns. Instead, one single column gives us a dimension of **Year**
    and another single column gives us a measure of **Population**. The number of
    rows has increased, while the number of columns has decreased. Now, the measure
    of population is at the same level of detail as the individual row, and so visual
    analysis in Tableau will be much easier.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有更多的行（每个国家每年一行）。单独的年份不再是分开的列，而人口测量也不再分布在这些列中。相反，一个单一的列给我们提供了**年份**的维度，另一个单一的列给我们提供了**人口**的度量。行数增加了，而列数减少了。现在，人口的度量与每一行的详细信息处于同一层次，因此在Tableau中进行可视化分析将变得更容易。
- en: Let's take a look at the difference this makes in practice.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个差异在实践中的体现。
- en: Wide versus tall data in Tableau
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tableau中的宽数据与高数据
- en: 'You can easily see the difference between wide and tall data in Tableau. Here
    is what the **wide** **data** table looks like in the left **Data** window:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Tableau中轻松看到宽数据与高数据的区别。以下是**宽数据**表格在左侧**数据**窗口中的样子：
- en: '![](img/B16021_14_01.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_01.png)'
- en: 'Figure 14.1: The wide data has a measure for every year'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：宽格式数据每年都有一个度量。
- en: As we'd expect, Tableau treats each column in the table as a separate field.
    The wide structure of the data works against us. We end up with a separate measure
    for each year. If you wanted to plot a line graph of population per year, you
    would likely struggle. What dimension represents the date? What single measure
    can you use for the population?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所期望的那样，Tableau 将表中的每一列视为一个独立的字段。数据的宽格式结构对我们不利。最终，我们为每一年都得到一个独立的度量。如果你想绘制每年的人口折线图，你可能会感到很困难。哪个维度表示日期？你可以使用哪个单一度量来表示人口？
- en: 'This isn''t to say that you can''t use wide data in Tableau. For example, you
    might use **Measure Names**/**Measure Values** to plot all the **Year** measures
    in a single view, like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说不能在 Tableau 中使用宽格式数据。例如，你可以使用**度量名称**/**度量值**将所有**年份**度量绘制在一个视图中，如下所示：
- en: '![](img/B16021_14_02.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_02.png)'
- en: 'Figure 14.2: The wide data can still be used but in a complex and limited way'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2：宽格式数据仍然可以使用，但方式复杂且有限。
- en: You'll notice that every **Year** field has been placed in the **Measure Values**
    shelf. The good news is that you can create visualizations from poorly structured
    data like this. The bad news is that views are often more difficult to create
    and certain advanced features may not be available.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到每个**年份**字段都被放置在**度量值**货架上。好消息是，即使是结构不良的数据，你也可以从中创建可视化图表。坏消息是，创建视图往往更加困难，并且某些高级功能可能无法使用。
- en: 'The following limitations apply to the view in *Figure 14.2* based on the wide
    data structure:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基于宽格式数据结构，以下限制适用于图 *14.2* 中的视图：
- en: Because Tableau doesn't have a date dimension or integer, you cannot use forecasting
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 Tableau 没有日期维度或整数维度，所以无法使用预测功能。
- en: Because Tableau doesn't have a date or continuous field in **Columns**, you
    cannot enable trend lines
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 Tableau 在**列**中没有日期或连续字段，所以无法启用趋势线。
- en: Because each measure is a separate field, you cannot use quick table calculations
    (such as running total, percent difference, and others)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为每个度量都是一个独立的字段，所以无法使用快速表计算（例如累计总和、百分比差异等）。
- en: Determining things such as the average population across years will require
    a tedious custom calculation instead of simply changing the aggregation of a measure
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定诸如跨年份平均人口等内容，将需要繁琐的自定义计算，而不是仅仅更改度量的聚合方式。
- en: You don't have an axis for the date (just a series of headers for the measure
    names), so you won't be able to add reference lines
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你没有日期轴（只有度量名称的系列标题），因此无法添加参考线。
- en: 'In contrast, the **tall data** looks like this in the **Data** pane:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，**高格式数据**在**数据**面板中的样子是这样的：
- en: '![](img/B16021_14_03.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_03.png)'
- en: 'Figure 14.3: The tall data has a Year dimension and a single Population measure'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3：高格式数据具有一个**年份**维度和一个单独的**人口**度量。
- en: This data source is much easier to work with. There's only one measure (**Population**)
    and a **Year** dimension to slice the measure. If you want a line chart of the
    population by year, you can simply drag and drop the **Population** and **Year**
    fields into **Columns** and **Rows**. Forecasting, trend lines, clustering, averages,
    standard deviations, and other advanced features will all work in the way you
    expect them to.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据源更容易处理。只有一个度量（**人口**）和一个**年份**维度来切片该度量。如果你想制作按年份划分的人口折线图，只需将**人口**和**年份**字段拖到**列**和**行**中。预测、趋势线、聚类、平均值、标准差等高级功能都能按预期工作。
- en: 'You can see that the resulting visualization is much easier to create in Tableau,
    using only three active fields:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，使用仅三个活动字段创建的可视化结果，在 Tableau 中要容易得多。
- en: '![](img/B16021_14_04.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_04.png)'
- en: 'Figure 14.4: The view is much easier to create in Tableau with the tall data'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4：使用高格式数据在 Tableau 中创建视图要容易得多。
- en: Next, we'll consider a few other good structures for data that should work well
    with Tableau.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将考虑几种其他适合与 Tableau 配合使用的数据结构。
- en: Star schemas (Data mart/Data warehouse)
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 星型模式（数据集市/数据仓库）
- en: Assuming they are well-designed, **star schema** data models work very well
    with Tableau because they have well-defined granularity, measures, and dimensions.
    Additionally, if they are implemented well, they can be extremely efficient to
    query. This allows for an ergonomic experience when using live connections in
    Tableau.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设它们设计良好，**星型模式**数据模型与 Tableau 非常兼容，因为它们有明确的粒度、度量和维度定义。此外，如果它们实现得当，可以极为高效地查询。这使得在使用
    Tableau 的实时连接时，能够提供非常顺畅的体验。
- en: 'Star schemas are so named because they consist of a single fact table surrounded
    by related dimension tables, thus forming a star pattern. **Fact tables** contain
    measures at a meaningful granularity, while **dimension tables** contain attributes
    for various related entities. The following diagram illustrates a simple star
    schema with a single fact table (**Hospital Visit**) and three dimension tables
    (**Patient**, **Primary Physician**, and **Discharge Details**):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 星型架构之所以得名，是因为它由一个单一的事实表和与之相关的维度表组成，从而形成了一个星形模式。**事实表**包含具有有意义粒度的度量，而**维度表**包含各种相关实体的属性。下图展示了一个简单的星型架构，其中包含一个事实表（**医院就诊**）和三个维度表（**患者**、**主治医生**、和**出院详情**）：
- en: '![](img/B16021_14_05.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_05.png)'
- en: 'Figure 14.5: A simple star schema'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：一个简单的星型架构
- en: Fact tables are joined to the related dimension using what is often called a
    **surrogate key** or **foreign key** that references a single dimension record.
    The fact table defines the level of granularity and contains measures. In this
    case, **Hospital Visit** has a granularity of one record for each visit. In this
    simple example, each visit is for one patient who saw one primary physician and
    was discharged. The **Hospital Visit** table explicitly stores a measure of `Visit
    Duration` and implicitly defines another measure of `Number of Visits` (as the
    row count).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 事实表通过通常被称为**替代键**或**外键**的字段与相关的维度表连接，该外键引用单一的维度记录。事实表定义了粒度级别，并包含度量。在这种情况下，**医院就诊**的粒度是每次就诊一条记录。在这个简单的示例中，每次就诊都对应一个患者，患者见了一个主治医生并完成了出院。**医院就诊**表明确存储了`就诊时长`这一度量，并隐式定义了另一项度量`就诊次数`（即行数）。
- en: Data modeling purists would point out that date values have been stored in the
    fact table (and even some of the dimensions). They would, instead, recommend having
    a date dimension table with extensive attributes for each date and only a surrogate
    (foreign) key stored in the fact table.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数据建模的纯粹主义者会指出，日期值已被存储在事实表中（甚至一些维度表中）。他们会建议，应该有一个日期维度表，包含每个日期的详细属性，并且只在事实表中存储一个替代键（外键）。
- en: A date dimension can be very beneficial. However, Tableau's built-in date hierarchy
    and extensive date options make storing a date in the fact table, instead, a viable
    option. Consider using a date dimension if you need specific attributes of dates
    that are not available in Tableau (for example, which days are corporate holidays),
    have complex fiscal years, or if you need to support legacy BI reporting tools.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 日期维度非常有用。然而，Tableau内置的日期层次结构和丰富的日期选项使得将日期存储在事实表中成为一种可行的选择。如果你需要日期的特定属性，而这些属性在Tableau中不可用（例如，哪些天是公司假期），或者有复杂的财政年度，或者需要支持遗留的BI报表工具，可以考虑使用日期维度。
- en: A well-designed star schema allows the use of **inner joins** since every surrogate
    key should reference a single dimension record. In cases where dimension values
    are not known or not applicable, special dimension records are used. For example,
    a hospital visit that is not yet complete (the patient is still in the hospital)
    may reference a special record in the **Discharge Details** table marked as `Not
    yet discharged`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的星型架构允许使用**内连接**，因为每个替代键都应引用单个维度记录。在维度值未知或不适用的情况下，会使用特殊的维度记录。例如，一个尚未完成的住院就诊（患者仍在医院）可能会引用**出院详情**表中的一个特殊记录，标记为`尚未出院`。
- en: You've already worked with a similar structure of data in the previous chapter,
    where you experienced the differences of relating tables in the logical layer
    and the physical layer of the data model. Feel free to return to *Chapter 13*,
    *Understanding the Tableau Data Model, Joins, and Blends*, to review the concepts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在上一章中处理过类似的数据结构，在那里你体验了数据模型的逻辑层和物理层中表关系的差异。可以随时返回*第13章*，*理解Tableau数据模型、联接和合并*，以复习相关概念。
- en: Well-implemented star schemas are particularly attractive for use in **live
    connections** because Tableau can improve performance by implementing join culling.
    **Join culling** is Tableau's elimination of unnecessary joins in queries, since
    it sends them to the data source engine.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实现良好的星型架构尤其适合用于**实时连接**，因为Tableau可以通过实现联接剔除来提高性能。**联接剔除**是Tableau通过将查询中的不必要联接发送到数据源引擎来消除不必要的联接。
- en: For example, if you were to place the `Physician Name` on rows and the average
    of `Visit Duration` on columns to get a bar chart of average visit duration per
    physician, then joins to the **Treatment** and **Patient** tables may not be needed.
    Tableau will eliminate unnecessary joins as long as you are using a simple star
    schema with joins that are only from the central fact table and have referential
    integrity enabled in the source, or allow Tableau to assume referential integrity.
    For tables joined in the physical layer, select the data source connection from
    the data menu, or use the context menu from the data source connection and choose
    **Assume Referential Integrity**. For relationships in the logical layer of the
    data model, use the performance options for referential integrity for each applicable
    relationship.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果将`医生姓名`放置在行上，将`访问时长`的平均值放置在列上，以便获得每个医生的平均访问时长的条形图，那么可能不需要连接到**治疗**和**病人**表格。如果你使用的是简单的星型模式且只从中央事实表进行连接，并且在数据源中启用了参照完整性，或者允许
    Tableau 假设参照完整性，那么 Tableau 会自动去除不必要的连接。对于物理层中连接的表格，从数据菜单中选择数据源连接，或使用数据源连接的上下文菜单，选择**假设参照完整性**。对于数据模型的逻辑层中的关系，使用每个适用关系的参照完整性性能选项。
- en: Having considered some examples of good structures, let's turn our attention
    to some basic transformations that will help us to transform a poorly structured
    dataset to one with a good structure, which is easier to work with in Tableau.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了一些良好的结构示例后，让我们关注一些基本的转换，这些转换将帮助我们将结构不佳的数据集转换为结构良好的数据集，使得在 Tableau 中更容易操作。
- en: The four basic data transformations
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四种基本的数据转换
- en: In this section, we'll give you an overview of some basic transformations that
    can fundamentally change the structure of your data. We'll start with an overview
    and then look at some practical examples.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为您提供一些基本转换的概述，这些转换可以从根本上改变数据的结构。我们将从概述开始，然后查看一些实际示例。
- en: Overview of transformations
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换概述
- en: 'In Tableau (and Tableau Prep), there are four basic data transformations. The
    following definitions broadly apply to most databases and data transformation
    tools, but there are some details and terminology that are Tableau-specific:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Tableau（以及 Tableau Prep）中，有四种基本的数据转换。以下定义广泛适用于大多数数据库和数据转换工具，但也有一些特定于 Tableau
    的细节和术语：
- en: '**Pivots**: This indicates the transformation of columns to rows or rows to
    columns. The latter is possible in Tableau Prep only. The resulting dataset will
    be narrower and taller with fewer columns and more rows (columns to rows) or wider
    and shorter with more columns and fewer rows (rows to columns).'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透视**：这表示将列转换为行或将行转换为列。后者仅在 Tableau Prep 中可用。结果的数据集会更窄更高，列数较少，行数较多（列转行），或者会更宽更短，列数更多，行数较少（行转列）。'
- en: '**Unions**: This indicates the appending of rows from one table of data to
    another, with the matching columns **aligned** together. The resulting data structure
    is a single table containing rows from all unioned tables and columns that match
    between the original tables, along with unmatched columns containing `NULL` values
    for tables that did not have them.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联合**：这表示将一张数据表的行附加到另一张表格，匹配的列**对齐**在一起。结果数据结构是一个包含所有联合表格行的单一表格，以及原始表格之间匹配的列，未匹配的列则包含`NULL`值。'
- en: '**Joins**: This indicates the row-by-row matching of two or more tables resulting
    in a data structure that includes columns from all tables. The number of rows
    is based on the type of join and how many matches are found.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接**：这表示对两个或更多表格进行逐行匹配，生成一个包含所有表格列的数据结构。行数取决于连接类型和找到的匹配数量。'
- en: '**Aggregations**: This indicates the **rolling up** of a table to a higher
    level of detail such that there will be a row for each unique set of values for
    all dimensions used for grouping, along with other values that are aggregated
    (such as a sum, min, max, or other aggregation).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**：这表示将表格**汇总**到更高层次的细节，以便每个用于分组的维度的唯一值集都有一行，同时包含其他聚合值（如总和、最小值、最大值或其他聚合）。'
- en: In order to fully understand these definitions, we'll turn to some illustrations
    and practical examples.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更全面地理解这些定义，我们将借助一些插图和实际示例。
- en: Pivots (along with some simple data cleaning)
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 透视（以及一些简单的数据清理）
- en: 'The Excel workbook `World Population Data.xlsx`, which is included in the `Chapter
    14` directory of the resources that are included with this book, is typical of
    many Excel documents. Here is what it looks like:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`World Population Data.xlsx` 这份 Excel 工作簿，位于本书资源包中 `Chapter 14` 目录下，是许多 Excel
    文档的典型代表。它的内容如下所示：'
- en: '![](img/B16021_14_06.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_06.png)'
- en: 'Figure 14.6: The World Population Data Excel file'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6：World Population Data Excel 文件
- en: 'Excel documents such as this are often more human-readable but contain multiple
    issues when used for data analysis in Tableau. The issues in this particular document
    include the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这类 Excel 文档通常更加易于阅读，但在 Tableau 中用于数据分析时往往包含多个问题。此文档中的问题包括：
- en: Excessive headers (titles, notes, and formatting) that are not part of the data
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多余的表头（标题、注释和格式）不属于数据部分
- en: Merged cells
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并单元格
- en: Country name and code in a single column
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国家名称和代码合并在同一列中
- en: Columns that are likely unnecessary (**Indicator Name** and **Indicator Code**)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能不必要的列（**指标名称** 和 **指标代码**）
- en: The data is wide, that is, there is a column for each year, and the population
    measure is spread across these columns within a single record
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据较宽，即每一年都有一列，且人口数据分布在这些列中，属于同一条记录
- en: 'When we initially connect to the Excel document in Tableau, the connection
    screen will look similar to *Figure 14.7*, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初连接到 Excel 文档时，连接界面将类似于 *图 14.7*，如下所示：
- en: '![](img/B16021_14_07.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_07.png)'
- en: 'Figure 14.7: World Population Data.xlsx on Tableau''s Data Source page'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7：Tableau 数据源页面中的 World Population Data.xlsx
- en: 'The data preview reveals some of the issues resulting from the poor structure:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 数据预览显示了因结构不良而导致的一些问题：
- en: Since the column headers were not in the first Excel row, Tableau gave the defaults
    of **F1**, **F2**, and so on to each column
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于列头不在 Excel 的第一行，Tableau 默认为每一列赋予了 **F1**、**F2** 等名称
- en: The title **World Population Data** and the note about sample data were interpreted
    as values in the **F1** column
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题 **World Population Data** 和关于样本数据的注释被解读为 **F1** 列中的值
- en: The actual column headers are treated as a row of data (the third row)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的列头被当作了一行数据（第三行）
- en: 'Fortunately, these issues can be addressed in the connection window. First,
    we can correct many of the excessive header issues by turning on the **Tableau
    Data Interpreter**, a component that specifically identifies and resolves common
    structural issues in Excel or Google Sheets documents. When you check the **Use
    Data Interpreter** option, the data preview reveals much better results:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这些问题可以在连接窗口中解决。首先，我们可以通过启用 **Tableau 数据解析器** 来修正许多多余的表头问题，该组件专门用于识别和解决
    Excel 或 Google 表格文档中的常见结构问题。当你勾选 **使用数据解析器** 选项时，数据预览将呈现出更好的结果：
- en: '![](img/B16021_14_08.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_08.png)'
- en: 'Figure 14.8: Tableau Data Interpreter fixes many of the common issues found
    in Excel (and similar) data sources'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8：Tableau 数据解析器解决了 Excel（及类似）数据源中许多常见问题
- en: Clicking on the **Review the results...** link that appears under the checkbox
    will cause Tableau to generate a new Excel document that is color-coded to indicate
    how the data interpreter parsed the Excel document. Use this feature to verify
    that Tableau has correctly interpreted the Excel document and retained the data
    you expected.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 点击勾选框下方的 **查看结果...** 链接，将导致 Tableau 生成一个新的 Excel 文档，并通过颜色编码来显示数据解析器如何解析该 Excel
    文档。使用此功能可以验证 Tableau 是否正确解析了 Excel 文档，并保留了你预期的数据。
- en: Observe the elimination of the excess headers and the correct names of the columns.
    However, a few additional issues will still need to be corrected.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到多余的表头被去除，且列名得到了正确的显示。然而，仍然有一些附加的问题需要修正。
- en: First, we can hide the **Indicator Name** and **Indicator Code** columns if
    we feel they are not useful for our analysis. Clicking on the drop-down arrow
    on a column header reveals a menu of options.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们认为 **指标名称** 和 **指标代码** 列对分析没有用处，我们可以将其隐藏。点击列头上的下拉箭头，会显示一个菜单选项。
- en: 'Selecting **Hide** will remove the field from the connection and even prevent
    it from being stored in extracts:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **隐藏** 将会从连接中移除该字段，并且防止其被存储到提取文件中：
- en: '![](img/B16021_14_09.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_09.png)'
- en: 'Figure 14.9: You can hide fields from the Data Source screen'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9：你可以在数据源页面隐藏字段
- en: Second, we can use the option on the same menu to split the **Country Name and
    Code** column into two columns so that we can work with the name and code separately.
    In this case, the **Split** option on the menu works well and Tableau perfectly
    splits the data, even removing the parentheses from around the code. In cases
    where the split option does not initially work, try the **Custom Split...** option.
    We'll also use the **Rename** option to rename the split fields from `Country
    Name and Code - Split 1` and `Country Name and Code - Split 2` to **Country Name**
    and **Country Code**, respectively. Then, we'll **Hide** the original `Country
    Name and Code` field.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以使用相同菜单中的选项将**国家名称和代码**列分成两列，以便分别处理名称和代码。在这种情况下，菜单中的**拆分**选项效果很好，Tableau
    完美地拆分了数据，甚至去除了代码周围的括号。在拆分选项初次无法正常工作时，可以尝试**自定义拆分...**选项。我们还将使用**重命名**选项，将拆分后的字段`国家名称和代码
    - 拆分 1`和`国家名称和代码 - 拆分 2`分别重命名为**国家名称**和**国家代码**。然后，我们将**隐藏**原始的`国家名称和代码`字段。
- en: 'At this point, most of the data structure issues have been remedied. However,
    you''ll recognize that the data is in a **wide** format. We have already seen
    the issues that we''ll run into:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，大部分数据结构问题已经得到解决。然而，你会发现数据仍然是**宽格式**。我们已经看到了可能遇到的一些问题：
- en: '![](img/B16021_14_10.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_10.png)'
- en: 'Figure 14.10: After some cleaning, the data is still in an undesirable wide
    structure'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10：经过一些清理后，数据仍然呈现不理想的宽格式结构
- en: Our final step is to **pivot** the year columns. This means that we'll reshape
    the data in such a way that every country will have a row for every year. Select
    all the year columns by clicking on the **1960** column, scrolling to the far
    right, and holding *Shift* while clicking on the **2013** column. Finally, use
    the drop-down menu on any one of the year fields and select the **Pivot** option.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步是**透视**年份列。这意味着我们将重塑数据，使得每个国家在每一年都有一行。通过点击**1960**列，向右滚动，按住*Shift*键并点击**2013**列，选择所有年份列。最后，在任何一个年份字段的下拉菜单中选择**透视**选项。
- en: The result is two columns (**Pivot field names** and **Pivot field values**)
    in place of all the year columns. Rename the two new columns to **Year** and **Population**.
    Your dataset is now narrow and tall instead of wide and short.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是用两个列（**透视字段名称**和**透视字段值**）代替了所有年份列。将这两个新列重命名为**年份**和**人口**。现在，数据集变得更加狭长，而不是宽短。
- en: 'Finally, notice that the icon on the **Year** column is recognized by Tableau
    as a text field. Clicking on the icon will allow you to change the data type directly.
    In this case, selecting **Date** will result in `NULL` values, but changing the
    data type to **Number (whole)** will give you integer values that will work well
    in most cases:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意到**年份**列的图标被 Tableau 识别为文本字段。点击该图标可以直接更改数据类型。在这种情况下，选择**日期**会得到`NULL`值，但将数据类型更改为**数字（整数）**则会得到适用于大多数情况的整数值：
- en: '![](img/B16021_14_11.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_11.png)'
- en: 'Figure 14.11: You can change the data types of the fields on the Data Source
    page'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11：你可以在数据源页面上更改字段的数据类型
- en: Alternatively, you could use the first drop-down menu in the `Year` field and
    select **Create Calculated Field....** This would allow you to create a calculated
    field name **Year (date)**, which parses the year string as a date with code such
    as `DATE(DATEPARSE("yyyy", [Year]))`. This code will parse the string and then
    convert it into a simple date without a time. You can then hide the original **Year**
    field. You can hide any field, even if it is used in calculations, as long as
    it isn't used in a view. This leaves you with a very clean dataset.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以使用`年份`字段中第一个下拉菜单并选择**创建计算字段...**。这将允许你创建一个计算字段，命名为**年份（日期）**，该字段将年份字符串解析为日期，代码如下：`DATE(DATEPARSE("yyyy",
    [Year]))`。此代码将解析字符串并将其转换为没有时间的简单日期。然后，你可以隐藏原始的**年份**字段。即使字段用于计算，只要它不用于视图，你也可以将其隐藏。这将使数据集变得非常干净。
- en: 'The final cleaned, pivoted dataset is far easier to work with in Tableau than
    the original:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最终清理后的透视数据集在 Tableau 中比原始数据集更容易操作：
- en: '![](img/B16021_14_12.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_12.png)'
- en: 'Figure 14.12: The cleaned and pivoted dataset'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12：清理和透视后的数据集
- en: The data interpreter, cleaning options, and ability to pivot data (columns to
    rows) in Tableau make working with many datasets far easier. Next, we'll take
    a look at unions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数据解释器、清理选项以及在 Tableau 中透视数据（列转行）的功能，使得处理许多数据集变得更加轻松。接下来，我们将了解合并。
- en: Unions
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并
- en: Often, you may have multiple individual files or tables that, together, represent
    the entire set of data. For example, you might have a process that creates a new
    monthly data dump as a new text file in a certain directory. Or, you might have
    an Excel file where data for each department is contained in a separate sheet.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可能有多个独立的文件或表格，它们合在一起代表整个数据集。例如，你可能有一个过程，每月生成一个新的数据转储文件并保存到某个目录中。或者，你可能有一个
    Excel 文件，其中包含每个部门的数据，每个部门的数据在不同的工作表中。
- en: 'A **union** is a concatenation of data tables that brings together rows of
    each table into a single table. For example, consider the following three tables
    of data:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**联合**是将数据表按行拼接成一个单一表格的过程。比如，考虑以下三张数据表：'
- en: '**Originals**:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**原创**：'
- en: '| **Name** | **Occupation** | **Bank account balance** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **姓名** | **职业** | **银行账户余额** |'
- en: '| Luke | Farmer | $2,000 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| Luke | 农民 | $2,000 |'
- en: '| Leia | Princess | $50,000 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| Leia | 公主 | $50,000 |'
- en: '| Han | Smuggler | -$20,000 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| Han | 走私犯 | -$20,000 |'
- en: '**Prequels**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**前传**：'
- en: '| **Name** | **Occupation** | **Bank account balance** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **姓名** | **职业** | **银行账户余额** |'
- en: '| Watto | Junk Dealer | $9,000 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| Watto | 垃圾商 | $9,000 |'
- en: '| Darth Maul | Face Painter | $10,000 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| Darth Maul | 面部画家 | $10,000 |'
- en: '| Jar Jar | Sith Lord | -$100,000 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| Jar Jar | 西斯领主 | -$100,000 |'
- en: '**Sequels**:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**续集**：'
- en: '| **Name** | **Occupation** | **Bank account balance** |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **姓名** | **职业** | **银行账户余额** |'
- en: '| Rey | Scavenger | $600 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| Rey | 拾荒者 | $600 |'
- en: '| Poe | Pilot | $30,000 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| Poe | 飞行员 | $30,000 |'
- en: '| Kylo | Unemployed | $0 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| Kylo | 失业 | $0 |'
- en: 'A union of these tables would give a single table containing the rows of each
    individual table:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表的联合将生成一个包含每个单独表格行的单一表格：
- en: '| **Name** | **Occupation** | **Bank account balance** |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **姓名** | **职业** | **银行账户余额** |'
- en: '| Luke | Farmer | $2,000 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| Luke | 农民 | $2,000 |'
- en: '| Leia | Princess | $50,000 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| Leia | 公主 | $50,000 |'
- en: '| Han | Smuggler | -$20,000 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| Han | 走私犯 | -$20,000 |'
- en: '| Watto | Junk Dealer | $9,000 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| Watto | 垃圾商 | $9,000 |'
- en: '| Darth Maul | Face Painter | $10,000 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| Darth Maul | 面部画家 | $10,000 |'
- en: '| Jar Jar | Sith Lord | -$100,000 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| Jar Jar | 西斯领主 | -$100,000 |'
- en: '| Rey | Scavenger | $600 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| Rey | 拾荒者 | $600 |'
- en: '| Poe | Pilot | $30,000 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| Poe | 飞行员 | $30,000 |'
- en: '| Kylo | Unemployed | $0 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| Kylo | 失业 | $0 |'
- en: 'Tableau allows you to union together tables from file-based data sources, including
    the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Tableau 允许你将文件数据源中的表格联合起来，包括以下类型：
- en: Text files (`.csv`, `.txt`, and other text file formats)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本文件（`.csv`、`.txt` 和其他文本文件格式）
- en: Sheets (tabs) within Excel documents
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Excel 文档中的工作表（标签）
- en: Subtables within an Excel sheet
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Excel 表中的子表
- en: Multiple Excel documents
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个 Excel 文档
- en: Google Sheets
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google 表格
- en: Relational database tables
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系型数据库表
- en: Use the **Data Interpreter** feature to find subtables in Excel or Google Sheets.
    They will show up as additional tables of data in the left sidebar.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**数据解析器**功能查找 Excel 或 Google 表格中的子表。它们将作为数据的附加表格出现在左侧边栏。
- en: 'To create a union in Tableau, follow these steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Tableau 中创建联合，请按以下步骤操作：
- en: Create a new data source from the menu, toolbar, or **Data Source** screen,
    starting with one of the files you wish to be part of the union. Then, drag any
    additional files into the **Drag table to union** drop zone just beneath the existing
    table on the canvas (in either the logical or physical layers; though, the union,
    technically, exists in the physical layer):![](img/B16021_14_13.png)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单、工具栏或**数据源**屏幕中创建一个新的数据源，开始时选择你希望成为联合一部分的文件之一。然后，将任何其他文件拖动到画布上现有表格下方的**拖动表格到联合区域**，该区域位于逻辑层或物理层中（不过，技术上讲，联合存在于物理层中）：![](img/B16021_14_13.png)
- en: 'Figure 14.13: You may create unions by dragging and dropping tables or files
    directly under existing tables on the canvas'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.13：你可以通过将表格或文件直接拖放到画布上现有表格下方来创建联合
- en: Once you've created a union, you can use the drop-down menu on the table in
    the designer to configure options for the union. Alternatively, you can drag the
    **New Union** object from the left sidebar into the designer to replace the existing
    table. This will reveal options to create and configure the union:![](img/B16021_14_14.png)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你创建了联合，可以在设计器中的表格下拉菜单中配置联合选项。或者，你也可以将左侧边栏中的**新建联合**对象拖动到设计器中，替换现有表格。这将显示创建和配置联合的选项：![](img/B16021_14_14.png)
- en: 'Figure 14.14: You may edit unions with these options'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.14：你可以使用这些选项编辑联合
- en: The **Specific (manual)** tab allows you to drag tables into and out of the
    union. The **Wildcard (automatic)** tab allows you to specify wildcards for filenames
    and sheets (for Excel and Google Sheets) that will automatically include files
    and sheets in the union based on a wildcard match.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Specific (manual)**标签允许你将表格拖入或拖出联合操作。**Wildcard (automatic)**标签允许你指定文件名和工作表（对于Excel和Google
    Sheets）中的通配符，这些通配符会根据匹配情况自动将文件和工作表包含在联合操作中。'
- en: Use the **Wildcard (automatic)** feature if you anticipate additional files
    being added in the future. For example, if you have a specific directory where
    data files are dumped on a periodic basis, the wildcard feature will ensure that
    you don't have to manually edit the connection.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你预见未来会添加更多文件，使用**Wildcard (automatic)**功能。例如，如果你有一个特定的目录，用于定期存储数据文件，通配符功能将确保你不必手动编辑连接。
- en: Once you have defined the union, you may use the resulting data source to visualize
    the data. Additionally, a union table may be joined with other tables in the designer
    window, giving you a lot of flexibility in working with data.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦定义了联合操作，你可以使用结果数据源来可视化数据。此外，联合表可以与设计窗口中的其他表格进行连接，给你在数据处理上提供很大的灵活性。
- en: When you create a union, Tableau will include one or more new fields in your
    data source to help you to identify the file, sheet, and table where the data
    originated. **Path** will contain the file path (including the filename), **Sheet**
    will contain the sheet name (for Excel or Google Sheets), and **Table Name** will
    contain the subtable or text filename. You can use these fields to help you to
    identify data issues and also to extend your dataset as needed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建联合操作时，Tableau会在数据源中添加一个或多个新字段，帮助你识别数据来源的文件、工作表和表格。**Path**将包含文件路径（包括文件名），**Sheet**将包含工作表名称（对于Excel或Google
    Sheets），而**Table Name**将包含子表或文本文件名。你可以利用这些字段帮助识别数据问题，并根据需要扩展数据集。
- en: 'For example, if you had a directory of monthly data dump files, named `2020-01.txt`,
    `2020-02.txt`, `2020-03.txt`, and so on, but no actual date field in the files,
    you could obtain the date using a calculated field with code such as the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个按月命名的数据文件目录，文件名为`2020-01.txt`、`2020-02.txt`、`2020-03.txt`，依此类推，但文件中没有实际的日期字段，你可以使用如下代码通过计算字段获取日期：
- en: '[PRE0]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In a union, Tableau will match the columns between tables by name. What happens
    when columns are not the same between tables or files? If you were to write a
    query to a database, you might expect a failed result as column names usually
    have to match exactly. However, Tableau allows you to union together files or
    tables with mismatched names.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在联合操作中，Tableau会根据列名匹配不同表格之间的列。当表格或文件之间的列名不一致时会发生什么情况？如果你向数据库写查询，你可能会预期查询失败，因为列名通常需要完全匹配。然而，Tableau允许你联合那些列名不匹配的文件或表格。
- en: 'Columns that exist in one file/table but not in others will appear as part
    of the union table, but values will be `NULL` in files/tables where the column
    does not exist. For example, if one of the files contained a column named **Job**
    instead of **Occupation**, the final union table would contain a column named
    **Job** and another named **Occupation**, with `NULL` values where the column
    did not exist. You can merge the mismatched columns by selecting the columns and
    using the drop-down menu. This will coalesce (keep the first non-null of) the
    values per row of data in a single new column:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个文件/表格中存在但在其他文件/表格中不存在的列会作为联合表的一部分出现，但在没有该列的文件/表格中，值会显示为`NULL`。例如，如果某个文件包含一个名为**Job**的列，而不是**Occupation**，那么最终的联合表将包含一个名为**Job**的列和一个名为**Occupation**的列，在不存在该列的地方显示`NULL`值。你可以通过选择这些列并使用下拉菜单来合并不匹配的列。这将合并（保留每行数据中第一个非空值）为一个新的单列：
- en: '![](img/B16021_14_15.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_15.png)'
- en: 'Figure 14.15: Use Merge Mismatched Fields to combine columns resulting from
    a union where the field names didn''t match (this mismatch is not included in
    the example data)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.15：使用合并不匹配字段功能，合并因联合操作导致的字段名不匹配的列（该不匹配未包含在示例数据中）。
- en: You do not have to merge mismatched fields. At times, there will not be corresponding
    matches in all files or tables and that may be useful for your analysis.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必合并不匹配的字段。有时，某些文件或表格中没有对应的匹配项，这对于你的分析可能是有用的。
- en: Unions allow you to bring together multiple files or tables with relatively
    the same structure and **stack** them together so that you end up with all records
    from all tables/files. With pivots and unions explored, we've covered two of the
    four basic transformation types. We'll continue with an example of how joins can
    be used to restructure your data.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 联合（Unions）允许你将结构相对相同的多个文件或表格合并，并**堆叠**在一起，这样你就可以得到所有表格/文件中的记录。通过对旋转和联合的探索，我们已经涵盖了四种基本转换类型中的两种。接下来我们将继续演示如何使用连接来重构数据。
- en: Joins
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接（Joins）
- en: You'll recall that the concept of joins and the types of joins were previously
    discussed in *Chapter 13*, *Understanding the Tableau Data Model, Joins, and Blends*.
    While joins are quite useful in bringing together tables in the same database
    or even disparate data sources (data contained in different systems and formats),
    they can be used to solve other data issues too, such as reshaping data to make
    it easier to meet your objectives in Tableau.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得，我们之前在*第13章*，*理解 Tableau 数据模型、连接和混合*中讨论了连接的概念和类型。虽然连接在将同一数据库中的表格或甚至不同数据源（不同系统和格式中的数据）合并时非常有用，但它们也可以用来解决其他数据问题，例如重塑数据，使其更容易在
    Tableau 中实现你的目标。
- en: You can work through the following example in the `Chapter 14` workbook, but
    the server database data source is simulated with a text file (`Patient Visits.txt`).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`第14章`的工作簿中通过以下示例进行操作，但服务器数据库数据源是通过文本文件（`Patient Visits.txt`）进行模拟的。
- en: 'Let''s say you have a table in a server database (such as SQL Server or Oracle)
    that contains one row per hospital patient and includes the **Admit Date** and
    **Discharge Date** as separate columns for each patient:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个服务器数据库中的表格（例如 SQL Server 或 Oracle），该表格为每个患者包含一行数据，并将**入院日期**和**出院日期**作为单独的列：
- en: '| **Patient ID** | **Patient Name** | **Admit Date** | **Discharge Date** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **患者 ID** | **患者姓名** | **入院日期** | **出院日期** |'
- en: '| 1 | David | 12/1/2018 | 12/20/2018 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 1 | David | 2018/12/1 | 2018/12/20 |'
- en: '| 2 | Solomon | 12/3/2018 | 12/7/2018 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Solomon | 2018/12/3 | 2018/12/7 |'
- en: '| 3 | Asa | 12/5/2018 | 12/22/2018 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Asa | 2018/12/5 | 2018/12/22 |'
- en: '| 4 | Jehoshaphat | 12/5/2018 | 12/6/2018 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Jehoshaphat | 2018/12/5 | 2018/12/6 |'
- en: '| 5 | Joash | 12/9/2018 | 12/16/2018 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 5 | Joash | 2018/12/9 | 2018/12/16 |'
- en: '| 6 | Amaziah | 12/10/2018 | 12/14/2018 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 6 | Amaziah | 2018/12/10 | 2018/12/14 |'
- en: '| 7 | Uzziah | 12/12/2018 | 12/24/2018 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 7 | Uzziah | 2018/12/12 | 2018/12/24 |'
- en: '| 8 | Jotham | 12/16/2018 | 12/29/2018 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 8 | Jotham | 2018/12/16 | 2018/12/29 |'
- en: '| 9 | Hezekiah | 12/18/2018 | 12/22/2018 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 9 | Hezekiah | 2018/12/18 | 2018/12/22 |'
- en: '| 10 | Josiah | 12/22/2018 | 12/23/2018 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 10 | Josiah | 2018/12/22 | 2018/12/23 |'
- en: While this data structure works well for certain kinds of analyses, you would
    find it difficult to use if you wanted to visualize the number of patients in
    the hospital day by day for the month of December.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种数据结构适用于某些分析类型，但如果你想要按日展示12月住院患者的数量，可能会觉得难以使用。
- en: For one, which date field do you use for the axis? Even if you pivoted the table
    so that you had all of the dates in one field, you would find that you have gaps
    in the data. **Sparse data**, that is, data in which records do not exist for
    certain values, is quite common in certain real-world data sources. Specifically,
    in this case, you have a single record for each **Admit** or **Discharge** date,
    but no records for the days in between.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该使用哪个日期字段作为轴？即使你将表格旋转，使得所有日期都集中在一个字段中，你也会发现数据中有缺失。**稀疏数据**，即某些值没有记录的数据，在一些现实世界的数据源中非常常见。具体来说，在这个例子中，你每个**入院**或**出院**日期都有一条记录，但中间的日期没有记录。
- en: Sometimes, it might be an option to restructure the data at the source, but
    if the database is locked down, you may not have that option. You could also use
    Tableau's ability to fill in gaps in the data (**data densification**) to solve
    the problem. However, that solution could be complex and, potentially, brittle
    or difficult to maintain.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可能可以选择在源头重构数据，但如果数据库被锁定，你可能无法做到这一点。你还可以利用 Tableau 填补数据空白的功能（**数据密集化**）来解决这个问题。然而，这种解决方案可能会很复杂，并且潜在地不稳定或难以维护。
- en: 'An alternative is to use a join to create the rows for all dates. In this case,
    we''ll leverage a cross-database join to bring in another source of data altogether.
    You might quickly create an Excel sheet with a list of dates you want to see,
    like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用连接来创建所有日期的行。在这种情况下，我们将利用跨数据库连接，将另一个数据源完全引入。你可能会迅速创建一个包含你想要查看的日期列表的 Excel
    表格，如下所示：
- en: '![](img/B16021_14_16.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_16.png)'
- en: 'Figure 14.16: An Excel file containing only a comprehensive list of dates'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.16：一个仅包含日期综合列表的 Excel 文件
- en: The Excel file includes a record for each date. Our goal is to **cross join**
    (join every row from one table with every row in another) the data between the
    database table and the Excel table. With this accomplished, you will have a row
    for every patient for every date.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Excel 文件包含每个日期的记录。我们的目标是将数据库表与 Excel 表中的数据进行**交叉连接**（将一个表的每一行与另一个表的每一行连接）。完成此操作后，您将为每个患者的每个日期生成一行记录。
- en: Joining every record in one dataset with every record in another dataset creates
    what is called a **Cartesian product**. The resulting dataset will have `N1 *
    N2` rows (where `N1` is the number of rows in the first dataset and `N2` is the
    number of rows in the second). Take care in using this approach. It works well
    with smaller datasets. As you work with larger datasets, the Cartesian product
    may grow so large that this solution is untenable.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个数据集中的每条记录与另一个数据集中的每条记录连接起来，产生的结果称为**笛卡尔积**。生成的数据集将包含`N1 * N2`行（其中`N1`是第一个数据集的行数，`N2`是第二个数据集的行数）。使用这种方法时要小心。它在较小的数据集上效果良好，但随着数据集的增大，笛卡尔积可能会变得非常庞大，以至于这个解决方案不再可行。
- en: You'll often have specific fields in the various tables that will allow you
    to join the data together. In this case, however, we don't have any keys that
    define a join. The dates also do not give us a way to join all the data in a way
    that gives us the structure we want. To achieve the cross join, we'll use a join
    calculation. A **join calculation** allows you to write a special calculated field
    specifically for use in joins.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常会在各个表中找到可以用来连接数据的特定字段。然而，在这种情况下，我们没有定义连接的键。日期也没有给我们提供一种连接所有数据的方法，以便获得我们想要的结构。为了实现交叉连接，我们将使用连接计算。**连接计算**允许您编写一个专门用于连接的特殊计算字段。
- en: 'In this case, we''ll select **Create Join Calculation...** for both tables
    and enter the single, hard-coded value, that is, `1`, for both the left and right
    sides:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将为两个表选择**创建连接计算...**并为左右两侧都输入单一的硬编码值，也就是`1`：
- en: '![](img/B16021_14_17.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_17.png)'
- en: 'Figure 14.17: As we''ve seen, the join is created in the physical layer of
    the data model'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.17：正如我们所见，连接是在数据模型的物理层创建的
- en: Since `1` in every row on the left matches `1` in every row on the right, we
    get every row matching every row—a true cross join.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于左侧每行的`1`与右侧每行的`1`匹配，我们得到了每一行与每一行的匹配——这就是一个真正的交叉连接。
- en: As an alternative, with many other server-based data sources, you can use **Custom
    SQL** as a data source. On the **Data Source** screen, with the **Patient Visits**
    table in the designer, you could use the top menu to select **Data** | **Convert
    to Custom SQL** to edit the SQL script that Tableau uses for the source. Alternatively,
    you can write your own custom SQL using the **New Custom SQL** object on the left
    sidebar.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，对于许多其他基于服务器的数据源，您可以使用**自定义 SQL**作为数据源。在**数据源**屏幕上，使用设计器中的**患者访问**表，您可以使用顶部菜单选择**数据**
    | **转换为自定义 SQL**来编辑 Tableau 用于源的 SQL 脚本。或者，您也可以在左侧边栏使用**新建自定义 SQL**对象编写自己的自定义
    SQL。
- en: 'The script in this alternative example has been modified to include `1 AS Join`
    to create a field, called **Join**, with a value of `1` for every row (though,
    if you didn''t do this in the script, you could simply use a join calculation).
    Fields defined in Custom SQL can also be used in joins:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个替代示例中的脚本已被修改，加入了`1 AS Join`来创建一个名为**Join**的字段，字段值为每行`1`（尽管如果您没有在脚本中这样做，您也可以简单地使用连接计算）。在自定义
    SQL 中定义的字段也可以用于连接：
- en: '![](img/B16021_14_18.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_18.png)'
- en: 'Figure 14.18: A sample script that could be used to create a value on which
    to join'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.18：一个可以用来创建连接值的示例脚本
- en: 'Based on the join calculation, our new cross-joined dataset contains a record
    for every patient for every date, and we can now create a quick calculation to
    see whether a patient should be counted as part of the hospital population on
    any given date. The calculated field, named **Patients in Hospital**, has the
    following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 基于连接计算，我们新的交叉连接数据集包含了每个患者每个日期的记录，现在我们可以创建一个快速计算，查看某个患者是否应被计入特定日期的医院人口。名为**医院中的患者**的计算字段包含以下代码：
- en: '[PRE1]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This allows us to easily visualize the flow of patients, and even potentially
    perform advanced analytics based on averages, trends, and even forecasting:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够轻松可视化患者流动，甚至可能基于平均值、趋势，甚至预测进行高级分析：
- en: '![](img/B16021_14_19.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_19.png)'
- en: 'Figure 14.19: A visualization of the daily hospital population, made easy with
    some data restructuring'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.19：经过数据重构后的每日医院人口可视化图表，使得分析变得简单。
- en: Ultimately, for a long-term solution, you might want to consider developing
    a server-based data source that gives the structure that's needed for the desired
    analysis. However, a join here allowed us to achieve the analysis without waiting
    on a long development cycle.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，对于长期解决方案，你可能希望考虑开发一个基于服务器的数据源，以提供所需分析的结构。然而，这里的连接允许我们在不等待长时间开发周期的情况下实现分析。
- en: 'Having considered examples of pivots, unions, and joins, let''s turn our focus
    to an example of the final major transformation type: aggregation.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了枢轴、联合和连接的例子之后，让我们将焦点转向最终主要的转换类型之一：聚合。
- en: Aggregation
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合
- en: 'Remember that the two keys to a good data structure are as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，良好数据结构的两个关键要素如下：
- en: Having a level of detail that is meaningful
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有有意义的细节级别
- en: Having measures that match the level of detail or that are possibly at higher
    levels of detail
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有与细节级别相匹配的度量，或者可能处于更高细节级别的度量
- en: Measures at lower levels tend to result in wide data and can make some analysis
    difficult or even impossible. Measures at higher levels of detail can, at times,
    be useful. As long as we are aware of how to handle them correctly, we can avoid
    some pitfalls.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 处于较低细节级别的度量往往导致数据变得很宽，可能会使某些分析变得困难，甚至不可能。而较高细节级别的度量，有时也可能是有用的。只要我们了解如何正确处理它们，就可以避免一些陷阱。
- en: 'Consider, for example, the following data (included as `Apartment Rent.xlsx`
    in the `Chapter 14` directory), which gives us a single record each month per
    apartment:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，考虑以下数据（该数据以`Apartment Rent.xlsx`文件形式包含在`Chapter 14`目录中），该数据为每个公寓每个月提供一个记录：
- en: '![](img/B16021_14_20.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_20.png)'
- en: 'Figure 14.20: The Apartment Rent data, which is poorly structured because the
    Square Feet measure is repeated for every month'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.20：公寓租金数据，由于每个月的平方英尺（Square Feet）度量值被重复记录，结构较差。
- en: 'The two measures are really at different levels of detail:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个度量值实际上位于不同的细节级别：
- en: '**Rent Collected** matches the level of detail of the data where there is a
    record of how much rent was collected for each apartment for each month.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收取的租金（Rent Collected）**与数据的细节级别相匹配，其中记录了每月每个公寓的租金收入。'
- en: '**Square Feet**, on the other hand, does not change month to month. Rather,
    it is at the higher level of detail, of **Apartment** only.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，**平方英尺（Square Feet）**每个月并不变化。相反，它处于较高的细节级别，仅限于**公寓**。
- en: Tableau's data model would make this data very easy to work with if it was contained
    in two tables at the correct level of detail. If it was in a relational database
    where we could use a custom SQL statement to create a couple of tables at the
    right level of detail, we might consider that approach. In the next chapter, we'll
    consider how Tableau Prep could be used to easily solve this problem. For now,
    work through the details to gain some understanding of how to deal with aggregation
    issues if you are faced with a similar poor structure (and you'll gain an immense
    appreciation for what Tableau Prep and the Tableau data model can do!).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据被包含在两个表格中，且细节级别正确，Tableau 的数据模型会使得这些数据非常容易处理。如果数据存储在关系型数据库中，我们可以使用自定义 SQL
    语句创建几个具有正确细节级别的表格，那么我们可能会考虑这种方法。在下一章中，我们将讨论如何使用 Tableau Prep 来轻松解决这个问题。现在，请逐步分析这些细节，以便理解如何应对类似的结构问题（这样你会对
    Tableau Prep 和 Tableau 数据模型能做的事情有深刻的认识！）。
- en: 'The difference in levels of detail can be observed when we remove the date
    from the view and look at everything at the **Apartment** level:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 细节级别的差异可以通过移除视图中的日期，并查看所有数据的**公寓**级别来观察：
- en: '![](img/B16021_14_21.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_21.png)'
- en: 'Figure 14.21: An illustration of how various aggregations might be right or
    wrong depending on the level of detail'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.21：展示了不同聚合方式在不同细节级别下是否正确的插图。
- en: Notice that the **SUM(Rent Collected)** makes perfect sense. You can add up
    the rent collected per month and get a meaningful result per apartment. However,
    you cannot `Sum` **Square Feet** and get a meaningful result per apartment. Other
    aggregations, such as average, minimum, and maximum, do give the right results
    per apartment.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**SUM(收取的租金)** 是完全合理的。你可以将每个月收取的租金加总起来，并得出每个公寓的有意义的结果。然而，你不能对**平方英尺（Square
    Feet）**进行求和并得到每个公寓的有意义结果。其他聚合方法，如平均值、最小值和最大值，确实能给出每个公寓的正确结果。
- en: However, imagine that you were asked to come up with the ratio of total rent
    collected to square feet per apartment. You know it will be an aggregate calculation
    because you have to sum the rent that's collected prior to dividing. But which
    of the following is the correct calculation?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设您被要求计算每个公寓的租金与平方英尺的比率。您知道这将是一个聚合计算，因为您需要先将收取的租金求和再进行除法。但以下哪个是正确的计算方法呢？
- en: '`SUM([Rent Collected])/SUM([Square Feet])`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUM([收取租金])/SUM([平方英尺])`'
- en: '`SUM([Rent Collected])/AVG([Square Feet])`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUM([收取租金])/AVG([平方英尺])`'
- en: '`SUM([Rent Collected])/MIN([Square Feet])`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUM([收取租金])/MIN([平方英尺])`'
- en: '`SUM([Rent Collected])/MAX([Square Feet])`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUM([收取租金])/MAX([平方英尺])`'
- en: The first one is obviously wrong. We've already seen that square feet should
    not be added each month. Any of the final three would be correct if we ensure
    that **Apartment** continues to define the level of detail of the view.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个显然是错误的。我们已经看到每个月不应该添加平方英尺。只要确保**公寓**继续定义视图的详细级别，最后三个中的任何一个都是正确的。
- en: 'However, once we look at the view that has a different level of detail (for
    example, the total for all apartments or the monthly total for multiple apartments),
    the calculations don''t work. To understand why, consider what happens when we
    turn on the column grand totals (from the menu, select **Analysis** | **Totals**
    | **Show Column Grand Totals**, or drag and drop **Totals** from the **Analytics**
    tab):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们查看具有不同详细级别的视图（例如，所有公寓的总计或多个公寓的每月总计），这些计算就不起作用了。要理解原因，请考虑当我们打开列总计（从菜单中选择**分析**
    | **总计** | **显示列总计**，或者从**分析**选项卡中拖放**总计**）时会发生什么：
- en: '![](img/B16021_14_22.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_22.png)'
- en: 'Figure 14.22: None of the aggregations work to give us a grand total'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.22：没有一种聚合方式可以给我们提供总计
- en: The problem here is that the **Grand Total** line is at the level of detail
    of all apartments (for all months). What we really want as the **Grand Total**
    of square feet is `900 + 750 = 1,650`. However, here, the sum of square feet is
    the addition of square feet for all apartments for all months. The average won't
    work. The minimum finds the value **750** as the smallest measure for all apartments
    in the data. Likewise, the maximum picks **900** as the single largest value.
    Therefore, none of the proposed calculations would work at any level of detail
    that does not include the individual apartment.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题在于**总计**行位于所有公寓（所有月份）的详细级别。实际上，我们真正想要的**总计**平方英尺是 `900 + 750 = 1,650`。然而，在这里，平方英尺的总和是所有公寓所有月份的平方英尺相加。平均值不适用。最小值找到
    **750** 作为数据中所有公寓的最小度量。同样地，最大值选择 **900** 作为单个最大值。因此，任何提议的计算方法在不包括单个公寓的详细级别时都不会起作用。
- en: You can adjust how subtotals and grand totals are computed by clicking on the
    individual value and using the drop-down menu to select how the total is computed.
    Alternatively, right-click on the active measure field and select **Total Using**.
    You can change how all measures are totaled at once from the menu by selecting
    **Analysis** | **Totals** | **Total All Using**. Using this **two-pass total**
    technique could result in correct results in the preceding view, but it would
    not universally solve the problem. For example, if you wanted to show the price
    per square foot for each month, you'd have the same issue.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击单个值并使用下拉菜单选择总计方式来调整子总计和总计的计算方式。或者，右键单击活动度量字段并选择**使用总计**。您可以从菜单中选择**分析**
    | **总计** | **全部使用总计**来一次性更改所有度量的总计方式。使用这种**两遍总计**技术可以在先前的视图中得到正确的结果，但不能普遍解决问题。例如，如果您想显示每月每平方英尺的价格，您将面临同样的问题。
- en: Fortunately, Tableau gives us the ability to work with different levels of detail
    in a view. Using **Level of Detail** (**LOD**) calculations, which we encountered
    in *Chapter 5*, *Leveraging Level of Detail Calculations*, we can calculate the
    square feet per apartment.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Tableau允许我们在视图中处理不同的详细级别。使用我们在*第5章*，*利用详细级别计算*中遇到的**详细级别**（LOD）计算，我们可以计算每个公寓的平方英尺。
- en: 'Here, we''ll use a fixed LOD calculation to keep the level of detail fixed
    at the apartment level. We''ll create a calculated field, named `Square Feet per
    Apartment`, with the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用固定的LOD计算来保持公寓级别的详细信息不变。我们将创建一个名为`每个公寓的平方英尺`的计算字段，其代码如下：
- en: '[PRE2]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The curly braces surround a LOD calculation and the keyword `INCLUDE` indicates
    that we want to include `Apartment` as part of the level of detail for the calculation,
    even if it is not included in the view level of detail. `MIN` is used in the preceding
    code, but `MAX` or `AVG` could have been used as well because all give the same
    result per apartment.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号包围了一个LOD计算，关键字`INCLUDE`表示我们希望将`公寓`包含为计算的详细级别的一部分，即使它不包含在视图详细级别中。在前述代码中使用了`MIN`，但也可以使用`MAX`或`AVG`，因为所有这些都会得到每个公寓相同的结果。
- en: 'As you can see, the calculation returns the correct result in the view at the
    apartment level and at the grand total level, where Tableau includes **Apartment**
    to find **900** (the minimum for **A**) and **750** (the minimum for **B**) and
    then sums them to get **1,650**:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，计算返回了视图级别和总计级别的正确结果，在这里Tableau包括**公寓**以找到**900**（**A**的最小值）和**750**（**B**的最小值），然后将它们求和得到**1,650**：
- en: '![](img/B16021_14_23.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_23.png)'
- en: 'Figure 14.23: An LOD calculation gives us the correct result at all levels
    of detail'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.23：LOD计算为我们提供了所有详细级别上的正确结果
- en: 'Now, we can use the LOD calculated field in another calculation to determine
    the desired results. We''ll create a calculated field, named `Rent Collected per
    Square Foot`, with the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在另一个计算中使用LOD计算字段来确定所需的结果。我们将创建一个名为`每平方英尺收集的租金`的计算字段，并使用以下代码：
- en: '[PRE3]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When that field is added to the view and formatted to show decimals, the final
    outcome is correct:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当该字段添加到视图并格式化以显示小数时，最终结果是正确的：
- en: '![](img/B16021_14_24.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_14_24.png)'
- en: 'Figure 14.24: The LOD expression gives us the foundation for even more complexity,
    such as calculating the rent per area'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.24：LOD表达式为我们提供了更复杂的基础，例如计算每个区域的租金
- en: Alternatively, instead of using `INCLUDE`, we could have used a `FIXED` level
    of detail, which is always performed at the level of detail of the dimension(s)
    following the `FIXED` keywords, regardless of what level of detail is defined
    in the view. This would have told Tableau to always calculate the minimum square
    feet per apartment, regardless of what dimensions define the view level of detail.
    While very useful, be aware that the `FIXED` LOD calculations are calculated for
    the entire context (either the entire dataset or the subset defined by the **context
    filters**). Using them without understanding this can yield unexpected results.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`FIXED`级别的详细信息，而不是使用`INCLUDE`。这总是在遵循`FIXED`关键字后的维度级别上执行，而不管视图中定义的详细级别是什么。这将告诉Tableau始终计算每个公寓的最小平方英尺，而不管定义视图级别的维度是什么。虽然非常有用，请注意，`FIXED`
    LOD计算是针对整个上下文（整个数据集或由**上下文筛选器**定义的子集）计算的。如果不理解这一点，使用它们可能会产生意想不到的结果。
- en: For now, we've learned how to handle some aggregation issues; however, in the
    next chapter, we'll explore how we can truly transform the data with aggregations
    to make problems like the previous exercise much easier. In the meantime, let's
    consider some alternative fixes for data problems.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经学会了如何处理一些聚合问题；然而，在下一章中，我们将探讨如何通过聚合来真正转换数据，使类似前面练习的问题变得更加容易。与此同时，让我们考虑一些数据问题的替代修复方法。
- en: Overview of advanced fixes for data problems
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据问题的高级修复概述
- en: 'In addition to the techniques that we mentioned earlier in this chapter, there
    are some additional possibilities to deal with data structure issues. It is outside
    the scope of this book to develop these concepts fully. However, with some familiarity
    of these approaches, you can broaden your ability to deal with challenges as they
    arise:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章早些时候提到的技术之外，还有一些额外的方法来处理数据结构问题。本书不涵盖完全发展这些概念。然而，通过一些对这些方法的熟悉，你可以扩展自己解决挑战的能力：
- en: '**Custom SQL**: It can be used in the data connection to resolve some data
    problems. Beyond giving a field for a cross-database join, as we saw earlier,
    custom SQL can be used to radically reshape the data that''s retrieved from the
    source. Custom SQL is not an option for all data sources, but it is an option
    for many relational databases. Consider a custom SQL script that takes the wide
    table of country populations we mentioned earlier in this chapter and restructures
    it into a tall table:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义SQL**：它可以用于数据连接以解决一些数据问题。除了为跨数据库连接提供字段，如我们之前看到的，自定义SQL还可以用于根本重塑从源中检索的数据。自定义SQL并非适用于所有数据源，但适用于许多关系型数据库。考虑一个自定义SQL脚本，将我们之前在本章中提到的国家人口的宽表重构为高表：'
- en: '[PRE4]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And so on. It might be a little tedious to set up, but it will make the data
    much easier to work with in Tableau! However, many data sources using complex
    custom SQL will need to be extracted for performance reasons.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等等。虽然设置起来可能有些繁琐，但这将使得在Tableau中处理数据变得更加容易！然而，许多使用复杂自定义SQL的数据源出于性能考虑需要进行提取。
- en: '**Table calculations**: Table calculations can be used to solve a number of
    data challenges, from finding and eliminating duplicate records to working with
    multiple levels of detail. Since table calculations can work within partitions
    at higher levels of detail, you can use multiple table calculations and aggregate
    calculations together to mix levels of detail in a single view. A simple example
    of this is the **Percent of Total** table calculation, which compares an aggregate
    calculation at the level of detail in the view with a total at a higher level
    of detail.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表格计算**：表格计算可以用于解决许多数据挑战，从查找和消除重复记录到处理多个细节级别。由于表格计算可以在更高细节级别的分区内工作，你可以将多个表格计算与聚合计算结合使用，在一个视图中混合不同的细节级别。一个简单的例子是**总百分比**表格计算，它将视图中细节级别的聚合计算与更高细节级别的总计进行比较。'
- en: '**Data blending**: Data blending can be used to solve numerous data structure
    issues. Because you can define the linking fields that are used, you can control
    the level of detail of the blend.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据混合**：数据混合可以用来解决许多数据结构问题。由于你可以定义所使用的连接字段，你可以控制混合的细节级别。'
- en: '**Data scaffolding**: Data scaffolding extends the concept of data blending.
    With this approach, you construct a scaffold of various dimensional values to
    use as a primary source and then blend them to one or more secondary sources.
    In this way, you can control the structure and granularity of the primary source
    while still being able to leverage data that''s contained in the secondary sources.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据支架**：数据支架扩展了数据混合的概念。在这种方法中，你构建一个由各种维度值组成的支架，作为主要数据源，然后将它们与一个或多个次要数据源进行混合。通过这种方式，你可以控制主要数据源的结构和粒度，同时仍然能够利用次要数据源中的数据。'
- en: '**Data model**: Data blending is useful when you need to control the level
    of the relationship per view. If the relationship is better defined, the data
    model will give you incredible power to relate tables that are at different levels
    of detail and have confidence that aggregations will work correctly.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据模型**：数据混合在你需要控制每个视图的关系级别时非常有用。如果关系定义得更好，数据模型将为你提供强大的能力，将不同细节级别的表格关联起来，并确保聚合计算能够正确执行。'
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Up until this chapter, we'd looked at data that was, for the most part, well-structured
    and easy to use. In this chapter, we considered what constitutes a good structure
    and ways to deal with poor data structures. A good structure consists of data
    that has a meaningful level of detail and that has measures that match that level
    of detail. When measures are spread across multiple columns, we get data that
    is wide instead of tall.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了大多数结构良好且易于使用的数据。在这一章中，我们考虑了什么构成良好的结构以及如何处理不良的数据结构。一个良好的结构由具有有意义细节级别的数据组成，并且具有与该细节级别相匹配的度量。当度量分布在多个列中时，我们得到的是宽数据而非高数据。
- en: 'We also spent some time understanding the basic types of transformation: pivots,
    unions, joins, and aggregations. Understanding these will be fundamental to solving
    data structure issues.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还花了一些时间理解了基本的转换类型：数据透视、联合、连接和聚合。理解这些对于解决数据结构问题至关重要。
- en: You also got some practical experience in applying various techniques to deal
    with data that has the wrong shape or has measures at the wrong level of detail.
    Tableau gives us the power and flexibility to deal with some of these structural
    issues, but it is far preferable to fix a data structure at the source.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你还获得了一些实际经验，应用各种技术来处理具有错误形状或度量级别不匹配的数据。Tableau赋予我们处理一些结构性问题的能力和灵活性，但最好在源头上修复数据结构。
- en: In the next chapter, we'll take a brief pause from looking at Tableau Desktop
    to consider Tableau Prep, another alternative to tackle challenging data!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将暂时停下来不看Tableau Desktop，转而考虑Tableau Prep，另一个解决复杂数据问题的替代工具！
