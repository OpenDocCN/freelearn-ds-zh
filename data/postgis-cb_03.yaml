- en: Working with Vector Data – The Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理矢量数据 - 基础
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Working with GPS data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GPS 数据
- en: Fixing invalid geometries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复无效几何形状
- en: GIS analysis with spatial joins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空间连接进行 GIS 分析
- en: Simplifying geometries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化几何形状
- en: Measuring distances
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量距离
- en: Merging polygons using a common attribute
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用公共属性合并多边形
- en: Computing intersections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算交集
- en: Clipping geometries to deploy data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将几何形状裁剪以部署数据
- en: Simplifying geometries with PostGIS topology
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PostGIS 拓扑简化几何形状
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, you will work with a set of PostGIS functions and vector datasets.
    You will first take a look at how to use PostGIS with GPS data—you will import
    such datasets using `ogr2ogr` and then compose polylines from point geometries
    using the `ST_MakeLine` function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用一组 PostGIS 函数和矢量数据集。你首先将了解如何使用 PostGIS 与 GPS 数据交互——你将使用 `ogr2ogr` 导入此类数据集，然后使用
    `ST_MakeLine` 函数从点几何形状中组合折线。
- en: Then, you will see how PostGIS helps you find and fix invalid geometries with
    functions such as `ST_MakeValid`, `ST_IsValid`, `ST_IsValidReason`, and `ST_IsValidDetails`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将看到 PostGIS 如何帮助你使用诸如 `ST_MakeValid`、`ST_IsValid`、`ST_IsValidReason` 和 `ST_IsValidDetails`
    等函数查找和修复无效的几何形状。
- en: You will then learn about one of the most powerful elements of a spatial database,
    spatial joins. PostGIS provides you with a rich set of operators, such as `ST_Intersects`,
    `ST_Contains`, `ST_Covers`, `ST_Crosses`, and `ST_DWithin`, for this purpose.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将了解空间数据库中最强大的元素之一，空间连接。PostGIS 为你提供了一组丰富的运算符，例如 `ST_Intersects`、`ST_Contains`、`ST_Covers`、`ST_Crosses`
    和 `ST_DWithin`，用于此目的。
- en: After that, you will use the `ST_Simplify` and `ST_SimplifyPreverveTopology`
    functions to simplify (generalize) geometries when you don't need too many details.
    While this function works well on linear geometries, topological anomalies may
    be introduced for polygonal ones. In such cases, you should consider using an
    external GIS tool such as `GRASS`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将使用 `ST_Simplify` 和 `ST_SimplifyPrevergeTopology` 函数简化（泛化）几何形状，当你不需要太多细节时。虽然此函数在线性几何形状上表现良好，但对于多边形可能会引入拓扑异常。在这种情况下，你应该考虑使用外部
    GIS 工具，如 `GRASS`。
- en: You will then have a tour of PostGIS functions to make distance measurements—`ST_Distance`,
    `ST_DistanceSphere`, and `ST_DistanceSpheroid` are on the way.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将游览 PostGIS 函数以进行距离测量——`ST_Distance`、`ST_DistanceSphere` 和 `ST_DistanceSpheroid`
    都在途中。
- en: One of the recipes explained in this chapter will guide you through the typical
    GIS workflow to merge polygons based on a common attribute; you will use the `ST_Union`
    function for this purpose.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中解释的一个菜谱将指导你通过典型的 GIS 工作流程根据公共属性合并多边形；你将使用 `ST_Union` 函数来完成此目的。
- en: You will then learn how to clip geometries using the `ST_Intersection` function,
    before deep diving into the **PostGIS topology** in the last recipe that was introduced
    in version 2.0.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将学习如何使用 `ST_Intersection` 函数裁剪几何形状，在最后介绍的第 2.0 版本中深入探讨 **PostGIS 拓扑**。
- en: Working with GPS data
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GPS 数据
- en: In this recipe, you will work with GPS data. This kind of data is typically
    saved in a `.gpx` file. You will import a bunch of `.gpx` files to PostGIS from
    **RunKeeper**, a popular social network for runners.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将使用 GPS 数据。这类数据通常保存在 `.gpx` 文件中。你将从流行的跑步者社交网络 **RunKeeper** 导入一系列 `.gpx`
    文件到 PostGIS。
- en: If you have an account on RunKeeper, you can export your `.gpx` files and process
    them by following the instructions in this recipe. Otherwise, you can use the
    RunKeeper `.gpx` files included in the `runkeeper-gpx.zip` file located in the
    `chp03` directory available in the code bundle for this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个 RunKeeper 账户，你可以导出你的 `.gpx` 文件，并按照本菜谱中的说明进行处理。否则，你可以使用位于代码包中 `chp03`
    目录下的 `runkeeper-gpx.zip` 文件中包含的 RunKeeper `.gpx` 文件。
- en: You will first create a `bash` script for importing the `.gpx` files to a PostGIS
    table, using `ogr2ogr`. After the import is completed, you will try to write a
    couple of SQL queries and test some very useful functions, such as `ST_MakeLine`
    to generate polylines from point geometries, `ST_Length` to compute distance,
    and `ST_Intersects` to perform a spatial join operation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先将创建一个 `bash` 脚本，使用 `ogr2ogr` 将 `.gpx` 文件导入到 PostGIS 表中。导入完成后，你将尝试编写一些 SQL
    查询，并测试一些非常有用的函数，例如 `ST_MakeLine` 从点几何形状生成折线，`ST_Length` 计算距离，以及 `ST_Intersects`
    执行空间连接操作。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Extract the `data/chp03/runkeeper-gpx.zip` file to `working/chp03/runkeeper_gpx`.
    In case you haven't been through [Chapter 1](38f20dd1-ca55-47e8-80cd-21670bcb32b2.xhtml),
    *Moving Data In and Out of PostGIS*, be sure to have the `countries` dataset in
    the PostGIS database.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `data/chp03/runkeeper-gpx.zip` 文件解压到 `working/chp03/runkeeper_gpx`。如果你还没有通过
    [第 1 章](38f20dd1-ca55-47e8-80cd-21670bcb32b2.xhtml)，*在 PostGIS 中移动数据进和出*，确保 `countries`
    数据集在 PostGIS 数据库中。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, be sure of the format of the `.gpx` files that you need to import to
    PostGIS. Open one of them and check the file structure—each file must be in the
    XML format composed of just one `<trk>` element, which contains just one `<trkseg>`
    element, which contains many `<trkpt>` elements (the points stored from the runner''s
    GPS device). Import these points to a PostGIS `Point` table:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你需要的 `.gpx` 文件格式正确。打开其中一个并检查文件结构——每个文件必须由一个 `<trk>` 元素组成，该元素包含一个 `<trkseg>`
    元素，该元素包含多个 `<trkpt>` 元素（从跑步者的 GPS 设备存储的点）。将这些点导入到 PostGIS 的 `Point` 表中：
- en: 'Create a new schema named `chp03` to store the data for all the recipes in
    this chapter, using the following command:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个名为 `chp03` 的新模式，用于存储本章中所有食谱的数据：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the `chp03.rk_track_points` table in PostgreSQL by executing the following
    command lines:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PostgreSQL 中通过执行以下命令行创建 `chp03.rk_track_points` 表：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create the following script to import all of the `.gpx` files in the `chp03.rk_track_points`
    table using the GDAL `ogr2ogr` command.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下脚本，使用 GDAL 的 `ogr2ogr` 命令将 `chp03.rk_track_points` 表中的所有 `.gpx` 文件导入：
- en: 'The following is the Linux version (name it `working/chp03/import_gpx.sh`):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Linux 上的版本（命名为 `working/chp03/import_gpx.sh`）：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the command for macOS (name it `working/chp03/import_gpx.sh`):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 macOS 上的命令（命名为 `working/chp03/import_gpx.sh`）：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the Windows version (name it `working/chp03/import_gpx.bat`):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Windows 上的版本（命名为 `working/chp03/import_gpx.bat`）：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In Linux and macOS, don''t forget to assign execution permission to the script
    before running it. Then, run the following script:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Linux 和 macOS 中，在运行之前别忘了为脚本分配执行权限。然后，运行以下脚本：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In Windows, just double-click on the `.bat` file or run it from the command
    prompt using the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，只需双击 `.bat` 文件或从命令提示符使用以下命令运行它：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, create a polyline table containing a single runner''s track details using
    the `ST_MakeLine` function. Assume that on each distinct day, the runner had just
    one training session. In this table, you should include the start and end times
    of the track details as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `ST_MakeLine` 函数创建一个包含单个跑步者轨迹详情的多线表。假设跑步者在每个不同的日子只进行了一次训练。在这个表中，你应该包括轨迹详情的开始和结束时间，如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before querying the created tables, don''t forget to add spatial indexes to
    both of the tables to improve their performance, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查询创建的表之前，别忘了为两个表都添加空间索引以提高其性能，如下所示：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you try to open both the spatial tables on a desktop GIS on any given day,
    you should see that the points from the `rk_track_points` table compose a single
    polyline geometry record in the `tracks` table, as shown in the following screenshot:![](img/75e2ab83-d45c-4356-a7a4-96d40fb6f75f.png)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在任何给定的一天尝试在一个桌面 GIS 上打开这两个空间表，你应该会看到 `rk_track_points` 表中的点在 `tracks` 表中组成一个单独的多线几何记录，如下面的截图所示：![图片](img/75e2ab83-d45c-4356-a7a4-96d40fb6f75f.png)
- en: 'If you open all the tracks from a desktop GIS (such as QGIS), you will see
    the following:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在一个桌面 GIS（如 QGIS）中打开所有轨迹，你会看到以下内容：
- en: '![](img/976a2634-7f01-406a-b31f-9ba46e78f269.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/976a2634-7f01-406a-b31f-9ba46e78f269.png)'
- en: 'Now, query the `tracks` table to get a report of the total distance run (in
    km) by the runner for each month. For this purpose, use the `ST_Length` function,
    as shown in the following query:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，查询 `tracks` 表以获取跑步者每月跑步的总距离报告（单位：公里）。为此，使用 `ST_Length` 函数，如下所示：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](img/3c37c7e0-6d36-4fba-b9fc-5e3fef87ace9.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c37c7e0-6d36-4fba-b9fc-5e3fef87ace9.png)'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using a spatial join between the `tracks` and `countries` tables, and again
    using the `ST_Length` function as follows, you will get a report of the distance
    run (in km) by the runner, per country:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `tracks` 和 `countries` 表之间进行空间连接，并再次使用 `ST_Length` 函数，如下所示，你可以得到跑步者按国家计算的跑步距离报告（单位：公里）：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/397cdfbd-2aee-4418-a918-909e96d7a0ea.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/397cdfbd-2aee-4418-a918-909e96d7a0ea.png)'
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `.gpx` files store all the points' details in the WGS 84 spatial reference
    system; therefore, we created the `rk_track_points` table with SRID (4326).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`.gpx` 文件存储所有点的详情在 WGS 84 空间参考系中；因此，我们创建了具有 SRID（4326）的 `rk_track_points` 表。'
- en: After creating the `rk_track_points` table, we imported all of the `.gpx` files
    in the `runkeeper_gpx` directory using a bash script. The bash script iterates
    all of the files with the extension `*.gpx` in the `runkeeper_gpx` directory.
    For each of these files, the script runs the `ogr2ogr` command, importing the
    `.gpx` files to PostGIS using the GPX GDAL driver (for more details, go to [http://www.gdal.org/drv_gpx.html](http://www.gdal.org/drv_gpx.html)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `rk_track_points` 表之后，我们使用 bash 脚本导入了 `runkeeper_gpx` 目录中的所有 `.gpx` 文件。该
    bash 脚本迭代 `runkeeper_gpx` 目录中所有扩展名为 `*.gpx` 的文件。对于这些文件中的每一个，脚本运行 `ogr2ogr` 命令，使用
    GPX GDAL 驱动程序将 `.gpx` 文件导入到 PostGIS 中（更多详情，请参阅 [http://www.gdal.org/drv_gpx.html](http://www.gdal.org/drv_gpx.html))。
- en: 'In the GDAL''s abstraction, a `.gpx` file is an OGR data source composed of
    several layers as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GDAL 的抽象中，一个 `.gpx` 文件是一个由几个层组成的 OGR 数据源，如下所示：
- en: '![](img/630b3479-afb7-4e3e-bcb8-af32f7a96042.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/630b3479-afb7-4e3e-bcb8-af32f7a96042.png)'
- en: In the `.gpx` files (OGR data sources), you have just the `tracks` and `track_points`
    layers. As a shortcut, you could have imported just the `tracks` layer using `ogr2ogr`,
    but you would need to start from the `track_points` layer in order to generate
    the `tracks` layer itself, using some PostGIS functions. This is why in the `ogr2ogr`
    section in the bash script, we imported to the `rk_track_points` PostGIS table
    the point geometries from the `track_points` layer, plus a couple of useful attributes,
    such as `elevation` and `timestamp`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.gpx` 文件（OGR 数据源）中，你只有 `tracks` 和 `track_points` 层。作为一个快捷方式，你可以使用 `ogr2ogr`
    只导入 `tracks` 层，但你需要从 `track_points` 层开始，以便使用一些 PostGIS 函数生成 `tracks` 层本身。这就是为什么在
    bash 脚本中的 `ogr2ogr` 部分中，我们将来自 `track_points` 层的点几何形状以及一些有用的属性（如 `elevation` 和
    `timestamp`）导入到 `rk_track_points` PostGIS 表中。
- en: Once the records were imported, we fed a new polylines table named `tracks`
    using a subquery and selected all of the point geometries and their dates and
    times from the `rk_track_points` table, grouped by date and with the geometries
    aggregated using the `ST_MakeLine` function. This function was able to create
    linestrings from point geometries (for more details, go to [http://www.postgis.org/docs/ST_MakeLine.html](http://www.postgis.org/docs/ST_MakeLine.html)).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导入记录，我们使用子查询向名为 `tracks` 的新多段线表中输入数据，并从 `rk_track_points` 表中选择了所有点几何形状及其日期和时间，按日期分组，并使用
    `ST_MakeLine` 函数对几何形状进行聚合。此函数能够从点几何形状创建线字符串（更多详情，请参阅 [http://www.postgis.org/docs/ST_MakeLine.html](http://www.postgis.org/docs/ST_MakeLine.html))。
- en: You should not forget to sort the points in the subquery by `datetime`; otherwise,
    you will obtain an irregular linestring, jumping from one point to the other and
    not following the correct order.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该忘记在子查询中按 `datetime` 对点进行排序；否则，你将获得一个不规则的线字符串，从一个点到另一个点跳跃，并且不遵循正确的顺序。
- en: After loading the `tracks` table, we tested the two spatial queries.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载 `tracks` 表之后，我们测试了两个空间查询。
- en: At first, you got a month-by-month report of the total distance run by the runner.
    For this purpose, you selected all of the track records grouped by date (year
    and month), with the total distance obtained by summing up the lengths of the
    single tracks (obtained with the `ST_Length` function). To get the year and the
    month from the `run_date` function, you used the PostgreSQL `EXTRACT` function.
    Be aware that if you measure the distance using geometries in the WGS 84 system,
    you will obtain it in degree units. For this reason, you have to project the geometries
    to a planar metric system designed for the specific region from which the data
    will be projected.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你得到了跑步者每月跑步总距离的报告。为此目的，你选择了按日期（年和月）分组的所有轨迹记录，通过将单条轨迹的长度（使用 `ST_Length` 函数获得）相加来获得总距离。要从
    `run_date` 函数中获取年和月，你使用了 PostgreSQL 的 `EXTRACT` 函数。请注意，如果你使用 WGS 84 系统中的几何形状来测量距离，你将获得以度为单位的结果。因此，你必须将几何形状投影到一个为特定区域设计的平面度量系统中，该区域的数据将被投影。
- en: For large-scale areas, such as in our case where we have points that span all
    around Europe, as shown in the last query results, a good option is to use the
    `geography` data type introduced with PostGIS 1.5\. The calculations may be slower,
    but are much more accurate than in other systems. This is the reason why you cast
    the geometries to the `geography` data type before making measurements.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大规模区域，例如在我们的案例中，我们有一些跨越整个欧洲的点，如最后查询结果所示，一个好的选择是使用 PostGIS 1.5 中引入的 `geography`
    数据类型。计算可能会慢一些，但比其他系统更准确。这就是为什么在测量之前将几何形状转换为 `geography` 数据类型的原因。
- en: The last spatial query used a spatial join with the `ST_Intersects` function
    to get the name of the country for each track the runner ran (with the assumption
    that the runner didn't run cross-border tracks). Getting the total distance run
    per country is just a matter of aggregating the selection on the `country_name`
    field and aggregating the track distances with the PostgreSQL `SUM` operator.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个空间查询使用了 `ST_Intersects` 函数进行空间连接，以获取跑步者每条跑步轨迹所在国家的名称（假设跑步者没有跑过跨国轨迹）。获取每个国家跑步的总距离只需对
    `country_name` 字段的选择进行聚合，并使用 PostgreSQL 的 `SUM` 操作符对轨迹距离进行聚合。
- en: Fixing invalid geometries
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复无效几何形状
- en: You will often find invalid geometries in your PostGIS database. These invalid
    geometries could compromise the functioning of PostGIS itself and any external
    tool using it, such as QGIS and MapServer. PostGIS, being compliant with the OGC
    Simple Feature Specification, must manage and work with valid geometries.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常会在您的 PostGIS 数据库中找到无效的几何形状。这些无效的几何形状可能会损害 PostGIS 本身以及任何使用它的外部工具（如 QGIS 和
    MapServer）的功能。作为符合 OGC 简单特征规范的系统，PostGIS 必须管理和处理有效的几何形状。
- en: Luckily, PostGIS 2.0 offers you the `ST_MakeValid` function, which together
    with the `ST_IsValid`, `ST_IsValidReason`, and `ST_IsValidDetails` functions,
    is the ideal toolkit for inspecting and fixing geometries within the database.
    In this recipe, you will learn how to fix a common case of invalid geometry.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，PostGIS 2.0 为您提供了 `ST_MakeValid` 函数，该函数与 `ST_IsValid`、`ST_IsValidReason`
    和 `ST_IsValidDetails` 函数一起，是检查和修复数据库中几何形状的理想工具包。在本教程中，您将学习如何修复无效几何形状的常见情况。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Unzip the `data/TM_WORLD_BORDERS-0.3.zip` file into your working directory, `working/chp3`.
    Import the shapefile in PostGIS with the `shp2pgsql` command, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `data/TM_WORLD_BORDERS-0.3.zip` 文件解压到您的当前工作目录 `working/chp3` 中，然后使用 `shp2pgsql`
    命令将 shapefile 导入到 PostGIS 中，如下所示：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The file is also included with the name of `wborders` since for some operating
    systems, it does not work with the characters of `TM_WORLD_BORDERS-0.3.shp`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件还包含 `wborders` 名称，因为对于某些操作系统，它不能与 `TM_WORLD_BORDERS-0.3.shp` 中的字符一起使用。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The steps you need to perform to complete this recipe are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此教程所需执行的步骤如下：
- en: 'First, investigate whether or not any geometry is invalid in the imported table.
    As you can see in the following query, using the `ST_IsValid` and `ST_IsValidReason`
    functions, we find four invalid geometries that are all invalid for the same reason—ring
    self-intersection:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，调查导入的表中是否有任何几何形状无效。正如您在以下查询中可以看到的，使用 `ST_IsValid` 和 `ST_IsValidReason` 函数，我们找到了四个无效的几何形状，它们都是由于相同的理由——环自相交：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](img/9d492d78-48dd-4e87-95a7-244ff828e14c.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![无效几何形状图](img/9d492d78-48dd-4e87-95a7-244ff828e14c.png)'
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now concentrate on just one of the invalid geometries, for example, in the
    multipolygon geometry representing Russia. Create a table containing just the
    ring generating the invalidity, selecting the table using the point coordinates
    given in the `ST_IsValidReason` response in the previous step:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只关注一个无效的几何形状，例如，在表示俄罗斯的 multipolygon 几何形状中。创建一个只包含产生无效性的环的表，使用上一步 `ST_IsValidReason`
    响应中给出的点坐标选择该表：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`ST_MakeValid` requires GEOS 3.3.0 or higher; check whether or not your system
    supports it using the `PostGIS_full_version` function as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`ST_MakeValid` 函数需要 GEOS 3.3.0 或更高版本；您可以使用以下 `PostGIS_full_version` 函数来检查您的系统是否支持它：'
- en: '![](img/12ed12e5-57a6-44a6-831c-e467f4687927.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![步骤图](img/12ed12e5-57a6-44a6-831c-e467f4687927.png)'
- en: 'Now, using the `ST_MakeValid` function, add a new record in the previously
    created table with the valid version of the same geometry:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `ST_MakeValid` 函数，在之前创建的表中添加一个包含相同几何形状有效版本的记录：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open this geometry on your desktop GIS; the invalid geometry has just one self-intersecting
    ring that produces a hole in its internal. While this is accepted in the ESRI
    shapefile format specification (that was the original dataset you imported), the
    OGC standard does not allow for the self-intersecting ring, so neither does PostGIS:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的桌面 GIS 中打开此几何形状；无效的几何形状只有一个自相交的环，在内部产生一个洞。虽然这在 ESRI shapefile 格式规范中是可接受的（这是您最初导入的数据集），但
    OGC 标准不允许自相交的环，因此 PostGIS 也不允许：
- en: '![](img/3e410c76-e985-41de-b887-b34dd0790b6e.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![修复后的几何形状图](img/3e410c76-e985-41de-b887-b34dd0790b6e.png)'
- en: 'Now, in the `invalid_geometries` table, you have the invalid and valid versions
    of the polygon. It is easy to figure out that the self-intersecting ring was removed
    by `ST_MakeValid` adding one supplementary ring to the original polygon, which
    resulted in a valid geometry, according to the OGC standard:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，在`invalid_geometries`表中，你有多边形的无效和有效版本。很容易看出，自相交的环是通过`ST_MakeValid`移除的，它向原始多边形添加了一个补充环，从而根据OGC标准生成了一个有效的几何形状： '
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/572c141e-3931-4af7-83c7-d1f7f2e2fcb0.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/572c141e-3931-4af7-83c7-d1f7f2e2fcb0.png)'
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that you have identified the problem and its solution, don''t forget to
    fix all the other invalid geometries in the `countries` table by executing the
    following code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经确定了问题和解决方案，不要忘记通过执行以下代码修复`countries`表中的所有其他无效几何形状：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A smart way to not have invalid geometries in the database at all is by adding
    a `CHECK` constraint on the table to check for validity. This will increase the
    computation time when updating or inserting new geometries, but will keep your
    dataset valid. For example, in the `countries` table, this can be implemented
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一种聪明的做法是在数据库中完全不保留无效几何形状，即在表上添加一个`CHECK`约束来检查有效性。这将增加更新或插入新几何形状时的计算时间，但会保持你的数据集有效。例如，在`countries`表中，可以按以下方式实现：
- en: '`ALTER TABLE chp03.countries`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALTER TABLE chp03.countries`'
- en: '`ADD CONSTRAINT geometry_valid_check`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD CONSTRAINT geometry_valid_check`'
- en: '`CHECK (ST_IsValid(the_geom));`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHECK (ST_IsValid(the_geom));`'
- en: Many times in real use cases, though, you will need to remove such a constraint
    in order to be able to import records from a different source. After making validations
    with the `ST_MakeValid` function, you can safely add the constraint again.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，很多时候你需要移除这样的约束，以便能够从不同的来源导入记录。在用`ST_MakeValid`函数进行验证后，你可以安全地再次添加该约束。
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are a number of reasons why an invalid geometry could result in your database;
    for example, rings composed of polygons must be closed and cannot self-intersect
    or share more than one point with another ring.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因可能导致数据库中出现无效几何形状；例如，由多边形组成的环必须是闭合的，不能自相交或与另一个环共享超过一个点。
- en: After importing the `country` shapefile using the `ST_IsValid` and `ST_IsValidReason`
    functions, you will have figured out that four of the imported geometries are
    invalid, all because their polygons have self-intersecting rings.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`ST_IsValid`和`ST_IsValidReason`函数导入`country`形状文件后，你会发现有四个导入的几何形状是无效的，所有这些都是因为它们的多边形有自相交的环。
- en: At this point, a good way to investigate the invalid multipolygon geometry is
    by decomposing the polygon in to its component rings and checking out the invalid
    ones. For this purpose, we have exported the geometry of the ring causing the
    invalidity, using the `ST_GeometryN` function, which is able to extract the *n*^(th)
    ring from the polygon. We coupled this function with the useful PostgreSQL `generate_series`
    function to iterate all of the rings composing the geometry, selecting the desired
    one using the `ST_Intersects` function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，一个很好的方法是通过对多边形进行分解，检查其组成部分的环，来调查无效的多边形几何形状。为此，我们使用`ST_GeometryN`函数导出了导致无效性的环的几何形状，该函数能够从多边形中提取第*n*个环。我们将此函数与有用的PostgreSQL
    `generate_series`函数相结合，迭代组成几何形状的所有环，并使用`ST_Intersects`函数选择所需的环。
- en: As expected, the reason why this ring generates the invalidity is that it is
    self-intersecting and produces a hole in the polygon. While this adheres to the
    shapefile specification, it doesn't adhere to the OGC specification.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这个环产生无效性的原因是它是自相交的，并在多边形中产生了一个洞。虽然这符合形状文件规范，但它不符合OGC规范。
- en: By running the `ST_MakeValid` function, PostGIS has been able to make the geometry
    valid, generating a second ring. Remember that the `ST_MakeValid` function is
    available only with the latest PostGIS compiled with the latest GEOS (3.3.0+).
    If that is not the setup for your working box and you cannot upgrade (upgrading
    is always recommended!), you can follow the techniques used in the past and discussed
    in a very popular, excellent presentation by *Paul Ramsey* at [http://blog.opengeo.org/2010/09/08/tips-for-the-postgis-power-user/](http://blog.opengeo.org/2010/09/08/tips-for-the-postgis-power-user/).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `ST_MakeValid` 函数，PostGIS 已经能够使几何有效，生成第二个环。请注意，`ST_MakeValid` 函数仅在最新版本的
    PostGIS（编译了最新 GEOS（3.3.0+））中可用。如果这不是你的工作环境设置，并且你无法升级（升级始终是推荐的！），你可以遵循过去使用的技术，并在保罗·拉姆齐（*Paul
    Ramsey*）在 [http://blog.opengeo.org/2010/09/08/tips-for-the-postgis-power-user/](http://blog.opengeo.org/2010/09/08/tips-for-the-postgis-power-user/)
    上讨论的非常受欢迎、优秀的演示中找到这些技术。
- en: GIS analysis with spatial joins
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用空间连接进行 GIS 分析
- en: Joins for regular SQL tables have the real power in a relational database, and
    spatial joins are one of the most impressive features of a spatial database engine
    such as PostGIS.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规 SQL 表的连接具有关系数据库的实际功能，而空间连接是像 PostGIS 这样的空间数据库引擎中最令人印象深刻的特性之一。
- en: Basically, it is possible to correlate information from different layers on
    the basis of the geometric relation of each feature from the input layers. In
    this recipe, we will take a tour of some common use cases of spatial joins.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，可以根据输入图层中每个特征的几何关系来关联不同图层的信息。在本教程中，我们将探讨一些空间连接的常见用例。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, import some data to be used as a test bed in PostGIS. Download the `.kmz`
    file containing information about 2012 global earthquakes from the USGS website
    at [http://earthquake.usgs.gov/earthquakes/eqarchives/epic/kml/2012_Earthquakes_ALL.kmz](http://earthquake.usgs.gov/earthquakes/eqarchives/epic/kml/2012_Earthquakes_ALL.kmz).
    Save it in the `working/chp03` directory (alternatively, you can use the copy
    of this file included in the code bundle provided with this book).
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将一些数据导入到 PostGIS 中作为测试平台。从美国地质调查局网站 [http://earthquake.usgs.gov/earthquakes/eqarchives/epic/kml/2012_Earthquakes_ALL.kmz](http://earthquake.usgs.gov/earthquakes/eqarchives/epic/kml/2012_Earthquakes_ALL.kmz)
    下载包含 2012 年全球地震信息的 `.kmz` 文件。将其保存在 `working/chp03` 目录中（或者，你也可以使用本书附带代码包中包含的该文件副本）。
- en: 'A `.kmz` file is a collection of `.kml` files packaged with the ZIP compressor.
    Therefore, after unzipping the file (you may need to change the `.kmz` file extension
    to `.zip`), you may notice that it is composed of just a single `.kml` file. This
    file, which is in the GDAL abstraction, constitutes an OGR KML data source composed
    of nine different layers and containing 3D point geometries. Each layer contains
    earthquake data for each distinct earthquake magnitude:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.kmz` 文件是由 ZIP 压缩器打包的 `.kml` 文件集合。因此，在解压文件后（你可能需要将 `.kmz` 文件扩展名更改为 `.zip`），你可能会注意到它仅由一个
    `.kml` 文件组成。这个文件在 GDAL 抽象中，构成了一个由九个不同图层组成的 OGR KML 数据源，包含 3D 点几何形状。每个图层包含不同地震震级的地震数据：'
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output for this is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作的输出如下：
- en: '![](img/09c70540-c0dc-4a8b-9153-fad43b3d0333.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09c70540-c0dc-4a8b-9153-fad43b3d0333.png)'
- en: Import all of those layers in a PostGIS table named `chp03.earthquakes` simultaneously
    by executing one of the following scripts using the `ogr2ogr` command.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 `ogr2ogr` 命令执行以下脚本之一，同时将所有这些图层导入名为 `chp03.earthquakes` 的 PostGIS 表中。
- en: 'The following is the Linux version (name it `import_eq.sh`):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为 Linux 版本（命名为 `import_eq.sh`）：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following is the Windows version (name it `import_eq.bat`):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为 Windows 版本（命名为 `import_eq.bat`）：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Execute the following script (for Linux, you need to add `execute` permissions
    to it):'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下脚本（对于 Linux，你需要给它添加 `execute` 权限）：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To maintain consistency with the book''s conventions, rename the geometric
    column `wkb_geometry` (the default geometry output name in `ogr2ogr`) to `the_geom`,
    as illustrated in the following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了与本书的约定保持一致，将几何列 `wkb_geometry`（`ogr2ogr` 中的默认几何输出名称）重命名为 `the_geom`，如下命令所示：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Download the `cities` shapefile for the USA from the [https://nationalmap.gov/](https://nationalmap.gov/)
    website at [http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz)
    (this archive is also included in the code bundle provided with this book) and
    import it in PostGIS by executing the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://nationalmap.gov/](https://nationalmap.gov/)网站下载美国的`cities`形状文件，地址为[http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz)（此存档也包含在此书提供的代码包中），并在PostGIS中通过执行以下代码导入：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Download the `states` shapefile for the USA from the [https://nationalmap.gov/](https://nationalmap.gov/)
    website at [http://dds.cr.usgs.gov/pub/data/nationalatlas/statesp020_nt00032.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/statesp020_nt00032.tar.gz)
    (this archive is also included in the code bundle provided with this book) and
    import it in PostGIS by executing the following code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://nationalmap.gov/](https://nationalmap.gov/)网站下载美国的`states`形状文件，地址为[http://dds.cr.usgs.gov/pub/data/nationalatlas/statesp020_nt00032.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/statesp020_nt00032.tar.gz)（此存档也包含在此书提供的代码包中），并在PostGIS中通过执行以下代码导入：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, you will see for yourself the power of spatial SQL by solving
    a series of typical problems using spatial joins:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将亲自看到通过使用空间连接解决一系列典型问题来发挥空间SQL的力量：
- en: 'First, query PostGIS to get the number of registered earthquakes in 2012 by
    state:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，查询PostGIS以获取2012年按州划分的注册地震数量：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![](img/68f320cb-5d1f-4930-8e52-6cb8eaca5a9a.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68f320cb-5d1f-4930-8e52-6cb8eaca5a9a.png)'
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, to make it just a bit more complex, query PostGIS to get the number of
    earthquakes, grouped per magnitude, that are no further than 200 km from the cities
    in the USA that have more than 1 million inhabitants; execute the following code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了使问题稍微复杂一些，查询PostGIS以获取距离美国拥有超过100万居民的城镇不超过200公里的地震数量，按震级分组；执行以下代码：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](img/3a3620ef-98f6-4376-bea3-ac7b00b7001d.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a3620ef-98f6-4376-bea3-ac7b00b7001d.png)'
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As a variant of the previous query, executing the following code gives you
    a complete list of earthquakes along with their distance from the city (in meters):'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为之前查询的一个变体，执行以下代码将给出地震的完整列表以及它们与城市的距离（以米为单位）：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](img/4fcabdc0-6870-4f69-b0e6-c368d572f5b6.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fcabdc0-6870-4f69-b0e6-c368d572f5b6.png)'
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, ask PostGIS for the city count and the total population in each state
    by executing the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过执行以下代码请求PostGIS获取每个州的城镇数量和总人口：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![](img/3952b72d-a6be-4a23-b81d-a0d7a732c746.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3952b72d-a6be-4a23-b81d-a0d7a732c746.png)'
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As a final test, use a spatial join to update an existing table. You need to
    add the information in the `state_fips` field to the `earthquake` table from the
    `states` table. First, to host that kind of information, you need to create a
    column as shown in the following command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后的测试，使用空间连接更新现有表。您需要将`state_fips`字段中的信息添加到`earthquake`表中的`states`表。首先，为了存储此类信息，您需要创建一个列，如下命令所示：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, you can update the new column using a spatial join, as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以使用空间连接更新新列，如下所示：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Spatial joins are one of the key features that unleash the spatial power of
    PostGIS. For a regular join, it is possible to relate entities from two distinct
    tables using a common field. For a spatial join, it is possible to relate features
    from two distinct spatial tables using any spatial relationship function, such
    as `ST_Contains`, `ST_Covers`, `ST_Crosses`, and `ST_DWithin`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 空间连接是释放PostGIS空间功能的关键特性之一。对于常规连接，可以通过公共字段将两个不同表中的实体相关联。对于空间连接，可以使用任何空间关系函数（如`ST_Contains`、`ST_Covers`、`ST_Crosses`和`ST_DWithin`）将两个不同的空间表中的要素相关联。
- en: In the first query, we used the `ST_Intersects` function to join the earthquake
    points to their respective state. We grouped the query by the `state` column to
    obtain the number of earthquakes in the state.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个查询中，我们使用了`ST_Intersects`函数将地震点与其相应的州连接起来。我们通过`state`列对查询进行分组，以获得州内的地震数量。
- en: In the second query, we used the `ST_DWithin` function to relate each city to
    the earthquake points within a 200 km distance of it. We filtered out the cities
    with a population of less than 1 million inhabitants and grouped them by city
    name and earthquake magnitude to get a report of the number of earthquakes per
    city and by magnitude.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个查询中，我们使用了`ST_DWithin`函数将每个城市与其200公里范围内的地震点相关联。我们过滤掉了人口少于100万的城市，并按城市名称和地震震级分组，以获取每个城市和震级的地震数量报告。
- en: The third query is similar to the second one, except it doesn't group per city
    and by magnitude. The distance is computed using the `ST_Distance` function. Note
    that as feature coordinates are stored in WGS 84, you need to cast the geometric
    column to a spheroid and use the spheroid to get the distance in meters. Alternatively,
    you could project the geometries to a planar system that is accurate for the area
    we are studying in this recipe (in this case, the *ESPG:2163*, *US National Atlas
    Equal Area* would be a good choice) using the `ST_Transform` function. However,
    in the case of large areas like the one we've dealt with in this recipe, casting
    to geography is generally the best option as it gives more accurate results.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个查询与第二个查询类似，但不是按城市和震级分组。距离是通过`ST_Distance`函数计算的。请注意，由于特征坐标存储在WGS 84中，您需要将几何列转换为椭球体，并使用椭球体来获取以米为单位的距离。或者，您可以使用`ST_Transform`函数将几何形状投影到一个平面坐标系中，该坐标系适用于我们在此菜谱中研究的区域（在这种情况下，*ESPG:2163*，*US
    National Atlas Equal Area*将是一个不错的选择）。然而，在处理像我们在此菜谱中处理的大面积区域时，将几何体转换为地理类型通常是最佳选择，因为它提供了更准确的结果。
- en: The fourth query uses the `ST_Intersects` function. In this case, we grouped
    by the `state` column and used two aggregation SQL functions (`SUM` and `COUNT`)
    to get the desired results.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个查询使用了`ST_Intersects`函数。在这种情况下，我们按`state`列分组，并使用两个聚合SQL函数（`SUM`和`COUNT`）来获取所需的结果。
- en: Finally, in the last query, you update a spatial table using the results of
    a spatial join. The concept behind this is like that of the previous query, except
    that it is in the context of an `UPDATE` SQL command.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后一个查询中，您使用空间连接的结果更新一个空间表。这个概念与上一个查询类似，但它是`UPDATE` SQL命令的上下文。
- en: Simplifying geometries
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化几何形状
- en: There will be many times when you will need to generate a less detailed and
    lighter version of a vector dataset, as you may not need very detailed features
    for several reasons. Think about a case where you are going to publish the dataset
    to a website and performance is a concern, or maybe you need to deploy the dataset
    to a colleague who does not need too much detail because they are using it for
    a large-area map. In all these cases, GIS tools include implementations of **simplification
    algorithms** that reduce unwanted details from a given dataset. Basically, these
    algorithms reduce the vertex numbers comprised in a certain tolerance, which is
    expressed in units measuring distance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您将需要生成一个更详细和更轻量级的矢量数据集版本，因为您可能不需要非常详细的特征，可能有几个原因。考虑一下您将要发布数据集到网站，并且性能是一个关注点的情况，或者也许您需要将数据集部署给一个不需要太多细节的同事，因为他们正在使用它来创建大面积地图。在这些所有情况下，GIS工具都包括从给定数据集中减少不必要细节的实现**简化算法**。基本上，这些算法通过一定容差减少包含在其中的顶点数，该容差以距离单位表示。
- en: For this purpose, PostGIS provides you with the `ST_Simplify` and `ST_SimplifyPreserveTopology`
    functions. In many cases, they are the right solutions for simplification tasks,
    but in some cases, especially for polygonal features, they are not the best option
    out there and you will need a different GIS tool, such as `GRASS` or the new PostGIS
    topology support.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，PostGIS为您提供了`ST_Simplify`和`ST_SimplifyPreserveTopology`函数。在许多情况下，它们是简化任务的正确解决方案，但在某些情况下，特别是对于多边形特征，它们可能不是最佳选择，您可能需要使用不同的GIS工具，如`GRASS`或新的PostGIS拓扑支持。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The steps you need to do to complete this recipe are as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此菜谱所需采取的步骤如下：
- en: 'Set the PostgreSQL `search_path` variable such that all your newly created
    database objects will be stored in the `chp03` schema, using the following code:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码设置PostgreSQL `search_path`变量，以便所有您新创建的数据库对象都将存储在`chp03`模式中：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Suppose you need a less-detailed version of the `states` layer for your mapping
    website or to deploy to a client; you could consider using the `ST_SimplifyPreserveTopology`
    function as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您需要一个更详细版本的`states`层用于您的映射网站或部署给客户端；您可以考虑使用以下`ST_SimplifyPreserveTopology`函数：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The previous command works quickly, using a variant of the **Douglas-Peucker**
    algorithm, and effectively reduces the vertex number. But the resulting polygons,
    in some cases, are not adjacent any more. If you zoom in at any polygon border,
    you should notice something shown in the following screenshot: there are holes
    and overlaps along the shared border between two polygons. This is because PostGIS
    is using the OGC Simple Feature model, which doesn''t implement topology, so the
    function just removes the redundant vertex without taking the adjacent polygons
    into consideration:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的命令运行迅速，使用的是 **Douglas-Peucker** 算法的变体，并有效地减少了顶点数量。但有时，生成的多边形不再相邻。如果你放大查看任何多边形边界，你应该会注意到以下截图所示的内容：两个多边形共享边界的共有部分存在孔洞和重叠。这是因为
    PostGIS 使用的是 OGC 简单特征模型，该模型不实现拓扑，所以该函数只是移除了冗余顶点，而没有考虑相邻的多边形：
- en: '![](img/98800160-9449-4ed8-8204-a0037db378d4.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98800160-9449-4ed8-8204-a0037db378d4.png)'
- en: 'It looks like the `ST_SimplifyPreserveTopology` function, while working well
    with linear features, produces topological anomalies with polygons. In case you
    want topological simplification, another approach is the following code suggested
    by *Paul Ramsey* ([http://gis.stackexchange.com/questions/178/simplifying-adjacent-polygons](http://gis.stackexchange.com/questions/178/simplifying-adjacent-polygons))
    and improved in a *Webspaces* blog post ([http://webspaces.net.nz/page.php?view=polygon-dissolve-and-generalise](http://webspaces.net.nz/page.php?view=polygon-dissolve-and-generalise)):'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看起来 `ST_SimplifyPreserveTopology` 函数在处理线性特征时运行良好，但在处理多边形时会产生拓扑异常。如果你想要进行拓扑简化，另一种方法是以下由
    *Paul Ramsey* 提出的代码（[http://gis.stackexchange.com/questions/178/simplifying-adjacent-polygons](http://gis.stackexchange.com/questions/178/simplifying-adjacent-polygons)）以及在
    *Webspaces* 博客文章中改进的代码（[http://webspaces.net.nz/page.php?view=polygon-dissolve-and-generalise](http://webspaces.net.nz/page.php?view=polygon-dissolve-and-generalise)）：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This approach seems to work smoothly, but if you try to increment the simplifying
    tolerance from 150 to, let's say, 500 meters, you will again end up with topological
    anomalies (test this yourself). A better approach would be to use the PostGIS
    topology (you will do this in the *Simplifying geometries with PostGIS topology*
    recipe) or an external GIS tool that is able to manage topological operations
    the way `GRASS` can. For this recipe, you will use the `GRASS` approach.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种方法看起来运行顺畅，但如果尝试将简化容差从 150 米增加到，比如说，500 米，你将再次遇到拓扑异常（你可以亲自测试一下）。更好的方法是使用 PostGIS
    拓扑（你将在 *使用 PostGIS 拓扑简化几何形状* 章节中这样做）或能够像 `GRASS` 一样管理拓扑操作的第三方 GIS 工具。对于这个配方，你将使用
    `GRASS` 方法。
- en: 'Install `GRASS` on your system if you don''t have it. Then, create a directory
    to contain the `GRASS` database (in `GRASS` jargon, a `GISDBASE`), as follows:'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有安装 `GRASS`，请在你的系统上安装它。然后，创建一个目录来包含 `GRASS` 数据库（在 `GRASS` 术语中，称为 `GISDBASE`），如下所示：
- en: '[PRE41]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, start `GRASS` by typing `grass` in the Linux command prompt or by double-clicking
    on the GRASS GUI icon in Windows (Start | All Programs | OSGeo4W | GRASS GIS 6.4.3
    | GRASS 6.4.3 GUI) or on Applications in macOS. You will be prompted to select
    the `grass_db` database as the GIS data directory but should instead select the
    one you created in the previous step.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过在 Linux 命令提示符中输入 `grass` 或者在 Windows 中双击 GRASS GUI 图标（开始 | 所有程序 | OSGeo4W
    | GRASS GIS 6.4.3 | GRASS 6.4.3 GUI）或在 macOS 中的应用程序中，来启动 `GRASS`。你将被提示选择 `grass_db`
    数据库作为 GIS 数据目录，但应该选择你在上一步中创建的目录。
- en: Using the Location Wizard button, create a location named `postgis_cookbook`
    with the title `PostGIS Cookbook` (`GRASS` uses subdirectories named locations,
    where all of the data is kept in the same coordinate system, map projection, and
    geographical boundaries).
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“位置向导”按钮，创建一个名为 `postgis_cookbook` 的位置，标题为“PostGIS 烹饪书”（`GRASS` 使用名为位置的子目录，其中所有数据都保存在相同的坐标系、地图投影和地理边界中）。
- en: When creating the new location, select the EPSG with SRID 2163 as the spatial
    reference system (you need to select the Select EPSG code of spatial reference
    system option under Choose method for creating a new location).
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建新位置时，选择 EPSG 2163 作为空间参考系统（你需要在“选择创建新位置的方法”下选择“选择空间参考系统的 EPSG 代码”选项）。
- en: Now start `GRASS` by clicking on the Start GRASS button. The program's command
    line will start as shown in the following screenshot:![](img/01a70de2-a7c1-40f7-92ca-6d5994ef953e.png)
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过点击“启动 GRASS”按钮来启动 `GRASS`。程序的控制台将如以下截图所示启动：![图片](img/01a70de2-a7c1-40f7-92ca-6d5994ef953e.png)
- en: 'Import the `states` PostGIS spatial table to the `GRASS` location. To do so,
    use the `v.in.ogr GRASS` command, which will then use the OGR PostgreSQL driver
    (in fact, the PostGIS connection string syntax is the same):'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`states` PostGIS空间表导入`GRASS`位置。为此，使用`v.in.ogr GRASS`命令，它将使用OGR PostgreSQL驱动程序（实际上，PostGIS连接字符串语法是相同的）：
- en: '[PRE42]'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`GRASS` will import the OGR PostGIS table and simultaneously build the topology
    for this layer, which is composed of points, lines, areas, and so on. The `v.info`
    command can be used in combination with the `-c` option to check the attributes
    table and get more information on the imported layer, as follows:'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GRASS`将导入OGR PostGIS表，并同时为该层构建拓扑，该层由点、线、区域等组成。可以使用`v.info`命令结合`-c`选项来检查属性表并获取有关导入层的更多信息，如下所示：'
- en: '[PRE43]'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![](img/92ffb6e9-703e-430f-8fdf-6ccb5743daee.png)'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/92ffb6e9-703e-430f-8fdf-6ccb5743daee.png)'
- en: 'Now, you can simplify the polygon geometries using the `v.generalizeGRASS` command
    with a tolerance (threshold) of 500 meters. If you are using the same dataset
    used in this recipe, you will end up with 47,191 vertices from the original 346,914
    vertices, composing 1,919 polygons (areas) from the original 2,895 polygons:'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以使用具有500米容差（阈值）的`v.generalizeGRASS`命令简化多边形几何形状。如果你使用与本配方相同的数据集，你将最终从原始的346,914个顶点中获得47,191个顶点，组成1,919个多边形（区域），这些多边形来自原始的2,895个多边形：
- en: '[PRE44]'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Export the results back to PostGIS using the `v.out.ogr` command (the `v.in.ogr`
    counterpart) as follows:'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`v.out.ogr`命令（`v.in.ogr`的对应命令）将结果导回PostGIS，如下所示：
- en: '[PRE45]'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, open a desktop GIS and check for differences between the geometry simplification
    performed by the `ST_SimplifyPreserveTopology` PostGIS function and `GRASS`. There
    should be no holes or overlaps at shared polygon borders. In the following screenshot,
    the original layer boundaries are in red, the boundaries built by `ST_SimplifyPreserveTopology`
    are in blue, and those built by `GRASS` are in green:![](img/060b961d-896d-4c37-895b-26c439c6ff7b.png)
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开桌面GIS，检查`ST_SimplifyPreserveTopology` PostGIS函数和`GRASS`执行的几何形状简化之间的差异。在共享多边形边界处不应有孔洞或重叠。在下面的屏幕截图中，原始层边界用红色表示，由`ST_SimplifyPreserveTopology`构建的边界用蓝色表示，由`GRASS`构建的边界用绿色表示:![](img/060b961d-896d-4c37-895b-26c439c6ff7b.png)
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ST_Simplify` PostGIS function is able to simplify and generalize either
    a (simple or multi) linear or polygonal geometry using the Douglas-Peucker algorithm
    (for more details, go to [http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm](http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)).
    Since it can create invalid geometries in some cases, it is recommended that you
    use its evolved version—the `ST_SimplifyPreserveTopology` function—which will
    produce only valid geometries.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ST_Simplify` PostGIS函数能够使用Douglas-Peucker算法（更多详情请参阅[http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm](http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)）简化并泛化（简单或多）线性或多边形几何形状。由于在某些情况下它可能创建无效的几何形状，因此建议使用其进化版本——`ST_SimplifyPreserveTopology`函数，这将仅产生有效的几何形状。'
- en: While the functions are working well with (multi) linear geometries, in the
    case of (multi) polygons, they will most likely create topological anomalies such
    as overlaps and holes at shared polygon borders.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然这些函数与（多）线性几何形状配合得很好，但在（多）多边形的情况下，它们很可能会在共享多边形边界处创建拓扑异常，如重叠和孔洞。
- en: 'To get a valid, topologically simplified dataset, there are the following two
    choices at the time of writing:'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在编写时获得有效的、拓扑简化的数据集，有以下两种选择：
- en: Performing the simplified process on an external GIS tool such as `GRASS`
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在外部GIS工具（如`GRASS`）上执行简化过程
- en: Using the new PostGIS topological support
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的PostGIS拓扑支持
- en: While you will see the new PostGIS topological features in the *Simplifying
    geometries with PostGIS topology* recipe, in this one you have been using `GRASS`
    to perform the simplification process.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然你将在“使用PostGIS拓扑简化几何形状”的配方中看到新的PostGIS拓扑特征，但在本配方中，你已经使用`GRASS`来执行简化过程。
- en: We opened `GRASS`, created a GIS data directory and a project location, and
    then imported in the `GRASS` location, the polygonal PostGIS table using the `v.ogr.in`
    command, based on GDAL/OGR as the name suggests.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们打开了`GRASS`，创建了一个GIS数据目录和一个项目位置，然后使用`v.ogr.in`命令将多边形PostGIS表导入`GRASS`位置，正如其名称所暗示的那样，基于GDAL/OGR。
- en: Until this point, you have been using the `GRASS v.generalize` command to perform
    the simplification of the dataset using a tolerance (threshold) expressed in meters.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在使用 `GRASS v.generalize` 命令，通过以米为单位的容差（阈值）来执行数据集的简化。
- en: After simplifying the dataset, you imported it back to PostGIS using the `v.ogr.out
    GRASS` command and then opened the derived spatial table in a desktop GIS to see
    whether or not the process was performed in a topologically correct way.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在简化数据集后，你使用 `v.ogr.out GRASS` 命令将其导入 PostGIS，然后在桌面 GIS 中打开派生的空间表，以查看该过程是否以拓扑正确的方式进行。
- en: Measuring distances
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量距离
- en: In this recipe, we will check out the PostGIS functions needed for distance
    measurements (`ST_Distance` and its variants) and find out how considering the
    earth's curvature makes a big difference when measuring distances between distant
    points.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将检查用于距离测量的 PostGIS 函数（`ST_Distance` 及其变体），并找出考虑地球曲率在测量远距离点之间距离时会产生重大差异。
- en: Getting ready
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You should import the shapefile representing the cities from the USA that we
    generated in a previous recipe (the PostGIS table named `chp03.cities`). In case
    you haven''t done so, download that shapefile from the [https://nationalmap.gov/](https://nationalmap.gov/) website
    at [http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz)
    (this archive is also included in the code bundle available with this book) and
    import it to PostGIS:'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该导入表示我们之前在菜谱中生成的美国城市的 shapefile（名为 `chp03.cities` 的 PostGIS 表）。如果你还没有这样做，请从
    [https://nationalmap.gov/](https://nationalmap.gov/) 网站下载该 shapefile（[http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz)），并将其导入
    PostGIS：
- en: '[PRE46]'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The steps you need to perform to complete this recipe are as follows:'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成此菜谱所需执行的步骤如下：
- en: 'First, use the `ST_Distance` function to calculate the distances between cities
    in the USA that have more than 1 million inhabitants using the Spherical Mercator
    planar projection coordinate system (EPSG:900913, EPSG:3857, or EPSG:3785; all
    of these SRID representations are equivalent). Use the `ST_Transform` function
    as follows to convert the point coordinates from longitude latitude degrees (as
    the coordinates are originally in EPSG:4326) to a planar metric system if you
    want the results in meters:'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `ST_Distance` 函数，通过球面墨卡托平面投影坐标系（EPSG:900913, EPSG:3857, 或 EPSG:3785；所有这些
    SRID 表示都是等效的）来计算美国拥有超过 100 万人口的城市的距离。如果你想得到以米为单位的距离结果，可以使用以下 `ST_Transform` 函数将点坐标从经纬度度数（因为坐标最初在
    EPSG:4326 中）转换为平面度量系统：
- en: '[PRE47]'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![](img/425da6aa-4cd1-4b21-b65e-eea04e1449a3.png)'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/425da6aa-4cd1-4b21-b65e-eea04e1449a3.png)'
- en: '[PRE48]'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now write the same query as we did in the previous recipe, but in a more compact
    expression using a PostgreSQL **Common Table Expression** (**CTE**):'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在请像我们在上一个菜谱中做的那样，但使用一个更紧凑的表达式，通过 PostgreSQL **公共表表达式**（**CTE**）来编写相同的查询：
- en: '[PRE49]'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For large distances such as in this case, it is not correct to use a planar
    spatial reference system, but you should make the calculations taking into consideration
    the earth''s curvature. For example, the previously used Mercator planar system,
    while it is very good to use for map outputs, is very bad for measuring distances
    and areas as it assesses directions. For this purpose, it would be better to use
    a spatial reference system that is able to measure distance. You can also use
    the `ST_Distance_Sphere` or `ST_Distance_Spheroid` functions (the first being
    quicker, but less accurate, as it performs calculations on a sphere and not a
    spheroid). An even better option is converting the geometries to the geography
    data type, so you can use `ST_Distance` directly, as it will automatically make
    the calculations using the spheroid. Note that this is exactly equivalent to using
    `ST_DistanceSpheroid`. Try to check the difference between the various approaches,
    using the same query as before:'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于像这种情况的大距离，使用平面空间参考系是不正确的，但你应该考虑地球的曲率来进行计算。例如，之前使用的墨卡托平面系统，虽然非常适合用于地图输出，但在测量距离和面积时非常糟糕，因为它评估方向。为此，最好使用能够测量距离的空间参考系。你也可以使用
    `ST_Distance_Sphere` 或 `ST_Distance_Spheroid` 函数（第一个更快，但精度较低，因为它在球体而不是椭球体上执行计算）。更好的选择是将几何形状转换为地理数据类型，这样你就可以直接使用
    `ST_Distance`，因为它将自动使用椭球体进行计算。请注意，这与使用 `ST_DistanceSpheroid` 完全等效。尝试检查使用相同查询的各种方法之间的差异：
- en: '[PRE50]'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![](img/0f7e7db6-3a36-43d1-8c4b-29218c0681e2.png)'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/0f7e7db6-3a36-43d1-8c4b-29218c0681e2.png)'
- en: '[PRE51]'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can easily verify from the output that there is a big difference with using
    the planar system (EPSG:900913, as in the `d_900913` column) instead of systems
    that take into consideration the curvature of the earth.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以从输出结果中轻松验证，使用平面系统（EPSG:900913，如在`d_900913`列中）而不是考虑地球曲率的系统有很大的不同。
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you need to compute the minimum Cartesian distance between two points, you
    can use the PostGIS `ST_Distance` function. This function accepts two-point geometries
    as input parameters and these geometries must be specified in the same **spatial
    reference system**.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您需要计算两点之间的最小笛卡尔距离，可以使用PostGIS的`ST_Distance`函数。此函数接受两个几何形状作为输入参数，并且这些几何形状必须在相同的**空间参考系统**中指定。
- en: If the two input geometries are using different spatial references, you can
    use the `ST_Transform` function on one or both of them to make them consistent
    with a single spatial reference system.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果两个输入几何形状使用不同的空间参考，您可以使用`ST_Transform`函数对其中一个或两个进行操作，使它们与单个空间参考系统保持一致。
- en: To get better results, you should consider the earth's curvature, which is mandatory
    when measuring large distances, and use the `ST_Distance_Sphere` or the `ST_Distance_Spheroid`
    functions. Alternatively, use `ST_Distance`, but cast the input geometries to
    the **geography spatial data type**, which is optimized for this kind of operation.
    The geography type stores the geometries in WGS 84 longitude latitude degrees,
    but it always returns the measurements in meters.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了获得更好的结果，您应该考虑地球的曲率，这在测量大距离时是强制性的，并使用`ST_Distance_Sphere`或`ST_Distance_Spheroid`函数。或者，使用`ST_Distance`，但将输入几何形状转换为**地理空间数据类型**，该类型针对此类操作进行了优化。地理类型将几何形状存储在WGS
    84经纬度度数中，但它始终以米为单位返回测量值。
- en: In this recipe, you have used a PostgreSQL CTE, which is a handy way to provide
    a subquery in the context of the main query. You can consider a CTE as a temporary
    table used only within the scope of the main query.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此食谱中，您使用了PostgreSQL CTE，这是一种在主查询上下文中提供子查询的便捷方式。您可以将CTE视为仅在主查询范围内使用的临时表。
- en: Merging polygons using a common attribute
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用公共属性合并多边形
- en: There are many cases in GIS workflows where you need to merge a polygonal dataset
    based on a common attribute. A typical example is merging the European administrative
    areas (which you can see at [http://en.wikipedia.org/wiki/Nomenclature_of_Territorial_Units_for_Statistics](http://en.wikipedia.org/wiki/Nomenclature_of_Territorial_Units_for_Statistics)),
    starting from **Nomenclature des Units Territoriales Statistiques** (**NUTS**)
    level 4 to obtain the subsequent levels up to NUTS level 1, using the NUTS code
    or merging the USA counties layer using the state code to obtain the states layer.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在GIS工作流程中，有许多情况需要根据公共属性合并多边形数据集。一个典型的例子是从**Nomenclature des Units Territoriales
    Statistiques**（**NUTS**）第4级开始合并欧洲行政区域（您可以在[http://en.wikipedia.org/wiki/Nomenclature_of_Territorial_Units_for_Statistics](http://en.wikipedia.org/wiki/Nomenclature_of_Territorial_Units_for_Statistics)中看到），直到NUTS第1级，使用NUTS代码合并，或者使用州代码合并美国县图层以获得州图层。
- en: PostGIS lets you perform this kind of processing operation with the `ST_Union`
    function.
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: PostGIS允许您使用`ST_Union`函数执行此类处理操作。
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Download the USA countries shapefile from the [https://nationalmap.gov/](https://nationalmap.gov/) website
    at [http://dds.cr.usgs.gov/pub/data/nationalatlas/co2000p020_nt00157.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/co2000p020_nt00157.tar.gz)
    (this archive is also included in the code bundle provided with this book) and
    import it in PostGIS as follows:'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从[https://nationalmap.gov/](https://nationalmap.gov/)网站下载美国国家形状文件，地址为[http://dds.cr.usgs.gov/pub/data/nationalatlas/co2000p020_nt00157.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/co2000p020_nt00157.tar.gz)（此存档也包含在此书提供的代码包中），并在PostGIS中按照以下步骤导入：
- en: '[PRE52]'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The steps you need to perform to complete this recipe are as follows:'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成此食谱所需的步骤如下：
- en: 'First, check the imported table by running the following commands:'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过运行以下命令检查导入的表：
- en: '[PRE53]'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![](img/788d8e93-ee09-4743-b564-769622356040.png)'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/788d8e93-ee09-4743-b564-769622356040.png)'
- en: '[PRE54]'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now perform the merging operation based on the `state_fips` field, using the
    `ST_Union` PostGIS function:'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在根据`state_fips`字段执行合并操作，使用PostGIS的`ST_Union`函数：
- en: '[PRE55]'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The following screenshot shows how the output PostGIS layer looks in a desktop
    GIS; the aggregate counties have successfully been composed by their respective
    state (indicated by the thick blue border):![](img/fb9f84b5-447f-498f-ad80-68d4c6ed1576.png)
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了桌面 GIS 中输出 PostGIS 层的外观；聚合县已成功由各自的州组成（由粗蓝色边框表示）：![](img/fb9f84b5-447f-498f-ad80-68d4c6ed1576.png)
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have been using the `ST_Union` PostGIS function to make a polygon merge
    on a common attribute. This function can be used as an aggregate PostgreSQL function
    (such as `SUM`, `COUNT`, `MIN`, and `MAX`) on the layer's geometric field, using
    the common attribute in the `GROUP BY` clause.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你一直在使用 `ST_Union` PostGIS 函数在公共属性上执行多边形合并。此函数可以用作聚合 PostgreSQL 函数（如 `SUM`、`COUNT`、`MIN`
    和 `MAX`）在层的几何字段上，使用 `GROUP BY` 子句中的公共属性。
- en: Note that `ST_Union` can also be used as a non-aggregate function to perform
    the union of two geometries (which are the two input parameters).
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`ST_Union` 也可以用作非聚合函数，以执行两个几何体（即两个输入参数）的并集。
- en: Computing intersections
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算交集
- en: One typical GIS geoprocessing workflow is to compute intersections generated
    by intersecting linear geometries.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个典型的 GIS 地理处理工作流程是计算由相交线性几何体产生的交集。
- en: PostGIS offers a rich set of functions for solving this particular type of problem
    and you will have a look at them in this recipe.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: PostGIS 提供了一套丰富的函数来解决这类特定问题，你将在本配方中查看它们。
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will use the Rivers + lake centerlines dataset of North
    America and Europe with a scale 1:10m. Download the `rivers` dataset from the
    following `naturalearthdata.com` website (or use the ZIP file included in the
    code bundle provided with this book):'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用北美和欧洲的河流 + 湖泊中心线数据集，比例尺为 1:10m。从以下 `naturalearthdata.com` 网站下载 `rivers`
    数据集（或使用本书提供的代码包中包含的 ZIP 文件）：
- en: '[http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/10m/physical/ne_10m_rivers_lake_centerlines.zip](http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/10m/physical/ne_10m_rivers_lake_centerlines.zip)'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/10m/physical/ne_10m_rivers_lake_centerlines.zip](http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/10m/physical/ne_10m_rivers_lake_centerlines.zip)'
- en: 'Or find it on the following website:'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者在其网站上找到它：
- en: '[http://www.naturalearthdata.com/downloads/10m-physical-vectors/](http://www.naturalearthdata.com/downloads/10m-physical-vectors/)'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.naturalearthdata.com/downloads/10m-physical-vectors/](http://www.naturalearthdata.com/downloads/10m-physical-vectors/)'
- en: 'Extract the shapefile to your working directory `chp03/working`. Import the
    shapefile in PostGIS using `shp2pgsql` as follows:'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 shapefile 解压到工作目录 `chp03/working` 中。使用以下 `shp2pgsql` 命令将 shapefile 导入 PostGIS：
- en: '[PRE56]'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The steps you need to perform to complete this recipe are as follows:'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要执行以下步骤来完成这个配方：
- en: 'First, perform a self-spatial join between your `MultiLineString` dataset and
    the PostGIS `ST_Intersects` function and find intersections in the join context
    with the `ST_Intersection` PostGIS function. The following is the basic query,
    resulting in 1,448 records being selected:'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `MultiLineString` 数据集和 PostGIS 的 `ST_Intersects` 函数之间执行自空间连接，并使用 `ST_Intersection`
    PostGIS 函数在连接上下文中找到交集。以下是一个基本查询，结果选择了 1,448 条记录：
- en: '[PRE57]'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You may hastily assume that all of the intersections are single points, but
    this is not the case; if you check the geometry type of the geometric intersections
    using the `ST_GeometryType` function, you have three different cases of intersection,
    resulting in the following geometries:'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会草率地假设所有交集都是单点，但这并非事实；如果你使用 `ST_GeometryType` 函数检查几何交集的几何类型，你将遇到三种不同的交集情况，导致以下几何体：
- en: An `ST_POINT` geometry for a simple intersection between two linear geometries.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于两个线性几何体之间的简单交集，使用 `ST_POINT` 几何体。
- en: An `ST_MultiPoint` geometry, if two linear geometries intersect each other at
    more points.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个线性几何体在多个点上相交，则使用 `ST_MultiPoint` 几何体。
- en: An `ST_GeometryCollection` geometry in cases where the two `MultiLineString`
    objects intersect and share part of the line. In such a case, the geometry collection
    is composed of `ST_Point` and/or `ST_Line` geometries.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个 `MultiLineString` 对象相交并共享部分线的情况下，使用 `ST_GeometryCollection` 几何体。在这种情况下，几何体集合由
    `ST_Point` 和/或 `ST_Line` 几何体组成。
- en: 'You can check the different cases with a query, shown as follows:'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过以下查询检查不同的案例：
- en: '[PRE58]'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![](img/533aad33-1f44-4cb4-85d7-9bd94691ee92.png)'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/533aad33-1f44-4cb4-85d7-9bd94691ee92.png)'
- en: '[PRE59]'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'First, try to compute the intersection for just the first two cases (intersections
    composed of the `ST_Point` and `ST_MultiPoint` geometries). Just generate a table
    with the `Point` and `MultiPoint` geometries, excluding the records that have
    an intersection composed of a geometric collection. By executing the following
    commands, 1,444 of the 1,448 records are imported (the four records with geometry
    collections are ignored using the `ST_GeometryType` function):'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，尝试仅计算前两种情况（由`ST_Point`和`ST_MultiPoint`几何形状组成的交点）的交点。只需生成一个包含`Point`和`MultiPoint`几何形状的表，排除具有由几何集合组成的交点的记录。通过执行以下命令，1,444条记录中的1,448条被导入（使用`ST_GeometryType`函数忽略了具有几何集合的四个记录）：
- en: '[PRE60]'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In case you want to import the points from the geometry collection too (but
    just the points, ignoring the eventual linestrings), one way to go about it is
    by using the `ST_CollectionExtract` function in the context of a `SELECT``CASE`
    PostgreSQL conditional statement; this way, you can import all the 1,448 intersections
    as follows:'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想从几何集合中导入点（但仅限于点，忽略可能的线字符串），一种方法是在`SELECT``CASE` PostgreSQL条件语句的上下文中使用`ST_CollectionExtract`函数；这样，您可以按照以下方式导入所有1,448个交点：
- en: '[PRE61]'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You may see the difference between the two processes, counting the total number
    of points in each of the generated tables, as follows:'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过以下方式查看两种过程之间的差异，计算生成的每个表中点的总数，如下所示：
- en: '[PRE62]'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the following screenshot (taken from QGIS), you may notice the generated
    intersections generated by both approaches. In the case of the `intersection_all`
    layer, you will notice that some more intersections have been computed (in red):![](img/5a880965-4a30-4972-b6f9-03b988419711.png)
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下屏幕截图（来自QGIS）中，您可能会注意到两种方法生成的交点。在`intersection_all`层的情况下，您会注意到计算出了更多的交点（以红色显示）：![](img/5a880965-4a30-4972-b6f9-03b988419711.png)
- en: Layers of river intersections visualized in QGIS
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在QGIS中可视化的河流交点层
- en: How it works...
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have been using a self-spatial join of a linear PostGIS spatial layer to
    find intersections generated by the features of that layer.
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们一直在使用线性PostGIS空间层的自空间连接来查找由该层特征生成的交点。
- en: To generate the self-spatial join, we used the `ST_Intersects` function. This
    way, we found that all of the features have at least an intersection in their
    respective geometries.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了生成自空间连接，我们使用了`ST_Intersects`函数。这样，我们发现所有特征在其各自的几何形状中至少有一个交点。
- en: In the same self-spatial join context, we found out the intersections, using
    the `ST_Intersection` function.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在相同的自空间连接上下文中，我们使用`ST_Intersection`函数找到了交点。
- en: The problem is that the computed intersections are not always single points.
    In fact, two intersecting lines can produce the origin for a single-point geometry
    (`ST_Point`) if the two lines just intersect once. But, the two intersecting lines
    can produce the origin for a point collection (`ST_MultiPoint`) or even a geometric
    collection if the two lines intersect at more points and/or share common parts.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 问题在于计算出的交点并不总是单个点。实际上，两条相交的线可以产生一个单点几何形状（`ST_Point`）的起点，如果两条线仅相交一次。但是，两条相交的线可以产生一个点集合（`ST_MultiPoint`）或甚至几何集合的起点，如果两条线在更多点上相交/共享公共部分。
- en: As our target was to compute all the point intersections (`ST_Point` and `ST_MultiPoint`)
    using the `ST_GeometryType` function, we filtered out the values using a SQL `SELECT
    CASE` construct where the feature had a `GeometryCollection` geometry, for which
    we extracted just the points (and not the eventual linestrings) using the `ST_CollectionExtract`
    function (`parameter type = 1`) from the composing collections.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们的目标是使用`ST_GeometryType`函数计算所有点交点（`ST_Point`和`ST_MultiPoint`），我们使用SQL `SELECT
    CASE`构造过滤了值，其中特征具有`GeometryCollection`几何形状，我们使用`ST_CollectionExtract`函数（参数类型=1）从组成集合中提取了仅有的点（而不是可能的线字符串）。
- en: Finally, we compared the two result sets, both with plain SQL and a desktop
    GIS. The intersecting points computed filtered out the geometric collections from
    the output geometries and the intersecting points computed from all the geometries
    generated from the intersections, including the `GeometryCollection` features.
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们比较了两个结果集，既使用纯SQL又使用桌面GIS。计算出的交点从输出几何形状中过滤掉了几何集合，并从所有由交点生成的几何形状中计算出的交点，包括`GeometryCollection`特征。
- en: Clipping geometries to deploy data
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剪切几何形状以部署数据
- en: A common GIS use case is clipping a big dataset into small portions (subsets),
    with each perhaps representing an area of interest. In this recipe, you will export
    from a PostGIS layer representing the rivers in the world, with one distinct shapefile
    composed of rivers for each country. For this purpose, you will use the `ST_Intersection`
    function.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个常见的 GIS 应用场景是将大型数据集裁剪成小部分（子集），每个子集可能代表一个感兴趣的区域。在这个菜谱中，您将从表示世界河流的 PostGIS 层导出，每个国家都有一个独特的
    shapefile 组成河流。为此，您将使用 `ST_Intersection` 函数。
- en: Getting ready
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Be sure that you have imported in PostGIS the same river dataset (a shapefile)
    that was used in the previous recipe.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保您已将用于上一个菜谱的相同河流数据集（一个 shapefile）导入到 PostGIS 中。
- en: How to do it...
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The steps you need to take to complete this recipe are as follows:'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成此菜谱所需的步骤如下：
- en: 'First, you will create a view to clip the river geometries for each country
    using the `ST_Intersection` and `ST_Intersects` functions. Name the view `rivers_clipped_by_country`:'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您将创建一个视图，使用 `ST_Intersection` 和 `ST_Intersects` 函数裁剪每个国家的河流几何形状。将视图命名为 `rivers_clipped_by_country`：
- en: '[PRE63]'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a directory named `rivers` as follows:'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤创建名为 `rivers` 的目录：
- en: '[PRE64]'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Create the following scripts to export a `rivers` shapefile for each country.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下脚本以为每个国家导出 `rivers` shapefile。
- en: 'The following is the Linux version (name it `export_rivers.sh`):'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为 Linux 版本（命名为 `export_rivers.sh`）：
- en: '[PRE65]'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following is the Windows version (name it `export_rivers.bat`):'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为 Windows 版本（命名为 `export_rivers.bat`）：
- en: '[PRE66]'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: For Windows users
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 Windows 用户
- en: The script uses the `grep` and `awk` Linux commands, so you will need to download
    their Windows versions from [http://unxutils.sourceforge.net/](http://unxutils.sourceforge.net/).
    The script was tested with the `UnxUpdates.zip` file (which includes `gawk`, but
    not `awk`), but you are welcome to download the full version available at [https://sourceforge.net/projects/unxutils/](https://sourceforge.net/projects/unxutils/).
    Also remember to include the folder with the executable files on the Windows path.
    There's a chance that you already have them installed in your system if you have
    installed OSGeo4W, a binary distribution of a broad set of open source, geospatial
    software for win32 environments. You can find it at [http://trac.osgeo.org/osgeo4w/](http://trac.osgeo.org/osgeo4w/).
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该脚本使用 `grep` 和 `awk` Linux 命令，因此您需要从 [http://unxutils.sourceforge.net/](http://unxutils.sourceforge.net/)
    下载它们的 Windows 版本。脚本已使用 `UnxUpdates.zip` 文件（包含 `gawk` 但不包含 `awk`）进行测试，但您也可以下载 [https://sourceforge.net/projects/unxutils/](https://sourceforge.net/projects/unxutils/)
    上可用的完整版本。同时，请记住将包含可执行文件的文件夹添加到 Windows 路径中。如果您已安装 OSGeo4W，一个为 win32 环境提供大量开源地理空间软件的二进制发行版，那么您可能已经安装了它们。您可以在
    [http://trac.osgeo.org/osgeo4w/](http://trac.osgeo.org/osgeo4w/) 找到它。
- en: 'In Windows, run the batch file:'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 中运行批处理文件：
- en: '[PRE67]'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, run the following script (in Linux or macOS, you need to assign `execute`
    permissions to the script before running the shell file):'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下脚本（在 Linux 或 macOS 中，您需要在运行 shell 文件之前将脚本的 `execute` 权限分配给脚本）：
- en: '[PRE68]'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You could eventually skip the creation of the `rivers_clipped_by_country` view
    by replacing the `ogr2ogr` statement in the previous script with the following
    command (`ogr2ogr` passes the content of the `-sql` option directly to PostGIS);
    use `%%f` for Windows:'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您最终可以跳过创建 `rivers_clipped_by_country` 视图，只需将上一个脚本中的 `ogr2ogr` 语句替换为以下命令（`ogr2ogr`
    将 `-sql` 选项的内容直接传递给 PostGIS）；对于 Windows，请使用 `%%f`：
- en: '`ogr2ogr rivers/rivers_$f.shp PG:"dbname=''postgis_cookbook'' user=''me'' password=''mypassword''"
    -sql "SELECT r.name, c.iso2, ST_Intersection(r.the_geom, c.the_geom) AS the_geom
    FROM chp03.countries AS c JOIN chp03.rivers AS r ON ST_Intersects(r.the_geom,
    c.the_geom) WHERE c.iso2 = ''$f''"`'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ogr2ogr rivers/rivers_$f.shp PG:"dbname=''postgis_cookbook'' user=''me'' password=''mypassword''"
    -sql "SELECT r.name, c.iso2, ST_Intersection(r.the_geom, c.the_geom) AS the_geom
    FROM chp03.countries AS c JOIN chp03.rivers AS r ON ST_Intersects(r.the_geom,
    c.the_geom) WHERE c.iso2 = ''$f''"`'
- en: Check the output with `ogrinfo` or a desktop GIS. The following screenshot shows
    how the output looks in QGIS; we have added the original PostGIS `chp03.rivers`
    layer and a couple of the generated shapefiles:![](img/dc5c0ed4-c4bd-43de-a354-d248e33ca342.png)
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ogrinfo` 或桌面 GIS 检查输出。以下截图显示了在 QGIS 中的输出效果；我们添加了原始的 PostGIS `chp03.rivers`
    层和几个生成的 shapefile：![](img/dc5c0ed4-c4bd-43de-a354-d248e33ca342.png)
- en: How it works...
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can use the `ST_Intersection` function to clip one dataset from another.
    In this recipe, you first created a view, where you performed a spatial join between
    a polygonal layer (countries) and a linear layer (rivers) using the `ST_Intersects`
    function. In the context of the spatial join, you have used the `ST_Intersection`
    function to generate a snapshot of the rivers in every country.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用 `ST_Intersection` 函数从另一个数据集中剪切一个数据集。在这个菜谱中，您首先创建了一个视图，在该视图中，您使用 `ST_Intersects`
    函数在多边形层（国家）和线性层（河流）之间执行空间连接。在空间连接的上下文中，您使用了 `ST_Intersection` 函数来生成每个国家的河流快照。
- en: You have then created a bash script in which you iterated every single country
    and pulled out to a shapefile the clipped rivers for that country, using `ogr2ogr`
    and the previously created view as the input layer.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，您创建了一个bash脚本，遍历每个国家，并使用 `ogr2ogr` 和之前创建的视图作为输入层，将该国剪切的河流导出为shapefile。
- en: To iterate the countries in the script, you have been using `ogrinfo` with the
    `-sql` option, using a SQL `SELECT DISTINCT` statement. You have used a combination
    of the `grep` and `awk` Linux commands, piped together to get every single country
    code. The `grep` command is a utility for searching plaintext datasets for lines
    matching a regular expression, while `awk` is an interpreted programming language
    designed for text processing and typically used as a data extraction and reporting
    tool.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在脚本中遍历国家时，您使用了带有 `-sql` 选项的 `ogrinfo`，使用一个SQL `SELECT DISTINCT` 语句。您使用了 `grep`
    和 `awk` Linux命令的组合，通过管道连接以获取每个国家的代码。`grep` 命令是一个用于在纯文本数据集中搜索匹配正则表达式的行的实用程序，而 `awk`
    是一种用于文本处理的解释性编程语言，通常用作数据提取和报告工具。
- en: Simplifying geometries with PostGIS topology
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PostGIS拓扑简化几何形状
- en: In a previous recipe, we used the `ST_SimplifyPreserveTopology` function to
    try to generate a simplification of a polygonal PostGIS layer.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们使用了 `ST_SimplifyPreserveTopology` 函数来尝试生成一个多边形PostGIS层的简化。
- en: Unfortunately, while that function works well for linear layers, it produces
    topological anomalies (overlapping and holes) in shared polygon borders. You used
    an external toolset (`GRASS`) to generate a valid topological simplification.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不幸的是，虽然该函数对线性层工作良好，但它会在共享多边形边界处产生拓扑异常（重叠和空洞）。您使用外部工具集（`GRASS`）生成了有效的拓扑简化。
- en: In this recipe, you will use the PostGIS topology support to perform the same
    task within the spatial database, without needing to export the dataset to a different
    toolset.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将使用PostGIS拓扑支持在空间数据库中执行相同的任务，而无需将数据集导出到不同的工具集。
- en: Getting ready
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started, perform the following steps:'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要开始，请执行以下步骤：
- en: 'Be sure that you have PostGIS topology support enabled in your database instance.
    This support is packaged as a separate extension and, if you are using PostgreSQL
    9.1 or newer versions, you can install it using the following SQL `CREATE EXTENSION`
    command:'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已在数据库实例中启用了PostGIS拓扑支持。此支持作为单独的扩展程序打包，如果您使用的是PostgreSQL 9.1或更高版本，您可以使用以下SQL
    `CREATE EXTENSION` 命令进行安装：
- en: '[PRE69]'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Download the administrative area archive for Hungary from the `gadm.org` website
    at [http://gadm.org/country](http://gadm.org/country) (or use the copy included
    in the code bundle provided with this book).
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `gadm.org` 网站下载匈牙利的行政区域存档 [http://gadm.org/country](http://gadm.org/country)（或使用本书提供的代码包中的副本）。
- en: Extract the `HUN_adm1.shp` shapefile from the archive to your working directory,
    `working/chp03`.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `HUN_adm1.shp` shapefile从存档中提取到您的当前工作目录，`working/chp03`。
- en: 'Import the shapefile to PostGIS using a tool such as `ogr2ogr` or `shp2pgsql`,
    as follows:'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ogr2ogr` 或 `shp2pgsql` 等工具将shapefile导入PostGIS，如下所示：
- en: '[PRE70]'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'After the import process is completed, you can check the count using the following
    command; note that this spatial table consists of 20 multipolygons, each representing
    one administrative area in Hungary:'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入过程完成后，您可以使用以下命令来检查计数；请注意，这个空间表由20个多边形组成，每个多边形代表匈牙利的一个行政区域：
- en: '[PRE71]'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '![](img/0257f42c-5d33-4cd0-ad04-581f630b2918.png)'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/0257f42c-5d33-4cd0-ad04-581f630b2918.png)'
- en: '[PRE72]'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How to do it...
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The steps you need to take to complete this recipe are as follows:'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您需要采取以下步骤来完成此菜谱：
- en: 'All functions and tables associated with the topology module are installed
    in a schema named `topology`, so let''s add it to the search path to avoid prefixing
    it before every `topology` function or object:'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与拓扑模块相关的所有函数和表都安装在一个名为 `topology` 的模式中，所以让我们将其添加到搜索路径中，以避免在每次使用 `topology` 函数或对象之前都加上前缀：
- en: '[PRE73]'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now you will use the `CreateTopology` function to create a new `topology` schema
    named `hu_topo` in which you will import the 20 administrative areas from the
    `hungary` table. In PostGIS topology, all the topology entities and relations
    needed for one topology schema are stored in a single PostgreSQL schema using
    the same spatial reference system. You will name this schema `hu_topo` and use
    the EPSG:3857 spatial reference (the one used in the original shapefile):'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将使用`CreateTopology`函数创建一个新的名为`hu_topo`的`topology`模式，您将从中导入`hungary`表中的20个行政区域。在PostGIS拓扑中，一个拓扑模式所需的所有拓扑实体和关系都存储在单个PostgreSQL模式中，使用相同的空间参考系统。您将命名此模式为`hu_topo`并使用EPSG:3857空间参考（原始shapefile中使用的参考）：
- en: '[PRE74]'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Note how a record has been added to the `topology.topology` table in the following
    code:'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意以下代码中记录是如何被添加到`topology.topology`表的：
- en: '[PRE75]'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '![](img/907e7558-c19e-4349-a68f-c3372087b596.png)'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/907e7558-c19e-4349-a68f-c3372087b596.png)'
- en: '[PRE76]'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Also note that four tables and one view, which are needed for storing and managing
    the topology, have been generated in the schema named `hu_topo`, created from
    the `CreateTopology` function:'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要注意，为了存储和管理拓扑，已在该名为`hu_topo`的模式中生成四个表和一个视图，该模式由`CreateTopology`函数创建：
- en: '[PRE77]'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![](img/57fcdf33-578f-49f7-98a0-8b5ab182a381.png)'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/57fcdf33-578f-49f7-98a0-8b5ab182a381.png)'
- en: '[PRE78]'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Check the initial information for the created topology using the `topologysummary`
    function, as follows; still, none of the topologic entities (nodes, edges, faces,
    and so on) are initialized:'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`topologysummary`函数检查创建的拓扑的初始信息，如下所示；然而，仍然没有任何拓扑实体（节点、边、面等）被初始化：
- en: '[PRE79]'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![](img/02280017-3cd2-4ad0-8b3f-7af9cd4bfa24.png)'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/02280017-3cd2-4ad0-8b3f-7af9cd4bfa24.png)'
- en: '[PRE80]'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create a new PostGIS table as follows for storing the topological administrative
    boundaries:'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个新的PostGIS表以存储拓扑行政边界：
- en: '[PRE81]'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Add a topological geometry column to this table as follows, using the `AddTopoGeometryColumn`
    function:'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`AddTopoGeometryColumn`函数按以下方式向此表添加拓扑几何列：
- en: '[PRE82]'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Insert the polygons from the non-topological `hungary` spatial table to the
    topological table, using the `toTopoGeom` function:'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`toTopoGeom`函数将非拓扑的`hungary`空间表中的多边形插入到拓扑表中：
- en: '[PRE83]'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now run the following code to check out how the content of the topology schema
    has been modified by the `toTopoGeom` function; you would expect to have 20 faces,
    one for each Hungarian administrative area, but instead there are 92:'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行以下代码以检查`toTopoGeom`函数如何修改拓扑模式的内容；你预计会有20个面，每个代表一个匈牙利行政区域，但结果却有92个：
- en: '[PRE84]'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '![](img/698f067b-bfbd-4c6e-bf65-5fdb46f8167e.png)'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/698f067b-bfbd-4c6e-bf65-5fdb46f8167e.png)'
- en: 'The problem is easily identifiable by analyzing the `hu_topo.face` table or
    using a desktop GIS. If you sort the polygons from this table by area, using the
    `ST_Area` function, you will notice after the details of the first polygon, which
    has 1 null area (used by the topology screenshot in the next step) and 20 large
    areas (each representing one administrative area), that there are 77 very small
    polygons generated by topological anomalies (polygon overlaps and holes):'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过分析`hu_topo.face`表或使用桌面GIS，可以轻松地识别问题。如果您使用`ST_Area`函数按面积对表中的多边形进行排序，您将在第一个多边形的详细信息之后注意到，该多边形有1个空面积（用于下一步中的拓扑截图）和20个大面积（每个代表一个行政区域），还有77个由拓扑异常（多边形重叠和空洞）生成的小多边形：
- en: '[PRE85]'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '![](img/167416ff-d3a3-45e6-bb14-ec4a9a1bd452.png)'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/167416ff-d3a3-45e6-bb14-ec4a9a1bd452.png)'
- en: '[PRE86]'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You can eventually look at the built topology elements (nodes, edges, faces,
    and topological geometries, or topogeoms) using a desktop GIS. The following screenshot
    shows how they look in QGIS:![](img/85c159b9-4d66-4148-a1ca-326b71643541.png)
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您最终可以使用桌面GIS查看构建的拓扑元素（节点、边、面、拓扑几何体或topogeoms）。以下截图显示了它们在QGIS中的外观：![图片](img/85c159b9-4d66-4148-a1ca-326b71643541.png)
- en: 'Now you will rebuild the topology using a small tolerance value—1 meter—as
    an additional parameter to the `CreateTopology` function, in order to get rid
    of the unnecessary faces (the tolerance will collapse the vertex together, eliminating
    the small polygons). First, drop your topology schema with the `DropTopology`
    function and the topological table with the `DROP TABLE` command, and rebuild
    both of them using a topology tolerance of 1 meter, as follows:'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将使用`CreateTopology`函数重建拓扑，使用一个小容差值——1米——作为`CreateTopology`函数的附加参数，以消除不必要的面（容差将合并顶点，消除小多边形）。首先，使用`DropTopology`函数和`DROP
    TABLE`命令删除您的拓扑模式，并使用1米的拓扑容差重建它们，如下所示：
- en: '[PRE87]'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, if you check the information related to the topology using the `topologysummary`
    function as follows, you can see that there is one face per administrative boundary
    and the previous 72 faces generated by topological anomalies have been eliminated,
    leaving only 20:'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你使用`topologysummary`函数检查与拓扑相关的信息，如下所示，你可以看到每个行政边界都有一个面，并且之前由拓扑异常生成的72个面已经被消除，只剩下20个：
- en: '[PRE88]'
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '![](img/d75f81c3-2397-441c-90d1-15e22c38b671.png)'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/d75f81c3-2397-441c-90d1-15e22c38b671.png)'
- en: '[PRE89]'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Finally, simplify the polygons of the `topo_polygons` table using a tolerance
    of 500 meters, as follows:'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用500米的容差简化`topo_polygons`表中的多边形，如下所示：
- en: '[PRE90]'
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now it''s time to update the original `hungary` table using a join with the
    `hu_topo_polygons` table by running the following commands:'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候使用以下命令通过连接`hu_topo_polygons`表来更新原始的`hungary`表了：
- en: '[PRE91]'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The simplification process should have worked smoothly and produced a valid
    topological dataset. The following screenshot shows how the reduced topology looks
    (in red) compared to the original one (in black):![](img/e9fdda00-3e16-4eb9-9adb-cd9aba73f140.png)
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化过程应该顺利运行并生成一个有效的拓扑数据集。以下截图显示了简化后的拓扑（红色）与原始拓扑（黑色）的对比：![](img/e9fdda00-3e16-4eb9-9adb-cd9aba73f140.png)
- en: How it works...
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created a new PostGIS topology schema using the `CreateTopology` function.
    This function creates a new PostgreSQL schema where all the topological entities
    are stored.
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`CreateTopology`函数创建了一个新的PostGIS拓扑模式。此函数创建了一个新的PostgreSQL模式，其中存储了所有拓扑实体。
- en: We can have more topological schemas within the same spatial database, each
    being contained in a different PostgreSQL schema. The PostGIS `topology.topology`
    table manages all the metadata for all the topological schemas.
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在同一个空间数据库中，我们可以有更多的拓扑模式，每个模式包含在不同的PostgreSQL模式中。PostGIS的`topology.topology`表管理所有拓扑模式的元数据。
- en: Each topological schema is composed of a series of tables and views to manage
    the topological entities (such as edge, edge data, face, node, and topogeoms)
    and their relations.
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个拓扑模式由一系列表和视图组成，用于管理拓扑实体（如边、边数据、面、节点和topogeoms）及其关系。
- en: We can have a quick look at the description of a single topological schema using
    the `topologysummary` function, which summarizes the main metadata information-name,
    SRID, and precision; the number of nodes, edges, faces, topogeoms, and topological
    layers; and, for each topological layer, the geometry type, and the number of
    topogeoms.
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用`topologysummary`函数快速查看单个拓扑模式的描述，该函数总结了主要元数据信息——名称、SRID和精度；节点、边、面、topogeoms和拓扑层的数量；以及对于每个拓扑层，几何类型和topogeoms的数量。
- en: After creating the topology schema, we created a new PostGIS table and added
    to it a topological geometry column (`topogeom` in PostGIS topology jargon) using
    the `AddTopoGeometryColumn` function.
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在创建拓扑模式后，我们使用`AddTopoGeometryColumn`函数创建了一个新的PostGIS表，并向其中添加了一个拓扑几何列（在PostGIS拓扑术语中称为`topogeom`）。
- en: We then used the `ST_ChangeEdgeGeom` function to alter the geometries for the
    topological edges, using the `ST_SimplifyPreserveTopology` function, with a tolerance
    of 500 meters, and checked that this function, used in the context of a topological
    schema, produces topologically correct results for polygons too.
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们使用`ST_ChangeEdgeGeom`函数通过`ST_SimplifyPreserveTopology`函数更改拓扑边的几何形状，容差为500米，并检查了在拓扑模式上下文中使用此函数是否为多边形生成拓扑正确的结果。
