- en: 6 Working with Date and Time in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 在Python中处理日期和时间
- en: Join our book community on Discord
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的Discord书籍社区
- en: '![](img/file0.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file0.png)'
- en: '[https://packt.link/zmkOY](https://packt.link/zmkOY)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/zmkOY](https://packt.link/zmkOY)'
- en: At the core of time-series data is **time**. **Time-series data** is a sequence
    of observations or data points captured in successive order and at regular time
    intervals. In the context of a pandas DataFrame, time-series data has an ordered
    index of type `DatetimeIndex`, as you have seen in earlier chapters. The **DatetimeIndex**
    offers an easy and efficient slicing, indexing, and time-based grouping of data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列数据的核心是**时间**。**时间序列数据**是按顺序和定期时间间隔捕捉的一系列观测值或数据点。在pandas的DataFrame上下文中，时间序列数据有一个按顺序排列的`DatetimeIndex`类型的索引，如你在前面的章节中所见。**DatetimeIndex**提供了一个简便且高效的数据切片、索引和基于时间的数据分组方式。
- en: Being familiar with manipulating date and time in time-series data is an essential
    component of time series analysis and modeling. In this chapter, you will find
    recipes for common scenarios when working with date and time in time-series data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉在时间序列数据中操作日期和时间是时间序列分析和建模的基本组成部分。在本章中，你将找到一些常见场景的解决方案，帮助你在处理时间序列数据中的日期和时间时得心应手。
- en: Python has several built-in modules for working with date and time, such as
    the `datetime`, `time`, `calendar`, and `zoneinfo` modules. Additionally, there
    are other popular libraries in Python that further extend the capability to work
    with and manipulate date and time, such as `dateutil`, `pytz`, and `arrow`, to
    name a few.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python有几个内置模块用于处理日期和时间，如`datetime`、`time`、`calendar`和`zoneinfo`模块。此外，Python还有一些流行的库进一步扩展了日期和时间的处理能力，例如`dateutil`、`pytz`和`arrow`等。
- en: You will be introduced to the `datetime` module in this chapter but you will
    then transition to using **pandas** for enhanced and more complex date and time
    manipulation, and for generating time-series DataFrames with a sequence of `DatetimeIndex`.
    In addition, the `pandas` library contains several date-specific and time-specific
    classes that inherit from the aforementioned Python modules. In other words, you
    will not need to import additional date/time Python libraries.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍`datetime`模块，但你将转向使用**pandas**进行更复杂的日期和时间操作，以及生成带有`DatetimeIndex`序列的时间序列DataFrame。此外，`pandas`库包含多个继承自上述Python模块的日期和时间相关类。换句话说，你无需导入额外的日期/时间Python库。
- en: You will be introduced to pandas classes such as `Timestamp`, `Timedelta`, `Period`,
    and `DateOffset`. You will notice similarities between the functionality – for
    example, the pandas `Timestamp` class is equivalent to Python's `Datetime` class
    and can be interchangeable in most scenarios. Similarly, `pandas.Timedelta` is
    equivalent to Python's `datetime.timedelta` object. The `pandas` library offers
    a more straightforward, intuitive, and powerful interface to handle most of your
    date and time manipulation needs without importing additional modules. When using
    pandas, you will appreciate having a library that contains everything you need
    to work with time-series data and can easily handle many challenging tasks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会接触到pandas中的类，如`Timestamp`、`Timedelta`、`Period`和`DateOffset`。你会发现它们之间有很多相似性——例如，pandas的`Timestamp`类相当于Python的`Datetime`类，且在大多数情况下可以互换。类似地，`pandas.Timedelta`等同于Python的`datetime.timedelta`对象。`pandas`库提供了一个更简洁、直观和强大的接口，帮助你处理大多数日期和时间操作，无需额外导入模块。使用pandas时，你将享受一个包含所有时间序列数据处理所需工具的库，轻松应对许多复杂的任务。
- en: 'Here is the list of the recipes that we will cover in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本章中讨论的解决方案列表：
- en: Working with `DatetimeIndex`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`DatetimeIndex`
- en: Providing a format argument to `DateTime`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`DateTime`提供格式参数
- en: Working with Unix epoch timestamps
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unix纪元时间戳
- en: Working with time deltas
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理时间差
- en: Converting `DateTime` with time zone information
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换带有时区信息的`DateTime`
- en: Working with date offsets
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理日期偏移
- en: Working with custom business days
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理自定义工作日
- en: In a real-world scenario, you may not use all or any of these techniques. Still,
    it is critical to be aware of the options when facing a particular scenario that
    requires certain adjustments or formatting of dates.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，你可能并不会使用所有这些技巧或技术，但了解这些选项是至关重要的，尤其是在面对某些特定场景时，需要调整或格式化日期。
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter and going forward, we will extensively use pandas 2.1.3 (released
    on November 10, 2023\. This applies to all the recipes in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章及之后的内容中，我们将广泛使用 pandas 2.1.3（发布于 2023 年 11 月 10 日）。这适用于本章中的所有示例。
- en: 'Load these libraries in advance, since you will be using them throughout the
    chapter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请提前加载这些库，因为你将在本章中贯穿使用它们：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will use `dt`, `np`, and `pd` aliases going forward.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在接下来的内容中使用 `dt`、`np` 和 `pd` 别名。
- en: You can download the Jupyter notebooks from the GitHub repository at [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/code/Ch6](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/code/Ch6)
    to follow along.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 GitHub 仓库下载 Jupyter 笔记本，[https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/code/Ch6](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/code/Ch6)
    来进行跟随操作。
- en: Working with DatetimeIndex
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 DatetimeIndex
- en: The `pandas` library has many options and features to simplify tedious tasks
    when working with time-series data, dates, and time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` 库提供了许多选项和功能，可以简化在处理时间序列数据、日期和时间时繁琐的任务。'
- en: When working with time-series data in Python, it is common to load into a pandas
    DataFrame with an index of type `DatetimeIndex`. As an index, the `DatetimeIndex`
    class extends pandas DataFrame capabilities to work more efficiently and intelligently
    with time-series data. This was demonstrated numerous times in *Chapter 2*, *Reading
    Time Series Data from Files*, and *Chapter 3*, *Reading Time Series Data from
    Databases*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中处理时间序列数据时，通常将数据加载到具有 `DatetimeIndex` 类型索引的 pandas DataFrame 中。作为索引，`DatetimeIndex`
    类扩展了 pandas DataFrame 的功能，使其能够更高效、智能地处理时间序列数据。这个概念在*第二章*《从文件中读取时间序列数据》和*第三章*《从数据库中读取时间序列数据》中已经多次展示。
- en: By the end of this recipe, you will appreciate pandas' rich set of date functionality
    to handle almost any representation of date/time in your data. Additionally, you
    will learn how to use different functions in pandas to convert date-like objects
    to a DatetimeIndex.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本示例后，你将充分理解 pandas 提供的丰富日期功能，以处理数据中几乎所有日期/时间的表示方式。此外，你还将学习如何使用 pandas 中的不同函数将类似日期的对象转换为
    DatetimeIndex。
- en: How to do it…
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: In this recipe, you will explore Python's `datetime` module and learn about
    the `Timestamp` and `DatetimeIndex` classes and the relationship between them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，你将探索 Python 的 `datetime` 模块，并了解 `Timestamp` 和 `DatetimeIndex` 类以及它们之间的关系。
- en: 'To understand the relationship between Python''s `datetime.datetime` class
    and pandas'' `Timestamp` and `DatetimeIndex` classes, you will create three different
    `datetime` objects representing the date `2021, 1, 1`. You will then compare these
    objects to gain a better understanding:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了理解 Python 的 `datetime.datetime` 类与 pandas 的 `Timestamp` 和 `DatetimeIndex`
    类之间的关系，你将创建三个不同的 `datetime` 对象，表示日期 `2021, 1, 1`。然后，你将比较这些对象以获得更好的理解：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inspect the datetime representation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 检查日期时间表示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inspect their data types:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 检查它们的数据类型：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And finally, let''s see how they compare:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看它们的比较：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see from the preceding code that pandas'' `Timestamp` object is equivalent
    to Python''s `Datetime` object:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看到，pandas 的 `Timestamp` 对象等同于 Python 的 `Datetime` 对象：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that `dt2` is an instance of `pandas.Timestamp` class, and the `Timestamp`
    class is a subclass of Python's `dt.datetime` class (but not vice versa).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`dt2` 是 `pandas.Timestamp` 类的一个实例，而 `Timestamp` 类是 Python 的 `dt.datetime`
    类的子类（但反之不成立）。
- en: 'When you used the `pandas.to_datetime()` function, it returned a `Timestamp`
    object. Now, use `pandas.to_datetime()` on a list and examine the outcome:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你使用 `pandas.to_datetime()` 函数时，它返回了一个 `Timestamp` 对象。现在，使用 `pandas.to_datetime()`
    处理一个列表并检查结果：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Interestingly, the output is now of type `DatetimeIndex` created using the same
    `pandas.to_datetime()` function that you used earlier. Previously, when using
    the same function on an individual object, the result was of type `Timestamp`,
    but when applied on a list, it produced a sequence of type `DatetimeIndex`. You
    will perform one more task to make things clearer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，输出现在是 `DatetimeIndex` 类型，它是使用你之前使用的相同 `pandas.to_datetime()` 函数创建的。此前，当对单个对象使用相同的函数时，结果是
    `Timestamp` 类型，但当作用于列表时，它生成了一个 `DatetimeIndex` 类型的序列。你将执行另一个任务，以便更清楚地理解。
- en: 'Print out the first item (slice) from the `pd_dates` variable:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出 `pd_dates` 变量中的第一个元素（切片）：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From the preceding output, you can infer a relationship between the two classes:
    `DatetimeIndex` and `Timestamp`. A DatetimeIndex is a sequence (list) of `Timestamp`
    objects.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，你可以推测出两个类之间的关系：`DatetimeIndex` 和 `Timestamp`。`DatetimeIndex` 是一个 `Timestamp`
    对象的序列（列表）。
- en: Now that you know how to create a `DatetimeIndex` using the `pandas.to_datetime()`
    function, let's further expand on this and see what else you can do with the function.
    For example, you will see how simple it is to convert different `datetime` representations,
    including strings, integers, lists, pandas series, or other `datetime` objects,
    into a `DatetimeIndex`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经知道如何使用 `pandas.to_datetime()` 函数创建 `DatetimeIndex`，让我们进一步扩展，看看你还能使用这个函数做些什么。例如，你将看到如何轻松地将不同的
    `datetime` 表示形式（包括字符串、整数、列表、pandas 系列或其他 `datetime` 对象）转换为 `DatetimeIndex`。
- en: 'Let''s create a `dates` list:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `dates` 列表：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Parse the list using `pandas.to_datetime()`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pandas.to_datetime()` 解析列表：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice how the `to_datetime()` function properly parsed the entire list of
    different string representations and date types such as Python''s `Datetime` and
    NumPy''s `datetime64`. Similarly, you could have used the `DatetimeIndex` constructor
    directly, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`to_datetime()` 函数如何正确解析不同字符串表示形式和日期类型的整个列表，如 Python 的 `Datetime` 和 NumPy
    的 `datetime64`。类似地，你也可以直接使用 `DatetimeIndex` 构造函数，如下所示：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This would produce similar results.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似的结果。
- en: 'The `DatetimeIndex` object gives access to many useful properties and methods
    to extract additional date and time properties. As an example, you can extract
    `day_name`, `month`, `year`, `days_in_month`, `quarter`, `is_quarter_start`, `is_leap_year`,
    `is_month_start`, `is_month_end`, and `is_year_start`. The following code shows
    how this can be done:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DatetimeIndex` 对象提供了许多有用的属性和方法，用于提取附加的日期和时间属性。例如，你可以提取 `day_name`、`month`、`year`、`days_in_month`、`quarter`、`is_quarter_start`、`is_leap_year`、`is_month_start`、`is_month_end`
    和 `is_year_start`。以下代码展示了如何做到这一点：'
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code produces the following results:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生了以下结果：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These properties and methods will be very useful when transforming your time-series
    datasets for analysis.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性和方法在转换你的时间序列数据集以进行分析时非常有用。
- en: How it works…
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The, `pandas.to_datetime()` is a powerful function that can intelligently parse
    different date representations from strings. As you saw in *step 4* in the previous
    *How to do it…* section, the string examples, such as `'2021-01-01'`, `'2/1/2021'`,
    `'03-01-2021'`, `'April 1, 2021'`, and `'20210501'`, were parsed correctly. Other
    date representations such as `'April 1, 2021'` and '`1 April 2021'`, can be parsed
    using the `to_datetime()` function as well, and I'll leave it to you to explore
    additional examples that come to mind.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas.to_datetime()` 是一个强大的函数，可以智能地解析不同的日期表示形式（如字符串）。正如你在之前的 *第 4 步* 中看到的那样，字符串示例，如
    `''2021-01-01''`、`''2/1/2021''`、`''03-01-2021''`、`''April 1, 2021''` 和 `''20210501''`，都被正确解析。其他日期表示形式，如
    `''April 1, 2021''` 和 `''1 April 2021''`，也可以通过 `to_datetime()` 函数解析，我将留给你探索更多可以想到的其他示例。'
- en: The `to_datetime` function contains the `errors` parameter. In the following
    example, you specify `errors='coerce'` which instructs pandas to set any value
    it could not parse as `NaT` indicating a missing value. You will learn more about
    `NaT` in the Performing data quality checks recipe in *Chapter 7*, *Handling Missing
    Data*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_datetime` 函数包含了 `errors` 参数。在以下示例中，你指定了 `errors=''coerce''`，这指示 pandas
    将无法解析的任何值设置为 `NaT`，表示缺失值。在*第七章*《处理缺失数据》的数据质量检查部分，你将进一步了解 `NaT`。'
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In pandas, there are different representations to indicate missing values –
    `np.NaN` represents missing numeric values (**Not a Number**), while `pd.NaT`
    represents missing `datetime` values (**Not a Time**). Finally, pandas' `pd.NA`
    is used to represent missing scalar values (**Not Available**).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pandas 中，有不同的表示方式来表示缺失值——`np.NaN` 表示缺失的数值 (**Not a Number**)，而 `pd.NaT` 表示缺失的
    `datetime` 值 (**Not a Time**)。最后，pandas 的 `pd.NA` 用于表示缺失的标量值 (**Not Available**）。
- en: 'The `errors` parameter in `to_datetime` can take one of the three valid string
    options:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_datetime` 中的 `errors` 参数可以接受以下三种有效的字符串选项：'
- en: '`raise`, which means it will raise an exception (`error out`).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raise`，意味着它将抛出一个异常（`error out`）。'
- en: '`coerce` will not cause it to raise an exception. Instead, it will just replace
    `pd.NaT`, indicating a missing datetime value.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coerce` 不会导致抛出异常。相反，它将替换为 `pd.NaT`，表示缺失的日期时间值。'
- en: '`ignore` will also not cause it to raise an exception. Instead, it will just
    pass in the original value.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore` 同样不会导致抛出异常。相反，它将保留原始值。'
- en: 'Here is an example using the `ignore` value:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 `ignore` 值的示例：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When the errors parameter is set to `'ignore'`, pandas will not raise an error
    if it stumbles upon a date representation it cannot parse. Instead, the input
    value is passed as-is. For example, notice from the preceding output that the
    `to_datetime` function returned an `Index` type and not a `DatetimeIndex`. Further,
    the items in the Index sequence are of dtype `object` (and not `datetime64`).
    In pandas, the object dtype represents strings or mixed types.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `errors` 参数设置为 `'ignore'` 时，如果 pandas 遇到无法解析的日期表示，它将不会抛出错误。相反，输入值将按原样传递。例如，从前面的输出中可以看到，`to_datetime`
    函数返回的是 `Index` 类型，而不是 `DatetimeIndex`。此外，索引序列中的项是 `object` 类型（而不是 `datetime64`）。在
    pandas 中，`object` 类型表示字符串或混合类型。
- en: 'Additionally, you explored how you an extract additional datetime properties
    using built-in properties and methods such as:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还探索了如何使用内置属性和方法提取额外的日期时间属性，例如：
- en: '**day_name():** Returns the name of the day of the week (e.g., Monday, Tuesday).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**day_name():** 返回星期几的名称（例如，星期一，星期二）。'
- en: '**month**: Provides the month component of the date as an integer (1 through
    12).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**month**: 提供日期的月份部分，作为整数（1 到 12）。'
- en: '**month_name():** Returns the full name of the month (e.g., January, February).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**month_name():** 返回月份的完整名称（例如，1月，2月）。'
- en: 'year: Retrieves the year component of the date as an integer.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'year: 提取日期的年份部分，作为整数。'
- en: '**days_in_month**: Gives the number of days in the month for the given date.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**days_in_month**: 给出给定日期所在月份的天数。'
- en: 'quarter: Indicates the quarter of the year for the date (1 through 4).'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'quarter: 表示该日期所在年的季度（1 到 4）。'
- en: '**is_quarter_start**: Boolean value indicating whether the date is the first
    day of a quarter (True or False).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**is_quarter_start**: 布尔值，指示该日期是否为季度的第一天（True 或 False）。'
- en: '**is_leap_year**: Boolean value indicating whether the year of the date is
    a leap year (True or False).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**is_leap_year**: 布尔值，指示该日期年份是否为闰年（True 或 False）。'
- en: '**is_month_start**: Boolean value indicating whether the date is the first
    day of its month (True or False).'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**is_month_start**: 布尔值，指示该日期是否为该月份的第一天（True 或 False）。'
- en: '**is_month_end**: Boolean value indicating whether the date is the last day
    of its month (True or False).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**is_month_end**: 布尔值，指示该日期是否为该月份的最后一天（True 或 False）。'
- en: '**is_year_start**: Boolean value indicating whether the date is the first day
    of its year (True or False).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**is_year_start**: 布尔值，指示该日期是否为该年份的第一天（True 或 False）。'
- en: There’s more…
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'An alternate way to generate a `DatetimeIndex` is with the `pandas.date_range()`
    function. The following code provides a starting date and the number of periods
    to generate and specifies a daily frequency with `D`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 `DatetimeIndex` 的另一种方式是使用 `pandas.date_range()` 函数。以下代码提供了一个起始日期和生成的周期数，并指定了每日频率
    `D`：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`pandas.date_range()` requires at least three of the four parameters to be
    provided – `start`, `end`, `periods`, and `freq`. If you do not provide enough
    information, you will get a `ValueError` exception with the following message:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas.date_range()` 至少需要提供四个参数中的三个——`start`、`end`、`periods` 和 `freq`。如果没有提供足够的信息，将会抛出
    `ValueError` 异常，并显示以下信息：'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s explore the different parameter combinations required to use the `date_range`
    function. In the first example, provide a start date, end date, and specify a
    daily frequency. The function will always return a range of equally spaced time
    points:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用 `date_range` 函数所需的不同参数组合。在第一个示例中，提供开始日期、结束日期，并指定每日频率。该函数将始终返回一个等间隔的时间点范围：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the second example, provide a start date and an end date, but instead of
    frequency, provide a number of periods. Remember that the function will always
    return a range of equally spaced time points:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，提供开始日期和结束日期，但不提供频率，而是提供周期数。请记住，该函数将始终返回一个等间隔的时间点范围：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the following example, provide an end date and the number of periods returned,
    and indicate a daily frequency:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，提供结束日期和返回的周期数，并指定每日频率：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note, the `pd.date_range()` function can work with a minimum of two parameters
    if the information is sufficient to generate equally spaced time points and infer
    the missing parameters. Here is an example of providing start and end dates only:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果信息足够生成等间隔的时间点并推断缺失的参数，`pd.date_range()` 函数最少可以接受两个参数。以下是只提供开始和结束日期的示例：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice that pandas was able to construct the date sequence using the start
    and end dates and default to daily frequency. Here is another example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，pandas 能够使用开始和结束日期构造日期序列，并默认采用每日频率。这里有另一个例子：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With `start` and `periods`, pandas has enough information to construct the date
    sequence and default to daily frequency.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `start` 和 `periods`，pandas 有足够的信息来构造日期序列，并默认采用每日频率。
- en: 'Now, here is an example that lacks enough information on how to generate the
    sequence and will cause pandas to throw an error:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有一个例子，它缺乏足够的信息来生成序列，并且会导致 pandas 抛出错误：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that with just a start date and frequency, pandas does not have enough
    information to construct the date sequence. Therefore, adding either `periods`
    or the `end` date will be sufficient.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，仅凭开始日期和频率，pandas 并没有足够的信息来构造日期序列。因此，添加 `periods` 或 `end` 日期中的任何一个即可。
- en: 'Let’s put everything we have learned from generating a DatetimeIndex to extracting
    datatime properties. In the following example you will use date_range() function
    to create a DataFrame with one Date column. You will then create additional columns
    using the different properites and methods:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结从生成 DatetimeIndex 到提取 datetime 属性的所有内容。在以下示例中，您将使用 `date_range()` 函数创建一个包含日期列的
    DataFrame。然后，您将使用不同的属性和方法创建附加列：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code should produce the following DataFrame
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应生成以下 DataFrame：
- en: '![Figure 6.1 A Time Series DataFrame with 5 rows and 12 columns](img/file43.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 一个包含 5 行和 12 列的时间序列 DataFrame](img/file43.png)'
- en: Figure 6.1 A Time Series DataFrame with 5 rows and 12 columns
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 一个包含 5 行和 12 列的时间序列 DataFrame
- en: THE `Series.dt` ACCESSOR
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Series.dt` 访问器'
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notice the use of `.dt` accessor in the previous code example when working with
    a pandas **Series** of *datetime* object. The `.dt` accessor in pandas is a property
    used for accessing a wide range of datetime properties of a Series. In the previous
    example, you used `.dt` to access the datetime properties of the `df[‘Date’]`
    Series.
  id: totrans-110
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，在前面的代码示例中，当处理 pandas **Series** 的 *datetime* 对象时，使用了 `.dt` 访问器。pandas 中的
    `.dt` 访问器是用于访问 Series 的各种 datetime 属性的一个属性。在之前的例子中，您使用 `.dt` 访问了 `df[‘Date’]`
    Series 的 datetime 属性。
- en: See also
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另见：
- en: 'To learn more about pandas'' `to_datetime()` function and the `DatetimeIndex`
    class, please check out these resources:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 pandas 的 `to_datetime()` 函数和 `DatetimeIndex` 类的信息，请查看以下资源：
- en: '`pandas.DatetimeIndex` documentation: [https://pandas.pydata.org/docs/reference/api/pandas.DatetimeIndex.html](https://pandas.pydata.org/docs/reference/api/pandas.DatetimeIndex.html)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pandas.DatetimeIndex` 文档： [https://pandas.pydata.org/docs/reference/api/pandas.DatetimeIndex.html](https://pandas.pydata.org/docs/reference/api/pandas.DatetimeIndex.html)'
- en: '`pandas.to_datetime` documentation: [https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html](https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pandas.to_datetime` 文档：[https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html](https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html)'
- en: Providing a format argument to DateTime
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供格式参数给 DateTime
- en: When working with datasets extracted from different data sources, you may encounter
    date columns stored in string format, whether from files or databases. In the
    previous recipe, *Working with DatetimeIndex*, you explored the `pandas.to_datetime()`
    function that can parse various date formats with minimal input. However, you
    will want more granular control to ensure that the date is parsed correctly. For
    example, you will now be introduced to the `strptime` and `strftime` methods and
    see how you can specify formatting in `pandas.to_datetime()` to handle different
    date formats.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理从不同数据源提取的数据集时，您可能会遇到以字符串格式存储的日期列，无论是来自文件还是数据库。在之前的例子中，*使用 DatetimeIndex*，您探索了
    `pandas.to_datetime()` 函数，它可以通过最小的输入解析各种日期格式。然而，您可能希望有更精细的控制，以确保日期被正确解析。例如，接下来您将了解
    `strptime` 和 `strftime` 方法，并查看如何在 `pandas.to_datetime()` 中指定格式化选项，以处理不同的日期格式。
- en: In this recipe, you will learn how to parse strings that represent dates to
    a `datetime` or `date` object (an instance of the class `datetime.datetime` or
    `datetime.date`).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，您将学习如何将表示日期的字符串解析为 `datetime` 或 `date` 对象（`datetime.datetime` 或 `datetime.date`
    类的实例）。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Python''s `datetime` module contains the `strptime()` method to create `datetime`
    or `date` from a string that contains a date. You will first explore how you can
    do this in Python and then extend this to pandas:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `datetime` 模块包含 `strptime()` 方法，用于从包含日期的字符串创建 `datetime` 或 `date` 对象。您将首先探索如何在
    Python 中做到这一点，然后将其扩展到 pandas 中：
- en: 'Let''s explore a few examples, parsing strings to `datetime` objects using
    `datetime.strptime`. You will parse four different representations of `January
    1, 2022` that will produce the same output – `datetime.datetime(2022, 1, 1, 0,
    0)`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们探索一些示例，使用 `datetime.strptime` 解析字符串为 `datetime` 对象。您将解析四种不同表示方式的 `2022年1月1日`，它们会生成相同的输出
    – `datetime.datetime(2022, 1, 1, 0, 0)`：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that the output is a `datetime` object, representing the year, month,
    day, hour, and minute. You can specify only the date representation, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出是一个 `datetime` 对象，表示年份、月份、日期、小时和分钟。您可以仅指定日期表示方式，如下所示：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, you will have a `date` object instead of `datetime`. You can get the readable
    version of `datetime` using the `print()` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将获得一个 `date` 对象，而不是 `datetime` 对象。您可以使用 `print()` 函数获取 `datetime` 的可读版本：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s compare what you did using the `datetime.strptime` method using
    `pandas.to_datetime` method:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们比较一下使用 `datetime.strptime` 方法与 `pandas.to_datetime` 方法的差异：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, you can get the string (readable) representation of the `Timestamp`
    object using the `print()` function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用 `print()` 函数获取 `Timestamp` 对象的字符串（可读）表示：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There is an advantage in using `pandas.to_datetime()` over Python''s `datetime`
    module. The `to_datetime()` function can parse a variety of date representations,
    including string date formats with minimal input or specifications. The following
    code explains this concept; note that the `format` is omitted:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `pandas.to_datetime()` 相较于 Python 的 `datetime` 模块有一个优势。`to_datetime()` 函数可以解析多种日期表示方式，包括带有最少输入或规格的字符串日期格式。以下代码解释了这个概念；请注意省略了
    `format`：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that unlike `datetime`, which requires integer values or to use the `strptime`
    method for parsing strings, the `pandas.to_datetime()` function can intelligently
    parse different date representations without specifying a format (this is true
    in most cases).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与需要整数值或使用 `strptime` 方法解析字符串的 `datetime` 不同，`pandas.to_datetime()` 函数可以智能地解析不同的日期表示方式，而无需指定格式（大多数情况下是如此）。
- en: How it works…
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, you used Python's `datetime.datetime` and `pandas.to_datetime`
    methods to parse dates in string formats. When using `datetime`, you had to use
    the `dt.datetime.strptime()` function to specify the date format representation
    in the string using format codes (example `%d`, `%B`, and `%Y`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您使用了 Python 的 `datetime.datetime` 和 `pandas.to_datetime` 方法来解析字符串格式的日期。当使用
    `datetime` 时，您需要使用 `dt.datetime.strptime()` 函数来指定字符串中日期格式的表示方式，并使用格式代码（例如 `%d`、`%B`
    和 `%Y`）。
- en: 'For example, in `datetime.strptime(''1 January, 2022'', ''%d %B, %Y'')`, you
    provided the `%d`, `%B`, and `%Y` format codes in the exact order and spacing
    to represent the formatting provided in the string. Let''s break this down:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `datetime.strptime('1 January, 2022', '%d %B, %Y')` 中，您按确切顺序和间距提供了 `%d`、`%B`
    和 `%Y` 格式代码，以表示字符串中的格式。让我们详细解析一下：
- en: '![Figure 6.2 – Understanding the format](img/file44.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 理解格式](img/file44.jpg)'
- en: Figure 6.2 – Understanding the format
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 理解格式
- en: '`%d` indicates that the first value is a zero-padded digit representing the
    day of the month, followed by a space to display spacing between the digit and
    the next object.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%d` 表示第一个值是一个零填充的数字，表示月份中的日期，后面跟一个空格，用于显示数字与下一个对象之间的间隔。'
- en: '`%B` is used to indicate that the second value represents the month''s full
    name. Note that this was followed by a comma (`,`) to describe the exact format
    in the string, for example `"January,"`. Therefore, it is crucial to match the
    format in the strings you are parsing to include any commas, hyphens, backslashes,
    spaces, or whichever separator characters are used.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%B` 用于表示第二个值代表月份的完整名称。请注意，这后面跟着逗号（`,`），用于描述字符串中准确的格式，例如 `"January,"`。因此，在解析字符串时，匹配格式至关重要，必须包含任何逗号、破折号、反斜杠、空格或使用的任何分隔符。'
- en: To adhere to the string format, there is a space after the comma (`,`), followed
    by `%Y` to reflect the last value represents a four-digit year.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了遵循字符串格式，逗号（`,`）后面有一个空格，接着是`%Y`，表示最后一个值代表四位数的年份。
- en: FORMAT DIRECTIVES
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 格式指令
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Remember that you always use the percent sign (`%`) followed by the format
    code (a letter with or without a negative sign). This is called a formatting directive.
    For example, lower case `y`, as in `%y`, represents the year `22` without the
    century, while uppercase `y`, as in `%Y`, represents the year `2022` with the
    century. Here is a list of common Python directives that can be used in the `strptime()`
    function[: https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes).'
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记住，你总是使用百分号（`%`）后跟格式代码（一个字母，可能带有负号）。这称为格式化指令。例如，小写的`y`，如`%y`，表示年份`22`（没有世纪），而大写的`Y`，如`%Y`，表示年份`2022`（包含世纪）。以下是可以在`strptime()`函数中使用的常见Python指令列表：[https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes)。
- en: Recall that you used `pandas.to_datetime()` to parse the same string objects
    as with `dt.datetime.strptime()`. The biggest difference is that the pandas function
    can accurately parse the strings without explicitly providing an argument to the
    format parameter. That is one of many advantages of using pandas for time-series
    analysis, especially when handling complex date and `datetime` scenarios.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，你使用了`pandas.to_datetime()`来解析与`dt.datetime.strptime()`相同的字符串对象。最大不同之处在于，pandas函数能够准确地解析字符串，而无需显式提供格式参数。这是使用pandas进行时间序列分析的诸多优势之一，尤其是在处理复杂日期和`datetime`场景时。
- en: There's more…
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: Now you know how to use `pandas.to_datetime()` to parse string objects to `datetime`.
    So, let's see how you can apply this knowledge to transform a DataFrame column
    that contains date information in string format to a `datetime` data type.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何使用`pandas.to_datetime()`将字符串对象解析为`datetime`。那么，让我们看看如何将包含日期信息的字符串格式的DataFrame列转换为`datetime`数据类型。
- en: 'In the following code, you will create a small DataFrame:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，你将创建一个小的DataFrame：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To update the DataFrame to include a DatetimeIndex, you will parse the `Date`
    column to `datetime` and then assign it as an index to the DataFrame:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新DataFrame以包含DatetimeIndex，你需要将`Date`列解析为`datetime`，然后将其作为索引分配给DataFrame：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note how the index is now of the `DatetimeIndex` type, and there is only one
    column in the DataFrame (`Sales`), since `Date` is now an index.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在索引是`DatetimeIndex`类型，并且DataFrame中只有一列（`Sales`），因为`Date`现在是索引。
- en: See also
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另请参见
- en: To learn more about `pandas.to_datetime`, please visit the official documentation
    page here:[https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html](https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`pandas.to_datetime`的信息，请访问官方文档页面：[https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html](https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html)。
- en: Working with Unix epoch timestamps
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Unix纪元时间戳
- en: '**Epoch timestamps**, sometimes referred to as **Unix time** or **POSIX time**,
    are a common way to store `datetime` in an **integer** **format**. This integer
    represents the number of seconds elapsed from a reference point, and in the case
    of a Unix-based timestamp, the reference point is **January 1, 1970**, at midnight
    (**00:00:00 UTC**). This arbitrary date and time represent the baseline, starting
    at `0`. So, we just increment in seconds for every second beyond that time.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**纪元时间戳**，有时称为**Unix时间**或**POSIX时间**，是一种常见的以**整数**格式存储`datetime`的方式。这个整数表示自参考点以来经过的秒数，对于基于Unix的时间戳，参考点是**1970年1月1日**午夜（**00:00:00
    UTC**）。这个任意的日期和时间代表了基准，从`0`开始。所以，我们每经过一秒钟就增加1秒。'
- en: Many databases, applications, and systems store dates and times in numeric format,
    making it mathematically easier to work with, convert, increment, decrement, and
    so on. Note that in the case of the **Unix epoch**, it is based on **UTC**, which
    stands for **Universal Time Coordinated**. Using UTC is a clear choice when building
    applications used globally, making it easier to store dates and timestamps in
    a standardized format. This makes it easier to work with dates and times without
    worrying about daylight saving or different time zones around the globe. UTC is
    the standard international time used in aviation systems, weather forecast systems,
    the International Space Station, and so on.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据库、应用程序和系统将日期和时间存储为数字格式，这样在数学上更容易处理、转换、递增、递减等。请注意，在 **Unix 纪元** 的情况下，它是基于
    **UTC**（协调世界时），UTC 代表 **Universal Time Coordinated**。使用 UTC 是构建全球应用程序时的明确选择，它使得存储日期和时间戳以标准化格式变得更加简单。这也使得在处理日期和时间时，无需担心夏令时或全球各地的时区问题。UTC
    是航空系统、天气预报系统、国际空间站等使用的标准国际时间。
- en: You will, at some point, encounter Unix epoch timestamps, and to make more sense
    of the data, you will need to convert it to a human-readable format. This is what
    will be covered in this recipe. Again, you will explore the ease of using pandas'
    built-in functions to work with Unix epoch timestamps.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你在某个时刻会遇到 Unix 纪元时间戳，想要更好地理解数据，你需要将其转换为人类可读格式。这就是本节要介绍的内容。再次提醒，你将体验使用 pandas
    内置函数处理 Unix 纪元时间戳的简便性。
- en: How to do it…
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Before we start converting the Unix time to a human-readable `datetime` object,
    which is the easy part, let''s first gain some intuition about the idea of storing
    dates and time as a numeric object (a floating-point number):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始将 Unix 时间转换为可读的 `datetime` 对象（这部分比较简单）之前，首先让我们对将日期和时间存储为数字对象（浮点数）这一概念有一些直观的理解：
- en: 'You will use time from the `time` module (part of Python) to request the current
    time in seconds. This will be the time in seconds since the epoch, which for Unix
    systems starts from January 1, 1970, at 00:00:00 UTC:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将使用 `time` 模块（Python 的一部分）来请求当前的秒级时间。这将是从纪元开始以来的秒数，对于 Unix 系统来说，纪元从 1970 年
    1 月 1 日 00:00:00 UTC 开始：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, copy the numeric value you have and visit [https://www.epoch101.com](https://www.epoch101.com).
    The website should display your current epoch time. If you scroll down, you can
    paste the number and convert it to a human-readable format. Make sure that you
    click on **seconds**, as shown in the following figure:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，复制你得到的数字值并访问 [https://www.epoch101.com](https://www.epoch101.com)。该网站应该会显示你当前的纪元时间。如果你向下滚动，可以粘贴该数字并将其转换为人类可读格式。确保点击
    **秒**，如图所示：
- en: '![Figure 6.3: Converting a Unix timestamp to a human-readable format in both
    GMT and local time](img/file45.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3：将 Unix 时间戳转换为 GMT 和本地时间的可读格式](img/file45.png)'
- en: 'Figure 6.3: Converting a Unix timestamp to a human-readable format in both
    GMT and local time'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：将 Unix 时间戳转换为 GMT 和本地时间的可读格式
- en: Note, the GMT format was given as `Tue, 21 Nov 2023 20:02:22 GMT` and my local
    format as `Wed Nov 22 2023, 00:02:22 GMT+0400 (Gulf Standard Time)`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，GMT 格式是 `Tue, 21 Nov 2023 20:02:22 GMT`，而我的本地格式是 `Wed Nov 22 2023, 00:02:22
    GMT+0400 (海湾标准时间)`。
- en: 'Let''s see how pandas converts the epoch timestamp. The convenience here is
    that you will be using the same `pandas.to_datetime()` function that you should
    be familiar with by now, as you have used it in the previous two recipes from
    this chapter. This is one of the many conveniences you get when using pandas.
    For example, in the following code, you will use `pandas.to_datetime()` to parse
    the Unix epoch `1700596942.589581`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看 pandas 如何转换纪元时间戳。这里的便利之处在于，你将使用你现在应该已经熟悉的相同的 `pandas.to_datetime()` 函数，因为你在本章的前两部分中已经用过它。这就是使用
    pandas 的众多便利之一。例如，在以下代码中，你将使用 `pandas.to_datetime()` 来解析 Unix 纪元时间 `1700596942.589581`：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note the need to specify units as seconds. The output is similar to that in
    *Figure 6.3* for the GMT format.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意需要将单位指定为秒。输出与 *图 6.3* 中的 GMT 格式相似。
- en: 'If you want `datetime` to be time-zone aware – for example, the US/Pacific
    time zone – you can use `tz_localize(''US/Pacific'')`. To get a more accurate
    conversion though, it is better to do it in two steps:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望 `datetime` 具有时区感知功能——例如，美国/太平洋时区——可以使用 `tz_localize('US/Pacific')`。不过，为了获得更精确的转换，最好分两步进行：
- en: Convert the time zone-naive object to UTC using `tz_localize('UTC')`.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `tz_localize('UTC')` 将时区不敏感的对象转换为 UTC。
- en: Then, convert it to the desired time zone using `tz_convert()`.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `tz_convert()` 将其转换为所需的时区。
- en: 'The following code shows how this is done to convert to the Pacific time zone:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何将时间转换为太平洋时区：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s put all of this together. You will convert a DataFrame that contains
    a `datetime` column in Unix epoch format to a human-readable format. You will
    start by creating a new DataFrame with Unix epoch timestamps:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把这些内容整合在一起。你将把包含`datetime`列（以 Unix 纪元格式表示）的 DataFrame 转换为人类可读的格式。你将通过创建一个包含
    Unix 纪元时间戳的新 DataFrame 开始：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a new column, call it `Date` by parsing the `unix_epoch` column into
    a `datetime` (which defaults to GMT), then localize the output to UTC, and convert
    to a local time zone. Finally, set the `Date` column as the index:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新列，命名为`Date`，通过将`unix_epoch`列解析为`datetime`（默认为 GMT），然后将输出本地化为 UTC，并转换为本地时区。最后，将`Date`列设为索引：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that since the `Date` column was of the `datetime` type (not `DatetimeIndex`),
    you had to use the `Series.dt` accessor to tap into the built-in methods and attributes
    for the `datetime` objects. In the last step, you converted `datetime` to a `DatetimeIndex`
    object (a DataFrame index). If you recall from the *Working with DatetimeIndex*
    recipe of this chapter, a `DatetimeIndex` object can access any of the `datetime`
    methods and attributes without using the `dt` accessor.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`Date`列是`datetime`类型（而不是`DatetimeIndex`），你必须使用`Series.dt`访问器来访问内建的方法和属性。最后一步，你将`datetime`转换为`DatetimeIndex`对象（即
    DataFrame 索引）。如果你还记得本章中的*操作 DatetimeIndex*示例，`DatetimeIndex`对象可以访问所有`datetime`方法和属性，而无需使用`dt`访问器。
- en: 'If you do not need the time in your index (`DatetimeIndex`), given your data
    is daily and there is no use case for using time, then you can request just the
    date, as shown in the following code:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的数据是按天分布的，并且没有使用时间的需求，那么你可以仅请求日期，如以下代码所示：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that the output displays the date without time.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出只显示日期，不包括时间。
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Understanding Unix Epoch time is more relevant as one engages in technical fields
    where precise and standardized time representation is critical.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Unix 纪元时间在从事需要精确和标准化时间表示的技术领域时尤为重要。
- en: So far, you have used `pandas.to_datetime()` to parse dates in string format
    to a `datetime` object by leveraging the format attribute (see the *Providing
    a format argument to DateTime* recipe). In this recipe, you used the same function,
    but instead of providing a value to format, you passed a value to the unit parameter,
    as in `unit='s'` .
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你使用了`pandas.to_datetime()`将字符串格式的日期解析为`datetime`对象，并通过利用格式属性（请参阅*提供格式参数给
    DateTime*的示例）。在本例中，你使用了相同的函数，但这次没有提供格式值，而是传递了一个值给`unit`参数，如`unit='s'`。
- en: The `unit` parameter tells pandas which unit to use when calculating the difference
    from the epoch start. In this case, the request was in seconds. However, there
    is another critical parameter that you do not need to adjust (in most cases),
    which is the `origin` parameter. For example, the default value is `origin='unix'`,
    which indicates that the calculation should be based on the Unix (or POSIX) time
    set to `01-01-1970 00:00:00 UTC`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`unit`参数告诉 pandas 在计算与纪元起始的差异时使用哪种单位。在此示例中，请求的是秒。然而，还有一个重要的参数你通常不需要调整，即`origin`参数。例如，默认值为`origin=''unix''`，表示计算应基于
    Unix（或 POSIX）时间，起始时间为`1970-01-01 00:00:00 UTC`。'
- en: 'This is what the actual code looks like:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实际代码的样子：
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can modify the `origin` to use a different reference date to calculate
    the datetime value. In the following example, the `unit` is specified to be in
    days and the origin is set at `January 1, 2023`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改`origin`，使用不同的参考日期来计算日期时间值。在以下示例中，`unit` 被指定为天，`origin` 设置为`2023年1月1日`：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There's more…
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: If you would like to store your `datetime` value in Unix epoch, you can do this
    by subtracting `1970-01-01` and then floor-divide by a unit of `1` second. Python
    uses `/` as the division operator, `//` as the floor division operator to return
    the floored quotient, and `%` as the modulus operator to return the remainder
    from a division.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将`datetime`值存储为 Unix 纪元时间，可以通过减去`1970-01-01`，然后用`1`秒进行整除来实现。Python 使用`/`作为除法运算符，`//`作为整除运算符返回整除结果，`%`作为取余运算符返回除法的余数。
- en: 'Start by creating a new pandas DataFrame:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从创建一个新的 pandas DataFrame 开始：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can then perform the transformation, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按如下方式进行转换：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You have now generated your Unix epochs. There are different ways to achieve
    similar results. The preceding example is the recommended approach from pandas,
    which you can read more about here: [https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#from-timestamps-to-epoch.](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#from-timestamps-to-epoch.)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经生成了 Unix 时间戳。实现相似结果有多种方法。上述示例是 pandas 推荐的方法，详情请参阅此链接：[https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#from-timestamps-to-epoch](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#from-timestamps-to-epoch)。
- en: You will learn more about `Timedelta` [in the next recipe.](ch007.xhtml)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[下一个食谱中](ch007.xhtml)学到更多关于`Timedelta`的知识。
- en: See also
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'To learn more about `pandas.to_datetime`, please visit the official documentation
    page here: [https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html](https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`pandas.to_datetime`的信息，请访问官方文档页面：[https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html](https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html)。
- en: Working with time deltas
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用时间差进行操作
- en: When working with time-series data, you may need to perform some calculations
    on your `datetime` columns, such as adding or subtracting. Examples can include
    adding 30 days to purchase `datetime` to determine when the return policy expires
    for a product or when a warranty ends. For example, the `Timedelta` class makes
    it possible to derive new `datetime` objects by adding or subtracting at different
    ranges or increments, such as seconds, daily, and weekly. This includes time zone-aware
    calculations.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理时间序列数据时，你可能需要对`datetime`列进行一些计算，比如加减操作。例子包括将30天加到购买`datetime`上，以确定产品的退货政策何时到期或保修何时结束。例如，`Timedelta`类使得通过在不同的时间范围或增量（如秒、天、周等）上加减时间，得出新的`datetime`对象成为可能。这包括时区感知的计算。
- en: In this recipe, you will explore two practical approaches in pandas to capture
    date/time differences – the `pandas.Timedelta` class and the `pandas.to_timedelta`
    function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将探索 pandas 中两种捕获日期/时间差异的实用方法——`pandas.Timedelta` 类和 `pandas.to_timedelta`
    函数。
- en: How to do it…
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'In this recipe, you will work with hypothetical sales data for a retail store.
    You will generate the sales DataFrame, which will contain items purchased from
    the store and the purchase date. You will then explore different scenarios using
    the `Timedelta` class and the `to_timedelta()` function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将使用假设的零售商店销售数据。你将生成一个销售数据框，其中包含商店购买的商品及其购买日期。然后，你将使用`Timedelta`类和`to_timedelta()`函数探索不同的场景：
- en: 'Start by importing the `pandas` library and creating a DataFrame with two columns,
    `item` and `purchase_dt`, which will be standardized to UTC:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入`pandas`库并创建一个包含两列（`item` 和 `purchase_dt`）的数据框，这些列会标准化为UTC时间：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding code should output a DataFrame with six rows (`items`) and two
    columns (`item` and `purchase_dt`):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应输出一个包含六行（`items`）和两列（`item` 和 `purchase_dt`）的数据框：
- en: '![Figure 6.4: The DataFrame with the item purchased and purchase datetime (UTC)
    data](img/file46.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4：包含购买商品和购买日期时间（UTC）数据的数据框](img/file46.jpg)'
- en: 'Figure 6.4: The DataFrame with the item purchased and purchase datetime (UTC)
    data'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：包含购买商品和购买日期时间（UTC）数据的数据框
- en: 'Add another `datetime` column to represent the expiration date, which is 30
    days from the purchase date:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个`datetime`列，用于表示过期日期，设为购买日期后的30天：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding code should add a third column (`expiration_dt`) to the DataFrame,
    which is set at 30 days from the date of purchase:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应向数据框中添加一个第三列（`expiration_dt`），该列设置为购买日期后的30天：
- en: '![Figure 6.5: The updated DataFrame with a third column reflecting the expiration
    date](img/file47.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5：更新后的数据框，增加了一个反映过期日期的第三列](img/file47.jpg)'
- en: 'Figure 6.5: The updated DataFrame with a third column reflecting the expiration
    date'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：更新后的数据框，增加了一个反映过期日期的第三列
- en: 'Now, assume you are asked to create a special extended date for return, and
    this one is set at 35 days, 12 hours, and 30 minutes from the purchase date:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，假设你需要创建一个特殊的退货延长期，这个时间设置为从购买日期起35天、12小时和30分钟：
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding code should add a fourth column (`extended_dt`) to the DataFrame,
    reflecting the new datetime, based on the additional 35 days, 12 hours, and 30
    minutes:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应向数据框中添加一个第四列（`extended_dt`），根据额外的35天、12小时和30分钟，反映新的日期时间：
- en: '![Figure 6.6: The updated DataFrame with a fourth datetime column reflecting
    the extended date](img/file48.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6：更新后的 DataFrame，新增第四列日期时间列，反映扩展后的日期](img/file48.jpg)'
- en: 'Figure 6.6: The updated DataFrame with a fourth datetime column reflecting
    the extended date'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：更新后的 DataFrame，新增第四列日期时间列，反映扩展后的日期
- en: 'Assume that you are asked to convert the time zone from UTC to the local time
    zone of the retailer store''s headquarters, which is set in Los Angeles:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你被要求将时区从 UTC 转换为零售商店总部所在时区，也就是洛杉矶时区：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After converting from UTC to the US/Pacific time zone (Los Angeles), you are
    overwriting the `datetime` columns (`purchased_dt`, `expiration_dt`, and `extended_dt`).
    The DataFrame structure should remain the same – six rows and four columns – but
    now the data looks different, as shown in the following screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在将时区从 UTC 转换为美国/太平洋时区（洛杉矶）后，你将会覆盖`datetime`列（`purchased_dt`、`expiration_dt`和`extended_dt`）。DataFrame
    的结构应该保持不变——六行四列——但数据现在看起来有所不同，如下图所示：
- en: '![Figure 6.7: The updated DataFrame where all datetime columns are in Los Angeles
    (US/Pacific)](img/file49.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7：更新后的 DataFrame，所有日期时间列都显示洛杉矶（美国/太平洋时区）时间](img/file49.jpg)'
- en: 'Figure 6.7: The updated DataFrame where all datetime columns are in Los Angeles
    (US/Pacific)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：更新后的 DataFrame，所有日期时间列都显示洛杉矶（美国/太平洋时区）时间
- en: 'Finally, you can calculate the delta between the extended and original expiration
    dates. Since they are both `datetime` data types, you can achieve this with a
    simple subtraction between the two columns:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以计算扩展后的到期日期与原始到期日期之间的差异。由于它们都是`datetime`数据类型，你可以通过简单的两个列之间的减法来实现这一点：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Your final DataFrame should now have a fifth column that captures the difference
    between the extended date and the expiration date:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 DataFrame 应该会有一个第五列，表示扩展日期与到期日期之间的差异：
- en: '![Figure 6.8: The updated DataFrame with a fifth column](img/file50.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8：更新后的 DataFrame，新增第五列](img/file50.jpg)'
- en: 'Figure 6.8: The updated DataFrame with a fifth column'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：更新后的 DataFrame，新增第五列
- en: These types of transformations and calculations are simplified without needing
    any additional libraries, thanks to pandas' built-in capabilities to work with
    time-series data and `datetime` overall.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 pandas 内置了处理时间序列数据和`datetime`的功能，这些类型的转换和计算变得更加简化，无需任何额外的库。
- en: How it works…
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Time deltas can be handy for capturing the difference between two date or time
    objects. In pandas, the `pandas.Timedelta` class is equivalent to Python''s `datetime.timedelta`
    class and behaves very similarly. However, the advantage of pandas is that it
    includes a wide range of classes and functions for working with time-series data.
    These built-in functions within pandas, in general, are simpler and more efficient
    when working with DataFrames. Let''s try this quick experiment to demonstrate
    how pandas'' `Timedelta` class is a subclass of Python''s `timedelta` class:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 时间差可以帮助捕捉两个日期或时间对象之间的差异。在 pandas 中，`pandas.Timedelta`类等同于 Python 的`datetime.timedelta`类，行为非常相似。然而，pandas
    的优势在于它包含了大量用于处理时间序列数据的类和函数。这些内置的 pandas 函数在处理 DataFrame 时通常更简洁、高效。让我们做个简短实验，展示
    pandas 的`Timedelta`类是 Python `timedelta`类的子类：
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s validate that `pandas.Timedelta` is an instance of `datetime.timedelta`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下`pandas.Timedelta`是否是`datetime.timedelta`的一个实例：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Python''s `datetime.timedelta` class accepts integer values for these parameters
    – `days`, `seconds`, `microseconds`, `milliseconds`, `minutes`, `hours`, and `weeks`.
    On the other hand, `pandas.Timedelta` takes both integers and strings, as demonstrated
    in the following snippet:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的`datetime.timedelta`类接受这些参数的整数值——`days`、`seconds`、`microseconds`、`milliseconds`、`minutes`、`hours`
    和 `weeks`。另一方面，`pandas.Timedelta`接受整数和字符串，如下代码所示：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once you have defined your `Timedelta` object, you can use it to make calculations
    on `date`, `time`, or `datetime` objects:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了`Timedelta`对象，就可以将其用于对`date`、`time`或`datetime`对象进行计算：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the preceding example, `week_td` represents a 1-week `Timedelta` object,
    which can be added (or subtracted) from `datetime` to get the difference. By adding
    `week_td`, you are incrementing by 1 week. What if you want to add 2 weeks? You
    can use multiplication as well:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`week_td`表示一个1周的`Timedelta`对象，可以将其加到（或减去）`datetime`中，得到时间差。通过添加`week_td`，你增加了1周。如果你想增加2周呢？你也可以使用乘法：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There's more…
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Using `pd.Timedelta` is straightforward and makes working with large time-series
    DataFrames efficient without importing additional libraries, as it is built into
    pandas.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pd.Timedelta`非常简单，并且使得处理大规模时间序列DataFrame变得高效，无需导入额外的库，因为它已内置于pandas中。
- en: In the previous *How to do it...* section, you created a DataFrame and added
    additional columns based on the `timedelta` calculations. You can also add the
    `timedelta` object into a DataFrame and reference it by its column. Finally, let's
    see how this works.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的*如何实现...*部分，你创建了一个DataFrame，并基于`timedelta`计算添加了额外的列。你也可以将`timedelta`对象添加到DataFrame中，并通过它的列进行引用。最后，让我们看看它是如何工作的。
- en: 'First, let''s construct the same DataFrame used earlier:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们构建与之前相同的DataFrame：
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This should produce a DataFrame shown in *Figure 6.4*. Now, you will add a
    new column that contains the `Timedelta` object (1 week) and then use that column
    to add and subtract from the `purchased_dt` column:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个如*图6.4*所示的DataFrame。现在，你将添加一个包含`Timedelta`对象（1周）的新列，然后使用该列对`purchased_dt`列进行加减操作：
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The preceding code should produce a DataFrame with three additional columns.
    The `1 week` column holds the `Timedelta`, object and because of that, you can
    reference the column to calculate any time differences you need:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应该会生成一个带有三个额外列的DataFrame。`1 week`列包含`Timedelta`对象，因此，你可以引用该列来计算所需的任何时间差：
- en: '![Figure 6.9: The updated DataFrame with three additional columns](img/file51.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9：更新后的DataFrame，新增三个列](img/file51.jpg)'
- en: 'Figure 6.9: The updated DataFrame with three additional columns'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：更新后的DataFrame，新增三个列
- en: 'Let''s check the data types for each column in the DataFrame:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查DataFrame中每一列的数据类型：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that the `1 week` column is a particular data type, `timedelta64` (our
    `Timedelta` object), which allows you to make arithmetic operations on the `date`,
    `time`, and `datetime` columns in your DataFrame.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`1 week`列是一个特定的数据类型，`timedelta64`（我们的`Timedelta`对象），它允许你对DataFrame中的`date`、`time`和`datetime`列进行算术运算。
- en: In the *Working with DatetimeIndex* recipe, you explored the `pandas.date_range()`
    function to generate a DataFrame with `DatetimeIndex`. The function returns a
    range of equally spaced time points based on the start, end, period and frequency
    parameters.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在*与DatetimeIndex一起工作*的食谱中，你探讨了`pandas.date_range()`函数来生成一个带有`DatetimeIndex`的DataFrame。该函数基于开始时间、结束时间、周期和频率参数，返回一系列等间隔的时间点。
- en: 'Similarly, you have an option to generate `TimdedeltaIndex` with a fixed frequency
    using the `pandas.timedelta_range()` function, which takes similar parameters
    as the `pandas.date_range()` function. Here is a quick example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以使用`pandas.timedelta_range()`函数生成具有固定频率的`TimedeltaIndex`，它与`pandas.date_range()`函数的参数相似。下面是一个快速示例：
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output is as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 6.10: A DataFrame with a Timedelta column](img/file52.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10：包含Timedelta列的DataFrame](img/file52.jpg)'
- en: 'Figure 6.10: A DataFrame with a Timedelta column'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：包含Timedelta列的DataFrame
- en: See also
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另见
- en: 'To learn more about the `pandas.timedelta_range()` function, please refer to
    the official documentation here: [https://pandas.pydata.org/docs/reference/api/pandas.timedelta_range.html](https://pandas.pydata.org/docs/reference/api/pandas.timedelta_range.html).'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要了解更多关于`pandas.timedelta_range()`函数的信息，请参考官方文档：[https://pandas.pydata.org/docs/reference/api/pandas.timedelta_range.html](https://pandas.pydata.org/docs/reference/api/pandas.timedelta_range.html)。
- en: 'To learn more about the `pandas.Timedelta` class, please visit the official
    documentation here: [https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html](https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html).'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要了解更多关于`pandas.Timedelta`类的信息，请访问官方文档：[https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html](https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html)。
- en: Converting DateTime with time zone information
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换带有时区信息的DateTime
- en: When working with time-series data that requires attention to different time
    zones, things can get out of hand and become more complicated. For example, when
    developing data pipelines, building a data warehouse, or integrating data between
    systems, dealing with time zones requires attention and consensus amongst the
    different stakeholders in the project. For example, in Python, there are several
    libraries and modules dedicated to working with time zone conversion; these include
    `pytz`, `dateutil`, and `zoneinfo`, to name a few.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理需要关注不同时区的时间序列数据时，事情可能会变得不可控且复杂。例如，在开发数据管道、构建数据仓库或在系统之间集成数据时，处理时区需要在项目的各个利益相关者之间达成一致并引起足够的重视。例如，在
    Python 中，有几个专门用于处理时区转换的库和模块，包括 `pytz`、`dateutil` 和 `zoneinfo` 等。
- en: Let's discuss an inspiring example regarding time zones within time-series data.
    It is common for large companies that span their products and services across
    continents to include data from different places around the globe. For example,
    it would be hard to make data-driven business decisions if we neglect time zones.
    Let's say you want to determine whether most customers come to your e-commerce
    site in the morning or evening, and whether shoppers browse during the day and
    then make a purchase in the evening after work. For this analysis, you need to
    be aware of time zone differences and their interpretation on an international
    scale.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来讨论一个关于时区和时间序列数据的启发性示例。对于跨越多个大陆的大型公司来说，包含来自全球不同地方的数据是很常见的。如果忽略时区，将很难做出基于数据的商业决策。例如，假设你想确定大多数客户是早上还是晚上访问你的电子商务网站，或者是否顾客在白天浏览，晚上下班后再进行购买。为了进行这个分析，你需要意识到时区差异以及它们在国际范围内的解读。
- en: How to do it…
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, you will work with a hypothetical scenario – a small dataset
    that you will generate to represent website visits at different time intervals
    from various locations worldwide. The data will be standardized to UTC, and you
    will work with time-zone conversions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将处理一个假设场景——一个小型数据集，代表从全球各地不同时间间隔访问网站的数据。数据将被标准化为 UTC，并且你将处理时区转换。
- en: 'You will start by importing the `pandas` library and creating the time-series
    DataFrame:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将首先导入 `pandas` 库并创建时间序列 DataFrame：
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This will produce a DataFrame where `visit_dt` is the index of the `DatetimeIndex`
    type and two columns, `Location` and `tz`, indicate the time zone:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个 DataFrame，其中 `visit_dt` 是 `DatetimeIndex` 类型的索引，两个列 `Location` 和 `tz`
    表示时区：
- en: '![Figure 6.11: The DataFrame with visit_dt in UTC as an index](img/file53.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11：以 UTC 时间为索引的 DataFrame](img/file53.png)'
- en: 'Figure 6.11: The DataFrame with visit_dt in UTC as an index'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11：以 UTC 时间为索引的 DataFrame
- en: 'Assume that you need to convert this DataFrame to be in the same time zone
    as the company''s headquarters in Tokyo. You can do this easily using `DataFrame.tz_convert()`
    against the DataFrame, but you will get a `TypeError` exception if you do this.
    That is because your time-series DataFrame is not time zone-aware. So, you need
    to localize it first using `tz_localize()` to make it time-zone aware. In this
    case, you will localize it to UTC:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你需要将这个 DataFrame 转换为与公司总部东京所在的时区相同。你可以通过对 DataFrame 使用 `DataFrame.tz_convert()`
    来轻松完成，但如果这样做，你将遇到 `TypeError` 异常。这是因为你的时间序列 DataFrame 并不具有时区感知能力。所以，你需要先使用 `tz_localize()`
    将其本地化，才能使其具备时区感知能力。在这种情况下，你将其本地化为 UTC：
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You will now convert the DataFrame to the headquarters'' time zone (`Tokyo`):'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你将把 DataFrame 转换为总部所在的时区（`东京`）：
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The DataFrame index, `visit_dt`, will be converted to the new time zone:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 索引 `visit_dt` 将转换为新的时区：
- en: '![Figure 6.12: The DataFrame index converted to the headquarters'' time zone
    (Tokyo)](img/file54.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12：DataFrame 索引转换为总部所在时区（东京）](img/file54.png)'
- en: 'Figure 6.12: The DataFrame index converted to the headquarters'' time zone
    (Tokyo)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12：DataFrame 索引转换为总部所在时区（东京）
- en: 'Note that you were able to access the `tz_localize()` and `tz_convert()` methods
    because the DataFrame had an index of type `DatetimeIndex`. If that was not the
    case, you would get a `TypeError` exception with the following message:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你能够访问 `tz_localize()` 和 `tz_convert()` 方法，因为 DataFrame 的索引类型是 `DatetimeIndex`。如果不是这种情况，你将会遇到
    `TypeError` 异常，错误信息如下：
- en: '[PRE59]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, you will localize each row to the appropriate time zone. You will add
    a new column reflecting the time zone, based on the location of the user that
    accessed the website. You will leverage the `tz` column to accomplish this:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你将把每一行本地化到适当的时区。你将添加一个新列，反映基于访问网站用户位置的时区。你将利用`tz`列来完成这个操作：
- en: '[PRE60]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This should produce a new column, `local_dt`, which is based on the UTC datetime
    from `visit_dt` and converted based on the time zone provided in the `tz` column:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个新的列`local_dt`，该列基于`visit_dt`中的UTC时间，并根据`tz`列中提供的时区进行转换：
- en: '![Figure 6.13: The updated DataFrame with local_dt based on a localized time
    zone for each visit](img/file55.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图6.13：更新后的DataFrame，`local_dt`基于每次访问的本地时区](img/file55.png)'
- en: 'Figure 6.13: The updated DataFrame with local_dt based on a localized time
    zone for each visit'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：更新后的DataFrame，`local_dt`基于每次访问的本地时区
- en: 'You may wonder, what if you did not have a `tz` column? Where would you find
    the right `tz` string? Well, these are called **Time Zone** (**TZ**) database
    names. These are standard names, and you can find a subset of these in the Python
    documentation, or for a more comprehensive list, you can visit this link: [https://en.wikipedia.org/wiki/List_of_tz_database_time_zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，如果没有`tz`列怎么办？在哪里可以找到正确的`tz`字符串？这些被称为**时区**（**TZ**）数据库名称。它们是标准名称，你可以在Python文档中找到这些名称的一个子集，或者你可以访问这个链接查看更多信息：[https://en.wikipedia.org/wiki/List_of_tz_database_time_zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)。
- en: How it works…
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Converting a time-series DataFrame from one time zone to another was achieved
    using `DataFrame.tz_convert()`, providing it with a time-zone string argument
    such as `US/Pacific`. There are a few assumptions when using `DataFrame.tz_convert()`
    that you need to keep in mind:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 将时间序列的DataFrame从一个时区转换到另一个时区，可以使用`DataFrame.tz_convert()`方法，并提供像`US/Pacific`这样的时区字符串作为参数。在使用`DataFrame.tz_convert()`时，有几个假设需要记住：
- en: The DataFrame should have an index of the `DatetimeIndex` type.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataFrame应该具有`DatetimeIndex`类型的索引。
- en: '`DatetimeIndex` needs to be time zone-aware.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatetimeIndex`需要具备时区感知功能。'
- en: You used the `DataFrame.tz_localize()` function to make the index time zone
    aware. It is a good practice to standardize on *UTC* if you are dealing with different
    time zones and daylight saving, since UTC is always consistent and never changes
    (regardless of where you are or if daylight saving time is applied or not). Once
    in UTC, converting to other time zones is very straightforward.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了`DataFrame.tz_localize()`函数来使索引具备时区感知功能。如果你在处理不同的时区和夏令时，建议标准化为*UTC*，因为UTC始终一致且不变（无论你身在何处，或者是否应用了夏令时）。一旦使用UTC，转换到其他时区非常简单。
- en: 'We first localized the data in the previous steps and then converted it to
    a different time zone in two steps. You can also do this in one step by chaining
    the two methods, as shown in the following code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在前面的步骤中将数据本地化为UTC时间，然后分两步将其转换为不同的时区。你也可以通过链式调用这两个方法一步完成，如以下代码所示：
- en: '[PRE61]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If your index is already time zone-aware, then using `tz_localize()` will produce
    a `TypeError` exception with the following message:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的索引已经具备时区感知功能，那么使用`tz_localize()`将会引发`TypeError`异常，并显示以下信息：
- en: '[PRE62]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This indicates that you do not need to localize it again. Instead, just convert
    it to another time zone.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示你不需要再次本地化它。相反，只需将其转换为另一个时区即可。
- en: There's more…
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Looking at the DataFrame in *Figure 6.12*, it is hard to tell immediately whether
    the time was in the morning (AM) or evening (PM). You can format `datetime` using
    `strftime` (which we discussed in the *Providing a format argument to DateTime*
    recipe).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 看着*图6.12*中的DataFrame，很难立刻判断时间是上午（AM）还是下午（PM）。你可以使用`strftime`格式化`datetime`（我们在*提供格式参数给DateTime*的例子中讨论过）。
- en: 'You will construct the same DataFrame, localize it to UTC, then convert it
    to the headquarters'' time zone, and apply the new format:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你将构建相同的DataFrame，将其本地化为UTC时间，然后转换为总部所在的时区，并应用新的格式：
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We have combined the steps, and this should produce a DataFrame similar to the
    one in *Figure 6.12*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将这些步骤结合起来，生成的DataFrame应该类似于*图6.12*中的数据。
- en: 'Now, you can update the formatting to use the pattern – `YYYY-MM-DD HH:MM AM/PM`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以更新格式，使用`YYYY-MM-DD HH:MM AM/PM`的模式：
- en: '[PRE64]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The index will be updated from a format/layout perspective. However, it is
    still time zone-aware, based on Tokyo''s time zone, and the index is still `DatetimeIndex`.
    The only change is to the `datetime` layout:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 索引将从格式/布局的角度进行更新。然而，它仍然是基于东京时区的时区感知，并且索引仍然是`DatetimeIndex`。唯一的变化是`datetime`布局：
- en: '![Figure 6.14 – The updated DataFrame index, formatted based on the date format
    string provided](img/file56.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.14 – 更新后的 DataFrame 索引，基于提供的日期格式字符串进行格式化](img/file56.png)'
- en: Figure 6.14 – The updated DataFrame index, formatted based on the date format
    string provided
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 更新后的 DataFrame 索引，基于提供的日期格式字符串进行格式化
- en: I am sure you will agree that this is easier to present to users to determine
    whether the visit was AM or PM quickly.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你会同意，这样做能更轻松地向用户展示，快速确定访问是上午还是下午。
- en: See also
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另见
- en: To learn more about `tz_convert` you can read the official documentation at
    [https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.tz_convert.html
    and https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.tz_convert.html](https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.tz_convert.html).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `tz_convert` 的信息，你可以阅读官方文档 [https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.tz_convert.html
    和 https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.tz_convert.html](https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.tz_convert.html)。
- en: Working with date offsets
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理日期偏移
- en: When working with time series, it is critical that you learn more about the
    data you are working with and how it relates to the problem you are attempting
    to solve. For example, when working with manufacturing or sales data, you cannot
    assume that an organization's working day is Monday to Friday or whether it uses
    the standard calendar year or fiscal year. You should also consider understanding
    any holiday schedule, annual shutdowns, and other matters related to the business
    operation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理时间序列时，了解你所处理的数据以及它如何与正在解决的问题相关联至关重要。例如，在处理制造或销售数据时，你不能假设一个组织的工作日是周一到周五，或者它是否使用标准的日历年或财年。你还应该考虑了解任何假期安排、年度停产以及与业务运营相关的其他事项。
- en: This is where offsets can be handy. They can help transform your dates into
    something more meaningful and relatable to a business. They can also help correct
    data entries that may not be logical.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，偏移量就派上用场了。它们可以帮助将日期转换为对业务更有意义和更具相关性的内容。它们也可以帮助修正可能不合逻辑的数据条目。
- en: We will work through a hypothetical example in this recipe and see how to leverage
    pandas offsets.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个示例中通过一个假设的例子，展示如何利用 pandas 偏移量。
- en: How to do it…
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, you will generate a time-series DataFrame to represent some
    daily logs of production quantity. The company, a US-based firm, would like to
    analyze data to better understand production capacity for future forecasting:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，你将生成一个时间序列 DataFrame 来表示一些生产数量的每日日志。该公司是一家总部位于美国的公司，希望通过分析数据来更好地理解未来预测的生产能力：
- en: 'Start by importing the `pandas` library and then generate our DataFrame:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入 `pandas` 库，然后生成我们的 DataFrame：
- en: '[PRE65]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s add the name of the days:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加星期几的名称：
- en: '[PRE66]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: When working with any data, always understand the business context behind it.
    Without domain knowledge or business context, it would be difficult to determine
    whether a data point is acceptable or not. In this scenario, the company was described
    as a US-based firm, and thus, working days are Monday to Friday. If there is data
    on a Saturday or Sunday (the weekend), you should not make assumptions without
    validating with the business. You should confirm whether there was any exception
    made for production on those specific weekend dates. Also, realize that January
    1 was a holiday. After investigation, it was confirmed that production did occur
    due to an emergency exception. The business executives do not want to account
    for weekend or holiday work in the forecast. In other words, it was a one-time
    non-occurring event that they do not want to model or build a hypothesis on.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理任何数据时，始终理解其背后的业务背景。没有领域知识或业务背景，很难判断一个数据点是否可以接受。在这个情境中，公司被描述为一家总部位于美国的公司，因此，工作日是从周一到周五。如果有关于周六或周日（周末）的数据，未经与业务确认，不应该做任何假设。你应该确认是否在特定的周末日期有生产例外情况。此外，意识到
    1 月 1 日是节假日。经过调查，确认由于紧急例外，生产确实发生了。业务高层不希望在预测中考虑周末或节假日的工作。换句话说，这是一个一次性、未发生的事件，他们不希望以此为基础建立模型或假设。
- en: 'The firm asks you to push the weekend/holiday production numbers to the next
    business day instead. Here, you will use `pandas.offsets.BDay()`, which represents
    business days:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公司要求将周末/节假日的生产数据推迟到下一个工作日。在这里，您将使用 `pandas.offsets.BDay()`，它表示工作日：
- en: '[PRE67]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Because Saturday and Sunday were weekends, their production numbers were pushed
    to the next business day, Monday, January 4.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 由于周六和周日是周末，它们的生产数据被推迟到下一个工作日，即周一，1月4日。
- en: 'Let''s perform a summary aggregation that adds production numbers by business
    days to understand the impact of this change better:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们执行一个汇总聚合，按工作日添加生产数据，以更好地理解此更改的影响：
- en: '[PRE68]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now, Monday shows to be the most productive day for that week, given it was
    the first business day after the holiday and a long weekend.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，周一被显示为该周最具生产力的一天，因为它是节假日后的第一个工作日，并且是一个长周末之后的工作日。
- en: 'Finally, the business has made another request – they would like to track production
    monthly (`MonthEnd`) and quarterly (`QuarterEnd`). You can use `pandas.offsets`
    again to add two new columns:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，企业提出了另一个请求——他们希望按月（`MonthEnd`）和按季度（`QuarterEnd`）跟踪生产数据。您可以再次使用 `pandas.offsets`
    来添加两列新数据：
- en: '[PRE69]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, you have a DataFrame that should satisfy most of the reporting requirements
    of the business.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经有了一个 DataFrame，它应该能满足大多数企业的报告需求。
- en: How it works…
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Using date offsets made it possible to increment, decrement, and transform
    your dates to a new date range following specific rules. There are several offsets
    provided by pandas, each with its own rules, which can be applied to your dataset.
    Here is a list of the common offsets available in pandas:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日期偏移量使得根据特定规则增减日期或将日期转换为新的日期范围成为可能。pandas 提供了多种偏移量，每种偏移量都有其规则，可以应用到您的数据集上。以下是
    pandas 中常见的偏移量列表：
- en: '`BusinessDay` or `Bday`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BusinessDay` 或 `Bday`'
- en: '`MonthEnd`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MonthEnd`'
- en: '`BusinessMonthEnd` or `BmonthEnd`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BusinessMonthEnd` 或 `BmonthEnd`'
- en: '`CustomBusinessDay` or `Cday`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomBusinessDay` 或 `Cday`'
- en: '`QuarterEnd`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuarterEnd`'
- en: '`FY253Quarter`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FY253Quarter`'
- en: 'For a more comprehensive list and their descriptions, you can visit the documentation
    here: [https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects).'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看更全面的列表及其描述，请访问文档：[https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects)。
- en: 'Applying an offset in pandas is as simple as doing an addition or subtraction,
    as shown in the following example:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pandas 中应用偏移量与进行加法或减法一样简单，如以下示例所示：
- en: '[PRE70]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: There's more…
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Following our example, you may have noticed when using the `BusinessDay` (`BDay`)
    offset that it did not account for the New Year's Day holiday (January 1). So,
    what can be done to account for both the New Year's Day holiday and weekends?
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的示例，您可能已经注意到，在使用 `BusinessDay`（`BDay`）偏移量时，它并未考虑到新年假期（1月1日）。那么，如何既考虑到新年假期，又考虑到周末呢？
- en: To accomplish this, pandas provides two approaches to handle standard holidays.
    The first method is by defining a custom holiday. The second approach (when suitable)
    uses an existing holiday offset.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，pandas 提供了两种处理标准节假日的方法。第一种方法是定义自定义节假日。第二种方法（在适用时）使用现有的节假日偏移量。
- en: Let's start with an existing offset. For this example, dealing with New Year,
    you can use the `USFederalHolidayCalendar` class, which has standard holidays
    such as New Year, Christmas, and other holidays specific to the United States.
    So, let's see how this works.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从现有的偏移量开始。以新年为例，您可以使用 `USFederalHolidayCalendar` 类，它包含了标准节假日，如新年、圣诞节以及其他美国特定的节假日。接下来，我们来看看它是如何工作的。
- en: 'First, generate a new DataFrame and import the needed library and classes:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，生成一个新的 DataFrame，并导入所需的库和类：
- en: '[PRE71]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`USFederalHolidayCalendar` has some holiday rules that you can check using
    the following code:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`USFederalHolidayCalendar` 有一些假期规则，您可以使用以下代码检查：'
- en: '[PRE72]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To apply these rules, you will use the `CustomerBusinessDay` or `CDay` offset:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用这些规则，您将使用 `CustomerBusinessDay` 或 `CDay` 偏移量：
- en: '[PRE73]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output is as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 6.15 – The USFederalHolidays column added to the DataFrame, which
    recognizes New Year''s Day](img/file57.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15 – 添加到 DataFrame 中的 USFederalHolidays 列，识别新年假期](img/file57.jpg)'
- en: Figure 6.15 – The USFederalHolidays column added to the DataFrame, which recognizes
    New Year's Day
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 – 添加到 DataFrame 中的 USFederalHolidays 列，识别新年假期
- en: 'The custom holiday option will behave in the same way. You will need to import
    the `Holiday` class and the `nearest_workday` function. You will use the `Holiday`
    class to define your specific holidays. In this case, you will determine the New
    Year''s rule:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义假期选项将以相同的方式工作。你需要导入`Holiday`类和`nearest_workday`函数。你将使用`Holiday`类来定义你的具体假期。在本例中，你将确定新年规则：
- en: '[PRE74]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Similar to how you applied the `USFederalHolidayCalendar` class to the `CDay`
    offset, you will apply your new `newyears` object to `Cday`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于你如何将`USFederalHolidayCalendar`类应用于`CDay`偏移量，你将把你的新`newyears`对象应用于`Cday`：
- en: '[PRE75]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You will get the following output:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得以下输出：
- en: '![Figure 6.16 – The NewYearsHoliday column, added using a custom holiday offset](img/file58.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16 – 使用自定义假期偏移量添加的NewYearsHoliday列](img/file58.jpg)'
- en: Figure 6.16 – The NewYearsHoliday column, added using a custom holiday offset
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – 使用自定义假期偏移量添加的NewYearsHoliday列
- en: 'If you are curious about the `nearest_workday` function and how it was used
    in both the `USFederalHolidayCalendar` rules and your custom holiday, then the
    following code illustrates how it works:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对`nearest_workday`函数以及它如何在`USFederalHolidayCalendar`规则和你的自定义假期中被使用感到好奇，那么以下代码展示了它的工作原理：
- en: '[PRE76]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As illustrated, the function mainly determines whether the day is a weekday
    or not, and based on that, it will either use the day before (if it falls on a
    Saturday) or the day after (if it falls on a Sunday). There are other rules available
    as well as `nearest_workday`, including the following:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，函数主要判断一天是否为工作日，然后根据判断结果，它将使用前一天（如果是星期六）或后一天（如果是星期日）。`nearest_workday`还有其他可用规则，包括以下几种：
- en: '`Sunday_to_Monday`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sunday_to_Monday`'
- en: '`Next_Monday_or_Tuesday`'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Next_Monday_or_Tuesday`'
- en: '`Previous_Friday`'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Previous_Friday`'
- en: '`Next_monday`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Next_monday`'
- en: See also
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: For more insight regarding `pandas.tseries.holiday`, you can view the actual
    code, which highlights all the classes and functions and can serve as an excellent
    reference, at [https://github.com/pandas-dev/pandas/blob/master/pandas/tseries/holiday.py](https://github.com/pandas-dev/pandas/blob/master/pandas/tseries/holiday.py).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多有关`pandas.tseries.holiday`的详细信息，你可以查看实际的代码，它展示了所有的类和函数，可以作为一个很好的参考，访问[https://github.com/pandas-dev/pandas/blob/master/pandas/tseries/holiday.py](https://github.com/pandas-dev/pandas/blob/master/pandas/tseries/holiday.py)。
- en: Working with custom business days
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义工作日
- en: Companies have different working days worldwide, influenced by the region or
    territory they belong to. For example, when working with time-series data and
    depending on the analysis you need to make, knowing whether certain transactions
    fall on a workday or weekend can make a difference. For example, suppose you are
    doing anomaly detection, and you know that certain types of activities can only
    be done during working hours. In that case, any activities beyond these boundaries
    may trigger some further analysis.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 不同地区和领土的公司有不同的工作日。例如，在处理时间序列数据时，根据你需要进行的分析，了解某些交易是否发生在工作日或周末可能会产生差异。例如，假设你正在进行异常检测，并且你知道某些类型的活动只能在工作时间内进行。在这种情况下，任何超出这些时间范围的活动都可能触发进一步的分析。
- en: In this recipe, you will see how you can customize an offset to fit your requirements
    when doing an analysis that depends on defined business days and non-business
    days.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，你将看到如何定制一个偏移量以适应你的需求，特别是在进行依赖于已定义的工作日和非工作日的分析时。
- en: How to do it…
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, you will create custom business days and holidays for a company
    headquartered in Amman, Jordan. In Jordan, the working week is from Sunday to
    Thursday, whereas Friday and Saturday are the 2-day weekend. Additionally, their
    National Day (a holiday) is on May 25 of each year:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，你将为总部位于约旦安曼的公司创建自定义的工作日和假期。在约旦，工作周是从星期日到星期四，而星期五和星期六是为期两天的周末。此外，他们的国庆节（一个假期）是在每年的5月25日：
- en: 'ou will start by importing pandas and defining the workdays for Jordan:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将从导入pandas并定义约旦的工作日开始：
- en: '[PRE77]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You will define a custom class holiday `JordanHolidayCalendar` and a new `rule`
    for Jordan’s independence day:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将定义一个自定义类假期`JordanHolidayCalendar`和一个新的`rule`用于约旦的独立日：
- en: '[PRE78]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You will define a new instance of `CustomBusinessDay` with the custom holiday
    and weekdays:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将定义一个新的`CustomBusinessDay`实例，并包含自定义假期和工作日：
- en: '[PRE79]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You can validate that the rules were registered properly:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以验证规则是否已正确注册：
- en: '[PRE80]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now you can use `pd.date_range` to generate 10 **business** days starting from
    May 20, 2023\. The generated dates will exclude weekends (Friday and Saturday)
    and the Independence Day holiday (May 25^(th)):'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以使用`pd.date_range`生成从2023年5月20日开始的10个**工作**日。生成的日期将排除周末（周五和周六）以及独立日假期（5月25日）：
- en: '[PRE81]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To make it easier to determine whether things are working as expected, add
    a new column that represents the day name:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更容易判断功能是否按预期工作，添加一个新列来表示星期名称：
- en: '[PRE82]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The generated time series should have the new custom business days and a holiday
    rule for Jordan.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的时间序列应该具有新的自定义工作日，并包含约旦的节假日规则。
- en: '![Figure 6.17: The time series generated based on the UAE custom working days
    and holidays](img/file59.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17：基于阿联酋自定义工作日和节假日生成的时间序列](img/file59.png)'
- en: 'Figure 6.17: The time series generated based on the UAE custom working days
    and holidays'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：基于阿联酋自定义工作日和节假日生成的时间序列
- en: In *Figure 6.17* you can see the custom business workdays are from Sunday to
    Monday with the exception of May 25^(th) (Thursday) that was skipped since it
    is a national holiday in Jordan.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图6.17*中，你可以看到自定义的工作日从周日到周一，除了5月25日（星期四），因为这是约旦的国庆日，所有该日期被跳过。
- en: The example can be further extended to include different countries and holidays
    to fit the type of analysis you are working with.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例可以进一步扩展，涵盖不同国家和节假日，以适应你正在进行的分析类型。
- en: How it works…
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'This recipe builds on the Working with date offsets recipe but focuses on customizing
    offsets. The pandas provides several offsets that can take a custom calendar,
    **holiday**, and **weekmask**. These include the following:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方基于“处理日期偏移量”配方，但重点是自定义偏移量。pandas提供了几种偏移量，可以使用自定义日历、**节假日**和**weekmask**。这些包括以下内容：
- en: '`CustomBusinessDay` or `Cday`'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomBusinessDay`或`Cday`'
- en: '`CustomBusinessMonthEnd` or `CBMonthEnd`'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomBusinessMonthEnd`或`CBMonthEnd`'
- en: '`CustomBusinessMonthBegin` or `CBMonthBegin`'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomBusinessMonthBegin`或`CBMonthBegin`'
- en: '`CustomBusinessHour`'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomBusinessHour`'
- en: They behave like any other offset; the only difference is that they allow you
    to create your own rules.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的行为就像其他偏移量；唯一的区别是，它们允许你创建自己的规则。
- en: 'In the recipe you imported the `CustomBusinessDay` class, created an instance
    of it to create a custom frequency for business days, taking into account weekends
    and holidays. The following code is what you used:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你导入了`CustomBusinessDay`类，创建了它的一个实例来为工作日创建自定义频率，考虑了周末和节假日。以下是你使用的代码：
- en: '[PRE83]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Which is also equivalent to the following code:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这也等同于以下代码：
- en: '[PRE84]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Notice that when defining workdays, it was a string of abbreviated weekday names.
    This is called `weekmask`, and it's used in both pandas and NumPy when customizing
    weekdays. In pandas you can also define a custom holiday calendar by extending
    the `AbstractHolidayCalendar` class and including specific dates or rules for
    holidays, as demonstrated in the earlier code for Jordan Independence Day.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在定义工作日时，使用的是一串缩写的星期名称。这被称为`weekmask`，在自定义星期时，pandas和NumPy都使用它。在pandas中，你还可以通过扩展`AbstractHolidayCalendar`类并包含特定的日期或节假日规则来定义自定义假期日历，正如前面关于约旦独立日的代码所展示的那样。
- en: There's more…
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'Let''s extend the previous example and add custom business hours to the DataFrame.
    This will be another custom offset that you can use in a similar way to `CustomBusinessDay`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展前面的示例，并向DataFrame中添加自定义工作时间。这将是另一个自定义偏移量，你可以像使用`CustomBusinessDay`一样使用它：
- en: '[PRE85]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, you are applying the same rules, the custom `holidays` and `weekmask`
    for the custom workdays ensuring that the custom business hours also respect the
    defined workweek and holidays. You defined the custom hours by providing the `start`
    and `end` times (in 24-hour format).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你应用了相同的规则，自定义的`holidays`和`weekmask`用于自定义工作日，确保自定义的工作时间也遵守定义的工作周和节假日。你通过提供`start`和`end`时间（24小时制）来定义自定义工作时间。
- en: 'The following is a usage example of the custom business hours you just created:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你刚刚创建的自定义工作时间的使用示例：
- en: '[PRE86]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Note that custom offsets like `CustomBusinessDay` and `CustomBusinessHour` can
    be applied to both time zone-naive and time zone-aware datetime objects. However,
    the behavior and necessity of making a DataFrame time zone-aware depends on the
    specific use case. When needed, you can make your DataFrame time zone-aware (for
    example, localize it and then convert it to your time zone) using `tz.localize()`
    or `tz.convert()` before applying the custom offset to get better results.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，像`CustomBusinessDay`和`CustomBusinessHour`这样的自定义偏移量可以应用于无时区感知和有时区感知的日期时间对象。然而，是否需要将
    DataFrame 设置为时区感知取决于具体的使用案例。在需要时，你可以使用`tz.localize()`或`tz.convert()`将 DataFrame
    设置为时区感知（例如，先本地化再转换到你的时区），然后再应用自定义偏移量以获得更好的结果。
- en: See also
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'To learn more about pandas'' `CustomBusinessDay`, you can read the official
    documentation here: [https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessDay.html](https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessDay.html)'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于 pandas 的`CustomBusinessDay`，你可以阅读官方文档：[https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessDay.html](https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessDay.html)
- en: To learn more about pandas’ `CustomBusinessHours` you can read the official
    documentation here:[https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessHour.html](https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessHour.html)
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于 pandas 的`CustomBusinessHours`，你可以阅读官方文档：[https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessHour.html](https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessHour.html)
