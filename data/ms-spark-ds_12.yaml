- en: Chapter 12. TrendCalculus
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。TrendCalculus
- en: 'Long before the concept of what''s trending became a popular topic of study
    by data scientists, there was an older one that is still not well served by data
    science: it is that of Trends. Presently, the analysis of trends, if it can be
    called that, is primarily carried out by people "eyeballing" time series charts
    and offering interpretations. But what is it that people''s eyes are doing?'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学家开始研究趋势成为一个热门话题之前，有一个更古老的概念，至今仍未得到很好的数据科学服务：趋势。目前，对趋势的分析，如果可以这样称呼的话，主要是由人们“用眼睛看”时间序列图表并提供解释。但人们的眼睛在做什么呢？
- en: This chapter describes an implementation in Apache Spark of a new algorithm
    for studying trends numerically, called TrendCalculus, invented by Andrew Morgan.
    The original reference implementation is written in the Lua language and was open-sourced
    in 2015, the code can be viewed at [https://bitbucket.org/bytesumo/trendcalculus-public](https://bitbucket.org/bytesumo/trendcalculus-public).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了在Apache Spark中实现的一种用于数值研究趋势的新算法，称为TrendCalculus，由Andrew Morgan发明。原始的参考实现是用Lua语言编写的，并于2015年开源，代码可以在[https://bitbucket.org/bytesumo/trendcalculus-public](https://bitbucket.org/bytesumo/trendcalculus-public)上查看。
- en: This chapter explains the core method, which delivers the fast extraction of
    trend change points on a time series; these are the moments when trends change
    direction. We will describe our TrendCalculus algorithm in detail while implementing
    it in Apache Spark. The result is a set of scalable functions to quickly compare
    trends across time series, to make inferences about trends and examine correlation
    across timeframes. Using these disruptive new methods, we demonstrate how to construct
    a causal ranking technique to extract potential causal models from across the
    thousands of time series inputs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了核心方法，它可以快速提取时间序列上的趋势变化点；这些是趋势改变方向的时刻。我们将详细描述我们的TrendCalculus算法，并在Apache
    Spark中实现它。结果是一组可扩展的函数，可以快速比较时间序列上的趋势，以推断趋势并检查不同时间范围内的相关性。使用这些颠覆性的新方法，我们演示了如何构建因果排名技术，以从成千上万的时间序列输入中提取潜在的因果模型。
- en: 'In this chapter we will learn:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: How to construct time windowed summary data efficiently
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何有效构建时间窗口摘要数据
- en: How to effectively summarize time series data to reduce noise, for further trend
    studies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何有效地总结时间序列数据以减少噪音，以进行进一步的趋势研究
- en: How to extract trend reversal *change points* from the summary data using the
    new TrendCalculus algorithm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用新的TrendCalculus算法从摘要数据中提取趋势反转*变化点*
- en: How to create **User Defined Aggregate Functions** (**UDAFs**) that operate
    on partitions created by complex *window* functionality as well as more common
    *group by* methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建在复杂*窗口*功能创建的分区上操作的**用户定义的聚合函数**（**UDAFs**），以及更常见的*group by*方法
- en: How to return multiple values from UDAFs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从UDAFs返回多个值
- en: How to use lag functions to compare current and previous records
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用滞后函数比较当前和先前的记录
- en: When presented with a problem, amongst the first hypotheses that data scientists
    consider are those related to trends; trends are an excellent way to provide a
    visualization of data and lend themselves particularly well to large datasets,
    where the general direction of change of the data can often be seen. In Chapter
    5, *Spark for Geographic Analysis*, we produced a simple algorithm to attempt
    to predict the price of crude oil. In that study, we concentrated on the direction
    of change in the price, that is, by definition the trend of the price. We see
    that trends are a natural way to think, explain, and forecast.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当面临问题时，数据科学家首先考虑的假设之一与趋势有关；趋势是提供数据可视化的绝佳方式，特别适用于大型数据集，其中数据的一般变化方向通常是可见的。在第5章《用于地理分析的Spark》中，我们制定了一个简单的算法来尝试预测原油价格。在那项研究中，我们集中于价格的变化方向，也就是价格的趋势。我们看到，趋势是一种自然的思考、解释和预测方式。
- en: To explain and demonstrate our new trend methods, this chapter is organized
    into two sections. The first is technical, to deliver the code we need to execute
    our new algorithm. The second section is about the application of that method
    on real data. We hope it demonstrates that the apparent simplicity of trends as
    a concept can often be more complicated to calculate than we may have first thought,
    particularly in the presence of noise. Noise results in many local highs and lows
    (referred to as jitter in this chapter), which can make finding trend turning
    points and discovering the general direction of change over time difficult to
    determine. Ignoring noise in time series, and extracting interpretable trend signals,
    provides the central challenges we demonstrate how to overcome.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释和演示我们的新趋势方法，本章分为两个部分。第一部分是技术性的，提供我们执行新算法所需的代码。第二部分是关于在真实数据上应用该方法。我们希望它能证明，趋势作为一个概念的表面简单性通常比我们最初想到的更复杂，特别是在存在噪音的情况下。噪音导致许多局部高点和低点（在本章中称为抖动），这可能使得确定趋势转折点和发现随时间变化的一般方向变得困难。忽略时间序列中的噪音，并提取可解释的趋势信号，提供了我们演示如何克服的核心挑战。
- en: Studying trends
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究趋势
- en: 'The dictionary definition of trend is a general direction in which something
    is developing or changing, but there are other more focused definitions that might
    be more helpful for guiding data science. Two such definitions are from Salomé
    Areias, who studies social trends, and Eurostat, the official statistical agency
    in the European Union:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势的词典定义是某事物发展或变化的一般方向，但还有其他更专注的定义可能更有助于引导数据科学。其中两个定义来自研究社会趋势的Salomé Areias和欧盟官方统计机构Eurostat：
- en: '*"A trend is the slow variation over a longer period of time, usually several
    years, generally associated with the structural causes affecting the phenomenon
    being measured."* - EUROSTAT, official statistical agency in the European Union
    ([http://ec.europa.eu/eurostat/statistics-explained/index.php/Glossary:Trend](http://ec.europa.eu/eurostat/statistics-explained/index.php/Glossary:Trend))'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*“趋势是指在较长时期内缓慢变化，通常是几年，通常与影响所测量现象的结构性原因有关。”* - 欧盟官方统计机构EUROSTAT（[http://ec.europa.eu/eurostat/statistics-explained/index.php/Glossary:Trend](http://ec.europa.eu/eurostat/statistics-explained/index.php/Glossary:Trend)）'
- en: '*"A Trend is defined by a shift in behavior or mentality that influences a
    significant amount of people."* - Salomé Areias, social trend commentator ([https://salomeareias.wordpress.com/what-is-a-trend/](https://salomeareias.wordpress.com/what-is-a-trend/))'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*“趋势是指行为或心态的转变，影响大量人群。”* - Salomé Areias，社会趋势评论员（[https://salomeareias.wordpress.com/what-is-a-trend/](https://salomeareias.wordpress.com/what-is-a-trend/)）'
- en: 'We generally think of trends as nothing more than a long rise or fall in stock
    market prices. However, trends can also refer to many other use cases that relate
    to economics, politics, popular culture, and society: for example, the study of
    sentiments revealed by media outlets when they report on the news. In this chapter,
    we will use the price of oil as a simple demonstration; however, the technique
    could be applied to any data where trends occur in the following manner:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常认为趋势不过是股市价格的长期上涨或下跌。然而，趋势也可以指与经济、政治、流行文化和社会相关的许多其他用例：例如，媒体报道新闻时揭示的情绪研究。在本章中，我们将以石油价格作为简单的演示；然而，该技术可以应用于任何趋势发生的数据：
- en: '**Rising trends**: When successive peaks and troughs are higher (higher highs
    and higher lows), referred to as an upward or rising trend. For example, the first
    arrow in the following diagram is the result of a series of peaks and troughs
    where the overall effect is an increase.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上升趋势**：当连续的峰值和低谷较高（高峰和低谷）时，称为向上或上升趋势。例如，以下图表中的第一个箭头是一系列峰值和低谷的结果，整体效果是增加。'
- en: '**Falling trends**: When successive peaks and troughs are lower (lower highs
    and lower lows), referred to as a downward or falling trend. For example, the
    second arrow in the following diagram is the result of a series of peaks and troughs
    where the overall effect is a decrease.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下降趋势**：当连续的峰值和低谷较低（低峰和低谷）时，称为向下或下降趋势。例如，以下图表中的第二个箭头是一系列峰值和低谷的结果，整体效果是下降。'
- en: '**Horizontal trends**: This is not strictly a trend on its own, but a lack
    of a well-defined trend in either direction. We are not specifically concerned
    with this at this stage, but it is discussed later in the chapter.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平趋势**：这不是严格意义上的趋势，而是在任何方向上都没有明确定义的趋势。我们目前不特别关注这一点，但在本章后面会讨论。'
- en: '![Studying trends](img/image_12_001.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![研究趋势](img/image_12_001.jpg)'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you search for "higher highs" "higher lows" "trend" "lower highs" "lower
    lows" you will see over 16,000 hits including many high profile financial sites.
    This is a standard practice, rule of thumb definition of a trend in the finance
    industry.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您搜索“higher highs”“higher lows”“trend”“lower highs”“lower lows”，您将看到超过16,000个结果，包括许多知名的金融网站。这是金融行业中趋势的标准做法和经验法则定义。
- en: The TrendCalculus algorithm
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TrendCalculus算法
- en: In this section we will explain the detail of the TrendCalculus implementation,
    using the Brent oil price data set seen in Chapter 5, *Spark for Geographic Analysis*,
    as an example use case.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用第5章“地理分析的Spark”中看到的布伦特原油价格数据集作为示例用例，解释TrendCalculus实现的细节。
- en: Trend windows
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 趋势窗口
- en: 'In order to measure any type of change, we must first quantify it in some way.
    For trends, we are going to define this in the following manner:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了衡量任何类型的变化，我们必须首先以某种方式对其进行量化。对于趋势，我们将以以下方式定义：
- en: Overall positive change (usually expressed as a value increase)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体积极变化（通常表示为值增加）
- en: Higher highs and higher lows => +1
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Higher highs and higher lows => +1
- en: Overall negative change (usually expressed as a value decrease)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体消极变化（通常表示为值减少）
- en: Lower highs and lower lows => -1
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Lower highs and lower lows => -1
- en: 'We must therefore translate our data into a time series of trend direction,
    being either +1 or -1\. By splitting our data into a series of windows, size *n*,
    we can calculate the dated highs and lows for each of them:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须将我们的数据转换为趋势方向的时间序列，即+1或-1。通过将我们的数据分割成一系列窗口，大小为*n*，我们可以计算每个窗口的日期高点和低点：
- en: '![Trend windows](img/image_12_002.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![趋势窗口](img/image_12_002.jpg)'
- en: 'Since this type of windowing is a common practice in data science, it is reasonable
    to think there must be an implementation in Spark; if you have read [Chapter 5](ch05.xhtml
    "Chapter 5. Spark for Geographic Analysis"), *Spark for Geographic Analysis* you
    will have seen them, in the form of Spark SQL windows functions. Let''s read in
    some Brent oil data, which in this case is simply a date and the closing price
    of oil on that date (example data is located in our code repository):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种窗口化在数据科学中是一种常见的做法，因此合理地认为Spark中一定有一个实现；如果您阅读了[第5章](ch05.xhtml "第5章。地理分析的Spark")，“地理分析的Spark”，您将会看到它们，以Spark
    SQL窗口函数的形式。让我们读取一些布伦特原油数据，这种情况下只是日期和当天原油收盘价（示例数据位于我们的代码库中）：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we should ensure the date field schema is correct so that we can use
    it in the `window` function. Our example dataset has a `String` date in the format
    `dd/MM/yyyy` so we shall convert it to `yyyy-MM-dd` using `java.text.SimpleDateFormat`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该确保日期字段模式正确，以便我们可以在`window`函数中使用它。我们的示例数据集具有`dd/MM/yyyy`格式的`String`日期，因此我们将使用`java.text.SimpleDateFormat`将其转换为`yyyy-MM-dd`：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will allow us to create a **User Defined Function** (**UDF**) that we
    can use to replace the date column we already have in the `oilPriceDF` DataFrame:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够创建一个**用户定义函数**（**UDF**），我们可以用它来替换`oilPriceDF` DataFrame中已有的日期列：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As a quick aside, if we want to concentrate on a particular range of the data,
    we can filter it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速的旁注，如果我们想要集中在数据的特定范围上，我们可以对其进行过滤：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And now we can implement the window using the window function introduced in
    Spark 2.0:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用Spark 2.0中引入的窗口函数来实现窗口：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The arguments in the preceding statement allow us to provide a size of window,
    window offset and data offset, so this schema actually produces a tumbling window
    with an offset at the beginning of the data. This allows us to ensure that each
    window is constructed so that it always contains data for Monday to Friday (the
    trading days for oil), and each subsequent window contains data for the following
    week.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前述声明中的参数允许我们提供窗口大小、窗口偏移和数据偏移，因此这个模式实际上产生了一个带有数据开头偏移的滚动窗口。这样可以确保每个窗口都是构建的，以便始终包含星期一到星期五的数据（石油交易日），每个后续窗口都包含下一周的数据。
- en: 'View the DataFrame at this stage to ensure all is in order; we cannot use `show`
    method in the usual way as `windowDF` is a `RelationalGroupedDataset`. So we can
    run a simple inbuilt function to create a readable output. Counting each window
    content, showing the first twenty lines and not truncating the output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段查看DataFrame以确保一切井然有序；我们不能像通常那样使用`show`方法，因为`windowDF`是一个`RelationalGroupedDataset`。因此，我们可以运行一个简单的内置函数来创建可读的输出。计算每个窗口的内容，显示前二十行并且不截断输出：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Which will appear similar to this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将类似于这样：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, count is the number of entries in the window, that is, the number of prices
    in our case. Depending upon the data used, we may find that some windows contain
    less than five entries, due to missing data. We will keep these in the dataset,
    otherwise there will be gaps in our output.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，count是窗口中的条目数，也就是我们的情况下的价格数。根据使用的数据，我们可能会发现一些窗口包含少于五个条目，因为数据缺失。我们将保留这些数据，否则输出中将会出现间断。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Data quality should never be overlooked, and due diligence should always be
    performed before working with a new dataset, see Chapter 4, *Exploratory Data
    Analysis*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理新数据集之前，绝对不能忽视数据质量，并且必须始终进行尽职调查，参见第4章*探索性数据分析*。
- en: 'Changing the size of the window *n* (in this case, 1 week) will adjust our
    scale of investigation. For example, an *n* sized 1 week will provide a weekly
    change, and an *n* sized 1 year will provide a yearly change (each window will
    be sized: [no. of weeks'' oil traded * 5] using our data). Of course, this is
    entirely related to how the dataset is structured, that is, depending on whether
    it be hourly or daily prices, and so on. Later in the chapter we will see how
    we can easily examine trends on an iterative basis, taking the change points from
    one pass over the data as the inputs to a second iteration.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 更改窗口大小*n*（在本例中为1周）将调整我们的调查规模。例如，大小为1周的*n*将提供每周的变化，而大小为1年的*n*将提供每年的变化（每个窗口的大小将为：[交易的周数*5]使用我们的数据）。当然，这完全取决于数据集的结构，即是否为每小时或每日价格等。在本章后面，我们将看到如何可以轻松地迭代地检查趋势，将数据的变化点作为第二次迭代的输入。
- en: Simple trend
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单趋势
- en: 'Now that we have windowed data, we can calculate the +1 or -1 values for each
    window (the simple trend), so we need to develop a trend calculation equation.
    We can do this visually using an example from the previous graph diagram:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了窗口化的数据，我们可以计算每个窗口的+1或-1值（简单趋势），因此我们需要制定一个趋势计算方程。我们可以通过前面图表中的示例进行可视化处理：
- en: '![Simple trend](img/image_12_003.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![简单趋势](img/image_12_003.jpg)'
- en: For the set of calculated windows, we can compare the current window to the
    previous window thereby showing the higher highs, higher lows and lower highs,
    lower lows.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于计算出的窗口集，我们可以将当前窗口与上一个窗口进行比较，从而显示更高的高点、更低的低点和更低的高点、更低的低点。
- en: 'We do this by selecting the following from each window:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从每个窗口中选择以下内容来实现这一点：
- en: The earliest high price
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最早的高价
- en: The latest low price
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最新的低价
- en: 'Using this information, we can derive our TrendCalculus equation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些信息，我们可以推导出我们的TrendCalculus方程：
- en: '![Simple trend](img/image_12_004.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![简单趋势](img/image_12_004.jpg)'
- en: 'where:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '**sign**: is the function (x > 0) ? 1 : ((x < 0) ? -1 : 0)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sign**：是函数（x > 0）？1：（（x < 0）？-1：0）'
- en: '**H**: high'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**H**：高'
- en: '**L**: low'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：低'
- en: '**Pi**: current window'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pi**：当前窗口'
- en: '**Pi -1**: previous window'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pi -1**：上一个窗口'
- en: 'For example, given the following scenario:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定以下情景：
- en: '![Simple trend](img/image_12_005.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![简单趋势](img/image_12_005.jpg)'
- en: Simple trend = sign(sign(HighDiff) + sign(LowDiff))
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单趋势 = sign(sign(HighDiff) + sign(LowDiff))
- en: Simple trend = sign(sign(1000-970) + sign(800-780))
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单趋势 = sign(sign(1000-970) + sign(800-780))
- en: Simple trend = sign(sign(30) + sign(20))
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单趋势 = sign(sign(30) + sign(20))
- en: Simple trend = sign(1 + 1)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单趋势 = sign(1 + 1)
- en: Simple trend = sign(2)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单趋势 = sign(2)
- en: Simple trend = +1
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单趋势 = +1
- en: It is also possible to obtain an answer of 0\. This is explained in detail later
    in the chapter., see *Edge Cases*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能获得答案为0。这将在本章后面详细解释，参见*边缘案例*。
- en: User Defined Aggregate Functions
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户定义的聚合函数
- en: There are a number of ways to perform the above task programmatically, we are
    going to look at UDFs for aggregated data (Spark `UserDefinedAggregateFunction`)
    so that we can use the windowed data collected earlier.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以以编程方式执行上述任务，我们将看看用于聚合数据的UDF（Spark `UserDefinedAggregateFunction`），以便我们可以使用先前收集的窗口化数据。
- en: We would like to be able to use a function on our windows in a similar way to
    our previous UDF example. However, a standard UDF would not be possible, since
    our windows are represented as `RelationalGroupedDataset`. At runtime, the data
    for such a set may be held on more than one Spark node, so that functions are
    performed in parallel, as opposed to the data for a UDF, which must be co-located.
    The UDAF is therefore great news for us, as it means that we can implement our
    program logic safe in the knowledge that the concerns of parallelization efficiencies
    are abstracted away and the code will automatically scale to massive datasets!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够像以前的UDF示例一样在窗口上使用函数。但是，标准UDF是不可能的，因为我们的窗口被表示为`RelationalGroupedDataset`。在运行时，这样一个集合的数据可能保存在多个Spark节点上，因此函数是并行执行的，而不是UDF的数据必须是共同定位的。因此，UDAF对我们来说是一个好消息，因为这意味着我们可以在程序逻辑中实现并行化效率的关注点被抽象化，并且代码将自动扩展到大规模数据集！
- en: 'In summary, we are looking to output the earliest high price along with its
    date and the latest low price with date (for each window) so that we can use this
    data to calculate the simple trend as described previously. We will write a Scala
    class that extends the `UserDefinedAggregateFunction`, which contains the following
    functions:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们希望输出最早的高价及其日期，以及最新的低价及其日期（对于每个窗口），以便我们可以使用这些数据来计算之前描述的简单趋势。我们将编写一个扩展`UserDefinedAggregateFunction`的Scala类，其中包含以下函数：
- en: '`inputSchema`: The structure of the input data supplied to the function'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inputSchema`：提供给函数的输入数据的结构'
- en: '`bufferSchema`: The structure of the internal information (aggregation buffer)
    held for this instance'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bufferSchema`：为此实例保存的内部信息（聚合缓冲区）的结构'
- en: '`dataType`: The type of the output data structure'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dataType`：输出数据结构的类型'
- en: '`deterministic`: Whether the function is `deterministic` (that is, the same
    input always returns the same output)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deterministic`：函数是否是`确定性`的（即，相同的输入总是返回相同的输出）'
- en: '`initialize`: The initial state of the aggregation buffer; merging two initial
    buffers together must always return the same initial state'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize`：聚合缓冲区的初始状态；合并两个初始缓冲区必须始终返回相同的初始状态'
- en: '`update`: Update the aggregation buffer with the input data'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`：使用输入数据更新聚合缓冲区'
- en: '`merge`: Merge two aggregation buffers'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merge`：合并两个聚合缓冲区'
- en: '`evaluate`: Calculate the final result based on the aggregation buffer'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evaluate`：根据聚合缓冲区计算最终结果'
- en: The full code for our class is shown below, refer back to the preceding definitions
    as you're raeding through to understand the purpose of each. The code has deliberately
    been left quite verbose so that the functionality can be more easily understood.
    In practice, we could certainly refactor the `update` and `merge` functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类的完整代码如下所示，请参阅前面的定义，以便在阅读时了解每个的目的。代码故意留得相当冗长，以便更容易理解功能。实际上，我们肯定可以重构`update`和`merge`函数。
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will notice that there is common use of the `signum` function. This is
    very useful for comparison, as it produces the following outcomes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到`signum`函数的常见用法。这对于比较非常有用，因为它产生以下结果：
- en: If the first value is less than the second, output -1
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个值小于第二个值，则输出-1
- en: If the first value is greater than the second, output +1
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个值大于第二个值，则输出+1
- en: If the two values are equal, output 0
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个值相等，则输出0
- en: 'This function will really show its worth later in the chapter when we write
    the code to calculate the actual simple trend value. We have also used the `option`
    class (in `parseDate`), which enables us to return an instance of `Some` or `None`.
    This has a number of advantages: primarily it promotes a separation of concerns
    by removing the need to check for null immediately, but also enables the use of
    pattern matching, allowing us to chain together many Scala functions without the
    need for verbose type-checking. For example, if we write a function that returns
    either `Some(Int)` or `None`, then we can `flatMap` those values with no additional
    checking:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码来计算实际的简单趋势值时，这个函数将在本章后面真正显示其价值。我们还使用了`option`类（在`parseDate`中），它使我们能够返回`Some`或`None`的实例。这有许多优点：主要是通过消除立即检查空值来促进关注点的分离，还可以使用模式匹配，允许我们链式连接许多Scala函数，而无需冗长的类型检查。例如，如果我们编写一个返回`Some(Int)`或`None`的函数，那么我们可以`flatMap`这些值而无需额外的检查：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code returns `Int = 6`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码返回`Int = 6`。
- en: Simple trend calculation
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单趋势计算
- en: 'Now that we have our aggregation function, we can register it and use this
    to output the values to our DataFrame:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了聚合函数，我们可以注册它并使用它来输出值到我们的DataFrame：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Producing an output similar to this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 生成类似于以下内容的输出：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have already mentioned that we will need to compare the current window to
    the previous one. We can create a new DataFrame with the inclusion of the previous
    window details by implementing the Spark `lag` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，我们需要将当前窗口与上一个窗口进行比较。我们可以通过实现Spark的`lag`函数创建一个包含上一个窗口详情的新DataFrame：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We now have a DataFrame where each row contains all of the information required
    to calculate the simple trend value. We can again implement a UDF, this time to
    represent the simple trend equation using the `signum` function mentioned previously:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个DataFrame，其中每一行都包含计算简单趋势值所需的所有信息。我们可以再次实现一个UDF，这次使用先前提到的`signum`函数来表示简单趋势方程：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And finally, apply the UDF to our DataFrame:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将UDF应用于我们的DataFrame：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Reversal rule
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转规则
- en: 'Having run the code across all of the identified windows we now have our data
    represented as a series of +1 and -1s, and we can analyze this further to progress
    our understanding of the trends. You will notice that the data appears random,
    but there is a pattern that we can identify: the trend values often flip, either
    from +1 to -1 or -1 to +1\. On closer inspection of the graph at these points,
    we can see that these flips actually represent a reversal of the trend:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有识别的窗口上运行代码后，我们现在的数据表示为一系列+1和-1，并且我们可以进一步分析这些数据以进一步了解趋势。您会注意到数据看起来是随机的，但我们可以识别出一个模式：趋势值经常翻转，要么从+1到-1，要么从-1到+1。在更仔细地检查这些点的图表时，我们可以看到这些翻转实际上代表了趋势的反转：
- en: '![Reversal rule](img/image_12_006.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![反转规则](img/image_12_006.jpg)'
- en: 'This can be summarized thus:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以总结如下：
- en: If the trend moves from +1 to -1, then a previous high is a reversal
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果趋势从+1移动到-1，则先前的高点是一个反转
- en: If the trend moves from -1 to +1, then a previous low is a reversal
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果趋势从-1移动到+1，则先前的低点是一个反转
- en: 'Using this simple rule, we can output a new time series that contains just
    the reversal points found on our scale. In this time series, we will create tuples
    of (date, price) that are equivalent to the higher high for a +1 reversal and
    the lower low for a -1 reversal as discussed earlier. We can code this by using
    the same method as before, that is, capture the previous sign using the `lag`
    function and implement a UDF to work out the reversals, like so:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个简单的规则，我们可以输出一个新的时间序列，其中包含我们在比例上找到的反转点。在这个时间序列中，我们将创建元组（日期，价格），这些元组等同于+1反转的更高高点和-1反转的更低低点，如前面讨论的那样。我们可以通过使用与之前相同的方法来编写代码，即使用`lag`函数捕获先前的符号，并实现UDF来计算反转，如下所示：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In summary, we have successfully removed the jitter (non significant rise and
    fall) from our price data, and we could benefit from displaying this data straight
    away. It will certainly show a simplified representation of the original dataset
    and, assuming we are primarily interested in the points at which the price significantly
    changes, retains the key information, which is related to the important peaks
    and troughs. However, there is more that we can do to represent the data in a
    presentable and easily readable manner.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们成功地从我们的价格数据中去除了抖动（非显著的上升和下降），并且我们可以从中受益，立即显示这些数据。它肯定会显示原始数据集的简化表示，并且假设我们主要关注价格显著变化的点，它保留了与重要峰值和谷值相关的关键信息。然而，我们可以做更多的工作来以一种可呈现和易于阅读的方式表示数据。
- en: Introducing the FHLS bar structure
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入FHLS条形结构
- en: In the financial sector, **Open, High, Low, Close** (**OHLC**) charts are very
    common as they display the key data that every analyst requires; the price the
    item opened and closed at and the high and low price points for that period (usually
    one day). We can use this same idea for our own purposes. The **First, High, Low,
    Second** (**FHLS**) chart will enable us to visualize our data and build upon
    it to produce new insights.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在金融领域，**开盘价、最高价、最低价、收盘价**（**OHLC**）图表非常常见，因为它们显示了每个分析师所需的关键数据；物品的开盘价和收盘价，以及该时期的最高价和最低价（通常为一天）。我们可以利用这个想法来达到我们自己的目的。**第一、最高、最低、第二**（**FHLS**）图表将使我们能够可视化我们的数据并在此基础上产生新的见解。
- en: 'The FHLS data format is described as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: FHLS数据格式描述如下：
- en: The open date
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放日期
- en: '**First** of High/Low value - whichever high or low occurs first'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是高/低值 - 无论是高点还是低点先出现
- en: '**High** value'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高值
- en: '**Low** value'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低值
- en: '**Second** of High/Low value - the other value to first of High/Low'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个高/低值 - 高/低值中的另一个值先出现
- en: High date
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高日期
- en: Low date
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低日期
- en: Close date
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭日期
- en: 'We have almost all of the data we need in the `reversalsDF` described perviously,
    the only items that we have not identified are the First and Second values, that
    is, whether the highest or the lowest price was first seen in any given window.
    We could calculate this using a UDF or select statement, however updating the
    `UserDefinedAggregateFunction` from earlier will enable us to make a small change
    whilst ensuring an efficient method. Only the evaluate function requires change:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎已经在先前描述的`reversalsDF`中获得了所有需要的数据，我们尚未确定的只有第一和第二值，也就是在任何给定窗口中最高或最低价格是先出现的。我们可以使用UDF或选择语句来计算这一点，但是更新之前的`UserDefinedAggregateFunction`将使我们能够进行小的更改，同时确保方法的高效性。只有评估函数需要更改：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we can write a statement to select the required fields and write our
    data to file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以编写一个语句来选择所需的字段并将我们的数据写入文件：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will notice that the reversals column does not implement a `Struct` like
    the others, but a tuple. If you check `reversalsUDF`, you will see how this has
    been done. For demonstration purposes, we will show how to rename the component
    fields once they have been selected:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到反转列不像其他列一样实现了`Struct`，而是一个元组。如果您检查`reversalsUDF`，您将看到是如何做到的。为了演示目的，我们将展示如何在选择后重命名组件字段：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Writing the data to file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据写入文件：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You could encrypt the data with the addition of the line:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加以下行对数据进行加密：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This important codec, and other security related techniques, are described in
    [Chapter 13](ch13.xhtml "Chapter 13. Secure Data"), *Secure Data*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重要的编解码器和其他安全相关技术在[第13章](ch13.xhtml "第13章。安全数据") *安全数据*中有描述。
- en: Visualize the data
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化数据
- en: Now that we have the data in a file, we can take the opportunity to display
    it; there are many packages available for creating charts, as a data scientist
    perhaps one of the key ones is D3.js. As we have mentioned D3 in other areas of
    the book, it is not our intention to explore here any more detail than is necessary
    to produce our end results. That said, it's worth outlining that D3 is a JavaScript
    library for manipulating documents based on data, and that there are many contributors
    to the ecosystem such that the number of data visualizations available is huge.
    Understanding the basics will allow us to provide truly impressive results with
    relatively little effort.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了文件中的数据，我们可以利用这个机会来展示它；有许多可用于创建图表的软件包，作为一名数据科学家，其中一个关键的软件包就是D3.js。正如我们在本书的其他部分提到的D3一样，我们的目的不是在这里探索比必要的更多的细节，而是产生我们最终结果所需的。也就是说，值得概述的是，D3是一个基于数据操作文档的JavaScript库，生态系统中有许多贡献者，因此可用的数据可视化数量是巨大的。了解基础知识将使我们能够以相对较少的努力提供真正令人印象深刻的结果。
- en: Using the FHLS format, we can convince chart software to accept our data as
    if it were OHLC formatted. So we should search the Internet for a D3 OHLC library
    that we can use. In this example, we have chosen [techanjs.org](http://techanjs.org/)
    as it provides not just OHLC, but also some other visualizations that may be useful
    later.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FHLS格式，我们可以说服图表软件接受我们的数据，就好像它是OHLC格式的一样。因此，我们应该搜索互联网上可以使用的D3 OHLC库。在这个例子中，我们选择了[techanjs.org](http://techanjs.org/)，因为它不仅提供OHLC，还提供了一些其他可能在以后有用的可视化。
- en: 'Implementing D3 code is usually as simple as cutting and pasting into a text
    file, having amended any paths to data directories in the source code. If you
    have never worked in this area before, there are some useful tips below to help
    you get started:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 实现D3代码通常就是将其剪切并粘贴到一个文本文件中，修改源代码中的任何数据目录路径。如果您以前从未在这个领域工作过，下面有一些有用的提示，可以帮助您入门：
- en: If you are working with web technologies with the Chrome browser, there is a
    set of very useful tools located under ****Options** | **More Tools** | **Developer
    Tools**** . If nothing else, this will provide an output of errors from the code
    that you are trying to run, which otherwise will be lost, making a blank page
    result much easier to debug.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在使用Chrome浏览器的Web技术，可以在****选项** | **更多工具** | **开发者工具**** 下找到一组非常有用的工具。即使没有其他内容，这也将提供您尝试运行的代码的错误输出，否则将会丢失，使得调试空白页面的结果更加容易。
- en: If you are using a single file for your code, as in the example below, always
    use `index.html` for the filename.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的代码使用单个文件，就像下面的示例一样，请始终使用`index.html`作为文件名。
- en: 'If your code references local files, which is usually the case when implementing
    D3, you will need to run a web server so that they can be served. By default,
    a web browser cannot access local files due to the inherent security risks (malicious
    code accessing local files). A simple way to run a web server is to execute: `nohup
    python -m SimpleHTTPServer &` in the source directory for your code. You must
    never give your browser access to local files, as it will be left wide open to
    attack. For example, do not run: `chrome --allow-file-access-from-files`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的代码引用本地文件，通常在实现D3时会这样，您需要运行一个Web服务器，以便它们可以被提供。默认情况下，Web浏览器无法访问本地文件，因为存在固有的安全风险（恶意代码访问本地文件）。运行Web服务器的简单方法是在代码的源目录中执行：`nohup
    python -m SimpleHTTPServer &`。绝对不要让浏览器访问本地文件，因为这将使其完全暴露于攻击之下。例如，不要运行：`chrome --allow-file-access-from-files`
- en: When using D3 in your source, where possible always use `<script src="img/d3.v4.min.js"></script>`
    to ensure you import the latest version of the library.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源代码中使用D3时，尽可能始终使用`<script src="img/d3.v4.min.js"></script>`来确保导入库的最新版本。
- en: 'We can use the code as is, the only change we should make is the way in which
    the columns are referenced:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用代码，唯一需要改变的是引用列的方式：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will produce a chart similar to this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个类似于这样的图表：
- en: '![Visualize the data](img/image_12_007.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![可视化数据](img/image_12_007.jpg)'
- en: On this chart, green bars indicate an increase from the **First**, a low price,
    to the **Second**, a high price, and red bars indicate a decrease from a **first
    high** to **second low**. This subtle change from typical OHLC charts is critical.
    At a glance we can now easily see the flow of the time series as it rises and
    falls across the summarizing bars. This helps us to understand the flow of rises
    and falls in price on our fixed scale of enquiry, or window size, without having
    the disadvantage of having to interpret the effect of time scale as we would on
    a line chart of raw price values. The resulting chart offers a way to reduce noise
    on smaller timeframes, delivering a neat and repeatable way of summarizing our
    time series visually. There is still more that we can do, however.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表上，绿色的条表示从**第一个**低价到**第二个**高价的增加，红色的条表示从**第一个高价**到**第二个低价**的减少。这种与典型OHLC图表的微妙变化至关重要。一眼就能看到时间序列在总结条上的上升和下降流动。这有助于我们理解价格在我们固定的查询尺度或窗口大小上的上升和下降流动，而无需像在原始价格值的线图上那样解释时间尺度的影响。结果图表提供了一种减少较小时间框架上的噪音的方法，以一种整洁且可重复的方式对我们的时间序列进行可视化总结。然而，我们仍然可以做更多。
- en: FHLS with reversals
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有反转的FHLS
- en: 'We have previously calculated the trend reversals, using our TrendCalculus
    equation, and plotting these together with the FHLS summary data above will really
    enhance our visualization, showing the high/low bars and the trend reversal points
    together. We can do this by modifying our D3 code to also implement D3 Scatterplot
    code. The code required can be found on the Internet in many places, as before;
    we have some code below which can be integrated by adding the relevant parts to
    `<script>`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用我们的TrendCalculus方程计算了趋势反转，并将其与上面的FHLS摘要数据一起绘制，这将真正增强我们的可视化效果，显示高/低条和趋势反转点。我们可以通过修改我们的D3代码来实现D3散点图代码。所需的代码可以在互联网上的许多地方找到，就像以前一样；我们下面有一些代码，可以通过将相关部分添加到`<script>`中来集成。
- en: 'Add the `reversalPrice` field:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`reversalPrice`字段：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And draw the dots:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 并绘制点：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once this is successfully integrated, we will see a chart similar to this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功集成，我们将看到一个类似于这样的图表：
- en: '![FHLS with reversals](img/image_12_008.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![带有反转的FHLS](img/image_12_008.jpg)'
- en: 'Alternatively, the reversals can be very effective using just a simple line
    chart. The following is an example of such a chart to demonstrate the visual impact
    of trend reversal plotting:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，反转可以使用简单的折线图非常有效。以下是一个这样的图表示例，用于演示趋势反转绘图的视觉影响：
- en: '![FHLS with reversals](img/image_12_009.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![带有反转的FHLS](img/image_12_009.jpg)'
- en: Edge cases
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界情况
- en: 'During our previous calculations, we briefly mentioned that the value 0 could
    be produced when executing the simple trend algorithm. Given our algorithm, this
    can occur in the following scenarios:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的计算中，我们简要提到在执行简单趋势算法时可能产生值0。根据我们的算法，这可能发生在以下情况下：
- en: sign ( -1 + (+1) )
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sign ( -1 + (+1) )
- en: sign ( +1 + (-1) )
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sign ( +1 + (-1) )
- en: sign ( 0 + (0) )
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sign ( 0 + (0) )
- en: 'With an example graph we can identify the values using our algorithm thus:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个示例图，我们可以使用我们的算法识别出以下值：
- en: '![Edge cases](img/image_12_010.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![边界情况](img/image_12_010.jpg)'
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the money markets we can identify each of the windows as being an inner bar
    or outer bar. Inner is a bar that defines uncertainty in the market; there is
    no higher high or lower low. Outer is where a higher high or lower low has been
    reached; of course these terms can only be assigned once the data is available.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在货币市场中，我们可以将每个窗口识别为内部条或外部条。内部是定义市场不确定性的条，没有更高的高点或更低的低点。外部是已经达到更高的高点或更低的低点；当然，这些术语只能在数据可用时分配。
- en: From what we have seen so far, these zeroes appear to break our algorithm. However,
    this is not the case and indeed there is an efficient solution that enables us
    to take account of them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的这些零似乎会破坏我们的算法。然而，事实并非如此，实际上有一个有效的解决方案，使我们能够考虑到它们。
- en: Zero values
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 零值
- en: When reviewing the previous graph, we can imagine the path taken across the
    FHLS bars by the price, a process made easy considering that green bars mean rising
    prices in time, and red ones mean falling prices in time. How does understanding
    the path through time help solve the zero trend problem? There is a simple answer,
    but it is not necessarily intuitive.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查以前的图表时，我们可以想象价格在FHLS条形图上所走过的路径，这一过程变得容易，因为绿色条表示时间上的价格上涨，红色条表示时间上的价格下跌。了解时间路径如何帮助解决零趋势问题？有一个简单的答案，但不一定直观。
- en: 'We have previously kept a record of the dates of all highs and lows throughout
    our data processing; although we have not used all of them. Our **First** and
    **Second** values calculated using those dates actually indicate the flow or direction
    of that local trend, as in the following diagram, and once you study the summary
    charts for a while, your eye will naturally move with this flow to interpret the
    time series:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前一直记录了我们数据处理过程中所有高点和低点的日期；尽管我们没有使用所有的日期。我们使用这些日期计算出的**第一个**和**第二**值实际上指示了该局部趋势的流动或方向，如下图所示，一旦你研究了一段时间的摘要图表，你的眼睛自然会随着这种流动来解释时间序列：
- en: '![Zero values](img/image_12_011.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![零值](img/image_12_011.jpg)'
- en: 'If we look at the next diagram, we can see that the dotted line showing how
    our eyes interpret the flow of time is not just implied. Between our dated highs
    and lows, there are data values that are not summarized in the chart by our specially
    constructed bars, meaning there are time gaps in coverage between the bars. We
    can leverage this property to solve the problem. Consider the following diagram,
    with the price line added back in:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看下一个图表，我们会发现我们的眼睛如何解释时间流动的虚线不仅仅是暗示的。在我们的日期高点和低点之间，有一些数据值没有被我们特别构建的条形图总结，这意味着条形图之间存在时间间隙。我们可以利用这一特性来解决问题。考虑以下图表，加上价格线：
- en: '![Zero values](img/image_12_012.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![零值](img/image_12_012.jpg)'
- en: Completing the gaps
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 填补间隙
- en: 'Using a continuation of the same example, we will take one of the identified
    gaps and demonstrate a method that we can use to fill them:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用同一个示例的延续，我们将取出一个已识别的间隙，并演示我们可以用来填补它们的方法：
- en: '![Completing the gaps](img/image_12_013.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![填补间隙](img/image_12_013.jpg)'
- en: 'The steps are as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: Find a 0 trend (inner/outer bar)
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到0趋势（内/外部条）
- en: Insert a new FHLS summary for the gap implied by borrowing the second value
    from the previous window, and the first value from the current window (see previous
    diagram)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了填补由于从前一个窗口借用第二个值和从当前窗口借用第一个值而暗示的间隙，插入一个新的FHLS摘要（见前面的图表）
- en: Emit these special bars during normal FHLS construction, format them as per
    regular windows of highs/lows and use them to find the trends in the normal way
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在正常的FHLS构建过程中发出这些特殊的条形图，按照常规的高/低窗口格式化它们，并使用它们以正常的方式找到趋势
- en: Now that we have created a new bar, we can use it in the already defined manner;
    one of the signs of our equation (the high diff or low diff) will have a value
    of 0, the other will now be +1 or -1\. The reversals are then calculated as before.
    In the previous example, the question mark becomes a -1 under our new system as
    we find a lower low; therefore the last high was a reversal.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个新的条形图，我们可以以已定义的方式使用它；我们方程式的一个标志（高差或低差）将有一个值为0，另一个现在将是+1或-1。然后进行反转计算。在前面的例子中，问号在我们的新系统下变成了-1，因为我们找到了一个更低的低点；因此最后一个高点是一个反转。
- en: 'We can modify the code in the following way, starting with the `simpleTrendDF`
    from our previous efforts:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改代码，从我们之前的努力中的`simpleTrendDF`开始：
- en: Filter all of the rows with a sign of 0.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤所有标志为0的行。
- en: '`val zeroSignRowsDF = simpleTrendDF.filter("sign == 0")`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`val zeroSignRowsDF = simpleTrendDF.filter("sign == 0")`.'
- en: Drop the sign column as we are going to use the schema of this new DataFrame.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除sign列，因为我们将使用这个新DataFrame的模式。
- en: '`val zeroRowsDF = zeroSignRowsDF.drop("sign")`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`val zeroRowsDF = zeroSignRowsDF.drop("sign")`.'
- en: 'Iterate each row and output an updated row that has been amended in the following
    way:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代每一行并输出已经以以下方式修改的更新行：
- en: The `window.start` date is the date of the **Second** value from the `highLowPrev`
    column
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口开始日期是`highLowPrev`列中**第二**个值的日期
- en: The `window.end` date can remain the same, as it is not used in the FHLS calculation
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.end`日期可以保持不变，因为它在FHLS计算中没有被使用。'
- en: 'The `highLow` entry is constructed thus:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`highLow`条目构造如下：'
- en: '`HighestHighDate`: The earlier of the **First** `highLow` date and      **Second** `highLowPrev`
    date'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HighestHighDate`：**第一个**`highLow`日期和**第二**`highLowPrev`日期中较早的日期'
- en: '`HighestHighPrice`: The price related to above'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HighestHighPrice`：与上述相关的价格'
- en: '`LowestLowDate`: The later of the **First** `highLow` date and **Second** `highLowPrev`
    date'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LowestLowDate`：**第一个**`highLow`日期和**第二**`highLowPrev`日期中较晚的日期'
- en: '`LowestLowPrice`: The price related to above'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LowestLowPrice`：与上述相关的价格'
- en: '`firstPrice`: The price related to the earliest new `highLow` date'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`firstPrice`：与最早的新`highLow`日期相关的价格'
- en: '`secondPrice`: The price related to the latest new `highLow` date'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`secondPrice`：与最新的`highLow`日期相关的价格'
- en: The `highLowPrev` column can remain, as it will be deleted in the next step
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`highLowPrev`列可以保留，因为它将在下一步中被删除'
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Drop the `highLowPrev` column
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`highLowPrev`列
- en: '`val newHighLowDF = tempHighLowDF.drop("highLowPrev")`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`val newHighLowDF = tempHighLowDF.drop("highLowPrev")`'
- en: Union the new DataFrame with `highLowDF`, which has the effect of inserting
    new rows
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的DataFrame与`highLowDF`联合，这将插入新的行
- en: '`val updatedHighLowDF = newHighLowDF.union(highLowDF)`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`val updatedHighLowDF = newHighLowDF.union(highLowDF)`'
- en: 'Proceed with the simple trend process as before, using `updatedHighLowDF` instead
    of `highLowDF` and starting with:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续使用`updatedHighLowDF`而不是`highLowDF`进行简单的趋势处理，并从以下开始：
- en: '`val sortedWindow = Window.orderBy("window.start")`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`val sortedWindow = Window.orderBy("window.start")`'
- en: 'Continuing with the preceding example, we see that there are (probably) no
    longer any zeroes, and the reversals are still clear and quick to compute. If
    the selected time window is very small, for example, seconds or minutes, then
    there may still be zeroes in the output, indicating that the price has not changed
    for that period. The gap process can be repeated, or the size of the window can
    be changed to something that extends the period of static price:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前面的例子，我们可以看到（可能）不再有零值，反转仍然清晰且快速计算。如果选择的时间窗口非常小，例如秒或分钟，则输出中可能仍然有零值，表明价格在该时段内没有变化。可以重复间隙处理，或者将窗口的大小更改为延长静态价格期间的大小：
- en: '![Completing the gaps](img/image_12_014.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![填补间隙](img/image_12_014.jpg)'
- en: 'We have already seen the time series using D3, but can now use charting software
    to show where the new bars covering the implied gaps have been added, which are
    the white bars shown in the following diagram. The overall results are so intuitive,
    we can easily see the trends and their reversals just with our eyes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用D3看到了时间序列，但现在可以使用图表软件来显示新添加的覆盖隐含间隙的条形图，这些条形图显示在下图中的白色条形图中。总体结果非常直观，我们可以很容易地用肉眼看到趋势及其反转：
- en: '![Completing the gaps](img/image_12_015.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![填补间隙](img/image_12_015.jpg)'
- en: Stackable processing
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可堆叠处理
- en: Now we have this capability, we can treat the list of trend reversals as an
    input to a second pass of the algorithm. To do this we can adjust our windowing
    functions so that the inputs are windows of N-ordered observations, rather than
    fixed blocks of time. If we do this, we can *stack* and create multi-scale *trees
    of trends* TrendCalculus, meaning we can feed the output of the algorithm back
    into it on a subsequent pass. This creates a multi-scale reversal finder. Processing
    data in several passes, in this *stacked* way, is a highly efficient process due
    to the inherent data reduction on later passes. With multiple runs partitions
    build, bottom up, into a hierarchical structure. Working in this way, we can use
    this method to *zoom* in and out of the longer and shorter ranges of trends depending
    upon the level of detail we require; trend patterns become easier to see with
    the naked eye as we *zoom* out.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个功能，我们可以将趋势反转列表视为算法的第二次输入。为此，我们可以调整我们的窗口函数，使输入成为N个有序观察的窗口，而不是固定的时间块。如果这样做，我们可以*堆叠*并创建多尺度*趋势树*
    TrendCalculus，这意味着我们可以将算法的输出反馈到后续的处理中。这将创建一个多尺度的反转查找器。以这种*堆叠*的方式进行多次处理是一种高效的过程，因为后续处理中固有的数据减少。通过多次运行，分区会自下而上地构建成一个分层结构。通过这种方式工作，我们可以使用这种方法来根据我们需要的详细程度*缩放*长期和短期的趋势范围；随着我们*缩放*，趋势模式变得更容易用肉眼看到。
- en: 'Selecting the relevant data from our `reversalsDF` DataFrame would enable us
    to simply run the process again; the `highLow` column contains:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的`reversalsDF` DataFrame中选择相关数据将使我们能够简单地再次运行该过程；`highLow`列包含：
- en: The date and price of the `HighestHigh`
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HighestHigh`的日期和价格'
- en: The date and price of the `LowestLow`
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LowestLow`的日期和价格'
- en: 'Which can be selected and output as a file containing (date, price); exactly
    the format we used to ingest our original file:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择并输出为一个包含（日期，价格）的文件；正是我们用来摄取原始文件的格式：
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s review what we have built:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们已经构建的内容：
- en: We have constructed code to process a time series and to summarize it effectively
    into windows of dated highs and lows over fixed windows of time
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经构建了代码来处理时间序列，并有效地将其总结为固定时间窗口内的日期高点和低点
- en: We have assigned a positive or negative trend to each time window
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经为每个时间窗口分配了正向或负向趋势
- en: We have a method to cope with edge cases, eliminating the zero valued trend
    problem
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一种处理边缘情况的方法，消除了零值趋势问题
- en: We have a calculation to find the actual moments in time, and values of the
    prices when trend reversals occurred.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个计算方法来找到实际的时间点，以及趋势反转发生时的价格数值。
- en: The effect of this is that we have constructed a very fast proxy method for
    delivering something akin to a piecewise linear regression of our time series.
    Seen in another way, the list of trend reversals represents a simplification of
    our time series into a compressed form that ignores noise on small timeframes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的效果是，我们构建了一种非常快速的代理方法，可以将我们的时间序列简化为类似分段线性回归的压缩形式。从另一个角度来看，趋势逆转列表代表了我们的时间序列的简化形式，忽略了小时间尺度上的噪音。
- en: Practical applications
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际应用
- en: Now that we have our algorithm coded, let's look at practical applications for
    this method on real data. We will start by understanding how the algorithm performs,
    so that we can determine where we might use it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了我们的算法，让我们看看这种方法在真实数据上的实际应用。我们将首先了解算法的性能，以便确定我们可能在哪里使用它。
- en: Algorithm characteristics
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法特性
- en: So, what are the characteristics of this algorithm? Below is a list of strengths
    and weaknesses.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这种算法的特点是什么？以下是其优势和劣势的列表。
- en: Advantages
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点
- en: 'The advantages are as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 优点如下：
- en: The algorithm is general, lending itself well to both stream based and Spark
    implementations
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该算法是通用的，非常适合基于流和Spark的实现。
- en: The theory is simple, yet effective
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该理论简单而有效
- en: The implementation is fast and efficient
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现速度快且高效
- en: The result is visual and interpretable
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果是可视化和可解释的
- en: The method is stackable and allows for multi scale studies; this is very simple
    when using Spark windows
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法可堆叠，并允许进行多尺度研究；在使用Spark窗口时非常简单
- en: Disadvantages
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缺点
- en: 'The disadvantages are as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点如下：
- en: A lagging indicator the algorithm finds trend reversals that occurred in the
    past, and cannot be used directly to predict a trend change as it happens
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滞后指标，该算法找到了过去发生的趋势逆转，并不能直接用于预测趋势变化
- en: The lag accumulates for higher scales, meaning much more data (and thus time
    lag) is required to find long-range trend changes versus finding trend reversals
    on shorter timeframes
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滞后累积到更高的尺度，意味着需要更多的数据（因此需要更多的时间滞后）才能找到长期趋势变化，而不是在较短时间尺度上找到趋势逆转
- en: It's important to understand the limitations of this algorithm. We have created
    a very useful analysis tool that can be used for researching trends. However,
    it is not in itself a prediction tool, rather a tool to more easily identify trends
    for follow-on processing.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 了解该算法的局限性很重要。我们已经创建了一个非常有用的分析工具，可用于研究趋势。但是，它本身并不是一个预测工具，而是一个更容易识别趋势以进行后续处理的工具。
- en: Possible use cases
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可能的用例
- en: With our newly found ability to convert a time series into a list of change
    points, many use cases that were once difficult become easy. Let's take a look
    at some potential applications.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们新发现的将时间序列转换为变化点列表的能力，许多曾经困难的用例变得容易。让我们看看一些潜在的应用。
- en: Chart annotation
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图表注释
- en: We can retrieve News Headlines from the GDELT feed at moments when trend changes
    occur, at major highs or lows, thus annotating our charts with context.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在趋势变化发生时，即在主要高点或低点，从GDELT feed中检索新闻标题，从而为我们的图表添加上下文。
- en: Co-trending
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共同趋势
- en: We can use the reduction in noise to compare trends across different time series,
    and devise calculations to measure which are co-trending.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用噪音的减少来比较不同时间序列的趋势，并设计计算来衡量哪些是共同趋势。
- en: Data reduction
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据减少
- en: We can use the algorithm to simplify time series and reduce data volumes, while
    retaining critical moments, stacking the algorithm allows for greater reductions.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用该算法简化时间序列并减少数据量，同时保留关键时刻，堆叠该算法可以实现更大的减少。
- en: Indexing
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引
- en: We can view the change points as a novel form of index to the time series, allowing,
    for example, the retrieval of portions of the data where things were on a short
    time frame running counter to a trend on a longer time frame.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将变化点视为时间序列的一种新形式的指数，例如，允许检索数据的部分，其中短时间内的事物与长时间内的趋势相反。
- en: Fractal dimension
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分形维度
- en: We can find change points on different time scales, and use the information
    to investigate the fractal dimensions of the time series.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在不同的时间尺度上找到变化点，并使用信息来研究时间序列的分形维度。
- en: Streaming proxy for piecewise linear regression
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分段线性回归的流式代理
- en: The method can be used as a very fast way to compute proxy for piecewise linear
    regression, where such methods are needed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法可以作为计算分段线性回归的一种非常快速的方法，需要这种方法时。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have introduced a method for analyzing trends with TrendCalculus.
    We have outlined the fact that despite analysis of trends being a very common
    use case, there are few tools to aid the data scientist in this cause apart from
    very general-purpose visualization software. We have guided the reader through
    the TrendCalculus algorithm, demonstrating how we implement an efficient and scalable
    realization of the theory in Spark. We have described the process of identifying
    the key output of the algorithm: trend reversals on a named scale. Having calculated
    reversals, we used D3.js to visualize time series data that has been summarized
    for one-week windows, and plotted trend reversals. The chapter continued with
    an explanation of how to overcome the main edge case: the zero values found during
    simple trend calculation. We have concluded with a brief outline of the algorithm
    characteristics and potential use cases, demonstrating how the method is elegant
    and can be easily described and realized in Spark.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用TrendCalculus分析趋势的方法。我们概述了尽管趋势分析是一个非常常见的用例，但除了非常通用的可视化软件外，几乎没有工具可以帮助数据科学家进行这种分析。我们引导读者了解了TrendCalculus算法，演示了我们如何在Spark中实现理论的高效可扩展性。我们描述了识别算法的关键输出的过程：在命名尺度上的趋势逆转。在计算了逆转之后，我们使用D3.js可视化了已经总结为一周窗口的时间序列数据，并绘制了趋势逆转。本章继续解释了如何克服主要的边缘情况：在简单趋势计算中发现的零值。最后，我们简要概述了算法特性和潜在用例，演示了该方法是优雅的，可以在Spark中轻松描述和实现。
- en: In the next chapter, we will be demystifying the topic of data security. We'll
    describe the most important areas of security from a data science perspective,
    concentrating on the theory and implementation of sanctioned access for the handling
    of highly confidential data.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将揭秘数据安全的话题。我们将从数据科学的角度描述安全的最重要领域，集中讨论高度机密数据处理的理论和实施授权访问。
