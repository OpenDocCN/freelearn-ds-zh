- en: 6\. Learning the Hidden Secrets of Data Wrangling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 学习数据清洗的隐藏秘密
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn about data problems that arise in business use
    cases and how to resolve them. This chapter will give you the skills needed to
    be able to clean and handle real-life messy data. By the end of this chapter,
    you will be able to prepare data for analysis by formatting it as required by
    downstream systems. You will also be able to identify and remove outliers from
    data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解在商业用例中出现的各种数据问题以及如何解决这些问题。本章将为你提供清理和处理现实生活中杂乱数据所需的技能。到本章结束时，你将能够通过格式化数据以满足下游系统的要求来准备数据以供分析。你还将能够从数据中识别并移除异常值。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will learn the secret behind creating a successful data
    wrangling pipeline. In the previous chapters, we were introduced to basic and
    advanced data structures and other building blocks of data wrangling, such as
    `pandas` and NumPy. In this chapter, we will look at the data handling aspect
    of data wrangling.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习创建成功的数据清洗管道背后的秘密。在前几章中，我们介绍了基本和高级数据结构以及数据清洗的其他构建块，例如`pandas`和NumPy。在本章中，我们将探讨数据清洗的数据处理方面。
- en: Imagine that you have a database of patients who have heart diseases, and like
    any survey, the data is either missing, incorrect, or has outliers. Outliers are
    values that are abnormal and tend to be far away from the central tendency, and
    thus including it in your fancy machine learning model may introduce a terrible
    bias that we need to avoid. Often, these problems can cause a huge difference
    in terms of money, man-hours, and other organizational resources. It is undeniable
    that someone with the skills to solve these problems will prove to be an asset
    to an organization. In this chapter, we'll talk about a few advanced techniques
    that we can use to handle outliers and missing data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个包含患有心脏病患者的数据库，就像任何调查一样，数据可能缺失、错误或存在异常值。异常值是异常值，通常远离中心趋势，因此将其包含在您花哨的机器学习模型中可能会引入我们希望避免的严重偏差。通常，这些问题在金钱、人力和其他组织资源方面会产生巨大差异。不可否认，具备解决这些问题的技能的人将对组织证明是一笔财富。在本章中，我们将讨论一些可以用来处理异常值和缺失数据的先进技术。
- en: Advanced List Comprehension and the zip Function
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级列表推导式和zip函数
- en: In this section, we will deep dive into the heart of list comprehension. We
    have already seen a basic form of it, including something as simple as `a = [i
    for i in range(0, 30)]` to something a bit more complex that involves one conditional
    statement. However, as we already mentioned, list comprehension is a very powerful
    tool and, in this section, we will explore this amazing tool further. We will
    investigate another close relative of list comprehension called `zip` and its
    related functions and methods. By the end of this section, you will be confident
    in handling complicated logical problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨列表推导式的核心。我们已经看到了它的基本形式，包括像`a = [i for i in range(0, 30)]`这样简单的东西，到涉及一个条件语句的更复杂的形式。然而，正如我们之前提到的，列表推导式是一个非常强大的工具，在本节中，我们将进一步探索这个惊人的工具。我们将研究另一个与列表推导式密切相关的称为`zip`的工具及其相关函数和方法。到本节结束时，你将能够自信地处理复杂的逻辑问题。
- en: Introduction to Generator Expressions
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器表达式简介
- en: In the previous chapter, while discussing advanced data structures, we witnessed
    functions such as `repeat`. We said that they represent a special type of function
    known as iterators. We also showed you how the lazy evaluation of an iterator
    can lead to an enormous amount of space being saved and time efficiency.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，在讨论高级数据结构时，我们见证了诸如`repeat`之类的函数。我们说它们代表了一种特殊类型的函数，称为迭代器。我们还向您展示了迭代器的懒加载如何导致节省大量空间和提高时间效率。
- en: Iterators are one brick in the functional programming construct that Python
    has to offer. Functional programming is indeed a very efficient and safe way to
    approach a problem. It offers various advantages over other methods, such as modularity,
    ease of debugging and testing, composability, formal provability (a theoretical
    computer science concept), and more.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是Python提供的函数式编程结构中的一块砖。函数式编程确实是一种非常高效且安全的问题解决方法。它提供了比其他方法更多的优势，例如模块化、易于调试和测试、可组合性、形式可证明（一个理论计算机科学概念）等等。
- en: Now, let's look at an exercise where we'll see how to use generator expressions.
    But before we do that, we should define, formally, what a generator expression
    is. Generator expressions are a high-performance, memory-efficient generalization
    of list comprehensions and generators. We'll practice this concept in the following
    exercise. Since we have covered some amount of list comprehension already, generator
    expressions will look familiar to us. However, they also offer some advantages
    over list comprehension.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个练习，我们将看到如何使用生成器表达式。但在我们这样做之前，我们应该正式定义什么是生成器表达式。生成器表达式是列表解析和生成器的性能高、内存高效的泛化。我们将在以下练习中练习这个概念。由于我们已经覆盖了一些列表解析的内容，生成器表达式对我们来说将很熟悉。然而，它们也提供了一些相对于列表解析的优势。
- en: 'Exercise 6.01: Generator Expressions'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.01：生成器表达式
- en: 'In this exercise, we will be working with generator expressions, which are
    considered another brick of functional programming (as a matter of fact, they
    are inspired by the pure functional language known as Haskell). We will create
    a list of odd numbers using list comprehension and check the memory occupied by
    the list. We will then create the same list using a generator expression and see
    the advantage of using it over list comprehension. To do so, let''s go through
    the following steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用生成器表达式，这被认为是函数式编程的另一块基石（实际上，它们受到了被称为 Haskell 的纯函数式语言的启发）。我们将使用列表解析创建一个奇数列表并检查列表占用的内存。然后我们将使用生成器表达式创建相同的列表，并看到使用它相对于列表解析的优势。为此，让我们按照以下步骤进行：
- en: 'Open a new Jupyter Notebook and write the following code using list comprehension
    to generate a list of all the odd numbers between 0 and 10,0000:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook，并使用以下代码使用列表解析生成一个包含 0 到 10,0000 之间所有奇数的列表：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use `getsizeof` from `sys` by using the following code to understand the bytes
    of memory the generator expressions occupy:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码中的 `sys` 的 `getsizeof` 来理解生成器表达式占用的字节数：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output is as follows:'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will see that it takes a good amount of memory to do this. It is also not
    very time efficient. How can we change this? Using a method such as `repeat` is
    not applicable here because we need to have the logic of the list comprehension.
    Fortunately, we can turn any list comprehension into a generator expression.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将看到这需要相当多的内存。它也不是非常节省时间。我们如何改变这一点？使用 `repeat` 这样的方法在这里不适用，因为我们需要列表解析的逻辑。幸运的是，我们可以将任何列表解析转换为生成器表达式。
- en: 'Write the equivalent generator expression for the aforementioned list comprehension:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为上述列表解析编写等效的生成器表达式：
- en: '[PRE3]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that the only change we made is to surround the list comprehension statement
    with round brackets instead of square ones. This makes it shrink to only around
    `100` bytes. This is because this is a generator expression, so no explicit memory
    has been allocated for it. There's just enough memory to hold the logic of the
    generation of numbers. This makes it become a lazy evaluation, and thus is more
    efficient.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们唯一做的改变是将列表解析语句用圆括号而不是方括号包围。这使得它的大小缩减到大约 `100` 字节。这是因为这是一个生成器表达式，所以没有为它分配显式的内存。只需要足够的内存来存储生成数字的逻辑。这使得它成为一个惰性求值，因此更高效。
- en: 'Print the first 10 odd numbers, as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印前 10 个奇数，如下所示：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, the first 10 odd numbers are being printed on the console.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前 10 个奇数正在控制台上打印。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YMwDFH](https://packt.live/2YMwDFH).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YMwDFH](https://packt.live/2YMwDFH)。
- en: You can also run this example online at [https://packt.live/3daSb47](https://packt.live/3daSb47).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3daSb47](https://packt.live/3daSb47)上在线运行此示例。
- en: In the next exercise, we'll take a look at how to write a generator expression
    in one line.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将探讨如何在一行中编写一个生成器表达式。
- en: 'Exercise 6.02: Single-Line Generator Expression'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.02：单行生成器表达式
- en: 'In this exercise, we will use our knowledge of generator expressions to generate
    an expression that will read one word at a time from a list of words and will
    remove newline characters at the end of them while making them lowercase. This
    can certainly be done using a `for` loop explicitly. To do so, let''s go through
    the following steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用我们对生成器表达式的了解来生成一个表达式，该表达式将逐个从单词列表中读取单词，并在它们末尾删除换行符的同时将它们转换为小写。这当然可以使用显式的`for`循环来完成。为了做到这一点，让我们按照以下步骤进行：
- en: 'Create a new Jupyter Notebook and create a `words` string, as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Jupyter Notebook，创建一个`words`字符串，如下所示：
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Write the following generator expression to achieve this task, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下生成器表达式来完成此任务，如下所示：
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a list comprehension to get words one by one from the generator expression
    and finally print the list, as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个列表解析来从生成器表达式中逐个获取单词，并最终打印列表，如下所示：
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, we created a one-liner generator expression efficiently using
    a simple `for` loop.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们通过简单的`for`循环有效地创建了一个单行生成器表达式。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Bg5pzi](https://packt.live/2Bg5pzi).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2Bg5pzi](https://packt.live/2Bg5pzi)。
- en: You can also run this example online at [https://packt.live/2YbIo9J](https://packt.live/2YbIo9J).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2YbIo9J](https://packt.live/2YbIo9J)上在线运行此示例。
- en: In the next exercise, we'll extract a list using single words.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用单个单词提取列表。
- en: 'Exercise 6.03: Extracting a List with Single Words'
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.03：提取包含单个单词的列表
- en: 'If we look at the output of the previous exercise, we will notice that due
    to the messy nature of the source data (which is normal in the real world), we
    ended up with a list where, in some cases, we have more than one word together
    as a phrase, separated by a space. To improve this and to get a list of single
    words, we will have to modify the generator expressions. Let''s see how to do
    that:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看上一个练习的输出，我们会注意到，由于源数据的杂乱性质（这在现实世界中是正常的），我们最终得到了一个列表，在某些情况下，我们将多个单词作为一个短语放在一起，由空格分隔。为了改进这一点并得到一个包含单个单词的列表，我们必须修改生成器表达式。让我们看看如何做到这一点：
- en: 'Write the generator expression and then write the equivalent nested `for` loops
    so that we can compare the results:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写生成器表达式，然后编写等效的嵌套`for`循环，以便我们可以比较结果：
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Write an equivalent to the preceding code by using a nested `for` loop, as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用嵌套的`for`循环编写与前面代码等效的代码，如下所示：
- en: '[PRE12]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE13]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We must admit that the generator expression is not only space- and time-saving
    but also a more elegant way to write the same logic.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须承认，生成器表达式不仅节省空间和时间，而且是一种更优雅的方式来编写相同的逻辑。
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YFD5yo](https://packt.live/2YFD5yo).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YFD5yo](https://packt.live/2YFD5yo)。
- en: You can also run this example online at [https://packt.live/3hG4WXO](https://packt.live/3hG4WXO).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3hG4WXO](https://packt.live/3hG4WXO)上在线运行此示例。
- en: To remember how the nested loop works in generator expressions, keep in mind
    that the loops are evaluated from left to right and the final loop variable (in
    our example, which is denoted by the single letter `w`) is given back (thus, we
    could call `strip` and `lower` on it).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住生成器表达式中嵌套循环的工作方式，请记住，循环是从左到右评估的，并且最终的循环变量（在我们的例子中，用单个字母`w`表示）被返回（因此，我们可以对它调用`strip`和`lower`）。
- en: 'The following diagram will help you remember the trick about using nested `for`
    loops in list comprehension or generator expressions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表将帮助您记住在列表解析或生成器表达式中使用嵌套`for`循环的技巧：
- en: '![Figure 6.1: Nested loops illustration'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1：嵌套循环说明](img/B15780_06_01.jpg)'
- en: '](img/B15780_06_01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15780_06_01.jpg](img/B15780_06_01.jpg)'
- en: 'Figure 6.1: Nested loops illustration'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：嵌套循环说明
- en: We have learned about nested `for` loops in generator expressions previously,
    but now we are going to learn about independent `for` loops in a generator expression.
    We will have two output variables from two `for` loops and they must be treated
    as a tuple so that they don't have ambiguous grammar in Python.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经学过在生成器表达式中使用嵌套的`for`循环，但现在我们将学习在生成器表达式中使用独立的`for`循环。我们将从两个`for`循环中获得两个输出变量，并且它们必须被当作一个元组来处理，这样在Python中就不会有语法上的歧义。
- en: 'Create the following two lists:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下两个列表：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You are asked to generate all possible combinations of the values in the `marbles`
    array and `counts` array after being given the preceding two lists. How will you
    do that? Surely using a nested `for` loop and the `append` method, you can accomplish
    the task. How about a generator expression? A more elegant and easy solution is
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求在给出前两个列表后，生成 `marbles` 数组和 `counts` 数组中所有可能的值的组合。你将如何做？当然，使用嵌套 `for` 循环和
    `append` 方法，你可以完成这个任务。那么生成器表达式呢？一个更优雅、更简单的解决方案如下：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This generator expression creates a tuple in each iteration of the simultaneous
    `for` loops. This code is equivalent to the following explicit code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器表达式在同时 `for` 循环的每次迭代中创建一个元组。这段代码等同于以下显式代码：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This generator expression creates a tuple in each iteration of the simultaneous
    `for` loops. Once again, the generator expression is easy, elegant, and efficient
    compared to the `for..in` loop.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器表达式在同时 `for` 循环的每次迭代中创建一个元组。再次强调，与 `for..in` 循环相比，生成器表达式简单、优雅且高效。
- en: Let's move on to the next exercise, where we will examine the `zip` function
    and compare it with the generator expression.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个练习，我们将检查 `zip` 函数并将其与生成器表达式进行比较。
- en: 'Exercise 6.04: The zip Function'
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.04：zip 函数
- en: 'In this exercise, we will examine the `zip` function and compare it with the
    generator expression we wrote in the previous exercise. The problem with the previous
    generator expression is the fact that it produced all possible combinations. For
    instance, if we need to relate countries with their capitals, doing so using a
    generator expression will be difficult. Fortunately, Python gives us a built-in
    function called `zip` for just this purpose:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将检查 `zip` 函数并将其与我们之前练习中编写的生成器表达式进行比较。前一个生成器表达式的缺点是它产生了所有可能的组合。例如，如果我们需要将国家与它们的首都相关联，使用生成器表达式来做将会很困难。幸运的是，Python
    为此目的提供了一个内置函数，称为 `zip`：
- en: 'Open a new Jupyter Notebook and create the following two lists:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 并创建以下两个列表：
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Generate a list of tuples where the first element is the name of the country
    and the second element is the name of the capital by using the following commands:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令生成一个包含元组的列表，其中第一个元素是国家的名称，第二个元素是首都的名称：
- en: '[PRE19]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is not very well represented. It would make more sense if we can use `dict`
    where keys are the names of the countries, while the values are the names of the
    capitals.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这表示得不是很好。如果我们能使用 `dict`，其中键是国家的名称，而值是首都的名称，那就更有意义了。
- en: 'Use the following command, where keys are the names of the countries:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令，其中键是国家的名称：
- en: '[PRE21]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As always, in real life, data is messy. So, the nice equal length lists of countries
    and capitals that we just saw are not always available. The `zip` function cannot
    be used with unequal length lists, because `zip` will stop working as soon as
    one of the lists comes to an end.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如往常一样，在现实生活中，数据是杂乱的。因此，我们刚刚看到的那些国家列表和首都列表长度相等的美好情况并不总是存在的。`zip` 函数不能用于长度不等的长列表，因为一旦其中一个列表到达末尾，`zip`
    就会停止工作。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3hDfKG5](https://packt.live/3hDfKG5).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/3hDfKG5](https://packt.live/3hDfKG5)。
- en: You can also run this example online at [https://packt.live/2CgdOTP](https://packt.live/2CgdOTP).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 [https://packt.live/2CgdOTP](https://packt.live/2CgdOTP) 上运行此示例。
- en: Let's look at the following exercise to understand how we can handle messy data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下练习，以了解我们如何处理杂乱的数据。
- en: 'Exercise 6.05: Handling Messy Data'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.05：处理杂乱数据
- en: 'In this exercise, we''re going to use the `zip` function to handle messy data
    in lists of unequal length. In such a situation, we will use the `ziplongest`
    function from the `itertools` module. Let''s perform the following steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `zip` 函数来处理长度不等的长列表中的杂乱数据。在这种情况下，我们将使用 `itertools` 模块中的 `ziplongest`
    函数。让我们执行以下步骤：
- en: 'Open a new Jupyter Notebook and create two lists of unequal length, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 并创建两个长度不等的长列表，如下所示：
- en: '[PRE23]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the final dictionary. `None` will be displayed as the value for the
    countries that do not have a capital in the capital''s list:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建最终的字典。对于在首都列表中没有首都的国家，将显示 `None` 作为其值：
- en: '[PRE24]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We should pause here for a second and think about how many lines of explicit
    code and difficult-to-understand `if-else` conditional logic we just saved by
    calling a single function and just giving it the two source data lists. It is
    indeed amazing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在这里暂停一下，思考一下通过调用一个函数并仅给它两个源数据列表，我们刚刚节省了多少行显式代码和难以理解的 `if-else` 条件逻辑。这确实很神奇。
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3edKtYf](https://packt.live/3edKtYf).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的源代码，请参阅[https://packt.live/3edKtYf](https://packt.live/3edKtYf)。
- en: You can also run this example online at [https://packt.live/37CsacU](https://packt.live/37CsacU).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在此在线运行此示例[https://packt.live/37CsacU](https://packt.live/37CsacU)。
- en: With these exercises, we are ending the first topic of this chapter. Advanced
    list comprehension, generator expressions, and functions such as `zip` and `ziplongest`
    are some very important tricks that we need to master if we want to write clean,
    efficient, and maintainable code. Code that does not have these three qualities
    are considered subpar in the industry, and we certainly don't want to write such
    code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些练习，我们结束了本章的第一个主题。高级列表解析、生成器表达式以及 `zip` 和 `ziplongest` 等函数是一些我们必须掌握的重要技巧，如果我们想要编写干净、高效且可维护的代码。不具备这三个品质的代码在行业中被认为是次品，我们当然不希望编写这样的代码。
- en: However, we did not cover one important point here, that is, generators. Generators
    are a special type of function that shares behavioral traits with generator expressions.
    However, being functions, they have a broader scope and they are much more flexible.
    We strongly encourage you to learn about them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在这里没有涵盖一个重要的点，那就是生成器。生成器是一种特殊类型的函数，它具有与生成器表达式相似的行为特征。然而，作为函数，它们具有更广泛的范围，并且更加灵活。我们强烈建议您了解它们。
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read more about generators here: [https://wiki.python.org/moin/Generators](https://wiki.python.org/moin/Generators).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多关于生成器的信息：[https://wiki.python.org/moin/Generators](https://wiki.python.org/moin/Generators)。
- en: Data Formatting
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据格式化
- en: 'In this section, we will format a given dataset. The main motivations behind
    formatting data properly are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将格式化一个给定的数据集。正确格式化数据的动机主要包括以下几点：
- en: It helps all the downstream systems have a single and pre-agreed form of data
    for each data point, thus avoiding surprises and, in effect, there is no risk
    which might break the system.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这有助于所有下游系统对每个数据点都有一个单一且预先约定的数据格式，从而避免意外，实际上，没有可能破坏系统的风险。
- en: To produce a human-readable report from lower-level data that is, most of the
    time, created for machine consumption.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主要用于机器消费的底层数据中生成人类可读的报告。
- en: To find errors in data.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了查找数据中的错误。
- en: There are a few ways to perform data formatting in Python. We will begin with
    the modulus `%` operator.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中执行数据格式化有几种方法。我们将从模运算符 `%` 开始。
- en: The % operator
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 百分号运算符
- en: Python gives us the modulus `%` operator to apply basic formatting on data.
    To demonstrate this, we will load the data by reading the `combined_data.csv`
    file, and then we will apply some basic formatting to it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了模运算符 `%` 来对数据进行基本格式化。为了演示这一点，我们将通过读取 `combined_data.csv` 文件来加载数据，然后我们将对其应用一些基本格式化。
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `combined_data.csv` file contains some sample medical data for four individuals.
    The file can be found here: [https://packt.live/310179U](https://packt.live/310179U).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`combined_data.csv` 文件包含四个个体的样本医疗数据。文件可在此处找到：[https://packt.live/310179U](https://packt.live/310179U)。'
- en: 'We can load the data from the CSV file by using the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令从 CSV 文件加载数据：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, we have a list called `raw_data` that contains all the rows of the CSV
    file. Feel free to print it to see what the content of the `.csv` file looks like.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为 `raw_data` 的列表，它包含 CSV 文件的全部行。您可以随意打印它以查看 `.csv` 文件的内容。
- en: 'The output is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.2: Partial output of raw data'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2：原始数据的部分输出'
- en: '](img/B15780_06_02.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15780_06_02.jpg)'
- en: 'Figure 6.2: Partial output of raw data'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：原始数据的部分输出
- en: We will be producing a report on this data. This report will contain one section
    for each data point and will report the name, age, weight, height, history of
    family disease, and finally the present heart condition of the person. These points
    must be clear and easily understandable English sentences.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成关于这些数据的报告。该报告将包含每个数据点的一个部分，并报告姓名、年龄、体重、身高、家族病史以及最终的心脏状况。这些点必须是清晰且易于理解的英文句子。
- en: 'We do this in the following way:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以以下方式做到这一点：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.3: Raw data in a presentable format'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3：以可展示的格式呈现的原始数据](img/B15780_06_03.jpg)'
- en: '](img/B15780_06_03.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15780_06_03.jpg)'
- en: 'Figure 6.3: Raw data in a presentable format'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：以可展示的格式呈现的原始数据
- en: 'The `%` operator is used in two different ways:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`%`运算符有两种不同的用法：'
- en: When used inside a quote, it signifies what kind of data to expect here. `%s`
    stands for string, whereas `%d` stands for integer. If we indicate a wrong data
    type, it will throw an error. Thus, we can effectively use this kind of formatting
    as an error filter in the incoming data.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在引号内使用时，它表示这里期望的数据类型。`%s`代表字符串，而`%d`代表整数。如果我们指示错误的数据类型，它将引发错误。因此，我们可以有效地使用这种格式化作为输入数据的错误过滤器。
- en: When we use the `%` operator outside the quote, it basically tells Python to
    start replacing all the data inside with the values provided for them outside.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在引号外使用`%`运算符时，它基本上告诉Python开始用外部提供的值替换所有内部数据。
- en: Using the format Function
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用格式化函数
- en: In this section, we will be looking at the exact same formatting problem, but
    this time, we will use a more advanced approach. We will use Python's `format`
    function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨完全相同的格式化问题，但这次我们将使用更高级的方法。我们将使用Python的`format`函数。
- en: 'To use the `format` function, we do the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`format`函数，我们执行以下操作：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.4: Data formatted using the format function of the string'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4：使用字符串格式化函数格式化的数据](img/B15780_06_04.jpg)'
- en: '](img/B15780_06_04.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15780_06_04.jpg)'
- en: 'Figure 6.4: Data formatted using the format function of the string'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：使用字符串格式化函数格式化的数据
- en: Notice that we have replaced `%s` with `{}` and, instead of `%` outside the
    quote, we have called the `format` function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将`%s`替换为`{}`，并且不再在引号外使用`%`，而是调用了`format`函数。
- en: 'We will see how powerful the `format` function is by making the previous code
    a lot more readable and understandable. Instead of simple and blank `{}`, we mention
    the key names inside and then use the special Python `**` operation on a `dict`
    to unpack it and give that to the `format` function. It is smart enough to figure
    out how to replace the key names inside the quote with the values from the actual
    `dict` by using the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使之前的代码更加易于阅读和理解来展示`format`函数的强大功能。我们不再使用简单的空白`{}`，而是在其中提及键名，然后使用Python的特殊`**`操作对`dict`进行解包，并将其提供给`format`函数。它足够智能，可以通过以下命令确定如何使用实际的`dict`中的值替换引号内的键名：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.5: Reading a file using the ** operation'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5：使用**操作读取文件](img/B15780_06_05.jpg)'
- en: '](img/B15780_06_05.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15780_06_05.jpg)'
- en: 'Figure 6.5: Reading a file using the ** operation'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：使用**操作读取文件
- en: This approach is indeed much more concise and maintainable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确实更加简洁且易于维护。
- en: 'Exercise 6.06: Data Representation Using {}'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.06：使用{}进行数据表示
- en: 'In this exercise, the `{}` notation inside the quote is powerful and we can
    change our data representation significantly by using it, which means we can apply
    basic data transformation such as printing up to a certain decimal place, changing
    binary to decimal numbers, and more just using this operator and without writing
    many lines of code. Let''s perform the following steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，引号内的`{}`符号非常强大，我们可以通过使用它来显著改变我们的数据表示，这意味着我们可以仅使用这个运算符而不需要编写很多代码来实现基本的数据转换，例如打印到特定的十进制位，将二进制数转换为十进制数等。让我们执行以下步骤：
- en: 'Change a decimal number into its binary form by using the following command:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将十进制数字转换为二进制形式：
- en: '[PRE30]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Print a string that''s center oriented:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印一个居中的字符串：
- en: '[PRE32]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is as follows:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE33]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Printing a string that''s center oriented, but this time with padding on both
    sides:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印一个居中的字符串，但这次在两侧都有填充：
- en: '[PRE34]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output is as follows:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE35]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As we've already mentioned, the `format` statement is a powerful one.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`format`语句非常强大。
- en: In this exercise, we saw how powerful the `{}` notation is and how its use can
    benefit data representation immensely.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了`{}`符号的强大功能以及它的使用如何极大地提高数据表示。
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3dbNKpG](https://packt.live/3dbNKpG).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3dbNKpG](https://packt.live/3dbNKpG)。
- en: You can also run this example online at [https://packt.live/2Ygm9zH](https://packt.live/2Ygm9zH).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/2Ygm9zH](https://packt.live/2Ygm9zH)上运行这个示例。
- en: '**Formatting Dates**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**日期格式化**'
- en: It is important to format a date as dates have various formats, depending on
    what the source of the data is, and it may need several transformations inside
    the data wrangling pipeline.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化日期很重要，因为日期的格式取决于数据来源，并且在数据清洗管道中可能需要多次转换。
- en: 'We can use the familiar date formatting notations with `format` as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用熟悉的日期格式化符号与`format`一起使用，如下所示：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.6: Data after being formatted'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6：格式化后的数据'
- en: '](img/B15780_06_06.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_06_06.jpg)'
- en: 'Figure 6.6: Data after being formatted'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：格式化后的数据
- en: Compare this with the actual output of `datetime.utcnow` and you will see the
    power of this expression easily.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与`datetime.utcnow`的实际输出进行比较，你将很容易看到这个表达式的强大之处。
- en: Identifying and Cleaning Outliers
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别和清理异常值
- en: 'When confronted with real-world data, we often see a specific thing in a set
    of records: there are some data points that do not fit with the rest of the records.
    They have some values that are too big, too small, or that are completely missing.
    These kinds of records are called `outliers`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 面对现实世界的数据时，我们经常在记录集中看到一些特定的事情：有一些数据点与其余记录不匹配。它们有一些值太大、太小，或者完全缺失。这类记录被称为`异常值`。
- en: Statistically, there is a proper definition and idea about what an outlier means.
    And often, you need deep domain expertise to understand when to call a particular
    record an outlier. However, in this exercise, we will look into some basic techniques
    that are commonplace for flagging and filtering outliers in real-world data for
    day-to-day work.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学上，有一个关于异常值含义的适当定义和概念。通常，你需要深入的专业领域知识来理解何时将某个特定记录称为异常值。然而，在这个练习中，我们将探讨一些在现实世界数据中标记和过滤异常值的基本技术，这些技术在日常工作中很常见。
- en: 'Exercise 6.07: Outliers in Numerical Data'
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.07：数值数据中的异常值
- en: 'In this exercise, we will construct a notion of an outlier based on numerical
    data. Imagine a cosine curve. If you remember the math for this from high school,
    then a cosine curve is a very smooth curve within the limit of `[1, -1]`. We will
    plot this cosine curve using the `plot` function of `matplotlib`. Let''s go through
    the following steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将基于数值数据构建异常值的概念。想象一个余弦曲线。如果你还记得高中数学中的这个公式，那么余弦曲线是在`[1, -1]`范围内的一个非常平滑的曲线。我们将使用`matplotlib`的`plot`函数绘制这个余弦曲线。让我们按以下步骤进行：
- en: 'To construct a cosine curve, execute the following command:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建一个余弦曲线，请执行以下命令：
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Plot the data by using the following code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码绘制数据：
- en: '[PRE38]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is as follows:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.7: Cosine wave'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.7：余弦波'
- en: '](img/B15780_06_07.jpg)'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_06_07.jpg)'
- en: 'Figure 6.7: Cosine wave'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.7：余弦波
- en: As we can see, it is a very smooth curve, and there are no outliers. However,
    we are going to introduce some now.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所见，它是一个非常平滑的曲线，没有异常值。然而，我们现在要引入一些。
- en: 'Introduce some outliers by using the following command:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令引入一些异常值：
- en: '[PRE39]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Plot the curve:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制曲线：
- en: '[PRE40]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output is as follows:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.8: Wave with outliers'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.8：含异常值的波'
- en: '](img/B15780_06_08.jpg)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_06_08.jpg)'
- en: 'Figure 6.8: Wave with outliers'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：含异常值的波
- en: We can see that we have successfully introduced two values in the curve, which
    broke the smoothness and hence can be considered as outliers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们已经成功地在曲线上引入了两个值，这打破了平滑性，因此可以被认为是异常值。
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3fDRzFZ](https://packt.live/3fDRzFZ).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3fDRzFZ](https://packt.live/3fDRzFZ)。
- en: You can also run this example online at [https://packt.live/2YEstj6](https://packt.live/2YEstj6).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/2YEstj6](https://packt.live/2YEstj6)上在线运行此示例。
- en: 'A good way to detect whether our dataset has an outlier is to create a box
    plot. A box plot is a way of plotting numerical data based on their central tendency
    and some `buckets` (in reality, we call them `quartiles`). In a box plot, the
    outliers are usually drawn as separate points. The `matplotlib` library helps
    draw box plots out of a series of numerical data, which isn''t hard at all. This
    is how we do it:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 检测我们的数据集是否有异常值的一个好方法是创建箱线图。箱线图是一种基于数据的中心趋势和一些`桶`（实际上，我们称之为`四分位数`）来绘制数值数据的方式。在箱线图中，异常值通常被绘制为单独的点。`matplotlib`库帮助从一系列数值数据中绘制箱线图，这并不难。这就是我们这样做的方式：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once you execute the preceding code, you will be able to see that there is
    a nice box plot where the two outliers that we created are clearly shown, just
    like in the following diagram:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行前面的代码，你将能够看到一个很好的箱线图，其中清楚地显示了我们所创建的两个异常值，就像以下图示：
- en: '![Figure 6.9: Box plot with outliers'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.9: Box plot with outliers]'
- en: '](img/B15780_06_09.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15780_06_09.jpg]'
- en: 'Figure 6.9: Box plot with outliers'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9：包含异常值的箱线图
- en: Z-score
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Z-score
- en: A `+3` or less than `-3` is considered an outlier. We can use this concept with
    a bit of help from the excellent SciPy and `pandas` libraries to filter out the
    outliers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`+3` 或小于 `-3` 被认为是异常值。我们可以借助优秀的 SciPy 和 `pandas` 库的概念来过滤掉异常值。'
- en: 'Use SciPy and calculate the z-score by using the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SciPy 并使用以下命令计算 z-score：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.10: The z-score values'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.10: The z-score values]'
- en: '](img/B15780_06_10.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15780_06_10.jpg]'
- en: 'Figure 6.10: The z-score values'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10：z-score 值
- en: With this, we have observed how to calculate a z-score. In the following exercise,
    we will learn how to use this to remove outliers.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经观察到了如何计算 z-score。在接下来的练习中，我们将学习如何使用这个方法来移除异常值。
- en: 'Exercise 6.08: The Z-Score Value to Remove Outliers'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.08：移除异常值的 Z-Score 值
- en: 'This exercise will demonstrate how to get rid of outliers in a set of data.
    In the previous exercise, we calculated the z-score of each data point. In this
    exercise, we will continue directly from the previous exercise and use the z-score
    values to remove outliers from our data. To do so, let''s go through the following
    steps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将演示如何从一组数据中去除异常值。在上一个练习中，我们计算了每个数据点的 z-score。在这个练习中，我们将直接从上一个练习继续，并使用 z-score
    值来从我们的数据中移除异常值。为此，让我们按照以下步骤进行：
- en: 'Import `pandas` and create a DataFrame:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `pandas` 并创建一个 DataFrame：
- en: '[PRE43]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Assign outliers with a `z-score` value of less than `3`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `z-score` 值小于 `3` 的异常值分配：
- en: '[PRE44]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Use the `print` function to print the new and old shape:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `print` 函数打印新的和旧的形状：
- en: '[PRE45]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output is as follows:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE46]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: From the two printed data points (`49, 1` and `50, 1`), it is clear that the
    derived DataFrame has two less rows. These are our outliers.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从打印的两个数据点（`49, 1` 和 `50, 1`）来看，很明显，导出的 DataFrame 有两行更少。这些就是我们的异常值。
- en: Note
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2BgEzaf](https://packt.live/2BgEzaf).
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/2BgEzaf](https://packt.live/2BgEzaf)。
- en: You can also run this example online at [https://packt.live/2UXnZmV](https://packt.live/2UXnZmV).
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在 [https://packt.live/2UXnZmV](https://packt.live/2UXnZmV) 上在线运行此示例。
- en: Detecting and getting rid of outliers is a time consuming and critical process
    in any data wrangling pipeline. They need deep domain knowledge, expertise in
    descriptive statistics, mastery over the programming language (and all the useful
    libraries), and a lot of caution. We recommend being very careful when performing
    this operation on a dataset.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 检测和去除异常值是任何数据整理流程中耗时且关键的过程。这需要深厚的领域知识、描述性统计学的专业知识、对编程语言（以及所有有用的库）的掌握，以及大量的谨慎。我们建议在执行此操作时非常小心。
- en: Levenshtein Distance
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Levenshtein 距离
- en: '`python-Levenshtein`.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`python-Levenshtein`'
- en: Additional Software Required for This Section
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本节所需额外软件
- en: 'The code for this exercise depends on two additional libraries. We need to
    install `SciPy` and `python-Levenshtein`, libraries. To install the libraries,
    type the following command in the running Jupyter Notebook:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码依赖于两个额外的库。我们需要安装 `SciPy` 和 `python-Levenshtein` 库。要安装库，请在运行的 Jupyter Notebook
    中输入以下命令：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you''re facing issues while installing the Levenshtein package, you can
    try:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在安装 Levenshtein 包时遇到问题，你可以尝试：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Exercise 6.09: Fuzzy String Matching'
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.09：模糊字符串匹配
- en: 'In this exercise, we will look into a slightly different problem that, at first
    glance, may look like an outlier. However, upon careful examination, we will see
    that it is indeed not, and we will learn about a useful concept that is sometimes
    referred to as fuzzy matching of strings. To do so, let''s go through the following
    steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将探讨一个稍微不同的问题，乍一看可能看起来像异常值。然而，经过仔细检查，我们会发现它确实不是，我们将学习一个有时被称为字符串模糊匹配的有用概念。为此，让我们按照以下步骤进行：
- en: 'Create the load data of a ship on three different dates:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个不同日期的船舶负载数据：
- en: '[PRE49]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you look carefully, you will notice that the name of the ship is spelled
    differently in all three different cases. Let's assume that the actual name of
    the ship is `Sea Princess`. From a normal perspective, it does look like there
    has been a human error and that the data points do describe a single ship. Removing
    two of them on a strict basis of outliers may not be the best thing to do.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您仔细观察，您会注意到船名在三种不同情况下拼写不同。让我们假设实际的船名是`Sea Princess`。从正常的角度来看，它确实看起来像有人犯了错误，数据点确实描述了同一艘船。在严格的基础上基于异常值移除其中两个可能不是最好的做法。
- en: 'Then, we simply need to import the `distance` function from it and pass two
    strings to it to calculate the distance between them:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们只需从其中导入`distance`函数，并传递两个字符串给它来计算它们之间的距离：
- en: '[PRE50]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output is as follows:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE51]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We will notice that the distance between the strings is different. It is `0`
    when they are identical, and it is a positive integer when they are not. We can
    use this concept in our data wrangling jobs and say that strings with a distance
    less than or equal to a certain number is the same string.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会注意到字符串之间的距离不同。当它们相同的时候，距离是`0`，当它们不同的时候，距离是一个正整数。我们可以在我们的数据处理工作中使用这个概念，并说距离小于或等于某个数字的字符串是相同的字符串。
- en: Note
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/37Lx3An](https://packt.live/37Lx3An).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/37Lx3An](https://packt.live/37Lx3An)。
- en: You can also run this example online at [https://packt.live/3ehva0M](https://packt.live/3ehva0M).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3ehva0M](https://packt.live/3ehva0M)上在线运行此示例。
- en: Here, again, we need to be cautious about when and how to use this kind of fuzzy
    string matching. Sometimes, they are needed, and other times, they will result
    in a very bad bug.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们同样需要谨慎考虑何时以及如何使用这种模糊字符串匹配。有时，它们是必需的，而有时，它们会导致非常糟糕的错误。
- en: 'Activity 6.01: Handling Outliers and Missing Data'
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动六.01：处理异常值和缺失数据
- en: In this activity, we will identify and get rid of outliers. Here, we have a
    CSV file. The goal here is to clean the data by using the knowledge that we have
    learned about so far and come up with a nicely formatted DataFrame. Identify the
    type of outliers and their effect on the data and clean the messy data.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，我们将识别并移除异常值。这里我们有一个CSV文件。我们的目标是使用我们迄今为止学到的知识来清理数据，并创建一个格式良好的DataFrame。识别异常值的类型及其对数据的影响，并清理混乱的数据。
- en: The dataset that we have used here can be found in the `visit_data.csv` file.
    This file contains data generated by a random data generator, and it contains
    people's names, their `gender`, `email_id`, `ip_address`, and the number of visits
    they made to a particular web page.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的数据集可以在`visit_data.csv`文件中找到。此文件包含由随机数据生成器生成的数据，其中包含人们的姓名、他们的`gender`、`email_id`、`ip_address`以及他们访问特定网页的次数。
- en: Note
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The dataset can be found at [https://packt.live/2YajrLJ](https://packt.live/2YajrLJ).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集可以在[https://packt.live/2YajrLJ](https://packt.live/2YajrLJ)找到。
- en: 'The steps that will help you solve this activity are as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助您解决此活动的步骤如下：
- en: Read the `visit_data.csv` file.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取`visit_data.csv`文件。
- en: Check for duplicates.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查重复项。
- en: Check whether any essential column contains `NaN`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有任何重要列包含`NaN`。
- en: Get rid of the outliers.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除异常值。
- en: Report the size difference.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 报告大小差异。
- en: Create a box plot to check for outliers.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个箱线图来检查异常值。
- en: Get rid of any outliers.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除任何异常值。
- en: 'The final output should look like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出应如下所示：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15780_Solution_Final_RK.xhtml#_idTextAnchor320).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15780_Solution_Final_RK.xhtml#_idTextAnchor320)找到。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about interesting ways to deal with list data by
    using a generator expression. They are easy and elegant and, once mastered, they
    give us a powerful trick that we can use repeatedly to simplify several common
    data wrangling tasks. We also examined different ways to format data. Formatting
    data is not only useful for preparing beautiful reports – it is often very important
    to guarantee data integrity for the downstream system.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用生成器表达式处理列表数据的一些有趣方法。它们既简单又优雅，一旦掌握，就能给我们提供一个强大的技巧，我们可以反复使用它来简化几个常见的数据处理任务。我们还探讨了不同的数据格式化方法。格式化数据不仅对准备漂亮的报告有用——对于保证下游系统的数据完整性通常也非常重要。
- en: We ended this chapter by checking out some methods to identify and remove outliers.
    This is important for us because we want our data to be properly prepared and
    ready for all our fancy downstream analysis jobs. We also observed how important
    it is to take the time to and use domain expertise to set up rules for identifying
    outliers, as doing this incorrectly can do more harm than good.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章结束时，通过检查一些识别和去除异常值的方法来结束本章。这对我们来说很重要，因为我们希望我们的数据得到适当的准备，并准备好进行所有我们的复杂下游分析任务。我们还观察到，花时间并利用领域专业知识来制定识别异常值的规则是多么重要，因为这样做不正确可能会造成比好处更大的伤害。
- en: In the next chapter, we will cover how to read web pages, XML files, and APIs.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何阅读网页、XML文件和API。
