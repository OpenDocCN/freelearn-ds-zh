- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Developing a RESTful API with FastAPI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FastAPI开发RESTful API
- en: Now it’s time to begin learning about **FastAPI**! In this chapter, we’ll cover
    the basics of FastAPI. We’ll go through very simple and focused examples that
    will demonstrate the different features of FastAPI. Each example will lead to
    a working API endpoint that you’ll be able to test yourself using HTTPie. In the
    final section of this chapter, we’ll show you a more complex FastAPI project,
    with routes split across several files. It will give you an overview of how you
    can structure your own application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始学习**FastAPI**了！在这一章中，我们将介绍FastAPI的基础知识。我们将通过非常简单且集中的示例来演示FastAPI的不同特性。每个示例都将通向一个可用的API端点，你可以使用HTTPie进行测试。在本章的最后一部分，我们将展示一个更复杂的FastAPI项目，其中的路由分布在多个文件中。它将为你提供一个如何构建自己应用程序的概览。
- en: By the end of this chapter, you’ll know how to start a FastAPI application and
    how to write an API endpoint. You’ll also be able to handle request data and build
    a response according to your own logic. Finally, you’ll learn a way to structure
    a FastAPI project into several modules that will be easier to maintain and work
    with in the long term.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到了本章结束时，你将知道如何启动FastAPI应用程序以及如何编写API端点。你还将能够处理请求数据，并根据自己的逻辑构建响应。最后，你将学会一种将FastAPI项目结构化为多个模块的方法，这样长期来看，项目更容易维护和操作。
- en: 'In this chapter, we’ll cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主要内容：
- en: Creating the first endpoint and running it locally
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建第一个端点并在本地运行
- en: Handling request parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理请求参数
- en: Customizing the response
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义响应
- en: Structuring a bigger project with multiple routers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个路由器构建更大的项目
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You’ll need a Python virtual environment, as we set up in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024),
    *Python Development* *Environment Setup*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要一个Python虚拟环境，就像我们在[*第1章*](B19528_01.xhtml#_idTextAnchor024)中设置的那样，*Python开发*
    *环境设置*。
- en: 'You’ll find all the code examples of this chapter in the dedicated GitHub repository:
    [https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03)..'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个专门的GitHub仓库中找到本章的所有代码示例：[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03)。
- en: Creating a first endpoint and running it locally
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建第一个端点并在本地运行
- en: 'FastAPI is a framework that is easy to use and quick to write. In the following
    example, you’ll realize that this is not just a promise. In fact, creating an
    API endpoint involves just a few lines:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI是一个易于使用且快速编写的框架。在接下来的示例中，你会发现这不仅仅是一个承诺。事实上，创建一个API端点只需要几行代码：
- en: chapter03_first_endpoint_01.py
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_first_endpoint_01.py
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_first_endpoint_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_first_endpoint_01.py)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_first_endpoint_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_first_endpoint_01.py)'
- en: 'In this example, we define a `GET` endpoint at the root path, which always
    returns the `{"hello": "world"}` JSON response. To do this, we first instantiate
    a FastAPI object, `app`. It will be the main application object that will wire
    all the API routes.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，我们在根路径上定义了一个`GET`端点，它总是返回`{"hello": "world"}`的JSON响应。为了做到这一点，我们首先实例化一个FastAPI对象，`app`。它将是主应用对象，负责管理所有API路由。'
- en: Then, we simply define a coroutine that contains our route logic, the **path
    operation function**. Its return value is automatically handled by FastAPI to
    produce a proper HTTP response with a JSON payload.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们简单地定义一个协程，包含我们的路由逻辑，即**路径操作函数**。其返回值会被FastAPI自动处理，生成一个包含JSON负载的正确HTTP响应。
- en: Here, the most important part of this code is probably the line starting with
    `@`, which can be found above the coroutine definition, the `app.get("/")(hello_world)`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这段代码中最重要的部分可能是以`@`开头的那一行，可以在协程定义之上找到，`app.get("/")(hello_world)`。
- en: FastAPI exposes *one decorator per HTTP method* to add new routes to the application.
    The one shown here adds a `GET` endpoint with the **path** as the first argument.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI为每个HTTP方法提供*一个装饰器*，用来向应用程序添加新路由。这里展示的装饰器添加了一个以**路径**作为第一个参数的`GET`端点。
- en: 'Now, let’s run this API. Copy the example to the root of your project and run
    the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行这个 API。将示例代码复制到项目的根目录，并运行以下命令：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we mentioned in [*Chapter 2*](B19528_02.xhtml#_idTextAnchor032), *Python
    Programming Specificities*, in the *Asynchronous I/O* section, FastAPI exposes
    an `:`, and, finally, the variable name of your ASGI app instance (in our example,
    this is `app`). Afterward, it takes care of instantiating the application and
    exposing it on your local machine.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第二章*](B19528_02.xhtml#_idTextAnchor032)中提到的，*Python 编程特性*部分的 *异步 I/O*
    小节中，FastAPI 会暴露一个 `:`，最后是你的 ASGI 应用实例的变量名（在我们的示例中是 `app`）。之后，它会负责实例化应用并在你的本地机器上暴露它。
- en: 'Let’s try our endpoint with HTTPie. Open another terminal and run the following
    command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用 HTTPie 来测试我们的端点。打开另一个终端并运行以下命令：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It works! As you can see, we did get a JSON response with the payload we wanted,
    using just a few lines of Python and a command!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效！正如你所见，我们确实得到了一个带有我们所需负载的 JSON 响应，只用了几行 Python 代码和一个命令！
- en: 'One of the most beloved features of FastAPI is the *automatic interactive documentation*.
    If you open the `http://localhost:8000/docs` URL in your browser, you should get
    a web interface that looks similar to the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 最受欢迎的功能之一是 *自动交互式文档*。如果你在浏览器中打开 `http://localhost:8000/docs` URL，你应该能看到一个类似于以下截图的网页界面：
- en: '![Figure 3.1 – The FastAPI automatic interactive documentation](img/Figure_3.1_B19528.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – FastAPI 自动交互式文档](img/Figure_3.1_B19528.jpg)'
- en: Figure 3.1 – The FastAPI automatic interactive documentation
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – FastAPI 自动交互式文档
- en: FastAPI will automatically list all your defined endpoints and provide documentation
    about the expected inputs and outputs. You can even try each endpoint directly
    in this web interface. Under the hood, it relies on the OpenAPI specification
    and the associated tools from Swagger. You can read more about this on its official
    website at [https://swagger.io/](https://swagger.io/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 会自动列出你所有定义的端点，并提供关于期望输入和输出的文档。你甚至可以直接在这个网页界面中尝试每个端点。在背后，它依赖于 OpenAPI
    规范和来自 Swagger 的相关工具。你可以在其官方网站 [https://swagger.io/](https://swagger.io/) 阅读更多关于这方面的信息。
- en: That’s it! You’ve created your very first API with FastAPI. Of course, this
    is just a very simple example, but next, you’ll learn how to handle input data
    and start making meaningful things!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你已经用 FastAPI 创建了你的第一个 API。当然，这只是一个非常简单的示例，但接下来你将学习如何处理输入数据，并开始做一些有意义的事情！
- en: On the shoulder of giants
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 巨人的肩膀
- en: 'It’s worth noting that FastAPI is built upon two main Python libraries: Starlette,
    a low-level ASGI web framework ([https://www.starlette.io/](https://www.starlette.io/)),
    and Pydantic, a data validation library based on type hints ([https://pydantic-docs.helpmanual.io/](https://pydantic-docs.helpmanual.io/)).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，FastAPI 基于两个主要的 Python 库构建：Starlette，一个低级 ASGI Web 框架（[https://www.starlette.io/](https://www.starlette.io/)），以及
    Pydantic，一个基于类型提示的数据验证库（[https://pydantic-docs.helpmanual.io/](https://pydantic-docs.helpmanual.io/)）。
- en: Handling request parameters
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求参数
- en: The main goal of a **representational state transfer** (**REST**) API is to
    provide a structured way to interact with data. As such, it’s crucial for the
    end user to send some information to tailor the response they need, such as path
    parameters, query parameters, body payloads, headers, and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**表现状态转移**（**REST**）API 的主要目标是提供一种结构化的方式来与数据交互。因此，最终用户必须发送一些信息来定制他们需要的响应，例如路径参数、查询参数、请求体负载、头部等。'
- en: 'Web frameworks usually ask you to manipulate a request object to retrieve the
    parts you are interested in and manually apply validation to handle them. However,
    that’s not necessary with FastAPI! Indeed, it allows you to define all of your
    parameters declaratively. Then, it’ll automatically retrieve them in the request
    and apply validation based on the type hints. This is why we introduced type hinting
    in [*Chapter 2*](B19528_02.xhtml#_idTextAnchor032), *Python Programming Specificities*:
    it’s used by FastAPI to perform data validation!'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Web 框架通常要求你操作一个请求对象来获取你感兴趣的部分，并手动应用验证来处理它们。然而，FastAPI 不需要这样做！实际上，它允许你声明性地定义所有参数。然后，它会自动在请求中获取它们，并根据类型提示应用验证。这就是为什么我们在
    [*第二章*](B19528_02.xhtml#_idTextAnchor032)中介绍了类型提示：FastAPI 就是用它来执行数据验证的！
- en: Next, we’ll explore how you can use this feature to retrieve and validate this
    input data from different parts of the request.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索如何利用这个功能来从请求的不同部分获取和验证输入数据。
- en: Path parameters
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径参数
- en: 'The API path is the main thing that the end user will interact with. Therefore,
    it’s a good spot for dynamic parameters. A typical example is to put the unique
    identifier of an object we want to retrieve, such as `/users/123`. Let’s examine
    how to define this with FastAPI:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: API 路径是最终用户将与之交互的主要位置。因此，它是动态参数的好地方。一个典型的例子是将我们想要检索的对象的唯一标识符放在路径中，例如 `/users/123`。让我们看看如何在
    FastAPI 中定义这个：
- en: chapter03_path_parameters_01.py
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_path_parameters_01.py
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_01.py)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_01.py)'
- en: In this example, we defined an API that expects an integer in the last part
    of its path. We did this by putting the parameter name in the path around curly
    braces. Then, we defined this same parameter as an argument for our path operation
    function. Notice that we add a type hint to specify that the parameter is an integer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们定义了一个 API，它期望在其路径的最后部分传递一个整数。我们通过将参数名称放在花括号中定义路径来做到这一点。然后，我们将这个参数作为路径操作函数的参数进行了定义。请注意，我们添加了一个类型提示来指定参数是整数。
- en: Let’s run this example. You can refer to the previous *Creating a first endpoint
    and running it locally* section, to learn how to run a FastAPI app with Uvicorn.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个示例。你可以参考之前的 *创建第一个端点并在本地运行* 部分，了解如何使用 Uvicorn 运行 FastAPI 应用程序。
- en: 'First, we’ll try to make a request that omits our path parameter:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将尝试发起一个省略路径参数的请求：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We get a response with a `404` status. That’s expected: our route awaits a
    parameter after `/users`, so if we omit it, it simply doesn’t match any pattern.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个 `404` 状态的响应。这是预期的：我们的路由在 `/users` 后面期待一个参数，如果我们省略它，它就不会匹配任何模式。
- en: 'Let’s now try with a proper integer parameter:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用一个正确的整数参数：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It works! We get a `200` status, and the response does contain the integer we
    passed in the parameter. Notice that it has been properly *cast* as an integer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它运行成功了！我们得到了 `200` 状态，并且响应确实包含了我们传递的整数。请注意，它已经被正确地 *转换* 成了整数。
- en: 'So, what happens if we pass a value that’s not a valid integer? Let’s find
    out:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递的值不是有效的整数会发生什么？让我们来看看：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We get a response with a `422` status! Since `abc` is not a valid integer, the
    validation fails and outputs an error. Notice that we have a very detailed and
    structured error response telling us exactly which element caused the error and
    why. All we need to do to trigger this validation is to *type hint* our parameter!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个 `422` 状态的响应！由于 `abc` 不是有效的整数，验证失败并输出了错误。请注意，我们有一个非常详细和结构化的错误响应，准确告诉我们哪个元素导致了错误以及原因。我们触发这种验证的唯一要求就是
    *类型提示* 我们的参数！
- en: 'Of course, you are not limited to just one path parameter. You can have as
    many as you want, with different types. In the following example, we’ve added
    a `type` parameter of the string type:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不仅仅限于一个路径参数。你可以有任意多个路径参数，类型可以各不相同。在以下示例中，我们添加了一个字符串类型的 `type` 参数：
- en: chapter03_path_parameters_02.py
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_path_parameters_02.py
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_02.py)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_02.py)'
- en: This works well, but the endpoint will accept any string as the `type` parameter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法很有效，但是端点将接受任何字符串作为 `type` 参数。
- en: Limiting allowed values
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制允许的值
- en: 'So, what if we just want to accept a limited set of values? Once again, we’ll
    lean on type hinting. Python has a very useful class for this: `Enum`. An enumeration
    is a way to list all the valid values for a specific kind of data. Let’s define
    an `Enum` class that will list the different types of users:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想接受一组有限的值怎么办？再次，我们将依赖类型提示。Python 中有一个非常有用的类：`Enum`。枚举是列出特定类型数据所有有效值的一种方式。让我们定义一个
    `Enum` 类来列出不同类型的用户：
- en: chapter03_path_parameters_03.py
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_path_parameters_03.py
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_03.py)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_03.py)'
- en: 'To define a string enumeration, we inherit from both the `str` type and the
    `Enum` class. Then, we simply list the allowed values as class properties: the
    property name and its actual string value. Finally, we only have to type hint
    the `type` argument with this class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个字符串枚举，我们需要同时继承 `str` 类型和 `Enum` 类。然后，我们简单地将允许的值列出为类属性：属性名称及其实际字符串值。最后，我们只需要为
    `type` 参数指定此类的类型提示：
- en: chapter03_path_parameters_03.py
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_path_parameters_03.py
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_03.py)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_03.py)'
- en: 'If you run this example and call the endpoint with a type that is not in the
    enumeration, you’ll get the following response:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此示例，并调用一个类型不在枚举中的端点，你将得到以下响应：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, you get a nice validation error with the allowed values for
    this parameter!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以获得一个非常好的验证错误，显示此参数允许的值！
- en: Advanced validation
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级验证
- en: 'We can take one step further by defining more advanced validation rules, particularly
    for numbers and strings. In this case, the type of hint is no longer enough. We’ll
    rely on the functions provided by FastAPI, allowing us to set some options on
    each of our parameters. For path parameters, the function is named `Path`. In
    the following example, we’ll only allow an `id` argument that is greater than
    or equal to `1`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步通过定义更高级的验证规则，特别是对于数字和字符串。在这种情况下，类型提示已经不再足够。我们将依赖 FastAPI 提供的函数，允许我们为每个参数设置一些选项。对于路径参数，这个函数叫做
    `Path`。在以下示例中，我们只允许一个大于或等于 `1` 的 `id` 参数：
- en: chapter03_path_parameters_04.py
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_path_parameters_04.py
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_04.py)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_04.py)'
- en: 'There are several things to pay attention to here: the result of `Path` is
    used as a *default value* for the `id` argument in the path operation function.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的事项：`Path` 的结果作为路径操作函数中 `id` 参数的*默认值*。
- en: 'Additionally, you can see that we use the `Path`. Indeed, it expects the default
    value for the parameter as the first argument. In this scenario, we don’t want
    a default value: the parameter is required. Therefore, ellipses are here to tell
    FastAPI that we don’t want a default value.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以看到我们使用了 `Path`。事实上，它期望参数的默认值作为第一个参数。在这种情况下，我们不想要默认值：该参数是必需的。因此，省略号用来告诉
    FastAPI 我们不希望有默认值。
- en: Ellipsis doesn’t always mean this in Python
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 省略号在 Python 中并不总是意味着这个
- en: 'Using the ellipsis symbol to specify that a parameter is required, as we show
    here, is specific to FastAPI: it’s the choice of FastAPI creators to use it like
    this. In other Python programs, this symbol could be used for another means.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用省略号符号来指定参数是必需的，如我们这里展示的，这是 FastAPI 特有的：这是 FastAPI 创建者的选择，决定使用这种方式。在其他 Python
    程序中，这个符号可能有不同的含义。
- en: 'Then, we can add the keyword arguments we are interested in. In our example,
    we use `ge`, greater than or equal to, and its associated value. Here is the list
    of available keywords to validate numbers:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加我们感兴趣的关键字参数。在我们的示例中，我们使用 `ge`，大于或等于，以及其关联的值。以下是验证数字时可用的关键字列表：
- en: '`gt`: Greater than'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gt`: 大于'
- en: '`ge`: Greater than or equal to'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ge`: 大于或等于'
- en: '`lt`: Less than'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lt`: 小于'
- en: '`le`: Less than or equal to'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`le`: 小于或等于'
- en: 'There are also validation options for string values, which are based on *length*
    and *regular expression*. In the following example, we want to define a path parameter
    that accepts license plates in the form of AB-123-CD (French license plates).
    A first approach would be to force the string to be a length of `9` (that is,
    two letters, a dash, three digits, a dash, and two letters):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还有针对字符串值的验证选项，这些选项基于*长度*和*正则表达式*。在以下示例中，我们想定义一个路径参数，用来接受以 AB-123-CD（法国车牌）的形式出现的车牌号。一种方法是强制字符串的长度为
    `9`（即两个字母，一个连字符，三个数字，一个连字符，再加上两个字母）：
- en: chapter03_path_parameters_05.py
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_path_parameters_05.py
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_05.py)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_05.py)'
- en: 'Now we just have to define the `min_length` and `max_length` keyword arguments,
    just as we did for the number of validations. Of course, a better solution for
    this use case is to use a regular expression to validate the license plate number:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需定义 `min_length` 和 `max_length` 关键字参数，就像我们为数字验证所做的一样。当然，针对这种用例的更好解决方案是使用正则表达式来验证车牌号码：
- en: chapter03_path_parameters_06.py
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_path_parameters_06.py
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_06.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_06.py)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_06.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_06.py)'
- en: Thanks to this regular expression, we only accept strings that exactly match
    the license plate format. Notice that the regular expression is prefixed with
    `r`. Just like `f-strings`, this is a Python syntax that is used to indicate that
    the following string should be considered a regular expression.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个正则表达式，我们只接受与车牌格式完全匹配的字符串。请注意，正则表达式前面有一个 `r`。就像 `f-strings` 一样，这是 Python
    语法，用于表示接下来的字符串应被视为正则表达式。
- en: Parameter metadata
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 参数元数据
- en: Data validation is not the only option accepted by the parameter function. You
    can also set options that will add information about the parameter in the automatic
    documentation, such as `title`, `description`, and `deprecated`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数据验证并不是参数函数唯一接受的选项。你还可以设置其他选项，用于在自动生成的文档中添加关于参数的信息，例如 `title`、`description`
    和 `deprecated`。
- en: Now you should be able to define path parameters and apply some validation to
    them. Other useful parameters to put inside the URL are **query parameters**.
    We’ll discuss them next.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够定义路径参数并对其应用一些验证。另一个有用的参数是**查询参数**。我们接下来将讨论它们。
- en: Query parameters
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询参数
- en: 'Query parameters are a common way to add some dynamic parameters to a URL.
    You can find them at the end of the URL in the following form: `?param1=foo&param2=bar`.
    In a REST API, they are commonly used on read endpoints to apply pagination, a
    filter, a sorting order, or selecting fields.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数是一种常见的向 URL 添加动态参数的方式。你可以在 URL 末尾找到它们，形式如下：`?param1=foo&param2=bar`。在 REST
    API 中，它们通常用于读取端点，以应用分页、过滤器、排序顺序或选择字段。
- en: 'You’ll discover that they are quite straightforward to define with FastAPI.
    In fact, they use the exact same syntax as path parameters:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，使用 FastAPI 定义它们是相当简单的。实际上，它们使用与路径参数完全相同的语法：
- en: chapter03_query_parameters_01.py
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_query_parameters_01.py
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_01.py)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_01.py)'
- en: 'You simply have to declare them as arguments of your path operation function.
    If they don’t appear in the path pattern, as they do for path parameters, FastAPI
    automatically considers them to be query parameters. Let’s try it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要将它们声明为路径操作函数的参数。如果它们没有出现在路径模式中，就像路径参数那样，FastAPI 会自动将它们视为查询参数。让我们试试看：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, you can see that we have defined a default value for those arguments,
    which means they are *optional* when calling the API. Of course, if you wish to
    define a *required* query parameter, simply leave out the default value:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们为这些参数定义了默认值，这意味着它们在调用 API 时是 *可选的*。当然，如果你希望定义一个 *必填的* 查询参数，只需省略默认值：
- en: chapter03_query_parameters_02.py
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_query_parameters_02.py
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_02.py)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_02.py)'
- en: Now, if you omit the `format` parameter in the URL, you’ll get a 422 error response.
    Additionally, notice that, in this example, we defined a `UsersFormat` enumeration
    to limit the number of allowed values for this parameter; this is exactly what
    we did in the previous section for path parameters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在 URL 中省略了 `format` 参数，你会收到 422 错误响应。另外，注意在这个例子中，我们定义了一个 `UsersFormat`
    枚举来限制此参数允许的值数量；这正是我们在前一节中对路径参数所做的事情。
- en: 'We also have access to more advanced validations through the `Query` function.
    It works in the same way that we demonstrated in the *Path* *parameters* section:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过 `Query` 函数访问更高级的验证功能。它的工作方式与我们在 *路径* *参数* 部分演示的相同：
- en: chapter03_query_parameters_03.py
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_query_parameters_03.py
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_03.py)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_03.py)'
- en: Here, we force the page to be *greater than 0* and the size to be *less than
    or equal to 100*. Notice how the default parameter value is the first argument
    of the `Query` function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们强制页面参数值为 *大于 0* 且大小 *小于或等于 100*。注意，默认的参数值是 `Query` 函数的第一个参数。
- en: Naturally, when it comes to sending request data, the most obvious way is to
    use the request body. Let’s examine how it works.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，在发送请求数据时，最直观的方式是使用请求体。让我们看看它是如何工作的。
- en: The request body
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求体
- en: The body is the part of the HTTP request that contains raw data representing
    documents, files, or form submissions. In a REST API, it’s usually encoded in
    JSON and used to create structured objects in a database.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请求体是 HTTP 请求的一部分，包含表示文档、文件或表单提交的原始数据。在 REST API 中，它通常以 JSON 编码，用于在数据库中创建结构化对象。
- en: 'For the simplest cases, retrieving data from the body works exactly like query
    parameters. The only difference is that you always have to use the `Body` function;
    otherwise, FastAPI will look for it inside the query parameters by default. Let’s
    explore a simple example where we want to post some user data:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最简单的情况，从请求体中获取数据的方式与查询参数完全相同。唯一的区别是你必须始终使用 `Body` 函数；否则，FastAPI 会默认在查询参数中查找它。让我们探索一个简单的例子，我们想要发布一些用户数据：
- en: chapter03_request_body_01.py
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_request_body_01.py
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_01.py)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_01.py)'
- en: 'In the same way as query parameters, we define each argument with a type hint
    along with the `Body` function with no default value to make them required. Let’s
    try the following endpoint:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与查询参数的方式相同，我们为每个参数定义类型提示，并使用 `Body` 函数且不提供默认值来使其成为必填项。让我们尝试以下端点：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we used the `-v` option of HTTPie so that you can clearly see the JSON
    payload we sent. FastAPI successfully retrieves the data for each field from the
    payload. If you send a request with a missing or invalid field, you’ll get a `422`
    status error response.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了HTTPie的`-v`选项，以便您可以清楚地看到我们发送的JSON有效负载。FastAPI成功地从有效负载中检索每个字段的数据。如果您发送的请求缺少或无效字段，则会收到`422`状态错误响应。
- en: You also have access to more advanced validation through the `Body` function.
    It works in the same way as we demonstrated in the *Path* *parameters* section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Body`函数，您还可以进行更高级的验证。它的工作方式与我们在*Path* *parameters*部分演示的方式相同。
- en: However, defining payload validations such as this has some major drawbacks.
    First, it’s quite verbose and makes the path operation function prototype huge,
    especially for bigger models. Second, usually, you’ll need to reuse the data structure
    on other endpoints or in other parts of your application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，定义此类有效负载验证也有一些主要缺点。首先，它非常冗长，使得路径操作函数原型巨大，尤其是对于更大的模型。其次，通常情况下，您需要在其他端点或应用程序的其他部分重用数据结构。
- en: This is why FastAPI uses `Path`, `Query`, and `Body` functions that we’ve learned
    about so far use Pydantic under the hood!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么FastAPI使用`Path`、`Query`和`Body`函数，我们迄今所学的都使用Pydantic作为其基础！
- en: 'By defining your own Pydantic models and using them as type hints in your path
    arguments, FastAPI will automatically instantiate a model instance and validate
    the data. Let’s rewrite our previous example using this method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义自己的Pydantic模型并在路径参数中使用它们作为类型提示，FastAPI将自动实例化模型实例并验证数据。让我们使用这种方法重写我们之前的例子：
- en: chapter03_request_body_02.py
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_request_body_02.py
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_02.py)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_02.py)'
- en: 'First, we import `BaseModel` from `pydantic`. This is the base class that *every*
    model should inherit from. Then, we define our `User` class and list all of the
    properties as *class properties*. Each one of them should have a proper type hint:
    this is how Pydantic will be able to validate the type of the field.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`pydantic`导入`BaseModel`。这是每个模型都应该继承的基类。然后，我们定义我们的`User`类，并将所有属性列为*类属性*。每个属性都应具有适当的类型提示：这是Pydantic将能够验证字段类型的方式。
- en: Finally, we just declare `user` as an argument for our path operation function
    with the `User` class as a type hint. FastAPI automatically understands that the
    user data can be found in the request payload. Inside the function, you have access
    to a proper `user` object instance, where you can access individual properties
    by simply using the dot notation, such as `user.name`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需将`user`声明为路径操作函数的一个参数，并使用`User`类作为类型提示。FastAPI会自动理解用户数据可以在请求负载中找到。在函数内部，您可以访问一个适当的`user`对象实例，只需使用点表示法访问单个属性，例如`user.name`。
- en: Notice that if you just return the object, FastAPI is smart enough to convert
    it automatically into JSON to produce the HTTP response.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果只返回对象，FastAPI足够智能，会自动将其转换为JSON以生成HTTP响应。
- en: In the following chapter, [*Chapter 4*](B19528_04.xhtml#_idTextAnchor176), *Managing
    Pydantic Data Models in FastAPI*, we’ll explore, in more detail, the possibilities
    of Pydantic, particularly in terms of validation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，[*第4章*](B19528_04.xhtml#_idTextAnchor176)，*在FastAPI中管理Pydantic数据模型*，我们将更详细地探讨Pydantic的可能性，特别是在验证方面。
- en: Multiple objects
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个对象
- en: 'Sometimes, you might have several objects that you wish to send in the same
    payload all at once. For example, both `user` and `company`. In this scenario,
    you can simply add several arguments that have been type hinted by a Pydantic
    model, and FastAPI will automatically understand that there are several objects.
    In this configuration, it will expect a body containing each object *indexed by
    its* *argument name*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望一次性发送同一有效负载中的多个对象。例如，`user`和`company`。在这种情况下，您可以简单地添加几个由Pydantic模型类型提示的参数，FastAPI将自动理解存在多个对象。在这种配置中，它将期望包含每个对象*以其*
    *参数名称* *索引*：
- en: chapter03_request_body_03.py
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_request_body_03.py
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_03.py)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_03.py)'
- en: 'Here, `Company` is a simple Pydantic model with a single string `name` property.
    In this configuration, FastAPI expects a payload that looks similar to the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Company` 是一个简单的 Pydantic 模型，只有一个字符串类型的 `name` 属性。在这种配置下，FastAPI 期望接收一个看起来类似于以下内容的有效载荷：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For more complex JSON structures, it’s advised that you *pipe* a formatted
    JSON into HTTPie rather than use parameters. Let’s try this as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的 JSON 结构，建议你将格式化后的 JSON 通过管道传输给 HTTPie，而不是使用参数。让我们按如下方式尝试：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And that’s it!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: 'You can even add `Body` function, just as we saw at the beginning of this section.
    This is useful if you wish to have a single property that’s not part of any model:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以添加 `Body` 函数，就像我们在本节开始时看到的那样。如果你希望有一个不属于任何模型的单一属性，这会很有用：
- en: chapter03_request_body_04.py
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_request_body_04.py
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_04.py)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_04.py)'
- en: 'The `priority` property is an integer between 1 and 3, which is expected *beside*
    the `user` object:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`priority` 属性是一个介于 1 和 3 之间的整数，预计在 `user` 对象 *旁边*：'
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You now have a good overview of how to handle JSON payload data. However, sometimes,
    you’ll find that you need to accept more traditional-form data or even file uploads.
    Let’s find out how to do this next!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经很好地了解了如何处理 JSON 有效载荷数据。然而，有时你会发现需要接受更传统的表单数据，甚至是文件上传。接下来我们来看看如何做！
- en: Form data and file uploads
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单数据和文件上传
- en: Even if REST APIs work most of the time with JSON, sometimes, you might have
    to handle form-encoded data or file uploads, which have been encoded either as
    `application/x-www-form-urlencoded` or `multipart/form-data`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 REST API 大多数时候使用 JSON，偶尔你可能需要处理表单编码的数据或文件上传，这些数据要么被编码为 `application/x-www-form-urlencoded`，要么为
    `multipart/form-data`。
- en: 'Once again, FastAPI allows you to implement this case very easily. However,
    you’ll need an additional Python dependency, `python-multipart`, to handle this
    kind of data. As usual, you can install it with `pip`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，FastAPI 使得实现这一需求变得非常简单。然而，你需要一个额外的 Python 依赖项 `python-multipart` 来处理这种数据。和往常一样，你可以通过
    `pip` 安装它：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, you can use the FastAPI features that are dedicated to form data. First,
    let’s take a look at how you can handle simple form data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 FastAPI 提供的专门处理表单数据的功能。首先，让我们看看如何处理简单的表单数据。
- en: Form data
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表单数据
- en: 'The method to retrieve form data fields is similar to the one we discussed
    in the *The request body* section to retrieve singular JSON properties. The following
    example is roughly the same as the one you explored there. However, this example
    expects form-encoded data instead of JSON:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 获取表单数据字段的方法类似于我们在 *请求体* 部分讨论的获取单个 JSON 属性的方法。以下示例与在那里探索的示例大致相同。不过，这个示例期望接收的是表单编码的数据，而不是
    JSON：
- en: chapter03_form_data_01.py
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_form_data_01.py
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_form_data_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_form_data_01.py)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_form_data_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_form_data_01.py)'
- en: 'The only difference here is that we use the `Form` function instead of `Body`.
    You can try this endpoint with HTTPie and the `--form` option to force the data
    to be form-encoded:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不同之处是，我们使用 `Form` 函数代替 `Body`。你可以使用 HTTPie 和 `--form` 选项来尝试这个端点，以强制数据进行表单编码：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Pay attention to how the `Content-Type` header and the body data representation
    have changed in the request. You can also see that the response is still provided
    in JSON. Unless specified otherwise, FastAPI will always output a JSON response
    by default, no matter the form of the input data.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意请求中`Content-Type`头和正文数据表示方式的变化。你还可以看到，响应依旧以JSON格式提供。除非另有说明，FastAPI 默认总是输出JSON响应，无论输入数据的形式如何。
- en: Of course, the validation options we saw for `Path`, `Query`, and `Body` are
    still available. You can find a description for each of them in the *Path* *parameters*
    section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们之前看到的`Path`、`Query`和`Body`的验证选项仍然可用。你可以在*路径* *参数*部分找到它们的描述。
- en: It’s worth noting that, contrary to JSON payloads, FastAPI doesn’t allow you
    to define Pydantic models to validate form data. Instead, you have to manually
    define each field as an argument for the path operation function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，与JSON有效负载不同，FastAPI不允许你定义Pydantic模型来验证表单数据。相反，你必须手动为路径操作函数定义每个字段作为参数。
- en: Now, let’s go on to discuss how to handle file uploads.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论如何处理文件上传。
- en: File uploads
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件上传
- en: Uploading files is a common requirement for web applications, whether this is
    images or documents. FastAPI provides a parameter function, `File`, that enables
    this.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上传文件是Web应用程序中的常见需求，无论是图片还是文档，FastAPI 提供了一个参数函数`File`来实现这一功能。
- en: 'Let’s take a look at a simple example where you can directly retrieve a file
    as a `bytes` object:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，你可以直接将文件作为`bytes`对象来获取：
- en: chapter03_file_uploads_01.py
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_file_uploads_01.py
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_01.py)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_01.py)'
- en: 'Once again, you can see that the approach is still the same: we define an argument
    for the path operation function, `file`, add a type hint, `bytes`, and then we
    use the `File` function as a default value for this argument. By doing this, FastAPI
    understands that it will have to retrieve raw data in a part of the body named
    `file` and return it as `bytes`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 再次可以看到，这种方法依然是相同的：我们为路径操作函数定义一个参数`file`，并添加类型提示`bytes`，然后我们将`File`函数作为该参数的默认值。通过这种方式，FastAPI
    明白它需要从请求体中名为`file`的部分获取原始数据，并将其作为`bytes`返回。
- en: We simply return the size of this file by calling the `len` function on this
    `bytes` object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅通过调用`len`函数来返回该`bytes`对象的文件大小。
- en: 'In the code example repository, you should be able to find a picture of a cat:
    [https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/assets/cat.jpg](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/assets/cat.jpg).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例仓库中，你应该能找到一张猫的图片：[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/assets/cat.jpg](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/assets/cat.jpg)。
- en: 'Let’s upload it on our endpoint using HTTPie. To upload a file, type in the
    name of the file upload field (here, it is `file`), followed by `@` and the path
    of the file you want to upload. Don’t forget to set the `--``form` option:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用HTTPie将其上传到我们的端点。上传文件时，输入文件上传字段的名称（这里是`file`），后面跟上`@`和你要上传的文件路径。别忘了设置`--form`选项：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It works! We have correctly got the size of the file in bytes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！我们正确地获取了文件的字节大小。
- en: One drawback to this approach is that the uploaded file is entirely stored *in
    memory*. So, while it’ll work for small files, it is likely that you’ll run into
    issues for larger files. Besides, manipulating a `bytes` object is not always
    convenient for file handling.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是，上传的文件完全存储在*内存中*。因此，尽管它适用于小文件，但对于较大的文件，很可能会遇到问题。而且，操作`bytes`对象在文件处理上并不总是方便的。
- en: To fix this problem, FastAPI provides an `UploadFile` class. This class will
    store the data in memory up to a certain threshold and, after this, will automatically
    store it *on disk* in a temporary location. This allows you to accept much larger
    files without running out of memory. Furthermore, the exposed object instance
    exposes useful metadata, such as the content type, and a **file-like** interface.
    This means that you can manipulate it as a regular file in Python and feed it
    to any function that expects a file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，FastAPI 提供了一个 `UploadFile` 类。该类会将数据存储在内存中，直到达到某个阈值，之后它会自动将数据存储到 *磁盘*
    的临时位置。这使得你可以接受更大的文件，而不会耗尽内存。此外，暴露的对象实例还提供了有用的元数据，比如内容类型，以及一个 **类文件** 接口。这意味着你可以像处理普通文件一样在
    Python 中操作它，并将其传递给任何期望文件的函数。
- en: 'To use it, you simply have to specify it as a type hint instead of `bytes`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它时，你只需将其指定为类型提示，而不是 `bytes`：
- en: chapter03_file_uploads_02.py
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_file_uploads_02.py
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_02.py)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_02.py)'
- en: Notice that, here, we return the `filename` and `content_type` properties. The
    content type is especially useful for *checking the type* of the uploaded file
    and possibly rejecting it if it’s not one of the types you expect.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这里，我们返回了 `filename` 和 `content_type` 属性。内容类型对于 *检查文件类型* 特别有用，如果上传的文件类型不是你预期的类型，可以考虑拒绝它。
- en: 'Here is the result with HTTPie:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 HTTPie 的结果：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can even accept multiple files by type hinting the argument as a list of
    `UploadFile`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过将参数类型提示为 `UploadFile` 的列表来接受多个文件：
- en: chapter03_file_uploads_03.py
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_file_uploads_03.py
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_03.py)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_03.py)'
- en: 'To upload several files with HTTPie, simply repeat the argument. It should
    appear as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 HTTPie 上传多个文件，只需重复该参数。它应该如下所示：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, you should be able to handle form data and file uploads in a FastAPI application.
    So far, you’ve learned how to manage user-facing data. However, there are also
    very interesting pieces of information that are less visible: **headers**. We’ll
    explore them next.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够在 FastAPI 应用程序中处理表单数据和文件上传了。到目前为止，你已经学会了如何管理用户交互的数据。然而，还有一些不太显眼但非常有趣的信息：**headers**。接下来我们将探讨它们。
- en: Headers and cookies
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Headers 和 cookies
- en: Besides the URL and the body, another major part of the HTTP request are the
    headers. They contain all sorts of metadata that can be useful when handling requests.
    A common usage is to use them for authentication, for example, via the famous
    **cookies**.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 URL 和主体，HTTP 请求的另一个重要部分是 headers。它们包含各种元数据，当处理请求时非常有用。常见的用法是将它们用于身份验证，例如通过著名的
    **cookies**。
- en: 'Once again, retrieving them in FastAPI only involves a type hint and a parameter
    function. Let’s take a look at a simple example where we want to retrieve a header
    named `Hello`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在 FastAPI 中获取它们只需要一个类型提示和一个参数函数。让我们来看一个简单的例子，我们想要检索名为 `Hello` 的 header：
- en: chapter03_headers_cookies_01.py
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_headers_cookies_01.py
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_01.py)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_01.py)'
- en: 'Here, you can see that we simply have to use the `Header` function as a default
    value for the `hello` argument. The name of the argument determines the *key of
    the header* that we want to retrieve. Let’s see this in action:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们只需使用 `Header` 函数作为 `hello` 参数的默认值。参数的名称决定了我们想要检索的 *header 的 key*。让我们看看这个如何实现：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: FastAPI was able to retrieve the header value. Since there was no default value
    specified (we put in an ellipsis), the header is required. If it’s missing, once
    again, you’ll get a `422` status error response.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 能够成功获取头部值。由于没有指定默认值（我们放置了省略号），因此该头部是必需的。如果缺失，将再次返回 `422` 状态错误响应。
- en: 'Additionally, notice that FastAPI automatically converts the header name into
    *lowercase*. Besides that, since header names are usually separated by a hyphen,
    `-`, it also automatically converts it into snake case. Therefore, it works out
    of the box with any valid Python variable name. The following example shows this
    behavior by retrieving the `User-Agent` header:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，FastAPI 会自动将头部名称转换为 *小写字母*。除此之外，由于头部名称通常由短横线 `-` 分隔，它还会自动将其转换为蛇形命名法。因此，它开箱即用，能够适配任何有效的
    Python 变量名。以下示例展示了这种行为，通过获取 `User-Agent` 头部来实现：
- en: chapter03_headers_cookies_02.py
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_headers_cookies_02.py
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_02.py)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_02.py)'
- en: 'Now, let’s make a very simple request. We’ll keep the default user agent of
    HTTPie to see what happens:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们发出一个非常简单的请求。我们将保持 HTTPie 的默认用户代理来看看会发生什么：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: What is a user agent?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是用户代理？
- en: The user agent is an HTTP header added automatically by most HTTP clients, such
    as HTTPie or cURL and web browsers. It’s a way for web servers to identify which
    kind of application made the request. In some cases, web servers can use this
    information to adapt the response.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代理是大多数 HTTP 客户端（如 HTTPie 或 cURL 和网页浏览器）自动添加的 HTTP 头部。它是服务器识别请求来源应用程序的一种方式。在某些情况下，Web
    服务器可以利用这些信息来调整响应。
- en: One very special case of the header is cookies. You could retrieve them by parsing
    the `Cookie` header yourself, but that would be a bit tedious. FastAPI provides
    another parameter function that automatically does it for you.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 头部的一个非常特殊的案例是 cookies。你可以通过自己解析 `Cookie` 头部来获取它们，但那会有点繁琐。FastAPI 提供了另一个参数函数，它可以自动为你处理这些。
- en: 'The following example simply retrieves a cookie named `hello`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例简单地获取一个名为 `hello` 的 cookie：
- en: chapter03_headers_cookies_03.py
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_headers_cookies_03.py
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_03.py)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_03.py)'
- en: Notice that we type hinted the argument as `str | None`, and we set a default
    value of `None` to the `Cookie` function. This way, even if the cookie is not
    set in the request, FastAPI will proceed and not generate a `422` status error
    response.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们为参数添加了类型提示 `str | None`，并为 `Cookie` 函数设置了默认值 `None`。这样，即使请求中没有设置 cookie，FastAPI
    仍会继续处理，并且不会生成 `422` 状态错误响应。
- en: Headers and cookies can be very useful tools for implementing authentication
    features. In [*Chapter 7*](B19528_07.xhtml#_idTextAnchor448), *Managing Authentication
    and Security in FastAPI*, you’ll learn that there are built-in security functions
    that can help you to implement common authentication schemes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 头部和 cookies 可以成为实现身份验证功能的非常有用的工具。在 [*第 7 章*](B19528_07.xhtml#_idTextAnchor448)，*在
    FastAPI 中管理身份验证和安全性*，你将了解到一些内置的安全函数，它们能帮助你实现常见的身份验证方案。
- en: The request object
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求对象
- en: 'Sometimes, you might find that you need to access a raw request object with
    all of the data associated with it. That’s possible. Simply declare an argument
    on your path operation function type hinted with the `Request` class:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会发现需要访问一个包含所有相关数据的原始请求对象。那是完全可以做到的。只需在路径操作函数中声明一个以 `Request` 类为类型提示的参数：
- en: chapter03_request_object_01.py
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_request_object_01.py
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_object_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_object_01.py)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_object_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_object_01.py)'
- en: Under the hood, this is the `Request` object from Starlette, which is a library
    that provides all the core server logic for FastAPI. You can view a complete description
    of the methods and properties of this object in the official documentation of
    Starlette ([https://www.starlette.io/requests/](https://www.starlette.io/requests/)).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，这是来自 Starlette 的`Request`对象，Starlette 是一个为 FastAPI 提供所有核心服务器逻辑的库。你可以在 Starlette
    的官方文档中查看这个对象的完整方法和属性描述（[https://www.starlette.io/requests/](https://www.starlette.io/requests/))。
- en: Congratulations! You have now learned all of the basics regarding how to handle
    request data in FastAPI. As you learned, the logic is the same no matter what
    part of the HTTP request you want to look at. Simply name the argument you want
    to retrieve, add a type hint, and use a parameter function to tell FastAPI where
    it should look. You can even add some validation logic!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经学习了有关如何在 FastAPI 中处理请求数据的所有基础知识。如你所学，无论你想查看 HTTP 请求的哪个部分，逻辑都是相同的。只需命名你想要获取的参数，添加类型提示，并使用参数函数告诉
    FastAPI 它应该在哪里查找。你甚至可以添加一些验证逻辑！
- en: 'In the next section, we’ll explore the other side of a REST API job: returning
    a response.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将探讨 REST API 任务的另一面：返回响应。
- en: Customizing the response
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义响应
- en: In the previous sections, you learned that directly returning a dictionary or
    a Pydantic object in your path operation function was enough for FastAPI to return
    a JSON response.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的部分中，你已经学到，直接在路径操作函数中返回字典或 Pydantic 对象就足够让 FastAPI 返回一个 JSON 响应。
- en: Most of the time, you’ll want to customize this response a bit further; for
    instance, by changing the status code, raising validation errors, and setting
    cookies. FastAPI offers different ways to do this, from the simplest case to the
    most advanced one. First, we’ll learn how to customize the response declaratively
    by using path operation parameters.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你会想进一步自定义这个响应；例如，通过更改状态码、抛出验证错误和设置 cookies。FastAPI 提供了不同的方式来实现这一点，从最简单的情况到最复杂的情况。首先，我们将学习如何通过使用路径操作参数来声明性地自定义响应。
- en: Path operation parameters
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径操作参数
- en: In the *Creating a first endpoint and running it locally* section, you learned
    that in order to create a new endpoint, you had to put a decorator on top of the
    path operation function. This decorator accepts a lot of options, including ones
    to customize the response.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在*创建第一个端点并在本地运行*部分中，你学到了为了创建新的端点，你必须在路径操作函数上方放置一个装饰器。这个装饰器接受许多选项，包括自定义响应的选项。
- en: The status code
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态码
- en: The most obvious thing to customize in an HTTP response is the `200` status
    when everything goes well during your path operation function execution.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 响应中最明显的自定义项是当路径操作函数执行顺利时的`200`状态码。
- en: Sometimes, it might be useful to change this status. For example, it’s good
    practice in a REST API to return a `201 Created` status when the execution of
    the endpoint ends up in the creation of a new object.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，改变这个状态可能很有用。例如，在 REST API 中，返回`201 Created`状态码是一种良好的实践，当端点执行结果是创建了一个新对象时。
- en: 'To set this, simply specify the `status_code` argument on the path decorator:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置此项，只需在路径装饰器中指定`status_code`参数：
- en: chapter03_response_path_parameters_01.py
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_response_path_parameters_01.py
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_01.py)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_01.py)'
- en: The decorator arguments come right after the path as keyword arguments. The
    `status_code` option simply expects an integer representing the status code. We
    could have written `status_code=201`, but FastAPI provides a useful list in the
    `status` sub-module that improves code comprehensiveness, as you can see here.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的参数紧跟路径作为关键字参数。`status_code` 选项简单地接受一个整数，表示状态码。我们本可以写成 `status_code=201`，但是
    FastAPI 在 `status` 子模块中提供了一个有用的列表，可以提高代码的可读性，正如你在这里看到的。
- en: 'We can try this endpoint to obtain the resulting status code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试这个端点，以获得结果状态码：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We got our `201` status code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了 `201` 状态码。
- en: It’s important to understand that this option to override the status code is
    only useful *when everything goes well*. If your input data was invalid, you would
    still get a `422` status error response.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，这个覆盖状态码的选项只有在*一切顺利时*才有用。如果你的输入数据无效，你仍然会收到 `422` 状态错误响应。
- en: 'Another interesting scenario for this option is when you have nothing to return,
    such as when you delete an object. In this case, the `204 No content` status code
    is a good fit. In the following example, we implement a simple `delete` endpoint
    that sets this response status code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的场景是当你没有任何内容可返回时，比如在删除一个对象时。在这种情况下，`204 No content` 状态码非常适合。以下示例中，我们实现了一个简单的
    `delete` 端点，设置了这个响应状态码：
- en: chapter03_response_path_parameters_02.py
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_response_path_parameters_02.py
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_02.py)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_02.py)'
- en: Notice that you can very well return `None` in your path operation function.
    FastAPI will take care of it and return a response with an empty body.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你完全可以在路径操作函数中返回 `None`。FastAPI 会处理它，并返回一个空正文的响应。
- en: In the *Setting the status code dynamically* section, you’ll learn how to customize
    the status code dynamically inside the path operation logic.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在*动态设置状态码*一节中，你将学习如何在路径操作逻辑中动态定制状态码。
- en: The response model
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应模型
- en: With FastAPI, the main use case is to directly return a Pydantic model that
    automatically gets turned into properly formatted JSON. However, quite often,
    you’ll find that there are some differences between the input data, the data you
    store in your database, and the data you want to show to the end user. For instance,
    perhaps some fields are private or only for internal use, or perhaps some fields
    are only useful during the creation process and then discarded afterward.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FastAPI 中，主要的用例是直接返回一个 Pydantic 模型，它会自动转换成格式正确的 JSON。然而，往往你会发现输入数据、数据库中存储的数据和你希望展示给最终用户的数据之间会有一些差异。例如，某些字段可能是私密的或仅供内部使用，或者某些字段可能只在创建过程中有用，之后就会被丢弃。
- en: Now, let’s consider a simple example. Assume you have a database containing
    blog posts. Those blog posts have several properties, such as a title, content,
    or creation date. Additionally, you store the number of views of each one, but
    you don’t want the end user to see it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个简单的例子。假设你有一个包含博客文章的数据库。这些博客文章有几个属性，比如标题、内容或创建日期。此外，你还会存储每篇文章的浏览量，但你不希望最终用户看到这些数据。
- en: 'You could take the standard approach as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按以下标准方法进行操作：
- en: chapter03_response_path_parameters_03.py
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_response_path_parameters_03.py
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_03.py)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_03.py)'
- en: 'And then call this endpoint:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用这个端点：
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `nb_views` property is in the output. However, we don’t want this. This
    is exactly what the `response_model` option is for, to specify another model that
    only outputs the properties we want. First, let’s define another Pydantic model
    with only the `title` property:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`nb_views` 属性出现在输出中。然而，我们并不希望这样。`response_model` 选项正是为了这个目的，它指定了另一个只输出我们需要的属性的模型。首先，让我们定义一个只有
    `title` 属性的 Pydantic 模型：'
- en: chapter03_response_path_parameters_04.py
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_response_path_parameters_04.py
- en: '[PRE46]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_04.py)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_04.py)'
- en: 'Then, the only change is to add the `response_model` option as a keyword argument
    for the path decorator:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，唯一的变化是将 `response_model` 选项作为关键字参数添加到路径装饰器中：
- en: chapter03_response_path_parameters_04.py
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_response_path_parameters_04.py
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_04.py)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_04.py)'
- en: 'Now, let’s try to call this endpoint:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试调用这个端点：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `nb_views` property is no longer there! Thanks to the `response_model` option,
    FastAPI automatically converted our `Post` instance into a `PublicPost` instance
    before serializing it. Now our private data is safe!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`nb_views` 属性不再存在！多亏了 `response_model` 选项，FastAPI 在序列化之前自动将我们的 `Post` 实例转换为
    `PublicPost` 实例。现在我们的私密数据是安全的！'
- en: 'The good thing is that this option is also considered by the interactive documentation,
    which will show the correct output schema to the end user, as you can see in *Figure
    3**.2*:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，这个选项也被交互式文档考虑在内，文档会向最终用户展示正确的输出架构，正如您在 *图 3.2* 中看到的那样：
- en: '![Figure 3.2 – The response model schema in the interactive documentation](img/Figure_3.2_B19528.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 交互式文档中的响应模型架构](img/Figure_3.2_B19528.jpg)'
- en: Figure 3.2 – The response model schema in the interactive documentation
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 交互式文档中的响应模型架构
- en: So far, you’ve looked at options that can help you quickly customize the response
    generated by FastAPI. Now, we’ll introduce another approach that will open up
    more possibilities.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解了可以帮助您快速定制 FastAPI 生成的响应的选项。现在，我们将介绍另一种方法，它将开启更多的可能性。
- en: The response parameter
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应参数
- en: The body and status code are not the only interesting parts of an HTTP response.
    Sometimes, it might be useful to return some custom headers or set cookies. This
    can be done dynamically using FastAPI directly within the path operation logic.
    How so? By injecting the `Response` object as an argument of the path operation
    function.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 响应中不仅仅有主体和状态码才是有趣的部分。有时，返回一些自定义头部或设置 cookies 也可能是有用的。这可以通过 FastAPI 直接在路径操作逻辑中动态完成。怎么做呢？通过将
    `Response` 对象作为路径操作函数的一个参数进行注入。
- en: Setting headers
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置头部
- en: 'As usual, this only involves setting the proper type hinting to the argument.
    The following example shows you how to set a custom header:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，这仅涉及为参数设置正确的类型提示。以下示例向您展示了如何设置自定义头部：
- en: chapter03_response_parameter_01.py
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_response_parameter_01.py
- en: '[PRE49]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_01.py)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_01.py)'
- en: The `Response` object gives you access to a set of properties, including `headers`.
    It’s a simple dictionary where the key is the name of the header, and the value
    is its associated value. Therefore, it’s relatively straightforward to set your
    own custom header.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response`对象提供了一组属性，包括`headers`。它是一个简单的字典，键是头部名称，值是其关联的值。因此，设置自定义头部相对简单。'
- en: Also, notice that you *don’t have to return* the `Response` object. You can
    still return JSON-encodable data, and FastAPI will take care of forming a proper
    response, including the headers you’ve set. Therefore, the `response_model` and
    `status_code` options we discussed in the *Path operation parameters* section
    are still honored.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意你*不需要返回*`Response`对象。你仍然可以返回可编码为JSON的数据，FastAPI会处理形成正确的响应，包括你设置的头部。因此，我们在*路径操作参数*部分讨论的`response_model`和`status_code`选项仍然有效。
- en: 'Let’s view the result:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看结果：
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Our custom header is part of the response.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义头部是响应的一部分。
- en: As we mentioned earlier, the good thing about this approach is that it’s within
    your path operation logic. That means you can dynamically set headers depending
    on what’s happening in your business logic.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，这种方法的好处是它在你的路径操作逻辑中。这意味着你可以根据业务逻辑的变化动态地设置头部。
- en: Setting cookies
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置cookie
- en: Cookies can also be particularly useful when you want to maintain the user’s
    state within the browser between each of their visits.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望在每次访问之间保持用户在浏览器中的状态时，cookie也特别有用。
- en: 'To prompt the browser to save some cookies in your response, you could, of
    course, build your own `Set-Cookie` header and set it in the `headers` dictionary,
    just as we saw in the preceding command block. However, since this can be quite
    tricky to do, the `Response` object exposes a convenient `set_cookie` method:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让浏览器在响应中保存一些cookie，当然可以自己构建`Set-Cookie`头部并将其设置在`headers`字典中，就像我们在前面的命令块中看到的那样。然而，由于这样做可能相当复杂，`Response`对象提供了一个方便的`set_cookie`方法：
- en: chapter03_response_parameter_02.py
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_response_parameter_02.py
- en: '[PRE51]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_02.py)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_02.py)'
- en: Here, we simply set a cookie, named `cookie-name`, with the value of `cookie-value`.
    It’ll be valid for 86,400 seconds before the browser removes it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地设置了一个名为`cookie-name`的cookie，值为`cookie-value`。它将在浏览器删除之前有效86,400秒。
- en: 'Let’s try it:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看：
- en: '[PRE52]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, you can see that we have a nice `Set-Cookie` header with all of the properties
    of our cookie.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们有一个很好的`Set-Cookie`头部，包含了我们cookie的所有属性。
- en: As you may know, cookies have a lot more options than the ones we have shown
    here; for instance, path, domain, and HTTP-only. The `set_cookie` method supports
    all of them. You can read about the full list of options in the official Starlette
    documentation (since `Response` is also borrowed from Starlette) at [https://www.starlette.io/responses/#set-cookie](https://www.starlette.io/responses/#set-cookie).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知道的，cookie的选项比我们这里展示的要多；例如，路径、域和仅限HTTP。`set_cookie`方法支持所有这些选项。你可以在官方的Starlette文档中查看完整的选项列表（因为`Response`也是从Starlette借来的），链接为[https://www.starlette.io/responses/#set-cookie](https://www.starlette.io/responses/#set-cookie)。
- en: If you’re not familiar with the `Set-Cookie` header, we also recommend that
    you refer to *MDN Web Docs*, which can be accessed at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉`Set-Cookie`头部，我们还建议你参考*MDN Web Docs*，可以通过[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie)访问。
- en: Of course, if you need to set several cookies, you can call this method several
    times.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你需要设置多个cookie，可以多次调用这个方法。
- en: Setting the status code dynamically
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态设置状态码
- en: In the *Path operation parameters* section, we discussed a way to declaratively
    set the status code of the response. The drawback to this approach is that it’ll
    always be the same no matter what’s happening inside.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在*路径操作参数*部分，我们讨论了如何声明性地设置响应的状态码。这个方法的缺点是，无论内部发生什么，它总是相同的。
- en: Let’s assume that we have an endpoint that updates an object in the database
    or creates it if it doesn’t exist. A good approach would be to return a `200 OK`
    status when the object already exists or a `201 Created` status when the object
    has to be created.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个端点，可以在数据库中更新对象，或者如果对象不存在，则创建它。一种好的方法是在对象已经存在时返回`200 OK`状态，而当对象需要被创建时返回`201
    Created`状态。
- en: 'To do this, you can simply set the `status_code` property on the `Response`
    object:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你可以简单地在`Response`对象上设置`status_code`属性：
- en: chapter03_response_parameter_03.py
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_response_parameter_03.py
- en: '[PRE53]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_03.py)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_03.py)'
- en: First, we check whether the ID in the path exists in the database. If not, we
    change the status code to `201`. Then, we simply assign the post to this ID in
    the database.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查路径中的ID是否在数据库中存在。如果不存在，我们将状态码更改为`201`。然后，我们简单地将帖子分配给数据库中的这个ID。
- en: 'Let’s try with an existing post first:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先尝试一个已有的帖子：
- en: '[PRE54]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The post with an ID of `1` already exists, so we get a `200` status. Now, let’s
    try with a non-existing ID:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ID为`1`的帖子已经存在，因此我们得到了`200`状态码。现在，让我们尝试一个不存在的ID：
- en: '[PRE55]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We get a `201` status!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了`201`状态码！
- en: Now you have a way to dynamically set the status code in your logic. Bear in
    mind, though, that they *won’t be detected by the automatic documentation*. Therefore,
    they won’t appear as a possible response status code in it.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经有了一种在逻辑中动态设置状态码的方法。但请记住，它们*不会被自动文档检测到*。因此，它们不会出现在文档中的可能响应状态码中。
- en: 'You might be tempted to use this approach to set *error status codes*, such
    as `400 Bad Request` or `404 Not Found`. In fact, you *shouldn’t do that*. FastAPI
    provides a dedicated way to do this: `HTTPException`.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想使用这种方法设置*错误状态码*，例如`400 Bad Request`或`404 Not Found`。实际上，你*不应该这么做*。FastAPI提供了一种专门的方法来处理这个问题：`HTTPException`。
- en: Raising HTTP errors
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引发 HTTP 错误
- en: When calling a REST API, quite frequently, you might find that things don’t
    go very well; you might come across the wrong parameters, invalid payloads, or
    objects that don’t exist anymore. Errors can happen for a lot of reasons.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用REST API时，很多时候你会发现事情不太顺利；你可能会遇到错误的参数、无效的有效载荷，或者对象已经不再存在了。错误可能有很多原因。
- en: 'That’s why it’s critical to detect them and raise a clear and unambiguous error
    message to the end user so that they can correct their mistake. In a REST API,
    there are two very important things that you can use to return an informative
    message: the status code and the payload.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么检测这些错误并向最终用户抛出清晰、明确的错误信息如此重要，让他们能够纠正自己的错误。在 REST API 中，有两个非常重要的东西可以用来返回信息：状态码和有效载荷。
- en: The status code can give you a precious hint about the nature of the error.
    Since HTTP protocols provide a wide range of error status codes, your end user
    might not even need to read the payload to understand what’s wrong.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码可以为你提供关于错误性质的宝贵线索。由于HTTP协议提供了各种各样的错误状态码，最终用户甚至可能不需要读取有效载荷就能理解问题所在。
- en: Of course, it’s always better to provide a clear error message at the same time
    in order to give further details and add some useful information regarding how
    the end user can solve the issue.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，同时提供一个清晰的错误信息总是更好的，以便提供更多的细节并增加一些有用的信息，告诉最终用户如何解决问题。
- en: Error status codes are crucial
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 错误状态码至关重要
- en: 'Some APIs choose to always return a `200` status code with the payload containing
    a property stating whether the request was successful or not, such as `{"success":
    false}`. Don’t do that. The RESTful philosophy encourages you to use the HTTP
    semantics to give meaning to the data. Having to parse the output and look for
    a property to determine whether the call was successful is a bad design.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '一些API选择始终返回`200`状态码，并在有效载荷中包含一个属性，指明请求是否成功，例如`{"success": false}`。不要这么做。RESTful哲学鼓励你使用HTTP语义来赋予数据含义。必须解析输出并寻找一个属性来判断调用是否成功，是一种糟糕的设计。'
- en: To raise an HTTP error in FastAPI, you’ll have to raise a Python exception,
    `HTTPException`. This exception class will allow us to set a status code and an
    error message. It is caught by FastAPI error handlers that take care of forming
    a proper HTTP response.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 FastAPI 中抛出 HTTP 错误，你需要抛出一个 Python 异常 `HTTPException`。这个异常类允许我们设置状态码和错误信息。它会被
    FastAPI 的错误处理程序捕获，后者负责形成正确的 HTTP 响应。
- en: 'In the following example, we’ll raise a `400 Bad Request` error if the `password`
    and `password_confirm` payload properties don’t match:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，如果 `password` 和 `password_confirm` 的负载属性不匹配，我们将抛出一个 `400 Bad Request`
    错误：
- en: chapter03_raise_errors_01.py
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_raise_errors_01.py
- en: '[PRE56]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_raise_errors_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_raise_errors_01.py)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_raise_errors_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_raise_errors_01.py)'
- en: As you can see here, if the passwords are not equal, we directly raise `HTTPException`.
    The first argument is the status code, and the `detail` keyword argument lets
    us write an error message.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，如果密码不匹配，我们直接抛出 `HTTPException`。第一个参数是状态码，而 `detail` 关键字参数让我们编写错误信息。
- en: 'Let’s examine how it works:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看它是如何工作的：
- en: '[PRE57]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we do get a `400` status code, and our error message has been wrapped
    nicely in a JSON object with the `detail` key. This is how FastAPI handles errors
    by default.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们确实收到了 `400` 状态码，并且我们的错误信息已经很好地包装在一个带有 `detail` 键的 JSON 对象中。这就是 FastAPI
    默认处理错误的方式。
- en: 'In fact, you are not limited to a simple string for the error message: you
    can return a dictionary or a list in order to get structured information about
    the error. For example, take a look at the following code snippet:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你不仅仅可以用一个简单的字符串作为错误信息：你可以返回一个字典或列表，以便获得结构化的错误信息。例如，看看下面的代码片段：
- en: chapter03_raise_errors_02.py
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_raise_errors_02.py
- en: '[PRE58]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_raise_errors_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_raise_errors_02.py)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_raise_errors_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_raise_errors_02.py)'
- en: And that’s it! You now have the power to raise errors and give meaningful information
    about them to the end user.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在你已经能够抛出错误并向最终用户提供有意义的错误信息。
- en: So far, the methods you have seen should cover the majority of cases you’ll
    encounter during the development of an API. Sometimes, however, you’ll have scenarios
    where you’ll need to build a complete HTTP response yourself. This is the subject
    of the next section.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你所看到的方法应该涵盖了开发 API 时大多数情况下会遇到的情况。然而，有时你会遇到需要自己构建完整 HTTP 响应的场景。这是下一节的内容。
- en: Building a custom response
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建自定义响应
- en: Most of the time, you’ll let FastAPI take care of building an HTTP response
    by simply providing it with some data to serialize. Under the hood, FastAPI uses
    a subclass of `Response` called `JSONResponse`. Quite predictably, this response
    class takes care of serializing some data to JSON and adding the correct `Content-Type`
    header.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你只需向 FastAPI 提供一些数据以进行序列化，FastAPI 就会自动处理构建 HTTP 响应。FastAPI 底层使用了 `Response`
    的一个子类 `JSONResponse`。很容易预见，这个响应类负责将一些数据序列化为 JSON 并添加正确的 `Content-Type` 头部。
- en: 'However, there are other response classes that cover common cases:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有其他一些响应类可以处理常见的情况：
- en: '`HTMLResponse`: This can be used to return an HTML response'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTMLResponse`：可以用来返回一个 HTML 响应'
- en: '`PlainTextResponse`: This can be used to return raw text'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlainTextResponse`：可以用来返回原始文本'
- en: '`RedirectResponse`: This can be used to make a redirection'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RedirectResponse`：可以用来执行重定向'
- en: '`StreamingResponse`: This can be used to stream a flow of bytes'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StreamingResponse`：可以用来流式传输字节流'
- en: '`FileResponse`: This can be used to automatically build a proper file response
    given the path of a file on the local disk'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileResponse`：可以用来根据本地磁盘中文件的路径自动构建正确的文件响应'
- en: 'You have two ways of using them: either setting the `response_class` argument
    on the path decorator or directly returning a response instance.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两种使用它们的方法：要么在路径装饰器上设置 `response_class` 参数，要么直接返回一个响应实例。
- en: Using the response_class argument
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '使用`response_class`参数  '
- en: 'This is the simplest and most straightforward way to return a custom response.
    Indeed, by doing this, you won’t even have to create a class instance: you’ll
    just have to return the data as you usually do for standard JSON responses.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '这是返回自定义响应最简单直接的方式。实际上，做到这一点，你甚至不需要创建类实例：你只需要像标准JSON响应那样返回数据。  '
- en: 'This is well suited for `HTMLResponse` and `PlainTextResponse`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '这非常适合`HTMLResponse`和`PlainTextResponse`：  '
- en: chapter03_custom_response_01.py
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 'chapter03_custom_response_01.py  '
- en: '[PRE59]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_01.py)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_01.py)  '
- en: By setting the `response_class` argument on the decorator, you can change the
    class that will be used by FastAPI to build the response. Then, you can simply
    return valid data for this kind of response. Notice that the response classes
    are imported through the `fastapi.responses` module.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '通过在装饰器上设置`response_class`参数，你可以更改FastAPI用于构建响应的类。然后，你可以简单地返回这种类型响应的有效数据。请注意，响应类是通过`fastapi.responses`模块导入的。  '
- en: The nice thing about this is that you can combine this option with the ones
    we saw in the *Path operation parameters* section. Using the `Response` parameter
    that we described in *The response parameter* section also works perfectly!
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这点很棒，因为你可以将这个选项与我们在*路径操作参数*部分看到的选项结合使用。使用我们在*响应参数*部分描述的`Response`参数也能完美工作！
- en: For the other response classes, however, you’ll have to build the instance yourself
    and then return it.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，对于其他响应类，你必须自己构建实例，然后返回它。  '
- en: Making a redirection
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '实现重定向  '
- en: 'As mentioned earlier, `RedirectResponse` is a class that helps you build an
    HTTP redirection, which simply is an HTTP response with a `Location` header pointing
    to the new URL and a status code in the *3xx range*. It simply expects the URL
    you wish to redirect to as the first argument:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '如前所述，`RedirectResponse`是一个帮助你构建HTTP重定向的类，它仅仅是一个带有`Location`头指向新URL并且状态码在*3xx范围*内的HTTP响应。它只需要你希望重定向到的URL作为第一个参数：  '
- en: chapter03_custom_response_02.py
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 'chapter03_custom_response_02.py  '
- en: '[PRE60]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_02.py)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_02.py)  '
- en: 'By default, it’ll use the `307 Temporary Redirect` status code, but you can
    change this through the `status_code` argument:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，它将使用`307 Temporary Redirect`状态码，但你可以通过`status_code`参数进行更改：  '
- en: chapter03_custom_response_03.py
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 'chapter03_custom_response_03.py  '
- en: '[PRE61]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_03.py)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_03.py)  '
- en: erving a file
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '提供文件  '
- en: Now, let’s examine how `FileResponse` works. This is useful if you wish to propose
    some files to download. This response class will automatically take care of opening
    the file on disk and streaming the bytes along with the proper HTTP headers.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们来看看`FileResponse`是如何工作的。如果你希望提供一些文件供下载，这是非常有用的。这个响应类将自动负责打开磁盘上的文件并流式传输字节数据，同时附带正确的HTTP头。  '
- en: Let’s take a look at how we can use an endpoint to download a picture of a cat.
    You’ll find this in the code examples repository at [https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/assets/cat.jpg](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/assets/cat.jpg).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何使用一个端点下载一张猫的图片。你可以在代码示例库中找到它，地址是[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/assets/cat.jpg](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/assets/cat.jpg)。
- en: 'We just need to return an instance of `FileResponse` with the path of the file
    we want to serve as the first argument:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要返回一个`FileResponse`实例，并将我们希望提供的文件路径作为第一个参数：
- en: chapter03_custom_response_04.py
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_custom_response_04.py
- en: '[PRE62]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_04.py)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_04.py)'
- en: The pathlib module
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: pathlib模块
- en: Python provides a module to help you work with file paths, `pathlib`. It’s the
    recommended way to manipulate paths, as it takes care of handling them correctly,
    depending on the operating system you are running. You can read about the functions
    of this module in the official documentation at [https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一个模块来帮助你处理文件路径，`pathlib`。它是推荐的路径操作方式，因为它根据你运行的操作系统，自动正确地处理路径。你可以在官方文档中阅读这个模块的函数：[https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)。
- en: 'Let’s examine what the HTTP response looks like:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下HTTP响应的样子：
- en: '[PRE63]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see, we have the right `Content-Length` and `Content-Type` headers
    for our image. The response even sets the `Etag` and `Last-Modified` headers so
    that the browser can properly cache the resource. HTTPie doesn’t show the binary
    data in the body; however, if you open the endpoint in your browser, you’ll see
    the cat appear!
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的图片已经有了正确的`Content-Length`和`Content-Type`头部。响应甚至设置了`Etag`和`Last-Modified`头部，以便浏览器能够正确缓存该资源。HTTPie不会显示正文中的二进制数据；不过，如果你在浏览器中打开该端点，你将看到猫的图片出现！
- en: Custom responses
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义响应
- en: Finally, if you really have a case that’s not covered by the provided classes,
    you always have the option to use the `Response` class to build exactly what you
    need. With this class, you can set everything, including the body content and
    the headers.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你确实有一个没有被提供的类覆盖的情况，你总是可以选择使用`Response`类来构建你需要的内容。使用这个类，你可以设置一切，包括正文内容和头部信息。
- en: 'The following example shows you how to return an XML response:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例向你展示如何返回一个XML响应：
- en: chapter03_custom_response_05.py
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03_custom_response_05.py
- en: '[PRE64]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_05.py)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_05.py)'
- en: You can view the complete list of arguments in the Starlette documentation at
    [https://www.starlette.io/responses/#response](https://www.starlette.io/responses/#response).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Starlette文档中查看完整的参数列表：[https://www.starlette.io/responses/#response](https://www.starlette.io/responses/#response)。
- en: Path operation parameters and response parameters won’t have any effect
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 路径操作参数和响应参数不会有任何效果
- en: Bear in mind that when you directly return a `Response` class (or one of its
    subclasses), the parameters you set on the decorator or the operations you make
    on the injected `Response` object won’t have any effect. They are completely overridden
    by the `Response` object you return. If you need to customize the status code
    or the headers, then use the `status_code` and `headers` arguments when instantiating
    your class.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当你直接返回一个`Response`类（或它的子类）时，你在装饰器上设置的参数或者在注入的`Response`对象上进行的操作将不起作用。它们会被你返回的`Response`对象完全覆盖。如果你需要自定义状态码或头部信息，则在实例化类时使用`status_code`和`headers`参数。
- en: Well done! Now you have all the knowledge required to create the response you
    need for your REST API. You’ve learned that FastAPI comes with sensible defaults
    that can help you create proper JSON responses in no time. At the same time, it
    also gives you access to more advanced objects and options to allow you to make
    custom responses.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！现在，你已经掌握了创建 REST API 响应所需的所有知识。你已经了解到，FastAPI 提供了合理的默认设置，帮助你迅速创建适当的 JSON
    响应。同时，它还为你提供了更多高级对象和选项，让你能够制作自定义响应。
- en: So far, all of the examples we’ve looked at have been quite short and simple.
    However, when you’re developing a real application, you’ll probably have dozens
    of endpoints and models. In the final section of this chapter, we’ll examine how
    to organize such projects to make them modular and easier to maintain.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所查看的所有示例都非常简短和简单。然而，当你在开发一个真实的应用程序时，你可能会有几十个端点和模型。在本章的最后一部分，我们将探讨如何组织这样的项目，使其更加模块化和易于维护。
- en: Structuring a bigger project with multiple routers
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织一个更大的项目，包含多个路由器
- en: 'When building a real-world web application, you’re likely to have a lot of
    code and logic: data models, API endpoints, and services. Of course, all of those
    can’t live in a single file; we have to structure the project so that it’s easy
    to maintain and evolve.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建一个现实世界的 Web 应用程序时，你可能会有很多代码和逻辑：数据模型、API 端点和服务。当然，所有这些不能都放在一个文件中；我们必须以易于维护和发展的方式组织项目。
- en: FastAPI supports the concept of **routers**. They are “sub-parts” of your API
    and are usually dedicated to a single type of object, such as users or posts,
    which are defined in their own files. You can then include them in your main FastAPI
    app so that it can route it accordingly.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 支持**路由器**的概念。它们是你 API 的“子部分”，通常专注于单一类型的对象，如用户或帖子，这些对象在各自的文件中定义。你可以将它们包含到你的主
    FastAPI 应用程序中，以便它能够进行相应的路由。
- en: In this section, we’ll explore how to use routers and how you can structure
    a FastAPI project. While this structure is one way to do it and works quite well,
    it’s not a golden rule and can be adapted to your own needs.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将探索如何使用路由器，以及如何结构化 FastAPI 项目。虽然这种结构是一种做法，并且效果很好，但它并不是一条金科玉律，可以根据你的需求进行调整。
- en: 'In the code examples repository, there is a folder named `chapter03_project`,
    which contains a sample project with this structure: [https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例的仓库中，有一个名为`chapter03_project`的文件夹，里面包含了一个示例项目，具有以下结构：[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project)
- en: 'Here is the project structure:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这是项目结构：
- en: '[PRE65]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, you can see that we chose to have packages that contain Pydantic models
    on one side and routers on the other side. At the root of the project, we have
    a file named `app.py`, `which` will expose the main FastAPI application. The `db.py`
    file defines a dummy database for the sake of the example.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们选择了将包含 Pydantic 模型的包放在一边，将路由器放在另一边。在项目的根目录下，我们有一个名为`app.py`的文件，`它`将暴露主要的
    FastAPI 应用程序。`db.py` 文件定义了一个虚拟数据库，供示例使用。
- en: The `__init__.py` files are there to properly define our directories as Python
    packages. You can read more details about this in [*Chapter 2*](B19528_02.xhtml#_idTextAnchor032),
    *Python Programming Specificities*, in the *Packages, modules, and* *imports*
    section.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py` 文件用于正确地将我们的目录定义为 Python 包。你可以在[*第二章*](B19528_02.xhtml#_idTextAnchor032)，“*Python
    编程特性*”章节的“*包、模块与导入*”部分阅读更多细节。'
- en: 'First, let’s examine what a FastAPI router looks like:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 FastAPI 路由器的样子：
- en: users.py
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: users.py
- en: '[PRE66]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project/routers/users.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project/routers/users.py)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project/routers/users.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project/routers/users.py)'
- en: As you can see here, instead of instantiating the `FastAPI` class, you instantiate
    the `APIRouter` class. Then, you can use it exactly the same way to decorate your
    path operation functions.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这里，你不是实例化 `FastAPI` 类，而是实例化 `APIRouter` 类。然后，你可以用相同的方式装饰你的路径操作函数。
- en: Also, notice that we import the Pydantic models from the relevant module in
    the `schemas` package.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，注意我们从 `schemas` 包中的相关模块导入了 Pydantic 模型。
- en: We won’t go into detail about the logic of the endpoints, but we invite you
    to read about it. It uses all the FastAPI features that we’ve explored so far.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细讨论端点的逻辑，但我们邀请你阅读相关内容。它使用了我们到目前为止探索的所有 FastAPI 特性。
- en: 'Now, let’s take a look at how to import this router and include it within a
    FastAPI application:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何导入这个路由器并将其包含在 FastAPI 应用中：
- en: app.py
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE67]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project/routers/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project/routers/app.py)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project/routers/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project/routers/app.py)'
- en: As usual, we instantiate the `FastAPI` class. Then, we use the `include_router`
    method to add our sub-router. You can see that we simply imported the router from
    its relevant module and used it as the first argument of `include_router`. Notice
    that we used the `as` syntax while importing. Since both `users` and `posts` routers
    are named the same inside their module, this syntax allows us to alias their name
    and, thus, avoid **name collision**.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们实例化了 `FastAPI` 类。然后，我们使用 `include_router` 方法添加子路由器。你可以看到，我们只是从相关模块中导入了路由器，并将其作为
    `include_router` 的第一个参数。注意，我们在导入时使用了 `as` 语法。由于 `users` 和 `posts` 路由器在它们的模块中命名相同，这种语法让我们可以给它们取别名，从而避免了**命名冲突**。
- en: Additionally, you can see that we set the `prefix` keyword argument. This allows
    us to prefix the path of all the endpoints of this router. This way, you don’t
    have to hardcode it into the router logic and can easily change it for the whole
    router. It can also be used to provide versioned paths of your API, such as `/v1`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以看到我们设置了 `prefix` 关键字参数。这使我们能够为该路由器的所有端点路径添加前缀。这样，你就不需要将其硬编码到路由器逻辑中，并且可以轻松地为整个路由器更改它。它还可以用来为你的
    API 提供版本化路径，比如 `/v1`。
- en: Finally, the `tags` argument helps you to group endpoints in the interactive
    documentation for better readability. By doing this, the `posts` and `users` endpoints
    will be clearly separated in the documentation.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`tags` 参数帮助你在交互式文档中对端点进行分组，以便更好地提高可读性。通过这样做，`posts` 和 `users` 端点将在文档中清晰分开。
- en: 'And that’s all you need to do! You can run this whole application, as usual,
    with Uvicorn:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要做的所有事情！你可以像往常一样使用 Uvicorn 运行整个应用：
- en: '[PRE68]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If you open the interactive documentation at `http://localhost:8000/docs`,
    you’ll see that all the routes are there, grouped by the tags we specified when
    including the router:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 `http://localhost:8000/docs` 的交互式文档，你会看到所有的路由都在其中，并且按我们在包含路由器时指定的标签进行分组：
- en: '![Figure 3.3 – Tagged routers in the interactive documentation](img/Figure_3.3_B19528.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 交互式文档中的标记路由器](img/Figure_3.3_B19528.jpg)'
- en: Figure 3.3 – Tagged routers in the interactive documentation
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 交互式文档中的标记路由器
- en: Once again, you can see that FastAPI is both powerful and very lightweight to
    use. The good thing about routers is that you can even nest them and include sub-routers
    in routers that include other routers themselves. Therefore, you can have a quite
    complex routing hierarchy with very low effort.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，你可以看到 FastAPI 功能强大且非常轻量化。路由器的一个好处是你可以将它们嵌套，甚至将子路由器包含在包含其他路由器的路由器中。因此，你可以在很少的努力下构建一个相当复杂的路由层次结构。
- en: Summary
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Well done! You’re now acquainted with all the basic features of FastAPI. Throughout
    this chapter, you learned how to create and run API endpoints where you can validate
    and retrieve data from all parts of an HTTP request: the path, the query, the
    parameters, the headers, and, of course, the body. You also learned how to tailor
    the HTTP response to your needs, whether it is a simple JSON response, an error,
    or a file to download. Finally, you looked at how to define separate API routers
    and include them in your main application to keep a clean and maintainable project
    structure.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你现在已经熟悉了 FastAPI 的所有基础功能。在本章中，你学习了如何创建和运行 API 端点，验证和获取 HTTP 请求的各个部分的数据：路径、查询、参数、头部，当然还有正文。你还学习了如何根据需求定制
    HTTP 响应，无论是简单的 JSON 响应、错误信息还是文件下载。最后，你了解了如何定义独立的 API 路由器，并将它们包含到你的主应用中，以保持清晰且易于维护的项目结构。
- en: You have enough knowledge now to start building your own API with FastAPI. In
    the next chapter, we’ll focus on Pydantic models. You now know that they are at
    the core of the data validation features of FastAPI, so it’s crucial to fully
    understand how they work and how to manipulate them efficiently.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了足够的知识，可以开始使用 FastAPI 构建你自己的 API。在接下来的章节中，我们将重点讲解 Pydantic 模型。你现在知道它们是
    FastAPI 数据验证功能的核心，因此彻底理解它们的工作原理以及如何高效地操作它们至关重要。
