- en: Data-Driven Customer Segmentation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据驱动的客户细分
- en: In marketing, we often try to understand the behavior of certain subgroups of
    the customer base. Especially in targeted marketing, marketers try to segment
    the customer base in certain ways and focus on each target segment or customer
    group. This concentration on certain target customer segments results in better
    performance, as the needs and interests of those customers in the target group
    align and match better with the business's products, services, or content.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在营销中，我们通常试图理解客户群体中某些子群体的行为。尤其是在精准营销中，营销人员尝试以某些方式对客户群体进行细分，并专注于每个目标细分群体或客户群体。专注于特定目标客户群体有助于提升营销效果，因为目标群体内的客户需求和兴趣与业务的产品、服务或内容更为契合，从而带来更好的业绩表现。
- en: In this chapter, we are going to dive deeper into the concept of customer segmentation.
    We will discuss what customer segmentation is, the importance and benefits of
    having a good understanding of different segments of the customer base, and how
    to utilize customer segment analysis results for different marketing strategies.
    Aside from a more traditional way of segmenting the customer base, which involves
    looking at the key statistics of certain attributes of customers and manually
    cutting the customer base into segments, we can also use machine learning to have
    machines find the best ways to split the customer base into the desired number
    of segments. In this chapter, we will learn how we can use the k-means clustering
    algorithm to build customer segments based on the historical data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨客户细分的概念。我们将讨论什么是客户细分，了解不同客户群体的细分的重要性和好处，以及如何利用客户细分分析结果制定不同的营销策略。除了传统的客户群体细分方法，通过查看客户某些属性的关键统计数据并手动将客户群体切分为多个细分群体，我们还可以使用机器学习，让机器找到将客户群体分割为期望数量细分群体的最佳方法。在本章中，我们将学习如何使用k-means聚类算法基于历史数据构建客户细分。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Customer segmentation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户细分
- en: Clustering algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚类算法
- en: Segmenting customers with Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python进行客户细分
- en: Segmenting customers with R
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用R进行客户细分
- en: Customer segmentation
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户细分
- en: Given today's competition within the market, it is critical to understand the
    different behaviors, types, and interests of customers. Especially in targeted
    marketing, understanding and categorizing customers is an essential step in forming
    effective marketing strategies. By segmenting the customer base, marketers can
    focus on one segment of customers at a time. It also helps marketers to tailor
    their marketing messages to one specific audience at a time. Customer segmentation
    is the backbone of successful targeted marketing, with which you can target specific
    groups of customers with different pricing options, promotions, and product placements
    that capture the interests of the target audience in the most cost-effective way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于当前市场中的竞争，理解客户的不同行为、类型和兴趣至关重要。尤其是在精准营销中，理解并分类客户是制定有效营销策略的必要步骤。通过细分客户群体，营销人员可以一次专注于一个客户群体。这也有助于营销人员将营销信息精准地传递给一个特定的受众。客户细分是成功精准营销的基础，通过细分，您可以以最具成本效益的方式，针对特定客户群体提供不同的定价选项、促销活动和产品布局，最大程度地吸引目标受众的兴趣。
- en: Any business or industry can benefit from a better understanding of different
    customer segments. For example, television advertisements that are broadcast across
    all over the USA for an outerwear brand that sells winter clothes, such as parkas,
    snow boots, and hats, would not be so cost-effective. People residing in areas
    that never really get cold, such as Florida, Southern California, or Hawaii, would
    most likely not be interested in purchasing winter clothes. However, people residing
    in areas with cold winters, such as Alaska, Minnesota, or North Dakota, would
    most likely want to buy clothes that will keep them warm. So, for this outerwear
    brand, instead of sending out marketing mails or emails to all of their customers,
    it would be better to target those segments of customers, based on their geographic
    information, that live in places where they would need winter clothes more frequently
    than other customers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 任何行业或企业都可以通过更好地理解不同的顾客群体而受益。例如，针对全美播放的电视广告，如果是某个销售冬季服饰（如大衣、雪地靴和帽子）的外套品牌，这样的广告可能并不具有成本效益。居住在那些从不寒冷的地区，如佛罗里达、南加州或夏威夷的人们，可能不会对购买冬季服装感兴趣。然而，居住在寒冷冬季地区的人们，比如阿拉斯加、明尼苏达或北达科他州的人们，可能更倾向于购买能保暖的衣物。因此，对于这个外套品牌而言，与其向所有顾客发送营销邮件或电子邮件，不如基于顾客的地理信息，锁定那些生活在需要冬季服装的地方的顾客群体。
- en: As another example, if you own a rental building near a college, you might want
    to target your customers based on their age and education. Marketing to customers
    between 20 and 30 and who are attending surrounding colleges will have higher
    return than marketing to others. For hotel businesses, you might want to target
    those couples who have upcoming anniversaries for romantic package deals. Using
    social media platforms, such as Facebook or Instagram, you can target this segment
    of customers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，如果你拥有一栋靠近大学的出租楼，可能希望根据顾客的年龄和教育背景来精准定位你的客户。将营销对象锁定在20到30岁之间并且就读于周边大学的顾客群体，回报将高于向其他人群体进行营销。对于酒店业来说，你可能希望将目标顾客定位为即将庆祝周年纪念的情侣，推出浪漫套餐。通过使用社交媒体平台，如Facebook或Instagram，你可以精准定位这一部分顾客。
- en: As we briefly discussed with these three cases, understanding your customers
    and which segment describes them the best can help you develop effective and efficient
    marketing strategies. When segmenting the customer base into subgroups, you can
    use certain characteristics and their statistics, as shown in [Chapter 7](72e8f4ee-7f95-4acc-928d-d33c9fc31bd6.xhtml),
    *Exploratory Analysis for Customer Behavior*. However, when you are trying to
    segment your customers with multiple attributes, it becomes exponentially more
    difficult. In the following sections, we are going to discuss how we can use machine
    learning for customer segmentation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这三个案例中简要讨论的那样，了解你的顾客以及哪一类顾客群体最能代表他们，有助于你制定有效和高效的营销策略。在将顾客群体细分为子群体时，你可以使用某些特征及其统计数据，如在[第7章](72e8f4ee-7f95-4acc-928d-d33c9fc31bd6.xhtml)《顾客行为的探索性分析》中所示。然而，当你试图通过多个属性来细分顾客时，事情变得越来越复杂。在接下来的部分，我们将讨论如何使用机器学习进行顾客细分。
- en: Clustering algorithms
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚类算法
- en: '**Clustering algorithms** are frequently used in marketing for customer segmentation.
    This is a method of unsupervised learning that learns the commonalities between
    groups from data. Unlike supervised learning, where there is a target and a labeled
    variable that you would like to predict, unsupervised learning learns from data
    without any target or labeled variable. Among numerous other clustering algorithms,
    we are going to explore the usage of the k-means clustering algorithm in this
    chapter.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚类算法**在市场营销中经常用于顾客细分。这是一种无监督学习方法，通过数据来学习不同群体之间的共性。与有监督学习不同，有监督学习有明确的目标和标签变量，旨在预测这些目标和标签变量，而无监督学习则是在没有任何目标或标签变量的情况下从数据中学习。在众多聚类算法中，我们将在本章中探讨k-means聚类算法的使用。'
- en: 'The k-means clustering algorithm splits the records in the data into a pre-defined
    number of clusters, where the data points within each cluster are close to each
    other. In order to group similar records together, the k-means clustering algorithm
    tries to find the centroids, which are the centers or means of clusters, to minimize
    the distances between the data points and the centroids within the clusters. The
    objective equation (from [https://scikit-learn.org/stable/modules/clustering.html#k-means](https://scikit-learn.org/stable/modules/clustering.html#k-means))
    looks like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: k-means聚类算法将数据记录划分为预定义数量的聚类，每个聚类内的数据点彼此接近。为了将相似的记录分组，k-means聚类算法会尝试寻找聚类的中心点，即聚类的中心或均值，以最小化数据点与聚类中心之间的距离。目标方程（来自[https://scikit-learn.org/stable/modules/clustering.html#k-means](https://scikit-learn.org/stable/modules/clustering.html#k-means)）如下所示：
- en: '![](img/f2785420-51f0-409c-80cd-28663ce10950.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2785420-51f0-409c-80cd-28663ce10950.png)'
- en: Here *n* is the number of records in the dataset, *x[i]* is the *i*th data point,
    *C* is the number of clusters, and *µ[j]* is the *j*th centroid.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里*n*是数据集中的记录数，*x[i]*是第*i*个数据点，*C*是聚类的数量，*µ[j]*是第*j*个中心点。
- en: 'One downside or difficulty of using k-means clustering for customer segmentation
    is the fact that you need to know the number of clusters beforehand. However,
    quite often, you do not know what is the optimal number of clusters to create.
    The silhouette coefficient can be used to evaluate and help you make decisions
    on what the best number of clusters will be for your segmentation problem. Simply
    put, the silhouette coefficient measures how close the data points are to their
    clusters compared to other clusters. The equation is shown here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用k-means聚类进行客户细分的一个缺点或难点是，您需要事先知道聚类的数量。然而，通常情况下，您并不知道最优的聚类数量是多少。轮廓系数可以用来评估并帮助您做出关于细分问题最佳聚类数量的决策。简单来说，轮廓系数衡量的是数据点与其聚类之间的接近程度，与其他聚类的接近程度相比。公式如下：
- en: '![](img/58a5fb9b-0539-4e54-ad29-baa5fc082d4b.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58a5fb9b-0539-4e54-ad29-baa5fc082d4b.png)'
- en: Here `b` is the average of the distance between a point and its closest cluster
    and `a` is the average distance among data points within the same cluster. The
    silhouette coefficient value ranges from -1 to 1, where the closer the values
    are to 1, the better they are. In the following programming exercises, we will
    be segmenting the customer base from our dataset, using the k-means clustering
    algorithm and the silhouette coefficient.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`b`是某点与其最近的聚类之间的平均距离，而`a`是同一聚类内数据点之间的平均距离。轮廓系数的值范围从-1到1，其中值越接近1，表示越好。在接下来的编程练习中，我们将使用k-means聚类算法和轮廓系数对我们的数据集进行客户群体划分。
- en: Segmenting customers with Python
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行客户细分
- en: In this section, we are going to discuss how to segment the customer base into
    subgroups using the clustering algorithm in Python. By the end of this section,
    we will have built a customer segmentation model using the k-means clustering
    algorithm. We will be mainly using the `pandas`, `matplotlib`, and `scikit-learn` packages
    to analyze, visualize, and build machine learning models. For those readers, who
    would like to use R, instead of Python, for this exercise, you can skip to the
    next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何使用Python中的聚类算法将客户群体划分为子群体。在本节结束时，我们将使用k-means聚类算法建立一个客户细分模型。我们将主要使用`pandas`、`matplotlib`和`scikit-learn`包来分析、可视化和构建机器学习模型。对于那些希望使用R语言而非Python的读者，可以跳过到下一节。
- en: 'For this exercise, we will be using one of the publicly available datasets
    from the UCI Machine Learning Repository, which can be found at this link: [http://archive.ics.uci.edu/ml/datasets/online+retail](http://archive.ics.uci.edu/ml/datasets/online+retail).
    You can follow this link and download the data, which is available in XLSX format,
    named `Online Retail.xlsx`. Once you have downloaded this data, you can load it
    into your Jupyter Notebook by running the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次练习中，我们将使用UCI机器学习库中一个公开可用的数据集，您可以通过以下链接找到：[http://archive.ics.uci.edu/ml/datasets/online+retail](http://archive.ics.uci.edu/ml/datasets/online+retail)。您可以点击该链接并下载数据，数据为XLSX格式，名为`Online
    Retail.xlsx`。下载数据后，您可以通过运行以下命令将其加载到您的Jupyter Notebook中：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The DataFrame, `df`, looks like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame，`df`，如下所示：
- en: '![](img/f5468769-a05c-42eb-b78b-b31ed60dd46d.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5468769-a05c-42eb-b78b-b31ed60dd46d.png)'
- en: As you can notice, we have used this dataset a few times in the previous chapters. As
    you might recall from previous chapters, there are a few things we need to clean
    up before we proceed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我们在前面的章节中已经多次使用了这份数据集。正如你在前面章节中记得的，继续之前，我们需要清理一些数据。
- en: Data cleanup
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据清理
- en: 'Before we can start building clustering models, there are five tasks we need
    to do to clean up our data and prepare it for modeling. The clean-up steps are
    as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建聚类模型之前，有五个任务需要完成，以清理数据并为建模做准备。清理步骤如下：
- en: '**Dropping canceled orders**: We are going to drop records with negative `Quantity`,
    using the following code:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除已取消的订单**：我们将删除`Quantity`列中为负值的记录，使用以下代码：'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Dropping records with no `CustomerID`**: There are `133,361` records with
    no `CustomerID` and we are going to drop those records with the following code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除没有`CustomerID`的记录**：有`133,361`条记录没有`CustomerID`，我们将使用以下代码删除这些记录：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Excluding an incomplete month**: As you might recall from previous chapters,
    the data in the month of December, 2011, is incomplete. You can exclude this data
    with the following code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**排除不完整的月份**：正如你在前面章节中记得的，2011年12月的数据是不完整的。你可以用以下代码排除这些数据：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Computing total sales from** **the Quantity and UnitPrice columns**: For
    our analyses, we need the total sales value, so we are going to multiply the two
    `Quantity` and `UnitPrice` columns, to get the total sales, as shown in the following
    code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从`Quantity`和`UnitPrice`列计算总销售额**：对于我们的分析，我们需要总销售额，因此我们将`Quantity`和`UnitPrice`两列相乘，得到总销售额，具体代码如下：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Per-customer data**: In order to analyze customer segments, we need to transform
    our data, so that each record represents the purchase history of individual customers.
    Take a look at the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**每个客户的数据**：为了分析客户群体，我们需要转化数据，使每条记录代表单个客户的购买历史。请查看以下代码：'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see from this code, we are grouping the `DataFrame`, `df`, by `CustomerID`
    and computing the total sales and the number of orders for each customer. Then,
    we also calculate the average per-order value, `AvgOrderValue`, by dividing the
    `TotalSales` column by the `OrderCount` column. The result is shown in the following
    screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从这段代码中看到的，我们通过`CustomerID`对`DataFrame`（`df`）进行分组，并计算每个客户的总销售额和订单数量。然后，我们还计算每个订单的平均值`AvgOrderValue`，方法是将`TotalSales`列除以`OrderCount`列。结果如下图所示：
- en: '![](img/2e9bfddd-62e5-43d9-814c-bcb7fbc4e241.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e9bfddd-62e5-43d9-814c-bcb7fbc4e241.png)'
- en: 'Now, as you can see from this data, the three columns, `TotalSales`, `OrderCount`,
    and `AvgOrderValue`, have different scales. `TotalSales` can take any values from
    `0` to `26,848`, while `OrderCount` takes values between `1` and `201`. Clustering
    algorithms are highly affected by the scales of the data, so we need to normalize
    this data to be on the same scale. We are going to take two steps to normalize
    this data. First, we are going to rank the data, so that the values of each column
    range from `1` to `4298`, which is the total number of records. Take a look at
    the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从这份数据中看到的，`TotalSales`、`OrderCount`和`AvgOrderValue`这三列数据的尺度不同。`TotalSales`的取值范围从`0`到`26,848`，而`OrderCount`的取值范围是从`1`到`201`。聚类算法对数据的尺度非常敏感，因此我们需要将这些数据归一化，使其具有相同的尺度。我们将采取两个步骤来归一化数据。首先，我们将对数据进行排名，使每一列的值范围从`1`到`4298`（即记录的总数）。请查看以下代码：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result is shown in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在以下截图中：
- en: '![](img/126f7dc1-1f1c-424d-81f5-686b2e44d060.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/126f7dc1-1f1c-424d-81f5-686b2e44d060.png)'
- en: 'Next, we are going to normalize this data to center around the mean and have
    a mean of `0` and a standard deviation of `1`. Take a look at the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对这些数据进行归一化，使其集中在均值周围，均值为`0`，标准差为`1`。请查看以下代码：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result is shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在以下截图中：
- en: '![](img/1bad843b-fbd9-471d-b4e5-fc43a62e6cd0.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bad843b-fbd9-471d-b4e5-fc43a62e6cd0.png)'
- en: 'Take a look at the statistics of each of these columns, shown in the following
    screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 查看每一列的统计数据，如下图所示：
- en: '![](img/c17e2528-0809-43b9-bf02-5adf9dfeddf4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c17e2528-0809-43b9-bf02-5adf9dfeddf4.png)'
- en: You can see that the values are centered around at `0` and have a standard deviation
    of `1`. We are going to use this data for the following clustering analyses.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，数据值集中在`0`周围，标准差为`1`。我们将使用这些数据进行接下来的聚类分析。
- en: k-means clustering
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: k-means 聚类
- en: The **k-means clustering** algorithm is a frequently used algorithm for drawing
    insights into the formations and separations within data. In marketing, it is
    often used to build customer segments and understand the behaviors of these different
    segments. Let's dive into building clustering models in Python.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**k-means聚类**算法是一个常用的算法，用于挖掘数据中的分布和分离。在营销中，它常被用来构建客户细分，并理解不同细分的行为。让我们深入了解如何在Python中构建聚类模型。'
- en: 'In order to use the k-means clustering algorithm in the `scikit-learn` package,
    we need to import the `kmeans` module, as shown in the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`scikit-learn`包中使用k-means聚类算法，我们需要导入`kmeans`模块，如下所示的代码：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, you can build and fit a k-means clustering model, using the following
    code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用以下代码构建并拟合一个k-means聚类模型：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see from this code, we are building a clustering model that splits
    the data into four segments. You can change the desired number of clusters with
    the `n_clusters` parameter. Using the `fit` function, you can train a k-means
    clustering algorithm to learn to split the given data. In this code, we are building
    four clusters, based on the `TotalSales`, `OrderCount`, and `AvgOrderValue` values.
    The trained model object, `kmeans`, stores the labels and centers of the clusters
    in the `labels_` and `cluster_centers_` attributes of the model object. You can
    retrieve these values as shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看到，我们正在构建一个聚类模型，将数据分成四个部分。你可以通过`n_clusters`参数来更改所需的聚类数量。使用`fit`函数，你可以训练一个k-means聚类算法，让它学会分割给定的数据。在这段代码中，我们基于`TotalSales`、`OrderCount`和`AvgOrderValue`值构建了四个聚类。训练后的模型对象`kmeans`将聚类的标签和中心存储在模型对象的`labels_`和`cluster_centers_`属性中。你可以通过以下代码来获取这些值：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have built our first clustering model, let''s visualize this data.
    First, take a look at the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了第一个聚类模型，让我们来可视化这些数据。首先，看看以下代码：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We store the cluster label information for each record into a newly created
    DataFrame, `four_cluster_df`. With this `DataFrame`, we can visualize the clusters,
    using the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每条记录的聚类标签信息存储到一个新创建的DataFrame `four_cluster_df`中。通过这个`DataFrame`，我们可以使用以下代码来可视化这些聚类：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see from this code, we are visualizing the data using scatter plots.
    The result is shown in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这段代码中，我们正在通过散点图来可视化数据。结果如下所示：
- en: '![](img/cf3a60cb-0e8e-416d-bf46-ce464c85d530.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf3a60cb-0e8e-416d-bf46-ce464c85d530.png)'
- en: 'Let''s take a closer look at this plot. The cluster in blue is the group of
    low-value customers, who have not purchased our products so much. On the other
    hand, the cluster in red is the group of high-value customers, who have purchased
    the greatest amount and who have purchased products frequently. We can also visualize
    the clusters with different angles, using the rest of the variables. Take a look
    at the following plots:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这个图。蓝色聚类是低价值客户群体，这些客户购买我们的产品较少。另一方面，红色聚类是高价值客户群体，这些客户购买了最多的产品并且购买频率较高。我们还可以使用其他变量从不同角度来可视化聚类。请看以下图：
- en: '![](img/0d93eb9d-2344-4996-96e4-05b1163a2fbc.png) ![](img/ff0c9ce9-0012-4d72-8afe-a43c0407c603.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d93eb9d-2344-4996-96e4-05b1163a2fbc.png) ![](img/ff0c9ce9-0012-4d72-8afe-a43c0407c603.png)'
- en: The first plot shows the clusters visualized based on `AvgOrderValue` and `OrderCount`.
    On the other hand, the second plot shows the clusters visualized based on `AvgOrderValue` and
    `TotalSales`. As you can see from these plots, the cluster in blue has the lowest
    average per-order value and the lowest number of orders. However, the cluster
    in red has the highest average per-order value and the greatest number of orders.
    Visualizing clusters helps you understand the characteristics of different clusters
    much more easily and clearly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个图显示了基于`AvgOrderValue`和`OrderCount`可视化的聚类。另一方面，第二个图显示了基于`AvgOrderValue`和`TotalSales`可视化的聚类。从这些图中可以看出，蓝色聚类的每单平均值最低，订单数也最少。然而，红色聚类的每单平均值最高，订单数也最多。通过可视化聚类，你可以更加容易和清晰地理解不同聚类的特征。
- en: Selecting the best number of clusters
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择最佳的聚类数量
- en: 'Often, we do not know what the best number of clusters to use is when building
    k-means clustering models. As discussed in an earlier section of this chapter,
    we can use the silhouette coefficient to determine what the best number of clusters
    is to split the data. In the `scikit-learn` package, you can use the `silhouette_score`
    function in the `sklearn.metrics` module to calculate the silhouette score and
    measure the quality of clusters. Take a look at the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在构建 k-means 聚类模型时，我们并不知道最佳的聚类数。正如本章前面部分所讨论的，我们可以使用轮廓系数来确定将数据分割成最佳聚类数。在 `scikit-learn`
    包中，你可以使用 `sklearn.metrics` 模块中的 `silhouette_score` 函数来计算轮廓分数，从而衡量聚类的质量。看看以下代码：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see from this code, we are experimenting with five different numbers
    of clusters: `4`, `5`, `6`, `7`, and `8`. For each amount of clusters, we are
    going to measure the silhouette score and choose the amount of clusters with the
    highest score. The output of this code looks like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看到，我们正在尝试五个不同数量的聚类：`4`、`5`、`6`、`7` 和 `8`。对于每一个聚类数，我们都会衡量轮廓分数，并选择分数最高的聚类数。该代码的输出如下所示：
- en: '![](img/120a5ca4-f783-4157-bd15-5ed4d103c34d.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/120a5ca4-f783-4157-bd15-5ed4d103c34d.png)'
- en: In our case, of the five different numbers of clusters we have experimented
    with, the best number of clusters with the highest silhouette score was `4`. In
    the following section, we will use `4` as the number of clusters to show how we
    can interpret the results of the clustering analysis.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，在我们尝试的五个不同的聚类数中，轮廓分数最高的最佳聚类数是 `4`。在接下来的部分中，我们将使用 `4` 作为聚类数，展示如何解释聚类分析的结果。
- en: Interpreting customer segments
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释客户细分
- en: 'In this section, we are going to discuss different ways to draw insights from
    the results of the previous clustering analysis. Let''s first build a k-means
    clustering model with four clusters. You can use the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将讨论从前面的聚类分析结果中提取洞察的不同方法。首先，让我们构建一个包含四个聚类的 k-means 聚类模型。你可以使用以下代码：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see from this code, we are fitting a k-means clustering model with
    `4` clusters, based on three attributes: `TotalSales`, `OrderCount`, and `AvgOrderValue`.
    Then, we store the cluster label information into a DataFrame, `four_cluster_df`.
    This DataFrame is shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看到，我们正在使用基于三个属性：`TotalSales`（总销售额）、`OrderCount`（订单数）和 `AvgOrderValue`（每单平均值）的
    `4` 个聚类来拟合 k-means 聚类模型。然后，我们将聚类标签信息存储到一个 DataFrame `four_cluster_df` 中。这个 DataFrame
    如下图所示：
- en: '![](img/85420d12-e0cf-4985-a6e9-28b16c9bc6ca.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85420d12-e0cf-4985-a6e9-28b16c9bc6ca.png)'
- en: 'The first thing we are going to look at is the centers of each cluster. You
    can get the cluster centers using the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要查看的是每个聚类的中心。你可以使用以下代码获取聚类中心：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of this code is shown in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下面的截图所示：
- en: '![](img/63a9df3e-69eb-49e5-88e4-2a1505d6a11b.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63a9df3e-69eb-49e5-88e4-2a1505d6a11b.png)'
- en: Let's take a closer look at this. The fourth cluster has the lowest numbers
    for all three attributes. This suggests that the fourth cluster contains customers
    with the smallest amount of sales, smallest number of orders, and lowest average
    per-order value. This group of customers is one of low-value customers. On the
    other hand, the third cluster has the highest numbers for all three attributes.
    The customers in the third cluster have the greatest amount of sales, greatest
    number of orders, and highest average per-order value. So, these customers in
    the third cluster purchase expensive items and give the business the highest revenue.
    You would typically want to focus your marketing efforts on this segment of customers,
    as it will result in the highest return.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这一点。第四个聚类在所有三个属性上都具有最低的值。这表明第四个聚类包含销售额最少、订单数量最少、每单平均值最低的客户。这组客户是低价值客户。另一方面，第三个聚类在所有三个属性上都有最高的数值。第三个聚类中的客户拥有最高的销售额、最多的订单数和最高的每单平均值。因此，第三个聚类中的客户购买高价商品，并为业务带来了最高的收入。你通常会希望将营销重点放在这一部分客户身上，因为这样会带来最高的回报。
- en: The customers in the second cluster are interesting. They make purchases relatively
    frequently, as they have a medium-to-high cluster center value for `OrderCount`,
    but their average per-order value is low, as the cluster center for `AvgOrderValue`
    is low. These are the customers who make frequent purchases of low-value items.
    So, it would be perfect to market items with low per-item prices to this segment
    of customers. The customers in the first cluster are also interesting. Their contributions
    to the revenue and number of orders are medium to low, looking at the centers
    of this cluster. However, their average per-order value is high. These are the
    customers who buy expensive items infrequently. Thus, it would be perfect to market
    expensive items to this segment of customers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个聚类的客户非常有趣。他们购买频率相对较高，因为他们的`OrderCount`的聚类中心值属于中高范围，但他们的每单平均消费较低，因为`AvgOrderValue`的聚类中心值较低。这些客户经常购买低价值商品。因此，向这一客户群体推广单价较低的商品将是非常合适的。第一个聚类的客户也很有意思。从聚类中心来看，他们对收入和订单数量的贡献属于中低水平，但他们的每单平均消费较高。这些客户购买昂贵商品的频率较低。因此，向这一客户群体推广昂贵商品将是非常合适的。
- en: 'As you can see from this example, looking at the centers of clusters helps
    us understand different types and segments of customers and how to target them
    differently. Lastly, we can also find out what the best-selling items are for
    each customer segment. Take a look at the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，观察聚类中心有助于我们理解不同类型和细分的客户，以及如何针对不同群体进行差异化营销。最后，我们还可以找出每个客户细分市场的畅销商品。看看以下代码：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we have seen before, the third cluster was the group of high-value customers,
    and we are going to take a look at the top five best-selling items for this group.
    The output of this code is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，第三个聚类是高价值客户群体，我们将查看该群体的前五个畅销商品。此代码的输出如下：
- en: '![](img/a6ce561c-d6b2-4ae2-a2b3-cabc1c3b3d8d.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6ce561c-d6b2-4ae2-a2b3-cabc1c3b3d8d.png)'
- en: For this high-value segment, the best-selling item was `JUMBO BAG RED RETROSPOT`
    and the second best-selling item was `REGENCY CAKESTAND 3 TIER`. You can utilize
    this information in marketing strategies, when you target this customer segment.
    In your marketing campaigns, you can recommend items similar to these best-selling
    items to this segment of customers, as they are the most interested in these types
    of items.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一高价值细分市场，最畅销的商品是`JUMBO BAG RED RETROSPOT`，第二畅销商品是`REGENCY CAKESTAND 3 TIER`。当你针对这一客户群体制定营销策略时，可以利用这些信息。在营销活动中，你可以向这一客户群体推荐与这些畅销商品相似的商品，因为他们对这类商品最感兴趣。
- en: 'You can find the full code for this exercise in the following repository: [https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.10/python/CustomerSegmentation.ipynb](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.10/python/CustomerSegmentation.ipynb).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下仓库找到本次练习的完整代码：[https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.10/python/CustomerSegmentation.ipynb](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.10/python/CustomerSegmentation.ipynb)。
- en: Segmenting customers with R
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 R 进行客户细分
- en: In this section, we are going to discuss how to segment the customer base into
    subgroups using a clustering algorithm in R. By the end of this section, we will
    have built a customer segmentation model using the k-means clustering algorithm. For
    those readers who would like to use Python, instead of R, for this exercise, see
    the previous section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何使用 R 语言中的聚类算法将客户群体划分为子群体。到本节结束时，我们将使用 k-means 聚类算法构建一个客户细分模型。对于那些希望使用
    Python 而非 R 完成此练习的读者，请参阅上一节内容。
- en: 'For this exercise, we will be using one of the publicly available datasets
    from the UCI Machine Learning Repository, which can be found at this link: [http://archive.ics.uci.edu/ml/datasets/online+retail](http://archive.ics.uci.edu/ml/datasets/online+retail).
    You can follow this link and download the data, which is available in XLSX format,
    named `Online Retail.xlsx`. Once you have downloaded this data, you can load it
    into your RStudio by running the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本次练习，我们将使用来自 UCI 机器学习库的一个公开数据集，数据集可以通过以下链接找到：[http://archive.ics.uci.edu/ml/datasets/online+retail](http://archive.ics.uci.edu/ml/datasets/online+retail)。你可以点击此链接下载数据，数据以
    XLSX 格式提供，名为`Online Retail.xlsx`。下载完数据后，你可以通过运行以下命令将其加载到 RStudio 中：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The DataFrame, `df`, is shown in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了数据框`df`：
- en: '![](img/9b038be6-75b9-4d33-881a-81dac9d8e3fd.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b038be6-75b9-4d33-881a-81dac9d8e3fd.png)'
- en: As you may have noticed, we have used this dataset a few times in the previous
    chapters. As you might recall from previous chapters, there are a few things we
    need to clean up before we proceed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，我们在前面的章节中多次使用了这个数据集。你可能还记得，在继续之前，我们需要清理一些数据。
- en: Data cleanup
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据清理
- en: 'Before we can start building clustering models, there are five tasks we need
    to do to clean up our data and prepare it for modeling. The clean-up steps are
    as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建聚类模型之前，有五个任务需要完成，以清理数据并为建模做好准备。清理步骤如下：
- en: '**Dropping canceled orders**: We are going to drop records with negative `Quantity`,
    using the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除取消的订单**：我们将使用以下代码删除 `Quantity` 为负数的记录：'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Dropping records with no CustomerID**: There are `133,361` records with no `CustomerID` and
    we are going to drop those records with the following code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除没有 CustomerID 的记录**：有 `133,361` 条记录没有 `CustomerID`，我们将使用以下代码删除这些记录：'
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Excluding an incomplete month**: As you might recall from previous chapters,
    the data in the month of December, 2011, is incomplete. You can exclude this data
    with the following code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**排除不完整的月份**：你可能还记得，在前面的章节中，2011年12月的数据是不完整的。你可以使用以下代码排除这些数据：'
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Computing total sales from the Quantity and UnitPrice columns**: For our
    analyses, we need the total sales value, so we are going to multiply the `Quantity` and `UnitPrice`
    columns, to get the total sales, as shown in the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从 Quantity 和 UnitPrice 列计算总销售额**：为了进行分析，我们需要总销售额，因此我们将 `Quantity` 和 `UnitPrice`
    列相乘，得到总销售额，如以下代码所示：'
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Per-customer data**: In order to analyze customer segments, we need to transform
    our data, so that each record represents the purchase history of individual customers.
    Take a look at the following code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**按客户数据**：为了分析客户细分，我们需要转换数据，使每条记录代表单个客户的购买历史。请看以下代码：'
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see from this code, we are grouping the DataFrame, `df`, by `CustomerID` and
    computing the total sales and the number of orders for each customer. Then, we
    also calculate the average per-order value, `AvgOrderValue`, by dividing the `TotalSales` column
    by the `OrderCount` column. The result is shown in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这段代码中，我们将数据框 `df` 按 `CustomerID` 分组，计算每个客户的总销售额和订单数量。然后，我们还计算每个订单的平均订单值
    `AvgOrderValue`，通过将 `TotalSales` 列除以 `OrderCount` 列来获得。结果如下所示：
- en: '![](img/c0592e46-d55e-4294-836c-d066aa92a56f.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0592e46-d55e-4294-836c-d066aa92a56f.png)'
- en: 'Now, as you can see from this data, the `TotalSales`, `OrderCount`, and `AvgOrderValue`
    columns, have different scales. `TotalSales` can take any values from `0` to `26,848`,
    while `OrderCount` takes values between `1` and `201`. Clustering algorithms are
    highly affected by the scales of the data, so we need to normalize this data to
    be on the same scale. We are going to take two steps to normalize this data. First,
    we are going to rank the data, so that the values of each column range from `1` to `4298`,
    which is the total number of records. Take a look at the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这些数据中，`TotalSales`、`OrderCount` 和 `AvgOrderValue` 列的尺度不同。`TotalSales`
    的值范围从 `0` 到 `26,848`，而 `OrderCount` 的值介于 `1` 和 `201` 之间。聚类算法高度依赖数据的尺度，因此我们需要对这些数据进行归一化处理，使其具有相同的尺度。我们将采取两步来归一化这些数据。首先，我们将对数据进行排名，使每一列的值范围从
    `1` 到 `4298`，即记录的总数。请看以下代码：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The result is shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/b1420338-a64d-4835-8315-fd540e09fc3c.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1420338-a64d-4835-8315-fd540e09fc3c.png)'
- en: 'Next, we are going to normalize this data to center around the mean, and have
    a mean of `0` and a standard deviation of `1`, using the `scale` function in R.
    Take a look at the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对这些数据进行归一化，使其围绕均值进行中心化，均值为 `0`，标准差为 `1`，使用 R 中的 `scale` 函数。请看以下代码：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result is shown in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/cc0d9282-7791-4d3d-8532-6e2feafde93f.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc0d9282-7791-4d3d-8532-6e2feafde93f.png)'
- en: 'Take a look at the statistics of each of these columns, as shown in the following
    screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 查看每一列的统计数据，如下所示：
- en: '![](img/3565018b-68bc-439f-81a1-793ea6211417.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3565018b-68bc-439f-81a1-793ea6211417.png)'
- en: You can see that the values are centered around at `0` and have a standard deviation
    of `1`. We are going to use this data for the following clustering analyses.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这些值围绕 `0` 中心，并且标准差为 `1`。我们将使用这些数据进行接下来的聚类分析。
- en: k-means clustering
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: k-means 聚类
- en: The **k-means clustering** algorithm is a frequently used algorithm to draw
    insights on the formations and separations within the data. In marketing, it is
    often used to build customer segments and understand the behaviors of these different
    segments. Let's dive into building clustering models in R.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**k-means 聚类**算法是一个常用的算法，用于分析数据中的分布和分离。在营销中，它常被用于构建客户细分，并理解这些不同细分的行为。让我们深入了解如何在R中构建聚类模型。'
- en: 'You can build and fit a k-means clustering model using the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码来构建和拟合一个k-means聚类模型：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see from this code, we are building a clustering model that splits
    the data into `4` segments. The first parameter of the `kmeans` function is for
    the data to be used for k-means clustering and the second parameter is to define
    the desired number of clusters. In this code, we are building `4` clusters, based
    on the `TotalSales`, `OrderCount`, and `AvgOrderValue` values. The trained k-means
    clustering model object, `cluster`, stores the labels and centers of the clusters
    in the `cluster` and `centers` variables of the model object. You can retrieve
    these values, as shown in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这段代码中我们正在构建一个聚类模型，将数据分成`4`个部分。`kmeans`函数的第一个参数用于指定进行k均值聚类的数据，第二个参数定义了期望的聚类数量。在这段代码中，我们构建了`4`个聚类，基于`TotalSales`、`OrderCount`和`AvgOrderValue`值。训练后的k均值聚类模型对象`cluster`将聚类标签和中心存储在模型对象的`cluster`和`centers`变量中。你可以通过以下代码来提取这些值：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have built our first clustering model, let''s visualize this data.
    First, we are going to store the cluster labels as a separate column, named `Cluster`,
    in the `normalizedDF` variable, as shown in the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了第一个聚类模型，让我们来可视化这些数据。首先，我们将聚类标签存储为一个名为`Cluster`的单独列，放入`normalizedDF`变量中，如以下代码所示：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we can visualize the clusters, using the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码来可视化聚类：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see from this code, we are visualizing the data using scatterplots.
    The result in shown in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这段代码中我们正在使用散点图来可视化数据。结果如以下截图所示：
- en: '![](img/8f0fa682-ec51-4a5b-8927-49e536fa1566.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f0fa682-ec51-4a5b-8927-49e536fa1566.png)'
- en: 'Let''s take a closer look at this plot. The cluster in the bottom left is the
    group of low-value customers, who have not purchased our products so much. On
    the other hand, the cluster in the top right with the darkest color is the group
    of high-value customers, who have purchased the greatest amount and who have purchased
    products frequently. We can also visualize the clusters with different angles,
    using the rest of the variables. Take a look at the following plots:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这个图。左下角的聚类是低价值客户群体，这些客户购买我们的产品较少。另一方面，右上角颜色最深的聚类是高价值客户群体，这些客户购买的数量最多，而且购买频率很高。我们还可以使用其他变量，从不同的角度来可视化这些聚类。请看以下几个图：
- en: '![](img/6be6df8c-46c0-4f9f-a21a-501922c395ce.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6be6df8c-46c0-4f9f-a21a-501922c395ce.png)'
- en: '![](img/b59c48f0-4142-4a5a-b1c3-3525d90911d4.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59c48f0-4142-4a5a-b1c3-3525d90911d4.png)'
- en: The first plot shows the clusters visualized based on `AvgOrderValue` and `OrderCount`.
    On the other hand, the second plot the clusters visualized based on `AvgOrderValue` and `TotalSales`.
    As you can see from these plots, the cluster in the bottom left with the second-lightest
    color has the lowest average per-order value and the lowest number of orders.
    However, the cluster in the top right with the darkest color has the highest average
    per-order value and the greatest number of orders. Visualizing clusters helps
    you understand the characteristics of different clusters much more easily and
    clearly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个图展示了基于`AvgOrderValue`和`OrderCount`可视化的聚类。第二个图展示了基于`AvgOrderValue`和`TotalSales`可视化的聚类。正如你从这些图中看到的，左下角颜色第二浅的聚类，具有最低的每单平均值和最低的订单数量。然而，右上角颜色最深的聚类，具有最高的每单平均值和最多的订单数。聚类的可视化帮助你更轻松、更清晰地理解不同聚类的特征。
- en: Selecting the best number of clusters
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择最佳的聚类数量
- en: 'Quite often, we do not know what the best number of clusters to use is when
    building k-means clustering models. As discussed in an earlier section of this
    chapter, we can use the silhouette coefficient to determine what the best number
    of clusters is to split the data. In R, you can use the `silhouette` function
    in the `cluster` library to calculate the silhouette score and measure the quality
    of clusters. Take a look at the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，在构建k-means聚类模型时，我们并不知道最佳的聚类数量。正如本章前面部分所讨论的那样，我们可以使用轮廓系数来确定最适合划分数据的聚类数量。在R中，你可以使用`cluster`库中的`silhouette`函数来计算轮廓系数并衡量聚类质量。看看下面的代码：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see from this code, we are experimenting with five different number
    of clusters: `4`, `5`, `6`, `7`, and `8`. For each number of clusters, we are
    going to measure the silhouette score and choose the number of clusters with the
    highest score. The output of this code is shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从这段代码中所见，我们正在实验五种不同数量的聚类：`4`、`5`、`6`、`7` 和 `8`。对于每种聚类数量，我们将衡量轮廓系数并选择得分最高的聚类数量。此代码的输出结果如下所示：
- en: '![](img/71fd5298-4fb1-4576-846a-81667a4b383f.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71fd5298-4fb1-4576-846a-81667a4b383f.png)'
- en: In our case, of the five different numbers of clusters we have experimented
    with, the best number of clusters with the highest silhouette score was `4`. In
    the following section, we will use `4` for the number of clusters to show how
    we can interpret the results of clustering analysis.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实验中，五种不同聚类数量中，得分最高的聚类数量是`4`。在接下来的部分中，我们将使用`4`作为聚类数量，展示如何解读聚类分析的结果。
- en: Interpreting customer segments
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解读客户细分
- en: 'In this section, we are going to discuss different ways to draw insights from
    the results of the previous clustering analysis. Let''s first build a k-means
    clustering model with `4` clusters. You can use the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论从前面聚类分析结果中提取不同洞察的方法。首先，我们将构建一个`4`个聚类的k-means聚类模型。你可以使用以下代码：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see from this code, we are fitting a k-means clustering model with `4` clusters,
    based on the three attributes: `TotalSales`, `OrderCount`, and `AvgOrderValue`.
    Then, we store the cluster label information into a DataFrame, `normalizedDF`.
    This DataFrame is shown in the following screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从这段代码中所见，我们正在根据三个属性：`TotalSales`、`OrderCount` 和 `AvgOrderValue`，拟合一个`4`个聚类的k-means聚类模型。然后，我们将聚类标签信息存储到一个DataFrame中，命名为`normalizedDF`。该DataFrame的内容如下所示：
- en: '![](img/dcc5181c-f58a-4f37-a201-47af60d942af.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcc5181c-f58a-4f37-a201-47af60d942af.png)'
- en: 'The first thing we are going to look at is the centers of each cluster. You
    can get the cluster centers using the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要查看的是每个聚类的中心。你可以使用以下代码来获取聚类中心：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output of this code is shown in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出结果如下所示：
- en: '![](img/8870c2db-382e-497c-af61-322637e57e57.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8870c2db-382e-497c-af61-322637e57e57.png)'
- en: Let's take a closer look at this. The third cluster has the lowest numbers for
    all three attributes. This suggests that the third cluster contains customers
    with the lowest amount of sales, lowest number of orders, and lowest average per-order
    value. This group of customers is a group of low-value customers. On the other
    hand, the fourth cluster has the highest numbers for all three attributes. The
    customers in the fourth cluster have the highest amount of sales, highest number
    of orders, and highest average per-order value. This suggests that these customers
    in the fourth cluster purchase expensive items and give the business the highest
    revenue. You would typically want to focus your marketing efforts on this segment
    of customers, as it will result in the highest return.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这个。第三个聚类在所有三个属性上的数值都是最低的。这表明，第三个聚类包含的是销售额最低、订单数量最少、每单平均值最低的客户。这组客户是低价值客户。另一方面，第四个聚类在所有三个属性上的数值都是最高的。第四个聚类的客户拥有最高的销售额、最多的订单数量以及最高的每单平均值。这表明，这些客户购买了价格昂贵的商品，并为企业带来了最高的收入。你通常会希望将营销精力集中在这个客户群体上，因为这将带来最高的回报。
- en: The customers in the first cluster are interesting. They make purchases relatively
    frequently, as they have a medium to high cluster center value for `OrderCount`,
    but their average per-order value is low, as the cluster center for `AvgOrderValue` is
    low. These are the type of customers who make frequent purchases of low-value
    items. So, it would be perfect to market items with low per-item prices to this
    segment of customers. The customers in the second cluster are also interesting.
    Their contributions to the revenue and number of orders are low, looking at the
    centers of this cluster. However, their average per-order value is high. These
    are the type of customers who buy expensive items infrequently. Thus, it would
    be perfect to market expensive items to this segment of customers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个聚类中的客户很有趣。他们的购买频率相对较高，因为他们在`OrderCount`上的聚类中心值处于中到高水平，但他们的每单平均消费较低，因为`AvgOrderValue`的聚类中心值较低。这类客户经常购买低价值商品。因此，向这一类客户推广单品价格较低的商品是非常合适的。第二个聚类的客户也很有意思。根据该聚类的中心，他们的收入贡献和订单数较低。然而，他们的每单平均消费较高。这类客户购买高价商品的频率较低。因此，向这一类客户推广昂贵的商品非常合适。
- en: 'As you can see from this example, looking at the centers of clusters helps
    us understand different types and segments of customers and how to target them
    differently. Lastly, we can also find out what the best-selling items are for
    each customer segment. Take a look at the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从这个例子中看到的，通过查看聚类的中心，可以帮助我们理解不同类型和细分的客户，并了解如何采取不同的方式来针对他们。最后，我们还可以找到每个客户细分群体的畅销商品。请看以下代码：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we have seen before, the fourth cluster was the group of high-value customers
    and we are going to take a look at the best-selling items for this group. The
    output of this code is shown in the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，第四个聚类是高价值客户群体，我们将查看这一群体的畅销商品。此代码的输出结果如下图所示：
- en: '![](img/cd6cdcfe-9b9e-44af-997a-f5e24b82267b.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd6cdcfe-9b9e-44af-997a-f5e24b82267b.png)'
- en: For this high-value segment, the best-selling item was **JUMBO BAG RED RETROSPOT **and
    the second best-selling item was **REGENCY CAKESTAND 3 TIER**. You can utilize
    this information in the marketing strategies, when you target this customer segment.
    In your marketing campaigns, you can recommend items similar to these best-selling
    items to this segment of customers, as they are the most interested in these types
    of items.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个高价值群体，最畅销的商品是**JUMBO BAG RED RETROSPOT**，第二畅销商品是**REGENCY CAKESTAND 3 TIER**。当你针对这一客户群体时，可以将这些信息用于营销策略。在你的营销活动中，你可以推荐与这些畅销商品类似的商品给这一群体的客户，因为他们对这些类型的商品最感兴趣。
- en: You can find the full code for this exercise in the following repository: [https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.10/R/CustomerSegmentation.R](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.10/R/CustomerSegmentation.R).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下仓库中找到本练习的完整代码：[https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.10/R/CustomerSegmentation.R](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.10/R/CustomerSegmentation.R)。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned more about customer segmentation. We worked
    through three simple scenarios of how customer segmentation could help different
    businesses to form better and more cost-effective marketing strategies. We have
    discussed how having a good understanding of different customer segments, how
    customers in different segments behave, and what they need and are interested
    in can help you target your audience better. We have also learned about the k-means
    clustering algorithm, which is one of the most frequently used clustering algorithms
    for customer segmentation. In order to evaluate the quality of clusters, we have
    shown how we can use the silhouette coefficient.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了解了客户细分。我们探讨了客户细分如何帮助不同的企业形成更好、更具成本效益的营销策略的三种简单场景。我们讨论了了解不同客户细分的重要性，理解不同细分群体中的客户行为，以及他们的需求和兴趣如何帮助你更好地定位受众。我们还学习了k-means聚类算法，它是用于客户细分的最常用的聚类算法之一。为了评估聚类的质量，我们展示了如何使用轮廓系数。
- en: During programming exercises, we have experimented with how we can build a k-means
    clustering model in Python and R. In Python, we could use the `KMeans` module
    in the `scikit-learn` package and in R, we could use the `kmeans` function to
    build clustering models. Using the `silhouette_score` function in Python and the `silhouette`
    function in R, we have seen how we could use silhouette coefficients to evaluate
    the qualities of clusters and have seen how looking at silhouette scores can help
    us determine the best number of clusters. Lastly, we have discussed how to interpret
    clustering analysis results, using scatter plots and cluster centroids, and we
    have seen how to find out the best-selling items for each customer segment.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程练习中，我们实验了如何在 Python 和 R 中构建 k-means 聚类模型。在 Python 中，我们可以使用 `scikit-learn`
    包中的`KMeans`模块，而在 R 中，我们可以使用 `kmeans` 函数来构建聚类模型。通过使用 Python 中的 `silhouette_score`
    函数和 R 中的 `silhouette` 函数，我们了解了如何利用轮廓系数来评估聚类的质量，并看到了如何通过查看轮廓分数来帮助我们确定最佳的聚类数量。最后，我们讨论了如何解读聚类分析结果，使用散点图和聚类中心，并看到如何为每个客户群体找出最畅销的商品。
- en: In the next chapter, we are going to discuss customers at risk of churn and
    how to retain those customers. We will work together to build neural network models
    in Python and R, using the `keras` package, to identify those customers who are
    likely to churn.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论面临流失风险的客户以及如何留住这些客户。我们将共同在 Python 和 R 中使用 `keras` 包构建神经网络模型，以识别那些可能流失的客户。
