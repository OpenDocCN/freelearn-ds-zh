- en: Chapter 6. Advanced Visualization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章：高级可视化
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Making nicer matplotlib figures with prettyplotlib
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 prettyplotlib 创建更漂亮的 matplotlib 图形
- en: Creating beautiful statistical plots with seaborn
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 seaborn 创建漂亮的统计图
- en: Creating interactive web visualizations with Bokeh
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bokeh 创建交互式 Web 可视化
- en: Visualizing a NetworkX graph in the IPython notebook with D3.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 IPython 笔记本中使用 D3.js 可视化 NetworkX 图形
- en: Converting matplotlib figures to D3.js visualizations with mpld3
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 mpld3 将 matplotlib 图形转换为 D3.js 可视化
- en: Getting started with Vispy for high-performance interactive data visualizations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Vispy 开始进行高性能交互式数据可视化
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Visualization is a central theme of this book. We create graphics in most recipes
    because that's the most efficient way to communicate quantitative information.
    In most cases, we use matplotlib to create plots. In this chapter, we will see
    more advanced visualization features in Python.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化是本书的一个核心主题。我们在大多数食谱中创建图形，因为这是传达定量信息的最有效方式。在大多数情况下，我们使用 matplotlib 来创建图表。在本章中，我们将看到
    Python 中更高级的可视化功能。
- en: First, we will see a few packages that let us improve the default styling of
    matplotlib figures and the MATLAB-like pyplot interface. There are other high-level
    visualization programming interfaces that can be more convenient in some situations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看到几个包，它们可以让我们改善 matplotlib 图形的默认样式和类似 MATLAB 的 pyplot 接口。还有其他一些高层次的可视化编程接口，在某些情况下可能更方便。
- en: Also, the Web platform is getting closer and closer to Python. The IPython notebook
    is a good example of this trend. In this chapter, we will see a few techniques
    and libraries to create interactive Web visualizations in Python. These techniques
    will let us combine the power of Python for data analysis and the power of the
    Web for interactivity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Web 平台正在越来越接近 Python。IPython 笔记本就是这种趋势的一个很好例子。在本章中，我们将看到一些技术和库，帮助我们在 Python
    中创建交互式 Web 可视化。这些技术让我们能够将 Python 在数据分析方面的强大功能与 Web 在交互性方面的优势结合起来。
- en: Finally, we will introduce Vispy, a new high-performance interactive visualization
    library for big data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍 Vispy，这是一个新的高性能交互式可视化库，专为大数据而设计。
- en: Making nicer matplotlib figures with prettyplotlib
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 prettyplotlib 创建更漂亮的 matplotlib 图形
- en: matplotlib is sometimes criticized for the default appearance of its figures.
    For example, the default color maps are neither aesthetically appealing nor do
    they present perceptually clear information.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: matplotlib 有时因其图形的默认外观而受到批评。例如，默认的颜色映射既不具美学吸引力，也没有清晰的感知信息。
- en: There are many attempts to circumvent this problem. In this recipe, we will
    present **prettyplotlib**, created by Olga Botvinnik. This lightweight Python
    library considerably improves the default styling of many kinds of matplotlib
    figures.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法试图规避这个问题。在本食谱中，我们将介绍**prettyplotlib**，这是由 Olga Botvinnik 创建的。这款轻量级 Python
    库显著改善了许多 matplotlib 图形的默认样式。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will find the installation instructions of prettyplotlib on the project's
    page at [http://github.com/olgabot/prettyplotlib](http://github.com/olgabot/prettyplotlib).
    You can basically just do `pip install prettyplotlib` in a terminal.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目页面找到 prettyplotlib 的安装说明，网址是 [http://github.com/olgabot/prettyplotlib](http://github.com/olgabot/prettyplotlib)。你基本上只需在终端中执行
    `pip install prettyplotlib` 即可。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Let''s first import NumPy and matplotlib:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们导入 NumPy 和 matplotlib：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then draw several curves with matplotlib:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们用 matplotlib 绘制几条曲线：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![How to do it…](img/4818OS_06_01.jpg)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现……](img/4818OS_06_01.jpg)'
- en: Note
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're reading the printed version of this book, you won't see the colors.
    You can find the colored images on the book's website.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书的印刷版，你将看不到颜色。你可以在本书的网站上找到彩色图像。
- en: 'Now, we create the exact same plot with prettyplotlib. We just replace the
    `matplotlib.pyplot` namespace with `prettyplotlib`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们用 prettyplotlib 创建完全相同的图表。我们只需将 `matplotlib.pyplot` 命名空间替换为 `prettyplotlib`：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![How to do it…](img/4818OS_06_02.jpg)'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现……](img/4818OS_06_02.jpg)'
- en: 'Let''s show another example with an image. We first use matplotlib''s `pcolormesh()`
    function to display a 2D array as an image:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过一个图像展示另一个示例。我们首先使用 matplotlib 的 `pcolormesh()` 函数将 2D 数组显示为图像：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![How to do it…](img/4818OS_06_03.jpg)'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现……](img/4818OS_06_03.jpg)'
- en: The default *rainbow* color map is known to cause visualized data to be misinterpreted.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认的*彩虹*颜色映射被认为会导致可视化数据被误解。
- en: 'Now, we use prettyplotlib to display the exact same image:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用 prettyplotlib 显示完全相同的图像：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![How to do it…](img/4818OS_06_04.jpg)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现……](img/4818OS_06_04.jpg)'
- en: This visualization is much clearer, in that high or low values are more obvious
    than with the rainbow color map.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种可视化方式要更加清晰，因为高值或低值比彩虹色图更明显。
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: prettyplotlib merely tweaks the default styling options of matplotlib. The plotting
    interface is basically the same as matplotlib. To understand how to modify matplotlib's
    styling, it is worthwhile looking at prettyplotlib's code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: prettyplotlib 只是对 matplotlib 的默认样式选项进行了微调。它的绘图接口基本上与 matplotlib 相同。要了解如何修改 matplotlib
    的样式，值得查看 prettyplotlib 的代码。
- en: There's more…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'There are other ways to improve matplotlib''s styling:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 改进 matplotlib 样式的其他方法有很多：
- en: A blog post by Randal Olson explains how to make clean and beautiful plots with
    matplotlib; this is available at [http://www.randalolson.com/2014/06/28/how-to-make-beautiful-data-visualizations-in-python-with-matplotlib/](http://www.randalolson.com/2014/06/28/how-to-make-beautiful-data-visualizations-in-python-with-matplotlib/)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Randal Olson 的一篇博客文章解释了如何使用 matplotlib 创建干净且美观的图表；你可以在 [http://www.randalolson.com/2014/06/28/how-to-make-beautiful-data-visualizations-in-python-with-matplotlib/](http://www.randalolson.com/2014/06/28/how-to-make-beautiful-data-visualizations-in-python-with-matplotlib/)
    阅读到这篇文章。
- en: There is some work in progress in matplotlib to add style sheet support; more
    information can be found at [http://github.com/matplotlib/matplotlib/blob/master/doc/users/style_sheets.rst](http://github.com/matplotlib/matplotlib/blob/master/doc/users/style_sheets.rst)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: matplotlib 正在进行一些工作，添加样式表支持；更多信息可以在 [http://github.com/matplotlib/matplotlib/blob/master/doc/users/style_sheets.rst](http://github.com/matplotlib/matplotlib/blob/master/doc/users/style_sheets.rst)
    找到。
- en: Information about why rainbow color maps are misleading, at [http://eagereyes.org/basics/rainbow-color-map](http://eagereyes.org/basics/rainbow-color-map)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于为什么彩虹色图是误导性的，可以查看 [http://eagereyes.org/basics/rainbow-color-map](http://eagereyes.org/basics/rainbow-color-map)
- en: See also
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating beautiful statistical plots with seaborn* recipe
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 seaborn 创建美丽的统计图* 方案'
- en: Creating beautiful statistical plots with seaborn
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 seaborn 创建美丽的统计图
- en: matplotlib comes with a high-level plotting API called **pyplot**. Inspired
    by MATLAB (a widespread commercial software for numerical computing), this interface
    may be a bit too low-level for scientists, in that it can lead to boilerplate
    code that is difficult to read and maintain. Yet, it is probably one of the most
    widely used plotting interfaces in the scientific Python community.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: matplotlib 配有一个名为 **pyplot** 的高级绘图 API。受 MATLAB 启发（MATLAB 是一个广泛使用的数值计算商业软件），这个接口对于科学家来说可能有些过于底层，因为它可能会导致难以阅读和维护的样板代码。然而，它可能是科学
    Python 社区中最广泛使用的绘图接口之一。
- en: There exist higher-level, more convenient plotting interfaces. In this recipe,
    we present **seaborn** created by Michael Waskom. This library exposes a high-level
    plotting API that is specifically adapted to statistical figures. It also integrates
    nicely with pandas.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 存在更高级、更便捷的绘图接口。在这个方案中，我们介绍了 **seaborn**，它由 Michael Waskom 创建。这个库提供了一个高层次的绘图
    API，专门为统计图形量身定制，同时与 pandas 紧密集成。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will find the installation instructions of seaborn on the project's page
    at [http://github.com/mwaskom/seaborn](http://github.com/mwaskom/seaborn). You
    can just type `pip install seaborn` in a terminal.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目页面 [http://github.com/mwaskom/seaborn](http://github.com/mwaskom/seaborn)
    上找到 seaborn 的安装说明。你只需要在终端输入 `pip install seaborn`。
- en: How to do it…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s import NumPy, matplotlib, and seaborn:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入 NumPy、matplotlib 和 seaborn：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We generate a random dataset (following the example on seaborn''s website at
    [http://nbviewer.ipython.org/github/mwaskom/seaborn/blob/master/examples/linear_models.ipynb](http://nbviewer.ipython.org/github/mwaskom/seaborn/blob/master/examples/linear_models.ipynb)):'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们生成一个随机数据集（参考 seaborn 网站上的示例 [http://nbviewer.ipython.org/github/mwaskom/seaborn/blob/master/examples/linear_models.ipynb](http://nbviewer.ipython.org/github/mwaskom/seaborn/blob/master/examples/linear_models.ipynb)）：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Seaborn implements many easy-to-use statistical plotting functions. For example,
    here is how to create a **violin plot**. This type of plot allows us to show the
    detailed distribution of sets of points, instead of just quartiles like in box
    plots:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Seaborn 实现了许多易于使用的统计绘图函数。例如，下面是如何创建一个**小提琴图**。这种类型的图可以展示数据点的详细分布，而不仅仅是像箱形图那样显示四分位数：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![How to do it…](img/4818OS_06_05.jpg)'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/4818OS_06_05.jpg)'
- en: 'Seaborn also implements all-in-one statistical visualization functions. For
    example, we can use a single function (`regplot()`) to perform *and* display a
    linear regression between two variables:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Seaborn 也实现了全功能的统计可视化函数。例如，我们可以使用一个单独的函数（`regplot()`）来执行*并且*显示两个变量之间的线性回归：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![How to do it…](img/4818OS_06_06.jpg)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现…](img/4818OS_06_06.jpg)'
- en: 'Seaborn has built-in support for pandas data structures. Here, we display the
    pair-wise correlations between all variables defined in a `DataFrame` object:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Seaborn 内建对 pandas 数据结构的支持。在这里，我们显示了 `DataFrame` 对象中所有变量之间的成对相关性：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![How to do it…](img/4818OS_06_07.jpg)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现…](img/4818OS_06_07.jpg)'
- en: There's more…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Besides seaborn, there are other high-level plotting interfaces:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 seaborn，还有其他高级绘图接口：
- en: '*The Grammar of Graphics* is a book by Dr. Leland Wilkinson that has influenced
    many high-level plotting interfaces such as R''s *ggplot2*, Python''s *ggplot*
    by yhat, and others.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*The Grammar of Graphics* 是 Dr. Leland Wilkinson 撰写的一本书，影响了许多高级绘图接口，如 R 的 *ggplot2*、Python
    中 yhat 的 *ggplot* 等。'
- en: '**Vega**, by Trifacta, is a declarative visualization grammar that can be translated
    to D3.js (a JavaScript visualization library). Also, **Vincent** is a Python library
    that lets us create visualizations with Vega.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vega**，由 Trifacta 提供，是一种声明式可视化语法，可以转换为 D3.js（一种 JavaScript 可视化库）。此外，**Vincent**
    是一个 Python 库，让我们使用 Vega 创建可视化。'
- en: Tableau's **VizQL** is a commercial database-oriented visualization language.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tableau 的 **VizQL** 是一种面向商业数据库的可视化语言。
- en: 'Here are some more references:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有更多参考资料：
- en: Vega available at [http://trifacta.github.io/vega/](http://trifacta.github.io/vega/)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vega 可在 [http://trifacta.github.io/vega/](http://trifacta.github.io/vega/) 获取
- en: Vincent available at [http://vincent.readthedocs.org/en/latest/](http://vincent.readthedocs.org/en/latest/)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vincent 可在 [http://vincent.readthedocs.org/en/latest/](http://vincent.readthedocs.org/en/latest/)
    获取
- en: ggplot2 available at [http://ggplot2.org/](http://ggplot2.org/)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ggplot2 可在 [http://ggplot2.org/](http://ggplot2.org/) 获取
- en: ggplot for Python available at [http://blog.yhathq.com/posts/ggplot-for-python.html](http://blog.yhathq.com/posts/ggplot-for-python.html)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的 ggplot 可在 [http://blog.yhathq.com/posts/ggplot-for-python.html](http://blog.yhathq.com/posts/ggplot-for-python.html)
    获取
- en: VizQL available at [http://www.tableausoftware.com/fr-fr/products/technology](http://www.tableausoftware.com/fr-fr/products/technology)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VizQL 可在 [http://www.tableausoftware.com/fr-fr/products/technology](http://www.tableausoftware.com/fr-fr/products/technology)
    获取
- en: See also
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Making nicer matplotlib figures with prettyplotlib* recipe
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 prettyplotlib 美化 matplotlib 图形* 的配方'
- en: Creating interactive web visualizations with Bokeh
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Bokeh 创建交互式网页可视化
- en: '**Bokeh** is a library for creating rich interactive visualizations in a browser.
    Plots are designed in Python, and they are entirely rendered in the browser. In
    this recipe, we will learn how to create and render interactive Bokeh figures
    in the IPython notebook.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bokeh** 是一个用于在浏览器中创建丰富交互式可视化的库。图形在 Python 中设计，并完全在浏览器中渲染。在本配方中，我们将学习如何在 IPython
    notebook 中创建并渲染交互式 Bokeh 图形。'
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Install Bokeh by following the instructions on the website at [http://bokeh.pydata.org](http://bokeh.pydata.org).
    In principle, you can just type `pip install bokeh` in a terminal. On Windows,
    you can also download the binary installer from Chris Gohlke's website at [http://www.lfd.uci.edu/~gohlke/pythonlibs/#bokeh](http://www.lfd.uci.edu/~gohlke/pythonlibs/#bokeh).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 按照网站上的说明在 [http://bokeh.pydata.org](http://bokeh.pydata.org) 安装 Bokeh。原则上，你可以在终端中输入
    `pip install bokeh`。在 Windows 上，你也可以从 Chris Gohlke 的网站下载二进制安装程序，网址为 [http://www.lfd.uci.edu/~gohlke/pythonlibs/#bokeh](http://www.lfd.uci.edu/~gohlke/pythonlibs/#bokeh)。
- en: How to do it…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Let''s import NumPy and Bokeh. We need to call the `output_notebook()` function
    in order to tell Bokeh to render plots in the IPython notebook:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入 NumPy 和 Bokeh。我们需要调用 `output_notebook()` 函数来告诉 Bokeh 在 IPython notebook
    中渲染图形：
- en: '[PRE10]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We create some random data:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一些随机数据：
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s draw a curve:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们画一条曲线：
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An interactive plot is rendered in the notebook. We can pan and zoom by clicking
    on the buttons above the plot:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个交互式图形已在 notebook 中渲染。我们可以通过点击图形上方的按钮来平移和缩放：
- en: '![How to do it…](img/4818OS_06_08.jpg)'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现…](img/4818OS_06_08.jpg)'
- en: An interactive plot with Bokeh
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 Bokeh 创建的交互式图形
- en: 'Let''s move on to another example. We first load a sample dataset (*Iris flowers*).
    We also generate some colors based on the species of the flowers:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续另一个例子。我们首先加载一个示例数据集（*鸢尾花*）。我们还根据花的种类生成一些颜色：
- en: '[PRE13]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we render an interactive scatter plot:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们渲染一个交互式散点图：
- en: '[PRE14]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![How to do it…](img/4818OS_06_09.jpg)'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现…](img/4818OS_06_09.jpg)'
- en: An interactive scatter plot with Bokeh
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 Bokeh 的交互式散点图
- en: There's more…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Bokeh figures in the notebook are interactive even in the absence of a Python
    server. For example, our figures can be interactive in nbviewer. Bokeh can also
    generate standalone HTML/JavaScript documents from our plots. More examples can
    be found in the gallery at [http://bokeh.pydata.org/docs/gallery.html](http://bokeh.pydata.org/docs/gallery.html).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有 Python 服务器，Bokeh 图表在笔记本中也是互动的。例如，我们的图表可以在 nbviewer 中进行互动。Bokeh 还可以从我们的图表生成独立的
    HTML/JavaScript 文档。更多示例可以在图库中找到，网址为 [http://bokeh.pydata.org/docs/gallery.html](http://bokeh.pydata.org/docs/gallery.html)。
- en: There is an IPython extension in Bokeh that simplifies the integration of interactive
    plots in the notebook. This is available at [http://github.com/ContinuumIO/bokeh/tree/master/extensions](http://github.com/ContinuumIO/bokeh/tree/master/extensions).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Bokeh 提供了一个 IPython 扩展，简化了在笔记本中集成互动图表的过程。这个扩展可以在 [http://github.com/ContinuumIO/bokeh/tree/master/extensions](http://github.com/ContinuumIO/bokeh/tree/master/extensions)
    找到。
- en: In the same vein, let's mention *plot.ly*, an online commercial service for
    interactive Web-based visualization that offers Python interfaces, available at
    [http://plot.ly](http://plot.ly).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们还要提到 *plot.ly*，这是一个在线商业服务，提供用于 Web 基于的互动可视化的 Python 接口，网址为 [http://plot.ly](http://plot.ly)。
- en: See also
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Converting matplotlib figures to D3.js visualizations with mpld3* recipe
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 mpld3 将 matplotlib 图表转换为 D3.js 可视化* 这个食谱'
- en: Visualizing a NetworkX graph in the IPython notebook with D3.js
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 D3.js 在 IPython 笔记本中可视化 NetworkX 图表
- en: D3.js ([http://d3js.org](http://d3js.org)) is a popular interactive visualization
    framework for the Web. Written in JavaScript, it allows us to create data-driven
    visualizations based on Web technologies such as HTML, SVG, and CSS. There are
    many other JavaScript visualization and charting libraries, but we will focus
    on D3.js in this recipe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js ([http://d3js.org](http://d3js.org)) 是一个流行的 Web 互动可视化框架。它是用 JavaScript
    编写的，允许我们基于 Web 技术（如 HTML、SVG 和 CSS）创建数据驱动的可视化。虽然还有许多其他 JavaScript 可视化和图表库，但在本食谱中我们将重点介绍
    D3.js。
- en: Being a pure JavaScript library, D3.js has in principle nothing to do with Python.
    However, the HTML-based IPython notebook can integrate D3.js visualizations seamlessly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为纯 JavaScript 库，D3.js 原则上与 Python 无关。然而，基于 HTML 的 IPython 笔记本可以无缝集成 D3.js 可视化。
- en: In this recipe, we will create a graph in Python with NetworkX and visualize
    it in the IPython notebook with D3.js.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用 Python 的 NetworkX 创建一个图，并在 IPython 笔记本中使用 D3.js 进行可视化。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to know the basics of HTML, JavaScript, and D3.js for this recipe.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱需要你了解 HTML、JavaScript 和 D3.js 的基础知识。
- en: How to do it…
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s import the packages:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入所需的包：
- en: '[PRE15]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We load a famous social graph published in 1977 called **Zachary''s Karate
    Club graph**. This graph represents the friendships between members of a Karate
    club. The club''s president and the instructor were involved in a dispute, resulting
    in a split of this group. Here, we simply display the graph with matplotlib (using
    the `networkx.draw()` function):'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们加载了一个著名的社交图，该图于 1977 年发布，名为 **Zachary's Karate Club graph**。这个图展示了空手道俱乐部成员之间的友谊。俱乐部的主席和教练发生了争执，导致该小组分裂。在这里，我们只用
    matplotlib（使用 `networkx.draw()` 函数）显示图表：
- en: '[PRE16]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![How to do it…](img/4818OS_06_10.jpg)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/4818OS_06_10.jpg)'
- en: 'Now, we''re going to display this graph in the notebook with D3.js. The first
    step is to bring this graph to JavaScript. Here, we choose to export the graph
    to JSON. D3.js generally expects each edge to be an object with a source and target.
    Also, we specify which side each member has taken (`club` attribute). NetworkX
    comes with a built-in export function that we can use here:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用 D3.js 在笔记本中显示这个图。第一步是将图表导入到 JavaScript 中。我们选择将图表导出为 JSON 格式。D3.js 通常期望每个边都是一个具有源（source）和目标（target）的对象。此外，我们还指定了每个成员所代表的“俱乐部”属性（`club`）。NetworkX
    提供了一个内置的导出功能，我们可以在这里使用：
- en: '[PRE17]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next step is to create an HTML object that will contain the visualization.
    Here, we create a `<div>` element in the notebook. We also specify a few CSS styles
    for nodes and links (also called edges):'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个 HTML 对象，容纳可视化图表。我们在笔记本中创建了一个 `<div>` 元素，并为节点和链接（也叫边）指定了一些 CSS 样式：
- en: '[PRE18]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The last step is trickier. We write the JavaScript code to load the graph from
    the JSON file and display it with D3.js. Knowing the basics of D3.js is required
    here (see the documentation of D3.js). The code is long, and you can find it on
    the book''s website. Here, we highlight the most important steps:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步比较复杂。我们编写 JavaScript 代码，从 JSON 文件加载图表并使用 D3.js 显示它。这里需要了解 D3.js 的基础知识（请参阅
    D3.js 的文档）。代码较长，您可以在本书网站上找到完整代码。在这里，我们突出了最重要的步骤：
- en: '[PRE19]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we execute this cell, the HTML object created in the previous cell is
    updated. The graph is animated and interactive; we can click on nodes, see their
    labels, and move them within the canvas:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们执行此单元格时，前一个单元格中创建的 HTML 对象会被更新。图表是动画的并且是互动的；我们可以点击节点，查看其标签，并在画布中移动它们：
- en: '![How to do it…](img/4818OS_06_11.jpg)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/4818OS_06_11.jpg)'
- en: An interactive plot in the notebook with D3.js
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 D3.js 在笔记本中的互动图
- en: There's more…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: D3.js' gallery contains many more examples of beautiful, interactive visualizations
    for the Web. They are available at [http://github.com/mbostock/d3/wiki/Gallery](http://github.com/mbostock/d3/wiki/Gallery).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 的画廊包含更多 Web 上美丽的互动可视化示例。它们可以在 [http://github.com/mbostock/d3/wiki/Gallery](http://github.com/mbostock/d3/wiki/Gallery)
    找到。
- en: In this recipe, we created an HTML/JavaScript interactive visualization from
    a static dataset. With IPython 2.0 and above, we can also create dynamic, real-time
    visualizations that involve bi-directional communication between the browser and
    the Python kernel. There is an experimental implementation by Brian Granger available
    at [http://nbviewer.ipython.org/github/ellisonbg/talk-2014-strata-sc/blob/master/Graph%20Widget.ipynb](http://nbviewer.ipython.org/github/ellisonbg/talk-2014-strata-sc/blob/master/Graph%20Widget.ipynb).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们通过一个静态数据集创建了一个 HTML/JavaScript 互动可视化。使用 IPython 2.0 及以上版本，我们还可以创建涉及浏览器与
    Python 内核之间双向通信的动态、实时可视化。Brian Granger 提供了一个实验性实现，可以在 [http://nbviewer.ipython.org/github/ellisonbg/talk-2014-strata-sc/blob/master/Graph%20Widget.ipynb](http://nbviewer.ipython.org/github/ellisonbg/talk-2014-strata-sc/blob/master/Graph%20Widget.ipynb)
    访问。
- en: Let's also mention **Vincent**, a Python to Vega translator. Vega is a JSON-based
    visualization grammar that can be translated to D3.js. Vincent makes it possible
    to design an interactive visualization in Python and render it in the browser.
    More information can be found at [http://vincent.readthedocs.org/en/latest/](http://vincent.readthedocs.org/en/latest/).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们还要提到 **Vincent**，一个 Python 到 Vega 的翻译器。Vega 是一种基于 JSON 的可视化语法，可以被翻译为 D3.js。Vincent
    使得在 Python 中设计互动可视化并在浏览器中渲染成为可能。更多信息可以在 [http://vincent.readthedocs.org/en/latest/](http://vincent.readthedocs.org/en/latest/)
    找到。
- en: See also
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating interactive web visualizations with Bokeh* recipe
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Bokeh 创建互动 Web 可视化* 示例'
- en: The *Converting matplotlib figures to D3.js visualizations with mpld3* recipe
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将 matplotlib 图形转换为 D3.js 可视化图表，使用 mpld3* 示例'
- en: Converting matplotlib figures to D3.js visualizations with mpld3
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 mpld3 将 matplotlib 图形转换为 D3.js 可视化
- en: The **mpld3** library automatically converts matplotlib figures to interactive
    D3.js visualizations. In this recipe, we will see how to use this library in the
    notebook.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**mpld3** 库会自动将 matplotlib 图形转换为互动 D3.js 可视化图表。在本示例中，我们将展示如何在笔记本中使用该库。'
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To install the mpld3 library, you can just type `pip install mpld3` in a terminal.
    See also the main website at [http://mpld3.github.io](http://mpld3.github.io).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 mpld3 库，只需在终端中输入 `pip install mpld3`。更多信息请参见主网站 [http://mpld3.github.io](http://mpld3.github.io)。
- en: How to do it…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'First, we load NumPy and matplotlib as usual:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们像往常一样加载 NumPy 和 matplotlib：
- en: '[PRE20]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we enable the mpld3 figures in the notebook with a single function call:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过一个函数调用在笔记本中启用 mpld3 图形：
- en: '[PRE21]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s create a scatter plot with matplotlib:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 matplotlib 创建一个散点图：
- en: '[PRE22]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The matplotlib figure is rendered with D3.js instead of the standard matplotlib
    backend. In particular, the figure is interactive (we can pan and zoom in the
    figure):'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: matplotlib 图形通过 D3.js 渲染，而不是使用标准的 matplotlib 后端。特别是，图形是互动的（我们可以平移和缩放图形）：
- en: '![How to do it…](img/4818OS_06_12.jpg)'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/4818OS_06_12.jpg)'
- en: An interactive matplotlib figure with mpld3
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 mpld3 的互动 matplotlib 图
- en: 'Now, we create a more complex example with multiple subplots that represent
    different 2D projections of a 3D dataset. We use the `sharex` and `sharey` keywords
    in matplotlib''s `subplots()` function to automatically bind the *x* and *y* axes
    of the different figures. Panning and zooming in any of the subplots automatically
    updates all the other subplots:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个更复杂的示例，其中包含多个子图，表示一个 3D 数据集的不同 2D 投影。我们使用 matplotlib 的 `subplots()`
    函数中的 `sharex` 和 `sharey` 关键字来自动绑定不同图形的 *x* 和 *y* 轴。在任何子图上进行平移和缩放都会自动更新所有其他子图：
- en: '[PRE23]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This use case is perfectly handled by mpld3; the D3.js subplots are dynamically
    linked together:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个用例完全可以通过 mpld3 处理；D3.js 子图是动态联动的：
- en: '![How to do it…](img/4818OS_06_13.jpg)'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/4818OS_06_13.jpg)'
- en: Interactive linked subplots in mpld3
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 mpld3 中的互动联动子图
- en: How it works…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: mpld3 works by first crawling and exporting a matplotlib figure to JSON (in
    the context of the **mplexporter** framework). Then, the library generates D3.js
    code from this JSON representation. This architecture can enable other matplotlib
    backends besides D3.js.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: mpld3 的工作原理是首先爬取并将 matplotlib 图形导出为 JSON（在 **mplexporter** 框架的上下文中）。然后，库从该 JSON
    表示生成 D3.js 代码。这种架构可以支持除了 D3.js 之外的其他 matplotlib 后端。
- en: There's more…
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Here are some references:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: mplexporter available at [http://github.com/mpld3/mplexporter](http://github.com/mpld3/mplexporter)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mplexporter 可用：[http://github.com/mpld3/mplexporter](http://github.com/mpld3/mplexporter)
- en: mpld3 on GitHub available at [https://github.com/jakevdp/mpld3](https://github.com/jakevdp/mpld3)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mpld3 在 GitHub 上可用：[https://github.com/jakevdp/mpld3](https://github.com/jakevdp/mpld3)
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating interactive web visualizations with Bokeh* recipe
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Bokeh 创建交互式 Web 可视化* 食谱'
- en: The *Visualizing a NetworkX graph in the IPython notebook with D3.js* recipe
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 IPython 笔记本中使用 D3.js 可视化 NetworkX 图* 食谱'
- en: Getting started with Vispy for high-performance interactive data visualizations
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门 Vispy 进行高性能互动数据可视化
- en: Most existing plotting or visualization libraries in Python can display small
    or medium datasets (that contain no more than a few tens of thousands of points).
    In the *Big Data* era, it is sometimes necessary to display larger datasets.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现有的 Python 绘图或可视化库可以显示小型或中型数据集（包含不超过几万个点的数据集）。在 *大数据* 时代，有时需要显示更大的数据集。
- en: Vispy ([http://vispy.org](http://vispy.org)) is a young 2D/3D high-performance
    visualization library that can display very large datasets. Vispy leverages the
    computational power of modern Graphics Processing Units (GPUs) through the OpenGL
    library.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Vispy ([http://vispy.org](http://vispy.org)) 是一个年轻的 2D/3D 高性能可视化库，可以显示非常大的数据集。Vispy
    通过 OpenGL 库利用现代图形处理单元（GPU）的计算能力。
- en: The power of GPUs has been fostered by the video game industry in the last two
    decades. GPUs are specialized in high-performance, real-time rendering. As such,
    they are perfectly adapted to interactive scientific plotting.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的二十年里，视频游戏行业促进了 GPU 的强大功能。GPU 专注于高性能、实时渲染。因此，它们非常适合互动式科学绘图。
- en: Vispy offers a Pythonic object-oriented interface to OpenGL, useful to those
    who know OpenGL or who are willing to learn it. Higher-level graphical interfaces
    are also being developed at the time of this writing, and experimental versions
    are already available. These interfaces do not require any knowledge of OpenGL.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Vispy 提供了一个 Pythonic 的面向对象接口，用于 OpenGL，适用于那些了解 OpenGL 或愿意学习 OpenGL 的人。更高级别的图形接口也在写作时开发中，实验版本已经可以使用。这些接口不需要任何
    OpenGL 知识。
- en: 'In this recipe, we will give a brief introduction to the fundamental concepts
    of OpenGL. There are two situations where you would need to know these concepts:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将简要介绍 OpenGL 的基本概念。在以下两种情况中，你需要了解这些概念：
- en: If you want to use Vispy today, before the availability of the high-level plotting
    interfaces
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你今天想使用 Vispy，在高级绘图接口可用之前
- en: If you want to create custom, sophisticated, high-performance visualizations
    that are not yet implemented in Vispy
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想创建自定义的、复杂的、高性能的可视化，这些可视化在 Vispy 中尚未实现
- en: Here, we display a digital signal using Vispy's object-oriented interface to
    OpenGL.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 Vispy 的面向对象接口来显示一个数字信号。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Vispy depends on NumPy. A backend library is necessary (for example, PyQt4 or
    PySide).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Vispy 依赖于 NumPy。需要一个后端库（例如，PyQt4 或 PySide）。
- en: 'This recipe has been tested with the development version of Vispy available
    at [http://github.com/vispy/vispy](http://github.com/vispy/vispy). You should
    clone the GitHub repository and install Vispy with the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱已在 [http://github.com/vispy/vispy](http://github.com/vispy/vispy) 上可用的 Vispy
    开发版本中进行测试。你应该克隆 GitHub 仓库并使用以下命令安装 Vispy：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The API used in this recipe might change in future versions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中使用的 API 可能会在未来版本中发生变化。
- en: How to do it…
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Let''s import NumPy, `vispy.app` (to display a canvas), and `vispy.gloo` (object-oriented
    interface to OpenGL):'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入 NumPy，`vispy.app`（用于显示画布）和 `vispy.gloo`（面向对象的 OpenGL 接口）：
- en: '[PRE25]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In order to display a window, we need to create a **Canvas**:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了显示一个窗口，我们需要创建一个 **画布**：
- en: '[PRE26]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When using `vispy.gloo`, we need to write **shaders**. These programs, written
    in a C-like language, run on the GPU and give us full flexibility for our visualizations.
    Here, we create a trivial **vertex shader** that directly displays 2D data points
    (stored in the `a_position` variable) in the canvas. We will see more details
    in the next section:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`vispy.gloo`时，我们需要编写**着色器**。这些程序使用类似C语言的语言编写，运行在GPU上，为我们的可视化提供完全的灵活性。在这里，我们创建一个简单的**顶点着色器**，它直接在画布上显示2D数据点（存储在`a_position`变量中）。接下来我们将在下一节中看到更多细节：
- en: '[PRE27]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The other shader we need to create is the **fragment shader**. It lets us control
    the pixels'' color. Here, we display all data points in black:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建的另一个着色器是**片段着色器**。它让我们控制像素的颜色。在这里，我们将所有数据点显示为黑色：
- en: '[PRE28]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we create an **OpenGL** `Program`. This object contains shaders and links
    the shader variables to the NumPy data:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个**OpenGL** `Program`。这个对象包含着色器并将着色器变量链接到NumPy数据：
- en: '[PRE29]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We link the `a_position` variable to a *(1000, 2)* NumPy array that contains
    the coordinates of 1000 data points. In the default coordinate system, the coordinates
    of the four canvas corners are *(+/-1, +/-1)*:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`a_position`变量链接到一个*(1000, 2)*的NumPy数组，该数组包含1000个数据点的坐标。在默认坐标系中，四个画布角的坐标为*(+/-1,
    +/-1)*：
- en: '[PRE30]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We create a callback function when the window is being resized. Updating the
    **OpenGL viewport** lets us ensure that Vispy uses the entire canvas:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在窗口调整大小时创建一个回调函数。更新**OpenGL视口**可以确保Vispy使用整个画布：
- en: '[PRE31]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We create a callback function when the canvas needs to be refreshed. This `on_draw()`
    function renders the entire scene. First, we clear the window in white (it is
    necessary to do this at every frame). Then, we draw a succession of line segments
    using our OpenGL program:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当画布需要刷新时，我们创建一个回调函数。这个`on_draw()`函数渲染整个场景。首先，我们将窗口清空为白色（每一帧都需要这样做）。然后，我们使用OpenGL程序绘制一系列线段：
- en: '[PRE32]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we show the canvas and run the application:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们显示画布并运行应用程序：
- en: '[PRE33]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following figure shows a screenshot:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下图显示了一个截图：
- en: '![How to do it…](img/4818OS_06_14.jpg)'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作……](img/4818OS_06_14.jpg)'
- en: Basic visualization example with Vispy
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Vispy的基本可视化示例
- en: How it works…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: OpenGL is an open standard for hardware-accelerated interactive visualization.
    It is widely used in video games, industry (**Computer-Aided Design**, or **CAD**),
    virtual reality, and scientific applications (medical imaging, computer graphics,
    and so on).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL是一种硬件加速的互动可视化开放标准。它广泛应用于视频游戏、工业（**计算机辅助设计**，或**CAD**）、虚拟现实和科学应用（医学成像、计算机图形学等）。
- en: 'OpenGL is a mature technology created in the early 1990s. In the early 2000s,
    OpenGL 2.0 brought a major new feature: the possibility to customize fundamental
    steps of the **rendering pipeline**. This pipeline defines the way data is processed
    on the GPU for real-time rendering. Many OpenGL courses and tutorials cover the
    old, fixed pipeline. However, Vispy exclusively supports the modern, programmable
    pipeline.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL是一项成熟的技术，创建于1990年代初期。在2000年代初，OpenGL 2.0引入了一个重大的新特性：可以自定义**渲染管线**的基本步骤。这个管线定义了数据如何在GPU上处理，以进行实时渲染。许多OpenGL课程和教程讲解的是旧的、固定的管线。然而，Vispy仅支持现代的可编程管线。
- en: Here, we will introduce the fundamental concepts of the programmable pipeline
    used in this recipe. OpenGL is considerably more complex than what we can cover
    here. However, Vispy provides a vastly simplified API for the most common features
    of OpenGL.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍本食谱中使用的可编程管线的基本概念。OpenGL比我们在这里能覆盖的要复杂得多。然而，Vispy为OpenGL的最常见功能提供了一个大大简化的API。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Vispy is based on **OpenGL ES 2.0**, a flavor of OpenGL that is supported on
    desktop computers, mobile devices, and modern web browsers (through **WebGL**).
    Modern graphics cards can support additional features. These features will be
    available in future versions of Vispy.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Vispy基于**OpenGL ES 2.0**，这是OpenGL的一种变体，支持桌面计算机、移动设备和现代网页浏览器（通过**WebGL**）。现代图形卡可以支持额外的功能。这些功能将在未来版本的Vispy中提供。
- en: 'There are four major elements in the rendering pipeline of a given OpenGL program:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定OpenGL程序的渲染管线中，有四个主要元素：
- en: '**Data buffers** store numerical data on the GPU. The main types of buffers
    are **vertex buffers**, **index buffers**, and **textures**.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据缓冲区**将数值数据存储在GPU上。缓冲区的主要类型有**顶点缓冲区**、**索引缓冲区**和**纹理**。'
- en: '**Variables** are available in the shaders. There are four major types of variables:
    **attributes**, **uniforms**, **varyings**, and **texture samplers**.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**在着色器中是可用的。主要有四种类型的变量：**属性**、**常量**、**变化量**和**纹理采样器**。'
- en: '**Shaders** are GPU programs written in a C-like language called **OpenGL Shading
    Language** (**GLSL**). The two main types of shaders are **vertex shaders** and
    **fragment shaders**.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**着色器**是用一种类似C语言的语言编写的GPU程序，称为**OpenGL着色语言**（**GLSL**）。着色器的两种主要类型是**顶点着色器**和**片段着色器**。'
- en: '**The primitive type** defines the way data points are rendered. The main types
    are points, lines, and triangles.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图元类型**定义了数据点的渲染方式。主要类型有点、线和三角形。'
- en: 'Here is how the rendering pipeline works:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染管线的工作方式：
- en: Data is sent to the GPU and stored in buffers.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据被发送到GPU并存储在缓冲区中。
- en: The vertex shader processes the data in parallel and generates a number of 4D
    points in a normalized coordinate system *(+/-1, +/-1)*. The fourth dimension
    is a homogeneous coordinate (generally 1).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器并行处理数据，并生成多个4D点，这些点位于归一化坐标系中（+/-1, +/-1）。第四维是齐次坐标（通常为1）。
- en: Graphics primitives (points, lines, and triangles) are generated from the data
    points returned by the vertex shader (**primitive assembly** and **rasterization**).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图形图元（点、线和三角形）是通过顶点着色器返回的数据点生成的（**图元组装**和**光栅化**）。
- en: The fragment shader processes all primitive pixels in parallel and returns each
    pixel's color as RGBA components.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器并行处理所有图元像素，并返回每个像素的颜色作为RGBA组件。
- en: 'In this recipe''s example, there is only one GPU variable: the `a_position`
    attribute. An **attribute** is a variable that takes one value per data point.
    **Uniforms** are global variables (shared by all data points), whereas **varyings**
    are used to pass values from the vertex shader to the fragment shader (with automatic
    linear interpolation for a pixel between two or three vertices).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，只有一个GPU变量：`a_position`属性。**属性**是每个数据点取一个值的变量。**常量**是全局变量（所有数据点共享），而**变化量**则用于将值从顶点着色器传递到片段着色器（通过对两个或三个顶点之间的像素进行自动线性插值）。
- en: In `vispy.gloo`, a `Program` is created with the vertex and fragment shaders.
    Then, the variables declared in the shaders can be set with the `program['varname']
    = value` syntax. When `varname` is an attribute variable, the value can just be
    a NumPy 2D array. In this array, every line contains the components of every data
    point.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vispy.gloo`中，`Program`是通过顶点着色器和片段着色器创建的。然后，可以使用`program['varname'] = value`语法设置在着色器中声明的变量。当`varname`是一个属性变量时，值可以是一个NumPy二维数组。在这个数组中，每一行包含每个数据点的组成部分。
- en: Similarly, we can declare uniforms and textures in our program.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以在程序中声明常量和纹理。
- en: Finally, the `program.draw()` function renders the data using the specified
    primitive type. Here, the `line_strip` primitive type tells the GPU to run through
    all vertices (as returned by the vertex buffer) and to draw a line segment from
    one point to the next. If there are *n* points, there will be *n-1* line segments.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`program.draw()`函数使用指定的图元类型渲染数据。这里，`line_strip`图元类型告诉GPU遍历所有顶点（由顶点缓冲区返回），并绘制从一个点到下一个点的线段。如果有*n*个点，则会有*n-1*条线段。
- en: Other primitive types include points and triangles, with several ways of generating
    lines or triangles from a list of vertices.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 其他图元类型包括点和三角形，有几种方法可以从顶点列表中生成线或三角形。
- en: In addition, an index buffer can be provided. An index buffer contains indices
    pointing to the vertex buffers. Using an index buffer would allow us to reuse
    any vertex multiple times during the primitive assembly stage. For example, when
    rendering a cube with a `triangles` primitive type (one triangle is generated
    for every triplet of points), we can use a vertex buffer with eight data points
    and an index buffer with thirty-six indices (three points per triangle, two triangles
    per face, and six faces).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以提供索引缓冲区。索引缓冲区包含指向顶点缓冲区的索引。使用索引缓冲区可以让我们在图元组装阶段多次复用同一个顶点。例如，当使用`triangles`图元类型渲染一个立方体时（每三个点生成一个三角形），我们可以使用包含八个数据点的顶点缓冲区和包含三十六个索引的索引缓冲区（三个点构成一个三角形，每个面有两个三角形，共六个面）。
- en: There's more…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: The example shown here is extremely simple. The approach provided by OpenGL
    and Vispy is nevertheless particularly powerful. It gives us full control on the
    rendering pipeline, and it allows us to leverage the computational power of GPUs
    in a nearly optimal way.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的示例非常简单。然而，OpenGL 和 Vispy 提供的方法却特别强大。它使我们能够完全控制渲染管线，并且几乎可以以最优方式利用 GPU 的计算能力。
- en: High performance is achieved by minimizing the number of data transfers to the
    GPU. When displaying static data (for example, a scatter plot), it is possible
    to send the data to the GPU at initialization time only. Yet, rendering dynamic
    data is reasonably fast; the order of magnitude of data transfers is roughly 1
    GBps.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 高性能是通过最小化数据传输到 GPU 的次数来实现的。当显示静态数据（例如散点图）时，可以仅在初始化时将数据发送到 GPU。而渲染动态数据的速度也相当快；数据传输的数量级大约为
    1 GBps。
- en: Additionally, it is critical to use as few OpenGL draw calls as possible. Every
    draw incurs a significant overhead. High performance is achieved by rendering
    all similar primitive types at once (**batch rendering**). GPUs are particularly
    efficient with batch rendering, even when the properties of the points are different
    (for example, points with various sizes and colors).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽量减少 OpenGL 绘制调用的次数至关重要。每次绘制都会产生显著的开销。通过一次性渲染所有相似的原始类型来实现高性能（**批量渲染**）。即使点的属性不同（例如，不同大小和颜色的点），GPU
    在批量渲染时也特别高效。
- en: Finally, geometric or pixel transformations can be executed on the GPU with
    very high performance using the shaders. The massive architecture of GPUs, consisting
    of hundreds or thousands of computing units, is fully leveraged when transformations
    are implemented in the shaders.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以通过着色器在 GPU 上以非常高的性能执行几何或像素变换。当变换在着色器中实现时，GPU 强大的架构（由数百或数千个计算单元组成）得到了充分利用。
- en: 'General-purpose computations can be done in the shaders in the context of visualization.
    There is one major drawback compared to proper GPGPU frameworks like CUDA or OpenCL:
    in the vertex shader, a given thread has access to one data point only. Similarly,
    in the fragment shader, a thread has only access to one pixel. Yet, certain types
    of simulations or visualization effects require interactions between vertices
    or pixels. There are ways to mitigate this issue, but they lead to a drop in performance.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在可视化的上下文中，可以在着色器中执行通用计算。与适当的 GPGPU 框架（如 CUDA 或 OpenCL）相比，存在一个主要缺点：在顶点着色器中，给定线程只能访问一个数据点。同样，在片段着色器中，线程只能访问一个像素。然而，某些类型的仿真或可视化效果需要顶点或像素之间的交互。虽然有方法可以缓解这个问题，但这会导致性能下降。
- en: However, it is possible to interoperate OpenGL with CUDA/OpenCL. Buffers can
    be shared between OpenGL and the GPGPU framework. Complex CUDA/OpenCL computations
    can be implemented on vertex buffers or textures in real-time, leading to highly
    efficient rendering of numerical simulations.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，OpenGL 可以与 CUDA/OpenCL 进行互操作。缓冲区可以在 OpenGL 和 GPGPU 框架之间共享。复杂的 CUDA/OpenCL
    计算可以实时地在顶点缓冲区或纹理上实现，从而实现高效的数值仿真渲染。
- en: Vispy for scientific visualization
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vispy 用于科学可视化
- en: As we have seen in this recipe, Vispy requires the user to know OpenGL and GLSL.
    However, higher-level graphical interfaces are currently being developed. These
    interfaces will bring to scientists the power of GPUs for high-performance interactive
    visualization.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这个示例中看到的，Vispy 要求用户了解 OpenGL 和 GLSL。然而，当前正在开发更高级的图形接口。这些接口将为科学家们带来 GPU
    的强大能力，用于高性能交互式可视化。
- en: '**Visuals** will provide reusable, reactive graphical components like shapes,
    polygons, 3D meshes, graphs, and others. These visuals will be fully customizable
    and can be used without knowledge of OpenGL. A **shader composition system** will
    allow advanced users to reuse snippets of GLSL code in a modular way.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**视觉组件**将提供可重用的、响应式的图形组件，如形状、多边形、3D 网格、图形等。这些组件将是完全可定制的，并且可以在不需要了解 OpenGL 的情况下使用。**着色器组合系统**将允许高级用户以模块化的方式重用
    GLSL 代码片段。'
- en: Visuals will be organized within a **scene graph** implementing GPU-based **transformations**.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉组件将被组织在一个 **场景图** 中，执行基于 GPU 的 **变换**。
- en: Scientific plotting interfaces will be implemented. Vispy can also serve as
    a high-performance backend for existing plotting libraries such as matplotlib.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 科学绘图接口将会实现。Vispy 还可以作为现有绘图库（如 matplotlib）的高性能后端。
- en: Vispy will also support full integration in the IPython notebook using WebGL.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Vispy 还将支持通过 WebGL 在 IPython notebook 中的完全集成。
- en: 'Eventually, Vispy will be able to implement many kinds of scientific visualizations:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，Vispy将能够实现多种科学可视化：
- en: Scatter plots can be rendered efficiently with **point sprites**, using one
    vertex per data point. Panning and zooming can be implemented in the vertex shader,
    enabling fast interactive visualization of millions of points.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散点图可以通过点精灵高效渲染，每个数据点使用一个顶点。平移和缩放可以在顶点着色器中实现，从而实现对数百万点的快速交互式可视化。
- en: Static or dynamic (real-time) digital signals can be displayed with polylines.
    High-quality rendering of curves can be achieved using an OpenGL implementation
    of **Anti-Grain Geometry**, a high-quality 2D rendering library.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态或动态（实时）数字信号可以通过折线显示。使用Anti-Grain Geometry的OpenGL实现可以实现曲线的高质量渲染，这是一个高质量的2D渲染库。
- en: Graphs can be displayed by combining points and line segments.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图表可以通过组合点和线段来显示。
- en: 3D meshes can be displayed with triangles and index buffers. Geometric transformations
    and realistic lighting can be implemented in the vertex and fragment shaders.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D网格可以使用三角形和索引缓冲区显示。几何变换和逼真的光照可以在顶点和片段着色器中实现。
- en: Real-time streams of images can be displayed efficiently with textures.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时图像流可以有效地通过纹理显示。
- en: Axes, grids, ticks, text, and labels can be rendered efficiently in the fragment
    shader.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轴线、网格、刻度、文本和标签可以在片段着色器中高效渲染。
- en: Many examples can be found in Vispy's gallery.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vispy的画廊中可以找到许多示例。
- en: 'Here are a few references:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: Vispy's gallery available at [http://vispy.org/gallery.html](http://vispy.org/gallery.html)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vispy的画廊位于[http://vispy.org/gallery.html](http://vispy.org/gallery.html)
- en: A modern OpenGL tutorial, by Nicolas P. Rougier, available at [http://www.loria.fr/~rougier/teaching/opengl/](http://www.loria.fr/~rougier/teaching/opengl/)
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Nicolas P. Rougier编写的现代OpenGL教程，位于[http://www.loria.fr/~rougier/teaching/opengl/](http://www.loria.fr/~rougier/teaching/opengl/)
- en: '*Hardware-accelerated interactive data visualization for neuroscience in Python*,
    an article available at [http://journal.frontiersin.org/Journal/10.3389/fninf.2013.00036/full](http://journal.frontiersin.org/Journal/10.3389/fninf.2013.00036/full)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python中的神经科学硬件加速交互式数据可视化*，一篇文章位于[http://journal.frontiersin.org/Journal/10.3389/fninf.2013.00036/full](http://journal.frontiersin.org/Journal/10.3389/fninf.2013.00036/full)'
- en: The Vispy users mailing list available at [http://groups.google.com/forum/#!forum/vispy](http://groups.google.com/forum/#!forum/vispy)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vispy用户邮件列表位于[http://groups.google.com/forum/#!forum/vispy](http://groups.google.com/forum/#!forum/vispy)
- en: The Vispy-dev mailing list available at [http://groups.google.com/forum/#!forum/vispy-dev](http://groups.google.com/forum/#!forum/vispy-dev)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vispy-dev邮件列表位于[http://groups.google.com/forum/#!forum/vispy-dev](http://groups.google.com/forum/#!forum/vispy-dev)
- en: The Anti-Grain Geometry library on Wikipedia, available at [http://en.wikipedia.org/wiki/Anti-Grain_Geometry](http://en.wikipedia.org/wiki/Anti-Grain_Geometry)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anti-Grain Geometry库在维基百科上的页面，位于[http://en.wikipedia.org/wiki/Anti-Grain_Geometry](http://en.wikipedia.org/wiki/Anti-Grain_Geometry)
