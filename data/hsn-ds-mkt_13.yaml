- en: Customer Lifetime Value
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户生命周期价值
- en: In this chapter, we are going to focus on the second use case of predictive
    analytics in marketing, the customer lifetime value that we discussed in the previous
    chapter. In marketing, it is always a challenge to budget for marketing campaigns.
    We do not want to spend too much and result in a negative ROI. However, we also
    do not want to spend too little and have no visible impact or outcome. When determining
    the budget for a marketing strategy, it is essential to know what the expected
    return will be from running a given marketing campaign. Understanding what the
    **customer lifetime value** (**CLV**) is for individual customers can help marketers
    justify their marketing budget, as well as target potential high-value customers.
    In this chapter, we are going to discuss in more detail the concept and the advantage
    of calculating the CLV, as well as how to build a predictive machine learning
    model to predict the expected CLV for individual customers in Python and R.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点讨论预测分析在营销中的第二个应用案例，即我们在上一章讨论的客户生命周期价值。在营销中，确定营销活动的预算总是一个挑战。我们不希望花费过多而导致负的投资回报率（ROI），但我们也不希望花费过少而没有显著的影响或结果。在确定营销策略的预算时，了解运行某一营销活动所期望的回报非常重要。了解**客户生命周期价值**（**CLV**）对于单个客户而言，可以帮助营销人员为其营销预算提供依据，并且能够有针对性地寻找潜在的高价值客户。在本章中，我们将更详细地讨论计算CLV的概念与优势，以及如何在Python和R中构建预测机器学习模型，以预测单个客户的预期CLV。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: CLV
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLV
- en: Evaluation metrics for regression models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归模型的评估指标
- en: Predicting the 3 month CLV with Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python预测3个月的CLV
- en: Predicting the 3 month CLV with R
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用R预测3个月的CLV
- en: CLV
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLV
- en: In marketing, the CLV is one of the key metrics to have and monitor. The CLV
    measures customers' total worth to the business over the course of their lifetime
    relationship with the company. This metric is especially important to keep track
    of for acquiring new customers. It is generally more expensive to acquire new
    customers than to keep existing customers, so knowing the lifetime value and the
    costs associated with acquiring new customers is essential in order to build marketing
    strategies with a positive ROI. For example, if the average CLV of your customer
    is $100 and it only costs $10 to acquire a new customer, then your business will
    be generating more revenue as you acquire new customers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在营销中，CLV是一个必须拥有并监控的关键指标。CLV衡量的是客户在与公司关系的整个生命周期中，对企业的总价值。这个指标对于获取新客户尤其重要。获取新客户的成本通常比维持现有客户更高，因此了解客户生命周期价值以及获取新客户的相关成本对于制定具有正投资回报率的营销策略至关重要。例如，如果你的客户的平均CLV是$100，而获取一个新客户的成本仅为$10，那么随着新客户的获得，你的业务将创造更多收入。
- en: However, if it costs $150 to acquire a new customer and the average CLV of your
    customer is still $100, then you will be losing money for each acquisition. Simply
    put, if your marketing spend for new customer acquisition exceeds the CLV, you
    will be losing money for each acquisition, and it is better to just work with
    the existing customers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果获取一个新客户的成本是$150，而你的客户平均CLV仍然是$100，那么你每获得一个客户就会亏损。简单来说，如果你的新客户获取营销支出超过了CLV，你就会在每次获取客户时亏损，最好是只与现有客户合作。
- en: There are multiple ways to calculate CLV. One way is to find the customer's
    average purchase amount, purchase frequency, and lifetime span and do a simple
    calculation to get the CLV. For example, think of a hypothetical case, where a
    customer's average purchase amount is $100 and he or she makes purchases five
    times every month on average. Then this customer's average value per month is
    $500, which is simply multiplying the average purchase amount with the average
    purchase frequency. Now, we need to know this customer's lifetime span. One way
    to estimate a customer's lifetime span is to look at the average monthly churn
    rate, which is the percentage of customers leaving and terminating the relationship
    with your business. You can estimate a customer's lifetime span by dividing one
    by the churn rate. Assuming 5% of the churn rate in our hypothetical case, the
    estimated customer's lifetime span is 20 years. Given the customer's average value
    per month of $500 and lifetime span of 20 years, the CLV of this customer turns
    out to be $120,000\. This final CLV amount is calculated by multiplying $500,
    the average value per month, by 12 months and the lifetime span of 20 years.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 计算CLV有多种方法。一种方法是找到客户的平均购买金额、购买频率和生命周期，然后通过简单计算得到CLV。例如，假设有一个假设情况，某客户的平均购买金额是100美元，并且他或她每个月平均购买五次。那么，这个客户的每月平均价值是500美元，计算方法就是将平均购买金额与平均购买频率相乘。现在，我们需要知道该客户的生命周期。估算客户生命周期的一种方法是查看平均月流失率，即离开并终止与您业务关系的客户所占的百分比。您可以通过将1除以流失率来估算客户的生命周期。假设在我们的假设情况下流失率为5%，那么估算的客户生命周期为20年。根据客户每月平均价值500美元和生命周期20年的数据，该客户的CLV为120,000美元。这个最终的CLV金额是通过将500美元（每月平均值）乘以12个月，再乘以20年的生命周期计算得出的。
- en: Because we do not typically know the lifetime span of customers, we often try
    to estimate CLV over the course of a certain period. It can be done by estimating
    a customer's 12-month CLV, 24-month CLV, or can also be a 3-month CLV. Aside from
    the method we discussed through an example, CLV can also be estimated through
    building predictive models. Using machine learning algorithms and customers' purchase
    history data, we can build machine learning models that predict customers' CLV
    over the course of a certain period. In the programming exercises in this chapter,
    we are going to learn how to build a regression model that predicts customers'
    3-month CLV.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们通常不知道客户的生命周期，所以我们经常尝试估计在某一特定时期内的客户生命周期价值（CLV）。这可以通过估算客户的12个月CLV、24个月CLV，或者也可以是3个月CLV来实现。除了我们通过示例讨论的方法外，CLV还可以通过构建预测模型来估算。利用机器学习算法和客户的购买历史数据，我们可以构建预测客户在某一特定时期内CLV的机器学习模型。在本章的编程练习中，我们将学习如何构建一个回归模型来预测客户的3个月CLV。
- en: Evaluating regression models
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估回归模型
- en: We need to use a different set of metrics for evaluating regression models from
    those for classification model evaluations. This is because the prediction output
    of a regression model takes continuous values, meaning it can take any value and
    is not restricted to taking from a predefined set of values. On the other hand,
    as we have seen in [Chapter 8](4f5163a1-c34a-495f-bc5f-e02f9b2a2052.xhtml), *Predicting
    the Likelihood of Marketing Engagement*, the prediction output of a classification
    model can only take a certain number of values. As was the case for the engagement
    prediction, our classification model from the previous chapter could only take
    two values—zero for no engagement and one for engagement. Because of this difference,
    we need to use different metrics to evaluate regression models.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在评估回归模型时需要使用一组与分类模型评估不同的指标。这是因为回归模型的预测输出是连续值，意味着它可以取任何值，并且不受限于预定义的值集合。而另一方面，正如我们在[第8章](4f5163a1-c34a-495f-bc5f-e02f9b2a2052.xhtml)《预测营销互动的可能性》中所见，分类模型的预测输出只能取有限的几个值。就像在之前的互动预测中，我们的分类模型只能取两个值——0表示没有互动，1表示有互动。由于这种差异，我们需要使用不同的指标来评估回归模型。
- en: 'In this section, we are going to discuss four commonly used methodologies to
    evaluate regression models—**mean squared error** (**MSE**), **median absolute
    error** (**MAE**), *R²*, and predicted versus actual scatter plot. As the name
    suggests, MSE measures the average of the squared errors, where the errors are
    the differences between the predicted and actual values. The equation for *MSE*
    looks as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论四种常用的回归模型评估方法——**均方误差**（**MSE**）、**中位数绝对误差**（**MAE**）、*R²*和预测值与实际值散点图。顾名思义，MSE衡量的是平方误差的平均值，其中误差是预测值与实际值之间的差异。*MSE*的公式如下所示：
- en: '![](img/df961a94-c63a-455d-baaa-f02de0eb111a.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df961a94-c63a-455d-baaa-f02de0eb111a.png)'
- en: The *Y* values in this equation are the actual values and *Y' *values are the
    predicted values. Because MSE is an average of squared errors, this measure is
    sensitive to and highly affected by outliers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程中的*Y*值是实际值，*Y'*值是预测值。因为MSE是平方误差的平均值，这个度量对异常值非常敏感，容易受到异常值的强烈影响。
- en: 'The MAE, on the other hand, is less sensitive to outliers and considered more
    robust, as the median is affected by the outliers or values at the end tails much
    less than the average. The equation, borrowed from this `scikit-learn` documentation
    page, [https://scikit-learn.org/stable/modules/model_evaluation.html#median-absolute-error](https://scikit-learn.org/stable/modules/model_evaluation.html#median-absolute-error),
    looks as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，MAE对异常值的敏感性较低，因此被认为更为稳健，因为中位数受异常值或尾部极端值的影响远低于平均数。这个公式来自于`scikit-learn`文档页面，[https://scikit-learn.org/stable/modules/model_evaluation.html#median-absolute-error](https://scikit-learn.org/stable/modules/model_evaluation.html#median-absolute-error)，如下所示：
- en: '![](img/19aeba3e-bfca-4e51-b991-91e483b583ba.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19aeba3e-bfca-4e51-b991-91e483b583ba.png)'
- en: The *y* values in this equation represent the actual values and the ![](img/961dcb23-3ac8-4cd7-b07a-e5beeaaebc0d.png) values
    represent the predicted values.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程中的*y*值表示实际值，而![](img/961dcb23-3ac8-4cd7-b07a-e5beeaaebc0d.png)值表示预测值。
- en: 'Another frequently used measure for regression models is *R²*, also called
    the coefficient of determination. *R²* measures the goodness of fit. In other
    words, it measures how well a regression model is fitted to the data. Simply put,
    *R²* is the percentage of the explained variability of the target variable by
    the regression model. The equation looks as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的回归模型评估度量是*R²*，也称为决定系数。*R²*衡量拟合优度。换句话说，它衡量回归模型与数据的拟合程度。简而言之，*R²*是回归模型解释目标变量变异性的百分比。该公式如下所示：
- en: '![](img/d07966c9-3620-4cb9-a62d-eeb514756e3c.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d07966c9-3620-4cb9-a62d-eeb514756e3c.png)'
- en: '*R²* typically ranges between zero and one. The *R²* value of zero means the
    model does not explain or capture the target variable variability at all and is
    not a good fit to the data. On the other hand, the *R²* value of one means that
    the model captures 100% of the target variable variability and is a perfect fit
    to the data. The closer to one the *R²* value is, the better the model fit is.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*R²*的值通常在零和一之间。*R²*值为零意味着模型根本没有解释或捕捉到目标变量的变异性，且不适合数据。另一方面，*R²*值为一意味着模型捕捉到目标变量100%的变异性，完美地拟合数据。*R²*值越接近一，模型的拟合度越好。'
- en: 'Lastly, a scatter plot of predicted values against actual values is also used
    to visualize how closely the model fits. An example of this scatter plot looks
    like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，预测值与实际值的散点图也用于可视化模型拟合的紧密程度。这个散点图的示例如下：
- en: '![](img/fb192e2b-eec1-4f51-a8c5-e0123c35a3c7.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb192e2b-eec1-4f51-a8c5-e0123c35a3c7.png)'
- en: For a good fit, you will see points in this scatter plot that are close to the
    diagonal line. If the model's *R²* is high, the points will be close to the diagonal
    line. On the other hand, if the model's *R²* is low, the points will be dispersed
    away from the diagonal line. In the following programming exercises, we will discuss
    how to compute and visualize these measures in Python and R, and will use these
    measures to evaluate our regression model.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个良好的拟合，你会在这个散点图中看到靠近对角线的点。如果模型的*R²*值较高，点会靠近对角线。另一方面，如果模型的*R²*值较低，点会分散在对角线附近。在接下来的编程练习中，我们将讨论如何在Python和R中计算和可视化这些度量，并利用这些度量来评估我们的回归模型。
- en: Predicting the 3 month CLV with Python
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Python预测3个月的CLV
- en: In this section, we are going to discuss how to build and evaluate regression
    models using machine learning algorithms in Python. By the end of this section,
    we will have built a predictive model using a linear regression algorithm to predict
    the CLV**, **more specifically, the expected 3 month customer value. We will be
    mainly using the `pandas`, `matplotlib`, and `scikit-learn` packages to analyze,
    visualize, and build machine learning models that predict the expected 3 month
    customer value. For those readers who would like to use R instead of Python for
    this exercise, you can skip to the next section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何使用Python中的机器学习算法构建和评估回归模型。在本节结束时，我们将使用线性回归算法构建一个预测模型，来预测**CLV**，更具体地说，是预测3个月的客户价值。我们将主要使用`pandas`、`matplotlib`和`scikit-learn`这三个包来分析、可视化并构建预测3个月客户价值的机器学习模型。如果有读者希望使用R语言进行这个练习，你可以跳到下一节。
- en: For this exercise, we will be using one of the publicly available datasets from
    the UCI Machine Learning Repository, which can be found at this link: [http://archive.ics.uci.edu/ml/datasets/online+retail](http://archive.ics.uci.edu/ml/datasets/online+retail).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将使用来自UCI机器学习库的公开数据集之一，数据集可以通过这个链接访问：[http://archive.ics.uci.edu/ml/datasets/online+retail](http://archive.ics.uci.edu/ml/datasets/online+retail)。
- en: 'You can follow this link and download the data that is available in XLSX format,
    named `Online Retail.xlsx`. Once you have downloaded this data, you can load it
    into your Jupyter Notebook by running the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击这个链接下载以XLSX格式提供的数据，文件名为`Online Retail.xlsx`。下载完数据后，你可以通过运行以下命令将其加载到你的Jupyter
    Notebook中：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The DataFrame, `df`, looks as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框`df`如下所示：
- en: '![](img/a9eb6cfd-3f17-4def-a284-75d9244a0dad.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9eb6cfd-3f17-4def-a284-75d9244a0dad.png)'
- en: As you might have noticed, we have used this dataset a few times in the previous
    chapters. With the knowledge we gained about this dataset from the previous chapters,
    we are going to first prepare our data by cleaning it up.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，我们在前面的章节中已经多次使用了这个数据集。凭借我们从前几章学到的知识，我们将首先通过清理数据来准备它。
- en: Data cleanup
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据清理
- en: 'As you might recall, there are a few things we need to clean up in this dataset. The
    clean-up steps are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，数据集中有一些我们需要清理的内容。清理步骤如下：
- en: '**Handling negative quantity**: There are transactions with a negative `Quantity`
    value, which represent canceled orders. We are going to ignore those canceled
    orders for this exercise, so we will need to exclude them from our `pandas` DataFrame.
    The code to exclude these negative values in the `Quantity` column looks as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理负数量**：数据中有些交易的`Quantity`值为负，表示已取消的订单。为了这个练习，我们将忽略这些已取消的订单，因此需要将它们从`pandas`数据框中排除。排除`Quantity`列中负值的代码如下所示：'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are simply taking all of those rows with a positive `Quantity` value and
    storing them back to the `df` variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将所有`Quantity`值为正的行提取出来，并重新存储到`df`变量中。
- en: '**Dropping ****NaN**** records**: We need to drop records with no `CustomerID`.
    Since we are going to build a machine learning model to predict the 3 month customer
    value, we need to group the data by the `CustomerID` column. Without it, we cannot
    properly build models for this project. The code to drop records with no `CustomerID`
    values looks like the following code snippet:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除`NaN`记录**：我们需要删除没有`CustomerID`的记录。因为我们要构建一个机器学习模型来预测3个月的客户价值，我们需要按`CustomerID`列对数据进行分组。如果没有`CustomerID`，我们就无法为这个项目正确构建模型。删除没有`CustomerID`的记录的代码如下所示：'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see from this code, we are using the `notnull` function in the `pandas`
    package. This function returns a list of arrays, where `True` values indicate
    that the value in the given index is not `null` and `False` values indicate that
    the value in the given index is `null`. We store these records with not null values
    in the `CustomerID` column back to the `df` variable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中你可以看到，我们使用了`pandas`包中的`notnull`函数。该函数返回一个数组列表，其中`True`表示给定索引处的值不是`null`，`False`表示给定索引处的值是`null`。我们将`CustomerID`列中非空值的记录重新存储回`df`变量中。
- en: '**Handling incomplete data**: Another cleanup we need to do is to handle incomplete
    data. If you recall from previous chapters, the transaction data for the last
    month is incomplete. Take a look at the following output:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理不完整数据**：我们需要做的另一项清理工作是处理不完整的数据。如果你还记得之前章节的内容，上一月的交易数据是不完整的。请看一下下面的输出：'
- en: '![](img/a3af534f-d396-4326-99bb-56e0fc12fd39.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3af534f-d396-4326-99bb-56e0fc12fd39.png)'
- en: 'As you can see from this output, the dataset has all of the transactions between
    December 1, 2010 and December 9, 2011\. The data for the last month, December
    2011, is not complete. In order to properly build a model for the 3 month customer
    value predictions, we are going to ignore the transactions in the last month.
    Take a look at the following code that shows how to drop those records from our
    DataFrame:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从此输出中看到的，数据集包含了2010年12月1日至2011年12月9日之间的所有交易。2011年12月的数据是不完整的。为了正确构建3个月客户价值预测模型，我们将忽略最后一个月的交易。请查看以下代码，展示如何从我们的DataFrame中删除这些记录：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are simply taking all of the transactions that occurred before December 01,
    2011 and storing them back to the `df` variable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将2011年12月01日之前发生的所有交易提取出来，并存储回`df`变量中。
- en: '**Total sales value**: Lastly, we need to create a column for the total sales
    value for each transaction. Take a look at the following code:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**总销售额**：最后，我们需要为每笔交易创建一个列来记录总销售额。请查看以下代码：'
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are multiplying the `Quantity` column by the `UnitPrice` column to get the
    total purchase amount for each transaction. Then, we store these values into a
    column named `Sales`. We have now completed all of the clean-up tasks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Quantity`列与`UnitPrice`列相乘，以获得每笔交易的总购买金额。然后，我们将这些值存储到一个名为`Sales`的列中。我们现在已经完成了所有的清理任务。
- en: 'Now we have cleaned up all of the transaction data, let''s summarize this data
    for each order or `InvoiceNo`. Take a look at the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清理了所有交易数据，接下来让我们总结每个订单或`InvoiceNo`的数据。请查看以下代码：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see from this code, we are grouping the `DataFrame` `df` by two
    columns, `CustomerID` and `InvoiceNo`. Then, we are summing up all of the `Sales` values
    for each customer and order, and taking the last transaction time for the given
    order as `InvoiceDate`. This way we now have a `DataFrame`, `orders_df`, as we
    need to know about each order that each customer placed. The data looks like the
    following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从此代码中看到的，我们正在通过两列，`CustomerID`和`InvoiceNo`，对`DataFrame` `df`进行分组。然后，我们为每个客户和订单求和所有的`Sales`值，并取该订单的最后交易时间作为`InvoiceDate`。这样，我们就得到了一个`DataFrame`，`orders_df`，它包含了我们需要了解的每个客户的订单数据。数据如下所示：
- en: '![](img/ff405d41-3509-416f-a52b-97f8687aa1ff.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff405d41-3509-416f-a52b-97f8687aa1ff.png)'
- en: Before we dive into building models, let's take a closer look at this customer
    purchase history data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建模型之前，先来仔细看看这个客户购买历史数据。
- en: Data analysis
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据分析
- en: 'In order to calculate the CLV, we need to know the frequency, recency, and
    total amount of purchases by each customer. We are going to compute basic information
    about each customer''s average and lifetime purchase amount, as well as each customer''s
    duration and frequency of purchases. Take a look at the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算CLV，我们需要知道每个客户的购买频率、最近一次购买时间和总购买金额。我们将计算每个客户的平均购买金额、生命周期购买金额，以及每个客户的购买时长和购买频率。请查看以下代码：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We first group by the `CustomerID` column and aggregate the numbers by `Sales`
    and `InvoiceDate` columns. If you look closely at the aggregation functions, we
    are using four customer aggregation functions: `groupby_mean`, `groupby_count`,
    `purchase_duration`, and `avg_frequency`. The first function, `groupby_mean`,
    simply computes the average for each group and the second function, `groupby_count`,
    simply counts the number of records in each group. The `purchase_duration` function
    counts the number of days between the first and last invoice dates in each group
    and the `avg_frequency` function calculates the average number of days between
    orders by dividing `purchase_duration` by the number of orders.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先按`CustomerID`列进行分组，并根据`Sales`和`InvoiceDate`列对数据进行聚合。如果您仔细观察聚合函数，我们使用了四个客户聚合函数：`groupby_mean`、`groupby_count`、`purchase_duration`和`avg_frequency`。第一个函数`groupby_mean`简单地计算每个组的平均值，第二个函数`groupby_count`则计算每个组中的记录数。`purchase_duration`函数计算每个组中第一笔和最后一笔发票日期之间的天数，`avg_frequency`函数通过将`purchase_duration`除以订单数量来计算订单之间的平均天数。
- en: 'The resulting `DataFrame` looks like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 结果`DataFrame`如下所示：
- en: '![](img/e08ded75-3b01-4dd6-867a-70ca5df000ab.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e08ded75-3b01-4dd6-867a-70ca5df000ab.png)'
- en: This data gives us an idea of the purchases each customer has made. For example,
    the customer with ID `12346` only made one purchase on January 18, 2011\. However,
    the customer with ID `12347` has made six purchases that range from December 7,
    2010 to October 31, 2011, or over the course of `327` days. The average amount
    this customer spent on each order is `680` and, on average, this customer made
    a purchase every `54.5` days.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据让我们了解了每个客户的购买情况。例如，ID 为 `12346` 的客户只在 2011 年 1 月 18 日进行了一次购买。然而，ID 为 `12347`
    的客户在 2010 年 12 月 7 日至 2011 年 10 月 31 日之间共进行了六次购买，时间跨度为 `327` 天。该客户每次订单的平均花费为 `680`，平均每
    `54.5` 天进行一次购买。
- en: Let's take a closer look at the distributions of the number of purchases that
    the repeat customers have made.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看重复购买客户的购买次数分布情况。
- en: 'Take a look at the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see from this code, we clean up the column names of the DataFrame, `summary_df`, in
    the first line. Then, we are only taking the customers who have made at least
    two or more purchases, which represents repeat customers. Lastly, we group by
    the `sales_count` column and count how many customers belong to each category.
    The resulting plot looks as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码可以看到，首先我们清理了 `summary_df` 数据框中的列名。然后，我们仅选择那些至少进行过两次或更多次购买的客户，这代表了重复购买的客户。最后，我们按
    `sales_count` 列进行分组，并统计每个类别下的客户数量。结果图如下所示：
- en: '![](img/449becae-6f10-4e97-985c-08c3d53b7023.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/449becae-6f10-4e97-985c-08c3d53b7023.png)'
- en: 'As you can see from this plot, the majority of customers have made 10 or less
    purchases historically. Let''s take a look at the average number of days between
    purchases for these repeat customers. Take a look at the following code first:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张图可以看出，大多数客户的历史购买次数不超过 10 次。接下来，我们来看一下这些重复购买客户之间购买的平均天数。首先看一下以下代码：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are building a histogram with the purchase frequency data using the `hist`
    function in the `pandas` package. The `bins` parameter defines the number of histogram
    bins to build. The result looks as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 `pandas` 包中的 `hist` 函数构建购买频率数据的直方图。`bins` 参数定义了要构建的直方图的区间数。结果如下所示：
- en: '![](img/7f913c60-4b71-4ffe-aa3f-1c8c10660bbe.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f913c60-4b71-4ffe-aa3f-1c8c10660bbe.png)'
- en: This plot tells us the overall view of how frequently repeat customers made
    purchases historically. As you can see from this plot, the majority of repeat
    customers made purchases every 20 to 50 days.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图展示了重复购买客户历史购买频率的整体情况。从这张图可以看出，大多数重复购买客户每隔 20 到 50 天进行一次购买。
- en: Predicting the 3 month CLV
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测 3 个月的 CLV
- en: In this section, we are going to build a model that predicts the 3 month customer
    value using the `pandas` and `scikit-learn` packages in Python. We are going to
    first slice the data into chunks of 3 months and take the last 3 months' data
    as the target for predictions and the rest as the features. We will first prepare
    our data for model building and then train a linear regression model for the 3
    month customer value predictions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Python 中的 `pandas` 和 `scikit-learn` 包构建一个预测 3 个月客户价值的模型。我们将首先将数据切分为
    3 个月为一组，并将最后 3 个月的数据作为预测目标，其余的数据作为特征。我们将首先为模型构建准备数据，然后训练一个线性回归模型，以预测 3 个月的客户价值。
- en: Data preparation
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据准备
- en: 'In order to build a predictive model, we need to prepare our data first, so
    that we can feed the relevant data into the model. Take a look at the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建预测模型，我们首先需要准备数据，以便将相关数据输入模型。看看以下代码：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since we want to predict the 3 month customer value, we are breaking down the
    data into chunks of 3 months for each customer. As you can see in the `groupby`
    function, we group the previously built DataFrame `orders_df` by `CustomerID`
    and a custom `Grouper`, which groups `InvoiceDate` by every 3 months. Then, for
    each group of 3 month time windows, we sum up all of the sales to get the total
    purchase amount, take the average of purchase amount and the total number of purchases
    for the given period for each customer. This way we have aggregate data that has
    purchase information for each customer for every 3 months. Lastly, we do some
    cleanup for the column names. The data in `data_df` now looks like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要预测未来三个月的客户价值，我们将数据拆分成每个客户的三个月时间段。如你所见，在`groupby`函数中，我们通过`CustomerID`和自定义的`Grouper`将之前构建的`orders_df`数据框按每三个月进行分组。然后，对于每个三个月的时间窗口，我们将所有销售额求和，以获得总购买金额，计算购买金额的平均值，并统计给定时间段内每个客户的购买总数。通过这种方式，我们得到了每个客户每三个月的购买信息的汇总数据。最后，我们对列名进行了清理。`data_df`中的数据现在如下所示：
- en: '![](img/33c49877-1890-4c97-8648-38c7ad25ab60.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33c49877-1890-4c97-8648-38c7ad25ab60.png)'
- en: 'In order to make things simpler, let''s encode the `InvoiceDate` column values
    so that they are easier to read than the current date format. Take a look at the
    following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化操作，让我们对`InvoiceDate`列的值进行编码，使其比当前日期格式更易于阅读。请查看以下代码：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see from this code, we are encoding date values into `M_1`, `M_2`,
    `M_3`, and so forth, where the smaller number represents more recent dates. For
    example, the date `2011-12-31` is now encoded as `M_1` and the date `2011-09-30` is
    now encoded as `M_2`. The result looks as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看到，我们正在将日期值编码为`M_1`、`M_2`、`M_3`等，其中较小的数字代表较近的日期。例如，日期`2011-12-31`现在被编码为`M_1`，日期`2011-09-30`被编码为`M_2`。结果如下所示：
- en: '![](img/379317cf-1ae3-4426-b577-ebe2c341ac7e.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/379317cf-1ae3-4426-b577-ebe2c341ac7e.png)'
- en: 'We are now ready to build a sample set with features and target variables.
    As briefly mentioned before, we are going to use the last 3 months as the target
    variable and the rest as the features, meaning we are going to train a machine
    learning model that predicts the last 3 months'' customer value with the rest
    of the data. In order to train such a model, we need to transform this data into
    tabular data, where the rows represent the individual customers and the columns
    represent each feature. Take a look at the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好构建一个包含特征和目标变量的样本集。如前所述，我们将使用最近的三个月作为目标变量，其余的作为特征，这意味着我们将训练一个机器学习模型，用来预测未来三个月的客户价值，基于其余数据。为了训练这个模型，我们需要将数据转化为表格数据，其中行表示单个客户，列表示每个特征。请查看以下代码：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see from this code, we use the `pandas` function, `pivot_table`,
    where the index is going to be `CustomerID` and the columns are going to be `sales_sum`,
    `sales_avg`, and `sales_count` for each 3 month period. The DataFrame, `features_df`, that
    we created here looks like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看到，我们使用了`pandas`函数`pivot_table`，其中索引将是`CustomerID`，列将是每个三个月周期的`sales_sum`、`sales_avg`和`sales_count`。我们在这里创建的`features_df`数据框如下所示：
- en: '![](img/de663bc6-6fdc-42c6-896c-c7110483f16c.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de663bc6-6fdc-42c6-896c-c7110483f16c.png)'
- en: 'You might notice that this data has `NaN` values. We can encode these `NaN`
    values with `0.0` using the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到这些数据中有`NaN`值。我们可以使用以下代码将这些`NaN`值编码为`0.0`：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have built the features DataFrame, let''s build the target variables.
    Take a look at the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了特征数据框，接下来我们来构建目标变量。请查看以下代码：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see from this code, we are taking the last 3 month period, the `M_1`
    group, as the target variable. The target column will be `sales_sum`, as we want
    to predict the next 3 month customer value, which is the total purchase amount
    that a given customer is likely to make in the next 3 months. The target variable
    looks like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看到，我们正在选择最近的三个月时间段，即`M_1`组，作为目标变量。目标列将是`sales_sum`，因为我们想要预测下一个三个月的客户价值，也就是预测一个给定客户在接下来的三个月内可能进行的总购买金额。目标变量如下所示：
- en: '![](img/4340c6c8-7f71-45f5-acdd-c4f56f1823b1.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4340c6c8-7f71-45f5-acdd-c4f56f1823b1.png)'
- en: 'There is only one thing left to build, which is a sample set for building machine
    learning models, combining features and response data together. Take a look at
    the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下最后一步了，那就是构建一个样本集，用于构建机器学习模型，将特征和响应数据结合在一起。请查看以下代码：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see here, we are simply joining the two `DataFrames` on `CustomerID`,
    using the `merge` function. By having the `how=''left''` flag, we take all records
    in the features data, even if there is no corresponding data in the response data.
    This is a case where the given customer did not make any purchases in the last
    3 months, so we encode them as zero. The final sample set now looks as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过使用`merge`函数在`CustomerID`上将两个`DataFrames`进行连接。通过设置`how='left'`标志，我们将获取特征数据中的所有记录，即使响应数据中没有对应的数据。这是一个例子，其中给定的客户在过去3个月内没有进行任何购买，因此我们将其编码为零。最终的样本集现在如下所示：
- en: '![](img/15154c88-06d5-4b5a-a549-380ca1644e47.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15154c88-06d5-4b5a-a549-380ca1644e47.png)'
- en: With this data, we can now build a model that predicts the next 3 month customer
    value with historical purchase data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些数据，我们现在可以建立一个模型，通过历史购买数据预测未来3个月的客户价值。
- en: Linear regression
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性回归
- en: 'Similar to the previous chapter, we are going to split the sample set into
    train and test sets, using the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章类似，我们将使用以下代码将样本集分割成训练集和测试集：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see from this code, we are taking 70% of the sample set for training
    the model and the remaining 30% for testing and evaluating the model performance.
    In this section, we will be using a linear regression model. However, we recommend
    experimenting with other machine learning algorithms, such as random forest and
    **support vector machine** (**SVM**).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这段代码中所见，我们使用样本集的70%来训练模型，其余30%用于测试和评估模型性能。在本节中，我们将使用线性回归模型。然而，我们建议您尝试其他机器学习算法，例如随机森林和**支持向量机**（**SVM**）。
- en: More details on how to train these models with the `scikit-learn` package can
    be found at the following links: [https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html)
    and [https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVR.html](https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVR.html).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用`scikit-learn`包训练这些模型的更多细节，可以参考以下链接：[https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html)
    和 [https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVR.html](https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVR.html)。
- en: 'In order to train a linear regression model with our dataset, you can use the
    following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们的数据集训练线性回归模型，您可以使用以下代码：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is as simple as it gets. You import the `LinearRegression` class of the `scikit-learn`
    package and initiate a `LinearRegression` object. Then, you can train a linear
    regression model using the `fit` function with the `x_train` features and the
    `y_train` targets.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最简单的实现方式。您导入`scikit-learn`包中的`LinearRegression`类，并初始化一个`LinearRegression`对象。然后，您可以使用`fit`函数和`x_train`特征与`y_train`目标来训练线性回归模型。
- en: 'Once a linear regression model is trained, there is some useful information
    that you can find in the `LinearRegression` object. First, you can get the intercept
    of the linear regression equation, using the `intercept_` attribute of the `LinearRegression`
    object, like the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦训练了线性回归模型，您可以在`LinearRegression`对象中找到一些有用的信息。首先，您可以使用`LinearRegression`对象的`intercept_`属性来获取线性回归方程的截距，如下所示：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also, you can find the fitted linear regression model''s coefficients, using
    the `coef_` attribute like the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用`coef_`属性来查找拟合的线性回归模型的系数，如以下代码所示：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The coefficients of each feature of the fitted regression model look as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 拟合回归模型中每个特征的系数如下所示：
- en: '![](img/068cb89f-24b8-4507-b823-65dbb533af54.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/068cb89f-24b8-4507-b823-65dbb533af54.png)'
- en: As you can see from this coefficient output, you can easily find which features
    have negative correlation with the target and which features have positive correlation
    with the target. For example, the previous 3 month period's average purchase amount,
    `sales_avg_M_2`, has negative impacts on the next 3 month customer value. This
    means that the higher the previous 3 month period's purchase amount is, the lower
    the next 3 month purchase amount will be. On the other hand, the second and third most
    recent 3 month period's average purchase amounts, `sales_avg_M_3` and `sales_avg_M_4`,
    are positively correlated with the next 3 month customer value. In other words,
    the more a customer made purchases 3 months to 9 months ago, the higher value
    he or she will bring in the next 3 months. Looking at the coefficients is one
    way to gain insights on how the expected value will change, given certain features.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个系数输出中可以看出，你可以轻松地找到与目标变量呈负相关和正相关的特征。例如，前3个月的平均购买金额 `sales_avg_M_2` 对接下来的3个月客户价值有负面影响。这意味着，前3个月的购买金额越高，接下来3个月的购买金额越低。另一方面，第二和第三最近的3个月期间的平均购买金额
    `sales_avg_M_3` 和 `sales_avg_M_4` 与接下来3个月的客户价值呈正相关。换句话说，客户在3到9个月前的购买金额越多，接下来3个月的客户价值越高。查看系数是了解给定某些特征时，预期值如何变化的一种方式。
- en: Using the 3 month customer value prediction output, you can custom-tailor your
    marketing strategies in different ways. Since you know the expected revenue or
    purchase amount from individual customers for the next 3 months, you can set a
    better informed budget for your marketing campaign. It should be set high enough
    to reach your target customers, but low enough to be below the expected 3 month
    customer value, so that you can have a positive ROI marketing campaign. On the
    other hand, you can also use these 3 month customer value prediction output values to
    specifically target these high-value customers for the next 3 months. This can
    help you to create marketing campaigns with a higher ROI, as those high-value
    customers, predicted by this model, are likely to bring in more revenue than the
    others.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用3个月客户价值预测的输出，你可以根据不同方式定制你的营销策略。由于你已经知道了来自单个客户在接下来的3个月内的预期收入或购买金额，你可以为你的营销活动制定更为合理的预算。预算应该足够高，以便能够接触到目标客户，但又不能超过预期的3个月客户价值，这样才能确保你有一个正向投资回报率的营销活动。另一方面，你也可以利用这些3个月客户价值的预测输出，专门针对这些高价值客户进行营销。这可以帮助你制定出具有更高投资回报率的营销活动，因为根据该模型预测，这些高价值客户可能带来的收入会比其他客户更多。
- en: Evaluating regression model performance
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估回归模型性能
- en: 'Now that we have a machine learning model that is fitted to predict the 3 month
    customer value, let''s discuss how to evaluate the performance of this model.
    As discussed previously, we are going to use *R²*, MAE, and a scatter plot of
    predicted versus actual to evaluate our model. We need to get the prediction output
    from our model first, as shown in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个拟合好的机器学习模型，用于预测3个月的客户价值。接下来，我们来讨论如何评估这个模型的性能。如前所述，我们将使用 *R²*、MAE 和预测值与实际值的散点图来评估我们的模型。我们首先需要从模型中获取预测结果，代码如下所示：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `scikit-learn` package has implemented the functions to compute the *R²*
    and the MAE in their `metrics` module. You can use these functions by importing
    them into your environment, like the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-learn` 包已经实现了用于计算 *R²* 和 MAE 的函数，这些函数位于其 `metrics` 模块中。你可以通过将它们导入到你的环境中来使用这些函数，代码如下：'
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As the names suggest, the `r2_score` function computes the *R²* and the `median_absolute_error`
    function computes the MAE. You can compute the *R**²* and MAE numbers, using the
    following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，`r2_score` 函数计算 *R²*，而 `median_absolute_error` 函数计算 MAE。你可以使用以下代码计算 *R²*
    和 MAE 的数值：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see from here, both functions take two parameters, `y_true` and
    `y_pred`. The `y_true` parameter is for the actual target values and the `y_pred`
    parameter is for the predicted target values. Using these codes, the in-sample
    and out-of-sample values for R² and MAE in our case look like the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里可以看到，这两个函数都需要两个参数，`y_true` 和 `y_pred`。`y_true` 参数是实际的目标值，`y_pred` 参数是预测的目标值。使用这些代码，在我们的案例中，样本内和样本外的
    R² 和 MAE 数值输出如下：
- en: '![](img/eca7324c-292f-46d9-9ac2-80f1f24565af.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eca7324c-292f-46d9-9ac2-80f1f24565af.png)'
- en: Due to the randomness in splitting the sample set into train and test sets,
    your might differ from these results. In our case, the in-sample R² was `0.4445`
    and the out-of-sample R² was `0.7947`. On the other hand, the in-sample MAE was
    `178.2854` and the out-of-sample MAE was `178.7393`. Looking at these numbers,
    we do not necessarily see a hint of overfitting or a big gap between the in-sample
    and out-of-sample performances.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将样本集随机分割为训练集和测试集，您的结果可能与这些结果有所不同。在我们的情况下，训练集中的R²为`0.4445`，测试集中的R²为`0.7947`。另一方面，训练集中的MAE为`178.2854`，测试集中的MAE为`178.7393`。从这些数字来看，我们并没有看到明显的过拟合迹象，也没有在训练集和测试集的表现之间看到很大的差距。
- en: 'Lastly, let''s take a look at the scatter plot of predicted versus actual.
    You can use the following code for this scatter plot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看看预测值与实际值的散点图。您可以使用以下代码来生成该散点图：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The resulting plot looks as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图表如下所示：
- en: '![](img/17145852-4938-4328-ae5a-9fd7ed9a18bb.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17145852-4938-4328-ae5a-9fd7ed9a18bb.png)'
- en: As you can see from this plot, the *x*-values are the actual values and the
    *y*-values are the predicted values. As discussed earlier, the more the points
    that are on the straight line, the better the predictions are. This is because
    points on the straight line suggest that the actual values and the predicted values
    are close to each other. Looking at this plot, the points seem to be positioned
    around the straight line, which suggests that the predictions and the actual values
    are not too far apart from each other.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从这个图中看到的，*x*轴的值是实际值，*y*轴的值是预测值。如前所述，点越多位于直线附近，预测效果越好。这是因为直线上的点表明实际值和预测值非常接近。从这个图来看，点似乎围绕着直线分布，这表明预测值和实际值之间并没有太大的差距。
- en: The full code for this Python exercise can be found at the following repository: [https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.9/python/CustomerLifetimeValue.ipynb](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.9/python/CustomerLifetimeValue.ipynb).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本次Python练习的完整代码可以在以下仓库中找到：[https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.9/python/CustomerLifetimeValue.ipynb](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.9/python/CustomerLifetimeValue.ipynb)。
- en: Predicting the 3 month CLV with R
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用R预测未来3个月的CLV
- en: In this section, we are going to discuss how to build and evaluate regression
    models using machine learning algorithms in R. By the end of this section, we
    will have built a predictive model using a linear regression algorithm to predict
    the CLV, more specifically, the expected 3 month customer value. We will be using
    a handful of R packages, such as `dplyr`, `reshape2`, and `caTools`, to analyze,
    transform, and prepare the data for building machine learning models to predict
    the expected 3 month customer value. For those readers who would like to use Python
    instead of R for this exercise, you can refer to the previous section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何使用R中的机器学习算法构建和评估回归模型。到本节结束时，我们将使用线性回归算法构建一个预测模型，以预测**CLV**，更具体地说，预测未来3个月的客户价值。我们将使用一些R包，如`dplyr`、`reshape2`和`caTools`，来分析、转换和准备数据，以构建机器学习模型，预测未来3个月的客户价值。对于那些希望使用Python而非R来进行本次练习的读者，可以参考上一节。
- en: 'For this exercise, we will be using one of the publicly available datasets
    from the UCI Machine Learning Repository, which can be found at this link: [http://archive.ics.uci.edu/ml/datasets/online+retail](http://archive.ics.uci.edu/ml/datasets/online+retail).
    You can follow this link and download the data that is available in XLSX format,
    named `Online Retail.xlsx`. Once you have downloaded this data, you can load it
    into your R environment by running the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本次练习，我们将使用一个来自UCI机器学习库的公开数据集，您可以通过以下链接找到：[http://archive.ics.uci.edu/ml/datasets/online+retail](http://archive.ics.uci.edu/ml/datasets/online+retail)。您可以点击此链接并下载以XLSX格式提供的数据，文件名为`Online
    Retail.xlsx`。下载数据后，您可以通过运行以下命令将其加载到您的R环境中：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The DataFrame, `df`, looks as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框`df`如下所示：
- en: '![](img/2d1c74f8-8a70-4f8c-8529-b3997cb85879.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d1c74f8-8a70-4f8c-8529-b3997cb85879.png)'
- en: As you might have noticed, we have used this dataset a few times in the previous
    chapters. With the knowledge we gained about this dataset from the previous chapters,
    we are going to first prepare our data by cleaning up the data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，我们在前几章中已经多次使用了这个数据集。凭借我们从前几章中获得的关于这个数据集的知识，我们将首先通过清理数据来准备数据。
- en: Data cleanup
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据清理
- en: 'As you might recall, there are a few things we need to clean up in this dataset.
    The clean-up steps are as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，数据集中有一些需要清理的地方。清理步骤如下：
- en: '**Handling negative quantity**: There are transactions with a negative `Quantity`
    value, which represent canceled orders. We are going to ignore those canceled
    orders for this exercise, so we will need to exclude them from our `DataFrame`.
    The code to exclude these negative values in the `Quantity` column looks as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理负数量**：有些交易的`Quantity`值为负数，表示已取消的订单。我们将忽略这些取消的订单，因此需要从我们的`DataFrame`中排除它们。排除这些负值的`Quantity`列的代码如下：'
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are simply taking all of those rows with a positive `Quantity` value and
    storing them back to the variable `df`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将所有`Quantity`值为正的行提取出来，并将它们存储回变量`df`中。
- en: '**Dropping NA r****ecords**: We need to drop records with no value in the `CustomerID`
    column. Since we are going to build a machine learning model to predict the 3
    month customer value, we need to group the data by the `CustomerID` column. Without
    it, we cannot properly build models for this project. The code to drop records
    with null values looks like the following code snippet:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除NA记录**：我们需要删除在`CustomerID`列中没有值的记录。因为我们将构建一个机器学习模型来预测3个月的客户价值，所以需要按`CustomerID`列对数据进行分组。没有这个字段，我们就无法为这个项目构建合适的模型。删除这些空值记录的代码如下：'
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see from this code, we are using the `na.omit` function in R. This
    function returns an object with `null` or `NA` values removed. Then, we store
    the output back to the original DataFrame, `df` variable.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看到，我们在R语言中使用了`na.omit`函数。这个函数会返回一个去除了`null`或`NA`值的对象。然后，我们将输出结果重新存储到原始的`DataFrame`变量`df`中。
- en: '**Handling incomplete data**: If you recall from previous chapters, the transaction
    data for the last month is incomplete. Take a look at the following output:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理不完整数据**：如果你还记得前几章提到的，最后一个月的交易数据是不完整的。请看以下输出：'
- en: '![](img/aaa9c600-f132-4fee-90ec-67411a59dd9c.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaa9c600-f132-4fee-90ec-67411a59dd9c.png)'
- en: 'As you can see from this output, the dataset has all the transactions between
    December 1st, 2010 and December 9, 2011\. The data for the last month, December
    of 2011, is not complete. In order to properly build a model for the 3 month customer
    value predictions, we are going to ignore the transactions in the last month.
    Take a look at the following code on how to drop those records from our DataFrame:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中可以看到，数据集包含了2010年12月1日到2011年12月9日之间的所有交易数据。2011年12月的数据是不完整的。为了能够正确地构建3个月客户价值预测的模型，我们将忽略最后一个月的交易数据。请看以下代码，了解如何从我们的`DataFrame`中删除这些记录：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We are simply taking all of the transactions that occurred before December 1,
    2011 and storing them back to the variable, `df`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将2011年12月1日之前发生的所有交易提取出来，并将它们存储回变量`df`中。
- en: '**Total sales value**: Lastly, we need to create a column for the total sales
    value for each transaction. Take a look at the following code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**总销售额**：最后，我们需要为每笔交易创建一个列，表示每笔交易的总销售额。请看以下代码：'
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are simply multiplying the `Quantity` column by the `UnitPrice` column to
    get the total purchase amount for each transaction. Then, we store these values
    into a column named `Sales`. We have now completed all the cleanup tasks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅仅是将`Quantity`列与`UnitPrice`列相乘，以得到每笔交易的总购买金额。然后，我们将这些值存储到名为`Sales`的列中。现在，我们已经完成了所有的清理任务。
- en: 'Now we have cleaned up all the transaction data, let''s summarize this data
    for each order or `InvoiceNo`. Take a look at the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清理了所有交易数据，让我们为每个订单或`InvoiceNo`总结一下这些数据。请看以下代码：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see from this code, we are grouping `df` by two columns, `CustomerID` and `InvoiceNo`.
    Then, we are summing up all the `Sales` values for each customer and order, and
    taking the last transaction time for the given order as the `InvoiceDate`. This
    way we now have a DataFrame, `ordersDF`, that we need to know about each order
    that each customer placed. The data looks like the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码可以看到，我们正在按`CustomerID`和`InvoiceNo`两个列对`df`进行分组。接着，我们对每个客户和订单的`Sales`值进行求和，并将该订单的最后交易时间作为`InvoiceDate`。这样，我们就得到了一个名为`ordersDF`的`DataFrame`，它包含了每个客户所下的每个订单的相关信息。数据如下所示：
- en: '![](img/0232f5d8-47e5-426d-97f4-0d2f72b64178.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0232f5d8-47e5-426d-97f4-0d2f72b64178.png)'
- en: Before we dive into building models, let's take a closer look at this customer
    purchase history data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入构建模型之前，先来仔细查看一下这个客户购买历史数据。
- en: Data analysis
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据分析
- en: 'In order to calculate the CLV, we need to know the frequency, recency, and
    total amount of purchases by each customer. We are going to compute basic information
    about each customer''s average and lifetime purchase amount, as well as each customer''s
    duration and frequency of purchases. Take a look at the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算CLV（客户终身价值），我们需要了解每个客户的购买频率、最近购买时间和总购买金额。我们将计算每个客户的平均购买金额和生命周期购买金额，以及每个客户的购买持续时间和频率。请查看以下代码：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We first group by the `CustomerID` column and aggregate the numbers by `Sales` and `InvoiceDate` columns.
    Using the `min`, `max`, `sum`, `mean`, and `n` functions in R, we can compute
    the minimum, maximum, and total purchase amount, as well as the average amount
    and the number of purchases for each customer. We also use the `min` and `max`
    functions to get the first and last order dates for each customer. For `PurchaseDuration`,
    we are taking the number of days between the last and the first order dates. For
    `PurchaseFrequency`, we are dividing the `PurchaseDuration` number by the number
    of orders to get the average number of days between purchases.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先按照`CustomerID`列进行分组，并对`Sales`和`InvoiceDate`列进行聚合。通过使用R中的`min`、`max`、`sum`、`mean`和`n`函数，我们可以计算每个客户的最小、最大、总购买金额、平均购买金额以及购买次数。我们还使用`min`和`max`函数来获取每个客户的首次和最后一次订单日期。对于`PurchaseDuration`，我们计算的是每个客户最后一次和首次订单日期之间的天数。对于`PurchaseFrequency`，我们将`PurchaseDuration`的天数除以购买次数，从而得到平均购买间隔天数。
- en: 'The resulting DataFrame, `summaryDF`, looks like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`DataFrame`，`summaryDF`，如下所示：
- en: '![](img/a3175c13-7c99-4c44-ae47-f08ac0948bf4.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3175c13-7c99-4c44-ae47-f08ac0948bf4.png)'
- en: This data gives us an idea of the purchases each customer has made. For example,
    the customer with ID `12346` only made one purchase on January 18, 2011\. However,
    the customer with ID `12347` has made six purchases that range from December 7,
    2010 to October 31, 2011, or over the course of `327` days. The average amount
    this customer spent on each order is about `681` and, on average, this customer
    made a purchase every `54.5` days.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据让我们了解了每个客户的购买情况。例如，客户ID为`12346`的客户仅在2011年1月18日进行了单次购买。而客户ID为`12347`的客户则在2010年12月7日至2011年10月31日之间进行了六次购买，总计跨越了`327`天。该客户每次购买的平均金额约为`681`，而且平均每`54.5`天购买一次。
- en: 'Let''s take a closer look at the distributions of the number of purchases that
    the repeat customers have made. Take a look at the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地查看重复购买客户的购买次数分布。请查看以下代码：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We first exclude customers with only one purchase from our analysis in the
    first line of code. Then, we count the number of customers for each `SalesCount`.
    Lastly, we create a bar plot using `ggplot` and `geom_bar` to display this data.
    The result looks as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在代码的第一行中排除了仅进行过一次购买的客户。然后，我们统计了每个`SalesCount`对应的客户数量。最后，我们使用`ggplot`和`geom_bar`创建了一个条形图来展示这些数据。结果如下所示：
- en: '![](img/dbf9950d-c0b6-4061-9472-fd93bc4cebce.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbf9950d-c0b6-4061-9472-fd93bc4cebce.png)'
- en: 'As you can see from this plot, the majority of customers have made 10 or less
    purchases historically. Let''s take a look at the average number of days between
    purchases for these repeat customers. Take a look at the following code first:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张图中可以看出，大多数客户的历史购买次数都在10次以下。接下来，我们来看看这些重复购买客户的平均购买间隔天数。首先，请查看以下代码：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We are building a histogram with the purchase frequency data using the `hist` function
    in R. The `breaks` parameter defines the number of histogram bins to build. The
    result looks as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用R中的`hist`函数构建购买频率数据的直方图。`breaks`参数定义了直方图的分箱数。结果如下所示：
- en: '![](img/6031bee7-adc4-4f42-918c-e2d66dbe8c27.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6031bee7-adc4-4f42-918c-e2d66dbe8c27.png)'
- en: This plot tells us the overall view of how frequently repeat customers made
    purchases historically. As you can see from this plot, the majority of repeat
    customers made purchases every 20 to 50 days.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了历史上重复购买客户的购买频率的总体情况。从图中可以看出，大多数重复购买客户每隔20到50天进行一次购买。
- en: Predicting the 3 month CLV
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测3个月的CLV
- en: In this section, we are going to build a model that predicts the 3 month customer
    value in R. We are going to first slice the data into chunks of 3 months and take
    the last 3 month data as the target for predictions and the rest as the features.
    We will first prepare our data for model building and then train a linear regression
    model for the 3 month customer value predictions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将构建一个预测3个月客户价值的R模型。我们将首先将数据划分为3个月一组，并将最后3个月的数据作为预测的目标，其余的数据作为特征。我们将首先准备好数据来构建模型，然后训练一个线性回归模型来预测3个月的客户价值。
- en: Data preparation
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据准备
- en: 'In order to build a predictive model, we need to prepare our data first, so
    that we can feed in the relevant data into the model. Take a look at the following
    code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建预测模型，我们需要先准备数据，以便将相关数据输入模型。请查看以下代码：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see from this code, we are using the `lubridate` package that is
    going to help us to handle data with dates more easily. Using the `round_date`
    function in the `lubridate` package, we first round `InvoiceDate` to the nearest
    quarter. Then, we group the data by `CustomerID` and the newly-created column, `Quarter`, to
    get the quarterly sales data for each customer. For each group of 3 month time
    window, we sum up all of the sales to get the total purchase amount and take the
    average of purchase amount, and the total number of purchases for the given period
    for each customer. This way we have aggregate data that has purchase information
    for each customer for every 3 months. The data in `dataDF` now looks like the
    following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这段代码中，我们使用了`lubridate`包，它可以帮助我们更轻松地处理日期数据。通过`lubridate`包中的`round_date`函数，我们首先将`InvoiceDate`四舍五入到最接近的季度。接着，我们按`CustomerID`和新创建的列`Quarter`对数据进行分组，以获取每个客户的季度销售数据。对于每个3个月的时间窗口，我们将所有销售额求和以获得总购买金额，并计算该期间每个客户的平均购买金额和总购买次数。通过这种方式，我们得到了每个客户每3个月的聚合数据。`dataDF`中的数据现在如下所示：
- en: '![](img/8fbd0c64-17c6-4532-9e93-045b613adbc8.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fbd0c64-17c6-4532-9e93-045b613adbc8.png)'
- en: 'In order to make things simpler, let''s encode the `Quarter` column values
    to make them easier to read than the current date format. Take a look at the following
    code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化操作，我们将对`Quarter`列的值进行编码，使其比当前的日期格式更易于阅读。请查看以下代码：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you can see from this code, we are encoding the date values into `Q1`, `Q2`, `Q3`,
    and so forth, where the smaller number represents more recent dates. For example,
    the date `2012-01-01` is now encoded as `Q1` and the date `2011-10-01` is now
    encoded as `Q2`. The result looks as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这段代码中，我们将日期值编码为`Q1`、`Q2`、`Q3`等，其中较小的数字表示较新的日期。例如，日期`2012-01-01`现在编码为`Q1`，而日期`2011-10-01`现在编码为`Q2`。结果如下所示：
- en: '![](img/6c559f4b-73bd-49e1-82d2-f9c8e9ee2cca.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c559f4b-73bd-49e1-82d2-f9c8e9ee2cca.png)'
- en: 'We are now ready to build a sample set with features and target variables.
    As briefly mentioned before, we are going to use the last 3 months as the target
    variable and the rest as the features, meaning we are going to train a machine
    learning model that predicts the last 3 month customer value with the rest of
    the data. In order to train such a model, we need to transform this data into
    tabular data, where the rows represent the individual customers and the columns
    represent each feature. Take a look at the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好构建包含特征和目标变量的样本集。正如之前简要提到的，我们将使用过去3个月作为目标变量，其余的数据作为特征，这意味着我们将训练一个机器学习模型，该模型利用其他数据预测过去3个月的客户价值。为了训练这样的模型，我们需要将数据转换为表格数据，其中行表示单个客户，列表示每个特征。请查看以下代码：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see from this code, we are using the `reshape2` package to pivot
    the data. For example, using the `dcast` function in the `reshape2` package, we
    first transform the `SalesSum` data, where the row index represents each customer
    or `CustomerID`, the columns are each quarter, and the values are the total sales
    or purchase amount for the given customer and quarter. We repeat this process
    three times for `SalesSum`, `SalesAvg`, and `SalesCount` columns and merge the
    data in the end. Using the `merge` function, we can merge these DataFrames by
    the `CustomerID` index. Lastly, we encode the `null` or `NA` values with 0, by
    using the `is.na` function. The result looks like the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从这段代码中看到的，我们正在使用`reshape2`包来旋转数据。例如，使用`reshape2`包中的`dcast`函数，我们首先转换`SalesSum`数据，其中行索引代表每个客户或`CustomerID`，列表示每个季度，值则是给定客户和季度的总销售额或购买金额。我们对`SalesSum`、`SalesAvg`和`SalesCount`列分别执行这一过程三次，并最终合并这些数据。通过使用`merge`函数，我们可以按`CustomerID`索引合并这些DataFrame。最后，我们使用`is.na`函数将`null`或`NA`值编码为0。结果如下所示：
- en: '![](img/90c833e6-f5c6-499c-bedb-e46a4836123f.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90c833e6-f5c6-499c-bedb-e46a4836123f.png)'
- en: 'Now that we have built the features `DataFrame`, let''s build the target variables.
    Take a look at the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了特征`DataFrame`，接下来让我们建立目标变量。请查看以下代码：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see from this code, we are taking the last 3 month period, `Q1` group,
    as the target variable. The target column will be `SalesSum`, as we want to predict
    the next 3 month customer value, which is the total purchase amount that a given
    customer is likely to make in the next 3 months. The result looks like the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从这段代码中看到的，我们将最后3个月的时间段，即`Q1`组，作为目标变量。目标列将是`SalesSum`，因为我们想预测下3个月的客户价值，即给定客户在接下来的3个月内可能的总购买金额。结果如下所示：
- en: '![](img/612c5361-629a-43f7-8728-81b3cf31d43c.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/612c5361-629a-43f7-8728-81b3cf31d43c.png)'
- en: 'There is only one thing left to build, which is a sample set for building machine
    learning models, combining features and response data together. Take a look at
    the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下一件事需要完成，那就是构建一个样本集，将特征数据和响应数据结合在一起，用于构建机器学习模型。请查看以下代码：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see here, we are simply joining the two `DataFrames` on `CustomerID` using
    the `merge` function. By having the `all.x=TRUE` flag, we take all records in
    the features data, even if there is no corresponding data in the response data.
    This is a case where the given customer did not make any purchases in the last
    3 months, so we encode them as 0\. The final sample set now looks as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这里看到的，我们只是通过`merge`函数根据`CustomerID`将两个`DataFrame`连接起来。通过设置`all.x=TRUE`标志，即使响应数据中没有对应的数据，我们也会保留特征数据中的所有记录。这是一个示例，表示给定客户在过去3个月内没有进行任何购买，因此我们将其编码为0。最终的样本集如下所示：
- en: '![](img/18c944a9-5933-4b2a-ab76-20467400ca57.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18c944a9-5933-4b2a-ab76-20467400ca57.png)'
- en: With this data, we can now build a model that predicts the next 3 month customer
    value with historical purchase data.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些数据，我们现在可以建立一个模型，预测下3个月的客户价值，基于历史购买数据。
- en: Linear regression
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性回归
- en: 'Similar to the previous chapter, we are going to split the sample set into
    train and test sets using the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一章类似，我们将使用以下代码将样本集拆分为训练集和测试集：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see from this code, we are taking 80% of the sample set for training
    the model and the remaining 20% for testing and evaluating the model performance.
    In this section, we will be using a linear regression model. However, we recommend
    experimenting with other machine learning algorithms, such as **random forest** and **support
    vector machine (SVM)**. You can train a random forest model with the `randomForest`
    package and an SVM model with the `e1071` package. We highly recommend taking
    a look at their documentation on the usage.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从这段代码中看到的，我们将样本集的80%用于训练模型，剩余的20%用于测试和评估模型性能。在本节中，我们将使用线性回归模型。然而，我们建议尝试其他机器学习算法，例如**随机森林**和**支持向量机（SVM）**。您可以使用`randomForest`包训练一个随机森林模型，使用`e1071`包训练一个SVM模型。我们强烈建议查看它们的使用文档。
- en: 'In order to train a linear regression model with our dataset, you can use the
    following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们的数据集训练线性回归模型，您可以使用以下代码：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is as simple as it gets. You simply supply a formula, which is `CLV_3_Month
    ~ .` in our case, and the data to train with, which is the `train` variable in
    our case, to the `lm` function. This will instruct your machine to train a linear
    regression model with the given data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单。您只需要提供一个公式，即我们这个例子中的`CLV_3_Month ~ .`，以及训练数据，即我们这个例子中的`train`变量，传递给`lm`函数。这样就可以指示机器用给定的数据训练一个线性回归模型。
- en: 'Once a linear regression model is trained, there is some useful information
    you can find in the model object. You can use the following command to get detailed
    information about the model:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦线性回归模型训练完成，您可以从模型对象中找到一些有用的信息。您可以使用以下命令获取关于模型的详细信息：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output looks as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/3553d6a1-54c6-4672-bc4b-27bb187be74a.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3553d6a1-54c6-4672-bc4b-27bb187be74a.png)'
- en: As you can see from this output, you can easily find the coefficients of each
    feature and which features have negative or positive correlation with the target.
    For example, the previous 3 month period's aggregate purchase amount, `SalesSum.Q2`,
    has positive impacts on the next 3 month customer value. This means that the higher
    the previous 3 month period's total purchase amount is, the higher the next 3
    month purchase amount will be. On the other hand, the second and fourth most recent
    3 month period's aggregate purchase amounts, `SalesSum.Q3` and `SalesSum.Q5`,
    are negatively correlated with the next 3 month customer value. In other words,
    the more a customer made purchases two quarters or four quarters ago, the lower
    the value he or she will bring in the next 3 months. Looking at the coefficients
    is one way to gain insights on how the expected value will change, given certain
    features.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中可以看到，您可以轻松找到每个特征的系数，以及哪些特征与目标有正相关或负相关。例如，前一个三个月的总购买金额`SalesSum.Q2`对下一个三个月的客户价值有正面影响。这意味着，前一个三个月的总购买金额越高，接下来的三个月购买金额也越高。另一方面，第二和第四个最近的三个月的总购买金额`SalesSum.Q3`和`SalesSum.Q5`与下一个三个月的客户价值呈负相关。换句话说，客户在两季度或四季度前的购买金额越大，接下来三个月内他们带来的价值就越低。通过查看系数，您可以获得有关如何根据某些特征来预测期望值变化的洞察。
- en: Using the 3 month customer value prediction output, you can custom-tailor your
    marketing strategies in different ways. Since you know the expected revenue or
    purchase amount from individual customers for the next 3 months, you can set a
    better informed budget for your marketing campaign. It should be set high enough
    to reach your target customers, but low enough to be below the expected 3 month
    customer value, so that you can have a positive ROI marketing campaign. On the
    other hand, you can also use these 3 month customer value prediction outputs to
    specifically target these high-value customers for the next 3 months. This can
    help you to create marketing campaigns with a higher ROI, as those high-value
    customers, predicted by this model, are likely to bring in more revenue than the
    others.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个月客户价值的预测输出，您可以根据不同的方式定制您的营销策略。由于您知道每个客户在接下来的三个月内预期的收入或购买量，您可以为您的营销活动设定一个更有根据的预算。预算应该足够高，以便覆盖您的目标客户，但又要低于预计的三个月客户价值，以确保您能够实现正向投资回报率（ROI）的营销活动。另一方面，您还可以利用这些三个月客户价值的预测输出，专门针对这些高价值客户进行营销，这有助于您创建更高ROI的营销活动，因为这些通过模型预测的高价值客户，可能会带来比其他客户更多的收入。
- en: Evaluating regression model performance
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估回归模型的表现
- en: 'Now that we have a machine learning model that is trained to predict the 3
    month customer value, let''s discuss how to evaluate the performance of this model.
    As discussed previously, we are going to use R2, MAE, and a scatter plot of predicted
    versus actual to evaluate our model. We first need to get the prediction output
    from our model, like the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个训练好的机器学习模型，可以预测三个月后的客户价值，接下来我们来讨论如何评估这个模型的表现。正如前面所讨论的，我们将使用R²、MAE和预测值与实际值的散点图来评估我们的模型。我们首先需要从模型中获取预测输出，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We are going to use the `miscTools` package to compute the in-sample and out-of-sample
    R² values. Take a look at the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`miscTools`包来计算样本内和样本外的R²值。请看以下代码：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The R² values, in our case, look like the following output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，R²值看起来像以下输出：
- en: '![](img/446db2ee-cf0e-4c18-bc01-bc97fdbb3225.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/446db2ee-cf0e-4c18-bc01-bc97fdbb3225.png)'
- en: Due to the randomness in splitting the sample set into train and test sets,
    your results might differ from these results. In our case, the in-sample R² was `0.4557` and
    the out-of-sample R² was `0.1235`. The rather big gap between the in-sample and
    out-of-sample R² values suggests that there is some overfitting happening, where
    the model performs significantly better in the train set and worse in the test
    set. In case of overfitting, you can try different combinations of features or
    use more samples for training.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在将样本集分割为训练集和测试集时存在随机性，你的结果可能与这些结果不同。在我们的案例中，样本内的R²为`0.4557`，样本外的R²为`0.1235`。样本内和样本外R²值之间相当大的差距表明存在过拟合的情况，其中模型在训练集上的表现明显优于在测试集上的表现。遇到过拟合的情况时，你可以尝试不同的特征组合或使用更多的样本进行训练。
- en: 'Next, let''s take a look at the MAE for in-sample and out-of-sample predictions.
    Take a look at the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下样本内和样本外预测的MAE。请看下面的代码：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you can see from this code, we are using the `median` and `abs` functions
    to get the median of absolute errors in the in-sample and out-of-sample predictions.
    The result in our case looks like the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从这段代码中看到的，我们使用了`median`和`abs`函数来获取样本内和样本外预测的绝对误差的中位数。我们案例中的结果如下：
- en: '![](img/8956d3d9-c5d5-4ca6-9f0d-964a9eb69a2f.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8956d3d9-c5d5-4ca6-9f0d-964a9eb69a2f.png)'
- en: 'Lastly, let''s take a look at the scatter plot of predicted versus actual.
    You can use the following code for this scatter plot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看一下预测值与实际值的散点图。你可以使用以下代码生成这个散点图：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The resulting plot looks as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图表如下所示：
- en: '![](img/df0b8b7c-13e9-46b2-a9f0-ed8f14d5c050.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df0b8b7c-13e9-46b2-a9f0-ed8f14d5c050.png)'
- en: As you can see from this plot, the *x*-values are the actual values and the
    *y*-values are the predicted values. As discussed earlier, the more the points
    are on the straight line, the better the predictions are. This is because points
    on the straight line suggest that the actual values and the predicted values are
    close to each other. Looking at this plot, the points do not seem to be spread around
    the straight line, which suggest that the predictions are rather poor. This is
    in line with the low out-of-sample *R²* value that we observed previously. Scatter
    plot of predicted versus actual values is a good way to visualize the model performance.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从这个图表中看到的，*x*值是实际值，*y*值是预测值。正如之前讨论的，点越接近直线，预测效果越好。这是因为直线上的点表明实际值和预测值非常接近。看这个图表，点似乎没有分布在直线附近，这表明预测效果较差。这与我们之前观察到的低外样本*R²*值一致。预测值与实际值的散点图是可视化模型性能的好方法。
- en: The full code for this R exercise can be found at the following repo: [https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.9/R/CustomerLifetimeValue.R](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.9/R/CustomerLifetimeValue.R)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本次R语言练习的完整代码可以在以下仓库中找到：[https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.9/R/CustomerLifetimeValue.R](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.9/R/CustomerLifetimeValue.R)
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned what CLV is and its importance and usage in
    marketing. Particularly for justifying the cost of customer acquisition, it is
    crucial to have a good understanding of how much value each new customer is going
    to bring to the company. We discussed how CLV calculations can help marketers
    to develop positive ROI marketing strategies. Then, we went through a hypothetical
    example to show how we can calculate the CLV, using average purchase amount, purchase
    frequency, and customer lifetime span. We also mentioned another approach of using
    machine learning and predictive models to estimate the CLV.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了什么是CLV（客户生命周期价值），以及它在营销中的重要性和应用。特别是在验证客户获取成本时，了解每个新客户将为公司带来多少价值至关重要。我们讨论了CLV计算如何帮助营销人员制定正向投资回报率（ROI）的营销策略。接着，我们通过一个假设的例子展示了如何计算CLV，使用了平均购买金额、购买频率和客户生命周期。我们还提到了另一种方法，即使用机器学习和预测模型来估算CLV。
- en: During the programming exercises, we have learned how to build regression models
    that predict the CLV over the course of a 3 month period. In Python, we used the `scikit-learn`
    package to build a `LinearRegression` model. In R, we used the built-in `lm` function to
    train a linear regression model with our data. For regression model evaluations,
    we have discussed four commonly used measures, MSE, MAE, R², and predicted versus
    actual scatter plot, and what each of these metrics measures and tells us about
    the performance of regression models. In our programming exercises, we discussed
    how to compute and visualize MAE, R², and predicted versus actual scatter plot
    in Python and R.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程练习中，我们学习了如何构建回归模型来预测3个月期间的客户终身价值（CLV）。在Python中，我们使用了`scikit-learn`包来构建`LinearRegression`模型。在R中，我们使用了内置的`lm`函数，利用我们的数据训练线性回归模型。在回归模型评估中，我们讨论了四个常用的指标：MSE、MAE、R²和预测值与实际值的散点图，并解释了这些指标分别衡量了什么，以及它们告诉我们回归模型的表现。在我们的编程练习中，我们讨论了如何在Python和R中计算和可视化MAE、R²，以及预测值与实际值的散点图。
- en: In the following chapter, we are going to cover customer segmentation. We will
    discuss how segmenting the customer base can help marketers better understand
    their customers and come up with more efficient marketing strategies.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论客户细分。我们将探讨如何通过细分客户群体，帮助营销人员更好地了解他们的客户，并制定更加高效的营销策略。
