- en: Communicating Sales with Visualizations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可视化进行销售沟通
- en: In this chapter, we will explore a very important and useful aspect of data
    analysis, data visualization. We will show how to create graph functions, which
    are the functions that encapsulate the process of creating a graph and output
    a graph object that can be seen or saved to disk. Working with graphs this way
    increases efficiency, adds flexibility, and provides repeatable processes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨数据分析的一个重要且实用的方面，即数据可视化。我们将展示如何创建图函数，这些函数封装了创建图形的过程，并输出一个可以查看或保存到磁盘的图形对象。以这种方式处理图形可以提高效率，增加灵活性，并提供可重复的过程。
- en: The types of graphs we will create during this chapter include bar graphs, boxplots,
    scatter plots with marginal distributions, radar graphs, 3D interactive scatter
    plots, time-series graphs, static and interactive maps, and a cool globe visualization.
    The chapter will show the fundamentals you need to create a great variety of high-quality
    graphs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将创建的图形类型包括条形图、箱线图、带有边缘分布的散点图、雷达图、3D交互式散点图、时间序列图、静态和交互式地图，以及一个酷炫的地球可视化。本章将展示您需要创建各种高质量图形的基础知识。
- en: 'Some of the important topics covered in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的一些重要主题如下：
- en: Working efficiently with graph functions and graph objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效使用图函数和图对象
- en: Working with important graphing packages such as `ggplot2` and `leaflet`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用重要的绘图包，如 `ggplot2` 和 `leaflet`
- en: Data transformations to accommodate different visualizations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据转换以适应不同的可视化
- en: Graph generalization through variable parameterization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过变量参数化进行图形泛化
- en: Increasing dimensions shown with colors and shapes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用颜色和形状增加显示的维度
- en: Extending `ggplot2` with custom graph types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义图形类型扩展 `ggplot2`
- en: Numerical data exploration with interactive graphs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用交互式图形进行数值数据探索
- en: Geographical data exploration with interactive maps
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用交互式地图进行地理数据探索
- en: Required packages
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必需包
- en: 'During this chapter we will make use of the following R packages. If you don''t
    already have them installed, you can look into [Appendix](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730)*,
    Required Packages *for instructions on how do so. These packages will fall in
    one of two categories: packages for creating graphs and packages for working with
    data. Some of the packages used for interactive graphs (graphs that are not static,
    meaning you can *move them around* in your screen to see different angles of the
    data) will require system dependencies to work (for example, `rgl` and `rgdal`),
    and others will work through your web browser (for example, `threejs`, `leaflet`,
    and `plotly`). They have been tested using Google Chrome as a web browser. If
    you encounter any problems with your particular web browser, try using Google
    Chrome. The *static* graphics will be created using `ggplot2` and some packages
    that extend it (for example, `viridis` and `ggExtra`).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下 R 包。如果您尚未安装它们，可以查阅[附录](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730)*，*必需包*，了解如何安装。这些包将分为两类：用于创建图形的包和用于处理数据的包。一些用于交互式图形（非静态图形，意味着您可以在屏幕上*移动它们*以查看数据的不同角度）的包将需要系统依赖项才能工作（例如，`rgl`
    和 `rgdal`），而其他包将通过您的网络浏览器工作（例如，`threejs`、`leaflet` 和 `plotly`）。它们已使用 Google Chrome
    作为网络浏览器进行测试。如果您遇到特定网络浏览器的任何问题，请尝试使用 Google Chrome。*静态*图形将使用 `ggplot2` 和一些扩展它的包（例如，`viridis`
    和 `ggExtra`）创建。
- en: '| **Package** | **Reason** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **包** | **原因** |'
- en: '| `ggplot2` |  High-quality graphs |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `ggplot2` |  高质量图形 |'
- en: '| `viridis`  | Color palette for graphs |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `viridis`  | 图形颜色调色板 |'
- en: '| `ggExtra` | Graphs with marginal distributions |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `ggExtra` | 带边缘分布的图形 |'
- en: '| `threejs`  | Interactive globe |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `threejs`  | 交互式地球仪 |'
- en: '| `leaflet`  | Interactive high-quality maps |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `leaflet`  | 交互式高质量地图 |'
- en: '| `plotly`  | Interactive high-quality graphs |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `plotly`  | 交互式高质量图形 |'
- en: '| `rgl`  | Interactive 3D graphs |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `rgl`  | 交互式 3D 图形 |'
- en: '| `rgdal`  | Manipulating geographic data |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `rgdal`  | 地理数据操作 |'
- en: '| `tidyr`  | Manipulating data |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `tidyr`  | 数据操作 |'
- en: Extending our data with profit metrics
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用盈利指标扩展我们的数据
- en: As mentioned earlier, our objective for this chapter is to diagnose the current
    state of business and find new opportunities. To start with, we will look at three
    business metrics from different angles. The metrics are number of sales, profits,
    and profit ratios. They tell us how much The Food Factory is selling in quantity,
    how much it's earning in money (profit), and where it's growth opportunities are
    (profit ratio). Keep in mind that this is not a professional financial assessment
    and, as always, the focus is on the programming techniques not the actual results
    from the analysis.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们本章的目标是诊断当前的商业状况并寻找新的机会。首先，我们将从不同的角度查看三个业务指标。这些指标是销售数量、利润和利润率。它们告诉我们食品工厂在数量上卖出了多少，它赚了多少钱（利润），以及它的增长机会在哪里（利润率）。请记住，这并不是一个专业的财务评估，而且，一如既往，重点是编程技术而不是分析的实际结果。
- en: 'The first thing we need to do is add to each sale its corresponding profits
    and profit ratio. We assume that the only way we can count a profit is if the
    sale order has been delivered and has been paid. Otherwise, we''ll state the profit
    and profit ratio as zero. If the sale qualifies for a profit, then the profit
    calculation is *PROFIT = PRICE - COST - DISCOUNT*. Note that this allows for sales
    that are not profitable (The Food Factory loses money) if the *COST + DISCOUNT
    > PRICE*. If there''s a profit, then the profit ratio is *PROFIT / COST*. What
    we just described is programmed inside the `add_profits()` function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为每一笔销售添加其相应的利润和利润率。我们假设我们唯一能够计算利润的方式是如果销售订单已经交付并且已经付款。否则，我们将利润和利润率设为零。如果销售符合利润条件，那么利润的计算公式是*利润
    = 价格 - 成本 - 折扣*。请注意，这允许销售不盈利（食品工厂亏损）的情况发生，如果*成本 + 折扣 > 价格*。如果有利润，那么利润率是*利润 / 成本*。我们刚才描述的内容是在`add_profits()`函数中编程实现的：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After defining the `add_profit()` function, we simply apply it to our sales
    data as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`add_profit()`函数之后，我们只需将其应用到我们的销售数据上，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Building blocks for reusable high-quality graphs
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重用高质量图表的构建块
- en: To diagnose the business state and find new opportunities, in this chapter,
    we will use various types of graphs. When it comes to developing static high-quality
    graphs, you can't go wrong with the `ggplot2` package. Standard (built-in) graphs
    in R are fine for exploratory purposes, but are not as flexible or nice-looking
    as `ggplot2` graphs. Since we want to show how to create high-quality graphs,
    we will focus on using this package (and others extending it) for static graphs.
    However, since the vanilla `ggplot2` package only works for static graphs, we
    will use other packages for high-quality interactive graphs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了诊断商业状况和寻找新的机会，在本章中，我们将使用各种类型的图表。当涉及到开发静态高质量图表时，使用`ggplot2`包是不会出错的。R中的标准（内置）图表对于探索性目的来说很好，但与`ggplot2`图表相比，它们不够灵活或美观。由于我们想展示如何创建高质量图表，我们将专注于使用这个包（以及扩展它的其他包）来创建静态图表。然而，由于纯`ggplot2`包仅适用于静态图表，我们将使用其他包来创建高质量交互式图表。
- en: 'A downside of having so much flexibility when using `ggplot2` is that it''s
    very verbose, thus requiring a lot of code to create graphs (specially when compared
    to standard R built-in graphing functions). We want to avoid having to copy-paste
    code if we are going to create similar graphs, so we will develop reusable functions
    that we can use to easily create similar graphs. For example, we could do something
    like the following instead of repeating more than 10 lines of `ggplot2` code to
    only make a few small changes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`ggplot2`时，拥有如此多的灵活性有一个缺点，那就是它非常冗长，因此需要大量的代码来创建图表（尤其是与标准R内置的绘图函数相比）。如果我们打算创建类似的图表，我们希望避免复制粘贴代码，因此我们将开发可重用的函数，我们可以使用这些函数轻松地创建类似的图表。例如，我们可以做如下操作，而不是重复超过10行的`ggplot2`代码来仅进行一些小的修改：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sometimes, people are not comfortable working this way, but these graphing
    functions are just the same as any other kind of function. The only difference
    is that, whenever we can, we will return a graph object instead of other data
    types. These graph objects are a nice feature when working with `ggplot2` because
    they can''t be passed to other functions (not all graphing packages are designed
    this way). For example, while writing this book, we used the following `save_png()` function,
    which takes a graph object and saves it to disk. All we needed it to do was to
    optionally change a graph''s dimensions when we saved it to make sure that it''s
    the right size:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，人们可能不习惯以这种方式工作，但这些绘图函数与其他任何类型的函数一样。唯一的区别是，只要可能，我们将返回一个图表对象而不是其他数据类型。这些图表对象在处理`ggplot2`时是一个很好的特性，因为它们不能传递给其他函数（并非所有绘图包都是这样设计的）。例如，在编写这本书时，我们使用了以下`save_png()`函数，它接受一个图表对象并将其保存到磁盘。我们只需要在保存时可选地更改图表的尺寸，以确保它是正确的尺寸：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you're working with lots of graphs, if you get an error while creating one
    of them and you print it, you may be confused to see a previous graph you were
    working on. To avoid this confusion, you may execute `graph <- NULL` after every
    print or save function call to make sure that it's evident where the error occurred.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在处理大量图表，如果在创建其中一个图表时遇到错误并打印它，您可能会看到您之前正在工作的一个图表而感到困惑。为了避免这种困惑，您可以在每次打印或保存函数调用后执行`graph
    <- NULL`，以确保可以明显地看到错误发生的位置。
- en: 'Now if you want to create a graph and save it into a 1024x768 pixels image,
    you can use the `save_png()` function as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您想创建一个图表并将其保存为1024x768像素的图像，您可以使用以下`save_png()`函数：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The standard way of developing analyzing data is an iterative process closely
    related to the scientific method. However, we will only focus on the code that
    generates the graphs during this chapter. We will interpret the results in [Chapter
    7](part0147.html#4C62M0-f494c932c729429fb734ce52cafce730), *Developing Automatic
    Presentations*. We think this helps focus on each topic adequately in it's corresponding
    chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 开发分析数据的标准方式是一个与科学方法密切相关的迭代过程。然而，在本章中，我们只会关注生成图表的代码。我们将在[第7章](part0147.html#4C62M0-f494c932c729429fb734ce52cafce730)“开发自动演示”中解释结果。我们认为这有助于在相应的章节中充分关注每个主题。
- en: Starting with simple applications for bar graphs
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从简单的条形图应用开始
- en: We will start with simple graphs and build our way up towards advanced graphs.
    The first graph we will create is a bar graph. We will plot a frequency table
    that shows how many sale orders we have for each `QUANTITY` number in our sales.
    To do so, we use the `ggplot()` function using `sales` as the data and setting
    up the aesthetics with the `aes()` function with `QUANTITY` in the *x* axis (the
    first argument).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的图表开始，逐步构建到高级图表。我们将创建的第一个图表是条形图。我们将绘制一个频率表，显示我们销售中每个`QUANTITY`数字的销售订单数量。为此，我们使用`ggplot()`函数，将`sales`作为数据，并使用`aes()`函数设置美学，其中`QUANTITY`位于*x*轴（第一个参数）。
- en: After we create a graph base with the `ggplot()` function, we add layers for
    different objects we want to see in the graph (for example, bars, lines, and points).
    In this case, we add bars with the `geom_bar()` function. Note how this layer
    is added using the `+` (plus) sign to the graph base. After that, we add another
    layer for the title with `ggtitle()`. Finally, we add an *x* axis specification
    with the `scale_x_continuous()` function that will allow us to see a number for
    each bar in the graph. If you don't add this layer, your graph may not show a
    number for each bar, which may be a little confusing. The way we specify it is
    by sending a sequence of numbers that should be used as the breaks (where tick
    data is shown). Since the numbers in the data may vary with different simulations,
    we make sure that we use the correct numbers by creating a sequence with the `seq()` function
    from the minimum number in the `QUANTITY` variable to the maximum. This will automatically
    show the correct numbers even if the `QUANTITY` variable has vastly different
    ranges.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`ggplot()`函数创建图基础之后，我们为想要在图中显示的不同对象添加层（例如，条形、线条和点）。在这种情况下，我们使用`geom_bar()`函数添加条形。注意这个层是如何通过在图基础中使用`+`（加号）符号来添加的。之后，我们使用`ggtitle()`函数添加另一个标题层。最后，我们使用`scale_x_continuous()`函数添加一个*x*轴指定，这将允许我们看到图中每个条形的数字。如果你不添加这个层，你的图表可能不会显示每个条形的数字，这可能会有些令人困惑。我们指定它的方式是通过发送一个数字序列，这些数字应作为断点（显示刻度数据的位置）。由于数据中的数字可能因不同的模拟而变化，我们通过使用`seq()`函数从`QUANTITY`变量的最小值到最大值创建一个序列来确保我们使用正确的数字。这将自动显示正确的数字，即使`QUANTITY`变量的范围差异很大。
- en: 'These may seem like a lot of code to build a simple graph. However, it''s precisely
    the amount of code that allows us to be very specific about what we want to see
    in the graph as you''ll see in the following examples. Also, note that only the
    `ggplot()` (with its corresponding `aes()` function) and `geom_bar()` functions
    are required to actually produce the graph. The `ggtitle()` and `scale_x_continuous()` functions
    are only there to improve the graph:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码看起来可能很多，但构建一个简单的图表。然而，这正是允许我们非常具体地了解我们想要在图中看到的内容的代码量，正如你将在下面的示例中看到的那样。此外，请注意，实际上产生图表所需的只有`ggplot()`（及其相应的`aes()`函数）和`geom_bar()`函数。`ggtitle()`和`scale_x_continuous()`函数只是为了改进图表：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following graph shows the **QUANTITY frequency** for the preceding code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了前面代码的**QUANTITY频率**：
- en: '![](img/00031.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: QUANTITY Frequency
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: QUANTITY 频率
- en: Since we will be creating lots of bar graphs, we want to avoid having to copy-paste
    the code we just wrote, and not only that, but also make it more flexible. To
    accomplish this, we will generalize our code by parameterizing it and considering
    different scenarios we should cover.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将创建大量的条形图，我们希望避免复制粘贴我们刚刚编写的代码，不仅如此，我们还希望使其更加灵活。为了实现这一点，我们将通过参数化我们的代码并考虑我们应该覆盖的不同场景来泛化我们的代码。
- en: So, what may we want our custom `graph_bars()` function to allow us to do? To
    start with, we may want to specify different variables for our *x* axis and *y*
    axis. To do this, we need to understand how the `geom_bar()` function works internally.
    If you look back at the code, we never specified the variable for the *y* axis,
    and `ggplot()` automatically used the number of times a `QUANTITY` number appeared
    in the data (the frequency).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们可能希望我们的自定义`graph_bars()`函数允许我们做什么呢？首先，我们可能希望为我们的*x*轴和*y*轴指定不同的变量。为此，我们需要了解`geom_bar()`函数的内部工作方式。如果你回顾一下代码，我们从未指定*y*轴的变量，`ggplot()`自动使用了`QUANTITY`数字在数据中出现的次数（频率）。
- en: What if we want to use the `PROFIT` value for each sale as the variable for
    the *y* axis? In that case, we need to realize that we have more than 2,000 potentially
    different values as `PROFIT` when `QUANTITY` is two or three, and less so in the
    other cases. We need to aggregate those `PROFIT` values somehow before we can
    use `PROFIT` in the *y* axis.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用每次销售的`PROFIT`值作为*y*轴的变量呢？在这种情况下，我们需要意识到，当`QUANTITY`为二或三时，我们可能有超过2,000个不同的`PROFIT`值，而在其他情况下则较少。在我们能够在*y*轴中使用`PROFIT`之前，我们需要以某种方式对这些`PROFIT`值进行聚合。
- en: Any function that can reduce the `PROFIT` values into a single value for all
    the transactions, for each value of `QUANTITY`, could be used to aggregate the
    data. However, the most common choices are using the mean or the sum. The mean
    would show a graph where we see the average `PROFIT` for each `QUANTITY` value.
    The sum would show us the total `PROFIT` for each `QUANTITY` value. The same would
    apply if we want to use `PROFIT_RATIO` (or any other numerical variable) in the
    *y* axis. The most intuitive choices are using sum for `PROFIT` (total profit)
    and mean for `PROFIT_RATIO` (average profit ratio), so we will use those.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以将`PROFIT`值减少为所有交易的单个值的函数，对于每个`QUANTITY`值，都可以用来聚合数据。然而，最常见的选择是使用平均值或总和。平均值将显示一个图表，我们可以看到每个`QUANTITY`值的平均`PROFIT`。总和将显示每个`QUANTITY`值的总`PROFIT`。如果我们想在*y*轴上使用`PROFIT_RATIO`（或任何其他数值变量），这也适用。最直观的选择是对于`PROFIT`（总利润）使用总和，对于`PROFIT_RATIO`（平均利润比率）使用平均值，因此我们将使用这些。
- en: For the *x* axis, we may have categorical, numerical, or date variables. For
    this particular case, the default *x* axis options are fine for categorical and
    date variables, but we still want to see all the numbers in the ticks when working
    with numerical variables. This means that we need to provide a check for the type
    of variable in the *x* axis, and if it's numerical, then we need to do the proper
    adjustment (the same adjustment we saw in the previous code).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*x*轴，我们可能拥有分类、数值或日期变量。对于这个特定的情况，默认的*x*轴选项对于分类和日期变量来说是合适的，但当我们处理数值变量时，我们仍然希望看到所有数字在刻度上。这意味着我们需要在*x*轴上提供对变量类型的检查，如果它是数值型，那么我们需要进行适当的调整（与之前代码中看到的相同调整）。
- en: 'What we have explained before is what is programmed in our `graph_bars()` function.
    It receives as parameters the data and the *x* axis and *y* axis variables. First,
    it checks whether or not we specified a particular *y* axis variable. We use the
    "NULL check" technique mentioned in [Chapter 1](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730),
    *Introduction to R*. If we don''t receive a *y* axis variable, then we create
    a bar graph as we did earlier (using the frequency of the *x* axis variable by
    default), and we create the corresponding title using the `paste()` function.
    If we do get a variable for the *y* axis (meaning that we are in the `else` block),
    then we need to find out what type of aggregation we need to do, and we do so
    using our `get_aggregation()` function, which returns the sum as the aggregation
    method if we are asked to graph the `PROFIT` variable in the *y* axis, and returns
    the mean in any other case. We then use this function name as the value for the
    `fun.y` parameter (which is read as *function* *for* `y`), and specify that we
    are working with a summary function (when you don''t need aggregation for a variable
    you should send the `stat = ''identity''` parameter to the `geom_bar()` function
    and avoid sending it to the `fun.y` parameter). Then we specify the title of the
    graph as needed. After the `if else` block, we check if the variable type for
    the *x* axis is numeric, and if it is we apply the interval names transformation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前所解释的内容就是我们在`graph_bars()`函数中编程的内容。该函数接收数据和*x*轴以及*y*轴变量作为参数。首先，它会检查我们是否指定了特定的*y*轴变量。我们使用[第1章](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730)中提到的“NULL检查”技术，即《R语言入门》。如果我们没有接收到*y*轴变量，那么我们将创建一个条形图，就像我们之前做的那样（默认使用*x*轴变量的频率），并且使用`paste()`函数创建相应的标题。如果我们确实得到了*y*轴的变量（意味着我们处于`else`块中），那么我们需要找出我们需要进行哪种类型的聚合，我们通过使用我们的`get_aggregation()`函数来完成，如果要求我们在*y*轴上绘制`PROFIT`变量，该函数将返回求和作为聚合方法，而在任何其他情况下返回平均值。然后我们使用这个函数名作为`fun.y`参数的值（它被读作*y*的*函数*），并指定我们正在使用一个汇总函数（当你不需要对变量进行聚合时，你应该将`stat
    = 'identity'`参数发送到`geom_bar()`函数，并避免将其发送到`fun.y`参数）。然后我们根据需要指定图表的标题。在`if else`块之后，我们检查*x*轴的变量类型是否为数值型，如果是，我们应用区间名称转换：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When working with this special-case function, we recommend that you put the
    special case in the `if` part of the check to make sure that you only catch the
    special cases we''re looking for, and return the generic case otherwise. If you
    do this the other way around (checking for generic cases first) you''ll undoubtedly
    encounter some tricky bugs:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这个特殊情况的函数时，我们建议你将特殊情况放在检查的`if`部分，以确保你只捕获我们正在寻找的特殊情况，否则返回通用情况。如果你反过来这样做（首先检查通用情况），你无疑会遇到一些棘手的错误：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can create many more bar graphs with our custom `graph_bars()` function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们的自定义`graph_bars()`函数创建更多的条形图：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All of the following graphs are shown together for easier visualization and
    space preservation, but you would get them one-by-one when executing the code
    yourself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的以下图表都一起显示，以便更容易可视化并节省空间，但您在执行代码时将逐个获得它们。
- en: '![](img/00032.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00032.jpeg)'
- en: Bar graphs
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 条形图
- en: Adding a third dimension with colors
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用颜色添加第三个维度
- en: As often happens, we want to work on some code we had already created to add
    more features. In this case, we want to add a third dimension to the graphs using
    colors. We want to be able to specify a `color` variable that will be used to
    further divide the data in the graph.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如常发生的情况，我们想要在已经创建的代码上添加更多功能。在这种情况下，我们想要使用颜色为图表添加第三个维度。我们希望能够指定一个 `color` 变量，该变量将用于进一步划分图表中的数据。
- en: To accomplish this, we add a `color` parameter to the function's signature using
    the "NULL check" pattern and we add the corresponding parameter in each case.
    Adding the parameter directly in the `aes_string()` function is not problematic
    in case of `NULL` because `NULL` values indicate to `ggplot()` we don't want to
    use a fill color for the graph.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们使用“空值检查”模式在函数签名中添加一个 `color` 参数，并在每个情况中添加相应的参数。在 `aes_string()` 函数中直接添加参数在
    `NULL` 的情况下没有问题，因为 `NULL` 值表示我们不想为图表使用填充颜色。
- en: 'However, note that we are not able to use the same technique with `y` . Instead,
    we check whether we should send `y` or not, and only send it to the `ggplot()` function
    if we have a non-`NULL` value. Also, we add the `position = "dodge"` parameter
    to the `geom_bar()` function so that we get unstacked bar graphs. If we don''t
    send this parameter we would get stacked bar graphs, and for these particular
    graphs, we thought the unstacked version looked better. Feel free to try the stacked
    version yourself. Let''s look at the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，我们无法使用相同的技巧与 `y` 一起使用。相反，我们检查是否应该发送 `y` 或不发送，并且只有当有非 `NULL` 值时才将其发送到
    `ggplot()` 函数。我们还向 `geom_bar()` 函数添加了 `position = "dodge"` 参数，以便得到非堆叠条形图。如果我们不发送此参数，我们会得到堆叠条形图，对于这些特定的图表，我们认为非堆叠版本看起来更好。您可以自由尝试堆叠版本。让我们看看以下代码：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that now we have four different cases we may want to graph, first, when
    specify only the `x` value, second, when we specify the `x` and `y` values, third,
    when we specify the `x` and `color` values, fourth, when we specify all three
    of them. Since the `ggplot()` specification for each of those cases is unique,
    we can't collapse them into a lower number of cases. You should also note that
    we only keep inside the conditional blocks the code that is specific for a particular
    check, and bring out of the conditional block the code that is not specific to
    the check and should be applied to two cases every time. That's what we do with
    the `ylab()` and `geom_bar()` functions in the outer `if` block and with the `get_aggregation()` and
    `geom_bar()` functions in the outer `else` block. Otherwise, we would be repeating
    code unnecessarily, which is a very bad practice.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在我们有四种可能想要绘制的不同情况，首先，当只指定 `x` 值时，其次，当我们指定 `x` 和 `y` 值时，第三，当我们指定 `x` 和 `color`
    值时，第四，当我们指定所有三个值时。由于每个情况的 `ggplot()` 规范都是唯一的，我们不能将它们合并成更少的案例。您还应该注意，我们只在条件块中保留特定检查的特定代码，并将不特定于检查且每次应应用于两个情况的代码移出条件块。这就是我们在外层
    `if` 块中使用 `ylab()` 和 `geom_bar()` 函数，在外层 `else` 块中使用 `get_aggregation()` 和 `geom_bar()`
    函数所做的事情。否则，我们会不必要地重复代码，这是一种非常不好的做法。
- en: '![](img/00033.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00033.jpeg)'
- en: Bar graphs with colors
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 带颜色的条形图
- en: 'Now we can produce bar graphs that optionally receive a third parameter `color` (shown
    above), and if sent, it will be used to divide the data using colors. Note that
    in the first line of the following code, we need to explicitly send the `color` parameter.
    This is because we''re omitting the `y` parameter from the function call, and
    if we are not explicit about the `color` parameter, it will be interpreted as
    being the `x` parameter. You can take a refresher on function calls in [Chapter
    1](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730), *Introduction to R*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以生成可选接收第三个参数 `color`（如上图所示）的条形图，如果发送了该参数，它将用于使用颜色划分数据。请注意，在以下代码的第一行中，我们需要显式发送
    `color` 参数。这是因为我们在函数调用中省略了 `y` 参数，如果我们对 `color` 参数不明确，它将被解释为 `x` 参数。您可以在 [第1章](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730)，*R语言入门*
    中复习函数调用：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Graphing top performers with bar graphs
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用条形图绘制顶尖表现者
- en: Bar graphs are one of the most used graphing tools in the world and this chapter
    is no exception. In our last bar graph example, we will show how to graph the
    top performers for a given variable in the decreasing order. Our objective is
    to graph either `PROFIT` or `Frequency` in the *y* axis and a parameterized variable
    for the *x* axis. We want to show the top `n` performers for the `x` variable
    in a decreasing order from left to right, as is shown in the graph below.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 条形图是世界上使用最广泛的绘图工具之一，本章也不例外。在我们最后的条形图示例中，我们将展示如何按降序排列给定变量的表现最好的几个。我们的目标是绘制`y`轴上的`PROFIT`或`Frequency`，以及`x`轴上的参数化变量。我们希望从左到右按降序显示`x`变量的前`n`个表现最好的，如下面的图表所示。
- en: '![](img/00034.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00034.jpeg)'
- en: Top n bar graphs
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前`n`个条形图
- en: To accomplish this, we receive as parameters the data (`sales` in this case),
    the variable that will be used for the *x* axis `x`, the number of top performers
    we want to show `n`, and whether we want to use `PROFIT` in the *y* axis or not
    (in which case we will use the `Frequency`) by using the Boolean `by_profit`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们接收数据（在这种情况下是`sales`）、用于`x`轴的变量`x`、我们想要显示的表现最好的数量`n`，以及我们是否想在`y`轴上使用`PROFIT`（在这种情况下我们将使用`Frequency`），通过使用布尔值`by_profit`。
- en: The first thing we do is check for the `by_profit` parameter; if it's `TRUE`,
    then we aggregate the `PROFIT` data for each `CLIENT_ID` with the `aggregate()` function
    using the `sum` operator (we want the total profit by client, not the average
    profit by client). Then we order the results with the `order()` function. The
    minus sign (`-`) just before the `profit_by_client$x` value means that we want
    a decreasing order, and the `x` that follows `profit_by_client` is because the
    result of the `aggregate()` function is a data frame with `Group.1` and `x` columns,
    which store the `CLIENT_ID` and the `PROFIT` sum, respectively.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查`by_profit`参数；如果它是`TRUE`，那么我们使用`aggregate()`函数和`sum`运算符对每个`CLIENT_ID`的`PROFIT`数据进行聚合（我们想要的是按客户计算的总利润，而不是按客户计算的平均利润）。然后我们使用`order()`函数对结果进行排序。在`profit_by_client$x`值之前的一横线（`-`）表示我们想要降序排列，而跟在`profit_by_client`之后的`x`是因为`aggregate()`函数的结果是一个包含`Group.1`和`x`列的数据框，分别存储`CLIENT_ID`和`PROFIT`的总和。
- en: Since we want to avoid unnecessary duplication of the code when we return the
    graph we want, we need to make sure that both cases in the `if else` block use
    the same names for the variables we will use in the `ggplot()` function. That's
    why we explicitly assign the `x` and `y_bar` names to the `top_df` data frame.
    If you looked inside the `top_df` object during execution, you would find that
    it has duplicated data with different column names. We could take care of this
    by removing the columns with the names we don't want, but it's unnecessary at
    this point since it's a throwaway object anyway. However, in certain situations
    this may be a performance issue we need to deal with, but not in this case.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在返回我们想要的图时避免代码的不必要重复，我们需要确保`if else`块中的两种情况都使用我们在`ggplot()`函数中将使用的相同变量名。这就是为什么我们明确地将`x`和`y_bar`名称分配给`top_df`数据框。如果你在执行过程中查看`top_df`对象，你会发现在不同的列名下有重复的数据。我们可以通过删除我们不想要的列来解决这个问题，但在这个点上这是不必要的，因为这个对象无论如何都是一次性使用的。然而，在某些情况下，这可能会成为一个我们需要处理的性能问题，但在这个例子中不是。
- en: In the case of the `else` block, conceptually we do the same thing. However,
    technically we implement differently. In this case, we create a table where each
    entry in the table is a unique `CLIENT_ID` value and the value for each entry
    is the number of times the `CLIENT_ID` appears in the data (`Frequency`), and
    we do so with the `table()` function. Then we sort these results in the decreasing
    order with the `sort()` function and take the top `n` results. Then we use these
    results to create the `top_df` data frame with the corresponding columns. Note
    that we need an auxiliary name `aux_name` for the `x` variable since we can't
    create a data frame by specifying a column name with a variable. What we do is
    then copy the data from the `aux_name` column to the actual name we need (contained
    in the `x` variable).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`else`块的情况下，从概念上讲，我们做的是同样的事情。然而，在技术上我们实现的方式不同。在这种情况下，我们创建一个表，其中表中的每个条目都是一个唯一的`CLIENT_ID`值，每个条目的值是该`CLIENT_ID`在数据中出现的次数（`Frequency`），我们使用`table()`函数来完成这个操作。然后我们使用`sort()`函数按降序对这些结果进行排序，并取前`n`个结果。然后我们使用这些结果创建一个包含相应列的`top_df`数据框。请注意，我们需要一个辅助名称`aux_name`来为`x`变量命名，因为我们不能通过指定变量名来创建数据框。我们接下来要做的是将`aux_name`列中的数据复制到我们实际需要的名称中（包含在`x`变量中）。
- en: Finally, we create a graph and immediately return it without intermediate storage.
    The specifics on what each line is doing in that part of the code should be clear
    to you by this point, so we will avoid explaining that again.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个图表并立即返回，而不进行中间存储。到这一点，你应该已经清楚代码中每一行在该部分的作用，所以我们不会再次解释。
- en: 'Now you create *top n* graphs easily with the following code. We suggest that
    you try to create similar graphs for other categorical variables (for example,
    `CONTINENT` or `PROTEIN_SOURCE`). Note that the `CLIENT_ID` values in each case
    are different, meaning that the clients that buy the most from The Food Factory
    are not necessarily the clients that generate the most profit for it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用以下代码轻松创建*top n*图表。我们建议你尝试为其他分类变量（例如，`CONTINENT`或`PROTEIN_SOURCE`）创建类似的图表。请注意，每种情况下的`CLIENT_ID`值都不同，这意味着从食品工厂购买最多产品的客户不一定是为其创造最多利润的客户：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We wanted to start simple and show the basic concepts of working with graph
    functions before we complicate things in the following sections.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在接下来的章节中使事情复杂化之前，先从简单开始，展示使用图形函数的基本概念。
- en: Graphing disaggregated data with boxplots
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用箱线图绘制分解数据
- en: Creating bar graphs is useful when presenting results to people who are not
    familiar with statistics, but the fact that bar graphs aggregate information (just
    as we did in the bar graphs for top performers) means that, in reality, we lose
    information due to the reduction. If you're working with people who understand
    what quartiles are, then boxplots may be a useful visualization. They are an easy
    way to see individual distributions for different levels of a variable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建条形图在向不熟悉统计学的观众展示结果时很有用，但条形图汇总信息的事实（就像我们在表现最佳者条形图中做的那样）意味着实际上，由于汇总，我们失去了信息。如果你与理解四分位数是什么的人一起工作，那么箱线图可能是一种有用的可视化方式。它们是查看不同变量水平上个体分布的简单方法。
- en: Each box represents the first quartile at the bottom, the third quartile at
    the top, and the median on the line in the middle. The lines that extend vertically
    reach up to any observation within *1.5 * IQR*, where the **interquartile range**
    (**IQR**) is the distance between the first and third quartiles. Any observation
    beyond *1.5 * IQR* is treated as an outlier and is shown individually.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个箱子代表底部的第一四分位数，顶部的第三四分位数，以及中间线上的中位数。垂直延伸的线延伸到任何在*1.5 * IQR*范围内的观测值，其中**四分位距**（**IQR**）是第一四分位数和第三四分位数之间的距离。任何超过*1.5
    * IQR*的观测值被视为异常值，并单独显示。
- en: Our objective is to show the bar graph we created for top performers according
    to `PROFIT`, but in a disaggregated way. When using bar graphs, the difficulty
    comes from aggregating the data correctly, but since we don't need to aggregate
    data for boxplots, their creation is very simple.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是以分解的方式展示我们根据`PROFIT`创建的针对表现最佳者的条形图。当使用条形图时，困难在于正确汇总数据，但由于我们不需要为箱线图汇总数据，它们的创建非常简单。
- en: 'Our `graph_top_n_boxplots()` function takes as parameters the `data` value,
    the variables for the *x* and *y* axis, the number of top performers to show as
    `n`, and optionally the line and fill colors, as `c` and `f`, respectively. If
    no colors are specified, a selection of blues is used. The color specification
    must be done either in a HEX notation ([https://en.wikipedia.org/wiki/Web_colors#Hex_triplet](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet))
    or with R color names ([http://sape.inf.usi.ch/quick-reference/ggplot2/colour](http://sape.inf.usi.ch/quick-reference/ggplot2/colour)).
    We simply filter the data with our `filter_n_top()` function and use the `boxplot()` layer
    to produce the boxplots with the adequate colors. We also specify the title as
    the combination of the parameters received by the function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`graph_top_n_boxplots()`函数接受`data`值、x轴和y轴的变量、要显示的顶级表现者的数量`n`作为参数，以及可选的线条和填充颜色，分别用`c`和`f`表示。如果没有指定颜色，则使用一系列蓝色。颜色指定必须使用十六进制表示法（[https://en.wikipedia.org/wiki/Web_colors#Hex_triplet](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet)）或R颜色名称（[http://sape.inf.usi.ch/quick-reference/ggplot2/colour](http://sape.inf.usi.ch/quick-reference/ggplot2/colour)）。我们简单地使用我们的`filter_n_top()`函数过滤数据，并使用`boxplot()`层以适当的颜色生成箱线图。我们还指定标题为函数接收到的参数的组合：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `filter_n_top()` function receives as parameters the `data` value, the number
    of top performers we want to keep as `n`, and the identifier for the performers
    as `by`. First, we use the `aggregate()` function to aggregate the `PROFIT` variable
    by the chosen identifier (which is sent as a list, as is required by the function),
    and do the aggregation with the `sum` operator to get the total `PROFIT` per client.
    If we had used the `mean` operator, we would see a graph for the average `PROFIT` per
    client. Then we order the results, which are contained in the second column of
    the `aggr` object in decreasing order, and take the top `n` values from the first
    column, which contain the identifiers (the `CLIENT_ID` values in the example below).
    Finally, we keep only those observations in the data that correspond to the top
    identifiers we have in the `top` object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter_n_top()`函数接收参数为`data`值，我们想要保留的顶级表现者的数量为`n`，以及表现者的标识符为`by`。首先，我们使用`aggregate()`函数根据选择的标识符（作为列表发送，这是函数所要求的）对`PROFIT`变量进行聚合，并使用`sum`运算符进行聚合以获取每个客户的总`PROFIT`。如果我们使用了`mean`运算符，我们会看到一个每个客户的平均`PROFIT`的图形。然后我们按降序对结果进行排序，这些结果包含在`aggr`对象的第二列中，并从第一列中取出顶部`n`个值，这些值包含标识符（下面的例子中的`CLIENT_ID`值）。最后，我们只保留与`top`对象中顶级标识符对应的数据观测值。'
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we can easily replicate the bar graph we created in the previous section
    using boxplots.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松地复制上一节中创建的条形图，使用箱线图。
- en: '![](img/00035.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00035.jpeg)'
- en: Top m boxplots
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部m个箱线图
- en: 'As you can see, we have more information shown in the graph, but we loose the
    ability to easily spot the total `PROFIT` value for each `CLIENT_ID`. Choosing
    the graph type depends on what information you''re trying to communicate:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在图中显示了更多信息，但失去了轻松找到每个`CLIENT_ID`的总`PROFIT`值的可能性。选择图形类型取决于您试图传达的信息：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Scatter plots with joint and marginal distributions
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有联合和边缘分布的散点图
- en: We have seen how to create scatter plots with `ggplot()` in previous chapters.
    Therefore, in this section, we will only focus on the parts that we have not seen
    before. Our objective is to create scatter plots that not only show the scatter
    plot, but extend it by showing the marginal distributions on both axes. These
    are called **marginal plots** and are useful for understanding how data is jointly
    (two variables) as well as marginally (one variable) distributed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中已经看到了如何使用`ggplot()`创建散点图。因此，在本节中，我们将只关注我们之前没有看到的部分。我们的目标是创建不仅显示散点图，而且还通过在两个轴上显示边缘分布来扩展它。这些被称为**边缘图**，对于理解数据如何联合（两个变量）以及边缘（一个变量）分布非常有用。
- en: Pricing and profitability by protein source and continent
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按蛋白质来源和大陆定价和盈利能力
- en: 'As usual, we start developing our graph function. We receive as parameters
    the `data`, and the variables for the *x* axis (`x`) and *y* axis (`y`), and,
    in this case, we anticipate four cases that correspond to the combinations of
    including or not the `color` and `shape` variables for the graph. We do the standard
    checking and create the corresponding graph base. Here comes the different part,
    we call the `ggMarginal()` function of the `ggExtra` package with the graph object
    we want (in this case, the base graph plus the points layer), and specify the
    type of graph to be used for the marginal distributions. You can chose from `density`,
    `histogram`, and `boxplot`. We choose `histogram`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们开始开发我们的绘图函数。我们接收参数为`data`，以及用于*x*轴（`x`）和*y*轴（`y`）的变量，以及在这种情况下，我们预计四种情况，对应于包括或不包括`color`和`shape`变量组合的图形。我们进行标准的检查并创建相应的图形基础。接下来是不同的部分，我们调用`ggExtra`包中的`ggMarginal()`函数，使用我们想要的图形对象（在这种情况下，基础图形加上点层），并指定用于边缘分布的图形类型。您可以选择`density`、`histogram`和`boxplot`。我们选择`histogram`：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we are able to easily create scatter plots with marginal distributions on
    the sides. In the first graph (left), we show the relation among `PRICE`, `COST`,
    `PROTEIN_SOURCE`, and `CONTINENT`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够轻松地创建带有边缘分布的散点图。在第一个图形（左侧），我们展示了`PRICE`、`COST`、`PROTEIN_SOURCE`和`CONTINENT`之间的关系。
- en: '![](img/00036.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00036.jpeg)'
- en: Marginal distributions
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘分布
- en: Note that there are very distinguishable groups. In the second graph (right),
    we show the relation among `PRICE`, `PROFIT_RATIO`, `PROTEIN_SOURCE`, and `CONTINENT`.
    Note that we find the same relation we did in our 3D interactive scatter plots,
    the higher the `PRICE` value, the higher the `PROFIT_RATIO` value. However, there
    are two interesting findings here that we will mention in [Chapter 7](part0147.html#4C62M0-f494c932c729429fb734ce52cafce730),
    *Developing Automatic Presentations*. Can you tell what they are?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有一些非常明显的群体。在第二个图表（右侧）中，我们展示了`PRICE`、`PROFIT_RATIO`、`PROTEIN_SOURCE`和`CONTINENT`之间的关系。注意，我们发现与我们在3D交互散点图中发现的关系相同，即`PRICE`值越高，`PROFIT_RATIO`值越高。然而，这里有两个有趣的发现，我们将在[第7章](part0147.html#4C62M0-f494c932c729429fb734ce52cafce730)“开发自动演示”中提及。你能说出它们是什么吗？
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you use the `graph_marginal_distributions()` function to graph the combination
    of `COST`, `PRICE`, `STATUS`, and `PAID`, you should see no pattern emerge as
    those distributions were randomly simulated to be normally distributed in [Chapter
    4](part0091.html#2MP360-f494c932c729429fb734ce52cafce730), *Simulating Sales Data
    and Working with Databases*, and no skewing process was applied to them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`graph_marginal_distributions()`函数来绘制`COST`、`PRICE`、`STATUS`和`PAID`的组合图，你应该看不到任何模式出现，因为这些分布是在[第4章](part0091.html#2MP360-f494c932c729429fb734ce52cafce730)“模拟销售数据和与数据库协同工作”中随机模拟成正态分布的，并且没有对这些分布应用任何偏斜过程。
- en: Client birth dates, gender, and ratings
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户的出生日期、性别和评分
- en: A problem you will encounter when programming is that sometimes a function you
    thought would be general enough needs to be changed in some way. Sometimes the
    right decision is to change the existing function, but other times, the right
    decision is to create a new function (maybe based on the original one) that can
    be modified as needed without breaking old code that used it. This happens when
    the assumptions for the function are not met, and can't be easily accommodated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程过程中，你可能会遇到的一个问题是，有时你认为足够通用的函数需要以某种方式做出改变。有时，正确的决定是修改现有的函数，但其他时候，正确的决定是创建一个新的函数（可能基于原始函数），这样可以根据需要修改，而不会破坏使用它的旧代码。这种情况发生在函数的假设没有得到满足，并且无法轻易适应时。
- en: In our case, what happens if we want to use the `clients` data to graph our
    clients' birth dates using the year in the *x* axis, month in the *y* axis, color
    by gender, and show the rating adjusting the size of the dots? Well, the *x* axis
    and the *y* axis data assumptions may be fulfilled with minor data transformations,
    the color assumption is already met, but the size assumption doesn't seem to fit
    our previous model.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，如果我们想使用`clients`数据来绘制客户的出生日期图，使用*x*轴上的年份、*y*轴上的月份、按性别着色，并通过调整点的尺寸来显示评分，会发生什么？好吧，*x*轴和*y*轴的数据假设可能通过轻微的数据转换就能满足，颜色假设已经满足，但大小假设似乎不符合我们之前的模型。
- en: In our `graph_marginal_distributions()` function, we assumed that we would use
    the `shape` as the fourth variable to represent categorical variables, but it
    seems that, even though the `STARS` variable is technically a factor, it would
    be better represented using size rather than different shapes. The fact that we
    need to deal with the *x* axis, *y* axis, and size assumptions within special
    cases for the `clients` data, is reason enough to decide to create its own function
    based on the original one. If at some point we want to merge these two functions
    into a single one, we can do so, but there's no need to over complicate things
    for ourselves at this point.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`graph_marginal_distributions()`函数中，我们假设我们会使用`shape`作为第四个变量来表示分类变量，但似乎尽管`STARS`变量在技术上是一个因素，但使用大小而不是不同的形状来表示会更好。我们需要在`clients`数据的特殊情况中处理*x*轴、*y*轴和大小假设的事实，这足以决定基于原始函数创建它自己的函数。如果我们想在某个时候将这两个函数合并成一个，我们可以这样做，但在这个阶段没有必要让自己过于复杂化。
- en: In our `graph_marginal_distributions_client_birth_dates()` function, we only
    need to receive the data we will be working on (`clients` in this case). There's
    no need for other parameters because all the assumptions will be hardcoded inside
    the function in this case, because we're not looking to generalize the code. To
    make the code a little more readable, we will use short variable names to contain
    the string we will use to create the specification for the plot. That's what those
    `x`, `y`, `x_noise`, and `y_noise` variables are.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `graph_marginal_distributions_client_birth_dates()` 函数中，我们只需要接收我们将要处理的数据（在这种情况下是
    `clients`）。在这种情况下不需要其他参数，因为所有假设都将硬编码在函数内部，因为我们不打算使代码通用化。为了使代码更易于阅读，我们将使用短变量名来包含我们将用于创建图表规范的字符串。这就是那些
    `x`、`y`、`x_noise` 和 `y_noise` 变量的作用。
- en: As mentioned, we need to slightly transform the data before we are able to produce
    the plot. First, we need to disaggregate the `BIRTH_DATE` into `BD_YEAR` and `BD_MONTH` (`BD` is
    short for birth date). Then we add noise to the dates because if just kept dates
    as they are, we would get a grid of values, not a distribution, and that's because
    both the year and the month are integer values, so there would be a lot of dots
    stacked up on each other and a lot of space empty between them, we can see a mixed
    version of the data, and that's why we need to add noise to it. See below how
    both of these functions work internally.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在我们能够生成图表之前，我们需要稍微转换一下数据。首先，我们需要将 `BIRTH_DATE` 分解为 `BD_YEAR` 和 `BD_MONTH`（`BD`
    是出生日期的缩写）。然后我们向日期添加噪声，因为如果我们只是保持日期不变，我们会得到一个值网格，而不是一个分布，这是因为年份和月份都是整数值，所以会有很多点堆叠在一起，它们之间会有很多空隙。我们可以看到数据的混合版本，这就是为什么我们需要向其中添加噪声。下面我们可以看到这两个函数是如何在内部工作的。
- en: 'After we have our short names and have transformed our data, we are ready to
    create a scatter plot just as we have done before. Here''s where the distinction
    between dates with and without noise comes into play. If we used the dates with
    noise to display the tick values for the axis, we would see year labels like 1953.51,
    1973.85, 1993.23, and so on. Clearly, it''s not intuitive to display the year
    axis with such values. Similarly, for the *y* axis, we would see month values
    like 1.24, 4.09, 8.53, and so on. The same problem. That''s why we need two versions
    of the data, the one with the noise (real values) that is used to place the dots
    in the graph, and the one without the noise (integer values) that is used to show
    values in the axis. Finally, we add the axis labels and send the graph through
    the `ggMarginal()` function as we had done earlier:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了简短的名字并转换了数据之后，我们就准备好创建散点图了，就像我们之前做的那样。这里就是有噪声和无噪声日期之间的区别开始发挥作用的地方。如果我们使用带噪声的日期来显示轴的刻度值，我们会看到像
    1953.51、1973.85、1993.23 等年份标签。显然，用这样的值显示年份轴并不直观。同样，对于 *y* 轴，我们会看到像 1.24、4.09、8.53
    等月份值。同样的问题。这就是为什么我们需要两种数据版本的原因，一种是有噪声的（实值），用于在图中放置点，另一种是无噪声的（整数值），用于在轴上显示值。最后，我们添加轴标签，并将图表通过
    `ggMarginal()` 函数发送出去，就像我们之前做的那样：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Adding noise to the data is straightforward, we simply create new variables
    (`BD_YEAR_NOISE` and `BD_MONTH_NOISE`) that have the original (integer) values
    and we add a random number from the normal distribution with a mean of 0 and a
    standard deviation of 0.5\. We need a small standard deviation to make sure that
    our data is not changed too much:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 向数据中添加噪声很简单，我们只需创建新的变量（`BD_YEAR_NOISE` 和 `BD_MONTH_NOISE`），它们具有原始的（整数）值，然后我们添加一个均值为
    0、标准差为 0.5 的正态分布的随机数。我们需要一个小的标准差来确保我们的数据不会改变太多：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To disaggregate the dates, we simply create new variables (`BD_YEAR` and `BD_MONTH`)
    that contain the corresponding date value extracted using the date format specification
    that comes with R (`%Y` for year and `%m` for numeric month) converted to numbers
    (so that we can add noise to them and plot them). For more information on the
    date format specification, take a look at the *Dates and Times in R* page from
    Berkeley University ([https://www.stat.berkeley.edu/~s133/dates.html](https://www.stat.berkeley.edu/~s133/dates.html)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分解日期，我们只需创建新的变量（`BD_YEAR` 和 `BD_MONTH`），它们包含使用 R 中的日期格式说明符提取的相应日期值（`%Y` 用于年份和
    `%m` 用于数字月份），并将其转换为数字（这样我们就可以向它们添加噪声并绘制它们）。有关日期格式说明符的更多信息，请参阅加州大学伯克利分校的 *R 中的日期和时间*
    页面 ([https://www.stat.berkeley.edu/~s133/dates.html](https://www.stat.berkeley.edu/~s133/dates.html))。
- en: 'Let''s take a look at the client birth dates with the help of a graph:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助图表来看看客户的出生日期：
- en: '![](img/00037.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00037.jpeg)'
- en: Client birth dates with marginal distribution
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 客户出生日期与边缘分布
- en: 'Now we can easily create this graph anytime we want without having to worry
    about the details of how to create it with the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松地随时创建此图表，而无需担心如何创建它的细节，以下代码即可：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Developing our own graph type – radar graphs
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们自己的图表类型——雷达图
- en: This section will take our graph functions to the next level as we develop our
    own custom graph type. The `ggplot2` package does not have a way to produce radar
    graphs by default, so we will develop it ourselves during this section. There
    are packages that extend `ggplot2` with radar graph capabilities (for example,
    `ggradar`), but we will show how to create it yourself from scratch. After reading
    this section, you'll be equipped to develop complex graphs on your own.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将把我们的图形函数提升到新的水平，因为我们将在本节中开发自己的自定义图表类型。`ggplot2`包默认没有提供生成雷达图的方法，所以我们将在这个部分中自己开发它。有一些包通过雷达图功能扩展了`ggplot2`（例如，`ggradar`），但我们将展示如何从头开始创建它。阅读本节后，你将能够自己开发复杂的图表。
- en: Radar graphs are plotted on a circular canvas and can show many variables values
    at the same time. They form a *radar-looking* shape and are useful if you want
    to compare different variable values among various *entities*. Sometimes they
    are used to visually get a sense of how similar or different *entities* are. If
    you're not familiar with this type of graphs, there's one shown in the following
    image. In our example, instead of measuring speed, durability, comfort, power,
    and space, as this example does, we will measure the three different macronutrients
    for The Food Factory's top five clients.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 雷达图是在圆形画布上绘制的，可以同时显示许多变量的值。它们形成一种*雷达状*的形状，如果你想要比较不同实体之间的变量值，它们非常有用。有时，它们被用来直观地了解实体之间相似或不同的程度。如果你不熟悉这种图表类型，以下图片中有一个示例。在我们的例子中，我们将测量食品工厂前五名客户的三个不同宏量营养素，而不是像这个例子那样测量速度、耐用性、舒适性、动力和空间。
- en: '![](img/00038.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00038.jpeg)'
- en: The `graph_radar()` function receives as parameters the `data` data frame and
    the variable by which we want to show radars (`CLIENT_ID` in our case). First,
    it transforms the data we need from wide to long format using the `gather()` function.
    Then it creates the labels that will be used in top of each radar graph, which
    show the profit produced by each `CLIENT_ID`. Finally it returns the graph object,
    which is created by specifying the macronutrients and percentages, adding a polygon
    layer groups, colors, and fills by the `CLIENT_ID`, and adjusting the `alpha`(transparency)
    and line size to look good.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`graph_radar()`函数接收`data`数据框作为参数，以及我们想要显示雷达图的变量（在我们的例子中是`CLIENT_ID`）。首先，它使用`gather()`函数将我们需要的数据从宽格式转换为长格式。然后，它创建将在每个雷达图顶部使用的标签，显示每个`CLIENT_ID`产生的利润。最后，它返回一个图形对象，该对象通过指定宏量营养素和百分比，添加一个按`CLIENT_ID`分组的折线图层、颜色和填充，并调整`alpha`(透明度)和线宽来使其看起来更好。'
- en: 'The `facet_wrap()` function is used to repeat the same plot for each instance
    of the `by` variable in the data (`CLIENT_ID` in our case). Since it requires
    a formula, and we want to generalize its usage, we use a combination of the `as.formula()` and
    `paste()` functions. To recall how these work, look at [Chapter 3](part0076.html#28FAO0-f494c932c729429fb734ce52cafce730),
    *Predicting Votes with Linear Models*. We also pass the `nrow = 1` parameter to
    make sure that we get a single row of graphs. We remove any legend information
    with the `guides()` function by sending the `"none"` string to the corresponding
    legends, apply our `coord_radar()` function (more on this below), and remove the
    axis labels:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`facet_wrap()`函数用于对数据中每个`by`变量（在我们的例子中是`CLIENT_ID`）的实例重复相同的绘图。由于它需要一个公式，并且我们希望将其用法通用化，所以我们使用`as.formula()`和`paste()`函数的组合。要回忆这些函数是如何工作的，请参阅[第3章](part0076.html#28FAO0-f494c932c729429fb734ce52cafce730)，“使用线性模型预测投票”。我们还传递了`nrow
    = 1`参数，以确保我们得到一个单独的图表行。我们使用`guides()`函数通过发送`"none"`字符串到相应的图例来移除任何图例信息，应用我们的`coord_radar()`函数（下面会详细介绍），并移除轴标签：'
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `coord_radar()` function is not a built-in function in the `ggplot2` package,
    and we need to program it ourselves. The version we will work with here is a slightly
    modified version of the `coord_radar()` found around the internet first attributed
    to Hadley Wickham. It leverages the `ggproto()` function to inherit and modify
    the polar coordinates layer in `ggplot2`, which receives parameters `theta` (angle),
    `r` (radius), `start` (starting point), `direction` (whether to use positive or
    negative units), and a hack that returns the function required by the `is_linear` parameter
    such that its value is always `TRUE`. If we did not send this last hack, we would
    get circular shapes just as we do with polar coordinates when trying to graph
    a straight line. The preceding code simply selects the appropriate axis for the
    angle so that we get the radar shape:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`coord_radar()`函数不是`ggplot2`包中的内置函数，我们需要自己编程实现它。我们将使用的是在互联网上找到的`coord_radar()`的一个略微修改过的版本，最初归功于Hadley
    Wickham。它利用`ggproto()`函数继承并修改`ggplot2`中的极坐标层，该层接收参数`theta`（角度）、`r`（半径）、`start`（起始点）、`direction`（是否使用正或负单位）以及一个用于返回由`is_linear`参数所需的函数的hack，这样其值总是`TRUE`。如果我们没有发送这个最后的hack，我们就会得到圆形形状，就像我们在尝试绘制直线时使用极坐标所做的那样。前面的代码只是简单地选择适当的轴来表示角度，以便我们得到雷达形状：'
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `ggproto()` function is used as an *internal object system* within the `ggplot2` package,
    and was developed to avoid having to change too much of the code base when implementing
    layered objects. It's not recommended for you to use it unless absolutely necessary.
    For more information on object systems, look at [Chapter 8](part0178.html#59O440-f494c932c729429fb734ce52cafce730),
    *Object-Oriented System to Track Cryptocurrencies.*
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`ggproto()`函数在`ggplot2`包内用作一个*内部对象系统*，并且是为了在实现分层对象时避免对代码库进行太多修改而开发的。除非绝对必要，否则不建议您使用它。有关对象系统的更多信息，请参阅[第8章](part0178.html#59O440-f494c932c729429fb734ce52cafce730)，*面向对象系统用于跟踪加密货币*。'
- en: Now that we have our graph function ready, we need to make sure that our data
    is formatted correctly. To do so, we create the `filter_data()` function to filter
    the data and produce the expected structure. The function receives as parameters
    the `data` we will use, the number of days to keep backwards from the current
    date as `n_days`, the number of top performers we will show as `n_top`, and the
    variable we will aggregate by as `aggregate_by`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了我们的图形函数，我们需要确保我们的数据格式正确。为此，我们创建了一个`filter_data()`函数来过滤数据并生成预期的结构。该函数接收我们将使用的`data`、从当前日期回溯要保留的天数作为`n_days`、我们将显示的顶尖表现者的数量作为`n_top`以及我们将聚合的变量作为`aggregate_by`。
- en: First, we filter the data `n` days back and then keep the observations only
    for the `n_top` performers according to the `aggregate_by` variable. As we do,
    we update the `data` accordingly. Then, we aggregate the data twice, once by `PROFIT` and
    the other time by macronutrients (`PROTEIN`, `CARBS`, and `FAT`), and we get back
    the `CLIENT_ID` name into the data frame. Doing so produces two data frames, `aggr_profit` and
    `aggr_macros`, where each one aggregates its respective variables for each unique
    `CLIENT_ID`. Note that we separate this process into two independent parts because
    we want to aggregate `PROTEIN`, `CARBS`, and `FAT` with `mean` to get the average
    preference for each `CLIENT_ID`, but at the same time, we want to aggregate `PROFIT` with
    `sum` to get the total profit (not the average profit) for each `CLIENT_ID`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将数据过滤回`n`天前，然后仅保留根据`aggregate_by`变量排序的`n_top`表现者的观察结果。在这样做的同时，我们相应地更新`data`。然后，我们两次聚合数据，一次按`PROFIT`，另一次按宏量营养素（`PROTEIN`、`CARBS`和`FAT`），并将`CLIENT_ID`名称返回到数据框中。这样做会产生两个数据框，`aggr_profit`和`aggr_macros`，其中每个数据框分别对其各自的变量进行聚合，针对每个唯一的`CLIENT_ID`。请注意，我们将此过程分为两个独立的部分，因为我们想用`mean`来聚合`PROTEIN`、`CARBS`和`FAT`，以得到每个`CLIENT_ID`的平均偏好，但与此同时，我们还想用`sum`来聚合`PROFIT`，以得到每个`CLIENT_ID`的总利润（而不是平均利润）。
- en: 'Finally, we merge the data with the `merge()` function using our `aggregate_by` variable
    to be the index by which we join the data, drop residue columns from the data
    frame, and order it by `PROFIT`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`merge()`函数将数据与我们的`aggregate_by`变量合并，使其成为数据框中数据连接的索引，删除数据框中的残留列，并按`PROFIT`排序：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you read the code carefully, you may have noticed a detail we did not mention,
    the usage of the `PROFIT_RATIO` variable in the aggregation even if we don't use
    it later in the function. The reason for including `PROFIT_RATIO` in the `aggregate()` computation
    is because of the side-effect it produces. When specifying two or more variables
    inside the data for the `aggregate()` function, the result comes back with the
    actual data frame column names in the resulting data frame `aggr_profit`. If we
    only specify `PROFIT` by itself, the result will have a column named `x` instead
    of `PROFIT`, as we have seen and used in the previous code during this chapter.
    It's an easy way to avoid dealing with variable name changes. In my opinion, the
    `aggregate()` function should always return the original data frame names, but
    it does not so we have to work around it. Remember to keep this usability in mind
    when programming for others.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细阅读代码，你可能已经注意到了我们没有提到的细节，那就是即使在函数后面没有使用它，我们也使用了 `PROFIT_RATIO` 变量进行聚合。将
    `PROFIT_RATIO` 包含在 `aggregate()` 计算中的原因是它产生的副作用。当在 `aggregate()` 函数的数据中指定两个或更多变量时，结果会返回带有实际数据帧列名的结果数据帧
    `aggr_profit`。如果我们只指定 `PROFIT` 本身，结果将有一个名为 `x` 的列而不是 `PROFIT`，正如我们在本章前面的代码中看到和使用的。这是一个避免处理变量名更改的简单方法。在我看来，`aggregate()`
    函数应该始终返回原始数据帧名称，但它并不这样做，因此我们必须找到解决方案。记住在为他人编程时要考虑这种可用性。
- en: 'To see how we actually filter dates, we look inside the `filter_n_days_back()` function.
    As you can see, we receive as parameter the `data` we want to filter and the number
    of days we want to keep backwards as `n`. If `n` is `NULL`, meaning that the user
    did not want to filter the data backward, then we simply return the same `data` we
    got. If you do receive a number in `n`, then we get the current date and subtract
    `n` days from it with `Sys.Date() - n`. This simple subtraction is automatically
    done with days as units, thanks to a technique called **operator overloading**.
    We will look at the details of how it works in [Chapter 8](part0178.html#59O440-f494c932c729429fb734ce52cafce730),
    *Object-Oriented System to Track Cryptocurrencies*. Finally, we simply keep those
    dates that is at least the `n_days_back` date (another usage of the *operator
    overloading* technique which allows us to compare dates). The `filter_n_top()` function
    is the one we created earlier for the boxplots code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们实际上是如何过滤日期的，我们可以查看 `filter_n_days_back()` 函数内部。正如你所看到的，我们接收作为参数的 `data`
    我们想要过滤的数据和我们要保留的向后天数 `n`。如果 `n` 是 `NULL`，意味着用户不想向后过滤数据，那么我们就简单地返回我们得到相同的 `data`。如果你在
    `n` 中收到一个数字，那么我们就用 `Sys.Date() - n` 从当前日期中减去 `n` 天。这个简单的减法操作自动以天为单位完成，这要归功于一种称为
    **操作符重载** 的技术。我们将在 [第8章](part0178.html#59O440-f494c932c729429fb734ce52cafce730)
    中查看它是如何工作的，*面向对象的系统用于跟踪加密货币*。最后，我们只保留至少是 `n_days_back` 日期的日期（这是另一种使用 *操作符重载* 技术的用法，它允许我们比较日期）。`filter_n_top()`
    函数是我们之前为箱线图代码创建的：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our `filter_data()` function is very useful in itself. For example, we can
    easily show the average macronutrients for the top 5 clients during the last 30
    days by executing:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `filter_data()` 函数本身非常有用。例如，我们可以通过执行以下命令轻松地显示过去30天内前5个客户的平均宏量营养素：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Having made the investment in creating the corresponding graph function, we
    are now able to easily produce our own radar graphs. For example, we can easily
    produce the corresponding radar graph for the data we just showed earlier with:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了相应的图形函数的投资之后，我们现在能够轻松地生成我们自己的雷达图。例如，我们可以通过以下方式轻松地生成我们之前展示的数据的相应雷达图：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following image gives a representation of the preceding command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像展示了前面的命令：
- en: '![](img/00039.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: Top clients' macronutrients average radar
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 客户的宏量营养素平均雷达图
- en: Exploring with interactive 3D scatter plots
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用交互式3D散点图进行探索
- en: 'When exploring data, sometimes it''s useful to look at a 3D scatter plot. However,
    if the scatter plot is fixed (meaning that you cannot move it around), it may
    not be easy to interpret. Having an interactive plot (one you can move around)
    to see different angles of the data is very useful in these cases. These graphs
    don''t normally go into static reports because they are hard to interpret correctly
    when fixed, but are very useful to do data exploration. Luckily, they are also
    very easy to create with the `plot3d()` function from the `rgl` package:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索数据时，有时查看3D散点图很有用。然而，如果散点图是固定的（意味着你不能移动它），可能不容易解释。在这些情况下，有一个交互式图表（你可以移动它）来查看数据的不同角度非常有用。这些图表通常不会进入静态报告，因为它们固定时很难正确解释，但它们在数据探索中非常有用。幸运的是，它们也用`rgl`包中的`plot3d()`函数非常容易创建：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once you create these plots in your computer, remember to move them around with
    your mouse! The first time you do this, it's pretty amazing. In this case, you
    can see two phenomenons that occur in the `sales` data. First, macronutrient percentages
    must add to one, and since there are three of them, what you will see in the graph
    on the left is a triangle shape in such a way that the sum of the coordinates
    for each point inside it is equal to one. Second, the graph on the right shows
    the relation among `PRICE`, `QUANTITY`, and `PROFIT_RATIO`. It shows that there
    are no fractional quantities in our sales data (just as we designed it), that
    there are lots of orders with zero `PROFIT_RATIO` because they are not fulfilled
    or payed for, and that the higher the `PRICE` is, the higher the `PROFIT_RATIO` is.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在电脑上创建了这些图表，记得用鼠标移动它们！第一次这样做时，感觉非常神奇。在这种情况下，你可以看到在`sales`数据中发生的两个现象。首先，宏量营养素百分比必须加起来等于一，由于有三个，所以在左边的图表中你会看到一个三角形形状，这样每个点在其中的坐标之和等于一。其次，右边的图表显示了`PRICE`、`QUANTITY`和`PROFIT_RATIO`之间的关系。它显示我们的销售数据中没有分数量（正如我们设计的那样），有很多订单的`PROFIT_RATIO`为零，因为它们没有完成或付款，而且`PRICE`越高，`PROFIT_RATIO`也越高。
- en: '![](img/00040.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00040.jpeg)'
- en: There's not much more to explain about these graphs. They are simple to create,
    have a simple purpose which sometimes can be very useful, but you will not normally
    see them in written reports.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些图表没有太多要解释的。它们创建简单，目的简单，有时非常有用，但你通常不会在书面报告中看到它们。
- en: Looking at dynamic data with time-series
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过时间序列查看动态数据
- en: 'Now we are going to focus on another very common type of graph: time-series.
    Our objective is to understand how our data is behaving for the last `n` days,
    and, as we have done before, we want to further disaggregate using colors, like
    the graph below shows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将关注另一种非常常见的图表类型：时间序列图。我们的目标是了解过去`n`天内我们的数据是如何表现的，并且，就像我们之前所做的那样，我们希望通过颜色进一步细分，如下面的图表所示：
- en: '![](img/00041.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.jpeg)'
- en: 'If you have read all the chapter up until this point, you should be able to
    understand most of what the function is doing. The only new function is `scale_x_date()`.
    It allows us to specify date formats for the axis ticks other than the default.
    In this case, we want to use breaks by day (as we had done in some examples before),
    but we want the format of the labels to be similar to **July 30, 2017**, for example.
    To do so we make use of the date formats mentioned in a previous section in this
    chapter and send the desired string structure to the `date_labels` parameter:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了到目前为止的整章内容，你应该能够理解函数的大部分功能。唯一的新函数是`scale_x_date()`。它允许我们指定除了默认之外的其他轴刻度日期格式。在这种情况下，我们想要使用按天划分的间隔（就像我们在之前的某些示例中所做的那样），但我们希望标签的格式类似于**2017年7月30日**，例如。为此，我们利用本章前面提到的日期格式，并将所需的字符串结构发送到`date_labels`参数：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you want to look at simple line graphs that show either the frequency, `PROFIT`,
    or `PROFIT_RATIO` for the last 30 days, you can use the following code. We don''t
    show these images to preserve space:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看显示过去30天频率、`PROFIT`或`PROFIT_RATIO`的简单折线图，你可以使用以下代码。我们不展示这些图像以节省空间：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To look at line graphs for frequency, `PROFIT`, and `PROFIT_RATIO`, that distinguish
    `PROTEIN_SOURCE` with colors, you can use the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看区分`PROTEIN_SOURCE`的频率、`PROFIT`和`PROFIT_RATIO`的折线图，你可以使用以下代码：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can use the `graph_last_n_days()` function with other data frames. For example,
    graph the `STARS` ratings during the last 30 days coming from `client_messages`, you
    simply need to transform the categorical variable `STARS` into a numeric variable
    with the `as.numeric()` function so that you don't get errors for type mismatches,
    and call the function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `graph_last_n_days()` 函数与其他数据框一起使用。例如，绘制来自 `client_messages` 的过去 30 天的
    `STARS` 评分，你需要简单地使用 `as.numeric()` 函数将分类变量 `STARS` 转换为数值变量，以避免类型不匹配的错误，然后调用该函数。
- en: '![](img/00042.gif)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00042.gif)'
- en: 'If you don''t specify a variable to disaggregate using colors, it will graph
    with black by default:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定使用颜色分解的变量，它将默认用黑色绘图：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Looking at geographical data with static maps
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态地图查看地理数据
- en: Maps can be very useful tools to get an intuition behind geographical data.
    In this section, we will produce a map with the `ggplot2` package. The objective
    is to show the location of our client's messages, the `PRICE` associated to their
    purchases, and the corresponding `PROFIT_RATIO`. This example will show us how
    to join data from the `sales` and `client_messages` data frames.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 地图可以是获取地理数据背后直觉的非常有用的工具。在本节中，我们将使用 `ggplot2` 包生成地图。目标是展示我们客户的消息位置，他们购买相关的 `PRICE`，以及相应的
    `PROFIT_RATIO`。这个例子将展示我们如何将 `sales` 和 `client_messages` 数据框中的数据连接起来。
- en: Our `graph_client_messages_static()` function receives as parameters the `client_messages` and
    `sales` data frames, and that's all it needs as we are showing unfiltered (full)
    datasets. First, we need to merge our two data frames using the identifier they
    share, which is `SALE_ID`. To do so we use the `merge()` function, and we specify
    that we want to keep all observation on the `x` data frame, which is the first
    one (`client_messages`), and we don't want to keep observations from the `y` data
    frame, which is the second one (`sales`), if they don't have a corresponding identifier
    in the first data frame. This allows us to keep only data that has client messages
    associated with it. Then we produce the map geographical data with the `map_data()` (it
    comes in the `ggplot2` package), and we filter it to remove any region marked
    as `"Antarctica"`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `graph_client_messages_static()` 函数接收 `client_messages` 和 `sales` 数据框作为参数，并且这就是它所需要的，因为我们正在展示未过滤（完整）的数据集。首先，我们需要使用它们共有的标识符
    `SALE_ID` 来合并我们的两个数据框。为此，我们使用 `merge()` 函数，并指定我们想要保留 `x` 数据框上的所有观测值，这是第一个数据框（`client_messages`），我们不想保留
    `y` 数据框（`sales`）上的观测值，如果它们在第一个数据框中没有相应的标识符。这使我们能够仅保留与客户消息相关联的数据。然后我们使用 `map_data()`
    函数（来自 `ggplot2` 包）生成地图地理数据，并过滤掉任何标记为 `"Antarctica"` 的区域。
- en: 'To actually create the graph we are going to use two main layers. The first
    one is the geographical data, which is added with the `geom_polygon()` function,
    using the `world_map` data, specifying the coordinates and groups (groups define
    countries), and use some dark colors to contrast with our dots. The second layer
    is the messages data, which is added with the `geom_point()` function, using the
    merged `data` data frame, with the corresponding coordinates, and adding colors
    and sizes with `PRICE` and `PROFIT_RATIO`, respectively. Since we are using a
    numeric variable to specify the color in this example, we will get a gradient
    of colors instead of discrete colors as in previous examples. Finally, we specify
    the actual color palette using the `scale_color_viridis()` function, set up the
    appropriate axis labels, and make the coordinates have equal units with the `coord_fixed()` function.
    If we don''t use this last function, we can get maps which are deformed:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际创建我们想要的图形，我们将使用两个主要图层。第一个是地理数据，它通过 `geom_polygon()` 函数添加，使用 `world_map` 数据，指定坐标和组（组定义国家），并使用一些深色来与我们的点形成对比。第二个图层是消息数据，它通过
    `geom_point()` 函数添加，使用合并的 `data` 数据框，相应的坐标，并分别使用 `PRICE` 和 `PROFIT_RATIO` 添加颜色和大小。由于在这个例子中我们使用数值变量来指定颜色，我们将得到一个颜色渐变，而不是像之前例子中的离散颜色。最后，我们使用
    `scale_color_viridis()` 函数指定实际的调色板，设置适当的轴标签，并使用 `coord_fixed()` 函数使坐标具有相等的单位。如果我们不使用这个最后一个函数，我们可能会得到变形的地图：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we can create our maps with the following function call:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下函数调用创建我们的地图：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Doing so, results in the following graph:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，结果如下图形：
- en: '![](img/00043.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00043.jpeg)'
- en: Of course, if you want to generalize this function, you can parameterize some
    of the variables used for the graph's specification as we have done in previous
    examples.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想泛化这个函数，你可以将用于图形指定的某些变量参数化，就像我们在前面的例子中所做的那样。
- en: Navigating geographical data with interactive maps
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用交互式地图导航地理数据
- en: We can navigate the geographical data with the help of interactive maps, which
    are explained in the following sections.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过交互式地图来导航地理数据，这些交互式地图将在以下章节中解释。
- en: Maps you can navigate and zoom-in to
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可以导航和放大查看的地图
- en: In this final section, we will create interactive maps that we can navigate.
    This is a very powerful tool that can be embedded in your R projects, greatly
    increasing their value and impact on your audience. We will use the `leaflet` package
    to develop this map. Our objective is to show a map with the locations of the
    messages we receive from our clients with icons that represent the type of rating
    we got using the `STARS` variable of the message and tooltips that show the `PROFIT` associated
    to the corresponding purchase of each message.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将创建可以导航的交互式地图。这是一个非常强大的工具，可以嵌入到你的 R 项目中，大大增加其价值和对你受众的影响。我们将使用 `leaflet`
    包来开发这个地图。我们的目标是显示一个地图，上面有我们从客户那里收到的消息的位置，图标代表我们使用消息的 `STARS` 变量获得的评级类型，以及显示与每个消息对应的购买相关的
    `PROFIT` 的工具提示。
- en: 'Our `graph_client_messages_interactive()` function receives the `client_messages` and
    `sales` data frames. As in the previous map, we will show all data without any
    filters, so that''s all we need as parameters. The first thing we do, as we did
    earlier, is merge the data so that we keep only observations that have an associated
    message. Then we add a new variable to the `data` data frame that contains the
    icon specification that will be used by `leaflet`. To do so, we use the `awesomeIcons()` function
    (it''s part of the `leaflet` package) and specify the functions used to specify
    the icon, the marker color, and say we want our icons to be white and that they
    should come from the `ion` icon library ([http://ionicons.com/](http://ionicons.com/)).
    Other icon libraries available are `glyphicon` ([http://glyphicons.com/](http://glyphicons.com/))
    and `fa` (`fontawesome`, [http://fontawesome.io/icons/](http://fontawesome.io/icons/)).
    You may find the icon you''re looking for in the referenced websites. Finally,
    we return the *leaflet graph* by creating markers with the `addAwesomeMarkers()` function,
    which receives a *leaflet object* created with the `leaflet()` function wrapped
    around our `data`, the formulas for longitudes and latitudes, the formula for
    icons, and the formula for the labels. Optionally, we wrap the *leaflet graph* with
    the `addProviderTiles()` to make sure that we get *tiles* (geographical background
    images) in our web browser. We need this because at the time of this writing there''s
    a bug that will not show geographic data (only the markers) under specific circumstances
    and we want to avoid that problem, which we can easily do with the mentioned technique:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `graph_client_messages_interactive()` 函数接收 `client_messages` 和 `sales` 数据框。与之前的地图一样，我们将显示所有数据而不加任何过滤器，所以这就是我们需要的参数。我们首先做的事情，就像我们之前做的那样，是将数据合并，以便我们只保留与消息相关联的观测值。然后我们向
    `data` 数据框添加一个新变量，该变量包含 `leaflet` 将使用的图标规范。为此，我们使用 `awesomeIcons()` 函数（它是 `leaflet`
    包的一部分），并指定用于指定图标、标记颜色和函数，我们希望我们的图标是白色的，并且它们应该来自 `ion` 图标库（[http://ionicons.com/](http://ionicons.com/)）。其他可用的图标库有
    `glyphicon`（[http://glyphicons.com/](http://glyphicons.com/)）和 `fa`（`fontawesome`，[http://fontawesome.io/icons/](http://fontawesome.io/icons/)）。你可以在参考网站上找到你需要的图标。最后，我们通过使用
    `addAwesomeMarkers()` 函数创建标记来返回 *leaflet 图表*，该函数接收一个由 `leaflet()` 函数包装的 *leaflet
    对象*，该对象围绕我们的 `data`，经度和纬度的公式，图标的公式以及标签的公式。可选地，我们用 `addProviderTiles()` 包装 *leaflet
    图表*，以确保我们在网页浏览器中获取 *瓦片*（地理背景图像）。我们需要这样做，因为在撰写本文时，存在一个错误，在特定情况下不会显示地理数据（只有标记），我们希望避免这个问题，我们可以通过提到的技术轻松做到这一点：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we will explain the functions that specify the icons and marker colors.
    The `get_icon_color()` function will receive our `data` data frame and return
    a vector with string, which is either `"green"` or `"red"`, depending on whether
    or not the associated `STARS` where higher or equal to 4, or not. We do so using
    the `sapply()` function. If you need a refresher on these vectorized functions,
    take a look at [Chapter 1](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730),
    *Introduction to R*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将解释指定图标和标记颜色的函数。`get_icon_color()` 函数将接收我们的 `data` 数据框，并返回一个包含字符串的向量，这些字符串是
    `"green"` 或 `"red"`，这取决于相关的 `STARS` 是否高于或等于 4，或者不是。我们使用 `sapply()` 函数这样做。如果您需要这些向量化的函数的复习，请查看[第
    1 章](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730)，*R 语言入门*：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `get_icon()` function is very similar but it will return the name of the
    icon we want. We got these names from the `ion` icon library website (referenced
    earlier):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_icon()` 函数非常相似，但它将返回我们想要的图标名称。我们从 `ion` 图标库网站（之前已引用）获取了这些名称：'
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now we can easily produce the interactive maps for our clients' messages using
    the following code. It will open a web browser and show you a map that you can
    move around.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松地使用以下代码生成我们客户消息的交互式地图。它将打开一个网络浏览器并显示您可以移动的地图。
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The initial position for the map will show the full geographical data as is
    shown in the following image. As you can see, the markers contain either a happy
    or a sad face, depending on the rating each message had. Also, the color of the
    marker is either green or red, again depending on the rating.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 地图的初始位置将显示完整的地理数据，如以下图像所示。如您所见，标记包含快乐或悲伤的脸，具体取决于每条消息的评分。此外，标记的颜色是绿色或红色，同样取决于评分。
- en: '![](img/00044.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![高科技地球仪](img/00044.jpeg)'
- en: A zoomed-in version of the interactive map can be seen in the following image.
    Depending on the provider you choose in the `addProviderTiles()` function, you
    will get different types of geographical images (you can see some of them in action
    at [htt://leaflet-extras.github.io/leaflet-providers/preview/](http://leaflet-extras.github.io/leaflet-providers/preview/)).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 放大后的互动地图可以在以下图像中看到。根据您在 `addProviderTiles()` 函数中选择的提供者，您将获得不同类型的地理图像（您可以在[htt://leaflet-extras.github.io/leaflet-providers/preview/](http://leaflet-extras.github.io/leaflet-providers/preview/)中看到一些实际操作）。
- en: '![](img/00045.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![放大后的互动地图](img/00045.jpeg)'
- en: High-tech-looking interactive globe
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高科技地球仪
- en: To finish this chapter, we will build an interactive high-tech-looking globe
    you can move around and show off to your friends. These types of visualizations
    are normally not very useful for analysis, but they are cool!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一章，我们将构建一个可以移动并展示给朋友的互动式高科技地球仪。这类可视化通常对分析不是非常有用，但它们很酷！
- en: Our objective is to show a globe that will show geographical data coming from
    clients' messages as well as bars whose height represents the `PROFIT` associated
    to each sale and colors for `PROTEIN_SOURCE`. To accomplish this, we will use
    the `threejs` package.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是显示一个地球仪，它将显示来自客户消息的地理数据，以及表示每个销售相关联的 `PROFIT` 的高度条形图和 `PROTEIN_SOURCE`
    的颜色。为了实现这一点，我们将使用 `threejs` 包。
- en: 'As we did earlier, our `graph_client_message_in_globe()` function receives
    the `client_messages` and `sales` data and sets it up using the `setup_globe_data()` function.
    Then it will get world `data` using the `get_world_map_data()` function and append
    it to the `data` data frame using the `rbind.fill()` function from the `plyr` package.
    This function resembles R''s own `rbind()` function, but won''t complain if columns
    do not match. Instead, it will fill the empty values with missing data indicators.
    Finally, we return a globe object with the `globejs()` function, which receives
    the coordinates in `lat` and `long`, the bar height under the `val` parameter,
    which comes from the `PROFIT` variable, the `color` which comes from a `COLOR` variable
    created during the data setup (see in the following example), and the `atmosphere
    = TRUE` parameter to show a glowing effect around the globe:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，我们的 `graph_client_message_in_globe()` 函数接收 `client_messages` 和 `sales`
    数据，并使用 `setup_globe_data()` 函数进行设置。然后它将使用 `get_world_map_data()` 函数获取世界数据，并使用
    `plyr` 包中的 `rbind.fill()` 函数将其附加到 `data` 数据框上。此函数类似于 R 的 `rbind()` 函数，但如果列不匹配，它不会抱怨。相反，它将使用缺失数据指示符填充空值。最后，我们使用
    `globejs()` 函数返回一个地球仪对象，该函数接收 `lat` 和 `long` 坐标，`val` 参数下的条形图高度，该参数来自 `PROFIT`
    变量，来自在数据设置期间创建的 `COLOR` 变量的 `color`，以及 `atmosphere = TRUE` 参数以显示地球周围的发光效果：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `setup_globe_data()` function does the standard merging we''ve done with
    all maps and adds a new variable named `COLOR` that contains the colors that should
    be used for each observation. In the case of the `ggplot2` package, this color
    assignment was done automatically for us, but in the `threejs` package, we need
    do it ourselves. It will simply be a different color for each value in the `PROTEIN_SOURCE` variable:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup_globe_data()` 函数执行了我们与所有地图所进行的标准合并，并添加了一个名为 `COLOR` 的新变量，该变量包含用于每个观测值应使用的颜色。在
    `ggplot2` 包的情况下，这种颜色分配已经自动为我们完成，但在 `threejs` 包中，我们需要自己完成。它将为 `PROTEIN_SOURCE`
    变量中的每个值简单地使用不同的颜色：'
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `get_world_map_data()` function is somewhat complicated. If you don't understand
    how it works, don't worry too much, as you probably won't need to do this yourself.
    We can't just use the data we had used before to create maps that we crated with
    the `map_data()` function, because the required data structure is different. In
    this case, we will create a temporary file named `cache` with the `tempfile()` function.
    Then we will read a binary file coming from a URL with the `url()` and `readBin()` functions.
    The file is a TIFF file, which we open in a `"raw"` format to keep all the data
    as is and avoid any data interpretation within R. The `n` parameter is the maximum
    number of records to be read from the data, which is 1 million in this case. Then
    we send this data through the `writeBin()` function so that it gets written to
    the `cache` file we created before. This mechanism is a way of downloading some
    temporary data so that we can read it into a function that does not support reading
    from online resources.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_world_map_data()` 函数有些复杂。如果您不理解它是如何工作的，不必过于担心，因为您可能不需要自己这样做。我们不能仅仅使用之前用于创建地图的数据来创建我们用
    `map_data()` 函数创建的地图，因为所需的数据结构不同。在这种情况下，我们将使用 `tempfile()` 函数创建一个名为 `cache` 的临时文件。然后我们将使用
    `url()` 和 `readBin()` 函数读取来自 URL 的二进制文件。该文件是一个 TIFF 文件，我们以 `"raw"` 格式打开它，以保持所有数据原样不变，并避免在
    R 中进行任何数据解释。`n` 参数是从数据中读取的最大记录数，在这个例子中是 1 百万。然后我们通过 `writeBin()` 函数发送这些数据，以便将其写入我们之前创建的
    `cache` 文件。这种机制是下载一些临时数据的一种方式，以便我们可以将其读入不支持从在线资源读取的功能函数中。'
- en: 'Once we have the temporary file ready, we read it with the `readGDAL()` function
    from the `rgdal` package, which will read it as geographical data. The specific
    format for this data includes longitude, latitude, and an altitude metric. The
    altitude metric is used to identify areas without land (oceans), which contain
    a value higher than or equal to 255 in this data. We proceed to remove any `NA` values
    in the data and assign default `PROFIT` and `COLOR` values. Note that we create
    these `PROFIT` and `COLOR` values to facilitate merging the data later on. We
    use the `PROFIT` column name for the altitude metric just for convenience since
    we will want to show the geographic areas with low bars, and we know that we will
    use `PROFIT` to generate the height for each bar:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好了临时文件，我们使用 `rgdal` 包中的 `readGDAL()` 函数读取它，该函数将其作为地理数据读取。这些数据的特定格式包括经度、纬度和一个高度指标。高度指标用于识别没有陆地（海洋）的区域，在这个数据中，其值高于或等于
    255。我们继续删除数据中的任何 `NA` 值，并分配默认的 `PROFIT` 和 `COLOR` 值。请注意，我们创建这些 `PROFIT` 和 `COLOR`
    值是为了便于稍后合并数据。我们仅为了方便起见使用 `PROFIT` 列名作为高度指标，因为我们希望显示低条形的地理区域，并且我们知道我们将使用 `PROFIT`
    生成每个条形的高度：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once we invested in creating our graph function, we can create high-tech looking
    maps that display the location of messages we get from our clients, with bars
    and colors that indicate related `PROFIT` and `PROTEIN_SOURCE` for each message,
    respectively. Feel free to move the globe around in your web browser:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们投资创建了我们的图形函数，我们就可以创建看起来高科技的地图，显示我们从客户那里收到的消息的位置，以及表示每个消息相关 `PROFIT` 和 `PROTEIN_SOURCE`
    的条形和颜色。请随意在您的网络浏览器中移动地球仪：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It's a pretty cool effect isn't it?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这效果相当酷，不是吗？
- en: '![](img/00046.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00046.jpeg)'
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create various types of data visualizations
    and how to work with graph functions and graph objects efficiently. Apart from
    the basic graph types, you learned how to create interactive graphs and maps and
    how to create our own custom types of graphs. The fundamentals shown in this chapter
    allow you to create high-quality visualizations using important and popular packages
    such as `ggplot2` and `leaflet`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何创建各种类型的数据可视化以及如何高效地使用图形函数和图形对象。除了基本的图形类型外，你还学习了如何创建交互式图表和地图，以及如何创建我们自己的自定义图形类型。本章展示的基本原理允许你使用如`ggplot2`和`leaflet`等重要且流行的包来创建高质量的视觉呈现。
- en: In the next chapter, [Chapter 6](part0129.html#3R0OI0-f494c932c729429fb734ce52cafce730),
    *Understanding Reviews with Text Analysis*, we will analyze the text data we have
    from client messages as well as data we retrieve from Twitter in real-time. We
    will show how to generate sentiment analysis given textual data, and we will prepare
    ourselves to put the graphs in this chapter together with the text analysis in
    the following chapter into automatic reports in [Chapter 7](part0147.html#4C62M0-f494c932c729429fb734ce52cafce730),
    *Developing Automatic Presentations.*
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[第六章](part0129.html#3R0OI0-f494c932c729429fb734ce52cafce730)，*通过文本分析理解评论*，我们将分析来自客户消息以及我们从Twitter实时获取的文本数据。我们将展示如何根据文本数据生成情感分析，并为我们准备将本章中的图表与下一章中的文本分析一起放入[第七章](part0147.html#4C62M0-f494c932c729429fb734ce52cafce730)，*开发自动演示*中的自动报告中。
