- en: Chapter 12. Input and Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 输入和输出
- en: In this chapter, we will cover some options for handling data files. Depending
    on the data and the desired format, there are several options for reading and
    writing. We will show some of the most useful alternatives.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍处理数据文件的一些选项。根据数据和所需的格式，有几种读取和写入的选项。我们将展示一些最有用的替代方案。
- en: File handling
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件处理
- en: 'File I/O (input and output) is essential in a number of scenarios. For example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 文件输入输出（输入和输出）在许多场景中是必不可少的。例如：
- en: Working with measured or scanned data. Measurements are stored in files that
    need to be read to be analyzed.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理测量或扫描的数据。测量数据存储在需要读取以进行分析的文件中。
- en: Interacting with other programs. Save results to files so that they can be imported
    in other applications, and vice-versa.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他程序交互。将结果保存到文件中，以便可以在其他应用程序中导入，反之亦然。
- en: Storing information for future reference or comparisons.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储信息以供将来参考或比较。
- en: Sharing data and results with others, possibly on other platforms using other
    software.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与他人共享数据和结果，可能是在其他平台使用其他软件的情况下。
- en: In this section, we will cover how to handle file I/O in Python.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何在Python中处理文件输入输出。
- en: Interacting with files
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与文件交互
- en: 'In Python, an object of type `file` represents the contents of a physical file
    stored on disk. A new `file` object may be created using the following syntax:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，类型为`file`的对象代表存储在磁盘上的物理文件的 内容。可以使用以下语法创建一个新的`file`对象：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The contents of the file may be accessed, for instance, with this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下方式访问文件内容，例如：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Usage of file objects requires some care. The problem is that a file has to
    be closed before it can be reread or used by other applications, which is done
    using the following syntax:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件对象需要小心。问题是文件在可以重新读取或被其他应用程序使用之前必须关闭，这可以通过以下语法完成：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It is, however, not that simple because an exception might be triggered before
    the call to `close` is executed, which will skip the closing code (consider the
    following example). A simple way to make sure that a file will be properly closed
    is to use context managers. This construction, using the `with` keyword, is explained
    in more detail in section *Exception* in [Chapter 10](ch10.html "Chapter 10. Error
    Handling"), *Error Handling*. Here is how it is used with files:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不简单，因为可能在执行`close`调用之前触发异常，这将跳过关闭代码（考虑以下示例）。确保文件正确关闭的简单方法是用上下文管理器。这种使用`with`关键字的构造在[第10章](ch10.html
    "第10章. 错误处理")的*异常*部分有更详细的解释，*错误处理*。以下是它与文件一起使用的方式：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This ensures that the file is closed when one exits the `with` block, even
    if an exception is raised inside the block. The command works with context manager
    objects. We recommend that you read more on context managers in section *Exception*
    in [Chapter 10](ch10.html "Chapter 10. Error Handling"), *Error Handling*. Here
    is an example showing why the `with` construct is desirable:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了当退出`with`块时文件将被关闭，即使块内抛出异常。该命令与上下文管理器对象一起工作。我们建议您阅读[第10章](ch10.html "第10章.
    错误处理")的*异常*部分了解更多关于上下文管理器的信息，*错误处理*。以下是一个示例，说明为什么`with`构造是可取的：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'An exception is raised before the file is closed. The file remains open, and
    there is no guarantee of what data is written in the file or when it is written.
    Hence, the proper way to achieve the same result is this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭文件之前抛出异常。文件保持打开状态，无法保证文件中写入的数据或写入的时间。因此，实现相同结果的正确方式是：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In that case, the file is cleanly closed just after the exception (here, `ZeroDivisionError`)
    is raised. Notice also that there is no need to close the file explicitly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，文件在异常（这里为`ZeroDivisionError`）被引发后立即干净地关闭。注意，也没有必要显式关闭文件。
- en: Files are iterable
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件是可迭代的
- en: 'A file is, in particular, iterable (refer to section *Iterators* of [Chapter
    9](ch09.html "Chapter 9. Iterating"), *Iterating*). Files iterate their lines:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个文件特别地是可迭代的（参考第9章的*迭代器*部分[第9章](ch09.html "第9章. 迭代"), *迭代*）。文件通过迭代其行：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The lines of the file are returned as strings. The string method `split` is
    a possible tool to convert the string to a list of strings. For example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 文件行被返回为字符串。字符串方法`split`是将其转换为字符串列表的可能工具。例如：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since the `myfile` object is iterable, we can also do a direct extraction into
    a list, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`myfile`对象是可迭代的，我们也可以直接将其提取到列表中，如下所示：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: File modes
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件模式
- en: 'As you can see in these examples of file handling, the `open` function takes
    at least two arguments. The first is obviously the filename, and the second is
    a string describing the way in which the file will be used. There are several
    such modes for opening files; the basic ones are:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在这些文件处理示例中所见，`open` 函数至少需要两个参数。第一个显然是文件名，第二个是一个字符串，描述了文件将被如何使用。有几种这样的模式用于打开文件；基本的有：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `'r'`, `'r+'`, and `'a'` modes require that the file exists, whereas `'w'`
    will create a new file if no file with that name exists. Reading and writing with
    `'r'` and `'w'` is most common, as you saw in previous examples.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`''r''`、`''r+''` 和 `''a''` 模式要求文件存在，而 `''w''` 如果不存在具有该名称的文件，则会创建一个新文件。使用 `''r''`
    和 `''w''` 进行读取和写入是最常见的，正如您在之前的例子中所看到的。'
- en: 'Consider an example of opening a file and adding data at the end of the file
    without modifying what is already there using the append `''a''` mode. Note the
    line break,`\n` :'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑一个使用 append `''a''` 模式打开文件并在文件末尾添加数据而不修改现有内容的例子。注意换行符，`\n` :'
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: NumPy methods
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy 方法
- en: NumPy has built-in methods for reading and writing NumPy array data to text
    files. These are `numpy.loadtxt` and `numpy.savetxt`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 有内置的方法用于将 NumPy 数组数据读取和写入文本文件。这些是 `numpy.loadtxt` 和 `numpy.savetxt`。
- en: savetxt
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: savetxt
- en: 'Writing an array to a text file is simple:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组写入文本文件很简单：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are two useful parameters given as strings, `fmt` and `delimiter`, which
    control the format and the delimiter between columns. The defaults are space for
    the delimiter and `%.18e` for the format, which corresponds to the exponential
    format with all digits. The formatting parameters are used as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个作为字符串给出的有用参数，`fmt` 和 `delimiter`，它们控制列之间的格式和分隔符。默认的分隔符是空格，格式是 `%.18e`，这对应于包含所有数字的指数格式。格式化参数的使用方法如下：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: loadtxt
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: loadtxt
- en: 'Reading to an array from a text file is done with the help of the following
    syntax:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从文本文件读取到数组是通过以下语法完成的：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Due to the fact that each row in an array must have the same length, each row
    in the text file must have the same number of elements. Similar to `savetxt`,
    the default values are `float` and the delimiter is `space`. These can be set
    using the `dtype` and `delimiter` parameters. Another useful parameter is `comments`,
    which can be used to mark what symbol is used for comments in the data file. An
    example for using the formatting parameters is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组中的每一行必须具有相同的长度，因此文本文件中的每一行必须具有相同数量的元素。类似于 `savetxt`，默认值是 `float` 和分隔符是 `space`。这些可以通过
    `dtype` 和 `delimiter` 参数设置。另一个有用的参数是 `comments`，它可以用来标记数据文件中使用的注释符号。以下是一个使用格式化参数的例子：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Pickling
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pickling
- en: The read and write methods you just saw convert data to strings before writing.
    Complex types (such as objects and classes) cannot be written this way. With Python’s
    pickle module, you can save any object and also multiple objects to file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚才看到的读取和写入方法在写入之前将数据转换为字符串。复杂类型（如对象和类）不能这样写入。使用 Python 的 pickle 模块，您可以保存任何对象，也可以将多个对象保存到文件中。
- en: 'Data can be saved in plaintext (ASCII) format or using a slightly more efficient
    binary format. There are two main methods: `dump`, which saves a pickled representation
    of a Python object to a file, and `load`, which retrieves a pickled object from
    the file. The basic usage is like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以以纯文本（ASCII）格式或使用稍微更有效的二进制格式保存。有两种主要方法：`dump`，它将 Python 对象的 pickled 表示保存到文件中，以及
    `load`，它从文件中检索 pickled 对象。基本用法如下：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note the order in which the two objects are returned. Besides the two main
    methods, it is sometimes useful to serialize a Python object to a string instead
    of a file. This is done with `dumps` and `load`. Consider an example for serializing
    an array and a dictionary:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意返回的两个对象的顺序。除了两种主要方法外，有时将 Python 对象序列化为字符串而不是文件也是有用的。这是通过 `dumps` 和 `load`
    来实现的。考虑一个序列化数组和字典的例子：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A good example of using `dumps` is when you need to write Python objects or
    NumPy arrays to a database. These usually have support for storing strings, which
    makes it easy to write and read complex data and objects without any special modules.
    Besides the pickle module, there is also an optimized version called `cPickle`.
    It is written in C and is an option if you need fast reading and writing. The
    data produced by pickle and *cPickle* is identical and can be interchanged.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dumps`的一个好例子是当你需要将Python对象或NumPy数组写入数据库时。这些通常支持存储字符串，这使得在没有特殊模块的情况下写入和读取复杂的数据和对象变得容易。除了pickle模块外，还有一个称为`cPickle`的优化版本。它是用C编写的，如果你需要快速读写，这是一个选项。pickle和*cPickle*生成相同的数据，可以互换使用。
- en: Shelves
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shelving
- en: 'Objects in dictionaries can be accessed by keys. There is a similar way to
    access particular data in a file by first assigning it a key. This is possible
    by using the module shelve:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的对象可以通过键访问。有一种类似的方法可以通过首先分配一个键来访问文件中的特定数据。这可以通过使用shelve模块来实现：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the section *File handling*, we saw that the built-in `open` command generates
    a context manager, and we saw why this is important for handling external resources,
    such as files. In contrast to this command, `sv.open` does not create a context
    manager by itself. The `closing` command from the `contextlib` module is needed
    to transform it into an appropriate context manager. Consider the following example
    of restoring the file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在*文件处理*部分，我们看到了内置的`open`命令生成上下文管理器，并看到了为什么这对于处理外部资源（如文件）很重要。与此命令相反，`sv.open`本身不会创建上下文管理器。需要`contextlib`模块的`closing`命令将其转换为适当的上下文管理器。考虑以下恢复文件的示例：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A shelve object has all dictionary methods, for example, keys and values, and
    can be used in the same way as a dictionary. Note that changes are only written
    in the file after the `close` or `sync` method has been called.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: shelving对象具有所有字典方法，例如键和值，并且可以像字典一样使用。请注意，只有在调用`close`或`sync`方法后，更改才会写入文件。
- en: Reading and writing Matlab data files
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入Matlab数据文件
- en: 'SciPy has the ability to read and write data in Matlab’s `.mat` file format
    using the module. The commands are `loadmat` and `savemat`. To load data, use
    the following syntax:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy模块具有使用模块读取和写入Matlab的`.mat`文件格式的功能。命令是`loadmat`和`savemat`。要加载数据，请使用以下语法：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The variable data now contains a dictionary, with keys corresponding to the
    variable names saved in the `.mat` file. The variables are in NumPy array format.
    Saving to `.mat` files involves creating a dictionary with all the variables you
    want to save (variable name and value). The command is then `savemat`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 变量data现在包含一个字典，键对应于`.mat`文件中保存的变量名称。变量以NumPy数组格式存在。保存到`.mat`文件涉及创建一个包含您想要保存的所有变量（变量名和值）的字典。然后命令是`savemat`：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This saves the NumPy arrays `x` and `y` with the same names when read into Matlab.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用相同的名称将NumPy数组`x`和`y`保存到Matlab中。
- en: Reading and writing images
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入图像
- en: 'SciPy comes with some basic functions for handling images. The module function
    will read images to NumPy arrays. The function will save an array as an image.
    The following will read a *JPEG* image to an array, print the shape and type,
    then create a new array with a resized image, and write the new image to file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy附带了一些处理图像的基本函数。模块函数将图像读取到NumPy数组中。该函数将数组保存为图像。以下将读取*JPEG*图像到数组，打印形状和类型，然后创建一个新的具有调整大小图像的新数组，并将新图像写入文件：
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note the data type. Images are almost always stored with pixel values in the
    range *0...255*  as 8-bit unsigned integers. The third shape value shows how many
    color channels the image has. In this case, *3* means it is a color image with
    values stored in this order: red `im[0]`, green `im[1]`, blue `im[2]`. A gray
    scale image would only have one channel.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意数据类型。图像几乎总是以*0...255*范围内的像素值存储为8位无符号整数。第三个形状值显示了图像有多少个颜色通道。在这种情况下，*3*表示它是一个具有以下顺序存储值的彩色图像：红色`im[0]`，绿色`im[1]`，蓝色`im[2]`。灰度图像将只有一个通道。
- en: For working with images, the SciPy module `scipy.misc` contains many useful
    basic image processing functions such as filtering, transforms, and measurements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图像处理，SciPy模块的`scipy.misc`包含许多有用的基本图像处理函数，例如滤波、转换和测量。
- en: Summary
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: File handling is inevitable when dealing with measurements and other sources
    of a larger amount of data. Also communication with other programs and tools is
    done via file handling.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理测量和其他大量数据来源时，文件处理是不可避免的。与其他程序和工具的通信也是通过文件处理完成的。
- en: You learned to see a file as a Python object like others with important methods
    such as `readlines` and `write`. We showed how files can be protected by special
    attributes, which may allow only read or only write access.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你学会了将文件视为一个像其他对象一样的Python对象，它具有诸如`readlines`和`write`等重要方法。我们展示了如何通过特殊属性来保护文件，这些属性可能只允许读取或只允许写入访问。
- en: The way you write to a file often influences the speed of the process. We saw
    how data is stored by pickling or by using the `shelve` method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你写入文件的方式通常会影响到处理速度。我们看到了数据是如何通过序列化（pickling）或使用`shelve`方法进行存储的。
