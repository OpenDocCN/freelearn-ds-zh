- en: <st c="0">10</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">10</st>
- en: <st c="3">Dynamic Programming</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">动态规划</st>
- en: <st c="23">Dynamic programming is a</st> <st c="48">powerful technique that
    can dramatically lower the computational costs of many complex algorithms, though
    it comes with some trade-offs.</st> <st c="186">This chapter introduces dynamic
    programming and includes a review of</st> <st c="255">greedy algorithms.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23">动态规划是一种</st> <st c="48">强大的技术，能够显著降低许多复杂算法的计算成本，尽管它也有一些权衡。</st> <st
    c="186">本章介绍了动态规划，并包括对</st> <st c="255">贪心算法的回顾。</st>
- en: <st c="273">We will begin by revisiting the principles of divide-and-conquer
    strategies to contrast them with dynamic programming.</st> <st c="393">Dynamic
    programming stands out in algorithm design due to its ability to solve problems
    that involve overlapping subproblems and optimal substructure.</st> <st c="544">By
    storing the results of these subproblems, dynamic programming prevents redundant
    calculations, leading to significant</st> <st c="665">efficiency gains.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="273">我们将通过回顾分治法的原则，来与动态规划进行对比。</st> <st c="393">动态规划在算法设计中脱颖而出，因为它能够解决涉及重叠子问题和最优子结构的问题。</st>
    <st c="544">通过存储这些子问题的结果，动态规划避免了冗余计算，从而显著提高了</st> <st c="665">效率。</st>
- en: <st c="682">Through various examples, we will explore how dynamic programming
    can be applied to solve classical problems such as the knapsack problem, the longest
    common subsequence, and the Traveling Salesman Problem.</st> <st c="890">Each
    example will illustrate the step-by-step approach to breaking down a problem,
    defining the state space, and formulating the recurrence relations necessary for
    the dynamic</st> <st c="1066">programming solution.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="682">通过各种示例，我们将探索如何应用动态规划来解决经典问题，如背包问题、最长公共子序列问题和旅行推销员问题。</st> <st c="890">每个示例将展示如何逐步分解问题，定义状态空间，并制定递推关系，进而得出动态规划解法。</st>
- en: <st c="1087">It is important to note that dynamic programming is an extensive
    topic that cannot be fully covered in just one chapter.</st> <st c="1209">In this
    chapter, we will focus on the key aspects of this method, including its main elements,
    applications, and illustrative examples.</st> <st c="1345">Additionally, we will
    discuss how to estimate the complexities of dynamic programming solutions, and
    we will explore the advantages and limitations of</st> <st c="1496">this approach.</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1087">需要注意的是，动态规划是一个广泛的主题，不能仅通过一章内容完全覆盖。</st> <st c="1209">在这一章中，我们将重点讨论这一方法的关键方面，包括其主要元素、应用和示例。</st>
    <st c="1345">此外，我们还将讨论如何估算动态规划解法的复杂度，并探讨这种方法的优缺点。</st> <st c="1496">这一方法的优缺点。</st>
- en: <st c="1510">Specifically, we’ll cover all this in the following</st> <st c="1563">main
    sections:</st>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1510">具体来说，我们将在以下</st> <st c="1563">主要部分中进行详细阐述：</st>
- en: <st c="1577">Dynamic programming</st> <st c="1598">versus divide-and-conquer</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1577">动态规划</st> <st c="1598">与分治法</st>
- en: <st c="1623">Exploring</st> <st c="1634">dynamic programming</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1623">探索</st> <st c="1634">动态规划</st>
- en: <st c="1653">Greedy algorithms –</st> <st c="1674">an introduction</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1653">贪心算法 –</st> <st c="1674">简介</st>
- en: <st c="1689">Dynamic programming versus divide-and-conquer</st>
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1689">动态规划与分治法</st>
- en: <st c="1735">In</st> *<st c="1739">Chapters 4</st>* <st c="1749">and</st> *<st
    c="1754">5</st>*<st c="1755">, we</st> <st c="1759">explored recursive algorithms
    and the methods to analyze their complexities.</st> <st c="1837">We also explored
    divide-and-conquer strategies.</st> <st c="1885">The fundamental idea behind a
    divide-and-conquer approach is to break down a problem into smaller subproblems,
    solve these subproblems optimally, and then combine their solutions to form the
    final solution.</st> <st c="2092">This process is typically carried out recursively,
    meaning that the problem is continuously divided into subproblems until we reach
    a point where the subproblem is so small that it can be solved intuitively or
    straightforwardly.</st> <st c="2321">This smallest, simplest problem is referred
    to as the</st> **<st c="2375">base case</st>**<st c="2384">.</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1735">在</st> *<st c="1739">第4章</st>* <st c="1749">和</st> *<st c="1754">第5章</st>*<st
    c="1755">中，我们</st> <st c="1759">探讨了递归算法及其复杂度分析方法。</st> <st c="1837">我们还探讨了分治策略。</st>
    <st c="1885">分治法背后的基本思想是将问题分解为更小的子问题，优化解决这些子问题，然后将它们的解合并形成最终解。</st> <st c="2092">这一过程通常是递归进行的，也就是说，问题会不断被分解为子问题，直到达到一个子问题足够小，可以通过直觉或简单的方法解决。</st>
    <st c="2321">这个最小且最简单的问题被称为</st> **<st c="2375">基本情况</st>**<st c="2384">。</st>
- en: <st c="2385">Dynamic programming follows a similar strategy to divide-and-conquer.</st>
    <st c="2456">It breaks down a problem into subproblems with the explicit assumption
    that the optimal solution to any subproblem will contribute to the final optimal
    solution.</st> <st c="2618">This characteristic is known as the</st> **<st c="2654">optimal
    substructure</st>**<st c="2674">. While</st> <st c="2681">this property is also
    present in divide-and-conquer algorithms, it is typically assumed implicitly rather
    than</st> <st c="2793">explicitly stated.</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2385">动态规划遵循与分治法相似的策略。</st> <st c="2456">它将一个问题分解为多个子问题，明确假设任何子问题的最优解将有助于最终最优解的形成。</st>
    <st c="2618">这一特性被称为</st> **<st c="2654">最优子结构</st>**<st c="2674">。虽然</st> <st
    c="2681">这一特性在分治算法中也存在，但通常是隐式假设，而非</st> <st c="2793">明确声明。</st>
- en: <st c="2811">However, dynamic programming extends beyond the divide-and-conquer
    approach in a key way that sets it apart.</st> <st c="2921">In dynamic programming,
    subproblems often share common sub-subproblems, meaning that there is overlap
    between the subproblems.</st> <st c="3048">This characteristic is known</st> <st
    c="3077">as</st> **<st c="3080">overlapping subproblems</st>**<st c="3103">. Not
    all problems exhibit this behavior.</st> <st c="3145">When a problem does not
    have overlapping subproblems, using a straightforward divide-and-conquer approach
    is more appropriate, as dynamic programming would not provide any additional benefit
    in</st> <st c="3339">such cases.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2811">然而，动态规划在一个关键方面超越了分治方法，这也是它的独特之处。</st> <st c="2921">在动态规划中，子问题通常会共享公共的子子问题，也就是说，子问题之间会有重叠。</st>
    <st c="3048">这一特性被称为</st> **<st c="3080">重叠子问题</st>**<st c="3103">。并非所有问题都会表现出这种行为。</st>
    <st c="3145">当一个问题没有重叠子问题时，使用简单的分治方法更为合适，因为在</st> <st c="3339">这种情况下，动态规划不会提供额外的好处。</st>
- en: '<st c="3350">But why do overlapping subproblems matter?</st> <st c="3394">One
    of the primary goals in algorithm design and analysis, which we have consistently
    focused on, is reducing the computational cost or complexity of algorithms.</st>
    <st c="3556">The importance of overlapping subproblems lies in their potential
    to significantly lower this computational complexity.</st> <st c="3676">In problems
    where subproblems overlap, divide-and-conquer algorithms may redundantly solve
    these overlapping sub-subproblems multiple times.</st> <st c="3817">In contrast,
    dynamic programming stores the solutions to these sub-subproblems and reuses them
    whenever they are needed.</st> <st c="3938">This reuse of previously computed
    solutions can lead to a substantial reduction in computational complexity.</st>
    <st c="4047">However, this efficiency comes at a cost: the additional space required
    to store the solutions for</st> <st c="4146">these sub-subproblems.</st>'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3350">但为什么重叠子问题如此重要呢？</st> <st c="3394">算法设计和分析的主要目标之一，正是我们始终关注的，是减少算法的计算成本或复杂度。</st>
    <st c="3556">重叠子问题的重要性在于它们能够显著降低计算复杂度。</st> <st c="3676">在子问题重叠的情况下，分治算法可能会冗余地多次求解这些重叠的子子问题。</st>
    <st c="3817">相比之下，动态规划会存储这些子子问题的解，并在需要时重复使用它们。</st> <st c="3938">这种对先前计算结果的重用，可以大大减少计算复杂度。</st>
    <st c="4047">然而，这种高效性是有代价的：需要额外的空间来存储这些</st> <st c="4146">子子问题的解。</st>
- en: <st c="4168">Now that we understand the connection between divide-and-conquer
    and dynamic programming, let’s discuss dynamic programming itself.</st> <st c="4301">First,
    it’s crucial to clarify that the term dynamic programming does not pertain to
    writing code or computer programming.</st> <st c="4424">Instead, it refers to
    a method of mathematical optimization.</st> <st c="4485">Dynamic programming was
    originally proposed as a technique for solving optimization problems, which is
    why it is studied in both mathematical optimization and computer science.</st>
    <st c="4662">In this chapter, our focus will be on the application of dynamic
    programming within the field of</st> <st c="4759">computer science.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4168">现在我们理解了分治法与动态规划之间的联系，让我们来讨论一下动态规划本身。</st> <st c="4301">首先，需要明确的是，动态规划这一术语并不涉及编写代码或计算机编程。</st>
    <st c="4424">相反，它指的是一种数学优化方法。</st> <st c="4485">动态规划最初被提出作为解决优化问题的一种技术，这也是为什么它在数学优化和计算机科学中都有研究的原因。</st>
    <st c="4662">在本章中，我们将重点讨论动态规划在</st> <st c="4759">计算机科学领域中的应用。</st>
- en: '<st c="4776">As we</st> <st c="4782">previously discussed, dynamic programming
    is built on two fundamental concepts: the assumption of optimal substructure and
    the presence of overlapping subproblems.</st> <st c="4947">Optimal substructure
    implies that the optimal solution to a problem can be formed from the optimal
    solutions of its subproblems.</st> <st c="5076">Overlapping subproblems occur
    when the same subproblems are solved multiple times during the recursive process.</st>
    <st c="5188">In the following subsections, we will explore these concepts in greater
    detail, examining how they serve as the foundation of dynamic programming and
    how they facilitate the development of efficient algorithms for tackling</st>
    <st c="5411">complex problems.</st>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4776">正如我们</st> <st c="4782">之前讨论的，动态规划建立在两个基本概念之上：最优子结构的假设和重叠子问题的存在。</st>
    <st c="4947">最优子结构意味着问题的最优解可以通过其子问题的最优解来构建。</st> <st c="5076">重叠子问题是指在递归过程中，同一子问题被多次求解。</st>
    <st c="5188">在接下来的子节中，我们将更详细地探讨这些概念，研究它们如何成为动态规划的基础，以及它们如何促进高效算法的发展，以应对</st> <st
    c="5411">复杂问题。</st>
- en: <st c="5428">Optimal substructure</st>
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5428">最优子结构</st>
- en: <st c="5449">Optimal substructure</st> <st c="5471">is a cornerstone concept
    in algorithm design, signifying that an optimal solution to a given problem can
    be built efficiently using the optimal solutions of its smaller subproblems.</st>
    <st c="5653">This property suggests that the problem can be decomposed into simpler,
    overlapping subproblems, each of which can be solved independently.</st> <st c="5793">Once
    the subproblems are resolved optimally, their solutions can be combined to form
    the solution to the original,</st> <st c="5908">larger problem.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5449">最优子结构</st> <st c="5471">是算法设计中的一个核心概念，意味着一个给定问题的最优解可以通过有效利用其较小子问题的最优解来构建。</st>
    <st c="5653">这一特性表明，问题可以被分解为更简单、相互重叠的子问题，每个子问题都可以独立解决。</st> <st c="5793">一旦子问题得到最优解，它们的解就可以被组合起来，形成原始更大问题的解。</st>
    <st c="5908">大的问题。</st>
- en: <st c="5923">The presence of optimal substructure is crucial because it allows
    us to break down complex problems into more manageable components.</st> <st c="6057">This
    decomposition not only simplifies the problem-solving process but also makes it
    possible to apply algorithmic strategies such as dynamic programming and divide-and-conquer.</st>
    <st c="6235">In dynamic programming, the optimal substructure property ensures
    that once we have the optimal solutions for all subproblems, we can use them to
    systematically build the optimal solution for the entire problem.</st> <st c="6447">This
    is achieved by storing the results of subproblems in a table, preventing the need
    to recompute them and thus enhancing the</st> <st c="6575">algorithm’s efficiency.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5923">最优子结构的存在至关重要，因为它使我们能够将复杂问题分解为更易处理的组件。</st> <st c="6057">这种分解不仅简化了问题解决过程，而且使得可以应用像动态规划和分治这样的算法策略。</st>
    <st c="6235">在动态规划中，最优子结构特性确保一旦我们获得了所有子问题的最优解，就能利用它们系统地构建整个问题的最优解。</st> <st c="6447">通过将子问题的结果存储在表中，避免了重新计算，从而提高了</st>
    <st c="6575">算法的效率。</st>
- en: <st c="6598">In divide-and-conquer algorithms, although in a different way,
    the optimal substructure is also vital.</st> <st c="6702">These algorithms divide
    the problem into non-overlapping subproblems, solve each subproblem independently,
    and then combine their solutions.</st> <st c="6843">The success of both dynamic
    programming and divide-and-conquer approaches hinges on the problem exhibiting
    optimal substructure, as it guarantees that solving smaller parts optimally will
    lead to the best possible solution for the</st> <st c="7074">overall problem.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6598">在分治算法中，尽管方式不同，最优子结构同样至关重要。</st> <st c="6702">这些算法将问题分解为不重叠的子问题，独立解决每个子问题，然后合并它们的解。</st>
    <st c="6843">动态规划和分治方法的成功依赖于问题具备最优子结构，因为它保证了通过最优解决较小部分问题将导致整体问题的最优解。</st> <st
    c="7074">整体问题。</st>
- en: <st c="7090">Optimal substructure is</st> <st c="7115">not only a theoretical
    concept but also a practical tool in algorithm design.</st> <st c="7193">It helps
    us recognize when a problem can be efficiently tackled using dynamic programming
    or other strategies that rely on building up solutions from smaller components.</st>
    <st c="7363">Understanding and identifying optimal substructure in various problems
    is a key skill in developing efficient and effective algorithms.</st> <st c="7499">Next,
    we will explore this concept with some</st> <st c="7544">example problems.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7090">最优子结构不仅是一个理论概念，也是算法设计中的一个实用工具。</st> <st c="7115">它帮助我们识别何时可以通过动态规划或其他依赖于从较小组件逐步构建解决方案的策略高效地解决问题。</st>
    <st c="7193">理解并识别不同问题中的最优子结构是开发高效且有效算法的关键技能。</st> <st c="7363">接下来，我们将通过一些</st>
    <st c="7544">示例问题来探讨这一概念。</st>
- en: <st c="7561">The first example is the shortest path problem.</st> <st c="7610">In
    the shortest path problem on a graph, the goal is to find the shortest path from
    a source node (vertex) to a destination node.</st> <st c="7740">This problem exhibits
    optimal substructure because the shortest path between two nodes can be broken
    down into smaller shortest paths between intermediate nodes.</st> <st c="7902">Let’s
    assume</st> **<st c="7915">S</st>** <st c="7916">is the source node and</st> **<st
    c="7940">G</st>** <st c="7941">is the destination.</st> <st c="7962">We aim to
    find the shortest path between these two nodes.</st> <st c="8020">Suppose</st>
    **<st c="8028">A</st>** <st c="8029">is a node on the optimal (shortest) path
    from</st> **<st c="8076">S</st>** <st c="8077">to</st> **<st c="8081">G</st>**<st
    c="8082">. The optimal substructure characteristic suggests that because</st>
    **<st c="8146">A</st>** <st c="8147">is part of the optimal path, the overall
    optimal path from</st> **<st c="8207">S</st>** <st c="8208">to</st> **<st c="8212">G</st>**
    <st c="8213">must consist of the optimal path from</st> **<st c="8252">S</st>**
    <st c="8253">to</st> **<st c="8257">A</st>**<st c="8258">, followed by the optimal
    path from</st> **<st c="8294">A</st>** <st c="8295">to</st> **<st c="8299">G</st>**<st
    c="8300">. Optimal substructure also implies that any subpath that is not optimal
    cannot be part of the overall optimal solution.</st> <st c="8421">This means that
    if a subpath from S to</st> **<st c="8460">A</st>** <st c="8461">or from</st>
    **<st c="8470">A</st>** <st c="8471">to</st> **<st c="8475">G</st>** <st c="8476">is
    not the shortest, then the entire path from</st> **<st c="8524">S</st>** <st c="8525">to</st>
    **<st c="8529">G</st>** <st c="8530">cannot be the shortest (see</st> *<st c="8559">Figure
    10</st>**<st c="8568">.1</st>*<st c="8570">).</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7561">第一个例子是最短路径问题。</st> <st c="7610">在图上的最短路径问题中，目标是找到从源节点（顶点）到目标节点的最短路径。</st>
    <st c="7740">这个问题展示了最优子结构特性，因为两个节点之间的最短路径可以分解为经过中间节点的更小的最短路径。</st> <st c="7902">假设</st>
    **<st c="7915">S</st>** <st c="7916">是源节点，</st> **<st c="7940">G</st>** <st c="7941">是目标节点。</st>
    <st c="7962">我们的目标是找到这两个节点之间的最短路径。</st> <st c="8020">假设</st> **<st c="8028">A</st>**
    <st c="8029">是从</st> **<st c="8076">S</st>** <st c="8077">到</st> **<st c="8081">G</st>**
    <st c="8082">的最优（最短）路径上的一个节点。</st> 最优子结构特性表明，因为**<st c="8146">A</st>** <st c="8147">是最优路径的一部分，从</st>
    **<st c="8207">S</st>** <st c="8208">到</st> **<st c="8212">G</st>** <st c="8213">的整个最优路径必须包含从</st>
    **<st c="8252">S</st>** <st c="8253">到</st> **<st c="8257">A</st>** <st c="8258">的最优路径，接着是从</st>
    **<st c="8294">A</st>** <st c="8295">到</st> **<st c="8299">G</st>** <st c="8300">的最优路径。</st>
    最优子结构也意味着，任何不是最优的子路径不能成为整体最优解的一部分。</st> <st c="8421">这意味着，如果从S到</st> **<st c="8460">A</st>**
    <st c="8461">或从</st> **<st c="8470">A</st>** <st c="8471">到</st> **<st c="8475">G</st>**
    <st c="8476">的子路径不是最短的，那么从</st> **<st c="8524">S</st>** <st c="8525">到</st> **<st
    c="8529">G</st>** <st c="8530">的整个路径就不可能是最短的（见</st> *<st c="8559">图10.1</st>*<st
    c="8568">）。</st>
- en: '![Fig 10.1: Illustrating optimal substructure in shortest path problem.](img/B22248_10_1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1：展示最短路径问题中的最优子结构。](img/B22248_10_1.jpg)'
- en: '<st c="8587">Fig 10.1: Illustrating optimal substructure in shortest path problem.</st>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8587">图 10.1：展示最短路径问题中的最优子结构。</st>
- en: <st c="8656">The second example is finding the</st> **<st c="8691">Longest Common
    Subsequence</st>** <st c="8717">(</st>**<st c="8719">LCS</st>**<st c="8722">).</st>
    <st c="8726">The problem involves</st> <st c="8746">identifying the longest subsequence
    that can be found in a set of sequences.</st> <st c="8824">It is essential to
    understand that a subsequence differs from a substring.</st> <st c="8899">In a
    subsequence, unlike in a substring, the elements do not need to be in consecutive
    positions within the sequence.</st> <st c="9017">This distinction is crucial in
    many applications across computer science, such as in data compression, sequence
    alignment, and</st> <st c="9144">file comparison.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8656">第二个例子是寻找</st> **<st c="8691">最长公共子序列</st>** <st c="8717">(</st>**<st
    c="8719">LCS</st>**<st c="8722">)。</st> <st c="8726">这个问题涉及</st> <st c="8746">识别可以在一组序列中找到的最长子序列。</st>
    <st c="8824">需要理解的是，子序列不同于子串。</st> <st c="8899">在子序列中，与子串不同，元素不需要在序列中连续出现。</st>
    <st c="9017">这种区别在计算机科学的许多应用中至关重要，例如数据压缩、序列比对和</st> <st c="9144">文件比较。</st>
- en: <st c="9160">Optimal substructure in</st> <st c="9184">the LCS problem means
    that the solution to finding the LCS of two sequences can be constructed from
    the solutions to smaller subproblems.</st> <st c="9323">Specifically, the LCS
    of two sequences X and Y can be built by considering the LCS of prefixes of</st>
    <st c="9421">these sequences.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9160">LCS问题中的最优子结构</st> <st c="9184">意味着找到两个序列的LCS的解决方案可以通过较小子问题的解决方案构建。</st>
    <st c="9323">具体来说，两个序列X和Y的LCS可以通过考虑这些序列的前缀的LCS来构建。</st>
- en: '<st c="9437">Let’s assume we have two sequences</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1606.png)
    <st c="9473"><st c="9474">of length</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/1607.png)
    <st c="9485"><st c="9486">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1608.png)
    <st c="9491"><st c="9492">of length</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/945.png)<st
    c="9503"><st c="9504">. The LCS of these two sequences denoted as LCS</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1610.png)<st
    c="9551"><st c="9553">, can be determined using the following approach: if either</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1606.png)
    <st c="9613"><st c="9614">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1612.png)
    <st c="9618"><st c="9619">is an empty sequence, then the LCS is also an empty
    sequence.</st> <st c="9682">This is the base case for our recursion.</st> <st
    c="9723">If the last characters of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1613.png)
    <st c="9749"><st c="9750">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1614.png)
    <st c="9755"><st c="9756">match</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    separators="|"><mml:mrow><mml:mi>s</mml:mi><mml:mi>a</mml:mi><mml:mi>y</mml:mi><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/1615.png)<st
    c="9763"><st c="9780">, then these characters must be part of the LCS.</st> <st
    c="9829">Therefore, the problem reduces to finding the LCS of the prefixes</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1616.png)
    <st c="9895"><st c="9896">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1617.png)<st
    c="9901"><st c="9902">, and then appending the matching character to</st> <st
    c="9949">this LCS.</st></st></st></st></st></st></st></st></st></st></st></st></st>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9437">假设我们有两个序列</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1606.png)
    <st c="9473"><st c="9474">的长度为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/1607.png)
    <st c="9485"><st c="9486">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1608.png)
    <st c="9491"><st c="9492">的长度为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/945.png)<st
    c="9503"><st c="9504">。这两个序列的最长公共子序列（LCS）表示为LCS</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1610.png)<st
    c="9551"><st c="9553">，可以通过以下方法确定：如果</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1606.png)
    <st c="9613"><st c="9614">或</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1612.png)
    <st c="9618"><st c="9619">是空序列，那么LCS也是空序列。</st> <st c="9682">这是我们递归的基本情况。</st>
    <st c="9723">如果</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1613.png)
    <st c="9749"><st c="9750">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1614.png)
    <st c="9755"><st c="9756">的最后一个字符相同</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    separators="|"><mml:mrow><mml:mi>s</mml:mi><mml:mi>a</mml:mi><mml:mi>y</mml:mi><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/1615.png)<st
    c="9763"><st c="9780">，那么这些字符必须是LCS的一部分。</st> <st c="9829">因此，问题转化为查找前缀的LCS</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1616.png)
    <st c="9895"><st c="9896">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1617.png)<st
    c="9901"><st c="9902">，然后将匹配的字符附加到</st> <st c="9949">这个LCS中。</st></st></st></st></st></st></st></st></st></st></st></st></st>
- en: <st c="9958">However, if the last characters of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1606.png)
    <st c="9994"><st c="9995">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1608.png)
    <st c="10000"><st c="10001">do not match (i.e.,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>≠</mml:mo><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1620.png)<st
    c="10022"><st c="10023">), then the LCS is the longer of the LCS obtained by either
    of the</st> <st c="10090">following methods:</st></st></st></st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果最后的字符在 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1606.png)
    和 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1608.png)
    不匹配（即，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>≠</mml:mo><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1620.png))，那么最长公共子序列（LCS）是通过以下两种方法中得到的较长的一个：
- en: <st c="10108">Excluding the last character of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1606.png)
    <st c="10141"><st c="10142">and considering the LCS of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1622.png)
    <st c="10170"><st c="10171">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1623.png)</st></st>
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排除 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1606.png)
    的最后一个字符，并考虑 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1622.png)
    和 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1623.png)
    的最长公共子序列。
- en: <st c="10176">Excluding the last character of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1612.png)
    <st c="10208"><st c="10209">and considering the LCS of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1625.png)
    <st c="10237"><st c="10243">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1626.png)</st></st>
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="10176">排除最后一个字符</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1612.png)
    <st c="10208"><st c="10209">并考虑</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1625.png)
    <st c="10237"><st c="10243">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1626.png)</st></st>
- en: <st c="10248">Let</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>L</mi><mo>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1627.png)
    <st c="10252"><st c="10260">represent the LCS of the prefixes</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1628.png)
    <st c="10294"><st c="10300">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1629.png)<st
    c="10304"><st c="10313">. Then the optimal substructure property can be expressed</st>
    <st c="10371">as follows:</st></st></st></st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10248">设</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>L</mi><mo>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1627.png)
    <st c="10252"><st c="10260">表示前缀的LCS</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1628.png)
    <st c="10294"><st c="10300">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1629.png)<st
    c="10304"><st c="10313">。然后，最优子结构性质可以表示为</st> <st c="10371">如下：</st></st></st></st>
- en: '![](img/B22248_10_2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22248_10_2.jpg)'
- en: '**<st c="10467">Example 10.1:</st>**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="10467">示例 10.1：</st>**'
- en: <st c="10480">Consider the</st> <st c="10494">following sequences:</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10480">考虑以下序列：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mtext>abbbsbbsh</mml:mtext></mml:math>](img/1630.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mtext>abbbsbbsh</mml:mtext></mml:math>](img/1630.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mtext>bbsdhjsh</mml:mtext></mml:math>](img/1631.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mtext>bbsdhjsh</mml:mtext></mml:math>](img/1631.png)'
- en: <st c="10542">If the last characters of both sequences are the same (here, both
    end in</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi></mml:math>](img/1632.png)<st
    c="10615"><st c="10616">), then</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi></mml:math>](img/1632.png)
    <st c="10624"><st c="10625">is part of the LCS, and the problem reduces to finding
    the LCS of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mtext>abbbsbbs</mml:mtext></mml:math>](img/1634.png)
    <st c="10692"><st c="10705">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mtext>bbsdhjs</mml:mtext><mml:mo>.</mml:mo></mml:math>](img/1635.png)
    <st c="10709"><st c="10722">If the last characters are different, we must consider
    the LCS of the smaller sequences</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mtext>abbbsbbsh</mml:mtext></mml:math>](img/1630.png)
    <st c="10810"><st c="10824">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mtext>bbsdhjs</mml:mtext></mml:math>](img/1637.png)<st
    c="10828"><st c="10841">, or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mtext>abbbsbbs</mml:mtext></mml:math>](img/1638.png)
    <st c="10846"><st c="10859">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mtext>bbsdhjsh</mml:mtext></mml:math>](img/1631.png)<st
    c="10863"><st c="10876">, and take the</st> <st c="10891">longer one.</st></st></st></st></st></st></st></st></st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10542">如果两个序列的最后一个字符相同（这里，两者都以</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi></mml:math>](img/1632.png)<st
    c="10615"><st c="10616">) 结尾，那么</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi></mml:math>](img/1632.png)
    <st c="10624"><st c="10625">是最长公共子序列（LCS）的一部分，问题简化为寻找</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mtext>abbbsbbs</mml:mtext></mml:math>](img/1634.png)
    <st c="10692"><st c="10705">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mtext>bbsdhjs</mml:mtext><mml:mo>.</mml:mo></mml:math>](img/1635.png)
    <st c="10709"><st c="10722">如果最后一个字符不同，我们必须考虑较小序列的LCS</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mtext>abbbsbbsh</mml:mtext></mml:math>](img/1630.png)
    <st c="10810"><st c="10824">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mtext>bbsdhjs</mml:mtext></mml:math>](img/1637.png)<st
    c="10828"><st c="10841">，或者</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mtext>abbbsbbs</mml:mtext></mml:math>](img/1638.png)
    <st c="10846"><st c="10859">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mtext>bbsdhjsh</mml:mtext></mml:math>](img/1631.png)<st
    c="10863"><st c="10876">，然后取</st> <st c="10891">较长的那个。</st></st></st></st></st></st></st></st></st>
- en: <st c="10902">The optimal substructure in the LCS problem ensures that the overall
    LCS can be constructed from the LCS of smaller subproblems.</st> <st c="11032">This
    property is crucial for dynamic programming solutions, where we systematically
    solve and store the results of these subproblems to build the final</st> <st c="11184">solution
    efficiently.</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10902">LCS问题中的最优子结构确保了可以通过较小子问题的LCS来构建整体LCS。</st> <st c="11032">这一性质对动态规划方法至关重要，在动态规划中，我们系统地解决并存储这些子问题的结果，以高效地构建最终的</st>
    <st c="11184">解决方案。</st>
- en: '<st c="11205">Not all problems</st> <st c="11223">are optimal substructure
    problems.</st> <st c="11258">One example is the longest path problem.</st> <st
    c="11299">The longest path problem, particularly in a graph where cycles may exist,
    is not considered to have the optimal substructure property.</st> <st c="11434">To
    understand why, let’s first recall what optimal substructure means: a problem
    exhibits optimal substructure if the optimal solution to the problem can be constructed
    from the optimal solutions of</st> <st c="11633">its subproblems.</st>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11205">并非所有问题</st> <st c="11223">都具有最优子结构性质。</st> <st c="11258">最长路径问题就是一个例子。</st>
    <st c="11299">特别是在可能存在环的图中，最长路径问题被认为不具有最优子结构性质。</st> <st c="11434">要理解这一点，我们首先回顾一下最优子结构的含义：一个问题如果具有最优子结构性质，那么该问题的最优解可以通过其子问题的最优解来构造。</st>
    <st c="11633">其子问题的最优解。</st>
- en: <st c="11649">In the longest path problem, the goal is to find the longest simple
    path (a path that does not repeat nodes) between two nodes in a graph.</st> <st
    c="11789">This problem is particularly challenging when the graph contains cycles,
    as the presence of cycles can complicate the identification of the longest path.</st>
    <st c="11943">In the longest path problem, the optimal substructure property does
    not hold due to the</st> <st c="12031">following reasons:</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11649">在最长路径问题中，目标是找到图中两个节点之间的最长简单路径（即不重复节点的路径）。</st> <st c="11789">当图中包含环时，这个问题特别具有挑战性，因为环的存在可能使得识别最长路径变得复杂。</st>
    <st c="11943">在最长路径问题中，最优子结构性质不成立，原因如下：</st>
- en: '**<st c="12049">Dependency on subsequent paths</st>**<st c="12080">: In many
    cases, a subpath that appears to be part of the longest path from one node to
    another might not lead to the overall longest path when extended to other nodes.</st>
    <st c="12250">This is because choosing a subpath that looks long at first might
    force you to take shorter paths later, which would reduce the overall</st> <st
    c="12386">path length.</st>'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12049">后续路径的依赖性</st>**<st c="12080">：在许多情况下，一个看似是从一个节点到另一个节点的最长路径的一部分的子路径，扩展到其他节点时可能并不会导致整体的最长路径。</st>
    <st c="12250">这是因为，选择一个看起来很长的子路径，可能会迫使你在后续选择较短的路径，从而减少整体的</st> <st c="12386">路径长度。</st>'
- en: '**<st c="12398">Cycle involvement</st>**<st c="12416">: If the graph contains
    cycles, the longest path might involve traversing through parts of the graph in
    such a way that it doesn’t neatly decompose into subproblems that independently
    contribute to the overall longest path.</st> <st c="12641">The decision to include
    or exclude certain edges can dramatically change the resulting</st> <st c="12728">path’s
    length.</st>'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12398">环的参与</st>**<st c="12416">：如果图中包含环，那么最长路径可能涉及以某种方式穿越图的部分，使得它无法简单地分解为独立贡献于整体最长路径的子问题。</st>
    <st c="12641">是否包含或排除某些边缘的决定，可能会显著改变最终的</st> <st c="12728">路径长度。</st>'
- en: '**<st c="12742">Non-additive nature</st>**<st c="12762">: In problems with
    optimal substructure, you can usually solve subproblems independently and then
    combine them to get the optimal solution.</st> <st c="12903">However, in the longest
    path problem, solving a subproblem optimally (i.e., finding the longest path from
    one node to another) does not guarantee that this subpath will be part of the
    overall longest path in the entire graph.</st> <st c="13129">For example, if you
    have found the longest path from vertex</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:math>](img/1640.png)
    <st c="13189"><st c="13190">to vertex</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:math>](img/1641.png)
    <st c="13201"><st c="13202">and then from vertex</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:math>](img/1642.png)
    <st c="13224"><st c="13225">to vertex</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:math>](img/1643.png)<st
    c="13236"><st c="13237">, the combination of these paths might not yield the longest
    path from</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:math>](img/1644.png)
    <st c="13308"><st c="13309">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:math>](img/1645.png)<st
    c="13313"><st c="13314">. The globally optimal solution might instead bypass</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:math>](img/1646.png)
    <st c="13367"><st c="13368">entirely if a longer alternative path</st> <st c="13407">is
    available.</st></st></st></st></st></st></st></st>'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12742">非加性特性</st>**<st c="12762">：在具有最优子结构的问题中，通常可以独立地解决子问题，然后将它们组合起来得到最优解。</st>
    <st c="12903">然而，在最长路径问题中，优化地解决一个子问题（即，从一个节点到另一个节点找到最长路径）并不能保证这个子路径将成为整个图中最优解的一部分。</st>
    <st c="13129">例如，如果你已经找到了从顶点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:math>](img/1640.png)
    <st c="13189"><st c="13190">到顶点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:math>](img/1641.png)
    <st c="13201"><st c="13202">，然后从顶点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:math>](img/1642.png)
    <st c="13224"><st c="13225">到顶点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:math>](img/1643.png)<st
    c="13236"><st c="13237">，这些路径的组合可能并不会产生从</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:math>](img/1644.png)
    <st c="13308"><st c="13309">到</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:math>](img/1645.png)<st
    c="13313"><st c="13314">的最长路径。</st> 可能全局最优解会绕过</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:math>](img/1646.png)
    <st c="13367"><st c="13368">，如果有一条更长的替代路径</st> <st c="13407">可用的话。</st></st></st></st></st></st></st></st>'
- en: '**<st c="13420">Example 10.2:</st>**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="13420">示例 10.2：</st>**'
- en: <st c="13434">Consider a weighted graph where the nodes are</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1478.png)<st
    c="13481"><st c="13482">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>B</mml:mi></mml:math>](img/1648.png)<st
    c="13484"><st c="13485">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>C</mml:mi></mml:math>](img/1649.png)<st
    c="13487"><st c="13488">, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1650.png)<st
    c="13494"><st c="13495">, and there are edges</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow></mrow></math>](img/1651.png)<st
    c="13517"><st c="13518">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>B</mi><mo>→</mo><mi>C</mi></mrow></mrow></math>](img/1652.png)<st
    c="13520"><st c="13521">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>C</mi><mo>→</mo><mi>D</mi></mrow></mrow></math>](img/1653.png)<st
    c="13523"><st c="13524">, and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>D</mi></mrow></mrow></math>](img/1654.png)<st
    c="13530"><st c="13531">. The longest path from</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)
    <st c="13555"><st c="13556">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1656.png)
    <st c="13560"><st c="13561">could initially seem like it might go through B and
    C.</st> <st c="13617">However, if the direct edge</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>D</mi></mrow></mrow></math>](img/1657.png)
    <st c="13645"><st c="13646">is longer than the sum of the paths</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow></mrow></math>](img/1658.png)<st
    c="13683"><st c="13684">, then the optimal solution doesn’t involve the longest
    paths from</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)
    <st c="13751"><st c="13752">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>B</mml:mi></mml:math>](img/1660.png)<st
    c="13756"><st c="13757">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>B</mml:mi></mml:math>](img/1660.png)
    <st c="13759"><st c="13760">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>C</mml:mi></mml:math>](img/106.png)
    <st c="13764"><st c="13765">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>C</mml:mi></mml:math>](img/106.png)
    <st c="13770"><st c="13771">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1664.png)<st
    c="13774"><st c="13775">.</st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13434">考虑一个加权图，其中节点为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1478.png)<st
    c="13481"><st c="13482">、</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>B</mml:mi></mml:math>](img/1648.png)<st
    c="13484"><st c="13485">、</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>C</mml:mi></mml:math>](img/1649.png)<st
    c="13487"><st c="13488">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1650.png)<st
    c="13494"><st c="13495">，且存在边</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow></mrow></math>](img/1651.png)<st
    c="13517"><st c="13518">、</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>B</mi><mo>→</mo><mi>C</mi></mrow></mrow></math>](img/1652.png)<st
    c="13520"><st c="13521">、</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>C</mi><mo>→</mo><mi>D</mi></mrow></mrow></math>](img/1653.png)<st
    c="13523"><st c="13524">和</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>D</mi></mrow></mrow></math>](img/1654.png)<st
    c="13530"><st c="13531">。从</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)
    <st c="13555"><st c="13556">到</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1656.png)
    <st c="13560"><st c="13561">的最远路径最初可能看起来会经过 B 和 C。</st> <st c="13617">然而，如果直接边</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>D</mi></mrow></mrow></math>](img/1657.png)
    <st c="13645"><st c="13646">比路径的总和更长</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow></mrow></math>](img/1658.png)<st
    c="13683"><st c="13684">，那么最优解并不涉及从</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)
    <st c="13751"><st c="13752">到</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>B</mml:mi></mml:math>](img/1660.png)<st
    c="13756"><st c="13757">、</st> ![<mml:math xmlns=mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>B</mml:mi></mml:math>](img/1660.png)
    <st c="13759"><st c="13760">到</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>C</mml:mi></mml:math>](img/106.png)
    <st c="13764"><st c="13765">，以及</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>C</mml:mi></mml:math>](img/106.png)
    <st c="13770"><st c="13771">到</st> ![<mml:math xmlns=mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1664.png)<st
    c="13774"><st c="13775">的最长路径。</st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st>
- en: <st c="13776">Obviously, the graph</st> <st c="13797">is directed and weighted.</st>
    <st c="13824">If the graph were undirected and unweighted, this scenario would
    be infeasible because it would violate the triangular inequality, which states
    that the direct distance between two points should be less than or equal to the
    sum of the distances through an intermediate point.</st> <st c="14100">However,
    even in a directed, unweighted graph like this, the result can</st> <st c="14172">be
    counterintuitive.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13776">显然，这个图是有向的且带权重的。</st> <st c="13797">如果这个图是无向图且无权重的，那么这个场景是不可行的，因为它违反了三角不等式，三角不等式指出，两个点之间的直接距离应该小于或等于经过中间点的距离之和。</st>
    <st c="14100">然而，即使在这样一个有向的无权重图中，结果也可能</st> <st c="14172">让人感到反直觉。</st>
- en: '<st c="14192">Let’s assume that the nodes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)<st
    c="14221"><st c="14222">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>B</mml:mi></mml:math>](img/1660.png)<st
    c="14224"><st c="14225">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>C</mml:mi></mml:math>](img/106.png)<st
    c="14227"><st c="14228">, and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi></mrow></math>](img/1668.png)<st
    c="14234"><st c="14235">represent four cities: Toronto, Chicago, Denver, and Los
    Angeles, respectively.</st> <st c="14315">The edges represent the ticket prices
    of direct flights.</st> <st c="14372">For example,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow></mrow></math>](img/1669.png)
    <st c="14385"><st c="14386">represents the ticket price of a direct flight from
    Toronto</st> <st c="14447">to Chicago.</st></st></st></st></st></st>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这些节点<st c="14192">代表</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)<st
    c="14221"><st c="14222">、</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>B</mml:mi></mml:math>](img/1660.png)<st
    c="14224"><st c="14225">、</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>C</mml:mi></mml:math>](img/106.png)<st
    c="14227"><st c="14228">和</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi></mrow></math>](img/1668.png)<st
    c="14234"><st c="14235">分别代表四个城市：多伦多、芝加哥、丹佛和洛杉矶。</st> <st c="14315">边表示直飞航班的票价。</st>
    <st c="14372">例如，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow></mrow></math>](img/1669.png)
    <st c="14385"><st c="14386">表示从多伦多到芝加哥的直飞航班票价。</st></st></st></st></st></st>
- en: <st c="14458">As depicted in</st> *<st c="14474">Figure 10</st>**<st c="14483">.2</st>*<st
    c="14485">, the longest path from Toronto to Los Angeles is achieved through a
    direct flight (represented by the edge</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>o</mi><mo>→</mo><mi>L</mi><mi>o</mi><mi>s</mi><mi>A</mi><mi>n</mi><mi>g</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>s</mi></mrow></mrow></math>](img/1670.png)
    <st c="14593"><st c="14614">with a weight of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>$</mml:mi><mml:mn>957</mml:mn></mml:math>](img/1671.png)<st
    c="14631"><st c="14632">) and does not include any stops in Chicago or Denver.</st>
    <st c="14687">This outcome might seem counterintuitive, as one might expect a
    longer path to involve more stops, but in this scenario, the direct flight is
    the most expensive and therefore forms the longest path in terms</st> <st c="14894">of
    cost.</st></st></st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14458">如在</st> *<st c="14474">图10</st>**<st c="14483">.2</st>*<st c="14485">中所示，从多伦多到洛杉矶的最远路径是通过一班直飞航班（由边</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>o</mi><mo>→</mo><mi>L</mi><mi>o</mi><mi>s</mi><mi>A</mi><mi>n</mi><mi>g</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>s</mi></mrow></mrow></math>](img/1670.png)
    <st c="14593"><st c="14614">，权重为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>$</mml:mi><mml:mn>957</mml:mn></mml:math>](img/1671.png)<st
    c="14631"><st c="14632">）且不包含任何在芝加哥或丹佛的停留。</st> <st c="14687">这个结果可能显得反直觉，因为人们通常认为，较长的路径会涉及更多的停留，但在这种情况下，直飞航班最贵，因此在成本方面形成了最长路径。</st>
    <st c="14894">。</st>
- en: <st c="14902">It’s also worth mentioning that in the absence of cycles in the
    graph, as in our simple example, one straightforward algorithm to solve the longest
    path problem is to negate all weights and then solve it as the shortest path problem.</st>
    <st c="15137">This transformation works because finding the shortest path in a
    graph with negated weights is equivalent to finding the longest path in the</st>
    <st c="15278">original graph.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14902">值得一提的是，在图中没有循环的情况下，正如我们简单的示例所示，解决最长路径问题的一个简单算法是将所有权重取负，然后将其作为最短路径问题来解决。</st>
    <st c="15137">这个转换之所以有效，是因为在一个负权图中寻找最短路径，相当于在原始图中寻找最长路径。</st>
- en: '![Figure 10.2: An example of the longest path problem](img/B22248_10_3.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2：最长路径问题的一个示例](img/B22248_10_3.jpg)'
- en: '<st c="15314">Figure 10.2: An example of the longest path problem</st>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15314">图 10.2：最长路径问题的一个示例</st>
- en: <st c="15365">The lack of optimal substructure in the longest path problem means
    that dynamic programming and</st> <st c="15461">similar techniques that rely on
    breaking a problem down into subproblems do not work effectively.</st> <st c="15560">This
    is because the longest path problem requires global knowledge of the graph’s structure
    and cannot simply be built up from smaller, independently solved subproblems.</st>
    <st c="15730">As a result, the longest path problem is typically more challenging
    to solve, especially in graphs that contain cycles and is not suited to approaches
    such as dynamic programming that rely on an</st> <st c="15925">optimal substructure.</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15365">最长路径问题缺乏最优子结构，这意味着动态规划以及类似的依赖于将问题分解为子问题的技术并不奏效。</st> <st c="15461">这是因为，最长路径问题需要图的全局知识，不能仅仅依赖从较小、独立解决的子问题逐步构建。</st>
    <st c="15560">因此，最长路径问题通常更具挑战性，尤其是在包含循环的图中，并且不适合依赖最优子结构的动态规划等方法。</st>
- en: <st c="15946">Overlapping subproblems</st>
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="15946">重叠子问题</st>
- en: <st c="15970">The second</st> <st c="15982">element of dynamic programming that
    distinguishes it from divide-and-conquer algorithms is the concept of overlapping
    subproblems.</st> <st c="16113">In a well-designed divide-and-conquer strategy,
    each recursive step typically solves a new, distinct subproblem.</st> <st c="16226">A
    good example of this is merge sort, where, during each partitioning step, the
    partitions do not overlap, and each subproblem is independent of</st> <st c="16371">the
    others.</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15970">动态规划的第二个特点，区分它与分治算法的地方，是重叠子问题的概念。</st> <st c="15982">在一个设计良好的分治策略中，每一步递归通常解决一个新的、独特的子问题。</st>
    <st c="16113">一个很好的例子是归并排序，在每一步划分中，划分之间不会重叠，并且每个子问题都是相互独立的。</st>
- en: <st c="16382">However, there are problems where certain subproblems overlap,
    meaning the same subproblems are solved multiple times in the recursive process.</st>
    <st c="16527">This is where dynamic programming excels by avoiding redundant computations.</st>
    <st c="16604">To illustrate this, let’s consider the Fibonacci series as</st>
    <st c="16663">an example.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16382">然而，也有一些问题，其中某些子问题会重叠，意味着在递归过程中同一个子问题会被解决多次。</st> <st c="16527">这正是动态规划的优势所在，它通过避免冗余计算来提升效率。</st>
    <st c="16604">为了说明这一点，我们可以考虑斐波那契数列作为一个例子。</st>
- en: <st c="16674">The Fibonacci series is defined</st> <st c="16707">as follows:</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16674">斐波那契数列的定义如下：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>F</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/1672.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>F</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/1672.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>F</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1673.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>F</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1673.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>F</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>F</mi><mfenced open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfenced><mo>+</mo><mi>F</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></mfenced><mi>f</mi><mi>o</mi><mi>r</mi><mi>n</mi><mo>≥</mo><mn>2</mn></mrow></mrow></math>](img/1674.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>F</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>F</mi><mfenced open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfenced><mo>+</mo><mi>F</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></mfenced><mi>f</mi><mi>o</mi><mi>r</mi><mi>n</mi><mo>≥</mo><mn>2</mn></mrow></mrow></math>](img/1674.png)'
- en: <st c="16753">When calculating Fibonacci numbers using a divide-and-conquer
    approach, the same subproblems are solved repeatedly.</st> <st c="16869">For instance,
    to compute</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>5</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1675.png)<st
    c="16894"><st c="16895">, the algorithm would need to calculate</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>4</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1676.png)
    <st c="16935"><st c="16936">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>3</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1677.png)<st
    c="16941"><st c="16942">. But to compute</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>4</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1678.png)<st
    c="16959"><st c="16960">, the algorithm again computes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>3</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1677.png)
    <st c="16991"><st c="16992">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1680.png)<st
    c="16997"><st c="16998">, meaning</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>3</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1681.png)
    <st c="17008"><st c="17009">is calculated multiple times.</st> <st c="17040">One
    way to avoid this redundancy is to store the results of previously computed subproblems
    in data structures with near-constant access time, such as a</st> <st c="17193">hash
    table.</st></st></st></st></st></st></st></st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16753">使用分治法计算斐波那契数时，相同的子问题会被反复求解。</st> <st c="16869">例如，为了计算</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>5</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1675.png)<st
    c="16894"><st c="16895">，算法需要计算</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>4</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1676.png)
    <st c="16935"><st c="16936">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>3</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1677.png)<st
    c="16941"><st c="16942">。但是为了计算</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>4</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1678.png)<st
    c="16959"><st c="16960">，算法又会计算</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>3</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1677.png)
    <st c="16991"><st c="16992">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1680.png)<st
    c="16997"><st c="16998">，这意味着</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>3</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1681.png)
    <st c="17008"><st c="17009">会被计算多次。</st> <st c="17040">避免这种冗余的方法之一是将之前计算的子问题结果存储在具有近乎常数访问时间的数据结构中，例如</st>
    <st c="17193">哈希表。</st></st></st></st></st></st></st></st>
- en: <st c="17204">This redundancy leads to an exponential time complexity, as the
    number of recursive calls grows exponentially with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1054.png)<st
    c="17320"><st c="17321">. This is where dynamic programming provides a significant
    advantage.</st> <st c="17391">Instead of solving the same subproblems repeatedly,
    dynamic programming stores the results of these subproblems and reuses them when
    needed, drastically reducing the number</st> <st c="17564">of computations.</st></st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17204">这种冗余导致了指数级的时间复杂度，因为递归调用的数量随着</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1054.png)<st
    c="17320"><st c="17321">增长呈指数级。这就是动态规划提供显著优势的地方。</st> <st c="17391">通过避免重复解决相同的子问题，动态规划存储这些子问题的结果，并在需要时重用它们，从而大大减少了计算次数。</st></st>
- en: <st c="17580">By leveraging overlapping subproblems, dynamic programming transforms
    the recursive solution for the Fibonacci series from an exponential time complexity</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1683.png)
    <st c="17735"><st c="17736">to a linear time complexity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1684.png)<st
    c="17765"><st c="17766">. This efficiency gain is why dynamic programming is preferred
    over divide-and-conquer approaches in problems where overlapping subproblems exist.</st>
    <st c="17913">In the next section, we will explore dynamic programming in more
    detail by examining</st> <st c="17998">several examples.</st></st></st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17580">通过利用重叠子问题，动态规划将斐波那契数列的递归解法从指数级时间复杂度</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1683.png)
    <st c="17735"><st c="17736">转换为线性时间复杂度</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1684.png)<st
    c="17765"><st c="17766">。这种效率提升是动态规划在存在重叠子问题的情况下优于分治法的原因。</st> <st c="17913">在下一节中，我们将通过几个示例更详细地探讨动态规划。</st>
    <st c="17998">接下来，我们将深入分析这些例子。</st></st></st>
- en: <st c="18015">Exploring dynamic programming</st>
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="18015">探索动态规划</st>
- en: '<st c="18045">One question</st> <st c="18059">that arises when we identify
    overlapping subproblems is: how can we store these solutions to avoid redundant
    computations?</st> <st c="18182">This is where dynamic programming introduces
    the concept of</st> **<st c="18242">memoization</st>**<st c="18253">. It</st>
    <st c="18258">involves storing the results of subproblems in a data structure,
    such as an array or a dictionary, so that when the same subproblem arises again,
    the stored result can be used immediately, eliminating the need</st> <st c="18468">for
    recalculation.</st>'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18045">一个问题</st> <st c="18059">当我们识别出重叠子问题时会出现：如何存储这些解以避免冗余的计算呢？</st>
    <st c="18182">这就是动态规划引入“记忆化”概念的地方。</st> **<st c="18242">记忆化</st>**<st c="18253">技术</st>
    <st c="18258">包括将子问题的结果存储在数据结构中，如数组或字典中，这样当相同的子问题再次出现时，可以立即使用已存储的结果，避免重新计算。</st>
    <st c="18468">从而省去了重新计算的必要。</st>
- en: <st c="18486">Before we begin, it’s important to clarify that “memoization”
    is not a misspelling of “memorization.” These two terms have distinct meanings.</st>
    <st c="18629">Memoization comes from the Latin word “memo,” which means “to be
    remembered.” It refers to a technique in computer science where the results of
    expensive function calls are stored and reused to avoid redundant calculations.</st>
    <st c="18853">In contrast, memorization refers to the process of learning and
    committing information to memory, often</st> <st c="18957">through repetition.</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18486">在我们开始之前，重要的是澄清一下，“记忆化”（memoization）并不是“记忆”（memorization）的拼写错误。这两个术语有着不同的含义。</st>
    <st c="18629">记忆化来源于拉丁语单词“memo”，意思是“要被记住”。它指的是计算机科学中的一种技术，其中昂贵的函数调用结果被存储并重用，以避免冗余的计算。</st>
    <st c="18853">相反，记忆是指通过学习和重复将信息记住的过程。</st> <st c="18957">通常是通过重复进行的。</st>
- en: <st c="18976">Memoization is a technique used in dynamic programming to optimize
    recursive algorithms by storing the results of expensive function calls and reusing
    them when the same inputs occur again.</st> <st c="19167">Instead of recomputing
    the same result multiple times, memoization saves the result of each subproblem
    the first time it is solved and then returns the stored result whenever the same
    subproblem is encountered again.</st> <st c="19384">This significantly reduces
    the time complexity of algorithms that have</st> <st c="19455">overlapping subproblems.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18976">记忆化是一种在动态规划中使用的技术，通过存储代价较高的函数调用的结果，并在相同输入再次出现时重用它们，从而优化递归算法。</st>
    <st c="19167">记忆化避免了多次重新计算相同的结果，在第一次解决子问题时保存结果，然后每当再次遇到相同的子问题时返回存储的结果。</st> <st
    c="19384">这显著降低了具有</st> <st c="19455">重叠子问题</st> <st c="19384">的算法的时间复杂度。</st>
- en: <st c="19479">Let’s explore how memoization works.</st> <st c="19517">In a typical
    recursive algorithm, a function repeatedly calls itself with smaller inputs until
    it reaches a base case.</st> <st c="19636">Without memoization, the function might
    be called with the same inputs multiple times, resulting in redundant calculations.</st>
    <st c="19760">This inefficiency is common in straightforward recursive algorithms
    that use divide-and-conquer strategies.</st> <st c="19868">By storing the results
    of these repeated subproblems, memoization eliminates the need for these redundant
    calculations, making the algorithm</st> <st c="20009">more efficient.</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19479">让我们探讨记忆化是如何工作的。</st> <st c="19517">在典型的递归算法中，一个函数会不断地用更小的输入调用自己，直到达到基准情况。</st>
    <st c="19636">没有记忆化时，函数可能会用相同的输入被多次调用，从而导致冗余计算。</st> <st c="19760">这种低效在使用分治策略的直接递归算法中非常常见。</st>
    <st c="19868">通过存储这些重复的子问题的结果，记忆化消除了这些冗余计算，使算法变得</st> <st c="20009">更加高效。</st>
- en: <st c="20024">With memoization, when a function is called, the algorithm first
    checks whether the result for the given input is already stored.</st> <st c="20155">If
    it is, the stored result is returned immediately, avoiding redundant computation.</st>
    <st c="20240">The results of subproblems are stored in a data structure, typically
    a dictionary or an array, which acts as a lookup table.</st> <st c="20365">This
    table is often referred to as</st> <st c="20400">a</st> **<st c="20402">memo</st>**<st
    c="20406">.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20024">使用记忆化时，当一个函数被调用时，算法首先检查给定输入的结果是否已经被存储。</st> <st c="20155">如果已经存储，则立即返回存储的结果，避免冗余计算。</st>
    <st c="20240">子问题的结果被存储在一个数据结构中，通常是字典或数组，充当查找表。</st> <st c="20365">这个表通常被称为</st>
    <st c="20400">一个</st> **<st c="20402">记忆表</st>**<st c="20406">。</st>
- en: '**<st c="20407">Example 10.3:</st>**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="20407">例子 10.3：</st>**'
- en: <st c="20421">Let’s revisit the Fibonacci series example to illustrate memoization
    and compare it to the approach</st> <st c="20522">without memoization.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20421">让我们重新回顾斐波那契数列的例子，通过它来说明记忆化，并与不使用记忆化的方法进行比较。</st>
- en: <st c="20542">The Fibonacci sequence is defined</st> <st c="20577">as follows:</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20542">斐波那契数列定义为</st> <st c="20577">如下：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>F</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>0</mn></mrow></mrow></mrow></math>](img/1685.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>F</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>0</mn></mrow></mrow></mrow></math>](img/1685.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>F</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow></mrow></mrow></math>](img/1686.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>F</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow></mrow></mrow></math>](img/1686.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>F</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>F</mi><mfenced open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfenced><mo>+</mo><mi>F</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></mfenced><mi>f</mi><mi>o</mi><mi>r</mi><mi>n</mi><mo>≥</mo><mn>2</mn></mrow></mrow></math>](img/1687.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>F</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>F</mi><mfenced open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfenced><mo>+</mo><mi>F</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></mfenced><mi>f</mi><mi>o</mi><mi>r</mi><mi>n</mi><mo>≥</mo><mn>2</mn></mrow></mrow></math>](img/1687.png)'
- en: <st c="20620">Without memoization</st>
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="20620">没有记忆化时</st>
- en: <st c="20639">The following is</st> <st c="20657">a simple Python implementation
    of the Fibonacci sequence using a naive</st> <st c="20728">recursive approach:</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20639">以下是</st> <st c="20657">使用朴素递归方法实现斐波那契数列的一个简单 Python 实现：</st>
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="20860">This approach has an exponential time complexity</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1688.png)
    <st c="20910"><st c="20911">because it recalculates the same Fibonacci numbers</st>
    <st c="20963">multiple times.</st></st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20860">这种方法具有指数时间复杂度</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1688.png)
    <st c="20910"><st c="20911">因为它会重新计算相同的斐波那契数</st> <st c="20963">多次。</st></st>
- en: <st c="20978">First, let’s analyze the complexity of the recursive Fibonacci
    series algorithm.</st> <st c="21060">This algorithm divides the problem into two
    subproblems, where the sizes of the subproblems are reduced by one and two, respectively.</st>
    <st c="21194">The recursive part has two components, while the driving function,
    which computes the sum of the two previous Fibonacci numbers, operates in constant</st>
    <st c="21344">time (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>c</mml:mi></mml:math>](img/1689.png)<st
    c="21350"><st c="21366">).</st></st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20978">首先，让我们分析递归斐波那契数列算法的复杂性。</st> <st c="21060">该算法将问题分解为两个子问题，子问题的规模分别减少了一个和两个。</st>
    <st c="21194">递归部分有两个组件，而驱动函数用于计算前两个斐波那契数的和，并在常数</st> <st c="21344">时间内操作（</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>c</mml:mi></mml:math>](img/1689.png)<st
    c="21350"><st c="21366">)。</st></st>
- en: <st c="21368">The recurrence function for this algorithm can be expressed</st>
    <st c="21429">as follows:</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21368">这个算法的递归关系可以表示为</st> <st c="21429">如下：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1690.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1690.png)'
- en: <st c="21478">This recurrence does not fit neatly into the standard forms for
    divide-and-conquer or subtracting recurrence functions.</st> <st c="21598">Therefore,
    we simplify it</st> <st c="21624">as follows:</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21478">这个递归关系并不完全符合分治法或减法递归函数的标准形式。</st> <st c="21598">因此，我们将其简化为</st>
    <st c="21624">如下：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo>≈</mml:mo><mml:mn>2</mml:mn><mml:mfenced
    separators="|"><mml:mrow><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1691.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo>≈</mml:mo><mml:mn>2</mml:mn><mml:mfenced
    separators="|"><mml:mrow><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1691.png)'
- en: <st c="21637">With this</st> <st c="21647">simplification, the recurrence function
    resembles a form that can be analyzed using the Master Theorem for subtracting
    recurrences (see</st> [*<st c="21783">Chapter 5</st>*](B22248_05_split_000.xhtml#_idTextAnchor062)<st
    c="21792">).</st> <st c="21796">According to the Master Theorem, since</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo></mrow></mrow></math>](img/1692.png)<st
    c="21835"><st c="21836">2 and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/1693.png)<st
    c="21842"><st c="21845">, the time complexity of the recursive Fibonacci sequence
    algorithm</st> <st c="21913">is this:</st></st></st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21637">通过这种</st> <st c="21647">简化，递归函数呈现出一种可以使用主定理分析的形式（见</st> [*<st
    c="21783">第五章</st>*](B22248_05_split_000.xhtml#_idTextAnchor062)<st c="21792">）。</st>
    <st c="21796">根据主定理，由于</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo></mrow></mrow></math>](img/1692.png)<st
    c="21835"><st c="21836">2 且</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/1693.png)<st
    c="21842"><st c="21845">，递归斐波那契数列算法的时间复杂度为：</st></st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo>⋅</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1694.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo>⋅</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1694.png)'
- en: <st c="21950">This result shows that the recursive Fibonacci algorithm has exponential
    time complexity, specifically</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1695.png)<st
    c="22053"><st c="22054">, making it inefficient for large values of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="22098"><st c="22099">. This inefficiency is why memoization or dynamic programming
    is often used to optimize the computation of</st> <st c="22206">Fibonacci numbers.</st></st></st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21950">这个结果显示，递归的斐波那契算法具有指数时间复杂度，具体为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1695.png)<st
    c="22053"><st c="22054">，使得它在处理大值时效率低下</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="22098"><st c="22099">。这种低效是为什么备忘录技术或动态规划常用于优化斐波那契数的计算。</st></st></st>
- en: '![Figure 10.3: The tree demonstrating the non-memoized approach to calculating
    Fibonacci(5)](img/B22248_10_4.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3：展示计算斐波那契(5)的非备忘录方法的树形图](img/B22248_10_4.jpg)'
- en: '<st c="22478">Figure 10.3: The tree demonstrating the non-memoized approach
    to calculating Fibonacci(5)</st>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22478">图 10.3：展示计算斐波那契(5)的非备忘录方法的树形图</st>
- en: '*<st c="22567">Figure 10</st>**<st c="22577">.3</st>* <st c="22579">illustrates
    an example of the tree representing a divide-and-conquer (non-memoized) implementation
    to calculate Fibonacci(5).</st> <st c="22706">As shown, the leaf nodes repeatedly
    consist of Fibonacci(1) and Fibonacci(0).</st> <st c="22784">Additionally, many
    Fibonacci numbers are recalculated multiple times throughout</st> <st c="22864">the
    process.</st>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="22567">图 10</st>**<st c="22577">.3</st>* <st c="22579">展示了一个树形结构的例子，表示用于计算斐波那契(5)的分治（非备忘录）实现。</st>
    <st c="22706">如图所示，叶节点重复包含斐波那契(1)和斐波那契(0)。</st> <st c="22784">此外，许多斐波那契数在整个过程中被重复计算多次。</st>'
- en: <st c="22876">With memoization</st>
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="22876">使用备忘录技术</st>
- en: <st c="22893">By applying memoization, the algorithm avoids redundant calculations.</st>
    <st c="22964">Here is a simple Python</st> <st c="22987">implementation of the
    Fibonacci sequence using dynamic programming, which uses memoization to optimize</st>
    <st c="23091">the calculation:</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22893">通过应用备忘录技术，该算法避免了冗余的计算。</st> <st c="22964">这是一个简单的 Python</st>
    <st c="22987">实现斐波那契数列的动态规划实现，它使用备忘录技术来优化</st> <st c="23091">计算：</st>
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="23300">In this version, the time complexity is reduced to</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1697.png)<st
    c="23352"><st c="23353">, because each Fibonacci number is computed only once
    and then stored for</st> <st c="23427">future reference.</st></st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23300">在这个版本中，时间复杂度被降低为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1697.png)<st
    c="23352"><st c="23353">，因为每个斐波那契数仅计算一次，并存储以供</st> <st c="23427">以后参考。</st></st>
- en: '![Figure 10.4: The graph demonstrating the memoized approach to calculating
    Fibonacci(8)](img/B22248_10_5.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4：展示计算斐波那契(8)的备忘录方法的图表](img/B22248_10_5.jpg)'
- en: '<st c="23446">Figure 10.4: The graph demonstrating the memoized approach to
    calculating Fibonacci(8)</st>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23446">图 10.4：演示计算斐波那契(8)的备忘录方法的图表</st>
- en: '*<st c="23532">Figure 10</st>**<st c="23542">.4</st>* <st c="23544">illustrates
    the graph representing the dynamic programming approach (using memoization) to
    calculate Fibonacci(8).</st> <st c="23660">In this approach, no Fibonacci number
    is redundantly recalculated.</st> <st c="23727">Instead, previously solved subproblems
    are reused, which is reflected in the edges extending from nodes.</st> <st c="23832">This
    reuse of subproblems is why we visualize divide-and-conquer algorithms with trees
    (</st>*<st c="23920">Figure 10</st>**<st c="23930">.3</st>*<st c="23932">), while
    dynamic programming is better represented with graphs (</st>*<st c="23997">Figure
    10</st>**<st c="24007">.4</st>*<st c="24009">).</st>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="23532">图 10</st>**<st c="23542">.4</st>* <st c="23544">展示了使用备忘化的动态规划方法来计算
    Fibonacci(8) 的图示。</st> <st c="23660">在这种方法中，没有任何斐波那契数被重复计算。</st> <st c="23727">相反，之前解决过的子问题会被重用，这在从节点延伸出的边中得以体现。</st>
    <st c="23832">这种对子问题的重用是我们使用树形结构可视化分治算法的原因（</st>*<st c="23920">图 10</st>**<st
    c="23930">.3</st>*<st c="23932">），而动态规划更适合用图形来表示（</st>*<st c="23997">图 10</st>**<st
    c="24007">.4</st>*<st c="24009">）。</st>'
- en: <st c="24012">Memoization is crucial in dynamic programming, especially for
    problems with overlapping subproblems.</st> <st c="24114">By storing the results
    of these subproblems, memoization minimizes the number of calculations required
    to solve the overall problem, leading to significant improvements in time complexity.</st>
    <st c="24303">However, this benefit comes at the cost of additional</st> <st c="24356">space
    for storing these results.</st> <st c="24390">This tradeoff is usually favorable
    in scenarios where time efficiency is more critical.</st> <st c="24478">It’s important
    to note that memoization is typically employed in a top-down dynamic programming
    approach, where the problem is solved recursively, and results are stored as they
    are computed.</st> <st c="24670">In the upcoming subsection, we briefly discuss
    top-down and bottom-up</st> <st c="24740">dynamic programming.</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24012">备忘化在动态规划中至关重要，尤其是对于有重叠子问题的问题。</st> <st c="24114">通过存储这些子问题的结果，备忘化最小化了解决整体问题所需的计算次数，从而显著提高了时间复杂度。</st>
    <st c="24303">然而，这一好处是以额外的</st> <st c="24356">存储空间为代价的。</st> <st c="24390">这种权衡通常在时间效率更为关键的场景中是有利的。</st>
    <st c="24478">需要注意的是，备忘化通常用于自顶向下的动态规划方法中，在这种方法中，问题是递归地解决的，结果在计算时就会被存储。</st> <st
    c="24670">在接下来的子章节中，我们将简要讨论自顶向下和自底向上</st> <st c="24740">动态规划。</st>
- en: <st c="24760">Top-down versus bottom-up approaches for dynamic programming</st>
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="24760">自顶向下与自底向上动态规划方法</st>
- en: '<st c="24821">There are</st> <st c="24831">two main approaches to implementing
    dynamic programming: top-down and bottom-up.</st> <st c="24913">Both approaches
    aim to reduce computational complexity by avoiding redundant calculations, but
    they do so in</st> <st c="25022">different ways.</st>'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24821">实现动态规划有</st> <st c="24831">两种主要方法：自顶向下和自底向上。</st> <st c="24913">这两种方法都旨在通过避免冗余计算来降低计算复杂度，但它们的实现方式</st>
    <st c="25022">不同。</st>
- en: <st c="25037">Top-down dynamic programming, also known as memoization, is a
    recursive approach.</st> <st c="25120">It starts solving the problem from the
    top, breaking it down into smaller subproblems.</st> <st c="25207">As the algorithm
    solves these subproblems, it stores its results in a data structure (usually a
    dictionary or an array) so that if the same subproblem needs to be solved again,
    the stored result can be used directly instead of</st> <st c="25434">recalculating
    it.</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25037">自顶向下的动态规划，也叫做备忘化，是一种递归方法。</st> <st c="25120">它从顶部开始解决问题，逐步将其分解为更小的子问题。</st>
    <st c="25207">当算法解决这些子问题时，它会将结果存储在一个数据结构中（通常是字典或数组），这样如果相同的子问题需要再次解决时，就可以直接使用已存储的结果，而不是</st>
    <st c="25434">重新计算它。</st>
- en: <st c="25451">The top-down process begins with the original problem and recursively
    breaks it down into smaller subproblems.</st> <st c="25563">Each time a subproblem
    is solved, its result is stored (memoized).</st> <st c="25630">If a subproblem
    is encountered again, the algorithm retrieves the stored result instead of</st>
    <st c="25721">recomputing it.</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25451">自顶向下的过程从原始问题开始，递归地将其分解为更小的子问题。</st> <st c="25563">每次解决一个子问题时，结果会被存储（备忘化）。</st>
    <st c="25630">如果再次遇到该子问题，算法会检索已存储的结果，而不是</st> <st c="25721">重新计算它。</st>
- en: <st c="25736">The top-down approach is relatively straightforward to implement,
    particularly when adapting from a divide-and-conquer recursive solution.</st>
    <st c="25876">In top-down dynamic programming, only the subproblems essential
    to solving the original problem are addressed, which can be advantageous if certain
    subproblems aren’t needed.</st> <st c="26051">However, this approach does have
    its drawbacks.</st> <st c="26099">It may require more memory due to the need to
    store recursive function calls on the call stack.</st> <st c="26195">Additionally,
    deep recursion can result in a stack overflow when dealing with very large problems.</st>
    *<st c="26294">Example 10.3</st>* <st c="26306">illustrates the memoized version
    of the Fibonacci sequence calculation, serving as a classic example of top-down</st>
    <st c="26420">dynamic programming.</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25736">自顶向下方法相对较容易实现，特别是从分治递归解决方案适应而来。</st> <st c="25876">在自顶向下动态规划中，只处理解决原问题必要的子问题，这在某些子问题不需要时可以是有利的。</st>
    <st c="26051">然而，这种方法也有其缺点。</st> <st c="26099">由于需要在调用堆栈上存储递归函数调用，可能需要更多的内存。</st>
    *<st c="26294">例子 10.3</st>* <st c="26306">说明了斐波那契数列计算的备忘录版本，是自顶向下</st> <st c="26420">动态规划的经典示例。</st>
- en: <st c="26440">The alternative to the top-down approach is the bottom-up implementation
    of dynamic programming.</st> <st c="26538">Bottom-up dynamic programming, also
    known as tabulation, is an iterative method.</st> <st c="26619">It begins by solving
    the smallest subproblems first and then uses those solutions to build up to the
    solution of the original problem.</st> <st c="26754">In this approach, a table
    (usually an array) is created, with each entry representing the solution to a
    subproblem.</st> <st c="26870">The process starts by addressing the base cases
    and solving the smallest subproblems first.</st> <st c="26962">The solutions are
    stored in the table and then iteratively used to tackle larger subproblems, ultimately
    leading to the</st> <st c="27082">final solution.</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26440">自顶向下方法的替代方案是动态规划的自底向上实现。</st> <st c="26538">自底向上动态规划，也称为表格法，是一种迭代方法。</st>
    <st c="26619">它从解决最小的子问题开始，然后利用这些解来构建原问题的解。</st> <st c="26754">在这种方法中，创建一个表（通常是一个数组），每个条目代表一个子问题的解。</st>
    <st c="26870">该过程从处理基本情况开始，并首先解决最小的子问题。</st> <st c="26962">解决方案存储在表中，然后迭代使用它们来解决更大的子问题，最终导致</st>
    <st c="27082">最终解。</st>
- en: <st c="27097">The</st> <st c="27101">bottom-up approach is generally more space-efficient
    than the top-down method because it avoids the overhead associated with recursive
    function calls.</st> <st c="27253">Additionally, it eliminates the risk of stack
    overflow by using an iterative process instead of recursion.</st> <st c="27360">This
    approach often provides a clearer view of how the solution is constructed, making
    it easier to manage and understand.</st> <st c="27483">However, the bottom-up
    approach has two significant drawbacks.</st> <st c="27546">First, it requires
    solving all subproblems, even those that may not be necessary for the final solution.</st>
    <st c="27651">Additionally, it can be more complex to implement initially, particularly
    when transitioning from a</st> <st c="27751">recursive approach.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27097">自</st> <st c="27101">底向上方法通常比自顶向下方法更节省空间，因为它避免了递归函数调用的开销。</st>
    <st c="27253">此外，通过使用迭代过程而不是递归，它消除了堆栈溢出的风险。</st> <st c="27360">这种方法通常提供了解决方案构建方式的更清晰视角，使其更易于管理和理解。</st>
    <st c="27483">然而，自底向上方法有两个显著的缺点。</st> <st c="27546">首先，它需要解决所有子问题，即使对最终解也可能不必要。</st>
    <st c="27651">此外，在初始实现时可能更复杂，特别是从</st> <st c="27751">递归方法过渡时。</st>
- en: <st c="27770">The following is a Python implementation of bottom-up approach
    to the</st> <st c="27841">Fibonacci sequence:</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27770">以下是斐波那契数列的自底向上Python实现：</st>
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*<st c="28062">Table 10.1</st>* <st c="28073">provides a summary of the characteristics
    of both the top-down and bottom-up approaches in</st> <st c="28165">dynamic programming.</st>'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="28062">表格 10.1</st>* <st c="28073">总结了动态规划中自顶向下和自底向上方法的特点。</st>'
- en: '| **<st c="28185">Feature</st>** | **<st c="28193">Top-down (memoization)</st>**
    | **<st c="28216">Bottom-up (tabulation)</st>** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="28185">特点</st>** | **<st c="28193">自顶向下（记忆化）</st>** | **<st c="28216">自底向上（表格法）</st>**
    |'
- en: '| <st c="28239">Approach</st> | <st c="28248">Recursive, solves the problem
    from the top (main problem) and breaks it down</st> <st c="28326">into subproblems.</st>
    | <st c="28343">Iterative, solves the problem from the bottom (base cases) and
    builds up to the</st> <st c="28424">main problem.</st> |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| <st c="28239">方法</st> | <st c="28248">递归，从顶部（主要问题）开始解决问题，并将其拆分为</st> <st
    c="28326">子问题。</st> | <st c="28343">迭代，从底部（基本情况）开始解决问题，并逐步构建到</st> <st c="28424">主要问题。</st>
    |'
- en: '| <st c="28437">Space complexity</st> | <st c="28454">May use more memory due
    to the call stack, and</st> <st c="28502">memoization storage.</st> | <st c="28522">Typically
    uses less memory, as it mainly relies on a table</st> <st c="28582">or array.</st>
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| <st c="28437">空间复杂度</st> | <st c="28454">可能由于调用栈和</st> <st c="28502">记忆化存储使用更多内存。</st>
    | <st c="28522">通常使用较少的内存，因为它主要依赖于一个表</st> <st c="28582">或数组。</st> |'
- en: '| <st c="28591">Time complexity</st> | <st c="28607">Avoids re-computation
    by storing results of subproblems,</st> <st c="28665">generally</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1698.png)<st
    c="28675"><st c="28676">.</st></st> | <st c="28677">Also avoids re-computation,</st>
    <st c="28706">generally</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/450.png)<st
    c="28716"><st c="28717">.</st></st> |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| <st c="28591">时间复杂度</st> | <st c="28607">通过存储子问题的结果来避免重新计算，</st> <st c="28665">通常是</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1698.png)<st
    c="28675"><st c="28676">。</st></st> | <st c="28677">也避免了重新计算，</st> <st c="28706">通常是</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/450.png)<st
    c="28716"><st c="28717">。</st></st> |'
- en: '| <st c="28718">Ease</st> <st c="28724">of implementation</st> | <st c="28741">Easier
    to implement if transitioning from a naive</st> <st c="28792">recursive solution.</st>
    | <st c="28811">It might be harder to implement initially, especially if converting
    from a</st> <st c="28887">recursive approach.</st> |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| <st c="28718">实现难度</st> <st c="28724">实现难度</st> | <st c="28741">如果从朴素的</st>
    <st c="28792">递归解法过渡，通常更容易实现。</st> | <st c="28811">最初可能会更难实现，尤其是在转换自</st> <st
    c="28887">递归方法时。</st> |'
- en: '| <st c="28906">Risk of</st> <st c="28915">stack overflow</st> | <st c="28929">Higher
    risk due to</st> <st c="28949">deep recursion.</st> | <st c="28964">No risk, as
    it avoids</st> <st c="28987">recursion altogether.</st> |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| <st c="28906">栈溢出风险</st> | <st c="28915">由于</st> <st c="28929">深度递归，风险较高。</st>
    | <st c="28964">没有风险，因为它完全避免了</st> <st c="28987">递归。</st> |'
- en: '<st c="29008">Table 10.1: A comparison of top-down and bottom-up approaches</st>'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29008">表 10.1：自上而下与自下而上的方法对比</st>
- en: '<st c="29070">Both top-down</st> <st c="29085">and bottom-up approaches to
    dynamic programming achieve the same goal: optimizing the computation by avoiding
    redundant calculations.</st> <st c="29219">The choice between the two often depends
    on the specific problem, the programmer’s comfort with recursion or iteration,
    and the memory and performance constraints of the task at hand.</st> *<st c="29403">Table
    10.1</st>* <st c="29413">presents a comparison of the top-down and bottom-up approaches
    in</st> <st c="29480">dynamic programming.</st>'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29070">自上而下</st> <st c="29085">和自下而上的动态规划方法实现相同的目标：通过避免冗余计算来优化计算过程。</st>
    <st c="29219">两者之间的选择通常取决于特定问题、程序员对递归或迭代的熟悉程度以及任务的内存和性能约束。</st> *<st c="29403">表
    10.1</st>* <st c="29413">展示了动态规划中自上而下和自下而上的方法对比。</st>
- en: <st c="29500">Let’s take a moment to discuss how to calculate the time complexity
    of dynamic programming implementations.</st> <st c="29609">As we’ve noted, dynamic
    programming algorithms are better represented by directed graphs rather than trees.</st>
    <st c="29717">In</st> [*<st c="29720">Chapter 5</st>*](B22248_05_split_000.xhtml#_idTextAnchor062)<st
    c="29729">, we explored the use of recursion trees to estimate the time complexity
    of recursive algorithms.</st> <st c="29827">Here, instead of using trees, we’ll
    utilize a graph to visualize a dynamic</st> <st c="29902">programming algorithm.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29500">让我们花点时间讨论一下如何计算动态规划实现的时间复杂度。</st> <st c="29609">正如我们所指出的，动态规划算法更适合用有向图而非树来表示。</st>
    <st c="29717">在</st> [*<st c="29720">第5章</st>*](B22248_05_split_000.xhtml#_idTextAnchor062)<st
    c="29729">中，我们探讨了使用递归树来估算递归算法的时间复杂度。</st> <st c="29827">在这里，我们将不再使用树，而是利用图形来可视化动态规划算法。</st>
- en: <st c="29924">In a dynamic programming graph, nodes represent subproblems, and
    the edges emerging from these nodes represent the choices we encounter within
    each subproblem.</st> <st c="30085">We can interpret this from the perspective
    of the destination of the edges, given that the</st> <st c="30176">graph is directed.</st>
    <st c="30195">Each incoming edge to a node signifies a function call—this means
    the subproblem is being recalled rather than recalculated, as would happen in
    a typical</st> <st c="30349">divide-and-conquer approach.</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29924">在动态规划图中，节点表示子问题，从这些节点发出的边表示我们在每个子问题中遇到的选择。</st> <st c="30085">我们可以从边的目标节点的角度来解读这一点，因为图是有向的。</st>
    <st c="30176">每个指向节点的入边代表一个函数调用——这意味着子问题是被回忆而不是重新计算的，就像在典型的</st> <st c="30349">分治法中那样。</st>
- en: <st c="30377">Now, let’s assume there are</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)
    <st c="30406"><st c="30407">subproblems (or functions) in total, and each subproblem
    is recalled</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1701.png)
    <st c="30477"><st c="30478">times, where</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi></mrow></mrow></math>](img/1702.png)<st
    c="30492"><st c="30493">. The time complexity of this dynamic programming algorithm
    can be expressed</st> <st c="30570">as follows:</st></st></st></st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30377">现在，让我们假设总共有</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)
    <st c="30406"><st c="30407">个子问题（或函数），每个子问题被回忆</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1701.png)
    <st c="30477"><st c="30478">次，其中</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi></mrow></mrow></math>](img/1702.png)<st
    c="30492"><st c="30493">。这个动态规划算法的时间复杂度可以表示如下：</st> <st c="30570">如下所示：</st></st></st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mrow><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>m</mml:mi></mml:math>](img/1703.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mrow><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>m</mml:mi></mml:math>](img/1703.png)'
- en: <st c="30592">This approach typically results in a linear time complexity, particularly
    in cases where the number of subproblems</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/1358.png)
    <st c="30707"><st c="30708">is proportional to the size of the input</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="30750"><st c="30751">. In the worst-case scenario, where</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>m</mi><mo>=</mo><mi>n</mi></mrow></mrow></math>](img/1706.png)<st
    c="30787"><st c="30788">, each subproblem corresponds directly to a unique state
    of the input, and the algorithm must process each state</st> <st c="30901">exactly
    once.</st></st></st></st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30592">这种方法通常会导致线性时间复杂度，特别是在子问题的数量</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/1358.png)
    <st c="30707"><st c="30708">与输入的大小成正比的情况下</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="30750"><st c="30751">。在最坏的情况下，其中</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>m</mi><mo>=</mo><mi>n</mi></mrow></mrow></math>](img/1706.png)<st
    c="30787"><st c="30788">，每个子问题都直接对应输入的唯一状态，算法必须精确地处理每个状态</st> <st c="30901">一次。</st></st></st></st>
- en: <st c="30914">When this occurs, the dynamic programming algorithm efficiently
    computes the solution in</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1011.png)
    <st c="31004"><st c="31005">time.</st> <st c="31012">This is because the algorithm
    leverages the overlapping subproblems by storing their results and reusing them
    as needed, rather than recalculating them.</st> <st c="31165">As a result, the
    total number of operations is linearly related to the size of the input, avoiding
    the exponential time complexity that would occur if each subproblem were recomputed
    multiple times, as in naive</st> <st c="31376">recursive approaches.</st></st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30914">当这种情况发生时，动态规划算法会高效地在</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1011.png)
    <st c="31004"><st c="31005">时间内计算出解。</st> <st c="31012">这是因为算法通过存储并重用重叠的子问题的结果，而不是重新计算它们，从而避免了指数时间复杂度的产生。</st>
    <st c="31165">因此，总操作次数与输入的大小成线性关系，避免了在朴素</st> <st c="31376">递归方法中出现的指数时间复杂度。</st></st>
- en: <st c="31397">This linear time complexity is one of the key advantages of dynamic
    programming.</st> <st c="31479">It allows the algorithm to scale effectively with
    the size of the input, making it practical for solving large and complex problems
    that would otherwise be computationally infeasible using brute-force or</st> <st
    c="31683">divide-and-conquer strategies.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31397">这种线性时间复杂度是动态规划的一个关键优势。</st> <st c="31479">它使得算法能够有效地随着输入规模的变化进行扩展，从而使得解决大规模和复杂问题变得可行，而这些问题如果使用暴力法或</st>
    <st c="31683">分治策略将是计算上不可行的。</st>
- en: <st c="31713">Let’s apply the approach discussed earlier to analyze the time
    complexity of the dynamic programming implementation of the Fibonacci sequence,
    as shown in</st> *<st c="31869">Example 10.3</st>*<st c="31881">. By considering</st>
    *<st c="31898">Figure 10</st>**<st c="31907">.4</st>*<st c="31909">, which illustrates
    the graph representing the problem of calculating the Fibonacci of number 8 (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>8</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1708.png)<st
    c="32006"><st c="32008">), we can derive the</st> <st c="32029">time complexity.</st></st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31713">让我们应用前面讨论的方法来分析动态规划实现斐波那契数列的时间复杂度，如</st> *<st c="31869">示例 10.3</st>*<st
    c="31881">所示。通过考虑</st> *<st c="31898">图 10</st>**<st c="31907">.4</st>*<st c="31909">，该图表示计算斐波那契数列第8个数的图（</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>8</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1708.png)<st
    c="32006"><st c="32008">），我们可以推导出</st> <st c="32029">时间复杂度。</st></st>
- en: '<st c="32045">In the graph, each node corresponds to a subproblem—specifically,
    one of the Fibonacci numbers that needs to be computed.</st> <st c="32168">The
    graph for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>8</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1709.png)
    <st c="32182"><st c="32183">includes 8 nodes, each representing an overlapping
    subproblem.</st> <st c="32247">Additionally, each node in this graph has two choices:
    one corresponding to the function call for the previous Fibonacci number</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/1710.png)
    <st c="32375"><st c="32376">and the other for the Fibonacci number before that</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/1711.png)<st
    c="32428"><st c="32429">. These choices are depicted as outgoing edges from each
    node, or equivalently, two incoming edges to each node in</st> <st c="32544">the
    graph.</st></st></st></st>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32045">在图中，每个节点对应一个子问题——具体来说，就是需要计算的斐波那契数之一。</st> <st c="32168">![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>8</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1709.png)
    <st c="32182"><st c="32183">包括 8 个节点，每个节点代表一个重叠的子问题。</st> <st c="32247">此外，这个图中的每个节点都有两种选择：一种对应于前一个斐波那契数的函数调用</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/1710.png)
    <st c="32375"><st c="32376">和另一个对应于再前一个斐波那契数的函数调用</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/1711.png)<st
    c="32428"><st c="32429">。这些选择被描绘为每个节点的出边，或者等效地，作为每个节点的两条入边。</st> <st c="32544">在图中。</st></st></st></st>
- en: '<st c="32554">To calculate the</st> <st c="32572">time complexity, we observe
    that the graph structure results in every node (or subproblem) being processed
    once, with each node involving two operations: one for each of the outgoing edges.</st>
    <st c="32762">This results in a total of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>8</mn><mo>×</mo><mn>2</mn></mrow></mrow></math>](img/1712.png)
    <st c="32789"><st c="32790">operations</st> <st c="32802">for</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>8</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1708.png)<st
    c="32806"><st c="32807">.</st></st></st>'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32554">为了计算</st> <st c="32572">时间复杂度，我们观察到图结构导致每个节点（或子问题）只被处理一次，每个节点涉及两个操作：分别对应每个出边。</st>
    <st c="32762">这导致总共</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>8</mn><mo>×</mo><mn>2</mn></mrow></mrow></math>](img/1712.png)
    <st c="32789"><st c="32790">操作</st> <st c="32802">为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>8</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1708.png)<st
    c="32806"><st c="32807">。</st></st></st>
- en: <st c="32808">Generalizing this to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1714.png)<st
    c="32830"><st c="32831">, we observe that for any Fibonacci number</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1715.png)<st
    c="32874"><st c="32875">, the total number of operations can be expressed</st>
    <st c="32925">as follows:</st></st></st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32808">将这一推广到</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1714.png)<st
    c="32830"><st c="32831">，我们观察到对于任意斐波那契数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1715.png)<st
    c="32874"><st c="32875">，操作的总数可以表达为：</st> <st c="32925">如下：</st></st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1716.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1716.png)'
- en: <st c="32938">This formula shows that the dynamic programming approach to computing
    Fibonacci numbers of scales linearly with the input size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/98.png)<st
    c="33065"><st c="33066">. The efficiency is achieved because dynamic programming
    avoids redundant calculations by storing and reusing the results of subproblems
    (memoization), leading to a significant reduction in time complexity compared
    to the naive recursive approach, which has an exponential</st> <st c="33339">time
    complexity.</st></st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32938">该公式表明，动态规划计算斐波那契数列的方法随着输入规模呈线性增长</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/98.png)<st
    c="33065"><st c="33066">。这一效率是通过动态规划避免冗余计算，存储和重用子问题的结果（备忘录法）实现的，从而显著降低了时间复杂度，相较于朴素递归方法，其时间复杂度是指数级的</st>
    <st c="33339">时间复杂度。</st></st>
- en: <st c="33355">Let’s look at another classic example in the context of dynamic
    programming, which is the</st> **<st c="33446">knapsack problem</st>**<st c="33462">.</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33355">让我们来看另一个经典的动态规划例子，那就是</st> **<st c="33446">背包问题</st>**<st c="33462">。</st>
- en: <st c="33463">Solving the 0/1 knapsack problem using dynamic programming</st>
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="33463">使用动态规划解决0/1背包问题</st>
- en: <st c="33522">The</st> <st c="33527">knapsack problem is a classic</st> <st
    c="33557">optimization problem where the goal is to determine the maximum value
    that can be obtained</st> <st c="33647">by selecting items to include in a knapsack,
    subject to a weight capacity constraint.</st> <st c="33734">Each item has a specific
    weight and value, and the challenge is to choose the optimal combination of items
    to maximize the total value without exceeding the knapsack’s weight limit.</st>
    <st c="33916">Let’s assume we have a set of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/823.png)
    <st c="33946"><st c="33947">items, each with a weight</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1719.png)
    <st c="33974"><st c="33975">and a value</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1720.png)
    <st c="33988"><st c="33989">and a knapsack with a maximum weight capacity</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1721.png)<st
    c="34036"><st c="34037">. The objective is to maximize the total value</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/1722.png)
    <st c="34084"><st c="34085">of the items in the knapsack such that the</st> <st
    c="34129">following holds:</st></st></st></st></st></st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33522">背包问题是一个经典的</st> <st c="33527">优化问题，目标是确定通过选择物品放入背包，在满足重量限制的前提下能够获得的最大价值。</st>
    <st c="33647">每个物品都有特定的重量和价值，挑战在于选择最优的物品组合，以最大化总价值，同时不超过背包的重量限制。</st> <st c="33734">假设我们有一组</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/823.png)
    <st c="33946"><st c="33947">物品，每个物品都有一个重量</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1719.png)
    <st c="33974"><st c="33975">和一个价值</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1720.png)
    <st c="33988"><st c="33989">和一个最大重量容量为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1721.png)<st
    c="34036"><st c="34037">的背包。目标是最大化背包中物品的总价值，使得</st> <st c="34129">以下条件成立：</st></st></st></st></st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">max</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1723.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">max</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1723.png)'
- en: <st c="34147">subject to:</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34147">受限于：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mi>W</mml:mi></mml:math>](img/1724.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mi>W</mml:mi></mml:math>](img/1724.png)'
- en: <st c="34160">Depending</st> <st c="34169">on how we define</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1725.png)<st
    c="34187"><st c="34188">, we encounter the following types of</st> <st c="34226">knapsack
    problem:</st></st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34160">根据我们如何定义</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1725.png)<st
    c="34187"><st c="34188">，我们会遇到以下几种类型的</st> <st c="34226">背包问题：</st></st>
- en: <st c="34243">If</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0,1</mml:mn><mml:mo>}</mml:mo></mml:math>](img/1726.png)<st
    c="34247"><st c="34258">, the problem is known as the 0/1 knapsack problem.</st>
    <st c="34310">This is the problem we will focus on solving in</st> <st c="34358">this
    chapter.</st></st>
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="34243">如果</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0,1</mml:mn><mml:mo>}</mml:mo></mml:math>](img/1726.png)<st
    c="34247"><st c="34258">，这个问题被称为 0/1 背包问题。</st> <st c="34310">这是我们将在</st> <st
    c="34358">本章集中解决的问题。</st></st>
- en: <st c="34371">If</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0,1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>}</mml:mo></mml:math>](img/1727.png)<st
    c="34375"><st c="34394">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi></mml:math>](img/1728.png)
    <st c="34402"><st c="34403">is a constant, the</st> <st c="34422">problem is referred
    to as the</st> **<st c="34453">Bounded Knapsack</st>** **<st c="34470">Problem</st>**
    <st c="34477">(</st>**<st c="34479">BKP</st>**<st c="34482">).</st></st></st>
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="34371">如果</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0,1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>}</mml:mo></mml:math>](img/1727.png)<st
    c="34375"><st c="34394">，其中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi></mml:math>](img/1728.png)
    <st c="34402"><st c="34403">是一个常数，</st> <st c="34422">这个问题被称为</st> **<st c="34453">有界背包问题</st>**
    **<st c="34470">（BKP）</st>**<st c="34477">。</st></st></st>
- en: <st c="34485">If</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1729.png)
    <st c="34489"><st c="34490">can be any non-negative integer, the</st> <st c="34528">problem
    is called the</st> **<st c="34550">Unbounded Knapsack</st>** **<st c="34569">Problem</st>**
    <st c="34576">(</st>**<st c="34578">UKP</st>**<st c="34581">).</st></st>
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="34485">如果</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1729.png)
    <st c="34489"><st c="34490">可以是任何非负整数，那么</st> <st c="34528">该问题称为</st> **<st c="34550">无限背包问题</st>**
    **<st c="34569">问题</st>** <st c="34576">(</st>**<st c="34578">UKP</st>**<st c="34581">).</st></st>
- en: <st c="34584">First, let’s</st> <st c="34597">examine the complexity of the
    0/1 knapsack problem using a naïve approach.</st> <st c="34673">Given</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1730.png)
    <st c="34679"><st c="34680">items, a straightforward solution would involve generating
    all possible subsets of these</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="34770"><st c="34819">items, calculating the corresponding weight and value
    for each subset, and then identifying the optimal solution.</st> <st c="34933">This
    approach results in a time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1732.png)<st
    c="34979"><st c="34980">, making the problem non-polynomial and computationally
    infeasible for large values</st> <st c="35064">of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="35067"><st c="35116">.</st></st></st></st></st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34584">首先，让我们</st> <st c="34597">通过一种朴素的方法来分析0/1背包问题的复杂度。</st> <st c="34673">给定</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1730.png)
    <st c="34679"><st c="34680">个物品，一种直接的解决方案是生成这些</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="34770"><st c="34819">物品的所有可能子集，计算每个子集的对应重量和价值，然后确定最优解。</st> <st c="34933">这种方法的时间复杂度为</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1732.png)<st
    c="34979"><st c="34980">，使得该问题成为非多项式问题，对于较大的</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="35067"><st c="35116">值来说，计算上是不可行的。</st></st></st></st></st>
- en: <st c="35117">The goal is to solve the 0/1 knapsack problem using a dynamic
    programming approach.</st> <st c="35202">The knapsack problem exhibits both optimal
    substructure and overlapping subproblems, making it an ideal candidate for a dynamic</st>
    <st c="35330">programming solution.</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35117">目标是使用动态规划方法来解决0/1背包问题。</st> <st c="35202">背包问题具有最优子结构和重叠子问题的特性，使其成为动态</st>
    <st c="35330">规划解决方案的理想选择。</st>
- en: <st c="35351">Optimal substructure means that the optimal solution to a problem
    can consider a knapsack problem with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/322.png)
    <st c="35455"><st c="35456">items and capacity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1735.png)<st
    c="35476"><st c="35477">. Let’s assume we have an optimal solution for this problem.</st>
    <st c="35538">If we remove the last item from this optimal solution, the remaining
    items must form an optimal solution for a knapsack problem with</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math>](img/485.png)
    <st c="35671"><st c="35672">items and capacity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1721.png)
    <st c="35692"><st c="35693">minus the weight of the</st> <st c="35718">removed
    item.</st></st></st></st></st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最优子结构意味着问题的最优解可以看作一个背包问题，包含</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/322.png)
    <st c="35455"><st c="35456">项和容量</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1735.png)<st
    c="35476"><st c="35477">。假设我们已经有了该问题的最优解。</st> <st c="35538">如果我们从这个最优解中去除最后一项，那么剩下的项必须形成一个背包问题的最优解，包含</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math>](img/485.png)
    <st c="35671"><st c="35672">项和容量</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1721.png)
    <st c="35692"><st c="35693">减去被去除项的重量。</st>
- en: <st c="35731">In other words, the optimal solution to the larger problem (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="35792"><st c="35842">items, capacity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1721.png)<st
    c="35858"><st c="35859">) is composed of an optimal solution to a smaller subproblem
    (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1740.png)
    <st c="35921"><st c="35923">items, reduced capacity) plus the decision of whether
    to include the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/1741.png)
    <st c="35993"><st c="35996">item or not.</st> <st c="36009">This property allows
    us to break down the problem into smaller subproblems and solve them recursively,
    which is the foundation of the dynamic</st> <st c="36151">programming approach.</st></st></st></st></st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，较大问题（![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="35792"><st c="35842">项，容量</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1721.png)<st
    c="35858"><st c="35859">) 的最优解由一个较小子问题（![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1740.png)
    <st c="35921"><st c="35923">项，减少后的容量） 的最优解加上是否包括第</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/1741.png)
    <st c="35993"><st c="35996">项的决策组成。</st> <st c="36009">这一性质使得我们可以将问题分解为更小的子问题，并递归地求解它们，这是动态</st>
    <st c="36151">规划方法的基础。</st>
- en: <st c="36172">For example, if we</st> <st c="36192">have an optimal solution
    for a knapsack problem with 5 items and a capacity of 12, and we remove the fifth
    item, the remaining 4 items must form an optimal solution for a knapsack problem
    with 4 items and a capacity reduced by the weight of the</st> <st c="36437">fifth
    item.</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36172">例如，如果我们</st> <st c="36192">已经得到了一个包含 5 个物品和容量为 12 的背包问题的最优解，并且我们去除第五个物品，那么剩下的
    4 个物品必须形成一个包含 4 个物品且容量减少了第五个物品重量的最优解。</st>
- en: <st c="36448">Overlapping</st> <st c="36461">subproblems in this problem refer
    to the situation where the same subproblems are solved multiple times during the
    process of finding the optimal solution.</st> <st c="36617">When solving the 0/1
    knapsack problem using a recursive approach, we often find that the same subproblems
    are revisited.</st> <st c="36738">Specifically, when deciding whether to include
    or exclude an item from the knapsack, we are essentially solving the same problem
    but with reduced capacity or</st> <st c="36896">fewer items.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36448">重叠的</st> <st c="36461">子问题在这个问题中指的是在寻找最优解的过程中，同样的子问题被多次解决的情况。</st>
    <st c="36617">在使用递归方法解决 0/1 背包问题时，我们常常会发现相同的子问题被重复解决。</st> <st c="36738">具体来说，当决定是否将某个物品放入背包时，我们实际上是在解决相同的问题，只是背包容量减少了或</st>
    <st c="36896">物品数量减少了。</st>
- en: <st c="36908">Consider a simple example with three items, and a knapsack capacity</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>5</mn></mrow></mrow></math>](img/1742.png)<st
    c="36977"><st c="36978">. Each item has a weight</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>_</mml:mo><mml:mi>i</mml:mi></mml:math>](img/1743.png)
    <st c="37003"><st c="37004">and a</st> <st c="37011">value</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>v</mml:mi><mml:mo>_</mml:mo><mml:mi>i</mml:mi></mml:math>](img/1744.png)<st
    c="37017"><st c="37018">:</st></st></st></st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36908">考虑一个包含三个物品和背包容量为</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>5</mn></mrow></mrow></math>](img/1742.png)<st
    c="36977"><st c="36978">的简单例子。每个物品都有一个重量</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>_</mml:mo><mml:mi>i</mml:mi></mml:math>](img/1743.png)
    <st c="37003"><st c="37004">和一个</st> <st c="37011">价值</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>v</mml:mi><mml:mo>_</mml:mo><mml:mi>i</mml:mi></mml:math>](img/1744.png)<st
    c="37017"><st c="37018">：</st></st></st></st>
- en: <st c="37019">Item</st> <st c="37024">1:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math>](img/1745.png)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="37019">物品</st> <st c="37024">1:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math>](img/1745.png)
- en: <st c="37028">Item</st> <st c="37033">2:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:math>](img/1746.png)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="37028">物品</st> <st c="37033">2:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:math>](img/1746.png)
- en: <st c="37037">Item</st> <st c="37042">3:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math>](img/1747.png)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 3：![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math>](img/1747.png)
- en: <st c="37046">When solving this problem recursively, we might face the</st>
    <st c="37103">following subproblems:</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 递归解决这个问题时，我们可能会遇到以下子问题：
- en: '<st c="37125">Including Item 1: This leads to solving the subproblem with the
    remaining capacity</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1748.png)
    <st c="37209"><st c="37210">and the remaining items (Item 2 and</st> <st c="37247">Item
    3)</st></st>'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括项目 1：这会导致解决剩余容量为的子问题 ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1748.png)
    <st c="37209"><st c="37210">和剩余的项目（项目 2 和</st> <st c="37247">项目 3)</st></st>
- en: '<st c="37254">Excluding Item 1: This leads to solving the subproblem with the
    full capacity</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>5</mn></mrow></mrow></math>](img/1749.png)
    <st c="37333"><st c="37334">and the remaining items (Item 2 and</st> <st c="37371">Item
    3)</st></st>'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不包括项目 1：这会导致解决带有完全容量的子问题 ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>5</mn></mrow></mrow></math>](img/1749.png)
    <st c="37333"><st c="37334">和剩余的项目（项目 2 和</st> <st c="37371">项目 3)</st></st>
- en: <st c="37378">However, when we move on to consider Item 2, you will again encounter
    the</st> <st c="37453">same subproblems:</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们考虑项目 2 时，你将再次遇到</st> <st c="37453">相同的子问题：</st>
- en: '<st c="37470">Including Item 2: Solves the problem with a capacity of</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/1750.png)
    <st c="37527"><st c="37528">(if Item 1 was included) or</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1751.png)
    <st c="37557"><st c="37558">(if Item 1 was excluded) and the remaining item (</st><st
    c="37608">Item 3)</st></st></st>'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括项目 2：解决容量为的**问题** ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/1750.png)
    <st c="37527"><st c="37528">(如果包含项目 1) 或</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1751.png)
    <st c="37557"><st c="37558">(如果不包含项目 1) 和剩余项目（</st><st c="37608">项目 3)</st></st></st>
- en: '<st c="37616">Excluding Item 2: Solves the problem with the current capacity
    and just Item</st> <st c="37694">3 remaining</st>'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不包括项目 2：解决当前容量的问题，剩余只有项目</st> <st c="37694">3</st> 剩下
- en: <st c="37705">As we can see, some subproblems (e.g., the subproblem with</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1752.png)
    <st c="37765"><st c="37766">and Item 3) are encountered multiple times.</st> <st
    c="37811">Without dynamic programming, we would solve these subproblems repeatedly,
    leading to</st> <st c="37896">unnecessary computations.</st></st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，一些子问题（例如，带有的子问题） ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1752.png)
    <st c="37765"><st c="37766">和项目 3）会多次出现。</st> <st c="37811">如果没有动态规划，我们将反复解决这些子问题，导致</st>
    <st c="37896">不必要的计算。</st></st>
- en: <st c="37921">Now that we</st> <st c="37933">have a clear understanding of the
    two essential elements of dynamic programming in the 0/1 knapsack problem, let’s
    walk through the</st> <st c="38066">step-by-step solution:</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚理解了0/1背包问题中动态规划的两个基本要素，让我们一步步地走过</st> <st c="38066">解决方案：</st>
- en: <st c="38088">Create</st> <st c="38095">a two-dimensional table</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi></mml:math>](img/1172.png)
    <st c="38120"><st c="38121">with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1754.png)
    <st c="38127"><st c="38131">rows and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1755.png)
    <st c="38140"><st c="38142">columns, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1055.png)
    <st c="38157"><st c="38158">is the number of items and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1721.png)
    <st c="38186"><st c="38187">is the total capacity of the knapsack.</st> <st c="38227">Let</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>d</mi><mo>(</mo><mi>i</mi><mo>,</mo><mi>w</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1758.png)
    <st c="38231"><st c="38241">represent the maximum value that can be obtained using
    the first</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="38306"><st c="38307">items with a knapsack capacity of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi></mml:math>](img/1760.png)<st
    c="38342"><st c="38343">. For instance,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>d</mi><mo>(</mo><mn>4</mn><mo>,</mo><mn>5</mn><mo>)</mo></mrow></mrow></mrow></math>](img/1761.png)
    <st c="38359"><st c="38364">would represent the maximum value achievable with
    the first 4 items, assuming the knapsack has a maximum capacity of 5, even though
    the actual capacity might</st> <st c="38522">be greater.</st></st></st></st></st></st></st></st></st></st>
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38088">创建</st> <st c="38095">一个二维表格</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi></mml:math>](img/1172.png)
    <st c="38120"><st c="38121">，其中有</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1754.png)
    <st c="38127"><st c="38131">行和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1755.png)
    <st c="38140"><st c="38142">列，其中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1055.png)
    <st c="38157"><st c="38158">表示物品数量，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1721.png)
    <st c="38186"><st c="38187">表示背包的总容量。</st> <st c="38227">令</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>d</mi><mo>(</mo><mi>i</mi><mo>,</mo><mi>w</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1758.png)
    <st c="38231"><st c="38241">表示使用前</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="38306"><st c="38307">个物品，且背包容量为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi></mml:math>](img/1760.png)<st
    c="38342"><st c="38343">时所能获得的最大值。例如，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>d</mi><mo>(</mo><mn>4</mn><mo>,</mo><mn>5</mn><mo>)</mo></mrow></mrow></mrow></math>](img/1761.png)
    <st c="38359"><st c="38364">表示使用前4个物品，假设背包最大容量为5时能达到的最大值，尽管实际容量可能</st> <st c="38522">更大。</st>
- en: <st c="38533">Initialize the first row</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1762.png)
    <st c="38559"><st c="38560">and first column</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1763.png)<st
    c="38578"><st c="38579">, which means</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/1764.png)
    <st c="38593"><st c="38594">for all</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="38603"><st c="38604">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/1766.png)
    <st c="38609"><st c="38610">for all</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi></mml:math>](img/1760.png)<st
    c="38619"><st c="38620">. Let’s assume we have three items with the following
    weights and values:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1,3</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo>}</mml:mo></mml:math>](img/1768.png)
    <st c="38694"><st c="38698">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>15,20,30</mml:mn><mml:mo>}</mml:mo></mml:math>](img/1769.png)
    <st c="38702"><st c="38708">and the knapsack capacity is 6\.</st> <st c="38740">(see</st>
    *<st c="38745">Table 10.2</st>*<st c="38755">).</st>
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38533">初始化第一行</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1762.png)
    <st c="38559"><st c="38560">和第一列</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1763.png)<st
    c="38578"><st c="38579">，这意味着</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/1764.png)
    <st c="38593"><st c="38594">对于所有</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="38603"><st c="38604">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/1766.png)
    <st c="38609"><st c="38610">对于所有</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi></mml:math>](img/1760.png)<st
    c="38619"><st c="38620">. 假设我们有三个物品，其重量和价值如下：</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1,3</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo>}</mml:mo></mml:math>](img/1768.png)
    <st c="38694"><st c="38698">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>15,20,30</mml:mn><mml:mo>}</mml:mo></mml:math>](img/1769.png)
    <st c="38702"><st c="38708">并且背包容量是6。</st> <st c="38740">(见</st> *<st c="38745">表10.2</st>*<st
    c="38755">)。</st>
- en: '|  | ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>w</mml:mi></mml:math>](img/1760.png) |'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>w</mml:mi></mml:math>](img/1760.png) |'
- en: '| ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>i</mml:mi></mml:math>](img/701.png) |  | <st c="38761">0</st>
    | <st c="38762">1</st> | <st c="38763">2</st> | <st c="38764">3</st> | <st c="38765">4</st>
    | <st c="38766">5</st> | <st c="38767">6</st> |'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>i</mml:mi></mml:math>](img/701.png) |  | <st c="38761">0</st>
    | <st c="38762">1</st> | <st c="38763">2</st> | <st c="38764">3</st> | <st c="38765">4</st>
    | <st c="38766">5</st> | <st c="38767">6</st> |'
- en: '| <st c="38768">0</st> | <st c="38769">0</st> | <st c="38770">0</st> | <st
    c="38771">0</st> | <st c="38772">0</st> | <st c="38773">0</st> | <st c="38774">0</st>
    | <st c="38775">0</st> |'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| <st c="38768">0</st> | <st c="38769">0</st> | <st c="38770">0</st> | <st
    c="38771">0</st> | <st c="38772">0</st> | <st c="38773">0</st> | <st c="38774">0</st>
    | <st c="38775">0</st> |'
- en: '| <st c="38776">1</st> | <st c="38777">0</st> |  |  |  |  |  |  |'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| <st c="38776">1</st> | <st c="38777">0</st> |  |  |  |  |  |  |'
- en: '| <st c="38778">2</st> | <st c="38779">0</st> |  |  |  |  |  |  |'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| <st c="38778">2</st> | <st c="38779">0</st> |  |  |  |  |  |  |'
- en: '| <st c="38780">3</st> | <st c="38781">0</st> |  |  |  |  |  |  |</st></st></st></st></st></st></st></st>'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| <st c="38780">3</st> | <st c="38781">0</st> |  |  |  |  |  |  |</st></st></st></st></st></st></st></st>'
- en: '<st c="38782">Table 10.2: Initializing table</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">D</mml:mi></mml:math>](img/1772.png)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38782">表格 10.2：初始化表格</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">D</mml:mi></mml:math>](img/1772.png)
- en: <st c="38814">Populate the table by the</st> <st c="38840">following rules:</st>
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38814">通过以下规则填充表格：</st> <st c="38840">以下规则：</st>
- en: <st c="38856">For each item</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="38871"><st c="38872">and</st> <st c="38877">weight</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1774.png)<st
    c="38884"><st c="38885">:</st></st></st>
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38856">对于每个项</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="38871"><st c="38872">和</st> <st c="38877">重量</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1774.png)<st
    c="38884"><st c="38885">：</st></st></st>
- en: <st c="38886">If the weight of a new item exceeds the current weight limit,
    we exclude the new item:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi></mml:math>](img/1775.png)<st
    c="38973"><st c="38996">)</st> <st c="38998">if</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>></mml:mo><mml:mi>w</mml:mi></mml:math>](img/1776.png)<st
    c="39001"><st c="39002">.</st></st></st>
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="38886">如果新项的重量超过当前重量限制，我们将排除新项：</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi></mml:math>](img/1775.png)<st
    c="38973"><st c="38996">)</st> <st c="38998">如果</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>></mml:mo><mml:mi>w</mml:mi></mml:math>](img/1776.png)<st
    c="39001"><st c="39002">。</st></st></st>
- en: <st c="39003">Otherwise, we have</st> <st c="39023">two choices:</st>
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="39003">否则，我们有</st> <st c="39023">两种选择：</st>
- en: <st c="39035">Include the current</st> <st c="39056">item:</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/1777.png)
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="39035">包含当前</st> <st c="39056">项：</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/1777.png)
- en: <st c="39090">Exclude the current</st> <st c="39110">item:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>d</mi><mo>(</mo><mi>i</mi><mo>,</mo><mi>w</mi><mo>)</mo><mo>=</mo><mi>d</mi><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>w</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1778.png)
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="39090">排除当前</st> <st c="39110">项：</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>d</mi><mo>(</mo><mi>i</mi><mo>,</mo><mi>w</mi><mo>)</mo><mo>=</mo><mi>d</mi><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>w</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1778.png)
- en: <st c="39137">Choose the maximum of these</st> <st c="39165">two values:</st>
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39137">选择这两个值中的最大值：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mi
    mathvariant="italic">max</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/1779.png)
    <st c="39176"><st c="39219">if</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mi>w</mml:mi></mml:math>](img/1780.png)</st>'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mi
    mathvariant="italic">max</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/1779.png)
    <st c="39176"><st c="39219">如果</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mi>w</mml:mi></mml:math>](img/1780.png)</st>'
- en: <st c="39225">Generate</st> <st c="39233">the solution.</st> <st c="39248">The</st>
    <st c="39251">solution is located at</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>,</mo><mi>W</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1781.png)<st
    c="39275"><st c="39276">, which represents the maximum value achievable with the
    entire set of items and the full knapsack capacity.</st> *<st c="39385">Table
    10.3</st>* <st c="39395">shows the completed table,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">D</mml:mi></mml:math>](img/1782.png)<st
    c="39423"><st c="39424">, with the final solution highlighted in the bottom-right
    corner.</st> <st c="39490">The maximum value obtainable is 45, indicating that
    only items 1 and 3 will</st> <st c="39566">be selected.</st>
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="39225">生成</st> <st c="39233">解。</st> <st c="39248">该解位于</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>,</mo><mi>W</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1781.png)<st
    c="39275"><st c="39276">，表示通过整个物品集合和完整背包容量可以达到的最大值。</st> *<st c="39385">表 10.3</st>*
    <st c="39395">显示了完整的表格，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">D</mml:mi></mml:math>](img/1782.png)<st
    c="39423"><st c="39424">，最终的解在右下角被突出显示。</st> <st c="39490">最大值为45，表示仅选择物品1和物品3。</st>
- en: '|  | ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>w</mml:mi></mml:math>](img/1760.png) |'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>w</mml:mi></mml:math>](img/1760.png) |'
- en: '| ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>i</mml:mi></mml:math>](img/701.png) |  | <st c="39581">0</st>
    | <st c="39582">1</st> | <st c="39583">2</st> | <st c="39584">3</st> | <st c="39585">4</st>
    | <st c="39586">5</st> | <st c="39587">6</st> |'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>i</mml:mi></mml:math>](img/701.png) |  | <st c="39581">0</st>
    | <st c="39582">1</st> | <st c="39583">2</st> | <st c="39584">3</st> | <st c="39585">4</st>
    | <st c="39586">5</st> | <st c="39587">6</st> |'
- en: '| <st c="39588">0</st> | <st c="39589">0</st> | <st c="39590">0</st> | <st
    c="39591">0</st> | <st c="39592">0</st> | <st c="39593">0</st> | <st c="39594">0</st>
    | <st c="39595">0</st> |'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| <st c="39588">0</st> | <st c="39589">0</st> | <st c="39590">0</st> | <st
    c="39591">0</st> | <st c="39592">0</st> | <st c="39593">0</st> | <st c="39594">0</st>
    | <st c="39595">0</st> |'
- en: '| <st c="39596">1</st> | <st c="39597">0</st> | <st c="39598">15</st> | <st
    c="39600">15</st> | <st c="39603">15</st> | <st c="39606">15</st> | <st c="39609">15</st>
    | <st c="39612">15</st> |'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| <st c="39596">1</st> | <st c="39597">0</st> | <st c="39598">15</st> | <st
    c="39600">15</st> | <st c="39603">15</st> | <st c="39606">15</st> | <st c="39609">15</st>
    | <st c="39612">15</st> |'
- en: '| <st c="39615">2</st> | <st c="39617">0</st> | <st c="39618">15</st> | <st
    c="39620">15</st> | <st c="39623">20</st> | <st c="39626">30</st> | <st c="39629">30</st>
    | <st c="39632">30</st> |'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| <st c="39615">2</st> | <st c="39617">0</st> | <st c="39618">15</st> | <st
    c="39620">15</st> | <st c="39623">20</st> | <st c="39626">30</st> | <st c="39629">30</st>
    | <st c="39632">30</st> |'
- en: '| <st c="39635">3</st> | <st c="39637">0</st> | <st c="39638">15</st> | <st
    c="39640">15</st> | <st c="39643">20</st> | <st c="39646">30</st> | <st c="39649">30</st>
    | <st c="39652">45</st> |</st></st>'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| <st c="39635">3</st> | <st c="39637">0</st> | <st c="39638">15</st> | <st
    c="39640">15</st> | <st c="39643">20</st> | <st c="39646">30</st> | <st c="39649">30</st>
    | <st c="39652">45</st> |</st></st>'
- en: '<st c="39655">Table 10.3: Completed table</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">D</mml:mi></mml:math>](img/1772.png)<st
    c="39684"><st c="39685">. The final result is highlighted</st></st>'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39655">表 10.3：完成的表格</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">D</mml:mi></mml:math>](img/1772.png)<st
    c="39684"><st c="39685">。最终结果已突出显示</st></st>
- en: <st c="39718">The following is a Python implementation of the 0/1 knapsack problem
    using</st> <st c="39794">dynamic programming:</st>
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39718">以下是使用动态规划解决0/1背包问题的Python实现：</st>
- en: '[PRE3]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="40259">As we</st> <st c="40266">previously showed, a naïve divide-and-conquer
    approach for solving the 0/1 knapsack problem leads to exponential</st> <st c="40379">time
    complexity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/1786.png)<st
    c="40395"><st c="40401">), as it explores every possible combination of items,
    making it impractical for large datasets.</st> <st c="40498">The dynamic programming
    approach, on the other hand, solves each subproblem only once and stores the results
    in a table, leading to a time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mi>W</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1787.png)<st
    c="40651"><st c="40652">. The space complexity is also</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mi>W</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1788.png)
    <st c="40683"><st c="40684">due to the storage of the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">D</mml:mi></mml:math>](img/1789.png)
    <st c="40711"><st c="40712">table.</st></st></st></st></st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40259">正如我们</st> <st c="40266">之前所展示的，解决 0/1 背包问题的朴素分治法导致指数级的</st> <st
    c="40379">时间复杂度</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/1786.png)<st
    c="40395"><st c="40401">)，因为它会探索每一种可能的物品组合，使得对于大数据集来说不切实际。</st> <st c="40498">另一方面，动态规划方法只解决每个子问题一次，并将结果存储在表格中，从而导致时间复杂度为</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mi>W</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1787.png)<st
    c="40651"><st c="40652">。空间复杂度也是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mi>W</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1788.png)
    <st c="40683"><st c="40684">，因为需要存储</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">D</mml:mi></mml:math>](img/1789.png)
    <st c="40711"><st c="40712">表格。</st></st></st></st></st>
- en: <st c="40718">Limitations of dynamic programming</st>
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="40718">动态规划的局限性</st>
- en: <st c="40753">In the</st> <st c="40761">previous sections, we demonstrated through
    two examples and a complexity analysis that dynamic programming offers numerous
    advantages.</st> <st c="40896">Here is a summary of</st> <st c="40917">these benefits:</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40753">在前面的章节中，我们通过两个例子和复杂度分析演示了动态规划的诸多优点。</st> <st c="40896">以下是</st>
    <st c="40917">这些优点的总结：</st>
- en: '**<st c="40932">Optimal solutions</st>**<st c="40950">: Dynamic programming
    guarantees finding the optimal solution for problems with overlapping subproblems
    and optimal substructure.</st> <st c="41081">By systematically solving and storing
    the solutions to subproblems, dynamic programming ensures that the final solution
    is the</st> <st c="41208">best possible.</st>'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="40932">最优解</st>**<st c="40950">：动态规划保证在存在重叠子问题和最优子结构的问题中找到最优解。</st>
    <st c="41081">通过系统地解决并存储子问题的解，动态规划确保最终解是</st> <st c="41208">最佳可能解。</st>'
- en: '**<st c="41222">Efficiency</st>**<st c="41233">: By avoiding the re-computation
    of overlapping subproblems, dynamic programming reduces the time complexity of
    many problems from exponential to polynomial, making it feasible to solve large-scale
    problems that would be intractable using</st> <st c="41473">other approaches.</st>'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="41222">效率</st>**<st c="41233">：通过避免重计算重叠子问题，动态规划将许多问题的时间复杂度从指数级降低到多项式级，使得解决大规模问题成为可能，这些问题使用</st>
    <st c="41473">其他方法是不可行的。</st>'
- en: '**<st c="41490">Versatility</st>**<st c="41502">: Dynamic programming can be
    applied to a wide range of problems, including but not limited to optimization
    problems such as the knapsack problem, shortest path problems, and sequence alignment.</st>
    <st c="41698">It’s a powerful tool for solving various combinatorial, probabilistic,
    and</st> <st c="41773">deterministic problems.</st>'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="41490">多功能性</st>**<st c="41502">：动态规划可应用于广泛的问题领域，包括但不限于优化问题如背包问题、最短路径问题和序列比对。</st>
    <st c="41698">它是解决各种组合、概率和</st> <st c="41773">确定性问题的强大工具。</st>'
- en: '**<st c="41796">Space-time tradeoff</st>**<st c="41816">: Dynamic programming
    often allows a tradeoff between space and</st> <st c="41880">time complexity.</st>
    <st c="41898">For example, by storing intermediate results, time complexity is
    reduced at the expense of increased space usage.</st> <st c="42012">In some cases,
    space optimization techniques can also be applied to reduce</st> <st c="42087">space
    requirements.</st>'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="41796">空间与时间的权衡</st>**<st c="41816">：动态规划通常允许在空间和</st> <st c="41880">时间复杂度之间进行权衡。</st>
    <st c="41898">例如，通过存储中间结果，可以降低时间复杂度，但以增加空间使用为代价。</st> <st c="42012">在某些情况下，还可以应用空间优化技术以减少</st>
    <st c="42087">空间需求。</st>'
- en: <st c="42106">However, these benefits come with certain drawbacks</st> <st c="42159">and
    limitations:</st>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42106">然而，这些优势伴随着某些缺点</st> <st c="42159">和局限性：</st>
- en: '**<st c="42175">High space complexity</st>**<st c="42197">: One of the major
    drawbacks of dynamic programming is the potentially high space complexity.</st>
    <st c="42292">Storing solutions to all subproblems can require significant memory,
    especially for problems with large input sizes or dimensions, which might be infeasible
    in</st> <st c="42452">memory-constrained environments.</st>'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="42175">高空间复杂度</st>**<st c="42197">：动态规划的主要缺点之一是可能具有高空间复杂度。</st> <st
    c="42292">存储所有子问题的解可能需要大量内存，尤其是对于输入规模或维度较大的问题，在</st> <st c="42452">内存受限的环境中可能是不可行的。</st>'
- en: '**<st c="42484">Complex implementation</st>**<st c="42507">: Dynamic programming
    can be more complex to implement compared to simpler approaches such as greedy
    or divide-and-conquer.</st> <st c="42632">The need to correctly define subproblems,
    identify the recursive structure, and manage the dynamic programming table can
    make implementation challenging, particularly for</st> <st c="42803">complex problems.</st>'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="42484">复杂的实现</st>**<st c="42507">：与贪婪算法或分治法等简单方法相比，动态规划的实现可能更为复杂。</st>
    <st c="42632">正确定义子问题、识别递归结构以及管理动态规划表格的需要，可能使实现变得具有挑战性，特别是对于</st> <st c="42803">复杂的问题。</st>'
- en: '**<st c="42820">Problem specific</st>**<st c="42837">: Dynamic programming
    is not a universal solution and is only applicable to problems that exhibit both
    overlapping subproblems and optimal substructure.</st> <st c="42991">For problems
    that do not meet these criteria, dynamic programming might not provide any advantages
    or might even</st> <st c="43104">be inefficient.</st>'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="42820">问题特定</st>**<st c="42837">：动态规划并非通用解决方案，只适用于展示重叠子问题和最优子结构的问题。</st>
    <st c="42991">对于不符合这些条件的问题，动态规划可能不提供任何优势，甚至</st> <st c="43104">可能效率低下。</st>'
- en: '**<st c="43119">Difficulty in identifying subproblems</st>**<st c="43157">:
    In some cases, identifying the appropriate subproblems and constructing the recurrence
    relation for a dynamic programming solution can be nontrivial.</st> <st c="43310">This
    requires a deep understanding of the problem, which can be a barrier to applying
    dynamic</st> <st c="43404">programming effectively.</st>'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="43119">难以识别子问题</st>**<st c="43157">：在某些情况下，确定适当的子问题并构建动态规划解的递推关系可能并不容易。</st>
    <st c="43310">这需要对问题有深刻的理解，这可能是有效应用动态</st> <st c="43404">规划的障碍。</st>'
- en: '**<st c="43428">Overhead of table management</st>**<st c="43457">: Managing
    the dynamic programming table, especially in complex problems with multiple dimensions
    or states, can add additional overhead and complexity to the implementation.</st>
    <st c="43633">This can also lead to increased computational overhead if not</st>
    <st c="43695">managed efficiently.</st>'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="43428">表格管理的开销</st>**<st c="43457">：特别是在具有多个维度或状态的复杂问题中，管理动态规划表格可能会增加额外的开销和复杂性。</st>
    <st c="43633">如果不</st> <st c="43695">有效管理，这也可能导致增加的计算开销。</st>'
- en: <st c="43715">Dynamic programming</st> <st c="43735">is a powerful technique
    that can significantly reduce time complexity and guarantee optimal solutions
    for a wide range of problems.</st> <st c="43868">However, it comes with tradeoffs,
    particularly in terms of space complexity and implementation complexity.</st>
    <st c="43975">Understanding when and how to apply dynamic programming is key to
    leveraging its advantages while mitigating its limitations.</st> <st c="44101">In
    the next and final section of this chapter, we will introduce greedy algorithms.</st>
    <st c="44185">While they may not fully address all the limitations of dynamic
    programming, they provide greater flexibility in solving a broader range</st>
    <st c="44322">of problems.</st>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43715">动态规划</st> <st c="43735">是一种强大的技术，能够显著降低时间复杂度，并确保广泛问题的最优解。</st>
    <st c="43868">然而，它也有权衡，特别是在空间复杂度和实现复杂度方面。</st> <st c="43975">理解何时以及如何应用动态规划是充分利用其优势，同时减少其局限性的关键。</st>
    <st c="44101">在本章的下一节也是最后一节中，我们将介绍贪心算法。</st> <st c="44185">虽然它们可能无法完全解决动态规划的所有局限性，但它们在解决更广泛问题时提供了更大的灵活性。</st>
- en: <st c="44334">Greedy algorithms – an introduction</st>
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="44334">贪心算法——简介</st>
- en: '<st c="44370">At the beginning</st> <st c="44388">of this chapter, we highlighted
    a</st> <st c="44421">key distinction between divide-and-conquer algorithms and
    dynamic programming: while both strategies leverage optimal substructure, divide-and-conquer
    algorithms do not typically involve overlapping subproblems.</st> <st c="44634">Dynamic
    programming is particularly effective when overlapping subproblems are present
    because it avoids redundant calculations by storing and reusing the solutions
    to</st> <st c="44802">these subproblems.</st>'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44370">在本章的开始</st> <st c="44388">我们强调了分治算法和动态规划之间的一个关键区别：尽管两者都利用最优子结构，分治算法通常不涉及重叠子问题。</st>
    <st c="44634">动态规划在存在重叠子问题时特别有效，因为它通过存储和重用这些子问题的解决方案避免了冗余计算。</st>
- en: <st c="44820">But what happens if we cannot define an optimal substructure for
    the problem at hand?</st> <st c="44907">In such cases, we turn to a different
    category of algorithms known as Greedy Algorithms.</st> **<st c="44996">Greedy
    algorithms</st>** <st c="45013">adopt a fundamentally different approach to problem-solving.</st>
    <st c="45075">Instead</st> <st c="45083">of incrementally building solutions by
    optimally solving subproblems, as in dynamic programming, a greedy algorithm makes
    a series of decisions based on what appears to be the best choice at each step,
    with the expectation that</st> <st c="45310">these locally optimal decisions will
    collectively lead to a globally</st> <st c="45380">optimal solution.</st>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44820">但如果我们无法为当前问题定义最优子结构，会发生什么呢？</st> <st c="44907">在这种情况下，我们转向另一类算法，即贪心算法。</st>
    **<st c="44996">贪心算法</st>** <st c="45013">采用了与问题求解的根本不同的方法。</st> <st c="45075">与动态规划通过最优地解决子问题逐步构建解决方案不同，贪心算法基于每一步看似最佳的选择做出一系列决策，期望这些局部最优的决策最终会导致全局最优解。</st>
- en: <st c="45397">Key characteristics</st> <st c="45418">of greedy algorithms are</st>
    <st c="45443">as follows:</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45397">贪心算法的关键特征</st> <st c="45418">如下：</st>
- en: '**<st c="45454">Local optimal choice</st>**<st c="45475">: Greedy algorithms
    make decisions by selecting the option that seems best at each step, without considering
    the global consequences of</st> <st c="45612">this choice.</st>'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="45454">局部最优选择</st>**<st c="45475">：贪心算法通过选择每一步看似最好的选项来做出决策，而不考虑该选择的全局后果。</st>'
- en: '**<st c="45624">No overlapping subproblems</st>**<st c="45651">: Greedy algorithms
    do not require overlapping subproblems.</st> <st c="45712">Instead, they work
    best on problems where each choice is independent</st> <st c="45781">of others.</st>'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="45624">没有重叠子问题</st>**<st c="45651">：贪心算法不需要重叠的子问题。</st> <st c="45712">相反，它们最适用于每个选择互不依赖的问题。</st>'
- en: '**<st c="45791">Simple implementation</st>**<st c="45813">: Because greedy
    algorithms often involve straightforward, sequential decision-making, they tend
    to be easier to implement and more efficient in terms of time complexity compared
    to</st> <st c="45996">dynamic programming.</st>'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="45791">简单实现</st>**<st c="45813">：由于贪心算法通常涉及直接、顺序的决策，因此相比于</st> <st
    c="45996">动态规划，它们更容易实现，且在时间复杂度上更高效。</st>'
- en: <st c="46016">Let’s explain the greedy algorithm in a classical</st> <st c="46067">optimization
    problem.</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46016">让我们解释一个经典的优化问题中的贪心算法。</st>
- en: <st c="46088">Traveling salesman problem</st>
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="46088">旅行商问题</st>
- en: <st c="46115">The</st> **<st c="46120">Traveling Salesman Problem</st>** <st
    c="46146">(</st>**<st c="46148">TSP</st>**<st c="46151">) is a</st> <st c="46159">classic
    challenge in computer science and operations research.</st> <st c="46222">Given
    a</st> <st c="46229">set of locations and the distances between them, the goal
    is to determine the shortest possible route that visits each location once and
    returns to the starting point.</st> <st c="46398">The TSP is known for its computational
    complexity, as finding the exact optimal solution requires checking all possible
    permutations of city visits, which becomes infeasible for a large number of cities.</st>
    <st c="46602">However, a greedy algorithm offers a simpler, though not necessarily
    optimal, approach to solving</st> <st c="46700">the problem.</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46115">该</st> **<st c="46120">旅行商问题</st>** <st c="46146">(</st>**<st
    c="46148">TSP</st>**<st c="46151">)是计算机科学和运筹学中的经典挑战。</st> <st c="46222">给定一组位置和它们之间的距离，目标是确定一条最短的路径，经过每个位置一次并返回起点。</st>
    <st c="46398">TSP以其计算复杂性著称，因为找到确切的最优解需要检查所有可能的城市访问排列，对于大量城市来说，这是不可行的。</st> <st
    c="46602">然而，贪心算法提供了一种更简单的解决方法，尽管它不一定是最优的。</st>
- en: <st c="46712">The core concept behind greedy algorithms is the use of heuristics.</st>
    <st c="46781">In the next section, we will discuss the details of heuristics.</st>
    <st c="46845">For now, let’s pause and focus on solving the TSP using the</st>
    <st c="46905">greedy approach.</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46712">贪心算法背后的核心概念是使用启发式方法。</st> <st c="46781">在下一节中，我们将讨论启发式方法的详细信息。</st>
    <st c="46845">现在，让我们暂停一下，专注于使用贪心方法解决TSP。</st>
- en: <st c="46921">One of the</st> <st c="46933">common greedy heuristics for solving
    TSP is the nearest neighbor algorithm.</st> <st c="47009">The steps are</st> <st
    c="47023">as follows:</st>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46921">解决TSP的常见贪心启发式算法之一是最近邻算法。</st> <st c="47009">步骤如下：</st>
- en: '**<st c="47034">Start at a random city</st>**<st c="47057">: Choose an arbitrary
    city as the</st> <st c="47092">starting point.</st>'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="47034">从一个随机城市开始</st>**<st c="47057">：选择一个任意城市作为起点。</st>'
- en: '**<st c="47107">Visit the nearest unvisited city</st>**<st c="47140">: From
    the current city, visit the nearest city that has not yet been visited.</st> <st
    c="47220">This decision is made based on the shortest distance between the current
    city and the potential</st> <st c="47316">next cities.</st>'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="47107">访问最近的未访问城市</st>**<st c="47140">：从当前城市出发，访问尚未访问的最近城市。</st> <st
    c="47220">这一决策是根据当前城市与潜在下一个城市之间的最短距离做出的。</st>'
- en: '**<st c="47328">Repeat until all cities are visited</st>**<st c="47364">: Continue
    the process of moving to the nearest unvisited city until all cities have</st>
    <st c="47450">been visited.</st>'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="47328">重复直到所有城市都被访问</st>**<st c="47364">：继续移动到最近的未访问城市，直到所有城市都已被访问。</st>'
- en: '**<st c="47463">Return to the starting city</st>**<st c="47491">: Once all
    cities have been visited, return to the starting city to complete</st> <st c="47569">the
    tour.</st>'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="47463">返回起始城市</st>**<st c="47491">：当所有城市都被访问过后，返回起始城市以完成旅行。</st>'
- en: '**<st c="47578">Example 10.4:</st>**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="47578">示例10.4：</st>**'
- en: '<st c="47592">Let’s consider a simplified example with four cities: A, B, C,
    and D.</st> <st c="47663">These are the distances</st> <st c="47687">between cities:</st>'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47592">让我们考虑一个简化的例子，包含四个城市：A、B、C和D。</st> <st c="47663">这些是城市之间的距离：</st>
- en: <st c="47702">A to B =</st> <st c="47712">10</st>
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="47702">A到B =</st> <st c="47712">10</st>
- en: <st c="47714">A to C =</st> <st c="47724">15</st>
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="47714">A到C =</st> <st c="47724">15</st>
- en: <st c="47726">A to D =</st> <st c="47736">20</st>
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="47726">A到D =</st> <st c="47736">20</st>
- en: <st c="47738">B to C =</st> <st c="47748">35</st>
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="47738">B到C =</st> <st c="47748">35</st>
- en: <st c="47750">B to D =</st> <st c="47760">25</st>
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="47750">B到D =</st> <st c="47760">25</st>
- en: <st c="47762">C to D =</st> <st c="47772">30</st>
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="47762">C到D =</st> <st c="47772">30</st>
- en: <st c="47774">The nearest neighbor algorithm steps are</st> <st c="47816">as
    follows:</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47774">最近邻算法的步骤如下：</st> <st c="47816">：
- en: <st c="47827">Start at</st> <st c="47837">City A.</st>
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47827">从</st> <st c="47837">城市A开始。</st>
- en: '<st c="47844">Visit the nearest city: From A, the nearest city is B (distance
    =</st> <st c="47911">10).</st>'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47844">访问最近的城市：从 A 出发，最近的城市是 B（距离 =</st> <st c="47911">10）。</st>
- en: '<st c="47915">Move to City B: From B, the nearest unvisited city is D (distance
    =</st> <st c="47984">25).</st>'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47915">移动到 B 城市：从 B 出发，最近的未访问城市是 D（距离 =</st> <st c="47984">25）。</st>
- en: '<st c="47988">Move to City D: From D, the nearest unvisited city is C (distance
    =</st> <st c="48057">30).</st>'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47988">移动到 D 城市：从 D 出发，最近的未访问城市是 C（距离 =</st> <st c="48057">30）。</st>
- en: '<st c="48061">Move to City C: Now all cities have been visited.</st> <st c="48112">Finally,
    return to the starting city A (distance =</st> <st c="48163">15).</st>'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48061">移动到 C 城市：现在所有城市都已访问。</st> <st c="48112">最后，返回起始城市 A（距离 =</st>
    <st c="48163">15）。</st>
- en: <st c="48167">The</st> <st c="48171">resulting tour using the greedy algorithm
    is A → B → D → C → A and the total distance is 10 + 25 + 30 + 15 =</st> <st c="48281">80
    units.</st>
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48167">使用贪心算法得到的最终旅游路径是 A → B → D → C → A，总距离是 10 + 25 + 30 + 15 =</st>
    <st c="48281">80 单位。</st>
- en: <st c="48290">Heuristics and their role in greedy algorithms</st>
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="48290">启发式方法及其在贪心算法中的作用</st>
- en: <st c="48337">The term</st> *<st c="48347">heuristic</st>* <st c="48356">originates</st>
    <st c="48368">from the Latin word</st> *<st c="48388">heuristicus</st>*<st c="48399">,
    which itself is derived from the Greek word</st> *<st c="48445">heuriskein</st>*<st
    c="48455">, meaning to</st> *<st c="48468">find</st>*<st c="48472">. Heuristics
    are utilized across various domains.</st> <st c="48522">Here, we will focus on
    their application in problem-solving and</st> <st c="48586">artificial intelligence.</st>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48337">术语</st> *<st c="48347">启发式方法</st>* <st c="48356">源自拉丁词</st> *<st
    c="48388">heuristicus</st>*，<st c="48399">该词本身源自希腊词</st> *<st c="48445">heuriskein</st>*，意思是</st>
    *<st c="48468">发现</st>*。<st c="48472">启发式方法被广泛应用于各个领域。</st> <st c="48522">在这里，我们将重点讨论它们在问题解决和</st>
    <st c="48586">人工智能中的应用。</st>
- en: <st c="48610">Heuristics are</st> <st c="48625">problem-solving strategies or
    techniques</st> <st c="48667">that are designed to produce a solution quickly
    and efficiently, though not necessarily optimally.</st> <st c="48766">Heuristics
    are particularly useful in complex problems where finding the exact solution would
    require too much time or computational power.</st> <st c="48906">Instead of exhaustively
    exploring all possible solutions, a heuristic approach uses rules of thumb, educated
    guesses, or intuitive strategies to generate a solution that is</st> *<st c="49079">good
    enough</st>* <st c="49090">within a reasonable amount</st> <st c="49118">of time.</st>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 启发式方法是<st c="48610">解决问题的策略或技巧</st>，<st c="48625">旨在快速高效地产生解决方案，尽管不一定是最优的。</st>
    <st c="48667">启发式方法在复杂问题中尤其有用，在这些问题中，找到准确的解决方案可能需要过多的时间或计算能力。</st> <st c="48766">与其穷举所有可能的解决方案，启发式方法采用经验法则、教育性猜测或直觉策略来生成一个在合理时间内的解决方案，</st>
    *<st c="49079">足够好</st>* <st c="49090">而且通常是可接受的。</st>
- en: <st c="49126">Greedy algorithms are a class of algorithms that often rely on
    heuristics to make decisions.</st> <st c="49220">In a greedy algorithm, the strategy
    is to make the best possible choice at each step based on current information,
    with the hope that this will lead to an optimal or near-optimal solution.</st>
    <st c="49409">The</st> *<st c="49413">best possible choice</st>* <st c="49433">in
    each step is determined by</st> <st c="49464">a heuristic.</st>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49126">贪心算法是一类常常依赖启发式方法做决策的算法。</st> <st c="49220">在贪心算法中，策略是基于当前信息在每一步做出最佳选择，期望这将导致一个最优或近似最优的解决方案。</st>
    <st c="49409">每一步的</st> *<st c="49413">最佳选择</st>* <st c="49433">是由</st> <st c="49464">启发式方法决定的。</st>
- en: <st c="49476">Let’s discuss how heuristics work in greedy algorithms.</st> <st
    c="49533">In a greedy algorithm, a heuristic helps the algorithm decide which
    option to choose at each step.</st> <st c="49632">This decision is based on local
    information, meaning the algorithm does not consider the entire problem but focuses
    on the current step.</st> <st c="49769">In the TSP using the nearest neighbor
    algorithm, the heuristic is</st> *<st c="49835">choosing the nearest unvisited
    city</st>*<st c="49870">. This decision is made based on the distance from the
    current city to other cities, without considering the</st> <st c="49979">overall
    tour.</st>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49476">让我们讨论贪婪算法中启发式方法的工作原理。</st> <st c="49533">在贪婪算法中，启发式方法帮助算法决定在每个步骤中选择哪个选项。</st>
    <st c="49632">这个决定基于局部信息，意味着算法不考虑整个问题，而是专注于当前步骤。</st> <st c="49769">在使用最近邻居算法的TSP中，启发式方法是</st>
    *<st c="49835">选择最近的未访问城市</st>*<st c="49870">。这个决定基于当前城市到其他城市的距离，而不考虑</st> <st
    c="49979">整体路径。</st>
- en: <st c="49992">The heuristic</st> <st c="50007">guides the algorithm by providing
    a simple and fast rule to follow.</st> <st c="50075">This rule is based on the
    specific problem’s characteristics and is designed to lead to a good solution.</st>
    <st c="50180">Let’s examine this in the coin change problem.</st> <st c="50227">The
    coin change problem is a classic optimization problem where the goal is to determine
    the minimum number of coins needed to make a specific amount of money using a
    given set of coin denominations.</st> <st c="50427">For example, if we have coins
    of denominations 1, 5, and 10 and need to make 12, the challenge is to find the
    combination of these coins that minimizes the total number of coins used.</st>
    <st c="50611">This problem can be solved using various approaches, including greedy
    algorithms, dynamic programming, or recursion, depending on the specific set of
    denominations.</st> <st c="50776">For this problem, a greedy heuristic might</st>
    *<st c="50819">always take the largest denomination coin first</st>*<st c="50866">.
    This simple rule is easy to follow and often leads to a</st> <st c="50924">solution
    quickly.</st>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49992">启发式方法</st> <st c="50007">通过提供一条简单快速的规则来指导算法。</st> <st c="50075">这个规则基于特定问题的特征设计，旨在导致一个好的解决方案。</st>
    <st c="50180">让我们在找零问题中详细探讨一下。</st> <st c="50227">找零问题是一个经典的优化问题，目标是使用给定的硬币面额确定达到特定金额所需的最少硬币数量。</st>
    <st c="50427">例如，如果我们有面额为1、5和10的硬币，需要凑出12元，挑战在于找到最小化使用硬币总数的组合。</st> <st c="50611">这个问题可以使用各种方法来解决，包括贪婪算法、动态规划或递归，具体取决于硬币的具体面额。</st>
    <st c="50776">对于这个问题，贪婪启发式方法可能会</st> *<st c="50819">总是先选择最大面额的硬币</st>*<st c="50866">。这条简单规则易于遵循，并且通常能够快速找到</st>
    <st c="50924">解决方案。</st>
- en: <st c="50941">Heuristics also</st> <st c="50957">allow greedy algorithms to
    find solutions quickly, even in complex problems.</st> <st c="51035">However,
    this speed comes at the cost of potentially missing the optimal solution.</st>
    <st c="51118">The heuristic provides a balance between finding a solution quickly
    and finding the best possible solution.</st> <st c="51226">Let’s discuss this
    behavior in the Huffman Coding Algorithm.</st> <st c="51287">Huffman coding is
    a greedy algorithm used for lossless data compression.</st> <st c="51360">It assigns
    variable-length codes to characters based on their frequencies in the input data,
    with more frequent characters receiving shorter codes.</st> <st c="51508">The
    algorithm builds a binary tree, called the Huffman tree, where each leaf node
    represents a character and its frequency.</st> <st c="51632">By traversing the
    tree, a unique binary code is generated for each character, minimizing the overall
    length of the encoded data.</st> <st c="51761">Huffman coding is widely used in
    applications like file compression and encoding.</st> <st c="51843">In the Huffman
    coding algorithm, a greedy approach uses the heuristic of always merging the two
    least frequent symbols first, which leads to an efficient, though not necessarily</st>
    <st c="52021">optimal, encoding.</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50941">启发式方法还</st> <st c="50957">使得贪心算法能够快速找到解，即使是在复杂的问题中。</st> <st c="51035">然而，这种速度是以可能错过最优解为代价的。</st>
    <st c="51118">启发式方法在快速找到解和找到最佳解之间提供了平衡。</st> <st c="51226">让我们讨论一下霍夫曼编码算法中的这种行为。</st>
    <st c="51287">霍夫曼编码是一种用于无损数据压缩的贪心算法。</st> <st c="51360">它根据输入数据中字符的频率为字符分配可变长度的编码，频率较高的字符分配较短的编码。</st>
    <st c="51508">该算法构建了一棵二叉树，称为霍夫曼树，其中每个叶子节点代表一个字符及其频率。</st> <st c="51632">通过遍历这棵树，为每个字符生成唯一的二进制编码，从而最小化编码数据的总长度。</st>
    <st c="51761">霍夫曼编码广泛应用于文件压缩和编码等领域。</st> <st c="51843">在霍夫曼编码算法中，贪心方法采用启发式策略，总是首先合并两个最不常见的符号，这样可以得到一个高效的编码，尽管不一定是</st>
    <st c="52021">最优的编码。</st>
- en: <st c="52039">Heuristics provide significant advantages to greedy algorithms.</st>
    <st c="52104">They make these algorithms fast by enabling decisions without the
    need to explore every possible option.</st> <st c="52209">Moreover, heuristic-based
    decisions are typically easy to understand and implement, making greedy algorithms
    straightforward.</st> <st c="52335">In many real-world scenarios, particularly
    in artificial intelligence, a quickly found approximate solution is often more
    valuable than an exact solution that requires excessive</st> <st c="52513">computation
    time.</st>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52039">启发式方法为贪心算法提供了显著的优势。</st> <st c="52104">它们通过使决策无需探索所有可能的选项，来加速这些算法。</st>
    <st c="52209">此外，基于启发式的决策通常易于理解和实施，使得贪心算法变得直观。</st> <st c="52335">在许多实际场景中，特别是在人工智能中，快速找到一个近似解往往比需要过多计算时间的精确解更有价值。</st>
- en: <st c="52530">However, heuristics have their own limitations.</st> <st c="52579">Because
    heuristics rely on local information, they can sometimes result in suboptimal
    solutions; what seems like the best choice in the short term may not be the best
    choice in the long run.</st> <st c="52770">Additionally, heuristics are often</st>
    <st c="52805">problem-specific, meaning a heuristic that works well for one problem
    may not be effective for another.</st> <st c="52909">Greedy algorithms, guided
    by heuristics, can also become trapped in local optima – solutions that are better
    than nearby alternatives but not the best possible overall.</st> <st c="53078">This
    can cause the heuristic to miss the globally</st> <st c="53128">optimal solution.</st>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52530">然而，启发式方法有其自身的局限性。</st> <st c="52579">因为启发式方法依赖于局部信息，有时会导致次优解；在短期内看似最佳的选择，长期来看可能并非最优。</st>
    <st c="52770">此外，启发式方法通常是</st> <st c="52805">问题特定的，这意味着对于某个问题有效的启发式方法可能对另一个问题无效。</st>
    <st c="52909">由启发式方法指导的贪心算法，也可能会陷入局部最优解——即比邻近的替代方案更好的解，但并非全局最佳解。</st> <st c="53078">这可能导致启发式方法错过全局</st>
    <st c="53128">最优解。</st>
- en: <st c="53145">Greedy algorithms</st> <st c="53163">don’t always yield the optimal
    solution.</st> <st c="53205">In the TSP example discussed earlier, the greedy
    approach may overlook shorter routes that require more strategic decisions rather
    than just choosing the nearest neighbor at each step.</st> <st c="53390">Since
    the greedy algorithm is heuristic, it offers a fast, approximate solution but
    cannot guarantee that the solution is optimal.</st> <st c="53521">Additionally,
    the greedy approach can get trapped in local optima, where a seemingly best decision
    at the moment hinders achieving the</st> <st c="53656">global optimum.</st>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53145">贪心算法</st> <st c="53163">并不总能得到最优解。</st> <st c="53205">在前面讨论的旅行商问题（TSP）示例中，贪心策略可能忽略了需要更多战略决策的较短路径，而不仅仅是每一步选择最近的邻居。</st>
    <st c="53390">由于贪心算法是启发式的，它提供了一个快速的近似解，但无法保证解是最优的。</st> <st c="53521">此外，贪心策略可能会陷入局部最优解，其中某个看似最好的决策实际上会妨碍实现</st>
    <st c="53656">全局最优解。</st>
- en: <st c="53671">The greedy algorithm is best used in the</st> <st c="53713">following
    scenarios:</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53671">贪心算法最适用于以下场景：</st>
- en: <st c="53733">Optimal substructure doesn’t exist.</st> <st c="53770">If a problem
    lacks a clear optimal substructure, dynamic programming might not be applicable.</st>
    <st c="53864">Greedy algorithms can provide a more straightforward solution in</st>
    <st c="53929">such cases.</st>
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="53733">最优子结构不存在。</st> <st c="53770">如果问题没有明确的最优子结构，动态规划可能不适用。</st> <st
    c="53864">在这种情况下，贪心算法可以提供更直接的解决方案。</st> <st c="53929">例如。</st>
- en: <st c="53940">Greedy algorithms are tailored to specific types of problems,
    such as those involving scheduling, shortest paths, or resource allocation, where
    making the locally optimal choice at each step leads to an overall</st> <st c="54152">optimal
    solution.</st>
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="53940">贪心算法适用于特定类型的问题，例如调度、最短路径或资源分配问题，在这些问题中，每一步的局部最优选择能够产生整体</st> <st
    c="54152">最优解。</st>
- en: <st c="54169">A quick, approximate solution is acceptable, data is small, and
    computational resources</st> <st c="54258">are limited.</st>
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="54169">可以接受快速的近似解，数据量较小，且计算资源</st> <st c="54258">有限。</st>
- en: <st c="54270">The problem context allows for the potential trade-off between
    solution quality and</st> <st c="54355">computational efficiency.</st>
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="54270">问题的背景允许在解的质量与</st> <st c="54355">计算效率之间进行潜在的权衡。</st>
- en: <st c="54380">While greedy algorithms offer a simpler and often more efficient
    alternative to dynamic programming, they are not a one-size-fits-all solution.</st>
    <st c="54525">The absence of overlapping subproblems and the reliance on local
    optimization means that greedy algorithms can only be applied to certain types
    of problems.</st> <st c="54682">Understanding when to use a greedy approach versus
    dynamic programming is crucial for effective problem-solving in</st> <st c="54797">algorithm
    design.</st>
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54380">虽然贪心算法提供了一个比动态规划更简单且通常更高效的替代方案，但它并不是万能的。</st> <st c="54525">由于缺乏重叠的子问题和依赖局部优化，贪心算法只能应用于某些类型的问题。</st>
    <st c="54682">理解何时使用贪心算法与动态规划是算法设计中有效问题求解的关键。</st>
- en: '*<st c="54814">Table 10.4</st>* <st c="54825">demonstrates a comparison between
    divide-and-conquer, dynamic programming, and</st> <st c="54905">greedy algorithms.</st>'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="54814">表 10.4</st>* <st c="54825">展示了分治法、动态规划与</st> <st c="54905">贪心算法的比较。</st>'
- en: '| **<st c="54923">Feature</st>** | **<st c="54931">Divide-and-conquer</st>**
    | **<st c="54950">Dynamic programming</st>** | **<st c="54970">Greedy algorithms</st>**
    |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="54923">特征</st>** | **<st c="54931">分治法</st>** | **<st c="54950">动态规划</st>**
    | **<st c="54970">贪心算法</st>** |'
- en: '| <st c="54988">Problem-solving</st> <st c="55005">strategy</st> | <st c="55013">Breaks
    problem into independent subproblems, solves recursively,</st> <st c="55079">combines
    solutions</st> | <st c="55097">Breaks problem into overlapping subproblems, solves
    once,</st> <st c="55156">stores results</st> | <st c="55170">Builds solution piece
    by piece with locally</st> <st c="55215">optimal choices</st> |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| <st c="54988">问题求解</st> <st c="55005">策略</st> | <st c="55013">将问题分解为独立的子问题，递归求解，</st>
    <st c="55079">合并解决方案</st> | <st c="55097">将问题分解为重叠的子问题，一次性求解，</st> <st c="55156">存储结果</st>
    | <st c="55170">通过局部</st> <st c="55215">最优选择逐步构建解决方案</st> |'
- en: '| <st c="55230">Optimal</st> <st c="55239">substructure</st> | <st c="55251">Uses
    optimal</st> <st c="55265">substructure implicitly</st> | <st c="55288">Relies
    heavily on</st> <st c="55307">optimal substructure</st> | <st c="55327">Assumes
    local optimum leads to</st> <st c="55359">global optimum</st> |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| <st c="55230">最优</st> <st c="55239">子结构</st> | <st c="55251">隐式使用最优</st>
    <st c="55265">子结构</st> | <st c="55288">高度依赖</st> <st c="55307">最优子结构</st> | <st
    c="55327">假设局部最优能导出</st> <st c="55359">全局最优</st> |'
- en: '| <st c="55373">Overlapping</st> <st c="55386">subproblems</st> | <st c="55397">Subproblems
    are usually independent; solving one subproblem does not affect the solution</st>
    <st c="55487">of another</st> | <st c="55497">Handles problems with overlapping
    subproblems by storing and reusing results to avoid</st> <st c="55584">redundant
    calculations</st> | <st c="55606">Typically, it does not involve overlapping subproblems.</st>
    <st c="55663">Each decision is made based on the current state, independent of</st>
    <st c="55728">previous decisions</st> |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| <st c="55373">重叠</st> <st c="55386">子问题</st> | <st c="55397">子问题通常是独立的；解决一个子问题不会影响</st>
    <st c="55487">另一个子问题的解</st> | <st c="55497">通过存储和重用结果来处理具有重叠子问题的问题，以避免</st> <st
    c="55584">冗余计算</st> | <st c="55606">通常不涉及重叠子问题。</st> <st c="55663">每个决策是基于当前状态做出的，与</st>
    <st c="55728">之前的决策无关</st> |'
- en: '| <st c="55746">Use cases</st> | <st c="55756">Sorting, searching,</st> <st
    c="55777">numerical problems</st> | <st c="55795">Optimization problems,</st>
    <st c="55819">complex problems</st> | <st c="55835">Minimum spanning tree, shortest</st>
    <st c="55868">path, scheduling</st> |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| <st c="55746">使用场景</st> | <st c="55756">排序、查找、</st> <st c="55777">数值问题</st>
    | <st c="55795">优化问题、</st> <st c="55819">复杂问题</st> | <st c="55835">最小生成树、最短</st>
    <st c="55868">路径、调度</st> |'
- en: '| <st c="55884">Computational</st> <st c="55899">efficiency</st> | <st c="55909">Depends
    on problem nature,</st> <st c="55937">recursive overhead</st> | <st c="55955">More
    space intensive, avoids</st> <st c="55985">redundant calculations</st> | <st c="56007">Generally
    faster, less space, may not always</st> <st c="56053">be optimal</st> |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| <st c="55884">计算</st> <st c="55899">效率</st> | <st c="55909">取决于问题性质，</st>
    <st c="55937">递归开销</st> | <st c="55955">更多占用空间，避免</st> <st c="55985">冗余计算</st>
    | <st c="56007">通常更快，占用更少空间，但可能并不总是</st> <st c="56053">最优的</st> |'
- en: '| <st c="56063">Example</st> <st c="56072">problems</st> | <st c="56080">Merge
    sort, quick sort,</st> <st c="56105">binary search</st> | <st c="56118">Knapsack,
    Longest Common Subsequence,</st> <st c="56157">Floyd-Warshall</st> | <st c="56171">Kruskal’s,
    Dijkstra’s shortest path,</st> <st c="56209">activity selection</st> |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| <st c="56063">示例</st> <st c="56072">问题</st> | <st c="56080">归并排序、快速排序、</st>
    <st c="56105">二分查找</st> | <st c="56118">背包问题、最长公共子序列、</st> <st c="56157">Floyd-Warshall</st>
    | <st c="56171">Kruskal算法、Dijkstra最短路径、</st> <st c="56209">活动选择</st> |'
- en: '<st c="56227">Table 10.4: Comparison of divide-and-conquer, dynamic programming,
    and greedy algorithms</st>'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56227">表 10.4：分治法、动态规划和贪心算法的比较</st>
- en: <st c="56316">Summary</st>
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="56316">总结</st>
- en: <st c="56324">In this chapter, we explored the key concepts and differences
    among these algorithmic strategies, highlighting how each approach solves problems
    with optimal substructure.</st> <st c="56497">We discussed how divide-and-conquer
    algorithms break problems into smaller, non-overlapping subproblems, and how dynamic
    programming efficiently handles overlapping subproblems by storing and reusing
    their solutions.</st> <st c="56714">This chapter also covered greedy algorithms,
    emphasizing their reliance on heuristics to make locally optimal choices at each
    step, even though this may not always lead to a globally</st> <st c="56897">optimal
    solution.</st>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56324">在本章中，我们探讨了这些算法策略的关键概念和差异，重点讲解了每种方法如何利用最优子结构解决问题。</st> <st c="56497">我们讨论了分治算法如何将问题分解为较小且不重叠的子问题，以及动态规划如何通过存储和重用子问题的解来高效地处理重叠子问题。</st>
    <st c="56714">本章还涵盖了贪心算法，强调了它们依赖启发式方法在每一步做出局部最优选择，尽管这并不总是能导致全局</st> <st c="56897">最优解。</st>
- en: <st c="56914">Throughout the chapter, we provided examples such as the 0/1 knapsack
    problem and the TSP to illustrate the strengths and limitations of each approach.</st>
    <st c="57067">We also examined the role of heuristics in greedy algorithms, noting
    how they enable quick, approximate solutions but can sometimes lead to suboptimal
    results.</st> <st c="57227">As we concluded the discussion, we acknowledged the
    importance of choosing the right algorithmic strategy based on the problem</st>
    <st c="57354">at hand.</st>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56914">在本章中，我们提供了像0/1背包问题和旅行商问题（TSP）这样的例子，以说明每种方法的优缺点。</st> <st c="57067">我们还探讨了启发式在贪心算法中的作用，指出它们如何实现快速的近似解，但有时可能导致次优解。</st>
    <st c="57227">在总结讨论时，我们承认根据问题的实际情况选择合适的算法策略的重要性。</st> <st c="57354">在处理当前问题时，算法策略的选择至关重要。</st>
- en: <st c="57362">In the next chapter, we will transition into an introduction to
    data structures, the foundational elements that support efficient algorithm design</st>
    <st c="57510">and implementation.</st>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57362">在下一章中，我们将介绍数据结构，它是支持高效算法设计和实现的基础元素。</st> <st c="57510">数据结构在算法设计中的作用不容小觑。</st>
- en: <st c="57529">References and further reading</st>
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="57529">参考书目与进一步阅读</st>
- en: <st c="57560">Introduction to Algorithms.</st> <st c="57589">By Thomas H.</st>
    <st c="57602">Cormen, Charles E.</st> <st c="57621">Leiserson, Ronald L.</st>
    <st c="57642">Rivest, and Clifford Stein.</st> <st c="57670">Fourth Edition.</st>
    <st c="57686">MIT</st> <st c="57690">Press.</st> <st c="57697">2022.</st>
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="57560">算法导论。</st> <st c="57589">作者：Thomas H.</st> <st c="57602">Cormen，Charles
    E.</st> <st c="57621">Leiserson，Ronald L.</st> <st c="57642">Rivest，Clifford Stein。</st>
    <st c="57670">第四版。</st> <st c="57686">MIT出版社。</st> <st c="57690">2022年。</st>
- en: '*<st c="57702">Chapter 15,</st>* *<st c="57715">Dynamic Programming</st>*'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="57702">第15章，</st>* *<st c="57715">动态规划</st>*'
- en: '*<st c="57734">Chapter 16,</st>* *<st c="57747">Greedy Algorithms</st>*'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="57734">第16章，</st>* *<st c="57747">贪心算法</st>*'
- en: '*<st c="57764">Chapter 34, NP-Completeness (for a comparison of</st>* *<st
    c="57814">algorithm complexities)</st>*'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="57764">第34章，NP完全性（用于算法复杂度的比较）</st>* *<st c="57814">算法复杂度比较</st>*'
- en: <st c="57837">Algorithm Design.</st> <st c="57856">By J.</st> <st c="57862">Kleinberg
    and É.</st> <st c="57879">Tardos.</st> <st c="57887">Pearson.</st> <st c="57896">2006.</st>
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="57837">算法设计。</st> <st c="57856">作者：J.</st> <st c="57862">Kleinberg 和
    É.</st> <st c="57879">Tardos。</st> <st c="57887">Pearson出版。</st> <st c="57896">2006年。</st>
- en: '*<st c="57901">Chapter 4,</st>* *<st c="57913">Greedy Algorithms</st>*'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="57901">第四章，</st>* *<st c="57913">贪心算法</st>*'
- en: '*<st c="57930">Chapter</st>* *<st c="57939">5, Divide-and-Conquer</st>*'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="57930">第五章，</st>* *<st c="57939">分治法</st>*'
- en: '*<st c="57960">Chapter 6,</st>* *<st c="57972">Dynamic Programming</st>*'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="57960">第六章，</st>* *<st c="57972">动态规划</st>*'
- en: <st c="57991">Algorithms.</st> <st c="58004">By S.</st> <st c="58010">Dasgupta,
    C.</st> <st c="58023">H.</st> <st c="58026">Papadimitriou, and U.</st> <st c="58048">V.</st>
    <st c="58051">Vazirani.</st> <st c="58061">McGraw-Hill.</st> <st c="58074">2008</st>
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="57991">算法。</st> <st c="58004">作者：S.</st> <st c="58010">Dasgupta，C.</st>
    <st c="58023">H.</st> <st c="58026">Papadimitriou和U.</st> <st c="58048">V.</st>
    <st c="58051">Vazirani。</st> <st c="58061">McGraw-Hill出版。</st> <st c="58074">2008年</st>
- en: '*<st c="58078">Chapter</st>* *<st c="58087">2, Divide-and-Conquer</st>*'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="58078">第二章，</st>* *<st c="58087">分治法</st>*'
- en: '*<st c="58108">Chapter 5,</st>* *<st c="58120">Greedy Algorithms</st>*'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="58108">第五章，</st>* *<st c="58120">贪心算法</st>*'
- en: '*<st c="58137">Chapter 6,</st>* *<st c="58149">Dynamic Programming</st>*'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="58137">第六章，</st>* *<st c="58149">动态规划</st>*'
