- en: Chapter 1. A Tour of Interactive Computing with IPython
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章：IPython互动计算概述
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Introducing the IPython notebook
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍IPython笔记本
- en: Getting started with exploratory data analysis in IPython
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始在IPython中进行探索性数据分析
- en: Introducing the multidimensional array in NumPy for fast array computations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍NumPy中的多维数组以进行快速数组计算
- en: Creating an IPython extension with custom magic commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有自定义魔法命令的IPython扩展
- en: Mastering IPython's configuration system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握IPython的配置系统
- en: Creating a simple kernel for IPython
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为IPython创建一个简单的内核
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: 'This book targets intermediate to advanced users who are familiar with Python,
    IPython, and scientific computing. In this chapter, we will give a brief recap
    on the fundamental tools we will be using throughout this book: IPython, the notebook,
    pandas, NumPy, and matplotlib.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书面向熟悉Python、IPython和科学计算的中高级用户。在本章中，我们将简要回顾一下本书中将使用的基础工具：IPython、笔记本、pandas、NumPy和matplotlib。
- en: In this introduction, we will give a broad overview of IPython and the Python
    scientific stack for high-performance computing and data science.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节中，我们将对IPython和Python科学计算栈进行广泛的概述，以支持高性能计算和数据科学。
- en: What is IPython?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是IPython？
- en: '**IPython** is an open source platform for interactive and parallel computing.
    It offers powerful interactive shells and a browser-based notebook. The **notebook**
    combines code, text, mathematical expressions, inline plots, interactive plots,
    and other rich media within a sharable web document. This platform provides an
    ideal framework for interactive scientific computing and data analysis. IPython
    has become essential to researchers, data scientists, and teachers.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPython**是一个开源平台，用于互动和并行计算。它提供了强大的交互式命令行和基于浏览器的笔记本。**笔记本**将代码、文本、数学表达式、内联图形、交互式图表及其他丰富的媒体内容结合在一个可共享的Web文档中。该平台为互动科学计算和数据分析提供了理想的框架，IPython已成为研究人员、数据科学家和教师的必备工具。'
- en: IPython can be used with the Python programming language, but the platform also
    supports many other languages such as R, Julia, Haskell, or Ruby. The architecture
    of the project is indeed language-agnostic, consisting of messaging protocols
    and interactive clients (including the browser-based notebook). The clients are
    connected to **kernels** that implement the core interactive computing facilities.
    Therefore, the platform can be useful to technical and scientific communities
    that use languages other than Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: IPython可以与Python编程语言一起使用，但该平台也支持其他多种语言，如R、Julia、Haskell或Ruby。该项目的架构确实是与语言无关的，包含了消息协议和交互式客户端（包括基于浏览器的笔记本）。这些客户端与**内核**相连，后者实现了核心的交互式计算功能。因此，该平台对于使用Python以外语言的技术和科学社区也非常有用。
- en: In July 2014, **Project Jupyter** was announced by the IPython developers. This
    project will focus on the language-independent parts of IPython (including the
    notebook architecture), whereas the name IPython will be reserved to the Python
    kernel. In this book, for the sake of simplicity, we will just use the term IPython
    to refer to either the platform or the Python kernel.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年7月，**Jupyter项目**由IPython开发者宣布。该项目将专注于IPython中与语言无关的部分（包括笔记本架构），而IPython这个名称将保留用于Python内核。在本书中，为了简便起见，我们将使用IPython这个术语来指代平台或Python内核。
- en: A brief historical retrospective on Python as a scientific environment
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python作为科学计算环境的简要历史回顾
- en: Python is a high-level general-purpose language originally conceived by Guido
    van Rossum in the late 1980s (the name was inspired by the British comedy *Monty
    Python's Flying Circus*). This easy-to-use language is the basis of many scripting
    programs that glue different software components (**glue language**) together.
    In addition, Python comes with an extremely rich standard library (the *batteries
    included* philosophy), which covers string processing, Internet Protocols, operating
    system interfaces, and many other domains.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种高级通用编程语言，由Guido van Rossum于1980年代末期构思（其名称灵感来源于英国喜剧*Monty Python's Flying
    Circus*）。这种易于使用的语言是许多脚本程序的基础，这些程序将不同的软件组件（**胶水语言**）连接在一起。此外，Python还自带一个极其丰富的标准库（*内置电池*理念），涵盖了字符串处理、互联网协议、操作系统接口等多个领域。
- en: 'In the late 1990s, Travis Oliphant and others started to build efficient tools
    to deal with numerical data in Python: Numeric, Numarray, and finally, **NumPy**.
    **SciPy**, which implements many numerical computing algorithms, was also created
    on top of NumPy. In the early 2000s, John Hunter created **matplotlib** to bring
    scientific graphics to Python. At the same time, Fernando Perez created IPython
    to improve interactivity and productivity in Python. All the fundamental tools
    were here to turn Python into a great open source high-performance framework for
    scientific computing and data analysis.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年代末，Travis Oliphant和其他人开始构建用于处理Python中的数值数据的高效工具：Numeric、Numarray，最终是**NumPy**。**SciPy**，实现了许多数值计算算法，也是建立在NumPy之上的。在2000年代初，John
    Hunter创建了**matplotlib**，将科学图形带到了Python。与此同时，Fernando Perez创建了IPython，以提高Python中的交互性和生产力。所有基本工具都在这里，将Python打造成一个出色的开源高性能框架，用于科学计算和数据分析。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: It is worth noting that Python as a platform for scientific computing was built
    slowly, step-by-step, on top of a programming language that was not originally
    designed for this purpose. This fact might explain a few minor inconsistencies
    or weaknesses of the platform, which do not preclude it from being one of the
    most popular open frameworks for scientific computing at this time. (You can also
    refer to [http://cyrille.rossant.net/whats-wrong-with-scientific-python/](http://cyrille.rossant.net/whats-wrong-with-scientific-python/).)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Python作为科学计算平台是在原本不是为此目的设计的编程语言的基础上逐步构建起来的。这个事实可能解释了平台的一些细微不一致或弱点，但这并不妨碍它成为当今最受欢迎的科学计算开源框架之一。（您也可以参考[http://cyrille.rossant.net/whats-wrong-with-scientific-python/](http://cyrille.rossant.net/whats-wrong-with-scientific-python/)。）
- en: Notable competing open source platforms for numerical computing and data analysis
    include R (which focuses on statistics) and Julia (a young, high-level language
    that focuses on high performance and parallel computing). We will see these two
    languages very briefly in this book, as they can be used from the IPython notebook.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 用于数值计算和数据分析的值得注意的竞争性开源平台包括R（专注于统计）和Julia（一个年轻的、高级的语言，专注于高性能和并行计算）。我们将在本书中简要介绍这两种语言，因为它们可以从IPython笔记本中使用。
- en: In the late 2000s, Wes McKinney created **pandas** for the manipulation and
    analysis of numerical tables and time series. At the same time, the IPython developers
    started to work on a notebook client inspired by mathematical software such as
    **Sage**, **Maple**, and **Mathematica**. Finally, IPython 0.12, released in December
    2011, introduced the HTML-based notebook that has now gone mainstream.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代末，Wes McKinney创建了用于操作和分析数值表和时间序列的**pandas**。与此同时，IPython开发人员开始着手开发受数学软件如**Sage**、**Maple**和**Mathematica**启发的笔记本客户端。最终，2011年12月发布的IPython
    0.12引入了现在已经流行的基于HTML的笔记本。
- en: In 2013, the IPython team received a grant from the Sloan Foundation and a donation
    from Microsoft to support the development of the notebook. IPython 2.0, released
    in early 2014, brought many improvements and long-awaited features.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，IPython团队获得了Sloan基金会的资助和微软的捐赠，以支持笔记本的开发。2014年初发布的IPython 2.0带来了许多改进和期待已久的功能。
- en: What's new in IPython 2.0?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPython 2.0有什么新功能？
- en: 'Here is a short summary of the changes brought by IPython 2.0 (succeeding v1.1):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是IPython 2.0（接替v1.1）带来的变化的简要总结：
- en: 'The notebook comes with a new **modal user interface**:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记本带有一个新的**模态用户界面**：
- en: In the **edit mode**, we can edit a cell by entering code or text.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**编辑模式**下，我们可以通过输入代码或文本来编辑单元格。
- en: In the **command mode**, we can edit the notebook by moving cells around, duplicating
    or deleting them, changing their types, and so on. In this mode, the keyboard
    is mapped to a set of shortcuts that let us perform notebook and cell actions
    efficiently.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**命令模式**下，我们可以通过移动单元格、复制或删除它们、更改它们的类型等来编辑笔记本。在这种模式下，键盘映射到一组快捷键，让我们能够高效地执行笔记本和单元格操作。
- en: '**Notebook widgets** are JavaScript-based GUI widgets that interact dynamically
    with Python objects. This major feature considerably expands the possibilities
    of the IPython notebook. Writing Python code in the notebook is no longer the
    only possible interaction with the kernel. JavaScript widgets and, more generally,
    any JavaScript-based interactive element, can now interact with the kernel in
    real-time.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**笔记本小部件**是基于JavaScript的GUI小部件，可以与Python对象动态交互。这一重要功能极大地扩展了IPython笔记本的可能性。在笔记本中编写Python代码不再是与内核唯一可能的交互方式。JavaScript小部件，更一般地说，任何基于JavaScript的交互元素，现在都可以实时与内核交互。'
- en: We can now open notebooks in different subfolders with the dashboard, using
    the same server. A REST API maps local URIs to the filesystem.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过仪表板在不同的子文件夹中打开笔记本，并使用相同的服务器。一个REST API将本地URI映射到文件系统。
- en: Notebooks are now signed to prevent untrusted code from executing when notebooks
    are opened.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，笔记本已被签名，以防止在打开笔记本时执行不受信任的代码。
- en: The dashboard now contains a **Running** tab with the list of running kernels.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板现在包含一个**正在运行**的标签，显示运行中的内核列表。
- en: The tooltip now appears when pressing *Shift* + *Tab* instead of *Tab*.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示框现在在按下*Shift* + *Tab*时显示，而不是*Tab*。
- en: Notebooks can be run in an interactive session via `%run notebook.ipynb`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过`%run notebook.ipynb`在交互式会话中运行笔记本。
- en: The `%pylab` magic is discouraged in favor of `%matplotlib inline` (to embed
    figures in the notebook) and `import matplotlib.pyplot as plt`. The main reason
    is that `%pylab` clutters the interactive namespace by importing a huge number
    of variables. Also, it might harm the reproducibility and reusability of notebooks.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不推荐使用`%pylab`魔法命令，建议使用`%matplotlib inline`（将图形嵌入到笔记本中）和`import matplotlib.pyplot
    as plt`。主要原因是`%pylab`通过导入大量变量使交互命名空间变得杂乱无章。此外，它可能会影响笔记本的可重复性和可重用性。
- en: Python 2.6 and 3.2 are no longer supported. IPython now requires Python 2.7
    or >= 3.3.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 2.6和3.2不再支持。IPython现在需要Python 2.7或>=3.3。
- en: Roadmap for IPython 3.0 and 4.0
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPython 3.0和4.0的路线图
- en: IPython 3.0 and 4.0, planned for late 2014/early 2015, should facilitate the
    use of non-Python kernels and provide multiuser capabilities to the notebook.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 计划于2014年底/2015年初发布的IPython 3.0和4.0应该有助于使用非Python内核，并为笔记本提供多用户功能。
- en: References
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Here are a few references:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: The Python webpage at [www.python.org](http://www.python.org)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python官方网站：[www.python.org](http://www.python.org)
- en: Python on Wikipedia at [http://en.wikipedia.org/wiki/Python_%28programming_language%29](http://en.wikipedia.org/wiki/Python_%28programming_language%29)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia上的Python条目：[http://en.wikipedia.org/wiki/Python_%28programming_language%29](http://en.wikipedia.org/wiki/Python_%28programming_language%29)
- en: Python's standard library present at [https://docs.python.org/2/library/](https://docs.python.org/2/library/)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python的标准库：[https://docs.python.org/2/library/](https://docs.python.org/2/library/)
- en: Guido van Rossum on Wikipedia at [http://en.wikipedia.org/wiki/Guido_van_Rossum](http://en.wikipedia.org/wiki/Guido_van_Rossum)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Guido van Rossum的Wikipedia条目：[http://en.wikipedia.org/wiki/Guido_van_Rossum](http://en.wikipedia.org/wiki/Guido_van_Rossum)
- en: Conversation with Guido van Rossum on the birth of Python available at [www.artima.com/intv/pythonP.html](http://www.artima.com/intv/pythonP.html)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Guido van Rossum谈论Python的诞生：[www.artima.com/intv/pythonP.html](http://www.artima.com/intv/pythonP.html)
- en: History of scientific Python available at [http://fr.slideshare.net/shoheihido/sci-pyhistory](http://fr.slideshare.net/shoheihido/sci-pyhistory)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于科学Python的历史：[http://fr.slideshare.net/shoheihido/sci-pyhistory](http://fr.slideshare.net/shoheihido/sci-pyhistory)
- en: What's new in IPython 2.0 at [http://ipython.org/ipython-doc/2/whatsnew/version2.0.html](http://ipython.org/ipython-doc/2/whatsnew/version2.0.html)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPython 2.0的新特性：[http://ipython.org/ipython-doc/2/whatsnew/version2.0.html](http://ipython.org/ipython-doc/2/whatsnew/version2.0.html)
- en: IPython on Wikipedia at [http://en.wikipedia.org/wiki/IPython](http://en.wikipedia.org/wiki/IPython)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPython的Wikipedia条目：[http://en.wikipedia.org/wiki/IPython](http://en.wikipedia.org/wiki/IPython)
- en: History of the IPython notebook at [http://blog.fperez.org/2012/01/ipython-notebook-historical.html](http://blog.fperez.org/2012/01/ipython-notebook-historical.html)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPython笔记本的历史：[http://blog.fperez.org/2012/01/ipython-notebook-historical.html](http://blog.fperez.org/2012/01/ipython-notebook-historical.html)
- en: Introducing the IPython notebook
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍IPython笔记本
- en: The notebook is the flagship feature of IPython. This web-based interactive
    environment combines code, rich text, images, videos, animations, mathematics,
    and plots into a single document. This modern tool is an ideal gateway to high-performance
    numerical computing and data science in Python. This entire book has been written
    in the notebook, and the code of every recipe is available as a notebook on the
    book's GitHub repository at [https://github.com/ipython-books/cookbook-code](https://github.com/ipython-books/cookbook-code).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本是IPython的旗舰功能。这个基于Web的交互式环境将代码、富文本、图像、视频、动画、数学公式和图表集成到一个文档中。这个现代化的工具是Python中高性能数值计算和数据科学的理想门户。整本书都是在笔记本中编写的，每个教程的代码都可以在本书的GitHub仓库中的笔记本里找到，地址是：[https://github.com/ipython-books/cookbook-code](https://github.com/ipython-books/cookbook-code)。
- en: In this recipe, we give an introduction to IPython and its notebook. In *Getting
    ready*, we also give general instructions on installing IPython and the Python
    scientific stack.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们介绍了IPython及其笔记本。在*准备工作*中，我们还给出了有关安装IPython和Python科学计算栈的一般说明。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need Python, IPython, NumPy, pandas, and matplotlib in this chapter.
    Together with SciPy and SymPy, these libraries form the core of the Python scientific
    stack ([www.scipy.org/about.html](http://www.scipy.org/about.html)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将需要 Python、IPython、NumPy、pandas 和 matplotlib。与 SciPy 和 SymPy 一起，这些库构成了 Python
    科学计算栈的核心（[www.scipy.org/about.html](http://www.scipy.org/about.html)）。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will find full detailed installation instructions on the book's GitHub repository
    at [https://github.com/ipython-books/cookbook-code](https://github.com/ipython-books/cookbook-code).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库 [https://github.com/ipython-books/cookbook-code](https://github.com/ipython-books/cookbook-code)
    上找到完整的详细安装说明。
- en: We only give a summary of these instructions here; please refer to the link
    above for more up-to-date details.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里只给出这些说明的总结；请参考上面的链接以获取更详细的更新信息。
- en: 'If you''re just getting started with scientific computing in Python, the simplest
    option is to install an all-in-one Python distribution. The most common distributions
    are:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触 Python 中的科学计算，最简单的选择是安装一个一体化的 Python 发行版。最常见的发行版有：
- en: '**Anaconda** (free or commercial license) available at [http://store.continuum.io/cshop/anaconda/](http://store.continuum.io/cshop/anaconda/)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Anaconda**（免费或商业许可）可在 [http://store.continuum.io/cshop/anaconda/](http://store.continuum.io/cshop/anaconda/)
    获取。'
- en: '**Canopy** (free or commercial license) available at [www.enthought.com/products/canopy/](http://www.enthought.com/products/canopy/)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Canopy**（免费或商业许可）可在 [www.enthought.com/products/canopy/](http://www.enthought.com/products/canopy/)
    获取。'
- en: '**Python(x,y)**, a free distribution only for Windows, available at [https://code.google.com/p/pythonxy/](https://code.google.com/p/pythonxy/)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python(x,y)**，仅限 Windows 的免费发行版，可在 [https://code.google.com/p/pythonxy/](https://code.google.com/p/pythonxy/)
    获取。'
- en: We *highly* recommend Anaconda. These distributions contain everything you need
    to get started. You can also install additional packages as needed. You will find
    all the installation instructions in the links mentioned previously.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们*强烈*推荐使用 Anaconda。这些发行版包含了你开始所需的一切。你还可以根据需要安装其他包。你可以在之前提到的链接中找到所有安装说明。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout the book, we assume that you have installed Anaconda. We may not
    be able to offer support to readers who use another distribution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设你已经安装了 Anaconda。如果你使用其他发行版，可能无法获得我们的支持。
- en: 'Alternatively, if you feel brave, you can install Python, IPython, NumPy, pandas,
    and matplotlib manually. You will find all the instructions on the following websites:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你敢于挑战，可以手动安装 Python、IPython、NumPy、pandas 和 matplotlib。你可以在以下网站找到所有安装说明：
- en: '**Python** is the programming language underlying the ecosystem. The instructions
    are available at [www.python.org/](http://www.python.org/).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python** 是支撑整个生态系统的编程语言。安装说明可在 [www.python.org/](http://www.python.org/)
    找到。'
- en: '**IPython** provides tools for interactive computing in Python. The instructions
    for installation are available at [http://ipython.org/install.html](http://ipython.org/install.html).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IPython** 提供用于 Python 的交互式计算工具。安装说明可在 [http://ipython.org/install.html](http://ipython.org/install.html)
    找到。'
- en: '**NumPy/SciPy** are used for numerical computing in Python. The instructions
    for installation are available at [www.scipy.org/install.html](http://www.scipy.org/install.html).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NumPy/SciPy** 用于 Python 中的数值计算。安装说明可在 [www.scipy.org/install.html](http://www.scipy.org/install.html)
    找到。'
- en: '**pandas** provides data structures and tools for data analysis in Python.
    The instructions for installation are available at [http://pandas.pydata.org/getpandas.html](http://pandas.pydata.org/getpandas.html).'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pandas** 提供数据结构和数据分析工具。安装说明可在 [http://pandas.pydata.org/getpandas.html](http://pandas.pydata.org/getpandas.html)
    找到。'
- en: '**matplotlib** helps in creating scientific figures in Python. The instructions
    for installation are available at [http://matplotlib.org/index.html](http://matplotlib.org/index.html).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**matplotlib** 帮助在 Python 中创建科学图形。安装说明可在 [http://matplotlib.org/index.html](http://matplotlib.org/index.html)
    找到。'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Python 2 or Python 3?**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 2 还是 Python 3？**'
- en: Though Python 3 is the latest version at this date, many people are still using
    Python 2\. Python 3 has brought backward-incompatible changes that have slowed
    down its adoption. If you are just getting started with Python for scientific
    computing, you might as well choose Python 3\. In this book, all the code has
    been written for Python 3, but it also works with Python 2\. We will give more
    details about this question in [Chapter 2](ch02.html "Chapter 2. Best Practices
    in Interactive Computing"), *Best Practices in Interactive Computing*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Python 3 是目前最新版本，但许多人仍在使用 Python 2。Python 3 引入了一些不兼容的变更，这些变更减缓了它的普及。如果你刚刚开始进行科学计算，完全可以选择
    Python 3。本书中的所有代码都是为 Python 3 编写的，但也可以在 Python 2 中运行。我们将在[第2章](ch02.html "第2章：交互式计算中的最佳实践")中详细介绍这个问题，*交互式计算中的最佳实践*。
- en: Once you have installed either an all-in-one Python distribution (again, we
    *highly* recommend Anaconda), or Python and the required packages, you can get
    started! In this book, the IPython notebook is used in almost all recipes. This
    tool gives you access to Python from your web browser. We covered the essentials
    of the notebook in the *Learning IPython for Interactive Computing and Data Visualization*
    book. You can also find more information on IPython's website ([http://ipython.org/ipython-doc/stable/notebook/index.html](http://ipython.org/ipython-doc/stable/notebook/index.html)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了一个全功能的 Python 发行版（我们*强烈推荐*使用 Anaconda）或 Python 和所需的包，你就可以开始了！本书中的大多数示例都使用了
    IPython 笔记本工具。这个工具让你能够通过浏览器访问 Python。我们在《学习 IPython 进行交互式计算与数据可视化》一书中介绍了笔记本的基础内容。你也可以在
    IPython 的官网找到更多信息（[http://ipython.org/ipython-doc/stable/notebook/index.html](http://ipython.org/ipython-doc/stable/notebook/index.html)）。
- en: To run the IPython notebook server, type `ipython notebook` in a terminal (also
    called the **command prompt**). Your default web browser should open automatically
    and load the `127.0.0.1:8888` address. Then, you can create a new notebook in
    the dashboard or open an existing notebook. By default, the notebook server opens
    in the current directory (the directory you launched the command from). It lists
    all the notebooks present in this directory (files with the `.ipynb` extension).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 IPython 笔记本服务器，请在终端（也叫**命令提示符**）中输入 `ipython notebook`。默认情况下，您的浏览器会自动打开，并加载
    `127.0.0.1:8888` 地址。然后，你可以在仪表盘中创建一个新的笔记本，或者打开一个已有的笔记本。默认情况下，笔记本服务器会在当前目录下启动（即你执行命令的目录）。它会列出该目录下所有的笔记本（文件扩展名为
    `.ipynb`）。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Windows, you can open a command prompt by pressing the Windows key and *R*,
    then typing `cmd` in the prompt, and finally by pressing *Enter*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你可以通过按下 Windows 键和 *R*，然后在提示符中输入 `cmd`，最后按 *Enter* 打开命令提示符。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We assume that a Python distribution is installed with IPython and that we
    are now in an IPython notebook. We type the following command in a cell, and press
    *Shift* + *Enter* to evaluate it:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们假设已经安装了带有 IPython 的 Python 发行版，并且现在处于 IPython 笔记本中。我们在一个单元格中输入以下命令，并按 *Shift*
    + *Enter* 进行计算：
- en: '[PRE0]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![How to do it...](img/4818OS_01_01.jpg)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/4818OS_01_01.jpg)'
- en: Screenshot of the IPython notebook
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IPython 笔记本的截图
- en: A notebook contains a linear succession of **cells** and **output areas**. A
    cell contains Python code, in one or multiple lines. The output of the code is
    shown in the corresponding output area.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 笔记本包含一系列线性的**单元格**和**输出区域**。一个单元格中包含 Python 代码，可能有一行或多行。代码的输出显示在对应的输出区域中。
- en: 'Now, we do a simple arithmetic operation:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们进行一个简单的算术操作：
- en: '[PRE1]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result of the operation is shown in the output area. Let's be more precise.
    The output area not only displays the text that is printed by any command in the
    cell, but it also displays a text representation of the last returned object.
    Here, the last returned object is the result of `2+2`, that is, `4`.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 操作的结果会显示在输出区域。让我们更具体地说明一下。输出区域不仅显示单元格中任何命令打印的文本，还会显示最后返回对象的文本表示。这里，最后返回的对象是
    `2+2` 的结果，也就是 `4`。
- en: In the next cell, we can recover the value of the last returned object with
    the `_` (underscore) special variable. In practice, it might be more convenient
    to assign objects to named variables such as in `myresult = 2+2`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个单元格中，我们可以通过 `_`（下划线）特殊变量来恢复上一个返回对象的值。实际上，将对象赋值给命名变量（如 `myresult = 2+2`）可能更为方便。
- en: '[PRE2]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'IPython not only accepts Python code, but also shell commands. These commands
    are defined by the operating system (mainly Windows, Linux, and Mac OS X). We
    first type `!` in a cell before typing the shell command. Here, assuming a Linux
    or Mac OS X system, we get the list of all the notebooks in the current directory:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPython 不仅接受 Python 代码，还接受 shell 命令。这些命令由操作系统定义（主要是 Windows、Linux 和 Mac OS X）。我们需要在单元格中输入`!`，然后输入
    shell 命令。在这里，假设是 Linux 或 Mac OS X 系统，我们可以获得当前目录中所有笔记本的列表：
- en: '[PRE3]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On Windows, you should replace `ls` with `dir`.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Windows 上，你应将 `ls` 替换为 `dir`。
- en: 'IPython comes with a library of **magic commands**. These commands are convenient
    shortcuts to common actions. They all start with `%` (the percent character).
    We can get the list of all magic commands with `%lsmagic`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPython 附带了一些**魔法命令**库。这些命令是常见操作的便捷快捷方式，所有魔法命令都以 `%`（百分号字符）开头。我们可以通过 `%lsmagic`
    获取所有魔法命令的列表：
- en: '[PRE4]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Cell magics have a `%%` prefix; they concern entire code cells.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单元魔法命令以`%%`为前缀；它们涉及整个代码单元。
- en: 'For example, the `%%writefile` cell magic lets us create a text file easily.
    This magic command accepts a filename as an argument. All the remaining lines
    in the cell are directly written to this text file. Here, we create a file `test.txt`
    and write `Hello world!` in it:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，`%%writefile` 单元魔法命令可以让我们轻松创建文本文件。此魔法命令接受文件名作为参数。单元中的所有剩余行都将直接写入该文本文件。在这里，我们创建一个文件`test.txt`并写入`Hello
    world!`：
- en: '[PRE5]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we can see in the output of `%lsmagic`, there are many magic commands in
    IPython. We can find more information about any command by adding `?` after it.
    For example, to get some help about the `%run` magic command, we type `%run?`
    as shown here:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在`%lsmagic`的输出中看到的，IPython 中有许多魔法命令。我们可以通过在命令后添加`?`来获取有关任何命令的更多信息。例如，要获取有关`%run`魔法命令的帮助，我们可以输入`%run?`，如下所示：
- en: '[PRE6]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We covered the basics of IPython and the notebook. Let's now turn to the rich
    display and interactive features of the notebook. Until now, we have only created
    **code cells** (containing code). IPython supports other types of cells. In the
    notebook toolbar, there is a drop-down menu to select the cell's type. The most
    common cell type after the code cell is the **Markdown cell**.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经介绍了 IPython 和笔记本的基础知识。现在让我们转向笔记本的丰富显示和交互功能。到目前为止，我们只创建了**代码单元**（包含代码）。IPython
    支持其他类型的单元。在笔记本工具栏中，有一个下拉菜单可以选择单元的类型。在代码单元之后，最常见的单元类型是**Markdown 单元**。
- en: 'Markdown cells contain rich text formatted with **Markdown**, a popular plain
    text-formatting syntax. This format supports normal text, headers, bold, italics,
    hypertext links, images, mathematical equations in **LaTeX** (a typesetting system
    adapted to mathematics), code, HTML elements, and other features, as shown here:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Markdown 单元包含用**Markdown**格式化的丰富文本，这是一种流行的纯文本格式化语法。该格式支持普通文本、标题、粗体、斜体、超文本链接、图像、**LaTeX**（一种为数学适配的排版系统）中的数学方程式、代码、HTML
    元素以及其他功能，如下所示：
- en: '[PRE7]python'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE7]python'
- en: print("Hello world!")
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print("Hello world!")
- en: '[PRE8]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running a Markdown cell (by pressing *Shift* + *Enter*, for example) displays
    the output, as shown in the following screenshot:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行一个 Markdown 单元（例如，按 *Shift* + *Enter*）将显示输出，如下图所示：
- en: '![How to do it...](img/4818OS_01_02.jpg)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_01_02.jpg)'
- en: Rich text formatting with Markdown in the IPython notebook
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 IPython 笔记本中使用 Markdown 进行丰富文本格式化
- en: Tip
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: LaTeX equations are rendered with the `MathJax` library. We can enter inline
    equations with `$...$` and displayed equations with `$$...$$`. We can also use
    environments such as `equation`, `eqnarray`, or `align`. These features are very
    useful to scientific users.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LaTeX 方程式使用 `MathJax` 库渲染。我们可以使用`$...$`输入内联方程式，使用`$$...$$`输入显示的方程式。我们还可以使用如
    `equation`、`eqnarray` 或 `align` 等环境。这些功能对于科学用户非常有用。
- en: By combining code cells and Markdown cells, we can create a standalone interactive
    document that combines computations (code), text, and graphics.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过结合代码单元和Markdown单元，我们可以创建一个独立的交互式文档，结合计算（代码）、文本和图形。
- en: IPython also comes with a sophisticated display system that lets us insert rich
    web elements in the notebook. Here, we show how to add HTML, **SVG** (**Scalable
    Vector Graphics**), and even YouTube videos in a notebook.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPython 还带有一个复杂的显示系统，允许我们在笔记本中插入丰富的网页元素。在这里，我们展示如何在笔记本中添加 HTML、**SVG**（**可缩放矢量图形**）甚至
    YouTube 视频。
- en: 'First, we need to import some classes:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们需要导入一些类：
- en: '[PRE9]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We create an HTML table dynamically with Python, and we display it in the notebook:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 Python 动态创建 HTML 表格，并将其显示在笔记本中：
- en: '[PRE10]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![How to do it...](img/4818OS_01_03.jpg)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_01_03.jpg)'
- en: An HTML table in the notebook
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 笔记本中的 HTML 表格
- en: 'Similarly, we can create SVG graphics dynamically:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，我们可以动态创建 SVG 图形：
- en: '[PRE11]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![How to do it...](img/4818OS_01_04.jpg)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/4818OS_01_04.jpg)'
- en: SVG in the notebook
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 笔记本中的 SVG
- en: 'Finally, we display a YouTube video by giving its identifier to `YoutubeVideo`:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们通过将 YouTube 视频的标识符传递给 `YoutubeVideo` 来显示 YouTube 视频：
- en: '[PRE12]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![How to do it...](img/4818OS_01_05.jpg)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/4818OS_01_05.jpg)'
- en: YouTube in the notebook
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 笔记本中的 YouTube
- en: 'Now, we illustrate the latest interactive features in IPython 2.0+, namely
    JavaScript widgets. Here, we create a drop-down menu to select videos:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们展示了 IPython 2.0+ 中的最新交互式功能，即 JavaScript 小部件。在这里，我们创建了一个下拉菜单来选择视频：
- en: '[PRE13]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![How to do it...](img/4818OS_01_06.jpg)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/4818OS_01_06.jpg)'
- en: An interactive widget in the notebook
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 笔记本中的交互式小部件
- en: The interactive features of IPython 2.0 bring a whole new dimension to the notebook,
    and we can expect many developments in the future.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 2.0 的交互式功能为笔记本带来了全新的维度，我们可以期待未来会有更多的发展。
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Notebooks are saved as structured text files (JSON format), which makes them
    easily shareable. Here are the contents of a simple notebook:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本以结构化文本文件（JSON 格式）保存，这使得它们易于共享。以下是一个简单笔记本的内容：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: IPython comes with a special tool, **nbconvert**, which converts notebooks to
    other formats such as HTML and PDF ([http://ipython.org/ipython-doc/stable/notebook/index.html](http://ipython.org/ipython-doc/stable/notebook/index.html)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 附带了一个特殊工具 **nbconvert**，它将笔记本转换为其他格式，如 HTML 和 PDF ([http://ipython.org/ipython-doc/stable/notebook/index.html](http://ipython.org/ipython-doc/stable/notebook/index.html))。
- en: Another online tool, **nbviewer**, allows us to render a publicly available
    notebook directly in the browser and is available at [http://nbviewer.ipython.org](http://nbviewer.ipython.org).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在线工具 **nbviewer** 允许我们直接在浏览器中呈现公开可用的笔记本，访问地址为 [http://nbviewer.ipython.org](http://nbviewer.ipython.org)。
- en: We will cover many of these possibilities in the subsequent chapters, notably
    in [Chapter 3](ch03.html "Chapter 3. Mastering the Notebook"), *Mastering the
    Notebook*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中讨论这些可能性，特别是在 [第 3 章](ch03.html "第 3 章. 精通笔记本")，*精通笔记本*。
- en: 'Here are a few references about the notebook:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于笔记本的一些参考资料：
- en: Official page of the notebook available at [http://ipython.org/notebook](http://ipython.org/notebook)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方笔记本页面，访问地址为 [http://ipython.org/notebook](http://ipython.org/notebook)
- en: Documentation of the notebook available at [http://ipython.org/ipython-doc/dev/notebook/index.html](http://ipython.org/ipython-doc/dev/notebook/index.html)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记本的文档，访问地址为 [http://ipython.org/ipython-doc/dev/notebook/index.html](http://ipython.org/ipython-doc/dev/notebook/index.html)
- en: Official notebook examples present at [https://github.com/ipython/ipython/tree/master/examples/Notebook](https://github.com/ipython/ipython/tree/master/examples/Notebook)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方笔记本示例，访问地址为 [https://github.com/ipython/ipython/tree/master/examples/Notebook](https://github.com/ipython/ipython/tree/master/examples/Notebook)
- en: User-curated gallery of interesting notebooks available at [https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks](https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户策划的有趣笔记本画廊，访问地址为 [https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks](https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks)
- en: Official tutorial on the interactive widgets present at [http://nbviewer.ipython.org/github/ipython/ipython/tree/master/examples/Interactive%20Widgets/](http://nbviewer.ipython.org/github/ipython/ipython/tree/master/examples/Interactive%20Widgets/)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于交互式小部件的官方教程，访问地址为 [http://nbviewer.ipython.org/github/ipython/ipython/tree/master/examples/Interactive%20Widgets/](http://nbviewer.ipython.org/github/ipython/ipython/tree/master/examples/Interactive%20Widgets/)
- en: See also
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Getting started with data exploratory analysis in IPython* recipe
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 IPython 中开始数据探索性分析* 配方'
- en: Getting started with exploratory data analysis in IPython
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 IPython 中开始探索性数据分析
- en: In this recipe, we will give an introduction to IPython for data analysis. Most
    of the subject has been covered in the *Learning IPython for Interactive Computing
    and Data Visualization* book, but we will review the basics here.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将介绍 IPython 在数据分析中的应用。大部分内容已在 *学习 IPython 进行交互式计算和数据可视化* 一书中涵盖，但我们将在这里回顾基础知识。
- en: 'We will download and analyze a dataset about attendance on Montreal''s bicycle
    tracks. This example is largely inspired by a presentation from Julia Evans (available
    at [http://nbviewer.ipython.org/github/jvns/talks/blob/master/mtlpy35/pistes-cyclables.ipynb](http://nbviewer.ipython.org/github/jvns/talks/blob/master/mtlpy35/pistes-cyclables.ipynb)).
    Specifically, we will introduce the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将下载并分析关于蒙特利尔自行车轨道的出勤数据集。这个示例主要受到 Julia Evans 的演讲启发（可以在 [http://nbviewer.ipython.org/github/jvns/talks/blob/master/mtlpy35/pistes-cyclables.ipynb](http://nbviewer.ipython.org/github/jvns/talks/blob/master/mtlpy35/pistes-cyclables.ipynb)
    中查看）。具体来说，我们将介绍以下内容：
- en: Data manipulation with pandas
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 pandas 进行数据处理
- en: Data visualization with matplotlib
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 matplotlib 进行数据可视化
- en: Interactive widgets with IPython 2.0+
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IPython 2.0+ 的交互式小部件
- en: How to do it...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The very first step is to import the scientific packages we will be using in
    this recipe, namely NumPy, pandas, and matplotlib. We also instruct matplotlib
    to render the figures as inline images in the notebook:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是导入我们在此示例中将要使用的科学计算包，即 NumPy、pandas 和 matplotlib。我们还指示 matplotlib 将图形渲染为
    notebook 中的内联图像：
- en: '[PRE15]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we create a new Python variable called `url` that contains the address
    to a **CSV** (**Comma-separated values**) data file. This standard text-based
    file format is used to store tabular data:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个新的 Python 变量 `url`，它包含一个 **CSV**（**逗号分隔值**）数据文件的地址。该标准文本格式用于存储表格数据：
- en: '[PRE16]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'pandas defines a `read_csv()` function that can read any CSV file. Here, we
    pass the URL to the file. pandas will automatically download and parse the file,
    and return a `DataFrame` object. We need to specify a few options to make sure
    that the dates are parsed correctly:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: pandas 定义了一个 `read_csv()` 函数，可以读取任何 CSV 文件。在这里，我们传入文件的 URL。pandas 会自动下载并解析文件，然后返回一个
    `DataFrame` 对象。我们需要指定一些选项，以确保日期能够正确解析：
- en: '[PRE17]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `df` variable contains a `DataFrame` object, a specific pandas data structure
    that contains 2D tabular data. The `head(n)` method displays the first *n* rows
    of this table. In the notebook, pandas displays a `DataFrame` object in an HTML
    table, as shown in the following screenshot:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`df` 变量包含一个 `DataFrame` 对象，这是 pandas 特定的数据结构，包含二维表格数据。`head(n)` 方法显示表格的前 *n*
    行。在 notebook 中，pandas 会以 HTML 表格的形式显示 `DataFrame` 对象，如以下截图所示：'
- en: '[PRE18]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![How to do it...](img/4818OS_01_07.jpg)'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_01_07.jpg)'
- en: First rows of the DataFrame
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DataFrame` 的前几行'
- en: Here, every row contains the number of bicycles on every track of the city,
    for every day of the year.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，每一行包含每一天全年在城市各个轨道上的自行车数量。
- en: 'We can get some summary statistics of the table with the `describe()` method:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过 `describe()` 方法获得表格的一些摘要统计信息：
- en: '[PRE19]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![How to do it...](img/4818OS_01_08.jpg)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_01_08.jpg)'
- en: Summary statistics of the DataFrame
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DataFrame` 的摘要统计信息'
- en: 'Let''s display some figures. We will plot the daily attendance of two tracks.
    First, we select the two columns, `Berri1` and `PierDup`. Then, we call the `plot()`
    method:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们展示一些图形。我们将绘制两条轨道的每日出勤数据。首先，选择两列数据，`Berri1` 和 `PierDup`。然后，我们调用 `plot()` 方法：
- en: '[PRE20]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![How to do it...](img/4818OS_01_09.jpg)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_01_09.jpg)'
- en: 'Now, we move to a slightly more advanced analysis. We will look at the attendance
    of all tracks as a function of the weekday. We can get the weekday easily with
    pandas: the `index` attribute of the `DataFrame` object contains the dates of
    all rows in the table. This index has a few date-related attributes, including
    `weekday`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们进入稍微复杂一点的分析。我们将查看所有轨道的出勤情况与星期几的关系。我们可以通过 pandas 很容易地获取星期几：`DataFrame` 对象的
    `index` 属性包含表格中所有行的日期。这个索引有一些与日期相关的属性，包括 `weekday`：
- en: '[PRE21]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, we would like to have names (Monday, Tuesday, and so on) instead of
    numbers between 0 and 6\. This can be done easily. First, we create a `days` array
    with all the weekday names. Then, we index it by `df.index.weekday`. This operation
    replaces every integer in the index by the corresponding name in `days`. The first
    element, `Monday`, has the index 0, so every 0 in `df.index.weekday` is replaced
    by `Monday` and so on. We assign this new index to a new column, `Weekday`, in
    `DataFrame`:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，我们希望将 0 到 6 之间的数字替换为星期几的名称（例如星期一、星期二等）。这可以很容易地做到。首先，我们创建一个 `days` 数组，包含所有星期几的名称。然后，我们通过
    `df.index.weekday` 对其进行索引。这个操作将索引中的每个整数替换为 `days` 中对应的名称。第一个元素是 `Monday`，索引为 0，因此
    `df.index.weekday` 中的每个 0 会被替换为 `Monday`，以此类推。我们将这个新的索引赋给 `DataFrame` 中的新列 `Weekday`：
- en: '[PRE22]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To get the attendance as a function of the weekday, we need to group the table
    elements by the weekday. The `groupby()` method lets us do just that. Once grouped,
    we can sum all the rows in every group:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了按星期几获取出勤情况，我们需要按星期几对表格元素进行分组。`groupby()` 方法可以帮助我们做到这一点。分组后，我们可以对每个组中的所有行进行求和：
- en: '[PRE23]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![How to do it...](img/4818OS_01_10.jpg)'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现...](img/4818OS_01_10.jpg)'
- en: Grouped data with pandas
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 pandas 对数据进行分组
- en: 'We can now display this information in a figure. We first need to reorder the
    table by the weekday using `ix` (indexing operation). Then, we plot the table,
    specifying the line width:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在图形中显示这些信息了。我们首先需要使用 `ix`（索引操作）按星期几重新排序表格。然后，我们绘制表格，指定线条宽度：
- en: '[PRE24]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![How to do it...](img/4818OS_01_11.jpg)'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现...](img/4818OS_01_11.jpg)'
- en: 'Finally, let''s illustrate the new interactive capabilities of the notebook
    in IPython 2.0\. We will plot a *smoothed* version of the track attendance as
    a function of time (**rolling mean**). The idea is to compute the mean value in
    the neighborhood of any day. The larger the neighborhood, the smoother the curve.
    We will create an interactive slider in the notebook to vary this parameter in
    real time in the plot. All we have to do is add the `@interact` decorator above
    our plotting function:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们说明 IPython 2.0 中新的交互式功能。我们将绘制一个*平滑*的轨迹出勤情况与时间的关系图（**滚动平均**）。其思路是计算某一天邻近区域的平均值。邻域越大，曲线越平滑。我们将在笔记本中创建一个交互式滑块，以实时调整这个参数。我们只需要在绘图函数上方添加
    `@interact` 装饰器：
- en: '[PRE25]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![How to do it...](img/4818OS_01_12.jpg)'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现...](img/4818OS_01_12.jpg)'
- en: Interactive widget in the notebook
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 笔记本中的交互式小部件
- en: There's more...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: pandas is the right tool to load and manipulate a dataset. Other tools and methods
    are generally required for more advanced analyses (signal processing, statistics,
    and mathematical modeling). We will cover these steps in the second part of this
    book, starting with [Chapter 7](ch07.html "Chapter 7. Statistical Data Analysis"),
    *Statistical Data Analysis*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 是加载和操作数据集的正确工具。对于更高级的分析（信号处理、统计和数学建模），通常需要其他工具和方法。我们将在本书的第二部分中讲解这些步骤，从[第
    7 章](ch07.html "第 7 章. 统计数据分析")开始，*统计数据分析*。
- en: 'Here are some more references about data manipulation with pandas:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些关于使用 pandas 进行数据操作的参考资料：
- en: '*Learning IPython for Interactive Computing and Data Visualization*, *Packt
    Publishing*, our previous book'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《学习 IPython 进行互动计算和数据可视化》*，*Packt Publishing*，我们之前的书籍'
- en: '*Python for Data Analysis*, *O''Reilly Media*, by Wes McKinney, the creator
    of pandas'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python 数据分析*，*O''Reilly Media*，由 pandas 的创建者 Wes McKinney 编写'
- en: The documentation of pandas available at [http://pandas.pydata.org/pandas-docs/stable/](http://pandas.pydata.org/pandas-docs/stable/)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pandas 的文档可通过 [http://pandas.pydata.org/pandas-docs/stable/](http://pandas.pydata.org/pandas-docs/stable/)
    获取
- en: See also
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Introducing the multidimensional array in NumPy for fast array computations*
    recipe
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*介绍 NumPy 中的多维数组用于快速数组计算* 示例'
- en: Introducing the multidimensional array in NumPy for fast array computations
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 NumPy 中的多维数组用于快速数组计算
- en: 'NumPy is the main foundation of the scientific Python ecosystem. This library
    offers a specific data structure for high-performance numerical computing: the
    **multidimensional array**. The rationale behind NumPy is the following: Python
    being a high-level dynamic language, it is easier to use but slower than a low-level
    language such as C. NumPy implements the multidimensional array structure in C
    and provides a convenient Python interface, thus bringing together high performance
    and ease of use. NumPy is used by many Python libraries. For example, pandas is
    built on top of NumPy.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 是科学 Python 生态系统的主要基础。这个库提供了一种用于高性能数值计算的特定数据结构：**多维数组**。NumPy 背后的原理是：Python
    作为一种高级动态语言，使用起来更方便，但比起 C 这样的低级语言要慢。NumPy 在 C 中实现了多维数组结构，并提供了一个便捷的 Python 接口，从而将高性能与易用性结合在一起。许多
    Python 库都使用了 NumPy。例如，pandas 就是建立在 NumPy 之上的。
- en: In this recipe, we will illustrate the basic concepts of the multidimensional
    array. A more comprehensive coverage of the topic can be found in the *Learning
    IPython for Interactive Computing and Data Visualization* book.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将说明多维数组的基本概念。有关该主题的更全面的讲解可以在*《学习 IPython 进行互动计算和数据可视化》*一书中找到。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s import the built-in `random` Python module and NumPy:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入内置的 `random` Python 模块和 NumPy：
- en: '[PRE26]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We use the `%precision` magic (defined in IPython) to show only three decimals
    in the Python output. This is just to reduce the number of digits in the output's
    text.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `%precision` 魔法命令（在 IPython 中定义）来仅显示 Python 输出中的三位小数。这只是为了减少输出文本中的数字位数。
- en: '[PRE27]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We generate two Python lists, `x` and `y`, each one containing 1 million random
    numbers between 0 and 1:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们生成两个 Python 列表，`x` 和 `y`，每个列表包含 100 万个介于 0 和 1 之间的随机数：
- en: '[PRE28]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s compute the element-wise sum of all these numbers: the first element
    of `x` plus the first element of `y`, and so on. We use a `for` loop in a list
    comprehension:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们计算所有这些数字的逐元素和：`x` 的第一个元素加上 `y` 的第一个元素，以此类推。我们使用 `for` 循环在列表推导中进行操作：
- en: '[PRE29]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'How long does this computation take? IPython defines a handy `%timeit` magic
    command to quickly evaluate the time taken by a single statement:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个计算需要多长时间？IPython 定义了一个方便的 `%timeit` 魔法命令，可以快速评估单个语句所花费的时间：
- en: '[PRE30]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we will perform the same operation with NumPy. NumPy works on multidimensional
    arrays, so we need to convert our lists to arrays. The `np.array()` function does
    just that:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用 NumPy 执行相同的操作。NumPy 处理多维数组，因此我们需要将列表转换为数组。`np.array()` 函数正好完成了这个操作：
- en: '[PRE31]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `xa` and `ya` arrays contain the exact same numbers that our original lists,
    `x` and `y`, contained. Those lists were instances of the `list` built-in class,
    while our arrays are instances of the `ndarray` NumPy class. These types are implemented
    very differently in Python and NumPy. In this example, we will see that using
    arrays instead of lists leads to drastic performance improvements.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`xa` 和 `ya` 数组包含与我们原始列表 `x` 和 `y` 相同的数字。这些列表是 `list` 内建类的实例，而我们的数组是 `ndarray`
    NumPy 类的实例。这些类型在 Python 和 NumPy 中的实现方式非常不同。在这个例子中，我们将看到，使用数组代替列表可以大幅提高性能。'
- en: 'Now, to compute the element-wise sum of these arrays, we don''t need to do
    a `for` loop anymore. In NumPy, adding two arrays means adding the elements of
    the arrays component-by-component. This is the standard mathematical notation
    in linear algebra (operations on vectors and matrices):'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了计算这些数组的逐元素和，我们不再需要做 `for` 循环。在 NumPy 中，添加两个数组意味着逐个元素地将数组的元素相加。这是线性代数中的标准数学符号（对向量和矩阵的操作）：
- en: '[PRE32]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We see that the `z` list and the `za` array contain the same elements (the sum
    of the numbers in `x` and `y`).
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们看到，`z` 列表和 `za` 数组包含相同的元素（`x` 和 `y` 中数字的和）。
- en: 'Let''s compare the performance of this NumPy operation with the native Python
    loop:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将这个 NumPy 操作的性能与原生 Python 循环进行比较：
- en: '[PRE33]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We observe that this operation is more than one order of magnitude faster in
    NumPy than in pure Python!
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们观察到，在 NumPy 中，这个操作比在纯 Python 中快了一个数量级以上！
- en: 'Now, we will compute something else: the sum of all elements in `x` or `xa`.
    Although this is not an element-wise operation, NumPy is still highly efficient
    here. The pure Python version uses the built-in `sum()` function on an iterable.
    The NumPy version uses the `np.sum()` function on a NumPy array:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将计算其他内容：`x` 或 `xa` 中所有元素的和。尽管这不是逐元素操作，但 NumPy 在这里仍然非常高效。纯 Python 版本使用内建的
    `sum()` 函数对可迭代对象求和，而 NumPy 版本使用 `np.sum()` 函数对 NumPy 数组求和：
- en: '[PRE34]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We also observe an impressive speedup here also.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里也观察到令人印象深刻的加速。
- en: 'Finally, let''s perform one last operation: computing the arithmetic distance
    between any pair of numbers in our two lists (we only consider the first 1000
    elements to keep computing times reasonable). First, we implement this in pure
    Python with two nested `for` loops:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们执行最后一个操作：计算我们两个列表中任意一对数字之间的算术距离（我们只考虑前 1000 个元素，以保持计算时间合理）。首先，我们用两个嵌套的
    `for` 循环在纯 Python 中实现这个操作：
- en: '[PRE35]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we use a NumPy implementation, bringing out two slightly more advanced
    notions. First, we consider a **two-dimensional array** (or matrix). This is how
    we deal with the two indices, *i* and *j*. Second, we use **broadcasting** to
    perform an operation between a 2D array and 1D array. We will give more details
    in the *How it works...* section.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用 NumPy 实现，提出两个稍微高级的概念。首先，我们考虑一个**二维数组**（或矩阵）。这就是我们如何处理两个索引，*i* 和 *j*。其次，我们使用**广播**在
    2D 数组和 1D 数组之间执行操作。我们将在*它是如何工作的...*部分提供更多细节。
- en: '[PRE36]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here again, we observe significant speedups.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们再次观察到显著的加速。
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A NumPy array is a homogeneous block of data organized in a multidimensional
    finite grid. All elements of the array share the same **data type**, also called
    **dtype** (integer, floating-point number, and so on). The **shape** of the array
    is an *n*-tuple that gives the size of each axis.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组是一个均匀的数据块，按照多维有限网格组织。数组中的所有元素都具有相同的**数据类型**，也叫做 **dtype**（整数、浮动小数等）。数组的**形状**是一个
    *n* 元组，表示每个维度的大小。
- en: A 1D array is a **vector**; its shape is just the number of components.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一维数组是一个**向量**；它的形状只是组件的数量。
- en: A 2D array is a **matrix**; its shape is *(number of rows, number of columns)*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 二维数组是一个**矩阵**；它的形状是*(行数，列数)*。
- en: 'The following figure illustrates the structure of a 3D (3, 4, 2) array that
    contains 24 elements:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个包含 24 个元素的 3D（3, 4, 2）数组的结构：
- en: '![How it works...](img/4818OS_01_13.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![如何运作...](img/4818OS_01_13.jpg)'
- en: A NumPy array
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 NumPy 数组
- en: The slicing syntax in Python nicely translates to array indexing in NumPy. Also,
    we can add an extra dimension to an existing array, using `None` or `np.newaxis`
    in the index. We used this trick in our previous example.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的切片语法与 NumPy 中的数组索引非常匹配。此外，我们可以通过在索引中使用 `None` 或 `np.newaxis` 为现有数组添加一个额外的维度。我们在之前的例子中使用了这一技巧。
- en: Element-wise arithmetic operations can be performed on NumPy arrays that have
    the *same shape*. However, broadcasting relaxes this condition by allowing operations
    on arrays with different shapes in certain conditions. Notably, when one array
    has fewer dimensions than the other, it can be virtually stretched to match the
    other array's dimension. This is how we computed the pairwise distance between
    any pair of elements in `xa` and `ya`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对具有*相同形状*的 NumPy 数组执行逐元素的算术操作。然而，广播机制放宽了这一条件，它允许在特定条件下对具有不同形状的数组进行操作。特别是，当一个数组的维度比另一个数组少时，它可以被虚拟地拉伸以匹配另一个数组的维度。这就是我们如何计算
    `xa` 和 `ya` 中任何两个元素之间的成对距离的方式。
- en: 'How can array operations be so much faster than Python loops? There are several
    reasons, and we will review them in detail in [Chapter 4](ch04.html "Chapter 4. Profiling
    and Optimization"), *Profiling and Optimization*. We can already say here that:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 数组操作为什么比 Python 循环快得多？有几个原因，我们将在[第 4 章](ch04.html "第 4 章. 性能分析与优化")，*性能分析与优化*中详细回顾这些原因。我们在这里可以先说：
- en: In NumPy, array operations are implemented internally with C loops rather than
    Python loops. Python is typically slower than C because of its interpreted and
    dynamically-typed nature.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 NumPy 中，数组操作是通过 C 循环而非 Python 循环实现的。由于 Python 是解释型语言且具有动态类型的特性，它通常比 C 慢。
- en: The data in a NumPy array is stored in a **contiguous** block of memory in RAM.
    This property leads to more efficient use of CPU cycles and cache.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 数组中的数据存储在 RAM 中一个**连续**的内存块中。这一特性使得 CPU 周期和缓存的使用更为高效。
- en: There's more...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: There's obviously much more to say about this subject. Our previous book, *Learning
    IPython for Interactive Computing and Data Visualization*, contains more details
    about basic array operations. We will use the array data structure routinely throughout
    this book. Notably, [Chapter 4](ch04.html "Chapter 4. Profiling and Optimization"),
    *Profiling and Optimization*, covers advanced techniques of using NumPy arrays.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个话题还有很多内容可以讨论。我们之前的书籍 *Learning IPython for Interactive Computing and Data
    Visualization* 包含了更多关于基本数组操作的细节。本书将经常使用数组数据结构。特别地，[第 4 章](ch04.html "第 4 章. 性能分析与优化")，*性能分析与优化*，涵盖了使用
    NumPy 数组的高级技巧。
- en: 'Here are some more references:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考文献：
- en: Introduction to the `ndarray` on NumPy's documentation available at [http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html](http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 文档中关于 `ndarray` 的介绍可参考[http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html](http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html)
- en: Tutorial on the NumPy array available at [http://wiki.scipy.org/Tentative_NumPy_Tutorial](http://wiki.scipy.org/Tentative_NumPy_Tutorial)
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 数组教程可参考[http://wiki.scipy.org/Tentative_NumPy_Tutorial](http://wiki.scipy.org/Tentative_NumPy_Tutorial)
- en: The NumPy array in the SciPy lectures notes present at [http://scipy-lectures.github.io/intro/numpy/array_object.html](http://scipy-lectures.github.io/intro/numpy/array_object.html)
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SciPy 讲义中关于 NumPy 数组的介绍，参见[http://scipy-lectures.github.io/intro/numpy/array_object.html](http://scipy-lectures.github.io/intro/numpy/array_object.html)
- en: See also
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Getting started with exploratory data analysis in IPython* recipe
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始进行 IPython 中的探索性数据分析* 的教程'
- en: The *Understanding the internals of NumPy to avoid unnecessary array copying*
    recipe in [Chapter 4](ch04.html "Chapter 4. Profiling and Optimization"), *Profiling
    and Optimization*
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 4 章](ch04.html "第 4 章. 性能分析与优化")中的*理解 NumPy 的内部机制以避免不必要的数组复制*，*性能分析与优化*'
- en: Creating an IPython extension with custom magic commands
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有自定义魔法命令的 IPython 扩展
- en: Although IPython comes with a wide variety of magic commands, there are cases
    where we need to implement custom functionality in a new magic command. In this
    recipe, we will show how to create line and magic cells, and how to integrate
    them in an IPython extension.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 IPython 提供了各种各样的魔法命令，但在某些情况下，我们需要在新的魔法命令中实现自定义功能。在本教程中，我们将展示如何创建行魔法和单元魔法，并且如何将它们集成到
    IPython 扩展中。
- en: How to do it...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s import a few functions from the IPython magic system:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从 IPython 魔法系统中导入一些函数：
- en: '[PRE37]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Defining a new line magic is particularly simple. First, we create a function
    that accepts the contents of the line (except the initial `%`-prefixed name).
    The name of this function is the name of the magic. Then, we decorate this function
    with `@register_line_magic`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的行魔法非常简单。首先，我们创建一个接受行内容的函数（不包括前面的 `%`-前缀名称）。这个函数的名称就是魔法的名称。然后，我们使用`@register_line_magic`装饰这个函数：
- en: '[PRE38]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let's create a slightly more useful `%%csv` cell magic that parses a CSV string
    and returns a pandas `DataFrame` object. This time, the arguments of the function
    are the characters that follow `%%csv` in the first line and the contents of the
    cell (from the cell's second line to the last).
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个稍微有用一些的`%%csv`单元魔法，它解析 CSV 字符串并返回一个 pandas `DataFrame` 对象。这次，函数的参数是紧随`%%csv`之后的字符（位于第一行）和单元格的内容（从单元格的第二行到最后一行）。
- en: '[PRE39]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can access the returned object with `_`.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过 `_` 访问返回的对象。
- en: '[PRE40]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The method we described is useful in an interactive session. If we want to
    use the same magic in multiple notebooks or if we want to distribute it, then
    we need to create an **IPython extension** that implements our custom magic command.
    The first step is to create a Python script (`csvmagic.py` here) that implements
    the magic. We also need to define a special function `load_ipython_extension(ipython)`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们描述的方法在交互式会话中非常有用。如果我们想在多个笔记本中使用相同的魔法，或者想要分发它，那么我们需要创建一个实现自定义魔法命令的**IPython
    扩展**。第一步是创建一个 Python 脚本（这里是`csvmagic.py`），它实现了魔法功能。我们还需要定义一个特殊的函数`load_ipython_extension(ipython)`：
- en: '[PRE41]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once the extension module is created, we need to import it into the IPython
    session. We can do this with the `%load_ext` magic command. Here, loading our
    extension immediately registers our `%%csv` magic function in the interactive
    shell:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦扩展模块创建完成，我们需要将其导入到 IPython 会话中。我们可以通过 `%load_ext` 魔法命令做到这一点。在这里，加载我们的扩展立即在交互式
    shell 中注册我们的`%%csv`魔法函数：
- en: '[PRE42]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: An IPython extension is a Python module that implements the top-level `load_ipython_extension(ipython)`
    function. When the `%load_ext` magic command is called, the module is loaded and
    the `load_ipython_extension(ipython)` function is called. This function is passed
    the current `InteractiveShell` instance as an argument. This object implements
    several methods we can use to interact with the current IPython session.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 扩展是一个 Python 模块，它实现了顶级的`load_ipython_extension(ipython)`函数。当 `%load_ext`
    魔法命令被调用时，模块会被加载，且会调用`load_ipython_extension(ipython)`函数。这个函数会将当前的`InteractiveShell`实例作为参数传入。这个对象实现了几个方法，我们可以用来与当前的
    IPython 会话进行交互。
- en: The InteractiveShell class
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: InteractiveShell 类
- en: An interactive IPython session is represented by a (singleton) instance of the
    `InteractiveShell` class. This object handles the history, interactive namespace,
    and most features available in the session.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一个交互式 IPython 会话由`InteractiveShell`类的（单例）实例表示。这个对象处理历史记录、交互式命名空间以及会话中大多数可用功能。
- en: Within an interactive shell, we can get the current `InteractiveShell` instance
    with the `get_ipython()` function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式 shell 中，我们可以通过`get_ipython()`函数获取当前的`InteractiveShell`实例。
- en: 'The list of all methods of `InteractiveShell` can be found in the reference
    API (see link at the end of this recipe). The following are the most important
    attributes and methods:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`InteractiveShell`的所有方法列表可以在参考 API 中找到（请参见本教程末尾的链接）。以下是最重要的属性和方法：'
- en: '`user_ns`: The **user namespace** (a dictionary).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_ns`: **用户命名空间**（一个字典）。'
- en: '`push()`: **Push** (or inject) Python variables in the interactive namespace.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push()`: **推送**（或注入）Python 变量到交互命名空间中。'
- en: '`ev()`: **Evaluate** a Python expression in the user namespace.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ev()`: **评估**用户命名空间中的 Python 表达式。'
- en: '`ex()`: **Execute** a Python statement in the user namespace.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ex()`: **执行**用户命名空间中的Python语句。'
- en: '`run_cell()`: **Run a** **cell** (given as a string), possibly containing IPython
    magic commands.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run_cell()`: **运行**一个**单元格**（以字符串形式给出），可能包含IPython魔法命令。'
- en: '`safe_execfile()`: **Safely execute** a Python script.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`safe_execfile()`: **安全地执行**一个Python脚本。'
- en: '`system()`: Execute a **system** command.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system()`: 执行一个**系统**命令。'
- en: '`write()`: **Write** a string to the default output.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write()`: **写入**一个字符串到默认输出。'
- en: '`write_err()`: **Write** a string to the default **error** output.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write_err()`: **写入**一个字符串到默认的**错误**输出。'
- en: '`register_magic_function()`: **Register** a standalone function as an IPython
    **magic function**. We used this method in this recipe.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register_magic_function()`: **注册**一个独立的函数作为IPython**魔法函数**。我们在本食谱中使用了此方法。'
- en: Loading an extension
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载扩展
- en: The Python extension module needs to be importable when using `%load_ext`. Here,
    our module is in the current directory. In other situations, it has to be in the
    Python path. It can also be stored in `~\.ipython\extensions`, which is automatically
    put in the Python path.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`%load_ext`时，Python扩展模块需要是可导入的。这里，我们的模块位于当前目录。在其他情况下，它必须在Python路径中。它还可以存储在`~\.ipython\extensions`中，系统会自动将其加入Python路径。
- en: To ensure that our magic is automatically defined in our IPython profile, we
    can instruct IPython to load our extension automatically when a new interactive
    shell is launched. To do this, we have to open the `~/.ipython/profile_default/ipython_config.py`
    file and put `'csvmagic'` in the `c.InteractiveShellApp.extensions` list. The
    `csvmagic` module needs to be importable. It is common to create a **Python package**
    that implements an IPython extension, which itself defines custom magic commands.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的魔法命令在IPython配置文件中自动定义，我们可以指示IPython在启动新的交互式Shell时自动加载我们的扩展。为此，我们需要打开`~/.ipython/profile_default/ipython_config.py`文件，并将`'csvmagic'`加入到`c.InteractiveShellApp.extensions`列表中。`csvmagic`模块需要是可导入的。通常会创建一个**Python包**，该包实现IPython扩展，并定义自定义魔法命令。
- en: There's more...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Many third-party extensions and magic commands exist, notably `cythonmagic`,
    `octavemagic`, and `rmagic`, which all allow us to insert non-Python code in a
    cell. For example, with `cythonmagic`, we can create a Cython function in a cell
    and import it in the rest of the notebook.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多第三方扩展和魔法命令，特别是`cythonmagic`、`octavemagic`和`rmagic`，它们都允许我们在单元格中插入非Python代码。例如，使用`cythonmagic`，我们可以在单元格中创建一个Cython函数，并在笔记本的其余部分中导入它。
- en: 'Here are a few references:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: Documentation of IPython's extension system available at [http://ipython.org/ipython-doc/dev/config/extensions/](http://ipython.org/ipython-doc/dev/config/extensions/)
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPython扩展系统的文档请参见[http://ipython.org/ipython-doc/dev/config/extensions/](http://ipython.org/ipython-doc/dev/config/extensions/)
- en: Defining new magic commands explained at [http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics](http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义新的魔法命令请参见[http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics](http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics)
- en: Index of IPython extensions at [https://github.com/ipython/ipython/wiki/Extensions-Index](https://github.com/ipython/ipython/wiki/Extensions-Index)
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPython扩展的索引请参见[https://github.com/ipython/ipython/wiki/Extensions-Index](https://github.com/ipython/ipython/wiki/Extensions-Index)
- en: API reference of `InteractiveShell` available at [http://ipython.org/ipython-doc/dev/api/generated/IPython.core.interactiveshell.html](http://ipython.org/ipython-doc/dev/api/generated/IPython.core.interactiveshell.html)
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InteractiveShell`的API参考请参见[http://ipython.org/ipython-doc/dev/api/generated/IPython.core.interactiveshell.html](http://ipython.org/ipython-doc/dev/api/generated/IPython.core.interactiveshell.html)'
- en: See also
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Mastering IPython's configuration system* recipe
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*掌握IPython的配置系统*食谱'
- en: Mastering IPython's configuration system
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握IPython的配置系统
- en: IPython implements a truly powerful configuration system. This system is used
    throughout the project, but it can also be used by IPython extensions. It could
    even be used in entirely new applications.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: IPython实现了一个真正强大的配置系统。这个系统贯穿整个项目，但也可以被IPython扩展使用，甚至可以在全新的应用程序中使用。
- en: In this recipe, we show how to use this system to write a configurable IPython
    extension. We will create a simple magic command that displays random numbers.
    This magic command comes with configurable parameters that can be set by the user
    in their IPython configuration file.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们展示了如何使用这个系统来编写一个可配置的IPython扩展。我们将创建一个简单的魔法命令来显示随机数。这个魔法命令带有可配置的参数，用户可以在他们的IPython配置文件中进行设置。
- en: How to do it...
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We create an IPython extension in a `random_magics.py` file. Let's start by
    importing a few objects.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `random_magics.py` 文件中创建了一个 IPython 扩展。让我们先导入一些对象。
- en: Note
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be sure to put the code in steps 1-5 in an external text file named `random_magics.py`,
    rather than in the notebook's input!
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将步骤 1-5 中的代码放在一个名为 `random_magics.py` 的外部文本文件中，而不是笔记本的输入中！
- en: '[PRE43]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We create a `RandomMagics` class deriving from `Magics`. This class contains
    a few configurable parameters:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个从 `Magics` 派生的 `RandomMagics` 类。这个类包含一些可配置参数：
- en: '[PRE44]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We need to call the parent''s constructor. Then, we initialize a random number
    generator with a seed:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要调用父类的构造函数。然后，我们用一个种子初始化一个随机数生成器：
- en: '[PRE45]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We create a `%random` line magic that displays a random number:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`%random`行魔法，它显示一个随机数：
- en: '[PRE46]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we register that magic when the extension is loaded:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当扩展加载时，我们注册这个魔法：
- en: '[PRE47]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s test our extension in the notebook:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在笔记本中测试我们的扩展：
- en: '[PRE48]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Our magic command has a few configurable parameters. These variables are meant
    to be configured by the user in the IPython configuration file or in the console
    when starting IPython. To configure these variables in the terminal, we can type
    the following command in a system shell:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的魔法命令有一些可配置参数。这些变量是用户在 IPython 配置文件中或启动 IPython 时在控制台中配置的。要在终端中配置这些变量，我们可以在系统
    shell 中输入以下命令：
- en: '[PRE49]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this session, we get the following behavior:'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此会话中，我们得到以下行为：
- en: '[PRE50]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To configure the variables in the IPython configuration file, we have to open
    the `~/.ipython/profile_default/ipython_config.py` file and add the following
    line:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 IPython 配置文件中配置变量，我们必须打开 `~/.ipython/profile_default/ipython_config.py` 文件，并添加以下行：
- en: '[PRE51]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After launching IPython, we get the following behavior:'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启动 IPython 后，我们得到以下行为：
- en: '[PRE52]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'IPython''s configuration system defines several concepts:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 的配置系统定义了几个概念：
- en: A **user profile** is a set of parameters, logs, and command history, which
    are specific to a user. A user can have different profiles when working on different
    projects. A `xxx` profile is stored in `~/.ipython/profile_xxx`, where `~` is
    the user's home directory.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户配置文件** 是一组特定于用户的参数、日志和命令历史记录。用户在处理不同项目时可以有不同的配置文件。一个 `xxx` 配置文件存储在 `~/.ipython/profile_xxx`
    中，其中 `~` 是用户的主目录。'
- en: On Linux, the path is generally `/home/yourname/.ipython/profile_xxx`
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 上，路径通常是`/home/yourname/.ipython/profile_xxx`
- en: On Windows, the path is generally `C:\Users\YourName\.ipython\profile_xxx`
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上，路径通常是 `C:\Users\YourName\.ipython\profile_xxx`
- en: A **configuration object**, or `Config`, is a special Python dictionary that
    contains key-value pairs. The `Config` class derives from Python's `dict`.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置对象**，或者说 `Config`，是一个特殊的 Python 字典，包含键值对。`Config` 类继承自 Python 的 `dict`。'
- en: The `HasTraits` class is a class that can have special `trait` attributes. **Traits**
    are sophisticated Python attributes that have a specific type and a default value.
    Additionally, when a trait's value changes, a callback function is automatically
    and transparently called. This mechanism allows a class to be notified whenever
    a trait attribute is changed.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HasTraits` 类是一个可以拥有特殊 `trait` 属性的类。**Traits** 是复杂的 Python 属性，具有特定类型和默认值。此外，当
    trait 的值发生变化时，回调函数会自动且透明地被调用。这个机制允许一个类在 trait 属性发生变化时得到通知。'
- en: A `Configurable` class is the base class of all classes that want to benefit
    from the configuration system. A `Configurable` class can have configurable attributes.
    These attributes have default values specified directly in the class definition.
    The main feature of `Configurable` classes is that the default values of the traits
    can be overridden by configuration files on a class-by-class basis. Then, instances
    of `Configurables` can change these values at leisure.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Configurable` 类是所有希望受益于配置系统的类的基类。一个 `Configurable` 类可以拥有可配置的属性。这些属性在类定义中直接指定了默认值。`Configurable`
    类的主要特点是其 trait 的默认值可以通过配置文件逐个类地被覆盖。然后，`Configurables` 的实例可以随意更改这些值。'
- en: A **configuration file** is a Python or JSON file that contains the parameters
    of `Configurable` classes.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件** 是一个包含 `Configurable` 类参数的 Python 或 JSON 文件。'
- en: The `Configurable` classes and configuration files support an inheritance model.
    A `Configurable` class can derive from another `Configurable` class and override
    its parameters. Similarly, a configuration file can be included in another file.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`Configurable` 类和配置文件支持继承模型。一个 `Configurable` 类可以从另一个 `Configurable` 类派生并重写其参数。类似地，一个配置文件可以被包含在另一个文件中。'
- en: Configurables
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置项
- en: 'Here is a simple example of a `Configurable` class:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的 `Configurable` 类的示例：
- en: '[PRE53]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'By default, an instance of the `MyConfigurable` class will have its `myvariable`
    attribute equal to `100`. Now, let''s assume that our IPython configuration file
    contains the following lines:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`MyConfigurable` 类的实例将其 `myvariable` 属性设置为 `100`。现在，假设我们的 IPython 配置文件包含以下几行：
- en: '[PRE54]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Then, the `myvariable` attribute will default to `123`. Instances are free to
    change this default value after they are instantiated.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`myvariable` 属性将默认为 `123`。实例化后可以自由更改此默认值。
- en: The `get_config()` function is a special function that is available in any configuration
    file.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_config()` 函数是一个特殊的函数，可以在任何配置文件中使用。'
- en: Additionally, `Configurable` parameters can be specified in the command-line
    interface, as we saw in this recipe.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Configurable` 参数可以在命令行界面中指定，正如我们在本配方中所看到的那样。
- en: This configuration system is used by all IPython applications (notably `console`,
    `qtconsole`, and `notebook`). These applications have many configurable attributes.
    You will find the list of these attributes in your profile's configuration files.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置系统被所有 IPython 应用程序使用（特别是 `console`、`qtconsole` 和 `notebook`）。这些应用程序有许多可配置的属性。你将在配置文件中找到这些属性的列表。
- en: Magics
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 魔法命令
- en: The **Magics** class derives from `Configurable` and can contain configurable
    attributes. Moreover, magic commands can be defined by methods decorated by `@line_magic`
    or `@cell_magic`. The advantage of defining class magics instead of function magics
    (as in the previous recipe) is that we can keep a state between multiple magic
    calls (because we are using a class instead of a function).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**Magics** 类继承自 `Configurable` 类，可以包含可配置的属性。此外，可以通过 `@line_magic` 或 `@cell_magic`
    装饰的方法来定义魔法命令。与前面的配方中使用函数魔法不同，定义类魔法的优势在于我们可以在多个魔法调用之间保持状态（因为我们使用的是类而不是函数）。'
- en: There's more...
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Here are a few references:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: Configuring and customizing IPython at [http://ipython.org/ipython-doc/dev/config/index.html](http://ipython.org/ipython-doc/dev/config/index.html)
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [http://ipython.org/ipython-doc/dev/config/index.html](http://ipython.org/ipython-doc/dev/config/index.html)
    配置和定制 IPython
- en: Detailed overview of the configuration system at [http://ipython.org/ipython-doc/dev/development/config.html](http://ipython.org/ipython-doc/dev/development/config.html)
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置系统的详细概述，访问 [http://ipython.org/ipython-doc/dev/development/config.html](http://ipython.org/ipython-doc/dev/development/config.html)
- en: Defining custom magics available at [http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics](http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics)
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义自定义魔法，详见 [http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics](http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics)
- en: The traitlets module available at [http://ipython.org/ipython-doc/dev/api/generated/IPython.utils.traitlets.html](http://ipython.org/ipython-doc/dev/api/generated/IPython.utils.traitlets.html)
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的 traitlets 模块，访问 [http://ipython.org/ipython-doc/dev/api/generated/IPython.utils.traitlets.html](http://ipython.org/ipython-doc/dev/api/generated/IPython.utils.traitlets.html)
- en: See also
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating an IPython extension with custom magic commands* recipe
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建带有自定义魔法命令的IPython扩展* 配方'
- en: Creating a simple kernel for IPython
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 IPython 创建一个简单的内核
- en: The architecture that has been developed for IPython and that will be the core
    of Project Jupyter is becoming increasingly language independent. The decoupling
    between the client and kernel makes it possible to write kernels in any language.
    The client communicates with the kernel via socket-based messaging protocols.
    Thus, a kernel can be written in any language that supports sockets.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为 IPython 开发的架构，以及将成为 Project Jupyter 核心的架构，正在变得越来越独立于语言。客户端与内核之间的解耦使得可以用任何语言编写内核。客户端通过基于套接字的消息协议与内核通信。因此，可以用任何支持套接字的语言编写内核。
- en: However, the messaging protocols are complex. Writing a new kernel from scratch
    is not straightforward. Fortunately, IPython 3.0 brings a lightweight interface
    for kernel languages that can be wrapped in Python.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，消息协议是复杂的。从头编写一个新的内核并不简单。幸运的是，IPython 3.0 提供了一个轻量级的内核语言接口，可以用 Python 包装。
- en: This interface can also be used to create an entirely customized experience
    in the IPython notebook (or another client application such as the console). Normally,
    Python code has to be written in every code cell; however, we can write a kernel
    for any domain-specific language. We just have to write a Python function that
    accepts a code string as input (the contents of the code cell), and sends text
    or rich data as output. We can also easily implement code completion and code
    inspection.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口还可用于在 IPython 笔记本（或其他客户端应用程序，如控制台）中创建完全定制的体验。通常，Python 代码必须在每个代码单元中编写；但是，我们可以为任何领域特定语言编写一个内核。我们只需编写一个接受代码字符串作为输入（代码单元的内容）的
    Python 函数，并发送文本或丰富数据作为输出。我们还可以轻松实现代码完成和代码检查。
- en: We can imagine many interesting interactive applications that go far beyond
    the original use cases of IPython. These applications might be particularly useful
    for nonprogrammer end users such as high school students.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象许多有趣的交互式应用程序，远远超出了 IPython 最初用例的范围。这些应用程序对于非程序员终端用户（如高中学生）可能特别有用。
- en: In this recipe, we will create a simple graphing calculator. The calculator
    is transparently backed by NumPy and matplotlib. We just have to write functions
    as `y = f(x)` in a code cell to get a graph of these functions.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们将创建一个简单的图形计算器。计算器透明地由 NumPy 和 matplotlib 支持。我们只需在代码单元中编写函数，如 `y = f(x)`，即可获取这些函数的图形。
- en: Getting ready
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe has been tested on the development version of IPython 3.0\. It should
    work on the final version of IPython 3.0 with no or minimal changes. We give all
    references about wrapper kernels and messaging protocols at the end of this recipe.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方已在 IPython 3.0 开发版本上进行了测试。它应该可以在 IPython 3.0 最终版本上无或最小更改地运行。我们将所有有关包装器内核和消息协议的引用都放在此配方的结尾。
- en: How to do it...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: Note
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Warning: This recipe works only on IPython >= 3.0!'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：此配方仅适用于 IPython >= 3.0！
- en: 'First, we create a `plotkernel.py` file. This file will contain the implementation
    of our custom kernel. Let''s import a few modules:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `plotkernel.py` 文件。该文件将包含我们自定义内核的实现。让我们导入一些模块：
- en: Note
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be sure to put the code in steps 1-6 in an external text file named `plotkernel.py`,
    rather than in the notebook's input!
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请确保将步骤 1-6 的代码放在名为 `plotkernel.py` 的外部文本文件中，而不是笔记本的输入中！
- en: '[PRE55]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We write a function that returns a base64-encoded PNG representation of a matplotlib
    figure:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们编写一个函数，返回 matplotlib 图形的 base64 编码的 PNG 表示：
- en: '[PRE56]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we write a function that parses a code string, which has the form `y =
    f(x)`, and returns a NumPy function. Here, `f` is an arbitrary Python expression
    that can use NumPy functions:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们编写一个函数，解析具有 `y = f(x)` 形式的代码字符串，并返回一个 NumPy 函数。这里，`f` 是一个可以使用 NumPy 函数的任意
    Python 表达式：
- en: '[PRE57]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'For our new wrapper kernel, we create a class that derives from `Kernel`. There
    are a few metadata fields we need to provide:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的新包装器内核，我们创建一个派生自 `Kernel` 的类。我们需要提供一些元数据字段：
- en: '[PRE58]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In this class, we implement a `do_execute()` method that takes code as input
    and sends responses to the client:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此类中，我们实现了一个 `do_execute()` 方法，接受代码作为输入并向客户端发送响应：
- en: '[PRE59]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we add the following lines at the end of the file:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在文件末尾添加以下行：
- en: '[PRE60]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Our kernel is ready! The next step is to indicate to IPython that this new
    kernel is available. To do this, we need to create a **kernel spec** `kernel.json`
    file and put it in `~/.ipython/kernels/plot/`. This file contains the following
    lines:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的内核准备就绪！下一步是告诉 IPython 此新内核已可用。为此，我们需要创建一个**内核规范** `kernel.json` 文件，并将其放置在
    `~/.ipython/kernels/plot/` 中。此文件包含以下行：
- en: '[PRE61]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `plotkernel.py` file needs to be importable by Python. For example, we could
    simply put it in the current directory.
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`plotkernel.py` 文件需要 Python 能够导入。例如，我们可以简单地将其放在当前目录中。'
- en: In IPython 3.0, we can launch a notebook with this kernel from the IPython notebook
    dashboard. There is a drop-down menu at the top right of the notebook interface
    that contains the list of available kernels. Select the Plot kernel to use it.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IPython 3.0 中，我们可以从 IPython 笔记本仪表板启动具有此内核的笔记本。笔记本界面的右上角有一个下拉菜单，其中包含可用内核的列表。选择绘图内核以使用它。
- en: Finally, in a new notebook backed by our custom plot kernel, we can simply write
    the mathematical equation, `y = f(x)`. The corresponding graph appears in the
    output area. Here is an example:![How to do it...](img/4818OS_01_14.jpg)
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在由我们定制的绘图内核支持的新笔记本中，我们只需简单地编写数学方程 `y = f(x)`。相应的图形将显示在输出区域。这里是一个例子：![如何操作……](img/4818OS_01_14.jpg)
- en: Example of our custom plot wrapper kernel
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们自定义绘图包装器内核的示例
- en: How it works...
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何运行……
- en: We will give more details about the architecture of IPython and the notebook
    in [Chapter 3](ch03.html "Chapter 3. Mastering the Notebook"), *Mastering the
    Notebook*. We will just give a summary here. Note that these details might change
    in future versions of IPython.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](ch03.html "第3章. 精通笔记本")*《精通笔记本》*中提供更多关于IPython和笔记本架构的细节。这里我们仅做一个简要总结。请注意，这些细节可能会在未来版本的IPython中发生变化。
- en: The kernel and client live in different processes. They communicate via messaging
    protocols implemented on top of network sockets. Currently, these messages are
    encoded in JSON, a structured, text-based document format.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 内核和客户端运行在不同的进程中。它们通过在网络套接字上实现的消息协议进行通信。目前，这些消息采用JSON编码，这是一种结构化的基于文本的文档格式。
- en: Our kernel receives code from the client (the notebook, for example). The `do_execute()`function
    is called whenever the user sends a cell's code.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的内核接收来自客户端（例如，笔记本）的代码。每当用户发送一个单元格的代码时，`do_execute()`函数就会被调用。
- en: 'The kernel can send messages back to the client with the `self.send_response()`
    method:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 内核可以通过`self.send_response()`方法将消息发送回客户端：
- en: The first argument is the socket, here, the **IOPub** socket
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是套接字，这里是**IOPub**套接字
- en: The second argument is the **message type**, here, `stream`, to send back standard
    output or a standard error, or `display_data` to send back rich data
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是**消息类型**，在这里是`stream`，用于返回标准输出或标准错误，或者是`display_data`，用于返回富数据
- en: The third argument is the contents of the message, represented as a Python dictionary
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是消息的内容，表示为一个Python字典
- en: 'The data can contain multiple MIME representations: text, HTML, SVG, images,
    and others. It is up to the client to handle these data types. In particular,
    the HTML notebook client knows how to represent all these types in the browser.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以包含多种MIME表示：文本、HTML、SVG、图片等。由客户端来处理这些数据类型。特别是，HTML笔记本客户端知道如何在浏览器中呈现这些类型。
- en: The function returns execution results in a dictionary.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回一个包含执行结果的字典。
- en: In this toy example, we always return an `ok` status. In production code, it
    would be a good idea to detect errors (syntax errors in the function definitions,
    for example) and return an error status instead.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们始终返回`ok`状态。在生产代码中，最好检测到错误（例如函数定义中的语法错误），并返回错误状态。
- en: All messaging protocol details can be found at the links given at the end of
    this recipe.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 所有消息协议的细节可以在本食谱末尾给出的链接中找到。
- en: There's more...
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Wrapper kernels can implement optional methods, notably for code completion
    and code inspection. For example, to implement code completion, we need to write
    the following method:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 包装内核可以实现可选方法，特别是用于代码补全和代码检查。例如，为了实现代码补全，我们需要编写以下方法：
- en: '[PRE62]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This method is called whenever the user requests code completion when the cursor
    is at a given `cursor_pos` location in the code cell. In the method's response,
    the `cursor_start` and `cursor_end` fields represent the interval that code completion
    should overwrite in the output. The `matches` field contains the list of suggestions.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户请求代码补全且光标位于代码单元格中的某个`cursor_pos`位置时，会调用此方法。在该方法的响应中，`cursor_start`和`cursor_end`字段表示代码补全应覆盖的输出区间。`matches`字段包含建议的列表。
- en: 'These details might have changed by the time IPython 3.0 is released. You will
    find all up-to-date information in the following references:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这些细节可能会随着IPython 3.0的发布而发生变化。你可以在以下参考资料中找到所有最新的信息：
- en: Wrapper kernels, available at [http://ipython.org/ipython-doc/dev/development/wrapperkernels.html](http://ipython.org/ipython-doc/dev/development/wrapperkernels.html)
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装内核，访问地址：[http://ipython.org/ipython-doc/dev/development/wrapperkernels.html](http://ipython.org/ipython-doc/dev/development/wrapperkernels.html)
- en: Messaging protocols, available at [http://ipython.org/ipython-doc/dev/development/messaging.html](http://ipython.org/ipython-doc/dev/development/messaging.html)
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息协议，访问地址：[http://ipython.org/ipython-doc/dev/development/messaging.html](http://ipython.org/ipython-doc/dev/development/messaging.html)
- en: KernelBase API reference, available at [http://ipython.org/ipython-doc/dev/api/generated/IPython.kernel.zmq.kernelbase.html](http://ipython.org/ipython-doc/dev/api/generated/IPython.kernel.zmq.kernelbase.html)
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KernelBase API参考，访问地址：[http://ipython.org/ipython-doc/dev/api/generated/IPython.kernel.zmq.kernelbase.html](http://ipython.org/ipython-doc/dev/api/generated/IPython.kernel.zmq.kernelbase.html)
