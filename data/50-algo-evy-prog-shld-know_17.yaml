- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Cryptography
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学
- en: I carry my unwritten poems in cipher on my face!
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我把我未写的诗隐藏在面部的密码中！
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —George Eliot
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —乔治·艾略特
- en: This chapter introduces you to algorithms related to cryptography. We will start
    by presenting the background, then we will discuss symmetric encryption algorithms.
    We will then explain the **Message-Digest 5** (**MD5**) algorithm and the **Secure
    Hash Algorithm** (**SHA**) and present the limitations and weaknesses of symmetric
    algorithms. Next, we will discuss asymmetric encryption algorithms and how they
    are used to create digital certificates. Finally, we will present a practical
    example that summarizes all of these techniques.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向你介绍与密码学相关的算法。我们将首先介绍背景知识，然后讨论对称加密算法。接着，我们将解释**消息摘要 5**（**MD5**）算法和**安全哈希算法**（**SHA**），并展示对称算法的局限性和弱点。然后，我们将讨论非对称加密算法，以及它们如何用于创建数字证书。最后，我们将呈现一个实际示例，总结所有这些技术。
- en: By the end of this chapter, you will have a basic understanding of various issues
    related to cryptography.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对与密码学相关的各种问题有一个基本的理解。
- en: 'The following topics are discussed in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了以下主题：
- en: Introduction to cryptography
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学简介
- en: Understanding the types of cryptography techniques
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解密码学技术的种类
- en: Example – security concerns when deploying a machine learning model
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例 – 部署机器学习模型时的安全问题
- en: Let’s start by looking at the basic concepts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础概念开始。
- en: Introduction to cryptography
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学简介
- en: Techniques to protect secrets have been around for centuries. The earliest attempts
    to secure and hide data from adversaries date back to ancient inscriptions discovered
    on monuments in Egypt, where a special alphabet that was known by only a few trusted
    people was used. This early form of security is called obscurity and is still
    used in different forms today. In order for this method to work, it is critical
    to protect the secret, which would be the secret meaning of the alphabet in the
    above example. Later in time, finding foolproof ways of protecting important messages
    was important in both World War One and World War Two. In the late 20^(th) century,
    with the introduction of electronics and computers, sophisticated algorithms were
    developed to secure data, giving rise to a whole new field called cryptography.
    This chapter discusses the algorithmic aspects of cryptography. One of the uses
    of these algorithms is to allow secure data exchange between two processes or
    users. Cryptographic algorithms find strategies for using mathematical functions
    to ensure the stated security goals.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 保护秘密的技术已经存在了几个世纪。最早尝试保护和隐藏数据以防敌人窃取可以追溯到古埃及在纪念碑上发现的古老铭文，其中使用了一种只有少数可信人员才知道的特殊字母。这种早期的安全形式叫做“模糊性”，至今仍以不同形式使用。为了使这种方法有效，保护秘密是至关重要的，在上述例子中就是保护字母的秘密含义。后来，在第一次世界大战和第二次世界大战中，找到可靠的保护重要信息的方法变得尤为重要。进入20世纪后期，随着电子技术和计算机的出现，发展出了一些复杂的算法来保护数据，这促成了密码学这一新领域的出现。本章讨论了密码学的算法方面。密码学算法的一种用途是允许两个过程或用户之间进行安全的数据交换。密码算法通过使用数学函数来确保既定的安全目标。
- en: First, we will look at the importance of “the weakest link” in the infrastructure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看一下基础设施中“最弱链条”的重要性。
- en: Understanding the importance of the weakest link
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解最弱链条的重要性
- en: Sometimes, when architecting the security of digital infrastructure, we put
    too much emphasis on the security of individual entities and don’t pay the necessary
    attention to end-to-end security. This can result in us overlooking some loopholes
    and vulnerabilities in the system, which can later be exploited by hackers to
    access sensitive data. The important point to remember is that a digital infrastructure,
    as a whole, is only as strong as its weakest link. For a hacker, this weakest
    link can provide backdoor access to sensitive data in the digital infrastructure.
    Beyond a certain point, there is not much benefit in fortifying the front door
    without closing all the back doors.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在设计数字基础设施的安全性时，我们过于强调单个实体的安全，而没有足够关注端到端的安全性。这可能导致我们忽视系统中的某些漏洞和脆弱点，后来这些漏洞可能被黑客利用，从而访问敏感数据。需要记住的重要一点是，一个数字基础设施整体的强度取决于它最薄弱的环节。对于黑客来说，这个最弱的环节可能为他们提供进入数字基础设施的后门，访问敏感数据。超过某个点之后，如果没有关闭所有后门，再加固前门就没有太大的意义。
- en: As the algorithms and techniques for keeping digital infrastructure become more
    and more sophisticated, attackers keep upgrading their techniques as well. It
    is always important to remember that one of the easiest ways for attackers to
    hack digital infrastructure is by exploiting these vulnerabilities to access sensitive
    information.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着用于保护数字基础设施的算法和技术变得越来越复杂，攻击者也不断升级他们的技术。我们始终需要记住，攻击者攻破数字基础设施的最简单方法之一，就是通过利用这些漏洞来访问敏感信息。
- en: In 2014, a cyber attack on a Canadian federal research institute—the **National
    Research Council** (**NRC**)—is estimated to have cost hundreds of millions of
    dollars. The attackers were able to steal decades of research data and intellectual
    property material. They used a loophole in the Apache software that was used on
    the web servers to gain access to the sensitive data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，对加拿大一个联邦研究机构——**国家研究委员会**（**NRC**）的网络攻击估计造成了数亿美元的损失。攻击者能够窃取数十年的研究数据和知识产权材料。他们利用了Web服务器上使用的Apache软件中的一个漏洞，成功获得了敏感数据。
- en: In this chapter, we will highlight the vulnerabilities of various encryption
    algorithms.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点讲解各种加密算法的漏洞。
- en: Let’s first look at the basic terminology used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看一下使用的基本术语。
- en: The basic terminology
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本术语
- en: 'Let’s look at the basic terminology related to cryptography:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下与密码学相关的基本术语：
- en: '**Cipher**: An algorithm that performs a particular cryptographic function.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码**：执行特定密码学功能的算法。'
- en: '**Plain text**: The plain data, which can be a text file, a video, a bitmap,
    or a digitized voice. In this chapter, we will represent plain text as *P*.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**明文**：原始数据，可以是文本文件、视频、位图或数字化的语音。在本章中，我们将明文表示为 *P*。'
- en: '**Cipher text**: The scrambled text that is obtained after applying cryptography
    to the plain text. In this chapter, we will represent this as *C*.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密文**：在对明文应用密码学后得到的加密文本。在本章中，我们将其表示为 *C*。'
- en: '**Cipher suite**: A set or suite of cryptographic software components. When
    two separate nodes want to exchange messages using cryptography, they first need
    to agree on a cipher suite. This is important in ensuring that they use exactly
    the same implementation of the cryptographic functions.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码套件**：一组或一套密码学软件组件。当两个独立的节点希望使用密码学交换信息时，他们首先需要就密码套件达成一致。这一点对于确保他们使用完全相同的密码学功能实现非常重要。'
- en: '**Encryption**: The process of converting plain text, *P*, into cipher text,
    *C*, is called encryption. Mathematically, it is represented by *encrypt(P) =
    C*.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密**：将明文 *P* 转换为密文 *C* 的过程称为加密。从数学上讲，它表示为 *encrypt(P) = C*。'
- en: '**Decryption**: The process of converting cipher text back into plain text.
    Mathematically, it is represented by *decrypt(C) = P*.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解密**：将密文转换回明文的过程。数学上，它表示为 *decrypt(C) = P*。'
- en: '**Cryptanalysis**: The methods used to analyze the strength of cryptographic
    algorithms. The analyst tries to recover the plain text without access to the
    secret.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码分析**：分析密码算法强度的方法。分析者试图在没有密钥的情况下恢复明文。'
- en: '**Personally Identifiable Information** (**PII**): PII is information that
    can be used to trace an individual’s identity when used alone or with other relevant
    data. Some examples include protected information, such as a social security number,
    date of birth, or mother’s maiden name.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**个人身份信息**（**PII**）：PII是指那些可以单独或与其他相关数据一起用于追溯个人身份的信息。举例来说，保护性信息如社会安全号码、出生日期或母亲的娘家姓。'
- en: Let us first understand the security needs of a system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解系统的安全需求。
- en: Understanding the security requirements
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解安全需求
- en: It is important to first understand the exact security needs of a system. Understanding
    this will help us use the correct cryptographic technique and discover the potential
    loopholes in a system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 了解一个系统的确切安全需求非常重要。理解这一点将帮助我们使用正确的密码学技术，并发现系统中的潜在漏洞。
- en: 'One way of developing a better understanding of the security needs of a system
    is by answering the following four questions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地理解系统安全需求的一种方法是通过回答以下四个问题：
- en: Which individuals or processes need to be protected?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些个人或流程需要受到保护？
- en: Who are we protecting the individuals and processes from?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们保护这些个人和流程免受哪些威胁？
- en: Where should we protect them?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该在哪些地方进行保护？
- en: Why are we protecting them?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么要保护这些信息？
- en: 'Let us take the example of a **Virtual Private Cloud** (**VPC**) in the AWS
    cloud. A VPC allows us to create a logical isolation network where resources like
    virtual machines are added to it. In order to understand the security requirements
    of a VPC, it is important to first identify the identities by answering those
    four questions:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以AWS云中的**虚拟私有云**（**VPC**）为例。VPC允许我们创建一个逻辑隔离的网络，在其中添加虚拟机等资源。为了理解VPC的安全要求，首先需要通过回答以下四个问题来识别身份：
- en: How many individuals are planning to use this system?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少人计划使用这个系统？
- en: What sort of information needs to be protected?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要保护的是什么样的信息？
- en: Should we protect the VPC only, or we are passing a message to the system that
    needs to be encrypted and communicated to the VPC?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是只保护VPC，还是需要将消息加密并传递给系统，再与VPC进行通信？
- en: What is the security classification of the data? What are the potential risks?
    Why would anyone have an incentive to try to hack the system?
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的安全分类是什么？潜在的风险有哪些？为什么有人会有动机尝试攻击系统？
- en: 'Most of the answers to these questions will come by performing the following
    three steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的大多数答案将通过执行以下三个步骤来获得：
- en: Identify the entities.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别实体。
- en: Establish the security goals.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立安全目标。
- en: Understand the sensitivity of the data.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解数据的敏感性。
- en: Let’s look at these steps one by one.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一看看这些步骤。
- en: 'Step 1: Identifying the entities'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步：识别实体
- en: An entity can be defined as an individual, a process, or a resource that is
    part of an information system. We first need to identify how users, resources,
    and processes are present at runtime. Then, we will quantify the security needs
    of these identified entities, either individually or as a group.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实体可以定义为个人、过程或信息系统中的资源。我们首先需要识别在运行时用户、资源和过程如何存在。然后，我们将量化这些识别出的实体的安全需求，既可以单独考虑，也可以作为一个整体来考虑。
- en: Once we better understand these requirements, we can establish the security
    goals of our digital system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们更好地理解了这些要求，就可以建立我们数字系统的安全目标。
- en: 'Step 2: Establishing the security goals'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步：建立安全目标
- en: 'The goal of designing a security system is to protect information from being
    stolen, compromised, or attacked. Cryptographic algorithms are typically used
    to meet one or more security goals:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 设计安全系统的目标是保护信息免受盗窃、破坏或攻击。通常使用加密算法来实现一个或多个安全目标：
- en: '**Authentication**: Authentication is a mechanism by which we ascertain the
    identity of a user, device, or system, confirming that they are indeed what or
    who they claim to be.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：认证是我们确认用户、设备或系统身份的机制，确保他们确实是他们所声称的身份。'
- en: '**Authorization**: Authorization is the process of giving the user permission
    to access a specific resource or function.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：授权是指给予用户访问特定资源或功能的权限的过程。'
- en: '**Confidentiality**: Data that needs to be protected is called **sensitive
    data**. Confidentiality is the concept of restricting sensitive data to authorized
    users only. To protect the confidentiality of sensitive data during its transit
    or in storage, you need to render the data so that it is unreadable except by
    authorized users. This is accomplished by using encryption algorithms, which we
    will discuss later on in this chapter.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机密性**：需要保护的数据被称为**敏感数据**。机密性是指将敏感数据限制给授权用户的概念。为了在数据传输或存储过程中保护敏感数据的机密性，需要将数据加密，使其只有授权用户才能读取。这个过程是通过使用加密算法来实现的，我们将在本章稍后讨论这些算法。'
- en: '**Integrity**: Integrity is the process of establishing that data has not been
    altered in any way during its transit or storage. For example, **TCP**/**IP**
    (**Transmission Control Protocol**/**Internet Protocol**) uses checksum or **Cyclic
    Redundancy Check** (**CRC**) algorithms to verify data integrity.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：完整性是指在数据传输或存储过程中，确保数据未被篡改的过程。例如，**TCP**/**IP**（**传输控制协议**/**互联网协议**）使用校验和或**循环冗余检查**（**CRC**）算法来验证数据完整性。'
- en: '**Non-repudiation**: Non-repudiation is the ability to produce unforgeable
    and irrefutable evidence that a message was sent or received. This evidence can
    be used later to prove the receipt of data.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可否认性**：不可否认性是指能够提供不可伪造且无可辩驳的证据，证明一条消息已被发送或接收。这些证据可以在之后用来证明数据的接收。'
- en: 'Step 3: Understanding the sensitivity of the data'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：理解数据的敏感性
- en: 'It is important to understand the classified nature of data. Data is categorized
    by regulatory authorities such as governments, agencies, or organizations based
    on how serious the consequence will be if it is compromised. The categorization
    of the data helps us choose the correct cryptographic algorithm. There is more
    than one way to categorize data, based on the sensitivity of the information it
    contains. Let’s look at the typical ways of classifying data:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 理解数据的机密性质非常重要。数据由监管机构如政府、机构或组织根据其泄露后的后果的严重程度进行分类。数据的分类有助于我们选择正确的加密算法。根据数据所包含信息的敏感性，数据的分类方法不止一种。让我们来看看数据分类的典型方式：
- en: '**Public data or unclassified data**: Anything that is available for consumption
    to the public, for example, information found on a company’s website or a government’s
    info portal.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公开数据或未分类数据**：任何可供公众消费的数据，例如公司网站或政府信息门户网站上的信息。'
- en: '**Internal data or confidential data**: Although not for public consumption,
    exposing this data to the public may not have damaging consequences. For example,
    if an employee’s emails complaining about their manager are exposed, it may be
    embarrassing for the company but this may not have damaging consequences.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部数据或机密数据**：虽然不供公众消费，但将这些数据公开可能不会产生严重后果。例如，如果一个员工抱怨经理的电子邮件被公开，可能会让公司感到尴尬，但这可能不会带来严重后果。'
- en: '**Sensitive data or secret data**: Data that is not supposed to be for public
    consumption and exposing it to the public could have damaging consequences for
    an individual or an organization. For example, leaking the details of a future
    iPhone may harm Apple’s business goals and could give an advantage to rivals,
    such as Samsung.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**敏感数据或机密数据**：不应公开的数据显示，公开这些数据可能会对个人或组织造成严重后果。例如，泄露未来iPhone的细节可能会损害苹果的商业目标，并且可能给竞争对手，如三星，带来优势。'
- en: '**Highly sensitive data**: Also called **top-secret data**. This is information
    that, if disclosed, would be extremely damaging to the organization. Examples
    of highly sensitive data include proprietary research, strategic business plans,
    or internal financial data.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度敏感数据**：也称为**绝密数据**。如果这些信息被泄露，可能会对组织造成极大损害。高度敏感数据的例子包括专有研究、战略商业计划或内部财务数据。'
- en: Top-secret data is protected through multiple layers of security and requires
    special permission to access it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 绝密数据通过多层安全保护，需要特别的权限才能访问。
- en: In general, more sophisticated security designs are much slower than simple
    algorithms. It is important to strike the right balance between the security and
    the performance of the system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，更复杂的安全设计比简单的算法更慢。重要的是在安全性和系统性能之间找到正确的平衡。
- en: Understanding the basic design of ciphers
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解密码的基本设计
- en: Designing ciphers is about coming up with an algorithm that can scramble sensitive
    data so that a malicious process or an unauthorized user cannot access it. Although,
    over time, ciphers have become more and more sophisticated, the underlying principles
    that ciphers are based on remain unchanged.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 设计密码是制定一个算法，将敏感数据进行混淆，以便恶意进程或未经授权的用户无法访问。尽管随着时间的推移，密码变得越来越复杂，但密码所基于的基本原理依然保持不变。
- en: Let’s start by looking at some relatively simple ciphers that will help us understand
    the underlying principles that are used in the design of cryptographic algorithms.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些相对简单的密码开始，帮助我们理解设计加密算法时使用的基本原理。
- en: Presenting substitution ciphers
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍替代密码
- en: Substitution ciphers have been in use for hundreds of years in various forms.
    As the name indicates, substitution ciphers are based on a simple concept—substituting
    characters in plain text with other characters in a predetermined, organized way.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 替代密码已经使用了几百年，并且以不同形式出现。顾名思义，替代密码基于一个简单的概念——将明文中的字符按照预定的、组织好的方式替换为其他字符。
- en: 'Let’s look at the exact steps involved in this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个过程的具体步骤：
- en: First, we map each character to a substitute character.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将每个字符映射到一个替代字符。
- en: Then, we encode and convert the plain text into cipher text by replacing each
    character in the plain text with another character in the cipher text using substitution
    mapping.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过使用替代映射将明文中的每个字符替换为密码文本中的另一个字符，从而对明文进行编码和转换成密码文本。
- en: To decode, we bring back the plaintext by using substitution mapping.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解码，我们通过使用替代映射将明文还原回来。
- en: 'The following are examples of substitution-based ciphers:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于替换的密码示例：
- en: Caesar cipher
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凯撒密码
- en: Rotation 13
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转 13
- en: Let us look into them in more detail.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地研究一下它们。
- en: Caesar cipher
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 凯撒密码
- en: Caesar ciphers are based on substitution mapping. Substitution mapping changes
    the actual string in a deterministic way by applying a simple formula that is
    kept secret.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码基于替换映射。替换映射通过应用一个保密的简单公式，以确定性方式改变实际字符串。
- en: 'The substitution mapping is created by replacing each character with the third
    character to the right of it. This mapping is described in the following diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 替换映射是通过将每个字符替换为它右边第三个字符来创建的。这个映射在下图中进行了说明：
- en: '![Diagram  Description automatically generated](img/B18046_14_01.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图示  自动生成的描述](img/B18046_14_01.png)'
- en: 'Figure 13.1: The substitution mapping of Caesar ciphers'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：凯撒密码的替换映射
- en: 'Let’s see how we can implement a Caesar cipher using Python:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何用 Python 实现凯撒密码：
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can see that we applied a Caesar cipher to the plaintext `CALM`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们对明文 `CALM` 应用了凯撒密码。
- en: 'Let’s print the cipher text after encrypting it with the Caesar cipher:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在加密明文后打印出密文：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Caesar ciphers are said to have been used by Julius Caesar to communicate with
    his advisers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 据说凯撒密码曾被尤利乌斯·凯撒用来与他的顾问通信。
- en: A Caesar cipher is a simple cipher and is easy to implement. The downside is
    that it is not too difficult to crack as a hacker could simply iterate through
    all the possible shifts of the alphabet (all 2626 of them) and see if any coherent
    message appears. Given the current processing abilities of computers, this is
    a relatively small number of combinations to do. It should not be used to protect
    highly sensitive data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码是一种简单的密码，且易于实现。缺点是它并不难破解，因为黑客可以简单地通过遍历字母表的所有可能位移（共 2626 种）来查看是否出现任何连贯的消息。鉴于现代计算机的处理能力，这个组合数是相对较小的。因此，它不应被用来保护高度敏感的数据。
- en: Rotation 13 (ROT13)
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 旋转 13 (ROT13)
- en: 'ROT13 is a special case of the Caesar cipher where the substitution mapping
    is created by replacing each character with the 13^(th) character to the right
    of it. The following diagram illustrates this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ROT13 是凯撒密码的一种特殊情况，其中替换映射是通过将每个字符替换为它右边第13个字符来创建的。下图演示了这一点：
- en: '![A picture containing rectangle  Description automatically generated](img/B18046_14_02.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含矩形的图片  自动生成的描述](img/B18046_14_02.png)'
- en: 'Figure 14.2: Workings of ROT13'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2：ROT13 的工作原理
- en: 'This means that if `ROT13()` is the function that implements ROT13, then the
    following applies:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果 `ROT13()` 是实现 ROT13 的函数，那么以下内容适用：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let’s print the encoded value of `C`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打印 `C` 的编码值：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ROT13 is actually not used to accomplish data confidentiality. It is used more
    to mask text, for example, to hide potentially offensive text. It can also be
    used to avoid giving away the answer to a puzzle, and in other similar use-cases.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ROT13 实际上并不是用来实现数据保密的。它更多是用来掩盖文本，例如隐藏可能令人反感的文本。它也可以用来避免泄露谜题的答案，以及其他类似的使用场景。
- en: Cryptanalysis of substitution ciphers
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换密码的密码分析
- en: Substitution ciphers are simple to implement and understand. Unfortunately,
    they are also easy to crack. Simple cryptanalysis of substitution ciphers shows
    that if we use the English language alphabet, then all we need to determine to
    crack the cipher is how much we are rotating by. We can try each letter of the
    English alphabet one by one until we are able to decrypt the text. This means
    that it will take around 25 attempts to reconstruct the plain text.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 替换密码易于实现和理解。不幸的是，它们也容易破解。对替换密码的简单密码分析表明，如果我们使用英语字母表，那么破解密码所需做的就是确定我们旋转了多少。我们可以一一尝试英语字母表中的每个字母，直到我们能够解密文本为止。这意味着需要大约
    25 次尝试来恢复明文。
- en: Now, let’s look at another type of simple cipher—transposition ciphers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下另一种简单的密码——换位密码。
- en: Understanding transposition ciphers
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解换位密码
- en: In transposition ciphers, the characters of the plain text are encrypted using
    transposition. Transposition is a method of encryption where we scramble the position
    of the characters using deterministic logic. A transposition cipher writes characters
    into rows in a matrix and then reads the columns as output. Let’s look at an example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在换位密码中，明文的字符通过换位加密。换位是一种加密方法，我们通过使用确定性逻辑将字符的位置打乱。换位密码将字符写入矩阵中的行，然后按列读取作为输出。让我们来看一个例子。
- en: Let’s take the `Ottawa Rocks` plain text (*P*).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `Ottawa Rocks` 的明文（*P*）。
- en: 'First, let’s encode *P*. For that, we will use a 3 x 4 matrix and write in
    the plaintext horizontally:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们对 *P* 进行编码。为此，我们将使用一个 3 x 4 的矩阵，并水平书写明文：
- en: '| O | t | t | a |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| O | t | t | a |'
- en: '| w | a | R | o |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| w | a | R | o |'
- en: '| c | k | s |  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| c | k | s |  |'
- en: The `read` process will read the string vertically, which will generate the
    cipher text—`OwctaktRsao`. The key would be {1,2,3,4}, which is the order in which
    the columns are read. Encrypting with a different key, say, {2,4,3,1}, would result
    in a different cipher text, in this case, `takaotRsOwc`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`read` 过程将会垂直读取字符串，这将生成密文——`OwctaktRsao`。密钥将是 {1,2,3,4}，表示列的读取顺序。使用不同的密钥加密，比如
    {2,4,3,1}，将会得到不同的密文，此时为 `takaotRsOwc`。'
- en: The Germans used a cipher named ADFGVX in the First World War, which used both
    transposition and substitution ciphers. Years later, it was cracked by George
    Painvin.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 德国人在第一次世界大战中使用了一种名为 ADFGVX 的密码，这种密码结合了换位和替代密码。几年后，这个密码被乔治·潘文破解。
- en: So, these are some of the types of ciphers. In general, ciphers use a key to
    code plain text. Now, let’s look at some of the cryptographic techniques that
    are currently used. Cryptography protects a message using encryption and decryption
    processes, as discussed in the next section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这些是一些常见的密码。通常，密码使用密钥来加密明文。现在，让我们看看一些目前使用的密码学技术。密码学通过加密和解密过程来保护信息，这在下一节中会进一步讨论。
- en: Understanding the types of cryptographic techniques
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解密码学技术的类型
- en: Different types of cryptographic techniques use different types of algorithms
    and are used under different sets of circumstances. As different situations and
    use-cases have different requirements of security based on the business requirements
    and the data classification, the selection of the right technique is important
    for a well-designed architecture.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的密码学技术使用不同的算法，并在不同的情况下应用。由于不同的情况和使用场景对安全性有不同的需求，且这些需求依据业务要求和数据分类的不同而有所差异，因此选择合适的技术对于一个设计良好的架构至关重要。
- en: 'Broadly, cryptographic techniques can be divided into the following three types:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上，密码学技术可以分为以下三种类型：
- en: Hashing
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希
- en: Symmetric
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称
- en: Asymmetric
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非对称
- en: Let’s look at them one by one.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一来看。
- en: Using the cryptographic hash function
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用密码学哈希函数
- en: The cryptographic hash function is a mathematical algorithm that can be used
    to create a unique fingerprint of a message. It creates an output, called a hash,
    from plain text. The size of the output is usually fixed but can vary for some
    specialized algorithms.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学哈希函数是一种数学算法，可以用来创建消息的唯一指纹。它从明文生成一个输出，称为哈希。输出的大小通常是固定的，但某些特定算法的输出大小可能会有所不同。
- en: 'Mathematically, this looks as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度来看，这样表示：
- en: '*C*[1] *= hashFunction(P*[1]*)*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*[1] *= hashFunction(P*[1]*)*'
- en: 'This is explained as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以解释为：
- en: '*P*[1] is the plain text representing the input data'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*P*[1] 是表示输入数据的明文'
- en: '*C*[1] is a fixed-length hash that is generated by the cryptographic hash function'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C*[1] 是由密码学哈希函数生成的固定长度哈希'
- en: 'This is shown in the following diagram. The variable-length data is converted
    into a fixed-length hash through a one-way hash function:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下图表中有所显示。通过单向哈希函数，变长的数据被转换为固定长度的哈希：
- en: '![Diagram  Description automatically generated](img/B18046_14_03.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图表 说明自动生成](img/B18046_14_03.png)'
- en: 'Figure 14.3: One-way hash functions'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3：单向哈希函数
- en: 'A hash function is a mathematical algorithm that transforms an arbitrary amount
    of data into a fixed-size string of bytes. It plays a vital role in ensuring the
    integrity and authenticity of data. Below are the key characteristics that define
    a cryptographic hash function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数是一种数学算法，它将任意数量的数据转换为固定大小的字节串。它在确保数据的完整性和真实性方面起着至关重要的作用。以下是定义密码学哈希函数的关键特征：
- en: '**Deterministic**: A hash function is deterministic, meaning that the same
    input (or “plaintext”) will always produce the same output (or “hash”). No matter
    how many times you hash a particular piece of data, the result will remain consistent.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定性**：哈希函数是确定性的，这意味着相同的输入（或“明文”）总是会产生相同的输出（或“哈希”）。无论你对某一数据进行多少次哈希，结果将始终保持一致。'
- en: '**Uniqueness**: Ideally, different inputs should always produce unique hash
    outputs. If two distinct inputs produce the same hash, this is known as a collision.
    Quality hash functions are designed to minimize the likelihood of collisions.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**唯一性**：理想情况下，不同的输入应始终产生唯一的哈希输出。如果两个不同的输入产生相同的哈希，这被称为碰撞。优质的哈希函数旨在尽量减少碰撞的可能性。'
- en: '**Fixed length**: The output of a hash function has a fixed length, regardless
    of the size of the input data. Whether you’re hashing a single character or an
    entire novel, the resulting hash will be of the same size, specific to the hash
    algorithm used (e.g., 128 bits for MD5, 256 bits for SHA-256).'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定长度**：哈希函数的输出具有固定的长度，无论输入数据的大小如何。无论你是在哈希一个字符还是整个小说，结果哈希的大小都将相同，且特定于所使用的哈希算法（例如，MD5
    为 128 位，SHA-256 为 256 位）。'
- en: '**Sensitive to input changes**: Even a minor alteration in the plaintext leads
    to a significant and unpredictable change in the resulting hash value. This property
    ensures that it is not feasible to derive the original input or find a different
    input that produces the same hash, enhancing the security of the hash function.
    The effect is such that even changing a single letter in a large document will
    result in a hash that appears entirely different from the original.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对输入变化敏感**：即使在明文中进行微小的修改，也会导致结果哈希值发生显著且不可预测的变化。这一特性确保了无法推导出原始输入，也无法找到一个不同的输入产生相同的哈希，从而增强了哈希函数的安全性。其效果是，即使在大文档中改变一个字母，也会导致哈希值看起来完全不同。'
- en: '**One-way function**: Hash functions are one-way, meaning that it is computationally
    infeasible to reverse the process and generate the original plaintext (P[1]) from
    the hash (C[1]). This ensures that even if an unauthorized party obtains the hash,
    they cannot use it to determine the original data.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单向函数**：哈希函数是单向的，意味着计算上不可行地逆转这个过程，从哈希（C[1]）生成原始明文（P[1]）。这确保了即使未经授权的方获得了哈希值，他们也无法用它来确定原始数据。'
- en: If we have a situation where each unique message does not have a unique hash,
    we call it a collision. In other words, a collision is when the hash algorithm
    produces the same hash value for two different input values. For security applications,
    a collision is a potential vulnerability and its probability should be very low.
    That is, if we have two texts, P1 and P2, in the case of collision, it means *hashFunction(P*[1]*)
    = hashFunction(P*[2]*)*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到每个唯一的消息没有唯一的哈希值的情况，我们称之为碰撞。换句话说，碰撞是指哈希算法对两个不同的输入值产生相同的哈希值。对于安全应用程序，碰撞是一种潜在的漏洞，其概率应该非常低。也就是说，如果我们有两个文本，P1
    和 P2，在碰撞的情况下，意味着*hashFunction(P*[1]*) = hashFunction(P*[2]*)*。
- en: Regardless of the hashing algorithm used, collisions are rare. Otherwise, hashing
    wouldn’t be useful. However, for some applications, collisions cannot be tolerated.
    In those cases, we need to use a hashing algorithm that is more complex but much
    less likely to generate hash values that collide.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用何种哈希算法，碰撞是罕见的。否则，哈希就不会有用。然而，对于某些应用程序来说，碰撞是不能容忍的。在这些情况下，我们需要使用一种更复杂的哈希算法，但它生成碰撞的可能性要小得多。
- en: Implementing cryptographic hash functions
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现加密哈希函数
- en: 'Cryptographic hash functions can be implemented by using various algorithms.
    Let’s take a deeper look at two of them:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 加密哈希函数可以通过使用各种算法来实现。让我们深入了解其中的两种：
- en: MD5
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MD5
- en: '**Secure Hashing Algorithm** (**SHA**)'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安全哈希算法** (**SHA**)'
- en: Understanding MD5-tolerated
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解 MD5 容忍性
- en: MD5 was developed by Poul-Henning Kamp in 1994 to replace MD4\. It generates
    a 128-bit hash. Generating a 128-bit hash means that the resulting hash value
    is made up of 128 binary digits (bits).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: MD5 由 Poul-Henning Kamp 于 1994 年开发，用于替代 MD4。它生成一个 128 位的哈希值。生成一个 128 位的哈希值意味着结果哈希值由
    128 个二进制数字（位）组成。
- en: This translates to a fixed length of 16 bytes or 32 hexadecimal characters.
    The fixed length ensures that no matter the size of the original data, the hash
    will always be 128 bits long. The purpose of this fixed-length output is to create
    a “fingerprint” or “digest” of the original data. MD5 is a relatively simple algorithm
    that is vulnerable to collision. In applications where a collision cannot be tolerated,
    MD5 should not be used. For example, it can be used to check the integrity of
    files downloaded from the internet.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着固定长度为16字节或32个十六进制字符。固定长度确保了无论原始数据的大小如何，哈希值始终为128位长。这个固定长度输出的目的是为了创建原始数据的“指纹”或“摘要”。MD5是一个相对简单的算法，但它容易受到碰撞攻击。在无法容忍碰撞的应用场景中，不应使用MD5。例如，它可以用于检查从互联网下载文件的完整性。
- en: 'Let’s look at an example. In order to generate an MD5 hash in Python, we will
    start by using the `hashlib` module, which is part of the Python Standard Library
    and provides a range of different cryptographic hashing algorithms:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例。为了在Python中生成MD5哈希值，我们将从使用`hashlib`模块开始，`hashlib`是Python标准库的一部分，提供多种不同的加密哈希算法：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we define a utility function called `generate_md5_hash()`, which takes
    `input_string` as a parameter. This string will be hashed by the function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个名为`generate_md5_hash()`的工具函数，该函数以`input_string`作为参数。该字符串将被该函数哈希处理：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that `hashlib.md5()` creates a new hash object. This object uses the MD5
    algorithm and `md5_hash.update(input_string.encode())` updates the hash object
    with the bytes of the input string. The string is encoded to bytes using the default
    UTF-8 encoding. After all data has been updated in the hash object, we can call
    the `hexdigest()` method to return the hexadecimal representation of the digest.
    This is the MD5 hash of the input string.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`hashlib.md5()`会创建一个新的哈希对象。这个对象使用MD5算法，`md5_hash.update(input_string.encode())`会用输入字符串的字节更新哈希对象。该字符串会使用默认的UTF-8编码转换为字节。所有数据更新到哈希对象后，我们可以调用`hexdigest()`方法返回摘要的十六进制表示。这就是输入字符串的MD5哈希值。
- en: 'Here we use the `generate_md5_hash()` function to get the MD5 hash of the string
    `"Hello, World!"`, and print the result to the console:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`generate_md5_hash()`函数来获取字符串`"Hello, World!"`的MD5哈希值，并将结果打印到控制台：
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `verify_md5_hash` function, we take an input string and a known correct
    MD5 hash. We generate the MD5 hash of the input string using our `generate_md5_hash`
    function and then compare it to the known correct hash.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`verify_md5_hash`函数中，我们接受一个输入字符串和一个已知的正确MD5哈希值。我们使用`generate_md5_hash`函数生成输入字符串的MD5哈希值，并将其与已知的正确哈希值进行比较。
- en: When to use MD5
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用MD5
- en: Looking back at history, weaknesses with MD5 were discovered in the late 1990s.
    Despite several issues, MD5 usage is still popular. It is ideal to be used for
    integrity checks for data. Note that the MD5 message digest does not uniquely
    associate the hash with its owner as the MD5 digest is not a signed hash. MD5
    is used to prove that a file has not been changed since the hash was computed.
    It is not used to prove the authenticity of a file. Now, let’s look at another
    hashing algorithm—SHA.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾历史，MD5的弱点是在1990年代末被发现的。尽管存在一些问题，MD5的使用仍然很普遍。它非常适合用于数据的完整性检查。请注意，MD5消息摘要并未唯一地将哈希值与其所有者关联，因为MD5摘要不是一个签名哈希。MD5用于证明自哈希计算以来，文件没有被更改。它并不用于证明文件的真实性。现在，我们来看看另一种哈希算法——SHA。
- en: Understanding Secure Hashing Algorithm (SHA)
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解安全哈希算法（SHA）
- en: 'SHA was developed by the **National Institute of Standards and Technology**
    (**NIST**). It’s widely used to verify the integrity of data. Among its variations,
    SHA-512 is a popular hash function, and Python’s `hashlib` library includes it.
    Let’s see how we can use Python to create a hash using the SHA algorithm. For
    that, let us first import the `hashlib` library:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: SHA是由**美国国家标准与技术研究院**（**NIST**）开发的。它被广泛用于验证数据的完整性。在其变种中，SHA-512是一种流行的哈希函数，Python的`hashlib`库中包括了它。让我们看看如何使用Python创建一个使用SHA算法的哈希值。为此，我们首先需要导入`hashlib`库：
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we will define the salt and the message. Salting is the practice of adding
    random characters to a password before hashing. It enhances security by making
    hash collisions more challenging:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将定义盐值和消息。加盐是将随机字符添加到密码中以进行哈希的做法。它通过使哈希碰撞变得更加困难来增强安全性：
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will combine the salt with the password to apply the salting procedure:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把盐值与密码结合，应用加盐过程：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we will use the `sha512` function to create a hash of the salted password:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`sha512`函数来生成盐值密码的哈希值：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let us print `myHash`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印`myHash`：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that when we use the SHA algorithm, the hash generated is 512 bytes. This
    specific size isn’t arbitrary, but rather a key component of the algorithm’s security
    features. A larger hash size corresponds to an increased number of potential combinations,
    thereby reducing the chances of “collisions”—instances where two different inputs
    produce the same hash output. Collisions compromise the reliability of a hashing
    algorithm, and SHA-512’s 512-byte output significantly reduces this risk.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们使用SHA算法时，生成的哈希值为512字节。这个特定的大小并非随意，而是算法安全性特征的关键组成部分。更大的哈希大小对应着更多的潜在组合，从而减少了“碰撞”的概率——即两个不同的输入产生相同的哈希输出。碰撞会损害哈希算法的可靠性，而SHA-512的512字节输出大大降低了这一风险。
- en: An application of the cryptographic hash function
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码哈希函数的应用
- en: Hash functions are used to check the integrity of a file after making a copy
    of it. To achieve this, when a file is copied from a source to a destination (for
    example, when downloaded from a web server), a corresponding hash is also copied
    with it. This original hash, *horiginal*, acts as a fingerprint of the original
    file. After copying the file, we generate the hash again from the copied version
    of the file—that is, *hcopied*. If *horiginal = hcopied*—that is, the generated
    hash matches the original hash—this verifies that the file has not changed and
    none of the data was lost during the download process. We can use any cryptographic
    hash function, such as MD5 or SHA, to generate a hash for this purpose.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数用于在复制文件后检查文件的完整性。为此，当文件从源复制到目标（例如从Web服务器下载时），相应的哈希也会一并复制。这个原始哈希值*horiginal*作为原文件的指纹。在复制文件后，我们从复制版本的文件生成哈希——即*hcopied*。如果*horiginal
    = hcopied*——即生成的哈希与原始哈希匹配——这就验证了文件没有发生变化，下载过程中没有丢失任何数据。我们可以使用任何密码哈希函数，如MD5或SHA，来生成哈希值。
- en: Choosing between MD5 and SHA
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在MD5和SHA之间选择
- en: Both MD5 and SHA are hashing algorithms. MD5 is simple and fast, but it does
    not provide good security. SHA is complex compared to MD5 and it provides a greater
    level of security.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: MD5和SHA都是哈希算法。MD5简单且快速，但它的安全性较差。相比MD5，SHA更复杂，提供了更高的安全性。
- en: Now, let’s look at symmetric encryption.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看对称加密。
- en: Using symmetric encryption
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对称加密
- en: 'In cryptography, a key is a combination of numbers that is used to encode plain
    text using an algorithm of our choice. In symmetric encryption, we use the same
    key for encryption and decryption. If the key used for symmetric encryption is
    *K*, then for symmetric encryption, the following equation holds:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学中，密钥是用来通过选择的算法对明文进行编码的一组数字。在对称加密中，我们使用相同的密钥进行加密和解密。如果用于对称加密的密钥是*K*，那么对于对称加密，以下公式成立：
- en: '*EK(P) = C*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*EK(P) = C*'
- en: Here, *P* is the plain text and *C* is the cipher text.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*P*是明文，*C*是密文。
- en: 'For decryption, we use the same key, *K*, to convert it back to *P*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解密，我们使用相同的密钥*K*，将其转换回*P*：
- en: '*DK(C) = P*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*DK(C) = P*'
- en: 'This process is shown in the following diagram:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程如图所示：
- en: '![Diagram  Description automatically generated](img/B18046_14_04.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图示 说明自动生成](img/B18046_14_04.png)'
- en: 'Figure 14.4: Symmetric encryption'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：对称加密
- en: Now, let’s look at how we can use symmetric encryption with Python.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用Python进行对称加密。
- en: Coding symmetric encryption
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码对称加密
- en: 'In this section, we’ll explore how to work with hash functions using Python’s
    built-in `hashlib` library. `hashlib` comes pre-installed with Python and provides
    a wide array of hashing algorithms. First, let us import the `hashlib` library:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用Python内置的`hashlib`库处理哈希函数。`hashlib`是Python的预装库，提供了多种哈希算法。首先，我们导入`hashlib`库：
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We’ll use the SHA-256 algorithm to create our hash. Other algorithms like MD5,
    SHA-1, etc., can also be used:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用SHA-256算法来创建我们的哈希值。其他算法如MD5、SHA-1等也可以使用：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s create a hash for the message `"Ottawa is really cold"`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为消息`"Ottawa is really cold"`创建一个哈希值：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The hexadecimal representation of the hash can be printed with:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希的十六进制表示可以通过以下方式打印出来：
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let’s look at some of the advantages of symmetric encryption.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看对称加密的一些优点。
- en: The advantages of symmetric encryption
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对称加密的优点
- en: 'The following are the advantages of symmetric encryption:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对称加密的优点：
- en: '**Simple**: Encryption and decryption using symmetric encryption are simpler
    to implement.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单**：使用对称加密进行加密和解密实现起来更简单。'
- en: '**Fast**: Symmetric encryption is faster than asymmetric encryption.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速**：对称加密比非对称加密更快。'
- en: '**Secure**: One of the most widely used symmetric key encryption systems is
    the U.S. government-designated **Advanced Encryption Standard** (**AES**). When
    using a secure algorithm such as AES, symmetric encryption is at least as secure
    as asymmetric encryption.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：美国政府指定的最广泛使用的对称密钥加密系统是**高级加密标准**（**AES**）。当使用像AES这样的安全算法时，对称加密至少和非对称加密一样安全。'
- en: The problems with symmetric encryption
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对称加密的问题
- en: 'When two users or processes plan to use symmetric encryption to communicate,
    they need to exchange keys using a secure channel. This gives rise to the following
    two problems:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个用户或进程计划使用对称加密进行通信时，他们需要通过安全通道交换密钥。这就产生了以下两个问题：
- en: '**Key protection**: How to protect the symmetric encryption key'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥保护**：如何保护对称加密密钥'
- en: '**Key distribution**: How to share the symmetric encryption key from the source
    to the destination'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥分发**：如何通过安全通道从源头到目的地共享对称加密密钥'
- en: Now, let’s look at asymmetric encryption.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看非对称加密。
- en: Asymmetric encryption
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非对称加密
- en: In the 1970s, asymmetric encryption was devised to address some of the weaknesses
    of symmetric encryption that we discussed in the previous section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在1970年代，非对称加密被发明出来，以解决我们在上一节讨论的对称加密的一些弱点。
- en: 'The first step in asymmetric encryption is to generate two different keys that
    look totally different but are algorithmically related. One of them is chosen
    as the private key, *Kpr*, and the other one is chosen as the public key, *Kpu*.
    The choice of which one of the two keys is public or private is arbitrary. Mathematically,
    we can represent this as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密的第一步是生成两个看起来完全不同但在算法上有关联的密钥。一个被选为私钥，*Kpr*，另一个被选为公钥，*Kpu*。选择哪一个密钥作为公钥或私钥是任意的。数学上，我们可以表示为：
- en: '*EKpr(P) = C*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*EKpr(P) = C*'
- en: Here, *P* is the plain text and *C* is the cipher text.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*P*是明文，*C*是密文。
- en: 'We can decrypt it as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下解密：
- en: '*DKpu(C) = P*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*DKpu(C) = P*'
- en: Public keys are supposed to be freely distributed and private keys are kept
    secret by the owner of the key pair. For instance, in AWS, key pairs are used
    to secure connections to virtual instances and manage encrypted resources. The
    public key is used by others to encrypt data or verify signatures, while the private
    key, securely stored by the owner, is used to decrypt data or sign digital content.
    By adhering to the principle of keeping the private key secret and the public
    key accessible, AWS users can ensure secure communication and data integrity within
    their cloud environment. This separation between public and private keys is a
    cornerstone in the security and trust mechanisms within AWS and other cloud services.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥应该是可以自由分发的，而私钥则由密钥对的拥有者保密。例如，在AWS中，密钥对用于确保与虚拟实例的连接安全，并管理加密资源。公钥由他人用来加密数据或验证签名，而私钥则由拥有者安全存储，用于解密数据或签署数字内容。通过遵循将私钥保密、公钥可访问的原则，AWS用户可以确保云环境中的通信安全和数据完整性。公钥和私钥的分离是AWS及其他云服务中安全性和信任机制的基石。
- en: The fundamental principle is that if you encrypt with one of the keys, the only
    way to decrypt it is by using the other key. For example, if we encrypt the data
    using the public key, we will need to decrypt it using the other key—that is,
    the private key.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 基本原理是，如果你用其中一个密钥加密，唯一的解密方法就是使用另一个密钥。例如，如果我们用公钥加密数据，那么我们需要用另一个密钥——即私钥——来解密。
- en: Now, let’s look at one of the fundamental protocols of asymmetric encryption—the
    **Secure Sockets Layer** (**SSL**)/**Transport Layer Security** (**TLS**) handshake—which
    is responsible for establishing a connection between two nodes using asymmetric
    encryption.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下非对称加密的一个基本协议——**安全套接字层**（**SSL**）/**传输层安全**（**TLS**）握手协议——它负责通过非对称加密在两个节点之间建立连接。
- en: The SSL/TLS handshaking algorithm
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SSL/TLS握手算法
- en: 'SSL was originally developed to add security to HTTP. Over time, SSL was replaced
    with a more efficient and more secure protocol, called TLS. TLS handshakes are
    the basis of how HTTP creates a secure communication session. A TLS handshake
    occurs between the two participating entities—the client and the server. This
    process is shown in the following diagram:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: SSL最初是为了为HTTP添加安全性而开发的。随着时间的推移，SSL被一个更高效、更安全的协议所替代，称为TLS。TLS握手是HTTP如何创建安全通信会话的基础。TLS握手发生在两个参与实体之间——客户端和服务器。此过程如下图所示：
- en: '![Diagram  Description automatically generated](img/B18046_14_05.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![Diagram  Description automatically generated](img/B18046_14_05.png)'
- en: 'Figure 14.5: Secure session between the client and the server'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：客户端和服务器之间的安全会话
- en: 'A TLS handshake establishes a secure connection between the participating nodes.
    The following are the steps that are involved in this process:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: TLS握手在参与节点之间建立安全连接。以下是此过程中涉及的步骤：
- en: 'The client sends a `client hello` message to the server. The message also contains
    the following:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向服务器发送一个`client hello`消息。该消息还包含以下内容：
- en: The version of TLS that is used
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的TLS版本
- en: The list of cipher suites supported by the client
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端支持的密码套件列表
- en: A compression algorithm
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩算法
- en: A random byte string, identified by `byte_client`
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个随机字节串，标识为`byte_client`
- en: 'The server sends a `server hello` message back to the client. The message also
    contains the following:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器向客户端发送一个`server hello`消息。该消息还包含以下内容：
- en: A cipher suite selected by the server from the list provided by the client.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由服务器从客户端提供的列表中选择的密码套件。
- en: A session ID.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话ID。
- en: A random byte string, identified by `byte_server`.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个随机字节串，标识为`byte_server`。
- en: A server digital certificate, identified by `cert_server`, containing the public
    key of the server.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器数字证书，标识为`cert_server`，包含服务器的公钥。
- en: 'If the server requires a digital certificate for client authentication or a
    client certificate request, the client-server request also includes the following:'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务器需要数字证书来进行客户端身份验证或请求客户端证书，客户端-服务器请求还包括以下内容：
- en: The distinguished names of the acceptable CAs
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可接受CA的区分名称
- en: The types of certificates supported
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的证书类型
- en: The client verifies `cert_server`.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端验证`cert_server`。
- en: The client generates a random byte string, identified by `byte_client2`, and
    encrypts it with the public key of the server provided through `cert_server`.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端生成一个随机字节串，标识为`byte_client2`，并使用通过`cert_server`提供的服务器公钥加密。
- en: The client generates a random byte string and identifies and encrypts it with
    its own private key.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端生成一个随机字节串，并使用其私钥对其进行标识和加密。
- en: The server verifies the client certificate.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器验证客户端证书。
- en: The client sends a `finished` message to the server, which is encrypted with
    a secret key.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端向服务器发送一个`finished`消息，该消息使用秘密密钥进行加密。
- en: To acknowledge this from the server side, the server sends a `finished` message
    to the client, which is encrypted with a secret key.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了从服务器端确认这一点，服务器向客户端发送一个`finished`消息，该消息使用秘密密钥进行加密。
- en: 'The server and client have now established a secure channel. They can now exchange
    messages that are symmetrically encrypted with the shared secret key. The entire
    methodology is shown as follows:'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和客户端现在已经建立了一个安全通道。它们现在可以交换使用共享秘密密钥对称加密的消息。整个方法论如下所示：
- en: '![Chart, timeline  Description automatically generated](img/B18046_14_06.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![Chart, timeline  Description automatically generated](img/B18046_14_06.png)'
- en: 'Figure 14.6: Secure session between the client and the server'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6：客户端和服务器之间的安全会话
- en: Now, let’s discuss how we can use asymmetric encryption to create **Public Key
    Infrastructure** (**PKI**), which is created to meet one or more security goals
    for an organization.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何使用非对称加密来创建**公钥基础设施**（**PKI**），该基础设施旨在满足组织的一个或多个安全目标。
- en: Public key infrastructure
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公钥基础设施
- en: Asymmetric encryption is used to implement PKI. PKI is one of the most popular
    and reliable ways to manage encryption keys for an organization. All the participants
    trust a central trusting authority called a **Certification Authority** (**CA**).
    CAs verify the identity of individuals and organizations and then issue them digital
    certificates (a digital certificate contains a copy of a person or organization’s
    public key and its identity), verifying that the public key associated with that
    individual or organization actually belongs to that individual or organization.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密用于实现公钥基础设施（PKI）。PKI是管理组织加密密钥的最流行且可靠的方法之一。所有参与者信任一个称为**证书授权机构**（**CA**）的中央信任机构。CA验证个人和组织的身份，然后向他们颁发数字证书（数字证书包含个人或组织的公钥及其身份），验证与该个人或组织关联的公钥确实属于该个人或组织。
- en: The way it works is that the CA asks a user to prove their identity. The basic
    validation is called domain validation, which could involve simply verifying ownership
    of a domain name. The extended validation, if needed, involves a more rigorous
    process that involves physical proof of identity, depending on the type of digital
    certificate that a user is trying to obtain. If the CA is satisfied that the user
    is indeed who they claim to be, the user then provides the CA with their public
    encryption key over a secure channel.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理是，证书授权机构（CA）要求用户证明其身份。基本验证称为域验证，这可能仅仅是验证域名的所有权。扩展验证（如有需要）涉及更严格的流程，需要根据用户尝试获得的数字证书类型提供身份的物理证明。如果CA确认用户确实是他们所声称的人，用户将通过安全通道向CA提供他们的公钥。
- en: The CA uses this information to create a digital certificate that contains information
    about the user’s identity and their public key. This certificate is digitally
    signed by the CA. The certificate is a public entity as the user can then show
    their certificate to anyone who wants to verify their identity, without having
    to send it through a secure channel, as the certificate doesn’t contain any sensitive
    information itself. The person receiving the certificate does not have to verify
    the user’s identity directly. That person can simply verify that the certificate
    is valid by verifying the CA’s digital signature, which validates that the public
    key contained in the certificate does, in fact, belong to the individual or organization
    named on the certificate.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: CA利用这些信息创建包含用户身份和公钥的数字证书。该证书由CA进行数字签名。证书是公开的实体，因为用户可以将其证书展示给任何需要验证其身份的人，而无需通过安全通道传送，因为证书本身不包含任何敏感信息。接收证书的人不需要直接验证用户的身份。那个人只需通过验证CA的数字签名来验证证书是否有效，从而确认证书中包含的公钥确实属于证书上所列的个人或组织。
- en: The private key of the CA of an organization is the weakest link in the PKI
    chain of trust. If an impersonator got hold of Microsoft’s private key, for example,
    they could install malicious software on millions of computers around the world
    by impersonating a Windows update.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 组织的CA私钥是PKI信任链中的最弱环节。如果冒充者掌握了微软的私钥，例如，他们可以通过冒充Windows更新在全球数百万台计算机上安装恶意软件。
- en: Blockchain and cryptography
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块链与加密学
- en: 'There is no doubt that in recent years there has been a lot of excitement around
    blockchain and cryptocurrency. Blockchain is said to be one of the most secure
    technologies ever invented. The excitement about blockchain started with Bitcoin
    and digital currencies. Digital currencies were first developed in 1980, but with
    Bitcoin, they became mainstream. The rise of Bitcoin was due to the widespread
    availability of distributed systems. It has two important characteristics that
    made it a game-changer:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，近年来区块链和加密货币引起了大量关注。区块链被认为是有史以来最安全的技术之一。关于区块链的热潮始于比特币和数字货币。数字货币最早在1980年被开发，但随着比特币的出现，它们开始走向主流。比特币的崛起归功于分布式系统的广泛应用。它有两个重要特点，使其成为游戏规则的改变者：
- en: It is decentralized by design. It uses a network of miners and a distributed
    algorithm called blockchain.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在设计上是去中心化的。它利用了一种矿工网络和一种被称为区块链的分布式算法。
- en: Bitcoin is based on inherent incentives for miners to compete to add a block
    to the blockchain by attempting to answer a very complex computational puzzle.
    The winning miner is eligible to claim different bitcoins as a reward for their
    effort.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比特币基于矿工为了将区块添加到区块链而竞争的固有激励机制，通过尝试解答非常复杂的计算难题。获胜的矿工有资格要求不同比特币作为他们努力的奖励。
- en: 'Although blockchain was developed for Bitcoin, it has found broader use and
    applications. Blockchain is based on a distributed consensus algorithm, using
    **Distributed Ledger Technology** (**DLT**). It has the following characteristics:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管区块链最初是为比特币开发的，但它已经找到了更广泛的用途和应用。区块链基于分布式共识算法，使用**分布式账本技术**（**DLT**）。它具有以下特点：
- en: '**Decentralization**: It is based on distributed not centralized architecture.
    There is no central authority. Each node in a blockchain system is involved in
    maintaining the integrity of the DLT. There is a consensus among all the participating
    nodes. In this distributed architecture, the transactions are stored on the nodes
    of the constituent nodes, forming a P2P network.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**去中心化**：它基于分布式而非集中式架构。没有中央机构。区块链系统中的每个节点都参与维护DLT的完整性。所有参与节点之间存在共识。在这种分布式架构中，交易存储在组成节点的节点上，形成P2P网络。'
- en: Note that the term “P2P” stands for “Peer-to-Peer,” which means that each node,
    or “peer,” in the network communicates directly with the others without needing
    to go through a central server or authority.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，“P2P”术语代表“点对点”，这意味着网络中的每个节点或“对等方”直接与其他节点通信，而无需经过中央服务器或机构。
- en: '**Chain-like formations**: All transactions of blockchain are accumulated in
    a list of blocks. When several blocks are added, it creates a chain-like formation,
    which is the reason for its name, blockchain.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链状形成**：所有区块链的交易都累积在一个区块列表中。当添加多个区块时，它形成链状结构，这也是其名称“区块链”的原因。'
- en: '**Immutability**: The data is secure, replicated, and stored in immutable blocks.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变性**：数据是安全的，复制的，并以不可变的区块存储。'
- en: '**Reliability**: A lineage or history is maintained for each transaction. Each
    transaction is verified and recorded using cryptographic techniques.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：每笔交易都维护了一个血统或历史。使用密码学技术验证和记录每笔交易。'
- en: 'Under the hood, blockchain transactions use cryptographic hashes from each
    of the previous blocks in the chain. Hash functions are used to create a one-way
    fingerprint of an arbitrary chunk of data. A Merkle tree or hash tree is used
    to verify data stored, handled, and transferred between different participating
    nodes. It uses SHA-2 for hashing. A diagram of a particular transaction is shown
    below:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，区块链交易使用链中每个先前区块的加密哈希。哈希函数用于创建任意数据块的单向指纹。默克尔树或哈希树用于验证存储、处理和在不同参与节点之间传输的数据。它使用SHA-2进行哈希。下面显示了一个特定交易的图示：
- en: '![A diagram of a hashtag  Description automatically generated](img/B18046_14_07.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有标签的井号的图示 自动生成的描述](img/B18046_14_07.png)'
- en: 'Figure 14.7: The Merkle tree of blockchain'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7：区块链的默克尔树
- en: '*Figure 13.7* summarizes the workings of blockchain. It shows how transactions
    get converted into blocks, which are, in turn, converted into chains. On the left-hand
    side, four transactions, A, B, C, and D, are shown. Next, the Merkle root is created
    by applying a hash function. The Merkle root can be considered a data structure
    that forms part of the block header. As transactions are immutable, the previously
    recorded transactions cannot be changed.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13.7*总结了区块链的工作原理。它显示了如何将交易转换为区块，然后再转换为链。左侧显示了四笔交易，A、B、C和D。接下来，通过应用哈希函数创建了默克尔根。默克尔根可以视为区块头的一部分数据结构。由于交易是不可改变的，先前记录的交易不能被更改。'
- en: Note that the hash value of the previous block header also becomes part of the
    block, thus incorporating transaction records. This creates chain-like processing
    structures and is the reason for the name blockchain.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前一个区块头的哈希值也成为区块的一部分，从而整合交易记录。这创建了链状处理结构，并是“区块链”名称的原因。
- en: Each blockchain user is authenticated and authorized using cryptography, eliminating
    the need for third-party authentication and authorization. Digital signatures
    are used to secure transactions as well. The receiver of a transaction has a public
    key. Blockchain technology eliminates the involvement of third parties for transaction
    validation and relies on cryptographic proof for this. Transactions are secured
    using a digital signature. Each user has a unique private key that establishes
    their digital identity in the system.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 每个区块链用户通过加密技术进行身份验证和授权，从而消除了对第三方身份验证和授权的需求。数字签名也用于确保交易的安全性。交易的接收者拥有一个公钥。区块链技术消除了第三方参与交易验证，依赖加密证明来实现这一点。交易通过数字签名来确保安全。每个用户都有一个唯一的私钥，在系统中建立其数字身份。
- en: 'Example: security concerns when deploying a machine learning model'
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例：部署机器学习模型时的安全性问题
- en: In *Chapter 6*, *Unsupervised Machine Learning Algorithms*, we looked at the
    **Cross-Industry Standard Process for Data Mining** (**CRISP-DM**) life cycle,
    which specifies the different phases of training and deploying a machine learning
    model. Once a model is trained and evaluated, the final phase is deployment. If
    it is a critical machine learning model, then we want to make sure that all of
    its security goals are met.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第6章*《无监督机器学习算法》中，我们讨论了**跨行业数据挖掘标准过程**（**CRISP-DM**）生命周期，该生命周期定义了训练和部署机器学习模型的不同阶段。一旦模型训练并评估完成，最终阶段就是部署。如果是关键性的机器学习模型，我们希望确保其所有安全目标都得到满足。
- en: 'Let’s analyze the common challenges faced in deploying a model such as this
    and how we can address those challenges using the concepts discussed in this chapter.
    We will discuss strategies to protect our trained model against the following
    three challenges:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析在部署这样的模型时面临的常见挑战，并讨论如何利用本章中讨论的概念来解决这些挑战。我们将讨论保护训练模型免受以下三大挑战的策略：
- en: '**Man-in-the-Middle** (**MITM**) attacks'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间人攻击**（**MITM**）'
- en: Masquerading
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒充
- en: Data tempering
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据篡改
- en: Let’s look at them one by one.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析它们。
- en: MITM attacks
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间人攻击
- en: One of the possible attacks that we would want to protect our model against
    is MITM attacks. A MITM attack occurs when an intruder tries to eavesdrop on a
    supposedly private communication.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望保护模型免受的一种可能攻击是中间人攻击（MITM）。中间人攻击发生在入侵者试图窃听本应私密的通信时。
- en: Let’s try to understand MITM attacks sequentially using an example scenario.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例场景来逐步理解中间人攻击。
- en: 'Let’s assume that Bob and Alice want to exchange messages using PKI:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Bob和Alice想通过公钥基础设施（PKI）交换信息：
- en: Bob is using {*Pr*[Bob], *Pu*[Bob]} and Alice is using {*Pr*[Alice], *Pu*[Alice]}.
    Bob has created a message, *M*[Bob], and Alice has created a message, *M*[Alice].
    They want to exchange these messages with each other in a secure way.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob使用{*Pr*[Bob], *Pu*[Bob]}，而Alice使用{*Pr*[Alice], *Pu*[Alice]}。Bob创建了消息*M*[Bob]，Alice创建了消息*M*[Alice]。他们希望以安全的方式相互交换这些消息。
- en: Initially, they need to exchange their public keys to establish a secure connection
    with each other. This means that Bob uses *Pu*[Alice] to encrypt *M*[Bob] before
    sending the message to Alice.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最初，他们需要交换公钥，以建立彼此之间的安全连接。这意味着Bob使用*Pu*[Alice]来加密*M*[Bob]，然后将消息发送给Alice。
- en: Let’s assume that we have an eavesdropper, commonly referred to as Eve X, who
    is using {*Pr*[X], *Pu*[X]}. The attacker is able to intercept the public key
    exchanges between Bob and Alice and replace them with its own public certificate.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个窃听者，通常称为Eve X，Eve X使用{*Pr*[X], *Pu*[X]}。攻击者能够拦截Bob和Alice之间的公钥交换，并将其替换为自己的公钥证书。
- en: Bob sends *M*[Bob] to Alice, encrypting it with *Pu*[X] instead of *Pu*[Alice],
    wrongfully thinking that this is Alice’s public certificate. Eavesdropper *X*
    intercepts the communication. It intercepts the *M*[Bob] message and decrypts
    it using *Pr*[Bob].
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob将*M*[Bob]发送给Alice，用*Pu*[X]加密，而不是用*Pu*[Alice]，错误地认为这是Alice的公钥证书。窃听者*X*拦截了这次通信。它拦截了*M*[Bob]消息，并使用*Pr*[Bob]解密它。
- en: 'This MITM attack is shown in the following diagram:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中间人攻击在以下图表中展示：
- en: '![Diagram  Description automatically generated](img/B18046_14_08.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B18046_14_08.png)'
- en: 'Figure 14.8: MITM attack'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8：中间人攻击
- en: Now, let’s look at how we can prevent MITM attacks.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下如何防止中间人攻击。
- en: How to prevent MITM attacks
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何防止中间人攻击（MITM）
- en: Let’s explore how we can prevent MITM attacks by introducing a CA to the organization.
    Let’s say the name of this CA is myTrustCA. The digital certificate has its public
    key, named `PumyTrustCA`, embedded in it. myTrustCA is responsible for signing
    the certificates for all of the people in the organization, including Alice and
    Bob. This means that both Bob and Alice have their certificates signed by myTrustCA.
    When signing their certificates, myTrustCA verifies that they are indeed who they
    claim to be.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨如何通过引入CA（证书授权中心）来防止MITM攻击。假设这个CA的名称是myTrustCA。数字证书中嵌入了它的公钥，名为`PumyTrustCA`。myTrustCA负责为组织中的所有人签发证书，包括Alice和Bob。这意味着Bob和Alice的证书都由myTrustCA签署。在签发证书时，myTrustCA验证他们确实是他们所声称的身份。
- en: 'Now, with this new arrangement in place, let’s revisit the sequential interaction
    between Bob and Alice:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着这一新安排的到位，让我们重新审视Bob和Alice之间的顺序交互：
- en: Bob is using {*Pr*[Bob], *Pu*[Bob]} and Alice is using {*Pr*[Alice], *Pu*[Alice]}.
    Both of their public keys are embedded into their digital certificates, signed
    by myTrustCA. Bob has created a message, *M*[Bob], and Alice has created a message,
    *M*[Alice]. They want to exchange these messages with each other in a secure way.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob使用 {*Pr*[Bob], *Pu*[Bob]}，Alice使用 {*Pr*[Alice], *Pu*[Alice]}。他们的公钥都嵌入在由myTrustCA签署的数字证书中。Bob创建了一个消息*
    M*[Bob]，Alice创建了一个消息* M*[Alice]。他们希望以安全的方式交换这些消息。
- en: They exchange their digital certificates, which contain their public keys. They
    will only accept the public keys if they are embedded in the certificates signed
    by the CA they trust. They need to exchange their public keys to establish a secure
    connection with each other. This means that Bob will use *Pu*[Alice] to encrypt
    *M*[Bob] before sending the message to Alice.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们交换包含公钥的数字证书。只有当公钥嵌入在由他们信任的CA签署的证书中时，他们才会接受这些公钥。他们需要交换公钥以建立安全连接。这意味着Bob将使用*Pu*[Alice]来加密*M*[Bob]，然后将消息发送给Alice。
- en: Let’s assume that we have an eavesdropper, X, who is using {*Pr*[X], *Pu*[X]}.
    The attacker is able to intercept the public key exchanges between Bob and Alice
    and replace them with its own public certificate, *Pu*[X].
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个窃听者X，他使用 {*Pr*[X], *Pu*[X]}。攻击者能够拦截Bob和Alice之间的公钥交换，并用自己公钥证书*Pu*[X]替换它们。
- en: Bob rejects *X*’s attempt, as the bad guy’s digital certificate is not signed
    by the CA that Bob trusts. The secure handshake is aborted, the attempted attack
    is logged with a timestamp and all details, and a security exception is raised.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob拒绝了*X*的尝试，因为坏人的数字证书没有被Bob信任的CA签署。安全握手被中止，攻击尝试的时间戳和所有细节被记录，并触发了安全异常。
- en: When deploying a trained machine learning model, instead of Alice, there is
    a deployment server. Bob only deploys the model after establishing a secure channel,
    using the previously mentioned steps.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署训练好的机器学习模型时，替代Alice的是一个部署服务器。Bob在建立安全通道后才部署模型，使用之前提到的步骤。
- en: Avoiding masquerading
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免伪装
- en: Attacker X pretends to be an authorized user, Bob, and gains access to sensitive
    data, which is the trained model, in this case. We need to protect the model against
    any unauthorized changes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者X伪装成授权用户Bob，获得对敏感数据的访问权限，在这个案例中是已训练的模型。我们需要保护模型不受未经授权的更改。
- en: One way of protecting our trained model against masquerading is by encrypting
    the model with an authorized user’s private key. Once encrypted, anyone can read
    and utilize the model by decrypting it through the public key of the authorized
    user, which is found in their digital certificate. No one can make any unauthorized
    changes to the model.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 保护训练模型免受伪装的一种方式是使用授权用户的私钥加密模型。加密后，任何人都可以通过授权用户的公钥解密模型并使用它，而该公钥可以在他们的数字证书中找到。没有人能够对模型进行未经授权的更改。
- en: Data and model encryption
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据和模型加密
- en: Once the model is deployed, the real-time unlabeled data that is provided as
    input to the model can also be tampered with. The trained model is used for inference
    and provides a label for this data. To protect data against tampering, we need
    to protect the data at rest and in communication. To protect the data at rest,
    symmetric encryption can be used to encode it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模型部署完成，作为输入提供给模型的实时无标签数据也可能被篡改。训练好的模型用于推理，并为这些数据提供标签。为了防止数据被篡改，我们需要保护静态数据和传输中的数据。为了保护静态数据，可以使用对称加密对其进行编码。
- en: To transfer the data, SSL-/TLS-based secure channels can be established to provide
    a secure tunnel. This secure tunnel can be used to transfer the symmetric key
    and the data can be decrypted on the server before it is provided to the trained
    model.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了传输数据，可以建立基于SSL/TLS的安全通道来提供一个安全隧道。这个安全隧道可以用来传输对称密钥，数据可以在服务器上解密，然后再提供给训练好的模型。
- en: This is one of the more efficient and foolproof ways to protect data against
    tampering.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是保护数据不被篡改的更高效且万无一失的方法之一。
- en: Symmetric encryption can also be used to encrypt a model when it has been trained,
    before deploying it to a server. This will prevent any unauthorized access to
    the model before it is deployed.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密也可以用来加密训练好的模型，在将其部署到服务器之前。这将防止在模型部署之前任何未经授权的访问。
- en: 'Let’s see how we can encrypt a trained model at the source, using symmetric
    encryption with the help of the following steps, and then decrypt it at the destination
    before using it:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用对称加密加密源端的训练模型，按照以下步骤操作，然后在目标端解密它并使用：
- en: 'Let’s first train a simple model using the Iris dataset:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先使用Iris数据集训练一个简单的模型：
- en: '[PRE21]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let’s define the names of the files that will store the model:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义将存储模型的文件名：
- en: '[PRE22]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that `filename_source` is the file that will store the trained unencrypted
    model at the source. `filename_destination` is the file that will store the trained
    unencrypted model at the destination, and `filename_sec` is the encrypted trained
    model.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，`filename_source`是存储源端训练未加密模型的文件，`filename_destination`是存储目标端训练未加密模型的文件，而`filename_sec`是加密的训练模型。
- en: 'We will use `pickle` to store the trained model in a file:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`pickle`将训练好的模型存储在文件中：
- en: '[PRE23]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s define a function named `write_key()` that will generate a symmetric
    key and store it in a file named `key.key`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个名为`write_key()`的函数，它将生成一个对称密钥并将其存储在名为`key.key`的文件中：
- en: '[PRE24]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let’s define a function named `load_key()` that can read the stored key
    from the `key.key` file:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个名为`load_key()`的函数，它可以从`key.key`文件中读取存储的密钥：
- en: '[PRE25]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, let’s define an `encrypt()` function that can encrypt and train the model,
    and store it in a file named `filename_sec`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`encrypt()`函数，它可以加密并训练模型，并将其存储在名为`filename_sec`的文件中：
- en: '[PRE26]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will use these functions to generate a symmetric key and store it in a file.
    Then, we will read this key and use it to store our trained model in a file named
    `filename_sec`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用这些函数来生成一个对称密钥并将其存储在一个文件中。然后，我们将读取这个密钥并使用它将训练好的模型存储在名为`filename_sec`的文件中：
- en: '[PRE27]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now the model is encrypted. It will be transferred to the destination where
    it will be used for prediction:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模型已经加密。它将被传输到目标端，在那里它将用于预测：
- en: 'First, we will define a function named `decrypt()` that we can use to decrypt
    the model from `filename_sec` to `filename_destination` using the key stored in
    the `key.key` file:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个名为`decrypt()`的函数，可以用来使用存储在`key.key`文件中的密钥将模型从`filename_sec`解密到`filename_destination`：
- en: '[PRE28]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let’s use this function to decrypt the model and store it in a file named
    `filename_destination`:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用这个函数来解密模型并将其存储在名为`filename_destination`的文件中：
- en: '[PRE29]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let’s use this unencrypted file to load the model and use it for predictions:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用这个未加密的文件来加载模型并用它进行预测：
- en: '[PRE30]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that we have used symmetric encryption to encode the model. The same technique
    can be used to encrypt data as well, if needed.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了对称加密来编码模型。如果需要，相同的技术也可以用来加密数据。
- en: Summary
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about cryptographic algorithms. We started by identifying
    the security goals of a problem. We then discussed various cryptographic techniques
    and also looked at the details of the PKI. Finally, we looked at the different
    ways of protecting a trained machine learning model against common attacks. Now,
    you should be able to understand the fundamentals of security algorithms used
    to protect modern IT infrastructures.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了加密算法。我们首先确定了一个问题的安全目标。然后我们讨论了各种加密技术，还深入了解了公钥基础设施（PKI）的细节。最后，我们看了如何保护训练好的机器学习模型免受常见攻击。现在，你应该能够理解用于保护现代IT基础设施的安全算法的基础。
- en: In the next chapter, we will look at designing large-scale algorithms. We will
    study the challenges and trade-offs involved in designing and selecting large
    algorithms. We will also look at the use of a GPU and clusters to solve complex
    problems.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究设计大规模算法。我们将学习设计和选择大算法时面临的挑战和权衡。我们还将探讨使用GPU和集群来解决复杂问题。
- en: Learn more on Discord
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的Discord社区——在这里你可以分享反馈、向作者提问并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/WHLel](https://packt.link/WHLel)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/WHLel](https://packt.link/WHLel)'
- en: '![](img/QR_Code1955211820597889031.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1955211820597889031.png)'
