- en: 2\. Advanced Operations on Built-In Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 内置数据结构的高级操作
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will introduce advanced data operations on built-in data structures.
    You can utilize these data structures to solve data-wrangling problems. After
    reading this chapter, you will be able to compare Python's advanced data structures
    and make use of the Operating System (OS) file-handling operations. This chapter
    focuses on the data structures in Python and the OS functions that are the foundation
    of this book. By the end of this chapter, you will have learned how to handle
    advanced data structures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍内置数据结构的高级数据操作。您可以使用这些数据结构来解决数据处理问题。阅读本章后，您将能够比较Python的高级数据结构并利用操作系统（OS）的文件处理操作。本章重点介绍Python中的数据结构和本书基础中的操作系统函数。到本章结束时，您将学会如何处理高级数据结构。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: We were introduced to the basic concepts of different fundamental data structures
    in the previous chapter. We learned about lists, sets, dictionaries, tuples, and
    strings. However, what we have covered so far were only basic operations on those
    data structures. They have much more to offer once you learn how to utilize them
    effectively. In this chapter, we will venture further into the land of data structures.
    We will learn about advanced operations and manipulations and use fundamental
    data structures to represent more complex and higher-level data structures; this
    is often handy while wrangling data in real life. These higher-level topics will
    include stacks, queues, interiors, and file operations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了不同基本数据结构的基本概念。我们学习了列表、集合、字典、元组和字符串。然而，到目前为止，我们只涵盖了这些数据结构的基本操作。一旦您学会了如何有效地利用它们，它们将提供更多功能。在本章中，我们将进一步探索数据结构的世界。我们将学习高级操作和操作，并使用基本数据结构来表示更复杂和更高级的数据结构；这在现实生活中处理数据时非常有用。这些高级主题将包括栈、队列、内部结构以及文件操作。
- en: In this chapter, we will also learn how to open a file using built-in Python
    methods and about the many different file operations, such as reading and writing
    data, and safely closing files once we are done. We will also take a look at some
    of the problems to avoid while dealing with files.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将学习如何使用内置的Python方法打开文件，以及许多不同的文件操作，例如读取和写入数据，以及完成操作后安全地关闭文件。我们还将探讨在处理文件时需要避免的一些问题。
- en: Advanced Data Structures
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级数据结构
- en: We will start this chapter by discussing advanced data structures. Initially,
    we will be revisiting lists. Then, we will construct a stack and a queue, explore
    multiple-element membership checking to check whether the data is accurate, and
    throw a bit of functional programming in for good measure. Don't worry if all
    of this sounds intimidating. We will take things step by step, and you will feel
    confident about handling advanced data structures once you have finished this
    chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始讨论高级数据结构。最初，我们将回顾列表。然后，我们将构建一个栈和一个队列，探索多元素成员检查以检查数据是否准确，并为了平衡，加入一些函数式编程。如果所有这些都听起来令人畏惧，请不要担心。我们将一步一步地进行，一旦完成本章，您将对自己的高级数据结构处理能力充满信心。
- en: Before we jump into constructing data structures, we'll look at a few methods
    to manipulate them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入构建数据结构之前，我们将查看一些用于操作它们的方法。
- en: Iterator
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: Iterators in Python are very useful when dealing with data as they allow you
    to parse the data one unit at a time. Iterators are stateful, which means it will
    be helpful to keep track of the previous state. An iterator is an object that
    implements the `next` method—meaning an iterator can iterate over collections
    such as lists, tuples, dictionaries, and more. Practically, this means that each
    time we call the method, it gives us the next element from the collection; if
    there is no further element in the list, then it raises a `StopIteration` exception.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据时，Python中的迭代器非常有用，因为它们允许您逐个单元地解析数据。迭代器是有状态的，这意味着跟踪前一个状态将是有帮助的。迭代器是一个实现了`next`方法的对象——这意味着迭代器可以遍历列表、元组、字典等集合。实际上，这意味着每次我们调用该方法时，它都会从集合中给出下一个元素；如果列表中没有更多元素，则引发`StopIteration`异常。
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A `StopIteration` exception occurs with the iterator's `next` method when there
    are no further values to iterate.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当迭代器没有更多值可以迭代时，使用迭代器的`next`方法会引发`StopIteration`异常。
- en: 'If you are familiar with a programming language such as C, C++, Java, JavaScript,
    or PHP, you may have noticed the difference between the `for` loop implementation
    in those languages, which consists of three distinct parts (the initiation, the
    increment, and the termination condition), and the `for` loop in Python. In Python,
    we do not use that kind of a `for` loop. What we use in Python is more like a
    `foreach` loop:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉像 C、C++、Java、JavaScript 或 PHP 这样的编程语言，你可能已经注意到了这些语言中 `for` 循环的实现差异，它由三个不同的部分组成（初始化、递增和终止条件），而
    Python 中的 `for` 循环则不同。在 Python 中，我们不使用那种 `for` 循环。我们在 Python 中使用的是更类似于 `foreach`
    循环：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is because, under the hood, the `for` loop is using an iterator, and thus
    we do not need to do all the extra steps. The iterator does them for us.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，在底层，`for` 循环正在使用迭代器，因此我们不需要做所有额外的步骤。迭代器会为我们完成这些。
- en: 'Let''s learn about the various functions we can use with `itertools`. As you
    execute each line of the code after the `import` statement, you will be able to
    see details about what that particular function does and how to use it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们可以与 `itertools` 一起使用的各种函数。在执行 `import` 语句之后的每一行代码后，你将能够看到有关该特定函数的功能和使用方法的详细信息：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example, after executing `zip_longest?`, we''ll see the following output:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，执行 `zip_longest?` 后，我们将看到以下输出：
- en: '![Figure 2.1: Help file for the zip_longest function'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.1: Help file for the zip_longest function]'
- en: '](img/B15780_02_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15780_02_01.jpg]'
- en: 'Figure 2.1: Help file for the zip_longest function'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：zip_longest 函数的帮助文件
- en: The preceding screenshot shows how the `zip_longest` function could be used
    from the `itertools` module.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了如何从 `itertools` 模块中使用 `zip_longest` 函数。
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To look up the definition of any function, type the function name, followed
    by *?*, and then press *Shift* + *Enter* in a Jupyter Notebook.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找任何函数的定义，在 Jupyter Notebook 中输入函数名，然后跟一个 *?*，然后按 *Shift* + *Enter*。
- en: Let's go through the following exercise to understand how to use an iterator
    to iterate through a list.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下练习来了解如何使用迭代器遍历列表。
- en: 'Exercise 2.01: Introducing to the Iterator'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.01：介绍迭代器
- en: 'In this exercise, we''re going to generate a long list containing numbers.
    We will first check the memory occupied by the generated list. We will then check
    how we can use the `iterator` module to reduce memory utilization, and finally,
    we will use this iterator to loop over the list. To do this, let''s go through
    the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将生成一个包含数字的长列表。我们首先检查生成的列表占用的内存。然后，我们将检查如何使用 `iterator` 模块来减少内存利用率，最后，我们将使用这个迭代器来遍历列表。为此，让我们按照以下步骤进行：
- en: 'Open a new Jupyter Notebook and generate a list that will contain `10000000`
    ones. Then, store this list in a variable called `big_list_of_numbers`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook，生成一个包含 `10000000` 个一的列表。然后，将这个列表存储在一个名为 `big_list_of_numbers`
    的变量中：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output (partially shown) is as follows:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出（部分显示）如下：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Check the size of this variable:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查这个变量的大小：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output should be as follows:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The value shown is `81528056` (in bytes). This is a huge chunk of memory occupied
    by the list. And the `big_list_of_numbers` variable is only available once the
    list comprehension is over. It can also overflow the available system memory if
    you try too big a number.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显示的值是 `81528056`（以字节为单位）。这是列表占用的巨大内存块。只有在列表推导完成后，`big_list_of_numbers` 变量才可用。如果你尝试太大的数字，它也可能超出系统可用内存。
- en: 'Let''s use the `repeat()` method from `itertools` to get the same number but
    with less memory:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 `itertools` 中的 `repeat()` 方法获取相同的数字，但占用更少的内存：
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output should be:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该是：
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The last line shows that our list `small_list_of_numbers` is only `56` bytes
    in size. Also, it is a lazy method, a technique used in functional programming
    that will delay the execution of a method or a function by a few seconds. In this
    case, Python will not generate all the elements initially. It will, instead, generate
    them one by one when asked, thus saving us time. In fact, if you omit the `times`
    keyword argument in the `repeat()` method in the preceding code, then you can
    practically generate an infinite number of ones.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后的行显示，我们的列表 `small_list_of_numbers` 的大小仅为 `56` 字节。此外，它是一种惰性方法，是函数式编程中使用的技巧，它将延迟方法或函数的执行几秒钟。在这种情况下，Python
    不会最初生成所有元素。相反，当需要时，它会逐个生成它们，从而节省我们的时间。实际上，如果你在上面的代码中省略了 `repeat()` 方法的 `times`
    关键字参数，那么你可以实际生成无限多个一。
- en: 'Loop over the newly generated iterator:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历新创建的迭代器：
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We use the `enumerate` function so that we get the loop counter, along with
    the values. This will help us break the loop once we reach a certain number (`10`,
    for example).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `enumerate` 函数，以便我们得到循环计数器以及值。这有助于我们在达到一定数量（例如 `10`）时中断循环。
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2N8odTH](https://packt.live/2N8odTH).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/2N8odTH](https://packt.live/2N8odTH)。
- en: You can also run this example online at [https://packt.live/3fAPFGa](https://packt.live/3fAPFGa).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在 [https://packt.live/3fAPFGa](https://packt.live/3fAPFGa) 上在线运行此示例。
- en: In this exercise, we first learned how to use the iterator function to reduce
    memory usage. Then, we used an iterator to loop over a list. Now, we'll see how
    to create stacks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们首先学习了如何使用迭代器函数来减少内存使用。然后，我们使用迭代器遍历列表。现在，我们将看到如何创建栈。
- en: Stacks
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈
- en: 'A stack is a very useful data structure. If you know a bit about CPU internals
    and how a program gets executed, then you will know that a stack is present in
    many such cases. It is simply a list with one restriction, **Last In First Out**
    (**LIFO**), meaning an element that comes in last goes out first when a value
    is read from a stack. The following illustration will make this a bit clearer:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一个非常有用的数据结构。如果您对 CPU 内部结构和程序执行方式有些了解，那么您就会知道栈在这些情况下是普遍存在的。它只是一个具有一个限制的列表，**后进先出**（**LIFO**），意味着当从栈中读取值时，最后进入的元素先出来。以下插图将使这一点更加清晰：
- en: '![Figure 2.2: A stack with two insert elements and one pop operation'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2：带有两个插入元素和一个弹出操作的栈](img/B15780_02_02.jpg)'
- en: '](img/B15780_02_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2：带有两个插入元素和一个弹出操作的栈](img/B15780_02_02.jpg)'
- en: 'Figure 2.2: A stack with two insert elements and one pop operation'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：带有两个插入元素和一个弹出操作的栈
- en: As you can see, we have a LIFO strategy to read values from a stack. We will
    implement a stack using a Python list. Python lists have a method called `pop`,
    which does the exact same `pop` operation that you can see in the preceding illustration.
    Basically, the `pop` function will take an element off the stack, using the **Last
    in First Out** (**LIFO**) rules. We will use that to implement a stack in the
    following exercise.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个 LIFO（后进先出）策略来从栈中读取值。我们将使用 Python 列表来实现栈。Python 列表有一个名为 `pop` 的方法，它执行与前面插图中所见相同的
    `pop` 操作。基本上，`pop` 函数将从栈中移除一个元素，使用 **后进先出**（**LIFO**）规则。我们将在以下练习中使用它来实现栈。
- en: 'Exercise 2.02: Implementing a Stack in Python'
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.02：在 Python 中实现栈
- en: 'In this exercise, we''ll implement a stack in Python. We will first create
    an empty stack and add new elements to it using the `append` method. Next, we''ll
    take out elements from the stack using the `pop` method. Let''s go through the
    following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 Python 实现一个栈。我们首先创建一个空栈，并使用 `append` 方法向其中添加新元素。接下来，我们将使用 `pop`
    方法从栈中取出元素。让我们按照以下步骤进行：
- en: 'Import the necessary Python library and define an empty stack:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的 Python 库并定义一个空栈：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '`pandas` is an open source data analysis library in Python.'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`pandas` 是 Python 中的一个开源数据分析库。'
- en: 'Use the `append` method to add multiple elements to the stack. Thanks to the
    `append` method, the element will always be appended at the end of the list:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `append` 方法向栈中添加多个元素。多亏了 `append` 方法，元素将始终被追加到列表的末尾：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE12]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s read a value from our stack using the `pop` method. This method reads
    the current last index of the list and returns it to us. It also deletes the index
    once the read is done:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 `pop` 方法从我们的栈中读取一个值。此方法读取列表的当前最后一个索引并将其返回给我们。一旦读取完成，它也会删除该索引：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the last value of the stack has been retrieved. Now, if we add
    another value to the stack, the new value will be appended at the end of the stack.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，栈的最后一个值已被检索。现在，如果我们向栈中添加另一个值，新值将被追加到栈的末尾。
- en: 'Append `Hello@test.com` to the stack:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Hello@test.com` 添加到栈中：
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3hACc2B](https://packt.live/3hACc2B).
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/3hACc2B](https://packt.live/3hACc2B)。
- en: You can also run this example online at [https://packt.live/2Yb4uct](https://packt.live/2Yb4uct).
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以在 [https://packt.live/2Yb4uct](https://packt.live/2Yb4uct) 上在线运行此示例。
- en: From the exercise, we can see that the basic stack operations, `append` and
    `pop`, are pretty easy to perform.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从练习中，我们可以看到基本的栈操作，`append` 和 `pop`，执行起来相当简单。
- en: Let's visualize a problem where you are scraping a web page and you want to
    follow each URL present there (backlinks). Let's split the solution to this problem
    into three parts. In the first part, we would append all the URLs scraped off
    the page into the stack. In the second part, we would pop each element in the
    stack, and then lastly, we would examine every URL, repeating the same process
    for each page. We will examine a part of this task in the next exercise.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们可视化一个场景：你正在爬取一个网页，并希望跟随其中每个存在的URL（反向链接）。让我们将这个问题的解决方案分为三个部分。在第一部分，我们将从页面上爬取的所有URL追加到栈中。在第二部分，我们将从栈中弹出每个元素，最后，我们将检查每个URL，并对每个页面重复相同的流程。我们将在下一项练习中检查这个任务的一部分。
- en: 'Exercise 2.03: Implementing a Stack Using User-Defined Methods'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.03：使用用户定义的方法实现栈
- en: 'In this exercise, we will continue the topic of stacks from the last exercise.
    This time, we will implement the `append` and `pop` functions by creating user-defined
    methods. We will implement a stack, and this time with a business use case example
    (taking Wikipedia as a source). The aim of this exercise is twofold. In the first
    few steps, we will extract and append the URLs scraped off a web page in a stack,
    which also involves the `string` methods discussed in the last chapter. In the
    next few steps, we will use the `stack_pop` function to iterate over the stack
    and print them. This exercise will show us a subtle feature of Python and how
    it handles passing list variables to functions. Let''s go through the following
    steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将继续上一项练习中的栈主题。这次，我们将通过创建用户定义的方法来实现`append`和`pop`函数。我们将实现一个栈，这次以一个商业用例为例（以维基百科作为来源）。这个练习的目标有两个。在前几个步骤中，我们将从网页中提取并追加URL到栈中，这也涉及到上一章讨论的`string`方法。在接下来的几个步骤中，我们将使用`stack_pop`函数遍历栈并打印它们。这个练习将展示Python的一个微妙特性以及它是如何处理将列表变量传递给函数的。让我们按以下步骤进行：
- en: 'First, define two functions: `stack_push` and `stack_pop`. We renamed them
    so that we do not have a namespace conflict. Also, create a stack called `url_stack`
    for later use:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，定义两个函数：`stack_push`和`stack_pop`。我们将其重命名，以避免命名空间冲突。同时，创建一个名为`url_stack`的栈以供以后使用：
- en: '[PRE17]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE18]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first function takes the already existing stack and adds the value at the
    end of it.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个函数接受已经存在的栈，并将其值添加到栈的末尾。
- en: Note
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the square brackets around the value to convert it into a one-element
    list using the `+` operation. The second function reads the value that's currently
    at the `-1` index of the stack, then uses the `del` operator to delete that index,
    and finally returns the value it read earlier.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意值周围的方括号，使用`+`操作将其转换为单元素列表。第二个函数读取栈中当前`-1`索引的值，然后使用`del`运算符删除该索引，并最终返回它之前读取的值。
- en: Now, we are going to have a string with a few URLs in it.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们将有一个包含几个URL的字符串。
- en: 'Analyze the string so that we push the URLs in the stack one by one as we encounter
    them, and then use a `for` loop to pop them one by one. Let''s take the first
    line from the `Wikipedia` article ([https://en.wikipedia.org/wiki/Data_mining](https://en.wikipedia.org/wiki/Data_mining))
    about data science:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析字符串，以便我们在遇到URL时逐个将其推入栈中，然后使用`for`循环逐个弹出。让我们以维基百科文章的第一行为例（[https://en.wikipedia.org/wiki/Data_mining](https://en.wikipedia.org/wiki/Data_mining)）关于数据科学：
- en: '[PRE19]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For the sake of the simplicity of this exercise, we have kept the links in square
    brackets beside the target words.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了简化这个练习，我们在目标词旁边保留了方括号中的链接。
- en: 'Find the length of the string:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找字符串的长度：
- en: '[PRE20]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Convert this string into a list by using the `split` method from the string,
    and then calculate its length:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用字符串的`split`方法将这个字符串转换为列表，然后计算其长度：
- en: '[PRE22]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows (partial output):'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下（部分输出）：
- en: '[PRE23]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Check the length of the list:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查列表的长度：
- en: '[PRE24]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use a `for` loop to go over each word and check whether it is a URL. To do
    that, we will use the `startswith` method from the string, and if it is a URL,
    then we push it into the stack:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for`循环遍历每个单词，并检查它是否是URL。为此，我们将使用字符串的`startswith`方法，如果它是URL，则将其推入栈中：
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE27]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice the use of string slicing to remove the surrounding double quotes `"[" "]"`.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意使用字符串切片来移除周围的引号`"[" "]"`。
- en: 'Print the value in `url_stack`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印`url_stack`中的值：
- en: '[PRE28]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output is as follows:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE29]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Iterate over the list and print the URLs one by one by using the `stack_pop`z function:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历列表并使用 `stack_pop` 函数逐个打印 URL：
- en: '[PRE30]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 2.3: Output of the URLs that are printed using a stack'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.3：使用栈打印的 URL 输出'
- en: '](img/B15780_02_03.jpg)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_02_03.jpg)'
- en: 'Figure 2.3: Output of the URLs that are printed using a stack'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.3：使用栈打印的 URL 输出
- en: 'Print it again to make sure that the stack is empty after the final `for` loop:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打印以确保在最后的 `for` 循环之后栈为空：
- en: '[PRE31]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Y7oXyT](https://packt.live/2Y7oXyT).
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/2Y7oXyT](https://packt.live/2Y7oXyT)。
- en: You can also run this example online at [https://packt.live/3e9Smhz](https://packt.live/3e9Smhz).
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在 [https://packt.live/3e9Smhz](https://packt.live/3e9Smhz) 上在线运行此示例。
- en: In this exercise, we have noticed a strange phenomenon in the `stack_pop` method.
    We passed the `list` variable there, and we used the `del` operator inside the
    function in *step 1*, but it changed the original variable by deleting the last
    index each time we called the function. If you use languages like C, C++, and
    Java, then this is a completely unexpected behavior as, in those languages, this
    can only happen if we pass the variable by reference, and it can lead to subtle
    bugs in Python code. So, be careful when using the user-defined methods.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们在 `stack_pop` 方法中注意到一个奇怪的现象。我们传递了 `list` 变量到那里，并在函数内部使用了 `del` 操作符
    *步骤 1*，但每次调用函数时都会通过删除最后一个索引来改变原始变量。如果你使用像 C、C++ 和 Java 这样的语言，那么这种行为是完全不可预期的，因为在那些语言中，这只能通过引用传递变量来实现，并且可能导致
    Python 代码中的微妙错误。所以，在使用用户定义的方法时要小心。
- en: Lambda Expressions
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: In general, it is not a good idea to change a variable's value inside a function.
    Any variable that is passed to the function should be considered and treated as
    immutable. This is close to the principles of functional programming. However,
    in that case, we could use unnamed functions that are neither immutable nor mutable
    and are typically not stored in a variable. Such an expression or function, called
    a **lambda expression** in Python, is a way to construct one-line, nameless functions
    that are, by convention, side-effect-free and are loosely considered as implementing
    functional programming.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在函数内部改变变量的值不是一个好主意。任何传递给函数的变量都应被视为不可变的。这接近函数式编程的原则。然而，在这种情况下，我们可以使用既不可变也不可变的匿名函数，并且通常不会存储在变量中。在
    Python 中，这样的表达式或函数称为 **lambda 表达式**，它是一种构建单行、无名的函数的方法，按照惯例，这些函数是无副作用的，并且通常被认为是实现了函数式编程。
- en: Let's look at the following exercise to understand how we use a lambda expression.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下练习，以了解我们如何使用 lambda 表达式。
- en: 'Exercise 2.04: Implementing a Lambda Expression'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.04：实现 Lambda 表达式
- en: 'In this exercise, we will use a lambda expression to prove the famous trigonometric identity:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 lambda 表达式来证明著名的三角恒等式：
- en: '![Figure 2.4: Trigonometric identity'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4：三角恒等式'
- en: '](img/B15780_02_04.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_02_04.jpg)'
- en: 'Figure 2.4: Trigonometric identity'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：三角恒等式
- en: 'Let''s go through the following steps to do this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下步骤进行操作：
- en: 'Import the `math` package:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `math` 包：
- en: '[PRE33]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define two functions, `my_sine` and `my_cosine`, using the `def` keyword. The
    reason we are declaring these functions is the original `sin` and `cos` functions
    from the `math` package take `radians` as input, but we are more familiar with
    `degrees`. So, we will use a lambda expression to define a wrapper function for
    `sine` and `cosine`, then use it. This `lambda` function will automatically convert
    our degree input to radians and then apply `sin` or `cos` on it and return the value:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `def` 关键字定义两个函数，`my_sine` 和 `my_cosine`。我们声明这些函数的原因是 `math` 包中的原始 `sin` 和
    `cos` 函数接受 `radians` 作为输入，但我们更熟悉 `degrees`。因此，我们将使用 lambda 表达式来定义 `sine` 和 `cosine`
    的包装函数，然后使用它。这个 `lambda` 函数将自动将我们的度数输入转换为弧度，然后应用 `sin` 或 `cos` 并返回值：
- en: '[PRE34]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define `sine` and `cosine` for our purpose:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `sine` 和 `cosine` 以满足我们的目的：
- en: '[PRE35]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE36]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that we have assigned the return value from both `my_sine` and `my_cosine`
    to two variables, and then used them directly as the functions. It is a much cleaner
    approach than using them explicitly. Notice that we did not explicitly write a
    `return` statement inside the lambda function; it is assumed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将`my_sine`和`my_cosine`的返回值分别赋给了两个变量，然后直接将它们用作函数。这种方法比显式使用它们要干净得多。注意，我们没有在lambda函数内显式地写`return`语句；这是默认的。
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3fJW9mb](https://packt.live/3fJW9mb).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的源代码，请参阅[https://packt.live/3fJW9mb](https://packt.live/3fJW9mb)。
- en: You can also run this example online at [https://packt.live/30Pn8by](https://packt.live/30Pn8by).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/30Pn8by](https://packt.live/30Pn8by)上运行这个示例。
- en: Now, in the next section, we will be using lambda functions, also known as anonymous
    functions, which come from lambda calculus. Lambda functions are useful for creating
    temporary functions that are not named. The lambda expression will take an input
    and then return the first character of that input.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在下一节中，我们将使用lambda函数，也称为匿名函数，这些函数来自lambda演算。Lambda函数用于创建未命名的临时函数。Lambda表达式将接受一个输入，然后返回该输入的第一个字符。
- en: 'Exercise 2.05: Lambda Expression for Sorting'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.05：排序的Lambda表达式
- en: 'In this exercise, we will be exploring the `sort` function to take advantage
    of the lambda function. What makes this exercise useful is that you will be learning
    how to create any unique algorithm that could be used for sorting a dataset. The
    syntax for a lambda function is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将探索`sort`函数以利用lambda函数。这个练习有用的地方在于，你将学习如何创建任何可以用于排序数据集的独特算法。Lambda函数的语法如下：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A lambda expression can take one or more inputs. A lambda expression can also
    be used to reverse sort by using the parameter of `reverse` as `True`. We''ll
    use the reverse functionality as well in this exercise. Let''s go through the
    following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式可以接受一个或多个输入。Lambda表达式也可以通过使用`reverse`参数为`True`来逆序排序。我们将在本练习中同样使用逆序功能。让我们通过以下步骤进行：
- en: 'Let''s store the list of tuples we want to sort in a variable called `capitals`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将我们想要排序的元组列表存储在一个名为`capitals`的变量中：
- en: '[PRE38]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Print the output of this list:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印此列表的输出：
- en: '[PRE39]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output will be as follows:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE40]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Sort this list by the name of the capitals of each country, using a simple
    lambda expression. The following code uses a lambda function as the `sort` function.
    It will sort based on the first element in each tuple:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用简单的lambda表达式按每个国家的首都名称对列表进行排序。以下代码使用lambda函数作为`sort`函数。它将根据每个元组的第一个元素进行排序：
- en: '[PRE41]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output will be as follows:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE42]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As we can see, lambda expressions are powerful if we master them and use them
    in our data wrangling jobs. They are also side-effect-free—meaning that they do
    not change the values of the variables that are passed to them in place.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，如果我们掌握了它们并在我们数据处理工作中使用lambda表达式，它们是非常强大的。它们也是无副作用的——这意味着它们不会改变传递给它们的变量的值。
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2AzcTxv](https://packt.live/2AzcTxv).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的源代码，请参阅[https://packt.live/2AzcTxv](https://packt.live/2AzcTxv)。
- en: You can also run this example online at [https://packt.live/3hDpe4o](https://packt.live/3hDpe4o).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3hDpe4o](https://packt.live/3hDpe4o)上运行这个示例。
- en: We will now move on to the next section, where we will discuss membership checking
    for each element. Membership checking is commonly used terminology in qualitative
    research and describes the process of checking that the data present in a dataset
    is accurate.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将进入下一节，我们将讨论每个元素的成员检查。成员检查是定性研究中的常用术语，描述了检查数据集中数据准确性的过程。
- en: 'Exercise 2.06: Multi-Element Membership Checking'
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.06：多元素成员检查
- en: 'In this exercise, we will create a list of words using `for` loop to validate
    that all the elements in the first list are present in the second list. Let''s
    see how:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`for`循环创建一个单词列表，以验证第一个列表中的所有元素都存在于第二个列表中。让我们看看如何：
- en: 'Create a `list_of_words` list with words scraped from a text corpus:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`list_of_words`列表，其中包含从文本语料库中抓取的单词：
- en: '[PRE43]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is as follows:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE44]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Define a `check_for` list, which will contain two similar elements of `list_of_words`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`check_for`列表，它将包含`list_of_words`中的两个相似元素：
- en: '[PRE45]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output is as follows:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE46]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There is an elaborate solution, which involves a `for` loop and a few `if`/`else`
    conditions (and you should try to write it), but there is also an elegant Pythonic
    solution to this problem, which takes one line and uses the `all` function. The
    `all` function returns `True` if all elements of the iterable are `True`.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有一个详细解决方案，它涉及一个 `for` 循环和一些 `if`/`else` 条件（你应该尝试编写它），但还有一个优雅的 Pythonic 解决方案来解决这个问题，它只需要一行代码并使用
    `all` 函数。`all` 函数在可迭代对象的所有元素都是 `True` 时返回 `True`。
- en: 'Use the `in` keyword to check membership of the elements in the `check_for`
    list in `list_of_words`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `in` 关键字检查 `list_of_words` 中的 `check_for` 列表元素的成员资格：
- en: '[PRE47]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output is as follows:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE48]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3d5pyVT](https://packt.live/3d5pyVT).
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/3d5pyVT](https://packt.live/3d5pyVT)。
- en: You can also run this example online at [https://packt.live/2C7GPB1](https://packt.live/2C7GPB1).
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在 [https://packt.live/2C7GPB1](https://packt.live/2C7GPB1) 上在线运行此示例。
- en: It is indeed elegant and simple to reason about, and this neat trick is very
    important while dealing with lists. Basically, what we are doing is looping over
    the first list with the comprehension and then looping over the second list using
    the `for` loop. What makes this elegant is how compactly we can represent this
    complex process. Caution should be taken when using very complex list comprehension—the
    more complex you make it, the harder it is to read.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实既优雅又简单，在处理列表时这个巧妙的方法非常重要。基本上，我们正在使用列表推导式遍历第一个列表，然后使用 `for` 循环遍历第二个列表。使这个方法优雅的是我们如何紧凑地表示这个复杂的过程。当使用非常复杂的列表推导式时，应该小心——你让它越复杂，就越难阅读。
- en: 'Let''s look at the next data structure: a **queue**.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一个数据结构：一个**队列**。
- en: Queue
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列
- en: 'Apart from stacks, another high-level data structure type that we are interested
    in is queues. A queue is like a stack, which means that you continue adding elements
    one by one. With a queue, the reading of elements obeys the **First in First Out
    (FIFO)** strategy. Check out the following diagram to understand this better:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 除了栈之外，我们感兴趣的另一个高级数据结构类型是队列。队列就像栈一样，这意味着你一个接一个地继续添加元素。对于队列，元素的读取遵循**先进先出（FIFO）**策略。查看以下图表以更好地理解这一点：
- en: '![Figure 2.5: Pictorial representation of a queue'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.5：队列的示意图]'
- en: '](img/B15780_02_05.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_02_05.jpg)'
- en: 'Figure 2.5: Pictorial representation of a queue'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：队列的示意图
- en: We will accomplish this first using list methods and will show you that, for
    this purpose, they are inefficient. Then, we will learn about the `dequeue` data
    structure from the collections module of Python. A queue is a very important data
    structure. We can think of a scenario on a producer-consumer system design. When
    doing data wrangling, you will often come across a problem where you must process
    very big files. One of the ways to deal with this problem is to split the chunk
    the contents of the file into smaller parts and then push them into a queue while
    creating small, dedicated worker processes, to read off the queue and process
    one small chunk at a time. This is a very powerful design, and you can even use
    it efficiently to design huge multi-node data wrangling pipelines.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用列表方法来完成这个任务，并展示它们在这种情况下是低效的。然后，我们将学习 Python 的 collections 模块中的 `dequeue`
    数据结构。队列是一个非常重要的数据结构。我们可以考虑一个生产者-消费者系统设计的场景。在进行数据处理时，你经常会遇到必须处理非常大的文件的问题。处理这个问题的方法之一是将文件内容分成更小的部分，然后在创建小型专用工作进程的同时将它们推入队列，一次读取并处理一小部分。这是一个非常强大的设计，你甚至可以有效地使用它来设计大型多节点数据处理管道。
- en: 'Exercise 2.07: Implementing a Queue in Python'
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.07：在 Python 中实现队列
- en: 'In this exercise, we''ll implement a queue in Python. We''ll use the `append`
    function to add elements to the queue and use the `pop` function to take elements
    out of the queue. We''ll also use the `deque` data structure and compare it with
    the queue in order to understand the wall time required to complete the execution
    of an operation. To do so, perform the following steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 Python 实现一个队列。我们将使用 `append` 函数向队列中添加元素，并使用 `pop` 函数从队列中取出元素。我们还将使用
    `deque` 数据结构，并将其与队列进行比较，以了解完成操作所需的总墙时。为此，请执行以下步骤：
- en: 'Create a Python queue with the plain list methods. To record the time the `append`
    operation in the queue data structure takes, we use the `%%time` command:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python的普通列表方法创建一个Python队列。为了记录队列数据结构中`append`操作所需的时间，我们使用`%%time`命令：
- en: '[PRE49]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '`%%time` is a regular built-in magic command in Python to capture the time
    required for an operation to execute.'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`%%time`是Python中一个常见的内置魔术命令，用于捕获操作执行所需的时间。'
- en: 'The output (partially shown) is as follows:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出（部分显示）如下：
- en: '![Figure 2.6: Wall time recorded for the append function in the queue'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.6：队列中`append`函数记录的墙时'
- en: '](img/B15780_02_06.jpg)'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_02_06.jpg)'
- en: 'Figure 2.6: Wall time recorded for the append function in the queue'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.6：队列中`append`函数记录的墙时
- en: 'If we were to use the `pop` function to empty the queue and check the items
    in it:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们要使用`pop`函数来清空队列并检查其中的项目：
- en: '[PRE50]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output would be as follows:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE51]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'However, this time, we''ll use the `%%time` magic command while executing the
    preceding code to see that it takes a while to finish:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这次，我们将在执行前面的代码时使用`%%time`魔术命令，以查看它需要一段时间才能完成：
- en: '[PRE52]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output is as follows:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 2.7: Wall time recorded for the pop function in the queue'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.7：队列中`pop`函数记录的墙时'
- en: '](img/B15780_02_07.jpg)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_02_07.jpg)'
- en: 'Figure 2.7: Wall time recorded for the pop function in the queue'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.7：队列中`pop`函数记录的墙时
- en: Note
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: If you are working on Google Colab or other virtual environments, you will see
    an additional line indicating the CPU time present in the output. This is the
    CPU time of the server on which Google Colab (or any other virtual environment)
    is running on. However, if you are working on your local system, this information
    will not be a part of the output.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你正在使用Google Colab或其他虚拟环境，你将看到输出中额外的一行，指示CPU时间。这是Google Colab（或任何其他虚拟环境）运行的服务器上的CPU时间。然而，如果你在自己的本地系统上工作，这些信息将不会是输出的一部分。
- en: In a modern MacBook, with a quad-core processor and `8` GB of RAM, it took around
    `1.20` seconds to finish. With Windows 10, it took around 2.24 seconds to finish.
    It takes this amount of time because of the `pop(0)` operation, which means every
    time we pop a value from the left of the list (the current `0` index), Python
    has to rearrange all the other elements of the list by shifting them one space
    left. Indeed, it is not a very optimized implementation.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在一台配备四核处理器和8GB RAM的现代MacBook上，完成所需时间大约为1.20秒。在Windows 10上，完成所需时间大约为2.24秒。它需要这么长时间是因为`pop(0)`操作，这意味着每次我们从列表的左侧（当前`0`索引）弹出值时，Python都必须通过将其他所有元素向左移动一个位置来重新排列列表中的所有其他元素。确实，这不是一个很优化的实现。
- en: 'Implement the same queue using the `deque` data structure from Python''s `collections`
    package and perform the `append` and `pop` functions on this data structure:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python的`collections`包中的`deque`数据结构实现相同的队列，并在该数据结构上执行`append`和`pop`函数：
- en: '[PRE53]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output is as follows:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 2.8: Wall time measured for deque'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.8：测量deque的墙时'
- en: '](img/B15780_02_08.jpg)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_02_08.jpg)'
- en: 'Figure 2.8: Wall time measured for deque'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：测量deque的墙时
- en: With the specialized and optimized queue implementation from Python's standard
    library, the time that this should take for both the operations is only approximately
    `27.9` milliseconds. This is a huge improvement on the previous one.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python标准库中的专用和优化队列实现，这两个操作所需的时间仅为大约27.9毫秒。这是对之前的一个巨大改进。
- en: Note
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/30R69Wc](https://packt.live/30R69Wc).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/30R69Wc](https://packt.live/30R69Wc)。
- en: You can also run this example online at [https://packt.live/3dazIEL](https://packt.live/3dazIEL).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3dazIEL](https://packt.live/3dazIEL)在线运行此示例。
- en: We will end the discussion on data structures here. What we discussed here is
    just the tip of the iceberg. Data structures are a fascinating subject. There
    are many other data structures that we did not touch on and that, when used efficiently,
    can offer enormous added value. We strongly encourage you to explore data structures
    more. Try to learn about linked lists, trees, graphs, and all the different variations
    of them as much as you can; you will find there are many similarities between
    them and you will benefit greatly from studying them. Not only do they offer the
    joy of learning, but they are also the secret mega-weapons in the arsenal of a
    data practitioner that you can bring out every time you are challenged with a
    difficult data wrangling job.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里结束对数据结构的讨论。我们在这里讨论的只是冰山一角。数据结构是一个迷人的主题。还有许多其他的数据结构我们没有涉及，而且当它们被有效使用时，可以提供巨大的附加价值。我们强烈建议您更深入地探索数据结构。尽可能多地了解链表、树、图以及它们的各种变体；您会发现它们之间有许多相似之处，并且从学习它们中受益匪浅。它们不仅提供了学习的乐趣，而且也是数据从业者武器库中的秘密超级武器，每次面对困难的数据处理任务时都可以使用。
- en: 'Activity 2.01: Permutation, Iterator, Lambda, and List'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 2.01：排列、迭代器、Lambda 和列表
- en: In this activity, we will be using `permutations` to generate all possible three-digit
    numbers that can be generated using `0`, `1`, and `2`. A permutation is a mathematical
    way to represent all possible outcomes. Then, we'll loop over this iterator and
    also use `isinstance` and `assert` to make sure that the return types are tuples.
    Use a single line of code involving `dropwhile` and `lambda` expressions to convert
    all the tuples to lists while dropping any leading zeros (for example, `(0, 1,
    2)` becomes `[1, 2]`). Finally, we will write a function that takes a list like
    before and returns the actual number contained in it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将使用 `permutations` 来生成所有可能的由 `0`、`1` 和 `2` 组成的三位数。排列是一种数学方法，用于表示所有可能的结果。然后，我们将遍历这个迭代器，并使用
    `isinstance` 和 `assert` 确保返回类型是元组。使用一行代码，结合 `dropwhile` 和 lambda 表达式，将所有元组转换为列表，同时去除任何前导零（例如，`(0,
    1, 2)` 变为 `[1, 2]`）。最后，我们将编写一个函数，它接受一个列表作为输入，并返回列表中包含的实际数字。
- en: 'These steps will guide you as to how to solve this activity:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将指导您如何解决这个活动：
- en: Look up the definition of `permutations` and `dropwhile` from `itertools`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 `itertools` 中 `permutations` 和 `dropwhile` 的定义。
- en: Write an expression to generate all the possible three-digit numbers, using
    `0`, `1`, and `2`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个表达式，使用 `0`、`1` 和 `2` 生成所有可能的三位数。
- en: Loop over the iterator expression you generated before. Print each element returned
    by the iterator. Use `assert` and `isinstance` to make sure that the elements
    are of the tuple type.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历之前生成的迭代器表达式。打印迭代器返回的每个元素。使用 `assert` 和 `isinstance` 确保元素是元组类型。
- en: Write the loop again, using `dropwhile`, with a lambda expression to drop any
    leading zeros from the tuples. As an example, `(0, 1, 2)` will become `[0, 2]`.
    Also, cast the output of `dropwhile` to a list.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编写循环，这次使用 `dropwhile` 和 lambda 表达式来去除元组中的前导零。例如，`(0, 1, 2)` 将变为 `[0, 2]`。同时，将
    `dropwhile` 的输出转换为列表。
- en: Check the actual type that `dropwhile` returns.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `dropwhile` 返回的实际类型。
- en: Combine the preceding code into one block; this time, write a separate function
    where you will pass the list generated from `dropwhile` and the function will
    return the whole number contained in the list. As an example, if you pass `[1,
    2]` to the function, it will return `12`. Make sure that the return type is indeed
    a number and not a string. Although this task can be achieved using other tricks,
    treat the incoming list as a stack in the function and generate the number by
    reading the individual digits from the stack.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的代码合并成一个代码块；这次，编写一个单独的函数，您将传递由 `dropwhile` 生成的列表，该函数将返回列表中包含的整个数字。例如，如果您将
    `[1, 2]` 传递给函数，它将返回 `12`。确保返回类型确实是数字而不是字符串。尽管可以使用其他技巧完成此任务，但请将传入的列表在函数中视为栈，并通过读取栈中的各个数字来生成数字。
- en: 'The final output should look like this:'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终输出应如下所示：
- en: '[PRE54]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15780_Solution_Final_RK.xhtml#_idTextAnchor307).
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以通过[这个链接](B15780_Solution_Final_RK.xhtml#_idTextAnchor307)找到。
- en: With this activity, we have finished this topic and will move on to the next
    topic, which involves basic file-level operations.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个活动，我们完成了这个主题，并将继续到下一个主题，该主题涉及基本的文件级操作。
- en: Note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We encourage you to think about a solution to the preceding problem without
    using all the advanced operations and data structures we have used here. You will
    soon realize how complex the solution is, and how much more detailed it must be.
    Then, you will understand how much value these data structures and operations
    bring.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您在没有使用我们在这里使用的高级操作和数据结构的情况下，考虑解决前面问题的解决方案。您很快就会意识到解决方案是多么复杂，以及它必须多么详细。然后，您将理解这些数据结构和操作的价值有多大。
- en: Basic File Operations in Python
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的基本文件操作
- en: In the previous topic, we investigated a few advanced data structures and also
    learned neat and useful functional programming methods to manipulate them without
    side effects. In this topic, we will learn about a few OS-level functions in Python,
    such as working with files, but these could also include working with printers,
    and even the internet. We will concentrate mainly on file-related functions and
    learn how to open a file, read the data line by line or all at once, and finally,
    how to cleanly close the file we opened. The closing operation of a file should
    be done cautiously, which is ignored most of the time by developers. When handling
    file operations, we often run into very strange and hard-to-track-down bugs because
    a process opened a file and did not close it properly. We will apply a few of
    the techniques we have learned about to a file that we will read to practice our
    data wrangling skills further.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个主题中，我们研究了一些高级数据结构，并且还学习了干净且有用的函数式编程方法来无副作用地操作它们。在本主题中，我们将学习Python中的一些OS级函数，例如处理文件，但这也可能包括处理打印机，甚至互联网。我们将主要关注与文件相关的函数，并学习如何打开文件，逐行读取数据或一次性读取所有数据，最后，如何干净地关闭我们打开的文件。文件关闭操作应该谨慎进行，这在大多数情况下被开发者忽略。在处理文件操作时，我们经常会遇到非常奇怪且难以追踪的bug，因为某个进程打开了一个文件而没有正确关闭它。我们将应用我们学到的一些技术到一个我们将要读取的文件上，以进一步练习我们的数据处理技能。
- en: 'Exercise 2.08: File Operations'
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.08：文件操作
- en: In this exercise, we will learn about the OS module of Python, and we will also
    look at two very useful ways to write and read environment variables. The power
    of writing and reading environment variables is often very important when designing
    and developing data-wrangling pipelines.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习Python的OS模块，并且我们还将探讨两种非常实用的方法来编写和读取环境变量。编写和读取环境变量的能力在设计和开发数据处理管道时通常非常重要。
- en: Note
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In fact, one of the factors of the famous 12-factor app design is the very
    idea of storing configuration in the environment. You can check it out at this
    URL: [https://12factor.net/config](https://12factor.net/config).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，著名12因子应用程序设计的一个因素就是将配置存储在环境中的想法。您可以在以下URL中查看：[https://12factor.net/config](https://12factor.net/config)。
- en: 'The purpose of the OS module is to give you ways to interact with OS-dependent
    functionalities. In general, it is pretty low-level and most of the functions
    from there are not useful on a day-to-day basis; however, some are worth learning.
    `os.environ` is the collection Python maintains with all the present environment
    variables in your OS. It gives you the power to create new ones. The `os.getenv`
    function gives you the ability to read an environment variable:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: OS模块的目的是为您提供与操作系统依赖功能交互的方法。一般来说，它是相当底层的，并且那里的大多数函数在日常使用中并不有用；然而，其中一些是值得学习的。`os.environ`是Python维护的集合，包含了您操作系统中的所有当前环境变量。它赋予您创建新变量的能力。`os.getenv`函数赋予您读取环境变量的能力：
- en: Import the `os` module.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`os`模块。
- en: '[PRE55]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Set a few environment variables:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一些环境变量：
- en: '[PRE56]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output is as follows:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE57]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Print the environment variable when it is not set:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当未设置环境变量时打印：
- en: '[PRE58]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output is as follows:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE59]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Print the `os` environment:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印`os`环境：
- en: '[PRE60]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The output has not been added for security reasons.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于安全原因，输出尚未添加。
- en: To access the source code for this specific section, please refer to [https://packt.live/2YCZAnC](https://packt.live/2YCZAnC).
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问本节的具体源代码，请参阅[https://packt.live/2YCZAnC](https://packt.live/2YCZAnC)。
- en: You can also run this example online at [https://packt.live/3fCqnaB](https://packt.live/3fCqnaB).
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3fCqnaB](https://packt.live/3fCqnaB)上在线运行此示例。
- en: After executing the preceding code, you will be able to see that you have successfully
    printed the value of `MY_KEY`, and when you tried to print `MY_KEY_NOT_SET`, it
    printed `None`. Therefore, utilizing the OS module, you will be able to set the
    value of environment variables in your system.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码后，你将能够看到你已成功打印了`MY_KEY`的值，当你尝试打印`MY_KEY_NOT_SET`时，它打印了`None`。因此，利用OS模块，你将能够在你的系统中设置环境变量的值。
- en: File Handling
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件处理
- en: In this section, we will learn about how to open a file in Python. We will learn
    about the different modes that we can use and what they stand for when opening
    a file. Python has a built-in `open` function that we will use to open a file.
    The `open` function takes a few arguments as input. Among them, the first one,
    which stands for the name of the file you want to open, is the only one that's
    mandatory. Everything else has a default value. When you call `open`, Python uses
    underlying system-level calls to open a file handler and return it to the caller.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在Python中打开文件。我们将了解我们可以使用的不同模式以及它们在打开文件时的含义。Python有一个内置的`open`函数，我们将使用它来打开文件。`open`函数接受一些输入参数。其中，第一个参数代表你想要打开的文件名，是唯一必须的。其他所有内容都有默认值。当你调用`open`时，Python会使用底层系统级调用打开文件句柄并将其返回给调用者。
- en: Usually, a file can be opened either for reading or writing. If we open a file
    in one mode, the other operation is not supported. Whereas reading usually means
    we start to read from the beginning of an existing file, writing can mean either
    starting a new file and writing from the beginning or opening an existing file
    and appending to it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，文件可以用于读取或写入。如果我们以某种模式打开文件，则不支持其他操作。而读取通常意味着我们从现有文件的开始处开始读取，写入可以意味着从文件开始处创建新文件并写入，或者打开现有文件并附加到它。
- en: 'Here is a table showing you all the different modes Python supports for opening
    a file:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个表格，展示了Python支持的所有不同文件打开模式：
- en: '![Figure 2.9: Modes to read a file'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.9: 读取文件的模式'
- en: '](img/B15780_02_09.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15780_02_09.jpg]'
- en: 'Figure 2.9: Modes to read a file'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：读取文件的模式
- en: There is also a deprecated mode, `U`, which does nothing in a Python 3 environment.
    One thing we must remember here is that Python will always differentiate between
    `t` and `b` modes, even if the underlying OS doesn't. This is because, in `b`
    mode, Python does not try to decode what it is reading and gives us back the `byteobject`
    instead, whereas, in `t` mode, it does try to decode the stream and gives us back
    the `string` representation.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个已弃用的模式`U`，在Python 3环境中没有任何作用。我们必须记住的是，Python将始终区分`t`和`b`模式，即使底层操作系统不这样做。这是因为，在`b`模式下，Python不会尝试解码它所读取的内容，而是返回`byteobject`，而在`t`模式下，它会尝试解码流并返回字符串表示。
- en: You can open a file for reading with the command that follows. The path (highlighted)
    would need to be changed based on the location of the file on your system.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令打开文件进行读取。路径（高亮显示）需要根据你系统上文件的位置进行更改。
- en: '[PRE61]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We will discuss some more functions in the following section.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论更多函数。
- en: Note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The file can be found here [https://packt.live/2YGpbfv](https://packt.live/2YGpbfv).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 文件可以在这里找到：[https://packt.live/2YGpbfv](https://packt.live/2YGpbfv)。
- en: 'This is opened in `rt` mode (opened for the `reading+text` mode). You can open
    the same file in `binary` mode if you want. To open the file in binary mode, use
    the `rb (read, byte)` mode:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在`rt`模式下打开的（以`reading+text`模式打开）。如果你想以二进制模式打开相同的文件，也可以。要以二进制模式打开文件，请使用`rb
    (read, byte)`模式：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The file can be found here: [https://packt.live/30OSkaP](https://packt.live/30OSkaP).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 文件可以在这里找到：[https://packt.live/30OSkaP](https://packt.live/30OSkaP)。
- en: 'This is how we open a file for writing:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们打开文件进行写入的方式：
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The output is as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Let's practice this concept in the following exercise.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下面的练习中练习这个概念。
- en: 'Exercise 2.09: Opening and Closing a File'
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.09：打开和关闭文件
- en: In this exercise, we will learn how to close a file after opening it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习如何在打开文件后关闭它。
- en: Note
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The file we will be working on can be found here: [https://packt.live/30OSkaP](https://packt.live/30OSkaP).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的文件可以在这里找到：[https://packt.live/30OSkaP](https://packt.live/30OSkaP)。
- en: We must close a file once we have opened it. A lot of system-level bugs can
    occur due to a dangling file handler, which means the file is still being modified,
    even though the application is done using it. Once we close a file, no further
    operations can be performed on that file using that specific file handler.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一旦打开文件，就必须关闭它。由于悬挂的文件处理器，即文件仍在被修改，尽管应用程序已经完成使用它，因此可能会发生许多系统级错误。一旦我们关闭文件，就无法使用该特定的文件处理器在该文件上执行任何进一步的操作。
- en: 'Open a file in binary mode:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以二进制模式打开文件：
- en: '[PRE66]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Change the highlighted path based on the location of the file on your system.
    The video of this exercise shows how to use the same function on a different file.
    There, you'll also get a glimpse of the function used to write to files, which
    is something you'll learn about later in the chapter.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据您系统上文件的位置更改高亮显示的路径。本练习的视频展示了如何在不同文件上使用相同的函数。在那里，您还将看到用于写入文件的函数的示例，您将在本章的后面部分学习到这一点。
- en: 'Close a file using `close()`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `close()` 关闭文件：
- en: '[PRE67]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Python also gives us a `closed` flag with the file handler. If we print it before
    closing, then we will see `False`, whereas if we print it after closing, then
    we will see `True`. If our logic checks whether a file is properly closed or not,
    then this is the flag we want to use.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还为我们提供了文件处理器的 `closed` 标志。如果我们关闭文件之前打印它，那么我们会看到 `False`，而如果我们关闭文件之后打印它，那么我们会看到
    `True`。如果我们需要检查文件是否已正确关闭，那么这就是我们想要使用的标志。
- en: Note
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/30R6FDC](https://packt.live/30R6FDC).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的源代码，请参阅 [https://packt.live/30R6FDC](https://packt.live/30R6FDC)。
- en: You can also run this example online at [https://packt.live/3edLoI8](https://packt.live/3edLoI8).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在 [https://packt.live/3edLoI8](https://packt.live/3edLoI8) 上在线运行此示例。
- en: The with Statement
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`with` 语句'
- en: In this section, we will learn about the `with` statement in Python and how
    we can effectively use it in the context of opening and closing files.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习 Python 中的 `with` 语句以及我们如何在打开和关闭文件的情况下有效地使用它。
- en: The `with` command is a compound statement in Python, like `if` and `for`, designed
    to combine multiple lines. Like any compound statement, `with` also affects the
    execution of the code enclosed by it. In the case of `with`, it is used to wrap
    a block of code in the scope of what we call a *Context Manager* in Python. A
    context manager is a convenient way to work with resources and will help avoid
    forgetting to close the resource. A detailed discussion of context managers is
    out of the scope of this exercise and this topic in general, but it is sufficient
    to say that if a context manager is implemented inside the `open` call for opening
    a file in Python, it is guaranteed that a close call will automatically be made
    if we wrap it inside a `with` statement.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的 `with` 命令是一个复合语句，类似于 `if` 和 `for`，旨在组合多行。像任何复合语句一样，`with` 也会影响其包含的代码的执行。在
    `with` 的情况下，它用于将一段代码包裹在所谓的 Python 中的 *上下文管理器* 的作用域内。上下文管理器是一种方便的资源管理方式，有助于避免忘记关闭资源。关于上下文管理器的详细讨论超出了本练习的范围，但总的来说，如果上下文管理器是在
    Python 中打开文件的 `open` 调用中实现的，那么如果我们在 `with` 语句中包裹它，就保证会自动执行关闭调用。
- en: Note
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is an entire PEP for `with` at [https://www.python.org/dev/peps/pep-0343/](https://www.python.org/dev/peps/pep-0343/).
    We encourage you to look into it.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `with` 的整个 PEP 可以在 [https://www.python.org/dev/peps/pep-0343/](https://www.python.org/dev/peps/pep-0343/)
    找到。我们鼓励您去查看。
- en: Opening a File Using the with Statement
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `with` 语句打开文件
- en: 'Open a file using the `with` statement:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `with` 语句打开文件：
- en: '[PRE68]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The output is as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE69]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If we execute the preceding code, we will see that the first `print` will end
    up printing `False`, whereas the second one will print `True`. This means that
    as soon as the control goes out of the `with` block, the file descriptor is automatically
    closed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行前面的代码，我们会看到第一个 `print` 将打印 `False`，而第二个将打印 `True`。这意味着一旦控制流出 `with` 块，文件描述符就会自动关闭。
- en: Note
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is by far the cleanest and most Pythonic way to open a file and obtain
    a file descriptor for it. We encourage you to use this pattern whenever you need
    to open a file by yourself.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这无疑是打开文件并获得文件描述符的最干净、最 Pythonic 的方式。我们鼓励您在需要自己打开文件时始终使用此模式。
- en: 'Exercise 2.10: Reading a File Line by Line'
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.10：逐行读取文件
- en: 'In this exercise, we''ll read a file line by line. Let''s go through the following
    steps to do so:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将逐行读取文件。让我们按照以下步骤进行：
- en: 'Open a file and then read the file line by line and print it as we read it:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个文件，然后逐行读取文件并打印出我们读取的内容：
- en: '[PRE70]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Duplicate the same `for` loop, just after the first one:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个循环之后立即复制相同的`for`循环：
- en: '[PRE71]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Do not forget to change the path (highlighted) of the file based on its location
    on your system.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记根据文件在您系统中的位置更改文件路径（突出显示）。
- en: 'The output (partially shown) is as follows:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出（部分显示）如下：
- en: '![Figure 2.11: Section of the open file'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.11：打开文件的部分'
- en: '](img/B15780_02_11.jpg)'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_02_11.jpg)'
- en: 'Figure 2.11: Section of the open file'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：打开文件的部分
- en: Note
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/37B7aTX](https://packt.live/37B7aTX).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/37B7aTX](https://packt.live/37B7aTX)。
- en: You can also run this example online at [https://packt.live/3fCqWBf](https://packt.live/3fCqWBf).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3fCqWBf](https://packt.live/3fCqWBf)在线运行此示例。
- en: Let's look at the last exercise of this chapter.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看本章的最后一个练习。
- en: 'Exercise 2.11: Writing to a File'
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.11：写入文件
- en: 'In this exercise, we''ll look into file operations by showing you how to read
    from a dictionary and write to a file. We will write a few lines to a file and
    read the file:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过向您展示如何从字典中读取并写入文件来探讨文件操作。我们将向文件中写入几行，并读取该文件：
- en: Note
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`data_temporary_files.txt` can be found at [https://packt.live/2YGpbfv](https://packt.live/2YGpbfv).'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_temporary_files.txt`可以在[https://packt.live/2YGpbfv](https://packt.live/2YGpbfv)找到。'
- en: 'Let''s go through the following steps:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤进行：
- en: 'Use the `write` function from the file descriptor object:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文件描述符对象的`write`函数：
- en: '[PRE72]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this exercise, don't forget to change the path (highlighted) based
    on where you have stored the text file.
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在整个练习过程中，不要忘记根据您存储文本文件的位置更改文件路径（突出显示）。
- en: 'Read the file using the following command:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令读取文件：
- en: '[PRE73]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output is as follows:'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE74]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Use the `print` function to write to a file using the following command:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`print`函数通过以下命令写入文件：
- en: '[PRE75]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Read the file using the following command:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令读取文件：
- en: '[PRE76]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: With this, we will end this topic. Just like the previous topics, we have designed
    an activity for you to practice your newly acquired skills.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们将结束这个主题。就像前面的主题一样，我们为您设计了一个活动来练习您新获得的知识。
- en: 'Activity 2.02: Designing Your Own CSV Parser'
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动二.02：设计您自己的CSV解析器
- en: 'A CSV file is something you will encounter a lot in your life as a data practitioner.
    A CSV file is a comma-separated file where data from a tabular format is generally
    stored and separated using commas, although other characters can also be used,
    such as `tab` or `*`. Here''s an example CSV file:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在作为数据从业者的一生中，您会遇到很多CSV文件。CSV文件是一种以逗号分隔的文件，其中通常存储和用逗号分隔来自表格格式的数据，尽管也可以使用其他字符，如`tab`或`*`。以下是一个示例CSV文件：
- en: '![Figure 2.12: Partial output of a CSV file'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.12：CSV文件的部分输出'
- en: '](img/B15780_02_12.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_02_12.jpg)'
- en: 'Figure 2.12: Partial output of a CSV file'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：CSV文件的部分输出
- en: In this activity, we will be tasked with building our own CSV reader and parser.
    Although it is a big task if we try to cover all use cases and edge cases, along
    with escape characters, for the sake of this short activity, we will keep our
    requirements small. We will assume that there is no escape character—meaning that
    if you use a comma at any place in your row, you are starting a new column. We
    will also assume that the only function we are interested in is to be able to
    read a CSV file line by line, where each read will generate a new dictionary with
    the column names as keys and row names as values.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将被要求构建自己的CSV读取器和解析器。虽然如果我们试图涵盖所有用例和边缘情况，包括转义字符，这是一个大任务，但为了这个简短的活动，我们将保持我们的要求很小。我们将假设没有转义字符——这意味着如果您在行中的任何位置使用逗号，您将开始一个新列。我们还将假设我们唯一感兴趣的功能是能够逐行读取CSV文件，其中每次读取将生成一个新字典，列名作为键，行名作为值。
- en: 'Here is an example:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '![Figure 2.13: Table with sample data'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13：包含示例数据的表格'
- en: '](img/B15780_02_13.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_02_13.jpg)'
- en: 'Figure 2.13: Table with sample data'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：包含示例数据的表格
- en: 'We can convert the data in the preceding table into a Python dictionary, which
    would look as follows: `{"Name": "Bob", "Age": "24", "Location": "California"}`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以将前表中数据转换为Python字典，其外观如下：`{"Name": "Bob", "Age": "24", "Location": "California"}`：'
- en: Import `zip_longest` from `itertools`. Create a function to zip `header`, `line`,
    and `fillvalue=None`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`itertools`导入`zip_longest`。创建一个将`header`、`line`和`fillvalue=None`压缩的函数。
- en: Open the accompanying `sales_record.csv` file from the GitHub link ([https://packt.live/2Yb6iCh](https://packt.live/2Yb6iCh))
    by using `r` mode inside a `with` block and check that it is opened.
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使用`with`块内的`r`模式，从GitHub链接([https://packt.live/2Yb6iCh](https://packt.live/2Yb6iCh))打开附带的`sales_record.csv`文件，并检查它是否已打开。
- en: Read the first line and use string methods to generate a list of all the column names.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取第一行，并使用字符串方法生成所有列名的列表。
- en: Start reading the file. Read it line by line.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始读取文件。逐行读取。
- en: Read each line and pass that line to a function, along with the list of the
    headers. The work of the function is to construct a `dictionary` out of these
    two and fill up the `key:values` variables. Keep in mind that a missing value
    should result in `None`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取每一行，并将该行传递给一个函数，同时附带标题列表。该函数的工作是从这两个列表中构建一个`字典`，并填充`键:值`变量。请记住，缺失的值应导致`None`。
- en: 'The partial output of this should look like this:'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此部分的输出应类似于以下内容：
- en: '![Figure 2.14: Partial output of the sales_record file'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.14：销售记录文件的局部输出'
- en: '](img/B15780_02_14.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15780_02_14.jpg]'
- en: 'Figure 2.14: Partial output of the sales_record file'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14：销售记录文件的局部输出
- en: Note
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15780_Solution_Final_RK.xhtml#_idTextAnchor309).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15780_Solution_Final_RK.xhtml#_idTextAnchor309)找到。
- en: With this, we conclude the chapter.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们结束了本章。
- en: Summary
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered manipulation techniques of advanced data structures such
    as stacks and queues. We then focused on different methods of functional programming,
    including iterators, and combined lists and functions together. Later, we looked
    at OS-level functions and the management of environment variables. We examined
    how, using Python, we can open, close, and even write to local files in a variety
    of ways. Knowing how to deal with files in a clean way is a critical skill in
    a data wrangler's repertoire. Toward the end, we tested our newly learned skills
    by creating our own CSV parser.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了高级数据结构（如栈和队列）的操作技术。然后，我们关注了函数式编程的不同方法，包括迭代器，并将列表和函数结合起来。后来，我们探讨了操作系统级别的函数和环境变量的管理。我们检查了如何使用Python以各种方式打开、关闭甚至写入本地文件。知道如何以干净的方式处理文件是数据整理者技能库中的关键技能。最后，我们通过创建自己的CSV解析器来测试我们新学的技能。
- en: In the next chapter, we will be dealing with the three most important libraries,
    namely `NumPy`, `pandas`, and `matplotlib`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理三个最重要的库，即`NumPy`、`pandas`和`matplotlib`。
