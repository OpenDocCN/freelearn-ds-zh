- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Geometric Problems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何问题
- en: This chapter describes solutions to several problems concerning two-dimensional
    geometry. Geometry is a branch of mathematics concerned with the characteristics
    of points, lines, and other figures (shapes), the interaction between these figures,
    and the transformation of these figures. In this chapter, we’ll focus on the characteristics
    of two-dimensional figures and the interactions between these objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了关于二维几何的若干问题的解决方案。几何学是研究点、线和其他图形（形状）特征的数学分支，关注这些图形之间的相互作用及其变换。在本章中，我们将重点讨论二维图形的特征以及这些对象之间的相互作用。
- en: There are several problems we must overcome when working with geometric objects
    in Python. The biggest hurdle is the problem of representation. Most geometric
    objects occupy a region on the two-dimensional plane and, as such, it is impossible
    to store every point that lies within the region. Instead, we have to find a more
    compact way to represent the region that can be stored as a relatively small number
    of points or other attributes. For example, we might store a selection of points
    along the boundary of an object that we can reconstruct the boundary and the object
    itself from. We also have to reformulate the problems into questions that can
    be answered using representative data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Python 处理几何对象时，我们必须克服几个问题。最大的问题是表示问题。大多数几何对象占据二维平面上的一个区域，因此不可能存储区域内的每个点。相反，我们必须找到一种更紧凑的方式来表示这个区域，这种方式可以存储较少的点数或其他属性。例如，我们可以存储一组沿对象边界的点，通过这些点重建边界和对象本身。我们还必须将问题重新表述为可以通过代表性数据回答的问题。
- en: The second biggest problem is converting purely geometric questions into a form
    that can be understood and solved using software. This can be relatively simple
    – for example, finding the point at which two straight lines intersect is a matter
    of solving a matrix equation – or it can be extremely complex, depending on the
    type of question being asked. A common technique that’s used to solve these problems
    is to represent the figure in question using more simple objects and solve the
    (hopefully) easier problem using each of the simple objects. This should then
    give us an idea of the solution to the original problem.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第二大问题是将纯粹的几何问题转化为能够被软件理解和解决的形式。这可能相对简单——例如，找出两条直线交点的位置只是解一个矩阵方程——或者它可能非常复杂，这取决于所提问题的类型。解决这些问题的常见技巧是使用更简单的对象来表示问题中的图形，然后通过每个简单对象来解决（希望）更容易的问题。这样，我们就能对原始问题的解决方案有一个大致的了解。
- en: We will start by showing you how to visualize two-dimensional shapes using patches,
    and then learn how to determine whether a point is contained within another figure.
    Then, we’ll move on and look at edge detection, triangulation, and finding convex
    hulls. We’ll conclude this chapter by constructing Bezier curves.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从展示如何使用补丁可视化二维图形开始，然后学习如何判断一个点是否包含在另一个图形内。接下来，我们将继续探讨边缘检测、三角剖分和计算凸包。最后，我们将通过构建贝塞尔曲线来结束本章内容。
- en: 'This chapter covers the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下几个解决方案：
- en: Visualizing two-dimensional geometric shapes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化二维几何图形
- en: Finding interior points
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找内部点
- en: Finding edges in an image
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像中寻找边缘
- en: Triangulating planar figures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对平面图形进行三角剖分
- en: Computing convex hulls
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算凸包
- en: Constructing Bezier curves
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建贝塞尔曲线
- en: Let’s get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we will need the NumPy package and the Matplotlib package,
    as usual. We will also need the Shapely package and the `scikit-image` package,
    which can be installed using your favorite package manager, such as `pip`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用 NumPy 包和 Matplotlib 包，和往常一样。我们还需要 Shapely 包和 `scikit-image` 包，它们可以通过你喜欢的包管理工具（如
    `pip`）进行安装：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code for this chapter can be found in the `Chapter 08` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2008](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2008).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 仓库的 `Chapter 08` 文件夹中找到，地址为 [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2008](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2008)。
- en: Visualizing two-dimensional geometric shapes
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化二维几何图形
- en: The focus of this chapter is on two-dimensional geometry, so our first task
    is to learn how to visualize two-dimensional geometric figures. Some of the techniques
    and tools mentioned here might apply to three-dimensional geometric figures, but
    generally, this will require more specialized packages and tools. The first method
    for plotting a region on the plane might be to pick a selection of points around
    the boundary and plot these with the usual tools. However, this is generally going
    to be inefficient. Instead, we’re going to implement Matplotlib patches that make
    use of efficient representations of these figures – in this recipe, the center
    and radius of a circle (disk) – that Matplotlib can fill efficiently on a plot.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是二维几何学，因此我们的第一项任务是学习如何可视化二维几何图形。这里提到的一些技术和工具可能适用于三维几何图形，但通常这需要更专业的包和工具。在平面上绘制区域的第一种方法可能是选择边界周围的一些点，并使用常规工具绘制它们。然而，这通常效率较低。相反，我们将实现使用Matplotlib补丁，这些补丁采用高效的表示方法（例如圆形（圆盘）的圆心和半径），Matplotlib可以高效地将它们填充到图形中。
- en: A **geometric figure**, at least in the context of this book, is any point,
    line, curve, or closed region (including the boundary) whose boundary is a collection
    of lines and curves. Simple examples include points and lines (obviously), rectangles,
    polygons, and circles.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**几何图形**，至少在本书的上下文中，是指任何点、线、曲线或封闭区域（包括边界），其边界是由一组线和曲线组成的。简单的例子包括点和线（显然），矩形、多边形和圆形。'
- en: In this recipe, we will learn how to visualize geometric figures using Matplotlib
    patches.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用Matplotlib补丁可视化几何图形。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need the NumPy package imported as `np`, and the Matplotlib
    `pyplot` module imported as `plt`. We also need to import the `Circle` class from
    the Matplotlib `patches` module and the `PatchCollection` class from the Matplotlib
    `collections` module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，我们需要将NumPy包导入为`np`，将Matplotlib的`pyplot`模块导入为`plt`。我们还需要从Matplotlib的`patches`模块中导入`Circle`类，以及从Matplotlib的`collections`模块中导入`PatchCollection`类。
- en: 'This can be done with the following commands:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下命令完成：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will also need the `swisscheese-grid-10411.csv` data file from the code repository
    for this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要本章代码库中的`swisscheese-grid-10411.csv`数据文件。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The following steps show you to visualize a two-dimensional geometric figure:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何可视化一个二维几何图形：
- en: 'First, we load the data from the `swisscheese-grid-10411.csv` file from this
    book’s code repository:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从本书的代码库中加载`swisscheese-grid-10411.csv`文件的数据：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We create a new patch object that represents a region on a plot. This is going
    to be a circle (disk) with the center at the origin and a radius of `1`. We create
    a new set of axes and add this patch to them:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个新的补丁对象，用于表示图形中的一个区域。这个区域将是一个圆形（圆盘），圆心位于原点，半径为`1`。我们创建了一组新的坐标轴，并将这个补丁添加到坐标轴上：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we create a `PatchCollection` object from the data we loaded in *step
    1*, which contains centers and radii for a number of other circles. We then add
    this `PatchCollection` to the axes we created in *step 2*:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从*步骤1*加载的数据中创建一个`PatchCollection`对象，其中包含多个其他圆形的圆心和半径。然后，我们将这个`PatchCollection`添加到我们在*步骤2*中创建的坐标轴上：
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we set the ![](img/Formula_08_001.png)- and ![](img/Formula_08_002.png)-axis
    ranges so that the whole image is displayed and then turn the axes off:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们设置![](img/Formula_08_001.png)-和![](img/Formula_08_002.png)-轴范围，以便显示整个图像，然后关闭坐标轴：
- en: '[PRE12]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The resulting image is of a *Swiss cheese*, as shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图像是一个*瑞士奶酪*，如图所示：
- en: '![Figure 8.1 – Plot of a Swiss cheese'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 瑞士奶酪的图形]'
- en: '](img/B19085_08_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_08_01.jpg)'
- en: Figure 8.1 – Plot of a Swiss cheese
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 瑞士奶酪的图形
- en: You can see in *Figure 8**.1* that most of the original disk (shaded black)
    has been covered by subsequent disks (shaded white).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.1*中，你可以看到大部分原始的圆盘（黑色阴影部分）已经被后续的圆盘（白色阴影部分）覆盖。
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何运作...
- en: Key to this recipe are the `Circle` and `PatchCollection` objects, which represent
    the regions of the plot area on Matplotlib axes. In this case, we are creating
    one large circular patch, centered at the origin and with a radius of `1`, that
    has a black face color and uses `zorder=0` to place it behind other patches. This
    patch is added to the `Axes` object using the `add_patch` method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的关键是`Circle`和`PatchCollection`对象，它们表示Matplotlib坐标轴上图形区域。在本例中，我们创建了一个以原点为中心、半径为`1`的大圆形补丁，颜色为黑色面，并使用`zorder=0`将其放置在其他补丁的后面。这个补丁通过`add_patch`方法添加到`Axes`对象中。
- en: The next step is to create an object that will render the circles represented
    by the data that we loaded from the CSV file in *step 1*. This data consisted
    of ![](img/Formula_08_003.png), ![](img/Formula_08_004.png), and ![](img/Formula_08_005.png)
    values for the center ![](img/Formula_08_006.png) and the radius, ![](img/Formula_08_007.png),
    of the individual circles (10,411 in total). The `PatchCollection` object combines
    a sequence of patches into a single object that can be added to an `Axes` object.
    Here, we add one `Circle` for each row in our data, which is then added to the
    `Axes` object using the `add_collection` method. Notice that we have applied the
    face color to the whole collection, rather than to each individual `Circle` constituent.
    We set the face color to white (using the `facecolor="w"` argument), the edge
    color to black (using `ec="k"`), the line width (of the edge lines) to 0.2 (using
    `linewidth=0.2`), and the edge style to a continuous line. All of this, when put
    together, results in our image.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个对象，该对象将呈现由我们从CSV文件中加载的数据所表示的圆形，这些数据来自*步骤1*。这些数据包括![](img/Formula_08_003.png)、![](img/Formula_08_004.png)
    和 ![](img/Formula_08_005.png) 这些关于圆心 ![](img/Formula_08_006.png) 和半径 ![](img/Formula_08_007.png)
    的值（总共有10,411个圆）。`PatchCollection`对象将一系列的补丁合并成一个可以添加到`Axes`对象中的单一对象。在这里，我们为数据中的每一行添加一个`Circle`，然后通过`add_collection`方法将其添加到`Axes`对象中。请注意，我们将面颜色应用于整个集合，而不是每个单独的`Circle`元素。我们将面颜色设置为白色（使用`facecolor="w"`参数），边缘颜色设置为黑色（使用`ec="k"`），边缘线宽设置为0.2（使用`linewidth=0.2`），并且边缘样式设置为连续线条。将这些设置结合在一起，最终就得到了我们的图像。
- en: The image that we have created here is called a *Swiss cheese*. It was first
    used in rational approximation theory in 1938 by Alice Roth; it was subsequently
    rediscovered, and similar constructions have been used many times since. We used
    this example because it consists of one large individual part, plus a large collection
    of smaller individual parts. Roth’s Swiss cheese is an example of a set in the
    plane that has a positive area but no topological interior. This means that we
    cannot find any disk of positive radius that is wholly contained within the set
    (it is amazing that such a set can even exist!). More importantly, there are continuous
    functions defined on this Swiss cheese that cannot be uniformly approximated by
    rational functions. This property has made similar constructions useful in the
    theory of *uniform algebras*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建的图像被称为*瑞士奶酪*。它最早在1938年由Alice Roth在有理逼近理论中使用，随后被重新发现，类似的构造方法自此被多次使用。我们使用这个例子是因为它由一个大的单独部分和一大堆小的单独部分组成。Roth的瑞士奶酪是一个平面集合的例子，具有正的面积但没有拓扑内部。这意味着我们无法找到任何正半径的圆盘，完全包含在该集合内（真令人惊讶，竟然有这样的集合存在！）。更重要的是，定义在这个瑞士奶酪上的连续函数，无法通过有理函数进行一致逼近。这个特性使得类似的构造在*一致代数*理论中变得非常有用。
- en: The `Circle` class is a subclass of the more general `Patch` class. There are
    numerous other `Patch` classes that represent different planar figures, such as
    `Polygon` and `PathPatch`, which represent the region bounded by a path (curve
    or collection of curves). These can be used to generate complex patches that can
    be rendered in a Matplotlib figure. Collections can be used to apply settings
    to a number of patch objects simultaneously, which can be especially useful if,
    as in this recipe, you have a large number of objects that will all be rendered
    in the same style.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle`类是更通用的`Patch`类的子类。还有许多其他`Patch`类，表示不同的平面图形，比如`Polygon`和`PathPatch`，它们表示由路径（曲线或曲线集合）所围成的区域。这些可以用来生成复杂的补丁，并可以在Matplotlib图形中呈现。集合可以用来同时应用设置到多个补丁对象，尤其是在这个例子中，当你有大量对象需要以相同风格渲染时，这非常有用。'
- en: There’s more...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: There are many different patch types available in Matplotlib. In this recipe,
    we used the `Circle` patch class, which represents a circular region on the axes.
    There is also the `Polygon` patch class, which represents a polygon (regular or
    otherwise). There are also `PatchPath` objects, which are regions that are surrounded
    by a curve that does not necessarily consist of straight-line segments. This is
    similar to the way a shaded region can be constructed in many vector graphics
    software packages.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Matplotlib中有许多不同类型的补丁可用。在这个例子中，我们使用了`Circle`补丁类，它表示坐标轴上的圆形区域。还有`Polygon`补丁类，它表示一个多边形（可以是规则多边形，也可以是其他形状）。此外，还有`PatchPath`对象，它表示由曲线围成的区域，曲线不一定是由直线段组成的。这与许多矢量图形软件中构造阴影区域的方式类似。
- en: In addition to the single patch types in Matplotlib, there are a number of collection
    types that gather a number of patches together to be used as a single object.
    In this recipe, we used the `PatchCollection` class to gather a large number of
    `Circle` patches. There are more specialized patch collections that can be used
    to generate these internal patches automatically, rather than us generating them
    ourselves.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Matplotlib 中的单一补丁类型外，还有一些集合类型，它们将多个补丁聚集在一起，作为一个单一对象使用。在本食谱中，我们使用了 `PatchCollection`
    类来聚集大量的 `Circle` 补丁。还有一些更专业的补丁集合，可以自动生成这些内部补丁，而不是我们自己手动生成它们。
- en: See also
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'A more detailed history of Swiss cheeses in mathematics can be found in the
    following biographical article: Daepp, U., Gauthier, P., Gorkin, P., and Schmieder,
    G., 2005\. *Alice in Switzerland: The life and mathematics of Alice Roth*. *The
    Mathematical Intelligencer*, 27(1), pp. 41-54.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于瑞士奶酪在数学中的更详细历史，可以参考以下传记文章：Daepp, U., Gauthier, P., Gorkin, P., 和 Schmieder,
    G., 2005\. *爱丽丝在瑞士：爱丽丝·罗斯的生活与数学*。 *数学智能者*，27(1)，第41-54页。
- en: Finding interior points
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找内点
- en: One problem with working with two-dimensional figures in a programming environment
    is that you can’t possibly store all the points that lie within the figure. Instead,
    we usually store far fewer points that represent the figure in some way. In most
    cases, this will be a number of points (connected by lines) that describe the
    boundary of the figure. This is efficient in terms of memory and makes it easy
    to visualize them on screen using Matplotlib patches, for example. However, this
    approach makes it more difficult to determine whether a point or another figure
    lies within a given figure. This is a crucial question in many geometric problems.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程环境中处理二维图形的一个问题是，无法存储图形内部的所有点。相反，我们通常只存储少量点，这些点以某种方式表示该图形。在大多数情况下，这些点是由线条连接的，描述了图形的边界。这种方法在内存上更为高效，并且使得我们能够方便地通过
    Matplotlib 补丁等工具将图形可视化。然而，这种方法使得确定一个点或另一个图形是否位于给定图形内部变得更加困难。这在许多几何问题中是一个至关重要的问题。
- en: In this recipe, we will learn how to represent geometric figures and determine
    whether a point lies within a figure or not.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何表示几何图形，并确定一个点是否位于图形内部。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need to import the `matplotlib` package (as a whole)
    as `mpl` and the `pyplot` module as `plt`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将需要导入整个 `matplotlib` 包，并将其命名为 `mpl`，以及将 `pyplot` 模块导入为 `plt`：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We also need to import the `Point` and `Polygon` objects from the `geometry`
    module of the Shapely package. The Shapely package contains many routines and
    objects for representing, manipulating, and analyzing two-dimensional geometric
    figures:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从 Shapely 包的 `geometry` 模块导入 `Point` 和 `Polygon` 对象。Shapely 包包含许多用于表示、操作和分析二维几何图形的例程和对象：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These two classes will be used to represent our two-dimensional geometric figures.
    Let’s see how to use these classes to see whether a polygon contains a point or
    not.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类将用于表示我们的二维几何图形。让我们看看如何使用这些类来判断一个多边形是否包含一个点。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The following steps show you how to create a Shapely representation of a polygon
    and then test whether a point lies within this polygon:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何创建一个 Shapely 表示的多边形，并测试一个点是否位于该多边形内：
- en: 'Create a sample polygon to test:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个示例多边形进行测试：
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we plot the polygon onto a new figure. First, we need to convert the
    polygon into a Matplotlib `Polygon` patch that can be added to the figure:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将多边形绘制到一个新图形中。首先，我们需要将多边形转换为一个 Matplotlib `Polygon` 补丁，以便将其添加到图形中：
- en: '[PRE20]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we need to create two test points, one of which will be inside the polygon
    and one of which will be outside the polygon:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建两个测试点，其中一个点将在多边形内，另一个点将在多边形外：
- en: '[PRE27]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We plot and annotate these two points on top of the polygon to show their positions:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在多边形上绘制并标注这两个点，以显示它们的位置：
- en: '[PRE29]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we test where each point lies within the polygon using the `contains`
    method, and then print the result to the Terminal:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `contains` 方法测试每个点是否位于多边形内，然后将结果打印到终端：
- en: '[PRE33]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The results show that the first point, `p1`, is contained in the polygon, while
    the second point, `p2`, is not. This can also be seen in the following figure,
    which clearly shows that one point is contained within the shaded polygon, while
    the other point is not:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，第一个点 `p1` 位于多边形内，而第二个点 `p2` 不在其中。通过下图也可以看到这一点，图中清楚地显示一个点位于阴影多边形内，而另一个点则不在其中：
- en: '![Figure 8.2 – Points inside and outside a polygonal region'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 多边形区域内外的点'
- en: '](img/B19085_08_02.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_08_02.jpg)'
- en: Figure 8.2 – Points inside and outside a polygonal region
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 多边形区域内外的点
- en: Once we plot the points and the polygon it is easy (for us) to see that `contains`
    method on the `polygon` object correctly classifies the points too.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们绘制出点和多边形，就很容易（对我们来说）看到`polygon`对象上的`contains`方法也能正确分类这些点。
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Shapely `Polygon` class is a representation of a polygon that stores its
    vertices as points. The region enclosed by the outer boundary – the five straight
    lines between the stored vertices – is obvious to us and easily identified by
    the eye, but the notion of being *inside* the boundary is difficult to define
    in a way that can be easily understood by a computer. It is not even straightforward
    to give a formal mathematical definition of what it means to lie *within* a given
    curve.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely的`Polygon`类是多边形的表示，它将顶点存储为点。由外边界围成的区域——存储顶点之间的五条直线——对我们来说是显而易见的，眼睛很容易识别出来，但“在边界内”的概念很难以一种计算机容易理解的方式定义。甚至给出“位于给定曲线内”这一概念的正式数学定义也不是一件简单的事情。
- en: There are two main ways to determine whether a point lies within a simple closed
    curve – that is, a curve that starts and ends at the same place that does not
    contain any self-intersections. The first uses a mathematical concept called the
    `contains` method of a polygon does (under the hood, Shapely uses the GEOS library
    to perform this calculation).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要方法可以确定一个点是否位于一个简单的封闭曲线内——即一个从同一点开始并结束的曲线，且不包含自交点。第一种方法使用一个数学概念，即多边形的`contains`方法（Shapely内部使用GEOS库来执行此计算）。
- en: The Shapely `Polygon` class can be used to compute many quantities associated
    with these planar figures, including perimeter length and area. The `contains`
    method is used to determine whether a point, or a collection of points, lies within
    the polygon represented by the object (there are some limitations regarding the
    kinds of polygons that can be represented by this class). In fact, you can use
    the same method to determine whether one polygon is contained within another since,
    as we have seen in this recipe, a polygon is represented by a simple collection
    of points.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely的`Polygon`类可以用来计算与这些平面图形相关的许多量，包括周长和面积。`contains`方法用于确定一个点或一组点是否位于由对象表示的多边形内（该类表示的多边形类型有一些限制）。实际上，你可以使用相同的方法来判断一个多边形是否包含在另一个多边形内，因为，正如我们在本例中看到的，一个多边形由一组简单的点组成。
- en: Finding edges in an image
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图像中寻找边缘
- en: Finding edges in images is a good way of reducing a complex image that contains
    a lot of noise and distractions to a very simple image containing the most prominent
    outlines. This can be useful as our first step of the analysis process, such as
    in image classification, or as the process of importing line outlines into computer
    graphics software packages.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像中寻找边缘是一种将包含大量噪声和干扰的复杂图像简化为仅包含最显著轮廓的简单图像的好方法。这在分析过程中的第一步非常有用，比如在图像分类中，或者在将线条轮廓导入计算机图形软件包时。
- en: In this recipe, we will learn how to use the `scikit-image` package and the
    Canny algorithm to find the edges in a complex image.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用`scikit-image`包和Canny算法在复杂图像中找到边缘。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need to import the Matplotlib `pyplot` module as `plt`,
    the `imread` routine from the `skimage.io` module, and the `canny` routine from
    the `skimage.feature` module:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，我们需要导入Matplotlib的`pyplot`模块（命名为`plt`），从`skimage.io`模块导入`imread`例程，以及从`skimage.feature`模块导入`canny`例程：
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `canny` routine implements the edge detection algorithm. Let’s see how to
    use it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`canny`例程实现了边缘检测算法。让我们看看如何使用它。'
- en: How to do it…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to learn how to use the `scikit-image` package to find edges
    in an image:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤，学习如何使用`scikit-image`包在图像中找到边缘：
- en: 'Load the image data from the source file. This can be found in the GitHub repository
    for this chapter. Crucially, we pass in `as_gray=True` to load the image in grayscale:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从源文件加载图像数据。这可以在本章的GitHub仓库中找到。关键的是，我们传入`as_gray=True`以将图像加载为灰度图：
- en: '[PRE37]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following is the original image, for reference. The set itself is shown
    by the white region and, as you can see, the boundary, indicated by the darker
    shades, is very complex:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是原始图像，供参考。集合本身由白色区域表示，正如你所看到的，边界由较暗的阴影表示，非常复杂：
- en: '![Figure 8.3 – Plot of the Mandelbrot set generated using Python'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 使用 Python 生成的曼德尔布罗集合图'
- en: '](img/B19085_08_03.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_08_03.jpg)'
- en: Figure 8.3 – Plot of the Mandelbrot set generated using Python
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 使用 Python 生成的曼德尔布罗集合图
- en: 'Next, we use the `canny` routine, which needs to be imported from the `features`
    module of the `scikit-image` package. The `sigma` value is set to `0.5` for this
    image:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`canny`例程，它需要从`scikit-image`包的`features`模块中导入。对于此图像，`sigma`值设置为`0.5`：
- en: '[PRE38]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we add the `edges` image to a new figure with a grayscale (reversed)
    color map:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`edges`图像添加到一个新图形中，并使用灰度（反向）颜色映射：
- en: '[PRE39]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The edges that have been detected can be seen in the following image. The edge-finding
    algorithm has identified most of the visible details of the boundary of the Mandelbrot
    set, although it is not perfect (this is an estimate, after all):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 检测到的边缘可以在下图中看到。边缘查找算法已经识别出了曼德尔布罗集合边界的大部分可见细节，尽管它并不完美（毕竟这只是一个估计）。
- en: '![Figure 8.4 – The edges of the Mandelbrot set found using the scikit-image
    package’s Canny edge detection algorithm](img/B19085_08_04.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 使用 scikit-image 包的 Canny 边缘检测算法找到的曼德尔布罗集合的边缘](img/B19085_08_04.jpg)'
- en: Figure 8.4 – The edges of the Mandelbrot set found using the scikit-image package’s
    Canny edge detection algorithm
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 使用 scikit-image 包的 Canny 边缘检测算法找到的曼德尔布罗集合的边缘
- en: We can see that the edge detection has identified a good amount of the complexity
    of the edge of the Mandelbrot set. Of course, the boundary of the *true* Mandelbrot
    set is a fractal and has infinite complexity.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，边缘检测成功识别出了曼德尔布罗集合边缘的复杂性。当然，*真实*曼德尔布罗集合的边界是一个分形，具有无限的复杂性。
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `scikit-image` package provides various utilities and types for manipulating
    and analyzing data derived from images. As the name suggests, the `canny` routine
    uses the Canny edge detection algorithm to find edges in an image. This algorithm
    uses the intensity gradients in the image to detect edges, where the gradient
    is larger. It also performs some filtering to reduce the noise in the edges it
    finds.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-image`包提供了各种工具和类型，用于操作和分析源自图像的数据。顾名思义，`canny`例程使用 Canny 边缘检测算法来检测图像中的边缘。该算法通过图像中的强度梯度来检测边缘，梯度较大的地方即为边缘。它还执行一些滤波操作，以减少在检测到的边缘中出现的噪声。'
- en: The `sigma` keyword value we provided is the standard deviation of the Gaussian
    smoothing that’s applied to the image prior to calculating the gradients for edge
    detection. This helps us remove some of the noise from the image. The value we
    set (`0.5`) is smaller than the default (`1`), but it does give us a better resolution
    in this case. A large value would obscure some of the finer details in the boundary
    of the Mandelbrot set.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的`sigma`关键字值是应用于图像的高斯平滑的标准差，该平滑操作在计算边缘检测的梯度之前进行。这有助于我们去除图像中的一些噪声。我们设置的值（`0.5`）比默认值（`1`）小，但在这种情况下能给我们更好的分辨率。如果值过大，则会掩盖曼德尔布罗集合边界中一些细节。
- en: Triangulating planar figures
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三角剖分平面图形
- en: As we saw in [*Chapter 3*](B19085_03.xhtml#_idTextAnchor078), *Calculus and
    Differential Equations*, we often need to break down a continuous region into
    smaller, simpler regions. In earlier recipes, we reduced an interval of real numbers
    into a collection of smaller intervals, each with a small length. This process
    is usually called **discretization**. In this chapter, we are working with two-dimensional
    figures, so we need a two-dimensional version of this process. For this, we’ll
    break a two-dimensional figure (in this recipe, a polygon) into a collection of
    smaller and simpler polygons. The simplest of all polygons are triangles, so this
    is a good place to start for two-dimensional discretization. The process of finding
    a collection of triangles that *tiles* a geometric figure is called **triangulation**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第 3 章*](B19085_03.xhtml#_idTextAnchor078)《微积分与微分方程》中看到的那样，我们通常需要将一个连续区域拆分成更小、更简单的区域。在早期的配方中，我们将一个实数区间拆分成一组较小的区间，每个区间都有一个较小的长度。这个过程通常称为**离散化**。在本章中，我们处理的是二维图形，因此我们需要这个过程的二维版本。为此，我们将一个二维图形（在本例中是多边形）拆分成一组更小、更简单的多边形。所有多边形中最简单的是三角形，所以这是进行二维离散化的一个很好的起点。寻找一个可以“平铺”几何图形的三角形集合的过程称为**三角剖分**。
- en: In this recipe, we will learn how to triangulate a polygon (with a hole) using
    the Shapely package.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将学习如何使用 Shapely 包对带孔的多边形进行三角剖分。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'For this recipe, we will need the NumPy package imported as `np`, the Matplotlib
    package imported as `mpl`, and the `pyplot` module imported as `plt`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们需要导入 NumPy 包并命名为 `np`，导入 Matplotlib 包并命名为 `mpl`，以及导入 `pyplot` 模块并命名为
    `plt`：
- en: '[PRE42]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We also need the following items from the Shapely package:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从 Shapely 包中使用以下内容：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let’s see how to use the `triangulate` routine to triangulate a polygon.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `triangulate` 例程对一个多边形进行三角剖分。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps show you how to triangulate a polygon with a hole using
    the Shapely package:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何使用 Shapely 包对带孔的多边形进行三角剖分：
- en: 'First, we need to create a `Polygon` object that represents the figure that
    we wish to triangulate:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个表示我们希望进行三角剖分的图形的 `Polygon` 对象：
- en: '[PRE44]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we should plot the figure so that we can understand the region that we
    will be working within:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该绘制图形，以便了解我们将要处理的区域：
- en: '[PRE51]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This polygon can be seen in the following image. As we can see, the figure
    has a *hole* in it that must be carefully considered:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个多边形可以在下图中看到。正如我们所见，图形中有一个 *孔*，需要特别注意：
- en: '![Figure 8.5 – Sample polygon but with a hole'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 带孔的样本多边形'
- en: '](img/B19085_08_05.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_08_05.jpg)'
- en: Figure 8.5 – Sample polygon but with a hole
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 带孔的样本多边形
- en: 'We use the `triangulate` routine to generate a triangulation of the polygon.
    This triangulation includes external edges, which is something we don’t want in
    this recipe:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `triangulate` 例程生成多边形的三角剖分。这个三角剖分包括外部边，而这是我们在这个例子中不希望出现的：
- en: '[PRE60]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To remove the triangles that lie outside the original polygon, we need to use
    the built-in `filter` routine, along with the `contains` method (seen earlier
    in this chapter):'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了去除位于原始多边形外部的三角形，我们需要使用内置的 `filter` 例程，并结合使用 `contains` 方法（在本章前面已经提到过）：
- en: '[PRE61]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To plot the triangles on top of the original polygon, we need to convert the
    Shapely triangles into Matplotlib `Patch` objects, which we store in a `PatchCollection`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将三角形绘制到原始多边形上，我们需要将 Shapely 三角形转换为 Matplotlib `Patch` 对象，并将其存储在一个 `PatchCollection`
    中：
- en: '[PRE63]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, we add the collection of triangular patches to the figure we created
    earlier:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将三角形补丁集合添加到之前创建的图形中：
- en: '[PRE67]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The triangulation that’s been plotted on top of the original polygon can be
    seen in the following figure. Here, we can see that every vertex has been connected
    to two others to form a system of triangles that covers the entire original polygon:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中可以看到已绘制在原始多边形上的三角剖分。这里，我们可以看到每个顶点都与其他两个顶点连接，形成了一个覆盖整个原始多边形的三角形系统：
- en: '![Figure 8.6 – Triangulation of a sample polygon with a hole'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 带孔样本多边形的三角剖分'
- en: '](img/B19085_08_06.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_08_06.jpg)'
- en: Figure 8.6 – Triangulation of a sample polygon with a hole
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 带孔样本多边形的三角剖分
- en: The internal lines between the vertices of the original polygon in *Figure 8**.6*
    divide the polygon into 15 triangles.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 8.6* 中，原始多边形的顶点之间的内部线条将多边形分割成 15 个三角形。
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `triangulate` routine uses a technique called **Delaunay triangulation**
    to connect a collection of points to a system of triangles. In this case, the
    collection of points is the vertices of the polygon. The Delaunay method finds
    these triangles in such a way that none of the points are contained within the
    circumcircle of any of the triangles. This is a technical condition of the method,
    but it means that the triangles are chosen efficiently, in the sense that it avoids
    very long, thin triangles. The resulting triangulation makes use of the edges
    that are present in the original polygon and also connects some of the external
    edges.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`triangulate` 例程使用一种叫做 **德劳内三角剖分** 的技术，将一组点连接成一个三角形系统。在这个例子中，点集是多边形的顶点。德劳内方法以一种方式找到这些三角形，使得没有任何一个点位于任何一个三角形的外接圆内。这是该方法的一个技术性条件，但它意味着三角形的选择是高效的，因为它避免了非常长且细的三角形。最终的三角剖分利用了原始多边形中的边，并且还连接了一些外部边。'
- en: In order to remove the triangles that lie outside of the original polygon, we
    use the built-in `filter` routine, which creates a new iterable by removing the
    items that the criterion function falls under. This is used in conjunction with
    the `contains` method on Shapely `Polygon` objects to determine whether each triangle
    lies within the original figure. As we mentioned previously, we need to convert
    these Shapely items into Matplotlib patches before they can be added to the plot.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了去除位于原多边形外部的三角形，我们使用内置的`filter`例程，它通过移除符合标准函数的项目来创建一个新的可迭代对象。这个方法与Shapely `Polygon`对象上的`contains`方法结合使用，以确定每个三角形是否位于原始图形内部。正如我们之前提到的，在将这些Shapely对象添加到图表中之前，我们需要将它们转换为Matplotlib补丁。
- en: There’s more...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Triangulations are usually used to reduce a complex geometric figure into a
    collection of triangles, which are much simpler for computational tasks. However,
    they do have other uses. One particularly interesting application of triangulations
    is to solve the *art gallery problem*. This problem concerns finding the maximum
    number of guards that are necessary to *guard* an art gallery of a particular
    shape. Triangulations are an essential part of Fisk’s simple proof of the art
    gallery theorem, which was originally proved by Chvátal.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 三角剖分通常用于将复杂的几何图形简化为一组三角形，这对于计算任务来说要简单得多。然而，它们也有其他用途。三角剖分的一个特别有趣的应用是解决*艺术画廊问题*。这个问题涉及找到必要的最大守卫数，以*守卫*一个特定形状的艺术画廊。三角剖分是Fisk简单证明艺术画廊定理的关键部分，该定理最初由Chvátal证明。
- en: 'Suppose that the polygon from this recipe is the floor plan for an art gallery
    and that some guards need to be placed on the vertices. A small amount of work
    will show that you’ll need three guards to be placed at the polygon’s vertices
    for the whole museum to be covered. In the following image, we have plotted one
    possible arrangement:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个教程中的多边形是一个艺术画廊的平面图，并且需要在顶点放置一些守卫。通过少量工作可以发现，你需要在多边形的顶点放置三个守卫，以便完全覆盖整个博物馆。在以下图像中，我们绘制了一种可能的布局：
- en: '![Figure 8.7 – One possible solution to the art gallery problem where guards
    are placed on vertices'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7 – 一种可能的艺术画廊问题解决方案，其中守卫被安置在顶点'
- en: '](img/B19085_08_07.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_08_07.jpg)'
- en: Figure 8.7 – One possible solution to the art gallery problem where guards are
    placed on vertices
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 一种可能的艺术画廊问题解决方案，其中守卫被安置在顶点
- en: In *Figure 8**.7* here, the guards are indicated by the **X** symbols and their
    corresponding fields of vision are shaded. Here, you can see that the whole polygon
    is covered by at least one color. The solution to the art gallery problem – which
    is a variation of the original problem – tells us that we need, at most, four
    guards.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 8.7*中，守卫通过**X**符号表示，并且它们对应的视野区域被阴影填充。这里，你可以看到整个多边形被至少一种颜色覆盖。这个变种的艺术画廊问题的解决方案告诉我们，我们最多需要四个守卫。
- en: See also
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'More information about the art gallery problem can be found in the classic
    book by O’Rourke: O’Rourke, J. (1987). *Art gallery theorems and algorithms*.
    New York: Oxford University Press.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有关艺术画廊问题的更多信息，可以参阅O'Rourke的经典著作：O’Rourke, J. (1987). *艺术画廊定理与算法*。纽约：牛津大学出版社。
- en: Computing convex hulls
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算凸包
- en: A geometric figure is said to be *convex* if every pair of points within the
    figure can be joined using a straight line that is also contained within the figure.
    Simple examples of convex bodies include points, straight lines, squares, circles
    (disks), regular polygons, and so on. The geometric figure shown in *Figure 8**.5*
    is not convex since the points on the opposite sides of the hole cannot be connected
    by a straight line that remains inside the figure.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果几何图形中的任意一对点可以通过一条直线连接，且该直线也完全位于图形内部，则该几何图形被称为*凸*的。凸体的简单例子包括点、直线、正方形、圆（圆盘）、正多边形等。*图
    8.5*中所示的几何图形不是凸的，因为孔的对侧点无法通过一条直线连接，且该直线保持在图形内部。
- en: Convex figures are simple from a certain perspective, which means they are useful
    in a variety of applications. One problem involves finding the smallest convex
    set that contains a collection of points. This smallest convex set is called the
    *convex hull* of the set of points.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种角度来看，凸图形比较简单，这意味着它们在多种应用中都非常有用。一个问题是找到包含一组点的最小凸集。这个最小的凸集被称为该点集的*凸包*。
- en: In this recipe, we’ll learn how to find the convex hull of a set of points using
    the Shapely package.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何使用Shapely包找到一组点的凸包。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy package imported as `np`, the Matplotlib
    package imported as `mpl`, and the `pyplot` module imported as `plt`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，我们将需要导入为`np`的NumPy包，导入为`mpl`的Matplotlib包，以及导入为`plt`的`pyplot`模块：
- en: '[PRE68]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We will also need a default random number generator from NumPy. We can import
    this as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要NumPy的默认随机数生成器，可以按如下方式导入：
- en: '[PRE69]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, we will need to import the `MultiPoint` class from Shapely:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要从Shapely导入`MultiPoint`类：
- en: '[PRE70]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Follow these steps to find the convex hull of a collection of randomly generated
    points:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤查找随机生成的点的凸包：
- en: 'First, we generate a two-dimensional array of random numbers:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们生成一个二维的随机数数组：
- en: '[PRE71]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, we create a new figure and plot these raw sample points on this figure:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新图形，并将这些原始样本点绘制在这个图形中：
- en: '[PRE72]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'These randomly generated points can be seen in the following figure. The points
    are roughly spread over a square region:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些随机生成的点可以在下图中看到。点大致分布在一个方形区域内：
- en: '![Figure 8.8 – A collection of points on the plane'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.8 – 平面上一组点'
- en: '](img/B19085_08_08.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_08_08.jpg)'
- en: Figure 8.8 – A collection of points on the plane
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 平面上一组点
- en: 'Next, we construct a `MultiPoint` object that collects all these points and
    put them into a single object:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们构建一个`MultiPoint`对象，将所有这些点收集到一个单独的对象中：
- en: '[PRE75]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, we get the convex hull of this `MultiPoint` object using the `convex_hull`
    attribute:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过`convex_hull`属性获取这个`MultiPoint`对象的凸包：
- en: '[PRE76]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then, we create a Matplotlib `Polygon` patch that can be plotted onto our figure
    to show the result of finding the convex hull:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个Matplotlib `Polygon`补丁，可以将其绘制到图形上，以展示找到凸包的结果：
- en: '[PRE77]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Finally, we add the `Polygon` patch to the figure to show the convex hull:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`Polygon`补丁添加到图形中，以展示凸包：
- en: '[PRE80]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The convex hull of the randomly generated points can be seen in the following
    figure:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 随机生成点的凸包可以在下图中看到：
- en: '![Figure 8.9 – The convex hull of a collection of points on the plane'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.9 – 平面上一组点的凸包'
- en: '](img/B19085_08_09.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_08_09.jpg)'
- en: Figure 8.9 – The convex hull of a collection of points on the plane
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 平面上一组点的凸包
- en: The polygon shown in *Figure 8**.9* has vertices selected from the original
    points and all the other points lie within the shaded region.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.9* 中的多边形具有从原始点中选择的顶点，所有其他点都位于阴影区域内。'
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The Shapely package is a Python wrapper around the GEOS library for geometric
    analysis. The `convex_hull` attribute of Shapely geometric objects calls the convex
    hull computation routine from the GEOS library, resulting in a new Shapely object.
    From this recipe, we can see that the convex hull of the collection of points
    is a polygon with vertices at the points that are farthest away from the *center*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely包是一个用于几何分析的Python封装库，基于GEOS库。Shapely几何对象的`convex_hull`属性调用GEOS库中的凸包计算函数，结果是一个新的Shapely对象。从本示例可以看出，这些点的凸包是一个多边形，顶点位于距离*中心*最远的点上。
- en: Constructing Bezier curves
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建贝塞尔曲线
- en: '*Bezier curves*, or *B-splines*, are a family of curves that are extremely
    useful in vector graphics – for instance, they are commonly used in high-quality
    font packages. This is because they are defined by a small number of points that
    can then be used to inexpensively calculate a large number of points along the
    curve. This allows detail to be scaled according to the needs of the user.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*贝塞尔曲线*，或*B样条*，是一类在矢量图形中非常有用的曲线——例如，它们常用于高质量的字体包。这是因为它们由少数几个点定义，然后可以使用这些点来廉价地计算曲线上的大量点。这使得可以根据用户的需求来调整细节的规模。'
- en: In this recipe, we’ll learn how to create a simple class representing a Bezier
    curve and compute a number of points along it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何创建一个简单的类，表示贝塞尔曲线，并计算曲线上的多个点。
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will use the NumPy package imported as `np`, the Matplotlib
    `pyplot` module imported as `plt`, and the `comb` routine from the Python Standard
    Library `math` module, imported under the `binom` alias:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用导入为`np`的NumPy包，导入为`plt`的Matplotlib `pyplot`模块，以及从Python标准库`math`模块导入的`comb`函数，别名为`binom`：
- en: '[PRE81]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: How to do it...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Follow these steps to define a class that represents a Bezier curve that can
    be used to compute points along the curve:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤定义一个类，表示一个贝塞尔曲线，该曲线可用于计算曲线上的点：
- en: 'The first step is to set up the basic class. We need to provide the control
    points (nodes) and some associated numbers to instance attributes:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是设置基本类。我们需要提供控制点（节点）和一些相关数字作为实例属性：
- en: '[PRE82]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Still inside the `__init__` method, we generate the coefficients for the Bezier
    curve and store them in a list on an instance attribute:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`__init__`方法中，我们生成贝塞尔曲线的系数，并将它们存储在实例属性中的列表里：
- en: '[PRE87]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, we define a `__call__` method to make the class callable. We load the
    number of nodes from the instance into a local variable for clarity:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`__call__`方法，使得这个类可以被调用。我们将实例中的节点数量加载到本地变量中以便清晰：
- en: '[PRE89]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, we reshape the input array so that it contains a single row:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将输入数组重新调整形状，使其包含一行：
- en: '[PRE91]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, we generate a list of arrays of values using each of the coefficients
    in the `coeffs` attribute for the instance:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用实例中的`coeffs`属性中的每个系数生成一个值数组列表：
- en: '[PRE92]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Finally, we sum all the arrays that were constructed in *step 5* and return
    the resulting array:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将*第 5 步*中构造的所有数组相加，并返回结果数组：
- en: '[PRE94]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, we will test our class using an example. We’ll define four control points
    for this example:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用一个示例来测试我们的类。我们将为这个示例定义四个控制点：
- en: '[PRE95]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Next, we set up a new figure for plotting, and plot the control points with
    a dashed connecting line:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置一个新的绘图图形，并使用虚线连接的方式绘制控制点：
- en: '[PRE99]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Then, we create a new instance of our `Bezier` class using the four points
    we defined in *step 7*:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用在*第 7 步*中定义的四个点创建一个新的`Bezier`类实例：
- en: '[PRE104]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We can now create an array of equally spaced points between 0 and 1 using `linspace`
    and compute the points along the Bezier curve:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用`linspace`创建一个从 0 到 1 均匀间隔的点数组，并计算贝塞尔曲线上的点：
- en: '[PRE105]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Finally, we plot this curve on top of the control points that we plotted earlier:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在之前绘制的控制点上绘制这条曲线：
- en: '[PRE107]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The Bezier curve that we’ve plotted can be seen in the following diagram. As
    you can see, the curve starts at the first point (**0**, **0**) and finishes at
    the final point (**1**, **3**):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制的贝塞尔曲线可以在下面的图中看到。如你所见，曲线从第一个点（**0**, **0**）开始，到最终点（**1**, **3**）结束：
- en: '![Figure 8.10 – Bezier curve of degree 3 constructed using four nodes'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.10 – 使用四个节点构造的三次贝塞尔曲线'
- en: '](img/B19085_08_10.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_08_10.jpg)'
- en: Figure 8.10 – Bezier curve of degree 3 constructed using four nodes
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 使用四个节点构造的三次贝塞尔曲线
- en: The Bezier curve in *Figure 8**.10* is tangent to the vertical lines at the
    endpoints and smoothly connects these points. Notice that we only have to store
    the four control points in order to reconstruct this curve with arbitrary accuracy;
    this makes Bezier curves very efficient to store.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.10*中的贝塞尔曲线在端点处与垂直线相切，并平滑地连接这些点。注意，我们只需要存储四个控制点，就能以任意精度重新构建这条曲线；这使得贝塞尔曲线在存储上非常高效。'
- en: How it works...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A Bezier curve is described by a sequence of control points, from which we
    construct the curve recursively. A Bezier curve with one point is a constant curve
    that stays at that point. A Bezier curve with two control points is a line segment
    between those two points:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塞尔曲线由一系列控制点描述，我们通过递归构造曲线。一个只有一个点的贝塞尔曲线是一个常数曲线，始终保持在该点。两个控制点的贝塞尔曲线是这两点之间的线段：
- en: '![](img/Formula_08_008.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_08_008.png)'
- en: 'When we add a third control point, we take the line segment between the corresponding
    points on the Bezier curve of curves that are constructed with one less point.
    This means that we construct the Bezier curve with three control points using
    the following formula:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加第三个控制点时，我们取贝塞尔曲线上对应点之间的线段，这些曲线是通过少一个点的贝塞尔曲线构造的。这意味着我们使用以下公式构造一个有三个控制点的贝塞尔曲线：
- en: '![](img/Formula_08_009.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_08_009.png)'
- en: 'This construction can be seen in the following diagram:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造过程可以在下图中看到：
- en: '![Figure 8.11 – Construction of a quadratic Bezier curve using a recursive
    definition (the two linear Bezier curves are shown by the dashed lines)](img/B19085_08_11.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.11 – 使用递归定义构造二次贝塞尔曲线（两条线性贝塞尔曲线由虚线表示）](img/B19085_08_11.jpg)'
- en: Figure 8.11 – Construction of a quadratic Bezier curve using a recursive definition
    (the two linear Bezier curves are shown by the dashed lines)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 使用递归定义构造二次贝塞尔曲线（两条线性贝塞尔曲线由虚线表示）
- en: 'The construction continues in this manner to define the Bezier curve on any
    number of control points. Fortunately, we don’t need to work with this recursive
    definition in practice because we can flatten the formulae into a single formula
    for the curve, which is given by the following formula:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构建过程继续进行，以定义任意数量控制点的贝塞尔曲线。幸运的是，在实际操作中，我们不需要处理这个递归定义，因为我们可以将公式简化为一个单一的曲线公式，公式如下：
- en: '![](img/Formula_08_010.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_08_010.jpg)'
- en: 'Here, the ![](img/Formula_08_011.png) elements are the control points, ![](img/Formula_08_012.png)
    is a parameter, and each term involves the binomial coefficient:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，！[](img/Formula_08_011.png)元素是控制点，！[](img/Formula_08_012.png)是一个参数，每一项都涉及二项式系数：
- en: '![](img/Formula_08_013.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_08_013.png)'
- en: 'Remember that the ![](img/Formula_08_014.png) parameter is the quantity that
    is changing to generate the points of the curve. We can isolate the terms in the
    previous sum that involve ![](img/Formula_08_015.png) and those that do not. This
    defines the coefficients that we defined in *step 2*, each of which is given by
    the following code fragment:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，！[](img/Formula_08_014.png)参数是用于生成曲线点的变化量。我们可以将先前求和中的涉及！[](img/Formula_08_015.png)的项与不涉及的项分离开来。这定义了我们在*第2步*中定义的系数，每个系数通过以下代码片段给出：
- en: '[PRE108]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: We reshape each of the points, `p`, in this step to make sure it is arranged
    as a column vector. This means that each of the coefficients is a column vector
    (as a NumPy array) consisting of the control points scaled by the binomial coefficients.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们重新排列每个点`p`，确保它作为列向量排列。这意味着每个系数都是一个列向量（作为NumPy数组），由通过二项式系数缩放的控制点组成。
- en: 'Now, we need to specify how to evaluate the Bezier curve at various values
    of ![](img/Formula_08_016.png). This is where we make use of the high-performance
    array operations from the NumPy package. We reshaped our control points as column
    vectors when forming our coefficients. In *step 4*, we reshaped the input, ![](img/Formula_08_017.png),
    values to make a row vector. This means that we can use the matrix multiplication
    operator to multiply each coefficient by the corresponding (scalar) value, depending
    on the input, ![](img/Formula_08_018.png). This is what happens in *step 5*, inside
    the list comprehension. In the following line, we multiply the ![](img/Formula_08_019.png)
    array by the ![](img/Formula_08_020.png) array to obtain an ![](img/Formula_08_021.png)
    array:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要指定如何在不同的！[](img/Formula_08_016.png)值下评估贝塞尔曲线。这时我们利用了NumPy包中的高性能数组操作。我们在形成系数时将控制点重新排列为列向量。在*第4步*中，我们将输入的！[](img/Formula_08_017.png)值重新排列为行向量。这意味着我们可以使用矩阵乘法操作符，将每个系数与相应的（标量）值相乘，具体取决于输入的！[](img/Formula_08_018.png)。这就是在*第5步*中，列表推导式内部发生的事情。在下面这一行中，我们将！[](img/Formula_08_019.png)数组与！[](img/Formula_08_020.png)数组相乘，从而得到一个！[](img/Formula_08_021.png)数组：
- en: '[PRE109]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: We get one of these for each coefficient. We can then use the `np.sum` routine
    to sum each of these ![](img/Formula_08_022.png) arrays to get the values along
    the Bezier curve. In the example provided in this recipe, the top row of the output
    array contains the ![](img/Formula_08_023.png) values of the curve and the bottom
    row contains the ![](img/Formula_08_024.png) values of the curve. We have to be
    careful when specifying the `axis=0` keyword argument for the `sum` routine to
    make sure the sum takes over the list we created, and not the arrays that this
    list contains.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个系数得到一个这样的结果。然后，我们可以使用`np.sum`例程对每个！[](img/Formula_08_022.png)数组进行求和，从而获得贝塞尔曲线上的值。在本示例中，输出数组的顶行包含曲线的！[](img/Formula_08_023.png)值，底行包含曲线的！[](img/Formula_08_024.png)值。我们必须小心地指定`axis=0`关键字参数，以确保`sum`例程对我们创建的列表进行求和，而不是对该列表包含的数组进行求和。
- en: The class we defined is initialized using the control points for the Bezier
    curve, which are then used to generate the coefficients. The actual computation
    of the curve values is done using NumPy, so this implementation should have relatively
    good performance. Once a specific instance of this class has been created, it
    functions very much like a function, as you might expect. However, no type-checking
    is done here, so we can only call this *function* with a NumPy array as an argument.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的类通过使用贝塞尔曲线的控制点来初始化，然后用这些点来生成系数。曲线值的实际计算是通过使用NumPy进行的，因此这个实现应该具有相对较好的性能。一旦创建了该类的特定实例，它的功能就像一个函数，正如你所预期的那样。然而，这里没有进行类型检查，因此我们只能将NumPy数组作为参数来调用这个*函数*。
- en: There’s more...
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Bezier curves are defined using an iterative construction, where the curve with
    ![](img/Formula_08_025.png) points is defined using the straight line connecting
    the curves defined by the first and last ![](img/Formula_08_026.png) points. Keeping
    track of the coefficient of each of the control points using this construction
    will quickly lead you to the equation we used to define the preceding curve. This
    construction also leads to interesting – and useful – geometric properties of
    Bezier curves.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塞尔曲线是使用迭代构造定义的，其中使用直线连接由第一个和最后一个控制点定义的曲线来定义具有![](img/Formula_08_025.png)点的曲线。使用此构造跟踪每个控制点的系数将迅速导致我们用于定义前述曲线的方程。此构造还导致贝塞尔曲线的有趣
    - 和有用的 - 几何特性。
- en: As we mentioned in the introduction to this recipe, Bezier curves appear in
    many applications that involve vector graphics, such as fonts. They also appear
    in many common vector graphics software packages. In these software packages,
    it is common to see *quadratic Bezier curves*, which are defined by a collection
    of three points. However, you can also define a quadratic Bezier curve by supplying
    the two endpoints, along with the gradient lines, at those points. This is more
    common in graphics software packages. The resulting Bezier curve will leave each
    of the endpoints along the gradient lines and connect the curve smoothly between
    these points.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本篇文章开头提到的，贝塞尔曲线出现在许多涉及矢量图形的应用程序中，如字体。它们还出现在许多常见的矢量图形软件包中。在这些软件包中，通常可以看到*二次贝塞尔曲线*，它们由三个点的集合定义。但是，您也可以通过提供这些点上的两个端点以及梯度线来定义二次贝塞尔曲线。这在图形软件包中更为常见。生成的贝塞尔曲线将沿着这些梯度线留下每个端点，并在这些点之间平滑连接曲线。
- en: The implementation we constructed here will have relatively good performance
    for small applications but will not be sufficient for applications involving rendering
    curves with a large number of control points at a large number of ![](img/Formula_08_015.png)
    values. For this, it is best to use a low-level package written in a compiled
    language. For example, the `bezier` Python package uses a compiled Fortran backend
    for its computations and provides a much richer interface than the class we defined
    here.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里构建的实现在小型应用中性能相对较好，但对于涉及在大量控制点上渲染曲线的应用来说不足够。对此，最好使用一个用编译语言编写的低级包。例如，`bezier`
    Python包使用编译的Fortran后端进行计算，并提供比我们在这里定义的类更丰富的接口。
- en: Bezier curves can, of course, be extended to higher dimensions in a natural
    way. The result is a Bezier surface, which makes them very useful general-purpose
    tools for high-quality, scalable graphics.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塞尔曲线当然可以以一种自然的方式扩展到更高的维度。结果是贝塞尔曲面，这使它们成为非常有用的通用工具，用于高质量、可扩展的图形。
- en: Further reading
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'A description of some common algorithms from computation geometry can be found
    in the following book: Press, W.H., Teukolsky, S.A., Vetterling, W.T., and Flannery,
    B.P., 2007\. *Numerical recipes: the art of scientific computing*. 3rd ed. Cambridge:
    Cambridge University Press.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '计算几何中一些常见算法的描述可以在以下书籍中找到：Press, W.H., Teukolsky, S.A., Vetterling, W.T., and
    Flannery, B.P., 2007\. *数值计算法: 科学计算的艺术*. 第三版. 剑桥: 剑桥大学出版社。'
- en: 'For a more detailed account of some problems and techniques from computational
    geometry, check out the following book: O’Rourke, J., 1994\. *Computational geometry
    in C*. Cambridge: Cambridge University Press.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '想要更详细地了解计算几何中的一些问题和技术，请参阅以下书籍：O’Rourke, J., 1994\. *C语言中的计算几何*. 剑桥: 剑桥大学出版社。'
