- en: Chapter 5. Using QGIS in an External Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。在外部应用程序中使用 QGIS
- en: 'In [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting Started with
    QGIS"), *Getting Started with QGIS*, we looked briefly at a standalone Python
    program built using PyQt and the PyQGIS library. In this chapter, we will use
    the same technique to build a complete turnkey mapping application using PyQGIS.
    Along the way, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](part0014_split_000.html#page "Chapter 1. Getting Started with QGIS")，*使用
    QGIS 入门*中，我们简要地查看了一个使用 PyQt 和 PyQGIS 库构建的独立 Python 程序。在本章中，我们将使用相同的技巧，使用 PyQGIS
    构建一个完整的即插即用地图应用程序。在这个过程中，我们将：
- en: Design and build a simple but complete standalone mapping application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和构建一个简单但完整的独立地图应用程序
- en: Learn how to use a wrapper script to handle the platform-specific dependencies
    before our Python program is run
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在我们的 Python 程序运行之前使用包装脚本来处理平台特定的依赖项
- en: Define our application's user interface in a separate Python module so that
    we keep our UI separate from the application's business logic
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单独的 Python 模块中定义我们应用程序的用户界面，以便我们将 UI 与应用程序的业务逻辑分开
- en: Dynamically show and hide map layers based on the user's preference
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户的偏好动态显示和隐藏地图图层
- en: Learn how to use a rule-based renderer to selectively display features based
    on the map's current zoom level
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用基于规则的渲染器根据地图当前的缩放级别选择性地显示特征
- en: See how data-defined properties can be used to calculate the font size to use
    for a label based on the feature's attributes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看如何使用数据定义的属性来计算用于标签的字体大小，基于特征的属性
- en: Implement Google Maps style panning and zooming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现谷歌地图风格的平移和缩放
- en: Introducing Lex
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Lex
- en: Our mapping application will display a world map, allowing the user to zoom
    and pan, and display various landmarks on the map. If the user clicks on a landmark,
    information about that landmark will be displayed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的地图应用程序将显示世界地图，允许用户缩放和平移，并在地图上显示各种地标。如果用户点击一个地标，将显示该地标的详细信息。
- en: 'We''ll call our application **Lex**, which is short for **L**andmark **ex**plorer.
    Lex will make use of two freely available geospatial datasets: a high-resolution
    shaded-relief basemap, and a comprehensive database of place names, which we will
    use as the list of landmarks to display:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的应用程序称为 **Lex**，它是 **L**andmark **ex**plorer 的缩写。Lex 将使用两个免费提供的地理空间数据集：一个高分辨率的阴影地形图，以及一个全面的地点名称数据库，我们将使用它作为显示的地标列表：
- en: '![Introducing Lex](img/00047.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![介绍 Lex](img/00047.jpeg)'
- en: We will build our Lex application using PyQt, and make use of the PyQGIS libraries
    built into QGIS to do most of the hard work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 PyQt 构建 Lex 应用程序，并利用 QGIS 内置的 PyQGIS 库来完成大部分繁重的工作。
- en: 'Our requirements for the Lex application are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Lex 应用程序，我们的要求如下：
- en: It must run as a turnkey application. Double-clicking on the launcher script
    must start the PyQt program, load all the data, and present a complete working
    application to the user.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须作为一个即插即用应用程序运行。双击启动器脚本必须启动 PyQt 程序，加载所有数据，并向用户展示一个完整的工作应用程序。
- en: The user interface must be as professional as possible, with keyboard shortcuts
    and good-looking toolbar icons.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面必须尽可能专业，包括键盘快捷方式和美观的工具栏图标。
- en: When the user clicks on a landmark, the name and jurisdiction, time zone, and
    latitude/longitude for that landmark should be displayed.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击一个地标时，应显示该地标的名称和管辖区域、时区和经纬度。
- en: The look and feel should be as similar as possible to Google Maps.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观和感觉应尽可能类似于谷歌地图。
- en: Note
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This last requirement is an important point, as the zooming and panning tools
    built into QGIS are more complicated than what we would like to have in a turnkey
    mapping application. Most users are already familiar with the behavior of Google
    Maps, and we want to mimic this behavior rather than using the default panning
    and zooming tools supplied by QGIS.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个最后的要求是一个重要的点，因为 QGIS 内置的缩放和平移工具比我们希望在即插即用地图应用程序中拥有的要复杂。大多数用户已经熟悉谷歌地图的行为，我们希望模仿这种行为，而不是使用
    QGIS 提供的默认平移和缩放工具。
- en: Without further delay, let's start building our application. Our first step
    will be to download the geospatial data the application will be based on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们开始构建我们的应用程序。我们的第一步将是下载应用程序将基于的地理空间数据。
- en: Getting the data
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取数据
- en: 'Lex will make use of two map layers: a **basemap layer** that displays a shaded-relief
    raster image, and a **landmark layer** that shows the individual landmarks based
    on a set of place names. Both of these datasets can be downloaded from the Natural
    Earth Data website. Visit [http://www.naturalearthdata.com](http://www.naturalearthdata.com)
    and click on the **Get the Data** link to jump to the **Downloads** page.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Lex将使用两个地图层：一个**底图层**显示阴影高程栅格图像，以及一个**地标层**根据一组地名显示单个地标。这两个数据集都可以从自然地球数据网站下载。访问[http://www.naturalearthdata.com](http://www.naturalearthdata.com)，并点击**获取数据**链接跳转到**下载**页面。
- en: The basemap data can be found by clicking on the **Raster** link. We'll want
    the highest-resolution data available, so use the link in the **Large scale data,
    1:10m** section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**栅格**链接可以找到底图数据。我们希望使用最高分辨率的可用数据，因此请使用**大比例尺数据，1:10m**部分中的链接。
- en: While you could use any of these datasets as a basemap, we will download the
    **Natural Earth I with Shaded Relief, Water, and Drainages** dataset. Make sure
    you download the high-resolution version of this dataset so that the raster image
    will still look good when the user has zoomed in.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用这些数据集作为底图，但我们将下载**自然地球I带阴影高程、水和排水**数据集。确保你下载这个数据集的高分辨率版本，这样当用户放大时，栅格图像仍然看起来很好。
- en: For the landmarks, we'll be using the "populated places" dataset. Go back to
    the main downloads page and click on the **Cultural** link in the **Large scale
    data, 1:10m** section. Scroll down to the **Populated Places** section and click
    on the **Download Populated Places** link.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于地标，我们将使用“人口密集地区”数据集。返回主下载页面，在**大比例尺数据，1:10m**部分点击**文化**链接。向下滚动到**人口密集地区**部分，并点击**下载人口密集地区**链接。
- en: 'Once you have finished downloading, you should have two ZIP archives on your
    computer:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，你应该在电脑上有两个ZIP存档：
- en: '`NE1_HR_LC_SR_W_DR.zip`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`NE1_HR_LC_SR_W_DR.zip`'
- en: '`ne_10m_populated_places.zip`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`ne_10m_populated_places.zip`'
- en: Create a folder named `data`, decompress the preceding two ZIP archives, and
    place the resulting directories into your `data` folder.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`data`的文件夹，解压缩前面的两个ZIP存档，并将生成的目录放入你的`data`文件夹中。
- en: Designing the application
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计应用程序
- en: We now have a list of requirements for our mapping application, together with
    the geospatial data we want to display. Before we start coding, however, it's
    a good idea to step back and think about our application's user interface.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一份我们映射应用的需求列表，以及我们想要显示的地理空间数据。然而，在我们开始编码之前，退一步思考我们应用的用户界面是个好主意。
- en: 'Our application will have one main window, which we will call **Landmark Explorer**.
    To make it easy to use, we''ll display a map canvas along with a simple toolbar.
    Our basic window layout will look like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将有一个主窗口，我们将称之为**地标探索器**。为了使其易于使用，我们将显示一个地图画布以及一个简单的工具栏。我们的基本窗口布局将如下所示：
- en: '![Designing the application](img/00048.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![设计应用程序](img/00048.jpeg)'
- en: 'Along with the main window, our Lex application will have a menu bar with the
    following menus:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主窗口外，我们的Lex应用程序还将有一个包含以下菜单的菜单栏：
- en: '![Designing the application](img/00049.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![设计应用程序](img/00049.jpeg)'
- en: The toolbar will make it easy for new users to work with Lex by pointing and
    clicking on the toolbar icons, while experienced users can make use of the extensive
    keyboard shortcuts to access the program's features.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏将使新用户通过点击工具栏图标来使用Lex变得容易，而经验丰富的用户可以利用广泛的键盘快捷键来访问程序的功能。
- en: With this design in mind, let's start coding.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个设计思路，让我们开始编码。
- en: Creating the application's framework
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序框架
- en: 'Start by creating a folder to hold your application''s source code, and move
    the data folder you created earlier into it. Next, we want to create the basic
    framework for our application using the techniques we learned in [Chapter 1](part0014_split_000.html#page
    "Chapter 1. Getting Started with QGIS"), *Getting Started with QGIS*. Create a
    module named `lex.py`, and enter the following into this file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个用于存放应用程序源代码的文件夹，并将你之前创建的数据文件夹移动到其中。接下来，我们想要使用我们在[第1章](part0014_split_000.html#page
    "第1章。使用QGIS入门")中学习的技术来创建我们应用程序的基本框架，即*使用QGIS入门*。创建一个名为`lex.py`的模块，并将以下内容输入到该文件中：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We're simply importing the various libraries we'll need and setting up an external
    PyQGIS application using the techniques we learned earlier. We then create and
    display a blank window so that the application will do something when it starts
    up.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是导入所需的各个库，并使用我们之前学到的技术设置一个外部 PyQGIS 应用程序。然后我们创建并显示一个空白窗口，以便应用程序在启动时能做些事情。
- en: Since we want the Lex application to work on any operating system, we're not
    going to hard-wire the path to QGIS into our source code. Instead, we'll write
    a **wrapper script** that sets up the required environment variables before launching
    our Python program. As these wrapper scripts are operating-system dependent, you
    will need to create an appropriate wrapper script for your operating system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望 Lex 应用程序能在任何操作系统上运行，我们不会将 QGIS 的路径硬编码到我们的源代码中。相反，我们将编写一个 **封装脚本**，在启动我们的
    Python 程序之前设置所需的环境变量。由于这些封装脚本依赖于操作系统，您需要为您的操作系统创建一个适当的封装脚本。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that we use `os.environ['QGIS_PREFIX']` in our `lex.py` module to avoid
    hard-wiring the path to the QGIS application into our source code. Our wrapper
    script will take care of setting this environment variable before the application
    is run.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `lex.py` 模块中使用 `os.environ['QGIS_PREFIX']` 以避免将 QGIS 应用程序的路径硬编码到我们的源代码中。我们的封装脚本将负责在应用程序运行之前设置这个环境变量。
- en: 'If you are using a computer with Microsoft Windows, your wrapper script will
    look something like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Microsoft Windows 计算机上的计算机，您的封装脚本看起来可能如下所示：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Name this script something sensible, for example, `run.bat`, and put it in the
    same directory as your `lex.py` module.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本命名为有意义的名称，例如，`run.bat`，并将其放在与您的 `lex.py` 模块相同的目录中。
- en: 'If you are using a computer that runs Linux, your wrapper script will be named
    something like `run.sh`, and will look like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是运行 Linux 的计算机，您的封装脚本将被命名为类似 `run.sh` 的名称，并看起来如下所示：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will need to modify the paths to refer to the directory where QGIS has been
    installed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要修改路径以指向 QGIS 已安装的目录。
- en: 'For those running Mac OS X, your wrapper script will also be called `run.sh`,
    and will contain the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行 Mac OS X 的用户，您的封装脚本也将被命名为 `run.sh`，并包含以下内容：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that for Mac OS X and Linux, we have to set the framework or library
    paths. This allows the PyQGIS Python wrappers to find the underlying C++ shared
    libraries that they are based on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于 Mac OS X 和 Linux 系统，我们必须设置框架或库路径。这允许 PyQGIS 的 Python 封装器找到它们所依赖的底层 C++
    共享库。
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are running under Linux or Mac OS X, you'll also have to make your wrapper
    script executable. To do this, type `chmod +x run.sh` into the bash shell or terminal
    window.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 Linux 或 Mac OS X 下运行，您还必须使您的封装脚本可执行。为此，请在 bash shell 或终端窗口中输入 `chmod +x
    run.sh`。
- en: 'Once you have created your shell script, try running it. If all goes well,
    your PyQt application should start up and display a blank window, like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了您的 shell 脚本，尝试运行它。如果一切顺利，您的 PyQt 应用程序应该启动并显示一个空白窗口，如下所示：
- en: '![Creating the application''s framework](img/00050.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![创建应用程序框架](img/00050.jpeg)'
- en: If it doesn't work, you will need to check your wrapper script and/or your `lex.py`
    module. You might need to modify the directory paths to match your QGIS and Python
    installations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不起作用，您需要检查您的封装脚本和/或您的 `lex.py` 模块。您可能需要修改目录路径以匹配您的 QGIS 和 Python 安装。
- en: Adding the user interface
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用户界面
- en: Now that our program is running, we can start implementing the user interface
    (UI). A typical PyQt application will make use of Qt Designer to store the application's
    UI in a template file, which is then compiled into a Python module for use within
    your application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们程序正在运行，我们可以开始实现用户界面（UI）。一个典型的 PyQt 应用程序将使用 Qt Designer 将应用程序的 UI 存储在一个模板文件中，然后将其编译成一个
    Python 模块，以便在您的应用程序中使用。
- en: As it would take many pages to describe how to use Qt Designer to lay out our
    window with its toolbar and menus, we're going to cheat and create our user interface
    directly within Python. At the same time, however, we'll create our UI module
    as if it was created using Qt Designer; this keeps our application's UI separate,
    and also shows how our application would work if we were to use Qt Designer to
    design our user interface.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于描述如何使用 Qt Designer 来布局带有工具栏和菜单的窗口需要很多页面，我们将采取捷径，直接在 Python 中创建用户界面。同时，我们还将创建我们的
    UI 模块，就像它是使用 Qt Designer 创建的一样；这使我们的应用程序 UI 保持独立，同时也展示了如果使用 Qt Designer 设计用户界面，我们的应用程序将如何工作。
- en: 'Create a new module called `ui_explorerWindow.py`, and type the following code
    into this module:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`ui_explorerWindow.py`的新模块，并将以下代码输入到该模块中：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This module implements our Lex application's user interface, defining a `QtAction`
    object for each toolbar and menu item, creating a widget to hold our map canvas,
    and laying everything out within a `QtMainWindow` object. The structure of this
    module is identical to the way Qt Designer and the `pyuic4` command-line tool
    make a user interface template available to Python code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块实现了我们的Lex应用程序的用户界面，为每个工具栏和菜单项定义了一个`QtAction`对象，创建了一个用于容纳我们的地图画布的小部件，并在`QtMainWindow`对象内布局一切。此模块的结构与Qt
    Designer和`pyuic4`命令行工具将用户界面模板提供给Python代码的方式相同。
- en: Notice that the `Ui_ExplorerWindow` class makes use of several toolbar icons.
    We will need to create these icon images and define them in a resource description
    file, in the same way we created a `resources.py` module in the previous chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Ui_ExplorerWindow`类使用了多个工具栏图标。我们需要创建这些图标图像并在资源描述文件中定义它们，就像我们在上一章中创建`resources.py`模块一样。
- en: 'We are going to need the following icon images:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要以下图标图像：
- en: '`mActionZoomIn.png`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mActionZoomIn.png`'
- en: '`mActionZoomOut.png`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mActionZoomOut.png`'
- en: '`mActionPan.png`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mActionPan.png`'
- en: '`mActionExplore.png`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mActionExplore.png`'
- en: If you want, you can download these image files in SVG format from the QGIS
    source code repository ([https://github.com/qgis/QGIS/tree/master/images/themes/default](https://github.com/qgis/QGIS/tree/master/images/themes/default)),
    though you will need to convert them from `.svg` to `.png` in order to avoid issues
    with image file formats. If you don't want to convert the icons yourself, the
    images are available as part of the source code available with this book. Once
    you are done, place these four files in the main directory of your Lex application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以从QGIS源代码库中下载这些图像文件（SVG格式）[https://github.com/qgis/QGIS/tree/master/images/themes/default](https://github.com/qgis/QGIS/tree/master/images/themes/default)，但你需要将它们从`.svg`转换为`.png`以避免图像文件格式问题。如果你不想自己转换图标，这些图像作为本书提供的源代码的一部分可用。完成后，将这些四个文件放置在Lex应用程序的主目录中。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that the `mActionExplore.png` icon file is a converted copy of the `mActionIdentify.svg`
    image in the source code repository. We renamed the image file to match the name
    of the tool in our Lex application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`mActionExplore.png`图标文件是源代码库中`mActionIdentify.svg`图像的转换副本。我们将图像文件重命名为与Lex应用程序中工具的名称相匹配。
- en: 'Next, we need to create our `resources.qrc` file so that PyQt can use these
    images. Create this file and enter the following into it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建我们的`resources.qrc`文件，以便PyQt可以使用这些图像。创建此文件并输入以下内容：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will need to compile this file using `pyrcc4`. This will give you the `resources.py`
    module required by your user interface.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用`pyrcc4`编译此文件。这将为你提供用户界面所需的`resources.py`模块。
- en: 'Now that we''ve defined our user interface, let''s modify the `lex.py` module
    to use it. Add the following `import` statements to the top of your module:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的用户界面，让我们修改`lex.py`模块以使用它。将以下`import`语句添加到模块的顶部：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we want to replace our dummy implementation of the `MapExplorer` window
    with one that uses our new UI. This is what the `MapExplorer` class definition
    should look like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要用我们新的UI替换`MapExplorer`窗口的占位实现。`MapExplorer`类的定义应该如下所示：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If all goes well, our application should now run with a complete user interface—a
    toolbar, menus, and room for our map canvas:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们的应用程序现在应该运行带有完整的用户界面——工具栏、菜单和我们的地图画布的空间：
- en: '![Adding the user interface](img/00051.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![添加用户界面](img/00051.jpeg)'
- en: Of course, our user interface doesn't do anything yet, but our Lex application
    is starting to look like a real program. Now, let's implement the behavior behind
    our UI.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的用户界面目前还没有任何功能，但我们的Lex应用程序开始看起来像是一个真正的程序。现在，让我们实现UI背后的行为。
- en: Connecting the actions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接操作
- en: 'You might have noticed that none of the menu commands and toolbar icons do
    anything yet—even the **Quit** command doesn''t work. Before our actions do anything,
    we have to connect them to the appropriate method. To do this, add the following
    to your `MapExplorer.__init__()` method, immediately after the call to `setupUi()`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，菜单命令和工具栏图标目前都没有任何作用——即使是**退出**命令也不工作。在我们操作之前，我们必须将它们连接到适当的方法。为此，请将以下内容添加到`MapExplorer.__init__()`方法中，紧接在调用`setupUi()`之后：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''re connecting our **Quit** action to the `qApp.quit()` method. For the
    other actions, we''ll be calling methods within our `MapExplorer` class itself.
    Let''s define some placeholders for these methods:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的 **退出** 动作连接到 `qApp.quit()` 方法。对于其他动作，我们将在 `MapExplorer` 类本身内部调用方法。让我们为这些方法定义一些占位符：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We'll implement these methods later on, once we have the map canvas up and running.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在地图画布设置好并运行之后实现这些方法。
- en: Creating the map canvas
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建地图画布
- en: 'Our `Ui_ExplorerWindow` class defines an instance variable named `centralWidget`,
    which acts as a placeholder for our window''s contents. Since we want to place
    a QGIS map canvas into our window, let''s implement the code to create our map
    canvas and place it into this central widget. Add the following to the end of
    your `MapExplorer` window''s `__init__()` method (in `lex.py`):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Ui_ExplorerWindow` 类定义了一个名为 `centralWidget` 的实例变量，它作为窗口内容的占位符。由于我们想在窗口中放置一个
    QGIS 地图画布，让我们实现创建地图画布并将其放置到这个中央小部件中的代码。将以下内容添加到 `MapExplorer` 窗口的 `__init__()`
    方法的末尾（在 `lex.py` 中）：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we want to fill our map canvas with the basemap and landmark map layers.
    To do this, we''ll define a new method called `loadMap()`, and call this at the
    appropriate time. Add the following method to your `MapExplorer` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望将底图和地标图图层填充到地图画布中。为此，我们将定义一个新的方法，称为 `loadMap()`，并在适当的时候调用它。将以下方法添加到您的
    `MapExplorer` 类中：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method loads the raster and vector datasets we placed in our `data` directory.
    We then call a new method, `showVisibleMapLayers()`, to make those layers visible,
    and then set the extent of the map canvas to show the continental USA when the
    application first starts up.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法加载我们放置在 `data` 目录中的栅格和矢量数据集。然后我们调用一个新的方法 `showVisibleMapLayers()` 来使这些图层可见，并在应用程序首次启动时设置地图画布的范围以显示美国大陆。
- en: 'Let''s implement the `showVisibleMapLayers()` method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现 `showVisibleMapLayers()` 方法：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As the user can choose to show or hide the basemap and landmark layers individually,
    we only display the layers that the user has selected to display. We also put
    this into a separate method so that we can call it when the user toggles the visibility
    of a layer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户可以选择单独显示或隐藏底图和地标图层，我们只显示用户选择显示的图层。我们还将其放入一个单独的方法中，以便在用户切换图层的可见性时调用它。
- en: 'There are a few more things to do before our map can be displayed. First off,
    add the following line to your `main()` function immediately after the call to
    `window.raise_()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的地图可以显示之前，还有一些事情要做。首先，在调用 `window.raise_()` 之后，立即在 `main()` 函数中添加以下行：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This loads the map once the window has been displayed. Next, add the following
    to the end of your main window''s `__init__()` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在窗口显示后加载地图。接下来，将以下内容添加到主窗口的 `__init__()` 方法的末尾：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This makes the two layers visible when the program starts up. Finally, let''s
    implement the two methods we defined earlier so that the user can choose which
    layers are shown:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得两个图层在程序启动时可见。最后，让我们实现我们之前定义的两个方法，以便用户可以选择显示哪些图层：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running the program should show the two map layers, and you can show or hide
    each layer using the commands in the **View** menu:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序应显示两个地图图层，您可以使用 **视图** 菜单中的命令显示或隐藏每个图层：
- en: '![Creating the map canvas](img/00052.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![创建地图画布](img/00052.jpeg)'
- en: Labeling the points
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记点
- en: 'As you can see from the preceding image, each landmark is simply represented
    by a colored dot. To make the program more useful, we''ll want to display the
    name of each landmark. This can be done by using the "PAL" labeling engine built
    into QGIS. Add the following code to your `loadMap()` method, immediately before
    the call to `self.showVisibleMapLayers()`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，每个地标仅由一个彩色点表示。为了使程序更有用，我们希望显示每个地标的名称。这可以通过使用 QGIS 内置的 "PAL" 标签引擎来完成。将以下代码添加到您的
    `loadMap()` 方法中，在调用 `self.showVisibleMapLayers()` 之前立即执行：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will label each point on the map. Unfortunately, there are a lot of points,
    and the resulting map is completely unreadable:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为地图上的每个点添加标签。不幸的是，有很多点，结果地图几乎无法阅读：
- en: '![Labeling the points](img/00053.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![标记点](img/00053.jpeg)'
- en: Filtering the landmarks
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤地标
- en: The reason our labels are unreadable is because there are too many landmarks
    being displayed. However, not all landmarks are relevant at all zoom levels—we
    want to hide landmarks that are too small to be useful when the map is zoomed
    out, while still showing these landmarks when the user zooms in. To do this, we'll
    use a `QgsRuleBasedRendererV2` object and make use of the `SCALERANK` attribute
    to selectively hide features that are too small for the current zoom level.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的标签之所以难以阅读，是因为显示的地标太多。然而，并非所有地标在所有缩放级别都相关——我们希望在地图缩放时隐藏太小而无法使用的地标，同时当用户放大时仍然显示这些地标。为此，我们将使用
    `QgsRuleBasedRendererV2` 对象并利用 `SCALERANK` 属性来选择性地隐藏对于当前缩放级别来说太小的不必要特征。
- en: 'Add the following code to your `loadMap()` method, before the call to `self.showVisibleMapLayers()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `self.showVisibleMapLayers()` 之前，将以下代码添加到您的 `loadMap()` 方法中：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will have the effect of hiding landmarks that are too small (that is,
    which have too large a `SCALERANK` value) when the map is zoomed out. Now, our
    map looks much more reasonable:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在地图缩放时隐藏过小的地标（即具有过大 `SCALERANK` 值的地标）。现在，我们的地图看起来更加合理：
- en: '![Filtering the landmarks](img/00054.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![过滤地标](img/00054.jpeg)'
- en: 'There''s just one more feature we''d like to add here; at the moment, all the
    labels are of the same size. However, we''d like the larger landmarks to be shown
    with a larger label. To do this, replace the `p.setDataDefinedProperty(...)` line
    in your program with the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们还想添加一个功能；目前，所有标签的大小都是相同的。然而，我们希望较大的地标显示更大的标签。为此，将您的程序中的 `p.setDataDefinedProperty(...)`
    行替换为以下内容：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This calculates the font size based on the feature's `SCALERANK` attribute value.
    As you can imagine, using data-defined properties in this way can be extremely
    useful.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这根据特征的 `SCALERANK` 属性值计算字体大小。正如您所想象的，以这种方式使用数据定义属性可以非常有用。
- en: Implementing the zoom tool
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现缩放工具
- en: 'Next, we want to support zooming in and out. As mentioned earlier, one of the
    requirements for our Lex application is that it must work like Google Maps rather
    than QGIS, and this is an example of where we have to support this. QGIS has a
    zoom tool, which the user clicks on and then clicks or drags on the map to zoom
    in or out. In Lex, the user will click on the toolbar icons directly to do the
    zooming. Fortunately, this is easy to do; simply implement the `zoomIn()` and
    `zoomOut()` methods in the following way:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望支持缩放和放大。如前所述，Lex应用程序的一个要求是它必须像Google Maps而不是QGIS一样工作，这是一个我们必须支持的地方。QGIS有一个缩放工具，用户点击它，然后在地图上点击或拖动以缩放。在Lex中，用户将直接点击工具栏图标来进行缩放。幸运的是，这很容易做到；只需以下方式实现
    `zoomIn()` 和 `zoomOut()` 方法：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, try to run your program. As you zoom in and out, you can see the various
    landmarks appear and disappear, and you should also be able to see the different
    font sizes used for the labels based on each feature's `SCALERANK` value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试运行您的程序。在您缩放和放大时，您可以看到各种地标的出现和消失，您也应该能够看到根据每个特征的 `SCALERANK` 值使用的不同字体大小。
- en: Implementing the pan tool
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现平移工具
- en: 'Panning (that is, clicking and dragging on the map to move around) is another
    area where the QGIS default behavior isn''t quite what we want. QGIS includes
    a `classQgsMapToolPan` class, which implements panning; however, it also includes
    some features that could be quite confusing for users coming from Google Maps.
    In particular, if the user clicks without dragging, the map is re-centered over
    the clicked-on point. Instead of using `classQgsMapToolPan`, we will implement
    our own panning map tool. Fortunately, this is simple to do: simply add the following
    class definition to your `lex.py` module after the end of your `MapExplorer` class
    definition:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 平移（即点击并拖动地图以移动）是另一个QGIS默认行为并不完全符合我们期望的领域。QGIS包括一个 `classQgsMapToolPan` 类，它实现了平移；然而，它还包含了一些可能会让来自Google
    Maps的用户感到困惑的功能。特别是，如果用户点击而不拖动，地图将重新居中到点击的点。我们不会使用 `classQgsMapToolPan`，而是将实现我们自己的平移地图工具。幸运的是，这很简单：只需在
    `MapExplorer` 类定义之后，将以下类定义添加到您的 `lex.py` 模块中：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then need to add the following to the end of our main window''s `__init__()`
    method to create an instance of our panning tool:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将以下内容添加到主窗口的 `__init__()` 方法末尾，以创建我们的平移工具的实例：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now implement our `setPanMode()` method to use this map tool:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以实施我们的 `setPanMode()` 方法来使用这个地图工具：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we''ll want to select the panning mode when the application starts
    up. To do this, add the following to your `main()` function after the call to
    `window.loadMap()`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望在应用程序启动时选择平移模式。为此，在调用 `window.loadMap()` 之后，将以下内容添加到您的 `main()` 函数中：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Implementing the explore mode
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现探索模式
- en: 'So far, the user can choose which map layers are displayed, and can zoom and
    pan the map view. The only thing missing is the entire point of the application:
    exploring landmarks. To do this, we''ll have to implement our application''s **explore**
    mode.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，用户可以选择显示哪些地图图层，并且可以缩放和平移地图视图。唯一缺少的是应用程序的整个目的：探索地标。为此，我们必须实现应用程序的 **探索**
    模式。
- en: 'In the previous chapter, we saw how we can use a `QgsMapToolIdentify` subclass
    to respond when the user clicks on a vector feature. We''re going to use the same
    logic here to implement a new map tool, which we''ll call `ExploreTool`. Add the
    following class definition to your `lex.py` module after the `PanTool` class definition:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用 `QgsMapToolIdentify` 子类来响应用户点击矢量要素。我们将在这里使用相同的逻辑来实现一个新的地图工具，我们将称之为
    `ExploreTool`。在 `PanTool` 类定义之后，将以下类定义添加到您的 `lex.py` 模块中：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This tool identifies the landmark feature the user clicked on, extracts the
    relevant attributes for that feature, and displays the results in a message box.
    To use our new map tool, we''ll have to add the following to the end of our `MapExplorer`
    window''s `__init__()` method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具识别用户点击的地标要素，提取该要素的相关属性，并在消息框中显示结果。要使用我们新的地图工具，我们必须将以下内容添加到 `MapExplorer`
    窗口的 `__init__()` 方法的末尾：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ll then need to implement our `setExploreMode()` method to use this tool:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要实现我们的 `setExploreMode()` 方法来使用这个工具：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice that when the user switches to the explore mode, we have to uncheck
    the panning mode action. This ensures that the two modes are mutually exclusive.
    The final step we have to take is to modify our `setPanMode()` method so that
    it unchecks the explore mode action when the user switches back to the panning
    mode. To do this, add the following highlighted line to your `setPanMode()` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当用户切换到探索模式时，我们必须取消勾选平移模式操作。这确保了两种模式是互斥的。我们必须采取的最后一步是修改我们的 `setPanMode()`
    方法，以便当用户切换回平移模式时取消勾选探索模式操作。为此，将以下突出显示的行添加到您的 `setPanMode()` 方法中：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This completes our Lex program. The user can now zoom in and out, pan around,
    and click on a feature to get more information about that landmark:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的 Lex 程序。现在用户可以放大和缩小，平移地图，并点击要素以获取有关该地标的更多信息：
- en: '![Implementing the explore mode](img/00055.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![实现探索模式](img/00055.jpeg)'
- en: Further improvements and enhancements
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步的改进和增强
- en: 'Of course, while Lex is a useful and complete mapping application, it is really
    only a starting point. The information provided in the freely available populated
    places dataset doesn''t make for a particularly interesting set of landmarks,
    and our application is still quite basic. Here are some suggested improvements
    you could make to the Lex application:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，虽然 Lex 是一个有用且完整的地图应用程序，但它实际上只是一个起点。免费提供的已有人口数据集提供的信息并不构成一个特别有趣的地标集，而且我们的应用程序仍然相当基础。以下是一些您可以对
    Lex 应用程序进行的建议性改进：
- en: Add a **Search** action, where the user can type in the name of a feature and
    Lex will zoom and pan the map to show that feature.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个 **搜索** 操作，用户可以输入要素的名称，Lex 将缩放和平移地图以显示该要素。
- en: Let the user choose any two landmarks, and display the distance between those
    two points in both kilometers and miles.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让用户选择任意两个地标，并显示这两个点之间的距离，单位为千米和英里。
- en: Allow the user to load their own set of landmarks, either from a shapefile or
    an Excel spreadsheet. When loading from a shapefile, the user could be prompted
    to select the attribute(s) to display for each feature. When loading data from
    a spreadsheet (using, for example, the `xlrd` library), the various columns would
    contain the latitude and longitude values as well as the label and other data
    to display for each landmark.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户加载他们自己的地标集，无论是从 shapefile 还是 Excel 电子表格中。当从 shapefile 加载时，用户可能会被提示选择要显示的每个要素的属性。当从电子表格（例如使用
    `xlrd` 库）加载数据时，不同的列将包含纬度和经度值，以及要显示的标签和其他数据。
- en: See what is involved in bundling the Lex application and QGIS itself into a
    double-clickable installer for your operating system. The *PyQGIS Developer cookbook*
    has some tips on how to do this, and there are various tools such as **py2exe**
    and **py2app**, which you can use as a starting point.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看将 Lex 应用程序和 QGIS 本身捆绑成一个双击即可安装的操作系统安装程序涉及哪些内容。*PyQGIS 开发者手册*中提供了一些关于如何做到这一点的技巧，并且有各种工具，如
    **py2exe** 和 **py2app**，您可以用它们作为起点。
- en: Implementing these extra features would be a great way of learning more about
    PyQGIS and how to use it within your own standalone mapping programs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些额外功能是了解 PyQGIS 以及如何在您自己的独立地图程序中使用它的绝佳方式。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we designed and implemented a simple but complete turnkey mapping
    application using PyQGIS. In doing this, we learned how a wrapper script can be
    used to keep platform-specific settings out of your Python program. We also saw
    how we can define our application's UI in a separate module even if we don't use
    Qt Designer to create our user interface templates.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 PyQGIS 设计并实现了一个简单但完整的即用型地图应用程序。在这个过程中，我们学习了如何使用包装脚本将特定平台的设置排除在您的 Python
    程序之外。我们还看到了即使我们不使用 Qt Designer 创建用户界面模板，我们也可以在单独的模块中定义我们应用程序的 UI。
- en: We learned how to use the "PAL" labeling engine built into QGIS to display a
    label for each feature within a vector map layer. We saw that a `QgsRuleBasedRendererV2`
    object can be used to show or hide certain features based on the map's scale factor,
    and that data-defined properties allow us to calculate values such as the label's
    font size; we also saw how the `CASE...WHEN` expression can be used to calculate
    data-defined properties in sophisticated ways.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用 QGIS 内置的 "PAL" 标签引擎在矢量地图层中为每个要素显示标签。我们看到 `QgsRuleBasedRendererV2`
    对象可以用来根据地图的缩放因子显示或隐藏某些要素，并且数据定义的属性允许我们计算诸如标签字体大小之类的值；我们还看到了如何使用 `CASE...WHEN`
    表达式以复杂的方式计算数据定义的属性。
- en: Finally, we saw how to implement Google Maps style panning and zooming within
    a mapping application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何在地图应用程序中实现 Google Maps 风格的平移和缩放。
- en: In the next chapter, we will learn about some of the more advanced features
    of the QGIS Python API and how we can use them within our mapping applications.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解 QGIS Python API 的更多高级功能以及我们如何在我们的地图应用程序中使用它们。
