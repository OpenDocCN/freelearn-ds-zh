- en: 9 Exploratory Data Analysis and Diagnosis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 探索性数据分析与诊断
- en: Join our book community on Discord
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们在 Discord 上的书籍社区
- en: '![](img/file0.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file0.png)'
- en: '[https://packt.link/zmkOY](https://packt.link/zmkOY)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/zmkOY](https://packt.link/zmkOY)'
- en: So far, we have covered techniques to extract data from various sources. This
    was covered in *Chapter 2*, *Reading Time Series Data from Files*, and *Chapter
    3*, *Reading Time Series Data from Databases*. *Chapter 6*, *Working with Date
    and Time in Python*, and *Chapter 7*, *Handling Missing Data*, covered several
    techniques to help prepare, clean, and adjust data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了从不同来源提取数据的技术。这些内容在*第2章*，*从文件读取时间序列数据*和*第3章*，*从数据库读取时间序列数据*中已经讨论过了。*第6章*，*在Python中处理日期和时间*，以及*第7章*，*处理缺失数据*，介绍了几种有助于准备、清理和调整数据的技术。
- en: You will continue to explore additional techniques to better understand the
    time series process behind the data. Before modeling the data or doing any further
    analysis, an important step is to inspect the data at hand. More specifically,
    there are specific time series characteristics that you need to check for, such
    as stationarity, effects of trend and seasonality, and autocorrelation, to name
    a few. These characteristics that describe the time series process you are working
    with need to be combined with domain knowledge behind the process itself.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将继续探索额外的技术，以便更好地理解数据背后的时间序列过程。在建模数据或进行进一步分析之前，一个重要步骤是检查手头的数据。更具体地说，你需要检查一些特定的时间序列特征，如平稳性、趋势和季节性的影响、以及自相关等。这些描述你所处理的时间序列过程的特征需要与该过程背后的领域知识相结合。
- en: This chapter will build on what you have learned from previous chapters to prepare
    you for creating and evaluating forecasting models starting from *Chapter 10*,
    *Building Univariate Time Series Models Using Statistical Methods*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将建立在你从前几章学到的知识基础上，帮助你为从*第10章*开始创建和评估预测模型做准备，*构建单变量时间序列模型（使用统计方法）*。
- en: In this chapter, you will learn how to visualize time series data, decompose
    a time series into its components (trend, seasonality, and the residual random
    process), test for different assumptions that your models may rely on (such as
    stationarity, normality, and homoskedasticity), and explore techniques to transform
    the data to satisfy some of these assumptions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何可视化时间序列数据，如何将时间序列分解为其组成部分（趋势、季节性和残差随机过程），如何检验模型可能依赖的不同假设（如平稳性、正态性和同方差性），以及如何探索数据转换技术以满足其中的一些假设。
- en: 'The recipes that you will encounter in this chapter are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将遇到的食谱如下：
- en: Plotting time series data using pandas
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 pandas 绘制时间序列数据
- en: Plotting time series data with interactive visualizations using hvPlot
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 hvPlot 绘制交互式时间序列数据
- en: Decomposing time series data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解时间序列数据
- en: Detecting time series stationarity
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测时间序列的平稳性
- en: Applying power transformations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用幂次变换
- en: Testing for autocorrelation in time series data
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试时间序列数据的自相关性
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can download the Jupyter notebooks and datasets needed from the GitHub
    repository to follow along:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 GitHub 仓库下载所需的 Jupyter 笔记本和数据集，进行跟随学习：
- en: 'Jupyter notebooks: [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./blob/main/code/Ch9/Chapter%209.ipynb](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./blob/main/code/Ch9/Chapter%209.ipynb)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jupyter 笔记本： [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./blob/main/code/Ch9/Chapter%209.ipynb](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./blob/main/code/Ch9/Chapter%209.ipynb)
- en: 'Datasets: [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/datasets/Ch9](ch010.xhtml)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集： [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/datasets/Ch9](ch010.xhtml)
- en: In this chapter and onward, we will extensively use pandas 2.2.0 (released Jan
    20, 2024). This applies to all the recipes in the chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章起，我们将广泛使用 pandas 2.2.0（2024年1月20日发布）。这适用于本章中的所有食谱。
- en: 'There are four additional libraries that we will be using:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用四个额外的库：
- en: '`hvplot` and `PyViz`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hvplot` 和 `PyViz`'
- en: '`seaborn`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seaborn`'
- en: '`matplotlib`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matplotlib`'
- en: 'If you are using `pip`, then you can install these packages from your terminal
    with the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是`pip`，你可以通过终端安装这些包，命令如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are using `conda`, then you can install these packages with the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是`conda`，你可以通过以下命令安装这些包：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The **HvPlot** library will be used to build interactive visualizations in
    JupyterLab. If you are on the latest version of **JupyterLab** (`jupyterlab >=
    3.0`) then all the required extensions are automatically installed as they are
    bundled in the `pyviz_comms` package. If you are on an older version of JupyterLab
    (`jupyterlab < 3.0`) then you will need to install `jupyterlab_pyviz` extension
    manually as shown:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**HvPlot** 库将用于在 JupyterLab 中构建交互式可视化。如果你使用的是最新版本的 **JupyterLab**（`jupyterlab
    >= 3.0`），那么所有所需的扩展都会自动安装，因为它们已经捆绑在 `pyviz_comms` 包中。如果你使用的是较旧版本的 JupyterLab（`jupyterlab
    < 3.0`），那么你需要手动安装 `jupyterlab_pyviz` 扩展，具体步骤如下：'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Throughout this chapter, you will be using three datasets (`Closing Price Stock
    Data`, `CO2`, and `Air Passengers`). The CO2 and Air Passengers datasets are provided
    with the `statsmodels` library. The Air Passengers dataset contains monthly airline
    passenger numbers from 1949 to 1960\. The CO2 dataset contains weekly atmospheric
    carbon dioxide levels on Mauna Loa from 1958 to 2001\. The Closing Price Stock
    Data dataset includes Microsoft, Apple, and IBM stock prices from November 2019
    to November 2021.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用三个数据集（`Closing Price Stock Data`、`CO2` 和 `Air Passengers`）。CO2 和 Air
    Passengers 数据集由 `statsmodels` 库提供。Air Passengers 数据集包含了1949年至1960年的每月航空乘客人数。CO2
    数据集包含了1958年至2001年间，位于毛纳罗亚山的每周大气二氧化碳浓度。Closing Price Stock Data 数据集包括2019年11月到2021年11月的微软、苹果和IBM的股票价格。
- en: 'To get started, you will need to load the datasets and store them as pandas
    DataFrames and load any libraries or methods that are needed throughout:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，你需要加载数据集，并将其存储为 pandas DataFrame，并加载在整个过程中需要的任何库或方法：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, you should have three DataFrames: `airp_df`, `closing_price`, and `co2_df`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经有了三个数据框：`airp_df`、`closing_price` 和 `co2_df`。
- en: Plotting time series data using pandas
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pandas 绘制时间序列数据
- en: Visualization is a crucial aspect of data analysis, becoming even more significant
    when dealing with time series data. In previous chapters and recipes, you have
    encountered numerous instances where plotting the data was essential to highlight
    specific points or to draw conclusions about the time series. Visualizing our
    time series data enables us to easily identify patterns, trends, outliers, and
    other critical information at a glance. Furthermore, data visualization facilitates
    communication across different groups and can help bridge the gap between various
    stakeholders (such as business professionals and data scientists) by providing
    a common platform for communication and fostering constructive dialogue.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化是数据分析中的一个关键方面，尤其在处理时间序列数据时显得尤为重要。在前面的章节和示例中，你已经遇到过多次绘制数据的实例，这些实例对于突出特定点或得出关于时间序列的结论至关重要。可视化我们的时间序列数据使我们能够一眼识别出模式、趋势、异常值以及其他关键信息。此外，数据可视化有助于跨不同小组之间的沟通，并通过提供一个共同的平台促进各利益相关方（如商业专家和数据科学家）之间的建设性对话。
- en: In time series analysis, as well as in machine learning at large, we prioritize
    visualizing our data during exploratory data analysis (EDA) to gain a comprehensive
    understanding of the data we’re working with. We also depend on visualization
    when evaluating our models, comparing their performance, and identifying areas
    for improvement. Visualization plays a key role in model explainability, allowing
    stakeholders to grasp how models make predictions. Furthermore, after deploying
    our models, we rely on visualizations for ongoing monitoring, looking for any
    indications of performance degradation, such as model drift.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列分析以及机器学习领域，我们在探索性数据分析（EDA）中优先可视化数据，以全面理解我们正在处理的数据。在评估模型时，我们也依赖于可视化来比较它们的表现，并识别需要改进的地方。可视化在模型可解释性方面发挥着关键作用，使利益相关者能够理解模型如何进行预测。此外，在部署模型后，我们依赖可视化进行持续监控，寻找任何性能下降的迹象，如模型漂移。
- en: The pandas library offers built-in plotting capabilities for visualizing data
    stored in a DataFrame or Series data structures. In the backend, these visualizations
    are powered by the **Matplotlib** library, which is also the default option.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 库提供了内置的绘图功能，用于可视化存储在 DataFrame 或 Series 数据结构中的数据。在后台，这些可视化由 **Matplotlib**
    库支持，后者也是默认选项。
- en: 'The pandas library offers many convenient methods to plot data. Simply calling
    `DataFrame.plot()` or `Series.plot()` will generate a line plot by default. You
    can change the type of the plot in two ways:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 库提供了许多方便的绘图方法。简单调用 `DataFrame.plot()` 或 `Series.plot()` 默认将生成折线图。你可以通过两种方式更改图表的类型：
- en: Using the `kind` argument in the `plot` method as in`.plot(kind=“<charttype>“)`
    to specify the type of plot by replacing `<charttype>` with a chart type. For
    example, `.plot(kind=“hist”)` will plot a histogram while `.plot(kind=“bar”)`
    will produce a bar plot.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`plot`方法中的`kind`参数，如`.plot(kind=“<charttype>”)`，通过替换`<charttype>`为图表类型来指定绘图类型。例如，`.plot(kind=“hist”)`将绘制一个直方图，而`.plot(kind=“bar”)`将绘制柱状图。
- en: Alternatively, you can extendthe `plot` method. This can be achieved by chaining
    a specific plot function, such as `.hist()` or `.scatter()`, for example, using
    `.plot.hist()` or `.plot.line()`.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以扩展`plot`方法。这可以通过链式调用特定的绘图函数来实现，例如`.hist()`或`.scatter()`，比如使用`.plot.hist()`或`.plot.line()`。
- en: This recipe will use the standard pandas `.plot()` method with Matplotlib backend
    support.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方将使用标准的 pandas `.plot()` 方法，并支持 Matplotlib 后端。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download the Jupyter notebooks and datasets needed from the GitHub repository.
    Please refer to the *Technical requirements* section of this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 GitHub 仓库下载所需的 Jupyter 笔记本和数据集。请参考本章节的*技术要求*部分。
- en: You will be using the `Closing Price Stock` dataset for Microsoft, Apple, and
    IBM, which you can find in the `closing_price.csv` file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 Microsoft、Apple 和 IBM 的`Closing Price Stock`数据集，数据文件为`closing_price.csv`。
- en: How to do it…
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, you will explore how to plot time series data, change themes,
    produce subplots, and customize the output visualization:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将探索如何绘制时间序列数据、改变主题、生成子图以及自定义输出的可视化效果：
- en: 'Plotting in pandas can be done by simply adding `.plot()` to the end of the
    DataFrame or Series name:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 pandas 中绘图可以通过简单地在 DataFrame 或 Series 名称后添加`.plot()`来实现：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will produce a line plot, which is the default option for the `kind` parameter,
    which looks like `.plot(kind=“line”)`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一张线性图，它是`kind`参数的默认选项，类似于`.plot(kind=“line”)`：
- en: '![Figure 9.1: Multiline time series plot using pandas](img/file110.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1：使用 pandas 绘制的多线时间序列图](img/file110.png)'
- en: 'Figure 9.1: Multiline time series plot using pandas'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：使用 pandas 绘制的多线时间序列图
- en: 'You can customize the plot further by adding a title, update the axes labels,
    and customizing the *x* ticks and *y* ticks, to name a few. To add a title to
    the plot and update the y-axis label use the `title` and `ylabel` parameters as
    shown:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加标题、更新轴标签以及自定义 *x* 和 *y* 轴刻度等方式进一步自定义图表。例如，添加标题和更新 y 轴标签，可以使用`title`和`ylabel`参数，如下所示：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want to see how the prices fluctuate (up or down) in comparison to each
    other, one easy approach is to **normalize** the data. To accomplish this, just
    divide the stock prices by the first-day price (first row) for each stock. This
    will make all the stocks have the same starting point:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想看看价格之间的波动（上下浮动），一种简单的方法是**标准化**数据。为此，只需将每个股票的股价除以第一天的价格（第一行）。这将使所有股票具有相同的起点：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This would produce the following plot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成如下图表：
- en: '![Figure 9.2: Using a simple normalizing technique to make it visually easier
    to compare price fluctuations](img/file111.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2：使用简单的标准化技术，使得价格波动更加直观易比对](img/file111.jpg)'
- en: 'Figure 9.2: Using a simple normalizing technique to make it visually easier
    to compare price fluctuations'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：使用简单的标准化技术，使得价格波动更加直观易比对
- en: 'From the output, you can observe that the lines now have the same starting
    point (origin), set to `1`. The plot shows how the prices in the time series plot
    deviate from each other:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以观察到，现在这些线条的起点（原点）已经设置为`1`。图表显示了时间序列图中价格之间的偏差：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice that the first row from the output table is set to `1.0`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出表格的第一行已设置为`1.0`：
- en: '![Figure 9.3: Output of normalized time series with a common starting point
    at 1](img/file112.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3：标准化时间序列输出，所有序列的起点为 1](img/file112.jpg)'
- en: 'Figure 9.3: Output of normalized time series with a common starting point at
    1'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：标准化时间序列输出，所有序列的起点为 1
- en: 'Additionally, Matplotlib allows you to change the style of the plots. To do
    that, you can use the `style.use()` function. You can specify a style name from
    an existing template or use a custom style. For example, the following code shows
    how you can change from the `default` style to the `ggplot` style:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，Matplotlib 允许你更改图表的样式。为此，你可以使用`style.use()`函数。你可以从现有模板中指定一个样式名称，或者使用自定义样式。例如，以下代码展示了如何从`default`样式切换到`ggplot`样式：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code should produce the same plot in terms of data content but
    a different style.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码应该生成相同数据内容的图表，但样式有所不同。
- en: '![Figure 9.4: Using the ggplot style from Matplotlib](img/file113.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4：使用来自 Matplotlib 的 ggplot 风格](img/file113.jpg)'
- en: 'Figure 9.4: Using the ggplot style from Matplotlib'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：使用来自 Matplotlib 的 ggplot 风格
- en: The `ggplot` style was inspired by the `ggplot2` package from **R**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ggplot` 风格的灵感来自于 **R** 中的 `ggplot2` 包。'
- en: 'You can explore other attractive styles: `fivethirtyeight`, which is inspired
    by **fivethirtyeight.com**, `dark_background`, `dark-background`, and `tableau-colorblind10`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以探索其他吸引人的样式：`fivethirtyeight`，灵感来自 **fivethirtyeight.com**，`dark_background`，`dark-background`，和
    `tableau-colorblind10`。
- en: 'For a comprehensive list of available style sheets, you can reference the Matplotlib
    documentation here: [https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html.](https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html.)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的样式表的完整列表，您可以参考 Matplotlib 文档：[https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html](https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html)
- en: If you want to revert to the original theme, you specify `plt.style.use("default")`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想恢复到原始主题，可以指定 `plt.style.use("default")`。
- en: 'You can save your plots as a jpeg, png, svg or other file types. For example,
    you can save your file as a `plot_1.jpg` file with `.savefig()` method and specify
    dpi to be at a higher resolution for printing quality. The default dpi is 100:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将您的图表保存为 jpeg、png、svg 或其他文件类型。例如，您可以使用 `.savefig()` 方法将文件保存为 `plot_1.jpg`
    文件，并指定更高的 dpi 分辨率以保证打印质量。默认的 dpi 值为 100：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The plot should be saved as a `plot_1.jpg` image file on your local directory.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图表应作为 `plot_1.jpg` 图像文件保存在您的本地目录中。
- en: How it works…
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: There is good collaboration between the pandas and Matplotlib libraries, with
    an ambition to integrate and add more plotting capabilities within pandas.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 和 Matplotlib 库之间的协作非常好，双方有着集成并在 pandas 中增加更多绘图功能的雄心。
- en: 'There are many plotting styles that you can use within pandas simply by providing
    a value to the `kind` argument. For example, you can specify the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pandas 中，您可以通过向 `kind` 参数提供一个值来使用多种绘图样式。例如，您可以指定以下内容：
- en: '`line` for line charts commonly used to display time series'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line` 用于常用于展示时间序列的折线图'
- en: '`bar` or `barh` (horizontal) for bar plots'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bar` 或 `barh`（水平）用于条形图'
- en: '`hist` for histogram plots'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hist` 用于直方图'
- en: '`box` for boxplots'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`box` 用于箱形图'
- en: '`kde` or `density` for kernel density estimation plots'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kde` 或 `density` 用于核密度估计图'
- en: '`area` for area plots'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`area` 用于面积图'
- en: '`pie` for pie plots'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pie` 用于饼图'
- en: '`scatter` for scatter plots'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scatter` 用于散点图'
- en: '`hexbin` for hexagonal bin plots'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hexbin` 用于六边形图'
- en: There's more…
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多……
- en: As observed in the previous section, we plotted all three columns in the time
    series in one plot (three line charts in the same plot). What if you want each
    symbol (column) plotted separately?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所示，我们将时间序列中的所有三列绘制在一个图中（同一图中的三条线图）。如果您希望每个符号（列）单独绘制呢？
- en: 'This can be done by simply changing the `subplots` parameter to `True`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过简单地将 `subplots` 参数设置为 `True` 来完成：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code will generate a subplot for each column in the DataFrame.
    Using the `closing_price` DataFrame, this will generate three subplots.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在 DataFrame 中为每一列生成一个子图。使用 `closing_price` DataFrame，这将生成三个子图。
- en: '![Figure 9.5: Using the pandas subplot feature](img/file114.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5：使用 pandas 子图功能](img/file114.jpg)'
- en: 'Figure 9.5: Using the pandas subplot feature'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5：使用 pandas 子图功能
- en: See also
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另见
- en: 'To learn more about pandas charting and plotting capabilities, please visit
    the official documentation here: [https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html](https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解更多有关 pandas 绘图和可视化的功能，请访问官方文档：[https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html](https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html)
- en: Plotting time series data with interactive visualizations using hvPlot
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 hvPlot 绘制时间序列数据并进行交互式可视化
- en: Interactive visualizations allow us to analyze data more efficiently compared
    to static visuals. Simple interactions, such as zooming in and out or slicing
    through the visual, can unearth additional insights for further investigation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式可视化比静态图像更高效地分析数据。简单的交互，例如放大缩小或切片操作，可以揭示出更多有价值的见解，供进一步调查。
- en: In this recipe, we will explore the **hvPlot** library to create interactive
    visualizations. HvPlot offers a high-level API for data visualization and integrates
    seamlessly with various data sources, including pandas, Xarray, Dask, Polars,
    NetworkX, Streamlit, and GeoPandas. Utilizing hvPlot with pandas for rendering
    interactive visualizations requires minimal effort, allowing you to create dynamic
    visualizations with few modifications to the original code. We will use the 'closing_price.csv'
    dataset to explore the capabilities of the library in this recipe.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将探索 **hvPlot** 库来创建交互式可视化。HvPlot 提供了一个高级 API 用于数据可视化，并且与多种数据源无缝集成，包括
    pandas、Xarray、Dask、Polars、NetworkX、Streamlit 和 GeoPandas。利用 hvPlot 和 pandas 渲染交互式可视化需要最少的工作量，只需对原始代码做少量修改，就能创建动态可视化。我们将使用
    'closing_price.csv' 数据集来探索该库在本食谱中的应用。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download the Jupyter notebooks and datasets needed from the GitHub repository.
    Please refer to the *Technical requirements* section of this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 GitHub 仓库下载所需的 Jupyter 笔记本和数据集。请参阅本章的 *技术要求* 部分。
- en: How to do it…
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Start by importing the libraries needed. Notice that hvPlot has a pandas extension,
    which makes it more convenient. This will allow you to use the same syntax as
    in the previous recipe:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入所需的库。注意，hvPlot 有一个 pandas 扩展，使得使用更为方便。这将允许你使用与前面示例相同的语法：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When plotting using pandas, you would use the `.plot()` method, for example,
    `closing_price_n.plot()`. Similarly, hvPlot allows you to render an interactive
    plot simply by substituting `.plot()` with `.hvplot()`. This can be useful if
    you have a dense chart in terms of content. You can zoom in to a specific portion
    of the chart and then, with the panning feature, move to different portions of
    the chart:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pandas 绘图时，你会使用 `.plot()` 方法，例如，`closing_price_n.plot()`。类似地，hvPlot 允许你通过将
    `.plot()` 替换为 `.hvplot()` 来渲染交互式图表。如果你有内容密集的图表，这非常有用。你可以缩放到图表的特定部分，然后使用平移功能移动到图表的不同部分：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By substituting `.plot` with `.hvplot`, you get an interactive visualization
    with a hover effect:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `.plot` 替换为 `.hvplot`，你可以获得一个带有悬停效果的交互式可视化：
- en: '![Figure 9.6: hvPlot interactive visualization](img/file115.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6：hvPlot 交互式可视化](img/file115.png)'
- en: 'Figure 9.6: hvPlot interactive visualization'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：hvPlot 交互式可视化
- en: 'The same result could be accomplished simply by switching the pandas plotting
    backend. The default backend is `matplotlib`. To switch it to hvPlot, you can
    just update `backend=''hvplot''`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的结果可以通过简单地切换 pandas 绘图后端来实现。默认后端是 `matplotlib`。要切换到 hvPlot，只需更新 `backend='hvplot'`：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This should produce the same plot as in *Figure 9.6*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成与*图 9.6*相同的图表。
- en: Notice the widget bar to the right, which has a set of modes for interaction,
    including pan, box zoom, wheel zoom, save, reset, and hover.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意右侧的小部件栏，其中包含一组交互模式，包括平移、框选缩放、滚轮缩放、保存、重置和悬停。
- en: '![Figure 9.7: Widget bar with six modes of interaction](img/file116.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7：带有六种交互模式的小部件栏](img/file116.jpg)'
- en: 'Figure 9.7: Widget bar with six modes of interaction'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：带有六种交互模式的小部件栏
- en: 'You can split each time series into separate plots per symbol (column). For
    example, to split into three columns one for each symbol (or ticker): MSFT, AAPL,
    and IBM. **Subplotting** can be done by specifying `subplots=True`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以将每个时间序列按符号（列）分割成独立的图表。例如，将数据分为三列，每列对应一个符号（或股票代码）：MSFT、AAPL 和 IBM。**子图**可以通过指定
    `subplots=True` 来完成：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This should produce a subplot for each column:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成每列一个子图：
- en: '![Figure 9.8: hvPlot subplot example](img/file117.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8：hvPlot 子图示例](img/file117.png)'
- en: 'Figure 9.8: hvPlot subplot example'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：hvPlot 子图示例
- en: 'You can use the `.cols()` method for more control over the layout. The method
    allows you to control the number of plots per row. For example, `.cols(1)` means
    one plot per row, whereas `.cols(2)` indicates two plots per line:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `.cols()` 方法来更精确地控制布局。该方法允许你控制每行显示的图表数量。例如，`.cols(1)` 表示每行一个图表，而 `.cols(2)`
    表示每行两个图表：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should produce a figure with two subplots in the first row and the third
    subplot on the second row, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个图表，第一行有两个子图，第二行有第三个子图，如下所示：
- en: '![Figure 9.9: Example hvPlot with two columns per row using .col(2)](img/file118.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9：使用 .col(2) 每行两个列的示例 hvPlot](img/file118.png)'
- en: 'Figure 9.9: Example hvPlot with two columns per row using .col(2)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9：使用 .col(2) 每行两个列的示例 hvPlot
- en: Keep in mind that the `.cols()` method only works if the `subplots` parameter
    is set to `True`. Otherwise, you will get an error.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`.cols()` 方法仅在 `subplots` 参数设置为 `True` 时有效，否则会导致错误。
- en: How it works…
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Given the widespread use of pandas, it's notable that many libraries now integrate
    with pandas DataFrames and Series as inputs. Additionally, the integration between
    Matplotlib and hvPlot simplifies the process of changing the plotting engine used
    with pandas.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 pandas 被广泛使用，许多库现在都支持将 pandas DataFrame 和 Series 作为输入。此外，Matplotlib 和 hvPlot
    之间的集成简化了与 pandas 一起使用的绘图引擎的更换过程。
- en: 'HvPlot provides several convenient options for plotting your DataFrame: you
    can switch the backend easily, extend pandas functionality using `DataFrame.hvplot()`,
    or leverage hvPlot''s native API for more advanced visualizations.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: HvPlot 提供了几种方便的选项来绘制你的 DataFrame：你可以轻松切换后端，使用 `DataFrame.hvplot()` 扩展 pandas
    功能，或利用 hvPlot 的原生 API 进行更高级的可视化。
- en: There's more…
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: hvPlot allows you to use two arithmetic operators, `+` and `*`, to configure
    the layout of the plots.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: hvPlot 允许你使用两个算术运算符，`+` 和 `*`，来配置图表的布局。
- en: 'The plus sign (`+`) allows you to add two charts side by side, while multiply
    (`*`) will enable you to combine charts (merge one graph with another). In the
    following example, we will add two plots, so they are aligned side by side on
    the same row:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 加号 (`+`) 允许你将两个图表并排显示，而乘号 (`*`) 则使你能够合并图表（将一个图表与另一个合并）。在以下示例中，我们将两个图表相加，使它们在同一行上并排显示：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This should produce what is shown in the following figure:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成如下图所示的结果：
- en: '![Figure 9.10: Two plots side by side using the addition operator](img/file119.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10：使用加法运算符并排显示两个图表](img/file119.png)'
- en: 'Figure 9.10: Two plots side by side using the addition operator'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10：使用加法运算符并排显示两个图表
- en: Notice that the two plots will share the same widget bar. If you filter or zoom
    into one of the charts, the other chart will have the same action applied.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个图表将共享同一个小部件条。如果你对一个图表进行筛选或缩放，另一个图表将应用相同的操作。
- en: 'Now, let''s see how multiplication will combine the two plots into one:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何通过乘法将两个图表合并成一个：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code should produce one plot that combines both AAPL and MSFT:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应该生成一个结合了 AAPL 和 MSFT 的图表：
- en: '![Figure 9.11: Two plots combined into one using the multiplication operator](img/file120.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11：使用乘法运算符将两个图表合并为一个](img/file120.png)'
- en: 'Figure 9.11: Two plots combined into one using the multiplication operator'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11：使用乘法运算符将两个图表合并为一个
- en: 'Lastly, to create subgroups (akin to a ''group by'' operation) where each group
    is represented by a different color, you can use the by parameter as demonstrated
    below:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了创建子组（类似于 "group by" 操作），其中每个组由不同的颜色表示，你可以使用下方演示的 `by` 参数：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code generates a line chart, as expected, segmented by year (grouped by)
    as shown in Figure 9.12:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了一个如预期的折线图，并按年份分段（分组显示），如图 9.12 所示：
- en: '![Figure 9.12: Line chart with subgroups (by year).](img/file121.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12：按子组（按年份）绘制的折线图](img/file121.png)'
- en: 'Figure 9.12: Line chart with subgroups (by year).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12：按子组（按年份）绘制的折线图。
- en: Given that we have data spanning three years, you will observe three distinct
    colors on the chart, each corresponding to a different year, as indicated by the
    legend.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们的数据涵盖了三年，你将在图表中看到三种不同的颜色，每种颜色对应不同的年份，如图例所示。
- en: See also
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information on hvPlot, please visit their official page here: [https://hvplot.holoviz.org/](https://hvplot.holoviz.org/).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 hvPlot 的更多信息，请访问其官方网站：[https://hvplot.holoviz.org/](https://hvplot.holoviz.org/)。
- en: Decomposing time series data
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间序列数据的分解
- en: When conducting time series analysis, one key objective often involves forecasting,
    where you build a model capable of making future predictions. Before starting
    the modeling process, it is crucial to extract the components of the time series
    for analysis. This step is essential for making informed decisions throughout
    the modeling process.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行时间序列分析时，一个关键目标通常是预测，即构建一个能够做出未来预测的模型。在开始建模过程之前，至关重要的一步是提取时间序列的各个组成部分进行分析。这个步骤对整个建模过程中的决策至关重要。
- en: 'A time series typically comprises of **three** main components: trend, seasonality,
    and the residual random process. For statistical models that require the time
    series to be stationary, estimating and subsequently removing the trend and seasonality
    components from the time series might be necessary. Techniques and libraries for
    time series decomposition generally provide visual representations and identification
    of the trend, seasonality, and the residual random process.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个时间序列通常由**三个**主要组成部分构成：趋势、季节性和残差随机过程。对于需要时间序列平稳的统计模型，可能需要估计并随之去除时间序列中的趋势和季节性成分。时间序列分解的技术和库通常提供趋势、季节性和残差随机过程的可视化表示和识别。
- en: The **trend** component reflects the long-term direction of the time series,
    which can be upward, downward, or horizontal. For instance, a sales data time
    series might exhibit an upward trend, indicating increasing sales over time. **Seasonality**
    refers to patterns that repeat over specific intervals, such as an annual increase
    in sales around Christmas, a pattern that recurs each year as the holiday season
    approaches. The **residual** random process represents the portion of the time
    series that remains once the trend and seasonality have been extracted, encompassing
    the unexplained variability in the data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**趋势**成分反映了时间序列的长期方向，可能是向上、向下或水平的。例如，销售数据的时间序列可能显示出向上的趋势，表明销售随着时间的推移在增加。**季节性**是指在特定间隔内重复出现的模式，例如每年圣诞节前后的销售增长，这是一个随着假日季节的临近每年都会出现的模式。**残差**随机过程表示在去除趋势和季节性后，时间序列中剩余的部分，包含了数据中无法解释的变动性。'
- en: The **decomposition** of a time series is the process of separating it into
    the three components and estimating the trend and seasonality components as their
    respective models. The modeling of the decomposed components can be either **additive**
    or **multiplicative** depending on the nature of the interaction between the components.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列的**分解**是将其分离为三个组成部分的过程，并将趋势和季节性成分作为各自的模型来估计。分解后的组成部分可以根据它们之间的交互性质进行**加法**或**乘法**建模。
- en: 'When you have an *additive* model the original time series can be reconstructed
    by adding all three components together:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用*加法*模型时，可以通过将所有三个组成部分相加来重建原始时间序列：
- en: '![](img/file122.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file122.jpg)'
- en: 'An additive decomposition model is reasonable when the seasonal variations
    do not change over time. On the other hand, if the time series can be reconstructed
    by multiplying all three components, you have a *multiplicative* model:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当季节性变化不随时间变化时，加法分解模型是合理的。另一方面，如果时间序列可以通过将这三部分相乘来重建，则使用*乘法*模型：
- en: '![](img/file123.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file123.jpg)'
- en: A *multiplicative* model is suitable when the seasonal variation fluctuates
    over time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当季节性变化随时间波动时，使用*乘法*模型是合适的。
- en: Furthermore, you can group these into predictable versus non-predictable components.
    Predictable components are consistent, repeating patterns that can be captured
    and modeled. Seasonality and trend are examples. On the other hand, every time
    series has an unpredictable component that shows irregularity, often called **noise**,
    though it is referred to as **residual** in the context of decomposition.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以将这些成分分为可预测与不可预测的成分。可预测成分是稳定的、重复的模式，可以被捕捉和建模。季节性和趋势就是其中的例子。另一方面，每个时间序列都有一个不可预测的成分，它表现出不规则性，通常称为**噪声**，但在分解的上下文中被称为**残差**。
- en: In this recipe, you will explore different techniques for **decomposing** your
    time series using the `seasonal_decompose`, **Seasonal-Trend decomposition with
    LOESS** (`STL`), and `hp_filter` methods available in the `statsmodels` library.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，你将探索使用`seasonal_decompose`、**季节-趋势分解（LOESS）**（`STL`）和`hp_filter`方法来分解时间序列，这些方法在`statsmodels`库中可用。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download the Jupyter notebooks and datasets needed from the GitHub repository.
    Please refer to the *Technical requirements* section of this chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从GitHub仓库下载所需的Jupyter笔记本和数据集。请参考本章节中的*技术要求*部分。
- en: How to do it…
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'You will explore two methods available in the statsmodels library: seasonal_decompose
    and STL.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你将探索在statsmodels库中提供的两种方法：seasonal_decompose和STL。
- en: Using seasonal_decompose
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用seasonal_decompose
- en: The `seasonal_decompose` function relies on moving average to decompose a time
    series. You will be working with the CO2 and Air Passenger datasets from the *Technical
    requirements* section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`seasonal_decompose`函数依赖于移动平均法来分解时间序列。你将使用*技术要求*部分中的CO2和航空乘客数据集。'
- en: 'Import the libraries needed and set `rcParams` for the visuals to make them
    large enough. Generally, plots produced by statsmodels are small. You can fix
    this by adjusting `rcParams` for `figure.figsize` to apply for all the plots in
    this recipe:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库并设置`rcParams`，使可视化图表足够大。通常，statsmodels生成的图表较小。你可以通过调整`rcParams`中的`figure.figsize`来修复这个问题，使本食谱中的所有图表都应用相同的大小：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will make all the charts in the notebook the same size: width at 10 inches
    and height at 3 inches (*W x H*).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使所有图表的大小一致：宽度为10英寸，高度为3英寸（*W x H*）。
- en: You can apply a style such as the grayscale theme
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以应用诸如灰度主题之类的样式
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can decompose both datasets using the `seasonal_decompose()` function.
    But before doing so, you should plot your time series to understand whether the
    seasonality shows *multiplicative* or *additive* behavior:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用`seasonal_decompose()`函数分解这两个数据集。但在此之前，你应该绘制你的时间序列，以了解季节性是否表现出*乘法*或*加法*特征：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This should display a line chart showing weekly carbon dioxide levels measured
    in **parts per million** (**ppm**) from 1960 to 2000\. When using the `.plot()`
    method, the default chart type is a line chart with the `kind="line"` parameter.
    For more information about pandas' plotting capabilities, refer to the *Plotting
    time series data using pandas recipe*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会显示一张显示1960年到2000年每周二氧化碳水平的线图，单位为**百万分之一**（**ppm**）。使用`.plot()`方法时，默认的图表类型是线图，参数为`kind="line"`。关于pandas绘图功能的更多信息，请参考*使用pandas绘制时间序列数据的食谱*。
- en: '![Figure 9.13: The CO2 dataset showing an upward trend and constant seasonal
    variation](img/file124.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13：显示上升趋势和恒定季节性变化的CO2数据集](img/file124.png)'
- en: 'Figure 9.13: The CO2 dataset showing an upward trend and constant seasonal
    variation'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13：显示上升趋势和恒定季节性变化的CO2数据集
- en: The `co2_df` data shows a long-term linear trend (upward), with a repeated seasonal
    pattern at a constant rate (seasonal variation). This indicates that the CO2 dataset
    is an additive model.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`co2_df`数据展示了一个长期的线性趋势（向上），并且有一个以恒定速率重复的季节性模式（季节性变化）。这表明CO2数据集是一个加法模型。'
- en: 'Similarly, you can explore the `airp_df` DataFrame for the Air Passengers dataset
    to observe whether the seasonality shows *multiplicative* or *additive* behavior:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以探索`airp_df`数据框，观察航空乘客数据集中的季节性是否表现为*乘法*或*加法*行为：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This should produce a line chart showing the number of passengers per month
    from 1949 to 1960:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成一张显示1949年至1960年每月乘客数量的线图：
- en: '![Figure 9.14: The Air Passengers dataset showing trend and increasing seasonal
    variation](img/file125.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14：显示趋势和逐渐增加的季节性变化的航空乘客数据集](img/file125.png)'
- en: 'Figure 9.14: The Air Passengers dataset showing trend and increasing seasonal
    variation'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14：显示趋势和逐渐增加的季节性变化的航空乘客数据集
- en: The `airp_df` data shows a long-term linear trend and seasonality (upward).
    However, the seasonality fluctuations seem to be increasing as well, indicating
    a multiplicative model.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`airp_df`数据展示了一个长期的线性趋势和季节性变化（向上）。然而，季节性波动似乎也在增加，这表明是一个乘法模型。'
- en: 'Use `seasonal_decompose` on the two datasets. For the CO2 data, use an additive
    model and a multiplicative model for the air passenger data:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对这两个数据集使用`seasonal_decompose`。对于CO2数据，使用加法模型，而对于航空乘客数据，使用乘法模型：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Both `co2_decomposed` and `air_decomposed` have access to several methods,
    including `.trend`, `.seasonal`, and `.resid`. You can plot all three components
    by using the `.plot()` method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`co2_decomposed`和`air_decomposed`都可以访问几种方法，包括`.trend`、`.seasonal`和`.resid`。你可以通过使用`.plot()`方法绘制所有三个组成部分：'
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following plot is the result:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果图：
- en: '![Figure 9.15: Air Passengers multiplicative decomposed into trend, seasonality,
    and residual](img/file126.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15：航空乘客的乘法分解为趋势、季节性和残差](img/file126.png)'
- en: 'Figure 9.15: Air Passengers multiplicative decomposed into trend, seasonality,
    and residual'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15：航空乘客的乘法分解为趋势、季节性和残差
- en: 'Let''s break down the resulting plot into four parts:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将结果图分解成四个部分：
- en: This is the original observed data that we are decomposing.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们正在分解的原始观察数据。
- en: The *trend* component shows an upward direction. The trend indicates whether
    there is positive (increasing or upward), negative (decreasing or downward), or
    constant (no trend or horizontal) long-term movement.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*趋势*组件显示出上升的方向。趋势指示是否存在正向（增加或上升）、负向（减少或下降）或恒定（没有趋势或水平）长期运动。'
- en: The *seasonal* component shows the seasonality effect in terms of a repeating
    pattern of highs and lows.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*季节性*组件显示季节性效应，表现为高低交替的重复模式。'
- en: Finally, the *residual* (sometimes called *noise*) component shows the random
    variation in the data after removing trend and seasonality. In this case, a multiplicative
    model was used.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，*残差*（有时称为*噪声*）组件显示去除趋势和季节性后的数据中的随机变化。在这种情况下，使用了乘法模型。
- en: 'Similarly, you can plot the decomposition of the CO2 dataset:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以绘制CO2数据集的分解图：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This should produce the following plots:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成以下图形：
- en: '![Figure 9.16: CO2 additive decomposition into trend, seasonality, and residual](img/file127.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16：CO2 加性分解为趋势、季节性和残差](img/file127.png)'
- en: 'Figure 9.16: CO2 additive decomposition into trend, seasonality, and residual'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16：CO2 加性分解为趋势、季节性和残差
- en: When reconstructing the time series, for example, in a multiplicative model,
    you will be multiplying the three components. To demonstrate this concept, use
    `air_decomposed`, an instance of the `DecomposeResult` class. The class provides
    the `seasonal`, `trend`, and `resid` attributes as well as the `.plot()` method.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重建时间序列时，例如，在乘法模型中，你将会将三个组件相乘。为了演示这一概念，使用`air_decomposed`，这是`DecomposeResult`类的一个实例。该类提供了`seasonal`、`trend`和`resid`属性以及`.plot()`方法。
- en: 'In the following code, you can multiply the components to reconstruct the time
    series:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，你可以将这些组件相乘来重建时间序列：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It gives the following plot as output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它输出如下图：
- en: '![Figure 9.17: Reconstructing the Air Passengers time series dataset](img/file128.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17：重建航空乘客时间序列数据集](img/file128.png)'
- en: 'Figure 9.17: Reconstructing the Air Passengers time series dataset'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17：重建航空乘客时间序列数据集
- en: Using STL
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 STL
- en: Another decomposition option within `statsmodels` is **STL**. STL Stands for
    *Seasonal-Trend decomposition using LOESS* which is a more advanced decomposition
    technique. In statsmodels, the `STL` class requires additional parameters than
    the `seasonal_decompose` function. The two other parameters you will use are `seasonal`
    and `robust`. The `seasonal` parameter is for the seasonal smoother and can *only
    take odd integer values greater than or equal to 7*. Similarly, the `STL` function
    has a trend smoother (the `trend` parameter).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在`statsmodels`中的分解选项是**STL**。STL代表*使用LOESS的季节性-趋势分解*，这是一种更先进的分解技术。在`statsmodels`中，`STL`类比`seasonal_decompose`函数需要更多的参数。你将使用的另外两个参数是`seasonal`和`robust`。`seasonal`参数用于季节性平滑器，并且*只能接受大于或等于7的奇数整数值*。同样，`STL`函数有一个趋势平滑器（`trend`参数）。
- en: The second parameter is `robust`, which takes a Boolean value (`True` or `False`).
    Setting `robust=True` helps remove the impact of outliers on seasonal and trend
    components when calculated.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是`robust`，它接受一个布尔值（`True` 或 `False`）。设置`robust=True`有助于消除异常值对季节性和趋势组件的影响。
- en: 'You will use `STL` to decompose the `co2_df` DataFrame:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将使用`STL`来分解`co2_df`数据框：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This should produce similar subplots to the `seasonal_decompose` function,
    showing the trend, seasonality, and residuals:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成与`seasonal_decompose`函数类似的子图，显示趋势、季节性和残差：
- en: '![Figure 9.18: Decomposing the CO2 dataset with STL](img/file129.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.18：使用 STL 分解 CO2 数据集](img/file129.png)'
- en: 'Figure 9.18: Decomposing the CO2 dataset with STL'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18：使用 STL 分解 CO2 数据集
- en: Compare the output in `Figure 9.16` to that in `Figure 9.18`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 比较`图 9.16`中的输出与`图 9.18`中的输出。
- en: Notice when you used `STL`, you provided `seasonal=13` because the data has
    an annual seasonal effect. The seasonal argument takes only odd integers that
    are greater than or equal to 7.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当你使用`STL`时，你提供了`seasonal=13`，因为数据具有年度季节性效应。季节性参数仅接受大于或等于7的奇数整数。
- en: 'Both seasonal decomposition and STL produce an instance of DecomposeResult
    class which gives you access to residuals directly. You can compare the residuals
    from seasonal decomposition and STL from resid as shown:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 季节性分解和STL都生成`DecomposeResult`类的实例，可以直接访问残差。你可以比较`seasonal_decompose`和STL的残差，如下所示：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This should produce the following figure with two plots
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成如下图，包含两个子图
- en: '![Figure 9.19: Comparing residual plots from seasonal decomposition and STL](img/file130.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.19：比较季节分解与 STL 的残差图](img/file130.png)'
- en: 'Figure 9.19: Comparing residual plots from seasonal decomposition and STL'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19：比较季节分解与 STL 的残差图
- en: You will notice that the residual plots look different, indicating that both
    methods capture similar information using distinct mechanisms.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，残差图看起来不同，这表明两种方法使用不同的机制捕获了相似的信息。
- en: How it works…
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: You used two different approaches for time series decomposition. Both methods
    decompose a time series into trend, seasonal, and residual components.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了两种不同的时间序列分解方法。这两种方法都将时间序列分解为趋势、季节性和残差成分。
- en: The `STL` class uses the **LOESS** seasonal smoother, which stands for **Locally
    Estimated Scatterplot Smoothing**. `STL` is more robust than `seasonal_decompose`
    for measuring non-linear relationships. On the other hand, `STL` assumes additive
    composition, so you do not need to indicate a model, unlike with `seasonal_decompose`.
    Both approaches can extract seasonality from time series to better observe the
    overall trend in the data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`STL` 类使用 **LOESS** 季节性平滑器，代表的是 **局部加权散点图平滑**。与 `seasonal_decompose` 相比，`STL`
    在测量非线性关系方面更加稳健。另一方面，`STL` 假设成分是加性组合的，因此你不需要像 `seasonal_decompose` 那样指定模型。两种方法都可以从时间序列中提取季节性，以更好地观察数据的整体趋势。'
- en: 'The `seasonal_decompose` function performs the following *simplified* logic:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`seasonal_decompose` 函数执行以下 *简化* 逻辑：'
- en: Smooth the time series data to observe the trend. This is achieved by applying
    a convolution filter to estimate the trend.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对时间序列数据进行平滑处理，以观察趋势。这是通过应用卷积滤波器来估计趋势。
- en: Once the trend is estimated, it is then removed from the time series (de-trended).
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦趋势被估计出来，它就会从时间序列中被移除（去趋势）。
- en: The remaining de-trended time series is then averaged for each period or seasonal
    group. The seasonal averaging takes all data values in the time series corresponding
    to each season and averages them (for example, we take every January from each
    year and average that).
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩下的去趋势时间序列会根据每个周期或季节组进行平均。季节性平均会将时间序列中对应每个季节的所有数据值取平均（例如，我们取每年的每个一月并对其进行平均）。
- en: Once the seasonal component is estimated, it is then removed, and you are left
    with the residuals.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦季节性成分被估计出来，它就会被移除，剩下的就是残差。
- en: 'The `STL` function performs the following *simplified* logic:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`STL` 函数执行以下 *简化* 逻辑：'
- en: Similar to `seasonal_decompose`, the time series is smoothed to estimate the
    trend, but in STL, this is done using LOESS smoothing.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于 `seasonal_decompose`，时间序列通过平滑处理来估计趋势，但在 STL 中，这一过程是通过 LOESS 平滑来实现的。
- en: Once the trend is estimated, it is then removed from the time series (de-trended).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦趋势被估计出来，它就会从时间序列中被移除（去趋势）。
- en: For the seasonal component, STL applies Loess smoothing to the de-trended data,
    but separately for each season.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于季节性成分，STL 对去趋势后的数据应用了 Loess 平滑，但每个季节单独处理。
- en: Once the seasonal component is estimated, it is then removed, and you are left
    with the residuals.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦季节性成分被估计出来，它就会被移除，剩下的就是残差。
- en: There's more…
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多……
- en: The **Hodrick-Prescott filter** is a smoothing filter that can be used to separate
    short-term fluctuations (cyclic variations) from long-term trends. This is implemented
    as `hp_filter` in the statsmodels library.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**霍德里克-普雷斯科特滤波器** 是一种平滑滤波器，用于将短期波动（周期变化）与长期趋势分离。它在 statsmodels 库中实现为 `hp_filter`。'
- en: 'Recall that `STL` and `seasonal_decompose` returned three components (trend,
    seasonal, and residual). On the other hand, `hp_filter` returns only two components:
    a **cyclical component** and a **trend component**.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，`STL` 和 `seasonal_decompose` 返回了三个成分（趋势、季节性和残差）。另一方面，`hp_filter` 只返回两个成分：**周期成分**和**趋势成分**。
- en: 'Start by importing the `hpfilter` function from the statsmodels library:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先从 statsmodels 库中导入 `hpfilter` 函数：
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To decompose your time series into trend and cyclical components simply provide
    your time series DataFrame to the `hpfilter` function as shown:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的时间序列分解为趋势和周期成分，只需将你的时间序列 DataFrame 提供给 `hpfilter` 函数，如下所示：
- en: '[PRE30]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `hpfilter` function returns two pandas Series: the first Series is for
    the cycle and the second Series is for the trend. Plot `co2_cyclic` and `co2_trend`
    side by side to gain a better idea of what information the Hodrick-Prescott filter
    was able to extract from the data:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`hpfilter` 函数返回两个 pandas Series：第一个 Series 是周期成分，第二个 Series 是趋势成分。将 `co2_cyclic`
    和 `co2_trend` 并排绘制，以便更好地理解霍德里克-普雷斯科特滤波器从数据中提取了哪些信息：'
- en: '[PRE31]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This should produce two subplots on the same row (side by side), as shown:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在同一行中产生两个子图（并排显示），如所示：
- en: '![Figure 9.20: Cyclical and trend components using the Hedrick-Prescott filter](img/file131.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.20：使用赫德里克-普雷斯科特滤波器的周期性和趋势成分](img/file131.png)'
- en: 'Figure 9.20: Cyclical and trend components using the Hedrick-Prescott filter'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.20：使用赫德里克-普雷斯科特滤波器的周期性和趋势成分
- en: Note that the two components from `hpfilter` are **additive**. In other words,
    to reconstruct the original time series, you would add `co2_cyclic` and `co2_trend`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`hpfilter` 得到的两个成分是**加性**的。换句话说，要重构原始时间序列，你需要将 `co2_cyclic` 和 `co2_trend`
    相加。
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![Figure 9.21: Reconstructing the CO2 dataset from the trend and cyclical components
    given by hpfilter function](img/file132.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.21：从 `hpfilter` 函数给出的趋势和周期成分重构 CO2 数据集](img/file132.png)'
- en: 'Figure 9.21: Reconstructing the CO2 dataset from the trend and cyclical components
    given by hpfilter function'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21：从 `hpfilter` 函数给出的趋势和周期成分重构 CO2 数据集
- en: You can compare the reconstructed CO2 plot form the trend and cyclical components
    in Figure 9.21 with the original CO2 plot in Figure 9.13.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将图 9.21 中从趋势和周期性成分重构的 CO2 图与图 9.13 中的原始 CO2 图进行比较。
- en: See also
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另见
- en: 'To learn more about `hpfilter(),` please visit the official documentation page
    here: [https://www.statsmodels.org/dev/generated/statsmodels.tsa.filters.hp_filter.hpfilter.html#statsmodels.tsa.filters.hp_filter.hpfilter](https://www.statsmodels.org/dev/generated/statsmodels.tsa.filters.hp_filter.hpfilter.html#statsmodels.tsa.filters.hp_filter.hpfilter).'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于`hpfilter()`的信息，请访问官方文档页面：[https://www.statsmodels.org/dev/generated/statsmodels.tsa.filters.hp_filter.hpfilter.html#statsmodels.tsa.filters.hp_filter.hpfilter](https://www.statsmodels.org/dev/generated/statsmodels.tsa.filters.hp_filter.hpfilter.html#statsmodels.tsa.filters.hp_filter.hpfilter)。
- en: 'To learn more about `seasonal_decompose(),` please visit the official documentation
    page here: [https://www.statsmodels.org/dev/generated/statsmodels.tsa.seasonal.seasonal_decompose.html](https://www.statsmodels.org/dev/generated/statsmodels.tsa.seasonal.seasonal_decompose.html).'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于`seasonal_decompose()`的信息，请访问官方文档页面：[https://www.statsmodels.org/dev/generated/statsmodels.tsa.seasonal.seasonal_decompose.html](https://www.statsmodels.org/dev/generated/statsmodels.tsa.seasonal.seasonal_decompose.html)。
- en: 'To learn more about `STL(),` please visit the official documentation page here:
    [https://www.statsmodels.org/dev/generated/statsmodels.tsa.seasonal.STL.html#statsmodels.tsa.seasonal.STL](https://www.statsmodels.org/dev/generated/statsmodels.tsa.seasonal.STL.html#statsmodels.tsa.seasonal.STL).'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于`STL()`的信息，请访问官方文档页面：[https://www.statsmodels.org/dev/generated/statsmodels.tsa.seasonal.STL.html#statsmodels.tsa.seasonal.STL](https://www.statsmodels.org/dev/generated/statsmodels.tsa.seasonal.STL.html#statsmodels.tsa.seasonal.STL)。
- en: Detecting time series stationarity
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测时间序列的平稳性
- en: Several time series forecasting techniques assume a **stationary time** series
    process. Thus, it is crucial to determine whether the time series you are working
    with (the observed time series or the realization that you have) originates from
    a **stationary** or **non-stationary** process.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一些时间序列预测技术假设时间序列过程是**平稳的**。因此，确定你正在处理的时间序列（无论是观察到的时间序列还是你所拥有的实现）是否来源于**平稳**或**非平稳**过程是至关重要的。
- en: A stationary time series suggests that specific statistical properties do not
    change over time and remain steady, making the processes easier to model and predict.
    Conversely, a non-stationary process is more challenging to model due to its dynamic
    nature and variations over time (for example, in the presence of trend or seasonality).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一个平稳的时间序列表明特定的统计性质随时间不会发生变化，保持稳定，这使得建模和预测过程更加容易。相反，非平稳过程由于其动态特性和随时间的变化（例如，存在趋势或季节性）更难建模。
- en: There are different approaches for defining stationarity; some are strict and
    may not be observable in real-world data, referred to as **strong stationarity**.
    In contrast, other definitions are more modest in their criteria and can be observed
    in real-world data (or transformed into), known as **weak stationarity**.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 定义平稳性的方式有多种；有些方法严格，可能在现实数据中无法观察到，称为**强平稳性**。与之相反，其他定义则在标准上更为宽松，能够在现实数据中观察到（或通过变换得到），称为**弱平稳性**。
- en: In this recipe, and for practical reasons, the term stationarity implies “weak”
    stationary defined as a time series with a constant mean called *mu* (), a constant
    variance called *sigma squared* (), and a consistent covariance (or autocorrelation)
    between identical distanced periods (*lags*). Having the mean and variance as
    constants simplifies modeling since you are not solving for them as functions
    of time.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，出于实际考虑，平稳性一词指的是“弱”平稳性，即定义为具有恒定均值*mu*（），恒定方差*sigma squared*（）和一致的协方差（或自相关）在相同距离的周期（*lags*）之间的时间序列。均值和方差作为常数有助于简化建模，因为你不需要将它们作为时间的函数来求解。
- en: Generally, a time series with trend or seasonality can be considered non-stationary.
    Usually, spotting trends or seasonality visually in a plot can help you determine
    whether the time series is stationary or not. In such cases, a simple line plot
    would suffice. But in this recipe, you will explore statistical tests to help
    you identify a stationary or non-stationary time series numerically. You will
    explore testing for stationarity and techniques for making a time series stationary.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，具有趋势或季节性的时间序列可以认为是非平稳的。通常，通过图形直观识别趋势或季节性有助于判断时间序列是否平稳。在这种情况下，一个简单的折线图就足够了。但在本教程中，你将探索统计检验，帮助你从数值上识别时间序列是平稳还是非平稳。你将探索平稳性检验及使时间序列平稳的技术。
- en: You will explore two statistical tests, the **Augmented Dickey-Fuller** (**ADF**)
    test and the **Kwiatkowski-Phillips-Schmidt-Shin** (**KPSS**) test, using the
    `statsmodels` library. Both ADF and KPSS test for unit roots in a univariate time
    series process. Note that unit roots are just one cause for a time series to be
    non-stationary, but generally, the presence of unit roots indicates non-stationarity.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `statsmodels` 库探索两种统计检验：**扩展迪基-福勒**（**ADF**）检验和**克维亚特科夫-菲利普斯-施密特-辛**（**KPSS**）检验。ADF
    和 KPSS 都用于检验单变量时间序列过程中的单位根。需要注意的是，单位根只是时间序列非平稳的原因之一，但通常单位根的存在表明时间序列是非平稳的。
- en: Both ADF and KPSS are based on linear regression and are a type of statistical
    hypothesis test. For example, the **null hypothesis** for ADF states that there
    is a unit root in the time series, and thus, it is non-stationary. On the other
    hand, KPSS has the opposite null hypothesis, which assumes the time series is
    stationary. Therefore, you will need to interpret the test results to determine
    whether you can reject or fail to reject the null hypothesis. Generally, you can
    rely on the p-values returned to decide whether you reject or fail to reject the
    null hypothesis.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ADF 和 KPSS 都基于线性回归，并且是统计假设检验的一种。例如，ADF 的**零假设**表示时间序列中存在单位根，因此是非平稳的。另一方面，KPSS
    的零假设相反，假设时间序列是平稳的。因此，你需要根据检验结果来判断是否可以拒绝零假设或未能拒绝零假设。通常，可以依赖返回的 p 值来决定是否拒绝或未能拒绝零假设。
- en: Remember, the interpretation for ADF and KPSS test results differs due to their
    opposite null hypotheses. If the p-value is less than the significance level (usually
    0.05), you can reject the null hypothesis, suggesting the time series does not
    have a unit root and is likely **stationary**. If the p-value is less than the
    significance level in the KPSS test, it indicates you can reject the null hypothesis,
    suggesting the series is **not stationary**.
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请记住，ADF 和 KPSS 检验的解释不同，因为它们的零假设相反。如果 p 值小于显著性水平（通常为 0.05），则可以拒绝零假设，说明时间序列没有单位根，可能是**平稳**的。如果
    KPSS 检验中的 p 值小于显著性水平，则表示可以拒绝零假设，表明该序列是**非平稳**的。
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download the Jupyter notebooks and datasets needed from the GitHub repository.
    Please refer to the `Technical requirements` section of this chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 GitHub 仓库下载所需的 Jupyter notebook 和数据集。请参阅本章节的`技术要求`部分。
- en: In this recipe, you will be using the CO2 dataset, which was previously loaded
    as a pandas DataFrame under the `Technical requirements` section of this chapter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，你将使用 CO2 数据集，该数据集之前已作为 pandas DataFrame 在本章节的`技术要求`部分加载。
- en: How to do it…
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In addition to the visual interpretation of a time series plot to determine
    stationarity, a more concrete method would be to use one of the *unit root tests*,
    such as the ADF KPSS test.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过时间序列图形的视觉解释来判断平稳性之外，一种更为具体的方法是使用*单位根检验*，例如 ADF KPSS 检验。
- en: In *Figure 9.13*, you can spot an upward trend and a reoccurring seasonal pattern
    (annual). However, when trend or seasonality exists (in this case, both), it makes
    the time series non-stationary. It's not always this easy to identify stationarity
    or lack of it visually, and therefore, you will rely on statistical tests.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 9.13*中，你可以看到一个上升的趋势和一个重复的季节性模式（年度）。然而，当存在趋势或季节性（在这种情况下，两者都有）时，这会使时间序列非平稳。并不是总能通过视觉轻松识别平稳性或其缺乏，因此，你将依赖统计检验。
- en: 'You will use both the `adfuller` and `kpss` tests from the statsmodels library
    and interpret their results knowing they have opposite null hypotheses:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 statsmodels 库中的 `adfuller` 和 `kpss` 检验，并在理解它们有相反的原假设的前提下解释它们的结果：
- en: 'Start by importing both the `adfuller` and `kpss` functions from statsmodels:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先从 statsmodels 导入 `adfuller` 和 `kpss` 函数：
- en: '[PRE33]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To simplify the interpretation of the test results, create a function that
    outputs the results in a user-friendly way. Let''s call the function `print_results`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化对检验结果的解释，创建一个函数以用户友好的方式输出结果。我们将该函数称为 `print_results`：
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The function takes the output from the `adfuller` and `kpss` functions and returns
    a dictionary that adds labels to the output.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受 `adfuller` 和 `kpss` 函数的输出，并返回一个添加了标签的字典。
- en: 'Run both the `kpss` and `adfuller` tests. Use the default parameter values
    for both functions:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `kpss` 和 `adfuller` 检验。对于这两个函数，使用默认的参数值：
- en: '[PRE35]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Pass both outputs to the `print_results` function and concatenate them into
    a pandas DataFrame for easier comparison:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个输出传递给 `print_results` 函数，并将它们合并为 pandas DataFrame，便于比较：
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This should produce the following DataFrame:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成以下 DataFrame：
- en: '![Figure 9.22: Result output from the ADF and KPSS unit root tests](img/file133.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.22：来自 ADF 和 KPSS 单位根检验的结果输出](img/file133.jpg)'
- en: 'Figure 9.22: Result output from the ADF and KPSS unit root tests'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22：来自 ADF 和 KPSS 单位根检验的结果输出
- en: For ADF, the p-value is at 0.96, which is greater than 0.05, so you *cannot
    reject* the null hypothesis, and therefore, the time series is non-stationary.
    For KPSS, the p-value is at 0.01, which is less than 0.05, so you *reject* the
    null hypothesis, and therefore, the time series is non-stationary.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ADF，p 值为 0.96，大于 0.05，因此你*不能拒绝*原假设，因此时间序列是非平稳的。对于 KPSS，p 值为 0.01，小于 0.05，因此你*拒绝*原假设，因此时间序列是非平稳的。
- en: Next, you will explore six techniques for making the time series stationary,
    such as transformations and differencing. The techniques covered are first-order
    differencing, second-order differencing, subtracting moving average, log transformation,
    decomposition, and Hodrick-Prescott filter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将探索六种使时间序列平稳的方法，如变换和差分。所涵盖的方法有一阶差分、二阶差分、减去移动平均、对数变换、分解和霍德里克-普雷斯科特滤波器。
- en: 'Essentially, stationarity can be achieved by removing trend (de-trending) and
    seasonality effects. For each transformation, you will run the stationarity tests
    and compare the results between the different techniques. To simplify the interpretation
    and comparison, you will create two functions:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，通过去除趋势（去趋势化）和季节性效应可以实现平稳性。对于每个变换，你将运行平稳性检验，并比较不同方法的结果。为了简化解释和比较，你将创建两个函数：
- en: '`check_stationarity` takes a DataFrame, performs both KPSS and ADF tests, and
    returns the outcome.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_stationarity` 接受一个 DataFrame，执行 KPSS 和 ADF 检验，并返回结果。'
- en: '`plot_comparison` takes a list of methods and compares their plots. The function
    takes a `plot_type` parameter, so you can explore a line chart and a histogram.
    The function calls the `check_stationarity` function to capture the results for
    the subplot titles.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plot_comparison` 接受一个方法列表并比较它们的图表。该函数接受一个 `plot_type` 参数，因此你可以探索折线图和直方图。该函数调用
    `check_stationarity` 函数，以捕捉子图标题的结果。'
- en: 'Create the `check_stationarity` function, which is a simplified rewrite of
    the `print_results` function used earlier:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `check_stationarity` 函数，这是对之前使用的 `print_results` 函数的简化重写：
- en: '[PRE37]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create the `plot_comparison` function:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `plot_comparison` 函数：
- en: '[PRE38]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s implement some of the methods for making the time series stationary
    or extracting a stationary component. Then, combine the methods into a Python
    list:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一些使时间序列平稳或提取平稳成分的方法。然后，将这些方法合并成一个 Python 列表：
- en: '**First-order differencing**: Also known as de-trending, which is calculated
    by subtracting an observation at time `t` from the previous observation at time
    `t-1` ('
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一阶差分**：也称为去趋势化，它通过将时间 `t` 的观测值减去时间 `t-1` 的前一个观测值来计算（'
- en: '![](img/file134.png)'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/file134.png)'
- en: '). In pandas this can be done using the `.diff()` function, which defaults
    to `period=1`. Note that the differenced data will contain one less data point
    (row) than the original data, hence the use of the `.dropna()` method:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在pandas中，可以使用`.diff()`函数来实现，这个函数的默认参数是`period=1`。注意，差分后的数据将比原始数据少一个数据点（行），因此需要使用`.dropna()`方法：
- en: '[PRE39]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Second-order differencing**: This is useful if seasonality exists or if the
    first-order differencing was insufficient. This is essentially differencing twice
    – differencing to remove trend followed by differencing to seasonality trend:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二阶差分**：如果存在季节性或一阶差分不足时，这非常有用。这本质上是进行两次差分——第一次差分去除趋势，第二次差分去除季节性趋势：'
- en: '[PRE40]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Subtracting moving average** (rolling window) from the time series using
    `DataFrame.rolling(window=52).mean()` since it is weekly data:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从时间序列中**减去移动平均**（滚动窗口），使用`DataFrame.rolling(window=52).mean()`，因为这是每周数据：
- en: '[PRE41]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Log transformation** using `np.log()` is a common technique to stabilize
    the variance in a time series and sometimes enough to make the time series stationary.
    Simply, all it does is replace each observation with its log value:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对数变换**，使用`np.log()`，是一种常见的技术，用于稳定时间序列的方差，有时足以使时间序列平稳。简单来说，它所做的就是用每个观测值的对数值替代原始值：'
- en: '[PRE42]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Using time series **decomposition** to remove the trend and seasonality components,
    such as `seasonal_decompose`. From *Figure 9.13,* it seems the process is additive.
    This is the default parameter in `seasonal_decompose`, so you do not need to make
    any changes here:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用时间序列**分解**方法去除趋势和季节性成分，例如`seasonal_decompose`。从*图9.13*来看，似乎该过程是加法性的。这是`seasonal_decompose`的默认参数，因此这里无需进行任何更改：
- en: '[PRE43]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let’s add STL as well for another decomposition method
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也添加STL作为另一种分解方法
- en: '[PRE44]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Using the **Hodrick-Prescott filter** to remove the trend component, for example,
    using `hp_filter`:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**霍德里克-普雷斯科特滤波器**去除趋势成分，例如使用`hp_filter`：
- en: '[PRE45]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s combine the methods into a Python list, then pass the list to the
    `plot_comparison` function:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些方法组合成一个Python列表，然后将该列表传递给`plot_comparison`函数：
- en: '[PRE46]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This should display 4 x 2 subplots as shown:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这应显示如图所示的4 x 2子图：
- en: '![Figure 9.23: Plotting the different methods to make the CO2 time series stationary](img/file135.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图9.23：绘制不同方法使CO2时间序列平稳](img/file135.png)'
- en: 'Figure 9.23: Plotting the different methods to make the CO2 time series stationary'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23：绘制不同方法使CO2时间序列平稳
- en: Generally, you do not want to over-difference your time series as some studies
    have shown that models based on over-differenced data are less accurate. For example,
    `first_order_diff` already made the time series stationary, and thus there was
    no need to *difference* it any further. In other words, `differencing_twice` was
    not needed. Additionally, notice how `log_transform` is still non-stationary.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不想对时间序列进行过度差分，因为一些研究表明，基于过度差分数据的模型准确性较低。例如，`first_order_diff`已经使时间序列平稳，因此无需进一步进行*差分*。换句话说，`differencing_twice`是不必要的。此外，注意到`log_transform`仍然是非平稳的。
- en: Notice the center line representing the time series average (moving average).
    The mean should be constant for a stationary time series and look more like a
    straight horizontal line.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意中间线代表时间序列的平均值（移动平均）。对于平稳时间序列，均值应保持恒定，且更像是一条水平直线。
- en: How it works…
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Stationarity is an essential concept in time series forecasting, and more relevant
    when working with financial or economic data. Earlier we defined stationarity
    (weak) as having constant mean, a constant variance, and a consistent covariance.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 平稳性是时间序列预测中的一个重要概念，尤其在处理金融或经济数据时尤为相关。我们之前将平稳性（弱平稳）定义为均值恒定、方差恒定、协方差一致。
- en: The mean is considered stable and constant if the time series is stationary.
    In other words, there is an equilibrium as values may deviate from the mean (above
    or below), but eventually, it always returns to the mean. Some trading strategies
    rely on this core assumption, formally called a *mean reversion* strategy.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果时间序列是平稳的，则均值被认为是稳定且恒定的。换句话说，存在一种平衡，尽管值可能会偏离均值（高于或低于），但最终它总会回到均值。一些交易策略依赖于这一核心假设，正式称为*均值回归*策略。
- en: The statsmodels library offers several stationarity tests, such as the `adfuller`
    and `kpss` functions. Both are considered **unit root tests** and are used to
    determine whether differencing or other transformation strategies are needed to
    make the time series stationary.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`statsmodels`库提供了多个平稳性检验方法，例如`adfuller`和`kpss`函数。两者都被认为是**单位根检验**，用于确定是否需要差分或其他转换策略来使时间序列平稳。'
- en: Remember, ADF and KPSS tests are based on different null hypotheses. For example,
    `adfuller` and `kpss` have an opposite null hypothesis. So, the p-value that you
    use to reject (or fail to reject) the null hypothesis will be interpreted differently
    between the two.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，ADF和KPSS检验基于不同的原假设。例如，`adfuller`和`kpss`的原假设是相反的。因此，你用来拒绝（或无法拒绝）原假设的p值在这两者之间的解读会有所不同。
- en: 'In *Figure 9.22*, there is additional information returned by the tests. This
    includes the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 9.22*中，测试返回了额外的信息，具体包括以下内容：
- en: The **Test Statistic** value is 0.046 for ADF and 8.18 for KPSS, which are above
    the 1% critical value threshold. This indicates that the time series is non-stationary.
    It confirms that you cannot reject the null hypothesis. The critical values for
    ADF comes from a Dickey-Fuller table. Luckily, you do not have to reference the
    Dickey-Fuller table since all statistical software/libraries that offer the ADF
    test use the table internally. The same applies to KPSS.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检验统计量**值为ADF的0.046和KPSS的8.18，均高于1%的临界值阈值。这表明时间序列是非平稳的，确认你不能拒绝原假设。ADF的临界值来自Dickey-Fuller表格。幸运的是，你不必参考Dickey-Fuller表格，因为所有提供ADF检验的统计软件/库都会在内部使用该表格。KPSS也是如此。'
- en: The **p-value** result is associated with the test statistic. Generally, you
    can reject the null hypothesis if the p-value is less than 0.05 (5%). Again, when
    using ADF, KPSS, or other stationarity tests, make sure to understand the null
    hypothesis to accurately interpret the results.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**p值**结果与检验统计量相关。通常，当p值小于0.05（5%）时，你可以拒绝原假设。再次强调，在使用ADF、KPSS或其他平稳性检验时，确保理解原假设，以便准确解读结果。'
- en: '**Number of lags** represents the number of lags used in the autoregressive
    process in the test (ADF and KPSS). In both tests, 27 lags were used. Since our
    CO2 data is weekly, a lag represents 1 week back. So, 27 lags represent 27 weeks
    in our data.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滞后期数**表示检验中自回归过程使用的滞后期数（ADF和KPSS）。在这两个检验中，使用了27个滞后期。由于我们的CO2数据是按周记录的，一个滞后期表示1周。因此，27个滞后期代表我们数据中的27周。'
- en: The number of observations used is the number of data points, excluding the
    number of lags.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的观测值数量是数据点的数量，排除了滞后期数。
- en: The maximized info criteria are based on the **autolag** parameter. The default
    is `autolag="aic"` for the **Akaike Information Criterion**. Other acceptable
    `autolag` parameter values are `bic` for the **Bayesian Information Criterion**
    and `t-stat`.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大化的信息准则基于**autolag**参数。默认值是`autolag="aic"`，对应**赤池信息准则（AIC）**。其他可接受的`autolag`参数值有`bic`（对应**贝叶斯信息准则（BIC）**）和`t-stat`。
- en: You also explored some techniques for de-trending (removing trend) in a time
    series to make it stationary. For example, you used first-order differencing,
    decomposition, and log transform to remove the effect of the trend. Detrending
    stabilizes the mean of the time series and sometimes can be all that is needed
    to make it stationary. When you decide to de-trend your data, you are essentially
    removing an element of distraction so you can focus on hidden patterns that are
    not as obvious. Hence, you can build a model to capture these patterns and not
    be overshadowed by the long-term trend (upward or downward movement). An example
    was the first differencing approach.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你还探索了一些时间序列去趋势（移除趋势）的技术，以使其平稳。例如，你使用了一级差分、分解和对数变换来去除趋势的影响。去趋势稳定了时间序列的均值，有时这就是使其平稳所需的全部。当你决定去趋势时，本质上是移除一个干扰因素，这样你就能专注于那些不那么明显的潜在模式。因此，你可以构建一个模型来捕捉这些模式，而不会被长期趋势（向上或向下的波动）所掩盖。一个例子是一级差分方法。
- en: However, in the presence of seasonal patterns you will need to remove the seasonal
    effect as well, which can be done through seasonal differencing. This is done
    in addition to the first-order differencing for detrending; hence it can be called
    second-order differencing, twice-differencing, or differencing twice as you use
    differencing to remove the trend effect first and again to remove the seasonality.
    This assumes the seasonal differencing was insufficient to make the time series
    stationary. Your goal is to use the minimal amount of differencing needed and
    avoid over-differencing. You will rarely need to go beyond differencing twice.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在存在季节性模式的情况下，您还需要去除季节性效应，这可以通过季节性差分来完成。这是在去趋势的第一阶差分之外进行的；因此，它可以称为二阶差分、双重差分，或者称为“差分两次”，因为您首先使用差分去除趋势效应，然后再次去除季节性。这假设季节性差分不足以使时间序列平稳。您的目标是使用最少的差分，避免过度差分。您很少需要超过两次差分。
- en: There's more…
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'In the introduction section of this recipe, we mentioned that both ADF and
    KPSS use linear regression. More specifically, **Ordinary Least Squares** (**OLS**)
    regression is used to compute the model''s coefficients. To view the OLS results
    for ADF, you use the `store` parameter and set it to `True`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的介绍部分，我们提到过，ADF和KPSS都使用线性回归。更具体地说，**普通最小二乘法**（**OLS**）回归用于计算模型的系数。要查看ADF的OLS结果，您需要使用`store`参数并将其设置为`True`：
- en: '[PRE47]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The preceding code will return a tuple that contains the test results. The
    regression summary will be appended as the last item. There should be four items
    in the tuple: the first item, `adf_result[0]`, contains the **t-statistic**, the
    second item, `adf_result[1]`, includes the **p-value**, and the third item, `adf_result[2]`,
    contains the **critical values** for 1%, 5%, and 10% intervals. The last item,
    `adf_result[3]`, includes a **ResultStore** object. You can also access the last
    item by using `adf_result[-1]`, as shown in the following code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将返回一个包含测试结果的元组。回归摘要将作为最后一项附加到元组中。元组中应该有四项：第一项，`adf_result[0]`，包含**t统计量**；第二项，`adf_result[1]`，包含**p值**；第三项，`adf_result[2]`，包含1%、5%和10%区间的**临界值**。最后一项，`adf_result[3]`，包含**ResultStore**对象。您也可以使用`adf_result[-1]`来访问最后一项，如以下代码所示：
- en: '[PRE48]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `ResultStore` object gives you access to `.resols`, which contains the
    `.summary()` method. This should produce the following output:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultStore`对象让您可以访问`.resols`，其中包含`.summary()`方法。这将生成如下输出：'
- en: '![Figure 9.24: ADF OLS regression summary and the first five lags and their
    coefficients](img/file136.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图9.24：ADF OLS回归摘要及前五个滞后项及其系数](img/file136.png)'
- en: 'Figure 9.24: ADF OLS regression summary and the first five lags and their coefficients'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24：ADF OLS回归摘要及前五个滞后项及其系数
- en: See also
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另见
- en: 'To learn more about stationarity and detrending, visit the official statsmodels
    page here: [https://www.statsmodels.org/dev/examples/notebooks/generated/stationarity_detrending_adf_kpss.html](https://www.statsmodels.org/dev/examples/notebooks/generated/stationarity_detrending_adf_kpss.html).'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于平稳性和去趋势的内容，请访问官方statsmodels页面：[https://www.statsmodels.org/dev/examples/notebooks/generated/stationarity_detrending_adf_kpss.html](https://www.statsmodels.org/dev/examples/notebooks/generated/stationarity_detrending_adf_kpss.html)。
- en: Applying power transformations
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用幂次变换
- en: Time series data can be complex, and embedded within the data is critical information
    that you will need to understand and peek into to determine the best approach
    for building a model. For example, you have explored time series decomposition,
    understood the impact of trend and seasonality, and tested for stationarity. In
    the previous recipe, *Detecting time series stationarity*, you examined the technique
    to transform data from non-stationary to stationary. This includes the idea of
    detrending, which attempts to stabilize the mean over time.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列数据可能很复杂，数据中嵌入着您需要理解和分析的重要信息，以便确定构建模型的最佳方法。例如，您已经探索了时间序列分解，理解了趋势和季节性的影响，并测试了平稳性。在前面的食谱中，*检测时间序列的平稳性*，您研究了将数据从非平稳转变为平稳的技术。这包括去趋势的概念，旨在稳定时间序列的均值。
- en: Depending on the model and analysis you are pursuing, you may need to test for
    additional assumptions against the observed dataset or the model's residuals.
    For example, testing for **homoskedasticity** (also spelled homoscedasticity)
    and **normality**. Homoskedasticity means that the variance is stable over time.
    More specifically, it is the variance of the residuals. When the variance is not
    constant, changing over time, we call it **heteroskedasticity** (also spelled
    heteroscedasticity). Another assumption you will need to test for is normality;
    does the specific observation come from a normal (Gaussian) distribution? Sometimes,
    you may want to check the normality of the residuals as well, which can be part
    of the model diagnostics stage. Therefore, it is important to be aware of the
    assumptions made by specific models or techniques so you can determine which test
    to use and against which dataset. If you do not do this, you may end up with a
    flawed model or an outcome that may be overly optimistic or overly pessimistic.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你所进行的模型和分析，可能需要对观察数据集或模型的残差进行额外假设检验。例如，检验**同方差性**（也拼作 homoscedasticity）和**正态性**。同方差性意味着方差在时间上是稳定的。更具体地说，它是残差的方差。当方差不是常数，而是随时间变化时，我们称之为**异方差性**（也拼作
    heteroscedasticity）。另一个需要检验的假设是正态性；该特定观察值是否来自正态（高斯）分布？有时，你可能还需要检查残差的正态性，这通常是模型诊断阶段的一部分。因此，了解特定模型或技术所做的假设非常重要，这样你才能确定使用哪些测试以及针对哪个数据集进行测试。如果不进行这些检查，你可能会得到一个有缺陷的模型或一个过于乐观或悲观的结果。
- en: 'Additionally, in this recipe, you will learn about **Box-Cox transformation**,
    which you can use to transform the data to satisfy normality and homoskedasticity.
    Box-Cox transformation takes the following form:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本教程中，你将学习**Box-Cox 变换**，它可以帮助你转换数据，以满足正态性和同方差性的要求。Box-Cox 变换的形式如下：
- en: '![Figure 9.25: Box-Cox transformation](img/file137.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.25：Box-Cox 变换](img/file137.jpg)'
- en: 'Figure 9.25: Box-Cox transformation'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.25：Box-Cox 变换
- en: The Box-Cox transformation relies on just one parameter, lambda (![](img/file138.png)),
    and covers both logarithm and power transformations. If![](img/file139.png)is
    0, then you get a **natural log transformation**; otherwise, it's a power transformation.
    The approach is to try different values of![](img/file140.png)and then test for
    normality and homoskedasticity. For example, the **SciPy** library has the `boxcox`
    function, and you can specify different![](img/file141.png)values using the `lmbda`
    parameter (interestingly, this is how it is spelled in the implementation since
    `lambda` is a reserved Python keyword). If the `lmbda` parameter is set to `None`,
    the function will find the optimal lambda (![](img/file142.png)) value for you.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Box-Cox 变换依赖于一个参数，lambda（![](img/file138.png)），并涵盖了对数变换和幂变换。如果![](img/file139.png)为0，则得到**自然对数变换**；否则，则为幂变换。该方法是尝试不同的![](img/file140.png)值，然后测试正态性和同方差性。例如，**SciPy**
    库有一个 `boxcox` 函数，你可以通过 `lmbda` 参数指定不同的![](img/file141.png)值（有趣的是，在实现中这样拼写，因为 `lambda`
    是 Python 的保留关键字）。如果将 `lmbda` 参数设置为 `None`，该函数将为你找到最佳的 lambda（![](img/file142.png)）值。
- en: Getting ready
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download the Jupyter notebooks and datasets needed from the GitHub repository.
    Please refer to the *Technical requirements* section of this chapter.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 GitHub 仓库下载所需的 Jupyter notebook 和数据集。请参考本章的*技术要求*部分。
- en: In this recipe, you will be using the Air Passengers dataset, which was previously
    loaded as a pandas DataFrame under the *Technical requirements* section of this
    chapter.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，你将使用空气乘客数据集，这个数据集已在本章*技术要求*部分作为 pandas DataFrame 加载。
- en: You will be using the SciPy and `statsmodels`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 SciPy 和 `statsmodels`。
- en: 'For `pip` installation, use the following command:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `pip` 安装，请使用以下命令：
- en: '[PRE49]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For `conda` installation, use the following command:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `conda` 安装，请使用以下命令：
- en: '[PRE50]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In addition to the preparation highlighted in the *Technical requirements*
    section, you will need to import these common libraries that you will use throughout
    this recipe:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在*技术要求*部分中提到的准备工作外，你还需要导入在本教程中将使用到的常用库：
- en: '[PRE51]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To make the plots a lot bigger and easier to read, use the following command
    to establish a fixed size (20, 8) – a width of 20 inches and a height of 8 inches:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让图表更大、更易读，可以使用以下命令设置固定的尺寸（20, 8）——宽度为 20 英寸，高度为 8 英寸：
- en: '[PRE52]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How to do it…
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, you will extend what you learned from the previous recipe,
    *Detecting time series stationarity*, and test for two additional assumptions:
    **normality** and **homoskedasticity**.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将扩展从上一节*检测时间序列平稳性*中学到的内容，并测试两个额外的假设：**正态性**和**同方差性**。
- en: Usually, stationarity is the most crucial assumption you will need to worry
    about but being familiar with additional diagnostic techniques will serve you
    well.
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常，平稳性是你需要关注的最关键假设，但熟悉额外的诊断技术将对你大有帮助。
- en: Sometimes, you can determine normality and homoskedasticity from plots, for
    example, a histogram or a **Q-Q plot**. This recipe aims to teach you how to perform
    these diagnostic tests programmatically in Python. In addition, you will be introduced
    to the **White test** and the **Breusch-Pagan Lagrange** statistical test for
    *homoskedactisity*.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可以通过图形来判断正态性和同方差性，例如，通过直方图或**Q-Q图**。本节旨在教你如何在Python中编程执行这些诊断检验。此外，你还将了解**White检验**和**Breusch-Pagan
    Lagrange**统计检验，用于*同方差性*。
- en: For normality diagnostics, you will explore the **Shapiro-Wilk**, **D'Agostino-Pearson**,
    and **Kolmogorov-Smirnov** statistical tests. Overall, Shapiro-Wilk tends to perform
    best and handles a broader set of cases.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 对于正态性诊断，你将探索**Shapiro-Wilk**、**D'Agostino-Pearson**和**Kolmogorov-Smirnov**统计检验。总体而言，Shapiro-Wilk倾向于表现最好，且能够处理更广泛的情况。
- en: Testing normality
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 正态性检验
- en: 'The statsmodels library and the SciPy library have overlapping implementations.
    For example, the Kolmogorov-Smirnov test is implemented as `ktest` in SciPy and
    `ktest_normal` in statsmodels. In SciPy, the D''Agostino-Pearson test is implemented
    as `normaltest` and the Shapiro-Wilk test as `shapiro`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: statsmodels库和SciPy库有重叠的实现。例如，Kolmogorov-Smirnov检验在SciPy中实现为`ktest`，而在statsmodels中实现为`ktest_normal`。在SciPy中，D'Agostino-Pearson检验实现为`normaltest`，Shapiro-Wilk检验实现为`shapiro`：
- en: 'Start by importing the normality tests provided by the SciPy and statsmodels
    libraries:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入SciPy和statsmodels库提供的正态性检验：
- en: '[PRE53]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The normality diagnostic is a statistical test based on a null hypothesis that
    you need to determine whether you can accept or reject. Conveniently, the following
    tests that you will implement have the same null hypothesis. *The null hypothesis
    states that the data is normally distributed*; for example, you would reject the
    null hypothesis if the p-value is less than 0.05, making the time series not normally
    distributed. Let''s create a simple function, `is_normal()`, that will return
    either `Normal` or `Not Normal` based on the p-value:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正态性诊断是一种基于原假设的统计检验，你需要确定是否可以接受或拒绝该假设。方便的是，以下你将实现的检验有相同的原假设。*原假设声明数据是正态分布的*；例如，当p值小于0.05时，你将拒绝原假设，表示时间序列不服从正态分布。让我们创建一个简单的函数`is_normal()`，它将根据p值返回`Normal`或`Not
    Normal`：
- en: '[PRE54]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Run each test to check the results:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 运行每个检验以检查结果：
- en: '[PRE55]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The output from the tests confirms the data does not come from a normal distribution.
    You do not need to run that many tests. The `shapiro` test, for example, is a
    very common and popular test that you can rely on. Generally, as with any statistical
    test, you need to read the documentation regarding the implementation to gain
    an understanding of the test. More specifically, you will need to understand the
    null hypothesis behind the test to determine whether you can reject or fail to
    reject the null hypothesis.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 检验结果显示数据不来自正态分布。你不需要运行那么多检验。例如，`shapiro`检验是一个非常常见且受欢迎的检验，你可以依赖它。通常，像任何统计检验一样，你需要阅读关于该检验实现的文档，以了解检验的具体内容。更具体地，你需要了解检验背后的原假设，以便决定是否可以拒绝原假设或未能拒绝原假设。
- en: 'Sometimes, you may need to test normality as part of model evaluation and diagnostics.
    For example, you would evaluate the residuals (defined as the difference between
    actual and predicted values) if they follow a normal distribution. In *Chapter
    10*, *Building Univariate Time Series Models Using Statistical Methods*, you will
    explore building forecasting models using autoregressive and moving average models.
    For now, you will run a simple autoregressive (AR(1)) model to demonstrate how
    you can use a normality test against the residuals of a model:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，你可能需要在模型评估和诊断过程中测试正态性。例如，你可以评估残差（定义为实际值和预测值之间的差异）是否符合正态分布。在*第10章*，*使用统计方法构建单变量时间序列模型*中，你将探索使用自回归和移动平均模型构建预测模型。目前，你将运行一个简单的自回归（AR(1)）模型，演示如何将正态性检验应用于模型的残差：
- en: '[PRE56]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You can run the `shapiro` test against the residuals. To access the residuals,
    you would use the `.resid` property as in `model.resid`. This is common in many
    models you will build in *Chapter 10*, *Building Univariate Time Series Models
    Using Statistical Methods*:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对残差运行`shapiro`检验。要访问残差，你可以使用`.resid`属性，如`model.resid`。这是你在*第10章*中构建的许多模型中的常见方法，*使用统计方法构建单变量时间序列模型*：
- en: '[PRE57]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The output indicates the residuals are not normally distributed. This fact,
    residuals not being normally distributed, is not enough to determine the model's
    validity or potential improvements. But taken into context with the other tests,
    it should help you determine how good your model is. This is a topic you will
    explore further in the next chapter.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果表明残差不是正态分布的。残差不正态分布这一事实本身不足以确定模型的有效性或潜在改进，但结合其他测试，这应该有助于你评估模型的优劣。这是你将在下一章进一步探讨的话题。
- en: Testing homoskedactisity
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试同方差性
- en: 'You will be testing for the stability of the variance against the model''s
    residuals. This will be the same AR(1) model used in the previous normality test:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你将测试模型残差的方差稳定性。这将是与之前正态性测试中使用的相同的AR(1)模型：
- en: 'Let''s start by importing the method needed for this recipe:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先导入本章所需的方法：
- en: '[PRE58]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You will perform a homoskedasticity test on the model's residuals. As stated
    earlier regarding statistical tests, it is vital to understand the hypothesis
    behind these tests. The null hypothesis states that *the data is homoskedastic*
    for the two tests. For example, you would reject the null hypothesis if the p-value
    is less than 0.05, making the time series heteroskedastic.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将对模型的残差进行同方差性测试。正如前面所述，理解这些统计测试背后的假设非常重要。原假设表示*数据是同方差的*，适用于这两个测试。例如，如果p值小于0.05，你将拒绝原假设，这意味着时间序列是异方差的。
- en: 'Let''s create a small function, calling it `het_test(model, test)`, that takes
    in a model and the test function and returns either `Heteroskedastic` or `Homoskedastic`
    based on the p-value to determine whether the null hypothesis is accepted or rejected:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个小函数，命名为`het_test(model, test)`，该函数接受一个模型和一个测试函数，并根据p值返回`Heteroskedastic`或`Homoskedastic`，以确定是否接受或拒绝原假设：
- en: '[PRE59]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Start with the Breusch-Pagan Lagrange multiplier test to diagnose the residuals.
    In statsmodels, you will use the `het_breuschpagan` function, which takes `resid`,
    the model''s residual, and `exog_het`, where you provide the original data (explanatory
    variables) related to the heteroskedasticity in the residual:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Breusch-Pagan拉格朗日乘数检验开始诊断残差。在statsmodels中，你将使用`het_breuschpagan`函数，该函数接受`resid`（模型的残差）和`exog_het`（提供与残差异方差相关的原始数据，即解释变量）：
- en: '[PRE60]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This result indicates that the residual is homoskedastic, with a constant variance
    (stable).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果表明残差是同方差的，具有恒定方差（稳定性）。
- en: 'A very similar test is White''s Lagrange multiplier test. In statsmodels, you
    will use the `het_white` function, which has the same two parameters that you
    used with `het_breuschpagan`:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个非常相似的测试是怀特（White）的拉格朗日乘数检验。在statsmodels中，你将使用`het_white`函数，它有两个参数，与你使用`het_breuschpagan`时相同：
- en: '[PRE61]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Both tests indicate that the residuals of the autoregressive model have constant
    variance (homoskedastic). Both tests estimate the auxiliary regression against
    the squared residuals and all the explanatory variables.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 两个测试都表明自回归模型的残差具有恒定方差（同方差）。这两个测试都估计了辅助回归，并使用了残差的平方以及所有解释变量。
- en: Keep in mind that both normality and homoskedasticity are some of the tests
    you may need to conduct on the residuals as you diagnose your model. Another essential
    test is testing for autocorrelation, which is discussed in the following recipe,
    *Testing for autocorrelation in time series data*.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，正态性和同方差性是你在诊断模型时可能需要对残差进行的一些测试。另一个重要的测试是自相关性测试，相关内容将在接下来的章节中讨论，*时间序列数据中的自相关性测试*。
- en: Applying Box-Cox transform
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用Box-Cox变换
- en: 'Box-Cox transformation can be a useful tool, and it''s good to be familiar
    with. Box-Cox transforms a non-normally distributed dataset into a normally distributed
    one. At the same time, it stabilizes the variance, making the data homoskedastic.
    To gain a better understanding of the effect of Box-Cox transformation, you will
    use the Air Passengers dataset, which contains both trend and seasonality:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: Box-Cox 变换可以是一个有用的工具，熟悉它是很有帮助的。Box-Cox 将一个非正态分布的数据集转换为正态分布的数据集。同时，它稳定了方差，使数据呈同方差性。为了更好地理解
    Box-Cox 变换的效果，你将使用包含趋势和季节性的航空乘客数据集：
- en: 'Start by importing the `boxcox` function from the SciPy library:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 SciPy 库中导入 `boxcox` 函数：
- en: '[PRE62]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Recall, from the introduction section of this recipe and *Figure 9.22*, there
    is a lambda parameter used to determine which transformation to apply (logarithm
    or power transform). Use the `boxcox` function with the default parameter value
    for `lmbda`, which is `None`. Just provide the dataset to satisfy the required
    `x` parameter:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回顾本配方引言部分和 *图 9.22*，有一个 lambda 参数用于确定应用哪种变换（对数变换或幂变换）。使用默认的 `lmbda` 参数值为 `None`
    的 `boxcox` 函数，只需提供数据集以满足所需的 `x` 参数：
- en: '[PRE63]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: By not providing a value to `lmbda` and keeping it at `None`, the function will
    find the optimal lambda (![](img/file143.png)) value. From the introduction of
    this recipe, you'll remember lambda is spelled `lmbda` in the `boxcox` implementation.
    The function returns two values captured by `xt` for the transformed data and
    `lmda` for the optimal lambda value found.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不提供 `lmbda` 的值并将其保持为 `None`，该函数将找到最佳的 lambda (![](img/file143.png)) 值。根据本配方的引言，你会记得在
    `boxcox` 实现中 lambda 被拼写为 `lmbda`。该函数返回两个值，`xt` 用于保存变换后的数据，`lmda` 用于保存找到的最佳 lambda
    值。
- en: 'A histogram can visually show the impact of the transformation:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图可以直观地展示变换的影响：
- en: '[PRE64]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This should produce the following two plots:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成以下两个图：
- en: '![Figure 9.26: Box-Cox transformation and effect on the distribution](img/file144.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.26：Box-Cox 变换及其对分布的影响](img/file144.png)'
- en: 'Figure 9.26: Box-Cox transformation and effect on the distribution'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.26：Box-Cox 变换及其对分布的影响
- en: The second histogram shows that the data was transformed, and the overall distribution
    changed. It would be interesting to examine the dataset as a time series plot.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个直方图显示数据已被变换，总体分布发生了变化。将数据集作为时间序列图进行分析会很有意思。
- en: 'Plot both datasets to compare before and after the transformation:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制两个数据集，以比较变换前后的效果：
- en: '[PRE65]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This should produce the following two plots:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成以下两个图：
- en: '![Figure 9.27: Box-Cox transformation and overall effect on time series data](img/file145.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.27：Box-Cox 变换及其对时间序列数据的总体影响](img/file145.png)'
- en: 'Figure 9.27: Box-Cox transformation and overall effect on time series data'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.27：Box-Cox 变换及其对时间序列数据的总体影响
- en: Notice how the seasonal effect on the transformed dataset looks more stable
    than before.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 注意观察变换后的数据集，季节性效应看起来比之前更稳定。
- en: 'Finally, build two simple autoregressive models to compare the effect on the
    residuals before and after the transformation:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，构建两个简单的自回归模型，比较变换前后对残差的影响：
- en: '[PRE66]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This should produce the following two plots:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成以下两个图：
- en: '![Figure 9.28: Box-Cox transformation and effect on residuals](img/file146.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.28：Box-Cox 变换及其对残差的影响](img/file146.png)'
- en: 'Figure 9.28: Box-Cox transformation and effect on residuals'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.28：Box-Cox 变换及其对残差的影响
- en: How it works…
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Box-Cox allows us to make the data both normal and homoskedastic and is part
    of a family of power transforms that includes log transform and square root transform.
    Box-Cox is a powerful transform because it supports both root and log transforms,
    and others are made possible by changing the lambda values.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Box-Cox 使我们能够将数据转换为正态分布且具有同方差性，它是一个包含对数变换和平方根变换等变换的幂变换家族的一部分。Box-Cox 是一种强大的变换方法，因为它支持根变换和对数变换，并且通过调整
    lambda 值可以实现其他变换。
- en: One thing to point out is that the `boxcox` function requires the data to be
    positive.
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 需要指出的是，`boxcox` 函数要求数据为正数。
- en: There's more...
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The AutoReg model comes with two useful methods: diagnostic_summary() and plot_diagnostics().
    They will save you time from having to write additional code to test the model''s
    residuals for normality, homoskedasticity, and autocorrelation.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: AutoReg 模型有两个有用的方法：diagnostic_summary() 和 plot_diagnostics()。它们可以节省你编写额外代码的时间，测试模型残差的正态性、同方差性和自相关性。
- en: 'The following code shows how you can get the diagnostic summary for `model_bx`:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何获取`model_bx`的诊断摘要：
- en: '[PRE67]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This should display the results from the Ljung-Box test for autocorrelation
    and the homoskedasticity test against the model's residuals.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这应显示Ljung-Box自相关检验结果和模型残差的同方差性检验。
- en: '![Figure 9.29: diagnostic_summary for autocorrelation](img/file147.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![图9.29：自相关的diagnostic_summary](img/file147.png)'
- en: 'Figure 9.29: diagnostic_summary for autocorrelation'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29：自相关的diagnostic_summary
- en: 'To get the visual summary, you can use the following code:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得视觉摘要，可以使用以下代码：
- en: '[PRE68]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `.plot_diagnostics()` function will show four plots so you can examine the
    model's residuals. Mainly, the plots will show whether the residuals are normally
    distributed from the Q-Q plot and histogram. Additionally, the **autocorrelation
    function plot** (**ACF**) will allow you to examine for autocorrelation. You will
    examine ACF plots in more detail in the *Plotting ACF and PACF* recipe in *Chapter
    10*, *Building Univariate Time Series Models Using Statistical Methods*.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`.plot_diagnostics()`函数将显示四个图表，您可以检查模型的残差。主要地，图表将显示残差是否从Q-Q图和直方图中呈现正态分布。此外，**自相关函数图**（**ACF**）将允许您检查自相关。您将在*第10章*的“*绘制ACF和PACF*”一节中更详细地研究ACF图。'
- en: '![Figure 9.30: Output from the plot_diagnostics() method](img/file148.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![图9.30：来自plot_diagnostics()方法的输出](img/file148.png)'
- en: 'Figure 9.30: Output from the plot_diagnostics() method'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.30：来自plot_diagnostics()方法的输出
- en: See also
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn more about the `boxcox` function, visit the official SciPy documentation
    here: [https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.boxcox.html](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.boxcox.html).'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`boxcox`函数的信息，请访问官方SciPy文档：[https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.boxcox.html](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.boxcox.html)。
- en: Testing for autocorrelation in time series data
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试时间序列数据中的自相关
- en: '**Autocorrelation** is like statistical correlation (think **Pearson correlation**
    from high school), which measures the strength of a linear relationship between
    two variables, except that we measure the linear relationship between *time series
    values separated by a lag*. In other words, we are comparing a variable with its
    lagged version of itself.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**自相关**类似于统计学中的相关性（可以理解为高中学过的**皮尔逊相关**），用于衡量两个变量之间线性关系的强度，不同之处在于我们衡量的是*滞后时间序列值之间的线性关系*。换句话说，我们是在比较一个变量与其滞后的版本之间的关系。'
- en: In this recipe, you will perform a **Ljung-Box test** to check for autocorrelations
    up to a specified lag and whether they are significantly far off from 0\. *The
    null hypothesis for the Ljung-Box test states that the previous lags are not correlated
    with the current period*. In other words, you are testing for the absence of autocorrelation.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将执行**Ljung-Box检验**，检查是否存在直到指定滞后的自相关，以及它们是否显著偏离0。*Ljung-Box检验的原假设表示前期滞后与当前期无关*。换句话说，您正在检验自相关的不存在。
- en: When running the test using `acorr_ljungbox` from statsmodels, you need to provide
    a lag value. The test will run for all lags up to the specified lag (maximum lag).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 使用statsmodels中的`acorr_ljungbox`运行检验时，您需要提供一个滞后值。该检验将在所有滞后值（直到指定的最大滞后）上进行。
- en: The autocorrelation test is another helpful test for model diagnostics. As discussed
    in the previous recipe, *Applying power transformations*, there are assumptions
    that you need to test against the model's residuals. For example, when testing
    for autocorrelation on the residuals, the expectation is that there should be
    no autocorrelation between the residuals. This ensures that the model has captured
    all the necessary information. The presence of autocorrelation in the residuals
    can indicate that the model missed an opportunity to capture critical information
    and will need to be evaluated.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 自相关测试是另一种有助于模型诊断的测试。如前面“*应用幂变换*”一节所讨论的那样，模型的残差需要进行假设检验。例如，当对残差进行自相关测试时，期望残差之间没有自相关。这确保了模型已经捕获了所有必要的信息。残差中的自相关可能表示模型未能捕捉到关键信息，需进行评估。
- en: Getting ready
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download the Jupyter notebooks and datasets needed from the GitHub repository.
    Please refer to the *Technical requirements* section of this chapter.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub仓库下载所需的Jupyter笔记本和数据集。请参考本章的*技术要求*部分。
- en: You will be using `acorr_ljungbox` from the statsmodels library.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用来自statsmodels库的`acorr_ljungbox`。
- en: How to do it…
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'You will use the CO2 dataset stored in the `co2_df` DataFrame:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用存储在`co2_df` DataFrame中的CO2数据集：
- en: 'Load `acorr_ljungbox` from the statsmodels library:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从statsmodels库加载`acorr_ljungbox`：
- en: '[PRE69]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Since the data is not stationary (review the *Detecting time series stationarity*
    recipe), you will perform a log transform this time (log differencing):'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于数据不是平稳的（请回顾*检测时间序列平稳性*食谱），这次你将进行对数变换（对数差分）：
- en: '[PRE70]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Run the Ljung-Box test. Start with `lags=10`:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Ljung-Box检验。首先设置`lags=10`：
- en: '[PRE71]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This should print the results for the first 10 lags.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出前10个滞后的结果。
- en: '![Figure 9.31: The first 10 lags for the autocorrelation test](img/file149.png)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![图9.31：自相关检验的前10个滞后](img/file149.png)'
- en: 'Figure 9.31: The first 10 lags for the autocorrelation test'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.31：自相关检验的前10个滞后
- en: This shows that the test statistic for all lags up to lag 10 are significant
    (*p-value < 0.05*), so you can reject the null hypothesis. Rejecting the null
    hypothesis means you reject the claim that there is no autocorrelation.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，对于所有滞后期直到滞后10，自检验统计量都显著（*p值 < 0.05*），因此你可以拒绝原假设。拒绝原假设意味着你拒绝没有自相关的假设。
- en: How it works…
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`acorr_ljungbox` is a function that accumulates autocorrelation up until the
    lag specified. Therefore, it is helpful to determine whether the structure is
    worth modeling in the first place.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`acorr_ljungbox`是一个累积自相关直到指定滞后的函数。因此，它有助于确定结构是否值得建模。'
- en: There's more...
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Let''s use the Ljung-Box test against the residual from `model_bx` that was
    created in the *Applying power transformations* recipe:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对`model_bx`模型的残差使用Ljung-Box检验，该模型是在*应用幂变换*食谱中创建的：
- en: '[PRE72]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This should print the results for the first 10 lags:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出前10个滞后的结果：
- en: '![Figure 9.32: The first 10 lags for the autocorrelation test against residuals](img/file150.png)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![图9.32：自相关检验的前10个滞后，针对残差](img/file150.png)'
- en: 'Figure 9.32: The first 10 lags for the autocorrelation test against residuals'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.32：自相关检验的前10个滞后，针对残差
- en: From the preceding example, the p-values are less than 0.05, so you reject the
    null hypothesis, and there is autocorrelation.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，p值小于0.05，因此你拒绝原假设，并且存在自相关。
- en: See also
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另见
- en: 'To learn more about the `acorr_ljungbox` function, visit the official documentation
    here: [https://www.statsmodels.org/dev/generated/statsmodels.stats.diagnostic.acorr_ljungbox.html](https://www.statsmodels.org/dev/generated/statsmodels.stats.diagnostic.acorr_ljungbox.html).'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`acorr_ljungbox`函数的信息，请访问官方文档：[https://www.statsmodels.org/dev/generated/statsmodels.stats.diagnostic.acorr_ljungbox.html](https://www.statsmodels.org/dev/generated/statsmodels.stats.diagnostic.acorr_ljungbox.html)。
