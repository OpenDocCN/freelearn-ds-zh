- en: Chapter 3. SciPy for Linear Algebra
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。SciPy线性代数
- en: In this chapter, we will continue exploring the different SciPy modules through
    meaningful examples. We will start with the treatment of matrices (whether normal
    or sparse) with the modules on Linear Algebra—`linalg` and `sparse`. Note that
    `linalg` expands on the NumPy module with the same name.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过有意义的示例继续探索SciPy的不同模块。我们将从使用线性代数模块`linalg`和`sparse`处理矩阵（无论是正常还是稀疏）开始。请注意，`linalg`扩展了同名的NumPy模块。
- en: This discipline of mathematics studies vector spaces and linear mappings between
    them. Matrices represent objects in this field in such a way that any property
    of the underlying objects may be obtained by performing adequate operations on
    the representing matrices. In this chapter, we assume that you are familiar with
    at least the basics of linear algebra, in particular with the notion of matrix
    multiplication, finding the determinant and inverse of a matrix, as well as their
    immediate applications in **vector calculus**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这门数学学科研究向量空间及其之间的线性映射。矩阵以这种方式代表该领域的对象，通过在表示矩阵上执行适当的操作，可以获取底层对象的任何属性。在本章中，我们假设您至少熟悉线性代学的基础知识，特别是矩阵乘法、求矩阵的行列式和逆矩阵以及它们在**向量微积分**中的直接应用。
- en: Accordingly, in this chapter, we will explore how vectors and matrices are handled
    in Numpy/SciPy, how to create them, how to program standard mathematical operations
    between them, and how to represent this on a functional form. Next, we will solve
    linear system of equations expressed in the matrix form involving dense or sparse
    matrices. The corresponding IPython Notebook will help you test the functionality
    of the modules involved and modify each illustrative example according to your
    specific needs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将探讨Numpy/SciPy中如何处理向量和矩阵，如何创建它们，如何编程它们之间的标准数学运算，以及如何在函数形式上表示这些运算。接下来，我们将解决以矩阵形式表示的线性方程组，涉及稠密或稀疏矩阵。相应的IPython
    Notebook将帮助您测试涉及模块的功能，并根据您的具体需求修改每个示例。
- en: Vector creation
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量创建
- en: 'As mentioned in [Chapter 2](ch02.html "Chapter 2. Working with the NumPy Array
    As a First Step to SciPy"), *Working with the NumPy Array As a First Step to SciPy*,
    SciPy depends on NumPy''s main object''s `ndarray` data structure. You can look
    at one-dimensional arrays as vectors and vice versa (oriented points in an n-dimensional
    space). Consequently, a vector can be created via Numpy as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如同[第2章](ch02.html "第2章。作为SciPy入门的NumPy数组处理")中提到的，*作为SciPy入门的NumPy数组处理*，SciPy依赖于NumPy的主要对象`ndarray`数据结构。您可以将一维数组视为向量，反之亦然（n维空间中的有向点）。因此，可以通过Numpy创建一个向量如下所示：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is shown as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also use already defined arrays to create a new candidate. Some examples
    were presented in the previous chapter. Here we can reverse the already created
    vector and assign it to a new one:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用已经定义的数组来创建一个新的候选者。前一章中已经提供了几个例子。这里我们可以将已经创建的向量反转并分配给一个新的向量：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is shown as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that in this example, we have to make a copy of the reverse of the elements
    of `vectorA` and assign it to `vectorB`. This way, by changing elements of `vectorB`,
    the elements of `vectorA` remain unchanged, as shown here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，我们必须复制`vectorA`元素的逆序并将其分配给`vectorB`。这样，通过改变`vectorB`的元素，`vectorA`的元素保持不变，如下所示：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is shown as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s look at `vectorA`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`vectorA`：
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is shown as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s make a copy of `vectorA` by reversing its elements and assigning it
    to `vectorB`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过反转其元素并将结果分配给`vectorB`来复制`vectorA`：
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is shown as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE9]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the last code statement, we repeated the previous assignment to `vectorB`,
    bringing it back to its initial values taking the reverse of `vectorA`, once again.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的代码语句中，我们重复了之前的赋值给`vectorB`的操作，使其再次回到其初始值，即`vectorA`的逆序。
- en: Vector operations
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量运算
- en: 'In addition to being mathematical entities studied in linear algebra, Vectors
    are widely used in physics and engineering as a convenient way to represent physical
    quantities as **displacement**, **velocity**, **acceleration**, force, and so
    on. Accordingly, basic operations between vectors can be performed via Numpy/SciPy
    operations as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了是线性代数中研究的数学实体外，向量在物理学和工程学中被广泛用作表示物理量（如**位移**、**速度**、**加速度**、力等）的便捷方式。因此，向量之间的基本运算可以通过Numpy/SciPy操作如下进行：
- en: Addition/subtraction
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加法/减法
- en: 'Addition/subtraction of vectors does not require any explicit loop to perform
    them. Let''s take a look at addition of two vectors:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的加法/减法不需要任何显式的循环来执行。让我们看看两个向量的加法：
- en: '[PRE10]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is shown as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE11]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Further, we perform subtraction on two vectors:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步，我们对两个向量进行减法操作：
- en: '[PRE12]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is shown as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE13]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Scalar/Dot product
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标量/点积
- en: 'Numpy has the built-in function dot to compute the scalar (`dot`) product between
    two vectors. We show you its use computing the `dot` product of `vectorA` and
    `vectorB` from the previous code snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Numpy有一个内置函数`dot`，用于计算两个向量之间的标量（`dot`）积。我们展示了如何使用它来计算前一个代码片段中`vectorA`和`vectorB`的`dot`积：
- en: '[PRE14]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is shown as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE15]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, to compute this product we could perform the element-wise product
    between the components of the vectors and then add the respective results. This
    is implemented in the following lines of code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了计算这个乘积，我们可以执行向量的各分量之间的逐元素乘积，然后将相应的结果相加。这已在以下代码行中实现：
- en: '[PRE16]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is shown as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE17]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Cross/Vector product – on three-dimensional space vectors
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交叉/向量积 – 在三维空间向量上
- en: 'First, two vectors in 3 dimensions are created before applying the built-in
    function from NumPy to compute the cross product between the vectors:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在应用NumPy的内置函数计算向量的叉积之前，创建了三个维度的两个向量：
- en: '[PRE18]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is shown as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE19]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Further, we perform a `cross` operation of `vectorB` over `vectorA`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步，我们对`vectorB`在`vectorA`上执行`cross`操作：
- en: '[PRE20]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is shown as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE21]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that the last expression shows the expected result that `vectorA` cross
    `vectorB` is the negative of `vectorB` cross `vectorA`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到最后一个表达式显示了预期的结果，即`vectorA`与`vectorB`的叉积是`vectorB`与`vectorA`叉积的相反数。
- en: Creating a matrix
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个矩阵
- en: 'In SciPy, a matrix structure is given to any one- or two-dimensional `ndarray`,
    with either the `matrix` or `mat` command. The complete syntax is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在SciPy中，任何一维或二维`ndarray`都可以通过`matrix`或`mat`命令获得矩阵结构。完整的语法如下：
- en: '[PRE22]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Creating matrices, the data may be given as `ndarray`, a string or a Python
    list (as the second example below), which is very convenient. When using strings,
    the semicolon denotes change of row and the comma, change of column:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 创建矩阵时，数据可以以`ndarray`、字符串或Python列表（如下面的第二个示例）的形式给出，这非常方便。当使用字符串时，分号表示行变化，逗号表示列变化：
- en: '[PRE23]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is shown a follows s:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE24]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s look at another example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个例子：
- en: '[PRE25]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is shown as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE26]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Another technique to create a matrix from a two-dimensional array is to enforce
    the matrix structure on a new object, copying the data of the former with the
    `asmatrix` routine.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个二维数组创建矩阵的另一种技术是将矩阵结构强加到新对象上，通过`asmatrix`例程复制前者的数据。
- en: A matrix is said to be sparse ([http://en.wikipedia.org/wiki/Sparse_matrix](http://en.wikipedia.org/wiki/Sparse_matrix))
    if most of its entries are zeros. It is a waste of memory to input such matrices
    in the usual way, especially if the dimensions are large. SciPy provides different
    procedures to store such matrices effectively in memory. Most of the usual methods
    to input sparse matrices are contemplated in SciPy as routines in the `scipy.sparse`
    module. Some of those methods are **block sparse row** (`bsr_matrix`), **coordinate
    format** (`coo_matrix`), compressed sparse column or row (`csc_matrix`, `csr_matrix`),
    sparse matrix with diagonal storage (`dia_matrix`), dictionary with **Keys-based
    sorting** (`dok_matrix`), and **Row-based linked list** (`lil_matrix`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个矩阵被称为稀疏矩阵 ([http://en.wikipedia.org/wiki/Sparse_matrix](http://en.wikipedia.org/wiki/Sparse_matrix))，如果其大多数条目都是零。以通常的方式输入这样的矩阵是浪费内存的，尤其是如果维度很大。SciPy
    提供了不同的程序来有效地在内存中存储这样的矩阵。SciPy 中的 `scipy.sparse` 模块考虑了大多数输入稀疏矩阵的常规方法作为例程。其中一些方法包括
    **块稀疏行** (`bsr_matrix`)，**坐标格式** (`coo_matrix`)，压缩稀疏列或行 (`csc_matrix`，`csr_matrix`)，具有对角存储的稀疏矩阵
    (`dia_matrix`)，基于 **键排序** 的字典 (`dok_matrix`)，以及 **基于行的链表** (`lil_matrix`)。
- en: 'At this point, we would like to present one of these: the coordinate format.
    In this format, and given a sparse matrix `A`, we identify the coordinates of
    the nonzero elements, say *n* of them, and we create two n-dimensional `ndarray`
    arrays containing the columns and the rows of those entries, and a third `ndarray`
    containing the values of the corresponding entries. For instance, notice the following
    sparse matrix:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们想介绍其中之一：坐标格式。在这个格式中，给定一个稀疏矩阵 `A`，我们识别非零元素的位置，比如说有 *n* 个，然后我们创建两个 n 维的
    `ndarray` 数组，包含这些条目的列和行，以及一个包含相应条目值的第三个 `ndarray`。例如，注意以下稀疏矩阵：
- en: '![Creating a matrix](img/7702OS_03_01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![创建矩阵](img/7702OS_03_01.jpg)'
- en: 'The standard form of creating such matrices is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此类矩阵的标准形式如下：
- en: '[PRE27]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is shown as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE28]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A more memory-efficient way to create these matrices would be to properly store
    the nonzero elements. In this case, one of the nonzero entries is at the 1^(st)
    row and 2^(nd) column (or location `(0, 1)` in Python) with value, `10`. Another
    nonzero entry is at `(1, 2)` with value, `20`. A 3^(rd) nonzero entry, with the
    value `30`, is located at `(2, 3)`. The last nonzero entry of `A` is located at
    `(3, 4)`, and has the value, `40`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些矩阵的一种更节省内存的方法是正确存储非零元素。在这种情况下，一个非零条目位于第 1 行第 2 列（或 Python 中的位置 `(0, 1)`），值为
    `10`。另一个非零条目位于 `(1, 2)`，值为 `20`。第三个非零条目，值为 `30`，位于 `(2, 3)`。`A` 的最后一个非零条目位于 `(3,
    4)`，值为 `40`。
- en: 'We then have `ndarray` of rows, `ndarray` of columns, and another `ndarray`
    of values:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有行 `ndarray`，列 `ndarray`，以及另一个值 `ndarray`：
- en: '[PRE29]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We create the matrix `A` as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下创建矩阵 `A`：
- en: '[PRE30]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is shown as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE31]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice how the `todense` method turns sparse matrices into full matrices. Also
    note that it obviates any row or column of full zeros following the last nonzero
    element.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `todense` 方法如何将稀疏矩阵转换为全矩阵。还请注意，它消除了最后一个非零元素之后的任何全零行或列。
- en: 'Associated to each input method, we have functions that identify sparse matrices
    of each kind. For instance, if we suspect that `A` is a sparse matrix in the `coo_matrix`
    format, we may use the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与每种输入方法相关联，我们都有识别每种类型稀疏矩阵的函数。例如，如果我们怀疑 `A` 是 `coo_matrix` 格式的稀疏矩阵，我们可以使用以下命令：
- en: '[PRE32]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is shown as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE33]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'All the array routines are cast to matrices, provided the input is a matrix.
    This is very convenient for matrix creation, especially thanks to stacking commands
    (`hstack`, `vstack`, `tile`). Besides these, matrices enjoy one more amazing stacking
    command, `bmat`. This routine allows the stacking of matrices by means of strings,
    making use of the convention: semicolon for change of row and comma for change
    of column. Also, it allows matrix names inside of the string to be evaluated.
    The following example is enlightening:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数组例程都转换为矩阵，只要输入是矩阵。这对于矩阵创建非常方便，尤其是在堆叠命令（`hstack`，`vstack`，`tile`）的帮助下。除此之外，矩阵还有一个令人惊叹的堆叠命令，`bmat`。这个例程允许通过字符串堆叠矩阵，利用以下约定：分号用于行变化，逗号用于列变化。它还允许在字符串内部评估矩阵名称。以下示例很有启发性：
- en: '[PRE34]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output is shown as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE35]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The main difference between arrays and matrices is in regards to the behavior
    of the product of two objects of the same type. For example, multiplication between
    two arrays means *element-wise multiplication of the entries of the two arrays*
    and requires two objects of the same shape. The following code snippet is an example
    of multiplication between two arrays:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和矩阵之间的主要区别在于相同类型两个对象的乘积行为。例如，两个数组之间的乘法意味着*两个数组条目的逐元素乘法*，并且需要具有相同形状的两个对象。以下是一个两个数组乘法示例的代码片段：
- en: '[PRE36]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is shown as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE37]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'On the other hand, matrix multiplication requires a first matrix with shape
    (*m*, *n*), and a second matrix with shape (*n*, *p*)—the number of columns in
    the first matrix must be the same as the number of rows in the second matrix.
    This operation offers a new matrix of shape (*m*, *p*), as shown in the following
    diagram:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，矩阵乘法需要一个形状为(*m*，*n*)的第一个矩阵和一个形状为(*n*，*p*)的第二个矩阵——第一个矩阵的列数必须与第二个矩阵的行数相同。这个操作会提供一个形状为(*m*，*p*)的新矩阵，如下面的图所示：
- en: '![Creating a matrix](img/7702OS_03_02.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![创建矩阵](img/7702OS_03_02.jpg)'
- en: 'The following is the code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码片段：
- en: '[PRE38]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is shown as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE39]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Alternatively, to obtain the matrix product between two conforming matrices
    as `ndarray` objects, we don''t really need to transform the `ndarray` object
    to a matrix object if not needed. The matrix product could be obtained directly
    via the `numpy.dot` function introduced earlier in the *Scalar/Dot product* section
    of this chapter. Let''s take a look at the following `numpy.dot` command example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了获得两个符合规范的矩阵作为`ndarray`对象的矩阵乘积，如果不需要，我们实际上不需要将`ndarray`对象转换为矩阵对象。矩阵乘积可以通过本章*标量/点积*部分中介绍过的`numpy.dot`函数直接获得。让我们看看以下`numpy.dot`命令的示例：
- en: '[PRE40]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output is shown as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE41]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we desire to perform an element-wise multiplication of the elements of two
    matrices, we can do so with the versatile `numpy.multiply` command, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要对两个矩阵的元素进行逐元素乘法，我们可以使用多功能的`numpy.multiply`命令，如下所示：
- en: '[PRE42]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is shown as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE43]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The other difference between arrays and matrices worth noticing is in regard
    to their shapes. While we allow arrays to have one dimension; their corresponding
    matrices must have at least two. This is very important to have in mind when we
    transpose either object. Let''s take a look at the following code snippet implementing
    `shape()` and `transpose()` commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和矩阵之间另一个值得注意的区别在于它们的形状。虽然我们允许数组有一个维度；它们对应的矩阵必须至少有两个维度。当我们转置任一对象时，这一点非常重要。让我们看看以下实现`shape()`和`transpose()`命令的代码片段：
- en: '[PRE44]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output is shown as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE45]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As it has been shown, SciPy offers quite a number of basic tools to instantiate
    and manipulate matrices, with many related methods to follow. This also allows
    us to speed up computations in the cases where special matrices are used.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，SciPy提供了相当多的基本工具来实例化和操作矩阵，还有许多相关的方法可以继续使用。这也允许我们在使用特殊矩阵的情况下加快计算速度。
- en: The `scipy.linalg` module provides commands to create special matrices such
    as block diagonal matrices from provided arrays (`block_diag`), **circulant matrices**
    (circulant), companion matrices (`companion`), **Hadamard matrices** (`hadamard`),
    **Hankel matrices** (`hankel`), **Hilbert** and **inverse Hilbert matrices** (`hilbert`,
    `invhilbert`), **Leslie matrices** (`leslie`), **square Pascal matrices** (`pascal`),
    **Toeplitz matrices** (`toeplitz`), **lower-triangular matrices** (`tril`), and
    **upper-triangular matrices** (`triu`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.linalg`模块提供了创建特殊矩阵的命令，例如从提供的数组创建块对角矩阵（`block_diag`）、**循环矩阵**（circulant）、伴随矩阵（`companion`）、**Hadamard矩阵**（`hadamard`）、**Hankel矩阵**（`hankel`）、**Hilbert**和**逆Hilbert矩阵**（`hilbert`，`invhilbert`）、**Leslie矩阵**（`leslie`）、**平方Pascal矩阵**（`pascal`）、**Toeplitz矩阵**（`toeplitz`）、**下三角矩阵**（`tril`）和**上三角矩阵**（`triu`）。'
- en: Let's see an example on **optimal weighings**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个关于**最优称重**的例子。
- en: Suppose we are given *p* objects to be weighed in *n* weighings with a two-pan
    balance. We create an *n* x *p* matrix of plus and minus one, where a positive
    value in the *(i, j)* position indicates that the *j^(th)* object is placed in
    the left pan of the balance in the *i^(th)* weighing and a negative value that
    the *j^(th)* object corresponding is in the right pan.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们给定 *p* 个物体需要在 *n* 次称重中使用双盘天平进行称重。我们创建一个 *n* x *p* 的矩阵，其中包含加号和减号，其中在 *(i,
    j)* 位置的正值表示在 *i^(th)* 次称重中，*j^(th)* 物体被放置在天平的左盘上，而负值表示相应的 *j^(th)* 物体在右盘上。
- en: 'It is known that optimal weighings are designed by submatrices of Hadamard
    matrices. For the problem of designing an optimal weighing for eight objects with
    three weighings, we could then explore different choices of three rows of a Hadamard
    matrix of order eight. The only requirement is that the sum of the elements on
    the row of the matrix is zero (so that the same number of objects are placed on
    each pan). Through slicing, we can accomplish just that:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 已知最优称重是由哈达玛矩阵的子矩阵设计的。对于设计八个物体的三次称重问题，我们可以探索八阶哈达玛矩阵的三行不同的选择。唯一的要求是矩阵行的元素之和为零（这样每个天平上放置的物体数量相同）。通过切片，我们可以实现这一点：
- en: '[PRE46]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output is shown as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE47]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `scipy.sparse` module has its own set of special matrices. The most common
    are matrices of those along diagonals (`eye`), identity matrices (`identity`),
    matrices from diagonals (`diags`, `spdiags`), block diagonal matrices from sparse
    matrices (`block_diag`), matrices from sparse sub-blocks (`bmat`), column-wise
    and row-wise stacks (`hstack`, `vstack`), and random matrices of a given shape
    and density with uniformly distributed values (`rand`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.sparse` 模块有其自己的一套特殊矩阵。最常见的是对角线上的矩阵（`eye`）、单位矩阵（`identity`）、从对角线生成的矩阵（`diags`,
    `spdiags`）、从稀疏矩阵生成的分块对角矩阵（`block_diag`）、从稀疏子块生成的矩阵（`bmat`）、按列和按行堆叠的矩阵（`hstack`,
    `vstack`），以及给定形状和密度的随机矩阵，其值均匀分布（`rand`）。'
- en: Matrix methods
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵方法
- en: 'Besides inheriting all the array methods, matrices enjoy four extra attributes:
    `T` for transpose, `H` for conjugate transpose, `I` for inverse, and `A` to cast
    as `ndarray`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了继承所有数组方法外，矩阵还享有四个额外的属性：`T` 用于转置，`H` 用于共轭转置，`I` 用于求逆，以及 `A` 用于转换为 `ndarray`：
- en: '[PRE48]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output is shown as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE49]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Operations between matrices
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵之间的运算
- en: 'We have briefly covered the most basic operation between two matrices; the
    matrix product. For any other kind of product, we resort to the basic utilities
    in the NumPy libraries, as: dot product for arrays or vectors (`dot`, `vdot`),
    inner and outer products of two arrays (`inner`, `outer`), **tensor dot product**
    along specified axes (`tensordot`), or the **Kronecker product** of two arrays
    (`kron`).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要介绍了两个矩阵之间最基本的操作；矩阵乘法。对于任何其他类型的乘法，我们求助于 NumPy 库中的基本工具，如：数组或向量的点积（`dot`, `vdot`）、两个数组的内积和外积（`inner`,
    `outer`）、沿指定轴的**张量点积**（`tensordot`）或两个数组的**克罗内克积**（`kron`）。
- en: Let's see an example of creating an **orthonormal** basis.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建一个**正交**基的例子。
- en: Create an orthonormal basis in the nine-dimensional real space from an orthonormal
    basis of the three-dimensional real space.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从三维实空间的正交归一基中创建九维实空间的正交归一基。
- en: 'Let''s choose, for example, the orthonormal basis formed by the vectors as
    shown in following diagram:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们选择如下图中所示的由向量构成的正交归一基：
- en: '![Operations between matrices](img/7702OS_03_03.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵之间的运算](img/7702OS_03_03.jpg)'
- en: 'We compute the desired basis by collecting these vectors in a matrix and using
    a Kronecker product, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将这些向量收集到一个矩阵中并使用克罗内克积来计算所需的基，如下所示：
- en: '[PRE50]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The columns of matrix `B` shown previously, give us an orthonormal basis directly.
    For instance, the vectors with odd indices would be the columns of the following
    submatrix:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的矩阵 `B` 的列直接给出了一个正交归一基。例如，奇数索引的向量将是以下子矩阵的列：
- en: '[PRE51]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output is shown as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE52]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Functions on matrices
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵上的函数
- en: 'The `scipy.linalg` module offers a useful set of functions on matrices. The
    basic two commands on square matrices are `inv` (for the inverse of a matrix)
    and `det` (for the determinant). The power of a square matrix is given by the
    standard exponentiation; that is, if `A` is a square matrix, then `A**2` indicates
    the matrix product `A*A`, which is shown in the following code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.linalg`模块为矩阵提供了一组有用的函数。对于方阵的基本两个命令是`inv`（矩阵的逆）和`det`（行列式）。方阵的幂由标准的指数运算给出；也就是说，如果`A`是一个方阵，那么`A**2`表示矩阵乘积`A*A`，如下面的代码片段所示：'
- en: '[PRE53]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output is shown as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE54]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It should be pointed out that as a type array, the product of `A*A` (or `A**2`)
    is calculated by squaring each element of the array:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出的是，作为一个类型数组，`A*A`（或`A**2`）的乘积是通过平方数组的每个元素来计算的：
- en: '[PRE55]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output is shown as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE56]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: More advanced commands compute matrix functions that rely on the power series
    representation of expressions involving matrix powers, such as the matrix **exponential**
    (for which there are three possibilities—`expm`, `expm2`, and `expm3`), the matrix
    **logarithm** (`logm`), matrix **trigonometric functions** (`cosm`, `sinm`, `tanm`),
    matrix **hyperbolic trigonometric functions** (`coshm`, `sinhm`, `tanhm`), the
    **matrix sign function** (`signm`), or the matrix **square root** (`sqrtm`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的命令计算依赖于涉及矩阵幂的表达式的幂级数表示的矩阵函数，例如矩阵**指数**（有三种可能性——`expm`、`expm2`和`expm3`），矩阵**对数**（`logm`），矩阵**三角函数**（`cosm`、`sinm`、`tanm`），矩阵**双曲三角函数**（`coshm`、`sinhm`、`tanhm`），**矩阵符号函数**（`signm`），或**矩阵平方根**（`sqrtm`）。
- en: Notice the difference between the application of the normal exponential function
    on a matrix, and the result of a matrix exponential function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意矩阵上正常指数函数的应用与矩阵指数函数的结果之间的区别。
- en: 'In the former case, we obtain the application of `numpy.exp` to each entry
    of the matrix; in the latter, we actually compute the exponential of the matrix
    following the power series representation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一种情况下，我们获得矩阵中每个元素的`numpy.exp`应用；在后一种情况下，我们实际上根据幂级数表示计算矩阵的指数：
- en: '![Functions on matrices](img/7702OS_03_04.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵上的函数](img/7702OS_03_04.jpg)'
- en: 'The preceding formula is illustrated in this code snippet:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了前面的公式：
- en: '[PRE57]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is shown as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE58]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s perform the `exp()` operation on `A`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`A`执行`exp()`操作：
- en: '[PRE59]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output is shown as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE60]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s perform the `expm()` operation on `A`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`A`执行`expm()`操作：
- en: '[PRE61]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output is shown as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE62]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: For sparse square matrices, we have an optimized inverse function, as well as
    a matrix exponential—`scipy.sparse.linalg.inv`, `scipy.sparse.linalg.expm`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于稀疏方阵，我们有一个优化的逆函数，以及矩阵指数——`scipy.sparse.linalg.inv`、`scipy.sparse.linalg.expm`。
- en: For general matrices, we have the basic norm function (norm), as well as two
    versions of the **Moore-Penrose pseudoinverse** (`pinv` and `pinv2`).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一般矩阵，我们有基本的范数函数（norm），以及两种版本的**Moore-Penrose伪逆**（`pinv`和`pinv2`）。
- en: 'Once again, we need to emphasize how important it is to rely on these functions,
    rather than coding their equivalent expressions manually. For instance, note the
    `norm` computation of vectors or matrices, `scipy.linalg.norm`. Let''s show you,
    by example, the 2-norm of a two-dimensional vector `v=numpy.matrix([x,y])`, where
    at least one of the `x` and `y` values is extremely large—large enough so that
    `x*x` overflows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，依赖这些函数而不是手动编码它们的等效表达式是多么重要。例如，注意向量的或矩阵的`norm`计算，`scipy.linalg.norm`。让我们通过以下示例向您展示二维向量`v=numpy.matrix([x,y])`的2-范数，其中至少一个`x`和`y`的值非常大——大到使得`x*x`溢出：
- en: '[PRE63]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output is shown as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE64]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, let''s perform the `sqrt()` operation:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行`sqrt()`操作：
- en: '[PRE65]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output is an error which is shown as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个错误，如下所示：
- en: '[PRE66]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Eigenvalue problems and matrix decompositions
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特征值问题和矩阵分解
- en: Another set of operations heavily used on matrices is to compute and handle
    eigenvalues and eigenvectors of square matrices. These two problems rank among
    the most complex operations that we can perform on square matrices, and extensive
    research has been put in place to obtain good algorithms with low complexity and
    optimal usage of memory resources. SciPy has state-of-the-art code to implement
    these ideas.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在矩阵上广泛使用的一组操作是计算和处理方阵的特征值和特征向量。这两个问题在我们能对方阵进行的复杂操作中排名很高，为此已经进行了大量研究，以获得低复杂度和最优内存资源使用的良好算法。SciPy提供了实现这些想法的先进代码。
- en: 'For the computation of eigenvalues, the `scipy.linalg` module provides three
    routines: `eigvals` (for any ordinary or general eigenvalue problem), `eigvalsh`
    (if the matrix is symmetric of complex **Hermitian**), and `eigvals_banded` (if
    the matrix is banded). To compute the eigenvectors, we similarly have three corresponding
    choices: `eig`, `eigh`, and `eigh_banded`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特征值的计算，`scipy.linalg`模块提供了三个例程：`eigvals`（用于任何普通或一般特征值问题）、`eigvalsh`（如果矩阵是对称的或复数的**厄米特**矩阵），以及`eigvals_banded`（如果矩阵是带状的）。为了计算特征向量，我们同样有三个相应的选择：`eig`、`eigh`和`eigh_banded`。
- en: 'The syntax used in all cases is very similar. For example, for the general
    case of eigenvalues, we use the following line of code where matrix `A` must be
    square:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 所用语法在所有情况下都非常相似。例如，对于特征值的通用情况，我们使用以下代码行，其中矩阵`A`必须是方阵：
- en: '[PRE67]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This should be the only parameter passed to the routine if we wish to solve
    an ordinary eigenvalue problem. If we wish to generalize this, we may provide
    an extra square matrix (of the same dimensions as matrix `A`). This is passed
    in the `B` parameter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望解决一个普通的特征值问题，那么应该只将这个参数传递给该例程。如果我们想推广这个概念，我们可以提供一个额外的方阵（与矩阵`A`具有相同的维度）。这个方阵通过`B`参数传递。
- en: 'The module also offers an extensive collection of functions that compute different
    decompositions of matrices, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块还提供了一组广泛的函数，用于计算矩阵的不同分解，如下所示：
- en: '**Pivoted LU decomposition**: This function allows us to use the `lu` and `lufactor`
    commands.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主元LU分解**：此函数允许我们使用`lu`和`lufactor`命令。'
- en: '**Singular value decomposition**: This function allows us to use the `svd`
    command. To compute the singular values, we issue `svdvals`. If we wish to compose
    the sigma matrix in the singular value decomposition from its singular values,
    we do so with the `diagsvd` routine. If we wish to compute an orthogonal basis
    for the range of a matrix using SVD, we can accomplish this with the `orth` command.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**奇异值分解**：此函数允许我们使用`svd`命令。为了计算奇异值，我们发出`svdvals`。如果我们想从奇异值组成奇异值分解中的sigma矩阵，我们使用`diagsvd`例程。如果我们想使用SVD计算矩阵范围的正交基，我们可以使用`orth`命令。'
- en: '**Cholesky decomposition**: This function allows us to use the `cholesky`,
    `cholesky_banded`, and `cho_factor` commands.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cholesky分解**：此函数允许我们使用`cholesky`、`cholesky_banded`和`cho_factor`命令。'
- en: '**QR and QZ decompositions**: This function allows us to use the `qr` and `qz`
    commands. If we wish to multiply a matrix with the matrix Q of a decomposition,
    we use the syntactic sugar `qr_multiply`, rather than performing this procedure
    in two steps.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QR和QZ分解**：此函数允许我们使用`qr`和`qz`命令。如果我们想将矩阵与分解的矩阵Q相乘，我们使用语法糖`qr_multiply`，而不是分两步执行此过程。'
- en: '**Schur and Hessenberg decompositions**: This function allows us to use the
    `schur` and `Hessenberg` commands. If we wish to convert a real Schur form to
    complex, we have the `rsf2csf` routine.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Schur和Hessenberg分解**：此函数允许我们使用`schur`和`Hessenberg`命令。如果我们想将实Schur形式转换为复数，我们有`rsf2csf`例程。'
- en: At this point, we have an interesting application—image compression, which makes
    use of some of the routines explained so far.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有一个有趣的应用——图像压缩，它利用了之前解释的一些例程。
- en: Image compression via the singular value decomposition
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过奇异值分解进行图像压缩
- en: 'This is a very simple application where a square image `A` of size *n* x *n*,
    and stored as `ndarray` is regarded as a matrix, and where a singular value decomposition
    (SVD) is performed on it. This operation is visible in the following diagram:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的应用，其中大小为*n* x *n*的方阵图像`A`，存储为`ndarray`被视为矩阵，并且对其执行奇异值分解（SVD）。此操作在以下图中可见：
- en: '![Image compression via the singular value decomposition](img/7702OS_03_05.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![通过奇异值分解进行图像压缩](img/7702OS_03_05.jpg)'
- en: 'From all the singular values of `s` we choose a fraction, together with their
    corresponding left and right singular vectors `u`, `v`. We compute a new matrix
    by collecting them according to the formula given in the following diagram:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从`s`的所有奇异值中选择一个分数，以及它们对应的左奇异向量`u`和右奇异向量`v`。我们根据以下图表中给出的公式收集它们来计算一个新的矩阵：
- en: '![Image compression via the singular value decomposition](img/7702OS_03_06.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![通过奇异值分解进行图像压缩](img/7702OS_03_06.jpg)'
- en: 'Note, for example, the similarity between the original (512 singular values)
    and an approximation using only 32 singular values:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，注意原始（512个奇异值）和仅使用32个奇异值进行的近似之间的相似性：
- en: '[PRE68]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This produces the following images, of which the picture to the left is the
    original image and the picture to the right, the approximation using 32 singular
    values:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下图像，其中左边的图片是原始图像，右边的图片是使用32个奇异值进行的近似：
- en: '![Image compression via the singular value decomposition](img/7702OS_03_07.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![通过奇异值分解进行图像压缩](img/7702OS_03_07.jpg)'
- en: Using the `svd` approximation we managed to compress the original image of 262,144
    coefficients (512 * 512)to only 32,800 coefficients ((2 * 32 * 512) + 32), or
    to one-eighth of the original information.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`svd`近似，我们成功将原始图像的262,144个系数（512 * 512）压缩到仅有32,800个系数（(2 * 32 * 512) + 32），即原始信息的八分之一。
- en: Solvers
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 求解器
- en: 'One of the fundamental applications of linear algebra is to solve large systems
    of linear equations. For the basic systems of the form *Ax=b*, for any square
    matrix `A` and general matrix `b` (with as many rows as columns in `A`), we have
    two generic methods to find *x* (`solve` for dense matrices and `spsolve` for
    sparse matrices), using the following syntax:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数的一个基本应用是求解大型线性方程组。对于形式为*Ax=b*的基本系统，对于任何方阵`A`和一般矩阵`b`（`A`的行数与列数相同），我们有两种通用的方法来找到*x*（对于密集矩阵使用`solve`，对于稀疏矩阵使用`spsolve`），语法如下：
- en: '[PRE69]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'There are solvers that are even more sophisticated in SciPy, with enhanced
    performance for situations in which the structure of the matrix `A` is known.
    For dense matrices we have three commands in the `scipy.linalg` module: `solve_banded`
    (for banded matrices), `solveh_banded` (if besides banded, `A` is Hermitian),
    and `solve_triangular` (for triangular matrices).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在SciPy中，有一些求解器比这更复杂，它们在矩阵`A`的结构已知的情况下具有增强的性能。对于密集矩阵，我们在`scipy.linalg`模块中有三个命令：`solve_banded`（用于带状矩阵），`solveh_banded`（如果除了带状，`A`是厄米特矩阵），以及`solve_triangular`（用于三角矩阵）。
- en: 'When a solution is not possible (for example, if `A` is a singular matrix),
    it is still possible to obtain a matrix *x* that minimizes the `norm` of *b-Ax*
    in a least-squares sense. We can compute such a matrix with the `lstsq` command,
    which has the following syntax:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当无法找到解（例如，如果`A`是一个奇异矩阵）时，仍然可以找到一个矩阵*x*，它在最小二乘意义上最小化*b-Ax*的`norm`。我们可以使用`lstsq`命令来计算这样一个矩阵，其语法如下：
- en: '[PRE70]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The output of this function is a tuple that contains the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的输出是一个包含以下内容的元组：
- en: The solution found (as `ndarray`)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到的解（作为`ndarray`）
- en: The sum of residues (as another `ndarray`)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 残差的和（作为另一个`ndarray`）
- en: The effective rank of the matrix `A`
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵`A`的有效秩
- en: The singular values of the matrix `A` (as another `ndarray`)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵`A`的奇异值（作为另一个`ndarray`）
- en: 'Let''s illustrate this routine with a simple example, to solve the following
    system:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来说明这个例程，以求解以下系统：
- en: '![Solvers](img/7702OS_03_08.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![求解器](img/7702OS_03_08.jpg)'
- en: 'The following is the code snippet:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码片段：
- en: '[PRE71]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output is shown as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE72]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s move further into the code and perform the following operations on `b`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步进入代码，并在`b`上执行以下操作：
- en: '[PRE73]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output is shown as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE74]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Further, let''s perform the `lstsq` operation:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步，让我们执行`lstsq`操作：
- en: '[PRE75]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output is shown as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE76]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `overwrite_` options are designed to enhance performance of the algorithms,
    and should be used carefully, since they destroy the original data.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`overwrite_`选项旨在提高算法的性能，应谨慎使用，因为它们会破坏原始数据。'
- en: The truly fastest solvers in SciPy are based upon decomposition of matrices.
    Reducing the system into something simpler easily solves huge and really complicated
    systems of linear equations. We may accomplish this using decomposition techniques
    presented in the *Eigenvalue problems and matrix decompositions* and *Image compression
    via the singular value decomposition* subsections under the *Matrix methods* section
    of this chapter, but of course, the SciPy philosophy is to help us deal with all
    nuisances of memory and resources internally. To this end, the module also has
    the `lu_solve` (for solutions based on LU decompositions), and `cho_solve`, `cho_solve_banded`
    (for solutions based on Cholesky decompositions).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy中真正最快的求解器基于矩阵分解。将系统简化为更简单的东西可以轻松解决巨大且真正复杂的线性方程组。我们可以使用本章“矩阵方法”部分的“特征值问题和矩阵分解”以及“通过奇异值分解进行图像压缩”子部分中提出的分解技术来完成这项工作，但当然，SciPy的哲学是帮助我们内部处理所有与内存和资源相关的烦恼。为此，该模块还提供了`lu_solve`（基于LU分解的解）、`cho_solve`、`cho_solve_banded`（基于Cholesky分解的解）。
- en: Finally, you will also find solvers for very complex matrix equations—the **Sylvester**
    equation (`solve_sylvester`), both the continuous and discrete algebraic **Riccati**
    equations (`solve_continuous_are`, `solve_discrete_are`) and both the continuous
    and discrete **Lyapunov** equations (`solve_discrete_lyapunov`, `solve_lyapunov`).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还会找到非常复杂的矩阵方程的求解器——**Sylvester**方程（`solve_sylvester`），包括连续和离散的代数**Riccati**方程（`solve_continuous_are`,
    `solve_discrete_are`）以及连续和离散的**Lyapunov**方程（`solve_discrete_lyapunov`, `solve_lyapunov`）。
- en: Most of the matrix decompositions and solutions to eigenvalue problems are contemplated
    for sparse matrices in the `scipy.sparse.linalg` module with a similar naming
    convention, but with much more robust use of computer resources and error control.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数矩阵分解和特征值问题的解都是在`scipy.sparse.linalg`模块中针对稀疏矩阵考虑的，命名约定相似，但计算机资源的使用和错误控制更加稳健。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored the treatment of vectors, matrices (whether normal or
    sparse) with the modules on linear algebra—`linalg` and `sparse.linalg`, which
    expand and improve the NumPy module with the same name.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了使用线性代数模块——`linalg`和`sparse.linalg`处理向量、矩阵（无论是普通还是稀疏）的方法，这些模块扩展并改进了同名的NumPy模块。
- en: In [Chapter 4](ch04.html "Chapter 4. SciPy for Numerical Analysis"), *SciPy
    for Numerical Analysis*, we will continue discussing details of the options available
    in SciPy to perform numerical computations efficiently, will cover how to evaluate
    special functions found in applied mathematics and mathematical physics problems.
    This will be discussed in details of doing regression, interpolation and optimization
    via SciPy.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。SciPy数值分析")《SciPy数值分析》中，我们将继续讨论SciPy中用于高效执行数值计算的可选项的细节，将涵盖如何评估应用数学和数学物理问题中找到的特殊函数。这将在本章“矩阵方法”部分的“特征值问题和矩阵分解”以及“通过奇异值分解进行图像压缩”子部分的细节中进行讨论。
