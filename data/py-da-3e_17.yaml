- en: Analyzing Image Data
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 分析图像数据
- en: We are in the age of information, where every movement will generate data in
    a variety of formats, such as text, images, geospatial data, and videos. Smartphones
    have reached rural areas of the world and people are capturing activities, especially
    in images and videos, and sharing them on social media platforms. This is how
    lots of big chunks of data are generated and most of the data is in image and
    video formats. Industry and research institutes want to analyze image and video
    datasets to generate value and make automated solutions to reduce costs. Image
    processing and computer vision are fields that explore and develop image- and
    video-based solutions. There are lots of opportunities for research, innovation,
    and start-ups in the area of computer vision. In this chapter, we focus on the
    basics of image processing to build your fundamental knowledge in the computer
    vision area.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正处在信息时代，每一个动作都会生成各种格式的数据，如文本、图像、地理空间数据和视频。智能手机已经进入世界各地的乡村，人们正在捕捉活动，特别是图像和视频，并将它们分享到社交媒体平台。这就是大量数据产生的方式，而且大部分数据以图像和视频的形式存在。工业和研究机构希望分析图像和视频数据集，以创造价值并制定自动化解决方案以降低成本。图像处理和计算机视觉是探索和开发基于图像和视频的解决方案的领域。在计算机视觉领域，有许多研究、创新和初创企业的机会。在本章中，我们将重点介绍图像处理的基础知识，帮助你建立计算机视觉领域的基本知识。
- en: Image processing is a subset of computer vision. Computer vision is an advanced
    and more powerful field within machine learning and artificial intelligence. Computer
    vision offers enormous applications, such as detecting objects, classifying images
    and objects, image captioning, and image segmentation. An image can be defined
    as two-dimensional signals in signal processing, a set of points in 2D or 3D in
    geometry, and a two-dimensional or three-dimensional NumPy array in Python. Image
    processing refers to processing image data and performing operations such as drawing,
    writing, resizing, flipping, blurring, changing the brightness, and detecting
    faces. In this chapter, we will focus on all these image processing operations
    in detail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理是计算机视觉的一个子集。计算机视觉是机器学习和人工智能领域内的一个高级且更强大的领域。计算机视觉提供了大量的应用，例如物体检测、图像和物体分类、图像字幕生成和图像分割。图像可以在信号处理中定义为二维信号，在几何学中定义为二维或三维的点集，在
    Python 中则是二维或三维的 NumPy 数组。图像处理是指处理图像数据，并执行绘制、书写、调整大小、翻转、模糊、改变亮度和检测人脸等操作。在本章中，我们将详细探讨所有这些图像处理操作。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing OpenCV
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 OpenCV
- en: Understanding image data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解图像数据
- en: Color models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 色彩模型
- en: Drawing on images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像上绘制
- en: Writing on images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像上写字
- en: Resizing images
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整图像大小
- en: Flipping images
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 翻转图像
- en: Changing the brightness
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变亮度
- en: Blurring an image
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊图像
- en: Face detection
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人脸检测
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章具有以下技术要求：
- en: 'You can find the code, face classifier file, and the datasets at the following
    Github link: [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter13](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter13)[.](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch13)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过以下 Github 链接找到代码、人脸分类器文件以及数据集：[https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter13](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter13)[.](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch13)
- en: All the code blocks are available in the `ch13.ipynb` file.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有代码块均可在 `ch13.ipynb` 文件中找到。
- en: This chapter uses `.jpg`/`.jpeg` files (`google.jpg`, `image.jpg`, `messi.png`,
    `nature.jpeg`, `barcelona.jpeg`, and `tajmahal.jpg`) for practice purposes.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章使用 `.jpg`/`.jpeg` 文件（`google.jpg`、`image.jpg`、`messi.png`、`nature.jpeg`、`barcelona.jpeg`
    和 `tajmahal.jpg`）进行练习。
- en: This chapter uses one face classifier XML file (`haarcascade_frontalface_default.xml`).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章使用一个人脸分类器 XML 文件（`haarcascade_frontalface_default.xml`）。
- en: In this chapter, we will use the OpenCV, NumPy, and matplotlib Python libraries.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 OpenCV、NumPy 和 matplotlib Python 库。
- en: Installing OpenCV
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 OpenCV
- en: 'OpenCV is an open source library for computer vision operations such as image
    and video analysis. OpenCV is primarily developed by Intel in C++ and offers interfaces
    with Python, Java, and Matlab. OpenCV has the following features:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV是一个开源库，提供计算机视觉操作，如图像和视频分析。OpenCV主要由Intel使用C++开发，并提供Python、Java和Matlab的接口。OpenCV具有以下特点：
- en: It is an open source image processing Python library.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个开源的图像处理Python库。
- en: OpenCV is the core Python library for image processing and computer vision.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV是图像处理和计算机视觉的核心Python库。
- en: OpenCV is easy to learn and deploy with web and mobile applications.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV易于学习和在网页和移动应用程序中部署。
- en: OpenCV in Python is an API and wrapper around its C++ core implementation.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV在Python中是一个API和它C++核心实现的包装器。
- en: It is fast due to background C++ code.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它因为后台C++代码而运行速度很快。
- en: 'We can install OpenCV using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令安装OpenCV：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using the preceding pip command, we can easily install OpenCV. OpenCV is the
    most popular library for image processing and computer vision tasks. It offers
    various use cases related to image analysis operations such as improving image
    quality, filtering and transforming images, drawing on images, changing colors,
    detecting faces and objects, identifying human actions, tracking objects, analyzing
    motion, and finding similar images. After installing the OpenCV library, it's
    time to understand the basics of image processing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面提到的pip命令，我们可以轻松安装OpenCV。OpenCV是最受欢迎的图像处理和计算机视觉库。它提供了多种与图像分析操作相关的用例，例如提高图像质量、过滤和转换图像、在图像上绘制、改变颜色、检测人脸和物体、识别人类动作、跟踪物体、分析运动以及查找相似图像。安装完OpenCV库后，接下来就是了解图像处理的基础。
- en: Understanding image data
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解图像数据
- en: 'Image data is a two-dimensional array or function `f(x,y)` with spatial coordinates.
    The amplitude of the `coordinate(x,y)` is known as intensity. In Python, an image
    is a 2D or 3D NumPy array with pixel values. Pixels are the smallest, core tiny
    picture elements, which decide the image quality. A large number of pixels results
    in a higher resolution. Also, there are various image formats available, such
    as `.``jpeg`, `.png`, `.gif`, and `.tiff`. These file formats are helpful in organizing
    and maintaining digital image files. Before analyzing image data, we need to understand
    the types of images. Image data can be of three types:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图像数据是一个二维数组或函数`f(x,y)`，带有空间坐标。`coordinate(x,y)`的幅度称为强度。在Python中，图像是一个二维或三维的NumPy数组，包含像素值。像素是最小的图像单元，决定图像的质量。像素数量越多，分辨率越高。此外，还有多种图像格式可用，例如`.jpeg`、`.png`、`.gif`和`.tiff`。这些文件格式有助于组织和管理数字图像文件。在分析图像数据之前，我们需要了解图像的类型。图像数据有三种类型：
- en: Binary
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二值图像
- en: Grayscale
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灰度
- en: Color
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色
- en: Binary images
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二值图像
- en: Binary image pixels have only two colors, generally black and white. Binary
    image pixels take only binary values 0 or 1.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 二值图像像素只有两种颜色，一般是黑色和白色。二值图像像素仅使用二进制值0或1。
- en: '![](img/be833763-eeaf-4f2d-83e5-96cd7826d04e.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be833763-eeaf-4f2d-83e5-96cd7826d04e.png)'
- en: The preceding image is an example of a binary image. It has only two colors,
    black and white. It does not use shades of black and white.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图像是二值图像的示例。它只有两种颜色，黑色和白色，且不使用黑白的不同阴影。
- en: Grayscale images
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灰度图像
- en: A grayscale image looks like a black and white image. It is represented by 8
    bits per pixel, that is, 256 intensity values or tones ranging from 0 to 255\.
    These 256 shades move from pure black to pure white; 0 represents pure black while
    255 represents the color white.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度图像看起来像黑白图像。它由每个像素8位表示，也就是说有256个强度值或色调，范围从0到255。这256种色调从纯黑到纯白过渡；0代表纯黑，而255代表白色。
- en: '![](img/707a69e9-3a34-42f3-83a8-5b962598e35e.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/707a69e9-3a34-42f3-83a8-5b962598e35e.png)'
- en: The preceding image is a grayscale image. It is a black and white image where
    shades move from pure black to pure white.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图像是灰度图像。它是一个黑白图像，其中的色调从纯黑过渡到纯白。
- en: Color images
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 彩色图像
- en: 'Color images are a mixture of the primary colors red, blue, and green. These
    primary colors have the capability to form new colors by blending in certain proportions.
    Each color uses eight bits (intensity values between 0-255), that is, 24 bits
    per pixel. Let''s take an example of a color image:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 彩色图像是由红色、蓝色和绿色三种基本颜色混合而成。这些基本颜色具有按一定比例混合形成新颜色的能力。每种颜色使用8位（强度值在0到255之间），即每个像素24位。让我们看一个彩色图像的例子：
- en: '![](img/be37f829-ac45-43a3-aec0-8d91aedeae31.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be37f829-ac45-43a3-aec0-8d91aedeae31.png)'
- en: In the preceding image file, we can see most of the color shades with different
    intensities. After understanding the type of images, it's time to understand color
    models such as RGB, CMYK, HSV, HSL, and grayscale. Let's jump to color models.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像文件中，我们可以看到不同强度的各种颜色阴影。了解了图像类型之后，接下来就是了解RGB、CMYK、HSV、HSL和灰度等颜色模型。让我们来看看颜色模型。
- en: Color models
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色模型
- en: 'Color models are a structure for processing and measuring the combination of
    primary colors. They help us to explain how colors will display on the computer
    screen or on paper. Color models can be of two types: additive or subtractive.
    Additive models are used for computer screens, for example, the RGB (red, green,
    and blue) model, and subtractive models are used for printing images, for example,
    the CMYK (cyan, magenta, yellow, and black) model:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色模型是一种用于处理和测量原色组合的结构。它们帮助我们解释颜色在计算机屏幕或纸张上的显示方式。颜色模型可以分为两种类型：加法模型和减法模型。加法模型用于计算机屏幕，例如RGB（红色、绿色和蓝色）模型，减法模型用于图像打印，例如CMYK（青色、品红色、黄色和黑色）模型：
- en: '![](img/abbdc731-fa1c-4e51-ad1b-301597242bd9.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abbdc731-fa1c-4e51-ad1b-301597242bd9.png)'
- en: There are lots of models other than RGB and CMYK, such as HSV, HSL, and Gray
    Scale. HSV is an acronym for hue, saturation, and value. It is a three-dimensional
    color model, which is an improved version of the RGB model. In the HSV model,
    the top of the center axis is white, the bottom is black, and the remaining colors
    lie in between. Here, the hue is the angle, saturation is the distance from the
    center axis, and value is the distance from the bottom of the axis.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了RGB和CMYK，还有许多其他模型，如HSV、HSL和灰度模型。HSV是色调、饱和度和明度的缩写。它是一个三维颜色模型，是RGB模型的改进版本。在HSV模型中，中心轴的顶部是白色，底部是黑色，剩余的颜色位于其间。在这里，色调是角度，饱和度是离中心轴的距离，明度是离轴底部的距离。
- en: HSL is an acronym for hue, saturation, and lightness. The main difference between
    HSV and HSL is the amount of lightness and the value of colors from the center
    axis.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: HSL是色调、饱和度和亮度的缩写。HSV和HSL的主要区别在于亮度的量和颜色在中心轴上的值。
- en: '![](img/04a62af2-b68e-4586-ab6d-cf2789b9a00e.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04a62af2-b68e-4586-ab6d-cf2789b9a00e.png)'
- en: 'Let''s learn how to read and display the image file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何读取和显示图像文件：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This results in the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/29a3e562-3c87-4a8c-9067-7307faf75f69.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29a3e562-3c87-4a8c-9067-7307faf75f69.png)'
- en: 'In the preceding example, we imported `cv2`, NumPy, and `matplotlib.pyplot`.
    `cv2` is for image processing, NumPy is for arrays, and `matplotlib.pyplot` is
    for displaying an image. We read the image using the `imread()` function and returned
    an array of images. We can check its type using the `type()` function and its
    shape using the `shape` attribute of the NumPy array. We can display the image
    using the `show()` function of the `matpltlib.pyplot` module. The preceding image
    is not showing the correct colors of the Google logo image. This is because `imread()`
    reads images in the BGR color model. Lets convert BGR to the RGB color model using
    the `cvtColor()` function and passing tthe flag `cv2.COLOR_BGR2RGB`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们导入了`cv2`、NumPy和`matplotlib.pyplot`。`cv2`用于图像处理，NumPy用于数组，`matplotlib.pyplot`用于显示图像。我们使用`imread()`函数读取图像，并返回一个图像数组。我们可以使用`type()`函数检查其类型，并通过NumPy数组的`shape`属性查看其形状。我们可以使用`matpltlib.pyplot`模块的`show()`函数显示图像。前面的图像未显示Google徽标图像的正确颜色，这是因为`imread()`函数以BGR颜色模型读取图像。让我们使用`cvtColor()`函数将BGR转换为RGB颜色模型，并传递标志`cv2.COLOR_BGR2RGB`：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This results in the following output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/52f718fb-86b0-4a87-a371-41e86a25057f.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52f718fb-86b0-4a87-a371-41e86a25057f.png)'
- en: Here, you can see the correct image in RGB format.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到RGB格式下正确的图像。
- en: 'Let''s write the image file on a local disk using the `imwrite()` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`imwrite()`函数将图像文件写入本地磁盘：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code block, we have written the image file on a local disk
    with the image name `image.jpg`. After understanding color models, it's time to
    learn how to draw elements on an image.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们已经将图像文件写入本地磁盘，文件名为`image.jpg`。理解了颜色模型之后，接下来就是学习如何在图像上绘制元素。
- en: Drawing on images
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图像上绘制
- en: 'Let''s learn how to draw different figure shapes, such as a line, square, or
    triangle, on an image using OpenCV. When we draw any shape on an image, we need
    to take care of the coordinates, color, and thickness of the shape. Let''s first
    create a blank image with a white or black background:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何在图像上使用 OpenCV 绘制不同的图形形状，如线条、正方形或三角形。当我们在图像上绘制任何形状时，我们需要注意形状的坐标、颜色和粗细。首先，我们创建一个背景为白色或黑色的空白图像：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This results in the following output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/ecdc3915-4e69-4fc3-ac05-c7c2abc70fd7.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecdc3915-4e69-4fc3-ac05-c7c2abc70fd7.png)'
- en: In the preceding example, we created a blank image with a black background using
    the `zeros()` function of the NumPy module. The `zeros()` function creates an
    array of the given size and fills the matrix with zeros.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用 NumPy 模块的`zeros()`函数创建了一个背景为黑色的空白图像。`zeros()`函数创建一个给定大小的数组，并用零填充矩阵。
- en: 'Let''s create a blank image with a white background:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个背景为白色的空白图像：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This results in the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/fa9e9d82-e338-4be8-83d7-f8f96c6f1de2.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa9e9d82-e338-4be8-83d7-f8f96c6f1de2.png)'
- en: 'In the preceding example, we created a blank image with a white background
    using the `zeros()` function of the NumPy module and filled the image with 255
    for each pixel. The `zeros()` function creates an array of the given size and
    fills the matrix with zeros. The `fill()` function assigns a given value to all
    the elements of the matrix. Let''s draw a line using OpenCV on a black image:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用 NumPy 模块的`zeros()`函数创建了一个背景为白色的空白图像，并将每个像素的值填充为 255。`zeros()`函数创建一个给定大小的数组，并用零填充矩阵。`fill()`函数将给定的值赋给矩阵中的所有元素。接下来，我们将在一张黑色图像上使用
    OpenCV 绘制一条线：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This results in the following output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/ad50b113-98f2-4ec4-83a6-95967e4c3ebf.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad50b113-98f2-4ec4-83a6-95967e4c3ebf.png)'
- en: 'In the preceding example, we drew the green line on the black image using the
    `line()` function. The `line()` function takes the following arguments: image
    file, `start_point`, `end_point`, color, and thickness. In our example, the start
    and endpoints are (599,0) and (0,599), the color tuple is (0,255,0), and the thickness
    is 4\. Similarly, we can create a line on a white image. Let''s see the following
    example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`line()`函数在黑色图像上绘制了绿色线条。`line()`函数接受以下参数：图像文件，`start_point`，`end_point`，颜色和粗细。在我们的示例中，起点和终点分别是
    (599,0) 和 (0,599)，颜色元组是 (0,255,0)，粗细为 4。同样，我们可以在白色图像上创建一条线。让我们看看以下示例：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This results in the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/b0f328e6-f9f3-47fc-9448-a3cea18c12e6.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0f328e6-f9f3-47fc-9448-a3cea18c12e6.png)'
- en: 'Let''s see an example of drawing a circle on a white image:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在白色图像上绘制圆形的示例：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This results in the following output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/dc8f192c-851a-470b-956f-260e9843a5af.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc8f192c-851a-470b-956f-260e9843a5af.png)'
- en: 'In the preceding example, we created a white image and drew a circle using
    the `circle()` function. The `circle()` function takes the following arguments:
    image, `center_coordinates`, radius, color, and thickness. In our example, the
    center is (300, 300), the radius is 100, a color tuple is (255,0,0), and the thickness
    is 6.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个白色图像并使用`circle()`函数绘制了一个圆。`circle()`函数接受以下参数：图像，`center_coordinates`，半径，颜色和粗细。在我们的示例中，圆心是
    (300, 300)，半径是 100，颜色元组是 (255,0,0)，粗细是 6。
- en: 'Let''s see an example of drawing a rectangle on a black image:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在黑色图像上绘制矩形的示例：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This results in the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/2ec1550b-9e86-4e38-83f4-dc9c15e8a4f5.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ec1550b-9e86-4e38-83f4-dc9c15e8a4f5.png)'
- en: 'In the preceding example, we created a black image and drew a rectangle using
    the `rectangle()` function. The `rectangle()` function takes the following arguments:
    image, `start_point`, `end_point`, color, and thickness. Here, thickness also
    takes an argument `-1`, the `-1` px value will fill the rectangle shape with the
    specified color. Let''s see an example of a filled rectangle:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个黑色图像，并使用`rectangle()`函数绘制了一个矩形。`rectangle()`函数接受以下参数：图像，`start_point`，`end_point`，颜色和粗细。这里，粗细还可以接受一个参数`-1`，`-1`像素值将填充矩形形状并指定颜色。让我们看一个填充矩形的示例：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This results in the following output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/fad53d80-1e53-4070-9fde-3a996e76ca8e.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fad53d80-1e53-4070-9fde-3a996e76ca8e.png)'
- en: In the preceding example, we filled the rectangle by passing thickness values
    as -1 px. In a nutshell, we can say that the line takes mainly the start and endpoints
    as the input, the rectangle takes the top-left and the bottom-right coordinates,
    and the circle takes center coordinates and radius values.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们通过传递厚度值为-1 px来填充矩形。简而言之，我们可以说，线条主要以起始点和终点为输入，矩形以左上角和右下角坐标为输入，圆形则以中心坐标和半径值为输入。
- en: Writing on images
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图像上写字
- en: 'In the previous section, we created various shapes on images. Now, we will
    learn how to write text on images. Writing text on an image is similar to drawing
    shapes. Let''s see an example of writing on an image:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们在图像上创建了各种形状。现在，我们将学习如何在图像上写文字。在图像上写文字类似于绘制形状。让我们看看在图像上写字的例子：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This results in the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到以下输出：
- en: '![](img/a1e7e723-853d-4407-8eda-080ed11f136b.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1e7e723-853d-4407-8eda-080ed11f136b.png)'
- en: 'In the preceding example, we created a blank image with the color black. We
    have written text on an image using the `putText()` function. The `putText()`
    function will take the following arguments: image, text, coordinates of the bottom-left
    corner, font, `fontScale`, color, thickness, and `linetype`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个颜色为黑色的空白图像。我们使用`putText()`函数在图像上写了文字。`putText()`函数将接受以下参数：图像、文字、左下角坐标、字体、`fontScale`、颜色、厚度和`linetype`。
- en: Resizing images
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整图像大小
- en: 'Resizing an image means changing the dimension or scaling of a given image.
    Scaling or resizing is done either from the width, height, or both. One of the
    applications of resizing images is training deep learning models where reduced
    image sizes can speed up the training. Training a deep learning model is out of
    the scope of this book. If you are interested, then you can refer to any deep
    learning book from Packt Publishing. Let''s see an example of resizing an image:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 调整图像大小是指改变给定图像的尺寸或缩放。缩放或调整大小可以通过宽度、高度或两者进行。调整图像大小的应用之一是训练深度学习模型，在这种情况下，缩小的图像尺寸可以加速训练。本书不涉及训练深度学习模型。如果你感兴趣，可以参考Packt出版的任何深度学习书籍。让我们看看调整图像大小的例子：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This results in the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到以下输出：
- en: '![](img/68efbd7f-e4d1-4474-96a7-68e4580c7376.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68efbd7f-e4d1-4474-96a7-68e4580c7376.png)'
- en: 'In the preceding code, we read the image and converted it from BGR into the
    RGB space. Let''s resize it now using the `resize()` function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们读取了图像并将其从BGR空间转换为RGB空间。现在让我们使用`resize()`函数来调整图像大小：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This results in the following output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到以下输出：
- en: '![](img/b2deb151-83b5-4020-9698-96f27f21013b.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2deb151-83b5-4020-9698-96f27f21013b.png)'
- en: 'In the preceding example, we read the image, converted BGR to RGB color using
    the `cvtColor()` function, and resized the image using the `resize()` function.
    The `resize()` function takes the following arguments: image, size, and interpolation.
    Interpolation is used to scale moire-free images. Interpolation takes one of the
    following flags: `INTER_NEAREST` (for nearest-neighbor interpolation), `INTER_LINEAR`
    (bilinear interpolation), and `INTER_AREA` (resampling using pixel area relation).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们读取了图像，使用`cvtColor()`函数将BGR转换为RGB颜色，并使用`resize()`函数调整了图像大小。`resize()`函数将接受以下参数：图像、尺寸和插值。插值用于缩放无摩尔纹的图像。插值接受以下标志之一：`INTER_NEAREST`（最近邻插值）、`INTER_LINEAR`（双线性插值）和`INTER_AREA`（使用像素区域关系进行重采样）。
- en: Flipping images
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻转图像
- en: 'Flipping an image is equivalent to a mirror effect. Let''s learn how to flip
    an image across the *x* axis (vertical flipping), *y* axis (horizontal flipping),
    or both axes. OpenCV offers the `flip()` function to flip an image. The `flip()`
    function will take two arguments: image and flipcode. The image is a NumPy array
    of pixel values and the flipcode used defines the type of flip, such as horizontal,
    vertical, or both. The following flipcode values are for different types of flips:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 翻转图像相当于镜像效果。让我们学习如何沿* x *轴（垂直翻转）、* y *轴（水平翻转）或两个轴翻转图像。OpenCV提供了`flip()`函数来翻转图像。`flip()`函数将接受两个参数：图像和flipcode。图像是像素值的NumPy数组，flipcode定义了翻转类型，如水平翻转、垂直翻转或两者。以下flipcode值表示不同类型的翻转：
- en: Flipcode > 0 is for a horizontal flip.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flipcode > 0表示水平翻转。
- en: Flipcode = 0 is for a vertical flip.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flipcode = 0表示垂直翻转。
- en: Flipcode < 0 is for both a horizontal and vertical flip.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flipcode < 0表示水平和垂直翻转。
- en: 'Let''s see an example of flipping an image:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看翻转图像的例子：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This results in the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到以下输出：
- en: '![](img/5663bc78-a38a-4ab9-9120-0fa76efb8fb9.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5663bc78-a38a-4ab9-9120-0fa76efb8fb9.png)'
- en: 'This is the original image, of Lionel Messi. Let''s flip it horizontally using
    the `flip()` function by passing 1 as the flipcode in the `flip()` function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原始图像，展示了莱昂内尔·梅西的照片。让我们使用`flip()`函数通过将1作为flipcode传递给`flip()`函数，将图像水平翻转：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This results in the following output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/bad1b298-a750-4f95-97af-8e70a9f17024.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bad1b298-a750-4f95-97af-8e70a9f17024.png)'
- en: 'This is the horizontally flipped image. Let''s flip the original image vertically:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是水平翻转后的图像。让我们将原始图像垂直翻转：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This results in the following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/42ddf381-81cc-462d-a6dd-e74e98db6c5e.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42ddf381-81cc-462d-a6dd-e74e98db6c5e.png)'
- en: 'You can see the vertically flipped image. Let''s flip the original image on
    both axes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到垂直翻转后的图像。让我们在两个轴上翻转原始图像：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This results in the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/7d664c59-8a20-4ede-9030-3ae72e769a4c.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d664c59-8a20-4ede-9030-3ae72e769a4c.png)'
- en: You can see the vertically and horizontally flipped image. After flipping the
    image, let's learn how to change the brightness of the image in the next section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到垂直和水平翻转后的图像。在翻转图像后，接下来让我们学习如何更改图像的亮度。
- en: Changing the brightness
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变亮度
- en: Brightness is a comparative term that is determined by visual perception. Sometimes
    it is difficult to perceive the brightness. The value of pixel intensity can help
    us to find a brighter image. For example, if two pixels have the intensity values
    110 and 230, then the latter one is brighter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 亮度是一个由视觉感知决定的相对概念。有时候很难感知亮度。像素强度的值可以帮助我们找到更亮的图像。例如，如果两个像素的强度值分别是110和230，那么后者更亮。
- en: 'In OpenCV, adjusting image brightness is a very basic operation. Brightness
    can be controlled by changing the intensity of each pixel in an image:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCV中，调整图像亮度是一个非常基础的操作。亮度可以通过改变图像中每个像素的强度来控制：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This results in the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/7d7bd975-084f-48d1-9e10-615dec4e44c9.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d7bd975-084f-48d1-9e10-615dec4e44c9.png)'
- en: 'In the preceding code example, we have read the image and converted the BGR
    color model-based image into an RGB color model-based image. Let''s change the
    brightness of the image in the following code block:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们读取了图像并将基于BGR色彩模型的图像转换为基于RGB色彩模型的图像。接下来，让我们在以下代码块中更改图像的亮度：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This results in the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/565994a3-d029-43a2-985a-c145bf7694dc.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/565994a3-d029-43a2-985a-c145bf7694dc.png)'
- en: 'In the preceding example, we added the two matrices with the given weightage;
    alpha and beta using the `addWeighted()` function. `addWeighted()` takes the following
    arguments: `first_image`, `alpha, second_image`, `gamma`, and `beta`. In our example,
    the argument `first_image` input image and the argument `second_image` is the
    null matrix. The values of `alpha` and `beta` are the weights for both matrices
    and `gamma` is 0.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`addWeighted()`函数将两个矩阵按给定的权重（alpha和beta）相加。`addWeighted()`函数需要以下参数：`first_image`、`alpha`、`second_image`、`gamma`和`beta`。在我们的示例中，`first_image`是输入图像，而`second_image`是空矩阵。`alpha`和`beta`的值是两个矩阵的权重，`gamma`为0。
- en: Blurring an image
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像模糊
- en: Blurring is one of the crucial steps of image preprocessing. In preprocessing,
    the removal of noise impacts the performance of algorithms. Blurring is the process
    of reducing noise in image data to achieve better accuracy. Blurring also helps
    us to take charge of handling pixel intensity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊是图像预处理中的一个关键步骤。在预处理过程中，去除噪声对算法的表现有很大影响。模糊是减少图像数据噪声的过程，以实现更好的准确性。模糊也帮助我们处理像素强度。
- en: 'Let''s see an example of blurring an image:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个模糊图像的示例：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This results in the following output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/5c7fadcd-940c-41ec-af6f-20f83059e767.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c7fadcd-940c-41ec-af6f-20f83059e767.png)'
- en: 'In the preceding code sample, we read the image and converted it from a BGR
    to RGB based image. Let''s blur it using the `blur()` function. Blur takes two
    arguments: image and kernel size. The `blur()` function uses the average blurring
    method:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们读取了图像并将其从BGR转换为RGB图像。现在，让我们使用`blur()`函数对其进行模糊处理。`blur()`函数需要两个参数：图像和内核大小。`blur()`函数使用平均模糊方法：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This results in the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/163204d0-ae8f-450c-8d1f-74eca759d268.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/163204d0-ae8f-450c-8d1f-74eca759d268.png)'
- en: 'In the preceding example, we read the image, converted BGR to RGB color using
    the `cvtColor()` function, and displayed the image. Here, we blurred the image
    using the `blur()` function. The `blur()` function applies average blurring, which
    uses a normalized box filter. The `blur()` function takes the following arguments:
    image and kernel size.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们读取了图像，使用`cvtColor()`函数将BGR转换为RGB颜色，并显示了图像。在这里，我们使用`blur()`函数对图像进行了模糊处理。`blur()`函数应用了均值模糊，使用了归一化的盒式滤波器。`blur()`函数接受以下参数：图像和内核大小。
- en: 'We have seen a blurred image using average blurring. Let''s explore blurring
    using Gaussian blurring. In this blurring, the Gaussian kernel is used instead
    of a box filter. `GaussianBlur()` will take the image and kernel size. The kernel
    size will be a tuple of the width and height. Both width and height must be a
    positive and odd number:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了使用均值模糊处理的图像。让我们探索使用高斯模糊进行模糊处理。在这种模糊处理中，使用了高斯核而不是盒式滤波器。`GaussianBlur()`将接受图像和内核大小。内核大小将是一个由宽度和高度组成的元组。宽度和高度必须是正数且为奇数：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This results in the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/f4346a12-f6e3-42b9-9abf-bf8b9c9c26e0.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4346a12-f6e3-42b9-9abf-bf8b9c9c26e0.png)'
- en: 'Let''s explore the median blurring of the given image. Median blur takes pixels
    in the kernel area and replaces the central element with the median value. `medianBlur()`
    will take image and kernel size as an argument. It is recommended that the kernel
    size should be an odd number and greater than 1, for example, 3, 5, 7, 9, 11,
    and so on:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索给定图像的中值模糊。中值模糊将内核区域的像素取出，并将中央元素替换为中位值。`medianBlur()`将接受图像和内核大小作为参数。建议内核大小应该是一个大于1的奇数，例如3、5、7、9、11等：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This results in the following output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/f5ac0ef4-2ceb-4d7a-8924-d03d8bce731c.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5ac0ef4-2ceb-4d7a-8924-d03d8bce731c.png)'
- en: In the preceding code block, we blurred the image using median blurring. Here,
    we used the `medianBlur()` method for median blurring and we can observe the blurred
    image in the output. In this section, we discussed average blurring, Gaussian
    blurring, and median blurring techniques. In the next section, we will learn how
    to detect human faces in images.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用中值模糊对图像进行了模糊处理。在这里，我们使用了`medianBlur()`方法进行中值模糊处理，并且可以在输出中观察到模糊后的图像。在本节中，我们讨论了均值模糊、高斯模糊和中值模糊技术。在下一节中，我们将学习如何在图像中检测人脸。
- en: Face detection
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人脸检测
- en: Nowadays, everyone is using Facebook and you all must have seen facial recognition
    in an image on Facebook. Facial recognition identifies who a face belongs to and
    face detection only finds faces in an image, that is, face detection does not
    determine to whom the detected face belongs. Face detection in a given input image
    is quite a popular functionality in lots of applications; for example, counting
    the number of people in an image. In face detection, the algorithm tries to find
    human faces in a digital image.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大家都在使用Facebook，你们一定都见过Facebook上的图像人脸识别。人脸识别能够识别出一张脸属于谁，而人脸检测仅仅是找出图像中的人脸，也就是说，人脸检测并不确定被检测到的脸属于谁。人脸检测在许多应用中都很常见；例如，统计图像中的人数。在人脸检测中，算法试图在数字图像中找到人脸。
- en: 'Face detection is a kind of classification problem. We can classify images
    into two classes, face or not face. We need lots of images to train such a model
    for classification. Thankfully, OpenCV offers pre-trained models such as the Haar
    Feature-Based Cascade Classifier and the **Local Binary Pattern** (**LBP**) classifier,
    trained on thousands of images. In our example, we will use Haar feature extraction
    to detect a face. Let''s see how to capture a face in an image using OpenCV:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 人脸检测是一个分类问题。我们可以将图像分为两类，脸或非脸。我们需要大量的图像来训练这样的分类模型。幸运的是，OpenCV提供了预训练的模型，如Haar特征级联分类器和**局部二值模式**（**LBP**）分类器，这些分类器在数千张图像上进行了训练。在我们的示例中，我们将使用Haar特征提取来检测人脸。让我们看看如何使用OpenCV在图像中捕捉人脸：
- en: 'Read the image and convert it into grayscale:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取图像并将其转换为灰度图：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This results in the following output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/f3468c8d-b2ff-4b9a-81fe-6249cfa3f3f5.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3468c8d-b2ff-4b9a-81fe-6249cfa3f3f5.png)'
- en: In the preceding code example, we read the Lionel Messi image and converted
    it into a grayscale image using the `cvtColor()` function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们读取了莱昂内尔·梅西的图像，并使用`cvtColor()`函数将其转换为灰度图像。
- en: 'Let''s find the faces in the generated gray image:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在生成的灰度图像中找到人脸：
- en: 'Load the Haar cascade face classifier file:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载Haar级联人脸分类器文件：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Get coordinates for all the faces in the image:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取图像中所有人脸的坐标：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Draw a rectangle on detected faces:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检测到的面部上绘制矩形：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Convert image color space BGR to RGB and display the image:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像颜色空间从BGR转换为RGB并显示图像：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This results in the following output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到以下输出：
- en: '![](img/7c803d9f-c090-4999-951b-28b500decdab.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c803d9f-c090-4999-951b-28b500decdab.png)'
- en: 'In the preceding example, we converted the BGR image to a grayscale image.
    OpenCV has pre-trained classifiers for face, eye, and smile detection. We can
    use a pre-trained face cascade classifier XML file (`haarcascade_frontalface_default.xml`).
    You can get the classifier file (`haarcascade_frontalface_default.xml`) from the
    official Git repo: [https://github.com/opencv/opencv/tree/master/data/haarcascades](https://github.com/opencv/opencv/tree/master/data/haarcascades)
    or you can get it from our GitHub repo: [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter13](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter13).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将BGR图像转换为灰度图像。OpenCV已经预先训练了面部、眼睛和微笑检测的分类器。我们可以使用预训练的面部级联分类器XML文件（`haarcascade_frontalface_default.xml`）。你可以从官方Git仓库获取分类器文件（`haarcascade_frontalface_default.xml`）：[https://github.com/opencv/opencv/tree/master/data/haarcascades](https://github.com/opencv/opencv/tree/master/data/haarcascades)，或者你也可以从我们的GitHub仓库获取：
    [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter13](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter13)。
- en: 'After this, we can pass the image to the cascade classifier and get the face
    coordinates in the image. We have drawn rectangles on these face coordinates using
    the `rectangle()` function. Before displaying the output, we need to convert the
    RGB image to BGR to display it properly. Let''s try this example on an image with
    multiple faces:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以将图像传递给级联分类器，并获取图像中的面部坐标。我们已经使用`rectangle()`函数在这些面部坐标上绘制了矩形。显示输出之前，我们需要将RGB图像转换为BGR，以便正确显示它。让我们在一张包含多个面部的图像上尝试这个示例：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This results in the following output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到以下输出：
- en: '![](img/a5fb031e-9d60-4b9a-8848-5d93a2cfca36.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5fb031e-9d60-4b9a-8848-5d93a2cfca36.png)'
- en: In the preceding example, we can see the program has detected all the faces
    in the image.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到程序已经检测到图像中的所有面部。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed image processing using OpenCV. The main focus
    of the chapter was on basic image processing operations and face detection. The
    chapter started with an introduction to types of images and image color models.
    In later sections, the focus was on image operations such as drawing, resizing,
    flipping, and blurring an image. In the last section, we discussed face detection
    in a given input image
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了使用OpenCV进行图像处理。本章的主要内容是基础的图像处理操作和面部检测。章节开始时介绍了图像类型和图像颜色模型。在后续部分，重点讨论了图像操作，例如绘制、调整大小、翻转和模糊图像。在最后部分，我们讨论了在给定输入图像中的面部检测。
- en: The next chapter, [Chapter 14](b106abe7-1a2a-44d1-bf17-778e1588e0f1.xhtml),
    *Parallel Computing Using Dask*, will focus on parallel computation on basic data
    science Python libraries such as Pandas, NumPy, and scikit-learn using Dask. The
    chapter will start with Dask data types such as dataframes, arrays, and bags.
    In later sections, we'll shift focus from dataFrames and arrays to delayed, preprocessing,
    and machine learning algorithms in parallel using Dask.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，[第14章](b106abe7-1a2a-44d1-bf17-778e1588e0f1.xhtml)，*使用Dask进行并行计算*，将重点讨论使用Dask对基本的数据科学Python库（如Pandas、NumPy和scikit-learn）进行并行计算。章节将从Dask的数据类型（如数据框、数组和袋子）开始。在后续部分，我们将把重点从数据框和数组转移到使用Dask进行并行延迟、预处理和机器学习算法。
