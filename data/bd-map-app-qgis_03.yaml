- en: Chapter 3. Learning the QGIS Python API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 学习QGIS Python API
- en: In this chapter, we will take a closer look at the Python libraries available
    for the QGIS Python developer, and also look at the various ways in which we can
    use these libraries to perform useful tasks within QGIS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地了解QGIS Python开发者可用的Python库，并探讨我们可以使用这些库在QGIS中执行有用任务的多种方式。
- en: 'In particular, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是你会学到：
- en: How the QGIS Python libraries are based on the underlying C++ APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QGIS Python库是如何基于底层C++ API的
- en: How to use the C++ API documentation as a reference to work with the Python
    APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将C++ API文档作为参考来处理Python API
- en: How the PyQGIS libraries are organized
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyQGIS库是如何组织的
- en: The most important concepts and classes within the PyQGIS libraries and how
    to use them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyQGIS库中最重要概念和类以及如何使用它们
- en: Some practical examples of performing useful tasks using PyQGIS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyQGIS执行有用任务的实用示例
- en: About the QGIS Python APIs
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于QGIS Python API
- en: The QGIS system itself is written in C++, and has its own set of APIs that are
    also written in C++. The Python APIs are implemented as wrappers around these
    C++ APIs. For example, there is a Python class named `QgisInterface` that acts
    as a wrapper around a C++ class of the same name. All the methods, class variables,
    and the like that are implemented by the C++ version of `QgisInterface` are made
    available through the Python wrapper.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS系统本身是用C++编写的，并有一套自己的API，这些API也是用C++编写的。Python API作为这些C++ API的包装器来实现。例如，有一个名为`QgisInterface`的Python类，它作为同名的C++类的包装器。`QgisInterface`的C++版本实现的所有方法、类变量等，都通过Python包装器提供。
- en: 'What this means is that when you access the Python QGIS APIs, you aren''t accessing
    the API directly. Instead, the wrapper connects your code to the underlying C++
    objects and methods, as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当你访问Python QGIS API时，你不是直接访问API。相反，包装器将你的代码连接到底层的C++对象和方法，如下所示：
- en: '![About the QGIS Python APIs](img/00021.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![关于QGIS Python API](img/00021.jpeg)'
- en: Fortunately, in most cases, the QGIS Python wrappers simply hide away the complexity
    of the underlying C++ code, so the PyQGIS libraries work as you would expect them
    to. There are some gotchas, however, and we will cover these as they come up.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在大多数情况下，QGIS Python包装器简单地隐藏了底层C++代码的复杂性，所以PyQGIS库会按你期望的方式工作。然而，也有一些需要注意的问题，我们将在遇到时进行讨论。
- en: Deciphering the C++ documentation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解读C++文档
- en: 'As QGIS is implemented in C++, the documentation for QGIS APIs is all based
    on C++. This can make it difficult for Python developers to understand and work
    with the QGIS APIs. For example, the API documentation for the `QgsInterface.zoomToActiveLayer()`
    method:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于QGIS是用C++实现的，因此QGIS API的文档都是基于C++的。这可能会让Python开发者难以理解和使用QGIS API。例如，`QgsInterface.zoomToActiveLayer()`方法的API文档：
- en: '![Deciphering the C++ documentation](img/00022.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![解读C++文档](img/00022.jpeg)'
- en: 'If you''re not familiar with C++, this can be quite confusing. Fortunately,
    as a Python programmer, you can skip over much of the complexity as it doesn''t
    apply to you. In particular:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉C++，这可能会相当令人困惑。幸运的是，作为一个Python程序员，你可以跳过很多复杂性，因为它们对你不适用。特别是：
- en: The `virtual` keyword is an implementation detail you don't need to worry about
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtual`关键字是你不需要关心的实现细节'
- en: '`void` indicates that the method doesn''t return a value'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`表示该方法不返回任何值'
- en: The double colons in `QgisInterface::zoomToActiveLayer` are simply a C++ convention
    for separating the class name from the method name
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QgisInterface::zoomToActiveLayer`中的双冒号是C++中用于分隔类名和方法名的约定'
- en: 'Just like in Python, the parentheses show that the method doesn''t take any
    parameters. So if you have an instance of `QgisInterface` (for example, as the
    standard `iface` variable available in the Python Console), you can call this
    method simply by typing the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Python中一样，括号表明该方法不接收任何参数。所以如果你有一个`QgisInterface`的实例（例如，作为Python控制台中的标准`iface`变量），你可以通过简单地输入以下内容来调用此方法：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s take a look at a slightly more complex example: the C++ documentation
    for the `QgisInterface.addVectorLayer()` method looks like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个稍微复杂一点的例子：`QgisInterface.addVectorLayer()`方法的C++文档如下所示：
- en: '![Deciphering the C++ documentation](img/00023.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![解读C++文档](img/00023.jpeg)'
- en: Notice how the `virtual` keyword is followed by `QgsVectorLayer*` instead of
    `void`. This is the return value for this method; it returns a `QgsVector` object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `virtual` 关键字后面跟随的是 `QgsVectorLayer*` 而不是 `void`。这是此方法的返回值；它返回一个 `QgsVector`
    对象。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Technically speaking, `*` means that the method returns a **pointer** to an
    object of type `QgsVectorLayer`. Fortunately, Python wrappers automatically handle
    pointers, so you don't need to worry about this.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，`*` 表示该方法返回一个指向类型为 `QgsVectorLayer` 的对象的指针。幸运的是，Python 包装器会自动处理指针，因此您无需担心这一点。
- en: Notice the brief description at the bottom of the documentation for this method;
    while many of the C++ methods have very little, if any, additional information,
    other methods have more extensive information. Obviously, you should read these
    descriptions carefully as they tell you more about what the method does.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文档底部对此方法的简要描述；虽然许多 C++ 方法几乎没有，甚至没有任何附加信息，但其他方法有更详细的信息。显然，您应该仔细阅读这些描述，因为它们会告诉您更多关于方法的功能。
- en: Even without any description, the C++ documentation is still useful as it tells
    you what the method is called, what parameters it accepts, and what type of data
    is being returned.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有任何描述，C++ 文档仍然很有用，因为它告诉您方法的名称、它接受哪些参数以及返回的数据类型。
- en: 'In the preceding method, you can see that there are three parameters listed
    in between the parentheses. As C++ is a *strongly typed* language, you have to
    define the type of each parameter when you define a function. This is helpful
    for Python programmers as it tells you what type of value to supply. Apart from
    QGIS objects, you might also encounter the following data types in the C++ documentation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，您可以看到在括号之间列出了三个参数。由于 C++ 是一种强类型语言，因此在定义函数时必须定义每个参数的类型。这对 Python 程序员很有帮助，因为它告诉您应该提供什么类型的值。除了
    QGIS 对象外，您还可能在 C++ 文档中遇到以下数据类型：
- en: '| Data type | Description |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `int` | A standard Python integer value |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 标准的 Python 整数值 |'
- en: '| `long` | A standard Python long integer value |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 标准的 Python 长整数值 |'
- en: '| `float` | A standard Python floating point (real) number |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 标准的 Python 浮点（实数）数 |'
- en: '| `bool` | A Boolean value (`true` or `false`) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 布尔值（`true` 或 `false`） |'
- en: '| `QString` | A string value. Note that the QGIS Python wrappers automatically
    convert Python strings to C++ strings, so you don''t need to deal with `QString`
    objects directly |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `QString` | 字符串值。请注意，QGIS Python 包装器会自动将 Python 字符串转换为 C++ 字符串，因此您无需直接处理
    `QString` 对象 |'
- en: '| `QList` | This object is used to encapsulate a list of other objects. For
    example, `QList<QString*>` represents a list of strings |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `QList` | 此对象用于封装其他对象的列表。例如，`QList<QString*>` 表示字符串列表 |'
- en: 'Just as in Python, a method can take default values for each parameter. For
    example, the `QgisInterface.newProject()` method looks like the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 Python 中一样，方法可以为每个参数设置默认值。例如，`QgisInterface.newProject()` 方法的样子如下：
- en: '![Deciphering the C++ documentation](img/00024.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![解析 C++ 文档](img/00024.jpeg)'
- en: In this case, the `thePromptToSaveFlag` parameter has a default value, and this
    default value will be used if no value is supplied.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，`thePromptToSaveFlag` 参数有一个默认值，如果没有提供值，将使用此默认值。
- en: 'In Python, classes are initialized using the `__init__` method. In C++, this
    is called a *constructor*. For example, the constructor for the `QgsLabel` class
    looks like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，类使用 `__init__` 方法进行初始化。在 C++ 中，这被称为构造函数。例如，`QgsLabel` 类的构造函数如下所示：
- en: '![Deciphering the C++ documentation](img/00025.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![解析 C++ 文档](img/00025.jpeg)'
- en: Just as in Python, C++ classes *inherit* the methods defined in their superclass.
    Fortunately, QGIS doesn't have an extensive class hierarchy, so most of the classes
    don't have a superclass. However, don't forget to check for a superclass if you
    can't find the method you're looking for in the documentation for the class itself.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 Python 中一样，C++ 类会 *继承* 它们的超类中定义的方法。幸运的是，QGIS 没有庞大的类层次结构，因此大多数类没有超类。但是，如果您在类的文档中找不到您要查找的方法，不要忘记检查超类。
- en: Finally, be aware that C++ supports the concept of *method overloading*. A single
    method can be defined more than once, where each version accepts a different set
    of parameters. For example, take a look at the constructor for the `QgsRectangle`
    class—you will see that there are four different versions of this method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，C++ 支持方法重载的概念。一个方法可以定义多次，其中每个版本接受不同的参数集。例如，看看 `QgsRectangle` 类的构造函数——您会看到有四种不同版本的这个方法。
- en: 'The first version accepts the four coordinates as floating point numbers:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个版本接受四个坐标作为浮点数：
- en: '![Deciphering the C++ documentation](img/00026.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![解读 C++ 文档](img/00026.jpeg)'
- en: 'The second version constructs a rectangle using two `QgsPoint` objects:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本使用两个 `QgsPoint` 对象构建一个矩形：
- en: '![Deciphering the C++ documentation](img/00027.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![解读 C++ 文档](img/00027.jpeg)'
- en: 'The third version copies the coordinates from `QRectF` (which is a Qt data
    type) into a `QgsRectangle` object:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个版本将坐标从 `QRectF`（这是一个 Qt 数据类型）复制到一个 `QgsRectangle` 对象中：
- en: '![Deciphering the C++ documentation](img/00028.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![解读 C++ 文档](img/00028.jpeg)'
- en: 'The final version copies the coordinates from another `QgsRectangle` object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个版本将坐标从另一个 `QgsRectangle` 对象复制过来：
- en: '![Deciphering the C++ documentation](img/00029.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![解读 C++ 文档](img/00029.jpeg)'
- en: The C++ compiler chooses the correct method to use based on the parameters that
    have been supplied. Python has no concept of method overloading; just choose the
    version of the method that accepts the parameters you want to supply, and the
    QGIS Python wrappers will automatically choose the correct method for you.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 编译器根据提供的参数选择正确的方法。Python 没有方法重载的概念；只需选择接受您想要提供的参数的方法版本，QGIS Python 包装器将自动为您选择正确的方法。
- en: If you keep these guidelines in mind, deciphering the C++ documentation for
    QGIS isn't all that hard. It just looks more complicated than it really is, thanks
    to all the complexity specific to C++. However, it doesn't take long for your
    brain to start filtering out the C++ gobbledygook, and you'll be able to use the
    QGIS reference documentation almost as easily as if it was written for Python
    rather than C++.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记住这些指南，解读 QGIS 的 C++ 文档并不那么困难。它看起来比实际更复杂，这要归功于所有特定的 C++ 复杂性。然而，您的头脑很快就会开始过滤掉
    C++ 的混乱，您将能够几乎像阅读为 Python 编写的文档一样轻松地使用 QGIS 参考文档。
- en: Organizing the QGIS Python libraries
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织 QGIS Python 库
- en: 'Now that we can understand the C++-oriented documentation, let''s see how the
    PyQGIS libraries are structured. All of the PyQGIS libraries are organized under
    a package named `qgis`. You wouldn''t normally import `qgis` directly, however,
    as all the interesting libraries are subpackages within this main package; here
    are the five packages that make up the PyQGIS library:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够理解面向 C++ 的文档，让我们看看 PyQGIS 库是如何组织的。所有的 PyQGIS 库都组织在一个名为 `qgis` 的包下。然而，您通常不会直接导入
    `qgis`，因为所有有趣的库都是这个主包内的子包；以下是构成 PyQGIS 库的五个包：
- en: '| `qgis.core` | This provides access to the core GIS functionality used throughout
    QGIS. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `qgis.core` | 这提供了访问 QGIS 中使用的核心 GIS 功能。|'
- en: '| `qgis.gui` | This defines a range of GUI widgets that you can include in
    your own programs. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `qgis.gui` | 这定义了一系列 GUI 小部件，您可以将它们包含在自己的程序中。|'
- en: '| `qgis.analysis` | This provides spatial analysis tools to analyze vector
    and raster format data. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `qgis.analysis` | 这提供了分析矢量格式和栅格格式数据的空间分析工具。|'
- en: '| `qgis.networkanalysis` | This provides tools to build and analyze topologies.
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `qgis.networkanalysis` | 这提供了构建和分析拓扑的工具。|'
- en: '| `qgis.utils` | This implements miscellaneous functions that allow you to
    work with the QGIS application using Python. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `qgis.utils` | 这实现了允许您使用 Python 与 QGIS 应用程序一起工作的各种函数。|'
- en: The first two packages (`qgis.core` and `qgis.gui`) implement the most important
    parts of the PyQGIS library, and it's worth spending some time to become more
    familiar with the concepts and classes they define. Let's take a closer look at
    these two packages now.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个包（`qgis.core` 和 `qgis.gui`）实现了 PyQGIS 库的最重要部分，花些时间熟悉它们定义的概念和类是值得的。现在让我们更详细地看看这两个包。
- en: The qgis.core package
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`qgis.core` 包'
- en: The `qgis.core` package defines fundamental classes used throughout the QGIS
    system. A large part of this package is dedicated to working with vector and raster
    format geospatial data, and displaying these types of data within a map. Let's
    see how this is done.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`qgis.core`包定义了在整个QGIS系统中使用的根本类。这个包的大部分内容是专门用于处理矢量格式和栅格格式地理空间数据，并在地图中显示这些类型的数据。让我们看看这是如何实现的。'
- en: Maps and map layers
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地图和地图图层
- en: 'A map consists of multiple layers drawn one on top of the other:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 地图由多个图层组成，这些图层一个叠在另一个上面：
- en: '![Maps and map layers](img/00030.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![地图和地图图层](img/00030.jpeg)'
- en: 'There are three types of map layers supported by QGIS:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS支持三种类型的地图图层：
- en: '**Vector layer**: This layer draws geospatial features such as points, lines,
    and polygons'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矢量图层**：此图层绘制地理空间特征，如点、线和多边形'
- en: '**Raster layer**: This layer draws raster (bitmapped) data onto a map'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栅格图层**：此图层将栅格（位图）数据绘制到地图上'
- en: '**Plugin layer**: This layer allows a plugin to draw directly onto a map'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件图层**：此图层允许插件直接在地图上绘制'
- en: Each of these types of map layers has a corresponding class within the `qgis.core`
    library. For example, a vector map layer will be represented by an object of type
    `qgis.core.QgsVectorLayer`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的地图图层在`qgis.core`库中都有相应的类。例如，矢量地图图层将由`qgis.core.QgsVectorLayer`类型的对象表示。
- en: We will take a closer look at vector and raster map layers shortly. Before we
    do this, though, we need to learn how geospatial data (both vector and raster
    data) is positioned on a map.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快更详细地了解矢量图层和栅格图层。不过，在我们这样做之前，我们需要了解地理空间数据（矢量数据和栅格数据）是如何定位在地图上的。
- en: Coordinate reference systems
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 坐标参考系统
- en: 'Since the Earth is a three-dimensional object, while maps represent the Earth''s
    surface as a two-dimensional plane, there has to be a way of translating from
    points on the Earth''s surface into (x,y) coordinates within a map. This is done
    using a **Coordinate Reference System** (**CRS**):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于地球是一个三维物体，而地图将地球表面表示为二维平面，因此必须有一种方法将地球表面的点转换为地图内的(x,y)坐标。这是通过使用**坐标参考系统**（**CRS**）来完成的：
- en: '![Coordinate reference systems](img/00031.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![坐标参考系统](img/00031.jpeg)'
- en: Globe image courtesy Wikimedia ([http://commons.wikimedia.org/wiki/File:Rotating_globe.gif](http://commons.wikimedia.org/wiki/File:Rotating_globe.gif))
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 地球仪图像由维基媒体提供（[http://commons.wikimedia.org/wiki/File:Rotating_globe.gif](http://commons.wikimedia.org/wiki/File:Rotating_globe.gif)）
- en: 'A CRS has two parts: an **ellipsoid**, which is a mathematical model of the
    Earth''s surface, and a **projection**, which is a formula that converts points
    on the surface of the spheroid into (x,y) coordinates on a map.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标参考系统（CRS）有两个部分：一个**椭球体**，它是地球表面的数学模型，以及一个**投影**，它是一个将球面上各点转换为地图上的(x,y)坐标的公式。
- en: Fortunately, most of the time you can simply select the appropriate CRS that
    matches the CRS of the data you are using. However, because many different coordinate
    reference systems have been devised over the years, it is vital that you use the
    correct CRS when plotting your geospatial data. If you don't do this, your features
    will be displayed in the wrong place or have the wrong shape.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数时候，你可以简单地选择与你要使用的数据的CRS相匹配的适当CRS。然而，由于多年来已经设计了多种不同的坐标参考系统，因此在绘制你的地理空间数据时使用正确的CRS至关重要。如果你不这样做，你的特征将显示在错误的位置或具有错误的形状。
- en: The majority of geospatial data available today uses the **EPSG 4326** coordinate
    reference system (sometimes also referred to as WGS84). This CRS defines coordinates
    as latitude and longitude values. This is the default CRS used for new data imported
    into QGIS. However, if your data uses a different coordinate reference system,
    you will need to create and use a different CRS for your map layer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 今天大多数可用的地理空间数据使用**EPSG 4326**坐标参考系统（有时也称为WGS84）。此CRS定义坐标为经纬度值。这是将新数据导入QGIS时使用的默认CRS。但是，如果你的数据使用不同的坐标参考系统，你将需要为你的地图图层创建并使用不同的CRS。
- en: 'The `qgis.core.QgsCoordinateReferenceSystem` class represents a CRS. Once you
    create your coordinate reference system, you can tell your map layer to use that
    CRS when accessing the underlying data. For example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`qgis.core.QgsCoordinateReferenceSystem`类表示一个CRS。一旦你创建了你的坐标参考系统，你可以告诉你的地图图层在访问底层数据时使用该CRS。例如：'
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that different map layers can use different coordinate reference systems.
    Each layer will use its CRS when drawing the contents of the layer onto the map.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不同的地图图层可以使用不同的坐标参考系统。每个图层在将图层内容绘制到地图上时都会使用其自己的CRS。
- en: Vector layers
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矢量图层
- en: A vector layer draws geospatial data onto a map in the form of points, lines,
    polygons, and so on. Vector-format geospatial data is typically loaded from a
    **vector data source** such as a shapefile or database. Other vector data sources
    can hold vector data in memory, or load data from a web service across the Internet.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量层以点、线、多边形等形式将地理空间数据绘制到地图上。矢量格式的地理空间数据通常从**矢量数据源**（如shapefile或数据库）加载。其他矢量数据源可以在内存中存储矢量数据，或从互联网上的网络服务加载数据。
- en: 'A vector-format data source has a number of features, where each feature represents
    a single *record* within the data source. The `qgis.core.QgsFeature` class represents
    a feature within a data source. Each feature has the following components:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量格式数据源具有许多特征，其中每个特征代表数据源中的单个*记录*。`qgis.core.QgsFeature`类代表数据源中的特征。每个特征具有以下组件：
- en: '**ID**: This is the feature''s unique identifier within the data source'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ID**：这是特征在数据源中的唯一标识符'
- en: '**Geometry**: This is the underlying point, line, polygon, and so on, which
    represents the feature on the map. For example, a **city** data source would have
    one feature for each city, and the geometry would typically be either a point
    that represents the center of the city, or a polygon (or a multipolygon) that
    represents the city''s outline.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**几何形状**：这是地图上特征的底层点、线、多边形等，代表地图上的特征。例如，城市数据源会为每个城市有一个特征，几何形状通常是表示城市中心的点，或者表示城市轮廓的多边形（或多边形集合）。'
- en: '**Attributes**: These are key/value pairs that provide additional information
    about the feature. For example, a city data source representing cities might have
    attributes such as `total_area`, `population`, `elevation`, and so on. Attribute
    values can be strings, integers, or floating point numbers.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：这些是键值对，提供了关于特征的额外信息。例如，代表城市的城市数据源可能具有`total_area`（总面积）、`population`（人口）、`elevation`（海拔）等属性。属性值可以是字符串、整数或浮点数。'
- en: 'In QGIS, a **data provider** allows the vector layer to access the features
    within the data source. The data provider, an instance of `qgis.core.QgsVectorDataProvider`,
    includes:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在QGIS中，**数据提供者**允许矢量层访问数据源中的特征。数据提供者是一个`qgis.core.QgsVectorDataProvider`的实例，包括：
- en: A **geometry type** that is stored in the data source
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**几何类型**：这是在数据源中存储的几何类型'
- en: A list of **fields** that provide information about the attributes stored for
    each feature
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个提供关于每个特征存储的属性信息的**字段**列表
- en: The ability to search through the features within the data source, using the
    `getFeatures()` method and the `QgsFeatureRequest` class
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getFeatures()`方法和`QgsFeatureRequest`类在数据源中的特征中进行搜索的能力
- en: You can access the various vector (and also raster) data providers by using
    the `qgis.core.QgsProviderRegistry` class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`qgis.core.QgsProviderRegistry`类来访问各种矢量（以及栅格）数据提供者。
- en: 'The vector layer itself is represented by a `qgis.core.QgsVectorLayer` object.
    Each vector layer includes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量层本身由一个`qgis.core.QgsVectorLayer`对象表示。每个矢量层包括：
- en: '**Data provider**: This is the connection to the underlying file or database
    that holds the geospatial information to be displayed'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据提供者**：这是连接到包含要显示的地理空间信息的底层文件或数据库的连接'
- en: '**Coordinate reference system**: This indicates which CRS the geospatial data
    uses'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坐标参考系统**：这表示地理空间数据使用哪个CRS'
- en: '**Renderer**: This chooses how the features are to be displayed'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染器**：这决定了如何显示特征'
- en: Let's take a closer look at the concept of a renderer and how features are displayed
    within a vector map layer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看渲染器的概念以及如何在矢量地图层中显示特征。
- en: Displaying vector data
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示矢量数据
- en: The features within a vector map layer are displayed using a combination of
    **renderer** and **symbol** objects. The renderer chooses the symbol that has
    to be used for a given feature, and the symbol that does the actual drawing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量地图层中的特征是通过**渲染器**和**符号**对象的组合来显示的。渲染器选择用于特定特征的符号，而符号执行实际的绘制。
- en: 'There are three basic types of symbols defined by QGIS:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS定义了三种基本的符号类型：
- en: '**Marker symbol**: This displays a point as a filled circle'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标记符号**：这以填充圆的形式显示点'
- en: '**Line symbol**: This draws a line using a given line width and color'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线符号**：这使用给定的线宽和颜色绘制线'
- en: '**Fill symbol**: This draws the interior of a polygon with a given color'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**填充符号**：这使用给定的颜色绘制多边形的内部'
- en: 'These three types of symbols are implemented as subclasses of the `qgis.core.QgsSymbolV2`
    class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种类型的符号作为`qgis.core.QgsSymbolV2`类的子类实现：
- en: '`qgis.core.QgsMarkerSymbolV2`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qgis.core.QgsMarkerSymbolV2`'
- en: '`qgis.core.QgsLineSymbolV2`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qgis.core.QgsLineSymbolV2`'
- en: '`qgis.core.QgsFillSymbolV2`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qgis.core.QgsFillSymbolV2`'
- en: Note
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering why all these classes have "V2" in their name. This is
    a historical quirk of QGIS. Earlier versions of QGIS supported both an "old" and
    a "new" system of rendering, and the "V2" naming refers to the new rendering system.
    The old rendering system no longer exists, but the "V2" naming continues to maintain
    backward compatibility with existing code.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能想知道为什么所有这些类的名称中都有“V2”。这是QGIS的历史特性。QGIS的早期版本支持渲染的“旧”和“新”系统，而“V2”命名指的是新的渲染系统。旧的渲染系统已不再存在，但“V2”命名继续与现有代码保持向后兼容。
- en: 'Internally, symbols are rather complex, using "symbol layers" to draw multiple
    elements on top of each other. In most cases, however, you can make use of the
    "simple" version of the symbol. This makes it easier to create a new symbol without
    having to deal with the internal complexity of symbol layers. For example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 内部来说，符号相当复杂，使用“符号层”来在彼此之上绘制多个元素。然而，在大多数情况下，你可以使用“简单”版本的符号。这使得创建新符号时不必处理符号层的内部复杂性。例如：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'While symbols draw the features onto the map, a renderer is used to choose
    which symbol to use to draw a particular feature. In the simplest case, the same
    symbol is used for every feature within a layer. This is called a **single symbol
    renderer**, and is represented by the `qgis.core.QgsSingleSymbolRenderV2` class.
    Other possibilities include:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当符号将特征绘制到地图上时，渲染器用于选择用于绘制特定特征的符号。在最简单的情况下，同一符号用于图层内的每个特征。这被称为**单个符号渲染器**，由`qgis.core.QgsSingleSymbolRenderV2`类表示。其他可能性包括：
- en: '**Categorized symbol renderer** (`qgis.core.QgsCategorizedSymbolRendererV2`):
    This renderer chooses a symbol based on the value of an attribute. The categorized
    symbol renderer has a mapping from attribute values to symbols.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分类符号渲染器**（`qgis.core.QgsCategorizedSymbolRendererV2`）：此渲染器根据属性的值选择符号。分类符号渲染器具有属性值到符号的映射。'
- en: '**Graduated symbol renderer** (`qgis.core.QgsGraduatedSymbolRendererV2`): This
    type of renderer uses ranges of attribute values, and maps each range to an appropriate
    symbol.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渐变符号渲染器**（`qgis.core.QgsGraduatedSymbolRendererV2`）：此类渲染器使用属性值的范围，并将每个范围映射到适当的符号。'
- en: 'Using a single symbol renderer is very straightforward:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个符号渲染器非常直接：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To use a categorized symbol renderer, you first define a list of `qgis.core.QgsRendererCategoryV2`
    objects, and then use that to create the renderer. For example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用分类符号渲染器，你首先定义一个`qgis.core.QgsRendererCategoryV2`对象的列表，然后使用它来创建渲染器。例如：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice that the `QgsRendererCategoryV2` constructor takes three parameters:
    the desired value, the symbol used, and the label used to describe that category.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`QgsRendererCategoryV2`构造函数接受三个参数：所需的值、使用的符号以及用于描述该类别的标签。
- en: 'Finally, to use a graduated symbol renderer, you define a list of `qgis.core.QgsRendererRangeV2`
    objects and then use that to create your renderer. For example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要使用渐变符号渲染器，你首先定义一个`qgis.core.QgsRendererRangeV2`对象的列表，然后使用它来创建你的渲染器。例如：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Accessing vector data
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问矢量数据
- en: 'In addition to displaying the contents of a vector layer within a map, you
    can use Python to directly access the underlying data. This can be done using
    the data provider''s `getFeatures()` method. For example, to iterate over all
    the features within the layer, you can do the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在地图中显示矢量图层的内容外，你还可以使用Python直接访问底层数据。这可以通过数据提供者的`getFeatures()`方法完成。例如，要遍历图层内的所有特征，你可以执行以下操作：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you want to search for features based on some criteria, you can use the
    `QgsFeatureRequest` object''s `setFilterExpression()` method, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要根据某些标准搜索特征，你可以使用`QgsFeatureRequest`对象的`setFilterExpression()`方法，如下所示：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you have the features, it''s easy to get access to the feature''s geometry,
    ID, and attributes. For example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了特征，很容易获取特征的几何形状、ID和属性。例如：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The object returned by the `feature.geometry()` call, which will be an instance
    of `qgis.core.QgsGeometry`, represents the feature's geometry. This object has
    a large number of methods you can use to extract the underlying data and perform
    various geospatial calculations.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`feature.geometry()`调用返回的对象，它将是一个`qgis.core.QgsGeometry`实例，代表特征的几何形状。此对象有大量你可以使用的方法来提取底层数据并执行各种地理空间计算。'
- en: Spatial indexes
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 空间索引
- en: In the previous section, we searched for features based on their attribute values.
    There are times, though, when you might want to find features based on their position
    in space. For example, you might want to find all features that lie within a certain
    distance of a given point. To do this, you can use a **spatial index**, which
    indexes features according to their location and extent. Spatial indexes are represented
    in QGIS by the `QgsSpatialIndex` class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们根据属性值搜索特征。然而，有时您可能希望根据它们在空间中的位置来查找特征。例如，您可能希望找到所有位于给定点一定距离内的特征。为此，您可以使用**空间索引**，该索引根据特征的位置和范围进行索引。空间索引在QGIS中由`QgsSpatialIndex`类表示。
- en: 'For performance reasons, a spatial index is not created automatically for each
    vector layer. However, it''s easy to create one when you need it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了性能原因，不会为每个矢量图层自动创建空间索引。然而，当您需要时创建一个很容易：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Don't forget that you can use the `QgsFeatureRequest.setFilterExpression()`
    method to limit the set of features that get added to the index.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，您可以使用`QgsFeatureRequest.setFilterExpression()`方法来限制添加到索引中的特征集。
- en: 'Once you have the spatial index, you can use it to perform queries based on
    the position of the features. In particular:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了空间索引，您就可以使用它来根据特征的位置执行查询。特别是：
- en: 'You can find one or more features that are closest to a given point using the
    `nearestNeighbor()` method. For example:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`nearestNeighbor()`方法找到与给定点最近的特征。例如：
- en: '[PRE10]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that this method takes two parameters: the desired point as a `QgsPoint`
    object and the number of features to return.'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，此方法需要两个参数：所需的点作为一个`QgsPoint`对象以及要返回的特征数量。
- en: 'You can find all features that intersect with a given rectangular area by using
    the `intersects()` method, as follows:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`intersects()`方法找到与给定矩形区域相交的所有特征，如下所示：
- en: '[PRE11]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Raster layers
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栅格图层
- en: Raster-format geospatial data is essentially a bitmapped image, where each pixel
    or "cell" in the image corresponds to a particular part of the Earth's surface.
    Raster data is often organized into **bands**, where each band represents a different
    piece of information. A common use for bands is to store the red, green, and blue
    component of the pixel's color in a separate band. Bands might also represent
    other types of information, such as moisture level, elevation, or soil type.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格格式的地理空间数据本质上是一个位图图像，其中图像中的每个像素或“单元格”对应于地球表面的一个特定部分。栅格数据通常组织成**波段**，其中每个波段代表不同的信息。波段的一个常见用途是在单独的波段中存储像素颜色的红色、绿色和蓝色成分。波段也可能代表其他类型的信息，例如湿度水平、海拔或土壤类型。
- en: 'There are many ways in which raster information can be displayed. For example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格信息可以以多种方式显示。例如：
- en: If the raster data only has one band, the pixel value can be used as an index
    into a **palette**. The palette maps each pixel value maps to a particular color.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果栅格数据只有一个波段，则像素值可以用作**调色板**的索引。调色板将每个像素值映射到特定的颜色。
- en: If the raster data has only one band but no palette is provided, the pixel values
    can be used directly as a **grayscale** value; that is, larger numbers are lighter
    and smaller numbers are darker. Alternatively, the pixel values can be passed
    through a **pseudocolor algorithm** to calculate the color to be displayed.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果栅格数据只有一个波段但没有提供调色板，则像素值可以直接用作**灰度**值；也就是说，较大的数字较亮，较小的数字较暗。或者，像素值可以通过**伪彩色算法**来计算要显示的颜色。
- en: If the raster data has multiple bands, then typically, the bands would be combined
    to generate the desired color. For example, one band might represent the red component
    of the color, another band might represent the green component, and yet another
    band might represent the blue component.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果栅格数据有多个波段，那么通常，波段会被组合起来生成所需的颜色。例如，一个波段可能代表颜色的红色成分，另一个波段可能代表绿色成分，而另一个波段可能代表蓝色成分。
- en: Alternatively, a multiband raster data source might be drawn using a palette,
    or as a grayscale or a pseudocolor image, by selecting a particular band to use
    for the color calculation.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，可以使用调色板、灰度或伪彩色图像绘制多波段栅格数据源，通过选择用于颜色计算的特定波段。
- en: Let's take a closer look at how raster data can be drawn onto the map.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看如何将栅格数据绘制到地图上。
- en: How raster data is displayed
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 栅格数据的显示方式
- en: 'The **drawing style** associated with the raster band controls how the raster
    data will be displayed. The following drawing styles are currently supported:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与栅格波段关联的**绘图风格**控制了栅格数据的显示方式。以下是目前支持的绘图风格：
- en: '| Drawing style | Description |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 绘图风格 | 描述 |'
- en: '| --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PalettedColor` | For a single band raster data source, a palette maps each
    raster value to a color. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `PalettedColor` | 对于单波段栅格数据源，调色板将每个栅格值映射到颜色。|'
- en: '| `SingleBandGray` | For a single band raster data source, the raster value
    is used directly as a grayscale value. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `SingleBandGray` | 对于单波段栅格数据源，栅格值直接用作灰度值。|'
- en: '| `SingleBandPseudoColor` | For a single band raster data source, the raster
    value is used to calculate a pseudocolor. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `SingleBandPseudoColor` | 对于单波段栅格数据源，栅格值用于计算伪颜色。|'
- en: '| `PalettedSingleBandGray` | For a single band raster data source that has
    a palette, this drawing style tells QGIS to ignore the palette and use the raster
    value directly as a grayscale value. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `PalettedSingleBandGray` | 对于具有调色板的单波段栅格数据源，这种绘图风格告诉QGIS忽略调色板并直接使用栅格值作为灰度值。|'
- en: '| `PalettedSingleBandPseudoColor` | For a single band raster data source that
    has a palette, this drawing style tells QGIS to ignore the palette and use the
    raster value to calculate a pseudocolor. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `PalettedSingleBandPseudoColor` | 对于具有调色板的单波段栅格数据源，这种绘图风格告诉QGIS忽略调色板并使用栅格值计算伪颜色。|'
- en: '| `MultiBandColor` | For multiband raster data sources, use a separate band
    for each of the red, green, and blue color components. For this drawing style,
    the `setRedBand()`, `setGreenBand()`, and `setBlueBand()` methods can be used
    to choose which band to use for each color component. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `MultiBandColor` | 对于多波段栅格数据源，为红色、绿色和蓝色颜色组件分别使用一个单独的波段。对于这种绘图风格，可以使用`setRedBand()`、`setGreenBand()`和`setBlueBand()`方法来选择每个颜色组件使用的波段。|'
- en: '| `MultiBandSingleBandGray` | For multiband raster data sources, choose a single
    band to use as the grayscale color value. For this drawing style, use the `setGrayBand()`
    method to specify the band to use. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `MultiBandSingleBandGray` | 对于多波段栅格数据源，选择一个波段用作灰度颜色值。对于这种绘图风格，使用`setGrayBand()`方法指定要使用的波段。|'
- en: '| `MultiBandSingleBandPseudoColor` | For multiband raster data sources, choose
    a single band to use to calculate a pseudocolor. For this drawing style, use the
    `setGrayBand()` method to specify the band to use. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `MultiBandSingleBandPseudoColor` | 对于多波段栅格数据源，选择一个波段用于计算伪颜色。对于这种绘图风格，使用`setGrayBand()`方法指定要使用的波段。|'
- en: To set the drawing style, use the `layer.setDrawingStyle()` method, passing
    in a string that contains the name of the desired drawing style. You will also
    need to call the various `setXXXBand()` methods, as described in the preceding
    table, to tell the raster layer which bands contain the value(s) to use to draw
    each pixel.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置绘图风格，使用`layer.setDrawingStyle()`方法，传入包含所需绘图风格名称的字符串。您还需要调用前面表格中描述的各个`setXXXBand()`方法，以告诉栅格层哪些波段包含用于绘制每个像素的值。
- en: 'Note that QGIS doesn''t automatically update the map when you call the preceding
    functions to change the way the raster data is displayed. To have your changes
    displayed right away, you''ll need to do the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当您调用前面的函数来更改栅格数据的显示方式时，QGIS不会自动更新地图。要立即显示您的更改，您需要执行以下操作：
- en: Turn off raster image caching. This can be done by calling `layer.setImageCache(None)`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭栅格图像缓存。这可以通过调用`layer.setImageCache(None)`来实现。
- en: Tell the raster layer to redraw itself, by calling `layer.triggerRepaint()`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉栅格层重新绘制自身，通过调用`layer.triggerRepaint()`。
- en: Accessing raster data
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问栅格数据
- en: 'As with vector-format data, you can access the underlying raster data via the
    data provider''s `identify()` method. The easiest way to do this is to pass in
    a single coordinate and retrieve the value or values at that coordinate. For example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与矢量格式数据一样，您可以通过数据提供者的`identify()`方法访问底层栅格数据。这样做最简单的方法是传入一个坐标并检索该坐标处的值或值。例如：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, you need to check whether the given coordinate exists within
    the raster data (using the `isValid()` call). The `values.results()` method returns
    a dictionary that maps band numbers to values.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您需要检查给定坐标是否存在于栅格数据中（使用`isValid()`调用）。`values.results()`方法返回一个将波段编号映射到值的字典。
- en: Using this technique, you can extract all the underlying data associated with
    a given coordinate within the raster layer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，您可以提取与栅格层中给定坐标相关联的所有底层数据。
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can also use the `provider.block()` method to retrieve the band data for
    a large number of coordinates all at once. We will look at how to do this later
    in this chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `provider.block()` 方法一次性检索大量坐标的波段数据。我们将在本章后面讨论如何做到这一点。
- en: Other useful qgis.core classes
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他有用的 qgis.core 类
- en: 'Apart from all the classes and functionality involved in working with data
    sources and map layers, the `qgis.core` library also defines a number of other
    classes that you might find useful:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有涉及数据源和地图图层操作的相关类和功能外，`qgis.core` 库还定义了其他一些你可能觉得有用的类：
- en: '| Class | Description |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 描述 |'
- en: '| --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `QgsProject` | This represents the current QGIS project. Note that this is
    a singleton object, as only one project can be open at a time. The `QgsProject`
    class is responsible for loading and storing properties, which can be useful for
    plugins. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `QgsProject` | 这代表当前的 QGIS 项目。请注意，这是一个单例对象，因为一次只能打开一个项目。`QgsProject` 类负责加载和存储属性，这对于插件可能很有用。|'
- en: '| `QGis` | This class defines various constants, data types, and functions
    used throughout the QGIS system. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `QGis` | 这个类定义了 QGIS 系统中使用的各种常量、数据类型和函数。|'
- en: '| `QgsPoint` | This is a generic class that stores the coordinates for a point
    within a two-dimensional plane. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `QgsPoint` | 这是一个通用类，用于存储二维平面内点的坐标。|'
- en: '| `QgsRectangle` | This is a generic class that stores the coordinates for
    a rectangular area within a two-dimensional plane. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `QgsRectangle` | 这是一个通用类，用于存储二维平面内矩形区域的坐标。|'
- en: '| `QgsRasterInterface` | This is the base class to use for processing raster
    data, for example, to reproject a set of raster data into a new coordinate system,
    to apply filters to change the brightness or color of your raster data, to resample
    the raster data, and to generate new raster data by rendering the existing data
    in various ways. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `QgsRasterInterface` | 这是处理栅格数据的基础类，例如，将一组栅格数据重新投影到新的坐标系中，应用过滤器以改变栅格数据的亮度和颜色，重采样栅格数据，以及通过以各种方式渲染现有数据来生成新的栅格数据。|'
- en: '| `QgsDistanceArea` | This class can be used to calculate distances and areas
    for a given geometry, automatically converting from the source coordinate reference
    system into meters. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `QgsDistanceArea` | 这个类可以用来计算给定几何形状的距离和面积，自动将源坐标参考系统转换为米。|'
- en: '| `QgsMapLayerRegistry` | This class provides access to all the registered
    map layers in the current project. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `QgsMapLayerRegistry` | 这个类提供了对当前项目中所有已注册地图图层的访问。|'
- en: '| `QgsMessageLog` | This class provides general logging features within a QGIS
    program. This lets you send debugging messages, warnings, and errors to the QGIS
    "Log Messages" panel. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `QgsMessageLog` | 这个类在 QGIS 程序中提供了一般的日志功能。这让你可以将调试消息、警告和错误发送到 QGIS 的“日志消息”面板。|'
- en: The qgis.gui package
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: qgis.gui 包
- en: The `qgis.gui` package defines a number of user-interface widgets that you can
    include in your programs. Let's start by looking at the most important `qgis.gui`
    classes, and follow this up with a brief look at some of the other classes that
    you might find useful.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`qgis.gui` 包定义了一系列用户界面小部件，你可以将其包含在你的程序中。让我们首先看看最重要的 `qgis.gui` 类，然后简要地看看一些你可能觉得有用的其他类。'
- en: The QgisInterface class
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QgisInterface 类
- en: '`QgisInterface` represents the QGIS system''s user interface. It allows programmatic
    access to the map canvas, the menu bar, and other parts of the QGIS application.
    When running Python code within a script or a plugin, or directly from the QGIS
    Python console, a reference to `QgisInterface` is typically available through
    the `iface` global variable.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`QgisInterface` 代表 QGIS 系统的用户界面。它允许以编程方式访问地图画布、菜单栏和其他 QGIS 应用程序的各个部分。当在脚本或插件中运行
    Python 代码，或直接从 QGIS Python 控制台运行时，通常可以通过 `iface` 全局变量获得对 `QgisInterface` 的引用。'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `QgisInterface` object is only available when running the QGIS application
    itself. If you are running an external application and import the PyQGIS library
    into your application, `QgisInterface` won't be available.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`QgisInterface` 对象仅在运行 QGIS 应用程序本身时才可用。如果你正在运行外部应用程序并将 PyQGIS 库导入到你的应用程序中，`QgisInterface`
    将不可用。'
- en: 'Some of the more important things you can do with the `QgisInterface` object
    are:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `QgisInterface` 对象做一些更重要的事情：
- en: Get a reference to the list of layers within the current QGIS project via the
    `legendInterface()` method.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `legendInterface()` 方法获取当前 QGIS 项目中图层列表的引用。
- en: Get a reference to the map canvas displayed within the main application window,
    using the `mapCanvas()` method.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `mapCanvas()` 方法获取主应用程序窗口中显示的地图画布的引用。
- en: Retrieve the currently active layer within the project, using the `activeLayer()`
    method, and set the currently active layer by using the `setActiveLayer()` method.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `activeLayer()` 方法检索项目中的当前活动层，并使用 `setActiveLayer()` 方法设置当前活动层。
- en: Get a reference to the application's main window by calling the `mainWindow()`
    method. This can be useful if you want to create additional Qt windows or dialogs
    that use the main window as their parent.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用 `mainWindow()` 方法获取应用程序的主窗口引用。如果您想创建使用主窗口作为其父窗口的附加 Qt 窗口或对话框，这可能很有用。
- en: Get a reference to the QGIS system's message bar by calling the `messageBar()`
    method. This allows you to display messages to the user directly within the QGIS
    main window.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用 `messageBar()` 方法获取 QGIS 系统的消息栏引用。这允许您在 QGIS 主窗口中直接向用户显示消息。
- en: The QgsMapCanvas class
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QgsMapCanvas 类
- en: 'The **map canvas** is responsible for drawing the various map layers into a
    window. The `QgsMapCanvas` class represents a map canvas. This class includes:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**地图画布**负责将各种地图层绘制到窗口中。`QgsMapCanvas` 类代表一个地图画布。此类包括：'
- en: A list of the currently shown **map layers**. This can be accessed using the
    `layers()` method.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前显示的**地图层**列表。可以使用 `layers()` 方法访问。
- en: Tip
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that there is a subtle difference between the list of map layers available
    within the map canvas and the list of map layers included in the `QgisInterface.legendInterface()`
    method. The map canvas's list of layers only includes the list of layers currently
    visible, while `QgisInterface.legendInterface()` returns all the map layers, including
    those that are currently hidden.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，地图画布内可用的地图层列表与 `QgisInterface.legendInterface()` 方法中包含的地图层列表之间有一个细微的区别。地图画布的层列表仅包括当前可见的层列表，而
    `QgisInterface.legendInterface()` 返回所有地图层，包括当前隐藏的层。
- en: The **map units** used by this map (meters, feet, degrees, and so on). The map's
    map units can be retrieved by calling the `mapUnits()` method.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该地图使用的**地图单位**（米、英尺、度等）。可以通过调用 `mapUnits()` 方法检索地图的单位。
- en: An **extent**, **which** is the area of the map currently shown within the canvas.
    The map's extent will change as the user zooms in and out, and pans across the
    map. The current map extent can be obtained by calling the `extent()` method.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围**，即当前在画布中显示的地图区域。当用户缩放和平移地图时，地图的范围将发生变化。可以通过调用 `extent()` 方法获取当前地图的范围。'
- en: '**A current map tool** that is used to control the user''s interaction with
    the contents of the map canvas. The current map tool can be set using the `setMapTool()`
    method, and you can retrieve the current map tool (if any) by calling the `mapTool()`
    method.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前地图工具**，用于控制用户与地图画布内容的交互。可以使用 `setMapTool()` 方法设置当前地图工具，并通过调用 `mapTool()`
    方法检索当前地图工具（如果有）。'
- en: A **background color** used to draw the background behind all the map layers.
    You can change the map's background color by calling the `canvasColor()` method.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于绘制所有地图层背景的**背景颜色**。您可以通过调用 `canvasColor()` 方法来更改地图的背景颜色。
- en: A **coordinate transform** that converts from map coordinates (that is, coordinates
    in the data source's coordinate reference system) to pixels within the window.
    You can retrieve the current coordinate transform by calling the `getCoordinateTransform()`
    method.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坐标转换**，将地图坐标（即数据源坐标参考系中的坐标）转换为窗口内的像素。您可以通过调用 `getCoordinateTransform()` 方法检索当前坐标转换。'
- en: The QgsMapCanvasItem class
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QgsMapCanvasItem 类
- en: 'A **map canvas item** is an item drawn on top of the map canvas. The map canvas
    item will appear in front of the map layers. While you can create your own subclass
    of `QgsMapCanvasItem` if you want to draw custom items on top of the map canvas,
    you will find it easier to use an existing subclass that does much of the work
    for you. There are currently three subclasses of `QgsMapCanvasItem` that you might
    find useful:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**地图画布项**是在地图画布上绘制的项。地图画布项将出现在地图层之前。虽然您可以根据需要创建 `QgsMapCanvasItem` 的子类以在地图画布上绘制自定义项，但您会发现使用现有的子类更容易，这些子类为您做了很多工作。目前有三个
    `QgsMapCanvasItem` 的子类可能对您有用：'
- en: '`QgsVertexMarker`: This draws an icon (an "X", a "+", or a small box) centered
    around a given point on the map.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QgsVertexMarker`：在地图上给定点的周围绘制一个图标（一个 "X"、一个 "+" 或一个小方块）。'
- en: '`QgsRubberBand`: This draws an arbitrary polygon or polyline onto the map.
    It is intended to provide visual feedback as the user draws a polygon onto the
    map.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QgsRubberBand`：这将在地图上绘制任意多边形或多段线。它的目的是在用户在地图上绘制多边形时提供视觉反馈。'
- en: '`QgsAnnotationItem`: This is used to display additional information about a
    feature, in the form of a balloon that is connected to the feature. The `QgsAnnotationItem`
    class has various subclasses that allow you to customize the way the information
    is displayed.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QgsAnnotationItem`：这用于以气球的形式显示有关要素的附加信息，该气球与要素相连。`QgsAnnotationItem` 类有各种子类，允许您自定义信息显示的方式。'
- en: The QgsMapTool class
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QgsMapTool 类
- en: A **map tool** allows the user to interact with and manipulate the map canvas,
    capturing mouse events and responding appropriately. A number of `QgsMapTool`
    subclasses provide standard map interaction behavior such as clicking to zoom
    in, dragging to pan the map, and clicking on a feature to identify it. You can
    also create your own custom map tools by subclassing `QgsMapTool` and implementing
    the various methods that respond to user-interface events such as pressing down
    the mouse button, dragging the canvas, and so on.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**地图工具**允许用户与地图画布进行交互和操作，捕获鼠标事件并做出相应的响应。许多 `QgsMapTool` 子类提供了标准地图交互行为，例如点击放大、拖动平移地图以及点击要素进行识别。您还可以通过继承
    `QgsMapTool` 并实现响应用户界面事件的各种方法来创建自己的自定义地图工具，例如按下鼠标按钮、拖动画布等。'
- en: Once you have created a map tool, you can allow the user to activate it by associating
    the map tool with a toolbar button. Alternatively, you can activate it from within
    your Python code by calling the `mapCanvas.setMapTool(...)` method.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了地图工具，您可以通过将地图工具与工具栏按钮关联来允许用户激活它。或者，您也可以通过在您的 Python 代码中调用 `mapCanvas.setMapTool(...)`
    方法来激活它。
- en: We will look at the process of creating your own custom map tool in the section
    *Using the PyQGIS library*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *使用 PyQGIS 库* 这一部分中查看创建您自己的自定义地图工具的过程。
- en: Other useful qgis.gui classes
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他有用的 qgis.gui 类
- en: 'While the `qgis.gui` package defines a large number of classes, the ones you
    are most likely to find useful are given in the following table:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `qgis.gui` 包定义了大量的类，但您最可能发现有用的类在以下表中给出：
- en: '| Class | Description |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 班级 | 描述 |'
- en: '| --- | --- |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `QgsLegendInterface` | This provides access to the map legend, that is, the
    list of map layers within the current project. Note that map layers can be grouped,
    hidden, and shown within the map legend. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `QgsLegendInterface` | 这提供了访问地图图例的途径，即当前项目中的地图图层列表。请注意，地图图层可以在图例中分组、隐藏和显示。
    |'
- en: '| `QgsMapTip` | This displays a tip on a map canvas when the user holds the
    mouse over a feature. The map tip will show the display field for the feature;
    you can set this by calling `layer.setDisplayField("FIELD")`. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `QgsMapTip` | 当用户将鼠标悬停在要素上时，在地图画布上显示提示。地图提示将显示要素的显示字段；您可以通过调用 `layer.setDisplayField("FIELD")`
    来设置此字段。 |'
- en: '| `QgsColorDialog` | This is a dialog box that allows the user to select a
    color. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `QgsColorDialog` | 这是一个允许用户选择颜色的对话框。 |'
- en: '| `QgsDialog` | This is a generic dialog with a vertical box layout and a button
    box, making it easy to add content and standard buttons to your dialog. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `QgsDialog` | 这是一个具有垂直框布局和按钮框的通用对话框，这使得向对话框中添加内容和标准按钮变得容易。 |'
- en: '| `QgsMessageBar` | This is a bar that displays non-blocking messages to the
    user. We looked at the message bar class in the previous chapter. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `QgsMessageBar` | 这是一个显示非阻塞消息给用户的栏。我们在上一章中讨论了消息栏类。 |'
- en: '| `QgsMessageViewer` | This is a generic class that displays long messages
    to the user within a modal dialog. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `QgsMessageViewer` | 这是一个通用类，它在一个模态对话框中向用户显示长消息。 |'
- en: '| `QgsBlendModeComboBox``QgsBrushStyleComboBox``QgsColorRampComboBox``QgsPenCapStyleComboBox``QgsPenJoinStyleComboBox``QgsScaleComboBox`
    | These `QComboBox` user-interface widgets allow you to prompt the user for various
    drawing options. With the exception of the `QgsScaleComboBox`, which lets the
    user choose a map scale, all the other `QComboBox` subclasses let the user choose
    various Qt drawing options. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `QgsBlendModeComboBox` `QgsBrushStyleComboBox` `QgsColorRampComboBox` `QgsPenCapStyleComboBox`
    `QgsPenJoinStyleComboBox` `QgsScaleComboBox` | 这些 `QComboBox` 用户界面小部件允许您提示用户选择各种绘图选项。除了允许用户选择地图比例的
    `QgsScaleComboBox` 之外，所有其他的 `QComboBox` 子类都允许用户选择各种 Qt 绘图选项。 |'
- en: Using the PyQGIS library
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PyQGIS 库
- en: In the previous section, we looked at a number of classes provided by the PyQGIS
    library. Let's make use of these classes to perform some real-world geospatial
    development tasks.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们查看了一些由PyQGIS库提供的类。让我们利用这些类来执行一些实际的地理空间开发任务。
- en: Analyzing raster data
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析栅格数据
- en: We're going to start by writing a program to load in some raster-format data
    and analyze its contents. To make this more interesting, we'll use a **Digital
    Elevation Model** (**DEM**) file, which is a raster format data file that contains
    elevation data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写一个程序来加载一些栅格格式数据并分析其内容。为了使这个过程更有趣，我们将使用**数字高程模型**（**DEM**）文件，这是一种包含高程数据的栅格格式数据文件。
- en: The **Global Land One-Kilometer Base Elevation Project** (**GLOBE**) provides
    free DEM data for the world, where each pixel represents one square kilometer
    of the Earth's surface. GLOBE data can be downloaded from [http://www.ngdc.noaa.gov/mgg/topo/gltiles.html](http://www.ngdc.noaa.gov/mgg/topo/gltiles.html).
    Download the E tile, which includes the western half of the USA. The resulting
    file, which is named `e10g`, contains the height information you need. You'll
    also need to download the `e10g.hdr` header file so that QGIS can read the file—you
    can download this from [http://www.ngdc.noaa.gov/mgg/topo/elev/esri/hdr](http://www.ngdc.noaa.gov/mgg/topo/elev/esri/hdr).
    Once you've downloaded these two files, put them together into a convenient directory.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**全球陆地一千米基础高程项目**（**GLOBE**）为全球提供免费的DEM数据，其中每个像素代表地球表面的一个平方公里。GLOBE数据可以从[http://www.ngdc.noaa.gov/mgg/topo/gltiles.html](http://www.ngdc.noaa.gov/mgg/topo/gltiles.html)下载。下载E图块，它包括美国西部的一半。生成的文件，命名为`e10g`，包含您所需的高度信息。您还需要下载`e10g.hdr`头文件，以便QGIS能够读取该文件——您可以从[http://www.ngdc.noaa.gov/mgg/topo/elev/esri/hdr](http://www.ngdc.noaa.gov/mgg/topo/elev/esri/hdr)下载。一旦下载了这两个文件，将它们合并到一个方便的目录中。'
- en: 'You can now load the DEM data into QGIS using the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用以下代码将DEM数据加载到QGIS中：
- en: '[PRE13]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Unfortunately, there is a slight complexity here. Since QGIS doesn''t know
    which coordinate reference system is used for the data, it displays a dialog box
    that asks you to choose the CRS. Since the GLOBE DEM data is in the WGS84 CRS,
    which QGIS uses by default, this dialog box is redundant. To disable it, we need
    to add the following to the top of our program:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这里有一点复杂性。由于QGIS不知道数据使用的是哪个坐标参考系统，它会显示一个对话框，要求您选择CRS。由于GLOBE DEM数据位于WGS84
    CRS中，这是QGIS默认使用的，因此此对话框是多余的。为了禁用它，我们需要在程序顶部添加以下内容：
- en: '[PRE14]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we've loaded our raster DEM data into QGIS, we can analyze it. While
    there are lots of things we can do with DEM data, let's calculate how often each
    unique elevation value occurs within the data.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将我们的栅格DEM数据加载到QGIS中，我们可以分析它了。虽然我们可以用DEM数据做很多事情，但让我们计算数据中每个唯一高程值出现的频率。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that we're loading the DEM data directly using `QgsRasterDataProvider`.
    We don't want to display this information on a map, so we don't want (or need)
    to load it into `QgsRasterLayer`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在直接使用`QgsRasterDataProvider`加载DEM数据。我们不想在地图上显示这些信息，因此我们不想（或不需要）将其加载到`QgsRasterLayer`中。
- en: 'Since the DEM data is in a raster format, you need to iterate over the individual
    pixels or cells to get each height value. The `provider.xSize()` and `provider.ySize()`
    methods tell us how many cells are there in the DEM, while the `provider.extent()`
    method gives us the area of the Earth''s surface covered by the DEM. Using this
    information, we can extract the individual elevation values from the contents
    of the DEM in the following way:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DEM数据是栅格格式，您需要遍历单个像素或单元格以获取每个高度值。`provider.xSize()`和`provider.ySize()`方法告诉我们DEM中有多少个单元格，而`provider.extent()`方法给出了DEM覆盖的地球表面区域。使用这些信息，我们可以以下述方式从DEM的内容中提取单个高程值：
- en: '[PRE15]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The returned `block` variable is an object of type `QgsRasterBlock`, which
    is essentially a two-dimensional array of values. Let''s iterate over the raster
    and extract the individual elevation values:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的`block`变量是`QgsRasterBlock`类型的一个对象，它本质上是一个值的二维数组。让我们遍历栅格并提取单个高程值：
- en: '[PRE16]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we''ve loaded the individual elevation values, it''s easy to build
    a histogram out of those values. Here is the entire program to load the DEM data
    into memory, and then calculate and display the histogram:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了单个高程值，很容易从这些值中构建直方图。以下是整个程序，用于将DEM数据加载到内存中，然后计算并显示直方图：
- en: '[PRE17]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that we've added a *no data value* check to the code. Raster data often
    includes pixels that have no value associated with them. In the case of a DEM,
    elevation data is only provided for areas of land; pixels over the sea have no
    elevation, and we have to exclude them, or our histogram will be inaccurate.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在代码中添加了一个 *无数据值* 检查。栅格数据通常包括没有与之关联值的像素。在 DEM 的情况下，高程数据仅提供陆地区域的数据；海洋上的像素没有高程，我们必须排除它们，否则我们的直方图将不准确。
- en: Manipulating vector data and saving it to a shapefile
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作矢量数据并将其保存为 shapefile
- en: Let's create a program that takes two vector data sources, subtracts one set
    of vectors from the other, and saves the resulting geometries into a new shapefile.
    Along the way, we'll learn a few important things about the PyQGIS library.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个程序，该程序接受两个矢量数据源，从另一个数据源中减去一组矢量，并将结果几何体保存到一个新的 shapefile 中。在这个过程中，我们将了解
    PyQGIS 库的一些重要内容。
- en: 'We''ll be making use of the `QgsGeometry.difference()` function. This function
    performs a geometrical subtraction of one geometry from another, like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `QgsGeometry.difference()` 函数。此函数执行从一个几何体到另一个几何体的几何减法，如下所示：
- en: '![Manipulating vector data and saving it to a shapefile](img/00032.jpeg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![操作矢量数据并将其保存为 shapefile](img/00032.jpeg)'
- en: 'Let''s start by asking the user to select the first shapefile and open up a
    vector data provider for that file:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先让用户选择第一个 shapefile，并为该文件打开一个矢量数据提供者：
- en: '[PRE18]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can then read the geometries from that file into memory:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从该文件中读取几何体到内存中：
- en: '[PRE19]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This last line of code includes an important feature. Notice that we use the
    following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的最后一句包含了一个重要的特性。注意，我们使用以下方法：
- en: '[PRE20]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We use the preceding line instead of the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用前面的行而不是以下行：
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is to get the geometry object to add to the list. In other words, we had
    to create a new geometry object based on the feature''s existing geometry object.
    This is a limitation of the way the QGIS Python wrappers work: the `feature.geometry()`
    method returns a reference to the geometry, but the C++ code doesn''t know that
    you are storing this reference away in your Python code. So, when the feature
    is no longer needed, the memory used by the feature''s geometry is also released.
    If you then try to access that geometry later on, the entire QGIS system will
    crash. To get around this, we make a copy of the geometry so that we can refer
    to it even after the feature''s memory has been released.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了获取要添加到列表中的几何体对象。换句话说，我们必须基于现有几何体对象创建一个新的几何体对象。这是 QGIS Python 包装器工作方式的一个限制：`feature.geometry()`
    方法返回一个几何体的引用，但 C++ 代码不知道你在 Python 代码中将这个引用存储起来。所以，当特征不再需要时，特征几何体使用的内存也会被释放。如果你后来尝试访问该几何体，整个
    QGIS 系统将会崩溃。为了解决这个问题，我们创建几何体的一个副本，这样我们就可以在特征内存释放后仍然引用它。
- en: 'Now that we''ve loaded our first set of geometries into memory, let''s do the
    same for the second shapefile:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将第一组几何体加载到内存中，让我们对第二个 shapefile 也做同样的操作：
- en: '[PRE22]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the two sets of geometries loaded into memory, we''re ready to start subtracting
    one from the other. However, to make this process more efficient, we will combine
    the geometries from the second shapefile into one large geometry, which we can
    then subtract all at once, rather than subtracting one at a time. This will make
    the subtraction process much faster:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当两组几何体被加载到内存中后，我们就可以开始从一组中减去另一组了。然而，为了使这个过程更高效，我们将第二个 shapefile 中的几何体合并成一个大的几何体，然后一次性减去，而不是逐个减去。这将使减法过程变得更快：
- en: '[PRE23]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can now calculate the new set of geometries by subtracting one from the
    other:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过减去一个来计算新的几何体集：
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that we check to see whether the destination geometry is mathematically
    valid and is not empty.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们检查目标几何体是否在数学上是有效的，并且不为空。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Invalid geometries are a common problem when manipulating complex shapes. There
    are options for fixing them, such as splitting apart multi-geometries and performing
    a buffer operation. However, doing this is beyond the scope of this book.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作复杂形状时，无效的几何体是一个常见问题。有修复它们的方法，例如将多几何体分开并执行缓冲操作。然而，这超出了本书的范围。
- en: 'Our last task is to save the resulting geometries into a new shapefile. We''ll
    first ask the user for the name of the destination shapefile:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的任务是保存结果几何体到一个新的 shapefile 中。我们首先会要求用户输入目标 shapefile 的名称：
- en: '[PRE25]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ll make use of a **vector file writer** to save the geometries into a shapefile.
    Let''s start by initializing the file writer object:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**矢量文件写入器**将几何形状保存到形状文件中。让我们首先初始化文件写入器对象：
- en: '[PRE26]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We don''t have any attributes in our shapefile, so the fields list is empty.
    Now that the writer has been set up, we can save the geometries into the file:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形状文件中没有属性，因此字段列表为空。现在写入器已经设置好，我们可以将几何形状保存到文件中：
- en: '[PRE27]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that all the data has been written to the disk, let''s display a message
    box that informs the user that we''ve finished:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有数据都已写入磁盘，让我们显示一个消息框，通知用户我们已经完成：
- en: '[PRE28]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, creating a new shapefile is very straightforward in PyQGIS,
    and it's easy to manipulate geometries using Python—just so long as you copy the
    `QgsGeometry` objects you want to keep around. If your Python code starts to crash
    while manipulating geometries, this is probably the first thing you should look
    for.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在PyQGIS中创建新的形状文件非常简单，使用Python操作几何形状也很容易——只要您复制您想要保留的`QgsGeometry`对象。如果您的Python代码在操作几何形状时开始崩溃，这可能是您应该首先查找的问题。
- en: Using different symbols for different features within a map
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在地图中使用不同符号表示不同特征
- en: Let's use World Borders Dataset that you downloaded in the previous chapter
    to draw a world map, using different symbols for different continents. This is
    a good example of using a categorized symbol renderer, though we'll combine it
    into a script that loads the shapefile into a map layer and sets up the symbols
    and map renderer to display the map exactly as you want. We'll then save the resulting
    map as an image.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用在上一章中下载的世界边界数据集来绘制世界地图，为不同的洲使用不同的符号。这是一个使用分类符号渲染器的良好示例，尽管我们将将其组合到一个脚本中，该脚本将将形状文件加载到地图层中，并设置符号和地图渲染器以显示您想要的地图。然后我们将保存生成的地图为图像。
- en: 'Let''s start by creating a map layer to display the contents of the World Borders
    Dataset shapefile:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个地图层来显示世界边界数据集形状文件的内容：
- en: '[PRE29]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Each unique region code in the World Borders Dataset shapefile corresponds
    to a continent. We want to define the name and color to use for each of these
    regions, and use this information to set up the various categories to use when
    displaying the map:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 世界边界数据集形状文件中的每个唯一区域代码对应一个洲。我们想要定义每个这些区域使用的名称和颜色，并使用这些信息来设置显示地图时使用的各种类别：
- en: '[PRE30]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With these categories set up, we simply update the map layer to use a categorized
    renderer based on the value of the `region` attribute, and then redraw the map:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这些类别后，我们只需更新地图层以使用基于`region`属性值的分类渲染器，然后重新绘制地图：
- en: '[PRE31]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There''s only one more thing to do, since this is a script that can be run
    multiple times, let''s have our script automatically remove the existing `continents`
    layer, if it exists, before adding a new one. To do this, we can add the following
    to the start of our script:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个可以多次运行的脚本，让我们让我们的脚本在添加新层之前自动删除现有的`continents`层（如果存在）。为此，我们可以在脚本的开头添加以下内容：
- en: '[PRE32]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now when our script is run, it will create one (and only one) layer that shows
    the various continents in different colors. These will appear as different shades
    of gray in the printed book, but the colors will be visible on the computer screen:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们的脚本运行时，它将创建一个（并且只有一个）层，显示不同颜色的各种大陆。这些在打印的书中将显示为不同的灰色阴影，但在计算机屏幕上颜色将是可见的：
- en: '![Using different symbols for different features within a map](img/00033.jpeg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![在地图中使用不同符号表示不同特征](img/00033.jpeg)'
- en: 'Now, let''s use the same data set to color each country based on its relative
    population. We''ll start by removing the existing `"population"` layer, if it
    exists:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用相同的数据集根据每个国家的相对人口对其进行着色。我们首先删除现有的`"population"`层（如果存在）：
- en: '[PRE33]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we open the World Borders Dataset into a new layer called `"population"`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将世界边界数据集打开到一个新的层中，称为`"population"`：
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We then need to set up our various population ranges:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要设置我们的各种人口范围：
- en: '[PRE35]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that we have our population ranges and their associated colors, we simply
    set up a graduated symbol renderer to choose a symbol based on the value of the
    `pop2005` attribute, and tell the map to redraw itself:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了人口范围及其相关颜色，我们只需设置一个渐变符号渲染器，根据`pop2005`属性值选择符号，并告诉地图重新绘制自己：
- en: '[PRE36]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The result will be a map layer that shades each country according to its population:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个地图层，根据每个国家的人口进行着色：
- en: '![Using different symbols for different features within a map](img/00034.jpeg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![在地图中使用不同符号表示不同特征](img/00034.jpeg)'
- en: Calculating the distance between two user-defined points
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算两个用户定义点之间的距离
- en: In our final example of using the PyQGIS library, we'll write some code that,
    when run, starts listening for mouse events from the user. If the user clicks
    on a point, drags the mouse, and then releases the mouse button again, we will
    display the distance between those two points. This is a good example of how to
    add your own map interaction logic to QGIS, using the `QgsMapTool` class.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 PyQGIS 库的最后一个示例中，我们将编写一些代码，当运行时，它将开始监听用户的鼠标事件。如果用户点击一个点，拖动鼠标，然后再次释放鼠标按钮，我们将显示这两个点之间的距离。这是一个如何将您自己的地图交互逻辑添加到
    QGIS 中的好例子，使用 `QgsMapTool` 类。
- en: 'This is the basic structure for our `QgsMapTool` subclass:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 `QgsMapTool` 子类的结构基础：
- en: '[PRE37]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To make this map tool active, we'll create a new instance of it and pass it
    to the `mapCanvas.setMapTool()` method. Once this is done, our `canvasPressEvent()`
    and `canvasReleaseEvent()` methods will be called whenever the user clicks or
    releases the mouse button over the map canvas.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个地图工具生效，我们将创建一个新的实例并将其传递给 `mapCanvas.setMapTool()` 方法。一旦完成，当用户在地图画布上点击或释放鼠标按钮时，我们的
    `canvasPressEvent()` 和 `canvasReleaseEvent()` 方法将被调用。
- en: 'Let''s start with the code that responds when the user clicks on the canvas.
    In this method, we''re going to convert from the pixel coordinates that the user
    clicked on to the corresponding map coordinates (that is, a latitude and longitude
    value). We''ll then remember these coordinates so that we can refer to them later.
    Here is the necessary code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从响应用户在画布上点击的代码开始。在这个方法中，我们将从用户点击的像素坐标转换为相应的地图坐标（即纬度和经度值）。然后我们将记住这些坐标，以便以后可以引用它们。以下是必要的代码：
- en: '[PRE38]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When the `canvasReleaseEvent()` method is called, we''ll want to do the same
    with the point at which the user released the mouse button:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `canvasReleaseEvent()` 方法时，我们希望对用户释放鼠标按钮的点执行相同的操作：
- en: '[PRE39]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now that we have the two desired coordinates, we''ll want to calculate the
    distance between them. We can do this using a `QgsDistanceArea` object:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个所需的坐标，我们想要计算它们之间的距离。我们可以使用 `QgsDistanceArea` 对象来完成这项工作：
- en: '[PRE40]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice that we divide the resulting value by 1000\. This is because the `QgsDistanceArea`
    object returns the distance in meters, and we want to display the distance in
    kilometers.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将结果值除以 1000。这是因为 `QgsDistanceArea` 对象返回的距离是以米为单位的，而我们希望以千米为单位显示距离。
- en: 'Finally, we''ll display the calculated distance in the QGIS message bar:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将计算出的距离显示在 QGIS 消息栏中：
- en: '[PRE41]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now that we''ve created our map tool, we need to activate it. We can do this
    by adding the following to the end of our script:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的地图工具，我们需要激活它。我们可以通过将以下内容添加到脚本末尾来实现：
- en: '[PRE42]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With the map tool activated, the user can click and drag on the map. When the
    mouse button is released, the distance (in kilometers) between the two points
    will be displayed in the message bar:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图工具激活后，用户可以在地图上点击并拖动。当鼠标按钮释放时，两个点之间的距离（以千米为单位）将在消息栏中显示：
- en: '![Calculating the distance between two user-defined points](img/00035.jpeg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![计算两个用户定义点之间的距离](img/00035.jpeg)'
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took an in-depth look at the PyQGIS libraries and how you
    can use them in your own programs. We learned that the QGIS Python libraries are
    implemented as wrappers around the QGIS APIs implemented in C++. We saw how Python
    programmers can understand and work with the QGIS reference documentation, even
    though it is written for C++ developers. We also looked at the way the PyQGIS
    libraries are organized into different packages, and learned about the most important
    classes defined in the `qgis.core` and `qgis.gui` packages.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 PyQGIS 库以及如何在您的程序中使用它们。我们了解到，QGIS Python 库作为 C++ 中实现的 QGIS API
    的包装器来实现。我们看到了 Python 程序员如何理解和使用 QGIS 参考文档，尽管它是为 C++ 开发人员编写的。我们还了解了 PyQGIS 库是如何组织成不同的包的，并学习了在
    `qgis.core` 和 `qgis.gui` 包中定义的最重要类。
- en: We then saw how a coordinate reference systems (CRS) is used to translate from
    points on the three-dimensional surface of the Earth to coordinates within a two-dimensional
    map plane.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到了如何使用坐标参考系统（CRS）将地球三维表面上的点转换为二维地图平面内的坐标。
- en: We learned that vector format data is made up of features, where each feature
    has an ID, a geometry, and a set of attributes, and that symbols are used to draw
    vector geometries onto a map layer, while renderers are used to choose which symbol
    to use for a given feature.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到矢量格式数据由特征组成，其中每个特征都有一个ID、一个几何形状和一组属性，并且使用符号在地图层上绘制矢量几何形状，而渲染器用于选择给定特征应使用的符号。
- en: We learned how a spatial index can be used to speed up access to vector features.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到如何使用空间索引来加速对矢量特征的访问。
- en: Next, we saw how raster format data is organized into bands that represent information
    such as color, elevation, and so on, and looked at the various ways in which a
    raster data source can be displayed within a map layer. Along the way, we learned
    how to access the contents of a raster data source.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们看到了栅格格式数据是如何组织成代表颜色、高程等信息的光谱的，并探讨了在地图层中显示栅格数据源的各种方法。在这个过程中，我们学习了如何访问栅格数据源的内容。
- en: Finally, we looked at various techniques for performing useful tasks using the
    PyQGIS library.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了使用PyQGIS库执行有用任务的各种技术。
- en: In the next chapter, we will learn more about QGIS Python plugins, and then
    go on to use the plugin architecture as a way of implementing a useful feature
    within a mapping application.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于QGIS Python插件的内容，然后继续使用插件架构作为在地图应用程序中实现有用功能的一种方式。
