- en: Chapter 6. Understanding Big Data Analysis with Machine Learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：使用机器学习理解大数据分析
- en: 'In this chapter, we are going to learn about different machine learning techniques
    that can be used with R and Hadoop to perform Big Data analytics with the help
    of the following points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习不同的机器学习技术，这些技术可以与R和Hadoop一起使用，以通过以下要点执行大数据分析：
- en: Introduction to machine learning
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习简介
- en: Types of machine-learning algorithms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习算法类型
- en: Supervised machine-learning algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监督式机器学习算法
- en: Unsupervised machine-learning algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无监督机器学习算法
- en: Recommendation algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐算法
- en: Introduction to machine learning
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习简介
- en: Machine learning is a branch of artificial intelligence that allows us to make
    our application intelligent without being explicitly programmed. Machine learning
    concepts are used to enable applications to take a decision from the available
    datasets. A combination of machine learning and data mining can be used to develop
    spam mail detectors, self-driven cars, speech recognition, face recognition, and
    online transactional fraud-activity detection.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习是人工智能的一个分支，它使我们能够在没有显式编程的情况下，使应用程序具备智能。机器学习的概念被用于使应用程序能够从现有数据集中做出决策。机器学习与数据挖掘的结合可以用于开发垃圾邮件检测器、自动驾驶汽车、语音识别、面部识别和在线交易欺诈活动检测等。
- en: There are many popular organizations that are using machine-learning algorithms
    to make their service or product understand the need of their users and provide
    services as per their behavior. Google has its intelligent web search engine,
    which provides a number one search, spam classification in Google Mail, news labeling
    in Google News, and Amazon for recommender systems. There are many open source
    frameworks available for developing these types of applications/frameworks, such
    as R, Python, Apache Mahout, and Weka.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多知名的组织正在使用机器学习算法，使他们的服务或产品能够理解用户的需求，并根据用户的行为提供服务。谷歌拥有其智能的网页搜索引擎，提供了第一大搜索引擎、Google
    Mail中的垃圾邮件分类、Google News中的新闻标签分类，以及亚马逊的推荐系统。许多开源框架可用于开发这些类型的应用程序/框架，如R、Python、Apache
    Mahout和Weka。
- en: Types of machine-learning algorithms
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器学习算法类型
- en: 'There are three different types of machine-learning algorithms for intelligent
    system development:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有三种不同类型的机器学习算法，用于智能系统开发：
- en: Supervised machine-learning algorithms
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监督式机器学习算法
- en: Unsupervised machine-learning algorithms
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无监督机器学习算法
- en: Recommender systems
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐系统
- en: In this chapter, we are going to discuss well-known business problems with classification,
    regression, and clustering, as well as how to perform these machine-learning techniques
    over Hadoop to overcome memory issues.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一些著名的商业问题，包括分类、回归和聚类，以及如何在Hadoop上执行这些机器学习技术，以克服内存问题。
- en: 'If you load a dataset that won''t be able to fit into your machine memories
    and you try to run it, the predictive analysis will throw an error related to
    machine memory, such as **Error: cannot allocate vector of size 990.1 MB**. The
    solution is to increase the machine configuration or parallelize with commodity
    hardware.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你加载的某个数据集无法适应机器的内存，并且你尝试运行它，预测分析将抛出与机器内存相关的错误，例如**错误：无法分配大小为990.1 MB的向量**。解决方案是增加机器配置或使用商品硬件进行并行化。
- en: Supervised machine-learning algorithms
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监督式机器学习算法
- en: 'In this section, we will be learning about supervised machine-learning algorithms.
    The algorithms are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习监督式机器学习算法。算法如下：
- en: Linear regression
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性回归
- en: Logistic regression
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑回归
- en: Linear regression
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性回归
- en: Linear regression is mainly used for predicting and forecasting values based
    on historical information. Regression is a supervised machine-learning technique
    to identify the linear relationship between target variables and explanatory variables.
    We can say it is used for predicting the target variable values in numeric form.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归主要用于基于历史信息预测和预报值。回归是一个监督式机器学习技术，用于识别目标变量和解释变量之间的线性关系。我们可以说，它用于预测目标变量的数值。
- en: In the following section, we will be learning about linear regression with R
    and linear regression with R and Hadoop.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何使用R和Hadoop进行线性回归。
- en: Here, the variables that are going to be predicted are considered as target
    variables and the variables that are going to help predict the target variables
    are called explanatory variables. With the linear relationship, we can identify
    the impact of a change in explanatory variables on the target variable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，目标变量是需要预测的变量，帮助预测目标变量的变量称为解释变量。通过线性关系，我们可以识别解释变量变化对目标变量的影响。
- en: 'In mathematics, regression can be formulated as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，回归可以如下表示：
- en: y = ax +e
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: y = ax + e
- en: 'Other formulae include:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其他公式包括：
- en: 'The slope of the regression line is given by:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归线的斜率由以下公式给出：
- en: a= (NΣxy - (Σx)(Σy)) / (NΣx² - (Σx)²)
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a = (NΣxy - (Σx)(Σy)) / (NΣx² - (Σx)²)
- en: 'The intercept point of regression is given by:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归的截距点由以下公式给出：
- en: e = (Σy - b(Σx)) / N
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e = (Σy - b(Σx)) / N
- en: Here, *x* and *y* are variables that form a dataset and *N* is the total numbers
    of values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*x* 和 *y* 是构成数据集的变量，*N* 是值的总数。
- en: 'Suppose we have the data shown in the following table:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下表格中的数据：
- en: '| x | y |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| x | y |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 63 | 3.1 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 63 | 3.1 |'
- en: '| 64 | 3.6 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 3.6 |'
- en: '| 65 | 3.8 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 65 | 3.8 |'
- en: '| 66 | 4 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 66 | 4 |'
- en: If we have a new value of *x*, we can get the value of *y* with it with the
    help of the regression formula.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个新的 *x* 值，我们可以通过回归公式获得对应的 *y* 值。
- en: 'Applications of linear regression include:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归的应用包括：
- en: Sales forecasting
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销售预测
- en: Predicting optimum product price
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测最佳产品价格
- en: Predicting the next online purchase from various sources and campaigns
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从各种来源和活动中预测下一次在线购买
- en: Let's look at the statistical technique to implement the regression model for
    the provided dataset. Assume that we have been given n number of statistical data
    units.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用统计技术来实现提供的数据集的回归模型。假设我们已获得 n 个统计数据单元。
- en: '![Linear regression](img/3282OS_06_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![线性回归](img/3282OS_06_01.jpg)'
- en: 'Its formula is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它的公式如下：
- en: Y = e[0] + a[0]x[0] + a[1]x[1] + a[2]x[2] +a[3]x[3] + a[4]x[4]
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Y = e[0] + a[0]x[0] + a[1]x[1] + a[2]x[2] + a[3]x[3] + a[4]x[4]
- en: Here, *Y* is the target variable (response variable), *xi* are explanatory variables,
    and *e[0]* is the sum of the squared error term, which can be considered as noise.
    To get a more accurate prediction, we need to reduce this error term as soon as
    possible with the help of the `call` function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*Y* 是目标变量（响应变量），*xi* 是解释变量，*e[0]* 是误差项的平方和，可以视为噪声。为了获得更准确的预测，我们需要尽早通过 `call`
    函数减少这个误差项。
- en: Linear regression with R
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 R 进行线性回归
- en: Now we will see how to perform linear regression in R. We can use the in-built
    `lm()` method to build a linear regression model with R.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看看如何在 R 中执行线性回归。我们可以使用内置的 `lm()` 方法来构建一个线性回归模型。
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It will build a regression model based on the property of the provided dataset
    and store all of the variables' coefficients and model parameters used for predicting
    and identifying of data pattern from the model variable values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它将基于提供的数据集的属性构建回归模型，并存储所有用于预测和识别数据模式的变量系数和模型参数。
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following are the various model parameters that can be displayed with the
    preceding `summary` command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用前述 `summary` 命令可以显示的各种模型参数：
- en: '**RSS**: This is equal to ∑(yactual - y)².'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RSS**：这等于 ∑(y实际 - y)²。'
- en: '**Degrees of Freedom** (**DOF**): This is used for identifying the degree of
    fit for the prediction model, which should be as small as possible (logically,
    the value 0 means perfect prediction).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自由度**（**DOF**）：用于识别预测模型的拟合度，应该尽可能小（从逻辑上讲，值为 0 表示完美预测）。'
- en: '**Residual standard error** (**RSS/DF**): This is used for identifying the
    goodness of fit for the prediction model, which should be as small as possible
    (logically, the value 0 means perfect prediction).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**残差标准误差**（**RSS/DF**）：用于识别预测模型的拟合度，应该尽可能小（从逻辑上讲，值为 0 表示完美预测）。'
- en: '**pr**: This is the probability for a variable to be included into the model;
    it should be less than 0.05 for a variable to be included.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pr**：这是变量被纳入模型的概率；要将一个变量纳入模型，其值应小于 0.05。'
- en: '**t-value**: This is equal to 15.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**t 值**：这等于 15。'
- en: '**f**: This is the statistic that checks whether R square is a value other
    than zero.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f**：这是检查 R 方是否为非零值的统计量。'
- en: '![Linear regression with R](img/3282OS_06_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用 R 进行线性回归](img/3282OS_06_03.jpg)'
- en: Linear regression with R and Hadoop
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 R 和 Hadoop 进行线性回归
- en: Assume we have a large dataset. How will we perform regression data analysis
    now? In such cases, we can use R and Hadoop integration to perform parallel linear
    regression by implementing Mapper and Reducer. It will divide the dataset into
    chunks among the available nodes and then they will process the distributed data
    in parallel. It will not fire memory issues when we run with an R and Hadoop cluster
    because the large dataset is going to be distributed and processed with R among
    Hadoop computation nodes. Also, keep in mind that this implemented method does
    not provide higher prediction accuracy than the `lm()` model.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个大型数据集。现在我们如何进行回归数据分析？在这种情况下，我们可以使用 R 和 Hadoop 集成，通过实现 Mapper 和 Reducer
    来执行并行线性回归。它将把数据集分配到各个节点之间，然后这些节点将并行处理分布式数据。当我们在 R 和 Hadoop 集群中运行时，它不会引发内存问题，因为大型数据集将被分布式并与
    Hadoop 计算节点中的 R 一起处理。同时，请记住，这种实现方法的预测精度不比 `lm()` 模型高。
- en: RHadoop is used here for integration of R and Hadoop, which is a trusted open
    source distribution of **Revolution Analytics**. For more information on RHadoop,
    visit [https://github.com/RevolutionAnalytics/RHadoop/wiki](https://github.com/RevolutionAnalytics/RHadoop/wiki).
    Among the packages of RHadoop, here we are using only the `rmr` and `rhdfs` libraries.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: RHadoop 用于集成 R 和 Hadoop，它是 **Revolution Analytics** 的一个受信的开源发行版。如需了解有关 RHadoop
    的更多信息，请访问 [https://github.com/RevolutionAnalytics/RHadoop/wiki](https://github.com/RevolutionAnalytics/RHadoop/wiki)。在
    RHadoop 的软件包中，这里我们只使用 `rmr` 和 `rhdfs` 库。
- en: Let's see how to perform regression analysis with R and Hadoop data technologies.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 R 和 Hadoop 数据技术进行回归分析。
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, the `Sum()` function is re-usable as shown in the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Sum()` 函数是可重用的，如以下代码所示：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The outline of the linear regression algorithm is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归算法的大纲如下：
- en: Calculating the `Xtx` value with MapReduce job1.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 MapReduce 作业 1 计算 `Xtx` 值。
- en: Calculating the `Xty` value with MapReduce job2.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 MapReduce 作业 2 计算 `Xty` 值。
- en: Deriving the coefficient values with `Solve (Xtx, Xty)`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Solve (Xtx, Xty)` 推导系数值。
- en: Let's understand these steps one by one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一理解这些步骤。
- en: The first step is to calculate the `Xtx` value with MapReduce job 1.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用 MapReduce 作业 1 计算 `Xtx` 值。
- en: The big matrix is passed to the Mapper in chunks of complete rows. Smaller cross-products
    are computed for these submatrices and passed on to a single Reducer, which sums
    them together. Since we have a single key, a Combiner is mandatory and since the
    matrix sum is associative and commutative, we certainly can use it here.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大矩阵以完整行的块传递给 Mapper。这些子矩阵的较小交叉乘积会被计算并传递给单个 Reducer，后者将它们加总在一起。由于我们有一个单一的键，Combiner
    是必须的，而且由于矩阵求和具有结合性和交换性，我们当然可以在这里使用它。
- en: '[PRE4]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we have a large amount of data stored in **Hadoop Distributed File System**
    (**HDFS**), we need to pass its path value to the input parameters in the `MapReduce`
    method.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们有大量数据存储在 **Hadoop 分布式文件系统** (**HDFS**) 中时，我们需要将其路径值传递给 `MapReduce` 方法的输入参数。
- en: 'In the preceding code, we saw that `X` is the design matrix, which has been
    created with the following function:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到 `X` 是设计矩阵，它是通过以下函数创建的：
- en: '[PRE5]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Its output will look as shown in the following screenshot:![Linear regression
    with R and Hadoop](img/3282OS_06_10.jpg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它的输出将如下所示：![使用 R 和 Hadoop 进行线性回归](img/3282OS_06_10.jpg)
- en: So, here all the columns will be considered as explanatory variables and their
    standard errors can be calculated in a similar manner to how we calculated them
    with normal linear regression.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里所有列将被视为解释变量，并且它们的标准误差可以按照与正常线性回归中计算标准误差的相同方式来计算。
- en: To calculate the `Xty` value with MapReduce job 2 is pretty much the same as
    for the vector `y`, which is available to the nodes according to normal scope
    rules.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 `Xty` 值与 MapReduce 作业 2 基本相同，向量 `y` 会根据正常作用域规则在各节点中可用。
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To derive the coefficient values with `solve (Xtx, Xty)`, use the following
    steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要推导系数值，使用 `solve (Xtx, Xty)`，请按照以下步骤操作：
- en: Finally, we just need to call the following line of code to get the coefficient
    values.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需要调用以下代码行来获取系数值。
- en: '[PRE7]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output of the preceding command will be as shown in the following screenshot:![Linear
    regression with R and Hadoop](img/3282OS_06_02.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的命令的输出将如下所示：![使用 R 和 Hadoop 进行线性回归](img/3282OS_06_02.jpg)
- en: Logistic regression
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑回归
- en: In statistics, logistic regression or logit regression is a type of probabilistic
    classification model. Logistic regression is used extensively in numerous disciplines,
    including the medical and social science fields. It can be binomial or multinomial.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学中，逻辑回归或logit回归是一种概率分类模型。逻辑回归在许多学科中广泛应用，包括医学和社会科学领域。它可以是二项式或多项式。
- en: Binary logistic regression deals with situations in which the outcome for a
    dependent variable can have two possible types. Multinomial logistic regression
    deals with situations where the outcome can have three or more possible types.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 二元逻辑回归处理因变量结果可能有两种可能类型的情况。多项式逻辑回归处理结果可能有三种或更多类型的情况。
- en: Logistic regression can be implemented using logistic functions, which are listed
    here.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归可以使用逻辑函数实现，这里列出了它们。
- en: 'To predict the log odds ratios, use the following formula:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要预测对数几率比，请使用以下公式：
- en: logit(p) = β0 + β1 × x1 + β2 × x2 + ... + βn × xn
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: logit(p) = β0 + β1 × x1 + β2 × x2 + ... + βn × xn
- en: 'The probability formula is as follows:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概率公式如下：
- en: p = e^(logit(p)) ⁄ 1 + e^(logit(p))
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: p = e^(logit(p)) ⁄ 1 + e^(logit(p))
- en: '`logit(p)` is a linear function of the explanatory variable, X (x1,x2,x3..xn),
    which is similar to linear regression. So, the output of this function will be
    in the range 0 to 1\. Based on the probability score, we can set its probability
    range from 0 to 1\. In a majority of the cases, if the score is greater than 0.5,
    it will be considered as 1, otherwise 0\. Also, we can say it provides a classification
    boundary to classify the outcome variable.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`logit(p)`是解释变量X（x1，x2，x3..xn）的线性函数，类似于线性回归。因此，该函数的输出将在0到1的范围内。根据概率分数，我们可以将其概率范围设置为0到1。在大多数情况下，如果分数大于0.5，则视为1，否则为0。此外，我们可以说它为分类结果提供了分类边界。'
- en: '![Logistic regression](img/3282OS_06_04.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![逻辑回归](img/3282OS_06_04.jpg)'
- en: The preceding figure is of a training dataset. Based on the training dataset
    plot, we can say there is one classification boundary generated by the `glm` model
    in R.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图是一个训练数据集。基于训练数据集的绘图，我们可以说`glm`模型在R中生成了一个分类边界。
- en: 'Applications of logistic regression include:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归的应用包括：
- en: Predicting the likelihood of an online purchase
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测在线购买的可能性
- en: Detecting the presence of diabetes
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测糖尿病的存在
- en: Logistic regression with R
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用R进行逻辑回归
- en: To perform logistic regression with R, we will use the `iris` dataset and the
    `glm` model.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用R执行逻辑回归，我们将使用`iris`数据集和`glm`模型。
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Logistic regression with R and Hadoop
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用R和Hadoop进行逻辑回归
- en: To perform logistic regression with R and Hadoop, we will use RHadoop with `rmr2`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用R和Hadoop执行逻辑回归，我们将使用`rmr2`和RHadoop。
- en: 'The outline of the logistic regression algorithm is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归算法的大纲如下：
- en: Defining the `lr.map` Mapper function
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`lr.map`映射函数
- en: Defining the `lr.reducer` Reducer function
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`lr.reducer`减少函数
- en: Defining the `logistic.regression` MapReduce function
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`logistic.regression` MapReduce函数
- en: Let's understand them one by one.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一理解它们。
- en: We will first define the logistic regression function with gradient decent.
    Multivariate regression can be performed by forming the nondependent variable
    into a matrix data format. For factorial variables, we can translate them to binary
    variables for fitting the model. This function will ask for `input`, `iterations`,
    `dims`, and `alpha` as input parameters.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义梯度下降的逻辑回归函数。可以通过将非依赖变量形成矩阵数据格式来执行多变量回归。对于因子变量，我们可以将它们转换为二元变量以适应模型。此函数将要求`input`，`iterations`，`dims`和`alpha`作为输入参数。
- en: '`lr.map`: This stands for the logistic regression Mapper, which will compute
    the contribution of subset points to the gradient.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lr.map`：这代表逻辑回归映射器，将计算子集点对梯度的贡献。'
- en: '[PRE9]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`lr.reducer`: This stands for the logistic regression Reducer, which is performing
    just a big sum of all the values of key 1.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lr.reducer`：这代表逻辑回归减少器，仅执行键1所有值的总和。'
- en: '[PRE10]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`logistic.regression`: This will mainly define the `logistic.regression` MapReduce
    function with the following input parameters. Calling this function will start
    executing logistic regression of the MapReduce function.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logistic.regression`：这将主要定义`logistic.regression` MapReduce函数，并带有以下输入参数。调用此函数将开始执行MapReduce函数的逻辑回归。'
- en: '`input`: This is an input dataset'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input`: 这是一个输入数据集。'
- en: '`iterations`: This is the fixed number of iterations for calculating the gradient'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterations`: 这是计算梯度的固定迭代次数。'
- en: '`dims`: This is the dimension of input variables'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dims`：这是输入变量的维度'
- en: '`alpha`: This is the learning rate'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alpha`：这是学习率'
- en: Let's see how to develop the logistic regression function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何开发逻辑回归函数。
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s run this logistic regression function as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按如下方式运行这个逻辑回归函数：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the preceding command will be as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令的输出结果如下：
- en: '![Logistic regression with R and Hadoop](img/3282OS_06_09.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![使用R和Hadoop进行逻辑回归](img/3282OS_06_09.jpg)'
- en: Unsupervised machine learning algorithm
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无监督机器学习算法
- en: In machine learning, unsupervised learning is used for finding the hidden structure
    from the unlabeled dataset. Since the datasets are not labeled, there will be
    no error while evaluating for potential solutions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，无监督学习用于从未标记的数据集中发现隐藏的结构。由于数据集是未标记的，因此在评估潜在解决方案时不会出现错误。
- en: 'Unsupervised machine learning includes several algorithms, some of which are
    as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无监督机器学习包括几种算法，以下是其中的一些：
- en: Clustering
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚类
- en: Artificial neural networks
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工神经网络
- en: Vector quantization
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量量化
- en: We will consider popular clustering algorithms here.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里考虑流行的聚类算法。
- en: Clustering
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚类
- en: Clustering is the task of grouping a set of object in such a way that similar
    objects with similar characteristics are grouped in the same category, but other
    objects are grouped in other categories. In clustering, the input datasets are
    not labeled; they need to be labeled based on the similarity of their data structure.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类是将一组对象分组的任务，使得具有相似特征的对象被分到同一类别，而其他对象则分到不同类别。在聚类中，输入数据集是未标记的；它们需要根据数据结构的相似性进行标记。
- en: In unsupervised machine learning, the classification technique performs the
    same procedure to map the data to a category with the help of the provided set
    of input training datasets. The corresponding procedure is known as clustering
    (or cluster analysis), and involves grouping data into categories based on some
    measure of inherent similarity; for example, the distance between data points.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在无监督机器学习中，分类技术执行相同的程序，通过提供的输入训练数据集将数据映射到一个类别。这个相应的过程称为聚类（或聚类分析），它通过某种固有相似性的度量将数据分组到不同的类别中；例如，数据点之间的距离。
- en: 'From the following figure, we can identify clustering as grouping objects based
    on their similarity:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从下图中，我们可以识别出聚类是基于相似性将对象分组：
- en: '![Clustering](img/3282OS_06_05.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![聚类](img/3282OS_06_05.jpg)'
- en: There are several clustering techniques available within R libraries, such as
    k-means, k-medoids, hierarchical, and density-based clustering. Among them, k-means
    is widely used as the clustering algorithm in data science. This algorithm asks
    for a number of clusters to be the input parameters from the user side.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: R库中有几种聚类技术，如k-means、k-medoids、层次聚类和基于密度的聚类。在这些技术中，k-means是数据科学中广泛使用的聚类算法。该算法要求用户提供聚类的数量作为输入参数。
- en: 'Applications of clustering are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类的应用如下：
- en: Market segmentation
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场细分
- en: Social network analysis
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交网络分析
- en: Organizing computer network
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织计算机网络
- en: Astronomical data analysis
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天文数据分析
- en: Clustering with R
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用R进行聚类
- en: We are considering the `k-means` method here for implementing the clustering
    model over the `iris` input dataset, which can be achieved by just calling its
    in-built R dataset – the `iris` data (for more information, visit [http://stat.ethz.ch/R-manual/R-devel/library/datasets/html/iris.html](http://stat.ethz.ch/R-manual/R-devel/library/datasets/html/iris.html)).
    Here we will see how k-means clustering can be performed with R.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里考虑`k-means`方法来实现聚类模型，基于`iris`输入数据集，只需调用其内置的R数据集——`iris`数据（欲了解更多信息，请访问[http://stat.ethz.ch/R-manual/R-devel/library/datasets/html/iris.html](http://stat.ethz.ch/R-manual/R-devel/library/datasets/html/iris.html)）。在这里我们将看到如何使用R执行k-means聚类。
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Deriving clusters for small datasets is quite simple, but deriving it for huge
    datasets requires the use of Hadoop for providing computation power.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型数据集，推导聚类是相当简单的，但对于大型数据集，推导聚类需要使用Hadoop来提供计算能力。
- en: Performing clustering with R and Hadoop
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用R和Hadoop进行聚类
- en: Since the k-means clustering algorithm is already developed in RHadoop, we are
    going to use and understand it. You can make changes in their Mappers and Reducers
    as per the input dataset format. As we are dealing with Hadoop, we need to develop
    the Mappers and Reducers to be run on nodes in a parallel manner.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于k-means聚类算法已经在RHadoop中开发完成，我们将使用并理解它。您可以根据输入数据集格式修改它们的Mappers和Reducers。由于我们正在处理Hadoop，因此需要开发Mappers和Reducers，以便在节点上并行运行。
- en: 'The outline of the clustering algorithm is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类算法的概述如下：
- en: Defining the `dist.fun` distance function
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`dist.fun`距离函数
- en: Defining the `k-means.map` k-means Mapper function
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`k-means.map` k-means Mapper函数
- en: Defining the `k-means.reduce` k-means Reducer function
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`k-means.reduce` k-means Reducer函数
- en: Defining the `k-means.mr` k-means MapReduce function
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`k-means.mr` k-means MapReduce函数
- en: Defining input data points to be provided to the clustering algorithms
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义要提供给聚类算法的输入数据点
- en: Now we will run `k-means.mr` (the k-means MapReduce job) by providing the required
    parameters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过提供所需的参数运行`k-means.mr`（k-means MapReduce作业）。
- en: Let's understand them one by one.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一理解它们。
- en: '`dist.fun`: First, we will see the `dist.fun` function for calculating the
    distance between a matrix of center `C` and a matrix of point `P`, which is tested.
    It can produce 10⁶ points and 10² centers in five dimensions in approximately
    16 seconds.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dist.fun`：首先，我们将查看`dist.fun`函数，该函数用于计算中心矩阵`C`与点矩阵`P`之间的距离。它经过测试后，能够在大约16秒内生成10⁶个点和10²个中心（5维）。'
- en: '[PRE14]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`k-means.map`: The Mapper of the k-means MapReduce algorithm will compute the
    distance between points and all the centers and return the closest center for
    each point. This Mapper will run in iterations based on the following code. With
    the first iteration, the cluster center will be assigned randomly and from the
    next iteration, it will calculate these cluster centers based on the minimum distance
    from all the points of the cluster.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k-means.map`：k-means MapReduce算法的Mapper将计算点与所有中心之间的距离，并返回每个点的最近中心。这个Mapper将根据以下代码进行迭代运行。在第一次迭代中，聚类中心将被随机分配，从下一次迭代开始，它将根据与聚类中所有点的最小距离计算这些聚类中心。'
- en: '[PRE15]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`k-means.reduce`: The Reducer of the k-means MapReduce algorithm will compute
    the column average of matrix points as key.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k-means.reduce`：k-means MapReduce算法的Reducer将计算矩阵点的列平均值作为键。'
- en: '[PRE16]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`kmeans.mr`: Defining the k-means MapReduce function involves specifying several
    input parameters, which are as follows:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kmeans.mr`：定义k-means MapReduce函数涉及指定几个输入参数，具体如下：'
- en: '`P`: This denotes the input data points'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P`：表示输入数据点。'
- en: '`num.clusters`: This is the total number of clusters'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num.clusters`：这是总的聚类数量。'
- en: '`num.iter`: This is the total number of iterations to be processed with datasets'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num.iter`：这是处理数据集的总迭代次数。'
- en: '`combine`: This will decide whether the Combiner should be enabled or disabled
    (`TRUE` or `FALSE`)'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combine`：这将决定是否启用Combiner（`TRUE`或`FALSE`）。'
- en: '[PRE17]'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Defining the input data points to be provided to the clustering algorithms:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义要提供给聚类算法的输入数据点：
- en: '[PRE18]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running `kmeans.mr` (the k-means MapReduce job) by providing it with the required
    parameters.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供所需参数运行`kmeans.mr`（k-means MapReduce作业）。
- en: '[PRE19]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The output of the preceding command is shown in the following screenshot:![Performing
    clustering with R and Hadoop](img/3282OS_06_06.jpg)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述命令的输出显示在以下截图中：![使用R和Hadoop进行聚类](img/3282OS_06_06.jpg)
- en: Recommendation algorithms
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐算法
- en: Recommendation is a machine-learning technique to predict what new items a user
    would like based on associations with the user's previous items. Recommendations
    are widely used in the field of e-commerce applications. Through this flexible
    data and behavior-driven algorithms, businesses can increase conversions by helping
    to ensure that relevant choices are automatically suggested to the right customers
    at the right time with cross-selling or up-selling.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐是机器学习技术，用于预测用户可能喜欢的新项目，基于用户与之前项目的关联。推荐广泛应用于电子商务领域。通过这种灵活的数据和行为驱动算法，企业可以通过确保在正确的时间向正确的客户自动推荐相关选择，从而增加转化率，实现交叉销售或追加销售。
- en: For example, when a customer is looking for a Samsung Galaxy S IV/S4 mobile
    phone on Amazon, the store will also suggest other mobile phones similar to this
    one, presented in the **Customers Who Bought This Item Also Bought** window.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当一个客户在亚马逊上寻找三星Galaxy S IV/S4手机时，商店还会建议其他类似的手机，这些手机会出现在**购买此商品的客户还购买了**窗口中。
- en: 'There are two different types of recommendations:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同类型的推荐：
- en: '**User-based recommendations**: In this type, users (customers) similar to
    current user (customer) are determined. Based on this user similarity, their interested/used
    items can be recommended to other users. Let''s learn it through an example.![Recommendation
    algorithms](img/3282OS_06_07.jpg)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于用户的推荐**：在这种类型中，将确定与当前用户（客户）相似的用户（客户）。基于这种用户相似性，他们感兴趣/使用的物品可以推荐给其他用户。让我们通过一个例子来学习它。![推荐算法](img/3282OS_06_07.jpg)'
- en: Assume there are two users named Wendell and James; both have a similar interest
    because both are using an iPhone. Wendell had used two items, iPad and iPhone,
    so James will be recommended to use iPad. This is user-based recommendation.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设有两个用户，Wendell和James，他们有相似的兴趣，因为两人都在使用iPhone。Wendell使用了两种物品：iPad和iPhone，所以James会被推荐使用iPad。这是基于用户的推荐。
- en: '**Item-based recommendations**: In this type, items similar to the items that
    are being currently used by a user are determined. Based on the item-similarity
    score, the similar items will be presented to the users for cross-selling and
    up-selling type of recommendations. Let''s learn it through an example.![Recommendation
    algorithms](img/3282OS_06_08.jpg)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于项目的推荐**：在这种类型中，将确定与用户当前使用的项目相似的项目。基于项目相似度分数，将向用户展示类似的项目，以进行交叉销售和向上销售类型的推荐。让我们通过一个例子来学习它。![推荐算法](img/3282OS_06_08.jpg)'
- en: 'For example, a user named Vaibhav likes and uses the following books:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个名为Vaibhav的用户喜欢并使用以下几本书：
- en: '*Apache Mahout Cookbook*, *Piero Giacomelli*, *Packt Publishing*'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Apache Mahout秘籍》*，*Piero Giacomelli*，*Packt Publishing*'
- en: '*Hadoop MapReduce Cookbook*, *Thilina Gunarathne* and *Srinath Perera*, *Packt
    Publishing*'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Hadoop MapReduce秘籍》*，*Thilina Gunarathne* 和 *Srinath Perera*，*Packt Publishing*'
- en: '*Hadoop Real-World Solutions Cookbook*, *Brian Femiano*, *Jon Lentz*, and *Jonathan
    R. Owens*, *Packt Publishing*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Hadoop真实世界解决方案秘籍》*，*Brian Femiano*，*Jon Lentz* 和 *Jonathan R. Owens*，*Packt
    Publishing*'
- en: '*Big Data For Dummies*, *Dr. Fern Halper*, *Judith Hurwitz*, *Marcia Kaufman*,
    and *Alan Nugent*, *John Wiley & Sons Publishers*'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《大数据入门》*，*Dr. Fern Halper*，*Judith Hurwitz*，*Marcia Kaufman* 和 *Alan Nugent*，*John
    Wiley & Sons Publishers*'
- en: 'Based on the preceding information, the recommender system will predict which
    new books Vaibhav would like to read, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 基于上述信息，推荐系统将预测Vaibhav会喜欢阅读哪些新书，如下所示：
- en: '*Big Data Analytics with R and Hadoop*, *Vignesh Prajapati*, *Packt Publishing*'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《大数据分析与R与Hadoop》*，*Vignesh Prajapati*，*Packt Publishing*'
- en: Now we will see how to generate recommendations with R and Hadoop. But before
    going towards the R and Hadoop combination, let us first see how to generate it
    with R. This will clear the concepts to translate your generated recommender systems
    to MapReduce recommendation algorithms. In case of generating recommendations
    with R and Hadoop, we will use the RHadoop distribution of **Revolution Analytics**.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将了解如何使用R和Hadoop生成推荐。但是，在讲解R和Hadoop的结合之前，首先让我们看看如何用R来生成推荐。这将帮助你理解如何将生成的推荐系统转换为MapReduce推荐算法。在使用R和Hadoop生成推荐时，我们将使用**Revolution
    Analytics**的RHadoop分发版。
- en: Steps to generate recommendations in R
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在R中生成推荐的步骤
- en: To generate recommendations for users, we need to have datasets in a special
    format that can be read by the algorithm. Here, we will use the collaborative
    filtering algorithm for generating the recommendations rather than content-based
    algorithms. Hence, we will need the user's rating information for the available
    item sets. So, the `small.csv` dataset is given in the format `user ID, item ID,
    item's ratings`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成用户推荐，我们需要具有特定格式的数据集，算法可以读取这些数据。在这里，我们将使用协同过滤算法来生成推荐，而不是基于内容的算法。因此，我们需要用户对可用项目集的评分信息。因此，`small.csv`数据集采用`user
    ID, item ID, item's ratings`格式。
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code and datasets are reproduced from the book *Mahout in Action,
    Robin Anil, Ellen Friedman, Ted Dunning,* and *Sean Owen, Manning Publications*
    and the website is [http://www.fens.me/](http://www.fens.me/).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码和数据集摘自《*Mahout in Action*》一书，作者为*Robin Anil*、*Ellen Friedman*、*Ted Dunning*和*Sean
    Owen*，由Manning Publications出版，网址为[http://www.fens.me/](http://www.fens.me/)。
- en: 'Recommendations can be derived from the matrix-factorization technique as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐可以通过矩阵分解技术推导出来，如下所示：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To generate the recommenders, we will follow the given steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成推荐系统，我们将遵循以下步骤：
- en: Computing the co-occurrence matrix.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算共现矩阵。
- en: Establishing the user-scoring matrix.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立用户评分矩阵。
- en: Generating recommendations.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成推荐。
- en: From the next section, we will see technical details for performing the preceding
    steps.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一部分开始，我们将看到执行前述步骤的技术细节。
- en: In the first section, computing the co-occurrence matrix, we will be able to
    identify the co-occurred item sets given in the dataset. In simple words, we can
    call it counting the pair of items from the given dataset.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一部分中，计算共现矩阵时，我们能够识别数据集中给定的共现物品集。简单来说，我们可以称之为从给定数据集中计数物品对。
- en: '[PRE22]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To establish the user-scoring matrix based on the user's rating information,
    the user-item rating matrix can be generated for users.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了基于用户评分信息建立用户评分矩阵，可以为用户生成用户-物品评分矩阵。
- en: '[PRE23]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, the recommendations as output can be generated by the product operations
    of both matrix items: co-occurrence matrix and user''s scoring matrix.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，可以通过两个矩阵项的产品操作生成输出推荐：共现矩阵和用户评分矩阵。
- en: '[PRE24]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Generating recommendations via **Myrrix** and R interface is quite easy. For
    more information, refer to [https://github.com/jwijffels/Myrrix-R-interface](https://github.com/jwijffels/Myrrix-R-interface).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**Myrrix**和R接口生成推荐非常简单。更多信息，请参考[https://github.com/jwijffels/Myrrix-R-interface](https://github.com/jwijffels/Myrrix-R-interface)。
- en: Generating recommendations with R and Hadoop
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用R和Hadoop生成推荐
- en: To generate recommendations with R and Hadoop, we need to develop an algorithm
    that will be able to run and perform data processing in a parallel manner. This
    can be implemented using Mappers and Reducers. A very interesting part of this
    section is how we can use R and Hadoop together to generate recommendations from
    big datasets.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用R和Hadoop生成推荐，我们需要开发一个能够并行执行和处理数据的算法。这可以通过使用Mappers和Reducers来实现。该部分的一个非常有趣的部分是我们如何将R和Hadoop结合使用，从大数据集生成推荐。
- en: 'So, here are the steps that are similar to generating recommendations with
    R, but translating them to the Mapper and Reducer paradigms is a little tricky:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，以下步骤类似于使用R生成推荐，但将其转换为Mapper和Reducer范式有些复杂：
- en: Establishing the co-occurrence matrix items.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立共现矩阵项。
- en: Establishing the user scoring matrix to articles.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户评分矩阵建立到文章中。
- en: Generating recommendations.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成推荐。
- en: We will use the same concepts as our previous operation with R to generate recommendations
    with R and Hadoop. But in this case, we need to use a key-value paradigm as it's
    the base of parallel operations. Therefore, every function will be implemented
    by considering the key-value paradigm.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与之前在R中生成推荐相同的概念来结合R和Hadoop生成推荐。但在这种情况下，我们需要使用键值对范式，因为它是并行操作的基础。因此，每个函数都将通过考虑键值对范式来实现。
- en: 'In the first section, establishment of the co-occurrence matrix items, we will
    establish co-occurrence items in steps: grouped by user, locate each user-selected
    items appearing alone counting, and counting in pairs.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一部分中，建立共现矩阵项时，我们将按照步骤建立共现项：按用户分组，定位每个用户选择的单独出现物品计数，以及配对计数。
- en: '[PRE25]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The key points to note are:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要注意的要点是：
- en: '`train.mr`: This is the MapReduce job''s key-value paradigm information'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`train.mr`：这是MapReduce任务的键值对范式信息'
- en: '**key**: This is the list of items vector'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**key**：这是物品列表向量'
- en: '**value**: This is the item combination vector'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value**：这是物品组合向量'
- en: '[PRE26]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The co-occurrence matrix items will be combined to count them.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 共现矩阵项将被组合以进行计数。
- en: To define a MapReduce job, `step2.mr` is used for calculating the frequency
    of the combinations of items.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了定义一个MapReduce任务，使用`step2.mr`来计算物品组合的频率。
- en: '`Step2.mr`: This is the MapReduce job''s key value paradigm information'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Step2.mr`：这是MapReduce任务的键值对范式信息'
- en: '**key**: This is the list of items vector'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**key**：这是物品列表向量'
- en: '**value**: This is the co-occurrence matrix dataframe value (`item`, `item`,
    `Freq`)'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value**：这是共现矩阵数据框的值（`item`，`item`，`Freq`）'
- en: '[PRE27]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To establish the user-scoring matrix to articles, let us define the `Train2.mr`
    MapReduce job.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将用户评分矩阵建立到文章中，让我们定义`Train2.mr` MapReduce任务。
- en: '[PRE28]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Train2.mr`: This is the MapReduce job''s key value paradigm information'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Train2.mr`：这是MapReduce任务的键值对范式信息'
- en: '**key**: This is the list of items'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**key**：这是物品列表'
- en: '**value**: This is the value of the user goods scoring matrix'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value**：这是用户商品评分矩阵的值'
- en: 'The following is the consolidation and co-occurrence scoring matrix:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是合并和共现评分矩阵：
- en: '[PRE29]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`eq.hdfs`: This is the MapReduce job''s key value paradigm information'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eq.hdfs`：这是MapReduce任务的键值对范式信息'
- en: '**key**: The key here is null'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**key**：这里的键是空的'
- en: '**value**: This is the merged dataframe value'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value**：这是合并的数据框值'
- en: In the section of generating recommendations, we will obtain the recommended
    list of results.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成推荐的部分，我们将获取推荐结果的列表。
- en: '[PRE30]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`Cal.mr`: This is the MapReduce job''s key value paradigm information'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cal.mr`: 这是MapReduce作业的键值范式信息'
- en: '**key**: This is the list of items'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**key**: 这是项目列表'
- en: '**value**: This is the recommended result dataframe value'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value**: 这是推荐结果数据框的值'
- en: By defining the result for getting the list of recommended items with preference
    value, the sorting process will be applied on the recommendation result.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过定义用于获取带有优先级值的推荐项目列表的结果，将对推荐结果进行排序处理。
- en: '[PRE31]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`result.mr`: This is the MapReduce job''s key value paradigm information'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result.mr`: 这是MapReduce作业的键值范式信息'
- en: '**key**: This is the user ID'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**key**: 这是用户ID'
- en: '**value**: This is the recommended outcome dataframe value'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value**: 这是推荐结果数据框的值'
- en: Here, we have designed the collaborative algorithms for generating item-based
    recommendation. Since we have tried to make it run on parallel nodes, we have
    focused on the Mapper and Reducer. They may not be optimal in some cases, but
    you can make them optimal by using the available code.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设计了用于生成基于项目推荐的协同算法。由于我们尝试使其在并行节点上运行，我们重点关注了Mapper和Reducer。它们在某些情况下可能不是最优的，但你可以通过使用现有代码使其变得最优。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how we can perform Big Data analytics with machine
    learning with the help of R and Hadoop technologies. In the next chapter, we will
    learn how to enrich datasets in R by integrating R to various external data sources.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何借助R和Hadoop技术利用机器学习进行大数据分析。在下一章，我们将学习如何通过将R与各种外部数据源集成来丰富数据集。
