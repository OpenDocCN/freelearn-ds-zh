- en: Chapter 8. Automating Analysis with Processing Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章：使用 Processing 模型自动化分析
- en: In this chapter, you will learn how to use the graphical modeler from the QGIS
    Processing framework to create models and automate complex analysis tasks. We
    will cover all the necessary steps starting from creating the model and ending
    up with sharing the model with other users.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用 QGIS 处理框架中的图形模型器来创建模型并自动化复杂分析任务。我们将涵盖从创建模型到与其他用户共享模型的必要步骤。
- en: 'In this chapter, we will go through the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: The QGIS Processing framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QGIS 处理框架
- en: The Graphical modeler
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形模型器
- en: Adding inputs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加输入
- en: Implementing the workflow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施工作流程
- en: Filling in model metadata and saving
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填写模型元数据和保存
- en: Editing models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑模型
- en: Sharing models
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享模型
- en: The QGIS Processing framework
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QGIS 处理框架
- en: The QGIS Processing framework (formerly SEXTANTE) is an QGIS core plugin that
    implements a powerful analysis and geoprocessing environment and provides a user-friendly
    interface for various native QGIS algorithms and third-party analysis software,
    such as GRASS, SAGA, Orfeo ToolBox, and many others.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS 处理框架（以前称为 SEXTANTE）是一个 QGIS 核心插件，它实现了一个强大的分析和地理处理环境，并为各种原生 QGIS 算法和第三方分析软件（如
    GRASS、SAGA、Orfeo ToolBox 等）提供了一个用户友好的界面。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Refer to the QGIS user guide at [http://docs.qgis.org/testing/en/docs/user_manual/processing/intro.html](http://docs.qgis.org/testing/en/docs/user_manual/processing/intro.html)
    if you want more information about the QGIS Processing framework.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于 QGIS 处理框架的信息，请参阅 QGIS 用户指南：[http://docs.qgis.org/testing/en/docs/user_manual/processing/intro.html](http://docs.qgis.org/testing/en/docs/user_manual/processing/intro.html)。
- en: 'The Processing user interface consists of four main components. Each of them
    allows you to run algorithms in a different way. Deciding which component to use
    depends on the task and type of analysis. As the Processing plugin is activated
    by default, we can access all of its components and functionality, except the
    batch processing interface, from the Processing menu:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 用户界面由四个主要组件组成。每个组件都允许您以不同的方式运行算法。决定使用哪个组件取决于任务和分析类型。由于 Processing
    插件默认激活，我们可以从 Processing 菜单访问所有其组件和功能，除了批处理界面：
- en: '![The QGIS Processing framework](img/image00498.jpeg) Toolbox: This is the
    main Processing GUI element. It provides access to all available algorithms (grouped
    by provider or purpose) and allows us to run them in single-pass and batch modes.
    The Processing Toolbox has two modes: simplified (default) and advanced. In simplified
    mode, all algorithms are placed in predefined groups and have user-friendly names,
    with the aim of helping novice users find the necessary tools. In advanced mode,
    algorithms are grouped by *providers*. Each provider represents some analysis
    package or program, for example, GRASS, Orfeo ToolBox, and so on. Also, in advanced
    mode, we have access to a larger number of algorithms, as some special providers
    are available only in this mode. In the upcoming sections, we will assume that
    the toolbox is used in advanced mode.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![QGIS 处理框架](img/image00498.jpeg)工具箱：这是主要的 Processing 图形用户界面元素。它提供了对所有可用算法（按提供者或目的分组）的访问，并允许我们在单次传递和批处理模式下运行它们。Processing
    工具箱有两种模式：简化（默认）和高级。在简化模式下，所有算法都放置在预定义的组中，并具有用户友好的名称，旨在帮助新手用户找到必要的工具。在高级模式下，算法按*提供者*分组。每个提供者代表某个分析包或程序，例如
    GRASS、Orfeo ToolBox 等。此外，在高级模式下，我们还可以访问更多算法，因为一些特殊提供者仅在此模式下可用。在接下来的章节中，我们将假设工具箱是在高级模式下使用的。'
- en: To activate advanced mode, just select the **Advanced** interface from the combobox
    at the bottom of the Processing toolbox.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要激活高级模式，只需从 Processing 工具箱底部的组合框中选择**高级**界面。
- en: '![The QGIS Processing framework](img/image00499.jpeg)**history manager**: This
    stores information about all executed algorithms and their parameters so that,
    if necessary, one can easily reproduce a past action. Also, all errors, warnings,
    and information messages are displayed here.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![QGIS 处理框架](img/image00499.jpeg)**历史管理器**：此功能存储有关所有执行算法及其参数的信息，以便在必要时可以轻松地重现过去的行为。此外，所有错误、警告和信息消息都显示在此处。'
- en: '**batch processing interface**: This is used to run individual algorithms on
    multiple datasets. This interface is accessible only from the Processing Toolbox
    and is not available in the Processing menu.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批处理界面**：此界面用于在多个数据集上运行单个算法。此界面仅从 Processing 工具箱中访问，并在 Processing 菜单中不可用。'
- en: '![The QGIS Processing framework](img/image00500.jpeg)**graphical modeler**:
    This is used to create new algorithms by combining existing ones into a single
    workflow. It allows us to easily automate a complex analysis that involves several
    steps.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![QGIS处理框架](img/image00500.jpeg)**图形模型器**：这是通过将现有算法组合成一个单一的工作流程来创建新算法的工具。它允许我们轻松自动化涉及多个步骤的复杂分析。'
- en: In the next section, we will see how to use the Processing Graphical modeler
    and create our own models to automate analysis tasks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解如何使用Processing图形模型器创建自己的模型以自动化分析任务。
- en: Graphical Modeler
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形模型器
- en: As we have already seen in previous chapters, even a simple analysis may require
    several steps. In real-life applications, much more complex tasks exist, and they
    involve and combine different processes of analysis. Running them manually is
    a time-consuming process, and it may take hours to complete. Things become even
    worse and complicated when you need to run this analysis several times with different
    input data or use the same data with different settings.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中已经看到的，即使是简单的分析也可能需要多个步骤。在实际应用中，存在更多更复杂的任务，它们涉及并组合不同的分析过程。手动运行这些任务是一个耗时的过程，可能需要数小时才能完成。当你需要多次运行此分析，使用不同的输入数据或使用相同数据但不同设置时，事情变得更加糟糕和复杂。
- en: This is where the QGIS Processing framework comes to help. It allows us to automate
    repeated tasks and create new complex algorithms that involve different types
    of data processing. With the help of the Graphical modeler from the Processing
    toolbox, we can easily create our own algorithms by combining existing algorithms.
    The created model can be executed like any other Processing algorithm, and even
    used as part of another, more complex model.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是QGIS处理框架提供帮助的地方。它允许我们自动化重复的任务并创建涉及不同类型数据处理的新复杂算法。借助Processing工具箱中的图形模型器，我们可以轻松通过组合现有算法来创建自己的算法。创建的模型可以像任何其他Processing算法一样执行，甚至可以作为更复杂模型的一部分使用。
- en: 'There are two common ways of opening the Graphical Modeler:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 打开图形模型器有两种常见方式：
- en: From the menu, go to **Processing** | **Graphical Modeler...**.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从菜单中，转到**Processing** | **图形模型器...**。
- en: Use the Processing Toolbox. Ensure that the Processing Toolbox uses the **Advanced**
    mode. Go to the **Models** group and expand it. In the **Tools** subgroup, find
    the **Create new model** item and double-click on it.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Processing工具箱。确保Processing工具箱使用**高级**模式。转到**模型**组并展开它。在**工具**子组中，找到**创建新模型**项并双击它。
- en: 'Any of these methods will open the **Processing modeler** window, as shown
    in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下任何一种方法都可以打开**Processing模型器**窗口，如图下所示：
- en: '![Graphical Modeler](img/image00501.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图形模型器](img/image00501.jpeg)'
- en: 'The **Processing modeler** window can be divided into the following main areas:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**Processing模型器**窗口可以分为以下主要区域：'
- en: '**Toolbar**: This provides some useful actions, such as opening existing models,
    saving and exporting a model, the help editor, and so on.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具栏**：它提供了一些有用的操作，例如打开现有模型、保存和导出模型、帮助编辑器等。'
- en: '**Inputs and algorithm trees**: These are located on the left side of the window
    and consist of two tabs: one contains the available inputs, and the second contains
    the available algorithms. It is worth mentioning that the **Algorithm** tab supports
    the same modes for displays of algorithms as the toolbox: simplified and advanced.
    However, note that there are no switches in this tab for changing the display
    mode. If you need to change it, you should do it in the toolbox before opening
    the modeler.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入和算法树**：这些位于窗口的左侧，包含两个标签页：一个包含可用的输入，另一个包含可用的算法。值得注意的是，**算法**标签页支持与工具箱相同的算法显示模式：简化和高级。然而，请注意，此标签页中没有切换按钮来更改显示模式。如果您需要更改它，您应该在打开模型器之前在工具箱中完成。'
- en: '**Working area**: This is used to display the model structure. Here, we will
    place our building blocks and connect them to each other.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作区**：用于显示模型结构。在这里，我们将放置我们的构建块并将它们相互连接。'
- en: 'The creation of the model can be divided into two steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的创建可以分为两个步骤：
- en: 'Defining the input: This means that we need to specify which data is necessary
    for analysis. All items of input that we define here will be represented later
    as algorithm parameters, and the user will be able to set them according to their
    requirements.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义输入：这意味着我们需要指定哪些数据对于分析是必要的。我们在这里定义的所有输入项都将作为算法参数在以后表示，用户将能够根据他们的需求设置它们。
- en: 'Defining the workflow: At this step, we establish links between input items
    and algorithms. In other words, we determine how each algorithm in the model will
    use input and output from other algorithms.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义工作流程：在此步骤中，我们建立输入项和算法之间的链接。换句话说，我们确定模型中的每个算法将如何使用其他算法的输入和输出。
- en: Let's create a model to generate density maps from a point vector layer using
    the binning technique, which was described in the *Mapping density with a hexagonal
    grid* section of [Chapter 5](part0043.xhtml#aid-190861 "Chapter 5. Answering Questions
    with Density Analysis"), *Answering Questions with Density Analysis*. To make
    this example more useful, we will create a model that generates not only a hexagonal
    density grid, but also a square density grid. This is done so that you can later
    compare the results and choose the one that you like more.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个模型，使用分箱技术从点矢量层生成密度图，这在[第5章](part0043.xhtml#aid-190861 "第5章。使用密度分析回答问题")的*使用六边形网格映射密度*部分中已有描述，*使用密度分析回答问题*。为了使这个例子更有用，我们将创建一个模型，不仅生成六边形密度网格，还生成方形密度网格。这样做是为了让您以后可以比较结果并选择您更喜欢的一个。
- en: Adding inputs
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加输入
- en: The first step of model creation is defining the input necessary for it. To
    do this, we should go over all the algorithms of the process that we want to automate
    and find out which input items are necessary. It is necessary to remember that
    some algorithms may not need separate inputs. They will use only results obtained
    in some previous steps, or in other words, the output of other algorithms. Also,
    some inputs may not be important and can be hardcoded in the model.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模型创建的第一步是定义模型所需的输入。为此，我们应该遍历我们想要自动化的所有算法，并找出哪些输入项是必要的。必须记住，某些算法可能不需要单独的输入。它们将仅使用在先前步骤中获得的结果，或者换句话说，其他算法的输出。此外，某些输入可能并不重要，可以在模型中硬编码。
- en: 'The **Processing modeler** supports the following kinds of input, which can
    be found in the **Inputs** tab on the left side of the modeler window:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理模型器**支持以下类型的输入，这些输入可以在模型器窗口左侧的**输入**选项卡中找到：'
- en: 'Number: This is used for integer and floating-point values. When adding it,
    it is necessary to specify the minimum and maximum values allowed as well as a
    default value.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：这用于整数和浮点值。添加时，必须指定允许的最小值和最大值以及默认值。
- en: 'String: This is a string literal. There is only one additional setting, namely
    the default value.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：这是一个字符串字面量。只有一个额外的设置，即默认值。
- en: 'Boolean: This is a boolean value, usually used as a checkbox. It is necessary
    to specify the default state: checked or unchecked.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：这是一个布尔值，通常用作复选框。必须指定默认状态：选中或未选中。
- en: 'Extent: This represents a geographical extent.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围：这表示地理范围。
- en: 'Vector layer: This is used for vector layers. If necessary, it is possible
    to limit the supported geometry types to one of the available types and make this
    input optional.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矢量层：这用于矢量层。如果需要，可以将支持的几何类型限制为可用类型之一，并使此输入可选。
- en: 'Raster layer: This represents the raster layer in GDAL-supported format. It
    can be optional.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栅格层：这表示GDAL支持的格式中的栅格层。它是可选的。
- en: 'Table: This is used for geometryless tables, for example, DBF files. It can
    be optional.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格：这用于无几何表格，例如DBF文件。它是可选的。
- en: 'Table field: This represents a field of the layer attribute table or geometryless
    table. It is necessary to specify the parent layer from which this field will
    be fetched.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表字段：这表示层属性表或无几何表的字段。必须指定从该字段中获取字段的父层。
- en: 'File: This is used to represent files and directories.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件：这用于表示文件和目录。
- en: To add an input, double-click on its name. A **Parameter definition** dialog
    will open. Its content depends on the input type, but common for all input types
    is a **Parameter name** field, where it is necessary to specify at least the name
    of the input. This text will be used as a caption for the corresponding field
    when the model will be executed. All other fields are different for different
    input.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加输入，双击其名称。将打开一个**参数定义**对话框。其内容取决于输入类型，但所有输入类型都共有**参数名称**字段，其中必须指定至少输入的名称。当模型执行时，此文本将用作相应字段的标题。所有其他字段对于不同的输入都是不同的。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also use the drag-and-drop method from the inputs/algorithms tree to
    the modeler work area when adding inputs or algorithms.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 添加输入或算法时，您也可以从输入/算法树拖放至模型器工作区。
- en: Once all the settings are specified, click on the **OK** button. A new input
    block will be added to the modeler's working area.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦指定了所有设置，点击**确定**按钮。将在模型器工作区中添加一个新的输入块。
- en: 'Let''s start with adding input for our model. The first input is obvious; it
    is a vector layer to create a density map for. Double-click on the **Vector layer**
    item in the **Inputs** tab of the **Processing modeler** window to open the **Parameter
    definition** dialog, which looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为我们的模型添加输入开始。第一个输入很明显；它是一个矢量层，用于创建密度图。双击**处理模型器**窗口中的**输入**选项卡中的**矢量层**项以打开**参数定义**对话框，其外观如下：
- en: '![Adding inputs](img/image00502.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![添加输入](img/image00502.jpeg)'
- en: Enter a name in **Parameter name**, for example, `Point layer`. As we don't
    want to see all available layers as input later, and search for a required layer
    through a long list, we can limit the supported geometry type by choosing the
    **Point** geometry type in the **Shape type** combobox. Finally, as this input
    is required, we leave the **Required** field as **Yes**. Click on the **OK** button
    to add the input to the modeler working area.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在**参数名称**中输入一个名称，例如，`点层`。因为我们不希望在以后看到所有可用的层作为输入，并且通过一个长长的列表搜索所需的层，我们可以通过在**形状类型**组合框中选择**点**几何类型来限制支持的几何类型。最后，因为这个输入是必需的，所以我们把**必需**字段保留为**是**。点击**确定**按钮将输入添加到模型器工作区。
- en: To be able to make our final density map more detailed or more general, depending
    on our requirements, we need a way to adjust the cell size. So, double-click on
    the **Number** item in the **Inputs** tab to add another input.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够根据我们的需求使我们的最终密度图更详细或更一般，我们需要一种调整单元格大小的方法。因此，双击**输入**选项卡中的**数字**项以添加另一个输入。
- en: '![Adding inputs](img/image00503.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![添加输入](img/image00503.jpeg)'
- en: Enter `Vertical grid spacing` as **Parameter name** as shown in the preceding
    screenshot. We can leave all other fields untouched, but it is better to specify
    them too. This should be done to prevent wrong input from users. We should now
    keep in mind the fact that different layers may have different coordinate reference
    systems (CRS). As a result, we will probably have different distance units. So,
    our numeric input should allow the user to enter values suitable for layers in
    geographic CRS (degrees) and projected CRS (meters, feet, and so on). That's why
    we use `0` as the minimum value and `99999999.999999` as the maximum value. These
    values allow us to change the cell size over a wide range, irrespective of the
    CRS used. Enter any reasonable value as **Default value** and click on **OK**
    when you're done.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将“垂直网格间距”作为**参数名称**，如前一张截图所示。我们可以保留所有其他字段不变，但最好还是指定它们。这样做是为了防止用户输入错误。我们应该现在记住这样一个事实：不同的层可能具有不同的坐标参考系统（CRS）。因此，我们可能会有不同的距离单位。所以，我们的数值输入应该允许用户输入适合地理CRS（度）和投影CRS（米、英尺等）的值。这就是为什么我们使用`0`作为最小值，`99999999.999999`作为最大值。这些值允许我们在广泛的范围内更改单元格大小，而不考虑使用的CRS。输入任何合理的值作为**默认值**，完成后点击**确定**。
- en: As cell sizes in the horizontal and vertical directions can be different, we
    need to create another numeric parameter called `Horizontal grid spacing` using
    the same settings as you saw before.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于水平和垂直方向上的单元格大小可能不同，我们需要使用之前看到的相同设置创建另一个名为“水平网格间距”的数值参数。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you always need the same spacing in both the horizontal and vertical directions,
    it is better to use only one input parameter, as a single parameter can be used
    multiple times as an input in the same algorithm, or even in different algorithms.
    Later, we can adjust our model to use only one numeric parameter to define the
    grid spacing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在水平和垂直方向上始终需要相同的间距，最好只使用一个输入参数，因为单个参数可以在同一算法中多次用作输入，甚至在不同算法中使用。稍后，我们可以调整我们的模型，使其只使用一个数值参数来定义网格间距。
- en: As you may remember from the *Mapping density with a hexagonal grid* section
    of [Chapter 5](part0043.xhtml#aid-190861 "Chapter 5. Answering Questions with
    Density Analysis"), *Answering Questions with Density Analysis*, when using a
    `Create grid` algorithm, it is necessary to specify the desired grid extent, and
    we take this extent from our input layer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从[第5章](part0043.xhtml#aid-190861 "第5章. 使用密度分析回答问题")的“使用六边形网格映射密度”部分中可能记得，在[使用密度分析回答问题](https://wiki.example.org/answering_questions_with_density_analysis)时，使用“创建网格”算法时，需要指定所需的网格范围，并且我们从输入层获取这个范围。
- en: 'Now, for designing our model, we have two options:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了设计我们的模型，我们有两种选择：
- en: Define the input for the grid extent. This will make our model a bit more complex,
    as we need to specify the grid extent each time we use the model, instead of specifying
    just the layer. But this option also brings more flexibility, because by having
    a separate input for the grid extent, we will be able to generate density maps
    not only for the entire layer but also for a specified region inside it.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义网格范围的输入。这将使我们的模型变得更加复杂，因为每次我们使用模型时，我们需要指定网格范围，而不是只指定层。但这个选项也带来了更多的灵活性，因为通过为网格范围设置单独的输入，我们将能够生成不仅适用于整个层，而且适用于其中指定区域的密度图。
- en: Take the extent from the input layer. In this case, our model will be simpler
    for users, as all they need to do is to define the layer and grid cell size. But
    on the other hand, the density map will be generated for the entire layer.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入层获取范围。在这种情况下，我们的模型对用户来说将更加简单，因为他们只需要定义层和网格单元大小。但另一方面，密度图将生成整个层。
- en: As the most common use case is a density map for the entire layer, we choose
    the second option. The grid extent should be calculated automatically from the
    input point layer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最常见的用例是整个层的密度图，我们选择了第二个选项。网格范围应自动从输入点层计算得出。
- en: 'So, we have just defined almost all of the necessary input for our model: the
    input layer, and two numbers that represent the grid cell size in the horizontal
    and vertical directions. There is only one undefined input—the grid extent. You
    will learn how to extract it from the input layer in the next section, as this
    is closely related to workflow definition.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们几乎已经定义了我们模型所需的所有必要输入：输入层，以及代表水平和垂直方向网格单元大小的两个数字。只有一个输入尚未定义——网格范围。你将在下一节中学习如何从输入层中提取它，因为这与工作流程定义密切相关。
- en: Implementing the workflow
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现工作流程
- en: When all the input items are in place, we can start implementing a workflow.
    All the available algorithms can be found in the **Algorithms** tab on the left
    side of the modeler window.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有输入项都已就绪时，我们可以开始实现工作流程。所有可用的算法都可以在模型器窗口左侧的**算法**选项卡中找到。
- en: 'Workflow implementation is very similar to manual execution of all steps of
    analysis: we add algorithms one by one, choosing the correct input and, if necessary,
    defining the output. While the modeler allows us to add parameters and algorithms
    in any random order, it is better to add algorithms in the same order in which
    they should be executed to avoid confusion. Let''s start!'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程实现与手动执行所有分析步骤非常相似：我们逐个添加算法，选择正确的输入，并在必要时定义输出。虽然模型器允许我们以任何随机顺序添加参数和算法，但最好按照它们应该执行的顺序添加算法，以避免混淆。让我们开始吧！
- en: 'As you may remember, we did not add a separate input for grid extent, and you
    may be curious to know how we will extract it from the point layer in a format
    compatible with the modeler input. The answer is simple: we will use special tools,
    which are so-called modeler-only tools. What are these? Well, all the algorithms
    that are available exclusively in the **Processing modeler** are not available
    in the toolbox. Basically, these are helper tools that can be really useful in
    different models, for example, a simple calculator or a value converter. You can
    find these tools in the **Algorithms** tab (as they are also algorithms) within
    the Modeler-only tools group.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记得，我们没有为网格范围添加单独的输入，您可能想知道我们将如何从点层中提取它，以与模型器输入兼容的格式。答案是简单的：我们将使用特殊的工具，这些工具被称为仅模型器工具。这些是什么？嗯，所有仅在**处理模型器**中可用的算法在工具箱中不可用。基本上，这些是可以在不同模型中真正有用的辅助工具，例如简单的计算器或值转换器。您可以在**算法**选项卡（因为它们也是算法）中的仅模型器工具组中找到这些工具。
- en: Right now, we need a **Vector layer bounds** tool, which takes a vector layer
    as the input and returns its extent as the output.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们需要一个**矢量层范围**工具，它以矢量层作为输入，并返回其范围作为输出。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Besides the extent, this tool also returns four numeric values: minimum and
    maximum *x* coordinates, as well as minimum and maximum *y* coordinates. You may
    use these values as input for different algorithms.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了范围之外，此工具还返回四个数值：最小和最大*x*坐标，以及最小和最大*y*坐标。您可以使用这些值作为不同算法的输入。
- en: 'This output value can then be used as the input in any algorithm that requires
    the extent as the input. Find the **Vector layer bounds** algorithm by typing
    its name in the filter field, and double-click on it to open the algorithm definition
    dialog as shown:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出值然后可以用于任何需要范围作为输入的算法。在过滤器字段中输入其名称以找到**矢量层边界**算法，然后双击它以打开如图所示的算法定义对话框。
- en: '![Implementing the workflow](img/image00504.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![实施工作流程](img/image00504.jpeg)'
- en: The dialog is very simple. We will discuss definition dialogs a bit later. Right
    now, we just select our previously added **Point layer** input in the **Layer**
    combobox and click on the **OK** button to close the dialog and add the algorithm
    to the modeler working area. Now that all preparation steps are done, we are ready
    to implement the main workflow.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框非常简单。我们将在稍后讨论定义对话框。现在，我们只需在**层**组合框中选择之前添加的**点层**输入，然后点击**确定**按钮关闭对话框并将算法添加到模型器工作区。现在所有准备工作都已完成，我们准备实施主要工作流程。
- en: The first step in our analysis is grid generation, so switch to the **Algorithms**
    tab, find the `Create grid` algorithm by typing its name in the filter field,
    and double-click on it to open the algorithm definition dialog.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析的第一步是网格生成，因此切换到**算法**选项卡，在过滤器字段中输入其名称以找到`创建网格`算法，然后双击它以打开算法定义对话框。
- en: '![Implementing the workflow](img/image00505.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![实施工作流程](img/image00505.jpeg)'
- en: 'As you can see, the algorithm definition dialog has almost the same content
    as the algorithm dialog opened from the toolbox. The main differences are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，算法定义对话框的内容几乎与从工具箱中打开的算法对话框相同。主要区别如下：
- en: There is no **Log** tab where the algorithm reports its execution progress and
    other information. As the algorithm is not executed right now, this tab is not
    needed.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有用于报告算法执行进度和其他信息的**日志**选项卡。由于算法目前没有执行，因此此选项卡不需要。
- en: There is a new **Description** field. It is used to define the algorithm name
    inside the model. By default, this name is the same as the original algorithm
    name. This feature is very handy when the model contains several algorithm blocks
    that represent the same algorithm but use different inputs. In such a case, just
    assign different descriptions to this algorithm, and you will never be lost amid
    them. You will be able to identify their outputs easily.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个新的**描述**字段。它用于在模型中定义算法名称。默认情况下，此名称与原始算法名称相同。当模型包含几个代表相同算法但使用不同输入的算法块时，此功能非常有用。在这种情况下，只需为此算法分配不同的描述，你就不会在其中迷失方向。你将能够轻松识别它们的输出。
- en: There is a new **Parent algorithms** parameter at the bottom of the definition
    dialog, which does not exist when the algorithm is executed from the Processing
    toolbox. As the name implies, this parameter allows us to define parent algorithms
    for the selected algorithm, or in other words, set the algorithms' execution order.
    Parent algorithms will be executed in the specified order and before their children.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义对话框的底部有一个新的**父算法**参数，当算法从处理工具箱中执行时，该参数不存在。正如其名称所暗示的，此参数允许我们为所选算法定义父算法，换句话说，设置算法的执行顺序。父算法将按指定顺序执行，并在其子算法之前执行。
- en: 'By default, when the current algorithm uses the output of another algorithm
    as its input, the latter automatically becomes a parent of the current algorithm,
    and a link between these two algorithms is created. But sometimes, one algorithm
    can depend on another even if it has not used any output from it. Here is a well-known
    example of such a situation: before executing a query against a database layer,
    it is necessary to create the database and the layer.'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，当当前算法使用另一个算法的输出作为其输入时，后者自动成为当前算法的父算法，并在这两个算法之间创建一个链接。但有时，一个算法即使没有使用其任何输出，也可能依赖于另一个算法。以下是一个这样的情况的典型例子：在针对数据库层执行查询之前，必须创建数据库和层。
- en: There is a different approach for selecting inputs and outputs. All values can
    be selected from the list of already available model inputs and outputs, generated
    by algorithms that are already added to the model algorithms. Also, values such
    as numbers, strings, booleans, and table fields can be entered manually in the
    corresponding fields. Note that you cannot change values that are entered manually
    at design time if your model is executed from the toolbox or used as part of another
    model. So, don't hardcode values unless there is an urgent need.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择输入和输出的方法有所不同。所有值都可以从已添加到模型算法的算法生成的已可用模型输入和输出列表中选择。也可以在相应的字段中手动输入诸如数字、字符串、布尔值和表字段之类的值。请注意，如果你的模型是从工具箱中执行或作为另一个模型的一部分使用，则无法在设计时更改手动输入的值。因此，除非有紧急需要，否则不要硬编码值。
- en: Now, proceed with the `Create grid` algorithm definition for our model. As we
    will generate two grids—hexagonal and square—using the same algorithm, we need
    to distinguish the algorithm blocks. So, change the **Description** field to `Create
    hexagon grid`. We hardcode the **Grid type** parameter by selecting `Hexagon (polygon)`
    from the combobox, as this is what we need.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续为我们的模型定义`创建网格`算法。由于我们将使用相同的算法生成两个网格——六边形和正方形——我们需要区分算法块。因此，将**描述**字段改为`创建六边形网格`。我们通过从组合框中选择`六边形（多边形）`来硬编码**网格类型**参数，这是我们需要的。
- en: In the **Grid extent** combobox, select `'Extent' from algorithm 'Vector layer
    bounds'`. This is the extent of our input layer, so the generated hexagonal grid
    will cover it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在**网格范围**组合框中，选择`从算法'矢量图层边界'获取'范围'`。这是我们的输入图层范围，因此生成的六边形网格将覆盖它。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the `'Extent' from algorithm 'vector layer bounds'` text, `'Extent'` is the
    name of the output from the algorithm, and `'Vector layer bounds'` is an algorithm
    description from the **Description** field of the corresponding definition dialog.
    So, you can easily detect which output is from which algorithm.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`从算法'矢量图层边界'获取'范围'`文本中，`'范围'`是算法的输出名称，`'矢量图层边界'`是从相应定义对话框的**描述**字段中获取的算法描述。因此，你可以轻松地检测出哪个输出来自哪个算法。
- en: For horizontal and vertical grid spacing, select the previously defined input
    values from the corresponding comboboxes. You may notice that apart from the input
    values defined by us, there are some additional values produced by the **Vector
    layer bounds** algorithm. Ignore them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于水平和垂直网格间距，从相应的组合框中选择之前定义的输入值。你可能注意到，除了我们定义的输入值之外，还有一些由**矢量图层边界**算法产生的附加值。忽略它们。
- en: Don't enter any text in the **Output** field, as the hexagonal grid generated
    by this algorithm is an intermediate, temporary output and not the final result.
    Temporary outputs will be generated and stored in the temporary directory, but
    will never be added to the QGIS main canvas after model execution. If you want
    to see these intermediate results, it is necessary to turn them into model output
    by entering descriptions for them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在**输出**字段中输入任何文本，因为这个算法生成的六边形网格是一个中间的、临时的输出，而不是最终结果。临时输出将被生成并存储在临时目录中，但在模型执行后永远不会添加到QGIS主画布上。如果你想要查看这些中间结果，有必要通过为它们输入描述来将它们转换为模型输出。
- en: When all parameters have their values assigned, click on the **OK** button to
    add the algorithm to the modeler's working area. You will see that the algorithm
    block is now connected to its inputs. Clicking on the small **+** sign near the
    **In** or **Out** labels will expand a list of inputs and/or outputs, so you can
    verify the correctness of the connections. The second click will collapse them
    back.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有参数都已分配值后，点击**确定**按钮将算法添加到模型器的工作区域。你会看到算法块现在已连接到其输入。点击**In**或**Out**标签附近的小**+**号将展开输入和/或输出的列表，以便你可以验证连接的正确性。第二次点击将它们折叠回原状。
- en: 'Add another **Create grid** algorithm. Change its **Description** field to
    `Create square grid`, select `Rectangle (polygon)` as **Grid type**, and set all
    other parameters as we did earlier with hexagon grid generation. Click on the
    **OK** button when you are done. Now, we have two algorithm blocks in the modeler''s
    working area that use the same input as shown in the following figure:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 添加另一个**创建网格**算法。将它的**描述**字段改为`创建正方形网格`，选择`矩形（多边形）`作为**网格类型**，并将所有其他参数设置为与我们之前创建六边形网格时相同。完成后，点击**确定**按钮。现在，模型器的工作区域中有两个算法块，它们使用相同的输入，如图所示：
- en: '![Implementing the workflow](img/image00506.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![实现工作流程](img/image00506.jpeg)'
- en: 'The next algorithm we should add is **Count points in polygon**. Find it in
    the **Algorithms** tab of the modeler window by typing its name in the filter
    field, and double-click on it to open the algorithm definition dialog:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来应该添加的算法是**在多边形中计数点**。在模型器窗口的**算法**选项卡中通过在过滤器字段中输入其名称来找到它，并双击它以打开算法定义对话框：
- en: '![Implementing the workflow](img/image00507.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![实现工作流程](img/image00507.jpeg)'
- en: 'Here, we also edit the **Description** field to be able to distinguish the
    results of processing different grids, for example, `Count points in hexagon grid`.
    If you look at the available choices in the **Polygons** and **Points** comboboxes,
    you will see that both have an identical set of options: `Point layer`, `''Output''
    from algorithm ''Create hexagon grid''`, and `''Output'' from algorithm ''Create
    square grid''`. The first is our previously defined input, and the second and
    third are the results produced by already added **Create grid** algorithms. As
    you can see, we can easily identify the results produced by algorithms, thanks
    to their different descriptions.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们也编辑**描述**字段，以便能够区分不同网格的处理结果，例如，`Count points in hexagon grid`。如果你查看**多边形**和**点**组合框中可用的选项，你会看到它们都有一个相同的选项集：`点层`，`'Output'
    from algorithm 'Create hexagon grid'`，和`'Output' from algorithm 'Create square
    grid'`。第一个是我们之前定义的输入，第二个和第三个是由已添加的**创建网格**算法产生的结果。正如你所看到的，我们可以很容易地识别算法产生的结果，这要归功于它们不同的描述。
- en: Careful readers may ask, "Why do we see both the items in comboboxes? After
    all, they have different geometry types and we should see only those input items
    that have matching geometry types." Well, this is a current limitation of Processing—the
    modeler does not perform any accurate checks of the input. It always shows all
    of the available inputs with the corresponding type (vector, raster, or geometryless
    table) despite defined restrictions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细的读者可能会问，“为什么我们在组合框中看到这两个项目？毕竟，它们有不同的几何类型，我们应该只看到具有匹配几何类型的输入项目。” 好吧，这是处理过程中的一个当前限制——模型器不执行任何准确的输入检查。它总是显示所有可用的输入及其对应类型（矢量、栅格或无几何表），尽管有定义的限制。
- en: So, in the **Polygons** combobox, we need to select the hexagonal grid produced
    by the **Create grid** algorithm (`'Output' from algorithm 'Create hexagon grid'`),
    and in the **Points** combobox, select the previously defined `Point layer` input.
    Leave the **Count field name** field unchanged. This parameter will be used only
    in the next step and can be safely kept hardcoded.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在**多边形**组合框中，我们需要选择由**创建网格**算法生成的六边形网格（`'Output' from algorithm 'Create hexagon
    grid'`），并在**点**组合框中选择之前定义的`点层`输入。保持**计数字段名称**字段不变。此参数将在下一步中使用，并且可以安全地保持硬编码。
- en: We again leave the **Result** field empty, as the density map produced at this
    stage is a temporary, intermediate result. It may contain empty cells, which should
    be deleted. Finally, press the **OK** button to complete the algorithm definition
    and add it to the modeler working area.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次保持**结果**字段为空，因为在此阶段产生的密度图是一个临时、中间结果。它可能包含空单元格，应该被删除。最后，按下**确定**按钮以完成算法定义并将其添加到模型器工作区。
- en: Add another **Count points in polygon** algorithm to create a square density
    map. Set its description to `Count points in square grid`, and as the **Polygon**
    input, select the output from `'Output' from algorithm 'Create square grid'`.
    All other parameters should be the same as in the previous algorithm. Also, keep
    the **Result** field empty.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 添加另一个**在多边形中计数点**算法以创建一个正方形密度图。将其描述设置为`Count points in square grid`，并将**多边形**输入选择为`'Output'
    from algorithm 'Create square grid'`的输出。所有其他参数应与上一个算法相同。同时，保持**结果**字段为空。
- en: Now, we can add the last algorithm to complete our simple model—**Extract by
    attribute**. With this algorithm, we will clean up our density maps from cells
    that do not contain any useful information. In other words, we will remove empty
    cells.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加最后一个算法来完成我们的简单模型——**按属性提取**。使用此算法，我们将从不含任何有用信息的单元格中清理我们的密度图。换句话说，我们将删除空单元格。
- en: 'Find the **Extract by attribute** algorithm in the **Algorithms** tab of the
    modeler window by typing its name in the filter field, and double-click on it
    to open the algorithm definition dialog:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型器窗口的**算法**选项卡中通过在过滤器字段中输入其名称来找到**按属性提取**算法，并双击它以打开算法定义对话框：
- en: '![Implementing the workflow](img/image00508.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![实现工作流程](img/image00508.jpeg)'
- en: As before, we edit the **Description** field to distinguish the same algorithm
    blocks and their output. For the description, we choose `Extract from hexagon
    grid`. In the **Input layer** combobox, we should select the output of the **Count
    points in polygon** algorithm—`'Result' from algorithm 'Count points in hexagon
    grid'`. As we have hardcoded the field name in the previous step, we enter the
    same name in the **Selection attribute** field. Select `!=` (not equal to) from
    the **Operator** combobox and enter `0` in the **Value** field.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们编辑**描述**字段以区分相同的算法块及其输出。对于描述，我们选择`从六边形网格提取`。在**输入层**组合框中，我们应该选择**计数多边形中的点**算法的输出——`'Result'
    from algorithm 'Count points in hexagon grid'`。由于我们在上一步硬编码了字段名称，我们在**选择属性**字段中输入相同的名称。从**运算符**组合框中选择`!=`（不等于），并在**值**字段中输入`0`。
- en: As this algorithm will produce a result that we want to use later, it is necessary
    to enter a result description in the **Output** field, for example, `Hexagon density
    map`. Click on the **OK** button to complete the algorithm definition and add
    it to the modeler working area. In addition to the algorithm block, this time,
    an output block will be added too.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此算法将生成我们希望以后使用的输出，因此有必要在**输出**字段中输入结果描述，例如，`六边形密度图`。点击**确定**按钮以完成算法定义并将其添加到模型器工作区。除了算法块外，这次还将添加一个输出块。
- en: Finally, add another **Extract by attribute** algorithm to produce the final
    square density map. Don't forget to adjust the algorithm description, set the
    correct inputs, and specify the output name.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加另一个**按属性提取**算法以生成最终的方形密度图。别忘了调整算法描述，设置正确的输入，并指定输出名称。
- en: 'Currently, the model elements are placed in a slightly random order, and it
    is difficult to recognize the links between them. To improve readability and organize
    the model in a more structured way, we can drag all the blocks within working
    area. The links between them will be preserved. If necessary, you can also zoom
    in and out with the mouse wheel. Here is what final model may look like:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，模型元素以略微随机的顺序放置，难以识别它们之间的链接。为了提高可读性并以更结构化的方式组织模型，我们可以拖动工作区内的所有块。它们之间的链接将被保留。如有必要，您也可以使用鼠标滚轮进行缩放。以下可能是最终模型的外观：
- en: '![Implementing the workflow](img/image00509.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![实现工作流程](img/image00509.jpeg)'
- en: That's all! We just create our first model, and if you have layers loaded in
    QGIS, you can try it out by clicking on the **Run model** button on the toolbar.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！我们刚刚创建了我们第一个模型，如果您在QGIS中加载了图层，您可以通过点击工具栏上的**运行模型**按钮来尝试它。
- en: '![Implementing the workflow](img/image00510.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![实现工作流程](img/image00510.jpeg)'
- en: As you see, the model execution dialog has the same look and feel as all other
    Processing algorithms. Input vector layers can be selected from already available
    layers and loaded from the disk. Numerical values can be selected with spinboxes,
    can be accompanied by a calculator, and can maintain the restrictions we set.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，模型执行对话框的外观和感觉与其他所有处理算法相同。可以从已提供的层中选择输入向量层，也可以从磁盘加载。数值可以通过旋转框选择，可以附带计算器，并保持我们设置的限制。
- en: But don't close the modeler right now! To fully use our model, run it from the
    toolbox as a batch process, and reuse it in other models, we need to save and
    document it first. That's what we are going to do in the next section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在不要关闭模型器！为了完全使用我们的模型，我们需要先从工具箱中以批处理方式运行它，并在其他模型中重用它，我们首先需要保存和记录它。这就是我们将在下一节中要做的。
- en: Filling model metadata and saving
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充模型元数据和保存
- en: After creating the model, is it necessary to save it on the disk so that Processing
    will be able to load it and register within toolbox.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模型后，是否需要在磁盘上保存它，以便处理能够加载它并在工具箱中注册。
- en: By default, models are saved in JSON format with the `.model` extension in the
    models subdirectory inside the processing directory in the your QGIS user folder.
    Under Windows, this is usually `C:\Users\login\.qgis2` (`login` here is the name
    of your Windows user) and under Linux, it is `~/.qgis2`. If necessary, you can
    always change the location of the folder using the **Processing settings** dialog.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，模型以JSON格式保存，扩展名为`.model`，位于QGIS用户文件夹中处理目录的子目录内。在Windows上，这通常是`C:\Users\login\.qgis2`（这里的`login`是您的Windows用户名），在Linux上则是`~/.qgis2`。如有必要，您始终可以使用**处理设置**对话框更改文件夹的位置。
- en: When Processing starts, it looks for files with the `.model` extension in this
    directory and loads them. Loaded models appear in the toolbox, in the **Models**
    group. Also, they are available in modeler like any other Processing algorithm.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理启动时，它会查找此目录中具有`.model`扩展名的文件并加载它们。加载的模型会出现在工具箱中的**模型**组中。此外，它们在模型器中与其他处理算法一样可用。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes, you may get errors if you are loading third-party models. This mainly
    occurs because some algorithms used in a particular model are not available. For
    example, a certain algorithm provider is deactivated from Processing settings,
    or the model requires additional scripts/models, which are not available in your
    Processing. In such cases, read the error message carefully and examine Processing's
    logs to learn which algorithms are missed. Activate or install them and try to
    load the problematic model again.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果你正在加载第三方模型，可能会遇到错误。这主要是因为某些模型中使用的算法不可用。例如，某个算法提供者在处理设置中被禁用，或者模型需要额外的脚本/模型，而这些在处理中不可用。在这种情况下，仔细阅读错误消息并检查处理的日志，以了解哪些算法缺失。激活或安装它们，然后再次尝试加载有问题的模型。
- en: Before saving the model, it is necessary to define its name and the group where
    it will be placed. This information should be entered in fields above the modeler's
    working area. We choose `Density` maps as the model name and `Binning` as the
    group name. Feel free to choose your own names if you don't like these.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存模型之前，有必要定义其名称和它将被放置的组。这些信息应输入在模型器工作区域上方的字段中。我们选择`密度`图作为模型名称，`分箱`作为组名称。如果你不喜欢这些名称，可以自由选择自己的名称。
- en: When the model name and group are defined, click on the **Save** button in the
    toolbar and enter the name of the model. You will see a confirmation message when
    the model is saved.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型名称和组被定义后，点击工具栏中的**保存**按钮并输入模型的名称。当模型保存时，你会看到一个确认消息。
- en: We can close the modeler window right now, but don't rush! It is good practice
    to document your models, that is, describe the input, the actions performed, and
    the final results. Such information will be extremely useful for other users,
    who may want to reuse the model in their own tasks. Also, this metadata will afterwards
    help you recall what is this model is for.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以关闭模型器窗口，但不要急！记录你的模型是一个好习惯，即描述输入、执行的操作和最终结果。此类信息将极其有用，其他用户可能希望在自己的任务中重用该模型。此外，此元数据将有助于你回忆该模型是用于什么目的。
- en: 'To start editing the model metadata, click on the **Edit model help** button
    in the modeler dialog toolbar. A **Help editor** dialog will open, like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编辑模型元数据，点击模型器对话框工具栏中的**编辑模型帮助**按钮。将打开一个**帮助编辑器**对话框，如下所示：
- en: '![Filling model metadata and saving](img/image00511.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![填充模型元数据和保存](img/image00511.jpeg)'
- en: This dialog is divided into three areas. At the top, there is a preview area.
    Here, the current help contents are displayed so that you can see how the final
    result will look in real-time mode. In the bottom-left part is the elements tree,
    where all help sections are listed, including algorithm description as well as
    parameters, input, and other information. In the bottom-right part, there is an
    editing area. Here, we will enter a description of the corresponding element.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此对话框分为三个区域。在顶部是预览区域。在这里，当前的帮助内容被显示出来，以便你可以实时看到最终结果的外观。在左下角是元素树，其中列出了所有帮助部分，包括算法描述以及参数、输入和其他信息。在右下角是编辑区域。在这里，我们将输入对应元素的描述。
- en: To edit the description of the element, select it in the elements list and enter
    text in the **Element description** field. To save the changes, just select another
    element in the elements tree.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑元素的描述，在元素列表中选择它，并在**元素描述**字段中输入文本。要保存更改，只需在元素树中选择另一个元素。
- en: 'Go through all the items in elements tree and enter their descriptions. For
    example, as **Algorithm description**, you can use the following text:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历元素树中的所有项目并输入它们的描述。例如，作为**算法描述**，你可以使用以下文本：
- en: '[PRE0]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Describe all the other fields yourself. Try to be short and, at the same time,
    give as much useful information as possible. Don't explain obvious things—it's
    better to concentrate on important details. For example, in the description of
    the grid spacing inputs, it is worth mentioning that grid spacing should be defined
    in the same distance units as those used by layer. When you're done, click on
    the **OK** button to close the **Help editor** dialog.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 描述所有其他字段。尽量简短，同时尽可能提供有用的信息。不要解释明显的事情——最好专注于重要细节。例如，在网格间距输入的描述中，值得提到的是，网格间距应定义为与层使用的相同距离单位。完成操作后，单击**确定**按钮关闭**帮助编辑器**对话框。
- en: The model metadata will be saved automatically in the same file as the model
    itself when you click on the **Save** button in the toolbar.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在工具栏中单击**保存**按钮时，模型元数据将自动保存在与模型本身相同的文件中。
- en: Editing models
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑模型
- en: 'You can also load any existing model in the modeler to edit it. You can do
    this, for example, to adjust some hardcoded parameters, to redefine the workflow,
    or just to learn how it works. There are two ways of loading an existing model:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在模型器中加载任何现有的模型进行编辑。您可以通过以下方式完成此操作，例如调整一些硬编码的参数，重新定义工作流程，或者只是了解其工作原理。加载现有模型有两种方式：
- en: Find the model in toolbox by typing its name in the search field. Right-click
    on the model to open the context menu and select **Edit model**.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在搜索字段中输入模型名称，在工具箱中找到模型。右键单击模型以打开上下文菜单，并选择**编辑模型**。
- en: Open the Processing modeler from the **Processing** menu, click on the **Open
    model** button from the toolbar and navigate to the model file.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**处理**菜单中打开处理模型器，从工具栏中单击**打开模型**按钮，并导航到模型文件。
- en: To edit any input or algorithm, click on the small pencil icon in the bottom-right
    corner of the corresponding block. Also, you can choose **Edit** from the context
    menu, opened by right-clicking. Any of these actions will open a definition dialog
    where you can perform the necessary changes, for example, update the values or
    restrictions or reconnect the elements. After you have clicked on the **OK** button,
    the dialog will be closed and links between model blocks will be updated, if necessary.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑任何输入或算法，请单击相应块右下角的小铅笔图标。您还可以通过右键单击打开的上下文菜单选择**编辑**。任何这些操作都会打开一个定义对话框，您可以在其中执行必要的更改，例如更新值或限制或重新连接元素。点击**确定**按钮后，对话框将关闭，如果需要，模型块之间的链接将更新。
- en: To delete unnecessary items (input or algorithm), click on the cross button
    in the top-right corner of the corresponding block, or select **Remove** from
    the item's context menu. Note that the algorithm or input can be removed only
    if there are no other elements depending on it. In other words, an input should
    not be used by any algorithm, and algorithm outputs should not be used as inputs
    in other algorithms. If you try to delete a block that has items depending on
    it, you will see a warning message and the operation will be canceled.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除不必要的项目（输入或算法），请单击相应块右上角的小叉按钮，或从项目上下文菜单中选择**删除**。请注意，只有当没有其他元素依赖于它时，才能删除算法或输入。换句话说，输入不应被任何算法使用，算法输出不应在其他算法中用作输入。如果您尝试删除依赖于其他元素的块，您将看到警告消息，并且操作将被取消。
- en: Now, let's edit our model. As in almost all use cases, grid cells should have
    equal dimensions in both horizontal and vertical directions. It is very good to
    leave only one numeric parameter in the model. This simplifies the model and makes
    the user's life simpler, as they will need to enter less data when executing the
    model.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编辑我们的模型。在几乎所有用例中，网格单元在水平和垂直方向上都应该具有相同的尺寸。只保留模型中的一个数值参数是非常好的。这简化了模型，并使用户的生活更加简单，因为他们执行模型时需要输入的数据更少。
- en: First, we need to edit one of the numeric inputs and change its name to match
    the input meaning. Click on the pencil icon in the bottom-right corner of the
    **Vertical grid spacing** block, change the **Parameter** name to `Grid spacing`,
    and click on the **OK** button to save your edits.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要编辑一个数值输入，并将其名称更改为与输入含义相匹配。单击**垂直网格间距**块右下角的小铅笔图标，将**参数**名称更改为`网格间距`，然后单击**确定**按钮以保存您的编辑。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Alternatively, you can edit the **Horizontal grid spacing** input. This replacement
    is completely safe.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以编辑**水平网格间距**输入。这种替换是完全安全的。
- en: 'Now, open the definition dialog of the **Create grid** algorithm and select
    the `Grid spacing` input in both fields: **Horizontal spacing** and **Vertical
    spacing**. When you''re done, click on the **OK** button to save your edits and
    close the dialog. You will see that the connections between blocks have now changed—one
    numeric input (its name depends on the input you edited previously) is not connected
    to any algorithm. To delete this input, click on the cross in the top-right corner.
    The updated model may look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开**创建网格**算法的定义对话框，并在两个字段中：**水平间距**和**垂直间距**中选择`Grid spacing`输入。完成后，点击**确定**按钮保存您的编辑并关闭对话框。你会看到块之间的连接现在已更改——一个数值输入（其名称取决于你之前编辑的输入）没有连接到任何算法。要删除此输入，点击右上角的交叉。更新后的模型可能看起来像这样：
- en: '![Editing models](img/image00512.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![编辑模型](img/image00512.jpeg)'
- en: If you want, you can save the updated model as a new model. To do this, just
    enter a different model name and, if necessary, a group name. Then, click on the
    **Save as...** button and enter a name for the new model file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想，可以将更新后的模型保存为一个新的模型。为此，只需输入一个不同的模型名称，如果需要，还可以输入一个组名称。然后，点击**另存为...**按钮，并为新的模型文件输入一个名称。
- en: It is also possible to deactivate some parts of the model—a particular algorithm
    or even an entire branch—without deleting the corresponding blocks. This feature
    is extremely useful when you don't want to get all of the output produced by the
    model or need to debug/test a small part of it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在不删除相应块的情况下停用模型的一些部分——一个特定的算法甚至整个分支。当你不希望得到模型产生的所有输出或需要调试/测试其一小部分时，这个功能非常有用。
- en: To deactivate an algorithm, right-click on it and select **Deactivate** in the
    context menu. The corresponding algorithm block will be grayed out, and all algorithm
    blocks that depend on it will be automatically deactivated too. Deactivated algorithms
    will be skipped during model execution and will not generate any output. This
    has an advantage—the model's execution time is reduced. Keep in mind that the
    status of the algorithms (active/deactivated) is being saved in the model file,
    and before saving a model, make sure that you don't miss anything.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要停用算法，右键单击它，并在上下文菜单中选择**停用**。相应的算法块将被灰色显示，并且所有依赖于它的算法块也将自动停用。停用的算法在模型执行期间将被跳过，不会生成任何输出。这有一个优点——模型的执行时间会减少。请记住，算法的状态（激活/停用）正在模型文件中保存，在保存模型之前，请确保你没有遗漏任何内容。
- en: To activate an algorithm, right-click on it and select **Activate** from the
    context menu. Note that this activation affects only the selected algorithm. All
    algorithms that depend on it will remain deactivated, and you'll have to activate
    them one by one.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活一个算法，右键单击它，并在上下文菜单中选择**激活**。请注意，这种激活只影响所选算法。所有依赖于它的算法都将保持未激活状态，你必须逐个激活它们。
- en: As an example, imagine that you don't need to generate square density maps.
    Of course, we can create a new model from an existing one by deleting unnecessary
    blocks and using the **Save as...** functionality. Creating a new model makes
    sense when you often need to generate only hexagonal density maps. But if there
    is a one-time requirement, it is better to simply deactivate the **Create square
    grid** block in our model, and all the dependent blocks will be deactivated too.
    So, you can execute the model, generate only hexagonal density maps, and then
    activate the disabled blocks again.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你不需要生成正方形密度图。当然，我们可以通过删除不必要的块并使用**另存为...**功能从现有模型创建一个新的模型。当你经常需要只生成六边形密度图时，创建新模型是有意义的。但如果是一次性需求，最好简单地停用模型中的**创建正方形网格**块，这样所有依赖的块也会被停用。因此，你可以执行模型，只生成六边形密度图，然后再次激活已停用的块。
- en: Sharing models
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享模型
- en: If you have created useful models that may help other users, it would be good
    to share them with the community so that others don't need to reinvent the wheel.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了可能帮助其他用户的实用模型，那么与社区分享它们会很好，这样其他人就不需要重新发明轮子了。
- en: As the saved Processing model is a single file in JSON format, the easiest way
    to share it with others is to send it to those who are interested in it, or upload
    the model file to any file sharing or hosting site and provide everyone with a
    link to this file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于保存的Processing模型是一个JSON格式的单个文件，因此与他人分享它的最简单方法是将其发送给感兴趣的人，或者将模型文件上传到任何文件共享或托管网站，并为每个人提供此文件的链接。
- en: A bit more complex—but at the same time, a very convenient and user-friendly—way
    is to publish your model in the Processing models and scripts community repository.
    This repository was created in the spring of 2014, and provides a centralized
    way to share Processing scripts and models among QGIS users.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种稍微复杂一些，但同时也非常方便和用户友好的方法：在处理模型和脚本社区存储库中发布您的模型。此存储库于 2014 年春季创建，为 QGIS 用户之间共享处理脚本和模型提供了一个集中的方式。
- en: To put your model into this repository, you need to fork the GitHub repository
    ([https://github.com/qgis/QGIS-Processing](https://github.com/qgis/QGIS-Processing)),
    commit your model in your fork, and issue a pull request.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的模型放入此存储库，您需要将 GitHub 存储库 ([https://github.com/qgis/QGIS-Processing](https://github.com/qgis/QGIS-Processing))
    分叉，在您的分叉中提交您的模型，并发出一个拉取请求。
- en: Tip
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To learn more about Git, use one of the Packt''s books, such as *Git: Version
    Control for Everyone*, and refer to the GitHub documentation at [https://help.github.com/](https://help.github.com/).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Git 的信息，可以使用 Packt 的书籍之一，例如 *Git：面向所有人的版本控制*，并参考 GitHub 文档，链接为 [https://help.github.com/](https://help.github.com/).
- en: Another option is to send the model to the qgis-developer mailing list, or directly
    to one of Processing's developers and ask them to put it into the repository.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将模型发送到 qgis-developer 邮件列表，或者直接发送给 Processing 的开发者之一，并请他们将其放入存储库。
- en: To get models from this repository, use the **Get models from on-line script
    collection** tool located in the **Tools** subgroup under the **Models** item
    in the Processing toolbox.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要从此存储库获取模型，请使用位于处理工具箱中 **模型** 项下的 **工具** 子组中的 **从在线脚本集合获取模型** 工具。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use the Graphical modeler from the QGIS
    Processing framework to create geoprocessing models from multiple algorithms.
    The Modeler allows us to automate analyses and increase productivity by combining
    complex analyses that require several steps into a single, easy-to-use algorithm
    that can be reused.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用 QGIS 处理框架中的图形模型器从多个算法创建地理处理模型。模型器允许我们将需要多个步骤的复杂分析组合成一个单一、易于使用的算法，从而实现自动化分析和提高生产力。
- en: We also covered additional important topics, including documenting models and
    sharing them with other users.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了其他一些重要主题，包括记录模型并与其他用户共享。
