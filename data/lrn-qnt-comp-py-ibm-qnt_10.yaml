- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Suppressing and Mitigating Quantum Noise
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抑制和减轻量子噪声
- en: In the previous edition of this book, you may recall a chapter which discussed,
    in a reasonable amount of detail, the different types of noise that affect various
    quantum systems. Since then, there has been an incredible amount of research that
    has evolved not only the hardware but the software as well. Due to the changes
    since then, which includes a few major refactorization iterations of Qiskit, for
    example, the deprecation of Ignis and its many test circuit libraries, I thought
    it might be a good time to shift into the latest and not spend too much time on
    how to test a system, but rather understand how to leverage the latest error suppression
    and mitigation techniques. Of course, I don’t want to leave you too far in the
    dark, so I will cover some of the fundamentals of what these noises are and how
    they affect your experiments. However, I do want to ensure we cover the current
    era of quantum utility ([https://www.nature.com/articles/s41586-023-06096-3](https://www.nature.com/articles/s41586-023-06096-3)),
    which entails using error suppression and mitigation techniques to help you find
    some useful quantum applications. We should expect to see some advancements as
    the systems evolve and get wider (more qubits) and deeper (complex quantum circuits
    with thousands of 2-qubit gates), which can be seen as a great step towards useful
    quantum applications without needing to wait for fault-tolerant quantum computers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前一版中，你可能还记得一个章节，该章节详细讨论了影响各种量子系统的不同类型的噪声。从那时起，有大量的研究不仅发展了硬件，也发展了软件。由于那时以来的变化，包括Qiskit的一些主要重构迭代，例如Ignis及其许多测试电路库的弃用，我认为现在是时候转向最新的内容，而不是花太多时间讨论如何测试系统，而是理解如何利用最新的错误抑制和减轻技术。当然，我不想让你太迷茫，所以我将涵盖一些关于这些噪声是什么以及它们如何影响你的实验的基本知识。然而，我确实想确保我们涵盖当前量子实用性的时代([https://www.nature.com/articles/s41586-023-06096-3](https://www.nature.com/articles/s41586-023-06096-3))，这包括使用错误抑制和减轻技术来帮助你找到一些有用的量子应用。我们应该期待随着系统的演变和扩展（更多的量子位）以及深化（具有数千个2量子位门的复杂量子电路），我们将看到一些进步，这可以被视为朝着无需等待容错量子计算机就能实现有用量子应用迈出的巨大一步。
- en: Early quantum systems were commonly referred to as near-term devices, which
    generally means they are close to becoming fully fault-tolerant quantum systems.
    One of the reasons for this is that all current quantum systems, no matter what
    technology they use to create qubits, are affected by **noise** in some shape
    or form, which increases the error rates of these systems. To address, and in
    turn minimize the error rates, it helps to understand what causes these errors
    and how can we suppress or mitigate them. Keep in mind that the study of errors
    in any one of the following examples could easily qualify as a research topic,
    which is why we will simply touch on some examples but if you are interested in
    more details, I will provide some reference materials at the end of the chapter.
    For now, this chapter is merely an overview with some examples to help you get
    an idea on how to create some of these noise models using the functionalities
    provided to you in Qiskit and how to suppress and mitigate against them using
    features included in the Qiskit Runtime. The goal here is to help you optimize
    the effectiveness of your quantum circuits, which in turn helps you design your
    applications to be as resistant as possible to the various forms of errors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的量子系统通常被称为近端设备，这通常意味着它们接近成为完全容错的量子系统。其中一个原因是，所有当前的量子系统，无论它们使用什么技术来创建量子位，都受到某种形式的**噪声**的影响，这增加了这些系统的错误率。为了解决这个问题，并相应地最小化错误率，了解这些错误的原因以及我们如何抑制或减轻它们是有帮助的。请记住，对以下任何一个示例中的错误的研究都很容易成为一个研究课题，这就是为什么我们只是简单触及一些示例，如果你对更多细节感兴趣，我将在本章末尾提供一些参考资料。目前，本章仅是一个概述，包含一些示例，帮助你了解如何使用Qiskit提供的功能来创建一些噪声模型，以及如何使用Qiskit
    Runtime中的功能来抑制和减轻它们。这里的目的是帮助你优化量子电路的有效性，从而帮助你设计尽可能抵抗各种形式错误的应用程序。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the Qiskit Runtime Service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Qiskit Runtime服务
- en: Understanding Sessions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解会话
- en: Understanding the Qiskit Runtime Options
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Qiskit Runtime选项
- en: Understanding Primitives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解原语
- en: Understanding the Sampler primitive
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Sampler原语
- en: Understand the noise effects of decoherence
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解退相干的噪声效应
- en: Differences between error suppression, mitigation, and correction
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误抑制、减轻和纠正之间的区别
- en: 'In this chapter, we will cover one of the challenges faced by most quantum
    systems: noise. By the end of the chapter, you will understand some of the varying
    noise effects, such as relaxation and dephasing. Then, you’ll get an overview
    of the latest advancements in the Qiskit Runtime Service and learn about the building
    blocks to run your circuits efficiently on any backend system. Finally, you will
    learn about the error suppression and error mitigation techniques and how to apply
    them to your complex quantum circuits.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍大多数量子系统面临的一个挑战：噪声。到本章结束时，你将了解一些不同的噪声效应，例如弛豫和去相位。然后，你将概述Qiskit运行时服务的最新进展，并了解在任意后端系统上高效运行电路的构建块。最后，你将了解错误抑制和错误减轻技术，以及如何将它们应用于你的复杂量子电路。
- en: In previous versions of Qiskit, there was a module titled, Ignis, which was
    the module that contained libraries to characterize and mitigate against noise.
    Since then, the Ignis library has been deprecated, so it is recommended that you
    read the Qiskit Migration Guide on the Qiskit GitHub page ([https://github.com/Qiskit/qiskit-ignis#migration-guide](https://github.com/Qiskit/qiskit-ignis#migration-guide)),
    particularly if you want to use many of the recent advancements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qiskit的早期版本中，有一个名为Ignis的模块，该模块包含用于表征和减轻噪声的库。从那时起，Ignis库已被弃用，因此建议你阅读Qiskit迁移指南，位于Qiskit
    GitHub页面([https://github.com/Qiskit/qiskit-ignis#migration-guide](https://github.com/Qiskit/qiskit-ignis#migration-guide))，特别是如果你想使用许多最新的进展。
- en: 'In quantum systems, noise originates from various sources: thermal heat from
    electronics, decoherence, dephasing, crosstalk, or signal loss. Here, we will
    see how to measure the effects of noise on a **qubit**, and how to mitigate readout
    error noise to optimize our results. In the end, we will compare the differences
    to better understand the effects and ways to mitigate them using other techniques
    such as **dynamical decoupling**, which is used to help reduce noise caused by
    decoherence of a qubit when its state is left idle for too long.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在量子系统中，噪声来源于各种来源：电子的热量、退相干、去相位、串扰或信号损失。在这里，我们将了解如何测量噪声对**量子比特**的影响，以及如何减轻读出误差噪声以优化我们的结果。最后，我们将比较差异，以更好地理解其影响以及使用其他技术（如**动态去耦**）来减轻它们的方法，动态去耦用于帮助减少量子比特状态闲置时间过长时由于退相干引起的噪声。
- en: 'Before we get started with all of that, we need to first get familiar with
    one of the newest features that will help bring all these techniques to our fingertips
    and allow us to adjust them all as needed: the Qiskit Runtime service.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始所有这些之前，我们首先需要熟悉将帮助我们将所有这些技术带到指尖并允许我们根据需要调整它们的最新的一个特性：Qiskit运行时服务。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will cover some refreshers on simulating noise, so if you
    have some knowledge of signal to noise theory, this will help. If not, review
    *Chapter 9*, *Simulating Quantum Systems and Noise Models*, to get an understanding
    of the various forms of noise that affect quantum systems. This will help you
    understand how to suppress and mitigate errors on a quantum computer using the
    Qiskit Runtime.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾一些关于模拟噪声的内容，所以如果你对信号与噪声理论有所了解，这将有所帮助。如果没有，请回顾*第9章*，*模拟量子系统和噪声模型*，以了解影响量子系统的各种噪声形式。这将帮助你了解如何使用Qiskit运行时在量子计算机上抑制和减轻错误。
- en: 'Here is the full source code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本书中使用的完整源代码：[https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition)。
- en: Understanding the Qiskit Runtime service
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Qiskit运行时服务
- en: For those of you who have used earlier versions of Qiskit, you may have been
    using the `execute()` or `backend.run()` functions to run quantum circuits on
    a quantum system. This was good to run some basic quantum circuits for learning
    purposes on small quantum systems with less than 100 qubits. However, if we want
    to start to think about the future and how we can create circuits for hundreds,
    thousands, and even millions of qubits, then we will need to think about how to
    optimally do so without just throwing a large circuit onto a single machine. This
    is where the **Qiskit Runtime Service** comes in very handy. Not only does it
    include many new options, such as selecting the optimization and resilience levels,
    which we will learn about later in this chapter, but it also includes all the
    transpilation features we covered earlier, so we won’t necessarily lose what we
    have learned so far. In this section, we will cover what the Qiskit Runtime is
    and how you can execute your circuits using it. Knowing how to use the Qiskit
    Runtime will also help you later in this chapter, when we learn about the various
    error suppression and mitigation techniques and how they are applied to your quantum
    circuit.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些使用过Qiskit早期版本的人来说，你们可能使用过`execute()`或`backend.run()`函数来在量子系统上运行量子电路。这对于在小于100个量子比特的小型量子系统上运行一些基本的量子电路用于学习目的来说是很好的。然而，如果我们想要开始考虑未来，以及我们如何为数百、数千甚至数百万个量子比特创建电路，那么我们需要考虑如何最优地做到这一点，而不仅仅是将一个大的电路扔到一台机器上。这就是**Qiskit
    Runtime服务**大有用武之地的地方。它不仅包括许多新选项，例如选择优化和弹性级别，我们将在本章后面学习这些内容，而且还包括我们之前覆盖的所有编译功能，所以我们不会失去我们迄今为止所学到的。在本节中，我们将介绍Qiskit
    Runtime是什么以及如何使用它来执行你的电路。了解如何使用Qiskit Runtime也将帮助你在此章后面学习各种错误抑制和缓解技术以及它们是如何应用于你的量子电路的。
- en: Let’s begin by learning more about the Qiskit Runtime Service, how is it different
    from the execute function, and what new features we can use to optimize executing
    our quantum circuits on a quantum system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来了解Qiskit Runtime服务，它与执行函数有何不同，以及我们可以使用哪些新功能来优化在量子系统上执行量子电路。
- en: First, let’s create a new notebook and import a few Qiskit Runtime objects,
    functions, and instantiate the `QiskitRuntimeService` class, using our helper
    file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的笔记本，并导入一些Qiskit Runtime对象、函数，并使用我们的辅助文件实例化`QiskitRuntimeService`类。
- en: Note, at the time of writing, there has been a switch from the current Sampler
    version to SamplerV2\. In the following code, it is assumed that the “V2” will
    be removed. If for some reason it is not, then please update `Sampler` to `SamplerV2`
    to ensure you are using the latest version of the Sampler.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在撰写本文时，已经从当前的Sampler版本切换到SamplerV2。在下面的代码中，假设“V2”将被移除。如果由于某些原因它没有被移除，那么请将`Sampler`更新为`SamplerV2`以确保你使用的是Sampler的最新版本。
- en: Another important step is that you must use the `token` parameter to set either
    your IBM Quantum or IBM Cloud API token, as illustrated in the following code
    snippet. If you do not set this, you will likely get an error, and when trying
    to access the Qiskit Runtime service, it will not work.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的步骤是，你必须使用`token`参数来设置你的IBM Quantum或IBM Cloud API令牌，如下面的代码片段所示。如果你不设置这个参数，你可能会遇到错误，并且当尝试访问Qiskit
    Runtime服务时，它将无法工作。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that you have your notebook setup, let’s dig into some of the execution
    mode descriptions..
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了你的笔记本，让我们深入探讨一些执行模式描述。
- en: Understanding Sessions
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解会话
- en: 'A **Session** is in essence a collection of Jobs that is guaranteed to run
    on the backend without any interruptions from other user Jobs, particularly those
    that require multiple iterations, such as those that are based on variational
    algorithms: **Variational Quantum Eigensolver** (**VQE**), and **Quantum Approximate
    Optimization Algorithm** (**QAOA**). In other words, “without interruptions” means
    that the Qiskit Runtime will ensure that each Job will complete, including the
    period where the variables are being adjusted between classical and quantum resources,
    where in the past this time was used to interleave Jobs from another user in the
    queue.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**会话**本质上是一组作业，保证在后台运行而不会受到其他用户作业的干扰，尤其是那些需要多次迭代的作业，例如基于变分算法的作业：**变分量子本征求解器**（**VQE**）和**量子近似优化算法**（**QAOA**）。换句话说，“无干扰”意味着Qiskit
    Runtime将确保每个作业都能完成，包括在经典资源和量子资源之间调整变量的期间，在过去，这段时间被用来在队列中交错处理来自另一个用户的作业。'
- en: To understand the practicality of this format, imagine standing in a long queue
    waiting your turn to submit a form, like renewing your driver’s license. After
    waiting a few hours, you’re finally at the window and handing over your form,
    only to be told that you need to adjust some values in the form. This is where
    the difference comes in. In the previous version, you would have to stand off
    to the side and update the form fields; meanwhile, someone else will move up to
    the window. Now, if you happen to be ready, you now must wait for that other person
    to finish before you can continue. This, of course, might take a long time, causing
    you to wait longer. What Sessions allows you to do is keep that window free and
    available for you until you finish updating the form and then turn it in.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这种格式的实用性，想象一下站在一个长长的队伍中等待轮到您提交表格，比如更新您的驾驶执照。等了几小时后，您终于到了窗口，递上您的表格，却被告知需要调整表格中的某些值。这就是差异所在。在之前的版本中，您必须站在一旁更新表格字段；同时，另一个人会走到窗口前。现在，如果您恰好准备好了，您现在必须等待那个人完成，然后才能继续。当然，这可能会花费很长时间，让您等待更久。会话允许您在完成更新表格并提交之前，保持窗口空闲并可供您使用。
- en: Regarding what the default and max times are for both the interactive and maximum
    time values, I would refer you to the Qiskit Runtime documentation [https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/runtime_service](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/runtime_service)
    ) as these values might change over time. However, time in the queue does count
    towards the maximum time of the Session. The idle time could be used to perform
    any classical operations based on the results of the Job and/or prepare for the
    subsequent Job in the Session.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关于交互式和最大时间值的默认值和最大时间，我建议您参考Qiskit运行时文档[https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/runtime_service](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/runtime_service)，因为这些值可能会随时间而变化。然而，队列中的时间会计算到会话的最大时间之内。空闲时间可以用来根据作业的结果执行任何经典操作，并为会话中的后续作业做准备。
- en: Each Job can be set as part of a batch of Jobs to ensure that they run on the
    same device or closely together to avoid the issues that can occur if they are
    run on separate systems or far apart, which would introduce strangeness to our
    results due to device characteristics or device drift. To learn more about device
    drift, see the *Further reading* section at the end of this chapter. At the time
    of writing, there are upcoming features that will further optimize execution of
    circuits, so do keep an eye on the documentation and information feeds for details
    and examples.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个作业都可以设置为作业批次的一部分，以确保它们在相同的设备上或紧密地一起运行，以避免它们在单独的系统或相隔很远时运行可能引起的问题，这可能会由于设备特性或设备漂移而使我们的结果出现异常。要了解更多关于设备漂移的信息，请参阅本章末尾的*进一步阅读*部分。在撰写本文时，有一些即将推出的功能将进一步优化电路的执行，因此请密切关注文档和信息源以获取详细信息示例。
- en: Before we start coding, let’s get familiar with the other classes first as this
    will simplify our coding experience moving forward. In the next section, we will
    look at the options that we can set to our `Session` class. The `Options` class
    will also be very important later when suppressing and mitigating errors.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，让我们先熟悉其他类，这样将简化我们后续的编码体验。在下一节中，我们将查看可以设置到`Session`类的选项。`Options`类在抑制和缓解错误时也非常重要。
- en: Understanding the Qiskit Runtime Options
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Qiskit运行时选项
- en: '`RuntimeOptions` is a class used to set the various parameters for the Qiskit
    Runtime execution options. Parameters are used to select which quantum system
    to use and which optimization or resilience levels to use that enable various
    error suppression or error mitigation features. Below is a list of `Options` parameters
    that are used for the various Qiskit Runtime primitives. Keep in mind that, as
    always, you should check the latest version of Qiskit API documentation to ensure
    your code is always current:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`RuntimeOptions`是一个用于设置Qiskit运行时执行选项的各种参数的类。参数用于选择使用哪个量子系统以及使用哪种优化或弹性级别，这可以启用各种错误抑制或错误缓解功能。以下是用于各种Qiskit运行时原语的一些`Options`参数列表。请记住，就像往常一样，您应该检查Qiskit
    API文档的最新版本，以确保您的代码始终保持最新：'
- en: 'Environment parameters such as `log_level` (`DEBUG`, `INFO`, etc.), and `callback`
    for any interim or final results, which will receive two positional parameters:
    Job ID and Job result'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境参数，如`log_level`（`DEBUG`、`INFO`等），以及用于任何中间或最终结果的`callback`，它将接收两个位置参数：作业ID和作业结果
- en: Execution parameters for execution time options, such as number of `shots(int)`,
    and `init_qubits(bool)`, which will reset the qubits to the ground state for each
    shot the (default is `true`)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行参数用于执行时间选项，如 `shots(int)`（整数）和 `init_qubits(bool)`（布尔值），这将重置每个射击的量子位到基态（默认为
    `true`）
- en: '`max_execution_time` is the maximum time, in seconds, after which a job is
    canceled. If this is not set, the default will be the time limit of the Primitive.
    If it is set, then the time must be set between 300 seconds and the maximum execution
    time set for the simulator or device, which can be found in the Qiskit API documentation:
    [https://docs.quantum.ibm.com/guides/max-execution-time](https://docs.quantum.ibm.com/guides/max-execution-time).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_execution_time` 是作业取消的最大时间，以秒为单位。如果没有设置，则默认为原始的时限。如果设置了，则时间必须在 300 秒和模拟器或设备设置的最大的执行时间之间，这可以在
    Qiskit API 文档中找到：[https://docs.quantum.ibm.com/guides/max-execution-time](https://docs.quantum.ibm.com/guides/max-execution-time)。'
- en: '`optimization_level` sets the level of optimization to the circuit. The higher
    the level, the more optimal and therefore longer the transpilation time. These
    optimization levels also include error suppression such as dynamical decoupling,
    which we will cover later in this chapter. There are four `optimization_level`
    settings. The default value is set to the highest, `3`:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`optimization_level` 设置电路的优化级别。级别越高，优化程度越高，因此编译时间越长。这些优化级别还包括动态去耦等错误抑制，我们将在本章后面介绍。有四个
    `optimization_level` 设置。默认值设置为最高值 `3`：'
- en: 0 – no optimization, uses basic translation, whichever layout is specified,
    and routing (uses stochastic swaps by default)
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 – 无优化，使用基本翻译，使用指定的任何布局，并路由（默认使用随机交换）
- en: 1 – light optimization, routing (uses SabreSWAP, 1Q gate optimization, and dynamical
    decoupling for error suppression)
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 – 轻度优化，路由（使用 SabreSWAP、1Q 门优化和动态去耦以抑制错误）
- en: 2 – medium optimization, layout and routing are the same as level 1, but includes
    heuristic optimization with a greater search depth and trials of optimization
    and dynamical decoupling for error suppression
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 – 中度优化，布局和路由与第 1 级相同，但包括具有更大搜索深度和优化及动态去耦尝试的启发式优化
- en: 3 – high optimization, layout and routing are the same as level 2 and include
    further optimization with greater efforts/trials, 2-qubit KAK optimization, and
    dynamical decoupling for error suppression
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 – 高度优化，布局和路由与第 2 级相同，并包括更大努力/尝试的进一步优化，2-量子比特 KAK 优化和动态去耦以抑制错误
- en: '`resilience_level` sets the level of resilience to mitigate errors. The higher
    the resilience level, the higher the accuracy of your results. Higher results
    are like that of the optimization level where it will cause longer transpilation
    time. These resilience levels range from 0 to 2, where level 1 is the default
    value and is only available for the Estimator primitive. It is important to note
    that as the technology evolves, so does the implementation and mitigation of these
    techniques. Please refer to the latest documentation to ensure your code is running
    the latest version ([https://docs.quantum.ibm.com/guides/configure-error-mitigation](https://docs.quantum.ibm.com/guides/configure-error-mitigation)
    ).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resilience_level` 设置缓解错误的恢复级别。恢复级别越高，结果精度越高。更高的结果类似于优化级别，这将导致更长的编译时间。这些恢复级别从
    0 到 2，其中级别 1 是默认值，并且仅适用于估计原始。重要的是要注意，随着技术的进步，这些技术的实现和缓解措施也在不断发展。请参考最新的文档，以确保您的代码正在运行最新版本
    ([https://docs.quantum.ibm.com/guides/configure-error-mitigation](https://docs.quantum.ibm.com/guides/configure-error-mitigation)
    )。'
- en: 0 – no mitigation.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 – 无缓解。
- en: 1 – (default) minimal mitigation, which minimizes readout errors. The Estimator
    primitive uses the Twirled Readout Error Extinction.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 – （默认）最小缓解，最小化读出错误。估计原始使用 Twirled Readout Error Extinction。
- en: 2 – medium mitigation, used to minimize bias in a circuit but indicates that
    it is not guaranteed to be zero, using the same as level 1 and includes Zero Noise
    Extrapolation.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 – 中度缓解，用于最小化电路中的偏差，但表示不能保证为零，使用与级别 1 相同的方法，并包括零噪声外推。
- en: Now that we’re familiar with all the options we can set to optimize and run
    circuits on our backend systems, let’s continue to move forward and learn what
    the Primitive classes are all about.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经熟悉了可以在我们的后端系统上设置以优化和运行电路的所有选项，让我们继续前进，了解原始类是什么。
- en: Understanding Primitives
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解原始类
- en: '**Primitives**, as defined on the Qiskit documentation, are generally the “*foundational
    building blocks for designing and optimizing quantum workloads*.” At the time
    of writing, there are two primitives within the Qiskit Runtime: **Sampler** and
    **Estimator**. Each of these provides a simple way to encapsulate your circuit
    and leverage each of its features to optimize workloads during execution to optimize
    running them on multiple quantum systems at scale. If you recall in the previous
    chapters, when we built and applied optimization levels to our circuit, it involved
    quite a bit of work, and the optimization was based on a single quantum system
    that we selected to run on. You can imagine the number of steps and overhead that
    would require if we needed to do that for each different system that executes
    our circuit. With the interface provided by the primitives, a lot of that is taken
    care of for us by applying a handful of option settings and selections. The runtime
    will then apply these accordingly as it selects multiple systems to execute the
    circuits. The primitives each perform a specific task and serve as the entry point
    to the Qiskit Runtime service. Let’s look at each primitive to get a little understanding
    of their functionality and the differences between them. In this chapter, we will
    focus on the Sampler primitive. The IBM Quantum Learning platform has some very
    good examples, courses, and tutorials that you can learn from in much greater
    detail than I can provide in this one chapter.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**原语**，如Qiskit文档中定义的，通常是“*设计和优化量子工作负载的基础构建块*。”在撰写本文时，Qiskit Runtime中有两个原语：**采样器**和**估计器**。每个都提供了一种简单的方式来封装你的电路，并利用其每个功能在执行过程中优化工作负载，以便在多个量子系统上大规模运行。如果你还记得在前面章节中，当我们构建并应用优化级别到我们的电路时，这涉及到相当多的工作，并且优化是基于我们选择的单个量子系统来运行的。你可以想象，如果我们需要为每个执行我们电路的不同系统做这件事，需要多少步骤和开销。通过原语提供的接口，很多工作都由我们通过应用一些选项设置和选择来处理。然后，运行时将相应地应用这些设置，因为它选择多个系统来执行电路。每个原语执行特定的任务，并作为Qiskit
    Runtime服务的入口点。让我们逐一查看每个原语，以了解它们的功能以及它们之间的差异。在本章中，我们将重点关注采样器原语。IBM量子学习平台有一些非常好的示例、课程和教程，你可以从中学习到比我在本章中提供的更详细的内容。'
- en: Understanding the Sampler primitive
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解采样器原语
- en: The **Sampler** primitive is similar to what we have used throughout this book
    in that it takes a quantum circuit as its input and generates a quasi-probability
    result. The result of this is also error-mitigated to ensure that the results
    are as precise as possible. Example of Sampler primitive circuits are Grover’s
    search and Deutsch-Jozsa. The Sampler can be modified to allow changes such as
    backends (local simulator or quantum system), which simplifies the management
    of your circuits and how they are run on the backend in accordance with the needs
    of your experiments. This is very helpful as each primitive has its own form of
    operating on the quantum circuit when executed on a quantum system, therefore
    certain properties or mitigating techniques will not work on some primitives based
    on the way they perform their tasks.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**采样器**原语与我们在这本书中使用的类似，它以量子电路作为输入并生成一个准概率结果。这个结果也被误差缓解，以确保结果尽可能精确。采样器原语电路的例子包括Grover搜索和Deutsch-Jozsa。采样器可以被修改以允许更改，例如后端（本地模拟器或量子系统），这简化了你的电路管理以及它们在根据实验需求的后端上运行的方式。这非常有帮助，因为每个原语在量子系统上执行时都有自己操作量子电路的方式，因此某些属性或缓解技术可能不会在某些原语上工作，这取决于它们执行任务的方式。'
- en: Well, so far, we’ve done quite a bit of reading, why don’t we get back to some
    coding. Let’s create a new Qiskit notebook and run a simple circuit using the
    Sampler to try it out. We’ll also include the classes mentioned earlier so we
    can wrap everything together in a simple construct of a circuit.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，到目前为止，我们已经阅读了很多内容，为什么不回到一些编码上来呢？让我们创建一个新的Qiskit笔记本，并使用采样器运行一个简单的电路来尝试一下。我们还将包括前面提到的类，这样我们就可以将所有内容封装在一个简单的电路结构中。
- en: 'First, we’ll create a simple circuit:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的电路：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will display the following circuit that we wish to run:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示我们希望运行的以下电路：
- en: '![A diagram of a circuit  Description automatically generated](img/B18420_10_01.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![电路的示意图  描述由系统自动生成](img/B18420_10_01.png)'
- en: 'Figure 10.1: Simple circuit to run on the system'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：要在系统上运行的简单电路
- en: Now, here’s where the fun starts! Let’s begin by following the Qiskit Patterns
    so we are not only ensuring that our circuits are efficient but also our development
    patterns.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从这里开始就变得有趣了！让我们首先遵循Qiskit模式，这样我们不仅确保我们的电路是高效的，而且我们的开发模式也是高效的。
- en: 'Qiskit Patterns are a 4-step process that we can use to help integrate our
    quantum computation circuits into a larger application layer. The 4 steps are
    Map, Optimize, Execute, and Post-process. We’ll go through each of these steps
    so that you can get familiar with running circuits optimally on a quantum system.
    We’ll start with what we just did: map our problem into a quantum circuit.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit模式是一个4步过程，我们可以使用它来帮助我们集成我们的量子计算电路到更大的应用层。这4个步骤是映射、优化、执行和后处理。我们将逐一介绍这些步骤，以便您熟悉在量子系统上以最佳方式运行电路。我们将从我们刚刚做的事情开始：将我们的问题映射到量子电路。
- en: 'Step 1: Map'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第1步：映射
- en: Mapping a problem to a quantum circuit can be done in many ways. We can probably
    write volumes of books that could be dedicated to this. This is because it not
    only depends on the problem we’re trying to solve, but also how we can best map
    our input data and problem solution into a quantum state or initial state. This
    is similar to planning a trip. If I were to ask you to plan a group trip to New
    York, there could be many options and even more questions regarding how to get
    there? Where will everyone be? Are they all in the same location at the beginning
    of the trip. How long will they be available? These are similar questions we need
    to consider. How do we get the data to the quantum systems? Where is all the data,
    at that moment, and how long will the data be there? Once we have obtained the
    input data the next step is to translate it from classical information into a
    quantum state or input for our circuit. Let’s do this now with a simple example,
    the circuit we built earlier in this chapter. In *Chapter 13*, we will cover a
    more sophisticated problem, Grover’s search. For now, to allow us to focus on
    the overall process, we’ll stick with the simple circuit, and some random circuits.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将问题映射到量子电路可以有多种方式。我们可能可以写出大量的书籍来专门讨论这一点。这是因为这不仅取决于我们试图解决的问题，还取决于我们如何将我们的输入数据和问题解决方案最佳地映射到量子状态或初始状态。这类似于规划一次旅行。如果我要请你帮我规划一次去纽约的团队旅行，可能会有很多选择，甚至更多关于如何到达那里的问题？大家会在哪里？他们是否在旅行的开始时都在同一个地点。他们会有多长时间可用？这些问题是我们需要考虑的。我们如何将数据传输到量子系统中？在那个时刻，所有数据在哪里，数据会持续多久？一旦我们获得了输入数据，下一步就是将其从经典信息转换为量子状态或电路的输入。现在让我们用一个简单的例子来做这件事，即本章前面构建的电路。在*第13章*中，我们将讨论一个更复杂的问题，即Grover搜索。现在，为了让我们专注于整个过程，我们将继续使用简单的电路和一些随机电路。
- en: So far, we have mapped a problem into a quantum state, in this case the circuit
    we constructed above. That’s step one, Map, done.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将问题映射到了量子状态，在这种情况下是上面构建的电路。这是第一步，映射，已完成。
- en: Let’s now run this circuit using a `Statevector` class to get the expected results
    before running on a quantum system. Since this is a small and simple quantum circuit,
    we can simulate this easily on a classical system such as the one you have at
    home or in your office. If the circuit or problem involved a large number of qubits
    that you would be unable to run on a classical system, then the preferred way
    to do this would be to reduce the problem size to something you can run on a classical
    system so that you can confirm the expected result at a smaller scale and then
    run on a quantum system to get the full-scale results.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用`Statevector`类来运行这个电路，在量子系统上运行之前获取预期的结果。由于这是一个小型且简单的量子电路，我们可以在一个经典系统上轻松模拟，比如你在家或办公室里的系统。如果电路或问题涉及大量比特，你无法在经典系统上运行，那么首选的方法是将问题规模减小到可以在经典系统上运行的大小，这样你可以在较小的规模上确认预期的结果，然后运行在量子系统上以获得全面的结果。
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will display the expected results in the following diagram:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在以下图中显示预期的结果：
- en: '![A graph with blue bars  Description automatically generated](img/B18420_10_02.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有蓝色条的图表，描述自动生成](img/B18420_10_02.png)'
- en: 'Figure 10.2: Expected probability results from the circuit using Statevector'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：使用Statevector从电路中得到的预期概率结果
- en: 'Next, we can prepare this to run on an actual backend. To do this, we need
    to include measurement operators in our circuit, which we will do, and then obtain
    the least busy backend system to run this circuit:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以准备在真实后端上运行。为此，我们需要在我们的电路中包含测量算子，我们将这样做，然后获取最不繁忙的后端系统来运行这个电路：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will print out the selected backend, which is the least busy at the time
    it is called.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出所选的后端，这是在调用时最不繁忙的后端。
- en: 'Step 2: Optimize'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第2步：优化
- en: Now we can prepare our circuit to run on the backend by transpiling it accordingly.
    To do this, we will use the new `preset_passmanager` function, which is a new
    addition to the Qiskit `transpiler` library that allows you to set, run, and draw
    the result of the circuit after transpilation. Aligning a circuit to a target
    backend is ideal in that it will optimize the circuit to that selected backend
    by applying not only the general passes available but also AI generated optimizers
    that introduce further improvements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过相应的转译来准备电路在后台运行。为此，我们将使用新的`preset_passmanager`函数，这是Qiskit `transpiler`库的新增功能，允许您设置、运行和绘制电路转译后的结果。将电路与目标后端对齐是理想的，因为它将通过应用不仅通用的传递，还包括引入进一步改进的AI生成优化器来优化电路到所选的后端。
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This displays the transpiled circuit specific to the selected backend target.
    Here, you will note two differences from the original circuit. First, note the
    qubit mapping has changed; qubit 0 is now assigned to qubit 73\. In your case,
    depending on which system was selected, it might point to other qubits. Next,
    you’ll also note that there are more gates added. This is due to having to use
    basis gates and connectivity between qubits (using ECR gates: [https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.ECRGate](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.ECRGate)
    ) to connect between qubits that might not be adjacent to each other. Results
    might differ here as your selected backend might have different results.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了针对所选后端目标的特定转译电路。在这里，您将注意到与原始电路的两个不同之处。首先，请注意量子比特映射已更改；量子比特0现在分配给量子比特73。在您的情况下，这取决于您选择了哪个系统，它可能指向其他量子比特。接下来，您还会注意到添加了更多的门。这是由于必须使用基门和量子比特之间的连接性（使用ECR门：[https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.ECRGate](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.ECRGate)）来连接可能不相邻的量子比特。结果可能不同，因为您所选的后端可能得到不同的结果。
- en: '![A diagram of a graph  Description automatically generated with medium confidence](img/B18420_10_03.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![一个图的示意图  描述由中等置信度自动生成](img/B18420_10_03.png)'
- en: 'Figure 10.3: Transpiled circuit'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：转译电路
- en: Now that we know how to transpile a circuit and set the optimization level values,
    let’s now switch to a bit more complex circuit so we can push the optimizer further
    and see the differences between the resulting circuits. We’ll use a simple Grover
    operator to generate a circuit. Since we have not yet covered Grover’s algorithm
    in much detail, let’s ease into it and just say that we will use it to mark a
    state we wish the circuit to find. In this case, we will use the binary representation
    `110`. Grover’s algorithm will be discussed in *Chapter 13*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何转译电路并设置优化级别值，让我们现在切换到一个更复杂的电路，这样我们就可以进一步推动优化器，并看到结果电路之间的差异。我们将使用一个简单的Grover算子来生成电路。由于我们还没有详细讨论Grover算法，让我们先简单地说，我们将使用它来标记电路要找到的状态。在这种情况下，我们将使用二进制表示`110`。Grover算法将在*第13章*中讨论。
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will result in the following circuit, where we have a set of Hadamard gates
    followed by the Grover operator composite. Note that this is a composite that
    represents a series of gates into a single block titled Q to simplify the visualization
    of the circuit. You can run the `decompose` method a few times to break it down
    to the basis gates.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下电路，其中我们有一系列Hadamard门，后面跟着Grover算子复合体。请注意，这是一个复合体，它将一系列门表示为单个名为Q的块，以简化电路的可视化。您可以通过多次运行`decompose`方法将其分解为基门。
- en: In the next steps, we will transpile it with varying optimization level values
    and compare the two so you can see the power that the `transpiler` optimizers
    have on the circuit.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将使用不同的优化级别值进行转译，并比较这两种方法，以便您可以看到`转译器`优化器对电路的影响。
- en: '![A diagram of a number of squares  Description automatically generated with
    medium confidence](img/B18420_10_04.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![多个正方形的示意图  描述由中等置信度自动生成](img/B18420_10_04.png)'
- en: 'Figure 10.4: Grover operator circuit'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：Grover算子电路
- en: The following will highlight the difference between optimization levels with
    the complexities that accompany many circuits. To be more specific regarding the
    comparisons, we will be observing the number of **ECR** gates, which is an acronym
    for **Echoed Cross-Resonance** gate. They’re similar to CX gates but with an echoing
    procedure, which mitigates a few unwanted terms. Details on this gate can be found
    in the Qiskit Circuit Library. ECR gates, or any multi-source/multi-target gates,
    are quite complex as they require additional gates to generate connectivity. In
    this example, we will use the number of ECR gates to compare the circuits.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的内容将突出显示优化级别之间的差异，以及许多电路伴随的复杂性。为了更具体地进行比较，我们将观察**ECR**门的数量，这是**Echoed Cross-Resonance**门的缩写。它们类似于CX门，但有一个回声过程，可以减少一些不希望的项。关于这个门的具体信息可以在Qiskit电路库中找到。ECR门或任何多源/多目标门相当复杂，因为它们需要额外的门来生成连接性。在这个例子中，我们将使用ECR门的数量来比较电路。
- en: 'Let’s first capture the `Statevector` results from the current circuit so we
    can compare them to the results after transpiling and running on the quantum systems:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从当前电路中捕获`Statevector`结果，这样我们就可以将它们与转换后在量子系统上运行的结果进行比较：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we’ll add measurement gates to this circuit and create multiple copies,
    each with varying `optimization_level` values to compare:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向这个电路添加测量门并创建多个副本，每个副本具有不同的`optimization_level`值以进行比较：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result here is a transpiled version of the original Grover circuit we created.
    I have included a truncated portion of it in the following figure:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里得到的结果是我们创建的原始Grover电路的转换版本。我在下面的图中包括了它的截断部分：
- en: '![A diagram of a circuit  Description automatically generated with medium confidence](img/B18420_10_05.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![电路的示意图  描述由中等置信度自动生成](img/B18420_10_05.png)'
- en: 'Figure 10.5: Transpiled Grover operator circuit (truncated)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：转换后的Grover算子电路（截断）
- en: As you can see, it is much more complex and with quite a few extra gates, including
    ECR gates.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它要复杂得多，并且包含相当多的额外门，包括ECR门。
- en: Now, let’s go through the circuit and assign a different `optimization_level`
    value for each. In this case, we’ll compare the extreme levels, one at 0, which
    is to say no optimization at all, and another at 3, which is fully optimized.
    We’ll then add it to a `circuits` array to run on a quantum system later.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们遍历电路并为每个分配不同的`optimization_level`值。在这种情况下，我们将比较极端的水平，一个在0，也就是说完全没有优化，另一个在3，即完全优化。然后我们将它添加到`circuits`数组中，稍后在量子系统上运行。
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will display the number of ECR gates for each circuit. Note the difference
    between the two circuits (they will vary based on system) is quite large when
    compared with no optimization (level 0) and fully optimized (level 3).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示每个电路的ECR门数量。注意，与没有优化（级别0）和完全优化（级别3）相比，两个电路（它们将根据系统而变化）之间的差异相当大。
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have optimized our circuit by transpiling to the device with specific
    optimization levels, let’s now run both circuits and compare the results, along
    with the simulated results, on an actual quantum system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过将电路转换为具有特定优化级别的设备来优化了我们的电路，现在让我们运行这两个电路，并在实际的量子系统上比较结果，包括模拟结果。
- en: This completes the optimize step and we move onto the next Qiskit Pattern, executing
    the optimized circuit.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了优化步骤，我们接下来进行下一个Qiskit模式，执行优化后的电路。
- en: 'Step 3: Execute'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第3步：执行
- en: Here, we will now run our circuit on the targeted backend, but this time with
    a twist. We will use a new feature of the Qiskit Runtime called Batch. This will
    allow us to provide a batch of operations to run on a quantum system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们现在将在目标后端上运行我们的电路，但这次有一些变化。我们将使用Qiskit Runtime的新功能Batch。这将允许我们提供一批操作在量子系统上运行。
- en: To execute the circuits we created, we will first need to create a batch, which
    is one of the execution modes of the Qiskit Runtime ([https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.Batch](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.Batch)
    ), and load it up with our circuit and backend information first, then within
    the batch, we’ll run the Sampler primitive on the backend and print the results.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行我们创建的电路，我们首先需要创建一个批次，这是Qiskit Runtime（[https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.Batch](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.Batch)）的执行模式之一，首先将我们的电路和后端信息加载到批次中，然后在批次内部，我们将在后端上运行Sampler原语并打印结果。
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This might take a while depending on where you are in the queue. But once it’s
    complete, you should see the following results from your experiment, which includes
    the quasi-probability results and the metadata from the experiment, in this case
    the number of shots used to obtain the results.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要一段时间，具体取决于你在队列中的位置。但一旦完成，你应该看到实验的以下结果，包括准概率结果和实验的元数据，在这种情况下是获取结果所使用的射击次数。
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s look at the results a little deeper. First, you will see a set of `quasi_dists`.
    These are the results of the quasi-distribution from our experiments. Since we
    ran a 3-qubit circuit, we should see 8 possible results, 0-7, and the quasi-probabilities
    for each. This is then followed by some nice information on the readout overhead
    for each circuit, which is simply the time it took to read out the results for
    each circuit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地看看结果。首先，你会看到一组`quasi_dists`。这是我们实验中准分布的结果。由于我们运行了一个3量子比特电路，我们应该看到8种可能的结果，0-7，以及每个结果的准概率。然后是一些关于每个电路读出开销的详细信息，这仅仅是读取每个电路结果所需的时间。
- en: This now helps us move into the final step in the Qiskit Patterns, post-process.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在帮助我们进入Qiskit模式的最后一步，后处理。
- en: 'Step 4: Post-process'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第4步：后处理
- en: 'In this final step of the Qiskit patterns, we will extract the results from
    the quantum systems and do some post-processing. What exactly is post-processing?
    Well, simply put, it’s whatever you wish it to be. You could extrapolate the results
    and return them to the next task in your classical application to continue a particular
    hybrid classical-quantum workflow, or you can simply provide the results as an
    input to another classical or quantum computational task and continue. In this
    case, we’ll keep it simple and just display the results visually to compare them.
    We’ll compare the state vector results we computed earlier and visualize them
    in comparison to the results from the two circuits we ran on a quantum system.
    The following will display the results onto a histogram:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qiskit模式的最后一步，我们将从量子系统中提取结果并进行一些后处理。后处理究竟是什么？简单来说，就是你想让它成为的样子。你可以外推结果并将其返回到你的经典应用程序中的下一个任务，以继续特定的混合经典-量子工作流程，或者你可以简单地提供结果作为另一个经典或量子计算任务的输入并继续。在这种情况下，我们将保持简单，只以可视化的方式显示结果以进行比较。我们将比较我们之前计算的状态向量结果，并将它们与我们在量子系统上运行的两个电路的结果进行比较。以下将结果显示在直方图上：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The resulting plot will be as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图将如下所示：
- en: '![A graph with different colored bars  Description automatically generated](img/B18420_10_06.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有不同颜色条的图表，自动生成描述](img/B18420_10_06.png)'
- en: 'Figure 10.6: Post-processed results, visualization comparison'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：后处理结果，可视化比较
- en: Here, you can see that our result is as expected, where the results from the
    optimization at the higher level, 3, are closer to our simulated results, whereas
    the results from the circuit without any optimization are less accurate.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们的结果是预期的，其中在更高层次优化（3）的结果更接近我们的模拟结果，而没有进行任何优化的电路的结果则不太准确。
- en: 'This brings us to the next topic we need to discuss: noise. All quantum systems,
    no matter the technology, have some form of noise or effect that the system has
    that is related to noise. There are some technologies that isolate qubits from
    any environmental noise; however, this also presents a disadvantage in that when
    we want to alter the state of the qubit, the speed and fidelity might take longer
    than other technologies. In this book, since we are using IBM Quantum systems,
    we will focus on superconducting qubits and the effects that noise has on them.
    We will, of course, also cover the latest advancements in both error suppression
    and error mitigation, which over time will potentially provide us with useful
    quantum applications. In the next section, we’ll begin by understanding the differences
    between the types of noise and how they affect quantum systems.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了我们需要讨论的下一个主题：噪声。所有量子系统，无论技术如何，都存在某种形式的噪声或与噪声相关的效应。有些技术可以将量子比特与任何环境噪声隔离；然而，这也带来一个缺点，即当我们想要改变量子比特的状态时，速度和保真度可能比其他技术慢。在这本书中，由于我们使用IBM量子系统，我们将重点关注超导量子比特以及噪声对它们的影响。当然，我们还将涵盖错误抑制和错误缓解的最新进展，这些进展随着时间的推移可能会为我们提供有用的量子应用。在下一节中，我们将首先了解不同类型噪声之间的差异以及它们如何影响量子系统。
- en: Understanding the noise effects of decoherence
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解退相干噪声效应
- en: We learned in *Chapter 9*, *Simulating Quantum Systems and Noise Models*, that
    we can generate various noise models that are based on the configuration of a
    specified quantum computer. After the configuration information is extracted,
    we can then apply any one of an array of error functions to a local simulator,
    which will reproduce similar error effects to what we would get from a quantum
    computer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第9章*，*模拟量子系统和噪声模型*中，我们了解到我们可以生成基于指定量子计算机配置的各种噪声模型。在提取配置信息后，我们可以将一系列错误函数中的任何一个应用到本地模拟器上，这将重现类似于从量子计算机获得的类似错误效应。
- en: 'In this section, we will expand on that to learn how these errors affect our
    circuits over time. The two effects we will review here are the two most common
    issues found in near-term quantum systems: **relaxation** and **dephasing**. These
    are critical errors as they can affect the quantum state information, which would
    result in erroneous responses.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进一步探讨这些错误如何随时间影响我们的电路。我们将回顾的两个效应是近期量子系统中发现的两个最常见问题：**弛豫**和**失相**。这些是关键错误，因为它们可以影响量子状态信息，从而导致错误响应。
- en: Later in this chapter, we will also look at **readout errors**, another common
    source of noise that originates when the system is applying a measurement pulse,
    while in parallel, listening in on the acquisition channel. The results and conversion
    from an analog pulse to a digital value (either 0 or 1) can introduce many errors
    as well, which we will then try and mitigate.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们还将探讨**读出错误**，这是噪声的另一个常见来源，它发生在系统应用测量脉冲的同时，并行地监听采集通道。从模拟脉冲到数字值（要么是0要么是1）的转换也可能引入许多错误，我们将尝试减轻这些错误。
- en: 'We will start by learning about one of the most common and important effects
    of noise in quantum systems: **decoherence**. The three main types of decoherence
    are **T1**, **T2**, and **T2***. Each of these represents a type of decoherence
    effect on the qubit. We will begin by looking at each of them individually to
    understand the differences between them and how to suppress and mitigate against
    them when they are run on a real quantum device.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解量子系统中噪声最常见和最重要的效应之一：**去相干**。去相干主要有三种类型：**T1**、**T2**和**T2**。每一种都代表了对量子比特的去相干效应。我们将逐一研究它们，以了解它们之间的差异，以及如何在真实量子设备上运行时抑制和减轻这些效应。
- en: If you are deeply interested to learn how to analyze the effects of **relaxation**
    (**T1**) and **dephasing** (**T2/T2***), *Chapter 9*, *Simulating Quantum Systems
    and Noise Models*, illustrates ways to create circuits that include noise models
    that replicate each of the three. This will help you run experiments to analyze
    the characterization of the device.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对学习如何分析**弛豫**（**T1**）和**失相**（**T2/T2**）的效果有浓厚的兴趣，*第9章*，*模拟量子系统和噪声模型*展示了创建包含复制每种三种去相干效应的噪声模型的电路的方法。这将帮助您运行实验以分析设备的表征。
- en: The next section provides a quick overview of both, just to get you to understand
    which of them is affected when discussing the mitigation features.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将简要概述这两者，以便让您了解在讨论缓解功能时，哪一项受到影响。
- en: Understanding decoherence errors
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解去相干错误
- en: 'T[1], as we covered in *Chapter 9*, *Simulating Quantum Systems and Noise Models*,
    is often referred to as the **relaxation time**. Relaxation time refers to the
    time it takes the energy of a qubit to decay from the **excited state** (![](img/B18420_05_005.png))
    back down to its **ground state** (![](img/B18420_10_002.png)), as illustrated
    in the following graph, where ![](img/B18420_10_003.png) indicates the probability
    of `1`, and ![](img/B18420_10_004.png) is the probability of `0`. The T[1] time
    is defined as the value when *P(t) = 1/e* (refer to the following diagram):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: T[1]，正如我们在*第9章*，*模拟量子系统和噪声模型*中提到的，通常被称为**弛豫时间**。弛豫时间指的是量子比特的能量从**激发态**（![](img/B18420_05_005.png)）衰减回其**基态**（![](img/B18420_10_002.png)）所需的时间，如下面的图表所示，其中![](img/B18420_10_003.png)表示概率为`1`，![](img/B18420_10_004.png)是概率为`0`。T[1]时间定义为*P(t)
    = 1/e*时的值（参见图表）：
- en: '![Figure 11.1 – T1 defined as the decay time where the probability of the energy
    state reaches 1/e ](img/B18420_10_07.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – T1定义为能量状态达到1/e的概率衰减时间](img/B18420_10_07.png)'
- en: 'Figure 10.7: T1 defined as the decay time where the probability of the energy
    state reaches 1/e'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：T1定义为能量状态达到1/e的概率衰减时间
- en: When applying this to a quantum system, if you want to determine the amount
    of time to reach T[1] for any qubit, you would need to create a test circuit that
    places the qubit in an excited state, ![](img/B18420_05_005.png). We know how
    to do this by simply applying an X gate to the qubit and then waiting a given
    amount of time before measuring that qubit. If you were to do this over a set
    number of time intervals, you will likely start to see the results switch from
    the excited state transition to the ground state.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当将此应用于量子系统时，如果你想要确定任何量子比特达到 T[1] 所需的时间量，你需要创建一个测试电路，将量子比特置于激发态，![](img/B18420_05_005.png)。我们知道如何通过简单地对一个量子比特应用
    X 门，然后等待一段时间再测量该量子比特来实现这一点。如果你要在一定数量的时间间隔内这样做，你可能会开始看到结果从激发态跃迁到基态。
- en: So, what does all that mean? Let’s dig in a little bit and see how this applies
    to quantum systems over time and on complex circuits.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这一切意味着什么呢？让我们深入探讨一下，看看这如何应用于随着时间的推移和复杂电路上的量子系统。
- en: We’ll start with a simple analogy to provide you with some intuitive understanding
    of the concepts here. For those of you who already have knowledge of these concepts,
    feel free to jump to the next section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的类比开始，为你提供一些直观的概念理解。对于那些已经了解这些概念的人来说，请自由地跳到下一节。
- en: Imagine yourself just before or soon after New Year’s Eve making that same resolution
    most of us make, me included, year after year of hitting the gym and getting back
    in shape, particularly after the feasts we’ve enjoyed over the holidays. Then,
    usually on the first or second week of January, we go to the gym and our personal
    trainer takes us straight to the weights and asks us to pick a weight. Now, one
    of the things we naturally do is try to pick up where we were the last time we
    were at the gym and grab a heavy weight. Of course, at first it seems a little
    heavy, but we power on. Our trainer then wants to test our strength and asks us
    to hold the weight high over our heads with our arms extended. We then raise the
    weight confidently over our heads and we’re *excited* that this wasn’t too bad.
    Let’s call our ability to hold the weight over our heads the excited state. OK,
    so let’s now say our trainer asks us to hold it there as long as we can. What
    we will notice is that our strength can only sustain this position for some time.
    We will then begin to feel the fatigue in our muscles, which will then slowly,
    or in my case rather rapidly, start to lower down towards the original position,
    which is with the weight down close to the *ground*, where I am no longer feeling
    the strain of my muscles. Let’s call this the *relaxed* position, the ground state.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，就在新年除夕前后，或者不久之后，我们大多数人包括我自己，每年都会做出同样的承诺，那就是去健身房锻炼，恢复体型，尤其是在假期享受盛宴之后。然后，通常在一月的第一周或第二周，我们会去健身房，我们的私人教练直接带我们去举重，并要求我们选择一个重量。当然，一开始可能会觉得有点重，但我们还是鼓起勇气。然后，我们的教练想要测试我们的力量，并要求我们用伸直的胳膊将重量高举过头顶。然后我们自信地将重量举过头顶，我们感到*兴奋*，这并不太糟糕。让我们称我们能够将重量举过头顶的能力为激发态。好，现在假设我们的教练要求我们尽可能长时间地保持这个姿势。我们会注意到，我们的力量只能维持这个姿势一段时间。然后，我们会开始感觉到肌肉的疲劳，这会慢慢地，或者在我的情况下，比较快地开始降低到原始位置，即重量靠近*地面*的位置，在那里我不再感觉到肌肉的紧张。让我们称这个位置为*放松*状态，基态。
- en: A qubit pretty much follows this concept in that it will start at a ground state,
    then sometime later we will amplify the qubit from the ground state to some excited
    state. Now, just like us, over time we will return to that ground state to relax.
    This relaxation from excited to ground state is, logically enough, called amplitude
    relaxation, which may sound familiar because we learned about this in the previous
    chapter when creating an amplitude dampening noise model to represent decoherence.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特在很大程度上遵循这个概念，它将从基态开始，然后我们将在一段时间后从基态放大量子比特到某个激发态。现在，就像我们一样，随着时间的推移，我们将回到基态以放松。这种从激发态到基态的放松，从逻辑上讲，被称为振幅弛豫，这可能听起来很熟悉，因为我们之前在创建振幅衰减噪声模型来表示退相干时学过这个概念。
- en: Looking back at *Figure 10.8*, you can imagine this is what the effect decoherence
    (T[1]) has on a qubit caused by its environment. What do we mean by environment?
    I’m glad you asked! A qubit isn’t just a single aluminum-niobium component with
    a Josephson Junction.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾*图10.8*，你可以想象这就是环境效应（T[1]）对量子比特的影响。我们所说的环境是什么意思？我很高兴你问了这个问题！量子比特不仅仅是一个带有约瑟夫森结的单个铝铌组件。
- en: 'Oh no, no, no, it has so much more going on! Of course, depending on the technology
    that the qubit relies on, superconducting, ion traps, photonics, etc. the qubit
    is not sitting all alone. It is usually surrounded by various environment variables
    that can interfere with and even at times speed up the decoherence of the qubit.
    Superconducting qubits, for example, must sit at a certain temperature, approximately
    15 millikelvin, to work properly and make sure that the energy levels between
    the ground and first excited state are precise to determine the state of the qubit.
    Then, the pulse sent to the qubit has to have the right amplitude, duration, frequency,
    etc. in order to place the qubit in the correct state. Keep in mind that this
    could be difficult as the quantum system might be very complex. For example, we
    defined one amplitude value as the excited state as just one position earlier
    in our example: lifting the weight over our heads. But what if we needed multiple
    amplitudes to encode our data? Then the precision of our gates will need to be
    very exact, which means that the fidelity of the gates also might influence our
    system. This is how decoherence, also referred to as the relaxation rate or T[1],
    if not suppressed, causes us to lose the quantum state information of our circuit,
    which leads to errors when we read the results of our circuits.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不，不，不，这里还有更多的事情在发生！当然，根据量子比特所依赖的技术，如超导、离子阱、光子学等，量子比特并不是孤立的。它通常被各种环境变量所包围，这些变量可能会干扰量子比特，有时甚至能加速其退相干。例如，超导量子比特必须处于一定的温度下，大约15毫开尔文，才能正常工作并确保基态和第一激发态之间的能级精确，以确定量子比特的状态。然后，发送给量子比特的脉冲必须具有正确的幅度、持续时间、频率等，以便将量子比特置于正确的状态。记住，这可能很困难，因为量子系统可能非常复杂。例如，我们在前面的例子中定义一个幅度值作为激发态，只是比之前的位置高一点：将重物举过头顶。但如果我们需要多个幅度来编码我们的数据呢？那么我们门控的精度就需要非常精确，这意味着门控的保真度也可能影响我们的系统。这就是退相干，也称为弛豫率或T[1]，如果不被抑制，会导致我们失去电路的量子状态信息，从而导致我们在读取电路结果时出现错误。
- en: Understanding dephasing errors
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解去相干错误
- en: T[1], we learned in the previous section, refers to the decoherence or relaxation
    rate caused when the amplitude of the qubit decays over time. Dephasing errors,
    on the other hand, occur when the phase of the qubit is blurred, often referred
    to either T[2] or T[2]*. Dephasing is quite like decoherence in that we will also
    lose state information over time, only in a slightly different manner.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: T[1]，我们在上一节中了解到，是指量子比特随时间衰减时引起的退相干或弛豫率。另一方面，去相干错误发生在量子比特的相位变得模糊时，通常被称为T[2]或T[2]*。去相干与退相干相似，我们也会随着时间的推移失去状态信息，只是方式略有不同。
- en: To define dephasing simply means to lose phase information, of a qubit in this
    case.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，定义去相干就是失去量子比特的相位信息。
- en: 'There are many different sources for dephasing noise, each of which has varying
    properties. A few examples are:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 去相干噪声有许多不同的来源，每个来源都有不同的特性。一些例子包括：
- en: '**White noise**, when there is an equal amount of a signal that is of equal
    intensity at varying frequencies.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**白噪声**，当信号在变化频率上具有相等强度且数量相等时。'
- en: '**Pink noise**, often referred to as flicker noise, occurs usually in electronic
    devices where the power density decreases with increasing frequency, i.e., 1/f,
    where f is the frequency.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粉红噪声**，通常被称为闪烁噪声，通常出现在电子设备中，其中功率密度随着频率的增加而减少，即1/f，其中f是频率。'
- en: '**Flux noise**, is found on the surface of **superconducting quantum interference
    devices**, commonly referred to as **SQUIDS**, the source of which are the magnetic
    spins on the surface of the SQUID.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁通噪声**，出现在**超导量子干涉器件**（SQUID）的表面，通常被称为**SQUID**，其来源是SQUID表面的磁自旋。'
- en: Short of converting this from a developer to an engineering book, I will include
    some references to these as well, should you want to learn more about them, at
    the end of this chapter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不能将这本书从开发者手册转变为工程手册，但如果您想了解更多关于这些内容，我将在本章末尾提供一些参考。
- en: Now that we have a basic understanding of noise, let’s learn what the differences
    are between error suppression, error mitigation, and error correction and how
    we can use them to create useful quantum applications.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对噪声有了基本的了解，让我们学习一下错误抑制、错误缓解和错误纠正之间的区别，以及我们如何使用它们来创建有用的量子应用。
- en: Differences between error suppression, mitigation, and correction
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误抑制、缓解和纠正之间的区别
- en: In the previous section, we discussed some sources of errors that can be introduced
    to your quantum circuit when running them on a quantum system. Here, we will define
    the various ways to eliminate these errors from your quantum circuit to obtain
    optimal results. We’ll begin by first defining what the differences between suppressing,
    mitigating, and correcting errors.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了一些在量子系统上运行量子电路时可能引入的错误来源。在这里，我们将定义从量子电路中消除这些错误的各种方法，以获得最佳结果。我们将首先定义抑制、缓解和纠正错误的区别。
- en: '**Error suppression** is just as the name states, suppressing the noise of
    a given circuit so that the quantum state remains intact. The specific noise here
    could be either the decoherence time of a qubit (amplitude dampening) or dephasing.
    As we learned earlier, if a qubit is placed in a specific state and left there
    over some long period of time, that qubit will eventually return to the ground
    state, or some state that is different from the set state. What we would like
    to do here is suppress this by keeping the circuit in the current state. Of course,
    this is easier said than done. Let’s first think about this intuitively, and then
    get into the details.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误抑制**正如其名所示，就是抑制给定电路的噪声，以保持量子状态完整。这里的特定噪声可能是量子比特的退相干时间（振幅衰减）或去相位。正如我们之前所学的，如果一个量子比特被放置在特定的状态，并在一段时间内保持在那里，那么这个量子比特最终会回到基态，或者某个与设定状态不同的状态。我们在这里想做的就是通过保持电路在当前状态来抑制这种情况。当然，说起来容易做起来难。让我们首先从直觉上考虑这个问题，然后再深入细节。'
- en: Returning to our gym scenario from earlier, let’s now assume you are lifting
    a very heavy set of weights over your chest from a laying position on the workout
    bench, bench-pressing. There is a risk here that the weight, over time, starts
    to feel heavier due to the strain your muscles are feeling. This is why you see
    most people that do this have, standing very close to the weights, a spotter.
    This is someone who helps you either when you are fatigued and need a little help,
    or helps lift the weight off your chest when your muscles just suddenly give up.
    There are many videos I’m sure you can find online where you can see the terrible
    results when there’s no spotter around, but for now, let’s elaborate on what this
    has to do with error suppression.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前提到的健身房场景，现在假设你正从卧推凳上的躺姿开始，举起非常重的哑铃进行卧推。这里存在一个风险，随着时间的推移，由于肌肉的紧张，哑铃开始感觉越来越重。这就是为什么大多数做这个动作的人都会站在哑铃非常近的地方，有一个保护者。这个人会在你疲劳需要一点帮助时帮助你，或者在你肌肉突然放弃时帮助你将哑铃从胸部抬起。我相信你可以在网上找到很多视频，可以看到没有保护者在场时的可怕后果，但就现在而言，让我们详细说明这与错误抑制有什么关系。
- en: If you imagine that you need to sustain the weight over your head for a long
    period of time, you’ll realize that over time your muscles will strain; we aligned
    this to decoherence earlier. To help with this, your spotter can assist by gently
    helping you raise the bar back up so you can maintain your initial position, or
    state in this case. That assistance from your spotter can be seen as error suppression
    in that it helped maintain your state while not changing the state itself, meaning
    you’re not holding it any higher or lower than expected to count as a lift. Now,
    let’s get out of the gym and switch our context back to quantum and see how this
    helps us understand error suppression with respect to a quantum circuit.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想象你需要长时间保持头顶上的重量，你会意识到随着时间的推移，你的肌肉会感到紧张；我们将这比作之前的退相干。为了帮助解决这个问题，你的保护者可以通过轻轻地帮助你将杠铃重新举起来，这样你就可以保持你的初始位置或状态。这种来自保护者的帮助可以看作是错误抑制，因为它帮助保持了你的状态，而没有改变状态本身，这意味着你没有把它举得比预期更高或更低，以算作一次举起。现在，让我们离开健身房，将我们的背景切换回量子，看看这如何帮助我们理解与量子电路相关的错误抑制。
- en: When a gate or set of gates is applied to a qubit within a circuit, that circuit
    may, over some period of time, lose its state in many ways, some of which we mentioned
    earlier. What we need to do is apply a technique in which we can help the circuit
    maintain its state. Yes, this sounds like the definition of error correction,
    but let me take a moment to elaborate on that to identify the difference. To do
    that I’ll explain a new Pass (recall that a Pass is an object used to optimize
    a circuit, such as finding an optimal layout mapping, or optimal qubits) that
    was added to Qiskit called **Dynamical Decoupling** (**DD**). Dynamical decoupling
    is a well-known technique that was described back in 1998 by Dr. Seth Lloyd and
    Dr. Lorenza Viola from MIT ([https://arxiv.org/abs/quant-ph/9803057](https://arxiv.org/abs/quant-ph/9803057)
    ). They describe it as a form of using control pulses to minimize the diffusion
    of the state of the qubit. This is generally done by applying the same gate operation
    twice, which mimics an identity gate. We learned about this earlier when we explained
    that most universal quantum gates are reversible, hence by applying two reversible
    gates back-to-back, you end up with the identity gate. So, how does this work,
    you ask? I’m glad you did, here we go!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个门或一组门作用于电路中的量子比特时，该电路可能在一段时间内以多种方式失去其状态，其中一些我们在之前提到过。我们需要做的是应用一种技术，帮助我们保持电路的状态。是的，这听起来像是纠错定义，但让我花点时间来详细说明，以便识别其中的区别。为此，我将解释一个新添加到Qiskit中的Pass（回想一下，Pass是一个用于优化电路的对象，例如找到最优布局映射或最优量子比特）。这个Pass叫做**动态去耦**（**DD**）。动态去耦是一种已知的技巧，由麻省理工学院的Dr.
    Seth Lloyd和Dr. Lorenza Viola在1998年描述（[https://arxiv.org/abs/quant-ph/9803057](https://arxiv.org/abs/quant-ph/9803057)）。他们将其描述为一种使用控制脉冲来最小化量子比特状态扩散的形式。这通常是通过应用相同的门操作两次来完成的，这模仿了一个恒等门。我们之前在解释大多数通用量子门都是可逆的时候了解到这一点，因此通过连续应用两个可逆门，你最终会得到一个恒等门。那么，这是如何工作的呢？你问得好，下面我们就来探讨一下！
- en: If you recall from *Chapter 7*, *Programming with Qiskit*; *Understanding pulses,
    and Pulse Library* section when we described that when running your circuit on
    a quantum computer, you must first create a pulse schedule, which is what dictates
    to the control systems the pulses to the qubits by following the pulse schedule
    in order. You may also recall that the pulse schedule includes information regarding
    the pulse, but also the duration of the pulse and the time gaps in between pulses.
    Luckily for us, we learned that all of this is done for us with the Transpiler
    and the `PassManager`. Once the pulse schedule is created to run on the specific
    quantum system, the Dynamical Decoupling Pass takes a run through it before running
    on the system. What the DD Pass looks for is idle time gaps between pulse signals,
    and it inserts a sequence of gates into those gaps. Remember that since the gates
    are reversible and we do not want to alter the state or phase of the circuit,
    it will apply a pair of gates to ensure that it sustains the action of a unitary
    gate. Let’s go to the code and see this in action to get a better idea.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得*第7章*，*使用Qiskit编程*；*理解脉冲和脉冲库*部分，当我们描述在量子计算机上运行你的电路时，你必须首先创建一个脉冲时序，这是通过按照脉冲时序的顺序来指导控制系统向量子比特发送脉冲的。你可能也记得，脉冲时序包括有关脉冲的信息，但还包括脉冲的持续时间以及脉冲之间的时间间隔。幸运的是，我们了解到所有这些都有Transpiler和`PassManager`为我们完成。一旦创建了在特定量子系统上运行的脉冲时序，动态去耦Pass就会在系统运行之前遍历它。DD
    Pass寻找的是脉冲信号之间的空闲时间间隔，并在这些间隔中插入一系列门。记住，由于门是可逆的，我们不希望改变电路的状态或相位，因此它将应用一对门来确保它持续执行一个幺正门的作用。让我们看看代码，看看这是如何实现的，以便更好地理解。
- en: First, we’ll import some of the objects and functions we need to get started.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将导入一些我们需要开始工作的对象和函数。
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s go over what we are importing here. First, from the Transpiler, we’re
    pulling in `PassManager` and `InstructionDurations`. `PassManager` is what manages
    the Passes used to optimize our quantum circuits during transpilation. `InstructionDurations`
    is basically just that; it stores the durations of all the gates, timescales (dt),
    to the selected backend system. Let’s pull the durations for a random backend
    system to try this out. Check which backends are availale as the systems may change
    over time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在这里导入的内容。首先，从Transpiler中，我们引入了`PassManager`和`InstructionDurations`。`PassManager`是用来管理在编译过程中优化我们的量子电路所使用的Pass的。`InstructionDurations`基本上就是那样；它存储了所有门的持续时间、时间尺度（dt）到所选后端系统。让我们拉取一个随机后端系统的持续时间来尝试一下。检查哪些后端可用，因为系统可能会随时间而变化。
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is a truncated example of the outputs, in this case the X gates.
    Since `ibm_kyoto` is a 127-qubit device, we see that the durations shown are indexed
    to identify the duration time for the x-gate and its corresponding qubit. Note
    that the actual results will be a list of all gate durations between all qubits;
    the following is just a subset of the results:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个输出截断的示例，在这种情况下是X门。由于`ibm_kyoto`是一个127量子比特的设备，我们看到显示的持续时间是按索引排列的，以识别x门及其对应量子比特的持续时间。请注意，实际结果将是所有量子比特之间所有门持续时间的一个列表；以下只是结果的一个子集：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Qiskit also provides you with the ability to set the durations yourself for
    each gate. This allows you to have a bit more control should you want to modify
    them for specific devices. The following illustrates how to do this for all gates:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit还为你提供了为每个门设置持续时间的能力。这允许你在需要为特定设备修改它们时拥有更多控制权。以下是如何为所有门执行此操作的说明：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we have set the following custom duration times for each gate:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为每个门设置了以下自定义持续时间：
- en: '| **Gate** | **Duration** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **门** | **持续时间** |'
- en: '| x | 100 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| x | 100 |'
- en: '| h | 100 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| h | 100 |'
- en: '| cx[0,1] | 200 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| cx[0,1] | 200 |'
- en: '| cx[1,2] | 200 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| cx[1,2] | 200 |'
- en: '| cx[2,3] | 200 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| cx[2,3] | 200 |'
- en: '| measure | 500 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| measure | 500 |'
- en: 'Table 10.1: Custom gate duration times'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1：自定义门持续时间
- en: Next, we will visualize the circuit duration in a nice timeline. To visualize
    the circuit and its timeline, we will need to transpile the circuit using a *scheduling
    method* to a backend. A scheduling method is how the `transpiler` will schedule
    the operations to the qubits, for example, as soon as possible when the qubit
    is ready for the next instruction, or you can have it scheduled for later, which
    basically keeps the qubit in the ground state when possible. For these examples,
    we will use the **alap** scheduling method, which is an acronym for *as late as
    possible*. You can find details about the various scheduling methods in the Qiskit
    API documentation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将以一个漂亮的时序图来可视化电路的持续时间。为了可视化电路及其时序，我们需要使用一种*调度方法*将电路编译到一个后端。调度方法是指`transpiler`如何调度操作到量子比特上，例如，当量子比特准备好下一个指令时尽可能快地进行，或者你可以将其调度到稍后，这基本上是在可能的情况下保持量子比特处于基态。在这些示例中，我们将使用**alap**调度方法，它是*尽可能晚*的缩写。你可以在Qiskit
    API文档中找到有关各种调度方法的详细信息。
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will print out a visual representation of the gate duration. It will look
    very much like the pulse schedule we learned about earlier; however, this is the
    circuit and not the pulse schedule. You can tell because we see the qubit labels
    on the left and not the drive
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出门持续时间的可视化表示。它看起来非常像我们之前学到的脉冲调度；然而，这是电路而不是脉冲调度。你可以通过我们看到左边的量子比特标签而不是驱动器来辨别。
- en: channels. Also note that CX gates have taken on the label of **ecr** in this
    case.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通道。此外，请注意，在这种情况下，CX门被标记为**ecr**。
- en: '![A screenshot of a computer  Description automatically generated](img/B18420_10_08.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B18420_10_08.png)'
- en: 'Figure 10.8: Circuit timeline visualization'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：电路时序可视化
- en: As shown in *Figure 10.8*, this is the specified duration for each gate that
    is based on the selected backend. We will use this duration to visualize some
    of the error suppression features included in Qiskit, particularly Dynamical Decoupling.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图10.8*所示，这是基于所选后端指定的每个门的持续时间。我们将使用这个持续时间来可视化Qiskit中包含的一些错误抑制功能，特别是动态去耦。
- en: The way Dynamical Decoupling works is that it will search for idle time in your
    circuit and insert a sequence of Dynamical Decoupling gates to those idle time
    slots to ensure that the qubit’s state is not altered. The pair of reversible
    gates used will operate equally to that of an Identity gate so that it does not
    alter the state of the circuit. Let’s use our custom duration times and a pair
    of X gates to create the Dynamical Decoupling sequence of reversible gates.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 动态去耦的工作方式是，它将在您的电路中寻找空闲时间，并在那些空闲时间槽中插入一系列动态去耦门，以确保量子位的状态不被改变。所使用的可逆门对将等效于恒等门，因此不会改变电路的状态。让我们使用我们的自定义持续时间和一个X门对来创建动态去耦的可逆门序列。
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What we have defined is the pair of reversible gates that mimic an Identity
    gate. In this case, we are using a pair of X gates. Then, we instantiated our
    `PassManager`, which is what manages which Passes to use to optimize our circuit
    during the transpilation phase. In this case, we are setting the `alap` scheduling
    method and Dynamical Decoupling times to the custom duration times we created
    earlier. Also included are the reversible gates as an argument to the constructor.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所定义的是模仿恒等门的可逆门对。在这种情况下，我们使用一对X门。然后，我们实例化了我们的`PassManager`，这是在编译阶段管理使用哪些Pass来优化电路的东西。在这种情况下，我们将`alap`调度方法和动态去耦时间设置为之前创建的自定义持续时间。还包括将可逆门作为构造函数的参数。
- en: 'Next, we want to run our transpiled circuit through the `PassManager` we just
    created to produce the altered circuit with the Dynamical Decoupling included:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要运行我们的编译电路通过我们刚刚创建的`PassManager`，以产生包含动态去耦的修改后的电路：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let’s visualize this circuit and compare it to the previous circuit in
    *Figure 10.9*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们可视化这个电路，并将其与上一电路中的*图10.9*进行比较：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will draw the circuit with the error suppression of the Dynamical Decoupling
    added. You can see the X gates that have been added to the first qubit, q[0].
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在添加了动态去耦错误抑制的情况下绘制电路。您可以看到添加到第一个量子位，q[0]的X门。
- en: '![A screenshot of a computer  Description automatically generated](img/B18420_10_09.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B18420_10_09.png)'
- en: 'Figure 10.9: Visualization of the Dynamical Decoupling circuit'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：动态去耦电路的可视化
- en: 'Here, we can observe a couple of things. First, that the gate durations are
    smaller due to the custom duration we set when compared to the previous circuit.
    Next, you will also note that the inserted X gates were added to the first qubit
    only, and not to the space after the second qubit, q[1]. This is because the idle
    time gap is shorter than that of the two X gates, therefore the gate pairs were
    not added. Let’s make a quick yet significant adjustment to the custom duration
    time to include a pair of X gates after the second qubit by increasing the duration
    from 50 to 1500\. Since we are only updating the value of one gate, we can just
    update the value of the gate without restating the other gates by using the `update()`
    function, as shown in the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以观察到一些事情。首先，由于我们设置的定制持续时间比之前的电路小，因此门持续时间更短。其次，您还会注意到插入的X门仅添加到第一个量子位，而没有添加到第二个量子位之后的空位，q[1]。这是因为空闲时间间隔比两个X门短，因此没有添加门对。让我们快速但显著地调整定制持续时间，通过将持续时间从50增加到1500，在第二个量子位之后包括一对X门。由于我们只更新一个门的价值，我们可以使用`update()`函数仅更新该门的价值，而无需重新声明其他门，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let’s retry and see what we get back this time. Here, we will set the
    parameters with the updated values and rerun the `PassManager` and visualize the
    results:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重试并看看这次我们得到了什么。在这里，我们将使用更新的值设置参数，重新运行`PassManager`并可视化结果：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will now produce two sets of reversible gates, one as before, and now
    a second set, which we can see after the second qubit. Since we have reduced the
    duration time, it can now fit in the idle time gap at the end of the second qubit,
    as shown in the following diagram:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将现在产生两组可逆门，一组与之前相同，现在还有另一组，我们可以在第二个量子位之后看到。由于我们已经减少了持续时间，它现在可以适应第二个量子位结束时的空闲时间间隔，如下面的图所示：
- en: '![A screenshot of a computer  Description automatically generated](img/B18420_10_10.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B18420_10_10.png)'
- en: 'Figure 10.10: Visualization of circuit with updated duration times'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：更新持续时间后的电路可视化
- en: As *Figure 10.10* illustrates, we can set the duration time of each gate. In
    this case, we increased the duration so we can see the changes. However, in many
    cases you need to reduce it to try to squeeze in our reversible gates to fill
    in the idle time gaps as needed. But, of course, like anything else, we do not
    necessarily need to do all this fine tuning ourselves. Thankfully for us, the
    Qiskit Runtime includes optimization and **resilience levels** that we can set
    to enable these features for us, as described earlier in this chapter when we
    discussed the various optimization levels we can set in the Options, which include
    enabling Dynamical Decoupling.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图10.10*所示，我们可以设置每个门的持续时间。在这种情况下，我们增加了持续时间，以便我们可以看到变化。然而，在许多情况下，你需要将其减少，以便尝试将可逆门挤入空闲时间间隙，以满足需要。但是，当然，就像其他任何事情一样，我们并不一定需要自己进行所有这些精细调整。幸运的是，Qiskit运行时包括优化和**弹性级别**，我们可以设置这些级别以启用这些功能，正如本章前面在讨论我们可以在选项中设置的各个优化级别时所述，其中包括启用动态去耦。
- en: Now that we have covered an example of error suppression, let’s continue and
    look at error mitigation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一个错误抑制的例子，让我们继续并看看误差缓解。
- en: 'First, before we begin defining what **error mitigation** is, let me cover
    what **error correction** is and how it is different. Error correction in general
    is composed of two steps: first identifying that an error has occurred and second,
    correcting that error using various error correcting techniques. Error mitigation
    on the other hand uses the errors to calculate and determine an outcome that reduces
    yet does not necessarily eliminate the error itself.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们开始定义什么是**误差缓解**之前，让我先介绍一下什么是**错误纠正**以及它们之间的区别。一般来说，错误纠正包括两个步骤：首先识别出错误已经发生，其次，使用各种错误纠正技术来纠正这个错误。而另一方面，误差缓解则是利用错误来计算和确定一个结果，这个结果可以减少错误，但并不一定消除错误本身。
- en: 'There are various error mitigating techniques, and much research is still ongoing
    to find more optimal ways to reduce errors. At the time of writing, three techniques
    are used to mitigate errors that are included into the Qiskit Runtime resilience
    level options: **TREX**, **ZNE**, and **PEC**. Details regarding each are linked
    earlier in this chapter, where we defined the resilience levels. Each of these
    techniques uses classical resources to perform their tasks. This of course introduces
    overhead into our application. However, there are advances released regularly
    that reduce a lot of the overhead to optimize speed, quality, and scalability.
    By continuing to do this we can surely over time reach a level of quantum utility
    that will mean the cost to implement a complex quantum circuit may be substantially
    lower than that of classical simulations.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着各种误差缓解技术，并且目前还有很多研究正在进行，以寻找更优化的方法来减少错误。在撰写本文时，三种用于缓解错误并包含在Qiskit运行时弹性级别选项中的技术是：**TREX**、**ZNE**和**PEC**。关于每种技术的详细信息，请参考本章前面的链接，其中我们定义了弹性级别。这些技术中的每一种都使用经典资源来执行其任务。这当然会给我们的应用程序引入额外的开销。然而，定期发布的进步大大减少了这些开销，以优化速度、质量和可扩展性。通过持续这样做，我们肯定会在未来达到一个量子效用水平，这意味着实现复杂量子电路的成本可能会比经典模拟低得多。
- en: Thankfully, again, Qiskit makes it easy for us to set the levels of error mitigation
    using the resilience levels to activate specific error mitigation techniques.
    In the following code snippet, we will run a circuit first without any error suppression
    or mitigation techniques, and then we will create one that will use Dynamical
    Decoupling for error suppression and TREX for error mitigation.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Qiskit使我们能够通过弹性级别轻松设置误差缓解的级别，以激活特定的误差缓解技术。在下面的代码片段中，我们首先运行一个没有错误抑制或缓解技术的电路，然后我们将创建一个使用动态去耦进行错误抑制和TREX进行误差缓解的电路。
- en: 'We’ll start with no error suppression or mitigation:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从没有错误抑制或缓解开始：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The results are as follows when running the Sampler, and you should see a visual
    representation of the results as well:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Sampler的结果如下，你应该也能看到结果的视觉表示：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we will enable both Dynamical Decoupling and TREX:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将启用动态去耦和TREX：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we set the `optimization_level` to `3`, which will enable Dynamical Decoupling,
    and the `resilience_level` to `1`, which uses TREX for error mitigation. Note
    the difference in the results are much more refined and the metadata includes
    the added overhead and mitigation time:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`optimization_level`设置为`3`，这将启用动态去耦，并将`resilience_level`设置为`1`，这使用TREX进行错误缓解。注意结果差异更加精细，并且元数据包括增加的开销和缓解时间：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This and many other error suppression and mitigation methods are increasing
    in popularity among researchers as they try to understand the effects of noise
    and determine optimal ways to mitigate against them in the hopes of accelerating
    our path from quantum utility towards quantum advantage.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 随着研究人员试图了解噪声的影响并确定减轻噪声的最佳方法，以加速我们从量子效用走向量子优势的进程，许多错误抑制和缓解方法在研究人员中越来越受欢迎。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some of the many effects that noise has on a quantum
    computing system, both specific to the qubit and externally with respect to the
    quantum system itself via readout errors. We discovered how we can use the Qiskit
    Runtime service to run our circuits using the fundamental building blocks known
    as Primitives. Finally, we learned how to apply error suppression and mitigation
    techniques to our quantum circuits so to filter the noisy results from a quantum
    device, which significantly reduces errors and provides more accurate results
    to complex quantum circuits.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了噪声对量子计算系统的影响，包括量子比特的特定影响以及通过读出错误与量子系统本身的相对外部影响。我们发现了如何使用 Qiskit 运行时服务通过称为原语的基本构建块来运行我们的电路。最后，我们学习了如何将错误抑制和缓解技术应用于我们的量子电路，以从量子设备中过滤出噪声结果，这显著减少了错误并提供了更准确的复杂量子电路结果。
- en: In the next chapter, we will learn how to create quantum applications using
    the many features available in Qiskit. We will look at creating quantum algorithms,
    and ultimately provide you with all the tools you need to create your own quantum
    algorithms and quantum applications.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 Qiskit 中提供的众多功能来创建量子应用程序。我们将探讨创建量子算法，并最终为您提供创建自己的量子算法和量子应用程序所需的所有工具。
- en: Questions
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: List the three main error mitigation techniques used by the Qiskit Runtime service.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出 Qiskit 运行时服务使用的三种主要错误缓解技术。
- en: Which resilience levels are used for error mitigation?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于错误缓解的哪些容错级别被使用？
- en: What other reversible gates could you use to fill in the idle time of a qubit
    using Dynamical Decoupling?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用哪些可逆门来使用动态去耦填充量子比特的空闲时间？
- en: Which type of noise contributes to amplitude dampening of a qubit?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种类型的噪声会导致量子比特振幅衰减？
- en: Which type of noises contribute to dephasing of a qubit?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种类型的噪声会导致量子比特去相干？
- en: Further reading
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'IBM Quantum Learning platform: [https://learning.quantum.ibm.com](https://learning.quantum.ibm.com)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'IBM 量子学习平台: [https://learning.quantum.ibm.com](https://learning.quantum.ibm.com)'
- en: 'Evidence for the utility of quantum computing before fault tolerance: [https://www.nature.com/articles/s41586-023-06096-3](https://www.nature.com/articles/s41586-023-06096-3)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在容错之前量子计算实用性的证据: [https://www.nature.com/articles/s41586-023-06096-3](https://www.nature.com/articles/s41586-023-06096-3)'
- en: 'Quasi-probability decompositions with reduced sampling overhead: [https://www.nature.com/articles/s41534-022-00517-3](https://www.nature.com/articles/s41534-022-00517-3)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '减少采样开销的准概率分解: [https://www.nature.com/articles/s41534-022-00517-3](https://www.nature.com/articles/s41534-022-00517-3)'
- en: 'Dynamical suppression of decoherence in two-state quantum systems: [https://arxiv.org/pdf/quant-ph/9803057.pdf](https://arxiv.org/pdf/quant-ph/9803057.pdf)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '二态量子系统中退相干的动力学抑制: [https://arxiv.org/pdf/quant-ph/9803057.pdf](https://arxiv.org/pdf/quant-ph/9803057.pdf)'
- en: 'Error mitigation in short depth circuits: [https://arxiv.org/pdf/1612.02058.pdf](https://arxiv.org/pdf/1612.02058.pdf)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '短深度电路中的错误缓解: [https://arxiv.org/pdf/1612.02058.pdf](https://arxiv.org/pdf/1612.02058.pdf)'
- en: 'Sutor, B., *Dancing with Qubits*, Packt Publishing: [https://www.packtpub.com/data/dancing-with-qubits](https://www.packtpub.com/data/dancing-with-qubits%0D%0A)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Sutor, B., *与量子比特共舞*，Packt 出版公司: [https://www.packtpub.com/data/dancing-with-qubits](https://www.packtpub.com/data/dancing-with-qubits%0D%0A)'
- en: 'Nielsen, M. & Chuang, I., *Quantum Computation and Quantum Information*, Cambridge
    University Press: [https://www.cambridge.org/us/academic/subjects/physics/quantum-physics-quantum-information-and-quantum-computation/quantum-computation-and-quantum-information-10th-anniversary-edition](https://www.cambridge.org/us/academic/subjects/physics/quantum-physics-quantum-information-and-quantum-computation/quantum-computation-and-quantum-information-10th-anniversary-edition)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Nielsen, M. & Chuang, I., *量子计算与量子信息*，剑桥大学出版社: [https://www.cambridge.org/us/academic/subjects/physics/quantum-physics-quantum-information-and-quantum-computation/quantum-computation-and-quantum-information-10th-anniversary-edition](https://www.cambridge.org/us/academic/subjects/physics/quantum-physics-quantum-information-and-quantum-computation/quantum-computation-and-quantum-information-10th-anniversary-edition)'
- en: 'Wootton, J., *What is Quantum Error Correction?*, Medium Series: [https://decodoku.medium.com/1-what-is-quantum-error-correction-4ab6d97cb398](https://decodoku.medium.com/1-what-is-quantum-error-correction-4ab6d97cb398%0D%0A%0D%0A)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wootton, J., *什么是量子纠错？*，Medium 系列：[https://decodoku.medium.com/1-what-is-quantum-error-correction-4ab6d97cb398](https://decodoku.medium.com/1-what-is-quantum-error-correction-4ab6d97cb398%0D%0A%0D%0A)
- en: Join us on Discord
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/3FyN1](Chapter_10.xhtml)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/3FyN1](Chapter_10.xhtml)'
- en: '![](img/QR_Code261762599683826593.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code261762599683826593.png)'
