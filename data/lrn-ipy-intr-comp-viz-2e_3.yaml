- en: Chapter 3. Numerical Computing with IPython
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：使用 IPython 进行数值计算
- en: Although IPython's powerful shell and extended console can be advantageously
    used by any Python programmer, this package was originally a tool designed *for
    scientists by scientists*. It was indeed meant to provide a convenient way of
    doing *interactive scientific computing* with Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 IPython 强大的 shell 和扩展控制台可以被任何 Python 程序员充分利用，但这个软件包最初是为 *科学家设计的工具*。它的确旨在为科学计算提供一种方便的方式，进行
    *互动式科学计算*。
- en: IPython does not really provide scientific computing features *per se*, but
    rather offers an interactive interface to powerful external libraries, such as
    NumPy, SciPy, Pandas, Matplotlib, and the like. Together, these tools provide
    a framework for scientific computing, which can compete with widespread commercial
    tools in the scientific community such as Matlab or Mathematica.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 本身并不提供科学计算功能 *本身*，而是提供了一个与强大外部库（如 NumPy、SciPy、Pandas、Matplotlib 等）互动的接口。这些工具共同提供了一个科学计算框架，能够与科学界广泛使用的商业工具如
    Matlab 或 Mathematica 竞争。
- en: NumPy provides a multidimensional array object that supports optimized vector
    operations. SciPy offers a wide variety of scientific algorithms (signal processing,
    optimization, and so on) that are based on NumPy. Pandas proposes convenient data
    structures for tabular data coming from real-world data set. Matplotlib allows
    to plot graphical figures easily so as to visualize interactively any form of
    data, and to generate publication-quality figures. IPython provides the adequate
    interactive framework for using all these tools in a streamlined way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了一个支持优化向量操作的多维数组对象。SciPy 提供了多种科学算法（如信号处理、优化等），这些算法基于 NumPy。Pandas 提供了便于处理来自现实数据集的表格数据的结构。Matplotlib
    允许轻松绘制图形，从而交互式地可视化各种数据，并生成出版质量的图表。IPython 提供了一个合适的交互框架，使得使用这些工具更加高效。
- en: 'In this section, we will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将：
- en: Explore the interactive computing possibilities offered by NumPy and Pandas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 NumPy 和 Pandas 提供的互动计算可能性
- en: Understand why multidimensional arrays are well adapted to high-performance
    computations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么多维数组适合进行高性能计算
- en: See how arrays can be used in practical applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解数组如何在实际应用中使用
- en: Find some references containing more advanced examples and applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找一些包含更高级示例和应用的参考资料
- en: A primer to vector computing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量计算简介
- en: In this section we will introduce the notion of **vectorized computations**.
    It is an absolutely crucial notion since it is the easiest way to achieve high
    performance with a high-level language such as Python.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍**向量化计算**的概念。这是一个至关重要的概念，因为它是使用像 Python 这样的高级语言实现高性能的最简便方法。
- en: An example of computation with Python loops
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个使用 Python 循环进行计算的示例
- en: Today's science and engineering are all about numbers. Most data processing
    and numerical simulations are nothing else but a succession of elementary operations
    on large amounts of numerical data, and computers are extremely good at it. However,
    data has to be structured in some rational way. The generic structure of numerical
    data is that of *vectors* and *matrices*, and more generally *multidimensional
    arrays*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的科学和工程都围绕数字展开。大多数数据处理和数值模拟不过是对大量数值数据进行一系列基本操作，计算机在这方面非常擅长。然而，数据必须以某种合理的方式进行结构化。数值数据的一般结构是
    *向量* 和 *矩阵*，更一般地说是 *多维数组*。
- en: Before we explain in more detail what a numerical array is, let's take a look
    at an example motivating the introduction of these objects. Let's suppose we have
    retrieved geographical data with the coordinates (latitude and longitude) of a
    large number of locations, and we need to find the location that is the closest
    to a given position of interest. For example, we may want to find the closest
    restaurant from the GPS position of a smartphone user.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地解释什么是数值数组之前，让我们先看一个激励引入这些对象的示例。假设我们已经获取了大量位置的地理数据，包括它们的坐标（纬度和经度），并且我们需要找出最靠近给定兴趣点的位置。例如，我们可能想找出离智能手机用户
    GPS 位置最近的餐馆。
- en: 'If the positions are stored in a Python list of tuples, we can write something
    like the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些位置存储在 Python 的元组列表中，我们可以写出如下代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we loop through all positions. The variable `i` keeps the index of the
    current position, whereas `(x, y)` contains the coordinates of this position.
    The position of interest is `position=(x0, y0)`. At the first iteration, the current
    position is recorded as the best so far, and at the next iterations, the closest
    position is updated only if the current position is closer than the closest one
    so far. At the end of the loop, the index of the closest location is `ibest`,
    the corresponding position is `positions[ibest]`, and the squared distance from
    the position of interest to the closest position is in `dbest`. To compute the
    distances, we use here the squared Euclidean distance formula, *D = (x - x0)²
    + (y - y0)²*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历所有位置。变量`i`保持当前位置信息的索引，而`(x, y)`则包含该位置的坐标。我们关注的位置是`position=(x0, y0)`。在第一次迭代中，当前的位置被记录为最优位置，在接下来的迭代中，只有当前的位置比最优位置更接近时，才会更新最优位置。循环结束时，最接近位置的索引是`ibest`，对应的位置是`positions[ibest]`，而从目标位置到最接近位置的平方距离存储在`dbest`中。为了计算距离，我们使用的是平方欧几里得距离公式，*D
    = (x - x0)² + (y - y0)²*。
- en: 'This is a standard and basic algorithm. Let''s evaluate its performance on
    a large dataset. We first generate a list of 10 million random positions as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准且基础的算法。让我们在一个大型数据集上评估它的性能。我们首先生成一个包含1000万个随机位置的列表，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We defined a list named `positions` with pairs of coordinates, each number
    being a random number between zero and one. Now, let''s set some benchmark using
    the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`positions`的列表，其中包含坐标对，每个数字都是0和1之间的随机数。现在，使用以下命令设置一些基准：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This algorithm took 16.4 seconds to process 10 million positions. Let's see
    if that is close to the theoretical maximum performance of a CPU. This code was
    executed on a 2 GHz single core processor. It can theoretically process four floating
    point operations per cycle, corresponding to eight billion operations per second.
    In our algorithm, each iteration involves five mathematical operations and a comparison,
    for a total of 50 million floating point operations (taking only the mathematical
    operations into account). The theoretical maximum performance should have been
    6.25 ms. This means that our algorithm performed about 2,600 times worse than
    the theoretical maximum performance!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法处理1000万个位置用了16.4秒。我们来看看这是否接近CPU的理论最大性能。该代码是在一颗2 GHz单核处理器上执行的。理论上，它每个周期可以处理四个浮点操作，相当于每秒80亿次操作。在我们的算法中，每次迭代涉及五个数学操作和一次比较，总共50百万次浮点操作（仅计算数学操作）。理论最大性能应该是6.25毫秒。这意味着我们的算法表现比理论最大性能差了大约2600倍！
- en: Of course, this is a very naive estimation, and the theoretical maximum performance
    is always far from being reached, but a discrepancy factor of 2,600 seems particularly
    bad. Can we do better? We will find out in the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个非常粗略的估算，理论上的最大性能通常是远未达到的，但2600倍的差异显得特别严重。我们能做得更好吗？我们将在下一节中找出答案。
- en: What an array is
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组是什么
- en: 'In the previous example, the same computation (computing the distance to a
    fixed point) was performed on a lot of numbers. NumPy provides a new type that
    is perfectly adapted to this situation: the **multidimensional array**. So, what
    is an array?'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，同样的计算（计算与一个固定点的距离）在大量数字上进行。NumPy提供了一种新的类型，完美适应这种情况：**多维数组**。那么，数组是什么？
- en: An array is a block of data organized into several dimensions. A one-dimensional
    array is a vector, which is an ordered sequence of elements (typically numbers)
    that are indexed with a single integer. A two-dimensional array is a matrix, containing
    elements indexed by a pair of integers, that is, the row index and the column
    index. More generally, an *n*-dimensional array is a set of elements with the
    same data type that are indexed by a tuple of *n* integers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个组织成多个维度的数据块。一维数组是一个向量，它是一个元素（通常是数字）有序的序列，使用一个整数进行索引。二维数组是一个矩阵，包含通过一对整数索引的元素，即行索引和列索引。更一般地说，*n*维数组是一个由相同数据类型的元素组成的集合，通过一个*n*个整数的元组进行索引。
- en: '![What an array is](img/9932OS_03_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![数组是什么](img/9932OS_03_01.jpg)'
- en: Schematic of a multidimensional NumPy array
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 多维NumPy数组的示意图
- en: 'All elements in an array must have the same type: it is called the **data type**
    (`dtype`). There are multiple possible types in NumPy: Booleans, signed/unsigned
    integers, single-precision/double-precision floating point numbers, complex numbers,
    strings, and so on. Custom data types can also be defined.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的所有元素必须具有相同的类型：这称为**数据类型**（`dtype`）。NumPy 中有多种可能的类型：布尔值、带符号/无符号整数、单精度/双精度浮点数、复数、字符串等。还可以定义自定义数据类型。
- en: Elements in an array are stored internally in a contiguous block of memory.
    For example, the elements in a vector of size 10 possess 10 consecutive memory
    addresses. When the dimension of the array is two or more, there is more than
    a unique choice for the ordering of the elements. For a matrix, the elements can
    be stored in **row-major order** (also known a **C-order**)or **column-major order**
    (also known as **Fort** **an-order**),depending on which index among the horizontal
    or vertical indexes moves the fastest as one goes along all elements in the array.
    This notion generalizes in three or more dimensions. The default order in NumPy
    is the C-order, but that can be changed when creating an array, typically with
    the `order` keyword argument.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的元素在内存中是连续存储的。例如，一个大小为 10 的向量中的元素占有 10 个连续的内存地址。当数组的维度为两维或更多时，元素的排序方式有不止一种选择。对于矩阵，元素可以按照**行主序**（也称为**C-顺序**）或**列主序**（也称为**Fortran-顺序**）存储，具体取决于在遍历数组中的所有元素时，横向或纵向索引中哪个索引的变化最快。这个概念在三维或更多维度中得以推广。NumPy
    中的默认顺序是 C-顺序，但在创建数组时可以通过 `order` 关键字参数更改这一顺序。
- en: '![What an array is](img/9932OS_03_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![什么是数组](img/9932OS_03_02.jpg)'
- en: Difference between row-major and column-major order in multidimensional arrays
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组中行主序和列主序的区别
- en: This notion can be extended to any number of dimensions. The **stride** defines
    the number of steps in each dimension that are made as one goes through all elements.
    NumPy handles all these low-level details automatically and provides convenient
    ways of creating, manipulating, and computing on these arrays. Most of the time,
    we do not need to bother about these details and we can think about our variables
    as multidimensional arrays. However, knowing how things work internally allows
    us to fix certain bugs and to optimize some portions of the code that involve
    very large arrays.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念可以扩展到任意维度。**步幅**定义了在每个维度中随着遍历所有元素所需的步数。NumPy 自动处理所有这些底层细节，并提供了方便的方式来创建、操作和计算这些数组。大多数时候，我们不需要关心这些细节，可以把我们的变量当作多维数组来思考。然而，了解内部工作原理可以帮助我们修复某些错误，并优化涉及非常大数组的代码部分。
- en: The advantage of arrays compared with native Python types is that it is possible
    to perform very efficient computations on arrays instead of relying on Python
    loops. The difference is that the loop is implemented internally in C by NumPy
    instead of Python, so that there is no longer the cost of interpretation within
    the loop. Indeed, Python being an interpreted, dynamically-typed language, each
    iteration involves various low-level operations performed by Python (type checking
    and so on). Those operations generally take negligible time, but they become noxious
    to performance when they are repeated millions of times.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数组相比于原生 Python 类型的优势在于，可以对数组执行非常高效的计算，而不是依赖于 Python 循环。区别在于，循环是在 NumPy 中以 C
    语言实现的，而不是用 Python，这样就没有了在循环中解释的开销。实际上，由于 Python 是一种解释型、动态类型语言，每次迭代都会涉及 Python
    执行的多种低级操作（如类型检查等）。这些操作通常消耗的时间很小，但当它们重复执行数百万次时，它们会对性能产生不良影响。
- en: In addition, modern CPUs implement vectorized instructions (SSE, AVX, XOP, and
    so on) that use large registers (128 bits or 256 bits) and can contain several
    single-precision or double-precision floating points. If NumPy is compiled with
    the adequate options, array computations can benefit from these vectorized CPU
    instructions and can be more than two or four times faster.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现代 CPU 实现了矢量化指令（SSE、AVX、XOP 等），这些指令使用大寄存器（128 位或 256 位），可以包含多个单精度或双精度浮点数。如果
    NumPy 使用适当的选项进行编译，数组计算可以利用这些矢量化 CPU 指令，从而比原来快两倍或四倍以上。
- en: These are the main reasons why vectorized computations with NumPy can potentially
    be much more efficient than Python loops. One refers to the **Single Instruction,
    Multiple** **Data** (**SIMD**) paradigm of computation, since the same computation
    is performed on multiple items in an array operation with NumPy. We will demonstrate
    this with the help of our previous example.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用NumPy进行向量化计算可能比Python循环更高效的主要原因之一。这与**单指令，多数据**（**SIMD**）计算范式有关，因为在NumPy的数组操作中，多个元素会同时执行相同的计算。我们将通过之前的示例来演示这一点。
- en: Reimplementing the example with arrays
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组重新实现示例
- en: 'Let''s rewrite our example using arrays. First, we need to import NumPy. In
    IPython, we can use the `%pylab` magic command (or start IPython with `ipython
    --pylab`), which loads NumPy and Matplotlib within the interactive namespace (available
    as `np` for `numpy` and `plt` for `matplotlib.pyplot`). It is the most convenient
    way of using NumPy in an IPython interactive session. The other possibility is
    to import NumPy with `import numpy` (or `import numpy as np` for the lazy ones)
    or `from numpy import *`. The former syntax is to be preferred in a script, while
    the latter can be used in an interactive session. Here, and in all the following
    chapters, we will always assume that the `pylab` mode has been activated as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用数组重新编写我们的示例。首先，我们需要导入NumPy。在IPython中，我们可以使用`%pylab`魔法命令（或者通过`ipython --pylab`启动IPython），该命令会在交互式命名空间中加载NumPy和Matplotlib（NumPy为`np`，Matplotlib.pyplot为`plt`）。这是在IPython交互式会话中使用NumPy的最便捷方法。另一种方法是通过`import
    numpy`导入NumPy（或者对于懒人来说使用`import numpy as np`）或使用`from numpy import *`。前者语法更适合脚本使用，而后者可以在交互式会话中使用。在此，以及所有后续章节中，我们将始终假定已激活`pylab`模式，如下所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, we need to generate some random data. NumPy provides an efficient way
    of doing this as shown in the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要生成一些随机数据。NumPy提供了一种高效的方法来完成这一点，具体命令如下：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `positions` array is a two-dimensional array with 10 million rows and two
    columns containing independent uniform random numbers between zero and one. We
    note that we do not use a `for` loop for the array creation. Loops should be avoided
    every time it is possible to use a NumPy operation instead. Let''s look at some
    properties of this object as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`positions`数组是一个二维数组，包含1000万行和两列，列中是介于零和一之间的独立均匀随机数。我们注意到，在数组创建过程中，我们没有使用`for`循环。每当可以使用NumPy操作时，都应该避免使用循环。让我们看看这个对象的一些属性：'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `shape` attribute contains the array shape as a tuple of integers. Other
    important attributes of an array include:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`shape` 属性包含数组形状，以整数元组的形式表示。数组的其他重要属性包括：'
- en: '`ndim`: The number of dimensions, which is also `len(positions.shape)`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ndim`：维度的数量，也就是`len(positions.shape)`'
- en: '`size`: The total number of elements (the product of all values in `positions.shape`)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`：元素的总数（即`positions.shape`中所有值的乘积）'
- en: '`itemsize`: The size in bytes of each element (four for an `int32` data type,
    eight for `float64`, and so on)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itemsize`：每个元素的字节大小（`int32`数据类型为四字节，`float64`为八字节，以此类推）'
- en: 'Now, we will compute the squared distance of each position to our position
    of interest in two steps. We first enter the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将分两步计算每个位置到我们感兴趣位置的平方距离。我们首先输入以下命令：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, `x` and `y` contain the *x* and *y* coordinates of all positions. Indeed,
    the variable `positions[:,0]` refers to the first column of `positions` (indexing
    is zero-based in Python). This is a special Python/NumPy syntax for indexing.
    The brackets `[]` allow to access elements from a Python-container object. Inside
    the brackets, the notation `:,0` refers to all pairs of indices with any first
    element (the colon `:`) and a second element equal to zero. Since, in NumPy, the
    first dimension always refers to the row and the second dimension to the column,
    we are precisely referring to the first column here. Similarly, `positions[:,1]`
    refers to the second column, with the *y* coordinates of all positions. The variables
    `x` and `y` are one-dimensional vectors. Let''s compute the `distances` variable
    with the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`x`和`y`包含所有位置的* x *和* y *坐标。实际上，变量`positions[:,0]`指的是`positions`的第一列（在Python中，索引是从零开始的）。这是Python/NumPy中特殊的索引语法。方括号`[]`用于访问Python容器对象中的元素。方括号内的`:,0`表示所有索引对，其中第一个元素可以是任何值（冒号`:`），第二个元素等于零。由于在NumPy中，第一维始终指的是行，第二维指的是列，因此我们这里准确地指的是第一列。同理，`positions[:,1]`指的是第二列，其中包含所有位置的*
    y *坐标。变量`x`和`y`是二维向量。我们可以通过以下命令计算`distances`变量：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we compute the vector of distances from the position of interest (0.5,
    0.5) to all positions. Indeed, the `x - .5` expression subtracts 0.5 from all
    elements in the first column of positions. The reason is that `x` is a one-dimensional
    vector with 10 million elements, and `0.5` is simply a floating point number.
    The convention in NumPy follows the mathematical convention in vector calculus,
    that is, the subtraction is performed on all elements in the array.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们计算了从感兴趣位置（0.5, 0.5）到所有位置的距离向量。事实上，`x - .5`表达式将0.5从所有位置的第一列元素中减去。原因是`x`是一个包含1000万元素的一维向量，而`0.5`只是一个浮点数。NumPy的约定遵循向量微积分中的数学约定，也就是说，减法会对数组中的所有元素进行操作。
- en: In the same way, `(x - .5) ** 2` computes the square of all elements in the
    vector appearing inside the parentheses. Finally, the `+` operator performs the
    point-wise operations of two 10 milion-long vectors.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`(x - .5) ** 2`计算了括号内向量中所有元素的平方。最后，`+`运算符对两个1000万长的向量执行逐点操作。
- en: 'We see that NumPy allows to perform vector operations with a really simple
    syntax. Computing with arrays is a very specific way of programming and requires
    some time to master. It is quite different to the standard sequential way of programming
    in most languages, but it is far more efficient in Python, as we can see in the
    following commands:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，NumPy允许通过非常简单的语法执行向量运算。使用数组进行计算是一种非常特定的编程方式，需要一些时间才能掌握。它与大多数语言中标准的顺序编程方式有很大的不同，但在Python中，它效率更高，正如我们在以下命令中所看到的：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When computing the `distances` variable again with the `%timeit` magic function,
    we find that the computation is much faster than the pure Python version. Even
    if we add the computation of the smallest element, which is also easy with NumPy,
    we still find a total time that is *30 times faster than the pure Python version*,
    as shown in the following commands:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次使用`%timeit`魔法函数计算`distances`变量时，我们发现计算速度比纯Python版本快得多。即使我们添加了最小元素的计算，这在NumPy中也很容易实现，我们仍然发现总时间是*比纯Python版本快30倍*，如以下命令所示：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In conclusion, the *raison d'être* of multidimensional arrays is to avoid Python
    loops as much as possible when performing numerical computations on large amounts
    of data. Vectorizing computations in an algorithm can sometimes be difficult,
    but it is always worth it in terms of performance improvement.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，多维数组的*raison d'être*是尽可能避免在大数据量的数值计算中使用Python循环。将计算向量化有时可能比较困难，但从性能提升的角度来看，始终是值得的。
- en: Creating and loading arrays
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和加载数组
- en: In this section, we will see how we can create and load arrays either from scratch
    or from existing data. This is the first step when analyzing data with Python.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何从头开始或从现有数据中创建和加载数组。这是用Python分析数据的第一步。
- en: Creating arrays
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数组
- en: There are several ways of creating an array. We will review them in this section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以创建数组。在本节中，我们将回顾它们。
- en: From scratch, element by element
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从头开始，逐个元素
- en: 'First, we can create an array by manually specifying its coefficients. This
    is the most direct way of creating an array, but it is not used very often in
    practice. The NumPy function `array` takes a list of elements and returns a corresponding
    NumPy array, as shown in the following example (the `pylab` mode of IPython needs
    to be activated):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以通过手动指定其系数来创建一个数组。这是创建数组的最直接方式，但在实际中并不常用。NumPy的`array`函数接受一个元素列表并返回一个对应的NumPy数组，如下所示（需要激活IPython的`pylab`模式）：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we create a one-dimensional array (that is, a vector) with three 32-bit
    integers (the default type of integers on 32-bit systems). The data type of the
    created array is automatically inferred from the elements provided in `array`.
    We can force the data type with the `dtype` keyword argument as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个一维数组（即向量），包含三个32位整数（在32位系统中，整数的默认类型）。创建的数组的数据类型是根据`array`中提供的元素自动推断的。我们可以通过`dtype`关键字参数强制指定数据类型，如下所示：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To create to-dimensional arrays (matrices), we need to provide a nested list
    of lists, each inner list containing one row, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建二维数组（矩阵），我们需要提供一个嵌套的列表，每个内层列表包含一行，如下所示：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To create an *n*-dimensional array, we need to provide a nested list of lists
    of lists with *n* levels of recursion. For example, let''s create a multiplication
    table using two nested Python lists comprehensions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 *n* 维数组，我们需要提供一个具有 *n* 层递归的嵌套列表。举例来说，我们可以使用两个嵌套的 Python 列表推导式来创建一个乘法表：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This function takes the table size as a parameter, and creates the multiplication
    table as an array from a list of rows, as shown in the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将表格大小作为参数，并从行列表中创建乘法表数组，如以下示例所示：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will see later more efficient ways of creating this multiplication table.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将看到更高效的创建此乘法表的方法。
- en: From scratch, using predefined templates
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从头开始，使用预定义模板
- en: 'Creating arrays by specifying the individual coefficients manually is rarely
    practical. One can use any of the several convenient functions defined in NumPy
    to create typical arrays with the desired shape. For example, to create a vector
    filled with 100 zeros, we can use the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 手动指定每个系数来创建数组通常不太实用。可以使用 NumPy 中定义的多种便捷函数来创建具有所需形状的典型数组。例如，要创建一个填充 100 个零的向量，可以使用以下命令：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To create a 2D matrix, we need to provide a tuple with the desired shape as
    an argument, hence the double parentheses in the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 2D 矩阵，我们需要提供一个包含所需形状的元组作为参数，因此以下命令中使用了双括号：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The default data type is `float64`. Similarly, the `ones` function creates an
    array filled with the value `1`. The functions `identity`, `eye`, and `diag` allow
    to create diagonal matrices.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的数据类型是 `float64`。类似地，`ones` 函数创建一个填充了 `1` 的数组。函数 `identity`、`eye` 和 `diag`
    用于创建对角矩阵。
- en: 'There are also several convenient functions that create vectors with regularly
    spaced numbers, as shown in the following example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些便捷的函数可以创建具有规律间隔数字的向量，如以下示例所示：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we create a vector of numbers linearly spaced between `2` and `10` with
    a step of two. Note that the first number is *included* (the first `2`), but the
    last number in the sequence (`10`) is *excluded*. This is a general convention
    in Python that is actually more intuitive than what it looks like. Another related
    function is `linspace`, which is similar to `arange`, except that the *size* of
    the output vector, and not the step, is provided as a third argument. This time,
    the first and last elements of the sequence are included.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个从 `2` 到 `10` 之间按步长为 2 线性间隔的数字向量。请注意，第一个数字是 *包括* 在内的（第一个 `2`），但序列中的最后一个数字（`10`）是
    *排除* 在外的。这是 Python 中的一个通用约定，实际上比它看起来的更直观。另一个相关的函数是 `linspace`，它与 `arange` 类似，只不过输出向量的
    *大小*，而不是步长，是作为第三个参数提供的。这一次，序列的第一个和最后一个元素都会被包括在内。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Function signatures**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数签名**'
- en: The function signatures, including the parameter order and the list of keyword
    arguments, can be obtained in IPython with `?` or `help()`. In addition, in the
    Qt console and in the notebook, typing `linspace(` will automatically open a tooltip
    with `linspace(` function's signature. The tooltip can then be expanded by pressing
    *Tab*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPython 中，可以通过 `?` 或 `help()` 获取函数签名，包括参数顺序和关键字参数列表。此外，在 Qt 控制台和笔记本中，输入 `linspace(`
    会自动弹出 `linspace(` 函数的签名提示框。然后，可以通过按 *Tab* 键展开该提示框。
- en: From random values
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从随机值生成
- en: 'NumPy provides various random sampling routines for generating arrays with
    independent random values following different probability distributions. For example,
    to create a 2 x 5 array with random floating numbers uniformly sampled between
    `0` and `1`, we can use the `rand` function as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了多种随机采样方法，用于生成具有不同概率分布的独立随机值数组。例如，要创建一个 2 x 5 的数组，里面的随机浮点数均匀分布在 `0`
    和 `1` 之间，可以使用 `rand` 函数，如下所示：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice the absence of double parentheses when specifying the shape of the array
    in `rand` (NumPy oddity).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `rand` 中指定数组形状时没有使用双括号（NumPy 的一个特性）。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Number formatting in IPython**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPython 中的数字格式化**'
- en: The way numbers are displayed in IPython can be specified with the `%precision`
    magic command. For example, to display exactly three decimals for floating point
    numbers, we can type `%precision 3` in IPython. Actually, any formatting string
    can be provided, as explained in the documentation %`precision?`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `%precision` 魔法命令指定在 IPython 中显示数字的方式。例如，要将浮点数显示为精确到三位小数，可以在 IPython 中输入
    `%precision 3`。实际上，可以提供任何格式化字符串，具体请参见文档 %`precision?`。
- en: Other functions include `randn` (random values sampled from a Gaussian distribution),
    `randint` (random integers), `exponential` (exponential distribution), and so
    on. Related functions include `shuffle` and `permutation`, which randomly permute
    existing arrays.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 其他函数包括`randn`（从高斯分布中采样的随机值）、`randint`（随机整数）、`exponential`（指数分布）等。相关函数包括`shuffle`和`permutation`，它们随机排列现有的数组。
- en: Loading arrays
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载数组
- en: The main interest of the array structure is the possibility to load existing
    data from Python or from an external source. NumPy provides efficient and convenient
    ways of loading multidimensional arrays from text (Python strings or text/CSV
    files) or from binary buffers or files. In addition, the Pandas package is particularly
    useful when loading tabular data, that is, tables that contain heterogeneous data
    types instead of just numbers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数组结构的主要兴趣在于能够从Python或外部源加载现有数据。NumPy提供了高效便捷的方式来从文本（Python字符串或文本/CSV文件）或二进制缓冲区或文件中加载多维数组。此外，Pandas包在加载表格数据时尤为有用，即包含异构数据类型的表格，而不仅仅是数字。
- en: From a native Python object
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从原生Python对象
- en: It is quite common to have data in some native Python object and to want to
    convert it into a NumPy array. The standard method is to use the `array` function.
    When we created arrays by directly specifying their values, we actually converted
    Python lists of numbers into arrays.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 数据常常以某种原生Python对象的形式存在，我们希望将其转换为NumPy数组。标准方法是使用`array`函数。当我们通过直接指定值来创建数组时，我们实际上是将Python数字列表转换为了数组。
- en: From a buffer or an external file
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从缓冲区或外部文件
- en: 'Another common way of creating an array is to load data from a memory buffer
    or from a file, with either binary or string elements. From a Python buffer object,
    which we know the exact data type of, we can obtain a NumPy array with the function
    `frombuffer`. Similarly, the `fromstring` function accepts either ASCII text with
    values separated by any delimiter or binary data in any data type, as shown in
    the following example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组的另一种常见方式是从内存缓冲区或文件中加载数据，无论是二进制数据还是字符串元素。从一个Python缓冲区对象（我们知道它的确切数据类型）中，我们可以使用`frombuffer`函数获得一个NumPy数组。同样，`fromstring`函数接受ASCII文本，值由任意分隔符分隔，或者接受任何数据类型的二进制数据，如下例所示：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The functions `fromfile`, `loadtxt`, and `genfromtxt` allow to load data from
    text files or binary files and convert them into NumPy arrays. The function `loadtxt`
    is a simplified version of `genfromtxt`, useful when the file format is straightforward.
    The `fromfile` function is highly efficient with binary data. For example, to
    import data contained in the text files of the Facebook dataset, we can enter
    the following commands:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromfile`、`loadtxt`和`genfromtxt`函数允许从文本文件或二进制文件加载数据，并将其转换为NumPy数组。`loadtxt`函数是`genfromtxt`的简化版本，适用于文件格式简单的情况。`fromfile`函数在处理二进制数据时效率很高。例如，要导入Facebook数据集的文本文件中的数据，我们可以输入以下命令：'
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, saving arrays in files is as easy as loading NumPy arrays. There are
    basically two functions, `save` and `savetxt`, which save an array into a binary
    and text file, respectively. Relatedly, the `loadz` and `savez` functions are
    also conveniently used to save *dictionaries* of variables of any type (including
    NumPy arrays). All these functions use platform-independent file formats.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将数组保存到文件中和加载NumPy数组一样简单。基本上有两个函数，`save`和`savetxt`，分别将数组保存为二进制文件和文本文件。相关的，`loadz`和`savez`函数也非常方便，用于保存*字典*类型的变量（包括NumPy数组）。所有这些函数使用平台无关的文件格式。
- en: Using Pandas
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Pandas
- en: Pandas is another, more recent Python package that provides convenient and efficient
    ways of loading and manipulating data sets from heterogeneous sources. It is particularly
    useful when dealing with tabular data sets, in opposition to purely numerical
    data (matrices or arrays of numbers). It can handle missing values and data alignment
    issues (for example, with time series). The loaded data sets can be used with
    NumPy for efficient numerical computations. In brief, Pandas provides high-level
    access to tabular data, whereas NumPy provides lower-level access to raw homogeneous
    multidimensional arrays.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas是另一个较新的Python包，提供了便捷高效的方式来加载和操作来自异构源的数据集。它特别适用于处理表格数据集，而不是纯粹的数值数据（矩阵或数字数组）。它能够处理缺失值和数据对齐问题（例如，时间序列）。加载的数据集可以与NumPy一起用于高效的数值计算。简而言之，Pandas提供了对表格数据的高层次访问，而NumPy则提供了对原始同质多维数组的低层次访问。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The future of NumPy**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**NumPy的未来**'
- en: Travis Oliphant, the creator of NumPy, is currently working on its successor,
    Blaze. This project will unify many of the features currently offered by NumPy,
    Pandas, SciPy, Numba, Theano, and so on within a single framework.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的创始人Travis Oliphant目前正在开发它的继任者Blaze。这个项目将把NumPy、Pandas、SciPy、Numba、Theano等当前提供的许多功能统一到一个框架中。
- en: Here is an example of how we can load a data set with Pandas. We will download
    and analyze a data set about a large number of cities around the world and their
    population. This data set has been created by **MaxMind** and is available for
    free from [http://www.maxmind.com](http://www.maxmind.com).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用Pandas加载数据集的一个示例。我们将下载并分析一个关于世界各地大量城市及其人口的数据集。这个数据集由**MaxMind**创建，并可以免费从[http://www.maxmind.com](http://www.maxmind.com)获得。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Online public data sets**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**在线公共数据集**'
- en: 'With the open data movement, more and more data is becoming publicly available.
    Analyzing interesting data is a good way to gain experience with the tools described
    in this book, which are particularly well adapted for this task. However, it is
    not always obvious to find good data sets online. The following are some links
    containing pointers to high quality data sets, often maintained by government
    agencies, international organizations, universities, or research institutes, and
    so on:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开放数据运动的推进，越来越多的数据变得公开可用。分析有趣的数据是使用本书中描述的工具的好方法，这些工具特别适合执行此类任务。然而，在线找到好的数据集并不总是那么显而易见。以下是一些链接，其中包含指向高质量数据集的指示，这些数据集通常由政府机构、国际组织、大学或研究机构等维护：
- en: Research-quality data sets, maintained by Hilary Mason, are available at [https://bitly.com/bundles/hmason/1](https://bitly.com/bundles/hmason/1).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Hilary Mason维护的研究质量数据集可以在[https://bitly.com/bundles/hmason/1](https://bitly.com/bundles/hmason/1)找到。
- en: Public data, maintained by Google, is available at [http://www.google.com/publicdata/](http://www.google.com/publicdata/).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Google维护的公共数据可在[http://www.google.com/publicdata/](http://www.google.com/publicdata/)上获取。
- en: Data catalogs are available at [http://datacatalogs.org/dataset](http://datacatalogs.org/dataset).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据目录可以在[http://datacatalogs.org/dataset](http://datacatalogs.org/dataset)上找到。
- en: 'We first download the ZIP file and uncompress it in a folder, as shown in the
    following commands (the ZIP file is about 40 MB large, so downloading it may take
    a while):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先下载ZIP文件并将其解压到一个文件夹中，如以下命令所示（ZIP文件约为40 MB，因此下载可能需要一些时间）：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For convenience, we can create an alias to the newly-created folder with the
    command `%bookmark citiesdata data`. Now, we are going to load the CSV file that
    has been extracted with Pandas. The `read_csv` function of Pandas can open any
    CSV file, as shown in the following commands:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们可以使用命令`%bookmark citiesdata data`创建对新建文件夹的别名。现在，我们将加载已提取的CSV文件，使用Pandas的`read_csv`函数可以打开任何CSV文件，如以下命令所示：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s explore the newly created `dat` object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探索新创建的`dat`对象：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `data` object is a `DataFrame` object, a Pandas type consisting of a two-dimensional
    labeled data structure with columns of potentially different types (like an Excel
    spreadsheet). Like a NumPy array, the `shape` attribute returns the shape of the
    table. But unlike NumPy, the `DataFrame` object has a richer structure, and, in
    particular, the `keys` method returns the names of the different columns, as shown
    in the following commands:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`对象是一个`DataFrame`对象，这是Pandas的一种类型，包含一个二维的标签化数据结构，其列可能具有不同的数据类型（如Excel电子表格）。像NumPy数组一样，`shape`属性返回表格的形状。但与NumPy不同，`DataFrame`对象具有更丰富的结构，特别是`keys`方法返回不同列的名称，如以下命令所示：'
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can see that `data` has more than three million lines and seven columns
    including the country, city, population, and geographical coordinates of each
    city. The `head` and `tail` methods allow to take a quick look at the beginning
    and the end of the table respectively. Note that, when using Pandas from the IPython
    notebook, the displayed data can be formatted as an HTML table for more convenient
    reading, as shown in the following example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`data`有超过三百万行，并且包括国家、城市、人口和每个城市的地理坐标在内的七个列。`head`和`tail`方法分别允许我们快速查看表格的开头和结尾。请注意，当在IPython笔记本中使用Pandas时，显示的数据可以格式化为HTML表格，方便阅读，如以下示例所示：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following is the example table:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例表格：
- en: '![Using Pandas](img/9932OS_03_03.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![使用Pandas](img/9932OS_03_03.jpg)'
- en: Displaying a Pandas table in the IPython notebook
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPython笔记本中显示Pandas表格
- en: We can see that some cities have **NaN** (**Not a Number**) values as populations.
    The reason is that the population is not available for all cities in the data
    set, and Pandas handles those missing values transparently.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一些城市的**NaN**（**不是数字**）值表示人口数据。原因是数据集中并不是所有城市都有可用的人口信息，Pandas 会透明地处理这些缺失值。
- en: We will see in the next sections what manipulations and computations we can
    actually perform with this data set to get useful information about it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中看到，如何使用这些数据进行操作和计算，从而获取有用的信息。
- en: Working with arrays
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作数组
- en: 'Once NumPy arrays are created or loaded, there are basically three things that
    we can do with them:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 NumPy 数组创建或加载完成，我们基本上可以做三件事：
- en: Selection
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择
- en: Manipulation
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作
- en: Computation
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算
- en: Selection
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择
- en: Selection consists of accessing one or several elements within an array. It
    can be done with NumPy or Pandas.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 选择指的是在数组中访问一个或多个元素。可以使用 NumPy 或 Pandas 来完成。
- en: Using Pandas
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Pandas
- en: 'Let''s continue with our example data opened with Pandas. Each column of the
    `data` object of `DataFrame` can be accessed through its name. In IPython, tab
    completion proposes the different columns of the data. In the following example,
    we get the names of all cities (`AccentCity` is the full name of the city, with
    uppercase characters and accents):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用之前用 Pandas 打开的示例数据。`DataFrame` 的 `data` 对象的每一列都可以通过其名称进行访问。在 IPython
    中，按下 Tab 键可以自动补全数据的不同列。以下示例中，我们获取所有城市的名称（`AccentCity` 是城市的完整名称，包含大写字母和重音符号）：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This column is an instance of the `Series` class. We can access certain rows
    using indexing. In the following example, we get the name of the 30,001th city
    (remembering that indexing is zero-based):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这一列是 `Series` 类的一个实例。我们可以使用索引访问某些行。以下示例中，我们获取第 30,001 个城市的名称（记住索引是从零开始的）：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So, we can access an element using its index. But how can we obtain a city from
    its name? For example, we would like to obtain the population and GPS coordinates
    of New York. A possibility might be to loop through all cities and check their
    names, but it would be extremely slow because the Python loops on millions of
    elements are not optimized at all. Pandas and NumPy offer a much more elegant
    and efficient way called **Boolean** **indexing**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过索引访问一个元素。但我们如何通过城市名称来获取城市数据呢？例如，我们想获取纽约的人口和 GPS 坐标。一个方法是循环遍历所有城市并检查它们的名称，但由于
    Python 对于百万级元素的循环效率很低，这种方法非常慢。Pandas 和 NumPy 提供了更优雅和高效的方式——**布尔索引**。
- en: 'There are two steps that typically occur on the same line of code. First, we
    create an array with Boolean values indicating, for each element, whether it satisfies
    a condition or not (here, whether the city name is `New York`). Then, we pass
    this array of Booleans as an index to our original array. The result is then a
    subpart of the full array with only the elements corresponding to `True`, as shown
    in the following example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在同一行代码上会执行两个步骤。首先，我们创建一个包含布尔值的数组，表示每个元素是否满足某个条件（此处为城市名称是否为 `New York`）。然后，我们将这个布尔数组作为索引传递给原始数组。结果是原数组的一个子部分，其中仅包含对应
    `True` 的元素，如以下示例所示：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The same syntax works in NumPy and Pandas. Here, we find a dozen cities named
    `New York`, but only one happens to be in the New York state. To access a single
    element with Pandas, we can use the `.ix` attribute (`ix` for index) as shown
    in the following commands:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的语法在 NumPy 和 Pandas 中都适用。在这里，我们找到了十几个名为 `New York` 的城市，但只有一个位于纽约州。要使用 Pandas
    访问单个元素，我们可以使用 `.ix` 属性（`ix` 代表索引），如下所示的命令：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using NumPy
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 NumPy
- en: 'Now, let''s turn this series object into a pure NumPy array. We go from the
    Pandas world to NumPy (keeping in mind that Pandas is built on top of NumPy).
    We will mostly work with the population count of all cities as shown in the following
    commands:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把这个系列对象转化为一个纯粹的 NumPy 数组。我们从 Pandas 世界转向 NumPy（记住，Pandas 是基于 NumPy 构建的）。我们主要处理所有城市的人口数，如以下命令所示：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `population` array is a one-dimensional vector with the populations of
    all cities (or `NaN` if the population is not available). The population of New
    York can be accessed in NumPy with basic indexing, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`population` 数组是一个一维向量，包含所有城市的人口数据（如果人口数据不可用，则为 `NaN`）。可以使用基本索引在 NumPy 中访问纽约的人口数据，如下所示：'
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s find out how many cities do have an actual population count. To do this,
    we will select all elements in the population array that have a value different
    from NaN. We can use the NumPy function `isnan` as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出哪些城市有实际的人口统计数据。为此，我们将选择人口数组中值不为NaN的所有元素。我们可以使用NumPy的`isnan`函数，如下所示：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that `~_` contains the negative values of `isnan(population)`. We find
    that there are roughly 48,000 cities, corresponding to 1.5 percent of all cities
    in this data set, which have an actual population count.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`~_`包含`isnan(population)`的负值。我们发现大约有48,000个城市，占数据集中所有城市的1.5%，这些城市有实际的人口统计数据。
- en: More indexing possibilities
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多的索引可能性
- en: More generally, indexing allows us to take any portion of an array. We saw in
    the previous section how to filter an array with a Boolean condition. We can also
    specify directly the list of indices we want to keep. For instance, if `x` is
    a one-dimensional NumPy array, `x[i:j:k]` represents a view on `x` with only those
    elements having indices between `i` (included) and `j` (excluded) with a step
    of `k`. If `i` is omitted, it is assumed to be zero. If `j` is omitted, it is
    assumed to be the length of the array in that dimension. Negative values mean
    we count from the end. Finally, the default value for `k` is one. This notation
    is also valid in multiple dimensions; for example, `M[i:j,k:l]` creates a submatrix
    view on a 2D array `M`. Also, we can use `x[::-1]` to get `x` in the reverse order.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，索引允许我们获取数组的任何部分。我们在上一节中看到过如何使用布尔条件过滤数组。我们也可以直接指定要保留的索引列表。例如，如果`x`是一个一维的NumPy数组，`x[i:j:k]`表示一个`x`的视图，只包含那些索引在`i`（包含）和`j`（不包含）之间，并且步长为`k`的元素。如果省略`i`，默认从0开始。如果省略`j`，默认到该维度数组的长度。负值表示从末尾开始计数。最后，`k`的默认值为1。这种符号在多维情况下也有效；例如，`M[i:j,k:l]`创建一个二维数组`M`的子矩阵视图。此外，我们还可以使用`x[::-1]`来反转`x`的顺序。
- en: These conventions, with `i` included and `j` excluded, are convenient when working
    with consecutive portions of an array. For example, the first and second halves
    of `x`, assuming a size `2n`, are simply `x[:n]` and `x[n:]`. In addition, the
    length of `x[i:j]` is simply `j - i`. In the end, there should not be `+1` or
    `-1` values hanging around in indices in general.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约定中，包含`i`而排除`j`，在处理数组的连续部分时非常方便。例如，假设`x`的大小为`2n`，`x`的前半部分和后半部分分别为`x[:n]`和`x[n:]`。此外，`x[i:j]`的长度就是`j
    - i`。最后，通常不应在索引中留有`+1`或`-1`的值。
- en: 'An important point to consider with array views is that they point to the same
    location in memory. So a view on a large array does not imply memory allocation,
    and changing the values of elements in the view also changes the corresponding
    values in the original array, as shown in the following example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组视图时需要考虑的一个重要点是，它们指向内存中的同一位置。因此，对一个大数组的视图并不意味着内存分配，并且在视图中更改元素的值也会更改原始数组中相应元素的值，如下例所示：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, `y` contains all elements in `x` with even indices (here, indices
    zero, two, and four). Changing the value of `y[0]` changes both `y[0]` and `x[0]`,
    since `y[0]` refers to the first element of `x`. If this behavior is unwanted,
    it is possible to force the creation of a new array with `y = x.copy()` or `y
    = array(x)`. In the latter case, it is also possible to change the data type of
    `x`, with the `dtype` keyword argument.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`y`包含`x`中所有偶数索引的元素（这里是索引0、2和4）。更改`y[0]`的值会同时更改`y[0]`和`x[0]`，因为`y[0]`指向的是`x`的第一个元素。如果不希望这种行为，可以通过`y
    = x.copy()`或`y = array(x)`强制创建一个新数组。在后者的情况下，还可以使用`dtype`关键字参数更改`x`的数据类型。
- en: 'Finally, another way of selecting a portion of an array consists in passing
    an array with explicit integer values for indices. This is called **fancy indexing**.
    If `x` is a one-dimensional vector, and `indices` is another one-dimensional vector
    (or a list) with positive integers, then `x[indices]` returns a vector containing
    `x[indices[0]]`, `x[indices[1]]`, and so on. Therefore, the length of `x[indices]`
    is equal to the length of `indices` and not the length of `x`, as shown here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，选择数组的一部分的另一种方法是传递一个包含显式整数索引值的数组。这种方式称为**花式索引**。如果`x`是一个一维向量，而`indices`是另一个包含正整数的一维向量（或列表），那么`x[indices]`会返回一个包含`x[indices[0]]`、`x[indices[1]]`等元素的向量。因此，`x[indices]`的长度等于`indices`的长度，而不是`x`的长度，如下所示：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that a given index can be repeated several times in the index array.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，给定的索引在索引数组中可以重复多次。
- en: Manipulation
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作
- en: Arrays can be manipulated and reshaped, which can sometimes be useful when performing
    vectorized computations. It is also possible to construct a new array from identical
    copies of an original array. The complete list of routines can be found in the
    NumPy reference guide at [http://docs.scipy.org/doc/numpy/reference/routines.html](http://docs.scipy.org/doc/numpy/reference/routines.html).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以被操作和重塑，这在执行矢量化计算时有时很有用。还可以通过原始数组的相同副本来构造一个新数组。所有函数的完整列表可以在NumPy参考指南中找到：[http://docs.scipy.org/doc/numpy/reference/routines.html](http://docs.scipy.org/doc/numpy/reference/routines.html)。
- en: Reshaping
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重塑
- en: 'First, the `reshape` method allows to change the shape of an array if the total
    number of elements is kept constant, as shown in the following example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`reshape`方法允许在保持总元素个数不变的情况下改变数组的形状，如以下示例所示：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It is possible to use `-1` in at most one dimension in the argument of `reshape`
    to specify that its value must be automatically inferred; for example, `x.reshape((2,
    -1))` instead of `x.reshape((2, 3))`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`reshape`的参数中，最多可以在一个维度上使用`-1`，以指定其值必须自动推断；例如，使用`x.reshape((2, -1))`，而不是`x.reshape((2,
    3))`。
- en: The number of dimensions can also be changed with `ravel` (to remove all multidimensional
    structures in an array and return a flattened vector), `squeeze` (to remove all
    single-dimensional entries from the shape of an array), and `expand_dims` (to
    insert a new axis in an array).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 维度的数量也可以通过`ravel`（移除数组中的所有多维结构并返回一个扁平化的向量）、`squeeze`（移除数组形状中的所有单维条目）和`expand_dims`（在数组中插入一个新轴）来改变。
- en: Repeating and concatenating
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复和拼接
- en: 'The `til` and `repeat` functions allow to create copies of an array, either
    by concatenating identical copies of it along a specified axis, or by copying
    every coefficient any number of times, as shown in the following example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`til`和`repeat`函数允许通过在指定轴上连接相同的数组副本，或按任何次数复制每个元素，来创建数组副本，如以下示例所示：'
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we first create an array with a vertical stack of two identical copies
    of `x`, and we create a new array with each element of `x` repeated three times.
    The second argument of repeat can also be a list `reps`, in which case the coefficient
    `x[i]` is repeated `reps[i]` times.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建一个包含两个相同`x`副本的垂直堆叠数组，然后创建一个新数组，其中`x`的每个元素重复三次。`repeat`的第二个参数也可以是一个列表`reps`，此时系数`x[i]`会重复`reps[i]`次。
- en: 'For example, let''s create a multiplication table using `reshape` and `tile`.
    The idea is to first define one row vector and one column vector with all integers
    between `1` and `n`, tile them, and multiply them, knowing that the multiplication
    occurs element-wise as shown in the following code snippet:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用`reshape`和`tile`创建一个乘法表。其思路是先定义一个包含从`1`到`n`之间所有整数的行向量和列向量，将它们拼接在一起并进行乘法运算，注意乘法是逐元素进行的，如以下代码片段所示：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s time the execution of this function using the following commands:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令来计时执行此函数：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This function is about 27 times faster than the previous version `mul1`, which
    used nested Python loops.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数比之前的版本`mul1`快约27倍，后者使用了嵌套的Python循环。
- en: Also, we can use `hstack`, `vstack`, `dstack`, or `concatenate` to join several
    arrays into a single array along the first, second, third, or any dimension, respectively.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`hstack`、`vstack`、`dstack`或`concatenate`，分别沿第一个、第二个、第三个或任意维度将多个数组连接成一个数组。
- en: 'Similarly, the `hsplit`, `vsplit`,`dsplit`, or `split` functions allow to split
    an array into several consecutive subarrays along any dimension, as shown in the
    following example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`hsplit`、`vsplit`、`dsplit`或`split`函数允许沿任意维度将数组拆分为多个连续的子数组，如以下示例所示：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The second argument of `split` is either an integer, `n`, in which case the
    array is split into *n* equal arrays, or a list with the indices where the array
    should be split (that is, the indices of the first element in each subarray except
    the first).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`split`的第二个参数是一个整数`n`，此时数组被拆分成*n*个相等的数组，或者是一个包含拆分点索引的列表（即每个子数组第一个元素的索引，除了第一个）。'
- en: Broadcasting
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广播
- en: In the previous multiplication table example, we had to repeat identical copies
    of a row and a column so that we could multiply the two arrays with identical
    shapes `(n, n)`. Actually, the `repeat` step is unnecessary, as arrays with different
    shapes can still be compatible under specific conditions; this is called **broadcasting**.
    The general rule is that *two dimensions are compatible when they are equal, or
    when one of them is 1*. For example, two arrays, `M` and `N`, of the shape `(1,
    n)` and `(n, 1)` can be multiplied together, because in the first dimension, `M`
    array's shape is `1`, whereas `N` array's shape is `1` in the second dimension.
    The dimension equal to one is transparently and silently stretched to match the
    other dimension, and this operation does not involve memory copy.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的乘法表示例中，我们不得不重复行和列的相同副本，以便能够乘以形状相同的两个数组`(n, n)`。实际上，`repeat`步骤是不必要的，因为形状不同的数组在特定条件下仍然可以兼容；这就是所谓的**广播**。一般规则是：*当两个维度相等，或其中一个维度为1时，它们是兼容的*。例如，两个形状为`(1,
    n)`和`(n, 1)`的数组`M`和`N`可以相乘，因为在第一维度中，`M`数组的形状为`1`，而在第二维度中，`N`数组的形状为`1`。维度等于1的数组会透明且默默地被扩展，以匹配另一个维度，这个操作不涉及内存复制。
- en: 'Therefore, we can get rid of the `tile` operation in the multiplication table
    example as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以像下面这样去掉乘法表示例中的`tile`操作：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following commands are used:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令被使用：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, `mul3` is about 2.6 times faster than `mul2`, and about 70 times faster
    than `mul1`! The reason is that `tile` involves array copying and memory allocation,
    whereas only multiplications happen in `mul3`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`mul3`比`mul2`快大约2.6倍，比`mul1`快大约70倍！原因在于`tile`涉及数组复制和内存分配，而`mul3`中仅仅进行乘法运算。
- en: Permuting
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排列
- en: Several functions allow to permute the axes in an array. For example, the `transpose`
    function permutes the dimensions of an array. The indices describing the permutation
    can be provided in the `axes` keyword argument.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个函数可以用于排列数组的轴。例如，`transpose`函数可以排列数组的维度。描述排列的索引可以通过`axes`关键字参数提供。
- en: Other transposition functions that may be useful include `fliplr` and `flipud`
    to flip an array in the left/right or up/down direction, `roll` to perform a circular
    permutation of the elements along a given axis, and `rot90` to rotate an array
    by 90 degrees in he counter-clockwise direction.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能有用的转置函数包括`fliplr`和`flipud`，它们分别用于在左右或上下方向翻转数组，`roll`用于沿给定轴执行元素的循环排列，以及`rot90`用于逆时针旋转数组90度。
- en: Computation
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算
- en: The whole point of creating and manipulating arrays is to perform efficient
    vectorized computations with them. The four elementary operations work between
    arrays under the condition that they have compatible shapes. In addition, a lot
    of mathematical functions are available in the vectorized form for NumPy arrays.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和操作数组的关键在于对它们进行高效的矢量化计算。四个基本操作在数组之间进行，前提是它们具有兼容的形状。此外，许多数学函数也可以以矢量化形式应用于NumPy数组。
- en: If `A` and `B` are two NumPy arrays with compatible shapes, `A + B`, `A - B`,
    `A x B`, and `A / B` are element-wise operations. In particular, when `A` and
    `B` are two-dimensional matrices, `A x B` is *not* the matrix product. The matrix
    product is rather provided by the `dot` function, which more generally computes
    the dot product of two arrays.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`A`和`B`是两个形状兼容的NumPy数组，`A + B`、`A - B`、`A x B`和`A / B`都是逐元素操作。特别地，当`A`和`B`是二维矩阵时，`A
    x B`*不是*矩阵乘积。矩阵乘积是通过`dot`函数来提供的，该函数更一般地计算两个数组的点积。
- en: Common unary operations include `-A`, `A ** x` (coefficients to power `x`),
    `abs(A)` (absolute value), `sign(A)` (an array with `-1`, `0`, or `1` depending
    on the sign of each element), `floor(A)` (floor of each element), `sqrt(A)` (square
    root), `log(A)` (natural logarithm), `exp(A)` (exponential), and a lot of other
    mathematical functions (trigonometric, hyperbolic, arithmetic functions, and so
    on).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的单目运算包括`-A`、`A ** x`（系数的`x`次幂）、`abs(A)`（绝对值）、`sign(A)`（返回数组中每个元素的符号，值为`-1`、`0`或`1`）、`floor(A)`（向下取整）、`sqrt(A)`（平方根）、`log(A)`（自然对数）、`exp(A)`（指数函数）以及其他许多数学函数（例如三角函数、双曲函数、算术函数等）。
- en: NumPy also provides functions to compute the sum (`sum`) or product (`prod`)
    of all elements in an array or in a given dimension. The `axis` keyword argument
    specifies the dimensions on which the sum is to be performed. This function returns
    an array with one dimension less than the original array.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy还提供了计算数组中所有元素或指定维度元素和（`sum`）或乘积（`prod`）的函数。`axis`关键字参数指定进行求和的维度。此函数返回一个比原数组少一个维度的数组。
- en: 'The `max` and `min` functions return the largest and lowest values in an array
    or in a given dimension. The `argmin` and `argmax` functions return the index
    of the smallest or largest element of the array. For example, continuing with
    our `cities` example we can have the following commands for the `locate` function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`max`和`min`函数返回数组或给定维度中的最大值和最小值。`argmin`和`argmax`函数返回数组中最小或最大元素的索引。例如，继续使用我们的`cities`示例，我们可以对`locate`函数执行以下命令：'
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `locate` function takes two coordinates with a position's latitude and longitude,
    and returns the closest city's name. The `argmin` function returns the index of
    the city with the smallest distance to the specified position.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`locate`函数接受两个坐标，分别是位置的纬度和经度，并返回离该位置最近的城市名称。`argmin`函数返回离指定位置最近城市的索引。'
- en: 'Finally, statistical functions such as `mean`, `median`, `std`, and `var` compute
    the mean, median, standard deviation, and variance of the elements along a given
    dimension or across the whole array. Also, the `describe` method of Pandas objects
    gives several useful statistics (including the mean, standard deviation, the 50
    percent quantile or median, and the 25 precent and 75 percent quantiles) as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，统计函数如`mean`、`median`、`std`和`var`计算给定维度或整个数组中元素的均值、中位数、标准差和方差。此外，Pandas对象的`describe`方法提供了几个有用的统计量（包括均值、标准差、50百分位数或中位数、25百分位数和75百分位数），如下所示：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Related functions that can be useful when simulating mathematical models include
    `diff` (discrete difference), `cumsum` (cumulative sum), and `cumprod` (cumulative
    product). The `diff` function allows to compute a discrete *derivative* of a signal
    (up to a scalar coefficient), whereas `cumsum` computes a discrete *indefinite
    integral* of a signal.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟数学模型时，一些相关函数可能很有用，包括`diff`（离散差分）、`cumsum`（累积和）和`cumprod`（累积积）。`diff`函数允许计算信号的离散*导数*（最多为标量系数），而`cumsum`计算信号的离散*不定积分*。
- en: Advanced mathematical processing
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级数学处理
- en: NumPy provides all necessary types and routines for doing efficient numerical
    computations with Python. SciPy is built on top of NumPy and implements a large
    variety of higher-level mathematical processing algorithms. These algorithms span
    several areas of numerical computing, such as optimization, linear algebra, signal
    processing, statistics, and the like. Also, the various **SciKits** packages (`scikit-learn`,
    `scikit-image`, and so on) are yet more advanced packages implementing highly
    specialized algorithms in specific domains (machine learning, image processing,
    and so on).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了进行高效数值计算所需的所有类型和例程。SciPy建立在NumPy之上，并实现了大量更高级的数学处理算法。这些算法涵盖了数值计算的多个领域，如优化、线性代数、信号处理、统计等。此外，各种**SciKits**包（如`scikit-learn`、`scikit-image`等）是更先进的包，实施了特定领域（如机器学习、图像处理等）中的高度专业化算法。
- en: 'We give here a short overview of the scientific computing features provided
    by SciPy and a few other packages. The full list of features can be found on the
    official reference guide: [http://docs.scipy.org/doc/scipy/reference/](http://docs.scipy.org/doc/scipy/reference/).
    Giving practical examples and applications is beyond the scope of this book, and
    the interested reader can find a wide variety of examples in the *NumPy Cookbook*,
    *Ivan Idris*, *Packt Publishing*, and *Learning SciPy for Numerical and Scientific
    Computing*, *Francisco Blanco-Silva*, *Packt Publishing*, both by Packt Publishing.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里简要概述了SciPy和其他几个包提供的科学计算功能。功能的完整列表可以在官方参考指南中找到：[http://docs.scipy.org/doc/scipy/reference/](http://docs.scipy.org/doc/scipy/reference/)。提供实际的例子和应用超出了本书的范围，感兴趣的读者可以在*NumPy
    Cookbook*、*Ivan Idris*、*Packt Publishing*和*Learning SciPy for Numerical and Scientific
    Computing*、*Francisco Blanco-Silva*、*Packt Publishing*中找到各种各样的例子，均由Packt Publishing出版。
- en: '**Linear algebra** routines are provided by the `scipy.linalg` subpackage:
    solvers of linear equations, matrix routines, eigenvalue problems, matrix decomposition,
    and so on.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性代数**例程由`scipy.linalg`子包提供：线性方程求解器、矩阵例程、特征值问题、矩阵分解等。'
- en: '**Optimization routines** are provided by the `scipy.optimize` subpackage:
    unconstrained or constrained minimization of real-valued functions, global optimization,
    curve fitting, and so on.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化例程**由`scipy.optimize`子包提供：实值函数的无约束或有约束最小化、全局优化、曲线拟合等。'
- en: '**Numerical integrators** are provided by the `scipy.integrate` subpackage.
    It can be used to solve differential equations, for example, in physics simulation
    engines.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数值积分器**由`scipy.integrate`子包提供。它可以用来解决微分方程，例如，在物理仿真引擎中使用。'
- en: '**Signal processing** algorithms are implemented in the `scipy.signal` subpackage:
    convolutions, linear filters, wavelets, and so on. The `scipy.fftpack` subpackage,
    which implements Fourier transforms routines, and the `scipy.ndimage` subpackage,
    which implements several image processing algorithms. Finally, other image processing
    packages of interest include `scikit-image`, `PIL`, and `OpenCV` (computer vision).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号处理**算法由`scipy.signal`子包实现：卷积、线性滤波器、小波变换等。`scipy.fftpack`子包实现了傅里叶变换例程，`scipy.ndimage`子包实现了若干图像处理算法。最后，其他感兴趣的图像处理包包括`scikit-image`、`PIL`和`OpenCV`（计算机视觉）。'
- en: '**Statistical routines** are provided by the `scipy.stats` subpackage: probability
    distributions, descriptive statistics and statistical tests, and so on. `SciPy.cluster`
    implements clustering algorithms that can be useful to find categories in unstructured
    data. Other statistical packages of interest include `Pandas` and `scikit-learn`
    (machine learning).'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统计例程**由`scipy.stats`子包提供：概率分布、描述性统计和统计检验等。`SciPy.cluster`实现了聚类算法，可用于在非结构化数据中找到类别。其他相关的统计包包括`Pandas`和`scikit-learn`（机器学习）。'
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we described the multidimensional array object offered by NumPy,
    and we showed how it can be used for efficient computations on numerical data
    sets. In particular, it is well adapted for loading any sort of data, and the
    Pandas package makes this task straightforward, even with complex data files.
    Using advanced algorithms is possible with IPython with the help of powerful external
    packages, such as NumPy, SciPy, and the SciKit libraries. However, this subject
    is beyond the scope of this book, and the interested reader can find a variety
    of examples in the *NumPy Cookbook, Ivan Idris, Packt Publishing* and *Learning
    SciPy for Numerical and Scientific Computing, Francisco Blanco-Silva, Packt Publishing*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们介绍了NumPy提供的多维数组对象，并展示了它如何用于对数值数据集进行高效计算。特别是，它非常适合加载任何类型的数据，Pandas包使得这项任务变得简单，即使是复杂的数据文件。使用高级算法也是可能的，借助于强大的外部包，如NumPy、SciPy和SciKit库，在IPython中进行计算。然而，这一主题超出了本书的范围，感兴趣的读者可以在*《NumPy
    Cookbook, Ivan Idris, Packt Publishing》*和*《Learning SciPy for Numerical and Scientific
    Computing, Francisco Blanco-Silva, Packt Publishing》*中找到各种实例。
- en: In the next chapter, we will present the visualization-related possibilities
    offered by IPython and Matplotlib, which are very often used in conjunction with
    NumPy for interactive visualization of data.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍IPython和Matplotlib提供的可视化相关功能，它们通常与NumPy结合使用，用于数据的交互式可视化。
