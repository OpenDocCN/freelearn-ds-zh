- en: 'Chapter 9. Analytics Study: Graph Algorithms - US Domestic Flight Data Analysis'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：分析学习：图算法 - 美国国内航班数据分析
- en: '"It is a capital mistake to theorize before one has data."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '“在没有数据之前进行理论推测是一个严重的错误。”  '
- en: – *Sherlock Holmes*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*福尔摩斯*  '
- en: In this chapter, we focus on a fundamental computer science data model called
    graphs and the different types of algorithm commonly used on them. As a data scientist
    or developer, it is very important to be familiar with graphs and quickly recognize
    when they provide the right solution to solve a particular data problem. For example,
    graphs are very well suited to GPS-based applications such as Google Maps, to
    find the best route from point A to point B, taking into account all kinds of
    parameters, including whether the user is driving, walking or taking public transport,
    or whether the user wants the shortest route or one that maximizes the use of
    highways regardless of overall distance. Some of these parameters can also be
    real-time parameters, such as traffic conditions, and the weather. Another important
    class of applications that uses graphs is social networks, such as Facebook or
    Twitter, where vertices represent individuals and edges represent relationships,
    such as *is a friend*, and *follows*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '本章我们将重点介绍一种基本的计算机科学数据模型——图，以及常用于图的各种算法。作为数据科学家或开发者，熟悉图并能迅速识别何时使用图来解决特定数据问题是非常重要的。例如，图非常适合于基于GPS的应用，如Google
    Maps，用于寻找从A点到B点的最佳路线，考虑到各种参数，包括用户是开车、步行还是乘坐公共交通工具，或者用户是否希望选择最短路径，还是最大化使用高速公路而不考虑总体距离。这些参数中的一些也可以是实时参数，如交通状况和天气。另一个使用图的应用重要类别是社交网络，如Facebook或Twitter，其中顶点代表个人，边表示关系，例如*是朋友*和*关注*。  '
- en: 'We''ll start this chapter with a high-level introduction to graphs and associated
    graph algorithms. We''ll then introduce `networkx` which is a Python library that
    makes it easy to load, manipulate, and visualize graph data structures as well
    as provide a rich set of graph algorithms. We''ll continue the discussion by building
    sample analytics that analyzes US flight data using various graph algorithms where
    airports are used as vertices and flights as edges. As always, we''ll also operationalize
    these analytics by building a simple dashboard PixieApp. We''ll finish this chapter
    by building a forecasting model applying time series techniques we''ve learned
    in [Chapter 8](ch08.xhtml "Chapter 8. Analytics Study: Prediction - Financial
    Time Series Analysis and Forecasting"), *Analytics Study: Prediction - Financial
    Time Series Analysis and Forecasting* to historical flight data.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '本章将从图论和相关图算法的高层次介绍开始。然后我们将介绍`networkx`，这是一个Python库，可以轻松加载、操作和可视化图数据结构，并提供丰富的图算法集合。接下来，我们将通过构建样本分析，使用各种图算法分析美国航班数据，其中机场作为顶点，航班作为边。像往常一样，我们还将通过构建一个简单的仪表板PixieApp来操作这些分析。最后，我们将通过建立一个预测模型，应用在[第8章](ch08.xhtml
    "第8章：分析学习：预测 - 财务时间序列分析与预测")中学到的时间序列技术，来分析历史航班数据。  '
- en: Introduction to graphs
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '图论简介  '
- en: The introduction of graphs and the associated graph theory is widely attributed
    to Leonhard Euler in 1736 when he worked on the problem of the *Seven Bridges
    of Königsberg* ([https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg](https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg)).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '图论的引入及相关理论广泛归功于1736年莱昂哈德·欧拉（Leonhard Euler），当时他研究了*哥尼斯堡七桥问题*（[https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg](https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg)）。  '
- en: The city was divided by the Pregel river which at some point formed two islands,
    and seven bridges were built according to the layout shown in the following diagram.
    The problem was to find a way for a person to walk across each and every bridge
    once and only once and come back to the starting point. Euler proved that there
    was no solution to this problem and while doing this gave birth to graph theory.
    The fundamental idea was to transform the city diagram into a graph where each
    land mass is a vertex, and each bridge is an edge that linked two vertices (that
    is, land mass). The problem was then reduced to finding a path, which is a continuous
    sequence of edges and vertices, that contains each and every bridge only once.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这座城市被普雷格尔河分开，河流形成了两座岛屿，并根据以下图示建造了七座桥。问题是找到一种方法，使一个人能够走过每座桥一次且仅一次，并回到起点。欧拉证明了这个问题没有解，并在此过程中创立了图论。其基本思路是将城市的布局转化为图，其中每块陆地是一个顶点，每座桥是连接两个顶点（即陆地）的边。问题被简化为找到一条路径，这条路径是一个包含每座桥仅一次的连续边和顶点的序列。
- en: 'The following diagram shows how Euler simplified the *Seven Bridges of Königsberg*
    problem into a graph problem:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了欧拉是如何将 *哥尼斯堡七桥问题* 简化为图论问题的：
- en: '![Introduction to graphs](img/B09699_09_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图形介绍](img/B09699_09_01.jpg)'
- en: Simplifying the Seven Bridges of Königsberg problem into a graph problem
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将哥尼斯堡七桥问题简化为图论问题
- en: 'Using a more formal definition, **graphs** are the data structures that represent
    pairwise relationships (called **edges**) between objects (called **vertices**
    or **nodes**). It is common to use the following notation to represent a graph:
    *G = (V, E)* where *V* is the set of vertices and *E* is the set of edges.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更正式的定义，**图**是表示对象之间成对关系（称为**边**）的数据结构（对象称为**顶点**或**节点**）。通常使用以下符号来表示图：*G =
    (V, E)*，其中 *V* 是顶点集，*E* 是边集。
- en: 'There are mainly two broad categories of graphs:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图的表示主要有两大类：
- en: '**Directed graphs (called digraphs)**: The order in the pairwise relationship
    matters, that is, the edge (A-B) going from vertex **A** to vertex **B** is different
    from the edge (B-A) going from vertex **B** to vertex **A**.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有向图（称为有向图）**：在成对关系中，顺序是重要的，即从顶点 **A** 到顶点 **B** 的边（A-B）与从顶点 **B** 到顶点 **A**
    的边（B-A）是不同的。'
- en: '**Undirected graphs**: The order in the pairwise relationship doesn''t matter,
    that is, edge (A-B) is the same as an edge (B-A).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无向图**：在成对关系中，顺序无关，即边（A-B）与边（B-A）是相同的。'
- en: 'The following diagram shows the representation of a sample graph both as undirected
    (edges have no arrows) and directed (edges have arrows):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了一个样本图的表示方式，既有无向图（边没有箭头），也有有向图（边有箭头）：
- en: '![Introduction to graphs](img/B09699_09_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图形介绍](img/B09699_09_02.jpg)'
- en: Graph representations
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形表示
- en: 'There are mainly two ways of representing a graph:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表示图的方式主要有两种：
- en: '**Adjacency matrix**: Represents the graph using an *n* by *n* matrix (we''ll
    call it *A*), where *n* is the number of vertices in the graph. The vertices are
    indexed using 1 to *n* integers. We use ![Graph representations](img/B09699_09_37.jpg)
    to denote that an edge exists between vertex *i* and vertex *j* and ![Graph representations](img/B09699_09_38.jpg)
    to denote that no edge exists between vertex *i* and vertex *j*. In the case of
    undirected graphs, we would always have ![Graph representations](img/B09699_09_39.jpg)![Graph
    representations](img/B09699_09_40.jpg) because the order doesn''t matter. However,
    in the case of digraphs where order matters, *A**[i,j]* may be different from
    *A**[j,i]*. The following example shows how to represent a sample graph in an adjacency
    matrix both directed and undirected:![Graph representations](img/B09699_09_03.jpg)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邻接矩阵**：使用 *n* 乘 *n* 矩阵（我们称之为 *A*）来表示图，其中 *n* 是图中顶点的数量。顶点通过 1 到 *n* 的整数进行索引。我们使用
    ![图形表示](img/B09699_09_37.jpg) 来表示顶点 *i* 和顶点 *j* 之间存在边，使用 ![图形表示](img/B09699_09_38.jpg)
    来表示顶点 *i* 和顶点 *j* 之间不存在边。在无向图的情况下，由于顺序无关，通常会有 ![图形表示](img/B09699_09_39.jpg)![图形表示](img/B09699_09_40.jpg)。然而，在有向图中，由于顺序重要，*A**[i,j]*
    可能与 *A**[j,i]* 不同。以下示例展示了如何在邻接矩阵中表示一个样本图，既适用于有向图，也适用于无向图：![图形表示](img/B09699_09_03.jpg)'
- en: Adjacency matrix representation of a graph (both directed and undirected)
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图的邻接矩阵表示（包括有向和无向图）
- en: It is important to note that the adjacency matrix representation has a constant
    space complexity which is ![Graph representations](img/B09699_09_41.jpg) where
    *n* is the number of vertices, but it has a time complexity of *O(1)* which is
    constant time to compute whether two vertices are connected with an edge between
    them. The high space complexity might be OK when the graph is dense (lots of edges)
    but could be a waste of space when the graph is sparse, in which case we might
    prefer the following adjacency list representation.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要注意的是，邻接矩阵表示法具有恒定的空间复杂度，其为 ![图表示](img/B09699_09_41.jpg)，其中 *n* 是顶点的数量，但它具有
    *O(1)* 的时间复杂度，即常数时间可以判断两个顶点是否通过边连接。当图是密集的（即边很多）时，高空间复杂度可能是可以接受的，但当图是稀疏的时，这种方式可能会浪费空间，在这种情况下，我们可能会更倾向于使用下面的邻接表表示法。
- en: Note
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: The big O notation ([https://en.wikipedia.org/wiki/Big_O_notation](https://en.wikipedia.org/wiki/Big_O_notation))
    is commonly used in code analysis to represent the performance of an algorithm
    by evaluating its behavior as the input size grows. It is used both for evaluating
    running time (number of instructions needed to run the algorithm) and space requirements
    (how much storage will it need over time).'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**：大 O 符号（[https://en.wikipedia.org/wiki/Big_O_notation](https://en.wikipedia.org/wiki/Big_O_notation)）常用于代码分析中，通过评估算法在输入大小增长时的表现来表示算法的性能。它用于评估运行时间（运行算法所需的指令数量）和空间需求（随着时间推移所需的存储量）。'
- en: '**Adjacency list**: For each vertex, we maintain a list of all the vertices
    connected by an edge. In the case of an undirected graph, each edge is represented
    twice, one for each endpoint, which is not the case for a digraph where the order
    matters.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邻接表**：对于每个顶点，我们维护一个与之相连的所有顶点的列表。在无向图中，每条边被表示两次，分别对应两个端点，而有向图则不同，边的顺序是有意义的。'
- en: 'The following figure shows the adjacency list representation of a graph, both directed
    and undirected:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下图展示了图的邻接表表示方法，包括有向图和无向图：
- en: '![Graph representations](img/B09699_09_04.jpg)'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图表示](img/B09699_09_04.jpg)'
- en: Adjacency list representation of a graph (both directed and undirected)
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图的邻接表表示（包括有向图和无向图）
- en: Contrary to the adjacency matrix representation, the adjacency list representation
    has a smaller space complexity which is *O (m + n)* where *m* is the number of
    edges and *n* is the number of vertices. However, the time complexity increases
    to *O(m)* compared to *O(1)* for the adjacency matrix. For these reasons, it is
    preferable to use the adjacency list representation when the graph is sparsely
    connected (that is, doesn't have a lot of edges).
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与邻接矩阵表示法相反，邻接表表示法具有较小的空间复杂度，时间复杂度为 *O (m + n)*，其中 *m* 是边的数量，*n* 是顶点的数量。然而，时间复杂度相较于邻接矩阵的
    *O(1)* 增加到 *O(m)*。因此，当图是稀疏连接时（即边较少），使用邻接表表示法更为合适。
- en: As hinted in the preceding discussion, which graph representation to use depends
    heavily on the graph density but also on the type of algorithms we are planning
    to use. In the next section, we discuss the most commonly used graph algorithms.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面讨论中所提示的，使用哪种图表示方法很大程度上依赖于图的密度，同时也取决于我们计划使用的算法类型。在接下来的章节中，我们将讨论最常用的图算法。
- en: Graph algorithms
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图算法
- en: 'The following is a list of the most commonly used graph algorithms:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常用的图算法列表：
- en: '**Search**: In the context of the graph, searching means finding paths between
    two vertices. A path is defined as a continuous sequence of edges and vertices.
    The motivation for searching paths in a graph can be multiple; it could be that
    you''re interested in finding the shortest path according to some predefined distance
    criteria, such as the minimum number of edges (for example, GPS route mapping)
    or you simply want to know that a path between two vertices exists (for example,
    ensure that every machine in a network is reachable from any other machine). A
    generic algorithm to search for a path is to start from the given vertex, *discover*
    all the vertices that are connected to it, mark the discovered vertices as explored
    (so we don''t find them twice) and continue the same exploration for each discovered
    vertex until we find the target vertex, or we run out of vertices. There are two
    commonly used flavors of this search algorithm: Breadth First Search and Depth
    First Search, each having their own use cases for which they are better suited.
    The difference between these two algorithms consists of the way we find the unexplored
    vertices:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：在图的上下文中，搜索意味着查找两个顶点之间的路径。路径被定义为一系列连续的边和顶点。图中搜索路径的动机可能有多种；它可能是你希望根据某些预定义的距离标准找到最短路径，例如最少的边数（例如，GPS路线规划），或者你仅仅想知道两个顶点之间是否存在路径（例如，确保网络中每台机器都可以与其他机器互联）。一种通用的路径搜索算法是从给定的顶点开始，*发现*与其连接的所有顶点，标记已发现的顶点为已探索（以防止重复发现），并对每个已发现的顶点继续相同的探索，直到找到目标顶点，或者所有顶点都已被遍历。这个搜索算法有两种常用的变种：广度优先搜索（BFS）和深度优先搜索（DFS），它们各自有适用的场景，适合不同的使用情况。这两种算法的区别在于它们寻找未探索顶点的方式：'
- en: '**Breadth First Search (BFS)**: The unexplored nodes that are immediate neighbors
    are explored first. When the immediate neighborhood has been explored, start exploring
    the neighborhood of each node in the layer, until the end of the graph is reached.
    Because we are exploring all vertices that are directly connected first, this
    algorithm guarantees to find the shortest path which corresponds to the number
    of neighborhoods found. An extension to BFS is the famous Dijkstra shortest path
    algorithm where each edge is associated with a non-negative weight. In this case,
    the shortest path may not be the one with the least number of hops but rather
    a path that minimizes the sum of all weights. One example application of the Dijkstra
    shortest path is to find the shortest route between two points on a map.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广度优先搜索（BFS）**：首先探索直接邻居的未探索节点。当一个层次的邻居已被探索完毕，开始探索每个节点的邻域，直到遍历完整个图。由于我们首先探索所有直接连接的顶点，这个算法保证能够找到最短路径，该路径与发现的邻居数量相对应。BFS的一个扩展是著名的Dijkstra最短路径算法，其中每条边都与一个非负权重关联。在这种情况下，最短路径可能不是跳数最少的路径，而是最小化所有权重之和的路径。Dijkstra最短路径的一个应用示例是查找地图上两点之间的最短路径。'
- en: '**Depth First Search (DFS)**: For each immediate neighbor vertex, aggressively
    explore its neighbors first going as deeply as you can and then start backtracking
    when you run out of neighbors. Example of applications for DFS include finding
    the topological sort and strongly connected components of a digraph. For reference,
    a topological sort is a linear ordering of the vertices such that each vertex
    in the linear order follows the edge direction of the next one (that is, it doesn''t
    move backward). See [https://en.wikipedia.org/wiki/Topological_sorting](https://en.wikipedia.org/wiki/Topological_sorting)
    for more information.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度优先搜索（DFS）**：对于每个直接邻居顶点，首先深入探索它的邻居，尽可能深入，直到没有更多邻居为止，然后开始回溯。DFS的应用示例包括查找有向图的拓扑排序和强连通分量。作为参考，拓扑排序是顶点的线性排序，使得每个顶点在排序中按照边的方向依次排列（即，不会逆向）。更多信息请参见
    [https://en.wikipedia.org/wiki/Topological_sorting](https://en.wikipedia.org/wiki/Topological_sorting)。'
- en: 'The following diagram demonstrates the differences in finding the unexplored
    nodes between BFS and DFS:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下图展示了BFS和DFS在寻找未探索节点时的差异：
- en: '![Graph algorithms](img/B09699_09_05.jpg)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图形算法](img/B09699_09_05.jpg)'
- en: Order of finding unexplored vertices in BFS and DFS
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: BFS和DFS中未探索顶点的发现顺序
- en: '**Connected components and strongly connected components**: Connected components
    of a graph are groups of vertices where there is a path between any two vertices.
    Note that the definition only specifies that a path must exist which means that
    two vertices do not have to have an edge between them as long as a path exists.
    In the case of a digraph, the connected component is called a **strongly connected
    component** because of the additional direction constraint that requires that
    not only should any vertex A have a path to any other vertex B, but that B must
    also have a path to A.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连通分量和强连通分量**：图的连通分量是指一组顶点，其中任意两个顶点之间都有路径。请注意，定义只要求存在路径，这意味着两个顶点之间不必有边，只要有路径就行。对于有向图，连通分量被称为**强连通分量**，这是因为有额外的方向约束要求，不仅任何顶点A应该有路径通向任意其他顶点B，而且B也必须有路径通向A。'
- en: 'The following diagram shows the strongly connected components or a sample directed
    graph:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下图示展示了强连通分量或一个示例有向图：
- en: '![Graph algorithms](img/B09699_09_06.jpg)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图算法](img/B09699_09_06.jpg)'
- en: Strongly connected components of a directed graph
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有向图的强连通分量
- en: '**Centrality**: The centrality indicator of a vertex provides an indication
    of how important the vertex is with regard to the other vertices in the graph.
    There are multiple important applications for these centrality indices. For example,
    identifying the most influential person in a social network or ranking a web search
    by pages that are the most important, and so on.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中心性**：顶点的中心性指标提供了一个关于该顶点相对于图中其他顶点的重要性的衡量。中心性指数有多个重要应用。例如，识别社交网络中最有影响力的人，或根据页面的重要性对网页搜索结果进行排名，等等。'
- en: 'There are multiple indices of centrality, but we''ll focus on the following
    four that we''ll use later in this chapter:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 中心性有多个指标，但我们将专注于本章稍后使用的以下四个：
- en: '**Degree**: The degree of a vertex is the number of edges for which the vertex
    is one of the endpoints. In the case of a digraph, it''s the number of edges for
    which the vertex is either a source or a target, and we call **indegree** the
    number of edges for which the vertex is a target and **outdegree** the number
    of edges for which the vertex is a source.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**度数**：顶点的度数是该顶点作为端点的边的数量。在有向图的情况下，它是该顶点作为源或目标的边的数量，我们称**入度**为该顶点作为目标的边的数量，**出度**为该顶点作为源的边的数量。'
- en: '**PageRank**: This is the famous algorithm developed by the founders of Google,
    Larry Page, and Sergey Brin. PageRank is used to rank the search results by providing
    a measure of importance for a given website that includes counting the number
    of links to that website from other websites. It also factors in an estimation
    of the quality of these links (that is, how trustworthy is the site linking to
    yours).'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PageRank**：这是由谷歌创始人拉里·佩奇和谢尔盖·布林开发的著名算法。PageRank用于通过提供一个衡量网站重要性的指标来排名搜索结果，其中包括计算指向该网站的其他网站的链接数量。它还考虑了这些链接的质量估计（即，指向你网站的链接站点的可信度）。'
- en: '**Closeness**: Closeness centrality is inversely proportional to the average
    length of the shortest path between the given vertex and all the other vertices
    in the graph. The intuition is that the closer a vertex is to all the other nodes,
    the more important it is.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接近度**：接近度中心性与给定顶点与图中所有其他顶点之间最短路径的平均长度成反比。直观上，顶点距离其他所有节点越近，它就越重要。'
- en: 'The closeness centrality can be calculated with the following simple equation:'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接近度中心性可以通过以下简单公式计算：
- en: '![Graph algorithms](img/B09699_09_42.jpg)'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图算法](img/B09699_09_42.jpg)'
- en: '(Source: https://en.wikipedia.org/wiki/Centrality#Closeness_centrality)'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (来源：https://en.wikipedia.org/wiki/Centrality#Closeness_centrality)
- en: Where *d(y,x)* is the length of the edge between node *x* and *y*.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 *d(y,x)* 是节点 *x* 和 *y* 之间的边的长度。
- en: '**Shortest path betweenness**: Measure based on how many times the given vertex
    is part of the shortest path between any two nodes. The intuition is that the
    more a vertex contributes to shortest paths, the more important it is. The mathematical
    equation for shortest path betweenness is provided here:![Graph algorithms](img/B09699_09_46.jpg)'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最短路径介入度**：这个度量是基于给定顶点在任意两节点之间最短路径上出现的次数。直观上，顶点对最短路径的贡献越大，它就越重要。最短路径介入度的数学公式如下所示：![图算法](img/B09699_09_46.jpg)'
- en: '(Source: https://en.wikipedia.org/wiki/Centrality#Betweenness_centrality)'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (来源：https://en.wikipedia.org/wiki/Centrality#Betweenness_centrality)
- en: Where ![Graph algorithms](img/B09699_09_43.jpg) is the total number of shortest
    paths from vertex *s* to vertex *t* and ![Graph algorithms](img/B09699_09_44.jpg)
    is the subset of ![Graph algorithms](img/B09699_09_45.jpg) that pass through *v*.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 ![图算法](img/B09699_09_43.jpg) 是从顶点 *s* 到顶点 *t* 的所有最短路径的总数，! [图算法](img/B09699_09_44.jpg)
    是经过 *v* 的 ![图算法](img/B09699_09_45.jpg) 的子集。
- en: Note
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: More information on centrality can be found here:'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**：更多关于中心性的详细信息可以在这里找到：'
- en: '[https://en.wikipedia.org/wiki/Centrality](https://en.wikipedia.org/wiki/Centrality)'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Centrality](https://en.wikipedia.org/wiki/Centrality)'
- en: Graph and big data
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图与大数据
- en: Our graph discussion has so far focused on data that can fit into a single machine,
    but what happens when we have very large graphs with billions of vertices and
    edges where loading the entire data into memory would not be possible? A natural
    solution would be to distribute the data across a cluster of multiple nodes which
    process the data in parallel and have the individual results merged to form the
    final answer. Fortunately, there are multiple frameworks that provide such graph-parallel
    capabilities, and they pretty much all include the implementation for most of
    the commonly-used graph algorithms. Examples of popular open-source frameworks
    are Apache Spark GraphX ([https://spark.apache.org/graphx](https://spark.apache.org/graphx))
    and Apache Giraph ([http://giraph.apache.org](http://giraph.apache.org)) which
    is currently used by Facebook to analyze its social network.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们的图讨论主要集中在可以适应单台机器的数据上，但当我们有包含数十亿个顶点和边的大图时，如何处理呢？如果将整个数据加载到内存中是不可能的，如何解决呢？一个自然的解决方案是将数据分布到多个节点的集群中，在这些节点上并行处理数据，并将各自的结果合并形成最终答案。幸运的是，已经有多个框架提供了这种图并行计算能力，并且它们几乎都实现了大多数常用图算法。流行的开源框架包括
    Apache Spark GraphX（[https://spark.apache.org/graphx](https://spark.apache.org/graphx)）和
    Apache Giraph（[http://giraph.apache.org](http://giraph.apache.org)），后者目前被 Facebook
    用于分析其社交网络。
- en: Without diving into too much detail, it's important to know that these frameworks
    are all inspired from the **bulk synchronous parallel** (**BSP**) model of distributed
    computation ([https://en.wikipedia.org/wiki/Bulk_synchronous_parallel](https://en.wikipedia.org/wiki/Bulk_synchronous_parallel))
    which uses messages between machines to find vertices across the cluster. The
    key point to remember is that these frameworks are usually very easy to use, for example,
    it would have been fairly easy to write this chapter's analytics using Apache
    Spark GraphX.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节，重要的是要知道，这些框架都受到**大规模同步并行**（**BSP**）分布式计算模型的启发（[https://en.wikipedia.org/wiki/Bulk_synchronous_parallel](https://en.wikipedia.org/wiki/Bulk_synchronous_parallel)），该模型通过机器间的消息传递来查找集群中的顶点。需要记住的关键点是，这些框架通常非常易于使用，例如，使用
    Apache Spark GraphX 编写本章的分析将相对简单。
- en: In this section, we've reviewed only a fraction of all the graph algorithms
    available and going deeper would be beyond the scope of this book. Implementing
    these algorithms yourself would take a considerable amount of time, but fortunately,
    there are plenty of open source libraries that provide fairly complete implementations
    of the graph algorithms and that are easy to use and integrate into your application.
    In the rest of this chapter, we'll use the `networkx` open source Python library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们只回顾了所有图算法中的一小部分，深入探讨将超出本书的范围。自己实现这些算法将花费大量时间，但幸运的是，现有许多开源库提供了相当完整的图算法实现，并且易于使用和集成到应用程序中。在本章的其余部分，我们将使用`networkx`开源
    Python 库。
- en: Getting started with the networkx graph library
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 networkx 图库
- en: 'Before we start, if not already done, we need to install the `networkx` library
    using the `pip` tool. Execute the following code in its own cell:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，如果尚未完成，需要使用`pip`工具安装`networkx`库。请在单独的单元格中执行以下代码：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: As always, don''t forget to restart the kernel after the installation
    is complete.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：和往常一样，安装完成后不要忘记重启内核。'
- en: 'Most of the algorithms provided by `networkx` are directly callable from the
    main module. Therefore a user will only need the following `import` statement:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`networkx` 提供的大多数算法可以直接从主模块调用。因此，用户只需要以下的`import`语句：'
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating a graph
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建图
- en: 'As a starting point, let''s review the different types of graphs supported
    by `networkx` and the constructors that create empty graphs:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，让我们回顾一下`networkx`支持的不同类型的图及其创建空图的构造函数：
- en: '`Graph`: An undirected graph with only one edge between vertices allowed. Self-loop
    edges are permitted. Constructor example:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Graph`：一个无向图，顶点之间只允许有一条边。允许自环边。构造函数示例：'
- en: '[PRE2]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Digraph`: Subclass of `Graph` that implements a directed graph. Constructor
    example:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Digraph`：`Graph` 的子类，表示有向图。构造函数示例：'
- en: '[PRE3]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`MultiGraph`: Undirected graph that allows multiple edges between vertices.
    Constructor example:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiGraph`：允许顶点之间有多条边的无向图。构造函数示例：'
- en: '[PRE4]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`MultiDiGraph`: Directed graph that allows multiples edges between vertices.
    Constructor example:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiDiGraph`：允许顶点之间有多条边的有向图。构造函数示例：'
- en: '[PRE5]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Graph` class provides many methods for adding and removing vertices and
    edges. Here is a subset of the available methods:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graph` 类提供了许多方法用于添加和删除顶点及边。以下是可用方法的子集：'
- en: '`add_edge(u_of_edge, v_of_edge, **attr)`: Add an edge between vertex `u` and
    vertex `v`, with optional additional attributes that will be associated with the
    edge. The vertices u and v will automatically be created if they don''t already
    exist in the graph.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_edge(u_of_edge, v_of_edge, **attr)`：在顶点 `u` 和顶点 `v` 之间添加一条边，并可选地添加附加属性，这些属性将与边相关联。如果顶点
    `u` 和 `v` 在图中不存在，它们会自动创建。'
- en: '`remove_edge(u, v)`: Remove the edge between `u` and `v`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_edge(u, v)`：移除顶点 `u` 和 `v` 之间的边。'
- en: '`add_node(self, node_for_adding, **attr)`: Add a node to the graph with optional
    additional attributes.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_node(self, node_for_adding, **attr)`：向图中添加一个节点，并可选地添加额外属性。'
- en: '`remove_node(n)`: Remove the node identified by the given argument `n`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_node(n)`：移除由给定参数 `n` 标识的节点。'
- en: '`add_edges_from(ebunch_to_add, **attr)`: Add multiple edges in bulk with optional
    additional attributes. The edges must be given as a list of two-tuples `(u,v)`
    or three-tuples `(u,v,d)` where `d` is the dictionary that contains edge data.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_edges_from(ebunch_to_add, **attr)`：批量添加多条边，并可选地添加额外属性。边必须以二元组 `(u,v)`
    或三元组 `(u,v,d)` 的形式给出，其中 `d` 是包含边数据的字典。'
- en: '`add_nodes_from(self, nodes_for_adding, **attr)`: Add multiple nodes in bulk
    with optional additional attributes. The nodes can be provided as a list, dict,
    set, array, and so on.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_nodes_from(self, nodes_for_adding, **attr)`：批量添加多个节点，并可选地添加额外属性。节点可以作为列表、字典、集合、数组等提供。'
- en: 'As an exercise, let''s build the directed graph we''ve been using as a sample
    from the beginning:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们从一开始就构建我们使用的有向图示例：
- en: '![Creating a graph](img/B09699_09_07.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![创建图](img/B09699_09_07.jpg)'
- en: Sample graph to be created programmatically using networkx
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过编程方式使用 networkx 创建的示例图
- en: 'The following code starts by creating a `DiGraph()` object, adds all the nodes
    in one call using the `add_nodes_from()` method, and then starts adding the edges
    using, for illustration, a combination of `add_edge()` and `add_edges_from()`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码通过创建一个 `DiGraph()` 对象开始，使用 `add_nodes_from()` 方法一次性添加所有节点，然后使用 `add_edge()`
    和 `add_edges_from()` 的组合（作为示例）开始添加边：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode1.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode1.py)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode1.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode1.py)'
- en: 'The `Graph` class also provides easy access to its properties through variable
    class views. For example, you can iterate over the vertices and edges of a graph
    using `G.nodes` and `G.edges`, but also access an individual edge with the following
    notation: `G.edges[u,v]`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graph` 类还通过变量类视图提供了方便访问其属性的方法。例如，你可以使用 `G.nodes` 和 `G.edges` 遍历图的顶点和边，但也可以通过以下表示法访问单个边：`G.edges[u,v]`。'
- en: 'The following code iterates over the nodes of a graph and prints them:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码遍历图的节点并打印它们：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `networkx` library also provides a rich set of prebuilt graph generators
    that can be useful for testing your algorithms. For example, you can easily generate
    a complete graph using the `complete_graph()` generator as shown in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`networkx` 库还提供了一套丰富的预构建图生成器，这些生成器对于测试你的算法非常有用。例如，你可以通过 `complete_graph()`
    生成器轻松生成一个完全图，如以下代码所示：'
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find a complete list of all the available graph generators here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到所有可用图生成器的完整列表：
- en: '[https://networkx.github.io/documentation/networkx-2.1/reference/generators.html#generators](https://networkx.github.io/documentation/networkx-2.1/reference/generators.html#generators)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://networkx.github.io/documentation/networkx-2.1/reference/generators.html#generators](https://networkx.github.io/documentation/networkx-2.1/reference/generators.html#generators)'
- en: Visualizing a graph
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化一个图
- en: NetworkX supports multiple rendering engines including Matplotlib, Graphviz
    AGraph ([http://pygraphviz.github.io](http://pygraphviz.github.io)) and Graphviz
    with pydot ([https://github.com/erocarrera/pydot](https://github.com/erocarrera/pydot)).
    Even though Graphviz provides very powerful drawing capabilities, I found it very
    hard to install. Matplotlib, however, is already preinstalled in Jupyter Notebooks
    which gets you started very quickly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX 支持多种渲染引擎，包括 Matplotlib、Graphviz AGraph ([http://pygraphviz.github.io](http://pygraphviz.github.io))
    和 Graphviz with pydot ([https://github.com/erocarrera/pydot](https://github.com/erocarrera/pydot))。尽管
    Graphviz 提供了非常强大的绘图功能，但我发现它的安装非常困难。然而，Matplotlib 已经在 Jupyter Notebooks 中预装，可以让你快速开始。
- en: 'The core drawing function is called `draw_networkx` which takes a graph as
    an argument and a bunch of optional keyword arguments that let you style the graph,
    such as color, width, and the label font of the nodes and edges. The overall layout
    of the graph drawing is configured by passing the `GraphLayout` object through
    the `pos` keyword argument. The default layout is `spring_layout` (which uses
    a force-directed algorithm), but NetworkX supports many others, including `circular_layout`,
    `random_layout`, and `spectral_layout`. You can find a list of all the available
    layouts here: [https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html#module-networkx.drawing.layout](https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html#module-networkx.drawing.layout).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 核心绘图功能是 `draw_networkx`，它接受一个图作为参数，并有一组可选的关键字参数，允许你对图进行样式设置，例如颜色、宽度，以及节点和边的标签字体。图形绘制的整体布局通过
    `pos` 关键字参数传递 `GraphLayout` 对象来配置。默认布局是 `spring_layout`（使用基于力的算法），但 NetworkX 支持许多其他布局，包括
    `circular_layout`、`random_layout` 和 `spectral_layout`。你可以在这里查看所有可用布局的列表：[https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html#module-networkx.drawing.layout](https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html#module-networkx.drawing.layout)。
- en: For convenience, `networkx` encapsulates each of these layouts into its own
    high-level drawing methods that call reasonable default values so that the caller
    doesn't have to deal with the intricacies of each of these layouts. For example,
    the `draw()` method will draw the graph with a `sprint_layout`, `draw_circular()`
    with a `circular_layout`, and `draw_random()`with a `random_layout`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，`networkx` 将每个布局封装成其高层绘图方法，调用合理的默认值，这样调用者就不需要处理每个布局的复杂性。例如，`draw()` 方法将使用
    `spring_layout` 绘制图形，`draw_circular()` 使用 `circular_layout`，`draw_random()` 使用
    `random_layout`。
- en: 'In the following sample code, we use the `draw()` method to visualize the `G_complete`
    graph we created earlier:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例代码中，我们使用 `draw()` 方法来可视化我们之前创建的 `G_complete` 图：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: 'You can find the code file here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode2.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode2.py)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode2.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode2.py)'
- en: 'The results are shown in the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在以下输出中：
- en: '![Visualizing a graph](img/B09699_09_08.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![可视化图形](img/B09699_09_08.jpg)'
- en: Drawing of a complete graph with 10 nodes
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个包含10个节点的完整图
- en: Drawing graphs with `networkx` is both easy and fun, and because it's using
    Matplotlib, you can beautify them even further using the Matplotlib drawing capabilities.
    I encourage the reader to experiment further by visualizing different graphs in
    a Notebook. In the next section, we'll start implementing a sample application
    that analyzes flight data using graph algorithms.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `networkx` 绘制图形既简单又有趣，并且由于它使用了 Matplotlib，你可以进一步美化它们，利用 Matplotlib 的绘图功能。我鼓励读者进一步实验，通过在笔记本中可视化不同的图形。在下一部分中，我们将开始实现一个示例应用程序，使用图算法分析航班数据。
- en: Part 1 – Loading the US domestic flight data into a graph
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1部分 – 将美国国内航班数据加载到图中
- en: 'To initialize the Notebook, let''s run the following code, in its own cell,
    to import the packages which we''ll be using quite heavily in the rest of this
    chapter:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化笔记本，接下来我们运行以下代码，在它自己的单元格中导入本章中将频繁使用的包：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We''ll also be using the *2015 Flight Delays and Cancellations* dataset available
    on the Kaggle website at this location: [https://www.kaggle.com/usdot/datasets](https://www.kaggle.com/usdot/datasets).
    The dataset is composed of three files:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 *2015年航班延误和取消* 数据集，该数据集可以在 Kaggle 网站上找到，位置为：[https://www.kaggle.com/usdot/datasets](https://www.kaggle.com/usdot/datasets)。该数据集由三个文件组成：
- en: '`airports.csv`: List of all U.S. airports including their **IATA** code (**International
    Air Transport Association**: [https://openflights.org/data.html](https://openflights.org/data.html)),
    city, state, longitude, and latitude.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`airports.csv`：所有美国机场的列表，包括它们的**IATA**代码（**国际航空运输协会**：[https://openflights.org/data.html](https://openflights.org/data.html)）、城市、州、经度和纬度。'
- en: '`airlines.csv`: List of U.S. airlines including their IATA code.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`airlines.csv`：美国航空公司的列表，包括它们的IATA代码。'
- en: '`flights.csv`: List of flights that occurred in 2015\. This data includes date,
    origin and destination airports, scheduled and actual times, and delays.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flights.csv`：2015年发生的航班列表。该数据包括日期、起点和终点机场、计划和实际时间以及延误情况。'
- en: The `flights.csv` file contains close to 6 million records, which need to be
    cleaned up to remove all flights that do not have an IATA three letter code in
    the origin or destination airport. We also want to remove the rows that have a
    missing value in the `ELAPSED_TIME` column. Failure to do so would cause problems
    when we load the data into a graph structure. Another issue is that the dataset
    contains a few time columns, such as `DEPARTURE_TIME`, and `ARRIVAL_TIME`, and
    to save space, these columns only store the time in `HHMM` format, while the actual
    date is stored in the `YEAR`, `MONTH`, and `DAY` column. One of the analyses we
    will do in this chapter will need a complete datetime for the `DEPARTURE_TIME`,
    and since it is a time-consuming operation to do this transformation, we do it
    now and store it in the processed version of `flights.csv` that we'll store on
    GitHub. This operation uses the pandas `apply()` method that is called with the
    `to_datetime()` function and `axis=1` (indicating that the transformation is applied
    on each row).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`flights.csv`文件包含接近600万条记录，需要清理，移除所有起点或终点机场没有IATA三字代码的航班。我们还需要删除`ELAPSED_TIME`列中缺失值的行。如果不这样做，在将数据加载到图形结构时会出现问题。另一个问题是数据集包含一些时间列，比如`DEPARTURE_TIME`和`ARRIVAL_TIME`，为了节省空间，这些列只存储`HHMM`格式的时间，实际日期存储在`YEAR`、`MONTH`和`DAY`列中。我们将在本章进行的一个分析中需要完整的`DEPARTURE_TIME`日期时间，因为进行这个转换是一个耗时的操作，所以我们现在就进行转换，并将处理后的版本存储在将上传到GitHub的`flights.csv`文件中。此操作使用pandas的`apply()`方法，调用`to_datetime()`函数并设置`axis=1`（表示该转换应用于每一行）。'
- en: Another issue is that we want to store the files on GitHub, but there is a maximum
    file size limitation of 100 M. So, to make the file smaller than 100 M, we also
    remove some of the columns that won't be needed in the analysis we're trying to
    build and then zip the file before storing it on GitHub. Of course, another benefit
    is that the DataFrame will load faster with a smaller file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是我们想将文件存储在GitHub上，但GitHub对文件大小有100MB的最大限制。因此，为了将文件大小缩小到100MB以下，我们还删除了一些在我们构建分析中不需要的列，然后将文件压缩后再存储到GitHub上。当然，另一个好处是，较小的文件会使DataFrame加载得更快。
- en: 'After downloading the files from the Kaggle website, we run the following code
    which first loads the CSV file into a pandas DataFrame, remove the unwanted rows and
    columns, and write the data back to a file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在从Kaggle网站下载文件后，我们运行以下代码，该代码首先将CSV文件加载到pandas DataFrame中，移除不需要的行和列，然后将数据写回到文件中：
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: The original data is stored in a file called `flights.raw.csv`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：原始数据存储在名为`flights.raw.csv`的文件中。'
- en: Running the following code may take some time due to the large size of the file
    which contains 6 million records.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码可能需要一些时间，因为文件非常大，包含600万条记录。
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode3.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode3.py)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode3.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode3.py)'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: As documented in the `pandas.read_csv` documentation ([http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.read_csv.html](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.read_csv.html)),
    we use the keyword argument `low_memory=False` to make sure the data is not loaded
    in chunks which could cause problems with type inference, especially with very
    large files.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：根据`pandas.read_csv`文档（[http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.read_csv.html](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.read_csv.html)），我们使用关键字参数`low_memory=False`来确保数据不是按块加载，这样可以避免在类型推断时出现问题，特别是在处理非常大的文件时。'
- en: 'For convenience, the three files are stored at the following GitHub location:
    [https://github.com/DTAIEB/Thoughtful-Data-Science/tree/master/chapter%209/USFlightsAnalysis](https://github.com/DTAIEB/Thoughtful-Data-Science/tree/master/chapter%209/USFlightsAnalysis).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，三个文件存储在以下 GitHub 位置：[https://github.com/DTAIEB/Thoughtful-Data-Science/tree/master/chapter%209/USFlightsAnalysis](https://github.com/DTAIEB/Thoughtful-Data-Science/tree/master/chapter%209/USFlightsAnalysis)。
- en: 'The following code uses the `pixiedust.sampleData()` method to load the data
    into three pandas DataFrames corresponding to `airlines`, `airports`, and `flights`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 `pixiedust.sampleData()` 方法将数据加载到三个 pandas DataFrame 中，分别对应 `airlines`、`airports`
    和 `flights`：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode4.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode4.py)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode4.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode4.py)'
- en: '**Note**: The GitHub URL uses the `/raw/` segment which indicates that we want
    to download the raw file as opposed to the HTML for the corresponding GitHub page.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：GitHub URL 使用了 `/raw/` 部分，表示我们希望下载原始文件，而不是相应 GitHub 页面上的 HTML。'
- en: 'The next step is to load the data into a `networkx` directed weighted graph
    object using the `flights` DataFrame as the `edge` list and the values from the
    `ELAPSED_TIME` column as the weight. We first deduplicate all the flights that
    have the same airports as origin and destination, by grouping them using the `pandas.groupby()`
    method with a multi-index that has `ORIGIN_AIRPORT` and `DESTINATION_AIRPORT`
    as the keys. We then select the `ELAPSED_TIME` column from the `DataFrameGroupBy`
    object and aggregate the results using the `mean()` method. This will give us
    a new DataFrame that has the mean average `ELAPSED_TIME` for each flight with
    the same origin and destination airport:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用 `flights` DataFrame 作为 `edge` 列表，并将 `ELAPSED_TIME` 列的值作为权重，加载数据到 `networkx`
    有向加权图对象中。我们首先通过使用 `pandas.groupby()` 方法按多重索引对所有起始地和目的地相同的航班进行去重，其中 `ORIGIN_AIRPORT`
    和 `DESTINATION_AIRPORT` 为键。接着，我们从 `DataFrameGroupBy` 对象中选择 `ELAPSED_TIME` 列，并使用
    `mean()` 方法对结果进行聚合。这将为我们提供一个新的 DataFrame，其中包含每个具有相同起始地和目的地机场的航班的平均 `ELAPSED_TIME`：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode5.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode5.py)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode5.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode5.py)'
- en: 'The results are shown in the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下截图所示：
- en: '![Part 1 – Loading the US domestic flight data into a graph](img/B09699_09_09.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![第1部分 – 将美国国内航班数据加载到图中](img/B09699_09_09.jpg)'
- en: Flights grouped by origin and destination with mean average ELAPSED_TIME
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 按起始地和目的地分组的航班，以及平均的 ELAPSED_TIME
- en: 'Before using this DataFrame to create the directed graph, we need to reset
    the index from a multi-index to a regular single index converting the index columns
    into regular columns. For that, we simply use the `reset_index()` method as shown
    here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这个 DataFrame 创建有向图之前，我们需要将索引从多重索引重置为常规的单一索引，并将索引列转换为常规列。为此，我们只需使用 `reset_index()`
    方法，如下所示：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode6.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode6.py)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode6.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode6.py)'
- en: 'We now have a DataFrame with the right shape, ready to be used to create the
    directed graph, as shown in the following screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个形状正确的 DataFrame，准备用于创建有向图，如下截图所示：
- en: '![Part 1 – Loading the US domestic flight data into a graph](img/B09699_09_10.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![第1部分 – 将美国国内航班数据加载到图中](img/B09699_09_10.jpg)'
- en: Flights grouped by origin and destination with mean average ELAPSED_TIME and
    a single index
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 按起始地和目的地分组的航班，计算平均 ELAPSED_TIME，并使用单一索引
- en: To create the directed weighted graph, we use the NetworkX `from_pandas_edgelist()`
    method which takes a pandas DataFrame as the input source. We also specify the
    source and target columns, as well as the weight column (in our case `ELAPSED_TIME`).
    Finally, we tell NetworkX that we want to create a directed graph by using the
    `create_using` keyword arguments, passing an instance of `DiGraph` as a value.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建有向加权图，我们使用 NetworkX 的 `from_pandas_edgelist()` 方法，该方法以 pandas DataFrame
    作为输入源。我们还指定了源列和目标列，以及权重列（在我们的例子中是 `ELAPSED_TIME`）。最后，我们通过使用 `create_using` 关键字参数，传入
    `DiGraph` 的实例，告诉 NetworkX 我们想要创建一个有向图。
- en: 'The following code shows how to call the `from_pandas_edgelist()` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何调用 `from_pandas_edgelist()` 方法：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode7.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode7.py)
    **Note**: NetworkX supports the creation of graphs by converting from multiple
    formats including dictionaries, lists, NumPy and SciPy matrices and of course
    pandas. You can find more information about these conversion capabilities here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode7.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode7.py)
    **注意**：NetworkX 支持通过转换多种格式（包括字典、列表、NumPy 和 SciPy 矩阵以及 pandas）来创建图形。你可以在这里找到关于这些转换功能的更多信息：'
- en: '[https://networkx.github.io/documentation/networkx-2.1/reference/convert.html](https://networkx.github.io/documentation/networkx-2.1/reference/convert.html)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://networkx.github.io/documentation/networkx-2.1/reference/convert.html](https://networkx.github.io/documentation/networkx-2.1/reference/convert.html)'
- en: 'We can quickly validate that our graph has the right values by directly printing
    its nodes and edges:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过直接打印图的节点和边来快速验证图的值是否正确：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode8.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode8.py)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode8.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode8.py)'
- en: 'Which produces the following output (truncated):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成以下输出（已截断）：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can also create better visualization by using the built-in drawing APIs available
    in `networkx` which support multiple rendering engines including Matplotlib, Graphviz
    AGraph ([http://pygraphviz.github.io](http://pygraphviz.github.io)) and Graphviz
    with pydot ([https://github.com/erocarrera/pydot](https://github.com/erocarrera/pydot)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `networkx` 中内置的绘图 API 来创建更好的可视化效果，这些 API 支持多个渲染引擎，包括 Matplotlib、Graphviz
    AGraph ([http://pygraphviz.github.io](http://pygraphviz.github.io)) 和带有 pydot
    的 Graphviz ([https://github.com/erocarrera/pydot](https://github.com/erocarrera/pydot))。
- en: 'For simplicity, we''ll use the NetworkX `draw()` method which uses the readily
    available Matplotlib engine. To beautify the visualization, we configure it with
    proper width and height `(12, 12)` and add a colormap with vivid color (we use
    the `cool` and `spring` colormap from `matplolib.cm`, see: [https://matplotlib.org/2.0.2/examples/color/colormaps_reference.html](https://matplotlib.org/2.0.2/examples/color/colormaps_reference.html)).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将使用 NetworkX 的 `draw()` 方法，该方法使用现成的 Matplotlib 引擎。为了美化可视化效果，我们配置了合适的宽度和高度
    `(12, 12)`，并添加了一个色彩图，色彩鲜艳（我们使用了 `matplotlib.cm` 中的 `cool` 和 `spring` 色彩图，参见：[https://matplotlib.org/2.0.2/examples/color/colormaps_reference.html](https://matplotlib.org/2.0.2/examples/color/colormaps_reference.html)）。
- en: 'The following code shows the implementation of the graph visualization:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了图形可视化的实现：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode9.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode9.py)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode9.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode9.py)'
- en: 'Which produces the following results:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成以下结果：
- en: '![Part 1 – Loading the US domestic flight data into a graph](img/B09699_09_11.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![第 1 部分 – 将美国国内航班数据加载到图中](img/B09699_09_11.jpg)'
- en: Quick visualization of our directed graph using Matplotlib
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 快速可视化我们的有向图
- en: In the preceding chart, the nodes are positioned using a default graph layout
    called `spring_layout`, which is a force-directed layout. One benefit of this
    layout is that it quickly reveals the nodes with the most edge connections which
    are located at the center of the graph. We can change the graph layout by using
    the `pos` keyword argument when calling the `draw()` method. `networkx` supports
    other types of layout including `circular_layout`, `random_layout`, `shell_layout`,
    and `spectral_layout`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，节点是通过一种名为`spring_layout`的默认图布局进行定位的，这是一种力导向布局。这种布局的一个优点是它能够快速显示出图中连接最多边的节点，这些节点位于图的中心。我们可以通过在调用`draw()`方法时使用`pos`关键字参数来更改图的布局。`networkx`还支持其他类型的布局，包括`circular_layout`、`random_layout`、`shell_layout`和`spectral_layout`。
- en: 'For example, using a `random_layout`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用`random_layout`：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode10.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode10.py)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode10.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode10.py)'
- en: 'We get the following results:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '![Part 1 – Loading the US domestic flight data into a graph](img/B09699_09_12.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![第1部分 - 将美国国内航班数据加载到图中](img/B09699_09_12.jpg)'
- en: Flight data graph using a random_layout
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`random_layout`的航班数据图
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: You can find more information about these layouts here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在这里找到更多关于这些布局的信息：
- en: '[https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html](https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html](https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html)'
- en: Graph centrality
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图的中心性
- en: 'The next interesting thing to analyze about the graph is its centrality indices
    which allow us to discover which nodes are the most important vertices. As an
    exercise, we''ll compute four types of centrality index: **degree**, **PageRank**,
    **closeness**, and **shortest path betweenness**. We''ll then augment the airports
    DataFrame to add a column for each of the centrality indices and visualize the
    results in a Mapbox map using PixieDust `display()`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，图的一个有趣分析点是其中心性指标，这可以帮助我们发现哪些节点是最重要的顶点。作为练习，我们将计算四种类型的中心性指标：**度数**、**PageRank**、**接近度**和**最短路径中介中心性**。然后，我们将扩展机场数据框，添加每个中心性指标的列，并使用PixieDust的`display()`在Mapbox地图中可视化结果。
- en: 'Computing the degree of the digraph is very easy with `networkx`; simply use
    the `degree` property of the `flight_graph` object as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 计算有向图的度数非常简单，只需使用`networkx`的`degree`属性，像这样：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This outputs an array of tuples with the airport code and the degree index
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出一个元组数组，每个元组包含机场代码和度数索引，如下所示：
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We now want to add a `DEGREE` column to the airport DataFrame that contains
    the degree value from the preceding array for each of the airport rows. To do
    that, we''ll need to create a new DataFrame that has two columns: `IATA_CODE`
    and `DEGREE` and perform a pandas `merge()` operation on the `IATA_CODE`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要在机场数据框中添加一个`DEGREE`列，其中包含前述数组中每个机场行的度数值。为了做到这一点，我们需要创建一个包含两个列的新数据框：`IATA_CODE`和`DEGREE`，并在`IATA_CODE`上执行pandas的`merge()`操作。
- en: 'The merge operation is illustrated in the following diagram:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 合并操作在下图中展示：
- en: '![Graph centrality](img/B09699_09_13.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图的中心性](img/B09699_09_13.jpg)'
- en: Merging the degree DataFrame to the airports DataFrame
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 合并度数数据框到机场数据框
- en: 'The following code shows how to implement the aforementioned steps. We first
    create a JSON payload by iterating over the `flight_path.degree` output and use
    the `pd.DataFrame()` constructor to create the DataFrame. We then use `pd.merge()`
    using `airports` and `degree_df` as arguments. We also use the `on` argument with
    value `IATA_CODE` which is the key column we''ll want to do the join on:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何实现上述步骤。我们首先通过遍历`flight_path.degree`输出创建一个JSON负载，并使用`pd.DataFrame()`构造函数创建数据框。然后我们使用`pd.merge()`，将`airports`和`degree_df`作为参数传入。我们还使用`on`参数，其值为`IATA_CODE`，这是我们要进行连接的键列：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode11.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode11.py)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode11.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode11.py)'
- en: 'The results are shown in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Graph centrality](img/B09699_09_14.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图形中心性](img/B09699_09_14.jpg)'
- en: Airport DataFrame augmented with the DEGREE column
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 增加了 DEGREE 列的机场数据框
- en: 'To visualize the data in a Mapbox map, we simply use `PixieDust.display()`
    on the `airport_centrality` DataFrame:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Mapbox 地图中可视化数据，我们只需对 `airport_centrality` 数据框使用 `PixieDust.display()`：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following screenshot shows the options dialog:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了选项对话框：
- en: '![Graph centrality](img/B09699_09_15.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图形中心性](img/B09699_09_15.jpg)'
- en: Mapbox options for displaying the airports
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Mapbox 显示机场的选项
- en: 'After clicking **OK** on the options dialog, we get the following results:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在选项对话框点击 **OK** 后，我们得到以下结果：
- en: '![Graph centrality](img/B09699_09_16.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图形中心性](img/B09699_09_16.jpg)'
- en: Showing the airport with degree centrality
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 显示具有度中心性的机场
- en: For the other centrality indices, we can notice that the corresponding computation
    functions all return a JSON output (as opposed to an array for the degree attribute)
    with the `IATA_CODE` airport code as key and the centrality index as value.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他中心性指标，我们可以注意到，相关的计算函数都返回一个 JSON 输出（与度属性的数组不同），其中 `IATA_CODE` 作为机场代码，中心性指数作为值。
- en: 'For example, if we are computing the PageRank using the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用以下代码计算 PageRank：
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We get the following results:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With this in mind, instead of repeating the same steps as we did for `degree`,
    we can implement a generic function called `compute_centrality()` that takes the
    function that computes the centrality and a column name as arguments, create a
    temporary DataFrame that contains the computed centrality values, and merge it
    with the `airports_centrality` DataFrame.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以实现一个通用的函数 `compute_centrality()`，而不是重复为 `degree` 所做的相同步骤。该函数接受计算中心性的函数和列名作为参数，创建一个包含计算中心性值的临时数据框，并将其与
    `airports_centrality` 数据框合并。
- en: 'The following code shows the implementation for `compute_centrality()`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 `compute_centrality()` 的实现：
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode12.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode12.py)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode12.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode12.py)'
- en: 'We can now simply call the `compute_centrality()` method with the three compute
    functions `nx.pagerank()`, `nx.closeness_centrality()`, and `nx.betweenness_centrality()`
    with the columns `PAGE_RANK`, `CLOSENESS`, and `BETWEENNESS` respectively as shown
    in the following code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以简单地调用 `compute_centrality()` 方法，并使用三个计算函数 `nx.pagerank()`、`nx.closeness_centrality()`
    和 `nx.betweenness_centrality()`，并分别将 `PAGE_RANK`、`CLOSENESS` 和 `BETWEENNESS` 作为列，如下所示的代码：
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode13.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode13.py)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode13.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode13.py)'
- en: 'The `airports_centrality` DataFrame now has the extra columns as shown in the
    following output:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`airports_centrality` 数据框现在增加了额外的列，如下所示的输出：'
- en: '![Graph centrality](img/B09699_09_17.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图形中心性](img/B09699_09_17.jpg)'
- en: Airports DataFrame augmented with PAGE_RANK, CLOSENESS and BETWEENNESS values
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 增加了 PAGE_RANK、CLOSENESS 和 BETWEENNESS 值的机场数据框
- en: 'As an exercise, we can verify that the four centrality indices provide consistent
    results for the top airports. Using the pandas `nlargest()` method, we can get
    the top 10 airports for the four indices as shown in the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，我们可以验证四个中心性指数对排名前的机场提供一致的结果。使用 pandas 的 `nlargest()` 方法，我们可以获得四个指数的前 10
    个机场，如下所示的代码：
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode14.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode14.py)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode14.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode14.py)'
- en: 'Which produces the following results:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '[PRE29]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we can see, Atlanta airport comes up as the top airport for all centrality
    indices. As an exercise, let's create a generic method called `visualize_neighbors()`
    that visualizes all the neighbors of a given node and call it with the Atlanta
    node. In this method, we create a subgraph centered around the parent node by
    adding an edge from itself to all its neighbors. We use the NetworkX `neighbors()`
    method to get all the neighbors of a specific node.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，亚特兰大机场在所有中心性指标中排名第一。作为一个练习，让我们创建一个通用方法 `visualize_neighbors()`，用来可视化给定节点的所有邻居，并通过亚特兰大节点调用它。在这个方法中，我们通过从父节点到所有邻居添加边，创建一个以父节点为中心的子图。我们使用
    NetworkX 的 `neighbors()` 方法获取特定节点的所有邻居。
- en: 'The following code shows the implementation of the `visualize_neighbors()`
    method:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 `visualize_neighbors()` 方法的实现：
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode15.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode15.py)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode15.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode15.py)'
- en: 'We then call the `visualize_neighbors()` method on the `ATL` node:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在 `ATL` 节点上调用 `visualize_neighbors()` 方法：
- en: '[PRE31]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Which produces the following output:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法生成如下输出：
- en: '![Graph centrality](img/B09699_09_18.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图中心性](img/B09699_09_18.jpg)'
- en: Visualization of the top node ATL and its neighbors
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化顶点 ATL 及其邻居
- en: We complete this *Part 1* section by computing the shortest path between two
    nodes using the famous Dijkstra algorithm ([https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)).
    We'll experiment with different weight attributes to check if we are getting different
    results.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过计算使用著名的 Dijkstra 算法在两个节点之间的最短路径来完成 *第1部分*，该算法的详细信息请参见（[https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)）。我们将尝试不同的权重属性，看看是否能得到不同的结果。
- en: As an example, let's compute the shortest path between Boston Logan Airport
    in Massachusetts (`BOS`) and Pasco Tri-Cities Airport in Washington (`PSC`) using
    the NetworkX `dijkstra_path()` method ([https://networkx.github.io/documentation/networkx-2.1/reference/algorithms/generated/networkx.algorithms.shortest_paths.weighted.dijkstra_path.html](https://networkx.github.io/documentation/networkx-2.1/reference/algorithms/generated/networkx.algorithms.shortest_paths.weighted.dijkstra_path.html)).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用 NetworkX 的 `dijkstra_path()` 方法计算从马萨诸塞州波士顿洛根机场（`BOS`）到华盛顿帕斯科三城市机场（`PSC`）之间的最短路径（[https://networkx.github.io/documentation/networkx-2.1/reference/algorithms/generated/networkx.algorithms.shortest_paths.weighted.dijkstra_path.html](https://networkx.github.io/documentation/networkx-2.1/reference/algorithms/generated/networkx.algorithms.shortest_paths.weighted.dijkstra_path.html)）。
- en: 'We first use the `ELAPSED_TIME` column as the weight attribute:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将 `ELAPSED_TIME` 列作为权重属性：
- en: Note
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: As a reminder, `ELAPSED_TIME` is the average flight time for each of
    the flights with the same origin and destination airports that we computed earlier
    in this section.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：提醒一下，`ELAPSED_TIME` 是我们在本节早些时候计算的，从相同出发地和目的地机场的每个航班的平均飞行时间。'
- en: '[PRE32]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Which returns:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回：
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Unfortunately, the centrality indices we computed earlier are not part of the
    `flight_graph` DataFrame, so using it as the column name for the `weight` attribute
    won't work. However, the `dijkstra_path()` also allows us to use a function to dynamically
    compute the weight. Since we want to try for different centrality indices, we
    need to create a factory method ([https://en.wikipedia.org/wiki/Factory_method_pattern](https://en.wikipedia.org/wiki/Factory_method_pattern))
    that will create a function for a given centrality index passed as an argument.
    This argument is used as a closure for a nested wrapper function that conforms
    to the `dijkstra_path()` method's `weight` argument. We also use a `cache` dictionary
    to remember the computed weights for a given airport, since the algorithm will
    call the function multiple times for the same airport. If the weight is not in
    the cache, we look it up in the `airports_centrality` DataFrame using the `centrality_indice_col`
    parameter. The final weight is computed by getting the inverse of the centrality
    value, since the Dijkstra algorithm favors paths with shorter distances.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们之前计算的中心性指标不属于`flight_graph`数据框，因此将其用作`weight`属性的列名是行不通的。然而，`dijkstra_path()`也允许我们使用一个函数来动态计算权重。由于我们希望尝试不同的中心性指标，我们需要创建一个工厂方法（[https://en.wikipedia.org/wiki/Factory_method_pattern](https://en.wikipedia.org/wiki/Factory_method_pattern)），该方法会为传入的中心性指标创建一个函数。这个参数作为闭包传递给一个嵌套的包装函数，符合`dijkstra_path()`方法的`weight`参数要求。我们还使用了一个`cache`字典来记住计算出的某个机场的权重，因为算法会对同一个机场多次调用该函数。如果权重不在缓存中，我们会在`airports_centrality`数据框中使用`centrality_indice_col`参数查找。最终的权重通过获取中心性值的倒数来计算，因为Dijkstra算法偏向于选择较短路径。
- en: 'The following code shows the implementation of the `compute_weight` factory
    method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`compute_weight`工厂方法的实现：
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode16.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode16.py)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode16.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode16.py)'
- en: We can now call the NetworkX `dijkstra_path()` method for each of the centrality
    indices. Note that we don't use BETWEENNESS because some of the values are equal
    to zero which can't be used as a weight. We also need to clear the cache before
    calling the `dijkstra_path()` method because using different centrality indices
    will produce different values for each airport.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以针对每个中心性指标调用 NetworkX 的`dijkstra_path()`方法。请注意，我们没有使用BETWEENNESS，因为一些值为零，不能用作权重。在调用`dijkstra_path()`方法之前，我们还需要清除缓存，因为使用不同的中心性指标会为每个机场生成不同的值。
- en: 'The following code shows how to compute the shortest path for each centrality
    index:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何计算每个中心性指标的最短路径：
- en: '[PRE35]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode17.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode17.py)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode17.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode17.py)'
- en: 'The following result is produced:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是产生的结果：
- en: '[PRE36]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It is interesting to note that, as expected, the computed shortest path is the
    same for the three centrality indices, going through Denver airport which is a
    top central airport. However, it is not the same as the one computed using the
    `ELAPSED_TIME` weight which would have us go through Minneapolis instead.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，正如预期的那样，计算出的最短路径对于三个中心性指标是相同的，都经过丹佛机场，这是一座重要的枢纽机场。然而，它与使用`ELAPSED_TIME`权重计算的路径不同，后者会让我们经过明尼阿波利斯。
- en: In this section, we have shown how to load US flight data into a graph data
    structure, compute different centrality indices and use them to compute the shortest
    path between airports. We also discussed different ways of visualizing the graph
    data.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何将美国航班数据加载到图数据结构中，计算不同的中心性指标，并利用这些指标计算机场之间的最短路径。我们还讨论了不同的图数据可视化方法。
- en: Note
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The complete Notebook for *Part 1* can be found here:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*第1部分*的完整笔记本可以在这里找到：'
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%201.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%201.ipynb)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%201.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%201.ipynb)'
- en: In the next section, we'll create the `USFlightsAnalysis` PixieApp that operationalizes
    these analytics.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将创建`USFlightsAnalysis` PixieApp，将这些分析功能实现并投入使用。
- en: Part 2 – Creating the USFlightsAnalysis PixieApp
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分 – 创建USFlightsAnalysis PixieApp
- en: 'For the first iteration of our `USFlightsAnalysis`, we want to implement a
    simple user story that leverages the analytics created in *Part 1*:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们`USFlightsAnalysis`的第一次迭代中，我们希望实现一个简单的用户故事，利用*第1部分*创建的分析功能：
- en: The welcome screen will show two drop-down controls for selecting an origin
    and a destination airport
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欢迎屏幕将显示两个下拉控制，用于选择出发机场和目的地机场。
- en: When an airport is selected, we show a graph showing the selected airports and
    its immediate neighbors
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当选择一个机场时，我们会显示一个图表，展示所选机场及其邻近的机场。
- en: When both airports are selected, the user clicks on the **Analyze** button to show
    a Mapbox map with all the airports
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个机场都被选择时，用户点击**分析**按钮，显示一个包含所有机场的Mapbox地图。
- en: The user can select one of the centrality indices available as checkboxes to show
    the shortest flight path according to the selected centrality
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以选择一个中心性指标（作为复选框）来根据选定的中心性显示最短的飞行路径。
- en: 'Let''s first look at the implementation for the welcome screen which is implemented
    in the default route of the `USFlightsAnalysis` PixieApp. The following code defines
    the `USFlightsAnalysis` class which is decorated with the `@PixieApp` decorator
    to make it a PixieApp. It contains a `main_screen()` method that is decorated
    with the `@route()` decorator to make it the default route. This method returns
    an HTML fragment that will be used as the welcome screen when the PixieApp starts.
    The HTML fragment is composed of two parts: one that shows the drop-down control
    for selecting the origin airport and one that contains the drop-down control for
    selecting the destination airport. We use a Jinja2 `{%for...%}` loop that goes
    over each of the airports (returned by the `get_airports()` method) to generate
    a set of `<options>` elements. Under each of these controls, we add a placeholder
    `<div>` element that will host the graph visualization when an airport is selected.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们来看一下欢迎屏幕的实现，它是在`USFlightsAnalysis` PixieApp的默认路由中实现的。以下代码定义了`USFlightsAnalysis`类，并用`@PixieApp`装饰器将其标记为PixieApp。它包含一个用`@route()`装饰器装饰的`main_screen()`方法，将其设置为默认路由。该方法返回一个HTML片段，该片段将在PixieApp启动时作为欢迎屏幕使用。HTML片段由两部分组成：一部分显示选择出发机场的下拉控制，另一部分包含选择目的地机场的下拉控制。我们使用Jinja2的`{%for...%}`循环遍历每个机场（由`get_airports()`方法返回），生成一组`<options>`元素。在每个控制下方，我们添加一个占位符`<div>`元素，当选择机场时，这个`<div>`将承载图表可视化。
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: As always, we use the `[[USFlightsAnalysis]]` notation to denote
    that the code shows only a partial implementation and therefore the reader should
    not attempt to run it as is until the full implementation is provided.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：和往常一样，我们使用`[[USFlightsAnalysis]]`符号来表示代码只显示了部分实现，因此读者在完整实现提供之前不应尝试直接运行。'
- en: We'll explain later on why the `USFlightsAnalysis` class inherits from the `MapboxBase`
    class.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会解释为什么`USFlightsAnalysis`类继承自`MapboxBase`类。
- en: '[PRE37]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode18.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode18.py)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode18.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode18.py)'
- en: 'When the user selects the origin airport, a `pd_refresh` targetted at the placeholder
    `<div>` element with ID `origin_graph{{prefix}}`, is triggered. In turn, this
    `<div>` element triggers a route using the state: `visualize_graph=$val(origin_airport{{prefix}}`.
    As a reminder, the `$val()` directive is resolved at runtime by fetching the airport
    value of the `origin_airport{{prefix}}` drop-down element. A similar implementation
    is used for the destination airport.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择出发机场时，会触发一个`pd_refresh`，该操作针对ID为`origin_graph{{prefix}}`的占位符`<div>`元素。进而，该`<div>`元素会触发一个路由，使用状态：`visualize_graph=$val(origin_airport{{prefix}})`。作为提醒，`$val()`指令在运行时解析，通过获取`origin_airport{{prefix}}`下拉菜单元素的机场值来实现。目的地机场的实现也类似。
- en: 'The code for the `visualize_graph` route is provided here. It simply calls
    the `visualize_neighbors()` method that we implemented in *Part 1*, which we slightly
    change in *Part 2* to add an optional figure size parameter to accommodate the
    size of the host `<div>` element. As a reminder, we also use the `@captureOutput`
    decorator since the `visualize_neighbors()` method is directly writing to the
    output of the selected cell:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`visualize_graph`路由的代码提供如下。它简单地调用了我们在*第一部分*中实现的`visualize_neighbors()`方法，并在*第二部分*中稍作修改，增加了一个可选的图形大小参数，以适应主机`<div>`元素的大小。作为提醒，我们还使用了`@captureOutput`装饰器，因为`visualize_neighbors()`方法直接写入选定单元格的输出：'
- en: '[PRE38]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode19.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode19.py)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode19.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode19.py)'
- en: The `Analyze` button is triggering the `compute_path_screen()` route which is
    associated with the `org_airport` and `dest_airport` state parameters. We also
    want to make sure that both airports are selected before allowing the `compute_path_screen()`
    route to proceed. To do that, we use a `<pd_script>` child element with `type="preRun"`
    that contains JavaScript code that will be executed before the route is triggered.
    The contract is for this code to return the Boolean `true` if we want to let the
    route proceed, or to return `false` otherwise.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`Analyze`按钮触发了`compute_path_screen()`路由，该路由与`org_airport`和`dest_airport`状态参数相关联。我们还希望在允许`compute_path_screen()`路由继续之前，确保两个机场都已选择。为此，我们使用一个`<pd_script>`子元素，`type="preRun"`，其中包含将在触发路由之前执行的JavaScript代码。该代码的契约是：如果我们希望让路由继续执行，它返回布尔值`true`，否则返回`false`。'
- en: 'For the `Analyze` button we check that both drop-downs have a value and return
    `true` if that''s the case or else raise an error message and return `false`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Analyze`按钮，我们检查两个下拉菜单是否都有值，如果是，则返回`true`，否则抛出错误信息并返回`false`：
- en: '[PRE39]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode20.html](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode20.html)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode20.html](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode20.html)'
- en: 'The following output shows the end results when selecting BOS as the origin
    airport and PSC as the destination:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了选择BOS作为出发机场，PSC作为目的地时的最终结果：
- en: '![Part 2 – Creating the USFlightsAnalysis PixieApp](img/B09699_09_19.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![Part 2 – 创建USFlightsAnalysis PixieApp](img/B09699_09_19.jpg)'
- en: Welcome screen with both airports selected
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎界面，已选择两个机场
- en: Let's now look at the implementation of the `compute_path_screen()` route which
    is responsible for showing the Mapbox map of all the airports and the shortest
    path based on the selected centrality index as a layer which is an extra visualization
    superimposed on the overall map.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`compute_path_screen()`路由的实现，它负责显示所有机场的Mapbox地图，以及基于所选的中心性指标作为图层的最短路径，这是一个附加的可视化层，叠加在整体地图上。
- en: 'The following code shows its implementation:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了其实现：
- en: '[PRE40]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode21.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode21.py)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode21.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode21.py)'
- en: The central `<div>` element of this screen is the Mapbox map which by default
    shows the Mapbox map of all the airports. As shown in the code above, the `<pd_options>`
    child element is taken directly from the corresponding cell metadata where we
    configured the map in *Part 1*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 该界面的中央`<div>`元素是Mapbox地图，默认显示所有机场的Mapbox地图。如上面的代码所示，`<pd_options>`子元素直接取自相应单元格的元数据，其中我们在*第1部分*中配置了地图。
- en: 'On the left-hand side, we generate a set of checkboxes corresponding to each
    centrality index, using a Jinja2 `{%for …%}` loop over the `centrality_indices`
    variable. We initialize this variable in the `setup()` method of the `USFlightsAnalysis`
    PixieApp which is guaranteed to be called when the PixieApp starts. This variable
    is an OrderedDict ([https://docs.python.org/3/library/collections.html#collections.OrderedDict](https://docs.python.org/3/library/collections.html#collections.OrderedDict))
    with keys as the centrality index and values as a color scheme that will be used
    in the Mapbox rendering:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们通过Jinja2的`{%for …%}`循环，针对每个中心性指数生成一组复选框，循环的目标是`centrality_indices`变量。我们在`USFlightsAnalysis`
    PixieApp的`setup()`方法中初始化了这个变量，该方法在PixieApp启动时必定会被调用。此变量是一个OrderedDict（[https://docs.python.org/3/library/collections.html#collections.OrderedDict](https://docs.python.org/3/library/collections.html#collections.OrderedDict)），键是中心性指数，值是将用于Mapbox渲染的颜色方案：
- en: '[PRE41]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode22.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode22.py)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode22.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode22.py)'
- en: 'The following output shows the analysis screen with no centrality index selected:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了未选择中心性指数的分析界面：
- en: '![Part 2 – Creating the USFlightsAnalysis PixieApp](img/B09699_09_20.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![第二部分 – 创建USFlightsAnalysis PixieApp](img/B09699_09_20.jpg)'
- en: Analysis screen with no centrality index selected
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 未选择中心性指数的分析界面
- en: We now arrive at the step where the user selects a centrality index to trigger
    a shortest path search. Each of the checkboxes have a `pd_script` attribute that
    calls the `compute_toggle_centrality_layer()` method. This method is responsible
    for calling the NetworkX `dijkastra_path()` method with a `weight` argument generated
    by calling the `compute_weight()` method that we discussed in *Part 1*. This method
    returns an array with each airport that constitutes the shortest path. Using this
    path, we then create a JSON object that contains the GeoJSON payload as a set
    of lines to be displayed on the map.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在到达了用户选择中心性指数以触发最短路径搜索的步骤。每个复选框都有一个`pd_script`属性，调用`compute_toggle_centrality_layer()`方法。该方法负责调用NetworkX的`dijkstra_path()`方法，并传入一个`weight`参数，该参数通过调用我们在*第1部分*中讨论的`compute_weight()`方法生成。此方法返回一个包含构成最短路径的每个机场的数组。利用该路径，我们创建一个包含GeoJSON有效负载的JSON对象，该有效负载作为一组要显示在地图上的线路。
- en: At this point, it's worth pausing to discuss what a layer is. A **layer** is
    defined using the GeoJSON format ([http://geojson.org](http://geojson.org)) which
    we briefly discussed in [Chapter 5](ch05.xhtml "Chapter 5. Python and PixieDust
    Best Practices and Advanced Concepts"), *Python and PixieDust Best Practices and
    Advanced Concepts*. As a reminder, a GeoJSON payload is a JSON object with a specific
    schema that includes among other things a `geometry` element that defines the
    shape of the object being drawn.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，值得暂停讨论一下什么是图层。**图层**是使用GeoJSON格式（[http://geojson.org](http://geojson.org)）定义的，我们在[第5章](ch05.xhtml
    "第5章. Python和PixieDust最佳实践与高级概念")中简要讨论过，*Python和PixieDust最佳实践与高级概念*。提醒一下，GeoJSON有效负载是一个具有特定模式的JSON对象，其中包括定义绘制对象形状的`geometry`元素等内容。
- en: 'For example, we can define a line using the `LineString` type and an array
    of longitude and latitude coordinates for both ends of the line:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`LineString`类型和一个包含线路两端经纬度坐标的数组来定义一条线：
- en: '[PRE42]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode23.json](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode23.json)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode23.json](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode23.json)'
- en: 'Assuming we can generate this GeoJSON payload from the shortest path, we may
    wonder how to pass it to the PixieDust Mapbox renderer so that it can be displayed.
    Well, the mechanism is pretty simple: the Mapbox renderer will introspect the
    host PixieApp for any class variable that conforms to a specific format and use
    it to generate the Mapbox layer to be displayed. To help with conforming with
    this mechanism, we use the `MapboxBase` utility class that we briefly introduced
    earlier. This class has a `get_layer_index()` method that takes a unique name
    (we use the `centrality` index) as an argument and returns its index. It also
    takes an extra optional argument that creates the layer in case it doesn''t already
    exist. We then call the `toggleLayer()` method passing the layer index as an argument
    to turn the layer on and off.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们能够从最短路径生成这个GeoJSON有效载荷，我们可能会想知道如何将其传递给PixieDust Mapbox渲染器，以便显示。其实，机制非常简单：Mapbox渲染器会检查主机PixieApp中是否有符合特定格式的类变量，并利用它生成要显示的Mapbox图层。为了帮助遵循这一机制，我们使用了之前简要介绍的`MapboxBase`工具类。该类有一个`get_layer_index()`方法，接受一个唯一的名称（我们使用`centrality`索引）作为参数并返回其索引。它还接受一个额外的可选参数，在图层不存在时创建该图层。然后，我们调用`toggleLayer()`方法，传递图层索引作为参数来打开和关闭图层。
- en: 'The following code shows the implementation of the `compute_toggle_centrality_layer()`
    method that implements the aforementioned steps:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`compute_toggle_centrality_layer()`方法的实现，该方法实现了上述步骤：
- en: '[PRE43]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode24.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode24.py)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode24.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode24.py)'
- en: 'The coordinates in the geometry object are computed using the `get_airport_location()`
    method that queries the `airports_centrality` DataFrame that we created in *Part
    1*, as shown in the following code:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 几何对象中的坐标是使用`get_airport_location()`方法计算的，该方法查询了我们在*第1部分*中创建的`airports_centrality`数据框，如下代码所示：
- en: '[PRE44]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode25.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode25.py)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode25.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode25.py)'
- en: 'The layer object passed to the `get_layer_index()` method has the following
    properties:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`get_layer_index()`方法的图层对象具有以下属性：
- en: '`name`: String that uniquely identifies the layer.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：唯一标识图层的字符串。'
- en: '`geojson`: GeoJSON object that defines the features and geometry of the layer.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geojson`：GeoJSON对象，定义了图层的特征和几何形状。'
- en: '`url`: Used only if `geojson` is not present. Points at a URL that returns
    a GeoJSON payload.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：仅在`geojson`不存在时使用。指向一个返回GeoJSON有效载荷的URL。'
- en: '`paint`: Optional extra properties specific to Mapbox specification that defines
    how the layer data is styled, for example, color, width, and opacity.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paint`：Mapbox规范中定义的可选附加属性，指定图层数据的样式，例如颜色、宽度和透明度。'
- en: '`layout`: Optional extra properties specific to Mapbox specification that defines
    how the layer data is drawn, for example, fill, visibility, and symbol.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout`：Mapbox规范中定义的可选附加属性，指定图层数据的绘制方式，例如填充、可见性和符号。'
- en: Note
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: You can find more information about Mapbox layout and paint properties
    here:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：你可以在这里找到更多关于Mapbox布局和绘制属性的信息：'
- en: '[https://www.mapbox.com/mapbox-gl-js/style-spec/#layers](https://www.mapbox.com/mapbox-gl-js/style-spec/#layers)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.mapbox.com/mapbox-gl-js/style-spec/#layers](https://www.mapbox.com/mapbox-gl-js/style-spec/#layers)'
- en: In the preceding code, we specify extra `paint` properties to configure the
    `line-width` and the `line-color` which we take from the `centrality_indices`
    JSON object defined in the `setup()` method.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们指定了额外的`paint`属性来配置`line-width`和`line-color`，这些属性来自在`setup()`方法中定义的`centrality_indices`
    JSON对象。
- en: 'The following output shows the shortest path for a flight from `BOS` to `PSC`
    using the **ELAPSED_TIME** (in red) and the **DEGREE** (in green) centrality indices:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了从`BOS`到`PSC`的最短飞行路径，使用了**ELAPSED_TIME**（红色）和**DEGREE**（绿色）中心性指标：
- en: '![Part 2 – Creating the USFlightsAnalysis PixieApp](img/B09699_09_21.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![第2部分 – 创建USFlightsAnalysis PixieApp](img/B09699_09_21.jpg)'
- en: Displaying the shortest path from BOS to PSC using the ELAPSED_TIME and DEGREE
    centrality indices
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ELAPSED_TIME和DEGREE中心性指标显示从BOS到PSC的最短路径
- en: In this section, we've built a PixieApp that provides visualization of the shortest
    path between two airports using the PixieDust Mapbox renderer. We've shown how
    to create a new layer to enrich the map with extra information using the `MapboxBase`
    utility class.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们构建了一个PixieApp，它使用PixieDust Mapbox渲染器可视化两个机场之间的最短路径。我们展示了如何使用`MapboxBase`工具类创建新图层，以丰富地图信息。
- en: Note
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the completed Notebook for *Part 2* here:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到完成的Notebook文件，*第二部分*：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%202.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%202.ipynb)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%202.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%202.ipynb)'
- en: In the next section, we'll add additional data exploration related to flight
    delays and associated airlines.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将添加与航班延误和相关航空公司有关的额外数据探索内容。
- en: Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分 – 向USFlightsAnalysis PixieApp添加数据探索功能
- en: 'In this section, we want to extend the route analysis screen of the `USFlightsAnalysis`
    PixieApp to add two charts showing the historical arrival delay for each airline
    that flies out of the selected origin airport: one for all the flights coming
    out of the origin airport and one for all the flights regardless of airport. This
    will give us a way to compare visually whether the delay for a particular airport
    is better or worse than for all the other airports.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们希望扩展`USFlightsAnalysis` PixieApp的路线分析界面，添加两张图表，展示从选定起始机场起飞的每个航空公司的历史到达延误情况：一张显示所有从该机场起飞的航班，另一张则显示所有航班（不管机场在哪里）。这将使我们能够直观地比较特定机场的延误情况与其他机场的延误情况。
- en: 'We start by implementing a method that selects the flights for a given airline.
    We also add an optional airport argument that can be used to control whether we include
    all flights or only the one that originates from this airport. The returned DataFrame
    should have two columns: `DATE` and `ARRIVAL_DELAY`.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从实现一个方法开始，该方法选择给定航空公司的航班。我们还添加了一个可选的机场参数，可以用来控制是包括所有航班，还是仅包括从该机场起飞的航班。返回的DataFrame应该包含两列：`DATE`和`ARRIVAL_DELAY`。
- en: 'The following code shows the implementation of this method:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了此方法的实现：
- en: '[PRE45]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode26.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode26.py)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode26.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode26.py)'
- en: 'We can test the preceding code by using it with Delta flights from Boston.
    We can then call the PixieDust `display()` method to create a line chart that
    we''ll use in the PixieApp:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用它来测试前面的代码，选择波士顿的Delta航班。然后，我们可以调用PixieDust的`display()`方法，创建一个线性图表，在PixieApp中使用：
- en: '[PRE46]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the PixieDust output we select the **Line Chart** menu and configure the
    options dialog as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在PixieDust输出中，我们选择**折线图**菜单，并按如下方式配置选项对话框：
- en: '![Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp](img/B09699_09_22.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![第三部分 – 向USFlightsAnalysis PixieApp添加数据探索功能](img/B09699_09_22.jpg)'
- en: The options dialog for generating an arrival delay line chart for Delta flights
    out of Boston
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 为生成波士顿出发的Delta航班到达延误线性图表的选项对话框
- en: 'When clicking **OK**, we get the following chart:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**后，我们得到以下图表：
- en: '![Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp](img/B09699_09_23.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![第三部分 – 向USFlightsAnalysis PixieApp添加数据探索功能](img/B09699_09_23.jpg)'
- en: Chart delay for all Delta flights coming out of Boston
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 展示所有从波士顿起飞的Delta航班的延误情况
- en: 'As we are going to use this chart in the PixieApp, it is a good idea to copy
    the JSON configuration from the **Edit Cell Metadata** dialog box:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在PixieApp中使用此图表，因此从**编辑单元格元数据**对话框复制JSON配置是个不错的主意：
- en: '![Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp](img/B09699_09_24.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![第三部分 – 向USFlightsAnalysis PixieApp添加数据探索功能](img/B09699_09_24.jpg)'
- en: PixieDust display() configuration for the delay chart that needs to be copied
    for the PixieApp
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: PixieDust display() 配置，用于延误图表，需要复制到PixieApp中
- en: 'Now that we know how to generate a delay chart, we can start designing the
    PixieApp. We start by changing the layout of the main screen to use the `TemplateTabbedApp`
    helper class that gives us the tabbed layout for free. The overall analysis screen
    is now driven by the `RouteAnalysisApp` child PixieApp that contains two tabs:
    the `Search Shortest Route` tab associated with the `SearchShortestRouteApp` child
    PixieApp and the `Explore Airlines` tab associated with the `AirlinesApp` child
    PixieApp.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何生成延迟图表了，可以开始设计 PixieApp。我们首先通过更改主屏幕的布局，使用 `TemplateTabbedApp` 辅助类，这样就能免费得到标签式布局。整体分析屏幕现在由
    `RouteAnalysisApp` 子类 PixieApp 驱动，包含两个标签：一个是与 `SearchShortestRouteApp` 子类 PixieApp
    相关的 `Search Shortest Route` 标签，另一个是与 `AirlinesApp` 子类 PixieApp 相关的 `Explore Airlines`
    标签。
- en: 'The following diagram provides a high-level flow of all the classes involved
    in the new layout:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表提供了新布局中涉及的所有类的高层次流程：
- en: '![Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp](img/B09699_09_25.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![第 3 部分 – 向 USFlightsAnalysis PixieApp 添加数据探索](img/B09699_09_25.jpg)'
- en: New tabbed layout class diagram
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 新的标签式布局类图
- en: 'The implementation for the `RouteAnalysisApp` is pretty straightforward using
    the `TemplateTabbedApp` as shown in the following code:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouteAnalysisApp` 的实现非常直接，使用 `TemplateTabbedApp`，如下代码所示：'
- en: '[PRE47]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode27.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode27.py)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode27.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode27.py)'
- en: The `SearchShortestRouteApp` child PixieApp is basically a copy of the main
    PixieApp class we created in *Part 2*. The only difference is that it is a child
    PixieApp of the `RouteAnalysisApp` which itself is a child PixieApp of the `USFlightsAnalysis`
    main PixieApp. Therefore, we need a mechanism for passing the origin and destination
    airport down to the respective child PixieApps. To achieve this, we use the `pd_options`
    attribute when instantiating the `RouteAnalysisApp` child PixieApp.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchShortestRouteApp` 子类 PixieApp 基本上是我们在*第 2 部分*中创建的主要 PixieApp 类的副本。唯一的不同是它是
    `RouteAnalysisApp` 的子类 PixieApp，而 `RouteAnalysisApp` 本身又是 `USFlightsAnalysis`
    主要 PixieApp 的子类。因此，我们需要一种机制将起始和目的地机场传递给各自的子类 PixieApp。为此，我们在实例化 `RouteAnalysisApp`
    子类 PixieApp 时使用 `pd_options` 属性。'
- en: 'In the `USFlightAnalysis` class, we change the `analyze_route` method to return
    a simple `<div>` element that triggers the `RouteAnalysisApp`. We also add a `pd_options`
    attribute with the `org_airport` and `dest_airport`, as shown in the following
    code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `USFlightAnalysis` 类中，我们将 `analyze_route` 方法更改为返回一个简单的 `<div>` 元素，该元素触发 `RouteAnalysisApp`。我们还添加了一个包含
    `org_airport` 和 `dest_airport` 的 `pd_options` 属性，如以下代码所示：
- en: '[PRE48]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode28.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode28.py)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode28.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode28.py)'
- en: 'Conversely, in the `setup()` method of the `SearchShortestRouteApp` child PixieApp,
    we read the values for `org_airport` and `dest_airport` from the options dictionary
    of the `parent_pixieapp`, as shown in the following code:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在 `SearchShortestRouteApp` 子类 PixieApp 的 `setup()` 方法中，我们从 `parent_pixieapp`
    的 options 字典中读取 `org_airport` 和 `dest_airport` 的值，如以下代码所示：
- en: '[PRE49]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode29.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode29.py)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode29.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode29.py)'
- en: '**Note**: The rest of the implementation of the `SearchShortestRouteApp` has
    been ommitted for brevity since it''s exactly the same as in *Part 2*. To access
    the implementation, please refer to the completed *Part 3* Notebook.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：由于 `SearchShortestRouteApp` 的其余实现与 *第 2 部分* 完全相同，因此已省略。若要访问实现，请参阅完整的
    *第 3 部分* Notebook。'
- en: 'The last PixieApp class to implement is the `AirlinesApp`, which that will
    display all the delay charts. Similar to the `SearchShortestRouteApp`, we store
    `org_airport` and `dest_airport` from the `parent_pixieapp` options dictionary.
    We also compute a list of tuples (code and name) for all the airlines that have
    flights out of the given `org_airport`. To do that, we use the pandas `groupby()`
    method on the `AIRLINE` column and get a list of the index values as shown in
    the following code:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要实现的PixieApp类是`AirlinesApp`，它将显示所有的延误图表。与`SearchShortestRouteApp`类似，我们从`parent_pixieapp`选项字典中存储了`org_airport`和`dest_airport`。我们还计算了一个元组列表（代码和名称），列出了所有从给定`org_airport`起飞的航空公司。为了实现这一点，我们使用pandas的`groupby()`方法对`AIRLINE`列进行分组，并获取索引值列表，代码如下所示：
- en: '[PRE50]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode30.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode30.py)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode30.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode30.py)'
- en: 'In the main screen of the `AirlinesApp`, we generate a set of rows for each
    of the airlines using the Jinja2 `{%for...%}` loop. In each row, we add two `<div>`
    elements that will hold the delay line chart for the given airline: one for flights
    coming out of the origin airport and one for all the flights for this airline.
    Each `<div>` element has a `pd_options attribute,` with the `org_airport` and
    `dest_airport` as state attributes, which triggers the `delay_airline_screen`
    route. We also add a `delay_org_airport` Boolean state attribute to denote which
    type of delay chart we want to display. To make sure the `<div>` element is rendered
    immediately, we add the `pd_render_onload` attribute as well.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AirlinesApp`的主屏幕上，我们使用Jinja2的`{%for...%}`循环为每个航空公司生成一组行。在每一行中，我们添加两个`<div>`元素，用于显示给定航空公司的延误折线图：一个用于显示从起始机场出发的航班，另一个用于显示该航空公司的所有航班。每个`<div>`元素都有一个`pd_options`属性，其中`org_airport`和`dest_airport`作为状态属性，触发`delay_airline_screen`路由。我们还添加了一个`delay_org_airport`布尔状态属性，用于表示我们想要显示哪种类型的延误图表。为了确保`<div>`元素能够立即渲染，我们还添加了`pd_render_onload`属性。
- en: 'The following code shows the implementation of the `AirlinesApp` default route:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`AirlinesApp`默认路由的实现：
- en: '[PRE51]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode31.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode31.py)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode31.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode31.py)'
- en: 'The `delay_airline_screen()` route has three parameters:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay_airline_screen()`路由有三个参数：'
- en: '`delay_org_airport`: `true` if we only want the flights coming out of the origin
    airport, and `false` if we want all the flights for the given airline. We use
    this flag to build the mask for filtering the data out of the flights DataFrame.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay_org_airport`：如果我们只想显示从起始机场出发的航班，则为`true`；如果我们想显示该航空公司的所有航班，则为`false`。我们使用这个标志来构建过滤航班DataFrame数据的掩码。'
- en: '`airline_code`: The IATA code for the given airline.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`airline_code`：给定航空公司的IATA代码。'
- en: '`airline_name`: The full name of the airline. We''ll use this when building
    the UI in the Jinja2 template.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`airline_name`：航空公司的全名。在构建Jinja2模板的UI时我们会使用这个值。'
- en: In the body of the `delay_airline_screen()` method, we also compute the average
    delay for the selected data in the `average_delay` local variable. As a reminder,
    in order to use this variable in the Jinja2 template, we use the `@templateArgs`
    decorator, which automatically makes all local variables available in the Jinja2
    template.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在`delay_airline_screen()`方法的主体中，我们还计算了所选数据的平均延误，并将结果保存在`average_delay`局部变量中。提醒一下，为了在Jinja2模板中使用此变量，我们使用了`@templateArgs`装饰器，它会自动使所有局部变量在Jinja2模板中可用。
- en: 'The `<div>` element that holds the chart has a `pd_entity` attribute that uses
    the `compute_delay_airline_df()` method that we created at the beginning of this
    section. However, we needed to rewrite this method as a member of the class since
    the arguments have changed: `org_airport` is now a class variable, and `delay_org_airport`
    is now a String Boolean. We also add a `<pd_options>` child element with the PixieDust
    `display()` JSON configuration that we copied from the **Edit Cell Metadata**
    dialog.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 承载图表的 `<div>` 元素具有一个 `pd_entity` 属性，使用我们在本节开头创建的 `compute_delay_airline_df()`
    方法。然而，由于参数发生了变化，我们需要将此方法重写为类的成员：`org_airport` 现在是一个类变量，`delay_org_airport` 现在是一个字符串布尔值。我们还添加了一个
    `<pd_options>` 子元素，其中包含我们从 **编辑单元格元数据** 对话框复制的 PixieDust `display()` JSON 配置。
- en: 'The following code shows the implementation of the `delay_airline_screen()`
    route:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 `delay_airline_screen()` 路由的实现：
- en: '[PRE52]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode32.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode32.py)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode32.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode32.py)'
- en: 'The `compute_delay_airline_df()` method has two arguments: airlines that correspond
    to the IATA code and the `delay_org_airport` String Boolean. We already covered
    implementation of this method, but the new adapted code is provided here:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`compute_delay_airline_df()` 方法有两个参数：对应IATA代码的航空公司和 `delay_org_airport` 字符串布尔值。我们已经介绍了该方法的实现，但这里提供了更新后的代码：'
- en: '[PRE53]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode33.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode33.py)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode33.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode33.py)'
- en: Running the `USFlightsAnalysis` PixieApp with BOS and PSC as the origin and destination
    airports respectively, we click on the **Explore Airlines** tab.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `USFlightsAnalysis` PixieApp，将BOS和PSC分别设置为起点和终点机场时，我们点击 **探索航空公司** 标签。
- en: 'The results are shown in the following screenshot:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下图所示：
- en: '![Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp](img/B09699_09_26.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![Part 3 – 向 USFlightsAnalysis PixieApp 添加数据探索](img/B09699_09_26.jpg)'
- en: Delay line charts for all the airlines that provide services from Boston airport
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 显示所有从波士顿机场提供服务的航空公司的延误线图
- en: In this section, we provide another example of how to use the PixieApp programming
    model to build powerful dashboards that provide visualization and insights into
    the output of the analytics developed in the Notebook.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们提供了另一个示例，展示如何使用PixieApp编程模型构建强大的仪表盘，提供可视化和分析结果的洞察，展示Notebook中开发的分析输出。
- en: Note
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The completed Notebook for *Part 3* of the `USFlightsAnalysis` PixieApp can
    be found here:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 *Part 3* Notebook 可在以下位置找到：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%203.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%203.ipynb)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%203.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%203.ipynb)'
- en: In the next section, we'll build an ARIMA model that tries to predict flight
    delays.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将构建一个ARIMA模型，尝试预测航班延误。
- en: Part 4 – Creating an ARIMA model for predicting flight delays
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分 - 创建一个ARIMA模型来预测航班延误
- en: 'In [Chapter 8](ch08.xhtml "Chapter 8. Analytics Study: Prediction - Financial
    Time Series Analysis and Forecasting"), *Analytics Study: Prediction - Financial
    Time Series Analysis and Forecasting*, we used time series analysis to build a
    forecasting model for predicting financial stocks. We can actually use the same
    technique in flight delays since, after all, we are also dealing here with time
    series, and so in this section, we''ll follow the exact same steps. For each destination
    airport and optional airline, we''ll build a pandas DataFrame that contains matching
    flight information.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.xhtml "第8章：分析研究：预测 - 财务时间序列分析与预测")，*分析研究：预测 - 财务时间序列分析与预测*中，我们使用时间序列分析构建了一个预测金融股票的预测模型。我们实际上可以使用相同的技术来分析航班延误，因为毕竟我们这里处理的也是时间序列，因此，在本节中，我们将遵循完全相同的步骤。对于每个目的地机场和可选航空公司，我们将构建一个包含匹配航班信息的pandas
    DataFrame。
- en: Note
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: We''ll use the `statsmodels` library again. Make sure to install
    it if you haven''t done so already and refer to [Chapter 8](ch08.xhtml "Chapter 8. Analytics
    Study: Prediction - Financial Time Series Analysis and Forecasting"), *Analytics
    Study: Prediction - Financial Time Series Analysis and Forecasting* for more information.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：我们将再次使用`statsmodels`库。如果你还没有安装它，请确保先安装，并参考[第8章](ch08.xhtml "第8章. 分析学习：预测
    - 金融时间序列分析与预测")，*分析学习：预测 - 金融时间序列分析与预测*，获取更多信息。'
- en: 'As an example, let''s focus on all the Delta (`DL`) flights with `BOS` as the
    destination:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，让我们关注所有以`BOS`为目的地的Delta（`DL`）航班：
- en: '[PRE54]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Using the `ARRIVAL_DELAY` column as a value for our time series, we plot the
    ACF and PACF plots to identify trends and seasonality as shown in the following
    code:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ARRIVAL_DELAY`列作为时间序列的值，我们绘制ACF和PACF图来识别趋势和季节性，如下代码所示：
- en: '[PRE55]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode34.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode34.py)'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode34.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode34.py)'
- en: 'The result is shown in the following screenshot:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_27.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![Part 4 – 创建ARIMA模型预测航班延误](img/B09699_09_27.jpg)'
- en: Autocorrelation function for the ARRIVAL_DELAY data
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: ARRIVAL_DELAY数据的自相关函数
- en: 'Similarly, we also plot the partial autocorrelation function using the following
    code:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用以下代码绘制偏自相关函数：
- en: '[PRE56]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode35.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode35.py)'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode35.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode35.py)'
- en: 'The results are shown here:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_28.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![Part 4 – 创建ARIMA模型预测航班延误](img/B09699_09_28.jpg)'
- en: Partial Autocorrelation for the ARRIVAL_DELAY data
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: ARRIVAL_DELAY数据的偏自相关
- en: 'From the preceding charts, we can hypothesize that the data has a trend and/or
    seasonality, and that it is not stationary. Using the log difference technique
    that we explained in [Chapter 8](ch08.xhtml "Chapter 8. Analytics Study: Prediction
    - Financial Time Series Analysis and Forecasting"), *Analytics Study: Prediction
    - Financial Time Series Analysis and Forecasting*, we transform the series and
    visualize it with the PixieDust `display()` method, as shown in the following
    code:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，我们可以推测数据具有趋势和/或季节性，并且它不是平稳的。使用我们在[第8章](ch08.xhtml "第8章. 分析学习：预测 - 金融时间序列分析与预测")，*分析学习：预测
    - 金融时间序列分析与预测*中解释的对数差分技术，我们转换该序列，并使用PixieDust的`display()`方法进行可视化，如以下代码所示：
- en: Note
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: We also make sure to remove the rows with NA and Infinite values
    by first calling the `replace()` method to replace `np.inf` and `-np.inf` with
    `np.nan`, and then call the `dropna()` method to remove all the rows with the
    `np.nan` value.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：我们还确保通过首先调用`replace()`方法将`np.inf`和`-np.inf`替换为`np.nan`，然后调用`dropna()`方法移除所有包含`np.nan`值的行，从而移除包含NA和无限值的行。'
- en: '[PRE57]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode36.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode36.py)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode36.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode36.py)'
- en: 'The following screenshot shows the PixieDust option dialog:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了PixieDust选项对话框：
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_29.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![Part 4 – 创建ARIMA模型预测航班延误](img/B09699_09_29.jpg)'
- en: Options dialog for the log difference of the ARRIVAL_DELAY data
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: ARRIVAL_DELAY数据的对数差分选项对话框
- en: 'After clicking **OK**, we get the following results:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**后，我们得到以下结果：
- en: Note
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: When running the preceding code, you may not get the exact same chart
    as shown in the following screenshot. This is because we configure the **# of
    Rows to Display** in the options dialog to be `100` which means that PixieDust
    will take a sample of size 100 before creating the chart.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：在运行上述代码时，你可能不会得到与以下截图完全相同的图表。这是因为我们在选项对话框中将**显示行数**配置为`100`，这意味着PixieDust将在创建图表之前从中抽取100个样本。'
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_30.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![Part 4 – 创建用于预测航班延误的ARIMA模型](img/B09699_09_30.jpg)'
- en: Log difference line chart of the ARRIVAL_DELAY data
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: ARRIVAL_DELAY数据的对数差分折线图
- en: 'The preceding chart looks stationary; we can reinforce this hypothesis by plotting
    the ACF and PACF again on the log difference as shown in the following code:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图看起来是平稳的；我们可以通过对对数差分重新绘制ACF和PACF来强化这个假设，如下代码所示：
- en: '[PRE58]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode37.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode37.py)'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode37.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode37.py)'
- en: 'The results are as follows:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_31.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![Part 4 – 创建用于预测航班延误的ARIMA模型](img/B09699_09_31.jpg)'
- en: ACF chart for the log difference of the ARRIVAL_DELAY data
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: ARRIVAL_DELAY数据的对数差分ACF图
- en: 'In the following code, we do the same thing for the PACF:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们对PACF进行了相同的操作：
- en: '[PRE59]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode38.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode38.py)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode38.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode38.py)'
- en: 'The results are as follows:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_32.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![Part 4 – 创建用于预测航班延误的ARIMA模型](img/B09699_09_32.jpg)'
- en: PACF chart for the log difference of the ARRIVAL_DELAY data
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: ARRIVAL_DELAY数据的对数差分PACF图
- en: 'As a reminder from [Chapter 8](ch08.xhtml "Chapter 8. Analytics Study: Prediction
    - Financial Time Series Analysis and Forecasting"), *Analytics Study: Prediction
    - Financial Time Series Analysis and Forecasting*, an ARIMA model is composed
    of three orders: *p*, *d*, and *q*. From the preceding two charts, we can infer
    these orders for the ARIMA model we want to build:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，参考[第8章](ch08.xhtml "第8章：分析研究：预测 - 财务时间序列分析与预测")，*分析研究：预测 - 财务时间序列分析与预测*，ARIMA模型由三个阶数组成：*p*、*d*和*q*。从前面的两张图，我们可以推断出我们要构建的ARIMA模型的这些阶数：
- en: '**Autoregression order p is 1**: Corresponds to the first time the ACF crosses
    the significance level'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自回归阶数p为1**：对应ACF首次穿越显著性水平的时刻'
- en: '**Integration order d is 1**: We had to do a log difference once'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**差分阶数d为1**：我们进行了1次对数差分'
- en: '**Moving average order q is 1**: Corresponds to the first time the PACF crosses
    the significance level'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动平均阶数q为1**：对应PACF首次穿越显著性水平的时刻'
- en: 'Based on these hypotheses, we can build an ARIMA model using the `statsmodels`
    package and get information about its residual error, as shown in the following
    code:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些假设，我们可以使用`statsmodels`包构建ARIMA模型，并获取其残差误差信息，如下代码所示：
- en: '[PRE60]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode39.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode39.py)'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode39.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode39.py)'
- en: 'The results are shown as follows:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE61]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As we can see, the mean error is only 0.003 which is pretty good, so we're ready
    to run the model with values from the `train_set` and visualize the discrepencies
    with the actual values.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，均值误差仅为0.003，非常好，因此我们可以准备使用`train_set`中的数据运行模型，并将结果与实际值的差异可视化。
- en: 'The following code uses the ARIMA `plot_predict()` method to create the chart:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用ARIMA的`plot_predict()`方法创建图表：
- en: '[PRE62]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note
  id: totrans-506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode40.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode40.py)'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode40.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode40.py)'
- en: 'The results are shown as follows:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_33.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![Part 4 – 创建用于预测航班延误的ARIMA模型](img/B09699_09_33.jpg)'
- en: Forecast versus actual
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 预测与实际值对比
- en: In the preceding chart, we can clearly see that the forecast line is much smoother
    than the actual values. This makes sense since, in reality, there are always unexpected
    reasons for delays that can be treated as outliers and therefore hard to model.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以清晰地看到，预测线比实际值平滑得多。这是有道理的，因为实际上，航班延误总是会有一些意外的原因，这些原因可能会被视为离群值，因此很难进行建模。
- en: 'We still need to use the `test_set` to validate the model with data not yet
    seen by the model. The following code creates a `compute_test_set_predictions()`
    method to compare forecast and test data and visualize the results using the PixieDust
    `display()` method:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要使用`test_set`来验证模型，使用的是模型尚未见过的数据。以下代码创建了一个`compute_test_set_predictions()`方法，用于比较预测数据和测试数据，并通过PixieDust的`display()`方法可视化结果：
- en: '[PRE63]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'You can find the code file here:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode41.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode41.py)'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode41.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode41.py)'
- en: 'The PixieDust options dialog is shown here:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的是PixieDust选项对话框：
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_34.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![第4部分 – 创建ARIMA模型以预测航班延误](img/B09699_09_34.jpg)'
- en: Options dialog for the forecast versus test comparison line chart
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 预测与测试对比折线图的选项对话框
- en: 'After clicking **OK**, we get the following results:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**后，我们得到以下结果：
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_35.jpg)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
  zh: '![第4部分 – 创建ARIMA模型以预测航班延误](img/B09699_09_35.jpg)'
- en: Forecast versus Test Data line chart
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 预测值与测试数据的折线图
- en: We are now ready to integrate this model into our `USFlightsAnalysis` PixieApp,
    by adding a third tab to the `RouteAnalysisApp` main screen called `Flight Delay
    Prediction`. This tab will be driven by a new child PixieApp called `PredictDelayApp`
    that will let the user select a flight segment of the shortest path computed using
    the Dijkstra shortest path algorithm with `DEGREE` as the centrality index. The
    user will also be able to select an airline, in which case the training data will
    be limited to flights operated by the selected airline.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备将这个模型集成到我们的`USFlightsAnalysis` PixieApp中，通过在`RouteAnalysisApp`主界面添加一个新的选项卡，名为`航班延误预测`。该选项卡将由一个名为`PredictDelayApp`的新子PixieApp驱动，用户可以选择使用Dijkstra最短路径算法计算出的最短路径航班段，`DEGREE`作为中心性指标。用户还可以选择航空公司，在这种情况下，训练数据将仅限于由所选航空公司运营的航班。
- en: 'In the following code, we create the `PredictDelayApp` child PixieApp and implement
    the `setup()` method that computes the Dijkstra shortest path for the selected
    origin and destination airports:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们创建了`PredictDelayApp`子PixieApp并实现了`setup()`方法，计算所选起点和终点机场的Dijkstra最短路径：
- en: '[PRE64]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the default route of the `PredictDelayApp`, we use the Jinja2 `{%for..%}`
    loop to build two drop-down boxes that display the flight segment and the airlines,
    as shown in the following code:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PredictDelayApp`的默认路由中，我们使用Jinja2的`{%for..%}`循环构建了两个下拉框，显示航班段和航空公司，如下所示：
- en: '[PRE65]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'You can find the code file here:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode42.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode42.py)'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode42.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode42.py)'
- en: The two drop-downs have a `pd_refresh` attribute that points to the `<div>`
    element with ID `prediction_graph{{prefix}}`. When triggered, this `<div>` element
    invokes the `predict_screen()` route using the `flight_segment` and `airline`
    state attributes.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个下拉框具有`pd_refresh`属性，该属性指向ID为`prediction_graph{{prefix}}`的`<div>`元素。当触发时，该`<div>`元素会调用`predict_screen()`路由，并使用`flight_segment`和`airline`的状态属性。
- en: In the `predict_screen()` route, we use the `flight_segment` and `airline` arguments
    to create the training dataset, build an ARIMA model that forecasts the model,
    and visualize the results in a line chart that compares the forecast and the actual
    values.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在`predict_screen()`路由中，我们使用`flight_segment`和`airline`参数来创建训练数据集，建立一个ARIMA模型来进行预测，并通过折线图展示预测值与实际值的对比。
- en: Note
  id: totrans-534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Time series forecast models are limited to predictions that are close to the
    actual data, and since we only have data from 2015, we can't really use this model
    to predict more recent data. Of course, in a production application, it is assumed
    that we have flight data that is current and therefore this wouldn't be a problem.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列预测模型的限制在于只能预测接近实际数据的结果，由于我们只有2015年的数据，因此无法使用该模型预测更新的数据。当然，在生产应用中，假设我们有当前的航班数据，因此这不会是一个问题。
- en: 'The following code shows the implementation of the `predict_screen()` route:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`predict_screen()`路由的实现：
- en: '[PRE66]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode43.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode43.py)'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode43.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode43.py)'
- en: In the following code, we also wanted to make sure that the dataset index is
    deduplicated to avoid errors when plotting the results. This is done by filtering
    the duplicated indices using `df = df[~df.index.duplicated(keep='first')]`.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们还希望确保数据集索引去重，以避免在绘制结果时发生错误。通过使用`df = df[~df.index.duplicated(keep='first')]`来过滤重复的索引。
- en: 'The last thing left to do is to wire the `PredictDelayApp` child PixieApp to
    the `RouteAnalysisApp` as shown in the following code:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是将`PredictDelayApp`子应用PixieApp接入到`RouteAnalysisApp`，如下代码所示：
- en: '[PRE67]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode44.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode44.py)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode44.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode44.py)'
- en: When we run the `USFlightsAnalysis` PixieApp using BOS and PSC as we did in
    the previous sections. In the **Flight Delay Prediction** tab, we select the **BOS->DEN**
    flight segment.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`USFlightsAnalysis` PixieApp并使用BOS和PSC，如前几节所做的那样，在**航班延误预测**标签页中，选择**BOS->DEN**航班段。
- en: 'The results are shown as follows:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_36.jpg)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![Part 4 – 创建一个ARIMA模型来预测航班延误](img/B09699_09_36.jpg)'
- en: Forecast for the Boston to Denver flight segment
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 波士顿到丹佛航段的预测
- en: In this section, we've shown how to use time series forecasting models to predict
    flight delays based on historical data.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何使用时间序列预测模型基于历史数据来预测航班延误。
- en: Note
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the complete Notebook here:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到完整的Notebook：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%204.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%204.ipynb)'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%204.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%204.ipynb)'
- en: As a reminder, while this is only a sample application which has a lot of room
    for improvement, the techniques for operationalizing data analytics using the
    PixieApp programming model would apply just the same in any other project.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，虽然这只是一个示例应用，仍有很多改进空间，但使用PixieApp编程模型将数据分析转化为实际应用的技巧，在任何其他项目中也同样适用。
- en: Summary
  id: totrans-556
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've discussed graphs and its associated graph theory, exploring
    its data structure and algorithms. We've also briefly introduced the `networkx`
    Python library that provides a rich set of APIs for manipulating and visualizing
    graphs. We then applied these techniques toward building a sample application
    that analyzes flight data by treating it as a graph problem with airports being
    the vertices and flights the edges. As always, we've also shown how to operationalize
    these analytics into a simple yet powerful dashboard that can run directly in
    the Jupyter Notebook and then optionally be deployed as a web analytics application
    with the PixieGateway microservice.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了图形及其相关的图论，探索了图的结构和算法。我们还简要介绍了`networkx` Python库，它提供了一套丰富的API，用于操作和可视化图形。然后，我们将这些技巧应用于构建一个示例应用，该应用通过将航班数据视为图问题（机场为顶点，航班为边）来进行分析。像往常一样，我们还展示了如何将这些分析转化为一个简单而强大的仪表盘，该仪表盘可以直接在Jupyter
    Notebook中运行，然后可以选择性地作为Web分析应用通过PixieGateway微服务部署。
- en: This chapter completes the series of sample applications that cover many important
    industry use cases. In the next chapter, I offer some final thoughts about the
    theme of this book which is to bridge the gap between data science and engineering
    by making working with data simple and accessible to all.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成了一系列涵盖许多重要行业应用的示例。在下一章中，我将对本书的主题做一些最终的思考，主题是通过简化和使数据工作变得对所有人可及，架起数据科学与工程之间的桥梁。
