- en: Namespaces, Scopes, and Modules
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间、作用域和模块
- en: In this chapter, we'll cover Python modules. Modules are files containing functions
    and class definitions. The concept of a namespace and the scope of variables across
    functions and modules are also explained in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Python 模块。模块是包含函数和类定义的文件。本章还解释了命名空间和跨函数和模块的变量作用域的概念。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Namespaces
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: The scope of a variable
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的作用域
- en: Modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: 13.1 Namespaces
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.1 命名空间
- en: Names of Python objects, such as the names of variables, classes, functions,
    and modules, are collected in namespaces. Modules and classes have their own named namespaces
    with the same name as these objects. These namespaces are created when a module
    is imported or a class is instantiated. The lifetime of a namespace of a module
    is as long as the current Python session. The lifetime of a namespace of a class
    instance is until the instance is deleted.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对象的名称，如变量、类、函数和模块的名称，都集中在命名空间中。模块和类具有它们自己的命名空间，与这些对象的名称相同。这些命名空间在导入模块或实例化类时创建。模块的命名空间的生存期与当前
    Python 会话一样长。类实例的命名空间的生存期是直到实例被删除。
- en: Functions create a local namespace when they are executed (invoked). It is deleted
    when the function stops the execution with a regular return or an exception. Local
    namespaces are unnamed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被执行（调用）时，函数会创建一个局部命名空间。当函数通过常规返回或异常停止执行时，局部命名空间将被删除。局部命名空间是无名的。
- en: 'The concept of namespaces puts a variable name in its context. For example,
    there are several functions with the name `sin` and they are distinguished by
    the namespace they belong to, as shown in the following code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间的概念将变量名放置在其上下文中。例如，有几个名为`sin`的函数，它们通过所属的命名空间进行区分，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'They are indeed different, as `numpy.sin` is a universal function accepting
    lists or arrays as input, while `math.sin` takes only floats. A list with all
    the names in a particular namespace can be obtained with the command `dir(<name
    of the namespace>)`. It contains two special names, `__name__` and `__doc__`.
    The former refers to the name of the module and the latter to its docstring:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它们确实不同，因为`numpy.sin`是一个通用函数，接受列表或数组作为输入，而`math.sin`仅接受浮点数。可以使用命令`dir(<name of
    the namespace>)`获取特定命名空间中所有名称的列表。它包含两个特殊名称，`__name__`指的是模块的名称，`__doc__`指的是其文档字符串：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There is a special namespace, `__builtin__`, which contains names that are
    available in Python without any `import`. It is a named namespace but its name
    needs not be given when referring to a built-in object:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊的命名空间，`__builtin__`，其中包含在 Python 中无需任何导入即可使用的名称。它是一个命名空间，但是在引用内置对象时不需要给出其名称：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's learn about the scope of a variable in the next section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节学习变量的作用域。
- en: 13.2 The scope of a variable
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.2 变量的作用域
- en: 'A variable defined in one part of a program does not need to be known in other
    parts. All program units to which a certain variable is known are called the *scope* of
    that variable. We''ll first give an example. Let''s consider the two nested functions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的一部分定义的变量不需要在其他部分中知道。已知某个变量的所有程序单元被称为该变量的*作用域*。我们先举一个例子。让我们考虑两个嵌套函数：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The execution of `my_function(3)` results in:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`my_function(3)`的结果是：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The variable `e` is in the namespace of the program unit that encloses the function `my_function`.
    The variable `a` is in the namespace of this function, which itself encloses the
    innermost function `other_function`. For the two functions, `e` is a global variable,
    that is, it is not in the local namespace and not listed by `dir()` but its value
    is available.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`e`位于包围函数`my_function`的程序单元的命名空间中。变量`a`位于该函数的命名空间中，该函数本身包围最内层的函数`other_function`。对于这两个函数，`e`是一个全局变量，即它不在本地命名空间中，也不会被`dir()`列出，但其值是可用的。
- en: 'It is a good practice to pass information to a function only by its parameter
    list and not use the construction from the preceding example. An exception can
    be found in [Section 7.7](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Anonymous
    functions*, where global variables are used for closures.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过参数列表将信息传递给函数，而不使用前面示例中的构造是一种良好的实践。一个例外可以在[第 7.7 节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)找到：*匿名函数*，在这里全局变量用于闭包。
- en: 'By assigning it a value, a variable automatically becomes a local variable:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为其分配一个值，变量自动成为局部变量：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This can be seen when executing the following code block:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码块时可以看到这一点：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the preceding code gives shows us the local variables of `my_function`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出显示了 `my_function` 的局部变量：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, `e` became a local variable. In fact, this piece of code now has two variables `e` belonging
    to different namespaces.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`e` 变成了一个局部变量。事实上，这段代码现在有两个 `e` 变量，分别属于不同的命名空间。
- en: 'By using the `global` declaration statement, a variable defined in a function
    can be made global, that is, its value will be accessible even outside this function.
    The use of a `global` declaration is demonstrated as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `global` 声明语句，可以将函数中定义的变量变为全局变量，也就是说，它的值即使在函数外部也可以访问。以下是使用 `global` 声明的示例：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It would be advisable to avoid using this construct and the use of `global`.
    Code using `global` is hard to debug and maintain. The use of classes makes the
    use of `global` mainly obsolete.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 建议避免使用这种构造以及 `global` 的使用。使用 `global` 的代码难以调试和维护。类的使用基本上使得 `global` 变得过时。
- en: 13.3 Modules
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.3 模块
- en: In Python, a module is simply a file containing classes and functions. By importing
    the file in your session or script, the functions and classes become usable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，模块只是一个包含类和函数的文件。通过在会话或脚本中导入该文件，函数和类就可以被使用。
- en: 13.3.1 Introduction
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3.1 介绍
- en: Python comes with many different libraries by default. You may also want to
    install more of those for specific purposes, such as optimization, plotting, reading/writing
    file formats, image handling, and so on. NumPy and SciPy are two important examples
    of such libraries, Matplotlib for plotting is another one. At the end of this
    chapter, we will list some useful libraries.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Python 默认带有许多不同的库。你可能还希望为特定目的安装更多的库，如优化、绘图、读写文件格式、图像处理等。NumPy 和 SciPy 是这类库的重要例子，Matplotlib
    是用于绘图的另一个例子。在本章结束时，我们将列出一些有用的库。
- en: To use a library, you may either
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用库的方法有两种：
- en: 'load only certain objects from a library, for example, from NumPy:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只从库中加载某些对象，例如，从 NumPy 中：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'load the entire library:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载整个库：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'or give access to an entire library by creating a namespace with the library
    name:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者通过创建一个与库名相同的命名空间来访问整个库：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Prefixing a function from the library with the namespace gives access to this
    function and distinguishes this function from other objects with the same name.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在库中的函数前加上命名空间，可以访问该函数，并将其与其他同名对象区分开来。
- en: 'Furthermore, the name of a namespace can be specified together with the `import` command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以在 `import` 命令中指定命名空间的名称：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Which of these alternatives you use affects the readability of your code as well as
    the possibilities for mistakes. A common mistake is shadowing:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择使用这些替代方式的方式会影响代码的可读性以及出错的可能性。一个常见的错误是变量覆盖（shadowing）：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A way to avoid this unintended effect is to use `import` instead of `from` and
    then access the command by referring to the namespace, here `sl`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种无意的效果的一种方法是使用 `import` 而不是 `from`，然后通过引用命名空间来访问命令，例如 `sl`：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Throughout this book, we have used many commands, objects, and functions. These
    were imported into the local namespace by statements such as:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中，我们使用了许多命令、对象和函数。这些通过类似以下语句被导入到本地命名空间中：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Importing objects in this manner does not make the module from which they are
    imported evident. Some examples are given in the following table (*Table 13.1*):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式导入对象不会显现它们来自的模块。以下表格给出了几个例子（*表 13.1*）：
- en: '| **Libraries** | **Methods** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **库** | **方法** |'
- en: '| `numpy` | `array`, `arange`, `linspace`, `vstack`, `hstack`, `dot`, `eye`, `identity`,
    and `zeros`. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `numpy` | `array`、`arange`、`linspace`、`vstack`、`hstack`、`dot`、`eye`、`identity`
    和 `zeros`。 |'
- en: '| `scipy.linalg` | `solve`, `lstsq`, `eig`, and `det`. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `scipy.linalg` | `solve`、`lstsq`、`eig` 和 `det`。 |'
- en: '| `matplotlib.pyplot` | `plot`, `legend`, and `cla`. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `matplotlib.pyplot` | `plot`、`legend` 和 `cla`。 |'
- en: '| `scipy.integrate` | `quad`. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `scipy.integrate` | `quad`。 |'
- en: '| `copy` | `copy` and `deepcopy`. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `copy` | `copy` 和 `deepcopy`。 |'
- en: 'Table 13.1: Examples of modules and corresponding imported functions'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.1：模块及其对应导入函数的示例
- en: 13.3.2 Modules in IPython
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3.2 IPython 中的模块
- en: IPython is used in code development. A typical scenario is that you work on
    a file with some function or class definitions that you change within a development
    cycle. To load the contents of such a file into the shell, you may use `import` but
    the file is loaded only once. Changing the file has no effect on later imports.
    That is where IPython's *magic command* `run` enters the stage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 用于代码开发。一个典型的场景是，你在一个文件中工作，文件中有一些函数或类定义，你在开发周期中对其进行更改。为了将该文件的内容加载到 Shell
    中，你可以使用 `import`，但文件只会加载一次。更改文件对后续的导入没有影响。这时，IPython 的 *魔法命令* `run` 就显得非常有用。
- en: The IPython magic command – run
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPython 魔法命令 – run
- en: 'IPython has a special *magic command* named `run` that executes a file as if
    you were running it directly in Python. This means that the file is executed independently
    of what is already defined in IPython. This is the recommended method to execute
    files from within IPython when you want to test a script intended as a standalone
    program. You must import all you need in the executed file in the same way as
    if you were executing it from the command line. A typical example of running code
    in `myfile.py` is:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 有一个特殊的 *魔法命令* `run`，它会像直接在 Python 中运行一样执行文件。这意味着文件会独立于 IPython 中已经定义的内容执行。这是推荐的在
    IPython 中执行文件的方法，特别是当你想要测试作为独立程序的脚本时。你必须像从命令行执行文件一样，在被执行的文件中导入所有需要的内容。运行 `myfile.py`
    文件的典型示例如下：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This script file is executed in Python by `exec(open('myfile.py').read())`.
    Alternatively, in IPython the *magic command *`run myfile` can be used if you
    want to make sure that the script runs independently of the previous imports.
    Everything that is defined in the file is imported into the IPython workspace.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本文件在 Python 中通过 `exec(open('myfile.py').read())` 执行。或者，在 IPython 中可以使用 *魔法命令*
    `run myfile`，如果你想确保脚本独立于之前的导入运行。文件中定义的所有内容都会被导入到 IPython 工作空间中。
- en: 13.3.3 The variable __name__
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3.3 变量 `__name__`
- en: 'In any module, the special variable `__name__` is defined as the name of the
    current module. In the command line (in IPython), this variable is set to `__main__`.
    This fact allows the following trick:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何模块中，特殊变量 `__name__` 被定义为当前模块的名称。在命令行（在IPython中）中，此变量被设置为 `__main__`。这个特性使得以下技巧成为可能：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The tests will be run only when the file is directly run, *not* when it is imported
    as, when imported, the variable `__name__` takes the name of the module instead
    of `__main__`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 测试只有在文件直接运行时才会执行，*而不是*在被导入时执行，因为当被导入时，变量 `__name__` 会取模块名，而不是 `__main__`。
- en: 13.3.4 Some useful modules
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3.4 一些有用的模块
- en: 'The list of useful Python modules is vast. In the following table, we have
    given a very short segment of such a list, focused on modules related to mathematical
    and engineering applications (*Table 13.2)*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的Python模块列表非常庞大。下表展示了这样一个简短的列表，专注于与数学和工程应用相关的模块 (*表13.2)*：
- en: '| **Module** | **Description** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **模块** | **描述** |'
- en: '| `scipy` | Functions used in scientific computing |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `scipy` | 科学计算中使用的函数 |'
- en: '| `numpy` | Support arrays and related methods |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `numpy` | 支持数组及相关方法 |'
- en: '| `matplotlib` | Plotting and visualization  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `matplotlib` | 绘图和可视化 |'
- en: '| `functools` | Partial application of functions |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `functools` | 函数的部分应用 |'
- en: '| `itertools` | Iterator tools to provide special capabilities, such as slicing
    to generators |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | 提供特殊功能的迭代器工具，例如切片生成器 |'
- en: '| `re` | Regular expressions for advanced string handling |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `re` | 用于高级字符串处理的正则表达式 |'
- en: '| `sys` | System-specific functions |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `sys` | 系统特定函数 |'
- en: '| `os` | Operating system interfaces such as directory listing and file handling
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `os` | 操作系统接口，如目录列表和文件处理 |'
- en: '| `datetime` | Representing dates and date increments |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `datetime` | 表示日期及日期增量 |'
- en: '| `time` | Returning wall clock time |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `time` | 返回壁钟时间 |'
- en: '| `timeit` | Measuring execution time |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `timeit` | 测量执行时间 |'
- en: '| `sympy` | Computer arithmetic package (symbolic computations) |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `sympy` | 计算机算术包（符号计算） |'
- en: '| `pickle` | Pickling, a special file input and output format |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `pickle` | Pickling，一种特殊的文件输入输出格式 |'
- en: '| `shelves` | Shelves, a special file input and output format |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `shelves` | Shelves，一种特殊的文件输入输出格式 |'
- en: '| `contextlib` | Tools for context managers |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `contextlib` | 用于上下文管理器的工具 |'
- en: 'Table 13.2: A non-exhaustive list of useful Python packages for engineering
    applications'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.2：用于工程应用的有用 Python 包的非详尽列表
- en: We advise against the use of the mathematics module `math` and favor `numpy`
    instead. The reason for this is that many of NumPy's functions, such as `sin`
    operate on arrays, while the corresponding functions in `math` don't.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议不要使用数学模块`math`，而是推荐使用`numpy`。原因是NumPy的许多函数，例如`sin`，是作用于数组的，而`math`中的对应函数则不支持。
- en: 13.4 Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.4 总结
- en: 'We started the book by telling you that you had to import SciPy and other useful
    modules. Now you fully understand what importing means. We introduced namespaces
    and discussed the difference between `import` and `from ... import *`. The scope
    of a variable was already introduced in [Section 7.2.3](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml):
    *Access to variables defined outside the local*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从告诉你需要导入SciPy和其他有用的模块开始。现在你已经完全理解了导入的含义。我们介绍了命名空间，并讨论了`import`和`from ... import
    *`之间的区别。变量的作用域已在[第7.2.3节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)中介绍：*访问定义在局部之外的变量*
- en: '*namespace**,* but now you have a more complete picture of the importance of
    that concept.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名空间*，但现在你对该概念的重要性有了更完整的理解。'
