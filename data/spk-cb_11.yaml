- en: Chapter 11. Graph Processing Using GraphX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。使用GraphX进行图处理
- en: This chapter will cover how we can do graph processing using GraphX, Spark's
    graph processing library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何使用GraphX进行图处理，Spark的图处理库。
- en: 'The chapter is divided into the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下食谱：
- en: Fundamental operations on graphs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的基本操作
- en: Using PageRank
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PageRank
- en: Finding connected components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找连通分量
- en: Performing neighborhood aggregation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行邻域聚合
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Graph analysis is much more commonplace in our life than we think. To take the
    most common example, when we ask a GPS to find the shortest route to a destination,
    it uses a graph-processing algorithm.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图分析在我们的生活中比我们想象的更普遍。最常见的一个例子是，当我们要求GPS找到目的地最短路线时，它使用图处理算法。
- en: Let's start by understanding graphs. A graph is a representation of a set of
    vertices where some pairs of vertices are connected by edges. When these edges
    move from one direction to another, it's called a **directed graph** or **digraph**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解图。图是一组顶点的表示，其中一些顶点对通过边连接。当这些边从一个方向移动到另一个方向时，它被称为**有向图**或**有向图**。
- en: GraphX is the Spark API for graph processing. It provides a wrapper around an
    RDD called **resilient distributed property graph**. The property graph is a directed
    multigraph with properties attached to each vertex and edge.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: GraphX是Spark的图处理API。它提供了一个围绕RDD的包装器，称为**弹性分布式属性图**。属性图是一个带有属性附加到每个顶点和边的有向多重图。
- en: There are two types of graphs—directed graphs (digraphs) and regular graphs.
    Directed graphs have edges that run in one direction, for example, from vertex
    A to vertex B. Twitter follower is a good example of a digraph. If John is David's
    Twitter follower, it does not mean that David is John's follower. On the other
    hand, Facebook is a good example of a regular graph. If John is David's Facebook
    friend, David is also John's Facebook friend.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的图——有向图（有向图）和正则图。有向图的边只有一个方向，例如，从顶点A到顶点B。Twitter关注者是一个很好的有向图例子。如果John是David的Twitter关注者，并不意味着David是John的关注者。另一方面，Facebook是一个很好的正则图例子。如果John是David的Facebook朋友，那么David也是John的Facebook朋友。
- en: A multigraph is a graph which is allowed to have multiple edges (also called
    **parallel edges**). Since every edge in GraphX has properties, each edge has
    its own identity.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 多重图是允许有多个边（也称为**并行边**）的图。由于GraphX中的每个边都有属性，每个边都有自己的标识。
- en: 'Traditionally, for distributed graph processing, there have been two types
    of systems:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，对于分布式图处理，有两种类型的系统：
- en: Data parallel
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据并行
- en: Graph parallel
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图并行
- en: GraphX aims to combine the two together in one system. GraphX API enables users
    to view the data both as graphs and as collections (RDDs) without data movement.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: GraphX旨在将两者结合在一个系统中。GraphX API允许用户在不移动数据的情况下将数据视为图和集合（RDD）。
- en: Fundamental operations on graphs
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的基本操作
- en: In this recipe, we will learn how to create graphs and do basic operations on
    them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何创建图以及如何在它们上执行基本操作。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As a starting example, we will have three vertices, each representing the city
    center of three cities in California—Santa Clara, Fremont, and San Francisco.
    The following is the distance between these cities:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起始示例，我们将有三个顶点，每个顶点代表加利福尼亚州三个城市的市中心——圣克拉拉、弗里蒙特和旧金山。以下是这些城市之间的距离：
- en: '| Source | Destination | Distance (miles) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 源 | 目标 | 距离（英里）|'
- en: '| --- | --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Santa Clara, CA | Fremont, CA | 20 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 圣克拉拉，CA | 弗里蒙特，CA | 20 |'
- en: '| Fremont, CA | San Francisco, CA | 44 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 弗里蒙特，CA | 旧金山，CA | 44 |'
- en: '| San Francisco, CA | Santa Clara, CA | 53 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 旧金山，CA | 圣克拉拉，CA | 53 |'
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Import the GraphX-related classes:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入GraphX相关类：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Load the vertex data in an array:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顶点数据加载到数组中：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Load the array of vertices into the RDD of vertices:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顶点数组加载到顶点RDD中：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Load the edge data in an array:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将边数据加载到数组中：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Load the data into the RDD of edges:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据加载到边RDD中：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create the graph:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建图：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Print all the vertices of the graph:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印图中所有顶点：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Print all the edges of the graph:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印图中所有边：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Print the edge triplets; a triplet is created by adding source and destination
    attributes to an edge:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印边三元组；边三元组是通过向边添加源和目标属性创建的：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In-degree of a graph is the number of inward-directed edges it has. Print the
    in-degree of each vertex (as `VertexRDD[Int]`):'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图的入度是指它拥有的内向边的数量。打印每个顶点的入度（作为`VertexRDD[Int]`）：
- en: '[PRE9]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using PageRank
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PageRank
- en: PageRank measures the importance of each vertex in a graph. PageRank was started
    by Google's founders, who used the theory that the most important pages on the
    Internet are the pages with the most links leading to them. PageRank also looks
    at the importance of a page leading to the target page. So, if a given web page
    has incoming links from higher rank pages, it will be ranked higher.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank衡量图中的每个顶点的重要性。PageRank是由谷歌的创始人发起的，他们使用理论认为，互联网上最重要的页面是那些有最多链接指向它们的页面。PageRank还考虑了指向目标页面的页面的重要性。因此，如果一个给定的网页有来自高排名页面的入链，它将被排名更高。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We are going to use Wikipedia page link data to calculate page rank. Wikipedia
    publishes its data in the form of a database dump. We are going to use link data
    from [http://haselgrove.id.au/wikipedia.htm](http://haselgrove.id.au/wikipedia.htm),
    which has the data in two files:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用维基百科页面链接数据来计算页面排名。维基百科以数据库转储的形式发布其数据。我们将使用来自[http://haselgrove.id.au/wikipedia.htm](http://haselgrove.id.au/wikipedia.htm)的链接数据，这些数据包含在两个文件中：
- en: '`links-simple-sorted.txt`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`links-simple-sorted.txt`'
- en: '`titles-sorted.txt`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`titles-sorted.txt`'
- en: I have put both of them on Amazon S3 at `s3n://com.infoobjects.wiki/links` and
    `s3n://com.infoobjects.wiki/nodes`. Since the data size is larger, it is recommended
    that you run it on either Amazon EC2 or your local cluster. Sandbox may be very
    slow.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将它们都放在Amazon S3的`s3n://com.infoobjects.wiki/links`和`s3n://com.infoobjects.wiki/nodes`上。由于数据量较大，建议您在Amazon
    EC2或本地集群上运行。沙盒可能非常慢。
- en: 'You can load the files to `hdfs` using the following commands:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令将文件加载到`hdfs`：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Import the GraphX related classes:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入GraphX相关类：
- en: '[PRE11]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Load the edges from `hdfs` with 20 partitions:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`hdfs`加载边，使用20个分区：
- en: '[PRE12]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or, load the edges from Amazon S3:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，从Amazon S3加载边：
- en: '[PRE13]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `links` file has links in the "sourcelink: link1 link2 …" format.'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`links`文件中的链接格式为“sourcelink: link1 link2 …”。'
- en: 'Flatten and convert it into an RDD of "link1,link2" format and then convert
    it into an RDD of `Edge` objects:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开并转换为“link1,link2”格式的RDD，然后将其转换为`Edge`对象的RDD：
- en: '[PRE14]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Load the vertices from `hdfs` with 20 partitions:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`hdfs`加载顶点，使用20个分区：
- en: '[PRE15]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or, load the edges from Amazon S3:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，从Amazon S3加载边：
- en: '[PRE16]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Provide an index to the vertices and then swap it to make it in the (index,
    title) format:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个顶点的索引，然后将其交换成（索引，标题）格式：
- en: '[PRE17]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create the `graph` object:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`graph`对象：
- en: '[PRE18]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run PageRank and get the vertices:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行PageRank并获取顶点：
- en: '[PRE19]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As ranks is in the (vertex ID, pagerank) format, swap it to make it in the
    (pagerank, vertex ID) format:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于排名是按照（顶点ID，pagerank）格式，将其交换成（pagerank，顶点ID）格式：
- en: '[PRE20]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Sort to get the highest ranked pages first:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 排序以首先获取最高排名的页面：
- en: '[PRE21]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Get the highest ranked page:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取最高排名的页面：
- en: '[PRE22]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding command gives the vertex id, which you still have to look up
    to see the actual title with rank. Let''s do a join:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的命令给出了顶点ID，您还需要查找以查看带有排名的实际标题。让我们进行连接操作：
- en: '[PRE23]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Sort the joined RDD again after converting from the (vertex ID, (page rank,
    title)) format to the (page rank, (vertex ID, title)) format:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将（顶点ID，（页面排名，标题））格式转换为（页面排名，（顶点ID，标题））格式后，再次对连接的RDD进行排序：
- en: '[PRE24]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Print the top five ranked pages
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印排名前五的页面
- en: '[PRE25]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here''s what the output should be:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出应该的样子：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finding connected components
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找连通分量
- en: A connected component is a subgraph (a graph whose vertices are a subset of
    the vertex set of the original graph and whose edges are a subset of the edge
    set of the original graph) in which any two vertices are connected to each other
    by an edge or a series of edges.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 连通分量是一个子图（一个顶点是原始图顶点集的子集，边是原始图边集的子集的图），其中任何两个顶点都通过一条边或一系列边相互连接。
- en: An easy way to understand it would be by taking a look at the road network graph
    of Hawaii. This state has numerous islands, which are not connected by roads.
    Within each island, most roads will be connected to each other. The goal of finding
    the connected components is to find these clusters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 理解它的一个简单方法是通过查看夏威夷的道路网络图。这个州有众多岛屿，它们之间没有道路相连。在每一个岛屿内，大多数道路都会相互连接。找到连通分量的目标是找到这些集群。
- en: The connected components algorithm labels each connected component of the graph
    with the ID of its lowest-numbered vertex.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 连通分量算法使用其最低编号顶点的ID来标记图中的每个连通分量。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will build a small graph here for the clusters we know and use connected
    components to segregate them. Let''s look at the following data:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个小的图来表示我们已知的集群，并使用连通分量来分离它们。让我们看看以下数据：
- en: '![Getting ready](img/3056_11_01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/3056_11_01.jpg)'
- en: '| Follower | Followee |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 关注者 | 关注者 |'
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| John | Pat |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| John | Pat |'
- en: '| Pat | Dave |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| Pat | Dave |'
- en: '| Gary | Chris |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| Gary | Chris |'
- en: '| Chris | Bill |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| Chris | Bill |'
- en: 'The preceding data is a simple one with six vertices and two clusters. Let''s
    put this data in the form of two files: `nodes.csv` and `edges.csv`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数据是一个简单的数据，包含六个顶点和两个簇。让我们以两个文件的形式（`nodes.csv`和`edges.csv`）存储这些数据。
- en: 'The following is the content of `nodes.csv`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`nodes.csv`的内容：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is the content of `edges.csv`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`edges.csv`的内容：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We should expect a connected component algorithm to identify two clusters, the
    first one identified by (1,John) and the second by (4,Gary).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该期望连通分量算法识别出两个簇，第一个由（1,John）识别，第二个由（4,Gary）识别。
- en: 'You can load the files to `hdfs` using the following commands:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令将文件加载到`hdfs`：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How to do it…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Load the Spark shell:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载Spark shell：
- en: '[PRE30]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Import the GraphX-related classes:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入GraphX相关类：
- en: '[PRE31]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Load the edges from `hdfs`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`hdfs`加载边：
- en: '[PRE32]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Convert the `edgesFile` RDD into the RDD of edges:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`edgesFile` RDD转换为边的RDD：
- en: '[PRE33]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Load the vertices from `hdfs`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`hdfs`加载顶点：
- en: '[PRE34]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Map the vertices:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 映射顶点：
- en: '[PRE35]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create the `graph` object:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`graph`对象：
- en: '[PRE36]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Calculate the connected components:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算连通分量：
- en: '[PRE37]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Find the vertices for the connected components (which is a subgraph):'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到连通分量的顶点（这是一个子图）：
- en: '[PRE38]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Print the `ccVertices`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印`ccVertices`：
- en: '[PRE39]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see in the output, vertices 1,2,3 are pointing to 1, while 4,5,6
    are pointing to 4\. Both of these are the lowest-indexed vertices in their respective
    clusters.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，顶点1、2、3指向1，而4、5、6指向4。这两个都是它们各自簇中索引最低的顶点。
- en: Performing neighborhood aggregation
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行邻域聚合
- en: 'GraphX does most of the computation by isolating each vertex and its neighbors.
    It makes it easier to process the massive graph data on distributed systems. This
    makes the neighborhood operations very important. GraphX has a mechanism to do
    it at each neighborhood level in the form of the `aggregateMessages` method. It
    does it in two steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: GraphX通过隔离每个顶点和其邻居来进行大部分计算。这使得在分布式系统上处理大规模图数据变得更容易。这使得邻域操作非常重要。GraphX有一个机制，以`aggregateMessages`方法的形式在每个邻域级别执行它。它分两步进行：
- en: In the first step (first function of the method), messages are send to the destination
    vertex or source vertex (similar to the Map function in MapReduce).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一步（方法的第一个函数）中，消息被发送到目标顶点或源顶点（类似于MapReduce中的Map函数）。
- en: In the second step (second function of the method), aggregation is done on these
    messages (similar to the Reduce function in MapReduce).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二步（方法的第二个函数）中，对这些消息进行聚合（类似于MapReduce中的Reduce函数）。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s build a small dataset of the followers:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个包含关注者的小型数据集：
- en: '| Follower | Followee |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 关注者 | 关注者 |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| John | Barack |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| John | Barack |'
- en: '| Pat | Barack |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| Pat | Barack |'
- en: '| Gary | Barack |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| Gary | Barack |'
- en: '| Chris | Mitt |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| Chris | Mitt |'
- en: '| Rob | Mitt |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| Rob | Mitt |'
- en: 'Our goal is to find out how many followers each node has. Let''s load this
    data in the form of two files: `nodes.csv` and `edges.csv`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找出每个节点有多少关注者。让我们以两个文件的形式加载这些数据：`nodes.csv`和`edges.csv`。
- en: 'The following is the content of `nodes.csv`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`nodes.csv`的内容：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following is the content of `edges.csv`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`edges.csv`的内容：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can load the files to `hdfs` using the following commands:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令将文件加载到`hdfs`：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How to do it…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Load the Spark shell:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载Spark shell：
- en: '[PRE43]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Import the GraphX related classes:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入GraphX相关类：
- en: '[PRE44]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Load the edges from `hdfs`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`hdfs`加载边：
- en: '[PRE45]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Convert the edges into the RDD of edges:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将边转换为边的RDD：
- en: '[PRE46]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Load the vertices from `hdfs`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`hdfs`加载顶点：
- en: '[PRE47]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Map the vertices:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 映射顶点：
- en: '[PRE48]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create the `graph` object:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`graph`对象：
- en: '[PRE49]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Do the neighborhood aggregation by sending messages to the followees with the
    number of followers from each follower, that is, 1 and then adding the number
    of followers:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向每个关注者发送包含其关注者数量的消息来进行邻域聚合，即1，然后添加关注者数量：
- en: '[PRE50]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Print `followerCount` in the form of (followee, number of followers):'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以（关注者，关注者数量）的形式打印`followerCount`：
- en: '[PRE51]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You should get an output similar to the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下类似的结果：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
