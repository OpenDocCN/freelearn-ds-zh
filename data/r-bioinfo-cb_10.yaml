- en: Programming with Tidyverse and Bioconductor
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Tidyverse 和 Bioconductor 编程
- en: R is a great language to use interactively; however, that does mean many users
    don't get experience of using it as a language in which to do programming—that
    is, for automating analyses and saving the user's time and efforts when it comes
    to repeating stuff. In this chapter, we'll take a look at some techniques for
    doing just that—in particular, we'll look at how to integrate base R objects into
    `tidyverse` workflows, extend `Bioconductor` classes to suit our own needs, and
    use literate programming and notebook-style coding to keep expressive and readable
    records of our work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: R 是一种适合交互式使用的优秀语言；然而，这也意味着许多用户没有体验过将其作为编程语言使用——也就是说，在自动化分析和节省重复工作所需时间和精力方面的应用。在本章中，我们将介绍一些实现这一目标的技术——特别是，我们将探讨如何将基础
    R 对象集成到 `tidyverse` 工作流中，如何扩展 `Bioconductor` 类以满足我们自己的需求，以及如何使用文献编程和笔记本风格的编码来保持我们的工作记录具有表达性和可读性。
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下食谱：
- en: Making base R objects tidy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使基础 R 对象整洁
- en: Using nested dataframes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用嵌套数据框
- en: Writing functions for use in `mutate`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `mutate` 编写函数
- en: Working programmatically with Bioconductor classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编程方式操作 Bioconductor 类
- en: Developing reusable workflows and reports
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发可重用的工作流和报告
- en: Making use of the apply family of functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 apply 系列函数
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample data you'll need is available from this book's GitHub repository
    at [https://github.com/PacktPublishing/R-Bioinformatics-Cookbook](https://github.com/PacktPublishing/R-Bioinformatics-Cookbook)[.](https://github.com/danmaclean/R_Bioinformatics_Cookbook) If
    you want to use the code examples as they are written, then you will need to make
    sure that this data is in a sub-directory of whatever your working directory is.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的示例数据可以从本书的 GitHub 仓库获取，链接为 [https://github.com/PacktPublishing/R-Bioinformatics-Cookbook](https://github.com/PacktPublishing/R-Bioinformatics-Cookbook)[.](https://github.com/danmaclean/R_Bioinformatics_Cookbook)
    如果你希望按原样使用代码示例，你需要确保这些数据位于你的工作目录的子目录中。
- en: 'Here are the R packages that you''ll need. In general, you can install these
    packages with `install.packages("package_name")`. The packages listed under `Bioconductor`
    need to be installed with the dedicated installer. If you need to do anything
    further, installation will be described in the recipes in which the packages are
    used:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你需要的 R 包。通常，你可以使用 `install.packages("package_name")` 来安装这些包。列在 `Bioconductor`
    下的包需要使用专用的安装程序进行安装。如果需要做其他操作，安装过程将在使用这些包的食谱中描述：
- en: '`Bioconductor`:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bioconductor`：'
- en: '`Biobase`'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Biobase`'
- en: '`biobroom`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`biobroom`'
- en: '`SummarizedExperiment`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SummarizedExperiment`'
- en: '`broom`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`broom`'
- en: '`dplyr`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dplyr`'
- en: '`ggplot2`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ggplot2`'
- en: '`knitr`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`knitr`'
- en: '`magrittr`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`magrittr`'
- en: '`purrr`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`purrr`'
- en: '`rmarkdown`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rmarkdown`'
- en: '`tidyr`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tidyr`'
- en: '`Bioconductor` is huge and has its own installation manager. You can install
    the manager with the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bioconductor` 非常庞大，并且有自己的安装管理器。你可以通过以下代码安装该管理器：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, you can install the packages with this code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下代码安装这些包：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Further information is available at [https://www.bioconductor.org/install/](https://www.bioconductor.org/install/).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参见 [https://www.bioconductor.org/install/](https://www.bioconductor.org/install/)。
- en: Normally, in R, a user will load a library and use functions directly by name.
    This is great in interactive sessions but it can cause confusion when many packages
    are loaded. To clarify which package and function I'm using at a given moment,
    I will occasionally use the `packageName::functionName()` convention.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在 R 中，用户会加载一个库并直接使用函数名。这在交互式会话中很方便，但当加载了许多包时，可能会导致混淆。为了明确当前使用的是哪个包和函数，我偶尔会使用
    `packageName::functionName()` 这种约定。
- en: 'Sometimes, in the middle of a recipe, I''ll interrupt the code so you can see
    some intermediate output or the structure of an object that''s important to understand.
    Whenever that happens, you''ll see a code block where each line begins with `##` (double
    hash) symbols. Consider the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在某个代码片段中，我会暂停代码执行，以便你能够看到一些中间输出或理解某个重要对象的结构。每当发生这种情况时，你会看到一个代码块，其中每行前面都以
    `##`（双井号）符号开头。考虑以下命令：
- en: '`letters[1:5]`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`letters[1:5]`'
- en: 'This will give us the following output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下输出：
- en: '`## a b c d e`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`## a b c d e`'
- en: Note that the output lines are prefixed with `##`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出行前缀为 `##`。
- en: Making base R objects tidy
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使基础 R 对象整洁
- en: The `tidyverse` set of packages (including `dplyr`, `tidyr`, and `magrittr`)
    have had a huge influence on data processing and analysis in R through their application
    of the tidy way of working. In essence, this means that data is kept in a particular
    tidy format, in which each row holds a single observation and each column keeps
    all observations of a single variable. Such a structure means that analytical
    steps have predictable inputs and outputs and can be built into fluid and expressive
    pipelines. However, most base R objects are not tidy and can often need significant
    programming work to extract the bits that are needed to assemble objects for use
    downstream. In this recipe, we'll look at some functions for automatically converting
    some common base R objects into a tidy dataframe.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`tidyverse`软件包集（包括`dplyr`、`tidyr`和`magrittr`）通过应用整洁的工作方式，在数据处理和分析中对R语言产生了巨大影响。本质上，这意味着数据保持在一种特定的整洁格式中，每一行包含一个单独的观测值，每一列包含一个变量的所有观测值。这样的结构意味着分析步骤有可预测的输入和输出，可以构建成流畅且富有表现力的管道。然而，大多数基础R对象并不整洁，往往需要大量的编程工作来提取所需的部分，以便下游使用。在这个教程中，我们将介绍一些函数，用于自动将一些常见的基础R对象转换为整洁的数据框。'
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need the `tidyr`, `broom`, and `biobroom` packages. We'll use the built-in
    `mtcars` data and `modencodefly_eset.RData` from the `datasets/ch1` folder of
    this book's repository.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要`tidyr`、`broom`和`biobroom`包。我们将使用内置的`mtcars`数据和来自本书仓库`datasets/ch1`文件夹中的`modencodefly_eset.RData`。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Making base R objects tidy can be done using the following steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使基础R对象整洁可以通过以下步骤完成：
- en: 'Tidy an `lm` object:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整理一个`lm`对象：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Tidy a `t_test` object:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整理一个`t_test`对象：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Tidy an ANOVA object:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整理一个ANOVA对象：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Tidy a `Bioconductor` `ExpressionSet` object:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整理一个`Bioconductor` `ExpressionSet`对象：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '*Step 1* shows some functions for tidying an `lm` object with the `lm()` function.
    The first step is to create the object. Here, we perform a multiple regression
    model using the `mtcars` data. We then use the `tidy()` function on the model
    to return the object summary of components of the model, for example, the coefficient,
    as a tidy dataframe. The `augment()` function returns extra per-observation data
    for an `lm` object should we want that—again, it''s in tidy format. The `glance()` function
    inspects the model itself and returns summaries about it—naturally, in tidy format.
    `glance()` is useful for comparing models.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 1* 展示了使用`lm()`函数整理`lm`对象的一些函数。第一步是创建对象。在这里，我们使用`mtcars`数据执行一个多元回归模型。然后，我们对该模型使用`tidy()`函数，返回模型组件的对象摘要，例如系数，以整洁的数据框形式。`augment()`函数返回额外的逐观测数据，如果需要的话——同样是整洁格式。`glance()`函数检查模型本身，并返回关于模型的摘要——自然地，以整洁格式显示。`glance()`对于比较模型非常有用。'
- en: '*Step 2* shows the same process for the `t.test` object. First, we run a t-test
    on two vectors of random numbers. The `tidy()` function gives us all of the details
    in a tidy dataframe.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 2* 展示了相同的过程，适用于`t.test`对象。首先，我们对两个随机数向量进行t检验。`tidy()`函数会将所有细节以整洁的数据框形式返回。'
- en: In *Step 3*, we run an ANOVA on the `iris` data. We use the `aov()` function
    to look at the effect of `Species` on `Petal.Length`. We can use `tidy()` again
    on the result but it gives a summary of the components of the model. In fact,
    we're probably more interested in the comparisons from a post-hoc test, which
    is performed using the `TukeyHSD()` function on the next line; it too can be used
    in `tidy()`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 3*中，我们对`iris`数据运行方差分析（ANOVA）。我们使用`aov()`函数查看`Species`对`Petal.Length`的影响。我们可以再次对结果使用`tidy()`，但它会给出模型组件的摘要。实际上，我们更感兴趣的可能是来自后验检验的比较结果，该检验使用`TukeyHSD()`函数进行，它也可以在`tidy()`中使用。
- en: In *Step 4*, we use the `biobroom` version of `tidy()` on the `ExpressionSet`
    object. This turns the square matrix of expression values into a tidy dataframe
    along with columns for sample and other types of data. The extra argument, `addPheno`, is
    specific to this type of object and inserts the phenotype metadata from the `ExpressionSet`
    metadata container. Note that the resulting dataframe is over 2 million lines
    long—biological datasets can be large and can generate very large dataframes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 4*中，我们使用`biobroom`版本的`tidy()`对`ExpressionSet`对象进行处理。这将表达值的方阵转化为整洁的数据框，并包含样本和其他数据类型的列。额外的参数`addPheno`是特定于此类对象的，并将`ExpressionSet`元数据容器中的表型元数据插入其中。请注意，结果数据框超过200万行——生物学数据集可能很大，并且生成非常大的数据框。
- en: Using nested dataframes
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用嵌套数据框
- en: The dataframe is at the core of the tidy way of working and we tend to think
    of it as a spreadsheet-like rectangular data container with only a single value
    in each cell. In fact, dataframes can be nested—that is, they can hold other dataframes
    in specific, single cells. This is achieved internally by replacing a dataframe's
    vector column with a list column. Each cell is instead a member of a list, so
    any sort of object can be held within the conceptual single cell of the outer
    dataframe. In this recipe, we'll look at ways of making a nested dataframe and
    different ways of working with it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框（dataframe）是整洁工作方式的核心，我们通常将其视为一个类似电子表格的矩形数据容器，每个单元格中仅包含一个值。实际上，数据框可以嵌套——即它们可以在特定的单个单元格中包含其他数据框。这是通过将数据框的向量列替换为列表列来实现的。每个单元格实际上是列表的一个成员，因此任何类型的对象都可以保存在外部数据框的概念性单元格中。在本教程中，我们将介绍创建嵌套数据框的方式以及与之合作的不同方法。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need the `tidyr`, `dplyr`, `purrr`, and `magrittr` libraries. We'll also
    use the `diamonds` data from the `ggplot2` package, though we won't use any functions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要`tidyr`、`dplyr`、`purrr`和`magrittr`库。我们还将使用来自`ggplot2`包的`diamonds`数据，但我们不会使用任何函数。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Using nested dataframes can be done with the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌套数据框可以通过以下步骤完成：
- en: 'Create a nested dataframe:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个嵌套数据框：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add a new list column holding the results of `lm()`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新列表列，包含`lm()`的结果：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add a new list column holding the results of `tidy()`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新列表列，包含`tidy()`的结果：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Unnest the whole dataframe:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解开整个数据框：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the pipeline in a single step:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单个步骤中运行管道：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In *Step 1*, we use the `nest()` function to nest the `mtcars` dataframe. The
    `-` option tells the function which columns to exclude from nesting effectively;
    making the `cyl` column a factor using which the different subsets are created.
    Conceptually, this is similar to the `dplyr::group_by()` function. Inspecting
    the object gives us this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们使用`nest()`函数将`mtcars`数据框进行嵌套。`-`选项告诉函数哪些列在嵌套时要排除；将`cyl`列转换为因子，用于创建不同的子集。从概念上讲，这类似于`dplyr::group_by()`函数。检查该对象会得到以下内容：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The nested dataframe contains a new column of dataframes called `data`, alongside
    the reduced `cyl` column.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套数据框包含一个名为`data`的新数据框列，以及被简化的`cyl`列。
- en: 'In *Step 2*, we create a new column on our dataframe by using `mutate()`. Within
    this, we use the `map()` function from `purrr`, which iterates over items in a
    list provided as its first argument (so our data column of dataframes) and uses
    them in the code provided as its second argument. Here, we use the `lm()` function
    on the nested data, one element at a time—note that the `.x` variable just means
    *the thing we''re currently working on—*so, the current item in the list. When
    run, the list now looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，我们通过使用`mutate()`在数据框中创建一个新列。在此过程中，我们使用`purrr`包中的`map()`函数，它遍历作为第一个参数提供的列表项（即我们的数据框列），并在作为第二个参数提供的代码中使用它们。在这里，我们对嵌套数据使用`lm()`函数，一次处理一个元素——注意，`.x`变量表示*我们当前正在处理的内容*——也就是列表中的当前项。运行后，列表看起来是这样的：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The new `model` list column holds our `lm` objects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`model`列表列包含我们的`lm`对象。
- en: 'Having established that the pattern to add new list columns is to use `mutate()`
    with `map()` inside, we can then tidy up the `lm` objects in the same way. This
    is what happens in *Step 3*. The result gives us the following nested dataframe:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认添加新列表列的模式是使用`mutate()`并在其中嵌入`map()`后，我们可以同样整理`lm`对象。这就是在*步骤 3*中发生的情况。结果给我们带来了以下嵌套数据框：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Step 4* uses the `unnest()` function to return everything to a single dataframe;
    the second argument, `tidy_model`, is the column to unpack.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 4*使用`unnest()`函数将所有内容恢复为单个数据框；第二个参数`tidy_model`是需要解包的列。'
- en: '*Step 5* repeats the whole of *Steps 1* to *4* in a single pipeline, highlighting
    that these are just regular `tidyverse` functions and can be chained together
    without having to save intermediate steps.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 5*将*步骤 1*到*步骤 4*的整个过程合并为一个管道，突出显示这些只是常规的`tidyverse`函数，并且可以链式调用，无需保存中间步骤。'
- en: There's more...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: The `unnest()` function will only work when the nested list column members are
    compatible and can be sensibly aligned and recycled according to the normal rules.
    In many cases, this won't be true so you will need to manually manipulate the
    output. The following example shows how we can do that. The workflow is essentially
    the same as the preceding example, though one change early on is that we use `dplyr::group_by()`
    to create the groups for `nest()`.In `mutate()`, we pass a custom function to
    analyze the data, but, otherwise, this step is the same. The last step is the
    biggest change and takes advantage of `transmute()` to drop the unneeded columns
    and create a new column that is the result of `map_dbl()` and a custom summary
    function. `map_dbl()` is like `map()` but returns only double numeric vectors.
    Other `map_**` functions also exist.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`unnest()`函数只有在嵌套列表列成员兼容且可以根据正常规则合理对齐和回收时才有效。在许多情况下，这种情况并不成立，因此你需要手动操作输出。以下示例展示了我们如何做到这一点。工作流程基本上与之前的示例相同，唯一的变化是在早期步骤中，我们使用`dplyr::group_by()`来创建`nest()`的分组。在`mutate()`中，我们传递自定义函数来分析数据，但其他步骤保持不变。最后一步是最大的变化，利用`transmute()`来删除不需要的列，并创建一个新的列，它是`map_dbl()`和自定义汇总函数的结果。`map_dbl()`类似于`map()`，但只返回双精度数值向量。其他的`map_**`函数也存在。'
- en: Writing functions for use in dplyr::mutate()
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`dplyr::mutate()`编写函数
- en: The `mutate()` function from `dplyr` is extremely useful one for adding new
    columns to a dataframe based on computations from existing columns. It is a vectorized
    function, though, and is often misunderstood as working row-wise when it actually
    works column-wise, that is, on whole vectors with R's built-in recycling. This
    behavior can often be confusing for those looking to use `mutate()` on non-trivial
    examples or with custom functions, so, in this recipe, we're going to examine
    how `mutate()` actually behaves in certain situations, with the hope that this
    will be enlightening.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr`的`mutate()`函数非常有用，可以根据现有列的计算结果向数据框中添加新列。它是一个矢量化函数，但通常被误解为按行工作，实际上它是按列工作的，也就是说，它对整个向量进行操作，并利用R内置的回收机制。这种行为往往会让那些想在复杂例子或自定义函数中使用`mutate()`的人感到困惑，因此，在本教程中，我们将探讨`mutate()`在某些情况下的实际行为，希望能够带来启示。'
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this, we'll need the `dplyr` package and the built-in `iris` data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要`dplyr`包和内置的`iris`数据。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Writing functions for use in `dplyr::mutate()` can be done using the following
    steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为`dplyr::mutate()`编写函数可以通过以下步骤完成：
- en: 'Use a function that returns a single value:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用返回单个值的函数：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Use a function that returns the same number of values as given:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用返回与给定值相同数量值的函数：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use a function that returns neither a single value nor the same number of values
    as given:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用返回既不是单个值也不是与给定值相同数量值的函数：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Force repetition of the function to fit the length of the vector:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制函数的重复以适应向量的长度：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'In *Step 1*, we create a function that, given a vector, returns only a single
    value (a vector of length one). We then use it in `mutate()` to add a column called
    `result` and get the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们创建一个函数，给定一个向量，返回一个单一的值（长度为1的向量）。然后我们在`mutate()`中使用它，添加一个名为`result`的列，并得到如下结果：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note how the single value the function returns in the `result` column is repeated
    over and over. With `length == 1` vectors, R will recycle the result and place
    it in every position.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数在`result`列中返回的单个值是反复出现的。对于`length == 1`的向量，R会回收结果并将其放置到每个位置。
- en: 'In *Step 2*, we go to the opposite end and create a function that, given a
    vector, returns a vector of identical length (specifically, it returns a vector
    of the word `result_` pasted onto a number representing the position in the vector).
    When we run it, we get this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们走到对立面，创建一个函数，给定一个向量，返回一个相同长度的向量（具体来说，它返回一个将`result_`与向量中的位置数字拼接在一起的向量）。当我们运行它时，我们得到如下结果：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because it is exactly the same length as the rest of the columns of the dataframe,
    R will accept it and apply it as a new column.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它的长度与数据框中其余列完全相同，R会接受它并将其作为新列应用。
- en: In *Step 3*, we create a function that returns a vector of three elements. As
    the length is neither one nor the length of the other columns of the dataframe,
    the code fails.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们创建一个返回三个元素的向量的函数。由于长度既不是1，也不是数据框中其他列的长度，代码会失败。
- en: 'In *Step 4*, we look at how we can repeat an incompatible length vector to
    make it fit should we need to. The `rep_until()` function with the `length.out`
    argument repeats its input until the vector is `length.out` long. In this way,
    we get the following column, which is what we were hoping to see with the function
    in *Step 3*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4步*中，我们将探讨如何重复一个不兼容长度的向量，以便在需要时使其适应。`rep_until()`函数与`length.out`参数会重复其输入，直到向量的长度为`length.out`。通过这种方式，我们可以得到以下列，这就是我们在*第3步*中使用该函数时所期望看到的结果：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Working programmatically with Bioconductor classes
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bioconductor类进行编程操作
- en: The wide scope of `Bioconductor` means that there are a great number of classes
    and methods for accomplishing pretty much any bioinformatics workflow that you'd
    want to. Sometimes, though, it would be helpful to have an extra data slot or
    some other tweak to the tools that would help to simplify our lives. In this recipe,
    we're going to look at how to extend an existing class to include some extra information
    that is specific to our particular data. We'll look at extending the `SummarizedExperiment` class
    to add hypothetical barcode information—a type of metadata indicating some nucleotide
    tags that identify the sample that is included in the sequence read.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bioconductor`的广泛应用意味着有大量的类和方法可以完成几乎任何你想要的生物信息学工作流程。不过，有时候，额外的数据槽或一些工具上的调整会帮助简化我们的工作。在本教程中，我们将探讨如何扩展一个现有的类，以包含一些特定于我们数据的额外信息。我们将扩展`SummarizedExperiment`类，以添加假设的条形码信息——一种元数据，表示一些核苷酸标签，这些标签可以标识包含在序列读取中的样本。'
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll just need the Bioconductor `SummarizedExperiment` packages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们只需要`Bioconductor`的`SummarizedExperiment`包。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Working programmatically with the `Bioconductor` classes can be done using
    the following steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤可以通过编程方式与`Bioconductor`类进行交互：
- en: 'Create a new class inheriting from `SummarizedExperiment`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个继承自`SummarizedExperiment`的新类：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a constructor function:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建构造函数：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the required methods to the class:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类中添加必需的方法：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Build an instance of the new class:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建新类的实例：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Call the new method:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用新的方法：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *Step 1*, we create a new S4 class using the `setClass()` function. This
    takes the name of the new class as the first argument. The `contains` argument
    specifies which existing class we wish to inherit from (so that our new class
    will contain all of the functionality of this class plus any new stuff we create).
    The `slots` argument specifies the new data slots we want to add and requires
    that we give a type for them. Here, we're adding text data slots for the new `barcode_id`
    and `barcode_sequence` slots, so use `character` for both.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1步*中，我们使用`setClass()`函数创建一个新的S4类。这个函数的第一个参数是新类的名称。`contains`参数指定我们希望继承的现有类（这样我们的新类就会包含这个类的所有功能以及我们创建的任何新功能）。`slots`参数指定我们希望添加的新数据槽，并要求我们为其指定类型。在这里，我们添加了文本数据槽，用于新的`barcode_id`和`barcode_sequence`槽，因此我们为这两个槽都使用`character`类型。
- en: In *Step 2*, we create a constructor function. The name of this function must
    be the same as the class, and we specify the arguments we need to create a new
    object in the call to `function()`. Within the body, we use the `new()` function,
    whose first argument is the name of the class to instantiate from. The rest of
    the body is taken up with the mechanics of populating the instance with data;
    we call the inherited `SummarizedExperiment` constructor to populate that part
    of the new object, and then manually populate the new barcode slots. Every time
    we run `BarcodedSummarizedExperiment`, we will get a new object of that class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2步*中，我们创建一个构造函数。该函数的名称必须与类名相同，并且我们在调用`function()`时指定创建新对象所需的参数。在函数体内，我们使用`new()`函数，其第一个参数是要实例化的类的名称。其余的部分用于填充实例数据；我们调用继承自`SummarizedExperiment`的构造函数，以填充新对象的那一部分，然后手动填充新的条形码槽。每次运行`BarcodedSummarizedExperiment`时，我们都会获得该类的一个新对象。
- en: In *Step 3*, we add a new function (strictly speaking, in R, it's called a method).
    If we choose a function name that doesn't already exist as a `Generic` function
    in R, we must register the name of the function with `setGeneric()`, which takes
    the name of the function as its first argument and a boilerplate function as its
    second. Once the `Generic` function is set, we can add actual functions with the
    `setMethod()` function. The name of the new function is the first argument, the
    class it will attach to is the second, and the code itself is the third. Note
    that we are just creating an accessor (`getter`) function that returns the data
    in the `barcode_id` slot of the current object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们添加了一个新函数（严格来说，在R中，它被称为方法）。如果我们选择一个在R中尚不存在的`Generic`函数名称，我们必须使用`setGeneric()`注册该函数名，`setGeneric()`的第一个参数是函数名，第二个参数是一个模板函数。`Generic`函数设置完毕后，我们可以使用`setMethod()`函数添加实际的函数。新函数的名称是第一个参数，它将附加到的类是第二个参数，而代码本身是第三个参数。请注意，我们这里只是在创建一个访问器（`getter`）函数，它返回当前对象中`barcode_id`槽的数据。
- en: In *Step 4*, our preparatory work is done so we can build an instance of the
    class. In the first six lines of this step, we simply create the data we need
    to build the object. This is the part that goes into a normal `SummarizedExperiment`
    object; you can see more details on what exactly is going on here in the documentation.
    We can then actually create `my_new_barcoded_experiment` by calling the `BarcodedSummarizedExperiment`
    function with the data we created and some new specific data for the new `barcode_id`
    and `barcode_sequence` slots.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们的准备工作已经完成，可以构建类的实例。在这一步的前六行中，我们仅仅创建了构建对象所需的数据。这部分数据进入一个普通的`SummarizedExperiment`对象；你可以在文档中看到更多关于这里具体发生了什么的细节。然后，我们可以通过调用`BarcodedSummarizedExperiment`函数，并传入我们创建的数据以及新`barcode_id`和`barcode_sequence`槽的特定数据，实际创建`my_new_barcoded_experiment`。
- en: Now, with the object created, in *Step 5*, we can use our method, calling it
    like any other function with our new object as the argument.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建了对象后，在*步骤5*中，我们可以像调用其他函数一样使用我们的方法，传入我们新创建的对象作为参数。
- en: Developing reusable workflows and reports
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发可重用的工作流程和报告
- en: A very common task in bioinformatics is writing up our results in order to communicate
    them to a colleague or just to have a good record in our laboratory books (electronic
    or otherwise). A key skill is to make the work as reproducible as possible so
    that we can rerun it ourselves when we need to revisit it or someone else interested
    in what we did can replicate the process. One increasingly popular solution to
    this problem is to use literate programming techniques and executable notebooks
    that are a mixture of human-readable text, analytical code, and computational
    output rolled into a single document. In R, the `rmarkdown` package allows us
    to combine code and text in this way and create output documents in a variety
    of formats.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在生物信息学中，一个非常常见的任务是撰写结果，以便与同事交流，或者仅仅为了在实验记录中留有一份完整的记录（无论是电子版还是纸质版）。一个关键技能是尽可能让工作可重复，以便当我们需要回顾它时，或者有其他人对我们所做的工作感兴趣时，他们可以复制整个过程。一个日益流行的解决方案是使用文献编程技术和可执行笔记本，这些笔记本结合了可读的文本、分析代码和计算输出，打包成一个单一文档。在R中，`rmarkdown`包使我们能够以这种方式将代码和文本结合在一起，并生成多种格式的输出文档。
- en: In this recipe, we'll look at the large-scale structure of one such document
    that can be compiled with `rmarkdown`. The RStudio application makes this process
    very straightforward so we'll look at compilation from within that tool.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将查看一个可以通过`rmarkdown`编译的文档的大规模结构。RStudio应用程序使得这个过程非常简便，所以我们将通过这个工具来查看编译过程。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll need the RStudio application available at [https://www.rstudio.com/](https://www.rstudio.com/) and
    the `rmarkdown` package. The sample code for this recipe is available in the `example_rmarkdown.rmd`
    file in this book's `datasets/ch10/` folder.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要[RStudio应用程序](https://www.rstudio.com/)和`rmarkdown`包。这个食谱的示例代码可以在本书的`datasets/ch10/`文件夹中的`example_rmarkdown.rmd`文件中找到。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Developing reusable workflows and reports can be done using the following steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 开发可重用的工作流程和报告可以通过以下步骤完成：
- en: 'In an external file, add a `YAML` header:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在外部文件中，添加一个`YAML`头部：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, add some text and code to be interpreted:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加一些文本和代码进行解释：
- en: '[PRE27]{r}'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE27]{r}'
- en: x <- iris$Sepal.Width
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: x <- iris$Sepal.Width
- en: y <- iris$Sepal.Length
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: y <- iris$Sepal.Length
- en: lm(y ~ x, data = iris)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: lm(y ~ x, data = iris)
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Text can be formatted using minimal markup tags:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本可以使用最小化标记格式进行格式化：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Apply further options and carry over variables within a block:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在块内应用更多选项并传递变量：
- en: '[PRE30]{r, fig.width=12 }'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]{r, fig.width=12 }'
- en: plot(x, y)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: plot(x, y)
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The code here is unique in that it must be run from inside an external document;
    it won't run in the R console. The compilation step to run the document can be
    done in a couple of ways. Within RStudio, once `rmarkdown` is installed and you
    are editing a document with a `.Rmd` extension, you get a `knit` button. Alternatively,
    you can compile a document from the console with the `rmarkdown::render()` function,
    though I recommend the RStudio IDE for this.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码很特殊，因为它必须从外部文档中运行；在R控制台中无法运行。运行文档的编译步骤有几种方法。在RStudio中，一旦安装了`rmarkdown`并且正在编辑一个`.Rmd`扩展名的文档，您会看到一个`knit`按钮。或者，您可以通过控制台使用`rmarkdown::render()`函数编译文档，尽管我建议使用RStudio
    IDE来完成此操作。
- en: In *Step 1* of the actual document, we create a `YAML` header that describes
    how the document should be rendered including output formats, dynamic date insertion,
    and author and titles. These will be added to your document automatically.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们创建了一个`YAML`头部，描述了文档的渲染方式，包括输出格式、动态日期插入、作者和标题。这些内容将自动添加到您的文档中。
- en: In *Step 2*, we actually create some content—the first line is just plaintext
    and will pass through into the eventual document unmodified as paragraph text.
    The section within the block delineated by [PRE32] [PRE33]
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们实际上创建了一些内容——第一行是纯文本，将作为段落文本传递到最终文档中，不做任何修改。块中的部分由[PRE32] [PRE33]限定
- en: m <- matrix(rep(1:10, 10, replace = TRUE), nrow = 10)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: m <- matrix(rep(1:10, 10, replace = TRUE), nrow = 10)
- en: apply(m, 1, sum)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: apply(m, 1, sum)
- en: apply(m, 2, sum)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: apply(m, 2, sum)
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: numbers <- 1:3
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: numbers <- 1:3
- en: number_of_numbers <- function(x){
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: number_of_numbers <- function(x){
- en: rnorm(x)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: rnorm(x)
- en: '}'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: my_list <- lapply(numbers, number_of_numbers)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: my_list <- lapply(numbers, number_of_numbers)
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: summary_function <- function(x){
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: summary_function <- function(x){
- en: mean(x)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: mean(x)
- en: '}'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: lapply(my_list, summary_function)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: lapply(my_list, summary_function)
- en: sapply(my_list, summary_function)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: sapply(my_list, summary_function)
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: list_from_data_frame <- lapply(iris, mean, trim = 0.1, na.rm = TRUE )
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: list_from_data_frame <- lapply(iris, mean, trim = 0.1, na.rm = TRUE )
- en: unlist(list_from_data_frame)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: unlist(list_from_data_frame)
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: m
  id: totrans-173
  prefs:
  - PREF_H2
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m
- en: '[,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]'
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]'
- en: '[1,] 1 1 1 1 1 1 1 1 1 1'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[1,] 1 1 1 1 1 1 1 1 1 1'
- en: '[2,] 2 2 2 2 2 2 2 2 2 2'
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[2,] 2 2 2 2 2 2 2 2 2 2'
- en: '[3,] 3 3 3 3 3 3 3 3 3 3'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[3,] 3 3 3 3 3 3 3 3 3 3'
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: apply(m, 1, sum)
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: apply(m, 1, sum)
- en: '[1] 10 20 30 40 50 60 70 80 90 100'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 10 20 30 40 50 60 70 80 90 100'
- en: apply(m, 2, sum)
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: apply(m, 2, sum)
- en: '[1] 55 55 55 55 55 55 55 55 55 55'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 55 55 55 55 55 55 55 55 55 55'
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '>my_list'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '>my_list'
- en: '[[1]] [1] -0.3069078'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1]] [1] -0.3069078'
- en: '[[2]] [1] 0.9207697 1.8198781'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[[2]] [1] 0.9207697 1.8198781'
- en: '[[3]] [1] 0.3801964 -1.3022340 -0.8660626'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[[3]] [1] 0.3801964 -1.3022340 -0.8660626'
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '>lapply(my_list, summary_function)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '>lapply(my_list, summary_function)'
- en: '[[1]] [1] -0.3069078'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1]] [1] -0.3069078'
- en: '[[2]] [1] 1.370324'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[[2]] [1] 1.370324'
- en: '[[3]] [1] -0.5960334'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[[3]] [1] -0.5960334'
- en: '>sapply(my_list, summary_function)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '>sapply(my_list, summary_function)'
- en: '[1] -0.3069078 1.3703239 -0.5960334'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] -0.3069078 1.3703239 -0.5960334'
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: lapply(iris, mean, trim = 0.1, na.rm = TRUE )
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lapply(iris, mean, trim = 0.1, na.rm = TRUE )
- en: $Sepal.Length [1] 5.808333
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: $Sepal.Length [1] 5.808333
- en: $Sepal.Width [1] 3.043333
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: $Sepal.Width [1] 3.043333
- en: $Petal.Length [1] 3.76
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: $Petal.Length [1] 3.76
- en: $Petal.Width [1] 1.184167
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: $Petal.Width [1] 1.184167
- en: $Species [1] NA
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: $Species [1] NA
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: unlist(list_from_data_frame)
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: unlist(list_from_data_frame)
- en: Sepal.Length Sepal.Width Petal.Length Petal.Width Species
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Sepal.Length Sepal.Width Petal.Length Petal.Width Species
- en: 5.808333 3.043333 3.760000 1.184167 NA
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 5.808333 3.043333 3.760000 1.184167 NA
- en: '```'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If names are present, the vector is named.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在名称，向量将被命名。
