- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Dependency Injection in FastAPI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FastAPI 中的依赖注入
- en: 'In this chapter, we’ll focus on one of the most interesting parts of FastAPI:
    **dependency injection**. You’ll see that it is a powerful and readable approach
    to reusing logic across your project. Indeed, it will allow you to create complex
    building blocks for your project, which you’ll be able to use everywhere in your
    logic. An authentication system, a query parameter validator, or a rate limiter
    are typical use cases for dependencies. In FastAPI, a dependency injection can
    even call another one recursively, allowing you to build high-level blocks from
    basic features. By the end of this chapter, you’ll be able to create your own
    dependencies for FastAPI and use them at several levels of your project.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点讨论 FastAPI 最有趣的部分之一：**依赖注入**。你将会看到，它是一种强大且易于阅读的方式，用于在项目中重用逻辑。事实上，它将允许你为项目创建复杂的构建模块，这些模块可以在整个逻辑中重复使用。认证系统、查询参数验证器或速率限制器是依赖项的典型用例。在
    FastAPI 中，依赖注入甚至可以递归调用另一个依赖项，从而允许你从基础功能构建高级模块。到本章结束时，你将能够为 FastAPI 创建自己的依赖项，并在项目的多个层次上使用它们。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What is dependency injection?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是依赖注入？
- en: Creating and using a function dependency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用函数依赖项
- en: Creating and using a parameterized dependency with a class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类创建和使用带参数的依赖项
- en: Using dependencies at the path, router, and global level
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路径、路由器和全局级别使用依赖项
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code examples, you’ll need a Python virtual environment, which we
    set up in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024), *Python Development*
    *Environment Setup*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码示例，你需要一个 Python 虚拟环境，我们在[*第一章*](B19528_01.xhtml#_idTextAnchor024)中设置了该环境，*Python
    开发* *环境设置*。
- en: You’ll find all the code examples for this chapter in the dedicated GitHub repository
    at [https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在专门的 GitHub 仓库中找到本章的所有代码示例：[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05)。
- en: What is dependency injection?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是依赖注入？
- en: Generally speaking, **dependency injection** is a system to automatically instantiate
    objects and the ones they depend on. The responsibility of developers is then
    to only provide a declaration of how an object should be created, and let the
    system resolve all the dependency chains and create the actual objects at runtime.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，**依赖注入**是一种自动实例化对象及其依赖项的系统。开发者的责任是仅提供对象创建的声明，让系统在运行时解析所有的依赖链并创建实际的对象。
- en: 'FastAPI allows you to declare only the objects and variables you wish to have
    at hand by declaring them in the path operation function arguments. Actually,
    we already used dependency injection in the previous chapters. In the following
    example, we use the `Header` function to retrieve the `user-agent` header:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 允许你通过在路径操作函数的参数中声明它们，仅声明你希望使用的对象和变量。事实上，我们在前几章中已经使用了依赖注入。在以下示例中，我们使用
    `Header` 函数来检索 `user-agent` 头信息：
- en: chapter05_what_is_dependency_injection_01.py
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_what_is_dependency_injection_01.py
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_what_is_dependency_injection_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_what_is_dependency_injection_01.py)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_what_is_dependency_injection_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_what_is_dependency_injection_01.py)'
- en: 'Internally, the `Header` function has some logic to automatically get the `request`
    object, check for the required header, return its value, or raise an error if
    it’s not present. From the developer’s perspective, however, we don’t know how
    it handled the required objects for this operation: we just ask for the value
    we need. *That’s* *dependency injection*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 内部来说，`Header` 函数具有一些逻辑，可以自动获取 `request` 对象，检查是否存在所需的头信息，返回其值，或者在不存在时抛出错误。然而，从开发者的角度来看，我们并不知道它是如何处理所需的对象的：我们只需要获取我们所需的值。*这就是*
    *依赖注入*。
- en: 'Admittedly, you could reproduce this example quite easily in the function body
    by picking the `user-agent` property in the `headers` dictionary of the `request`
    object. However, the dependency injection approach has numerous advantages over
    this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，你可以通过在 `request` 对象的 `headers` 字典中选取 `user-agent` 属性来在函数体中轻松地重现这个示例。然而，依赖注入方法相比之下有许多优势：
- en: 'The *intent is clear*: you know what the endpoint expects in the request data
    without reading the function’s code.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*意图明确*：你可以在不阅读函数代码的情况下，知道端点在请求数据中期望什么。'
- en: 'You have a *clear separation of concerns between the logic of the endpoint
    and the more generic logic*: the header retrieval and the associated error-handling
    doesn’t pollute the rest of the logic; it’s self-contained in the dependency function.
    Besides, it can be reused easily in other endpoints.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个*明确的关注点分离*：端点的逻辑和更通用的逻辑之间的头部检索及其关联的错误处理不会污染其他逻辑；它在依赖函数中自包含。此外，它可以轻松地在其他端点中重用。
- en: In the case of FastAPI, it’s used to *generate the OpenAPI schema* so that the
    automatic documentation can clearly show which parameters are expected for this
    endpoint.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 FastAPI 中，它被用来*生成 OpenAPI 架构*，以便自动生成的文档可以清楚地显示此端点所需的参数。
- en: Put another way, whenever you need utility logic to retrieve or validate data,
    make security checks, or call external logic that you’ll need several times across
    your application, a dependency is an ideal choice.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，每当你需要一些工具逻辑来检索或验证数据、进行安全检查，或调用你在应用中多次需要的外部逻辑时，依赖是一个理想的选择。
- en: FastAPI relies heavily on this dependency injection system and encourages developers
    to use it to implement their building blocks. It may be a bit puzzling if you
    come from other web frameworks such as Flask or Express, but you’ll surely be
    quickly convinced by its power and relevance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 很大程度上依赖于这个依赖注入系统，并鼓励开发者使用它来实现他们的构建模块。如果你来自其他 Web 框架，比如 Flask 或 Express，可能会有些困惑，但你肯定会很快被它的强大和相关性所说服。
- en: To convince you, we’ll now see how you can create and use your very own dependency,
    in the form of a function to begin with.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说服你，我们现在将看到如何创建和使用你自己的依赖，首先从函数形式开始。
- en: Creating and using a function dependency
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并使用一个函数依赖
- en: In FastAPI, a dependency can be defined either as a function or as a callable
    class. In this section, we’ll focus on the functions, which are the ones you’ll
    probably work with most of the time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FastAPI 中，依赖可以被定义为一个函数或一个可调用的类。在本节中，我们将重点关注函数，因为它们是你最可能经常使用的。
- en: As we said, a dependency is a way to wrap some logic that will retrieve some
    sub-values or sub-objects, make something with them, and finally, return a value
    that will be injected into the endpoint calling it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，依赖是将一些逻辑封装起来的方式，这些逻辑会获取一些子值或子对象，处理它们，并最终返回一个将被注入到调用端点中的值。
- en: 'Let’s look at the first example where we define a function dependency to retrieve
    pagination query parameters, `skip` and `limit`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看第一个示例，我们定义一个函数依赖来获取分页查询参数 `skip` 和 `limit`：
- en: chapter05_function_dependency_01.py
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_function_dependency_01.py
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_01.py)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_01.py)'
- en: 'There are two parts to this example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例有两个部分：
- en: 'First, we have the dependency definition, with the `pagination` function. You
    see that we define two arguments, `skip` and `limit`, which are integers with
    default values. Those will be the query parameters on our endpoint. We define
    them exactly like we would have done on a path operation function. That’s the
    beauty of this approach: FastAPI will recursively handle the arguments on the
    dependency and match them with the request data, such as query parameters or headers
    if needed.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们有依赖定义，带有 `pagination` 函数。你会看到我们定义了两个参数，`skip` 和 `limit`，它们是具有默认值的整数。这些将是我们端点的查询参数。我们定义它们的方式与在路径操作函数中定义的方式完全相同。这就是这种方法的美妙之处：FastAPI
    会递归地处理依赖中的参数，并根据需要与请求数据（如查询参数或头部）进行匹配。
- en: We simply return those values as a tuple.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将这些值作为一个元组返回。
- en: 'Second, we have the path operation function, `list_items`, which uses the `pagination`
    dependency. You see here that the usage is quite similar to what we have done
    for header or body values: we define the name of our resulting argument and we
    use a function result as a default value. In the case of a dependency, we use
    the `Depends` function. Its role is to take a function in the argument and execute
    it when the endpoint is called. The sub-dependencies are automatically discovered
    and executed.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，我们有路径操作函数 `list_items`，它使用了 `pagination` 依赖。你可以看到，使用方法与我们为头部或正文值所做的非常相似：我们定义了结果参数的名称，并使用函数结果作为默认值。对于依赖，我们使用
    `Depends` 函数。它的作用是将函数作为参数传递，并在调用端点时执行它。子依赖会被自动发现并执行。
- en: In the endpoint, we have the pagination directly in the form of a tuple.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在该端点中，我们将分页直接作为一个元组返回。
- en: 'Let’s run this example with the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令运行这个示例：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we’ll try to call the `/items` endpoint and see whether it’s able to retrieve
    the query parameters. You can try this with the following HTTPie command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试调用 `/items` 端点，看看它是否能够获取查询参数。你可以使用以下 HTTPie 命令来尝试：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `limit` and `skip` query parameters have correctly been retrieved thanks
    to our function dependency. You can also try to call the endpoint without the
    query parameter and notice that it will return the default values.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`limit` 和 `skip` 查询参数已经通过我们的函数依赖正确地获取。你也可以尝试不带查询参数调用该端点，并注意它会返回默认值。'
- en: Type hint of a dependency return value
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖返回值的类型提示
- en: You may have noticed that we had to type hint the result of our dependency in
    the path operation arguments, even though we already type hinted the dependency
    function itself. Unfortunately, this is a limitation of FastAPI and its `Depends`
    function, which isn’t able to forward the type of the dependency function. Therefore,
    we have to type hint the result by hand, as we did here.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们在路径操作的参数中必须对依赖的结果进行类型提示，即使我们已经为依赖函数本身进行了类型提示。不幸的是，这是 FastAPI 及其 `Depends`
    函数的一个限制，`Depends` 函数无法传递依赖函数的类型。因此，我们必须手动对结果进行类型提示，就像我们在这里所做的那样。
- en: 'And that’s it! As you see, it’s very simple and straightforward to create and
    use a dependency in FastAPI. Of course, you can now reuse it at will in several
    endpoints, as you can see in the rest of the example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如你所见，在 FastAPI 中创建和使用依赖非常简单直接。当然，你现在可以在多个端点中随意重用它，正如你在其余示例中所看到的那样。
- en: chapter05_function_dependency_01.py
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_function_dependency_01.py
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_01.py)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_01.py)'
- en: 'We can do more complex things in those dependencies, just like we would in
    a regular path operation function. In the following example, we add some validation
    to those pagination parameters and cap the limit at `100`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些依赖中，我们可以做更复杂的事情，就像在常规路径操作函数中一样。在以下示例中，我们为这些分页参数添加了一些验证，并将 `limit` 限制为 `100`：
- en: chapter05_function_dependency_02.py
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_function_dependency_02.py
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_02.py)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_02.py)'
- en: 'As you can see, our dependency starts to become more complex:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的依赖开始变得更加复杂：
- en: We added the `Query` function to our arguments to add a validation constraint;
    now, a `422` error will be raised if `skip` or `limit` are negative integers.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在参数中添加了 `Query` 函数来增加验证约束；现在，如果 `skip` 或 `limit` 是负整数，系统将抛出 `422` 错误。
- en: We ensure that the limit is, at most, `100.`
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们确保 `limit` 最多为 `100`。
- en: The code on our path operation functions doesn’t have to change; we have a clear
    separation of concerns between the logic of the endpoint and the more generic
    logic for the pagination parameters.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路径操作函数中的代码不需要修改；我们清楚地将端点的逻辑与分页参数的更通用逻辑分开。
- en: 'Let’s see another typical use of dependencies: get an object or raise a `404`
    error.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个典型的依赖项使用场景：获取一个对象或引发`404`错误。
- en: Getting an object or raising a 404 error
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取对象或引发404错误
- en: 'In a REST API, you’ll typically have endpoints to get, update, and delete a
    single object given its identifier in the path. On each one, you’ll likely have
    the same logic: try to retrieve this object in the database or raise a `404` error
    if it doesn’t exist. That’s a perfect use case for a dependency! In the following
    example, you’ll see how to implement it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST API中，你通常会有端点用于根据路径中的标识符获取、更新和删除单个对象。在每个端点中，你很可能会有相同的逻辑：尝试从数据库中检索这个对象，或者如果它不存在，就引发一个`404`错误。这是一个非常适合使用依赖项的场景！在以下示例中，你将看到如何实现它：
- en: chapter05_function_dependency_03.py
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_function_dependency_03.py
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_03.py)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_03.py)'
- en: 'The dependency definition is simple: it takes, in an argument, the ID of the
    post we want to retrieve. It will be pulled from the corresponding path parameter.
    Then, we check whether it exists in our dummy dictionary database: if it does,
    we return it; otherwise, we raise an HTTP exception with a `404` status code.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的定义很简单：它接受一个参数，即我们想要获取的帖子的ID。它将从相应的路径参数中提取。然后，我们检查它是否存在于我们的虚拟字典数据库中：如果存在，我们返回它；否则，我们会引发一个`404`状态码的HTTP异常。
- en: 'That’s the key takeaway of this example: *you can raise errors in your dependencies*.
    It’s extremely useful to check for some pre-conditions before your endpoint logic
    is executed. Another typical example of this is authentication: if the endpoint
    requires a user to be authenticated, we can raise a `401` error in the dependency
    by checking for the token or the cookie.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个示例的关键要点：*你可以在依赖项中引发错误*。在执行端点逻辑之前，检查某些前置条件是非常有用的。另一个典型的例子是身份验证：如果端点需要用户认证，我们可以通过检查令牌或cookie，在依赖项中引发`401`错误。
- en: 'Now, we can use this dependency in each of our API endpoints, as you can see
    in the following example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在每个API端点中使用这个依赖项，如下例所示：
- en: chapter05_function_dependency_03.py
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_function_dependency_03.py
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_03.py)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_03.py)'
- en: As you can see, we just had to define the `post` argument and use the `Depends`
    function on our `get_post_or_404` dependency. Then, within the path operation
    logic, we are guaranteed to have our `post` object at hand and we can focus on
    our core logic, which is now very concise. The `get` endpoint, for example, just
    has to return the object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只需要定义`post`参数并在`get_post_or_404`依赖项上使用`Depends`函数。然后，在路径操作逻辑中，我们可以确保手头有`post`对象，我们可以集中处理核心逻辑，现在变得非常简洁。例如，`get`端点只需要返回该对象。
- en: In this case, the only point of attention is to not forget the ID parameter
    in the path of those endpoints. According to the rules of FastAPI, if you don’t
    set this parameter in the path, it will automatically be regarded as a query parameter,
    which is not what we want here. You can find more details about this in the *Path
    parameters* section of [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058), *Developing
    a RESTful API* *with FastAPI*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，唯一需要注意的是不要忘记这些端点路径中的ID参数。根据FastAPI的规则，如果你在路径中没有设置这个参数，它会自动被视为查询参数，这不是我们想要的。你可以在[*第三章*](B19528_03.xhtml#_idTextAnchor058)，*使用FastAPI开发RESTful
    API*的*路径参数*部分找到更多详细信息。
- en: That’s all for the function dependencies. As we said, those are the main building
    blocks of a FastAPI project. In some cases, however, you’ll need to have some
    parameters on those dependencies – for example, with values coming from environment
    variables. For this, we can define class dependencies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是函数依赖项的全部内容。正如我们所说，它们是 FastAPI 项目的主要构建块。然而，在某些情况下，你可能需要在这些依赖项中设置一些参数——例如，来自环境变量的值。为此，我们可以定义类依赖项。
- en: "Creating and using a parameterized dependency \Lwith a class"
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类创建和使用带参数的依赖项
- en: In the previous section, we defined dependencies as regular functions, which
    work well in most cases. Still, you may need to set some parameters on a dependency
    to finely tune its behavior. Since the arguments of the function are set by the
    dependency injection system, we can’t add an argument to the function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分中，我们将依赖项定义为常规函数，这在大多数情况下效果良好。然而，你可能需要为依赖项设置一些参数，以便精细调整其行为。由于函数的参数是由依赖注入系统设置的，我们无法向函数添加额外的参数。
- en: In the pagination example, we added some logic to cap the limit value at `100`.
    If we wanted to set this maximum limit dynamically, how would we do that?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在分页示例中，我们添加了一些逻辑将限制值设定为 `100`。如果我们想要动态设置这个最大限制值，该如何操作呢？
- en: 'The solution is to create a class that will be used as a dependency. This way,
    we can set class properties – with the `__init__` method, for example – and use
    them in the logic of the dependency itself. This logic will be defined in the
    `__call__` method of the class. If you remember what we learned in the *Callable
    object* section of [*Chapter 2*](B19528_02.xhtml#_idTextAnchor032), *Python Programming
    Specificities*, you know that it makes the object callable, meaning it can be
    called like a regular function. Actually, that is all that `Depends` requires
    for a dependency: being callable. We’ll use this property to create a parameterized
    dependency thanks to a class.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是创建一个作为依赖项使用的类。这样，我们可以通过 `__init__` 方法等设置类属性，并在依赖项的逻辑中使用它们。这些逻辑将会在类的 `__call__`
    方法中定义。如果你还记得我们在[*第二章*](B19528_02.xhtml#_idTextAnchor032)的*可调用对象*部分中学到的内容，你会知道它使对象可调用，也就是说，它可以像常规函数一样被调用。事实上，这就是
    `Depends` 对依赖项的所有要求：可调用。我们将利用这一特性，通过类来创建一个带参数的依赖项。
- en: 'In the following example, we reimplemented the pagination example with a class,
    allowing us to set the maximum limit dynamically:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用类重新实现了分页示例，这使得我们可以动态设置最大限制：
- en: chapter05_class_dependency_01.py
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_class_dependency_01.py
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_01.py)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_01.py)'
- en: As you can see, the logic in the `__call__` method is the same as in the function
    we defined in the previous example. The only difference here is that we can pull
    our maximum limit from our class properties, which we can set at the object initialization.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`__call__` 方法中的逻辑与我们在前一个示例中定义的函数相同。唯一的区别是，我们可以从类的属性中获取最大限制值，这些属性可以在对象初始化时设置。
- en: 'Then, you can simply create an instance of this class and use it as a dependency
    with `Depends` on your path operation function, as you can see in the following
    code block:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以简单地创建该类的实例，并在路径操作函数中使用 `Depends` 作为依赖项，就像你在以下代码块中看到的那样：
- en: chapter05_class_dependency_01.py
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_class_dependency_01.py
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_01.py)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_01.py)'
- en: Here, we hardcoded the `50` value, but we could very well pull it from a configuration
    file or an environment variable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们硬编码了 `50` 的值，但我们完全可以从配置文件或环境变量中获取这个值。
- en: The other advantage of a class dependency is that it can maintain local values
    in memory. This property can be very useful if we have to make some heavy initialization
    logic, such as loading a machine learning model, for example, which we want to
    do only once at startup. Then, the callable part just has to call the loaded model
    to make the prediction, which should be quite fast.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 类依赖的另一个优点是它可以在内存中保持局部值。如果我们需要进行一些繁重的初始化逻辑，例如加载一个机器学习模型，我们希望在启动时只做一次。然后，可调用的部分只需调用已加载的模型来进行预测，这应该是非常快速的。
- en: Using class methods as dependencies
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类方法作为依赖项
- en: Even if the `__call__` method is the most straightforward way to make a class
    dependency, you can directly pass a method to `Depends`. Indeed, as we said, it
    simply expects a callable as an argument, and a class method is a perfectly valid
    callable!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`__call__`方法是实现类依赖的最直接方式，你也可以直接将方法传递给`Depends`。实际上，正如我们所说，它只需要一个可调用对象作为参数，而类方法是一个完全有效的可调用对象！
- en: This approach can be very useful if you have common parameters or logic that
    you need to reuse in slightly different cases. For example, you could have one
    pre-trained machine learning model made with scikit-learn. Before applying the
    decision function, you may want to apply different preprocessing steps, depending
    on the input data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些公共参数或逻辑需要在稍微不同的情况下重用，这种方法非常有用。例如，你可以有一个使用scikit-learn训练的预训练机器学习模型。在应用决策函数之前，你可能想根据输入数据应用不同的预处理步骤。
- en: To do this, simply write your logic in a class method and pass it to the `Depends`
    function through the dot notation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，只需将你的逻辑写入一个类方法，并通过点符号将其传递给`Depends`函数。
- en: 'You can see this in the following example, where we implement another style
    for our pagination dependency, with `page` and `size` parameters instead of `skip`
    and `limit`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下示例中看到这一点，我们为分页依赖项实现了另一种样式，使用`page`和`size`参数，而不是`skip`和`limit`：
- en: chapter05_class_dependency_02.py
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_class_dependency_02.py
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_02.py)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_02.py)'
- en: 'The logic of the two methods is quite similar. We just look at different query
    parameters. Then, on our path operation functions, we set the `/items` endpoint
    to work with the `skip`/`limit` style, while the `/things` endpoint will work
    with the `page`/`size` style:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的逻辑非常相似。我们只是在查看不同的查询参数。然后，在我们的路径操作函数中，我们将`/items`端点设置为使用`skip`/`limit`样式，而`/things`端点将使用`page`/`size`样式：
- en: chapter05_class_dependency_02.py
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_class_dependency_02.py
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_02.py)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_02.py)'
- en: As you can see, we only have to pass the method we want through the dot notation
    on the `pagination` object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们只需通过点符号将所需的方法传递给`pagination`对象。
- en: To sum up, the class dependency approach is more advanced than the function
    approach but can be very useful for cases when you need to set parameters dynamically,
    perform heavy initialization logic, or reuse common logic on several dependencies.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，类依赖方法比函数依赖方法更为先进，但在需要动态设置参数、执行繁重的初始化逻辑或在多个依赖项之间重用公共逻辑时非常有用。
- en: Until now, we’ve assumed that we care about the return value of the dependency.
    While this will probably be the case most of the time, you may occasionally need
    to call a dependency to check for some conditions but don’t really need the returned
    value. FastAPI allows such use cases, and that’s what we’ll see now.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假设我们关心依赖项的返回值。虽然大多数情况下确实如此，但你可能偶尔需要调用依赖项以检查某些条件，但并不需要返回值。FastAPI 允许这种用例，接下来我们将看到这个功能。
- en: Using dependencies at the path, router, and global level
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在路径、路由器和全局级别使用依赖项
- en: As we said, dependencies are the recommended way to create building blocks in
    a FastAPI project, allowing you to reuse logic across endpoints while maintaining
    maximum code readability. Until now, we’ve applied them to a single endpoint,
    but couldn’t we expand this approach to a whole router? Or even a whole FastAPI
    application? Actually, we can!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所说，依赖项是创建 FastAPI 项目构建模块的推荐方式，它允许你在多个端点间重用逻辑，同时保持代码的最大可读性。到目前为止，我们已将依赖项应用于单个端点，但我们能否将这种方法扩展到整个路由器？甚至是整个
    FastAPI 应用程序？事实上，我们可以！
- en: The main motivation for this is to be able to apply some global request validation
    or perform side logic on several routes without the need to add a dependency on
    each endpoint. Typically, an authentication method or a rate limiter could be
    very good candidates for this use case.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的主要动机是能够在多个路由上应用一些全局请求验证或执行副作用逻辑，而无需在每个端点上都添加依赖项。通常，身份验证方法或速率限制器可能是这个用例的很好的候选者。
- en: 'To show you how it works, we’ll implement a simple dependency that we will
    use across all the following examples. You can see it in the following example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向你展示它是如何工作的，我们将实现一个简单的依赖项，并在以下所有示例中使用它。你可以在以下示例中看到它：
- en: chapter05_path_dependency_01.py
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_path_dependency_01.py
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_path_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_path_dependency_01.py)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_path_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_path_dependency_01.py)'
- en: This dependency will simply look for a header in the request named `Secret-Header`.
    If it’s missing or not equal to `SECRET_VALUE`, it will raise a `403` error. Please
    note that this approach is only for the sake of the example; there are better
    ways to secure your API, which we’ll cover in [*Chapter 7*](B19528_07.xhtml#_idTextAnchor448),
    *Managing Authentication and Security* *in FastAPI*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖项将简单地查找请求中名为 `Secret-Header` 的头部。如果它缺失或不等于 `SECRET_VALUE`，它将引发 `403` 错误。请注意，这种方法仅用于示例；有更好的方式来保护你的
    API，我们将在[*第 7 章*](B19528_07.xhtml#_idTextAnchor448)中讨论，*在 FastAPI 中管理身份验证和安全性*。
- en: Using a dependency on a path decorator
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在路径装饰器上使用依赖项
- en: 'Until now, we’ve assumed that we were always interested in the return value
    of the dependency. As our `secret_header` dependency clearly shows here, this
    is not always the case. This is why you can add a dependency on a path operation
    decorator instead of the arguments. You can see how in the following example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们一直假设我们总是对依赖项的返回值感兴趣。正如我们的 `secret_header` 依赖项在这里清楚地显示的那样，这并非总是如此。这就是为什么你可以将依赖项添加到路径操作装饰器上，而不是传递参数。你可以在以下示例中看到如何操作：
- en: chapter05_path_dependency_01.py
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_path_dependency_01.py
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_path_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_path_dependency_01.py)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_path_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_path_dependency_01.py)'
- en: The path operation decorator accepts an argument, `dependencies`, which expects
    a list of dependencies. You see that, just like for dependencies you pass in arguments,
    you need to wrap your function (or callable) with the `Depends` function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 路径操作装饰器接受一个参数 `dependencies`，该参数期望一个依赖项列表。你会发现，就像为依赖项传递参数一样，你需要用 `Depends` 函数包装你的函数（或可调用对象）。
- en: Now, whenever the `/protected-route` route is called, the dependency will be
    called and will check for the required header.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当调用 `/protected-route` 路由时，依赖项将被调用并检查所需的头部信息。
- en: As you may have guessed, since `dependencies` is a list, you can add as many
    dependencies as you need.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，由于 `dependencies` 是一个列表，你可以根据需要添加任意数量的依赖项。
- en: That’s interesting, but what if we want to protect a whole set of endpoints?
    It would be a bit cumbersome and error-prone to add it manually to each one. Fortunately,
    FastAPI provides a way to do that.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣，但如果我们想保护一整组端点呢？手动为每个端点添加可能会有点繁琐且容易出错。幸运的是，FastAPI 提供了一种方法来实现这一点。
- en: Using a dependency on a whole router
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在整个路由器上使用依赖项
- en: If you recall the *Structuring a bigger project with multiple routers* section
    in [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058), *Developing a RESTful API
    with FastAPI*, you know that you can create several routers in your project to
    clearly split the different parts of your API and “wire” them to your main FastAPI
    application. This is done with the `APIRouter` class and the `include_router`
    method of the `FastAPI` class.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得在 [*第三章*](B19528_03.xhtml#_idTextAnchor058)中的 *使用多个路由器结构化一个更大的项目* 部分，*使用
    FastAPI 开发 RESTful API*，你就知道你可以在项目中创建多个路由器，以清晰地拆分 API 的不同部分，并将它们“连接”到你的主 FastAPI
    应用程序。这是通过 `APIRouter` 类和 `FastAPI` 类的 `include_router` 方法来完成的。
- en: 'With this approach, it can be interesting to inject a dependency into the whole
    router, so that it’s called for every route of this router. You have two ways
    of doing this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，将一个依赖项注入整个路由器是很有趣的，这样它会在该路由器的每个路由上被调用。你有两种方法可以做到这一点：
- en: 'Set the `dependencies` argument on the `APIRouter` class, as you can see in
    the following example:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `APIRouter` 类上设置 `dependencies` 参数，正如以下示例所示：
- en: chapter05_router_dependency_01.py
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_router_dependency_01.py
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_router_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_router_dependency_01.py)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_router_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_router_dependency_01.py)'
- en: 'Set the `dependencies` argument on the `include_router` method, as you can
    see in the following example:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `include_router` 方法上设置 `dependencies` 参数，正如以下示例所示：
- en: chapter05_router_dependency_02.py
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_router_dependency_02.py
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_router_dependency_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_router_dependency_02.py)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_router_dependency_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_router_dependency_02.py)'
- en: In both cases, the `dependencies` argument expects a list of dependencies. You
    can see that, just like for dependencies you pass in arguments, you need to wrap
    your function (or callable) with the `Depends` function. Of course, since it’s
    a list, you can add several dependencies if you need.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`dependencies` 参数都期望一个依赖项的列表。你可以看到，就像传递依赖项作为参数一样，你需要用 `Depends` 函数将你的函数（或可调用对象）包装起来。当然，由于它是一个列表，如果需要，你可以添加多个依赖项。
- en: Now, how to choose between the two approaches? In both cases, the effect will
    be exactly the same, so we could say it doesn’t really matter. Philosophically,
    we could say that we should declare a dependency on the `APIRouter` class if it’s
    needed in the context of this router. Put another way, we could ask ourselves
    the question, *Does this router work without this dependency if we run it independently*?
    If the answer to this question is *no*, then you should probably set the dependency
    on the `APIRouter` class. Otherwise, declaring it in the `include_router` method
    may make more sense. But again, this is an intellectual choice that won’t change
    the functionality of your API, so feel free to choose the one you’re more comfortable
    with.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如何选择这两种方法呢？在这两种情况下，效果完全相同，所以我们可以说其实并不重要。从哲学角度来看，我们可以说，如果依赖项在这个路由器的上下文中是必要的，我们应该在
    `APIRouter` 类上声明依赖项。换句话说，我们可以问自己这个问题，*如果我们独立运行这个路由器，是否没有这个依赖项就无法工作*？如果这个问题的答案是*否*，那么你可能应该在
    `APIRouter` 类上设置依赖项。否则，在 `include_router` 方法中声明它可能更有意义。但再说一次，这只是一个思想选择，它不会改变你
    API 的功能，因此你可以选择你更舒适的方式。
- en: We are now able to set dependencies for a whole router. In some cases, it could
    also be interesting to declare them for a whole application!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够为整个路由器设置依赖项。在某些情况下，为整个应用程序声明依赖项也可能很有趣！
- en: Using a dependency on a whole application
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在整个应用程序中使用依赖项
- en: 'If you have a dependency that implements some logging or rate-limiting functionality,
    for example, it could be interesting to execute it for every endpoint of your
    API. Fortunately, FastAPI allows this, as you can see in the following example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个实现了某些日志记录或限流功能的依赖项，例如，将其应用到你 API 的每个端点可能会很有意义。幸运的是，FastAPI 允许这样做，正如以下示例所示：
- en: chapter05_global_dependency_01.py
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05_global_dependency_01.py
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_global_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_global_dependency_01.py)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_global_dependency_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_global_dependency_01.py)'
- en: Once again, you only have to set the `dependencies` argument directly on the
    main `FastAPI` class. Now, the dependency is applied to every endpoint in your
    API!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你只需直接在主 `FastAPI` 类上设置 `dependencies` 参数。现在，依赖项应用于你 API 中的每个端点！
- en: 'In *Figure 5**.1*, we propose a simple decision tree to determine at which
    level you should inject your dependency:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5**.1* 中，我们提出了一个简单的决策树，用于确定你应该在哪个级别注入依赖项：
- en: '![Figure 5.1 – At which level should I inject my dependency?](img/Figure_5.1_B19528.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 我应该在哪个级别注入我的依赖项？](img/Figure_5.1_B19528.jpg)'
- en: Figure 5.1 – At which level should I inject my dependency?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 我应该在哪个级别注入我的依赖项？
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Well done! You should now be comfortable with one of the most iconic features
    of FastAPI: dependency injection. By implementing your own dependencies, you’ll
    be able to keep common logic that you wish to reuse across your API separate from
    the endpoints’ logic. This will make your project clean and maintainable while
    retaining maximum readability; dependencies just need to be declared as arguments
    of the path operation functions, which will help you to understand the intent
    without having to read the body of the function.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在你应该已经熟悉了 FastAPI 最具标志性的特性之一：依赖注入。通过实现自己的依赖项，你可以将希望在整个 API 中重用的常见逻辑与端点的逻辑分开。这样可以使你的项目清晰可维护，同时保持最大的可读性；只需将依赖项声明为路径操作函数的参数即可，这将帮助你理解意图，而无需阅读函数体。
- en: Those dependencies can be both simple wrappers to retrieve and validate request
    parameters, or complex services performing machine learning tasks. Thanks to the
    class-based approach, you can indeed set dynamic parameters or keep a local state
    for your most advanced tasks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖项可以是简单的包装器，用于检索和验证请求参数，也可以是执行机器学习任务的复杂服务。多亏了基于类的方法，你确实可以设置动态参数或为最复杂的任务保持局部状态。
- en: Finally, those dependencies can also be used at a router or global level, allowing
    you to perform common logic or checks for a set of routes or a whole application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这些依赖项还可以在路由器或全局级别上使用，允许你对一组路由或整个应用程序执行常见逻辑或检查。
- en: That’s the end of the first part of this book! You’re now acquainted with the
    main features of FastAPI and should now be able to write clean and performant
    REST APIs with the framework.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本书第一部分的结束！你现在已经熟悉了 FastAPI 的主要特性，并且应该能够使用这个框架编写干净且高性能的 REST API。
- en: In the next part, we’ll take your knowledge to the next level and show you how
    you can implement and deploy a robust, secure, and tested web backend. The first
    chapter will be dedicated to databases, a must-have for most APIs to be able to
    read and write data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将带你的知识提升到新的高度，并展示如何实现和部署一个强大、安全且经过测试的 Web 后端。第一章将专注于数据库，大多数 API 都需要能够读取和写入数据。
