- en: <st c="0">13</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">13</st>
- en: <st c="3">Non-Linear Data Structures</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">非线性数据结构</st>
- en: '**<st c="30">Non-linear data structures</st>** <st c="57">form</st> <st c="63">a
    crucial class of data structures with extensive applications in designing efficient
    algorithms.</st> <st c="161">Unlike linear data structures, such as arrays and
    linked lists, non-linear structures allow data elements to be stored and accessed
    in a more complex, hierarchical manner.</st> <st c="333">These structures enable
    the efficient handling of relationships, dependencies, and hierarchical data,
    making them vital for solving a wide range of</st> <st c="481">computational problems.</st>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="30">非线性数据结构</st>** <st c="57">构成</st> <st c="63">一个关键的数据结构类别，广泛应用于设计高效算法。</st>
    <st c="161">与线性数据结构（如数组和链表）不同，非线性结构允许数据元素以更复杂、层次化的方式存储和访问。</st> <st c="333">这些结构使得高效处理关系、依赖性和层次数据成为可能，因而在解决各种计算问题时至关重要。</st>
    <st c="481">计算问题。</st>'
- en: '<st c="504">In this chapter, we begin by exploring the general properties and
    characteristics that define non-linear data structures.</st> <st c="627">Following
    this, we discuss two major groups: graphs and trees.</st> **<st c="690">Graphs</st>**
    <st c="696">are</st> <st c="701">versatile structures used to model relationships
    between objects, while</st> **<st c="773">trees</st>** <st c="778">represent</st>
    <st c="788">hierarchical relationships in a more structured form.</st> <st c="843">Finally,
    we</st> <st c="854">examine a special case of binary trees, known as</st> **<st
    c="904">heaps</st>**<st c="909">, which are essential for implementing efficient
    algorithms such as heapsort.</st> <st c="987">Learning about non-linear data structures
    is essential for algorithm design, as they play a key role in many algorithms,
    including those for sorting and searching.</st> <st c="1151">Additionally, graphs,
    trees, and other forms of non-linear data structures are extensively used in advanced
    fields such as AI, machine learning, and optimization, where efficient data management
    and processing</st> <st c="1361">are critical.</st>'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="504">在本章中，我们首先探索定义非线性数据结构的一般属性和特征。</st> <st c="627">接着，我们讨论两大类：图和树。</st>
    **<st c="690">图</st>** <st c="696">是</st> <st c="701">用于模拟对象之间关系的多功能结构，而</st>
    **<st c="773">树</st>** <st c="778">则表示</st> <st c="788">层次关系，以更结构化的形式展现。</st>
    <st c="843">最后，我们</st> <st c="854">研究一种特殊的二叉树，称为</st> **<st c="904">堆</st>**<st
    c="909">，它在实现高效算法（如堆排序）中至关重要。</st> <st c="987">学习非线性数据结构对于算法设计至关重要，因为它们在许多算法中扮演着关键角色，包括排序和搜索算法。</st>
    <st c="1151">此外，图、树以及其他形式的非线性数据结构在人工智能、机器学习和优化等先进领域得到广泛应用，这些领域对高效的数据管理和处理要求极高。</st>
    <st c="1361">在这些领域中，数据管理和处理的效率至关重要。</st>
- en: <st c="1374">This chapter covers the</st> <st c="1399">following topics:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1374">本章涵盖以下主题：</st>
- en: <st c="1416">Introduction to non-linear</st> <st c="1444">data structures</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1416">非线性</st> <st c="1444">数据结构简介</st>
- en: <st c="1459">Graphs</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1459">图</st>
- en: <st c="1466">Trees</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1466">树</st>
- en: <st c="1472">Heaps</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1472">堆</st>
- en: <st c="1478">Introduction to non-linear data structures</st>
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1478">非线性数据结构简介</st>
- en: '<st c="1521">In</st> [*<st c="1525">Chapter 11</st>*](B22248_11.xhtml#_idTextAnchor164)<st
    c="1535">, we</st> <st c="1539">introduced the concept of</st> **<st c="1566">abstract
    data types</st>** <st c="1585">(</st>**<st c="1587">ADTs</st>**<st c="1591">),
    classifying</st> <st c="1606">them into two main categories: linear and non-linear.</st>
    <st c="1661">We followed this with an in-depth discussion of linear data structures
    in</st> [*<st c="1735">Chapter 12</st>*](B22248_12.xhtml#_idTextAnchor187)<st
    c="1745">, where we examined their relevance to our core focus – designing and
    analyzing efficient algorithms.</st> <st c="1847">While we touched on many essential
    aspects of linear data structures, it is worth noting that this area of study
    is vast and could easily warrant its own in-depth exploration.</st> <st c="2023">For
    those interested in deeper exploration of data structures, we have included references
    at the end of both</st> *<st c="2133">Chapters 11</st>* <st c="2144">and</st>
    *<st c="2149">12</st>*<st c="2151">.</st>'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1521">在</st> [*<st c="1525">第11章</st>*](B22248_11.xhtml#_idTextAnchor164)<st
    c="1535">中，我们</st> <st c="1539">介绍了</st> **<st c="1566">抽象数据类型</st>** <st c="1585">(</st>**<st
    c="1587">ADTs</st>**<st c="1591">)，并将其分为两大类：线性和非线性。</st> <st c="1606">随后，我们在</st>
    [*<st c="1735">第12章</st>*](B22248_12.xhtml#_idTextAnchor187)<st c="1745">中深入讨论了线性数据结构，分析了它们与我们核心目标——设计和分析高效算法——之间的关系。</st>
    <st c="1847">虽然我们触及了线性数据结构的许多关键方面，但值得注意的是，这一领域非常广泛，完全可以单独进行更深入的探讨。</st> <st c="2023">对于那些有兴趣深入探索数据结构的人，我们在</st>
    *<st c="2133">第11章</st>* <st c="2144">和</st> *<st c="2149">第12章</st>*<st c="2151">的末尾已列出了相关参考资料。</st>
- en: <st c="2152">In this chapter, our focus shifts to non-linear data structures.</st>
    <st c="2218">Like the previous chapter, we will approach this topic with an eye
    on its relationship with efficient algorithm design.</st> <st c="2338">Our goal
    is not merely to present the various types of non-linear data structures but to
    highlight their roles and applications in improving the performance</st> <st c="2495">of
    algorithms.</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2152">在本章中，我们的重点转向非线性数据结构。</st> <st c="2218">与前一章类似，我们将从它与高效算法设计的关系出发，来探讨这一话题。</st>
    <st c="2338">我们的目标不仅仅是介绍各种非线性数据结构，更是要突出它们在提高算法性能方面的作用和应用。</st> <st c="2495">。</st>
- en: <st c="2509">Let’s begin by briefly discussing what defines non-linear data
    structures, their key characteristics, and some of the most commonly</st> <st
    c="2642">used types.</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2509">让我们从简要讨论非线性数据结构的定义、其主要特征以及一些常用类型开始。</st>
- en: <st c="2653">Unlike linear data structures, where elements are arranged in a
    sequential manner (e.g., arrays, linked lists), non-linear data structures organize
    data in a hierarchical or interconnected way.</st> <st c="2848">In non-linear
    structures, each element may be connected to multiple other elements, forming
    complex relationships that enable more efficient data processing for</st> <st
    c="3009">certain operations.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2653">与线性数据结构不同，线性数据结构中的元素按顺序排列（例如，数组、链表），非线性数据结构以层级或互联的方式组织数据。</st>
    <st c="2848">在非线性结构中，每个元素可能与多个其他元素相连接，形成复杂的关系，从而在</st> <st c="3009">某些操作中实现更高效的数据处理。</st>
- en: <st c="3028">The following are the</st> <st c="3051">key features of non-linear</st>
    <st c="3078">data structures:</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3028">以下是非线性</st> <st c="3051">数据结构的主要特点：</st>
- en: '**<st c="3094">Hierarchical relationships</st>**<st c="3121">: Elements are
    structured in a way that reflects a hierarchy, meaning</st> <st c="3192">some
    elements may act as</st> **<st c="3217">parents</st>** <st c="3224">while others
    are</st> **<st c="3242">children</st>**<st c="3250">. This is particularly true
    for structures such as</st> **<st c="3301">trees</st>** <st c="3306">and</st>
    **<st c="3311">graphs</st>**<st c="3317">.</st>'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="3094">层级关系</st>**<st c="3121">：元素的结构呈现出反映层次关系的方式，这意味着</st> <st c="3192">某些元素可能作为</st>
    **<st c="3217">父元素</st>** <st c="3224">而其他元素则是</st> **<st c="3242">子元素</st>**<st
    c="3250">。这种情况在像</st> **<st c="3301">树形结构</st>** <st c="3306">和</st> **<st c="3311">图形</st>**<st
    c="3317">等结构中尤为明显。</st>'
- en: '**<st c="3318">Complex traversal patterns</st>**<st c="3345">: Unlike linear
    structures, where traversal is relatively</st> <st c="3403">straightforward, moving
    through non-linear data structures requires more sophisticated techniques, often
    specific to the structure</st> <st c="3535">being used.</st>'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="3318">复杂的遍历模式</st>**<st c="3345">：与线性结构不同，线性结构的遍历相对</st> <st c="3403">简单，遍历非线性数据结构需要更复杂的技术，这些技术通常是特定于所使用的结构的。</st>'
- en: '**<st c="3546">Variable access time</st>**<st c="3567">: The time</st> <st
    c="3579">it takes to search, insert, or delete elements can vary greatly depending
    on the structure and the way it is implemented.</st> <st c="3701">In many cases,
    non-linear data structures allow for more efficient operations compared</st> <st
    c="3788">to their</st> <st c="3797">linear counterparts.</st>'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="3546">变量访问时间</st>**<st c="3567">：搜索、插入或删除元素所需的时间可以根据结构和实现方式的不同而大相径庭。</st>
    <st c="3579">在许多情况下，非线性数据结构相比</st> <st c="3701">于其</st> <st c="3788">线性结构，能够实现更高效的操作。</st>'
- en: <st c="3817">Non-linear data structures are</st> <st c="3848">composed of several
    key elements that define their structure and functionality.</st> <st c="3929">The
    most important components include nodes, edges, parents, children, roots, leaves,
    and subtrees.</st> <st c="4029">Let’s understand these components</st> <st c="4063">in
    detail:</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3817">非线性数据结构由</st> <st c="3848">若干关键元素组成，这些元素定义了其结构和功能。</st> <st c="3929">最重要的组成部分包括节点、边、父节点、子节点、根节点、叶子节点和子树。</st>
    <st c="4029">让我们详细了解这些组成部分：</st>
- en: '**<st c="4073">Nodes</st>**<st c="4079">: A</st> <st c="4084">node or vertex
    is the fundamental building block of most non-linear data structures.</st> <st
    c="4169">Each node typically contains data and may also have connections to other
    vertices, depending on the type of structure.</st> <st c="4288">In trees, for
    example, vertices represent individual elements within the hierarchy.</st> <st
    c="4372">For example, in a social network graph, each node represents a user,
    and the data stored in the node might be the user’s</st> <st c="4493">profile
    information.</st>'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4073">节点</st>**<st c="4079">：节点或顶点是大多数非线性数据结构的基本构建块。</st> <st c="4084">每个节点通常包含数据，并且根据结构的类型，可能还会与其他顶点连接。</st>
    <st c="4169">例如，在树结构中，顶点表示层级中的独立元素。</st> <st c="4288">例如，在社交网络图中，每个节点代表一个用户，节点中存储的数据可能是该用户的</st>
    <st c="4372">个人资料信息。</st>'
- en: '**<st c="4513">Edges</st>**<st c="4519">: An</st> <st c="4525">edge or arrow
    is a link or connection between two nodes.</st> <st c="4582">In non-linear structures,
    edges play a critical role in defining the relationships between nodes.</st> <st
    c="4680">In a binary tree, edges define the relationship between a parent and
    its children.</st> <st c="4763">For example, if a parent node represents a manager,
    the edges would connect to child nodes that represent their employees.</st> <st
    c="4886">In a graph, an edge represents a relationship between two entities.</st>
    <st c="4954">In a transportation network, for instance, an edge might represent
    a direct flight between</st> <st c="5045">two cities.</st>'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4513">边</st>**<st c="4519">：边或箭头是连接两个节点的链接。</st> <st c="4525">在非线性结构中，边在定义节点之间的关系中起着至关重要的作用。</st>
    <st c="4582">在二叉树中，边定义了父节点与子节点之间的关系。</st> <st c="4680">例如，如果父节点代表经理，那么边将连接到表示其员工的子节点。</st>
    <st c="4763">在图中，边表示两个实体之间的关系。</st> <st c="4886">例如，在交通网络中，一条边可能表示两座城市之间的直飞航班。</st>
    <st c="4954">在运输网络中，一条边可能代表</st> <st c="5045">两座城市之间的航班。</st>'
- en: '**<st c="5056">Parents and children</st>**<st c="5077">: In hierarchical non-linear
    data structures such as trees, nodes are organized in levels, where parent nodes
    are directly connected to the child nodes below them.</st> <st c="5242">The parent-child
    relationship is a fundamental concept</st> <st c="5297">in trees:</st>'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="5056">父母和子女</st>**<st c="5077">：在树等层级非线性数据结构中，节点按层级组织，父节点直接连接到其下方的子节点。</st>
    <st c="5242">父子关系是树结构的基本概念：</st>'
- en: '**<st c="5306">Parent</st>**<st c="5313">: A</st> <st c="5318">node that has
    one or more child nodes directly</st> <st c="5365">beneath it</st>'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="5306">父节点</st>**<st c="5313">：一个具有一个或多个直接</st> <st c="5318">子节点的节点</st>'
- en: '**<st c="5375">Child</st>**<st c="5381">: A node</st> <st c="5390">that is
    directly connected to another node above it (</st><st c="5444">its parent)</st>'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="5375">子节点</st>**<st c="5381">：一个直接连接到其上方节点的节点（</st><st c="5444">即父节点）</st>'
- en: <st c="5456">For example, in a corporate hierarchy tree, a manager is a parent
    node, and their subordinates are the</st> <st c="5560">child nodes.</st>
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="5456">例如，在企业层级树中，经理是父节点，子下属是</st> <st c="5560">子节点。</st>
- en: '**<st c="5572">Root</st>**<st c="5577">: The root is</st> <st c="5591">the
    topmost node in a tree structure and acts as the starting point for traversing
    the tree.</st> <st c="5685">A tree can only have one root, and all other nodes
    are descendants of this root.</st> <st c="5766">If a node has no parent, it is
    considered the root.</st> <st c="5818">In a filesystem, the root directory is
    the topmost folder, and all other directories or files branch out</st> <st c="5923">from
    it.</st>'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="5572">根</st>**<st c="5577">：根是</st> <st c="5591">树结构中最顶部的节点，作为遍历树的起点。</st>
    <st c="5685">一棵树只能有一个根，所有其他节点都是该根的后代。</st> <st c="5766">如果一个节点没有父节点，它被认为是根。</st>
    <st c="5818">在文件系统中，根目录是最顶层的文件夹，所有其他目录或文件都从</st> <st c="5923">它那里分支出来。</st>'
- en: '**<st c="5931">Leaf</st>**<st c="5936">: A</st> <st c="5941">leaf is a node
    that has no children.</st> <st c="5978">Leaves represent the endpoints of a tree
    structure, where no further branching occurs.</st> <st c="6065">These are crucial
    in many algorithms, as they often signal completion points in traversals</st>
    <st c="6156">or searches.</st>'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="5931">叶子</st>**<st c="5936">：叶子是没有子节点的节点。</st> <st c="5941">叶子表示树结构的端点，在这些地方不会再发生分支。</st>
    <st c="5978">在许多算法中，叶子非常关键，因为它们通常标志着遍历</st> <st c="6065">或搜索的完成点。</st> <st c="6156">。</st>'
- en: '**<st c="6168">Subtree</st>**<st c="6176">: A</st> <st c="6180">subtree is
    a smaller portion of a tree that includes a node and all its descendants.</st>
    <st c="6266">Subtrees allow trees to be treated recursively, where each node,
    along with its children, can be considered a tree on its own.</st> <st c="6393">In
    a decision tree, each node and its branches form a subtree, representing a subset
    of</st> <st c="6481">possible decisions.</st>'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6168">子树</st>**<st c="6176">：子树是树的一部分，包括一个节点及其所有子孙节点。</st> <st c="6180">子树使得树可以递归处理，其中每个节点及其子节点可以被视为一个独立的树。</st>
    <st c="6266">在决策树中，每个节点及其分支构成一个子树，代表一部分</st> <st c="6393">可能的决策。</st> <st c="6481">。</st>'
- en: <st c="6500">There are several types of non-linear data structures, each suited
    to different kinds of algorithmic problems.</st> <st c="6612">The most common
    non-linear data structures include graphs, trees, and heaps.</st> <st c="6689">In
    the following sections, we will examine these three fundamental non-linear data
    structures in detail.</st> <st c="6794">Each of the structures has unique characteristics
    and applications, and understanding them is crucial for designing efficient algorithms.</st>
    <st c="6932">We will explore their properties, how they are implemented, and the
    roles they play in solving various</st> <st c="7035">computational problems.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6500">非线性数据结构有多种类型，每种类型都适用于不同的算法问题。</st> <st c="6612">最常见的非线性数据结构包括图、树和堆。</st>
    <st c="6689">在接下来的章节中，我们将详细探讨这三种基本的非线性数据结构。</st> <st c="6794">每种结构都有其独特的特点和应用，理解它们对于设计高效的算法至关重要。</st>
    <st c="6932">我们将探讨它们的属性、实现方式以及它们在解决各种</st> <st c="7035">计算问题中的作用。</st>
- en: <st c="7058">Graphs</st>
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="7058">图</st>
- en: '**<st c="7065">Graphs</st>** <st c="7072">are</st> <st c="7076">one of the
    most versatile and widely used non-linear data structures.</st> <st c="7147">They
    are used to represent relationships between entities, where entities are represented
    as nodes (also called</st> **<st c="7259">vertices</st>**<st c="7267">) and</st>
    <st c="7273">relationships as edges.</st> <st c="7298">Graphs can model a wide
    range of real-world problems, from social networks to transportation systems and</st>
    <st c="7403">communication protocols.</st>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="7065">图</st>** <st c="7072">是</st> <st c="7076">最具多功能性且广泛使用的非线性数据结构之一。</st>
    <st c="7147">它们用于表示实体之间的关系，其中实体表示为节点（也称为</st> **<st c="7259">顶点</st>**<st c="7267">），</st>
    <st c="7273">关系则表示为边。</st> <st c="7298">图可以建模各种现实世界的问题，从社交网络到交通系统和</st> <st c="7403">通信协议。</st>'
- en: <st c="7427">Graphs come in various types, each with specific properties that
    make them suitable for different tasks.</st> <st c="7533">Here are the most common
    types</st> <st c="7564">of graphs:</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7427">图有多种类型，每种类型具有特定的属性，使其适合不同的任务。</st> <st c="7533">以下是最常见的图类型：</st>
    <st c="7564">。</st>
- en: '**<st c="7574">Undirected graphs</st>**<st c="7592">: In</st> <st c="7598">undirected
    graphs, edges have no direction.</st> <st c="7642">The</st> <st c="7646">relationship
    between two nodes is bidirectional (see</st> *<st c="7699">Figure 13</st>**<st
    c="7708">.1</st>*<st c="7710">).</st> <st c="7714">If there is an edge between
    node A and node B, you can traverse from A to B or from B to A without any restrictions.</st>
    <st c="7831">An example of an undirected graph is the social network of Facebook
    friends, where connections are mutual.</st> <st c="7938">This means if A is friends
    with B, then B is also friends with A, reflecting the bidirectional nature of</st>
    <st c="8043">the relationship.</st>'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7574">无向图</st>**<st c="7592">：在</st> <st c="7598">无向图中，边没有方向。</st>
    <st c="7642">两个节点之间的关系是双向的（参见</st> *<st c="7699">图 13</st>**<st c="7708">.1</st>*<st
    c="7710">）。</st> <st c="7714">如果节点 A 和节点 B 之间有一条边，你可以从 A 遍历到 B，也可以从 B 遍历到 A，且没有任何限制。</st>
    <st c="7831">无向图的一个例子是 Facebook 好友的社交网络，其中的连接是相互的。</st> <st c="7938">这意味着如果 A
    是 B 的朋友，那么 B 也是 A 的朋友，体现了关系的双向性质。</st>'
- en: '![Figure 13.1: An undirected graph](img/B22248_13_1.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1：无向图](img/B22248_13_1.jpg)'
- en: '<st c="8062">Figure 13.1: An undirected graph</st>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8062">图 13.1：无向图</st>
- en: '**<st c="8094">Directed graphs (digraphs)</st>**<st c="8121">: In digraphs,
    edges have a direction.</st> <st c="8161">The relationship</st> <st c="8178">between
    nodes is one-way, meaning</st> <st c="8211">that if there is a directed edge from
    node A to node B, you can only traverse from A to B, not the other way around,
    for example, a website where pages have links pointing to other pages, forming
    a digraph.</st> *<st c="8419">Figure 13</st>**<st c="8428">.2</st>* <st c="8430">shows
    an example of digraphs.</st> <st c="8461">As illustrated, graphs do not have to
    be</st> <st c="8502">fully connected.</st>'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="8094">有向图（有向图）</st>**<st c="8121">：在有向图中，边具有方向。</st> <st c="8161">节点之间的关系是单向的，这意味着</st>
    <st c="8211">如果存在从节点 A 指向节点 B 的有向边，你只能从 A 遍历到 B，而不能反过来。例如，网站上的页面有指向其他页面的链接，形成了一个有向图。</st>
    *<st c="8419">图 13</st>**<st c="8428">.2</st>* <st c="8430">展示了有向图的一个例子。</st>
    <st c="8461">如图所示，图形不必是</st> <st c="8502">完全连接的。</st>'
- en: '![Figure 13.2: A digraph](img/B22248_13_2.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2：有向图](img/B22248_13_2.jpg)'
- en: '<st c="8522">Figure 13.2: A digraph</st>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8522">图 13.2：有向图</st>
- en: '**<st c="8544">Weighted graphs</st>**<st c="8560">: In a</st> <st c="8568">weighted
    graph, each edge is</st> <st c="8597">assigned a numerical value or</st> **<st
    c="8627">weight</st>**<st c="8633">. This weight often represents a cost, distance,
    or time associated with the connection between nodes.</st> <st c="8736">An example
    of a weighted graph is a road network where the weight of an edge represents the</st>
    <st c="8828">distance or travel time</st> <st c="8852">between cities.</st> *<st
    c="8868">Figure 13</st>**<st c="8877">.3</st>* <st c="8879">depicts a weighted
    graph, where the weights are assigned to</st> <st c="8940">the edges.</st>'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="8544">带权图</st>**<st c="8560">：在带权图中，每条边都被赋予一个数值或</st> **<st c="8627">权重</st>**<st
    c="8633">。这个权重通常表示与节点之间连接相关的成本、距离或时间。</st> <st c="8736">带权图的一个例子是道路网络，其中每条边的权重代表城市之间的</st>
    <st c="8828">距离或旅行时间。</st> <st c="8852">图 13.3 描绘了一个带权图，其中权重被分配给了</st> <st c="8940">各个边。</st>'
- en: '![Figure 13.3: A weighted graph](img/B22248_13_3.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3：带权图](img/B22248_13_3.jpg)'
- en: '<st c="8952">Figure 13.3: A weighted graph</st>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8952">图 13.3：带权图</st>
- en: '**<st c="8981">Unweighted graphs</st>**<st c="8999">: In unweighted graphs,
    all edges have equal significance, meaning</st> <st c="9067">that there is no
    particular cost or distance</st> <st c="9112">associated with traveling between
    nodes.</st> <st c="9153">In</st> *<st c="9156">Figure 13</st>**<st c="9165">.1</st>*<st
    c="9167">, the graph</st> <st c="9179">is unweighted.</st>'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="8981">无权图</st>**<st c="8999">：在无权图中，所有边具有相同的重要性，这意味着</st> <st c="9067">在节点之间的旅行没有特定的成本或距离。</st>
    <st c="9112">在</st> *<st c="9156">图 13</st>**<st c="9165">.1</st>*<st c="9167">中，图是无权图。</st>'
- en: '**<st c="9193">Cyclic and acyclic graphs</st>**<st c="9219">: A cyclic graph
    contains at least one cycle, meaning</st> <st c="9273">you</st> <st c="9277">can
    start from a node, traverse</st> <st c="9310">edges, and return to the</st> <st
    c="9335">same node.</st> <st c="9346">An acyclic graph has no such cycles, making
    them essential for applications such as task scheduling.</st> <st c="9447">The
    graph in</st> *<st c="9460">Figure 13</st>**<st c="9469">.1</st>* <st c="9471">has
    cycles.</st>'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="9193">有向图与无向图</st>**<st c="9219">：有向图包含至少一个循环，即</st> <st c="9273">你可以从一个节点出发，遍历</st>
    <st c="9310">边，最后回到</st> <st c="9335">同一个节点。</st> <st c="9346">无向图没有这样的循环，因此在任务调度等应用中至关重要。</st>
    <st c="9447">图中的</st> *<st c="9460">图 13.1</st>**<st c="9469">包含循环。</st>'
- en: '**<st c="9483">Signed graphs</st>**<st c="9497">: In</st> <st c="9503">signed
    graphs, edges are labeled with</st> <st c="9540">either positive or negative signs,
    typically representing favorable or unfavorable relationships.</st> <st c="9639">These
    graphs are useful in scenarios where relationships can have polarities, such as
    in social networks, where edges</st> <st c="9757">could represent</st> <st c="9772">friendship
    (positive) or conflict (negative).</st> <st c="9819">Social networks in which
    positive edges represent friendships and negative edges represent rivalries is
    an example of a</st> <st c="9939">signed graph.</st>'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="9483">符号图</st>**<st c="9497">：在符号图中，边上标有</st> <st c="9540">正号或负号，通常代表有利或不利的关系。</st>
    <st c="9639">这种图在关系可以有极性时非常有用，例如在社交网络中，边可以表示</st> <st c="9757">友谊（正向）或冲突（负向）。</st>
    <st c="9819">其中，正边代表友谊，负边代表竞争关系的社交网络就是符号图的一个例子。</st>'
- en: '**<st c="9952">Hypergraphs</st>**<st c="9964">: A</st> <st c="9969">hypergraph</st>
    <st c="9980">generalizes the</st> <st c="9995">concept of a graph by allowing
    edges (called</st> **<st c="10041">hyperedges</st>**<st c="10051">) to connect
    more than two nodes at a time.</st> <st c="10096">This type of graph is particularly
    useful in representing complex relationships where a single connection might involve
    multiple entities.</st> <st c="10235">For example, in a research collaboration
    network, a hyperedge might represent a publication authored by three or more researchers,
    connecting all of</st> <st c="10384">them simultaneously.</st>'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="9952">超图</st>**<st c="9964">：超图通过允许边（称为</st> **<st c="10041">超边</st>**<st
    c="10051">）一次连接多个节点，从而推广了图的概念。</st> <st c="10096">这种类型的图在表示复杂关系时尤为有用，尤其是当单一连接可能涉及多个实体时。</st>
    <st c="10235">例如，在研究合作网络中，一个超边可能代表三位或更多研究人员共同撰写的论文，同时连接所有研究人员。</st>'
- en: '![Figure 13.4: A hypergraph](img/B22248_13_4.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4：超图](img/B22248_13_4.jpg)'
- en: '<st c="10406">Figure 13.4: A hypergraph</st>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10406">图 13.4：超图</st>
- en: '*<st c="10431">Figure 13</st>**<st c="10441">.4</st>* <st c="10443">illustrates
    an example of a hypergraph with the following components: The set of vertices
    is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1836.png)<st
    c="10537"><st c="10562">, and the set of hyperedges is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/1837.png)<st
    c="10593"><st c="10605">. Each hyperedge connects multiple vertices as follows:</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1838.png)<st
    c="10661"><st c="10677">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1839.png)<st
    c="10679"><st c="10693">,</st> <st c="10695">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1840.png)<st
    c="10699"><st c="10714">.</st></st></st></st></st></st>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="10431">图 13</st>**<st c="10441">.4</st>* <st c="10443">展示了一个超图的示例，包含以下组件：顶点集合为</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1836.png)<st
    c="10537"><st c="10562">，超边集合为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/1837.png)<st
    c="10593"><st c="10605">。每个超边连接多个顶点，如下所示：</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1838.png)<st
    c="10661"><st c="10677">，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1839.png)<st
    c="10679"><st c="10693">，</st> <st c="10695">以及</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1840.png)<st
    c="10699"><st c="10714">。</st></st></st></st></st></st>'
- en: <st c="10715">In the following</st> <st c="10733">section, we will explore how
    to represent some of the most commonly used graphs in algorithms and discuss the
    complexities associated with each</st> <st c="10877">representation method.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10715">在接下来的</st> <st c="10733">章节中，我们将探讨如何表示算法中最常用的几种图，并讨论与每种表示方法相关的复杂性。</st>
    <st c="10877">。</st>
- en: <st c="10899">Graphs representation</st>
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10899">图的表示</st>
- en: <st c="10921">Graphs can be</st> <st c="10936">represented in several ways,
    each method being well suited to particular use cases depending on the graph structure
    and the type of operations needed.</st> <st c="11087">In the following subsections,
    we will examine three common methods for graph representation and their key properties.</st>
    <st c="11205">While evaluating each method, we will focus on three critical aspects
    of</st> <st c="11278">their performance:</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10921">图可以以</st> <st c="10936">多种方式表示，每种方法都适用于特定的使用场景，取决于图的结构和所需的操作类型。</st>
    <st c="11087">在接下来的小节中，我们将探讨三种常见的图表示方法及其关键特性。</st> <st c="11205">在评估每种方法时，我们将重点关注它们性能的三个关键方面：</st>
- en: '**<st c="11296">Space complexity</st>**<st c="11313">: How much memory is required
    to store the graph using the</st> <st c="11373">chosen representation</st>'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="11296">空间复杂度</st>**<st c="11313">：使用所选表示方法存储图所需的内存量</st> <st c="11373">。</st>'
- en: '**<st c="11394">The time complexity for accessing all neighbors of a node</st>**<st
    c="11452">: The efficiency of retrieving all nodes that are directly connected
    (adjacent) to a</st> <st c="11538">given node</st>'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="11394">访问节点所有邻居的时间复杂度</st>**<st c="11452">：检索所有直接连接（相邻）到某一给定节点的节点的效率</st>
    <st c="11538">。</st>'
- en: '**<st c="11548">The time complexity for checking edge existence</st>**<st c="11596">:
    The time required to determine whether an edge exists between two</st> <st c="11665">specific
    nodes</st>'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="11548">检查边是否存在的时间复杂度</st>**<st c="11596">：确定两个特定节点之间是否存在边所需的时间</st>
    <st c="11665">。</st>'
- en: <st c="11679">By analyzing these complexities, we can better understand the
    strengths and limitations of each graph representation and how they apply to different</st>
    <st c="11829">algorithmic tasks.</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11679">通过分析这些复杂性，我们可以更好地理解每种图形表示的优缺点，以及它们如何应用于不同的</st> <st c="11829">算法任务。</st>
- en: <st c="11847">Adjacency matrix</st>
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="11847">邻接矩阵</st>
- en: <st c="11864">An</st> **<st c="11868">adjacency matrix</st>** <st c="11884">represents</st>
    <st c="11895">a graph</st> <st c="11904">using a</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>V</mi><mo>×</mo><mi>V</mi></mrow></mrow></math>](img/1841.png)
    <st c="11912"><st c="11914">matrix, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/1842.png)
    <st c="11928"><st c="11929">is the number of nodes or vertices in the graph.</st>
    <st c="11979">Each cell in the matrix at position</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1843.png)
    <st c="12015"><st c="12016">indicates the presence (and possibly the weight) of
    an edge between node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/1844.png)
    <st c="12090"><st c="12091">and node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/1845.png)<st
    c="12101"><st c="12102">. In an undirected graph, the adjacency matrix</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1650.png)
    <st c="12149"><st c="12150">is symmetric, meaning that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi><mml:mo>=</mml:mo><mml:mi>D</mml:mi></mml:math>](img/1847.png)<st
    c="12178"><st c="12179">’, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1656.png)<st
    c="12188">*<st c="12189">’</st>* <st c="12190">represents the transpose of matrix</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1656.png)<st
    c="12226"><st c="12227">. This symmetry arises because the edges in an undirected
    graph have no direction, so</st> <st c="12313">if there is an edge between node</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="12346"><st c="12347">and node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/1035.png)<st
    c="12357"><st c="12358">, the relationship is mutual.</st> <st c="12388">Therefore,
    both</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1852.png)
    <st c="12404"><st c="12406">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1853.png)
    <st c="12410"><st c="12411">will have the</st> <st c="12426">same value.</st></st></st></st></st></st></st></st></st></st></st></st></st></st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11864">一个</st> **<st c="11868">邻接矩阵</st>** <st c="11884">用</st> <st c="11895">图形</st>
    <st c="11904">表示为</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>V</mi><mo>×</mo><mi>V</mi></mrow></mrow></math>](img/1841.png)
    <st c="11912"><st c="11914">矩阵，其中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/1842.png)
    <st c="11928"><st c="11929">是图中的节点或顶点数。</st> <st c="11979">矩阵中的每个单元格在位置</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1843.png)
    <st c="12015"><st c="12016">指示节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/1844.png)
    <st c="12090"><st c="12091">和节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/1845.png)<st
    c="12101"><st c="12102">之间边的存在（可能带有权重）。</st> 在无向图中，邻接矩阵 <st c="12149">![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1650.png)
    <st c="12150">对称，这意味着</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi><mml:mo>=</mml:mo><mml:mi>D</mml:mi></mml:math>](img/1847.png)<st
    c="12178"><st c="12179">’，其中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1656.png)<st
    c="12188">*<st c="12189">’</st>* <st c="12190">表示矩阵</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1656.png)<st
    c="12226"><st c="12227">的转置。这种对称性是因为无向图中的边没有方向，所以</st> <st c="12313">如果节点</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="12346"><st c="12347">和节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/1035.png)<st
    c="12357"><st c="12358">之间有边，关系是互相的。</st> <st c="12388">因此，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1852.png)
    <st c="12404"><st c="12406">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1853.png)
    <st c="12410"><st c="12411">将具有相同的值。</st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st
- en: <st c="12437">For</st> <st c="12442">unweighted, unsigned graphs, the adjacency
    matrix is a binary matrix, where each entry is either 0 or 1\.</st> <st c="12547">A
    value of 1 at</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1854.png)
    <st c="12563"><st c="12570">indicates that there is an edge between vertices</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="12619"><st c="12620">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/1035.png)<st
    c="12625"><st c="12626">, and a 0 means no edge exists</st> <st c="12657">between
    them.</st></st></st></st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12437">对于</st> <st c="12442">无权重、无符号图，邻接矩阵是一个二进制矩阵，其中每个元素的值为0或1。</st>
    <st c="12547">在</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1854.png)
    <st c="12563"><st c="12570">的值为1表示顶点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="12619"><st c="12620">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/1035.png)<st
    c="12625"><st c="12626">之间有一条边，值为0表示它们之间没有边。</st></st></st></st>
- en: '**<st c="12670">Example 13.1</st>**<st c="12683">:</st>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="12670">示例 13.1</st>**<st c="12683">：</st>'
- en: <st c="12685">Here is a matrix representing a digraph</st> <st c="12725">with
    weights:</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12685">这里是一个表示带权有向图的矩阵</st> <st c="12725">： </st>
- en: <st c="12738">A --></st> <st c="12745">B (2)</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12738">A --></st> <st c="12745">B (2)</st>
- en: <st c="12750">B --></st> <st c="12757">C (3)</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12750">B --></st> <st c="12757">C (3)</st>
- en: <st c="12762">A --></st> <st c="12769">C (4)</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12762">A --></st> <st c="12769">C (4)</st>
- en: <st c="12774">The adjacency matrix representing this simple graph is a</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:mn>3</mml:mn></mml:math>](img/1857.png)
    <st c="12832"><st c="12838">matrix</st> <st c="12845">as follows:</st></st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12774">表示这个简单图的邻接矩阵是一个</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:mn>3</mml:mn></mml:math>](img/1857.png)
    <st c="12832"><st c="12838">矩阵</st> <st c="12845">如下所示：</st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mtable
    columnspacing="0.8000em 0.8000em" columnwidth="auto auto auto" columnalign="center
    center center" rowalign="baseline"><mtr><mtd><mi>A</mi></mtd><mtd><mi>B</mi></mtd><mtd><mi>C</mi></mtd></mtr></mtable></mrow></math>](img/1858.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mtable
    columnspacing="0.8000em 0.8000em" columnwidth="auto auto auto" columnalign="center
    center center" rowalign="baseline"><mtr><mtd><mi>A</mi></mtd><mtd><mi>B</mi></mtd><mtd><mi>C</mi></mtd></mtr></mtable></mrow></math>](img/1858.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtable><mml:mtr><mml:mtd><mml:mi>A</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>B</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>C</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>2</mml:mn></mml:mtd><mml:mtd><mml:mn>4</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/1859.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtable><mml:mtr><mml:mtd><mml:mi>A</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>B</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>C</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>2</mml:mn></mml:mtd><mml:mtd><mml:mn>4</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/1859.png)'
- en: <st c="12859">It is obvious that the space complexity of this representation
    is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1860.png)<st
    c="12925"><st c="12926">. Regardless of the number of edges, the adjacency matrix
    requires space proportional to the square of the number of vertices because it
    must account for every possible edge between all pairs of vertices.</st> <st c="13131">This
    can be inefficient for large graphs, especially if the graph is sparse (i.e.,
    has relatively few edges compared to the number of</st> <st c="13265">possible
    edges).</st></st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12859">显然，该表示的空间复杂度是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1860.png)<st
    c="12925"><st c="12926">。无论边的数量如何，邻接矩阵都需要与顶点数的平方成比例的空间，因为它必须考虑所有顶点对之间的每条可能边。</st>
    <st c="13131">这对于大型图可能效率低下，特别是如果图是稀疏的（即边的数量相对于可能边的数量较少）。</st></st>
- en: <st c="13281">In graphs, one of the operations is accessing all neighbors of
    a node in the graph.</st> <st c="13366">Using adjacency matrix representation,
    the time complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1861.png)<st
    c="13428"><st c="13429">. To find all neighbors of a given node, we need to inspect
    all entries in the corresponding row (or column) of the matrix.</st> <st c="13553">For
    a node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="13564"><st c="13565">, you scan the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/1863.png)
    <st c="13580"><st c="13584">row to check which vertices have a direct edge from</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="13636"><st c="13637">, which reminds us of a linear search algorithm in which
    we want to report all non-zero entries.</st> <st c="13734">This operation requires
    examining</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/1865.png)
    <st c="13768"><st c="13769">entries, resulting in a time complexity of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1866.png)<st
    c="13813"><st c="13814">, regardless of the number of actual neighbors the node
    has.</st> <st c="13875">In contrast, checking whether an edge exists in the adjacency
    matrix representation has a time complexity of</st> <st c="13984">O</st><st c="13985">(</st><st
    c="13986">1</st><st c="13987">)</st><st c="13988">, as we can directly access
    any edge in constant time.</st> <st c="14043">Since the adjacency matrix</st>
    <st c="14069">is a two-dimensional array, checking whether an edge exists between
    node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="14143"><st c="14144">and</st> <st c="14149">node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/1035.png)
    <st c="14154"><st c="14155">is a direct access operation to the cell at position</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1869.png)<st
    c="14209"><st c="14210">. Simply check whether the value at</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1869.png)
    <st c="14246"><st c="14247">is non-zero (for weighted graphs) or</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>t</mml:mi><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi></mml:math>](img/1871.png)
    <st c="14285"><st c="14286">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>1</mml:mn></mml:math>](img/1872.png)
    <st c="14290"><st c="14291">(for</st> <st c="14297">unweighted graphs).</st></st></st></st></st></st></st></st></st></st></st></st></st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，访问节点的所有邻居是图中的一个操作。<st c="13366">使用邻接矩阵表示，时间复杂度是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1861.png)<st
    c="13428"><st c="13429">。要找到给定节点的所有邻居，需要检查矩阵的相应行（或列）中的所有条目。</st> <st c="13553">对于节点</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="13564"><st c="13565">，您扫描</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/1863.png)
    <st c="13580"><st c="13584">行以检查哪些顶点从</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="13636"><st c="13637">具有直接边缘，这让我们想起了线性搜索算法，其中我们要报告所有非零条目。</st> <st c="13734">这一操作需要检查</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/1865.png)
    <st c="13768"><st c="13769">条目，导致时间复杂度为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1866.png)<st
    c="13813"><st c="13814">，无论节点实际有多少邻居。</st> <st c="13875">相比之下，检查邻接矩阵表示中是否存在边的时间复杂度为</st>
    <st c="13984">O</st><st c="13985">(</st><st c="13986">1</st><st c="13987">)</st><st
    c="13988">，因为我们可以直接在常数时间内访问任何边。</st> <st c="14043">由于邻接矩阵</st> <st c="14069">是一个二维数组，检查节点</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="14143"><st c="14144">和</st> <st c="14149">节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/1035.png)
    <st c="14154"><st c="14155">之间是否存在边是对位置</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1869.png)<st
    c="14209"><st c="14210">的直接访问操作。只需检查</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1869.png)
    <st c="14246"><st c="14247">处的值是否非零（对于加权图）或</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>1</mml:mn></mml:math>](img/1872.png)
    <st c="14290"><st c="14291">（对于</st> <st c="14297">无权图）。</st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st>
- en: <st c="14316">When should we use an adjacency matrix?</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14316">我们什么时候应该使用邻接矩阵？</st>
- en: <st c="14356">It is particularly useful when the graph is dense (i.e., the number
    of edges is close to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/1873.png)<st
    c="14446"><st c="14447">), as the high space requirement becomes less significant
    in such cases.</st> <st c="14520">Additionally, if our algorithm needs constant-time
    edge existence checks, the adjacency matrix offers a clear advantage.</st> <st
    c="14641">Lastly, the adjacency matrix is simple to implement, making it a practical
    choice for certain algorithms where ease of use is</st> <st c="14767">a priority.</st></st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14356">当图是稠密图（即边的数量接近</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/1873.png)<st
    c="14446"><st c="14447">)，此时高空间需求变得不那么重要。</st> <st c="14520">此外，如果我们的算法需要常量时间的边存在性检查，邻接矩阵则具有明显的优势。</st>
    <st c="14641">最后，邻接矩阵实现简单，对于某些注重易用性的算法来说，它是一个实用的选择。</st>
- en: <st c="14778">Adjacency list</st>
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="14778">邻接表</st>
- en: <st c="14793">In</st> <st c="14797">an</st> **<st c="14800">adjacency list</st>**<st
    c="14814">, each node stores a list of its neighboring</st> <st c="14859">nodes
    (or nodes it is connected to).</st> <st c="14896">This is a more space-efficient
    representation, especially for sparse graphs.</st> <st c="14973">The adjacency
    list for</st> *<st c="14996">Example 13.1</st>* <st c="15008">is</st> <st c="15012">as
    follows:</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14793">在</st> <st c="14797">一个</st> **<st c="14800">邻接表</st>**<st c="14814">中，每个节点存储其邻居节点的列表</st>
    <st c="14859">（或与之相连的节点）。</st> <st c="14896">这是一种更节省空间的表示方法，尤其适用于稀疏图。</st> <st
    c="14973">示例 13.1 的邻接表</st> *<st c="14996">如以下所示</st>* <st c="15008">是</st> <st
    c="15012">如下：</st>
- en: <st c="15023">A:</st> <st c="15027">B(2), C(4)</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15023">A:</st> <st c="15027">B(2), C(4)</st>
- en: '<st c="15037">B: C(3)</st>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="15037">B: C(3)</st>'
- en: '<st c="15045">C: -</st>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="15045">C: -</st>'
- en: <st c="15050">The adjacency list representation uses</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>+</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1874.png)
    <st c="15090"><st c="15099">space, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/1875.png)
    <st c="15112"><st c="15113">is the number of edges.</st> <st c="15138">This is
    generally more efficient for</st> <st c="15175">sparse graphs.</st></st></st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15050">邻接表表示使用</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>+</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1874.png)
    <st c="15090"><st c="15099">空间，其中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/1875.png)
    <st c="15112"><st c="15113">是边的数量。</st> <st c="15138">这种表示方式通常对于</st> <st c="15175">稀疏图更加高效。</st></st></st>
- en: <st c="15189">Accessing the neighbors of a node (i.e., adjacent vertices) takes</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1876.png)<st
    c="15256"><st c="15257">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/1184.png)
    <st c="15265"><st c="15266">is the degree of the node (the number of edges connected
    to the node).</st> <st c="15338">In the worst case, this could be</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1878.png)<st
    c="15371"><st c="15374">, but for most practical applications, it’s much smaller.</st>
    <st c="15432">In the preceding adjacency list, the nodes listed after the colon
    represent the neighbors, or adjacent nodes, of the node on the</st> <st c="15561">left
    side.</st></st></st></st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 访问一个节点的邻居（即相邻的顶点）需要耗费<st c="15189">时间</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1876.png)<st
    c="15256"><st c="15257">，其中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/1184.png)
    <st c="15265"><st c="15266">是该节点的度（即与该节点相连的边的数量）。</st> <st c="15338">在最坏的情况下，这个时间复杂度可能是</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1878.png)<st
    c="15371"><st c="15374">，但是对于大多数实际应用来说，它要小得多。</st> <st c="15432">在上述邻接表中，冒号后列出的节点表示该节点左侧的邻居或相邻节点。</st></st></st></st>
- en: <st c="15571">To check</st> <st c="15581">whether there is an edge between two
    specific vertices, you need to traverse the list of adjacent vertices.</st> <st
    c="15689">This takes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1879.png)
    <st c="15700"><st c="15701">time, since we may need to scan through all neighbors
    of</st> <st c="15759">the source node.</st> <st c="15776">In the worst case, this
    is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1880.png)<st
    c="15803"><st c="15806">, but typically it is smaller for</st> <st c="15840">sparse
    graphs.</st></st></st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15571">要检查</st> <st c="15581">两个特定顶点之间是否存在一条边，你需要遍历相邻顶点的列表。</st> <st
    c="15689">这需要</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1879.png)
    <st c="15700"><st c="15701">的时间，因为我们可能需要扫描源节点的所有邻居。</st> <st c="15776">在最坏的情况下，这需要</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1880.png)<st
    c="15803"><st c="15806">，但对于稀疏图来说，通常要小得多。</st></st></st>
- en: <st c="15854">When to use an adjacency list</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15854">何时使用邻接表</st>
- en: <st c="15884">An adjacency list is most effective when the graph is sparse –
    that is when the number of edges is much smaller than</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/1881.png)<st
    c="16002"><st c="16003">. Since the space complexity is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1882.png)<st
    c="16035"><st c="16045">, it is more memory-efficient for graphs with fewer edges.</st>
    <st c="16104">Additionally, if our algorithm frequently needs to access all neighbors
    of a node, the adjacency list provides efficient</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1883.png)
    <st c="16225"><st c="16226">access.</st> <st c="16235">It is also beneficial for
    dynamic graphs where nodes and edges are frequently added or removed, as updating
    an adjacency list is straightforward and less costly in terms</st> <st c="16405">of
    memory.</st></st></st></st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15884">邻接表在图较为稀疏时最为高效——也就是说，当边的数量远小于</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/1881.png)<st
    c="16002"><st c="16003">。由于空间复杂度是</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1882.png)<st
    c="16035"><st c="16045">，因此对于边较少的图，邻接表更加节省内存。</st> <st c="16104">此外，如果我们的算法经常需要访问某个节点的所有邻居，邻接表提供高效的</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1883.png)
    <st c="16225"><st c="16226">访问。</st> <st c="16235">它对于动态图也非常有益，在这种图中，节点和边经常被添加或删除，因为更新邻接表直接且在</st>
    <st c="16405">内存方面的开销较小。</st></st></st></st>
- en: <st c="16415">Edge list</st>
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="16415">边列表</st>
- en: <st c="16425">An</st> **<st c="16429">edge list</st>** <st c="16438">explicitly</st>
    <st c="16449">stores all the edges in a graph</st> <st c="16482">along with their
    weights (if any).</st> <st c="16517">This is useful when the graph is sparse and
    you need to work primarily with the edges.</st> <st c="16604">The edge list in
    the</st> *<st c="16625">Example 13.1</st>* <st c="16637">graph is</st> <st c="16647">as
    follows:</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16425">一个</st> **<st c="16429">边列表</st>** <st c="16438">明确地</st> <st
    c="16449">存储图中的所有边</st> <st c="16482">以及它们的权重（如果有的话）。</st> <st c="16517">当图较为稀疏并且你主要需要处理边时，边列表非常有用。</st>
    <st c="16604">该边列表在</st> *<st c="16625">示例 13.1</st>* <st c="16637">中的图是</st>
    <st c="16647">如下：</st>
- en: <st c="16658">(A,</st> <st c="16663">B, 2)</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16658">(A,</st> <st c="16663">B, 2)</st>
- en: <st c="16668">(A,</st> <st c="16673">C, 4)</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16668">(A,</st> <st c="16673">C, 4)</st>
- en: <st c="16678">(B,</st> <st c="16683">C, 3)</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16678">(B,</st> <st c="16683">C, 3)</st>
- en: <st c="16688">The edge list representation uses</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1884.png)
    <st c="16723"><st c="16724">space.</st> <st c="16732">This is efficient for very
    sparse graphs.</st> <st c="16774">To access all neighbors of a node, the edge
    list does not directly store them, so finding all neighbors requires scanning
    the entire edge list, which has a worst-case time complexity of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1885.png)<st
    c="16960"><st c="16961">. Likewise, checking whether an edge exists between two
    vertices also involves scanning the entire edge list, resulting in a time complexity</st>
    <st c="17102">of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1886.png)<st
    c="17105"><st c="17106">.</st></st></st></st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 边列表表示法使用![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1884.png)
    <st c="16723"><st c="16724">空间。</st> <st c="16732">对于非常稀疏的图，这种表示方式非常高效。</st> <st
    c="16774">要访问节点的所有邻居，边列表并没有直接存储它们，因此查找所有邻居需要扫描整个边列表，最坏情况下的时间复杂度为</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1885.png)<st
    c="16960"><st c="16961">。</st> 同样，检查两个顶点之间是否存在边也需要扫描整个边列表，导致时间复杂度为</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1886.png)<st
    c="17105"><st c="17106">。</st></st></st></st>
- en: <st c="17107">When to use an edge list</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用边列表
- en: <st c="17132">An edge list is</st> <st c="17149">ideal for very sparse graphs
    where we primarily need to work with the edges themselves rather than frequently
    accessing neighbors or checking edge existence.</st> <st c="17307">It uses</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1887.png)
    <st c="17315"><st c="17320">space, making it highly memory-efficient for graphs
    with few edges.</st> <st c="17388">However, its primary limitation is that it
    is not efficient for operations such as finding all neighbors of a node or checking
    whether a specific edge exists, both of which require scanning through the entire
    list.</st> <st c="17603">Therefore, edge lists are best suited for algorithms
    where working directly with the edges is the focus, such as in certain edge-centric
    algorithms such as Kruskal’s minimum spanning</st> <st c="17786">tree algorithm.</st></st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 边列表是<st c="17132">非常适合稀疏图，在这种图中，我们主要需要处理边本身，而不是频繁访问邻居或检查边的存在。</st> 它使用![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1887.png)
    <st c="17315"><st c="17320">空间，使其在边较少的图中具有很高的内存效率。</st> <st c="17388">然而，它的主要限制在于，它对于某些操作并不高效，例如查找节点的所有邻居或检查特定边是否存在，这两者都需要扫描整个列表。</st>
    <st c="17603">因此，边列表最适合用于那些直接处理边的算法，例如一些以边为中心的算法，如 Kruskal 最小生成树算法。</st>
- en: <st c="17801">Traversing graphs</st>
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图遍历
- en: '**<st c="17819">Traversal</st>** <st c="17829">is a</st> <st c="17834">fundamental
    operation in graph algorithms, where the goal is to visit all nodes in a specific
    sequence.</st> <st c="17939">The two most widely used graph traversal techniques
    are</st> **<st c="17995">depth-first search</st>** <st c="18013">(</st>**<st c="18015">DFS</st>**<st
    c="18018">) and</st> **<st c="18025">breadth-first search</st>** <st c="18045">(</st>**<st
    c="18047">BFS</st>**<st c="18050">).</st> <st c="18054">In the sections that</st>
    <st c="18074">follow, we will explore both of these methods</st> <st c="18120">in
    detail, highlighting their processes, use cases,</st> <st c="18173">and complexities.</st>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="17819">遍历</st>** <st c="17829">是图算法中的一种基础操作，其目标是按照特定顺序访问所有节点。</st>
    <st c="17939">两种最广泛使用的图遍历技术是</st> **<st c="17995">深度优先搜索</st>** <st c="18013">（</st>**<st
    c="18015">DFS</st>**<st c="18018">）和</st> **<st c="18025">广度优先搜索</st>** <st c="18045">（</st>**<st
    c="18047">BFS</st>**<st c="18050">）。</st> <st c="18054">在接下来的章节中，我们将详细探讨这两种方法</st>
    <st c="18074">，重点介绍它们的过程、应用场景</st> <st c="18120">和复杂度。</st>'
- en: <st c="18190">DFS graph traversal</st>
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="18190">DFS 图遍历</st>
- en: <st c="18210">DFS is a</st> <st c="18220">graph traversal technique that explores
    as far along each</st> <st c="18277">branch or path as possible before backtracking.</st>
    <st c="18326">It is typically implemented using recursion or a stack, and it works
    well in exploring deep structures or discovering specific paths in</st> <st c="18462">a
    graph.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18210">DFS 是一种</st> <st c="18220">图遍历技术，它会在回溯之前尽可能深入地探索每一条分支或路径。</st>
    <st c="18277">它通常通过递归或栈实现，特别适合用于探索深层结构或在图中发现特定路径。</st> <st c="18462">在图中运作良好。</st>
- en: <st c="18470">The idea behind DFS is to start at an arbitrary node (usually
    called the</st> *<st c="18544">root</st>*<st c="18548">) and explore each branch
    of the graph as deeply as possible before moving on to the next branch.</st> <st
    c="18647">DFS follows these</st> <st c="18665">basic steps:</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18470">DFS 的核心思想是从一个任意节点开始（通常称为</st> *<st c="18544">根节点</st>*<st c="18548">），然后尽可能深入地探索图的每一条分支，再转向下一个分支。</st>
    <st c="18647">DFS 按照以下</st> <st c="18665">基本步骤进行：</st>
- en: <st c="18677">Visit the</st> <st c="18688">starting node.</st>
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="18677">访问起始节点。</st>
- en: <st c="18702">For each unvisited neighbor of the current node, perform a DFS
    on</st> <st c="18769">that neighbor.</st>
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="18702">对于当前节点的每个未访问的邻居，执行一次对该邻居的 DFS。</st>
- en: <st c="18783">Repeat this process until all nodes reachable from the starting
    node</st> <st c="18853">are visited.</st>
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="18783">重复此过程，直到所有从起始节点可达的节点都被访问。</st>
- en: <st c="18865">Let’s</st> <st c="18872">consider</st> <st c="18880">the graph
    in</st> *<st c="18894">Figure 13</st>**<st c="18903">.5</st>* <st c="18905">with</st>
    <st c="18911">six nodes.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18865">让我们</st> <st c="18872">考虑</st> <st c="18880">图中的</st> *<st c="18894">图
    13</st>**<st c="18903">.5</st>* <st c="18905">，它包含六个节点。</st>
- en: '![Figure 13.5: An example graph](img/B22248_13_5.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5：一个示例图](img/B22248_13_5.jpg)'
- en: '<st c="18923">Figure 13.5: An example graph</st>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18923">图 13.5：一个示例图</st>
- en: '<st c="18952">Starting the DFS at</st> *<st c="18973">node A</st>*<st c="18979">,
    the traversal order would be this: A --> B --> D --> E --> F --> C.</st> <st c="19049">This
    traversal explores one path (branch) completely before moving on to</st> <st c="19122">the
    next.</st>'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18952">从</st> *<st c="18973">节点 A</st>*<st c="18979">开始进行 DFS，遍历顺序如下：A
    --> B --> D --> E --> F --> C。</st> <st c="19049">这个遍历完全探索了一条路径（分支），然后才转向下一个。</st>
- en: <st c="19131">Here is a Python implementation of DFS using recursion.</st> <st
    c="19188">First, we define a</st> <st c="19207">simple graph:</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19131">这里是一个使用递归实现的 Python 深度优先搜索（DFS）。</st> <st c="19188">首先，我们定义一个</st>
    <st c="19207">简单的图：</st>
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="19468">The</st> <st c="19473">following</st> <st c="19483">code visualizes
    the</st> <st c="19503">example graph:</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19468">下面的</st> <st c="19473">代码可视化了</st> <st c="19483">示例图：</st>
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="20013">Now, we</st> <st c="20022">implement the DFS</st> <st c="20040">traversal
    algorithm:</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20013">现在，我们</st> <st c="20022">实现 DFS</st> <st c="20040">遍历算法：</st>
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="20263">Let’s examine</st> <st c="20277">the code:</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20263">让我们来看一下</st> <st c="20277">代码：</st>
- en: <st c="20287">The graph is represented as an</st> <st c="20319">adjacency list</st>
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="20287">该图表示为一个</st> <st c="20319">邻接表</st>
- en: <st c="20333">We use a</st> **<st c="20343">visited</st>** <st c="20350">set
    to ensure that nodes are</st> <st c="20380">not revisited</st>
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="20333">我们使用一个</st> **<st c="20343">访问</st>** <st c="20350">集合来确保节点不被重复访问</st>
    <st c="20380">。</st>
- en: <st c="20393">The</st> **<st c="20398">dfs</st>** <st c="20401">function prints
    the current node, marks it as visited, and recursively calls itself on all</st>
    <st c="20493">unvisited neighbors</st>
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="20393">**<st c="20398">dfs</st>**</st> <st c="20401">函数打印当前节点，标记其为已访问，并递归地对所有</st>
    <st c="20493">未访问的邻居节点</st> <st c="20512">进行调用。</st>
- en: <st c="20512">For the given graph, the output will be</st> <st c="20553">as
    follows:</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20553">对于给定的图，输出将如下所示：</st>
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="20581">DFS is more memory efficient compared to BFS, particularly in
    deep graphs.</st> <st c="20657">This is because DFS only needs to keep track of
    the current path and backtracking information, while BFS must store all nodes
    at each level of the graph.</st> <st c="20811">DFS is also beneficial for pathfinding,
    especially in scenarios where all possible paths need to be explored, such as
    maze-solving algorithms.</st> <st c="20954">Additionally, DFS is</st> <st c="20975">frequently
    used for topological sorting in</st> **<st c="21018">directed acyclic graphs</st>**
    <st c="21041">(</st>**<st c="21043">DAGs</st>**<st c="21047">), a technique useful
    in scheduling tasks and</st> <st c="21094">resolving dependencies.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20581">与广度优先搜索（BFS）相比，深度优先搜索（DFS）在内存使用上更为高效，特别是在处理深度图时。</st> <st c="20657">这是因为DFS只需要跟踪当前路径和回溯信息，而BFS必须在每一层存储所有节点。</st>
    <st c="20811">DFS在路径寻找方面也非常有用，尤其是在需要探索所有可能路径的场景下，比如迷宫求解算法。</st> <st c="20954">此外，DFS</st>
    <st c="20975">经常用于拓扑排序</st> **<st c="21018">有向无环图</st>** <st c="21041">(</st>**<st
    c="21043">DAGs</st>**<st c="21047">)，这一技术在任务调度和</st> <st c="21094">解决依赖关系时非常有用。</st>
- en: <st c="21117">However, DFS has some</st> <st c="21140">limitations.</st> <st
    c="21153">One major drawback is that DFS may not find the shortest path in an
    unweighted graph, as it could explore a deep path before reaching the solution,
    which might not be optimal.</st> <st c="21329">Additionally, in very large or
    infinite graphs, DFS can get</st> <st c="21389">stuck exploring long paths or
    cycles unless precautions, such as cycle detection, are in place.</st> <st c="21485">In
    languages such as Python, which have a limit on recursion depth, using a recursive
    DFS can lead to stack overflow errors if the graph is particularly deep.</st>
    <st c="21644">To avoid this, DFS can be implemented iteratively using an explicit
    stack instead of relying</st> <st c="21737">on recursion.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21117">然而，DFS也有一些</st> <st c="21140">局限性。</st> <st c="21153">一个主要的缺点是，DFS在无权图中可能无法找到最短路径，因为它可能在找到解决方案之前就探索了一个较深的路径，而这条路径可能不是最优的。</st>
    <st c="21329">此外，在非常大或无限的图中，DFS可能会陷入探索长路径或循环的困境，除非采取如循环检测等预防措施。</st> <st c="21485">在诸如Python这样的语言中，递归深度有限，如果图特别深，使用递归的DFS可能会导致栈溢出错误。</st>
    <st c="21644">为了避免这种情况，可以通过使用显式栈来迭代实现DFS，而不依赖</st> <st c="21737">递归。</st>
- en: <st c="21750">The</st> <st c="21754">time complexity of DFS is</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1888.png)<st
    c="21781"><st c="21791">, where V.</st> <st c="21802">This is because DFS visits
    every node and every edge in the graph once.</st> <st c="21874">In a sparse graph
    where</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>E</mi><mo>≈</mo><mi>V</mi></mrow></mrow></math>](img/1889.png)<st
    c="21898"><st c="21900">, the time complexity is close to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1890.png)<st
    c="21934"><st c="21935">. On the other side, in a dense graph where</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi><mml:mo>≈</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/1891.png)<st
    c="21979"><st c="21980">, the time complexity</st> <st c="22002">approaches</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1860.png)<st
    c="22013"><st c="22014">.</st></st></st></st></st></st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21750">DFS的</st> <st c="21754">时间复杂度是</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1888.png)<st
    c="21781"><st c="21791">，其中 V。</st> <st c="21802">这是因为 DFS 会访问图中的每个节点和每条边一次。</st>
    <st c="21874">在一个稀疏图中，其中</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>E</mi><mo>≈</mo><mi>V</mi></mrow></mrow></math>](img/1889.png)<st
    c="21898"><st c="21900">，时间复杂度接近</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1890.png)<st
    c="21934"><st c="21935">。另一方面，在一个稠密图中，其中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi><mml:mo>≈</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/1891.png)<st
    c="21979"><st c="21980">，时间复杂度</st> <st c="22002">接近</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1860.png)<st
    c="22013"><st c="22014">。</st></st></st></st></st></st>
- en: <st c="22015">The space complexity</st> <st c="22037">of DFS is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1880.png)
    <st c="22047"><st c="22050">in the worst case due to the depth of the recursion
    stack or the explicit stack used in the iterative version.</st> <st c="22161">In
    a worst-case scenario, where the graph is a long linear chain, the stack could
    hold all</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/1722.png)
    <st c="22252"><st c="22253">nodes.</st></st></st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22015">DFS的空间复杂度</st> <st c="22037">是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1880.png)
    <st c="22047"><st c="22050">在最坏的情况下，由于递归栈的深度或迭代版本中使用的显式栈。</st> <st c="22161">在最坏的情况下，如果图是一个长的线性链，栈可能会保存所有</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/1722.png)
    <st c="22252"><st c="22253">节点。</st></st></st>
- en: '<st c="22259">There are two</st> <st c="22274">common variants of DFS:</st>
    **<st c="22298">pre-order DFS</st>**<st c="22311">, which visits a node before
    exploring its neighbors (as seen in the earlier example), and</st> **<st c="22402">post-order
    DFS</st>**<st c="22416">, which visits a node only after visiting all its neighbors.</st>
    <st c="22477">In the</st> <st c="22484">same graph (</st>*<st c="22496">Figure
    13</st>**<st c="22506">.5</st>*<st c="22508">), if we perform a post-order DFS,
    the traversal will result in the following order: D --> F --> E --> B --> C -->
    A.</st> <st c="22627">These variants are useful in different scenarios, such as
    tree traversal and algorithms that require specific orderings of</st> <st c="22750">node
    processing.</st>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22259">DFS有两种常见的变种：</st> **<st c="22298">先序DFS</st>**<st c="22311">，即在探索邻居之前先访问节点（如前面的示例所示），以及</st>
    **<st c="22402">后序DFS</st>**<st c="22416">，即只在访问完所有邻居后才访问节点。</st> <st c="22477">在</st>
    <st c="22484">同一图中（</st>*<st c="22496">图13</st>**<st c="22506">.5</st>*<st c="22508">），如果我们执行后序DFS，遍历的顺序将是：D
    --> F --> E --> B --> C --> A。</st> <st c="22627">这些变种在不同的场景中很有用，比如树的遍历和需要特定顺序处理节点的算法。</st>
- en: <st c="22766">DFS has numerous applications in algorithm design, including its
    use in AI search algorithms.</st> <st c="22861">For instance, DFS is employed
    in problems that require exploring all possible paths between nodes, such as solving
    puzzles or finding paths through mazes.</st> <st c="23016">It is also highly effective
    for cycle detection in both directed and undirected graphs, helping to identify
    loops within</st> <st c="23136">the graph structure.</st> <st c="23158">Additionally,
    DFS can be used to find all connected components in a graph, particularly in undirected
    graphs.</st> <st c="23268">In DAGs, DFS plays a crucial role in topological sorting,
    which is essential for tasks such as scheduling and dependency resolution.</st>
    <st c="23401">These diverse applications highlight the importance of DFS in various</st>
    <st c="23471">computational problems.</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22766">DFS在算法设计中有很多应用，包括在AI搜索算法中的使用。</st> <st c="22861">例如，DFS用于需要探索节点之间所有可能路径的问题，如解决谜题或在迷宫中寻找路径。</st>
    <st c="23016">它对于检测有向图和无向图中的环路非常有效，帮助识别图结构中的循环。</st> <st c="23136">此外，DFS还可以用于查找图中的所有连通分量，特别是在无向图中。</st>
    <st c="23158">在有向无环图（DAG）中，DFS在拓扑排序中起着关键作用，这对于调度和依赖解析等任务至关重要。</st> <st c="23401">这些多样化的应用突显了DFS在各种</st>
    <st c="23471">计算问题中的重要性。</st>
- en: <st c="23494">In summary, DFS is a powerful and efficient graph traversal technique,
    especially useful for pathfinding and solving problems that require exploring
    all possibilities.</st> <st c="23663">Although it doesn’t guarantee</st> <st c="23693">the
    shortest path, it excels in scenarios where memory efficiency is critical or when
    dealing with deep structures.</st> <st c="23809">The key trade-offs include potentially
    long search times for large graphs and the risk of stack overflow in deep recursion.</st>
    <st c="23933">In the next section, we will explore the BFS</st> <st c="23978">traversal
    approach.</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23494">总之，DFS是一种强大且高效的图遍历技术，特别适用于路径寻找和解决需要探索所有可能性的问题。</st> <st c="23663">尽管它不能保证找到最短路径，但在内存效率至关重要或处理深度结构时，它表现得非常出色。</st>
    <st c="23693">其主要的权衡是，对于大型图可能需要较长的搜索时间，并且在深度递归时可能会发生栈溢出。</st> <st c="23809">在下一节中，我们将探讨广度优先搜索（BFS）</st>
    <st c="23978">遍历方法。</st>
- en: <st c="23997">BFS graph traversal</st>
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="23997">广度优先搜索（BFS）图遍历</st>
- en: '**<st c="24017">BFS</st>** <st c="24021">is another</st> <st c="24032">graph
    traversal algorithm that explores nodes</st> <st c="24079">level by level, starting
    from a given source node.</st> <st c="24130">Unlike DFS, which goes as deep as
    possible into one branch before backtracking, BFS explores all neighbors of a
    node before moving on to the next level of neighbors.</st> <st c="24296">This
    makes BFS particularly effective for finding the shortest path in</st> <st c="24367">unweighted
    graphs.</st>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="24017">广度优先搜索（BFS）</st>** <st c="24021">是另一种</st> <st c="24032">图遍历算法，它从给定的源节点开始，逐层探索节点。</st>
    <st c="24079">与深度优先搜索（DFS）不同，DFS会尽可能深入一个分支，直到回溯，而BFS会先探索一个节点的所有邻居，然后再移动到下一级的邻居。</st>
    <st c="24296">这使得BFS在寻找</st> <st c="24367">无权图中的最短路径时特别有效。</st>'
- en: <st c="24385">The BFS algorithm starts at the root (or any arbitrary starting
    node) and explores all its neighbors first.</st> <st c="24494">After visiting
    all neighbors at the current level, it proceeds to the next level, visiting the
    neighbors of those neighbors, and so on.</st> <st c="24630">The traversal continues
    until all nodes reachable from the starting node have</st> <st c="24708">been
    visited.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24385">BFS算法从根节点（或任意起始节点）开始，首先探索所有邻居节点。</st> <st c="24494">在访问完当前层级的所有邻居后，算法会继续到下一层，访问那些邻居的邻居，以此类推。</st>
    <st c="24630">遍历会持续进行，直到所有从起始节点可达的节点都被访问过。</st>
- en: <st c="24721">The core of BFS relies on using a queue data structure, which
    ensures that nodes are explored in the correct order (</st>**<st c="24838">first-in
    first-out</st>** <st c="24857">(</st>**<st c="24859">FIFO</st>**<st c="24863">)).</st>
    <st c="24868">Let’s consider the graph in</st> *<st c="24896">Figure 13</st>**<st
    c="24905">.6</st>* <st c="24907">with six nodes.</st> <st c="24924">Starting the
    BFS at</st> *<st c="24944">node A</st>*<st c="24950">, the traversal order would
    be A --> B --> C -->D --> E --> F --> C.</st> <st c="25019">This traversal explores
    one path (branch) completely before moving on to</st> <st c="25092">the next.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24721">BFS的核心依赖于使用队列数据结构，这确保了节点按照正确的顺序被探索（</st>**<st c="24838">先进先出</st>**
    <st c="24857">(</st>**<st c="24859">FIFO</st>**<st c="24863">））。</st> <st c="24868">让我们考虑</st>
    *<st c="24896">图13</st>**<st c="24905">.6</st>* <st c="24907">中包含六个节点的图。</st>
    <st c="24924">从</st> *<st c="24944">节点A</st>*<st c="24950">开始BFS，遍历顺序将是 A -->
    B --> C --> D --> E --> F --> C。</st> <st c="25019">这种遍历方式会先完全探索一条路径（分支），然后再移动到下一条。</st>
- en: '![Figure 13.6: An example graph for BFS traversal](img/B22248_13_6.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6：BFS遍历示例图](img/B22248_13_6.jpg)'
- en: '<st c="25103">Figure 13.6: An example graph for BFS traversal</st>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25103">图13.6：BFS遍历示例图</st>
- en: <st c="25150">Here is a</st> <st c="25161">Python</st> <st c="25167">implementation
    of BFS using</st> <st c="25196">a queue:</st>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25150">这是一个</st> <st c="25161">Python</st> <st c="25167">实现BFS的代码，使用了</st>
    <st c="25196">队列：</st>
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="25752">This is</st> <st c="25761">how</st> <st c="25764">the code works.</st>
    <st c="25781">First, we represent the graph using an adjacency list.</st> <st
    c="25836">Next, we implement the queue data structure, which is essential for
    the BFS algorithm.</st> <st c="25923">Finally, we implement the BFS traversal</st>
    <st c="25963">algorithm itself:</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25752">这就是</st> <st c="25761">代码的工作原理。</st> <st c="25781">首先，我们使用邻接表表示图。</st>
    <st c="25836">接下来，我们实现队列数据结构，这是BFS算法的核心。</st> <st c="25923">最后，我们实现BFS遍历</st>
    <st c="25963">算法本身：</st>
- en: '**<st c="25980">Graph representation</st>**<st c="26001">: The graph is represented
    as an</st> <st c="26035">adjacency list</st>'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="25980">图的表示</st>**<st c="26001">：图使用</st> <st c="26035">邻接表</st> <st
    c="26049">来表示。</st>'
- en: '**<st c="26049">Queue</st>**<st c="26055">:</st> **<st c="26058">deque</st>**
    <st c="26063">is used to efficiently handle queue operations (enqueueing and</st>
    <st c="26127">dequeueing nodes)</st>'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="26049">队列</st>**<st c="26055">：</st> **<st c="26058">deque</st>**
    <st c="26063">用于高效地处理队列操作（入队和</st> <st c="26127">出队节点）</st>'
- en: '**<st c="26144">bfs</st>**<st c="26148">: Nodes are processed in the order
    they are dequeued, and their neighbors are added to the queue for</st> <st c="26250">further
    exploration</st>'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="26144">bfs</st>**<st c="26148">：节点按照出队顺序被处理，它们的邻居被加入队列以供</st> <st
    c="26250">进一步探索</st>'
- en: <st c="26269">For the given graph, the output will be</st> <st c="26310">as
    follows:</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26269">对于给定的图，输出将会是：</st> <st c="26310">如下所示：</st>
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="26338">BFS offers several advantages</st> <st c="26368">over DFS.</st>
    <st c="26379">In an unweighted graph, BFS guarantees that the first time a node
    is reached, it is via the shortest path from the source node, making it ideal
    for pathfinding problems.</st> <st c="26549">Additionally, BFS explores all nodes
    at the same level before moving on to the next level, which is particularly useful
    when all immediate neighbors need to be visited first, such as in finding the
    shortest route in transportation systems.</st> <st c="26789">Furthermore, BFS
    is highly effective in identifying all connected components in an undirected graph,
    as it systematically explores all</st> <st c="26924">reachable nodes.</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26338">BFS相对于DFS有几个优点</st> <st c="26368">。 </st> <st c="26379">在无权图中，BFS保证了第一次到达一个节点时，是通过从源节点出发的最短路径，这使得它在路径查找问题中非常理想。</st>
    <st c="26549">此外，BFS会在转向下一层之前，先探索当前层的所有节点，这在需要首先访问所有直接邻居的情况下尤为有用，例如在交通系统中寻找最短路径。</st>
    <st c="26789">另外，BFS在识别无向图中所有连通分量方面非常有效，因为它会系统地探索所有</st> <st c="26924">可达的节点。</st>
- en: <st c="26940">However, BFS</st> <st c="26953">has its drawbacks.</st> <st c="26973">It
    requires storing all nodes at the current level in memory, which can lead to significant
    memory consumption, particularly in graphs with large branching factors.</st>
    <st c="27138">Additionally, BFS can be inefficient for graphs with deep structures,
    as it explores level by level.</st> <st c="27239">In cases where the graph is
    deep but not very broad, DFS may be a more efficient alternative since it focuses
    on depth rather than breadth in</st> <st c="27381">its exploration.</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26940">然而，BFS</st> <st c="26953">也有其缺点。</st> <st c="26973">它需要将当前层的所有节点存储在内存中，这可能导致显著的内存消耗，尤其是在分支因子较大的图中。</st>
    <st c="27138">此外，BFS对于深层结构的图可能效率较低，因为它是逐层探索的。</st> <st c="27239">在图的深度较大而宽度不宽的情况下，DFS可能是一个更高效的替代方案，因为它在探索时更侧重深度而非广度。</st>
- en: <st c="27397">The time complexity of BFS is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1895.png)<st
    c="27428"><st c="27437">, as each vertex and edge is processed exactly once during
    the traversal.</st> <st c="27511">In contrast, the space complexity of BFS is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1896.png)<st
    c="27555"><st c="27560">, since in the worst case, all nodes at a particular level
    could be stored in the queue simultaneously.</st> <st c="27664">This becomes particularly
    significant in graphs with large branching factors or wide levels, where the memory
    requirements can</st> <st c="27791">grow substantially.</st></st></st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27397">BFS的时间复杂度是</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1895.png)<st
    c="27428"><st c="27437">，因为在遍历过程中每个顶点和边都只会被处理一次。</st> <st c="27511">相比之下，BFS的空间复杂度是</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1896.png)<st
    c="27555"><st c="27560">，因为在最坏的情况下，某一层的所有节点可能会同时被存储在队列中。</st> <st c="27664">在分支因子大或层宽较大的图中，这一点尤其重要，因为内存需求可能</st>
    <st c="27791">会大幅增加。</st></st></st>
- en: <st c="27810">BFS has two notable variants:</st> **<st c="27841">bidirectional
    BFS</st>** <st c="27858">and</st> **<st c="27863">multi-source BFS</st>**<st c="27879">.
    Bidirectional BFS is</st> <st c="27902">used to find the shortest path between
    two nodes.</st> <st c="27952">It runs two BFS traversals simultaneously – one
    from the source node and</st> <st c="28025">one from the destination node – until
    the two searches meet in the middle.</st> <st c="28100">This approach reduces
    the search space significantly, making it faster than a traditional BFS in scenarios
    where the source and destination are far apart.</st> <st c="28255">Multi-source
    BFS involves multiple starting points.</st> <st c="28307">BFS is initiated from
    all the source nodes at the same time, allowing exploration from multiple origins
    simultaneously.</st> <st c="28427">This variant is useful in scenarios where you
    need to explore paths from several locations, such as finding the shortest distance
    from multiple sources to a destination in</st> <st c="28599">a graph.</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27810">BFS有两个显著的变种：</st> **<st c="27841">双向BFS</st>** <st c="27858">和</st>
    **<st c="27863">多源BFS</st>**<st c="27879">。双向BFS用于</st> <st c="27902">找到两个节点之间的最短路径。</st>
    <st c="27952">它同时进行两个BFS遍历——一个从源节点开始，</st> <st c="28025">一个从目标节点开始——直到两次搜索在中间相遇。</st>
    <st c="28100">这种方法显著减少了搜索空间，使得在源节点和目标节点相距较远的情况下，比传统BFS更快。</st> <st c="28255">多源BFS涉及多个起始点。</st>
    <st c="28307">BFS从所有源节点同时启动，允许从多个起点同时进行探索。</st> <st c="28427">这种变种在需要从多个位置探索路径的场景中非常有用，例如在图中找到从多个源到目标的最短距离。</st>
- en: <st c="28607">BFS has a wide</st> <st c="28623">range of applications, including
    its use in AI search strategies.</st> <st c="28689">One of its key strengths is
    its ability to find the shortest path in unweighted graphs.</st> <st c="28777">Since
    BFS explores all nodes at the same level before moving deeper, it guarantees that
    the first time a node is reached, it is via the shortest possible path.</st> <st
    c="28937">This makes BFS ideal for pathfinding algorithms, such</st> <st c="28991">as
    navigation systems or solving puzzles where all moves have</st> <st c="29053">equal
    cost.</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28607">BFS有着广泛的</st> <st c="28623">应用范围，包括它在人工智能搜索策略中的使用。</st> <st c="28689">其一个关键优势是能够在无权图中找到最短路径。</st>
    <st c="28777">由于BFS会在深入之前先探索同一层级的所有节点，因此它可以保证节点首次被访问时，必定是通过最短路径。</st> <st c="28937">这使得BFS非常适合用于路径寻找算法，例如导航系统或解决所有动作成本相等的谜题。</st>
- en: <st c="29064">Let’s modify the BFS algorithm to find the shortest path between</st>
    <st c="29130">two nodes:</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29064">让我们修改BFS算法来找到</st> <st c="29130">两个节点之间的最短路径：</st>
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="29734">For the given graph, the</st> <st c="29760">shortest path between</st>
    `<st c="29782">A</st>` <st c="29783">and</st> `<st c="29788">F</st>` <st c="29789">is</st>
    <st c="29793">as follows:</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29734">对于给定的图，</st> <st c="29760">节点</st> `<st c="29782">A</st>` <st
    c="29783">和</st> `<st c="29788">F</st>` <st c="29789">之间的最短路径</st> <st c="29793">如下所示：</st>
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="29820">Another</st> <st c="29829">notable application of BFS is in undirected
    graphs.</st> <st c="29881">BFS is particularly useful for identifying all nodes
    that are reachable from a given starting point.</st> <st c="29982">By doing this,
    BFS can efficiently detect and label connected components, which is essential
    in network analysis and social</st> <st c="30106">network mapping.</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29820">另一个</st> <st c="29829">BFS的重要应用是在无向图中。</st> <st c="29881">BFS尤其适用于识别从给定起点可达的所有节点。</st>
    <st c="29982">通过这种方式，BFS可以高效地检测并标记连通分量，这在网络分析和社交</st> <st c="30106">网络映射中至关重要。</st>
- en: <st c="30122">Additionally, BFS is widely used for level-order traversal in
    trees.</st> <st c="30192">In this scenario, BFS visits all nodes at each depth
    level before progressing to the next, making it an ideal approach when the hierarchy
    or levels of the nodes matter, such as in organization charts, filesystem structures,
    or</st> <st c="30419">hierarchical clustering.</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30122">此外，BFS广泛用于树的层次遍历。</st> <st c="30192">在这种情况下，BFS会先访问每个深度级别的所有节点，然后才会继续到下一个深度层级，这使得它在节点的层级或等级很重要时成为理想的算法，例如在组织结构图、文件系统结构或</st>
    <st c="30419">层次聚类中。</st>
- en: <st c="30443">Beyond these core applications, BFS is widely used in AI search
    algorithms, alongside DFS, as two major search techniques.</st> <st c="30567">Additionally,
    BFS is employed in finding the minimum spanning tree and the shortest path in
    various</st> <st c="30667">graph-related problems:</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些核心应用，BFS还广泛应用于人工智能搜索算法中，与DFS一起成为两种主要的搜索技术。此外，BFS还被用于在各种图相关问题中寻找最小生成树和最短路径：
- en: '**<st c="30690">BFS in AI</st>**<st c="30700">: BFS serves as the foundation
    for many AI search strategies, particularly those that require exploration of
    all possible states level by level, such as in game trees or</st> <st c="30871">puzzle
    solving</st>'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BFS在人工智能中的应用**：BFS作为许多人工智能搜索策略的基础，特别是那些需要逐层探索所有可能状态的策略，如游戏树或**谜题求解**。'
- en: '**<st c="30885">Finding the minimum spanning tree</st>**<st c="30919">: In
    unweighted graphs, BFS can be used as a building block to find the minimum spanning
    tree by ensuring all nodes are visited in the shortest path order from</st> <st
    c="31080">the source</st>'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寻找最小生成树**：在无权图中，BFS可以作为构建块，用来通过确保所有节点按最短路径顺序从源节点访问来找到最小生成树。'
- en: '**<st c="31090">Network broadcast</st>**<st c="31108">: In computer networks,
    BFS is used to simulate broadcast routing, where information must be sent to all
    nodes in the shortest possible time, making it crucial for network discovery protocols
    such as</st> **<st c="31309">Open Shortest Path</st>** **<st c="31328">First</st>**
    <st c="31333">(</st>**<st c="31335">OSPF</st>**<st c="31339">)</st>'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络广播**：在计算机网络中，BFS用于模拟广播路由，在这种情况下，信息必须在最短时间内发送到所有节点，这使得它在网络发现协议中至关重要，如**开放最短路径优先**（**OSPF**）。'
- en: <st c="31341">These diverse</st> <st c="31355">applications highlight the versatility
    of BFS, making it a fundamental tool in algorithm design and practical implementations
    across</st> <st c="31488">various fields.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些多样化的应用突出展示了BFS的多功能性，使其成为算法设计和实践应用中的基本工具，广泛应用于各个领域。
- en: <st c="31503">In summary, BFS is an essential graph traversal technique, particularly
    useful when the goal is to explore all nodes level by level or to find the shortest
    path in unweighted graphs.</st> <st c="31687">While it is efficient in terms of
    time complexity, its higher memory requirements can be a drawback for graphs with
    large branching factors.</st> <st c="31828">BFS’s guaranteed shortest-path property
    and its versatility in various algorithmic tasks make it a powerful tool in many</st>
    <st c="31949">real-world applications.</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，BFS是一种基本的图遍历技术，特别适用于当目标是逐层探索所有节点或在无权图中寻找最短路径时。虽然它在时间复杂度上效率较高，但由于其较高的内存需求，对于具有较大分支因子的图而言，可能会成为一个缺点。BFS保证的最短路径特性以及其在各种算法任务中的多功能性使其成为许多现实世界应用中的强大工具。
- en: <st c="31973">Before moving</st> <st c="31988">on to the next non-linear data
    structure, let’s conclude our discussion on graphs by summarizing their significance
    and applications in algorithm design.</st> <st c="32142">Graphs are incredibly
    versatile structures that allow us to model and solve a wide range of problems
    in areas such as networking, social analysis, and AI.</st> <st c="32297">They
    can represent complex relationships between entities, and through various algorithms
    such as BFS and DFS, we can efficiently traverse, search, and process graph data.</st>
    <st c="32469">Graphs play a central role in critical applications such as pathfinding,
    network routing, cycle detection, and even</st> <st c="32585">hierarchical problem-solving.</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续讨论下一个非线性数据结构之前，让我们通过总结图的意义和在算法设计中的应用来结束对图的讨论。图是极其多功能的结构，它使我们能够在网络、社会分析和人工智能等领域建模和解决各种问题。图可以表示实体之间的复杂关系，通过BFS和DFS等算法，我们可以高效地遍历、搜索和处理图数据。图在路径寻找、网络路由、环检测甚至层级问题解决等关键应用中发挥着核心作用。
- en: <st c="32614">Their importance in algorithm design cannot be overstated, as
    they form the foundation for solving problems that involve connectivity, optimization,
    and search strategies in both theoretical and</st> <st c="32810">practical fields.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在算法设计中的重要性不言而喻，因为它们为解决涉及连通性、优化和搜索策略的问题奠定了基础，无论是在理论领域还是实践领域。
- en: <st c="32827">Trees</st>
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="32827">树</st>
- en: <st c="32833">A</st> **<st c="32836">tree</st>** <st c="32840">is a</st> <st
    c="32845">hierarchical, non-linear data structure that consists of nodes connected
    by edges.</st> <st c="32929">Trees are widely used in various applications, such
    as organizing data, databases, network structures, and more.</st> <st c="33042">A
    tree has a single root node and all other nodes are connected in a parent-child
    relationship.</st> <st c="33138">The tree structure ensures that there are no
    cycles, and each child has exactly</st> <st c="33218">one parent.</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32833">树</st> **<st c="32836">是一种</st>** <st c="32840">层次化的非线性数据结构，由节点和连接这些节点的边构成。</st>
    <st c="32929">树在各种应用中被广泛使用，如数据组织、数据库、网络结构等。</st> <st c="33042">树有一个根节点，所有其他节点都通过父子关系连接。</st>
    <st c="33138">树的结构确保没有循环，每个子节点恰好有</st> <st c="33218">一个父节点。</st>
- en: <st c="33229">In this section, we will explore different types of trees, their
    properties, and how to represent trees and</st> <st c="33338">discuss</st> <st
    c="33346">two important types:</st> **<st c="33367">binary search trees</st>**
    <st c="33386">(</st>**<st c="33388">BSTs</st>**<st c="33392">) and</st> **<st
    c="33399">red-black trees</st>**<st c="33414">.</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33229">在本节中，我们将探索不同类型的树及其特性，以及如何表示树和</st> <st c="33338">讨论</st> <st c="33346">两种重要类型：</st>
    **<st c="33367">二叉搜索树</st>** <st c="33386">(</st>**<st c="33388">BSTs</st>**<st
    c="33392">) 和</st> **<st c="33399">红黑树</st>**<st c="33414">。</st>
- en: <st c="33415">Different types of trees and their properties</st>
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="33415">不同类型的树及其特性</st>
- en: <st c="33461">Trees come in many types, each with unique characteristics suited
    for different applications.</st> <st c="33556">Here are some of the most</st>
    <st c="33582">common types:</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33461">树木有许多类型，每种类型都有适合不同应用的独特特性。</st> <st c="33556">以下是一些最</st> <st
    c="33582">常见的类型：</st>
- en: '**<st c="33595">General tree</st>**<st c="33608">: A</st> <st c="33613">general
    tree is a type of tree where any node can</st> <st c="33662">have an arbitrary
    number of children.</st> <st c="33701">This type of tree can be used to represent
    hierarchical data, such as filesystems or organization charts.</st> *<st c="33807">Figure
    13</st>**<st c="33816">.7</st>* <st c="33818">illustrates an example of a</st>
    <st c="33847">general tree.</st>'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="33595">通用树</st>**<st c="33608">：通用树是一种树，其中任何节点可以</st> <st c="33662">拥有任意数量的子节点。</st>
    <st c="33701">这种树类型可用于表示层次化数据，如文件系统或组织结构图。</st> *<st c="33807">图 13</st>**<st
    c="33816">.7</st>* <st c="33818">展示了一个通用树的示例。</st>'
- en: '![Figure 13.7: An example general tree](img/B22248_13_7.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7：一个通用树的示例](img/B22248_13_7.jpg)'
- en: '<st c="33862">Figure 13.7: An example general tree</st>'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33862">图 13.7：一个通用树的示例</st>
- en: '**<st c="33898">Binary tree</st>**<st c="33910">: A</st> <st c="33915">binary
    tree is a type of tree where each node has a</st> <st c="33966">maximum of</st>
    <st c="33978">two children, known as the</st> **<st c="34005">left child</st>**
    <st c="34015">and</st> <st c="34020">the</st> **<st c="34024">right child</st>**<st
    c="34035">. It is one of the most commonly used tree structures in computer science.</st>
    <st c="34110">In</st> *<st c="34113">Figure 13</st>**<st c="34122">.7</st>*<st
    c="34124">, all subtrees rooted at</st> *<st c="34149">nodes 1</st>*<st c="34156">,</st>
    *<st c="34158">5</st>*<st c="34159">, and</st> *<st c="34165">6</st>* <st c="34166">are
    examples of</st> <st c="34183">binary trees.</st>'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="33898">二叉树</st>**<st c="33910">：二叉树是一种每个节点最多有两个子节点的树，子节点分别称为</st>
    **<st c="34005">左子节点</st>** <st c="34015">和</st> **<st c="34024">右子节点</st>**<st
    c="34035">。它是计算机科学中最常用的树结构之一。</st> <st c="34110">在</st> *<st c="34113">图 13</st>**<st
    c="34122">.7</st>*<st c="34124">中，所有以</st> *<st c="34149">节点 1</st>*<st c="34156">、</st>
    *<st c="34158">节点 5</st>*<st c="34159">、</st> *<st c="34165">节点 6</st>* <st c="34166">为根的子树是二叉树的示例。</st>'
- en: '**<st c="34196">Full binary tree</st>**<st c="34213">: A</st> <st c="34218">binary
    tree is considered full if every node has either</st> <st c="34273">zero or two
    children.</st> <st c="34296">No nodes have only one child.</st> <st c="34326">In</st>
    *<st c="34329">Figure 13</st>**<st c="34338">.7</st>*<st c="34340">, the subtree
    rooted at</st> *<st c="34364">node 5</st>* <st c="34370">is a full</st> <st c="34381">binary
    tree.</st>'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="34196">完全二叉树</st>**<st c="34213">：如果每个节点有零个或两个子节点，则称为完全二叉树。</st> <st
    c="34218">没有节点只有一个子节点。</st> <st c="34273">在</st> *<st c="34329">图 13</st>**<st
    c="34338">.7</st>*<st c="34340">中，以</st> *<st c="34364">节点 5</st>* <st c="34370">为根的子树是一个完全</st>
    <st c="34381">二叉树。</st>'
- en: '**<st c="34393">Complete binary tree</st>**<st c="34414">: A</st> <st c="34418">complete
    binary tree is a</st> <st c="34445">binary tree where all levels are fully filled
    except possibly the last, which must be filled from left to right.</st> <st c="34558">A
    well-known complete binary tree is a heap structure, which will be discussed at
    the end of</st> <st c="34651">this chapter.</st>'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="34393">完全二叉树</st>**<st c="34414">：一个</st> <st c="34418">完全二叉树是一个</st>
    <st c="34445">所有层级都已完全填充，除非是最后一层，该层必须从左到右填充。</st> <st c="34558">一个著名的完全二叉树是堆结构，我们将在本章末尾讨论它。</st>
    <st c="34651">本章。</st>'
- en: '**<st c="34664">Balanced binary tree</st>**<st c="34685">: A</st> <st c="34689">tree
    is considered balanced if the</st> <st c="34725">heights of the left and right
    subtrees of any node differ by no more than one.</st> <st c="34804">Balanced trees
    are preferred because they ensure optimal performance for search, insertion, and
    deletion operations.</st> <st c="34921">In</st> *<st c="34924">Figure 13</st>**<st
    c="34933">.8</st>*<st c="34935">, the binary tree is</st> <st c="34956">fully
    balanced.</st>'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="34664">平衡二叉树</st>**<st c="34685">：如果</st> <st c="34689">任何节点的左右子树的高度差不超过一，则该树被认为是平衡的。</st>
    <st c="34725">平衡树更受欢迎，因为它们可以确保搜索、插入和删除操作的最佳性能。</st> <st c="34804">在</st> *<st
    c="34924">图 13</st>**<st c="34933">.8</st>*<st c="34935">中，二叉树是</st> <st c="34956">完全平衡的。</st>'
- en: '![Figure 13.8: A perfectly balanced binary tree](img/B22248_13_8.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8：一个完全平衡的二叉树](img/B22248_13_8.jpg)'
- en: '<st c="34973">Figure 13.8: A perfectly balanced binary tree</st>'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34973">图 13.8：一个完全平衡的二叉树</st>
- en: '*<st c="35018">Figure 13</st>**<st c="35028">.9</st>* <st c="35030">illustrates
    a counterexample of a non-balanced binary tree.</st> <st c="35091">In this tree,
    the height of the subtrees differs significantly, violating the balanced binary
    tree property, where the heights of the left and right subtrees of any node should
    differ by no more than one.</st> <st c="35296">This imbalance can lead to inefficient
    operations such as searching, insertion, and deletion, as the tree structure begins
    to resemble a</st> <st c="35433">linear chain.</st>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="35018">图 13</st>**<st c="35028">.9</st>* <st c="35030">展示了一个非平衡二叉树的反例。</st>
    <st c="35091">在这棵树中，子树的高度差异很大，违反了平衡二叉树的特性，即任何节点的左右子树高度差不应超过一。</st> <st c="35296">这种不平衡会导致搜索、插入和删除等操作效率低下，因为树的结构开始类似于</st>
    <st c="35433">线性链表。</st>'
- en: '![Figure 13.9: A counterexample of a non-balanced binary tree](img/B22248_13_9.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.9：一个非平衡二叉树的反例](img/B22248_13_9.jpg)'
- en: '<st c="35448">Figure 13.9: A counterexample of a non-balanced binary tree</st>'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35448">图 13.9：一个非平衡二叉树的反例</st>
- en: '**<st c="35507">AVL tree</st>**<st c="35516">: An</st> <st c="35521">AVL tree
    (named after inventors Adelson-Velsky and Landis) is a self-balancing binary search
    tree (BST).</st> <st c="35627">It</st> <st c="35630">maintains a balance factor
    (the difference between the heights of the left and right subtrees) for every
    node, ensuring that the tree remains balanced after insertions</st> <st c="35798">and
    deletions.</st>'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="35507">AVL树</st>**<st c="35516">：一种</st> <st c="35521">AVL树（以发明者Adelson-Velsky和Landis命名）是一种自平衡的二叉查找树（BST）。</st>
    <st c="35627">它</st> <st c="35630">为每个节点维护一个平衡因子（即左右子树高度的差值），确保在插入</st> <st c="35798">和删除操作后，树保持平衡。</st>'
- en: '**<st c="35812">B-tree</st>**<st c="35819">: A B-tree</st> <st c="35830">is
    a self-balancing tree data structure that maintains</st> <st c="35885">sorted
    data and allows searches, sequential access, insertions, and deletions in logarithmic
    time.</st> <st c="35985">B-trees are commonly used in databases</st> <st c="36024">and
    filesystems.</st>'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="35812">B树</st>**<st c="35819">：B树</st> <st c="35830">是一种自平衡的树形数据结构，用于维护</st>
    <st c="35885">排序的数据，并允许在对数时间内进行搜索、顺序访问、插入和删除操作。</st> <st c="35985">B树通常用于数据库</st>
    <st c="36024">和文件系统中。</st>'
- en: '**<st c="36040">Red-black tree</st>**<st c="36055">: A</st> <st c="36060">red-black
    tree is another type of self-balancing BST.</st> <st c="36114">Each</st> <st c="36119">node
    in the tree is assigned a color (red or black) to ensure that the tree remains
    balanced, which guarantees better worst-case time complexity for insertions</st>
    <st c="36279">and deletions.</st>'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="36040">红黑树</st>**<st c="36055">：一种</st> <st c="36060">红黑树是另一种类型的自平衡二叉查找树。</st>
    <st c="36114">树中的每个节点都会被分配一个颜色（红色或黑色），以确保树保持平衡，这样可以保证插入</st> <st c="36279">和删除操作的最坏时间复杂度更好。</st>'
- en: <st c="36293">Next, we will discuss two common tree representation methods:</st>
    **<st c="36356">linked representation</st>** <st c="36377">and</st> **<st c="36382">array
    representation</st>**<st c="36402">. Each method offers different advantages and
    is suited for specific types of operations and tree structures.</st> <st c="36512">By
    understanding both, we can choose the most efficient representation for a</st>
    <st c="36589">given application.</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36293">接下来，我们将讨论两种常见的树表示方法：</st> **<st c="36356">链式表示法</st>** <st c="36377">和</st>
    **<st c="36382">数组表示法</st>**<st c="36402">。每种方法都有不同的优点，适用于特定类型的操作和树结构。</st> <st
    c="36512">通过了解这两种方法，我们可以为特定应用选择最有效的表示法。</st>
- en: <st c="36607">Tree representation</st>
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="36607">树的表示法</st>
- en: <st c="36627">Trees can be</st> <st c="36640">represented in several ways, each
    depending on the use case and complexity of the operations.</st> <st c="36735">Let’s
    explore this</st> <st c="36754">in detail.</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36627">树可以</st> <st c="36640">以多种方式表示，具体选择取决于使用场景和操作的复杂度。</st> <st c="36735">接下来我们将详细探讨这一点。</st>
- en: <st c="36764">Linked representation</st>
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="36764">链式表示法</st>
- en: <st c="36786">In the</st> <st c="36794">linked representation of a binary tree,
    each node contains data and pointers (or references) to its left and right children.</st>
    <st c="36919">This is a more flexible representation than the array representation,
    as it doesn’t require the tree to be a complete binary tree.</st> <st c="37050">Instead,
    each node directly references its children, allowing for</st> <st c="37116">irregular
    structures.</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36786">在</st> <st c="36794">二叉树的链式表示法中，每个节点包含数据和指向其左子节点和右子节点的指针（或引用）。</st>
    <st c="36919">与数组表示法相比，这种表示法更灵活，因为它不要求树必须是完全二叉树。</st> <st c="37050">相反，每个节点直接引用其子节点，从而允许</st>
    <st c="37116">不规则结构的存在。</st>
- en: <st c="37137">This</st> <st c="37143">representation is commonly used for binary
    trees and BST, where the nodes can have arbitrary arrangements.</st> <st c="37250">Each
    node in the tree is defined as a class or structure that holds a value and two
    pointers to its left and right</st> <st c="37365">child nodes.</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37137">这种</st> <st c="37143">表示法通常用于二叉树和二叉搜索树（BST），其中节点可以有任意的排列。</st>
    <st c="37250">树中的每个节点被定义为一个类或结构体，包含一个值和指向其左子节点和右子节点的两个指针。</st> <st c="37365">子节点。</st>
- en: <st c="37377">The following code is an implementation of a node in Python using
    the</st> <st c="37448">linked representation:</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37377">以下代码是一个使用</st> <st c="37448">链式表示法在Python中实现节点的示例：</st>
- en: '[PRE8]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="38405">Let’s</st> <st c="38411">explain</st> <st c="38420">the many components
    of</st> <st c="38443">the code:</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38405">接下来</st> <st c="38411">我们来解释一下</st> <st c="38420">代码的各个组件：</st>
- en: '**<st c="38452">TreeNode</st>**<st c="38461">: Each node contains a value (</st>**<st
    c="38492">key</st>**<st c="38496">) and two pointers (</st>**<st c="38517">left</st>**
    <st c="38522">and</st> **<st c="38527">right</st>**<st c="38532">), which reference
    the left and right</st> <st c="38571">children, respectively</st>'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="38452">TreeNode</st>**<st c="38461">：每个节点包含一个值（</st>**<st c="38492">key</st>**<st
    c="38496">）和两个指针（</st>**<st c="38517">left</st>** <st c="38522">和</st> **<st c="38527">right</st>**<st
    c="38532">），分别引用左子节点和右子节点。</st>'
- en: '**<st c="38593">Creating nodes</st>**<st c="38608">: We create nodes and link
    them to form the structure of a</st> <st c="38668">binary tree</st>'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="38593">创建节点</st>**<st c="38608">：我们创建节点并将它们链接在一起，形成一个</st> <st c="38668">二叉树</st>。'
- en: '**<st c="38679">In-order traversal</st>**<st c="38698">: The</st> **<st c="38705">inorder_traversal</st>**
    <st c="38722">function recursively visits the left subtree, the root, and then
    the right subtree, printing the nodes in a sorted order for</st> <st c="38848">a
    BST</st>'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="38679">中序遍历</st>**<st c="38698">：**<st c="38705">inorder_traversal</st>**
    <st c="38722">函数递归地访问左子树、根节点，然后是右子树，对于</st> <st c="38848">二叉搜索树（BST）</st> <st
    c="38848">以排序顺序打印节点。</st>'
- en: <st c="38853">The linked representation works for any type of binary tree, whether
    it is complete, balanced, or irregular.</st> <st c="38963">This approach is especially
    memory efficient for sparse trees, as memory is only</st> <st c="39044">allocated
    for the nodes that are actually present.</st> <st c="39095">This eliminates the
    need for continuous memory allocation for non-existent nodes, unlike</st> <st
    c="39184">array representation.</st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38853">链式表示法适用于任何类型的二叉树，无论是完全二叉树、平衡二叉树还是不规则二叉树。</st> <st c="38963">对于稀疏树，这种方法特别节省内存，因为只有实际存在的节点才会分配内存。</st>
    <st c="39044">这样就不需要为不存在的节点连续分配内存，这与</st> <st c="39184">数组表示法</st> <st c="39184">不同。</st>
- en: <st c="39205">Additionally, the</st> <st c="39223">linked representation is
    more flexible for dynamic operations such as insertion, deletion, and traversal.</st>
    <st c="39330">Since each node directly references its children, modifying the
    tree structure is straightforward and doesn’t require reordering or shifting elements,
    as would be needed in an array-based representation.</st> <st c="39534">This makes
    it ideal for trees that grow or change frequently, such as</st> <st c="39604">in
    BSTs.</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39205">此外，</st> <st c="39223">链式表示法对于动态操作，如插入、删除和遍历，更加灵活。</st> <st c="39330">由于每个节点直接引用其子节点，修改树结构非常直接，不需要像数组表示中那样重新排序或移动元素。</st>
    <st c="39534">这使得它非常适用于频繁增长或变化的树，例如</st> <st c="39604">在二叉搜索树（BST）中。</st>
- en: <st c="39612">Array representation</st>
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="39612">数组表示</st>
- en: <st c="39633">This</st> <st c="39639">method is commonly used for representing</st>
    <st c="39680">complete binary trees, such as heap structures.</st> <st c="39728">In
    this approach, a binary tree is stored as an array or list, where the root node
    is located at index</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>0</mml:mn></mml:math>](img/1897.png)<st
    c="39831"><st c="39832">. For any node at index</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="39856"><st c="39857">, its children are positioned</st> <st c="39887">as follows:</st></st></st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39633">这种</st> <st c="39639">方法常用于表示</st> <st c="39680">完全二叉树，例如堆结构。</st>
    <st c="39728">在这种方法中，二叉树作为数组或列表存储，其中根节点位于索引</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>0</mml:mn></mml:math>](img/1897.png)<st
    c="39831"><st c="39832">。对于索引</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="39856"><st c="39857">上的任何节点，其子节点的位置如下：</st> <st c="39887">。</st></st></st>
- en: <st c="39898">The left child is located at</st> <st c="39928">index</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mrow></math>](img/1899.png)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="39898">左子节点位于</st> <st c="39928">索引</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mrow></math>](img/1899.png)
- en: <st c="39935">The right child is located at</st> <st c="39965">index</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow></mrow></math>](img/1900.png)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="39935">右子节点位于</st> <st c="39965">索引</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow></mrow></math>](img/1900.png)
- en: <st c="39972">This array-based representation is highly efficient for complete
    binary trees because it avoids the need for pointers to track the parent-child
    relationships.</st> <st c="40131">It also allows for fast access to children or
    parents directly by calculating their indices.</st> <st c="40224">Here’s a simple
    Python example demonstrating the array representation of a small complete</st>
    <st c="40314">binary tree:</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39972">这种基于数组的表示对于完全二叉树非常高效，因为它避免了需要指针来追踪父子关系。</st> <st c="40131">它还允许通过计算索引快速访问子节点或父节点。</st>
    <st c="40224">以下是一个简单的 Python 示例，演示了一个小的完全</st> <st c="40314">二叉树的数组表示：</st>
- en: '[PRE9]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="40715">This</st> <st c="40720">array-based structure is ideal for heaps,
    where</st> <st c="40768">insertion and deletion operations require efficient reordering
    to maintain the heap property.</st> <st c="40863">The simplicity of the index-based
    parent-child relationships makes this representation fast and memory-efficient
    for complete</st> <st c="40989">binary trees.</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40715">这种</st> <st c="40720">基于数组的结构非常适合堆，其中</st> <st c="40768">插入和删除操作需要高效的重新排序以保持堆属性。</st>
    <st c="40863">基于索引的父子关系的简洁性使得这种表示方法在完全</st> <st c="40989">二叉树</st>中既快速又节省内存。</st>
- en: <st c="41002">Parent array representation</st>
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="41002">父数组表示</st>
- en: <st c="41030">Another</st> <st c="41039">way</st> <st c="41043">to represent
    a tree is by storing the parent of each node in an array.</st> <st c="41114">In
    this approach, each index of the array corresponds to a node, and the value at
    that index represents the parent of that node.</st> <st c="41243">The root node
    is assigned a special value (commonly</st> `<st c="41295">-1</st>`<st c="41297">)
    to indicate that it has</st> <st c="41324">no parent.</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41030">另一种</st> <st c="41039">表示树的方法是通过将每个节点的父节点存储在一个数组中。</st> <st c="41114">在这种方法中，数组的每个索引对应一个节点，索引处的值表示该节点的父节点。</st>
    <st c="41243">根节点被赋予一个特殊的值（通常是</st> `<st c="41295">-1</st>`<st c="41297">），以表示它没有父节点。</st>
- en: <st c="41334">This representation is particularly useful when we need to reconstruct
    the tree from parent-child relationships or when the tree is stored in such a
    way that direct access to child nodes is</st> <st c="41525">not necessary.</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41334">这种表示法在我们需要从父子关系重建树时特别有用，或者当树以某种方式存储，使得不需要直接访问子节点时</st> <st c="41525">尤其适用。</st>
- en: <st c="41539">Here is a simple Python implementation for representing a tree
    using a parent array.</st> <st c="41625">The first part is a function to build
    the tree from a</st> <st c="41679">parent array:</st>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41539">这里是一个简单的 Python 实现，用于通过父节点数组表示树。</st> <st c="41625">第一部分是一个根据父节点数组构建树的函数：</st>
- en: '[PRE10]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="42114">Next, we</st> <st c="42123">define</st> <st c="42130">the</st>
    `<st c="42135">TreeNode</st>` <st c="42143">class:</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42114">接下来，我们</st> <st c="42123">定义</st> <st c="42130">`TreeNode`</st>
    <st c="42143">类：</st>
- en: '[PRE11]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="42241">Finally, we build an example parent array, where</st> `<st c="42291">-1</st>`
    <st c="42293">represents</st> <st c="42305">the root:</st>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42241">最后，我们构建一个示例父节点数组，其中</st> `<st c="42291">-1</st>` <st c="42293">表示根节点：</st>
- en: '[PRE12]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="42687">Let’s</st> <st c="42694">explain the many components</st> <st
    c="42721">of</st> <st c="42725">the code:</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42687">让我们</st> <st c="42694">解释一下代码的各个组成部分：</st>
- en: '**<st c="42734">Parent array</st>**<st c="42747">: The array represents the
    parent of each node.</st> <st c="42796">For example, if</st> **<st c="42812">parent_array[3]
    = 1</st>**<st c="42831">, it means</st> *<st c="42842">node 3</st>* <st c="42848">has</st>
    *<st c="42853">node 1</st>* <st c="42859">as its parent.</st> <st c="42875">The
    root node has the value</st> **<st c="42903">-1</st>**<st c="42905">, indicating
    it has</st> <st c="42925">no parent.</st>'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="42734">父节点数组</st>**<st c="42747">：该数组表示每个节点的父节点。</st> <st c="42796">例如，如果</st>
    **<st c="42812">parent_array[3] = 1</st>**<st c="42831">，则意味着</st> *<st c="42842">节点
    3</st>* <st c="42848">的父节点是</st> *<st c="42853">节点 1</st>* <st c="42859">。根节点的值为</st>
    **<st c="42903">-1</st>**<st c="42905">，表示它没有父节点。</st>'
- en: '**<st c="42935">build_tree</st>**<st c="42946">: We first create an array of
    nodes and then link each node to its parent using the parent array.</st> <st c="43045">The
    nodes are connected either as the left or right child, depending</st> <st c="43114">on
    availability.</st>'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="42935">构建树</st>**<st c="42946">：我们首先创建一个节点数组，然后通过父节点数组将每个节点链接到它的父节点。</st>
    <st c="43045">这些节点根据可用性，作为左子节点或右子节点相连接。</st>'
- en: '**<st c="43130">inorder_traversal</st>**<st c="43148">: We perform an in-order
    traversal of the tree to visit the nodes in their</st> <st c="43224">sorted order.</st>'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="43130">中序遍历</st>**<st c="43148">：我们进行树的中序遍历，以按照它们的</st> <st c="43224">排序顺序访问节点。</st>'
- en: <st c="43237">The parent array representation offers several advantages.</st>
    <st c="43297">One significant benefit is its space efficiency.</st> <st c="43346">Since
    this method only stores the parent-child relationships, it eliminates the need
    for additional pointers to left and right children, making it a compact structure.</st>
    <st c="43514">This feature makes it particularly suitable for environments where
    memory</st> <st c="43588">is limited.</st>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43237">父节点数组表示法有几个优点。</st> <st c="43297">其中一个显著的好处是它的空间效率。</st> <st c="43346">由于这种方法仅存储父子关系，它省去了额外指向左子节点和右子节点的指针，从而使其成为一种紧凑的结构。</st>
    <st c="43514">这一特点使得它特别适用于内存</st> <st c="43588">有限的环境。</st>
- en: <st c="43599">Another advantage is its usefulness in reconstructing a tree from
    given parent-child relationships, such as those found in filesystems, organization
    charts, or other hierarchical structures.</st> <st c="43791">This method allows
    for easy and efficient</st> <st c="43833">tree reconstruction.</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43599">另一个优点是它在从给定的父子关系中重建树时非常有用，比如在文件系统、组织结构图或其他层次结构中。</st> <st c="43791">这种方法使得树的重建变得简单而高效。</st>
- en: <st c="43853">Additionally, it is</st> <st c="43873">efficient in applications
    where direct access to parent nodes is required.</st> <st c="43949">Since each
    index in the array corresponds to a specific node and stores its parent, retrieving
    the parent of any node can be done in</st> <st c="44082">constant time.</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43853">此外，在需要直接访问父节点的应用中，它也非常高效。</st> <st c="43873">由于数组中的每个索引都对应一个特定的节点并存储其父节点，检索任何节点的父节点可以在</st>
    <st c="44082">常数时间内完成。</st>
- en: <st c="44096">Lastly, the</st> <st c="44109">parent array representation is
    well suited for cases where trees are stored in external memory.</st> <st c="44205">It
    requires minimal data storage, which makes it particularly useful in databases
    or large-scale systems where the tree structure needs to be reconstructed on demand
    with</st><st c="44375">out taking up</st> <st c="44390">excessive space.</st>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44096">最后，</st> <st c="44109">父节点数组表示法非常适合存储在外部存储器中的树结构。</st> <st c="44205">它需要最小的数据存储空间，这使得它在数据库或大型系统中尤其有用，在这些系统中，树结构需要按需重建，而不占用过多空间。</st>
- en: <st c="44406">This representation is helpful when working with static tree structures,
    especially in cases where storing the parent relationships alone suffices for
    the</st> <st c="44562">intended operations.</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44406">这种表示方式在处理静态树结构时非常有用，尤其是在只需要存储父节点关系即可进行预期操作的情况下。</st>
- en: <st c="44582">BSTs</st>
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="44582">二叉搜索树</st>
- en: <st c="44587">A</st> **<st c="44590">BST</st>** <st c="44593">is a</st> <st
    c="44599">type of binary tree where the nodes are organized in a way that for
    every node, the left subtree contains only nodes with values less than the node,
    and the right subtree contains only nodes with values greater than the node.</st>
    <st c="44825">This property makes BSTs efficient for search operations.</st> *<st
    c="44883">Figure 13</st>**<st c="44892">.10</st>* <st c="44895">illustrates a
    simple BST.</st> <st c="44922">The following are</st> <st c="44939">the properties
    of</st> <st c="44958">a BST:</st>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="44587">A</st>** **<st c="44590">二叉搜索树（BST）</st>** <st c="44593">是一种二叉树，其中的节点按照特定方式组织：每个节点的左子树只包含值小于该节点的节点，而右子树只包含值大于该节点的节点。</st>
    <st c="44825">这一特性使得二叉搜索树在搜索操作中非常高效。</st> *<st c="44883">图13</st>**<st c="44892">.10</st>*
    <st c="44895">展示了一个简单的二叉搜索树。</st> <st c="44922">以下是</st> <st c="44939">二叉搜索树的</st>
    <st c="44958">一些属性：</st>'
- en: <st c="44964">The left child contains values less than the</st> <st c="45010">parent
    node</st>
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="44964">左子节点包含的值小于</st> <st c="45010">父节点的值</st>
- en: <st c="45021">The right child contains values greater than the</st> <st c="45071">parent
    node</st>
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="45021">右子节点包含的值大于</st> <st c="45071">父节点的值</st>
- en: <st c="45082">In-order traversal of a BST produces a</st> <st c="45122">sorted
    sequence</st>
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="45082">二叉搜索树的中序遍历会生成一个</st> <st c="45122">有序序列</st>
- en: "![Figur\uFEFFe 13.10: An example BST](img/B22248_13_10.jpg)"
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图13.10：一个示例二叉搜索树](img/B22248_13_10.jpg)'
- en: '<st c="45139">Figur</st><st c="45144">e 13.10: An example BST</st>'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45139">图13.10：一个示例二叉搜索树</st>
- en: '<st c="45168">Before exploring</st> <st c="45185">the operations of a BST,
    it is important to first understand how to traverse a BST.</st> <st c="45270">In
    a BST, similar to graphs, traversal refers to the process of visiting and processing
    each node in the tree.</st> <st c="45381">There are three common methods of traversal
    (or tree-walk): in-order, pre-order, and post-order.</st> <st c="45478">Each traversal
    method follows a specific order to visit the nodes, and all of them have the same
    time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)
    <st c="45594"><st c="45595">since each node is visited</st> <st c="45623">exactly
    once.</st></st>'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45168">在探讨二叉搜索树的操作之前，首先了解如何遍历二叉搜索树非常重要。</st> <st c="45185">在二叉搜索树中，遍历类似于图的遍历，指的是访问并处理树中每个节点的过程。</st>
    <st c="45270">二叉搜索树有三种常见的遍历方法（或树走访方式）：中序遍历、前序遍历和后序遍历。</st> <st c="45381">每种遍历方法都有特定的节点访问顺序，且它们的时间复杂度都是</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)
    <st c="45594"><st c="45595">因为每个节点只会被访问一次。</st> <st c="45623">。</st></st>
- en: <st c="45636">In-order traversal</st>
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="45636">中序遍历</st>
- en: '**<st c="45655">In-order traversal</st>** <st c="45674">visits</st> <st c="45681">the
    nodes in the following order: left subtree, root, right subtree.</st> <st c="45751">In
    a BST, an in-order traversal will visit the nodes in sorted order (ascending).</st>
    <st c="45833">The in-order traversal steps are</st> <st c="45866">as follows:</st>'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="45655">中序遍历</st>** <st c="45674">访问</st> <st c="45681">节点的顺序为：左子树，根节点，右子树。</st>
    <st c="45751">在二叉搜索树（BST）中，中序遍历将按升序访问节点。</st> <st c="45833">中序遍历的步骤如下：</st> <st
    c="45866">如下所示：</st>'
- en: <st c="45877">Traverse the</st> <st c="45891">left subtree.</st>
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="45877">遍历</st> <st c="45891">左子树。</st>
- en: <st c="45904">Visit the</st> <st c="45915">root node.</st>
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="45904">访问</st> <st c="45915">根节点。</st>
- en: <st c="45925">Traverse the</st> <st c="45939">right subtree.</st>
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="45925">遍历</st> <st c="45939">右子树。</st>
- en: <st c="45953">For the BST shown in</st> *<st c="45975">Figure 13</st>**<st c="45984">.11</st>*<st
    c="45987">, we aim to perform an in-order traversal of</st> <st c="46032">the
    tree.</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45953">对于图示的二叉搜索树（BST）</st> *<st c="45975">图 13</st>**<st c="45984">.11</st>*<st
    c="45987">，我们希望对树执行中序遍历。</st>
- en: '![Figure 13.11: An example BST](img/B22248_13_11.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.11：一个示例二叉搜索树（BST）](img/B22248_13_11.jpg)'
- en: '<st c="46043">Figure 13.11: An example BST</st>'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46043">图 13.11：一个示例二叉搜索树（BST）</st>
- en: <st c="46071">Here is the Python code for</st> <st c="46100">in-order traversal:</st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46071">以下是用于</st> <st c="46100">中序遍历的 Python 代码：</st>
- en: '[PRE13]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="46397">First, we build</st> <st c="46413">the BST using the following</st>
    <st c="46442">Python code:</st>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46397">首先，我们使用以下</st> <st c="46413">Python 代码构建</st> <st c="46442">二叉搜索树（BST）：</st>
- en: '[PRE14]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="46673">Then, we call</st> `<st c="46688">inorder_traversal</st>` <st
    c="46705">to perform in-order</st> <st c="46726">BST traversal:</st>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46673">然后，我们调用</st> `<st c="46688">inorder_traversal</st>` <st c="46705">来执行中序</st>
    <st c="46726">二叉搜索树（BST）遍历：</st>
- en: '[PRE15]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="46822">In-order traversal</st> <st c="46842">generates</st> <st c="46852">the
    following:</st>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46822">中序遍历</st> <st c="46842">生成</st> <st c="46852">如下：</st>
- en: '[PRE16]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="46886">Pre-order traversal</st>
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="46886">先序遍历</st>
- en: '**<st c="46906">Pre-order traversal</st>** <st c="46926">visits</st> <st c="46934">the
    nodes in the following order: root, left subtree, right subtree.</st> <st c="47003">This
    method is useful for creating a copy of the tree or for printing the tree structure.</st>
    <st c="47093">The pre-order traversal steps are</st> <st c="47127">as follows:</st>'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="46906">先序遍历</st>** <st c="46926">访问</st> <st c="46934">节点的顺序为：根节点，左子树，右子树。</st>
    <st c="47003">这种方法对于创建树的副本或打印树结构非常有用。</st> <st c="47093">先序遍历的步骤如下：</st> <st c="47127">如下所示：</st>'
- en: <st c="47138">Visit the</st> <st c="47149">root node.</st>
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47138">访问</st> <st c="47149">根节点。</st>
- en: <st c="47159">Traverse the</st> <st c="47173">left subtree.</st>
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47159">遍历</st> <st c="47173">左子树。</st>
- en: <st c="47186">Traverse the</st> <st c="47200">right subtree.</st>
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47186">遍历</st> <st c="47200">右子树。</st>
- en: <st c="47214">The pre-order traversal will visit the nodes in BST of</st> *<st
    c="47270">Figure 13</st>**<st c="47279">.11</st>* <st c="47282">in the following
    order:</st> `<st c="47307">20, 10, 5, 15, 30,</st>` `<st c="47326">25, 35</st>`<st
    c="47332">.</st>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47214">先序遍历将按照以下顺序访问二叉搜索树（BST）中的节点：</st> *<st c="47270">图 13</st>**<st
    c="47279">.11</st>* <st c="47282">中的顺序：</st> `<st c="47307">20, 10, 5, 15, 30,</st>`
    `<st c="47326">25, 35</st>`<st c="47332">。</st>
- en: <st c="47333">The following is the Python code for</st> <st c="47371">pre-order
    traversal:</st>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47333">以下是用于</st> <st c="47371">先序遍历的 Python 代码：</st>
- en: '[PRE17]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="47636">Post-order traversal</st>
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="47636">后序遍历</st>
- en: '**<st c="47657">Post-order traversal</st>** <st c="47678">visits</st> <st c="47685">the
    nodes in the following order: left subtree, right subtree, root.</st> <st c="47755">This
    traversal is often used in applications such as tree deletion, where you must
    delete the children before deleting the parent node.</st> <st c="47891">The post-order
    traversal steps are</st> <st c="47926">as follows:</st>'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="47657">后序遍历</st>** <st c="47678">访问</st> <st c="47685">节点的顺序为：左子树，右子树，根节点。</st>
    <st c="47755">这种遍历通常用于树的删除操作中，因为在删除父节点之前需要先删除子节点。</st> <st c="47891">后序遍历的步骤如下：</st>
    <st c="47926">如下所示：</st>'
- en: <st c="47937">Traverse the</st> <st c="47951">left subtree.</st>
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47937">遍历</st> <st c="47951">左子树。</st>
- en: <st c="47964">Traverse the</st> <st c="47978">right subtree.</st>
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47964">遍历</st> <st c="47978">右子树。</st>
- en: <st c="47992">Visit the</st> <st c="48003">root node.</st>
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47992">访问</st> <st c="48003">根节点。</st>
- en: <st c="48013">For the example in</st> *<st c="48033">Figure 13</st>**<st c="48042">.11</st>*<st
    c="48045">, the post-order traversal will visit the nodes in the following order:</st>
    `<st c="48117">5, 15, 10, 25, 35,</st>` `<st c="48136">30, 20</st>`<st c="48142">.</st>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48013">在</st> *<st c="48033">图 13</st>**<st c="48042">.11</st>*<st c="48045">中，后序遍历将按照以下顺序访问节点：</st>
    `<st c="48117">5, 15, 10, 25, 35,</st>` `<st c="48136">30, 20</st>`<st c="48142">。</st>
- en: <st c="48143">Here is the Python code for</st> <st c="48172">post-order traversal:</st>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48143">以下是</st> <st c="48172">后序遍历的 Python 代码：</st>
- en: '[PRE18]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="48445">In summary, in-order traversal visits nodes in the sorted order
    (left, root, right) and is commonly used for</st> <st c="48554">extracting sorted
    data from BSTs.</st> <st c="48589">Pre-order traversal visits nodes in the order
    (root, left, right), making it useful for copying the tree structure or printing
    it.</st> <st c="48720">Post-order traversal visits nodes in the order (left, right,
    root) and is helpful for tasks such as tree deletion, where processing the child
    before the parent</st> <st c="48880">is necessary.</st>
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48445">总之，先序遍历按顺序访问节点（左、根、右），通常用于</st> <st c="48554">从二叉搜索树中提取排序数据。</st>
    <st c="48589">先序遍历按顺序访问节点（根、左、右），适用于复制树结构或打印树。</st> <st c="48720">后序遍历按顺序访问节点（左、右、根），有助于像树删除这样的任务，其中需要先处理子节点再处理父节点。</st>
    <st c="48880">。</st>
- en: <st c="48893">In a BST, the main operations – insertion, deletion, and searching
    – rely on the tree structure and properties.</st> <st c="49006">The efficiency
    of these operations depends heavily on whether the tree is balanced or not.</st>
    <st c="49097">Let’s explore these operations</st> <st c="49128">in detail.</st>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48893">在二叉搜索树中，主要操作——插入、删除和搜索——依赖于树的结构和属性。</st> <st c="49006">这些操作的效率很大程度上取决于树是否平衡。</st>
    <st c="49097">接下来，让我们详细探讨这些操作。</st>
- en: <st c="49138">The search operation in a BST</st>
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="49138">二叉搜索树中的搜索操作</st>
- en: <st c="49168">Searching</st> <st c="49178">in a BST leverages the property that
    the left subtree contains values smaller than the current node and the right subtree
    contains values larger than the current node.</st> <st c="49347">This allows us
    to effectively halve the search space with each step, similar to</st> <st c="49427">binary
    search:</st>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49168">在二叉搜索树中搜索</st> <st c="49178">利用了左子树的值小于当前节点，右子树的值大于当前节点的特性。</st>
    <st c="49347">这使得我们可以在每一步有效地将搜索空间减半，类似于</st> <st c="49427">二分搜索：</st>
- en: '**<st c="49441">Average case (balanced tree)</st>**<st c="49470">: In a balanced
    BST (such as the one shown in</st> *<st c="49517">Figure 13</st>**<st c="49526">.6</st>*<st
    c="49528">), the search</st> <st c="49542">operation takes</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1246.png)
    <st c="49559"><st c="49568">time.</st> <st c="49574">This is because the tree
    height is logarithmic relative to the number of nodes, and we reduce the search
    space at</st> <st c="49688">each level.</st></st>'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="49441">平均情况（平衡树）</st>**<st c="49470">：在平衡的二叉搜索树（如</st> *<st c="49517">图
    13</st>**<st c="49526">.6</st>*<st c="49528">所示），搜索</st> <st c="49542">操作需要</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1246.png)
    <st c="49559"><st c="49568">时间。</st> <st c="49574">这是因为树的高度相对于节点数量是对数级别的，我们在</st>
    <st c="49688">每一层都缩小了搜索空间。</st></st>'
- en: '**<st c="49699">Worst case (unbalanced tree)</st>**<st c="49728">: If the BST
    is unbalanced, the search time complexity</st> <st c="49784">can approach</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1201.png)<st
    c="49797"><st c="49798">, where the tree starts resembling a linked list.</st>
    <st c="49848">In such cases, the tree height grows linearly with the number of
    nodes, making</st> <st c="49927">searches inefficient.</st></st>'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="49699">最坏情况（不平衡树）</st>**<st c="49728">：如果二叉搜索树（BST）不平衡，搜索的时间复杂度</st>
    <st c="49784">可能接近</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1201.png)<st
    c="49797"><st c="49798">，此时树形结构类似于链表。</st> <st c="49848">在这种情况下，树的高度会随着节点数量的增加而线性增长，导致</st>
    <st c="49927">搜索效率低下。</st></st>'
- en: <st c="49948">For extreme cases, such as the skewed tree in</st> *<st c="49995">Figure
    13</st>**<st c="50004">.12</st>*<st c="50007">, the search complexity reaches</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1904.png)<st
    c="50039"><st c="50040">, where every node has only one child, and the tree degenerates
    into a</st> <st c="50111">linear structure.</st></st>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49948">对于极端情况，如</st> *<st c="49995">图 13</st>**<st c="50004">.12</st>*<st
    c="50007">中偏斜的树，搜索复杂度达到</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1904.png)<st
    c="50039"><st c="50040">，在这种情况下，每个节点只有一个子节点，树退化成一个</st> <st c="50111">线性结构。</st></st>
- en: '![Figure 13.12: An example of extreme unbalanced BST](img/B22248_13_12.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.12：极端不平衡二叉搜索树的示例](img/B22248_13_12.jpg)'
- en: '<st c="50130">Figure 13.12: An example of extreme unbalanced BST</st>'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50130">图 13.12：极端不平衡二叉搜索树的示例</st>
- en: <st c="50180">The following</st> <st c="50194">is a Python implementation of
    searching in a BST.</st> <st c="50245">The first part is the definition of a</st>
    `<st c="50283">TreeNode</st>` <st c="50291">class for</st> <st c="50302">the BST:</st>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50180">以下是一个在BST中搜索的Python实现。</st> <st c="50194">第一部分是对BST中</st> `<st
    c="50283">TreeNode</st>` <st c="50291">类的定义：</st>
- en: '[PRE19]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="50401">To build the BST, we implement the insertion operation using the</st>
    `<st c="50467">insert</st>` <st c="50473">function</st> <st c="50483">as follows:</st>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50401">为了构建二叉搜索树（BST），我们使用</st> `<st c="50467">insert</st>` <st c="50473">函数实现插入操作</st>
    <st c="50483">，代码如下：</st>
- en: '[PRE20]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="50776">The</st> `<st c="50781">search</st>` <st c="50787">operation</st>
    <st c="50797">is implemented</st> <st c="50813">as follows:</st>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50776">以下是</st> `<st c="50781">search</st>` <st c="50787">操作的实现代码：</st>
- en: '[PRE21]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="51208">Let’s create the root node and insert elements into</st> <st c="51261">the
    BST:</st>
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51208">让我们创建根节点并将元素插入</st> <st c="51261">二叉搜索树（BST）：</st>
- en: '[PRE22]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="51358">The following shows how to search a key</st> <st c="51399">in
    BST:</st>
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51358">下面展示了如何在BST中搜索一个键：</st> <st c="51399">在BST中搜索：</st>
- en: '[PRE23]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="51595">Let’s explain the</st> <st c="51613">important parts of</st> <st
    c="51633">the algorithm:</st>
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51595">让我们解释一下</st> <st c="51613">算法中的重要部分：</st>
- en: '**<st c="51647">TreeNode</st>**<st c="51656">: Each node in the BST contains
    a key (the value of the node), and references (</st>**<st c="51736">left</st>**
    <st c="51741">and</st> **<st c="51746">right</st>**<st c="51751">) to its left
    and</st> <st c="51770">right children.</st>'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="51647">TreeNode</st>**<st c="51656">：每个BST中的节点包含一个键（节点的值），以及指向其左子节点和</st>
    **<st c="51736">右子节点</st>**<st c="51741">的引用。</st>'
- en: '**<st c="51785">insert</st>**<st c="51792">: The insert function inserts values
    into the BST.</st> <st c="51844">It recursively traverses the tree and inserts
    the new node in the correct position based on the</st> <st c="51940">BST property.</st>'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="51785">insert</st>**<st c="51792">：insert函数将值插入到BST中。</st> <st c="51844">它递归遍历树并根据BST的属性将新节点插入到正确的位置。</st>'
- en: '**<st c="51953">search</st>**<st c="51960">: The search function recursively
    looks for a given key.</st> <st c="52018">If the current node’s key matches the
    key being searched, it returns that node.</st> <st c="52098">Otherwise, it continues
    searching in the left or right subtree based on whether the key is smaller or
    larger than the current</st> <st c="52224">node’s key.</st>'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="51953">search</st>**<st c="51960">：search函数递归地查找给定的键。</st> <st c="52018">如果当前节点的键与正在搜索的键匹配，它会返回该节点。</st>
    <st c="52098">否则，根据键是小于还是大于当前节点的键，它会继续在左子树或右子树中进行搜索。</st>'
- en: <st c="52235">The time complexity of searching in a BST depends on how balanced
    the tree is.</st> <st c="52315">In the worst case, the complexity is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1905.png)<st
    c="52352"><st c="52353">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>L</mml:mi></mml:math>](img/1906.png)
    <st c="52361"><st c="52362">is the depth of the BST.</st> <st c="52388">In an
    extremely unbalanced case, where the BST essentially forms a linear structure,
    the time complexity becomes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1907.png)<st
    c="52501"><st c="52502">. However, in a fully balanced BST, the time complexity
    is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/1908.png)<st
    c="52561"><st c="52569">, ensuring more</st> <st c="52585">efficient searches.</st></st></st></st></st>
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52235">在二叉搜索树中，查找操作的时间复杂度取决于树的平衡程度。</st> <st c="52315">在最坏的情况下，时间复杂度为</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1905.png)<st
    c="52352"><st c="52353">，其中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>L</mml:mi></mml:math>](img/1906.png)
    <st c="52361"><st c="52362">是二叉搜索树的深度。</st> <st c="52388">在极度不平衡的情况下，如果二叉搜索树实际上形成了线性结构，则时间复杂度变为</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1907.png)<st
    c="52501"><st c="52502">。然而，在完全平衡的二叉搜索树中，时间复杂度为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/1908.png)<st
    c="52561"><st c="52569">，从而确保更高效的查找。</st></st></st></st></st>
- en: <st c="52604">The insertion operation in a BST</st>
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="52604">二叉搜索树中的插入操作</st>
- en: <st c="52637">The</st> `<st c="52886">null</st>`<st c="52891">), the new node
    is</st> <st c="52911">inserted there.</st>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52637">当</st> `<st c="52886">null</st>`<st c="52891">)，新节点被</st> <st
    c="52911">插入到该位置。</st>
- en: '<st c="52926">Let’s briefly discuss the complexity of insertion in a BST: Similar
    to searching, the time complexity of insertion in a BST depends on its balance.</st>
    <st c="53075">In the worst case, when the tree is highly unbalanced and resembles
    a linear structure, the time complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1909.png)<st
    c="53186"><st c="53187">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/322.png)
    <st c="53195"><st c="53196">is the</st> <st c="53203">number of nodes.</st> <st
    c="53221">In contrast, in a balanced BST, the time complexity is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/1908.png)<st
    c="53276"><st c="53284">, as the insertion operation involves traversing the</st>
    <st c="53337">tree’s height:</st></st></st></st>'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52926">让我们简要讨论一下在二叉搜索树（BST）中插入操作的时间复杂度：与搜索类似，插入操作的时间复杂度取决于树的平衡性。</st>
    <st c="53075">在最坏的情况下，当树非常不平衡并且类似于线性结构时，时间复杂度为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1909.png)<st
    c="53186"><st c="53187">，其中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/322.png)
    <st c="53195"><st c="53196">表示</st> <st c="53203">节点的数量。</st> <st c="53221">相比之下，在平衡的二叉搜索树中，插入操作的时间复杂度为</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/1908.png)<st
    c="53276"><st c="53284">，因为插入操作涉及到遍历</st> <st c="53337">树的高度：</st></st></st></st>
- en: '**<st c="53351">Average case (balanced tree)</st>**<st c="53380">: In a balanced
    BST, insertion takes</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1912.png)
    <st c="53418"><st c="53427">time on</st> <st c="53434">average, as we are essentially
    performing a search to find the appropriate location to insert the</st> <st c="53533">new
    node</st></st>'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="53351">平均情况（平衡树）</st>**<st c="53380">：在平衡的二叉搜索树中，插入操作平均需要</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1912.png)
    <st c="53418"><st c="53427">的时间，因为我们本质上是在执行搜索，找到合适的位置来插入</st> <st c="53533">新节点</st></st>'
- en: '**<st c="53541">Worst case (unbalanced tree)</st>**<st c="53570">: Similar
    to searching, if the BST is unbalanced, insertion time can degrade to</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/49.png)<st
    c="53651"><st c="53668">, particularly if the values being inserted cause the
    tree to</st> <st c="53730">become skewed</st></st>'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="53541">最坏情况（不平衡树）</st>**<st c="53570">：与搜索类似，如果二叉搜索树不平衡，插入时间可能退化为</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/49.png)<st
    c="53651"><st c="53668">，尤其是当插入的值使树变得</st> <st c="53730">倾斜</st></st>'
- en: <st c="53743">In the Python code provided for the search algorithm, the</st>
    `<st c="53802">insert</st>` <st c="53808">function is responsible for inserting
    nodes into the BST while maintaining the BST property.</st> <st c="53902">It works
    recursively to find the correct position for the</st> <st c="53960">new node.</st>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53743">在提供的 Python 搜索算法代码中，`<st c="53802">insert</st>` <st c="53808">函数负责将节点插入到二叉搜索树中，同时保持树的属性。</st>
    <st c="53902">它通过递归方式工作，找到插入</st> <st c="53960">新节点的正确位置。</st>
- en: <st c="53969">Let’s see how the</st> `<st c="53988">insert</st>` <st c="53994">function
    works.</st> <st c="54011">If the tree is empty (i.e., the current node is</st>
    `<st c="54059">None</st>`<st c="54063">), the function creates a new node with
    the given key and returns it, effectively making it the root or a leaf.</st> <st
    c="54176">If the key to be inserted is smaller than the current node’s key, the
    function recursively moves to the left subtree to find the appropriate position.</st>
    <st c="54327">If the key to be inserted is larger than the current node’s key,
    it recursively moves to the right subtree.</st> <st c="54435">Once the appropriate
    position is found, the new node is added as either the left or</st> <st c="54519">right
    child.</st>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53969">让我们来看看</st> `<st c="53988">insert</st>` <st c="53994">函数是如何工作的。</st>
    <st c="54011">如果树为空（即当前节点是</st> `<st c="54059">None</st>`<st c="54063">），函数会创建一个新的节点，并返回它，从而使其成为根节点或叶子节点。</st>
    <st c="54176">如果要插入的键小于当前节点的键，函数会递归地向左子树移动，以找到合适的位置。</st> <st c="54327">如果要插入的键大于当前节点的键，函数会递归地向右子树移动。</st>
    <st c="54435">一旦找到合适的位置，新的节点会作为左子节点或右子节点添加。</st>
- en: <st c="54531">Here is a simple Python code implementing insertion in</st> <st
    c="54587">a BST:</st>
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54531">这是一个简单的Python代码实现，用于在</st> <st c="54587">二叉搜索树（BST）中插入：</st>
- en: '[PRE24]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="54877">For example, if we insert the values</st> `<st c="54915">20</st>`<st
    c="54917">,</st> `<st c="54919">10</st>`<st c="54921">,</st> `<st c="54923">30</st>`<st
    c="54925">,</st> `<st c="54927">5</st>`<st c="54928">,</st> `<st c="54930">15</st>`<st
    c="54932">,</st> `<st c="54934">25</st>`<st c="54936">, and</st> `<st c="54942">35</st>`
    <st c="54944">using this</st> `<st c="54956">insert</st>` <st c="54962">function,
    it will create the BST depicted in</st> *<st c="55008">Figure 13</st>**<st c="55017">.13</st>*<st
    c="55020">.</st>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54877">例如，如果我们插入值</st> `<st c="54915">20</st>`<st c="54917">,</st> `<st
    c="54919">10</st>`<st c="54921">,</st> `<st c="54923">30</st>`<st c="54925">,</st>
    `<st c="54927">5</st>`<st c="54928">,</st> `<st c="54930">15</st>`<st c="54932">,</st>
    `<st c="54934">25</st>`<st c="54936">, 和</st> `<st c="54942">35</st>` <st c="54944">使用这个</st>
    `<st c="54956">insert</st>` <st c="54962">函数，它将创建如</st> *<st c="55008">图13</st>**<st
    c="55017">.13</st>*<st c="55020">所示的二叉搜索树（BST）。</st>
- en: '![Figure 13.13: The final BST representing [20, 10, 30, 5, 15, 25, 35]](img/B22248_13_13.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图13.13：表示[20, 10, 30, 5, 15, 25, 35]的最终二叉搜索树（BST）](img/B22248_13_13.jpg)'
- en: '<st c="55023">Figure 13.13: The final BST representing [20, 10, 30, 5, 15,
    25, 35]</st>'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55023">图13.13：表示[20, 10, 30, 5, 15, 25, 35]的最终二叉搜索树（BST）</st>
- en: <st c="55091">The</st> <st c="55096">insertion of the value</st> `<st c="55119">35</st>`
    <st c="55121">is highlighted in the tree.</st> <st c="55150">When inserting</st>
    `<st c="55165">35</st>`<st c="55167">, first, it is compared with the root node,</st>
    `<st c="55211">20</st>`<st c="55213">. Since</st> `<st c="55221">35</st>` <st
    c="55223">is greater than</st> `<st c="55240">20</st>`<st c="55242">, we move
    to the right subtree.</st> <st c="55274">Next,</st> `<st c="55280">35</st>` <st
    c="55282">is compared with the node</st> `<st c="55309">30</st>`<st c="55311">.
    Since</st> `<st c="55319">35</st>` <st c="55321">is greater than</st> `<st c="55338">30</st>`<st
    c="55340">, it will be inserted as the right child of node</st> `<st c="55389">30</st>`<st
    c="55391">. The key comparison process ensures that</st> `<st c="55433">35</st>`
    <st c="55435">is placed correctly in the BST according to the BST property, where
    values in the right subtree are greater than the</st> <st c="55553">parent node.</st>
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55091">值</st> <st c="55096">35</st> <st c="55096">的插入过程在树中被高亮显示。</st>
    <st c="55150">插入</st> `<st c="55165">35</st>`<st c="55167">时，首先将其与根节点</st> `<st
    c="55211">20</st>`<st c="55213">进行比较。由于</st> `<st c="55221">35</st>` <st c="55223">大于</st>
    `<st c="55240">20</st>`<st c="55242">，我们移动到右子树。</st> <st c="55274">接下来，</st> `<st
    c="55280">35</st>` <st c="55282">与节点</st> `<st c="55309">30</st>`<st c="55311">进行比较。由于</st>
    `<st c="55319">35</st>` <st c="55321">大于</st> `<st c="55338">30</st>`<st c="55340">，它将被插入为节点</st>
    `<st c="55389">30</st>`<st c="55391">的右子节点。</st> <st c="55433">关键字比较过程确保了</st>
    `<st c="55433">35</st>` <st c="55435">根据二叉搜索树的属性正确地放置，其中右子树中的值大于</st> <st c="55553">父节点。</st>
- en: <st c="55565">As a summary, the</st> `<st c="55584">insert</st>` <st c="55590">function
    ensures that each new value is placed in the correct position in the tree by comparing
    it to the existing node values.</st> <st c="55719">It maintains in the BST property
    that all values in the left subtree are smaller than the parent node, and all
    values in the right subtree</st> <st c="55858">are larger.</st>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55565">总结来说，</st> `<st c="55584">insert</st>` <st c="55590">函数通过将每个新值与现有节点值进行比较，确保每个新值都被放置在树中的正确位置。</st>
    <st c="55719">它保持了二叉搜索树的属性，即左子树中的所有值都小于父节点，而右子树中的所有值</st> <st c="55858">都大于父节点。</st>
- en: <st c="55869">The deletion operation in a BST</st>
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="55869">二叉搜索树（BST）中的删除操作</st>
- en: <st c="55901">In a BST, the</st> <st c="55916">deletion operation is more complex
    than the insertion operation because we need to maintain the BST property after
    removing a node.</st> <st c="56048">There are three possible cases to consider
    when deleting</st> <st c="56105">a node:</st>
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55901">在二叉搜索树（BST）中，</st> <st c="55916">删除操作比插入操作更复杂，因为我们需要在删除节点后维护二叉搜索树的特性。</st>
    <st c="56048">删除节点时，需要考虑三种可能的情况：</st> <st c="56105">删除一个节点：</st>
- en: '**<st c="56112">Deleting a leaf node</st>**<st c="56133">: A node with no children
    can be</st> <st c="56167">directly removed.</st>'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="56112">删除叶子节点</st>**<st c="56133">：没有子节点的节点可以</st> <st c="56167">直接删除。</st>'
- en: '**<st c="56184">Deleting a node with one child</st>**<st c="56215">: The node
    is replaced by</st> <st c="56242">its child.</st>'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="56184">删除具有一个子节点的节点</st>**<st c="56215">：该节点将被</st> <st c="56242">其子节点替代。</st>'
- en: '**<st c="56252">Deleting a node with two children</st>**<st c="56286">: The
    node is replaced by either its in-order predecessor (the largest node in the left
    subtree) or its in-order successor (the smallest node in the right subtree).</st>
    <st c="56452">After replacement, the node from which the replacement came must
    also</st> <st c="56522">be removed.</st>'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="56252">删除具有两个子节点的节点</st>**<st c="56286">：该节点将被其中序前驱节点（左子树中的最大节点）或中序后继节点（右子树中的最小节点）替换。</st>
    <st c="56452">替换后，替换源节点也必须</st> <st c="56522">被删除。</st>'
- en: <st c="56533">The</st> <st c="56537">following is the Python code that implements
    the deletion operation in a BST.</st> <st c="56616">First, we must define the</st>
    `<st c="56642">TreeNode</st>` <st c="56650">class (refer to previous examples).</st>
    <st c="56687">Next, we need to construct the tree using the</st> `<st c="56733">insert</st>`
    <st c="56739">function that was discussed earlier.</st> <st c="56777">Next, we
    implement the</st> `<st c="56800">min_value_node</st>` <st c="56814">function
    to find the successor when a node</st> <st c="56858">is deleted:</st>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56533">以下是实现二叉搜索树（BST）中删除操作的 Python 代码。</st> <st c="56616">首先，我们必须定义</st>
    `<st c="56642">TreeNode</st>` <st c="56650">类（参见前面的例子）。</st> <st c="56687">接下来，我们使用前面讨论过的</st>
    `<st c="56733">insert</st>` <st c="56739">函数来构建树。</st> <st c="56777">接下来，我们实现</st>
    `<st c="56800">min_value_node</st>` <st c="56814">函数，以便在删除节点时找到后继节点：</st>
- en: '[PRE25]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="57064">Lastly, we have</st> `<st c="57081">delete_node</st>` <st c="57092">to
    implement the three cases of the deletion operation</st> <st c="57148">in BSTs:</st>
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57064">最后，我们实现</st> `<st c="57081">delete_node</st>` <st c="57092">函数来处理删除操作的三种情况</st>
    <st c="57148">在二叉搜索树（BST）中的实现：</st>
- en: '[PRE26]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="58081">The</st> <st c="58086">following is an example of constructing
    a BST using the</st> `<st c="58142">insert</st>` <st c="58148">function and then
    deleting the node with the</st> <st c="58194">value</st> `<st c="58200">30</st>`<st
    c="58202">:</st>
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58081">以下是一个使用</st> `<st c="58142">insert</st>` <st c="58148">函数构建二叉搜索树（BST）并删除值为</st>
    `<st c="58194">30</st>`<st c="58202">的节点的例子：</st>
- en: '[PRE27]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="58691">Let’s explain</st> <st c="58705">the example.</st> <st c="58719">We
    first compare</st> *<st c="58736">node 30</st>* <st c="58743">with the root</st>
    *<st c="58758">node 20</st>*<st c="58765">. Since 30 is greater than 20, we move
    to the right subtree.</st> <st c="58826">We find</st> *<st c="58834">node 30</st>*
    <st c="58841">and notice that it has two children (</st>*<st c="58879">nodes 25</st>*
    <st c="58888">and</st> *<st c="58893">35</st>*<st c="58895">).</st> <st c="58899">We
    replace</st> *<st c="58910">node 30</st>* <st c="58917">with its in-order successor,</st>
    *<st c="58947">node 35</st>*<st c="58954">, and then remove</st> *<st c="58972">node
    35</st>* <st c="58979">from its original position.</st> *<st c="59008">Figure
    13</st>**<st c="59017">.14</st>* <st c="59020">demonstrates the BST after removing</st>
    *<st c="59057">node 35</st>*<st c="59064">.</st>
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58691">让我们解释一下</st> <st c="58705">这个例子。</st> <st c="58719">我们首先比较</st>
    *<st c="58736">节点 30</st>* <st c="58743">和根节点</st> *<st c="58758">节点 20</st>*<st
    c="58765">。由于 30 大于 20，我们移动到右子树。</st> <st c="58826">我们发现</st> *<st c="58834">节点
    30</st>* <st c="58841">并注意到它有两个子节点（</st>*<st c="58879">节点 25</st>* <st c="58888">和</st>
    *<st c="58893">35</st>*<st c="58895">）。</st> <st c="58899">我们用它的中序后继节点</st> *<st
    c="58910">节点 30</st>* <st c="58917">替换该节点，</st> *<st c="58947">节点 35</st>*<st
    c="58954">，然后从原位置删除</st> *<st c="58972">节点 35</st>* <st c="58979">。</st> *<st
    c="59008">图 13</st>**<st c="59017">.14</st>* <st c="59020">展示了移除</st> *<st c="59057">节点
    35</st>*<st c="59064">后的二叉搜索树（BST）。</st>
- en: '![Figure 13.14: The BST in Figure 13.9 after removing 35](img/B22248_13_14.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.14：移除 35 后的二叉搜索树（见图 13.9）](img/B22248_13_14.jpg)'
- en: '<st c="59067">Figure 13.14: The BST in Figure 13.9 after removing 35</st>'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59067">图 13.14：移除 35 后的二叉搜索树（见图 13.9）</st>
- en: <st c="59121">The time complexity of deletion in BSTs is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1914.png)
    <st c="59165"><st c="59174">on average, which occurs when the tree is balanced
    since we only need to traverse the tree’s height to locate and delete the node.</st>
    <st c="59305">However, in the worst case, the time complexity is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1011.png)<st
    c="59356"><st c="59357">, particularly when the tree is unbalanced and takes the
    form of a</st> <st c="59424">linked list.</st></st></st>
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59121">在二叉搜索树（BST）中，删除操作的时间复杂度是</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1914.png)
    <st c="59165"><st c="59174">平均情况下，当树是平衡时，因为我们只需遍历树的高度来定位并删除节点。</st> <st c="59305">然而，在最坏的情况下，时间复杂度是</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1011.png)<st
    c="59356"><st c="59357">，特别是在树不平衡并且呈现为</st> <st c="59424">链表的情况下。</st></st></st>
- en: <st c="59436">In the next section, we will explore heap structures, which play
    a crucial role in sorting algorithms and other applications requiring efficient</st>
    <st c="59582">data management.</st>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59436">在下一节中，我们将探讨堆结构，它在排序算法和其他需要高效</st> <st c="59582">数据管理的应用中发挥着至关重要的作用。</st>
- en: <st c="59598">Heaps</st>
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="59598">堆</st>
- en: <st c="59604">A</st> **<st c="59607">heap</st>** <st c="59611">is a</st> <st
    c="59616">special type of binary tree that satisfies the heap property.</st> <st
    c="59679">In a heap, the parent node always follows a specific order relation
    with respect to its children.</st> <st c="59777">Heaps are commonly used in various
    algorithms, especially in sorting and priority queues, due to their e</st><st
    c="59881">fficient access to the minimum or</st> <st c="59916">maximum element.</st>
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59604">A</st> **<st c="59607">堆</st>** <st c="59611">是一种特殊类型的二叉树，满足堆的性质。</st>
    <st c="59679">在堆中，父节点总是与其子节点之间遵循特定的顺序关系。</st> <st c="59777">堆常用于各种算法，特别是在排序和优先队列中，因为它们能够高效地访问最小或</st><st
    c="59881">最大元素。</st>
- en: <st c="59932">There are two main types of heaps, based on the order property</st>
    <st c="59996">they follow:</st>
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59932">根据它们遵循的顺序性质，堆主要有两种类型：</st>
- en: '**<st c="60008">Max-heap</st>**<st c="60017">: In a</st> <st c="60025">max-heap,
    each node’s value is greater than or equal to the values of its children, with
    the largest element positioned at the root.</st> <st c="60158">Max-heaps are commonly
    used in algorithms that need efficient access to the maximum element, such as
    heapsort and priority queue implementations.</st> <st c="60304">In max-heap, the
    heap property is as</st> <st c="60341">follows:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi
    mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">e</mi><mo>.</mo></mrow></mrow></math>](img/1916.png) <st
    c="60350">*   ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mfenced
    open="[" close="]"><mi>i</mi></mfenced><mo>≥</mo><mi>A</mi><mfenced open="[" close="]"><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mfenced></mrow></mrow></math>](img/1917.png)<st
    c="60370"><st c="60390">(</st><st c="60391">left child)</st></st>'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="60008">最大堆</st>**<st c="60017">：在最大堆中，每个节点的值都大于或等于其子节点的值，最大的元素位于根节点。</st>
    <st c="60158">最大堆通常用于需要高效访问最大元素的算法中，比如堆排序和优先队列的实现。</st> <st c="60304">在最大堆中，堆的性质如下：</st>
    <st c="60341">对于每个节点</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi
    mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">e</mi><mo>.</mo></mrow></mrow></math>](img/1916.png) <st
    c="60350">*   ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mfenced
    open="[" close="]"><mi>i</mi></mfenced><mo>≥</mo><mi>A</mi><mfenced open="[" close="]"><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mfenced></mrow></mrow></math>](img/1917.png)<st
    c="60370"><st c="60390">(左子节点)</st></st>'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo>≥</mml:mo><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1918.png)
    <st c="60402"><st c="60419">(right child), where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)
    <st c="60440"><st c="60441">is the array representation of</st> <st c="60473">the
    heap</st></st></st></st>'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo>≥</mml:mo><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1918.png)
    <st c="60402"><st c="60419">(右子节点)，其中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)
    <st c="60440"><st c="60441">是</st> <st c="60473">堆的数组表示</st></st></st></st>'
- en: '**<st c="60481">Min-heap</st>**<st c="60490">: In a min-heap, the</st> <st
    c="60512">value of each node is less than or equal to the values of its children.</st>
    <st c="60584">The smallest element is always at the root.</st> <st c="60628">Min-heaps
    are commonly used in algorithms such as Dijkstra’s shortest path and Prim’s minimum
    spanning tree.</st> <st c="60737">In this case, the heap property is as follows:
    For each node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="60798"><st c="60799">, this is</st> <st c="60809">the case:</st>'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="60481">最小堆</st>**<st c="60490">：在最小堆中，</st> <st c="60512">每个节点的值都小于或等于其子节点的值。</st>
    <st c="60584">最小元素始终位于根节点。</st> <st c="60628">最小堆通常用于像 Dijkstra 最短路径算法和 Prim 最小生成树这样的算法中。</st>
    <st c="60737">在这种情况下，堆的性质如下：对于每个节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="60798"><st c="60799">，这是</st> <st c="60809">成立的：</st>'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1921.png)
    <st c="60818"><st c="60839">(</st><st c="60840">left child)</st></st>'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mn><mml:mi>i</mml:mi><mml:mo>+</mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1921.png)
    <st c="60818"><st c="60839">(</st><st c="60840">左子节点)</st></st>'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1922.png)
    <st c="60851"><st c="60869">(</st><st c="60870">right child)</st></st></st>'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mn><mml:mi>i</mml:mi><mml:mo>+</mo><mml:mn>2</mn></mml:mrow></mml:mfenced></mml:math>](img/1922.png)
    <st c="60851"><st c="60869">(</st><st c="60870">右子节点)</st></st></st>'
- en: <st c="60882">Heaps are typically represented as complete binary trees stored
    in an array.</st> <st c="60960">In a complete binary tree, this is</st> <st c="60995">the
    case:</st>
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60882">堆通常表示为存储在数组中的完全二叉树。</st> <st c="60960">在完全二叉树中，情况是这样的：</st> <st
    c="60995">如下所示：</st>
- en: <st c="61004">The root node is at</st> <st c="61025">index 0</st>
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="61004">根节点位于</st> <st c="61025">索引 0</st>
- en: <st c="61032">For a node at index</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="61053"><st c="61054">, the left child is at index</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mrow></math>](img/1899.png)<st
    c="61083"><st c="61084">, and the right child is at</st> <st c="61112">index</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow></mrow></math>](img/1900.png)</st></st>
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="61032">对于索引</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="61053"><st c="61054">处的节点，左子节点位于索引</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mrow></math>](img/1899.png)<st
    c="61083"><st c="61084">，右子节点位于索引</st> <st c="61112">处</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow></mrow></math>](img/1900.png)</st></st>
- en: <st c="61119">The parent of a node at index</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="61149"><st c="61150">is located</st> <st c="61162">at</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mtext>floor</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1927.png)</st>
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="61119">位于索引</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="61149"><st c="61150">的节点的父节点位于</st> <st c="61162">索引</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mtext>floor</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1927.png)</st>
- en: <st c="61182">This array representation allows heaps to be efficiently stored
    in memory without using pointers for the child nodes (see</st> *<st c="61304">Figure
    13</st>**<st c="61313">.15</st>*<st c="61316">).</st>
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61182">这种数组表示法使得堆能够高效地存储在内存中，而无需使用指针来表示子节点（见</st> *<st c="61304">图 13</st>**<st
    c="61313">.15</st>*<st c="61316">）。</st>
- en: '![Figure 13.15: An example max-heap](img/B22248_13_15.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.15：一个示例最大堆](img/B22248_13_15.jpg)'
- en: '<st c="61321">Figure 13.15: An example max-heap</st>'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61321">图 13.15：一个示例最大堆</st>
- en: '| **<st c="61354">Index</st>** | <st c="61360">1</st> | <st c="61362">2</st>
    | <st c="61363">3</st> | <st c="61364">4</st> | <st c="61365">5</st> | <st c="61366">6</st>
    | <st c="61367">7</st> | <st c="61368">8</st> | <st c="61369">9</st> | <st c="61370">10</st>
    | <st c="61372">11</st> | <st c="61375">12</st> | <st c="61378">13</st> |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="61354">索引</st>** | <st c="61360">1</st> | <st c="61362">2</st> |
    <st c="61363">3</st> | <st c="61364">4</st> | <st c="61365">5</st> | <st c="61366">6</st>
    | <st c="61367">7</st> | <st c="61368">8</st> | <st c="61369">9</st> | <st c="61370">10</st>
    | <st c="61372">11</st> | <st c="61375">12</st> | <st c="61378">13</st> |'
- en: '| **<st c="61381">node</st>** | <st c="61386">98</st> | <st c="61389">81</st>
    | <st c="61392">86</st> | <st c="61395">63</st> | <st c="61398">21</st> | <st
    c="61401">68</st> | <st c="61404">18</st> | <st c="61407">10</st> | <st c="61410">51</st>
    | <st c="61413">4</st> | <st c="61415">14</st> | <st c="61417">1</st> | <st c="61419">50</st>
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="61381">节点</st>** | <st c="61386">98</st> | <st c="61389">81</st>
    | <st c="61392">86</st> | <st c="61395">63</st> | <st c="61398">21</st> | <st
    c="61401">68</st> | <st c="61404">18</st> | <st c="61407">10</st> | <st c="61410">51</st>
    | <st c="61413">4</st> | <st c="61415">14</st> | <st c="61417">1</st> | <st c="61419">50</st>
    |'
- en: '<st c="61421">Figure 13.16: The array representation of the max-heap in Figure
    13.15</st>'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61421">图13.16：图13.15中最大堆的数组表示</st>
- en: <st c="61492">Now that we have</st> <st c="61509">learned about the heap property
    and heap representation, let’s explore the operation</st> <st c="61595">on heaps.</st>
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61492">现在我们已经了解了堆的属性和堆的表示方法，接下来让我们探讨堆上的操作。</st>
- en: <st c="61604">Heap operations</st>
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="61604">堆操作</st>
- en: <st c="61620">The</st> <st c="61625">primary operations on heaps are</st> *<st
    c="61657">insertion</st>*<st c="61666">,</st> *<st c="61668">deletion</st>*<st
    c="61676">, and</st> *<st c="61682">heapify</st>* <st c="61689">(used for maintaining
    the heap property).</st> <st c="61732">Each of these operations relies on the
    heap property to ensure that the structure remains a</st> <st c="61824">valid
    heap.</st>
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61620">堆的</st> <st c="61625">主要操作包括</st> *<st c="61657">插入</st>*<st c="61666">，</st>
    *<st c="61668">删除</st>*<st c="61676">和</st> *<st c="61682">堆化</st>* <st c="61689">（用于维护堆的属性）。</st>
    <st c="61732">这些操作都依赖于堆的属性，以确保结构保持有效的</st> <st c="61824">堆。</st>
- en: <st c="61835">Insertion in a heap</st>
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="61835">堆中的插入</st>
- en: <st c="61855">To insert an element</st> <st c="61876">into a heap, we first
    add the element at the last position in the array (the end of the heap).</st>
    <st c="61972">Then, we perform a</st> `<st c="61991">heapify-up</st>` <st c="62001">operation,
    which involves comparing the inserted element with its parent.</st> <st c="62076">If
    the heap property is violated, we swap the two.</st> <st c="62127">This process
    is repeated until the heap property</st> <st c="62176">is restored.</st>
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61855">要将一个元素插入堆中，我们首先将元素添加到数组的最后一个位置（堆的末尾）。</st> <st c="61972">然后，执行</st>
    `<st c="61991">堆化向上</st>` <st c="62001">操作，涉及将插入的元素与其父元素进行比较。</st> <st c="62076">如果堆的属性被破坏，我们交换这两个元素。</st>
    <st c="62127">此过程会一直重复，直到恢复堆的属性。</st>
- en: <st c="62188">Here is the Python code for insertion in</st> <st c="62230">a
    max-heap:</st>
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62188">以下是插入操作的Python代码，适用于</st> <st c="62230">最大堆：</st>
- en: '[PRE28]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="62582">The</st> <st c="62586">following is an example of building</st>
    <st c="62623">a max-heap:</st>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62582">以下是构建</st> <st c="62586">最大堆的例子：</st>
- en: '[PRE29]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="62827">The time complexity for insertion is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1928.png)<st
    c="62865"><st c="62874">, as we may need to swap elements up the tree to restore
    the</st> <st c="62935">heap property.</st></st>
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62827">插入操作的时间复杂度是</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1928.png)<st
    c="62865"><st c="62874">，因为我们可能需要交换树中的元素以恢复</st> <st c="62935">堆的属性。</st></st>
- en: <st c="62949">Deletion in a heap</st>
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="62949">堆中的删除</st>
- en: <st c="62968">In a heap, deletion</st> <st c="62988">typically involves removing
    the root element (the maximum in a max-heap or the minimum in a min-heap).</st>
    <st c="63092">The deletion process is performed in</st> <st c="63129">three steps:</st>
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62968">在堆中，删除</st> <st c="62988">通常涉及移除根元素（在最大堆中是最大值，在最小堆中是最小值）。</st>
    <st c="63092">删除过程分为</st> <st c="63129">三步：</st>
- en: <st c="63141">Replace the root element with the last element in</st> <st c="63192">the
    array.</st>
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="63141">用数组中的最后一个元素替换根元素。</st>
- en: <st c="63202">Remove the last element from</st> <st c="63232">the array.</st>
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="63202">从</st> <st c="63232">数组中移除最后一个元素。</st>
- en: <st c="63242">The process of heapifying down the root element involves comparing
    it with its children.</st> <st c="63332">In cases where the heap property is violated,
    a swap occurs between the root and the largest child for a max-heap or the smallest
    child for a min-heap.</st> <st c="63484">This continues until the heap property</st>
    <st c="63523">is restored.</st>
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆化根元素的过程涉及将其与子节点进行比较。在堆属性被破坏的情况下，会在最大堆中将根与最大的子节点交换，或者在最小堆中将根与最小的子节点交换。此过程会持续直到堆属性**恢复**。
- en: <st c="63535">Here is a</st> <st c="63545">simple Python code for deletion in</st>
    <st c="63581">a max-heap:</st>
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个用于在最大堆中删除元素的**简单 Python 代码**：
- en: '[PRE30]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="64145">Let’s have an</st> <st c="64160">example max-heap and delete the
    root</st> <st c="64197">using</st> `<st c="64203">delete_max_heap</st>`<st c="64218">:</st>
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个**示例最大堆**并使用`delete_max_heap`删除根元素：
- en: '[PRE31]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <st c="64330">The heap after the deletion of a max element is</st> `<st c="64379">[30,
    15,</st>` `<st c="64388">20, 5]</st>`<st c="64394">.</st>
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 删除最大元素后的堆是`[30, 15, 20, 5]`。
- en: <st c="64395">The time complexity for deletion is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1929.png)<st
    c="64432"><st c="64441">, as we may need to swap elements down the tree to restore
    the</st> <st c="64504">heap property.</st></st>
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作的时间复杂度是![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1929.png)，因为我们可能需要交换树中的元素以恢复堆的**堆属性**。
- en: <st c="64518">Heapify (building a heap)</st>
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆化（构建堆）
- en: <st c="64544">To build a</st> <st c="64556">heap from an arbitrary array, we
    use the heapify process.</st> <st c="64614">Starting from the first non-leaf node,
    we move up to the root, ensuring the heap property is maintained.</st> <st c="64719">Consider
    the following Python implementation</st> <st c="64764">of</st> `<st c="64767">heapify</st>`<st
    c="64774">:</st>
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从任意数组构建堆，我们使用堆化过程。从第一个非叶子节点开始，向上遍历至根节点，确保堆属性得以保持。考虑以下`heapify`的 Python 实现：
- en: '[PRE32]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: <st c="65060">As we</st> <st c="65066">can see, the</st> `<st c="65080">heapify</st>`
    <st c="65087">function recursively calls itself to ensure that the heap property
    is maintained throughout the tree.</st> <st c="65190">If a violation of the heap
    property is detected at any node,</st> `<st c="65251">heapify</st>` <st c="65258">continues
    down the tree, correcting the structure by comparing and swapping nodes as needed,
    until the property is</st> <st c="65374">fully restored.</st>
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`heapify`函数递归调用自身，以确保整个树的堆属性得以保持。如果在任何节点发现堆属性被破坏，`heapify`将继续向下遍历树，通过比较和交换节点来修复结构，直到堆属性**完全恢复**。
- en: <st c="65389">The following is a Python code to build a max-heap using the</st>
    `<st c="65451">heapify</st>` <st c="65458">recursive algorithm:</st>
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用`heapify`递归算法构建最大堆的 Python 代码：
- en: '[PRE33]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <st c="65625">The following is a simple example of a</st> `<st c="65665">build_max_heap</st>`
    <st c="65679">usage:</st>
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的`build_max_heap`用法示例：
- en: '[PRE34]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: <st c="65773">The</st> `<st c="65778">a</st>` <st c="65779">array representing
    the max-heap after building the max-heap is</st> `<st c="65843">[40, 30, 20,</st>`
    `<st c="65856">5, 15]</st>`<st c="65862">.</st>
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 建立最大堆后，表示最大堆的`数组`是`[40, 30, 20, 5, 15]`。
- en: <st c="65863">The time complexity for building a heap is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1930.png)
    <st c="65907"><st c="65908">since each node requires at most</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1931.png)
    <st c="65942"><st c="65951">swaps, but most nodes are near the bottom of the tree
    and need</st> <st c="66014">fewer swaps.</st></st></st>
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65863">构建堆的时间复杂度是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1930.png)
    <st c="65907"><st c="65908">因为每个节点最多需要</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1931.png)
    <st c="65942"><st c="65951">次交换，但大多数节点位于树的底部，需要</st> <st c="66014">较少的交换。</st></st></st>
- en: '<st c="66026">Let’s explore a major application of heap</st> <st c="66069">structures:
    heapsort.</st>'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66026">让我们探索堆的一个主要应用</st> <st c="66069">：堆排序。</st>
- en: <st c="66090">Heapsort</st>
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="66090">堆排序</st>
- en: '**<st c="66099">Heapsort</st>** <st c="66108">is an</st> <st c="66115">efficient
    comparison-based sorting algorithm that leverages the heap data structure, particularly
    the max-heap, to sort elements in</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1010.png)
    <st c="66247"><st c="66258">time.</st> <st c="66264">It works by first converting
    the input array into a max-heap and then repeatedly extracting the largest element
    (the root of the heap) to build the sorted output.</st> <st c="66427">This process
    ensures that the elements are sorted in ascending order.</st> <st c="66497">The
    following outlines</st> <st c="66520">the steps involved in</st> <st c="66542">performing
    heapsort:</st></st>'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="66099">堆排序</st>** <st c="66108">是一种</st> <st c="66115">高效的基于比较的排序算法，利用堆数据结构（尤其是最大堆）对元素进行排序，其时间复杂度为</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1010.png)
    <st c="66247"><st c="66258">。</st> <st c="66264">它的工作方式首先将输入数组转换为最大堆，然后重复提取最大元素（堆的根），以构建排序好的输出。</st>
    <st c="66427">这个过程确保元素按升序排列。</st> <st c="66497">以下概述</st> <st c="66520">执行堆排序所涉及的步骤：</st></st>'
- en: <st c="66562">Build a max-heap from the</st> <st c="66589">input array.</st>
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="66562">从输入数组构建一个最大堆。</st>
- en: <st c="66601">Swap the root (maximum element) with the</st> <st c="66643">last
    element.</st>
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="66601">交换根（最大元素）与</st> <st c="66643">最后一个元素。</st>
- en: <st c="66656">Reduce the heap size by one and</st> **<st c="66689">heapify</st>**
    <st c="66696">the</st> <st c="66701">root element.</st>
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="66656">减小堆的大小并</st> **<st c="66689">堆化</st>** <st c="66696">根元素。</st>
- en: <st c="66714">Repeat the process until the heap</st> <st c="66749">is empty.</st>
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="66714">重复这个过程直到堆</st> <st c="66749">为空。</st>
- en: <st c="66758">Here is the Python implementation</st> <st c="66793">of heapsort:</st>
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66758">这是堆排序的Python实现：</st>
- en: '[PRE35]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <st c="67038">Let’s examine the heapsort algorithm in</st> <st c="67079">an
    example:</st>
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67038">让我们通过一个例子来详细讨论堆排序算法：</st>
- en: '[PRE36]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <st c="67156">The output will be</st> <st c="67176">as follows:</st>
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67156">输出将会</st> <st c="67176">如下所示：</st>
- en: '[PRE37]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <st c="67221">The time</st> <st c="67230">complexity of heapsort is</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1084.png)<st
    c="67257"><st c="67268">, as building the heap takes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1071.png)<st
    c="67297"><st c="67298">, and each extraction of the maximum (in a max-heap) or
    minimum (in a min-heap) requires</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1047.png)
    <st c="67387"><st c="67396">over</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1271.png)
    <st c="67401"><st c="67402">elements.</st> <st c="67413">As discussed and demonstrated
    in</st> [*<st c="67446">Chapter 6</st>*](B22248_06.xhtml#_idTextAnchor081)<st
    c="67455">, the time complexity of heapsort cannot be better than</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1937.png)
    <st c="67511"><st c="67522">because it is a comparison-based sorting algorithm,
    which imposes a lower bound on the time complexity for such algorithms.</st> <st
    c="67646">Heapsort is an in-place sorting algorithm and its space complexity</st>
    <st c="67713">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)<st
    c="67716"><st c="67717">.</st></st></st></st></st></st></st>
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67221">堆排序的时间</st> <st c="67230">复杂度是</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1084.png)<st
    c="67257"><st c="67268">，因为构建堆需要</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mo><mml:mo>)</mml:mo></mml:math>](img/1071.png)<st
    c="67297"><st c="67298">，而每次提取最大值（在最大堆中）或最小值（在最小堆中）需要</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1047.png)
    <st c="67387"><st c="67396">，总共需要</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1271.png)
    <st c="67401"><st c="67402">个元素。</st> <st c="67413">正如在</st> [*<st c="67446">第6章</st>*](B22248_06.xhtml#_idTextAnchor081)<st
    c="67455">中讨论并展示的那样，堆排序的时间复杂度无法优于</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1937.png)
    <st c="67511"><st c="67522">，因为它是一种基于比较的排序算法，这对此类算法的时间复杂度设定了下界。</st> <st c="67646">堆排序是一种就地排序算法，其空间复杂度</st>
    <st c="67713">是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)<st
    c="67716"><st c="67717">。</st></st></st></st></st></st></st>
- en: <st c="67718">With the heap structure, we conclude our discussion on non-linear
    data structures.</st> <st c="67802">This chapter has provided key highlights of
    this important class of data structures, but it is not meant to serve as a comprehensive
    replacement for a dedicated book on data structures.</st> <st c="67988">It offers
    an overview, emphasizing their role in algorithm design, while more detailed exploration
    can be found in</st> <st c="68103">specialized texts.</st>
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67718">通过堆结构，我们结束了关于非线性数据结构的讨论。</st> <st c="67802">本章提供了这一重要数据结构类的关键要点，但并不打算作为一本专门讲解数据结构的书籍的全面替代。</st>
    <st c="67988">它提供了一个概览，强调了它们在算法设计中的作用，更多的细节可以在</st> <st c="68103">专业书籍中找到。</st>
- en: <st c="68121">Summary</st>
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="68121">总结</st>
- en: '<st c="68129">In this chapter, we explored the key concepts and applications
    of non-linear data structures, which are essential for designing efficient algorithms.</st>
    <st c="68280">We began by discussing the general properties of non-linear structures,
    highlighting how they differ from linear data structures in terms of organization
    and access patterns.</st> <st c="68455">Two major categories were covered in detail:
    graphs and trees.</st> <st c="68518">Graphs were presented as versatile structures
    for modeling relationships, while trees provided a more hierarchical organization
    of data.</st> <st c="68655">We examined different types of trees, such as BSTs,
    discussing their properties, operations, and use cases in</st> <st c="68765">algorithm
    design.</st>'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="68129">在本章中，我们探讨了非线性数据结构的关键概念和应用，这些结构对于设计高效的算法至关重要。</st> <st c="68280">我们首先讨论了非线性结构的一般特性，强调了它们在组织和访问模式方面与线性数据结构的不同。</st>
    <st c="68455">我们详细介绍了两个主要类别：图和树。</st> <st c="68518">图被介绍为建模关系的多功能结构，而树则提供了数据的更层次化的组织方式。</st>
    <st c="68655">我们考察了不同类型的树，如二叉搜索树，讨论了它们的特性、操作和在</st> <st c="68765">算法设计中的应用。</st>
- en: <st c="68782">The chapter concluded by focusing on heaps, a special form of
    binary tree that is commonly used in priority queues and sorting algorithms such
    as heapsort.</st> <st c="68939">We covered how heaps are constructed, how the
    heap property is maintained through insertion, deletion, and heapify operations,
    and the role heaps play in sorting.</st> <st c="69102">Overall, this chapter provided
    a foundational understanding of non-linear data structures and emphasized their
    significance in the efficient processing and manipulation of complex data relationships.</st>
    <st c="69302">By the end of this chapter, our discussion of algorithms comes to
    a close.</st> <st c="69377">However, in the next chapter, we will explore emerging
    trends and future directions in</st> <st c="69464">algorithm development.</st>
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="68782">本章以堆作为重点，堆是二叉树的一种特殊形式，广泛应用于优先队列和排序算法（如堆排序）中。</st> <st c="68939">我们介绍了堆的构建过程，如何通过插入、删除和堆化操作维护堆的性质，以及堆在排序中的作用。</st>
    <st c="69102">总体而言，本章为非线性数据结构提供了基础理解，并强调了它们在高效处理和操作复杂数据关系中的重要性。</st> <st c="69302">本章结束时，我们的算法讨论暂时告一段落。</st>
    <st c="69377">然而，在下一章中，我们将探讨算法发展中的新兴趋势和未来方向。</st>
- en: <st c="69486">References and further reading</st>
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="69486">参考文献及进一步阅读</st>
- en: '*<st c="69517">Introduction to Algorithms</st>*<st c="69544">. By Thomas H.</st>
    <st c="69559">Cormen, Charles E.</st> <st c="69578">Leiserson, Ronald L.</st>
    <st c="69599">Rivest, and Clifford Stein.</st> <st c="69627">Fourth Edition.</st>
    <st c="69643">MIT</st> <st c="69647">Press.</st> <st c="69654">2022:</st>'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="69517">《算法导论》</st>*<st c="69544">. 作者：Thomas H.</st> <st c="69559">Cormen,
    Charles E.</st> <st c="69578">Leiserson, Ronald L.</st> <st c="69599">Rivest,
    和 Clifford Stein.</st> <st c="69627">第四版.</st> <st c="69643">MIT</st> <st c="69647">出版社.</st>
    <st c="69654">2022年：</st>'
- en: '*<st c="69659">Chapter</st>* *<st c="69668">6</st>*<st c="69669">,</st> *<st
    c="69671">Heapsort</st>*'
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="69659">第六章</st>* *<st c="69668">6</st>*<st c="69669">,</st> *<st c="69671">堆排序</st>*'
- en: '*<st c="69679">Chapter 12</st>*<st c="69690">,</st> *<st c="69692">Binary</st>*
    *<st c="69699">Search Trees</st>*'
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="69679">第12章</st>*<st c="69690">,</st> *<st c="69692">二叉</st>* *<st
    c="69699">查找树</st>*'
- en: '*<st c="69711">Chapter 22</st>*<st c="69722">,</st> *<st c="69724">Elementary</st>*
    *<st c="69735">Graph Algorithms</st>*'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="69711">第22章</st>*<st c="69722">,</st> *<st c="69724">基础</st>* *<st
    c="69735">图算法</st>*'
- en: '*<st c="69751">Data Structures and Algorithm Analysis in C++.</st>* <st c="69798">By
    Mark A.</st> <st c="69810">Weiss.</st> <st c="69817">Fourth Edition.</st> <st
    c="69833">Pearson.</st> <st c="69842">2012:</st>'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="69751">《C++中的数据结构与算法分析》</st>* <st c="69798">. 作者：Mark A.</st> <st c="69810">Weiss.</st>
    <st c="69817">第四版.</st> <st c="69833">Pearson.</st> <st c="69842">2012年：</st>'
- en: '*<st c="69847">Chapter</st>* *<st c="69856">4</st>*<st c="69857">,</st> *<st
    c="69859">Trees</st>*'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="69847">第四章</st>* *<st c="69856">4</st>*<st c="69857">,</st> *<st c="69859">树</st>*'
- en: '*<st c="69864">Chapter 5</st>*<st c="69874">,</st> *<st c="69876">Binary</st>*
    *<st c="69883">Search Trees</st>*'
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="69864">第五章</st>*<st c="69874">,</st> *<st c="69876">二叉</st>* *<st c="69883">查找树</st>*'
- en: '*<st c="69895">Chapter</st>* *<st c="69904">6</st>*<st c="69905">,</st> *<st
    c="69907">Heaps</st>*'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="69895">第六章</st>* *<st c="69904">6</st>*<st c="69905">,</st> *<st c="69907">堆</st>*'
- en: '*<st c="69912">Chapter 9</st>*<st c="69922">,</st> *<st c="69924">Graph Algorithms</st>*'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="69912">第9章</st>*<st c="69922">,</st> *<st c="69924">图算法</st>*'
- en: '*<st c="69940">Algorithms</st>*<st c="69951">. By R.</st> <st c="69959">Sedgewick,
    K.</st> <st c="69973">Wayne.</st> <st c="69980">Fourth Edition.</st> <st c="69996">Addison-Wesley.</st>
    <st c="70012">2011.</st>'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="69940">算法</st>*<st c="69951">. 作者：R.</st> <st c="69959">Sedgewick，K.</st>
    <st c="69973">Wayne。</st> <st c="69980">第四版。</st> <st c="69996">Addison-Wesley出版社。</st>
    <st c="70012">2011年。</st>'
- en: '*<st c="70017">Chapter 3</st>*<st c="70027">,</st> *<st c="70029">Searching
    (Binary</st>* *<st c="70047">Search Trees)</st>*'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="70017">第3章</st>*<st c="70027">,</st> *<st c="70029">查找（二叉</st>* *<st
    c="70047">搜索树）</st>*'
- en: '*<st c="70060">Chapter 4</st>*<st c="70070">,</st> *<st c="70072">Sorting (Heapsort)</st>*'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="70060">第4章</st>*<st c="70070">,</st> *<st c="70072">排序（堆排序）</st>*'
- en: '*<st c="70090">Chapter</st>* *<st c="70099">5</st>*<st c="70100">,</st> *<st
    c="70102">Graphs</st>*'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="70090">第5章</st>* *<st c="70099">,</st>* <st c="70100">图</st>'
