- en: Geospatial Python Toolbox
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理空间Python工具箱
- en: The first three chapters of this book covered the history of geospatial analysis,
    the types of geospatial data that are used by analysts, and the major software
    and libraries found within the geospatial industry. We used some simple Python
    examples here and there to illustrate certain points, but we mainly focused on
    the field of geospatial analysis, independent of any specific technology. Starting
    here, we will be using Python to conquer geospatial analysis and we will continue
    with that approach for the rest of this book. This chapter explains the software
    you will need in your toolbox to do just about anything you want in the geospatial
    field.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前三章涵盖了地理空间分析的历史、分析师使用的地理空间数据类型以及地理空间行业中的主要软件和库。我们在某些地方使用了一些简单的Python示例来说明某些观点，但我们主要关注地理空间分析领域，而不考虑任何特定技术。从现在开始，我们将使用Python来征服地理空间分析，并将继续使用这种方法完成本书的其余部分。本章解释了您工具箱中所需的软件，以便在地理空间领域做几乎所有您想做的事情。
- en: We'll discover the Python libraries that are used to access the different types
    of data that were found in the vector data and raster data sections of [Chapter
    2](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml), *Learning Geospatial Data*. Some
    of these libraries are pure Python, as well as some of the bindings to the different
    software packages that we looked at in [Chapter 3](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml),
    *The Geospatial Technology Landscape*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发现用于访问[第2章](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml)“学习地理空间数据”中发现的矢量数据和栅格数据不同类型的Python库。其中一些库是纯Python，还有一些是我们[第3章](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml)“地理空间技术景观”中查看的不同软件包的绑定。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Installing third-party Python modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装第三方Python模块
- en: Python virtual environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python虚拟环境
- en: Conda
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Conda
- en: Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Python networking libraries for acquiring data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于获取数据的Python网络库
- en: Python tag-based parsers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python基于标签的解析器
- en: Python JSON libraries
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python JSON库
- en: OGR
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OGR
- en: PyShp
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyShp
- en: DBFPY
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DBFPY
- en: Shapely
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shapely
- en: GDAL
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDAL
- en: Fiona
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fiona
- en: NumPy
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy
- en: GeoPandas
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GeoPandas
- en: Python Imaging Library (PIL)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python图像库（PIL）
- en: PNGCanvas
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PNGCanvas
- en: ReportLab
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReportLab
- en: GeoPDF
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GeoPDF
- en: Python NetCDF libraries
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python NetCDF库
- en: Python HDF libraries
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python HDF库
- en: OSMnx
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSMnx
- en: Spatial indexing libraries
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间索引库
- en: Jupyter
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jupyter
- en: Conda
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Conda
- en: We will examine pure Python solutions whenever possible. Python is a very capable
    programming language, but some operations, particularly in remote sensing, are
    too computationally intensive and therefore are impractical when it comes to using
    pure Python or other interpreted languages. Fortunately, every aspect of geospatial
    analysis can be addressed in some way through Python, even if it is binding to
    a highly efficient C/C++/other compiled-language library.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，我们将检查纯Python解决方案。Python是一种非常强大的编程语言，但某些操作，尤其是在遥感领域，计算量过于庞大，因此在使用纯Python或其他解释型语言时不太实用。幸运的是，可以通过Python以某种方式解决地理空间分析的各个方面，即使它绑定到高度高效的C/C++/其他编译语言库。
- en: We will avoid using broad scientific libraries that cover other domains beyond
    geospatial analysis to keep the solutions as simple as possible. There are many
    reasons to use Python for geospatial analysis, but one of the strongest arguments
    is its portability.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将避免使用覆盖地理空间分析以外的其他领域的广泛科学库，以使解决方案尽可能简单。使用Python进行地理空间分析有许多原因，但其中最强有力的论据之一是其可移植性。
- en: Furthermore, Python has been ported to Java as the Jython distribution and to
    the .NET **Common Language Runtime** (**CLR**) as IronPython. Python also has
    versions such as Stackless Python for massively concurrent programs. There are
    versions of Python that are designed to run on cluster computers for distributed
    processing. Python is also available on many hosted application servers that do
    not allow you to install custom executables, such as the Google App Engine platform,
    which has a Python API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python已被移植到Java作为Jython发行版，以及到.NET **公共语言运行时**（**CLR**）作为IronPython。Python还有如Stackless
    Python这样的版本，适用于大量并发程序。还有专为在集群计算机上运行分布式处理而设计的Python版本。Python还可在许多托管应用程序服务器上使用，这些服务器不允许您安装自定义可执行文件，例如具有Python
    API的Google App Engine平台。
- en: Technical requirements
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Python 3.6 or higher
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.6或更高版本
- en: 'RAM: Minimum 6 GB (Windows), 8 GB (macOS) recommended 8 GB'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM：最小6 GB（Windows），推荐8 GB（macOS），建议8 GB
- en: 'Storage: Minimum 7200 RPM SATA with 20 GB of available space; recommended SSD
    with 40 GB of available space'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储：最小 7200 RPM SATA，可用空间 20 GB；推荐 SSD，可用空间 40 GB
- en: 'Processor: Minimum Intel Core i3 2.5 GHz; recommended Intel Core i5'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器：最小 Intel Core i3 2.5 GHz；推荐 Intel Core i5
- en: Installing third-party Python modules
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装第三方 Python 模块
- en: Modules written in pure Python (using the standard library) will mostly run
    on any of the 20 platforms that the Python ([https://www.python.org/](https://www.python.org/))
    website mentions. Each time you add a third-party module that relies on bindings
    to external libraries in other languages, you reduce Python's inherent portability.
    You also add a layer of complexity to fundamentally change the code by adding
    another language into the mix. Pure Python keeps things simple. Also, Python bindings
    to external libraries tend to be automatically or semi-automatically generated.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯 Python（使用标准库）编写的模块将在 Python 网站提到的 20 个平台中的任何一个上运行。每次你添加一个依赖于绑定到其他语言外部库的第三方模块时，你都会降低
    Python 的固有可移植性。你还在代码中添加了另一层复杂性，通过添加另一种语言来彻底改变代码。纯 Python 保持简单。此外，Python 对外部库的绑定通常是由自动或半自动生成的。
- en: These automatically generated bindings are very generic and esoteric, and they
    simply connect Python to a C/C++ API using the method names from that API, instead
    of following the best practices for Python. There are, of course, notable exceptions
    to this approach that are driven by project requirements which may include speed,
    unique library features, or frequently updated libraries where an automatically
    generated interface is preferable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自动生成的绑定非常通用且晦涩，它们只是通过使用该 API 的方法名将 Python 连接到 C/C++ API，而不是遵循 Python 的最佳实践。当然，也有一些值得注意的例外，这些例外是由项目需求驱动的，可能包括速度、独特的库功能或经常更新的库，在这些库中，自动生成的接口更可取。
- en: We'll make a distinction between modules that are included as a part of Python's
    standard library and modules that must be installed. In Python, the `words` module
    and library are used interchangeably. To install libraries, you either get them
    from the **Python Package Index **(**PyPI**) or in the case of a lot of geospatial
    modules, you download a specialized installer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Python 的标准库中包含的模块和必须安装的模块之间做出区分。在 Python 中，`words` 模块和库是通用的。要安装库，你可以从 **Python
    包索引（PyPI**） 获取，或者在许多地理空间模块的情况下，下载一个专门的安装程序。
- en: 'PyPI acts as the official software repository for libraries and offers some
    easy-to-use setup programs that simplify installing packages. You can use the
    `easy_install` program, which is especially good on Windows or the `pip` program
    that''s more commonly found on Linux and Unix systems. Once it''s installed, you
    can then install third-party packages by running the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: PyPI 作为官方的软件仓库，提供了一些易于使用的设置程序，简化了包的安装。你可以使用 `easy_install` 程序，它在 Windows 上特别有用，或者使用在
    Linux 和 Unix 系统上更常见的 `pip` 程序。一旦安装，你就可以通过运行以下代码来安装第三方包：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For installing `pip`, run the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `pip`，请运行以下代码：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This book will provide links and installation instructions for open source packages
    that are not available on the PyPI. You can manually install third-party Python
    modules by downloading the Python source code and putting it in your current working
    directory, or you can put it in your Python `site-packages` directory. These two
    directories are available in Python's search path when you try to import a module.
    If you put a module in your current working directory, it'll only be available
    when you start Python from that directory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将提供不在 PyPI 上可用的开源软件包的链接和安装说明。你可以通过下载 Python 源代码并将其放入当前工作目录，或者将其放入 Python 的
    `site-packages` 目录中来手动安装第三方 Python 模块。这两个目录在尝试导入模块时都可用在 Python 的搜索路径中。如果你将模块放入当前工作目录，它只会在你从该目录启动
    Python 时可用。
- en: 'If you put it in your `site-packages` directory, it''ll be available every
    time you start Python. The `site-packages` directory is specifically meant for
    third-party modules. To locate the `site-packages` directory for your installation,
    you need to ask Python''s `sys` module. The `sys` module has a `path` attribute
    that has a list of all the directories in Python''s search path. The `site-packages`
    directory should be the last one. You can locate it by specifying an index of
    `-1`, as shown in the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将其放在`site-packages`目录中，每次启动Python时它都将可用。`site-packages`目录专门用于第三方模块。为了定位您安装的`site-packages`目录，您需要询问Python的`sys`模块。`sys`模块有一个`path`属性，其中包含Python搜索路径中的所有目录。`site-packages`目录应该是最后一个。您可以通过指定索引`-1`来定位它，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If that call doesn''t return the `site-packages` path, just look at the entire
    list to locate it, as shown in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该调用没有返回`site-packages`路径，只需查看整个列表以定位它，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These installation methods will be used in the rest of this book. You can find
    the latest Python version, the source code for your platform installation, and
    compilation instructions at [http://python.org/download/](http://python.org/download/).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些安装方法将在本书的其余部分中使用。您可以在[http://python.org/download/](http://python.org/download/)找到最新的Python版本、您平台安装的源代码以及编译说明。
- en: The Python `virtualenv` module allows you to easily create an isolated copy
    of Python for a specific project without affecting your main Python installation
    or other projects. Using this module, you can have different projects with different
    versions of the same library. Once you have a working code base, you can keep
    it isolated from changes to the modules you used or even Python itself. The `virtualenv`
    module is simple to use and can be used for any example in this book; however,
    explicit instructions on its use are not included.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`virtualenv`模块允许您轻松地为特定项目创建一个隔离的Python副本，而不会影响您的主Python安装或其他项目。使用此模块，您可以拥有具有相同库的不同版本的不同项目。一旦您有一个工作代码库，您就可以将其与您使用的模块或甚至Python本身的变化隔离开来。`virtualenv`模块简单易用，可以用于本书中的任何示例；然而，关于其使用的明确说明并未包含。
- en: 'To get started with `virtualenv`, follow this simple guide: [http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用`virtualenv`，请遵循以下简单指南：[http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/)。
- en: Python virtualenv
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python虚拟环境
- en: Python geospatial analysis requires that we use a variety of modules with many
    dependencies. These modules often build on each other using specific versions
    of C or C++ libraries. You often run into version conflicts as you add Python
    modules to your system. Sometimes, when you upgrade a particular module, it might
    break your existing Python program due to changes in the API – or maybe you are
    running both Python 2 and Python 3 to take advantage of libraries written for
    each version. What you need is a way to safely install new modules without corrupting
    a working system or code. The solution to that issue is to use Python virtual
    environments through the `virtualenv` module.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python地理空间分析需要我们使用许多具有许多依赖关系的模块。这些模块通常使用特定版本的C或C++库相互构建。当您向系统中添加Python模块时，经常会遇到版本冲突。有时，当您升级特定模块时，由于API的变化，它可能会破坏您现有的Python程序——或者您可能同时运行Python
    2和Python 3以利用为每个版本编写的库。您需要的是一种安全安装新模块的方法，而不会破坏工作系统或代码。解决这个问题的方法是使用`virtualenv`模块的Python虚拟环境。
- en: 'The Python `virtualenv` module creates isolated, individual Python environments
    for each project so that you can avoid conflicting modules polluting your main
    Python installation. You can switch a particular environment on and off by activating
    it or deactivating it. The `virtualenv` module is efficient in that it doesn''t
    actually copy your entire system Python installation each time you create an environment.
    Let''s get started:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`virtualenv`模块为每个项目创建隔离的、独立的Python环境，这样您就可以避免冲突的模块污染您的主Python安装。您可以通过激活或停用特定环境来打开或关闭该环境。`virtualenv`模块在效率上很高，因为它在创建环境时实际上并不复制您整个系统Python安装。让我们开始吧：
- en: 'Installing `virtualenv` is as simple as running the following code:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`virtualenv`就像运行以下代码一样简单：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, create a directory for your virtual Python environments. Name it whatever
    you want:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为您的虚拟Python环境创建一个目录。命名它 whatever you want：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, you can create your first virtual environment using the following command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下命令创建您的第一个虚拟环境：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, after entering the following command, you can activate the environment:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在输入以下命令后，你可以激活该环境：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, when you run any Python commands in that directory, it will use the isolated
    virtual environment. When you''re done, you can deactivate that environment with
    the following simple command:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你在这个目录中运行任何 Python 命令时，它将使用隔离的虚拟环境。当你完成时，你可以使用以下简单的命令来停用该环境：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is how you install, activate for use, and deactivate the `virtualenv` module.
    There's one other environment you should know about, however. We'll examine that
    next.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是安装、激活以供使用以及停用 `virtualenv` 模块的方法。然而，你还需要了解另一个环境。我们将在下一节中检查它。
- en: Conda
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Conda
- en: It's also worth mentioning Conda here, which is an open source, cross-platform
    package management system that can also create and manage environments similar
    to `virtualenv`. Conda makes it easy to install complex packages, including geospatial
    ones. It also works with other languages besides Python, including R, Node.js,
    and Java.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里也值得提一下 Conda，它是一个开源的、跨平台的包管理系统，也可以创建和管理类似于 `virtualenv` 的环境。Conda 使得安装复杂的包变得容易，包括地理空间包。它还支持
    Python 之外的其他语言，包括 R、Node.js 和 Java。
- en: Conda is available here: [https://docs.conda.io/en/latest/](https://docs.conda.io/en/latest/).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Conda 可在此处找到：[https://docs.conda.io/en/latest/](https://docs.conda.io/en/latest/)。
- en: Now, let's check out how to install GDAL so that we can start processing geospatial
    data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何安装 GDAL，这样我们就可以开始处理地理空间数据了。
- en: Installing GDAL
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 GDAL
- en: The **Geospatial Data Abstraction Library** (**GDAL**), which includes OGR,
    is critical to many of the examples in this book and is also one of the more complicated
    Python setups. For these reasons, we'll discuss it separately here. The latest
    GDAL bindings are available on PyPI; however, the installation requires a few
    more steps because of additional resources that are needed by the GDAL library.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**地理空间数据抽象库**（**GDAL**），包括 OGR，对于本书中的许多示例至关重要，也是更复杂的 Python 设置之一。因此，我们将在这里单独讨论它。最新的
    GDAL 绑定可在 PyPI 上找到；然而，由于 GDAL 库需要额外的资源，安装需要额外的步骤。'
- en: 'There are three ways to install GDAL for use with Python. You can use any one
    of them:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以安装 GDAL 以用于 Python。你可以使用其中任何一种：
- en: Compile it from the source code.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源代码编译它。
- en: Install it as part of a larger software package.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为更大软件包的一部分安装它。
- en: Install a binary distribution and then the Python bindings.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装二进制发行版，然后安装 Python 绑定。
- en: If you have experience with compiling C libraries as well as the required compiler
    software, then the first option gives you the most control. However, it is not
    recommended if you just want to get going as quickly as possible, because even
    experienced software developers can find compiling GDAL and the associated Python
    bindings challenging. Instructions for compiling GDAL on leading platforms can
    be found at [http://trac.osgeo.org/gdal/wiki/BuildHints](http://trac.osgeo.org/gdal/wiki/BuildHints).
    There are also basic build instructions on the PyPI GDAL page; have a look at
    [https://pypi.python.org/pypi/GDAL](https://pypi.python.org/pypi/GDAL).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你也有编译 C 库以及所需编译软件的经验，那么第一个选项会给你最大的控制权。然而，如果你只是想尽快开始，那么这个选项并不推荐，因为即使是经验丰富的软件开发者也会发现编译
    GDAL 和相关的 Python 绑定具有挑战性。在主要平台上的 GDAL 编译说明可以在 [http://trac.osgeo.org/gdal/wiki/BuildHints](http://trac.osgeo.org/gdal/wiki/BuildHints)
    找到；PyPI GDAL 页面上也有基本的构建说明；请查看 [https://pypi.python.org/pypi/GDAL](https://pypi.python.org/pypi/GDAL)。
- en: The second option is by far the quickest and easiest. The **Open Source Geospatial
    Foundation** (**OSGeo**) distributes an installer called OSGeo4W, which installs
    all of the top open source geospatial packages on Windows at the click of a button.
    OSGeo4W can be found at [http://trac.osgeo.org/osgeo4w/](http://trac.osgeo.org/osgeo4w/).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项无疑是最快和最简单的方法。**开源地理空间基金会**（**OSGeo**）分发了一个名为 OSGeo4W 的安装程序，只需点击一下按钮即可在
    Windows 上安装所有顶级开源地理空间包。OSGeo4W 可在 [http://trac.osgeo.org/osgeo4w/](http://trac.osgeo.org/osgeo4w/)
    找到。
- en: While these packages are the easiest to work with, they come with their own
    version of Python. If you already have Python installed, then having another Python
    distribution just to use certain libraries may be problematic. In that case, the
    third option may be for you.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些包最容易使用，但它们带有自己的 Python 版本。如果你已经安装了 Python，那么仅为了使用某些库就安装另一个 Python 发行版可能会出现问题。在这种情况下，第三个选项可能适合你。
- en: The third option installs a pre-compiled binary specific to your Python version.
    This method is the best compromise between ease of installation and customization.
    The catch is that you must make sure the binary distributions and the corresponding
    Python bindings are compatible with each other, your Python version, and in many
    cases your operating system configuration.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项安装了针对您的Python版本预编译的二进制文件。这种方法在安装简便性和定制之间提供了最佳折衷。但是，您必须确保二进制发行版和相应的Python绑定彼此兼容，与您的Python版本兼容，并且在许多情况下与您的操作系统配置兼容。
- en: Windows
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows
- en: 'The installation of GDAL for Python on Windows becomes easier and easier each
    year. To install GDAL on Windows, you must check whether you are running the 32-bit
    or 64-bit version of Python:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每年，Windows上Python的GDAL安装都变得越来越容易。要在Windows上安装GDAL，您必须检查您是否正在运行32位或64位版本的Python：
- en: 'To do so, just start your Python interpreter at a Command Prompt, as shown
    in the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，只需在命令提示符中启动Python解释器，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Based on this instance, we can see that Python is version 3.4.2 for `win32`,
    which means it is the 32-bit version. Once you have this information, go to the
    following URL: [http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal](http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于此实例，我们可以看到Python版本为3.4.2的`win32`，这意味着它是32位版本。一旦您有了这些信息，请访问以下URL：[http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal](http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal)。
- en: This web page contains Python Windows binaries and bindings for nearly every
    open source scientific library. On that web page, in the GDAL section, find the
    release that matches your version of Python. The release names use the abbreviation
    `cp` for C Python, followed by the major Python version number and either `win32`
    for 32-bit Windows or `win_amd64` for 64-bit Windows.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个网页包含了适用于几乎所有开源科学库的Python Windows二进制文件和绑定。在该网页的GDAL部分，找到与您的Python版本匹配的版本。版本名称使用C
    Python的缩写`cp`，后跟主要的Python版本号，以及32位Windows的`win32`或64位Windows的`win_amd64`。
- en: In the previous example, we would download the file named `GDAL-1.11.3-cp34-none-win32.whl`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们会下载名为`GDAL-1.11.3-cp34-none-win32.whl`的文件。
- en: 'This download package is in the newer Python `pip` wheel format. To install
    it, simply open a Command Prompt and type in the following code:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此下载包是较新的Python `pip` wheel格式。要安装它，只需打开命令提示符并输入以下代码：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once the package has been installed, open your Python interpreter and run the
    following commands to verify that GDAL is installed by checking its version:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦安装了包，打开Python解释器并运行以下命令，通过检查其版本来验证GDAL是否已安装：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, GDAL should return its version as `1.11.3`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，GDAL应该返回版本号`1.11.3`。
- en: If you have trouble installing modules using `easy_install` or `pip` and PyPI,
    try to download and install the wheel package from the same site as the GDAL example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在使用`easy_install`或`pip`和PyPI安装模块时遇到问题，请尝试从与GDAL示例相同的网站下载并安装wheel包。
- en: Linux
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: 'GDAL installation on Linux varies widely by distribution. The following [https://gdal.org](https://gdal.org)
    binaries web page lists the installation instructions for several distributions:
    [http://trac.osgeo.org/gdal/wiki/DownloadingGdalBinaries](http://trac.osgeo.org/gdal/wiki/DownloadingGdalBinaries).
    Let''s get started:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Linux上的GDAL安装因发行版而异。以下[https://gdal.org](https://gdal.org)二进制网页列出了几个发行版的安装说明：[http://trac.osgeo.org/gdal/wiki/DownloadingGdalBinaries](http://trac.osgeo.org/gdal/wiki/DownloadingGdalBinaries)。让我们开始吧：
- en: 'Typically, your package manager will install both GDAL and Python bindings.
    For example, on Ubuntu, to install GDAL, you need to run the following code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，您的包管理器会安装GDAL和Python绑定。例如，在Ubuntu上，要安装GDAL，您需要运行以下代码：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, to install the Python bindings, you can run the following command:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，要安装Python绑定，您可以运行以下命令：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Most Linux distributions are set up to compile software already, and their instructions
    are much simpler than those on Windows.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数Linux发行版已经配置好了编译软件，它们的说明比Windows上的简单得多。
- en: 'Depending on the installation, you may have to import `gdal` and `ogr` as part
    of the `osgeo` package, as shown in the following command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据安装情况，您可能需要将`gdal`和`ogr`作为`osgeo`包的一部分导入，如下面的命令所示：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: macOS X
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS X
- en: To install GDAL on macOS X, you can also use the Homebrew package management
    system, which is available at [http://brew.sh/](http://brew.sh/).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要在macOS X上安装GDAL，您还可以使用Homebrew包管理系统，该系统可在[http://brew.sh/](http://brew.sh/)找到。
- en: Alternatively, you can use the MacPorts package management system, which is
    available at [https://www.macports.org/](https://www.macports.org/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用 MacPorts 软件包管理系统，该系统可在 [https://www.macports.org/](https://www.macports.org/)
    获取。
- en: Both of these systems are well-documented and contain GDAL packages for Python
    3\. You only really need them for libraries that require a properly compiled binary
    written in C that has a lot of dependencies and includes many of the scientific
    and geospatial libraries.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个系统都有很好的文档记录，并包含适用于 Python 3 的 GDAL 包。你实际上只需要它们用于需要正确编译的二进制文件（用 C 语言编写，具有许多依赖项并包含许多科学和地理空间库）的库。
- en: Python networking libraries for acquiring data
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 网络库用于获取数据
- en: The vast majority of geospatial data sharing is accomplished via the internet,
    and Python is well equipped when it comes to networking libraries for almost any
    protocol. Automated data downloads are often an important step in automating a
    geospatial process. Data is typically retrieved from a website's **Uniform Resource
    Locator** (**URL**) or **File Transfer Protocol** (**FTP**) server and, because
    geospatial datasets often contain multiple files, data is often distributed as
    ZIP files.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数地理空间数据共享都是通过互联网完成的，Python 在处理几乎任何协议的网络库方面都准备得很充分。自动数据下载通常是自动化地理空间过程的一个重要步骤。数据通常从网站的 **统一资源定位符**
    (**URL**) 或 **文件传输协议** (**FTP**) 服务器检索，由于地理空间数据集通常包含多个文件，因此数据通常以 ZIP 文件的形式分发。
- en: A nice feature of Python is its concept of a file-like object. Most Python libraries
    that read and write data use a standard set of methods that allow you to access
    data from different types of resources, as if you were writing a simple file on
    disk. The networking modules in the Python standard library use this convention
    as well. The benefit of this approach is that it allows you to pass file-like
    objects to other libraries and methods, which recognize the convention without
    a lot of setup for different types of data that are distributed in different ways.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的一个优点是其文件类似对象的概念。大多数用于读取和写入数据的 Python 库都使用一组标准方法，允许您从不同类型的资源访问数据，就像您在磁盘上写入一个简单的文件一样。Python
    标准库中的网络模块也使用这种约定。这种方法的优点是它允许您将文件类似对象传递给其他库和方法，这些库和方法可以识别该约定，而无需为以不同方式分发的不同类型的数据进行大量设置。
- en: The Python urllib module
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 的 urllib 模块
- en: The Python `urllib` package is designed for simple access to any file with a
    URL address. The `urllib` package in Python 3 consists of several modules that
    handle different parts of managing web requests and responses. These modules implement
    some of Python's file-like object conventions, starting with its `open()` method.
    When you call `open()`, it prepares a connection to the resource but does not
    access any data. Sometimes, you just want to grab a file and save it to disk,
    instead of accessing it in memory. This function is available through the `urllib.request.retrieve()`
    method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `urllib` 包旨在简单访问任何具有 URL 地址的文件。Python 3 中的 `urllib` 包由几个模块组成，这些模块处理管理网络请求和响应的不同部分。这些模块实现了
    Python 的一些文件类似对象约定，从其 `open()` 方法开始。当你调用 `open()` 时，它会准备与资源的连接，但不会访问任何数据。有时，你只想获取一个文件并将其保存到磁盘上，而不是将其加载到内存中。这个功能可以通过
    `urllib.request.retrieve()` 方法获得。
- en: 'The following example uses the `urllib.request.retrieve()` method to download
    the zipped shapefile named `hancock.zip`, which is used in other examples. We
    define the URL and the local filename as variables. The URL is passed as an argument,
    as well as the filename we want to use, to save it to our local machine, which,
    in this case, is just `hancock.zip`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用 `urllib.request.retrieve()` 方法下载名为 `hancock.zip` 的压缩形状文件，该文件在其他示例中使用。我们定义了
    URL 和本地文件名作为变量。URL 作为参数传递，以及我们想要使用的文件名，以将其保存到我们的本地机器上，在这种情况下，只是 `hancock.zip`：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The message from the underlying `httplib` module confirms that the file was
    downloaded to the current directory. The URL and filename could have been passed
    to the `retrieve()` method directly as strings as well. If you specify just the
    filename, the download saves to the current working directory. You can also specify
    a fully qualified pathname to save it somewhere else. You can also specify a callback
    function as a third argument, which will receive download status information for
    the file so that you can create a simple download status indicator or perform
    some other action.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 来自底层`httplib`模块的消息确认文件已下载到当前目录。URL和文件名也可以直接作为字符串传递给`retrieve()`方法。如果你只指定文件名，下载将保存到当前工作目录。你也可以指定一个完全限定的路径名来将其保存到其他位置。你还可以指定一个回调函数作为第三个参数，该函数将接收文件的下载状态信息，这样你就可以创建一个简单的下载状态指示器或执行其他操作。
- en: The `urllib.request.urlopen()` method allows you to access an online resource
    with more precision and control. As we mentioned previously, it implements most
    of the Python file-like object methods with the exception of the `seek()` method,
    which allows you to jump to arbitrary locations within a file. You can read a
    file online one line at a time, read all the lines as a list, read a specified
    number of bytes, or iterate through each line of the file. All of these functions
    are performed in memory, so you don't have to store the data on disk. This ability
    is useful for accessing frequently updated data online that you may want to process
    without saving to disk.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`urllib.request.urlopen()`方法允许你以更高的精度和控制访问在线资源。正如我们之前提到的，它实现了大多数Python文件类似对象方法，除了`seek()`方法，它允许你在文件中的任意位置跳转。你可以逐行读取在线文件，将所有行作为列表读取，读取指定数量的字节，或者遍历文件的每一行。所有这些功能都在内存中执行，因此你不需要将数据存储在磁盘上。这种能力对于访问可能需要处理但不想保存到磁盘上的在线频繁更新的数据非常有用。'
- en: 'In the following example, we demonstrate this concept by accessing the **United
    States Geological Survey** (**USGS**) earthquake feed to view all of the earthquakes
    in the world that have occurred within the last hour. This data is distributed
    as a **Comma-Separated Value** (**CSV**) file, which we can read line by line
    like a text file. CSV files are similar to spreadsheets and can be opened in a
    text editor or spreadsheet program:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们通过访问**美国地质调查局**（**USGS**）地震源来演示这个概念，查看在过去一小时内发生的所有地震。这些数据以**逗号分隔值**（**CSV**）文件的形式分发，我们可以像文本文件一样逐行读取。CSV文件类似于电子表格，可以在文本编辑器或电子表格程序中打开：
- en: First, you need to open the URL and read the header with the column names in
    the file.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要打开URL并读取包含文件列名的标题。
- en: 'Then, you need to read the first line, which contains a record of a recent
    earthquake, as shown in the following lines of code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要读取第一行，其中包含最近地震的记录，如下面的代码行所示：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can also iterate through this file, which is a memory-efficient way to read
    through large files.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以遍历这个文件，这是一种读取大文件的内存高效方式。
- en: 'If you are running this example in the Python interpreter, you will need to
    press the *Enter* or *return* key twice to execute the loop. This action is necessary
    because it signals to the interpreter that you are done building the loop. In
    the following example, we abbreviate the output:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在这个Python解释器中运行这个示例，你需要按下*Enter*或*return*键两次来执行循环。这个动作是必要的，因为它向解释器发出信号，表明你已经完成了循环的构建。在下面的示例中，我们简化了输出：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Python requests module
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python请求模块
- en: 'The `urllib` module has been around for a long time. Another third-party module
    has been developed to make common HTTP requests even easier. The `requests` module
    has the following features:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`urllib`模块已经存在很长时间了。另一个第三方模块已经被开发出来，使得常见的HTTP请求更加容易。`requests`模块具有以下功能：'
- en: Keep-alive and connection pooling
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持连接和连接池
- en: International domains and URLs
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际域名和URL
- en: Sessions with cookie persistence
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话中保持cookie持久性
- en: Browser-style SSL verification
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器风格的SSL验证
- en: Automatic content decoding
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动内容解码
- en: Basic/digest authentication
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本摘要认证
- en: Elegant key/value cookies
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精美的键/值cookie
- en: Automatic decompression
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动解压缩
- en: Unicode response bodies
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode响应体
- en: HTTP(S) proxy Support
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP(S)代理支持
- en: Multipart file uploads
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多部分文件上传
- en: Streaming downloads
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式下载
- en: Connection timeouts
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接超时
- en: Chunked requests
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分块请求
- en: '`.netrc` support'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.netrc`支持'
- en: 'In the following example, we''ll download the same ZIP file we downloaded with
    the `urllib` module, except this time using the `requests` module. First, we need
    to install the `requests` module:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将下载与使用`urllib`模块下载的相同ZIP文件，但这次我们将使用`requests`模块。首先，我们需要安装`requests`模块：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we can import it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以导入它：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we can set up our variables for the URL and the output filename:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以设置URL和输出文件名的变量：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Retrieving the ZIP file is as simple as using the `requests` module''s `get()`
    method:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`requests`模块的`get()`方法检索ZIP文件非常简单：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we can get the content from the `.zip` file and write it to our output
    file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从`.zip`文件中获取内容并将其写入我们的输出文件：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `requests` module has many more advanced features that are just as easy
    to use as this example. Now that we know how to get information via the HTTP protocol,
    let's examine the FTP protocol which is often used to access geospatial data from
    online archives.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests`模块还有许多其他高级功能，使用起来与这个例子一样简单。现在我们知道了如何通过HTTP协议获取信息，让我们来检查FTP协议，它通常用于从在线存档访问地理空间数据。'
- en: FTP
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP
- en: FTP allows you to browse an online directory and download data using FTP client
    software. Until around 2004, when geospatial web services became very common,
    FTP was one of the most common ways to distribute geospatial data. FTP is less
    common now, but you occasionally encounter it when you're searching for data.
    Once again Python's batteries-included standard library has a reasonable FTP module
    called `ftplib` with a main class called `FTP()`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: FTP允许你使用FTP客户端软件浏览在线目录并下载数据。直到大约2004年，当地理空间网络服务变得非常普遍之前，FTP是分发地理空间数据最常见的方式之一。现在FTP不太常见，但在搜索数据时偶尔会遇到它。再次强调，Python的内置标准库有一个名为`ftplib`的合理FTP模块，其主要类名为`FTP()`。
- en: 'In the following example, we will do the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将执行以下操作：
- en: We will access an FTP server hosted by the US **National Oceanic and Atmospheric
    Administration** (**NOAA**) to access a text file containing data from the **Deep-ocean
    Assessment and Reporting of Tsunamis** (**DART**) buoy network that's used to
    watch for tsunamis around the world. This particular buoy is off the coast of
    Peru.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将访问由美国**国家海洋和大气管理局**（**NOAA**）托管的FTP服务器，以访问包含全球海啸监测网络**深海评估和报告**（**DART**）浮标数据的文本文件。这个特定的浮标位于秘鲁海岸。
- en: We'll define the server and the directory path, and then we will access the
    server. All FTP servers require a username and password. Most public servers have
    a user called anonymous with the password as anonymous, just like this one does.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义服务器和目录路径，然后我们将访问服务器。所有FTP服务器都需要用户名和密码。大多数公共服务器都有一个名为anonymous的用户，密码也是anonymous，就像这个服务器一样。
- en: Using Python's `ftplib`, you can just call the `login()` method without any
    arguments to log in as the default anonymous user. Otherwise, you can add the
    username and password as string arguments.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python的`ftplib`，你可以不带任何参数调用`login()`方法以默认匿名用户身份登录。否则，你可以添加用户名和密码作为字符串参数。
- en: Once we're logged in, we'll change to the directory containing the DART datafile.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，我们将切换到包含DART数据文件的目录。
- en: To download the file, we'll open up a local file called out and pass its `write()`
    method as a callback function to the `ftplib.ftp.retrbinary()` method, which simultaneously
    downloads the file and writes it to our local file.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要下载文件，我们将打开一个名为out的本地文件，并将它的`write()`方法作为回调函数传递给`ftplib.ftp.retrbinary()`方法，该方法同时下载文件并将其写入我们的本地文件。
- en: Once the file has been downloaded, we can close it to save it.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件下载完成后，我们可以关闭它以保存它。
- en: 'Then, we''ll read the file and look for the line containing the latitude and
    longitude of the buoy to make sure that the data was downloaded successfully,
    as shown in the following lines of code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将读取文件并查找包含浮标纬度和经度的行，以确保数据已成功下载，如下面的代码行所示：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, we opened the local file in binary write mode, and we used
    the `retrbinary() ftplib` method, as opposed to `retrlines()`, which uses ASCII
    mode. The binary mode works for both ASCII and binary files, so it's always a
    safer bet. In fact, in Python, the binary read and write modes for a file are
    only required on Windows.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们以二进制写入模式打开了本地文件，并使用了`retrbinary()``ftplib`方法，而不是使用ASCII模式的`retrlines()`。二进制模式适用于ASCII和二进制文件，因此始终是一个更安全的赌注。实际上，在Python中，文件的二进制读写模式仅在Windows上需要。
- en: 'If you are just downloading a simple file from an FTP server, many FTP servers
    have a web interface as well. In that case, you could use `urllib` to read the
    file. FTP URLs use the following format to access data:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是从FTP服务器下载一个简单的文件，许多FTP服务器也有一个网络界面。在这种情况下，你可以使用`urllib`来读取文件。FTP URL使用以下格式来访问数据：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This format is insecure for password-protected directories because you are
    transmitting your login information over the internet. But for anonymous FTP servers,
    there is no additional security risk. To demonstrate this, the following example
    accesses the same file that we just saw but by using `urllib` instead of `ftplib`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式对于密码保护的目录来说是不安全的，因为你正在通过互联网传输你的登录信息。但对于匿名FTP服务器来说，没有额外的安全风险。为了演示这一点，以下示例通过使用`urllib`而不是`ftplib`来访问我们刚刚看到的相同文件：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that we can download files, let's learn how to decompress them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以下载文件了，让我们学习如何解压缩它们。
- en: ZIP and TAR files
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZIP和TAR文件
- en: Geospatial datasets often consist of multiple files. For this reason, they are
    often distributed as ZIP or TAR file archives. These formats can also compress
    data, but their ability to bundle multiple files is the primary reason they are
    used for geospatial data. While the TAR format doesn't contain a compression algorithm,
    it incorporates gzip compression and offers it as a program option. Python has
    standard modules for reading and writing both ZIP and TAR archives. These modules
    are called `zipfile` and `tarfile`, respectively.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 地理空间数据集通常由多个文件组成。因此，它们通常以ZIP或TAR文件归档的形式分发。这些格式也可以压缩数据，但它们捆绑多个文件的能力是它们被用于地理空间数据的主要原因。虽然TAR格式不包含压缩算法，但它结合了gzip压缩，并将其作为程序选项提供。Python有用于读取和写入ZIP和TAR归档的标准模块。这些模块分别称为`zipfile`和`tarfile`。
- en: 'The following example extracts the `hancock.shp`, `hancock.shx`, and `hancock.dbf`
    files contained in the `hancock.zip` file we downloaded using `urllib` for use
    in the previous examples. This example assumes that the ZIP file is in the current
    directory:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`urllib`下载的`hancock.zip`文件中的`hancock.shp`、`hancock.shx`和`hancock.dbf`文件，用于在之前的示例中使用。此示例假定ZIP文件位于当前目录中：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This example is more verbose than necessary for clarity. We can shorten this
    example and make it more robust by using a `for` loop around the `zipfile.namelist()`
    method without explicitly defining the different files as variables. This method
    is a more flexible and Pythonic approach, and could be used on ZIP archives with
    unknown contents, as shown in the following lines of code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子比必要的更详细，为了清晰起见。我们可以通过在`zipfile.namelist()`方法周围使用`for`循环来缩短这个例子，并使其更健壮，而不必明确地将不同的文件定义为变量。这种方法是一种更灵活且更Pythonic的方法，可以用于具有未知内容的ZIP归档，如下面的代码行所示：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that you understand the basics of the `zipfile` module, let''s take the
    files we just unzipped and create a TAR archive with them. In this example, when
    we open the TAR archive for writing, we specify the write mode as `w:gz` for gzipped
    compression. We also specify the file extension as `tar.gz` to reflect this mode,
    as shown in the following lines of code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了`zipfile`模块的基础知识，让我们用我们刚刚解压的文件创建一个TAR归档。在这个例子中，当我们打开TAR归档进行写入时，我们指定写入模式为`w:gz`以进行gzip压缩。我们还指定文件扩展名为`tar.gz`以反映这种模式，如下面的代码行所示：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can extract the files using the simple `tarfile.extractall()` method. First,
    we open the file using the `tarfile.open()` method and then extract it, as shown
    in the following lines of code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用简单的`tarfile.extractall()`方法提取文件。首先，我们使用`tarfile.open()`方法打开文件，然后提取它，如下面的代码行所示：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We'll work on one more example by combining elements we've learned in this chapter
    as well as the elements in the vector data section of [Chapter 2](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml),
    *Learning Geospatial Data*. We'll read the bounding box coordinates from the `hancock.zip`
    file without ever saving it to disk. We'll use the power of Python's file-like
    object convention to pass around the data. Then, we'll use Python's `struct` module
    to read the bounding box, like we did in [Chapter 2](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml), *Learning
    Geospatial Data*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过结合本章学到的元素以及[第2章](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml)“学习地理空间数据”中向量数据部分的元素来工作一个额外的示例。我们将从`hancock.zip`文件中读取边界框坐标，而无需将其保存到磁盘。我们将使用Python的文件-like对象约定来传递数据。然后，我们将使用Python的`struct`模块来读取边界框，就像我们在[第2章](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml)“学习地理空间数据”中所做的那样。
- en: 'In this case, we read the unzipped `.shp` file into a variable and access the
    data using Python array slicing by specifying the starting and ending indexes
    of the data separated by a colon (`:`). We are able to use list slicing because
    Python allows you to treat strings as lists. In this example, we also use Python''s
    `StringIO` module to temporarily store data in memory in a file-like object that
    implements various methods, including the `seek()` method, which is absent from
    most Python networking modules, as shown in the following lines of code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将未压缩的`.shp`文件读入一个变量，并通过指定数据起始和结束索引（由冒号`:`分隔）使用Python数组切片来访问数据。我们能够使用列表切片，因为Python允许您将字符串视为列表。在这个例子中，我们还使用了Python的`StringIO`模块，以文件对象的形式在内存中临时存储数据，该对象实现了包括`seek()`方法在内的各种方法，而`seek()`方法在大多数Python网络模块中是缺失的，如下面的代码行所示：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see from the examples so far, Python's standard library packs a lot
    of punch. Most of the time, you don't have to download a third-party library just
    to access a file online.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从迄今为止的示例中看到的，Python的标准库包含了很多功能。大多数时候，您不需要下载第三方库就能访问在线文件。
- en: Python markup and tag-based parsers
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python标记和基于标签的解析器
- en: Tag-based data, particularly different XML dialects, have become a very popular
    way to distribute geospatial data. Formats that are both machine and human-readable
    are generally easy to work with, though they sacrifice storage efficiency for
    usability. These formats can become unmanageable for very large datasets but work
    very well in most cases.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 基于标签的数据，尤其是不同的XML方言，已经成为分发地理空间数据的一种非常流行的方式。既适合机器阅读又适合人类阅读的格式通常易于处理，尽管它们为了可用性牺牲了存储效率。这些格式对于非常大的数据集可能难以管理，但在大多数情况下工作得很好。
- en: While most formats are some form of XML (such as KML or GML), there is a notable
    exception. The **Well-Known Text** (**WKT**) format is fairly common but uses
    external markers and square brackets (`[]`) to surround data instead of tags in
    angled brackets around data like XML does.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数格式都是某种形式的XML（例如KML或GML），但有一个显著的例外。**已知文本**（**WKT**）格式相当常见，但使用外部标记和方括号（`[]`）来包围数据，而不是像XML那样使用尖括号包围数据。
- en: Python has standard library support for XML, as well as some excellent third-party
    libraries available. Proper XML formats all follow the same structure, so you
    can use a generic XML library to read it. Because XML is text-based, it is often
    easy to write it as a string instead of using an XML library. The vast majority
    of applications that output XML do so in this way.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Python对XML有标准库支持，还有一些优秀的第三方库可用。所有合适的XML格式都遵循相同的结构，因此您可以使用通用的XML库来读取它。因为XML是基于文本的，所以通常很容易将其作为字符串编写，而不是使用XML库。大多数输出XML的应用程序都是这种方式。
- en: The primary advantage of using XML libraries for writing XML is that your output
    is usually validated. It is very easy to create an error while creating your own
    XML format. A single missing quotation mark can derail an XML parser and throw
    an error for somebody trying to read your data. When these errors happen, they
    virtually render your dataset useless. You will find that this problem is very
    common among XML-based geospatial data. What you'll discover is that some parsers
    are more forgiving with incorrect XML than others. Often, reliability is more
    important than speed or memory efficiency.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用XML库编写XML的主要优势是您的输出通常经过验证。在创建自己的XML格式时，很容易出错。单个缺失的引号就可以使XML解析器崩溃，并给试图读取您数据的人抛出错误。当这些错误发生时，它们几乎使您的数据集变得无用。您会发现这个问题在基于XML的地理空间数据中非常普遍。您会发现一些解析器对不正确的XML比其他解析器更宽容。通常，可靠性比速度或内存效率更重要。
- en: The analysis that's available at [http://lxml.de/performance.html](http://lxml.de/performance.html)
    provides benchmarks for memory and speed among the different Python XML parsers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://lxml.de/performance.html](http://lxml.de/performance.html)提供的分析中，提供了不同Python
    XML解析器在内存和速度方面的基准。
- en: The minidom module
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: minidom模块
- en: The Python `minidom` module is a very old and simple to use XML parser. It is
    part of Python's built-in set of XML tools in the XML package. It can parse XML
    files or XML that's been fed in as a string. The `minidom` module is best for
    small to medium-sized XML documents of less than about 20 MB before speed begins
    to decrease.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`minidom`模块是一个非常古老且易于使用的XML解析器。它是Python XML包内建的一组XML工具的一部分。它可以解析XML文件或作为字符串输入的XML。`minidom`模块最适合小于约20
    MB的小到中等大小的XML文档，因为在此之前的速度开始下降。
- en: 'To demonstrate the `minidom` module, we''ll use a sample KML file, which is
    a part of Google''s KML documentation that you can download. The data that''s
    available at the following link represents time-stamped point locations that have
    been transferred from a GPS device: [https://github.com/GeospatialPython/Learn/raw/master/time-stamp-point.kml](https://github.com/GeospatialPython/Learn/raw/master/time-stamp-point.kml).
    Let''s get started:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 `minidom` 模块，我们将使用一个示例 KML 文件，这是 Google KML 文档的一部分，你可以下载。以下链接中的数据代表从 GPS
    设备传输的时间戳点位置：[https://github.com/GeospatialPython/Learn/raw/master/time-stamp-point.kml](https://github.com/GeospatialPython/Learn/raw/master/time-stamp-point.kml)。让我们开始吧：
- en: 'First, we''ll parse this data by reading it in from the file and creating a
    `minidom` parser object. The file contains a series of `<Placemark>` tags, which
    contain a point and a timestamp at which that point was collected. So, we''ll
    get a list of all of the `Placemarks` in the file, and we can count them by checking
    the length of that list, as shown in the following lines of code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将通过从文件中读取数据并创建一个 `minidom` 解析器对象来解析这些数据。文件包含一系列 `<Placemark>` 标签，这些标签包含一个点和收集该点的时间戳。因此，我们将获取文件中所有
    `Placemarks` 的列表，并且可以通过检查该列表的长度来计数，如下面的代码行所示：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, we retrieved all `Placemarks`, which totaled `361`. Now, let''s
    take a look at the first `Placemark` element in the list:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，我们检索了所有的 `Placemark`，总数为 `361`。现在，让我们看看列表中的第一个 `Placemark` 元素：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Each `<Placemark>` tag is now a DOM element data type. To really see what that
    element is, we call the `toxml()` method, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个 `<Placemark>` 标签都是一个 DOM 元素数据类型。为了真正看到这个元素是什么，我们调用 `toxml()` 方法，如下所示：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `toxml()` function outputs everything contained in the `Placemark` tag as
    a string object. If we want to print this information to a text file, we can call
    the `toprettyxml()` method, which would add additional indentation to make the
    XML more readable.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`toxml()` 函数将 `Placemark` 标签内包含的所有内容输出为一个字符串对象。如果我们想将此信息打印到文本文件中，我们可以调用 `toprettyxml()`
    方法，这将添加额外的缩进来使 XML 更易于阅读。'
- en: Now, what if we want to grab just the coordinates from this placemark? The coordinates
    are buried inside the `coordinates` tag, which is contained in the `point` tag
    and nested inside the `Placemark` tag. Each element of a `minidom` object is called
    a **node**. Nested nodes are called children or child nodes. The child nodes include
    more than just tags – they can also include whitespace separating tags, as well
    as the data inside the tags. So, we can drill down to the `coordinates` tag using
    the tag name, but then we'll need to access the `data` node. All the `minidom`
    elements have `childNodeslist`, as well as a `firstChild()` method to access the
    first node.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们只想从这个 placemark 中获取坐标会怎样？坐标隐藏在 `coordinates` 标签中，该标签位于 `point` 标签内，嵌套在
    `Placemark` 标签内。`minidom` 对象的每个元素都称为 **节点**。嵌套节点称为子节点或子节点。子节点不仅包括标签，还包括分隔标签的空白，以及标签内的数据。因此，我们可以通过标签名称钻到
    `coordinates` 标签，但之后我们需要访问 `data` 节点。所有的 `minidom` 元素都有 `childNodeslist`，以及一个
    `firstChild()` 方法来访问第一个节点。
- en: 'We''ll combine these methods to get to the `data` attribute of the first coordinate''s
    `data` node, which we reference using index `0` in the list of coordinate stags:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将结合这些方法来获取第一个坐标的 `data` 节点的 `data` 属性，我们使用列表中的索引 `0` 来引用坐标标签列表：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you're new to Python, you'll notice that the text output in these examples
    is tagged with the letter `u`. This markup is how Python denotes Unicode strings
    that support internationalization to multiple languages with different character
    sets. Python 3.4.3 changes this convention slightly and leaves Unicode strings
    unmarked while marking UTF-8 strings with a `b`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚接触 Python，你会注意到这些示例中的文本输出被标记为字母 `u`。这种标记是 Python 表示支持国际化并使用不同字符集的多语言 Unicode
    字符串的方式。Python 3.4.3 对此约定略有改变，不再标记 Unicode 字符串，而是用 `b` 标记 UTF-8 字符串。
- en: 'We can go a little further and convert this `point` string into usable data
    by splitting the string and converting the resulting strings into Python float
    types, as shown here:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以更进一步，将这个 `point` 字符串转换为可用的数据，通过分割字符串并将结果字符串转换为 Python 浮点类型来实现，如下所示：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Using Python list comprehension, we can perform this operation in a single
    step, as you can see in the following lines of code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python 列表推导式，我们可以一步完成这个操作，如下面的代码行所示：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This example scratches the surface of what the `minidom` library can do. For
    a great tutorial on this library, have a look at the following tutorial: [https://www.edureka.co/blog/python-xml-parser-tutorial/](https://www.edureka.co/blog/python-xml-parser-tutorial/).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只是触及了`minidom`库所能做到的一小部分。关于这个库的精彩教程，请查看以下教程：[https://www.edureka.co/blog/python-xml-parser-tutorial/](https://www.edureka.co/blog/python-xml-parser-tutorial/)。
- en: ElementTree
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ElementTree
- en: The `minidom` module is pure Python, easy to work with, and has been around
    since Python 2.0\. However, Python 2.5 added a more efficient yet high-level XML
    parser to the standard library called `ElementTree`. `ElementTree` is interesting
    because it has been implemented in multiple versions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`minidom`模块是纯Python编写，易于使用，自Python 2.0以来一直存在。然而，Python 2.5在标准库中增加了一个更高效但更高级的XML解析器，称为`ElementTree`。`ElementTree`很有趣，因为它已经实现了多个版本。'
- en: 'There is a pure Python version and a faster version written in C called `cElementTree`.
    You should use `cElementTree` wherever possible, but it''s possible that you may
    be on a platform that doesn''t include the C-based version. When you import `cElementTree`,
    you can test to see if it''s available and fall back to the pure Python version
    if necessary:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个纯Python版本和一个用C编写的更快版本，称为`cElementTree`。你应该尽可能使用`cElementTree`，但可能你所在的平台不包括基于C的版本。当你导入`cElementTree`时，你可以测试它是否可用，并在必要时回退到纯Python版本：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: One of the great features of `ElementTree` is its implementation of a subset
    of the XPath query language. XPath is short for XML Path and allows you to search
    an XML document using a path-style syntax. If you work with XML frequently, learning
    XPath is essential. You can learn more about XPath at the following link: [https://www.w3schools.com/xml/xpath_intro.asp](https://www.w3schools.com/xml/xpath_intro.asp).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElementTree`的一个伟大特性是它实现了XPath查询语言的一个子集。XPath代表XML Path，允许你使用路径式语法搜索XML文档。如果你经常处理XML，学习XPath是必不可少的。你可以在以下链接中了解更多关于XPath的信息：[https://www.w3schools.com/xml/xpath_intro.asp](https://www.w3schools.com/xml/xpath_intro.asp)。'
- en: One catch with this feature is that if the document specifies a namespace, as
    most XML documents do, you must insert that namespace into queries. `ElementTree`
    does not automatically handle the namespace for you. Your options are to manually
    specify it or try to extract it using string parsing from the root element's tag
    name.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性的一个问题是，如果文档指定了命名空间，就像大多数XML文档一样，你必须将那个命名空间插入到查询中。`ElementTree`不会自动为你处理命名空间。你的选择是手动指定它或尝试从根元素的标签名中通过字符串解析提取它。
- en: 'We''ll repeat the `minidomXML` parsing example using `ElementTree`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ElementTree`重复`minidomXML`解析示例：
- en: First, we'll parse the document and then we'll manually define the KML namespace;
    later, we'll use an XPath expression and the `find()` method to find the first
    `Placemark` element.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将解析文档，然后手动定义KML命名空间；稍后，我们将使用XPath表达式和`find()`方法来查找第一个`Placemark`元素。
- en: Finally, we'll find the coordinates and the child node and then grab the text
    containing the latitude and longitude.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将找到坐标和子节点，然后获取包含纬度和经度的文本。
- en: 'In both cases, we could have searched directly for the `coordinates` tag. But,
    by grabbing the `Placemark` element, it gives us the option of grabbing the corresponding
    timestamp child element later, if we so choose, as shown in the following lines
    of code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们都可以直接搜索`coordinates`标签。但是，通过获取`Placemark`元素，它给我们提供了选择，稍后如果需要的话，可以获取相应的timestamp子元素，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, notice that we used the Python string formatting syntax, which
    is based on the string formatting concept found in C. When we defined the XPath
    expression for the placemark variable, we used the `%` placeholder to specify
    the insertion of a string. Then, after the string, we used the `%` operator followed
    by a variable name to insert the `ns` namespace variable where the placeholder
    is. In the `coordinates` variable, we used the `ns` variable twice, so we specified
    a tuple containing `ns` twice after the string.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，请注意我们使用了Python字符串格式化语法，它基于C中的字符串格式化概念。当我们为placemark变量定义XPath表达式时，我们使用了`%`占位符来指定字符串的插入。然后，在字符串之后，我们使用了`%`运算符后跟变量名来在占位符处插入`ns`命名空间变量。在`coordinates`变量中，我们使用了`ns`变量两次，因此在字符串之后指定了包含两次`ns`的元组。
- en: 'String formatting is a simple yet extremely powerful and useful tool in Python
    that''s worth learning. You can find more information in Python''s documentation
    online at the following link: [https://docs.python.org/3.4/library/string.html](https://docs.python.org/3.4/library/string.html).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串格式化是 Python 中一种简单但极其强大且有用的工具，值得学习。你可以在以下链接中找到更多信息：[https://docs.python.org/3.4/library/string.html](https://docs.python.org/3.4/library/string.html)。
- en: Building XML using ElementTree and Minidom
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ElementTree 和 Minidom 构建 XML
- en: 'Most of the time, XML can be built by concatenating strings, as you can see
    in the following command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，XML 可以通过连接字符串来构建，如下面的命令所示：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, this method can be quite prone to typos, which creates invalid XML
    documents. A safer way is to use an XML library. Let''s build this simple KML
    document using `ElementTree`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法很容易出错，这会创建无效的 XML 文档。一种更安全的方法是使用 XML 库。让我们使用 `ElementTree` 构建这个简单的 KML
    文档：
- en: We'll define the `rootKML` element and assign it a namespace.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义 `rootKML` 元素并为其分配一个命名空间。
- en: 'Then, we''ll systematically append sub elements to the root, wrap the elements
    as an `ElementTree` object, declare the XML encoding, and write it out to a file
    called `placemark.xml`, as shown in the following lines of code:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将系统地添加子元素到根元素，将元素包装为 `ElementTree` 对象，声明 XML 编码，并将其写入名为 `placemark.xml`
    的文件中，如下面的代码行所示：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The output is identical to the previous string building example, except that
    `ElementTree` does not indent the tags but rather writes it as one long string.
    The `minidom` module has a similar interface, which is documented in the book
    *Dive Into Python*, by Mark Pilgrim, which was referenced in the `minidom` example
    that we just saw.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与之前的字符串构建示例相同，但 `ElementTree` 不缩进标签，而是将其作为一条长字符串写入。`minidom` 模块具有类似的接口，这在
    Mark Pilgrim 的《深入 Python》一书中有所记录，该书籍在前面看到的 `minidom` 示例中有所引用。
- en: XML parsers such as `minidom` and `ElementTree` work very well on perfectly
    formatted XML documents. Unfortunately, the vast majority of XML documents out
    there don't follow these rules and contain formatting errors or invalid characters.
    You'll find that you are often forced to work with this data and must resort to
    extraordinary string parsing techniques to get the small subset of data you actually
    need. But thanks to Python and Beautiful Soup, you can elegantly work with bad
    and even terrible tag-based data.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: XML 解析器，如 `minidom` 和 `ElementTree`，在格式完美的 XML 文档上工作得非常好。不幸的是，绝大多数的 XML 文档并不遵循这些规则，并包含格式错误或无效字符。你会发现你经常被迫处理这些数据，并且必须求助于非常规的字符串解析技术来获取你实际需要的少量数据。但是，多亏了
    Python 和 Beautiful Soup，你可以优雅地处理糟糕的甚至极差的基于标签的数据。
- en: 'Beautiful Soup is a module that was specifically designed to robustly handle
    broken XML. It is oriented toward HTML, which is notorious for incorrect formatting
    but works with other XML dialects too. Beautiful Soup is available on PyPI, so
    use either `easy_install` or `pip` to install it, as you can see in the following
    command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Beautiful Soup 是一个专门设计用来鲁棒地处理损坏的 XML 的模块。它面向 HTML，HTML 以格式错误而闻名，但也适用于其他 XML
    方言。Beautiful Soup 可在 PyPI 上找到，因此可以使用 `easy_install` 或 `pip` 来安装它，如下面的命令所示：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Alternatively, you can execute the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以执行以下命令：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, to use it, you simply import it:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了使用它，你只需简单地导入它：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To try it out, we'll use a **GPS Exchange Format** (**GPX**) tracking file from
    a smartphone application, which has a glitch and exports slightly broken data.
    You can download this sample file from [https://raw.githubusercontent.com/GeospatialPython/Learn/master/broken_data.gpx](https://raw.githubusercontent.com/GeospatialPython/Learn/master/broken_data.gpx).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试它，我们将使用来自智能手机应用程序的 **GPS 交换格式**（**GPX**）跟踪文件，该文件存在故障并导出了略微损坏的数据。您可以从以下链接下载此样本文件：[https://raw.githubusercontent.com/GeospatialPython/Learn/master/broken_data.gpx](https://raw.githubusercontent.com/GeospatialPython/Learn/master/broken_data.gpx)。
- en: 'This 2,347-line data file is in pristine condition except that it is missing
    a closing `</trkseg>` tag, which should be located at the very end of the file,
    just before the closing `</trk>` tag. This error was caused by a data export function
    in the source program. This defect is most likely a result of the original developer
    manually generating the GPX XML on export and forgetting the line of code that
    adds this closing tag. Watch what happens if we try to parse this file with `minidom`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个2,347行的数据文件处于原始状态，除了它缺少一个关闭的`</trkseg>`标签，这个标签应该位于文件的末尾，就在关闭的`</trk>`标签之前。这个错误是由源程序中的数据导出函数引起的。这个缺陷很可能是原始开发者手动生成导出时的GPX
    XML并忘记添加此关闭标签的代码行所导致的。看看如果我们尝试用`minidom`解析这个文件会发生什么：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see from the last line in the error message, the underlying XML parser
    in `minidom` knows exactly what the problem is – a `mismatched` tag right at the
    end of the file. However, it refused to do anything more than report the error.
    You must have perfectly formed XML or none at all to avoid this.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从错误信息的最后一行所看到的，`minidom`中的底层XML解析器确切地知道问题所在——文件末尾存在一个`mismatched`标签。然而，它拒绝做任何更多的事情，只是报告了错误。您必须拥有完美无瑕的XML，或者根本不使用，以避免这种情况。
- en: 'Now, let''s try the more sophisticated and efficient `ElementTree` module with
    the same data:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用相同数据的更复杂和高效的`ElementTree`模块：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, different parsers face the same problem. Poorly formed XML
    is an all too common reality in geospatial analysis, and every XML parser assumes
    that all the XML in the world is perfect, except for one. Enter Beautiful Soup.
    This library shreds bad XML into usable data without a second thought, and it
    can handle far worse defects than missing tags. It will work despite missing punctuation
    or other syntax and will give you the best data it can. It was originally developed
    for parsing HTML, which is notoriously horrible for being poorly formed, but it
    works fairly well with XML as well, as shown here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，不同的解析器面临相同的问题。在地理空间分析中，格式不良的XML是一个过于常见的现实，每个XML解析器都假设世界上所有的XML都是完美的，除了一个。这就是Beautiful
    Soup的用武之地。这个库毫不犹豫地将不良XML撕成可用的数据，并且它可以处理比缺失标签更严重的缺陷。即使缺少标点符号或其他语法，它也能正常工作，并给出它能给出的最佳数据。它最初是为解析HTML而开发的，HTML因其格式不良而臭名昭著，但它与XML也相当兼容，如下所示：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'No complaints from Beautiful Soup! Just to make sure the data is actually usable,
    let''s try and access some of the data. One of the fantastic features of Beautiful
    Soup is that it turns tags into attributes of the parse tree. If there are multiple
    tags with the same name, it grabs the first one. Our sample data file has hundreds
    of `<trkpt>` tags. Let''s access the first one:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Beautiful Soup没有任何抱怨！为了确保数据实际上是可以使用的，让我们尝试访问一些数据。Beautiful Soup的一个令人惊叹的特性是它将标签转换为解析树的属性。如果有多个具有相同名称的标签，它将获取第一个。我们的样本数据文件有数百个`<trkpt>`标签。让我们访问第一个：
- en: '[PRE48]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We''re now certain that the data has been parsed correctly and that we can
    access it. If we want to access all of the `<trkpt>` tags, we can use the `findAll()`
    method to grab them and then use the built-in Python `len()` function to count
    them, as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在确信数据已经被正确解析，并且我们可以访问它。如果我们想访问所有的`<trkpt>`标签，我们可以使用`findAll()`方法来获取它们，然后使用内置的Python
    `len()`函数来计数，如下所示：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we write the parsed data back out to a file, Beautiful Soup outputs the
    corrected version. We''ll save the fixed data as a new GPX file using Beautiful
    Soup module''s `prettify()` method to format the XML with nice indentation, as
    you can see in the following lines of code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将解析的数据写回到文件中，Beautiful Soup会输出修正后的版本。我们将使用Beautiful Soup模块的`prettify()`方法将固定数据保存为一个新的GPX文件，以格式化XML并添加漂亮的缩进，如下面的代码行所示：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Beautiful Soup is a very rich library with many more features. To explore it
    further, visit the Beautiful Soup documentation online at [http://www.crummy.com/software/BeautifulSoup/bs4/documentation.html](http://www.crummy.com/software/BeautifulSoup/bs4/documentation.html).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Beautiful Soup是一个非常丰富的库，具有更多功能。要进一步探索它，请访问在线的Beautiful Soup文档[http://www.crummy.com/software/BeautifulSoup/bs4/documentation.html](http://www.crummy.com/software/BeautifulSoup/bs4/documentation.html)。
- en: While `minidom`, `ElementTree`, and `cElementTree` come with the Python standard
    library, there is an even more powerful and popular XML library for Python called
    `lxml`. The `lxml` module provides a Pythonic interface to the `libxml2` and `libxslt`
    C libraries using the `ElementTree` API. An even better fact is that `lxml` also
    works with Beautiful Soup to parse bad tag-based data. On some installations,
    `beautifulsoup4` may require `lxml.` The `lxml` module is available via PyPI but
    requires some additional steps for the C libraries. More information is available
    on the `lxml` home page at the following link: [http://lxml.de/](http://lxml.de/).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`minidom`、`ElementTree`和`cElementTree`是Python标准库的一部分，但还有一个更强大、更受欢迎的Python
    XML库，称为`lxml`。`lxml`模块通过`ElementTree` API提供了对`libxml2`和`libxslt` C库的Pythonic接口。更好的事实是，`lxml`还可以与Beautiful
    Soup一起解析基于标签的坏数据。在某些安装中，`beautifulsoup4`可能需要`lxml`。`lxml`模块可通过PyPI获取，但需要为C库执行一些额外步骤。更多信息可在以下链接的`lxml`主页上找到：[http://lxml.de/](http://lxml.de/)。
- en: Well-Known Text (WKT)
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Well-Known Text (WKT)
- en: 'The WKT format has been around for years and is a simple text-based format
    for representing geometries and spatial reference systems. It is primarily used
    as a data exchange format by systems that implement the OGC Simple Features for
    SQL specification. Take a look at the following sample WKT representation of a
    polygon:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: WKT格式已经存在多年，是一种简单的基于文本的格式，用于表示几何形状和空间参考系统。它主要用作实现OGC Simple Features for SQL规范的系统的数据交换格式。请看以下多边形的WKT表示示例：
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Currently, the best way to read and write WKT is by using the Shapely library.
    Shapely provides a very Python-oriented or Pythonic interface to the **Geometry
    Engine - Open Source** (**GEOS**) library we described in [Chapter 3](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml),
    *The Geospatial Technology Landscape*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，读取和写入WKT的最佳方式是使用Shapely库。Shapely提供了一个非常Python导向或Pythonic的接口，用于我们[第3章](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml)中描述的**Geometry
    Engine - Open Source**（**GEOS**）库，*地理空间技术景观*。
- en: 'You can install Shapely using either `easy_install` or `pip`. You can also
    use the wheel from the site we mentioned in the previous section. Shapely has
    a WKT module which can load and export this data. Let''s use Shapely to load the
    previous polygon sample and then verify that it has been loaded as a polygon object
    by calculating its area:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`easy_install`或`pip`安装Shapely。您还可以使用上一节中提到的网站上的wheel。Shapely有一个WKT模块，可以加载和导出这些数据。让我们使用Shapely加载之前的多边形样本，然后通过计算其面积来验证它是否已作为多边形对象加载：
- en: '[PRE52]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can convert any Shapely geometry back into a WKT by simply calling its `wkt`
    attribute, as shown here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地调用其`wkt`属性，将任何Shapely几何形状转换回WKT，如下所示：
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Shapely can also handle the WKT binary counterpart called W**ell-Known Binary**
    (**WKB**), which is used to store WKT strings as binary objects in databases.
    Shapely loads WKB using its `wkb` module in the same way as the `wkt` module,
    and it can convert geometries by calling that object's `wkb` attribute.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely还可以处理WKT的二进制对应物，称为W**ell-Known Binary**（**WKB**），它用于在数据库中以二进制对象的形式存储WKT字符串。Shapely使用其`wkb`模块以与`wkt`模块相同的方式加载WKB，并且可以通过调用该对象的`wkb`属性来转换几何形状。
- en: Shapely is the most Pythonic way to work with WKT data, but you can also use
    the Python bindings to the OGR library, which we installed earlier in this chapter.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely是处理WKT数据最Pythonic的方式，但您也可以使用OGR库的Python绑定，这是我们本章早些时候安装的。
- en: 'For this example, we''ll use a shapefile with one simple polygon, which can
    be downloaded as a ZIP file. It is available at the following link: [https://github.com/GeospatialPython/Learn/raw/master/polygon.zip](https://github.com/GeospatialPython/Learn/raw/master/polygon.zip).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用一个包含一个简单多边形的shapefile，它可以作为一个ZIP文件下载。您可以通过以下链接获取：[https://github.com/GeospatialPython/Learn/raw/master/polygon.zip](https://github.com/GeospatialPython/Learn/raw/master/polygon.zip)。
- en: 'In the following example, we''ll open the `polygon.shp` file from the shapefile
    dataset, call the required `GetLayer()` method, get the first (and only) feature,
    and then export it to WKT:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将打开shapefile数据集中的`polygon.shp`文件，调用所需的`GetLayer()`方法，获取第一个（也是唯一一个）要素，然后将其导出为WKT格式：
- en: '[PRE54]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Note that with OGR, you would have to read access each feature and export it
    individually, since the `ExporttoWkt()` method is at the feature level. We can
    now turn around and read a WKT string using the `wkt` variable containing the
    export. We''ll import it back into `ogr` and get the bounding box, also known
    as an envelope, of the polygon, as you can see here:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用OGR时，你必须逐个读取每个要素并单独导出它，因为`ExporttoWkt()`方法是在要素级别。现在我们可以使用包含导出的`wkt`变量来读取WKT字符串。我们将将其导入`ogr`，并获取多边形的边界框，也称为包围盒，如下所示：
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Shapely and OGR are used for reading and writing valid WKT strings. Of course,
    just like XML, which is also text, you could manipulate small amounts of WKT as
    strings in a pinch.  Next, we'll look at a modern text format that is becoming
    very common in the geospatial world.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely和OGR用于读取和写入有效的WKT字符串。当然，就像XML一样，它也是文本，你可以在必要时将少量WKT作为字符串进行操作。接下来，我们将探讨一个在地理空间领域变得越来越常见的现代文本格式。
- en: Python JSON libraries
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python JSON库
- en: '**JavaScript Object Notation** (**JSON**) is rapidly becoming the number one
    data exchange format across a lot of fields. The lightweight syntax and its similarity
    to existing data structures in both the JavaScript that Python borrows some data
    structures from, as well as JavaScript itself, make it a perfect match for Python.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法**（**JSON**）正在迅速成为许多领域的首选数据交换格式。轻量级的语法以及它与JavaScript数据结构的相似性，使得它非常适合Python，Python也借鉴了一些数据结构。'
- en: 'The following GeoJSON sample document contains a single point:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下GeoJSON样本文档包含一个单独的点：
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This sample is just a simple point with new attributes, which would be stored
    in the properties data structure of the geometry. In the preceding example, the
    ID, coordinates, and CRS information would change depending on your particular
    dataset.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个样本只是一个带有新属性的基本点，这些属性将被存储在几何的属性数据结构中。在前面的例子中，ID、坐标和CRS信息将根据你的特定数据集而变化。
- en: 'Let''s modify this sample GeoJSON document using Python. First, we''ll compact
    the sample document into a single string to make it easier to handle:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Python修改这个示例GeoJSON文档。首先，我们将样本文档压缩成一个字符串，以便更容易处理：
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, we can use the GeoJSON `jsdata` string variable we created in the preceding
    code, in the following examples.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用前面代码中创建的GeoJSON `jsdata` 字符串变量，在以下示例中使用。
- en: The json module
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: json模块
- en: 'GeoJSON looks very similar to a nested set of Python''s dictionaries and lists.
    Just for fun, let''s just try and use Python''s `eval()` function to parse it
    as Python code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: GeoJSON看起来非常类似于Python的嵌套字典和列表集合。为了好玩，让我们尝试使用Python的`eval()`函数将其解析为Python代码：
- en: '[PRE58]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Wow! That worked! We turned that random GeoJSON string into native Python data
    in one easy step. Keep in mind that the JSON data format is based on JavaScript
    syntax, which happens to be similar to Python. Also, as you get deeper into GeoJSON
    data and work with larger data, you'll find that JSON allows characters that Python
    does not. Using Python's `eval()` function is considered very insecure as well.
    But as far as keeping things simple is concerned, note that it doesn't get any
    simpler than that!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这成功了！我们只需一步就将那个随机的GeoJSON字符串转换成了原生的Python数据。记住，JSON数据格式基于JavaScript语法，这恰好与Python相似。此外，随着你对GeoJSON数据的深入了解以及处理更大的数据，你会发现JSON允许使用Python不允许的字符。使用Python的`eval()`函数也被认为是非常不安全的。但就保持简单而言，这已经是最简单的方法了！
- en: 'Thanks to Python''s drive toward simplicity, the more advanced method doesn''t
    get much more complicated. Let''s use Python''s `json` module, which is part of
    the standard library, to turn the same string into Python the right way:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python追求简单，更高级的方法并没有变得更加复杂。让我们使用Python的`json`模块，它是标准库的一部分，将相同的字符串正确地转换为Python：
- en: '[PRE59]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As a side note, in the previous example, the CRS84 property is a synonym for
    the common WGS84 coordinate system. The `json` module adds some nice features
    such as safer parsing and conversion of strings into Unicode. We can export Python
    data structures to JSON in almost the same way:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，在先前的例子中，CRS84属性是常见WGS84坐标系统的同义词。`json`模块添加了一些很好的功能，例如更安全的解析和将字符串转换为Unicode。我们可以以几乎相同的方式将Python数据结构导出为JSON：
- en: '[PRE60]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When you dump data, it comes out as one long string that''s difficult to read.
    There''s a way we can print the data so it is easier to read: by passing the `dumps()`
    method an indent value:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导出数据时，它会以一长串难以阅读的字符串形式输出。我们可以通过传递`dumps()`方法一个缩进值来打印数据，使其更容易阅读：
- en: '[PRE61]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now that we understand `json` module, let's look at the geospatial version called
    `geojson`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 `json` 模块，让我们看看地理空间版本 `geojson`。
- en: The geojson module
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: geojson 模块
- en: 'We could happily go on reading and writing GeoJSON data using the `json` module
    forever, but there''s an even better way. The `geojson` module that''s available
    on PyPI offers some distinct advantages. For starters, it knows the requirements
    of the GeoJSON specification, which can save a lot of typing. Let''s create a
    simple point using this module and export it to GeoJSON:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以愉快地继续使用 `json` 模块读取和写入 GeoJSON 数据，但还有更好的方法。PyPI 上可用的 `geojson` 模块提供了一些独特的优势。首先，它了解
    GeoJSON 规范的要求，这可以节省大量的输入。让我们使用此模块创建一个简单的点并将其导出为 GeoJSON：
- en: '[PRE62]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This time, when we dump the JSON data for viewing, we''ll add an indent argument
    with a value of `4` so that we get nicely indented JSON data that''s easier to
    read:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们转储 JSON 数据以供查看时，我们将添加一个缩进参数，其值为 `4`，这样我们就可以得到格式良好的缩进 JSON 数据，更容易阅读：
- en: '[PRE63]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Our output is as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果如下：
- en: '[PRE64]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Notice that the `geojson` module has an interface for different data types and
    saves us from setting the type and coordinates attributes manually. Now, imagine
    if you had a geographic object with hundreds of features. You could programmatically
    build this data structure instead of building a very large string.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `geojson` 模块为不同的数据类型提供了一个接口，并使我们免于手动设置类型和坐标属性。现在，想象一下如果你有一个具有数百个要素的地理对象。你可以通过编程构建这个数据结构，而不是构建一个非常大的字符串。
- en: 'The `geojson` module is also the reference implementation for the Python `geo_interface`
    convention. This interface allows cooperating programs to exchange data seamlessly
    and in a Pythonic way without the programmer explicitly exporting and importing
    GeoJSON strings. So, if we wanted to feed the point we created with the `geojson`
    module to the Shapely module, we could perform the following command, which reads
    the `geojson` module''s point object straight into Shapely, after which we''ll
    export it as WKT:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`geojson` 模块也是 Python `geo_interface` 规范的参考实现。这个接口允许协作程序以 Pythonic 的方式无缝交换数据，而无需程序员显式导出和导入
    GeoJSON 字符串。因此，如果我们想将使用 `geojson` 模块创建的点传递给 Shapely 模块，我们可以执行以下命令，该命令将 `geojson`
    模块的点对象直接读取到 Shapely 中，然后将其导出为 WKT：'
- en: '[PRE65]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: More and more geospatial Python libraries are implementing both the `geojson`
    and `geo_interface` functionality, including PyShp, Fiona, Karta, and ArcGIS.
    Third-party implementations exist for QGIS.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的地理空间 Python 库正在实现 `geojson` 和 `geo_interface` 功能，包括 PyShp、Fiona、Karta 和
    ArcGIS。对于 QGIS，存在第三方实现。
- en: GeoJSON is a simple text format that is human and computer-readable. Now, we'll
    look at some binary vector formats.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: GeoJSON 是一种简单且易于人类和计算机阅读的文本格式。现在，我们将查看一些二进制矢量格式。
- en: OGR
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OGR
- en: We touched on OGR as a way to handle WKT strings, but its real power is as a
    universal vector library. This book strives for pure Python solutions, but no
    single library even comes close to the variety of formats that OGR can process.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到了 OGR 作为处理 WKT 字符串的方法，但它的真正力量在于作为一个通用的矢量库。本书力求提供纯 Python 解决方案，但没有单个库甚至接近
    OGR 可以处理的格式多样性。
- en: 'Let''s read a sample point shapefile using the OGR Python API. The sample shapefile
    can be downloaded as a ZIP file here: [https://github.com/GeospatialPython/Learn/raw/master/point.zip](https://github.com/GeospatialPython/Learn/raw/master/point.zip).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 OGR Python API 读取一个示例点形状文件。示例形状文件可以作为 ZIP 文件在此处下载：[https://github.com/GeospatialPython/Learn/raw/master/point.zip](https://github.com/GeospatialPython/Learn/raw/master/point.zip)。
- en: 'This point shapefile has five points with single digit, positive coordinates.
    The attributes list the order in which the points were created, making it useful
    for testing. This simple example will read in the point shapefile and loop through
    each feature; then, it will print the *x* and *y* values of each point, plus the
    value of the first attribute field:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这个点形状文件有五个带有单个数字、正坐标的点。属性列表了点的创建顺序，这使得它在测试中非常有用。这个简单的例子将读取点形状文件，并遍历每个要素；然后，它将打印每个点的
    *x* 和 *y* 值，以及第一个属性字段的值：
- en: '[PRE66]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This example is simple, but OGR can become quite verbose as your script becomes
    more complex. Next, we'll look at a simpler way to deal with shapefiles.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很简单，但 OGR 在脚本变得更加复杂时可能会变得相当冗长。接下来，我们将看看处理形状文件的一种更简单的方法。
- en: PyShp
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyShp
- en: PyShp is a simple, pure Python library that reads and writes shapefiles. It
    doesn't perform any geometry operations and only uses Python's standard library.
    It's contained in a single file that's easy to move around, squeeze onto small
    embedded platforms, and modify. It is also compatible with Python 3\. It also
    implements `__geo_interface__`. The PyShp module is available on PyPI.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: PyShp是一个简单的纯Python库，用于读取和写入形状文件。它不执行任何几何操作，仅使用Python的标准库。它包含在一个易于移动、压缩到小型嵌入式平台和修改的单个文件中。它也与Python
    3兼容。它还实现了`__geo_interface__`。PyShp模块可在PyPI上找到。
- en: 'Let''s repeat the previous OGR example with PyShp:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用PyShp重复之前的OGR示例：
- en: '[PRE67]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: dbfpy
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: dbfpy
- en: 'Both OGR and PyShp read and write the `.dbf` files because they are part of
    the shapefile specification. The `.dbf` files contain the attributes and fields
    for the shapefiles. However, both libraries have very basic `.dbf` support. Occasionally,
    you will need to do some heavy-duty DBF work. The `dbfpy3` module is a pure Python
    module dedicated to working with `.dbf` files. It is currently hosted on GitHub.
    You can force `easy_install` to find the download by specifying the download file:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: OGR和PyShp都读取和写入`.dbf`文件，因为它们是形状文件规范的一部分。`.dbf`文件包含形状文件的属性和字段。然而，这两个库对`.dbf`的支持非常基础。偶尔，你可能需要进行一些重型的DBF工作。`dbfpy3`模块是一个专门用于处理`.dbf`文件的纯Python模块。它目前托管在GitHub上。你可以通过指定下载文件来强制`easy_install`找到下载：
- en: '[PRE68]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If you are using `pip` to install packages, use the following command:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`pip`安装软件包，请使用以下命令：
- en: '[PRE69]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The following shapefile has over 600 `.dbf` records representing US Census Bureau
    tracts, which make it a good sample for trying out `dbfpy`: [https://github.com/GeospatialPython/Learn/raw/master/GIS_CensusTract.zip](https://github.com/GeospatialPython/Learn/raw/master/GIS_CensusTract.zip).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下形状文件包含超过600条`.dbf`记录，代表美国人口普查局的区域，这使得它成为尝试`dbfpy`的好样本：[https://github.com/GeospatialPython/Learn/raw/master/GIS_CensusTract.zip](https://github.com/GeospatialPython/Learn/raw/master/GIS_CensusTract.zip).
- en: 'Let''s open up the `.dbf` file of this shapefile and look at the first record:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开这个形状文件的`.dbf`文件并查看第一条记录：
- en: '[PRE70]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The module quickly and easily gives us both the column names and data values
    together, as opposed to handling them as separate lists, so that they''re easier
    to manage. Now, let''s increment the population field contained in `POPULAT10`
    by `1`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块快速且容易地为我们提供列名和数据值，而不是将它们作为单独的列表处理，这使得它们更容易管理。现在，让我们将包含在`POPULAT10`中的人口字段增加`1`：
- en: '[PRE71]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Keep in mind that both OGR and PyShp can do this same procedure, but `dbfp3y`
    makes it a little easier if you are only making a lot of changes to the .dbf files.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，OGR和PyShp都可以执行此相同的过程，但如果您只是对`.dbf`文件进行大量更改，`dbfp3y`会使它稍微容易一些。
- en: Shapely
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shapely
- en: Shapely was mentioned in the **Well-Known Text** (**WKT**) section for its import
    and exportability. However, its true purpose is as a generic geometry library.
    Shapely is a high-level, Pythonic interface to the GEOS library for geometric
    operations. In fact, Shapely intentionally avoids reading or writing files. It
    relies completely on data import and export from other modules and maintains focus
    on geometry manipulation.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely在**已知文本**（**WKT**）部分被提及，因为它具有导入和导出功能。然而，它的真正目的是作为一个通用的几何库。Shapely是GEOS库的几何操作的高级Python接口。实际上，Shapely故意避免读取或写入文件。它完全依赖于从其他模块导入和导出数据，并专注于几何操作。
- en: 'Let''s do a quick Shapely demonstration in which we''ll define a single WKT
    polygon and then import it into Shapely. Then, we''ll measure the area. Our computational
    geometry will consist of buffering that polygon by a measure of five arbitrary
    units, which will return a new, bigger polygon for which we''ll measure the area:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个快速的Shapely演示，我们将定义一个WKT多边形，然后将其导入Shapely。然后，我们将测量面积。我们的计算几何将包括通过五个任意单位对多边形进行缓冲，这将返回一个新的更大的多边形，我们将测量其面积：
- en: '[PRE72]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can then perform a difference in the area of the buffer and the original
    polygon area, as shown here:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以执行缓冲区面积与原始多边形面积的差值，如下所示：
- en: '[PRE73]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If you can't have pure Python, a Pythonic API as clean as Shapely that packs
    such a punch is certainly the next best thing.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不能使用纯Python，那么像Shapely一样干净、功能强大的Python API无疑是下一个最佳选择。
- en: Fiona
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fiona
- en: The Fiona library provides a simple Python API around the OGR library for data
    access and nothing more. This approach makes it easy to use and is less verbose
    than OGR while using Python. Fiona outputs GeoJSON by default. You can find a
    wheel file for Fiona at [http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona](http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Fiona 库提供了围绕 OGR 库的简单 Python API，用于数据访问，仅此而已。这种方法使其易于使用，并且在使用 Python 时比 OGR
    更简洁。Fiona 默认输出 GeoJSON。您可以在 [http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona](http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona)
    找到 Fiona 的 wheel 文件。
- en: As an example, we'll use the `GIS_CensusTract_poly.shp` file from the `dbfpy`
    example we looked at earlier in this chapter.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将使用本章前面查看的 `dbfpy` 示例中的 `GIS_CensusTract_poly.shp` 文件。
- en: 'First, we''ll import `fiona` and Python''s `pprint` module to format the output.
    Then, we''ll open the shapefile and check its driver type:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将导入 `fiona` 和 Python 的 `pprint` 模块以格式化输出。然后，我们将打开 shapefile 并检查其驱动程序类型：
- en: '[PRE74]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ESRI shapefile
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ESRI shapefile
- en: 'Next, we''ll check its coordinate reference system and get the data bounding
    box, as shown here:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查其坐标参考系统并获取数据边界框，如下所示：
- en: '[PRE75]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, we''ll view the data schema as `geojson` and format it using the `pprint`
    module, as you can see in the following lines of code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将以 `geojson` 格式查看数据模式，并使用 `pprint` 模块进行格式化，如下面的代码行所示：
- en: '[PRE76]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, let''s get a count of the number of features:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们获取特征数量的统计：
- en: '[PRE77]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, we''ll print one of the records as formatted GeoJSON, as shown here:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将打印一条记录作为格式化的 GeoJSON，如下所示：
- en: '[PRE78]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: GDAL
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GDAL
- en: 'GDAL is the dominant geospatial library for raster data. Its raster capability
    is so significant that it is a part of virtually every geospatial toolkit in any
    language, and Python is no exception to this. To see the basics of how GDAL works
    in Python, download the following sample raster satellite image as a ZIP file
    and unzip it: [https://github.com/GeospatialPython/Learn/raw/master/SatImage.zip](https://github.com/GeospatialPython/Learn/raw/master/SatImage.zip).
    Let''s open this image and see how many bands it has and how many pixels are present
    along each axis:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL 是用于栅格数据的占主导地位的地理空间库。其栅格功能非常显著，以至于它是任何语言中几乎所有地理空间工具包的一部分，Python 也不例外。要了解
    GDAL 在 Python 中的基本工作原理，请下载以下示例栅格卫星图像的 ZIP 文件并解压：[https://github.com/GeospatialPython/Learn/raw/master/SatImage.zip](https://github.com/GeospatialPython/Learn/raw/master/SatImage.zip)。让我们打开这张图片，看看它有多少波段以及每个轴上有多少像素：
- en: '[PRE79]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'By viewing it in OpenEV, we can see that the following image has three bands,
    2,592 columns of pixels, and 2,693 rows of pixels:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 OpenEV 中查看，我们可以看到以下图像有三个波段，2,592 列像素和 2,693 行像素：
- en: '![](img/1831299e-4500-49f1-8ef2-f8ee35f21442.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1831299e-4500-49f1-8ef2-f8ee35f21442.png)'
- en: GDAL is an extremely fast geospatial raster reader and writer within Python.
    It can also reproject images quite well in addition to being able to do a few
    other tricks. However, the true value of GDAL comes from its interaction with
    the next Python module, which we'll examine now.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL 是 Python 中一个极快的地理空间栅格读取器和写入器。它还可以很好地重新投影图像，除了能够执行一些其他技巧之外。然而，GDAL 的真正价值来自于它与下一个
    Python 模块的交互，我们现在将对其进行检查。
- en: NumPy
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy
- en: NumPy is an extremely fast, multidimensional Python array processor designed
    specifically for Python and scientific computing but is written in C. It is available
    via PyPI or as a wheel file (available at [http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy](http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy))
    and can be installed with ease. In addition to its amazing speed, the magic of
    NumPy includes its interaction with other libraries. NumPy can exchange data with
    GDAL, Shapely, the **Python Imaging Library** (**PIL**), and many other scientific
    computing Python libraries in other fields.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 是一个专为 Python 和科学计算设计的极快的多维 Python 数组处理器，但用 C 语言编写。它可以通过 PyPI 或作为 wheel
    文件（可在 [http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy](http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy)
    找到）获得，并且可以轻松安装。除了其惊人的速度外，NumPy 的魔力还包括其与其他库的交互。NumPy 可以与 GDAL、Shapely、**Python
    图像库**（**PIL**）以及许多其他领域的科学计算 Python 库交换数据。
- en: As a quick example of NumPy's ability, we'll combine it with GDAL to read in
    our sample satellite image and then create a histogram of it. The interface between
    GDAL and NumPy is a GDAL module called `gdal_array`, which has NumPy as a dependency.
    Numeric is the legacy name of the NumPy module. The `gdal_array` module imports
    NumPy.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 NumPy 能力的快速示例，我们将将其与 GDAL 结合起来读取我们的示例卫星图像，然后创建其直方图。GDAL 和 NumPy 之间的接口是一个名为
    `gdal_array` 的 GDAL 模块，它依赖于 NumPy。Numeric 是 NumPy 模块的传统名称。`gdal_array` 模块导入 NumPy。
- en: 'In the following example, we''ll use `gdal_array`, which imports NumPy, to
    read the image in as an array, grab the first band, and save it as a JPEG image:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用`gdal_array`，它导入NumPy，将图像作为数组读取，获取第一个波段，并将其保存为JPEG图像：
- en: '[PRE80]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This operation gives us the following grayscale image in OpenEV:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作在OpenEV中给出了以下灰度图像：
- en: '![](img/9e69e56e-1fcd-4829-9bbd-e3f7e5e1e51e.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e69e56e-1fcd-4829-9bbd-e3f7e5e1e51e.png)'
- en: PIL
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PIL
- en: PIL was originally developed for remote sensing but has evolved as a general
    image editing library for Python. Like NumPy, it is written in C for speed but
    is designed specifically for Python. In addition to image creation and processing,
    it also has a useful raster drawing module. PIL is also available via PyPI; however,
    in Python 3, you may want to use the Pillow module, which is an upgraded version
    of PIL. As you'll see in the following example, we can use a Python try statement
    to import PIL using two possible variations, depending on how you installed it.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: PIL最初是为遥感开发的，但已经发展成为一个通用的Python图像编辑库。像NumPy一样，它是用C语言编写的，以提高速度，但它是专门为Python设计的。除了图像创建和处理外，它还有一个有用的栅格绘图模块。PIL也可以通过PyPI获得；然而，在Python
    3中，你可能想使用Pillow模块，它是PIL的升级版本。正如你将在以下示例中看到的那样，我们可以使用Python的try语句以两种可能的方式导入PIL，这取决于你的安装方式。
- en: 'In this example, we''ll combine PyShp and PIL to rasterize the `hancock` shapefile
    from the previous examples and save it as an image. We''ll use a world to pixel
    coordinate transformation similar to our SimpleGIS from [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python*. We''ll create an image to use
    as a canvas in PIL, and then we''ll use the PIL `ImageDraw` module to render the
    polygon. Finally, we''ll save it as a PNG image, as you can see in the following
    lines of code:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将结合PyShp和PIL将前一个示例中的`hancock` shapefile转换为栅格并保存为图像。我们将使用类似于[第1章](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml)中的SimpleGIS的世界到像素坐标转换，即使用Python进行地理空间分析。我们将创建一个图像作为PIL中的画布，然后使用PIL的`ImageDraw`模块来渲染多边形。最后，我们将将其保存为PNG图像，如下面的代码行所示：
- en: '[PRE81]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This example creates the following image:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例创建以下图像：
- en: '![](img/fe5e5ae1-a9ff-4c7e-b9e1-fa1da206b56b.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe5e5ae1-a9ff-4c7e-b9e1-fa1da206b56b.png)'
- en: PNGCanvas
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PNGCanvas
- en: Sometimes, you may find that PIL is overkill for your purposes, or you are not
    allowed to install PIL because you do not have administrative rights to the machine
    that you're using to install Python modules that have been created and compiled
    in C. In those cases, you can usually get away with the lightweight pure Python
    PNGCanvas module. You can install it using `easy_install` or pip.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能发现PIL对于你的目的来说过于强大，或者你不允许安装PIL，因为你没有使用Python模块的C语言创建和编译的机器的管理权限。在这些情况下，你通常可以使用轻量级的纯Python
    PNGCanvas模块来解决问题。你可以使用`easy_install`或pip来安装它。
- en: 'Using this module, we can repeat the raster shapefile example we performed
    using PIL but in pure Python, as you can see here:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模块，我们可以重复使用PIL执行的光栅形状文件示例，但使用纯Python，如下所示：
- en: '[PRE82]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This example gives us a simple outline as PNGCanvas does not have a built-in
    fill method:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例提供了一个简单的轮廓，因为PNGCanvas没有内置的填充方法：
- en: '![](img/a5135eda-4450-4838-8565-64ba2695193f.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5135eda-4450-4838-8565-64ba2695193f.png)'
- en: GeoPandas
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GeoPandas
- en: Pandas is a high-performance Python data analysis library that can handle large
    datasets that are tabular (similar to a database), ordered/unordered, labeled
    matrices, or unlabeled statistical data. GeoPandas is simply a geospatial extension
    to Pandas that builds upon Shapely, Fiona, PyProj, Matplotlib, and Descartes,
    all of which must be installed. It allows you to easily perform operations in
    Python, which would otherwise require a spatial database such as PostGIS. You
    can download a wheel file for GeoPandas from [http://www.lfd.uci.edu/~gohlke/pythonlibs/#panda](http://www.lfd.uci.edu/~gohlke/pythonlibs/#panda).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas是一个高性能的Python数据分析库，可以处理大型表格数据集（类似于数据库），有序/无序，标记矩阵或未标记的统计数据。GeoPandas是Pandas的一个地理空间扩展，基于Shapely、Fiona、PyProj、Matplotlib和Descartes构建，所有这些都必须安装。它允许你轻松地在Python中执行操作，否则可能需要像PostGIS这样的空间数据库。你可以从[http://www.lfd.uci.edu/~gohlke/pythonlibs/#panda](http://www.lfd.uci.edu/~gohlke/pythonlibs/#panda)下载GeoPandas的wheel文件。
- en: 'The following script opens a shapefile and dumps it into GeoJSON. Then, it
    creates a map with `matplotlib`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本打开一个shapefile并将其转换为GeoJSON。然后，它使用`matplotlib`创建一个地图：
- en: '[PRE83]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The following image is the resulting map plot of the previous commands:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像是先前命令的结果地图：
- en: '![](img/930444cb-0f37-407e-875f-dc4c5398b1ff.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/930444cb-0f37-407e-875f-dc4c5398b1ff.png)'
- en: PyMySQL
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyMySQL
- en: The popular MySQL (available at [http://dev.mysql.com/downloads](http://dev.mysql.com/downloads))
    database is gradually evolving spatial functions. It has support for OGC geometries
    and a few spatial functions. It also has a pure Python API available in the PyMySQL
    library. The limited spatial functions use planar geometry and bounding rectangles
    as opposed to spherical geometry and shapes. The latest development release of
    MySQL contains some additional functions that improve this capability.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的 MySQL（可在 [http://dev.mysql.com/downloads](http://dev.mysql.com/downloads)
    获取）数据库正在逐渐发展空间功能。它支持 OGC 几何形状和一些空间函数。它还提供了 PyMySQL 库中的纯 Python API。有限的空间函数使用平面几何和边界矩形，而不是球面几何和形状。MySQL
    的最新开发版本包含一些额外的函数，这些函数提高了这一功能。
- en: In the following example, we'll create a database in MySQL called `spatial_db`.
    Then, we'll add a table called `PLACES` with a geometry column. Next, we'll add
    two cities as point locations. Finally, we'll calculate the distance using MySQL's
    `ST_Distance` function and then convert the result from degrees into miles.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将创建一个名为 `spatial_db` 的 MySQL 数据库。然后，我们将添加一个名为 `PLACES` 的表，其中包含一个几何列。接下来，我们将添加两个城市作为点位置。最后，我们将使用
    MySQL 的 `ST_Distance` 函数计算距离，并将结果从度数转换为英里。
- en: 'First, we will import our `mysql` library and set up the database connection:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将导入我们的 `mysql` 库并设置数据库连接：
- en: '[PRE84]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Next, we get the database cursor:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取数据库游标：
- en: '[PRE85]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, we check if the database already exists, and drop it if it does:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们检查数据库是否已存在，如果存在则将其删除：
- en: '[PRE86]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, we set up a new connection and get a cursor:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们设置一个新的连接并获取游标：
- en: '[PRE87]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next, we can create our new table and add our fields:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建我们的新表并添加我们的字段：
- en: '[PRE88]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'With the fields added, we are ready to insert records for the location of some
    cities:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了字段后，我们就可以为一些城市的地理位置插入记录了：
- en: '[PRE89]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then, we can commit changes to the database:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将更改提交到数据库：
- en: '[PRE90]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, we can query the database! First, we''ll get a list of all of the point
    locations:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查询数据库了！首先，我们将获取所有点位置列表：
- en: '[PRE91]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, we''ll extract the two points from the query results:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从查询结果中提取两个点：
- en: '[PRE92]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Before we can measure the distance, we need to convert the point listings into
    geospatial geometries:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够测量距离之前，我们需要将点列表转换为地理空间几何形状：
- en: '[PRE93]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Finally, we can use the `Distance` stored procedure to measure the distance
    between the two geometries:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `Distance` 存储过程来测量两个几何形状之间的距离：
- en: '[PRE94]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output is as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE95]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: There are other spatial database options available, including PostGIS and SpatiaLite;
    however, Python 3 support for these spatial engines is developmental at best.
    You can access PostGIS and MySQL through the OGR library; however, MySQL support
    is limited.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 其他空间数据库选项也可用，包括 PostGIS 和 SpatiaLite；然而，这些空间引擎在 Python 3 中的支持最多处于开发阶段。您可以通过
    OGR 库访问 PostGIS 和 MySQL；然而，MySQL 的支持有限。
- en: PyFPDF
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyFPDF
- en: 'The pure Python PyFPDF library is a lightweight way to create PDFs, including
    maps. Because the PDF format is a widely used standard, PDFs are commonly used
    to distribute maps. You can install it via PyPI as `fpdf`. The official name of
    the software is PyFPDF because it is a part of the PHP language module called `fpdf`.
    This module uses a concept called a cell to lay items out at specific locations
    on a page. As a quick example, we''ll import the `hancock.png` image we created
    from the PIL example into a PDF called `map.pdf` to create a simple PDF map. The
    map will have the header text at the top that says Hancock County Boundary, followed
    by the map image:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 纯 Python 的 PyFPDF 库是一种创建 PDF（包括地图）的轻量级方式。由于 PDF 格式是一种广泛使用的标准，PDF 通常用于分发地图。您可以通过
    PyPI 以 `fpdf` 的方式安装它。该软件的官方名称是 PyFPDF，因为它 PHP 语言模块 `fpdf` 的一部分。此模块使用一个称为单元格的概念，在页面的特定位置布局项目。作为一个快速示例，我们将从
    PIL 示例中导入的 `hancock.png` 图像放入名为 `map.pdf` 的 PDF 中，以创建一个简单的 PDF 地图。地图顶部将有标题文本，说明汉考克县边界，然后是地图图像：
- en: '[PRE96]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: If you open the PDF file named `map.pdf` in Adobe Acrobat Reader or another
    PDF reader such as Sumatra PDF, you'll see that the image is now centered on an
    A4 page. Geospatial products are often included as part of larger reports, and
    the PyFPDF module simplifies automatically generating reports as PDFs.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 Adobe Acrobat Reader 或其他 PDF 阅读器（如 Sumatra PDF）中打开名为 `map.pdf` 的 PDF 文件，您会看到图像现在位于
    A4 页面的中心。地理空间产品通常作为更大报告的一部分，PyFPDF 模块简化了自动生成 PDF 报告的过程。
- en: Geospatial PDF
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理空间 PDF
- en: The **Portable Document Format**, or **PDF**, is a file format for storing and
    presenting digitally-formatted text and images in a cross-platform and application-independent
    way. PDF is a widely used document format that has also been extended to store
    geospatial information.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**便携式文档格式**，或**PDF**，是一种存储和以跨平台和应用独立的方式呈现数字化文本和图像的文件格式。PDF是一种广泛使用的文档格式，它也被扩展用于存储地理空间信息。'
- en: The PDF specification, starting with version 1.7, includes extensions for geospatial
    PDFs that map portions of the document to a physical space, also known as georeferencing.
    You can create points, lines, or polygons as geospatial geometries, which can
    also have attributes.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: PDF规范从1.7版本开始包括地理空间PDF的扩展，这些扩展将文档的部分映射到物理空间，也称为地理参照。您可以创建点、线或多边形作为地理空间几何形状，这些几何形状也可以有属性。
- en: There are two methods for encoding geospatial information within a PDF. A company
    named TerraGo created a specification that has been adopted by the Open Geospatial
    Consortium as a best practice which is not a standard. That format is known as
    **GeoPDF**. The extensions that were proposed by Adobe Systems, which created
    the PDF specification known as ISO 32000, are currently being incorporated into
    the 2.0 version of the specification.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在PDF内部编码地理空间信息有两种方法。一家名为TerraGo的公司制定了一个规范，该规范已被开放地理空间联盟作为最佳实践采用，但不是一个标准。这种格式被称为**GeoPDF**。Adobe
    Systems提出的扩展，即创建PDF规范的ISO 32000，目前正在纳入规范的2.0版本。
- en: The geospatial PDF products by TerraGo conform to the OGC best practice document
    and the Adobe PDF extension. But TerraGo goes beyond those features to include
    layers and other GIS functionality. However, you must use TerraGo's plugins for
    Adobe Acrobat or other software to access that functionality. At a minimum, TerraGo
    supports the features that are needed to at least display in any PDF software.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: TerraGo的地理空间PDF产品符合OGC最佳实践文档和Adobe PDF扩展。但是，TerraGo超越了这些功能，包括图层和其他GIS功能。然而，您必须使用TerraGo的Adobe
    Acrobat或其他软件的插件来访问这些功能。至少，TerraGo支持至少在PDF软件中显示所需的功能。
- en: In Python, there is a library called `geopdf` which has nothing to do with TerraGo
    but does support the OGC best practice. This library was originally developed
    by Tyler Garner of Prominent Edge ([https://prominentedge.com/](https://prominentedge.com/))
    for Python 2\. It has been ported to Python 3.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有一个名为`geopdf`的库，它与TerraGo无关，但支持OGC最佳实践。这个库最初是由Prominent Edge的Tyler
    Garner开发的，用于Python 2。它已被移植到Python 3。
- en: 'Installing `geopdf` from GitHub is as simple as running the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub安装`geopdf`就像运行以下命令一样简单：
- en: '[PRE97]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The following example recreates the map we created in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python*, in the *Simple GIS* section
    as a geospatial PDF. The `geopdf` library relies on the Python ReportLab PDF library.
    The steps we will need to execute are as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例重新创建了我们在[第1章](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml)，“使用Python学习地理空间分析”，在*简单GIS*部分创建的地图，作为一个地理空间PDF。`geopdf`库依赖于Python的ReportLab
    PDF库。我们需要执行的步骤如下：
- en: Create a PDF drawing canvas.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个PDF绘图画布。
- en: Draw a rectangle for the state of Colorado.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为科罗拉多州绘制一个矩形。
- en: Set up a function to convert map coordinates into screen coordinates.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个函数将地图坐标转换为屏幕坐标。
- en: Draw and label the cities and populations.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制并标注城市和人口。
- en: Register the corners of the state as geospatial PDF coordinates that georeference
    the entire map.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该州的所有角落注册为地理空间PDF坐标，这些坐标将整个地图进行地理参照。
- en: 'The Python code''s comments explain what''s happening in each step:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码的注释解释了每一步发生了什么：
- en: '[PRE98]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Rasterio
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rasterio
- en: The GDAL library we introduced earlier in this chapter is extremely powerful,
    but it wasn't designed for Python. The `rasterio` library solves that problem
    by wrapping GDAL in a very simple, clean Pythonic API for raster data operations.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章早期介绍的GDAL库功能非常强大，但它并不是为Python设计的。`rasterio`库通过将GDAL包装在一个非常简单、干净的Pythonic
    API中，解决了这个问题，用于栅格数据操作。
- en: This example uses the satellite image from the GDAL example in this chapter.
    We'll open the image and get some metadata, like the following
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用本章GDAL示例中的卫星图像。我们将打开图像并获取一些元数据，如下所示
- en: '[PRE99]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: OSMnx
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OSMnx
- en: The `osmnx` library combines **Open Street Map** (**OSM**) and the powerful
    NetworkX library to manage street networks used for routing. This library has
    dozens of dependencies which it rolls up to do all of the complex steps of downloading,
    analyzing, and visualizing street networks.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`osmnx`库结合了**Open Street Map**（**OSM**）和强大的NetworkX库来管理用于路由的街道网络。这个库有数十个依赖项，它将这些依赖项整合起来以执行下载、分析和可视化街道网络的复杂步骤。'
- en: 'You can try to install `osmnx` using `pip`:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`pip`尝试安装`osmnx`：
- en: '[PRE100]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: However, you may run into some installation issues due to the dependencies.
    In that case, it's easier to use the Conda system, which we'll introduce later
    in this chapter.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能会因为依赖项而遇到一些安装问题。在这种情况下，使用我们将在本章后面介绍的Conda系统会更容易一些。
- en: 'The following example uses `osmnx` to download street data from OSM for a city,
    creates a street network from it, and calculates some basic statistics:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`osmnx`从OSM下载城市的街道数据，从中创建街道网络，并计算一些基本统计数据：
- en: '[PRE101]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Jupyter
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jupyter
- en: The Jupyter project is something you should be aware of when working with geospatial
    or other scientific data. The Jupyter Notebook app creates and displays notebook
    documents in a web browser that are human-readable and machine-executable code
    and data. It's great for sharing tutorials for software and has become very common
    in the geospatial Python world.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当您处理地理空间或其他科学数据时，您应该了解Jupyter项目。Jupyter Notebook应用程序在网页浏览器中创建和显示笔记本文档，这些文档是可读和可执行的代码和数据。它非常适合分享软件教程，并在地理空间Python世界中变得非常普遍。
- en: You can find a good introduction for Jupyter Notebooks and Python here: [https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html](https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到Jupyter Notebooks和Python的良好介绍：[https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html](https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html)。
- en: Conda
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Conda
- en: Conda is an open source package management system that makes installing and
    updating complex libraries easier. It works with several languages, including
    Python. Conda is very useful for setting up libraries and testing them so that
    we can try out new things in a development environment. It's usually better to
    custom configure production environments, but Conda is a great way to prototype
    new ideas.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: Conda是一个开源的包管理系统，它使得安装和更新复杂的库变得更加容易。它与多种语言兼容，包括Python。Conda对于设置库和测试它们非常有用，这样我们就可以在开发环境中尝试新事物。通常，自定义配置生产环境会更好，但Conda是原型化新想法的绝佳方式。
- en: You can get started with Conda at [https://conda.io/en/latest/](https://conda.io/en/latest/).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://conda.io/en/latest/](https://conda.io/en/latest/)开始使用Conda。
- en: Summary
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we surveyed the Python-specific tools for geospatial analysis.
    Many of these tools included bindings to the libraries we discussed in [Chapter
    3](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml), *The Geospatial Technology Landscape*,
    for best-of-breed solutions for specific operations such as GDAL's raster access
    functions. We also included pure Python libraries as much as possible and will
    continue to include pure Python algorithms as we work through the upcoming chapters.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了Python特定的地理空间分析工具。许多这些工具都包含了绑定到我们在[第3章](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml)，“地理空间技术景观”中讨论的库，以提供针对特定操作（如GDAL的栅格访问函数）的最佳解决方案。我们还尽可能地包括了纯Python库，并且在我们处理即将到来的章节时将继续包括纯Python算法。
- en: In the next chapter, we'll begin applying all of these tools for GIS analysis.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始应用所有这些工具进行GIS分析。
- en: Further reading
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following links will allow you to explore the topics in this chapter further.
    The first link is about the XPath query language, which we used to filter XML
    elements using Elementree. The second link is the documentation for the Python
    string library, which will be critical throughout this book for manipulating data.
    Third, we have the `lxml` library, one of the more powerful and fast XML libraries. Finally,
    we have Conda, which provides a comprehensive, easy-to-use framework for scientific
    operations in Python, including geospatial technology:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接将帮助您进一步探索本章的主题。第一个链接是关于XPath查询语言，我们使用Elementree来过滤XML元素。第二个链接是Python字符串库的文档，这在本书中对于操作数据至关重要。第三，我们有`lxml`库，这是更强大和快速的XML库之一。最后，我们有Conda，它为Python中的科学操作提供了一个全面、易于使用的框架，包括地理空间技术：
- en: 'For more information on XPath, check out the following link: [http://www.w3schools.com/xsl/xpath_intro.asp](http://www.w3schools.com/xsl/xpath_intro.asp)'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要获取XPath的更多信息，请查看以下链接：[http://www.w3schools.com/xsl/xpath_intro.asp](http://www.w3schools.com/xsl/xpath_intro.asp)
- en: 'For more details on the Python `string` module, check out the following link:
    [https://docs.python.org/3.4/library/string.html](https://docs.python.org/3.4/library/string.html)'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要了解更多关于Python `string`模块的详细信息，请查看以下链接：[https://docs.python.org/3.4/library/string.html](https://docs.python.org/3.4/library/string.html)
- en: 'The documentation on LXML can be found at the following link: [http://lxml.de/](http://lxml.de/)'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LXML的文档可以在以下链接中找到：[http://lxml.de/](http://lxml.de/)
- en: 'You can learn more about Conda at the following link: [https://conda.io/en/latest/](https://conda.io/en/latest/)'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于Conda的信息：[https://conda.io/en/latest/](https://conda.io/en/latest/)
