- en: Chapter 5. Vector Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 向量分析
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Clipping LineStrings to an area of interest
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将线字符串裁剪到感兴趣的区域
- en: Splitting polygons with lines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用线分割多边形
- en: Finding the location of a point on a line using linear referencing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线性参照找到线上的点位置
- en: Snapping a point to the nearest line
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将点捕捉到最近的线上
- en: Calculating 3D ground distance and total elevation gain
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算三维地面距离和总海拔升高
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Vector data analysis is used in many, many application areas, starting from
    measuring the distance from point A to point B all the way through to complex
    routing algorithms. The first GIS systems were built on vector data and vector
    analysis, and then later expanded into the raster domain. In this chapter, we
    will start with simple vector operations, then work our way into a more complex
    model, chaining the various vector methods together to deliver new data that answers
    our spatial questions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 向量数据分析被应用于许多应用领域，从测量点A到点B的距离一直到复杂的路由算法。最早的GIS系统是基于向量数据和向量分析构建的，后来扩展到栅格域。在本章中，我们将从简单的向量操作开始，然后逐步深入到一个更复杂的模型，将各种向量方法串联起来，以提供回答我们空间问题的新的数据。
- en: 'This process of data analysis is broken down into a couple of steps starting
    with an *input* dataset, performing a *spatial operation* on the data such as
    a buffer analysis, and, finally, we''ll have some *output* in the form of a new
    dataset. The following diagram shows the flow of analysis in the simplest model
    form:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据分析过程被分解为几个步骤，从*输入*数据集开始，对数据进行空间操作，如缓冲区分析，最后，我们将有一些*输出*，以新的数据集的形式。以下图表显示了分析流程在
    simplest 模型形式中的流程：
- en: '![Introduction](img/B03543_05_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/B03543_05_01.jpg)'
- en: 'Converting simple questions into spatial operation methods and models takes
    experience and is not a simple task. For example, you may come across a simple
    task such as, "Identify and locate how many residential land parcels were affected
    by the flood." This would translate into the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将简单问题转换为空间操作方法和模型需要经验，并且不是一项简单的任务。例如，你可能会遇到一个简单的任务，比如，“识别并定位受洪水影响的住宅地块数量。”这会转化为以下内容：
- en: Firstly, an input dataset in the form of a flood polygon that defines the affected
    floods areas
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，一个以洪水多边形形式存在的输入数据集，它定义了受影响洪水区域
- en: Secondly, the input dataset represents cadaster polygons
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，输入数据集表示地籍多边形
- en: Our spatial operation is an intersection function
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的空间操作是一个交集函数
- en: All of this results in a new polygon dataset
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些都会导致一个新的多边形数据集
- en: 'This would result in a spatial model that could look like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致一个可能看起来像这样的空间模型：
- en: '![Introduction](img/B03543_05_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/B03543_05_02.jpg)'
- en: To tackle more complex questions, spatial modeling simply starts chaining more
    inputs along with more operations that output new data feeding into other new
    operations. This then leads us to a final set or sets of data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决更复杂的问题，空间建模简单地将更多的输入和更多的操作链在一起，这些操作输出新的数据，并输入到其他新的操作中。这最终导致一组或几组数据。
- en: Clipping LineStrings to an area of interest
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将线字符串裁剪到感兴趣的区域
- en: A project involving spatial data is typically geographically limited to within
    a specified boundary area, the so-called *project area*. The input data can come
    from multiple sources and usually extends outside the project area. Removing this
    excess data is sometimes critical to speed up spatial processes, and at the same
    time, it reduces data volume. Reductions in data volumes can also result in secondary
    speed-ups, for example, less time to transfer or copy the data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个涉及空间数据的工程项目通常在指定的边界区域内进行地理限制，即所谓的*项目区域*。输入数据可能来自多个来源，通常超出项目区域。移除这些多余数据有时对于加快空间处理速度至关重要，同时，它也减少了数据量。数据量的减少也可能导致二级加速，例如，减少数据传输或复制的耗时。
- en: In this recipe, we will take a boundary polygon represented by a circle Shapefile,
    and then remove all excess LineStrings that are outside this circle.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用表示圆形Shapefile的边界多边形，然后移除所有超出这个圆的额外LineStrings。
- en: This process of clipping will remove all lines outside the clip area—that is,
    our project area of interest.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个裁剪过程将移除所有位于裁剪区域之外的所有线条——即，我们的感兴趣的项目区域。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A standard function called `clip` performs an intersection spatial operation.
    This is slightly different from a normal intersection function. The clip will
    NOT or should not retain the attributes attached to the clip area. Clipping involves
    two input datasets; the first defines the boundary that we want to clip our data
    to, and the second defines the data that will be clipped. Both sets contain attributes
    and these attributes of the clipping boundary are usually not included in a clip
    operation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`clip`的标准函数执行空间交集操作。这与正常的交集函数略有不同。裁剪将不会或不应保留附加到裁剪区域上的属性。裁剪涉及两个输入数据集；第一个定义了我们想要裁剪数据到的边界，第二个定义了将被裁剪的数据。这两个集合都包含属性，而裁剪边界的这些属性通常不包括在裁剪操作中。
- en: The new clipped data will only have the attributes from the original input dataset,
    excluding all the attributes from the clip polygon.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 新的裁剪数据将只包含原始输入数据集的属性，不包括裁剪多边形的所有属性。
- en: An `intersection` function will find geometries that overlap and output only
    lines within a circle. To demonstrate this concept better, the following graphical
    representation shows what we are going to achieve.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`intersection`函数将找到重叠的几何形状，并仅输出圆内的线条。为了更好地演示这个概念，以下图形表示了我们将要实现的内容。'
- en: To demonstrate a simple clip operation, we will take a single LineString and
    polygon defining a clip boundary and perform a quick intersect. The result will
    look like what's represented in the following screenshot and can be viewed as
    a live web map in your browser. Refer to the HTML file located at `/code/html/ch05-01-clipping.html`
    to check out the result.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示简单的裁剪操作，我们将使用一条LineString和一个定义裁剪边界的多边形，并执行快速交集操作。结果将类似于以下截图所示，您可以在浏览器中将其视为实时网络地图。请参考位于`/code/html/ch05-01-clipping.html`的HTML文件以查看结果。
- en: '![Clipping LineStrings to an area of interest](img/B03543_05_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![将LineStrings裁剪到感兴趣区域](img/B03543_05_03.jpg)'
- en: When running the simple `intersection` function, the line is cut into two new
    LineStrings as in the preceding screenshot.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行简单的`intersection`函数时，线条将被切割成两个新的LineStrings，如前一个截图所示。
- en: Our second result will use two Shapefiles that represent our inputs. Our real
    data from `OpenStreetMapconverted` is converted to a Shapefile format for our
    input and output. The circle defines our polygon area of interest, while the road
    LineStrings are what we want to clip. Our result will be in the form of a new
    Shapefile that only shows the roads that are inside the circle.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个结果将使用两个代表输入的Shapefiles。我们的真实数据`OpenStreetMapconverted`被转换为Shapefile格式，用于我们的输入和输出。圆定义了我们感兴趣的多边形区域，而道路LineStrings是我们想要裁剪的部分。我们的结果将以新的Shapefile的形式呈现，只显示圆内的道路。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is in two parts. The first part is a simple clip demonstration using
    two GeoJSON files consisting of a single LineString and polygon. The second part
    uses data from OSM and can be found in your `/ch05/geodata` folder containing
    the circle polygon that represents our area of interest named `clip_area_3857.shp`.
    The `roads_london_3857.shp` file represents our input Shapefile of lines that
    we will clip to the circle polygon.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱分为两部分。第一部分是使用两个包含单个LineString和多边形的GeoJSON文件进行的简单裁剪演示。第二部分使用来自OSM的数据，可以在您的`/ch05/geodata`文件夹中找到，其中包含代表我们感兴趣区域的圆形多边形`clip_area_3857.shp`。`roads_london_3857.shp`文件代表我们将要裁剪到圆形多边形的线条输入Shapefile。
- en: To visualize the first part, we use the leaflet JavaScript library in a very
    basic HTML page. Our second resulting Shapefile can then be opened with QGIS to
    see the resulting clipped set of roads.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化第一部分，我们在一个非常基础的HTML页面中使用了leaflet JavaScript库。然后，我们可以使用QGIS打开我们的第二个结果Shapefile，以查看裁剪后的道路集合。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We have two sets of code examples ahead of us. The first is a simple self-made
    set of GeoJSON inputs that are clipped and outputted as a GeoJSON representation.
    This is then visualized using a web page with the help of Leaflet JS.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面前有两套代码示例。第一个是一个简单的自制的GeoJSON输入集，它被裁剪并输出为GeoJSON表示。然后，使用Leaflet JS的帮助，通过网页进行可视化。
- en: The second code example takes in two Shapefiles and returns a clipped Shapefile
    that you can view using QGIS. Both examples use the same method and demonstrate
    how a clipping function works.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个代码示例接受两个Shapefiles，并返回一个裁剪后的Shapefile，您可以使用QGIS查看。这两个示例都使用了相同的方法，并演示了裁剪函数的工作原理。
- en: 'Now, let''s take a look at the first code example:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看第一个代码示例：
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This ends our first code demonstration using a simple self-made GeoJSON LineString
    that's clipped to a simple polygon. This quick recipe is found in the `/code/ch05-01-1_clipping_simple.py`
    file. After you run this file, you can go ahead and open the `/code/html/ch05-01-clipping.html`
    file in your local web browser to see the results.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就结束了我们使用简单自制的GeoJSON LineString进行裁剪的第一次代码演示，该LineString裁剪到一个简单的多边形上。这个快速食谱可以在`/code/ch05-01-1_clipping_simple.py`文件中找到。运行此文件后，您可以在本地网页浏览器中打开`/code/html/ch05-01-clipping.html`文件以查看结果。
- en: It works by defining an output JavaScript file that is used to visualize our
    clipped results. This is followed by our input clipping areas and the LineString
    to be clipped as GeoJSON. We'll convert our GeoJSON to shapely geometry objects
    with the `ashape()` function so that we can run the intersection. The resulting
    intersection geometry is then converted from a shapely geometry into a GeoJSON
    file that is written to our output JavaScript file, which is used inside the `.html`
    file for visualization with Leaflet.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它通过定义一个输出JavaScript文件来实现，该文件用于可视化我们的裁剪结果。接下来是我们的输入裁剪区域和要裁剪的LineString作为GeoJSON。我们将使用`ashape()`函数将我们的GeoJSON转换为shapely几何对象，以便我们可以运行交点操作。然后，将结果交点几何对象从shapely几何对象转换为GeoJSON文件，并将其写入我们的输出JavaScript文件，该文件用于在`.html`文件内部使用Leaflet进行可视化。
- en: 'To begin our second code example located in the `/code/ch05-01-2_clipping.py`
    file, we will input two Shapefiles, create a new set of roads that are clipped
    to our circle polygon, and export them as Shapefiles:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始位于`/code/ch05-01-2_clipping.py`文件中的第二个代码示例，我们将输入两个Shapefiles，创建一组新的道路，这些道路裁剪到我们的圆形多边形上，并将它们作为Shapefiles导出：
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For this recipe, we'll use Shapely for our spatial operation and pyshp to read
    in and out of our Shapefiles.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用Shapely进行空间操作，并使用pyshp来读取和写入我们的Shapefiles。
- en: We'll begin with the import of the road LineStrings and our circle polygon for
    the demo project area. We'll use the `pyshp` module to handle the Shapefile input/output.
    `Pyshp` allows us to access the Shapefile bounds, feature geometry, feature attributes,
    and more.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始导入用于演示项目区域的道路LineStrings和圆形多边形。我们将使用`pyshp`模块来处理Shapefile的输入/输出。`Pyshp`允许我们访问Shapefile的边界、要素几何、要素属性等。
- en: Our first task is to convert the `pyshp` geometry object into something that
    `Shapely` can understand. We'll use the `shape()` function to get the `pyshp`
    geometry followed by the Shapely `asShape()` function. Next, we'll want all the
    records of roads so that we can use `shapeRecords()` to return these records for
    us.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是将`pyshp`几何对象转换为Shapely可以理解的形式。我们将使用`shape()`函数获取`pyshp`几何对象，然后使用Shapely的`asShape()`函数。接下来，我们希望获取所有道路记录，以便我们可以使用`shapeRecords()`函数返回这些记录。
- en: Now, we'll get ourselves ready to perform the actual clipping by setting up
    two list variables to store our new data. The *for* loop runs over each record,
    that is, each line in the road dataset, converts it to a shapely geometry object
    using `geo_interface,` and is built in the pyshp function. This is then followed
    by the actual `intersection` shapely function that only returns geometry that
    *intersects* our circle. Finally, we'll check to see if the intersection geometry
    is a LineString. If it is, we'll append it to our output list.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为实际裁剪做好准备，通过设置两个列表变量来存储我们的新数据。`for`循环遍历每个记录，即道路数据集中的每一行，使用`geo_interface`将其转换为shapely几何对象，并在pyshp函数中构建。然后，跟随实际的`intersection`
    shapely函数，该函数只返回与我们的圆相交的几何对象。最后，我们将检查交点几何对象是否为LineString。如果是，我们将将其追加到我们的输出列表中。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: During an intersection operation, Shapely will return points and LineStrings
    in a geometry collection. The reason for this is that, if two LineStrings touch
    at the ends, for example, or overlap each other, it will generate a point intersection
    location plus any overlapping segments.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在交点操作过程中，Shapely将在一个几何集合中返回点和LineStrings。这样做的原因是，如果两个LineStrings在末端接触，例如，或者相互重叠，它将生成一个点交点位置以及任何重叠的段。
- en: At last, we can write out our new dataset to a new Shapefile. Using the pyshp
    `writer()` function, we create a new object and give it one single field called
    `name`. Looping through each feature, we can create a GeoJSON object using the
    shapely mapping function and an empty pyhsp record that we will add to it in a
    moment. We want to add the point coordinates from our GeoJSON and append them
    together.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将我们的新数据集写入一个新的Shapefile。使用pyshp的`writer()`函数，我们创建一个新的对象，并给它一个名为`name`的单个字段。遍历每个要素，我们可以使用shapely映射函数和一个空的pyhsp记录来创建一个GeoJSON对象，我们将在稍后将其添加到其中。我们希望添加来自GeoJSON的点坐标并将它们一起附加。
- en: Exiting the loop, we'll save our new Shapefile `roads_clipped.shp` to disk.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 退出循环后，我们将我们的新Shapefile `roads_clipped.shp`保存到磁盘。
- en: Splitting polygons with lines
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线条分割多边形
- en: Typically, in GIS, we work with data that influences other data in some form
    due to their inherit spatial relationship. This means that we need to work with
    one dataset to edit, update, and even delete another dataset. A typical example
    of this is an administrative boundary, which is a polygon that you cannot see
    on a physical surface but that influences feature information it crosses such
    as a lake. If we have a lake polygon and an administrative boundary, we might
    want to know how many square meters of lake belongs to each administrative boundary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在GIS中，我们处理的数据以某种形式影响其他数据，这是由于它们固有的空间关系。这意味着我们需要处理一个数据集来编辑、更新甚至删除另一个数据集。一个典型的例子是行政边界，这是一个你无法在物理表面上看到的但会影响它所穿越的特征信息的多边形，例如湖泊。如果我们有一个湖泊多边形和一个行政边界，我们可能想知道每个行政边界属于多少平方米的湖泊。
- en: Another example could be a forest polygon that contains one species of trees
    that crosses a river. We might want to know the area on either side of the river.
    In the first scenario, we need to transform our administrative boundaries into
    LineStrings and then perform the cut.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子可能是一个包含一种树木种类且横跨河流的森林多边形。我们可能想知道河流两侧的面积。在第一种情况下，我们需要将我们的行政边界转换为LineStrings，然后执行切割操作。
- en: To see what this looks like, take a look at this spoiler on how the results
    will look up front since we all like a good visual.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这看起来像什么，看看这个预告，看看结果将如何，因为我们都喜欢一个好的视觉效果。
- en: '![Splitting polygons with lines](img/B03543_05_04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![使用线条分割多边形](img/B03543_05_04.jpg)'
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will once again use our GeoJSON LineString and polygon from
    the previous recipe. These homemade geometries will cut up our polygon into three
    new polygons. Be sure to fire up your virtual environment with the `workon pygeoan_cb`
    command.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们还将再次使用我们之前菜谱中的GeoJSON LineString和polygon。这些自制的几何形状将把我们的多边形切割成三个新的多边形。确保使用`workon
    pygeoan_cb`命令启动你的虚拟环境。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This code example is located at `/code/ch05-02_split_poly_with_line.py` as
    follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个代码示例位于`/code/ch05-02_split_poly_with_line.py`，如下所示：
- en: '[PRE2]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now the actual splitting of the polygons takes place in our `/ch05/code/ch05-02_split_poly_with_line.py`
    script.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在多边形的实际分割操作发生在我们的`/ch05/code/ch05-02_split_poly_with_line.py`脚本中。
- en: The basic methodology to split a polygon based on a LineString follows this
    simple algorithm. First, we'll take our input polygon and convert the boundaries
    of this polygon into a new LineString dataset. Next up, we'll combine the LineString
    we want to use to cut the newly generated polygon LineStrings of boundaries. Finally,
    we use the `polygonize` method to rebuild polygons based on the new union set
    of LineStrings.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 基于LineString分割多边形的基本方法遵循这个简单的算法。首先，我们将我们的输入多边形转换为新的LineString数据集的边界。接下来，我们将我们想要用来切割新生成的多边形边界LineStrings的LineString组合起来。最后，我们使用`polygonize`方法根据新的LineStrings联合集重建多边形。
- en: This rebuilding of polygons results in extra polygons that are created outside
    the original polygon. To identify these polygons, we'll use a simple trick. We
    can simply generate a `centroid` point inside each newly created polygon and then
    check to see if this point is inside the original polygon using the `within` predicate.
    If the point is not inside the original polygon, the predicate returns `False`
    and we do not need to include this polygon in our output.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种多边形重建的结果是在原始多边形外部创建的额外多边形。为了识别这些多边形，我们将使用一个简单的技巧。我们可以在每个新创建的多边形内部生成一个`centroid`点，然后检查这个点是否在原始多边形内部使用`within`谓词。如果点不在原始多边形内部，谓词返回`False`，我们不需要将这个多边形包含在我们的输出中。
- en: Finding the location of a point on a line using linear referencing
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线性参照找到线上的点位置
- en: The use of linear referencing is widespread, ranging from storing bus routes
    to oil and gas pipelines. Our ability to locate any position along a line based
    on a distance value from the start of the line is done using the interpolation
    methodology. We want to interpolate a point location at any position along a line.
    To determine the position, we'll use simple mathematics to calculate the position
    along a line based on the distance from the starting coordinate.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 线性引用的使用非常广泛，从存储公交路线到石油和天然气管道。我们根据从线起始点的距离值定位任何位置的能力是通过插值方法实现的。我们想要在线的任何位置插值一个点位置。为了确定位置，我们将使用简单的数学来根据起始坐标的距离计算线上的位置。
- en: For our calculation, we'll measure the length of the line and find a coordinate
    located at a specified length from the start of the line. However, the question
    of where the start of the line is will soon arise. The starting point of the line
    is the first coordinate in the LineString's array of vertexes that make up the
    LineString because a LineString is nothing more than a collection of points chained
    together.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的计算，我们将测量线的长度，并找到一个位于线起始点指定长度的坐标。然而，关于线起始点在哪里的问题很快就会出现。线的起始点是构成LineString的顶点数组中的第一个坐标，因为LineString不过是一系列点连在一起。
- en: This will lead nicely to our next recipe, which is a little more complex.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将很好地引出我们的下一个菜谱，它稍微复杂一些。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This is our shortest code snippet; check it out:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们的最短代码片段；来看看：
- en: '[PRE3]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After executing the `/code/ch05-03_point_on_line.py` file, you should see the
    following screenshot when you open the `/code/html/ch05-03.html` file in your
    web browser:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行`/code/ch05-03_point_on_line.py`文件后，当你用你的网络浏览器打开`/code/html/ch05-03.html`文件时，你应该会看到以下截图：
- en: '![How to do it...](img/B03543_05_05.jpg)'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/B03543_05_05.jpg)'
- en: If you would like to reverse the LineString starting and ending points, you
    can use the `list(shply_line.coords)[::-1]` code to reverse the coordinate order
    as shown in the preceding code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要反转LineString的起始和结束点，你可以使用`list(shply_line.coords)[::-1]`代码来反转坐标顺序，如前述代码所示。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It all boils down to executing one single line of code to locate a point on
    a line specified at a certain distance. The shapely interpolate function does
    this for us. All you need is the shapely LineString geometry and a distance value.
    The distance value is the distance from the 0,0 start coordinate of the LineString.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切归结为执行一行代码来定位一个在特定距离上的线上的点。Shapely插值函数为我们做了这件事。你所需要的只是Shapely LineString几何形状和一个距离值。距离值是LineString的0,0起始坐标的距离。
- en: Be careful in case the LineString direction is not the correct form in which
    you want to measure it. This would mean that you need to switch the LineString
    direction. Take a look at the `line_reversed` variable that holds the original
    LineString with a reversed order. To do the `reverse`, we'll use a simple python
    string operation, `[::-1]`, to reverse our LineString list.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果LineString的方向不是你想要测量的正确形式，请小心。这意味着你需要切换LineString的方向。看看`line_reversed`变量，它持有原始LineString，顺序被反转。为了进行`reverse`操作，我们将使用简单的Python字符串操作`[::-1]`来反转我们的LineString列表。
- en: 'You can see this in action with our print statement reversing the LineString
    order on screen as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下屏幕截图中的打印语句看到这一功能的作用：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: See also
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you are interested in more information regarding linear referencing, ESRI
    has a great reference of use cases and examples at [http://resources.arcgis.com/en/help/main/10.1/0039/003900000001000000.htm](http://resources.arcgis.com/en/help/main/10.1/0039/003900000001000000.htm)
    and [http://en.wikipedia.org/wiki/Linear_referencin](http://en.wikipedia.org/wiki/Linear_referencin).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更多关于线性引用的信息，ESRI在[http://resources.arcgis.com/en/help/main/10.1/0039/003900000001000000.htm](http://resources.arcgis.com/en/help/main/10.1/0039/003900000001000000.htm)和[http://en.wikipedia.org/wiki/Linear_referencin](http://en.wikipedia.org/wiki/Linear_referencin)提供了很好的用例和示例。
- en: Snapping a point to the nearest line
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将点捕捉到最近的线上
- en: Building on our newly gained wisdom from the last recipe, we will now attack
    another common spatial problem. This super common spatial task is for all the
    GPS junkies who want their GPS coordinates to snap to an existing road. Imagine
    that you have some GPS tracks and you want to have these coordinates snap to your
    base road dataset. To accomplish such a task, we need to snap a point (GPS coordinates)
    to a line (roads).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在上一菜谱中获得的新知识的基础上，我们现在将解决另一个常见空间问题。这个超级常见空间任务是为所有想要将GPS坐标捕捉到现有道路上的GPS爱好者准备的。想象一下，你有一些GPS轨迹，你想要将这些坐标捕捉到你的基础道路数据集中。为了完成这个任务，我们需要将一个点（GPS坐标）捕捉到一条线（道路）上。
- en: The `geos` library is what `Shapely` is built on and can handle this problem
    with ease. We will combine the use of the `shapely.interpolate` and `shapely.project`
    functions to snap our point to the true nearest point on the line using linear
    referencing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`geos`库是`Shapely`构建的基础，可以轻松处理这个问题。我们将结合使用`shapely.interpolate`和`shapely.project`函数，通过线性引用将我们的点捕捉到线上的真实最近点。'
- en: As you can see in the following diagram, our input point is located on the sun
    icon. The green line is what we want to snap our point to at the nearest location.
    The gray icon with a point on it is our result that represents the nearest point
    on the line from our original x position.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，我们的输入点位于太阳图标上。绿色线是我们想要将点捕捉到最近位置的地方。带有点的灰色图标是我们的结果，它代表从原始x位置到线上的最近点。
- en: '![Snapping a point to the nearest line](img/B03543_05_06.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![将点捕捉到最近线上](img/B03543_05_06.jpg)'
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Shapely is well suited for snapping a point to the nearest line, so let''s
    get started:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Shapely非常适合将点捕捉到最近的线上，让我们开始吧：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We''ll use a tried and tested methodology called **linear referencing** to
    do the work. Let''s kick it off with the imports needed to do this, including
    `shapely.geometry asShape`, `json`, and `pyproj`'' Pyproj is used to quickly transform
    our coordinates to and from EPSG: 4326 and EPSG 3857\. Shapely works on planar
    coordinates and cannot work directly with `lat`/`lon` values.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将使用一种经过验证的方法，称为**线性引用**来完成这项工作。让我们从完成这项工作所需的导入开始，包括`shapely.geometry asShape`、`json`和`pyproj`。Pyproj用于快速将我们的坐标从EPSG:
    4326和EPSG 3857转换过来和转换回去。Shapely在平面坐标上工作，不能直接使用`lat`/`lon`值。'
- en: Extending our functions from the last recipe, we have the `transform_point()`
    function alongside the `transform_geom()` function. The `transform_point()` function
    converts a Shapely geometry to GeoJSON and transforms the point coordinate, while
    the `transform_geom()` function takes GeoJSON in and transforms it to the new
    coordinate system. Both functions use pyproj to execute the transformations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一个菜谱扩展我们的函数，我们有了`transform_point()`函数和`transform_geom()`函数。`transform_point()`函数将Shapely几何体转换为GeoJSON并转换点坐标，而`transform_geom()`函数接收GeoJSON并转换为新的坐标系。这两个函数都使用pyproj来执行转换。
- en: Next, we'll define our output GeoJSON file and the input line and point features.
    Then, we'll execute our two new transform functions followed closely with the
    conversion into a Shapely geometry object. This new Shapely geometry is then run
    through the interpolate function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义我们的输出GeoJSON文件和输入线要素和点要素。然后，我们将执行我们的两个新转换函数，紧接着是将它们转换为Shapely几何对象。这个新的Shapely几何对象随后通过插值函数运行。
- en: Interpolate alone does not answer our question. We need to combine its usage
    with the Shapely `project` function that takes in the original point and projects
    it onto the line.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用插值并不能回答我们的问题。我们需要将其与Shapely的`project`函数结合使用，该函数接收原始点并将其投影到线上。
- en: We then print out our results to screen and create a new JavaScript file called
    `/geodata/ch05-04-geojson.js,` used in our `/code/html/ch05-04.html` for viewing.
    Go ahead and open the HTML file in your browser to see the results.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将结果打印到屏幕上，并创建一个新的JavaScript文件`/geodata/ch05-04-geojson.js`，用于在`/code/html/ch05-04.html`中查看。请打开浏览器中的HTML文件以查看结果。
- en: 'Take a look at your console to see the print to console statements that show
    us the point coordinates and distances from the original as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 查看你的控制台，以查看以下打印到控制台语句，显示点坐标和从原始点的距离：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Calculating 3D ground distance and total elevation gain
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算三维地面距离和总海拔升高
- en: We've finished finding points on lines and returning points on a line, so now,
    it is time to calculate the true ground 3D distance that we actually ran or biked
    along a real 3D road. It is also possible to calculate the elevation profile and
    we will see this in the [Chapter 7](ch07.html "Chapter 7. Raster Analysis"), *Raster
    Analysis*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了在直线上找到点并返回直线上的点的工作，现在，是时候计算我们实际上沿着真实3D道路跑或骑行的真实地面3D距离了。还可以计算高程剖面，我们将在[第7章](ch07.html
    "第7章。栅格分析") *栅格分析* 中看到这一点。
- en: Calculating the ground distance sounds easy, but 3D calculations are more complicated
    to calculate than 2D. Our 3D LineString has a z-coordinate for each vertex that
    makes up our LineString. Therefore, we need to calculate the 3D distance between
    each set of coordinates, —that is, from vertex to vertex in our input LineString.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 计算地面距离听起来很简单，但3D计算比2D计算更复杂。我们的3D LineString为组成LineString的每个顶点都有一个z坐标。因此，我们需要计算每对坐标之间的3D距离，即从输入LineString的顶点到顶点的距离。
- en: 'The mathematics to calculate the distance between two 3D Cartesian coordinates
    is relatively simple and uses the 3D form of the Pythagoras formula:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 计算两个3D笛卡尔坐标之间距离的数学方法相对简单，使用了毕达哥拉斯公式的3D形式：
- en: '*3d_distance = square root √ ( (x2 – x1) ² + (y2 – y1) ² + (z2 -z1)²)*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*3d_distance = 平方根 √ ( (x2 – x1) ² + (y2 – y1) ² + (z2 -z1)²)*'
- en: 'Here it is in Python:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Python代码示例：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: First up, we will get our hands on some 3D data to play with and what better
    to analyze than the Stage 16 Carcassonne/Bagnères-de-Luchon of the Tour de France
    2014 mountain stage, a real killer. Here are some stats from [www.letour.com](http://www.letour.com),
    including the 237.5 km length, Michael Rogers' winning time of 6:07:10, the average
    speed of 38.811 km/h, and the highest point of 1753 m. You will find the data
    in your folder at `/ch05/geodata/velowire_stage_16_27563_utf8.geojson`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将获取一些3D数据来进行分析，还有什么比分析2014年环法自行车赛第16赛段（卡卡斯/巴涅尔-德-卢什翁）的山地赛段更好的呢？这是一个真正的挑战。以下是从
    [www.letour.com](http://www.letour.com) 获取的一些统计数据，包括237.5公里的长度，迈克尔·罗杰斯的获胜时间为6:07:10，平均速度为38.811公里/小时，最高点为1753米。您将在您的文件夹中找到这些数据，位于
    `/ch05/geodata/velowire_stage_16_27563_utf8.geojson`。
- en: The original KML was generously provided by Thomas Vergouwen ([www.velowire.com](http://www.velowire.com))
    and it is free for us to use with his permission; thanks, Thomas. The original
    data is located at `/ch05/geodata/velowire_stage_16-Carcassonne-Bagneres-de-Luchon.kml`.
    The conversion to *GeoJSON* and the transformation to EPSG:27563 was done using
    the QGIS `save as` function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的KML文件由Thomas Vergouwen慷慨提供([www.velowire.com](http://www.velowire.com))，并且在他的许可下我们可以免费使用；谢谢，Thomas。原始数据位于
    `/ch05/geodata/velowire_stage_16-Carcassonne-Bagneres-de-Luchon.kml`。将数据转换为 *GeoJSON*
    并转换为EPSG:27563是通过使用QGIS的 `另存为` 功能完成的。
- en: Now, according to the LA Times web page ([http://www.latimes.com/la-sp-g-tour-de-france-stage-elevation-profile-20140722-htmlstory.html](http://www.latimes.com/la-sp-g-tour-de-france-stage-elevation-profile-20140722-htmlstory.html)),
    they've quoted a 3895 m elevation gain. As compared to team Strava ([http://blog.strava.com/tour-de-france-2014/](http://blog.strava.com/tour-de-france-2014/))
    where they've stated a 4715 m elevation gain. Now, who is correct and is this
    237.5 km ground distance in 3D? Let's find out!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据《洛杉矶时报》网页([http://www.latimes.com/la-sp-g-tour-de-france-stage-elevation-profile-20140722-htmlstory.html](http://www.latimes.com/la-sp-g-tour-de-france-stage-elevation-profile-20140722-htmlstory.html))，他们引用了3895米的高程上升。与Strava团队([http://blog.strava.com/tour-de-france-2014/](http://blog.strava.com/tour-de-france-2014/))相比，他们声称上升了4715米。现在，谁是对的，这个3D中的237.5公里地面距离是多少？让我们找出答案！
- en: 'This is the official profile of Stage 16 for your visual pleasure:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是官方的第16赛段的剖面图，供您欣赏：
- en: '![Getting ready](img/B03543_05_07.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/B03543_05_07.jpg)'
- en: 'To give you an idea of what accurate and simplified data looks like, take a
    look at this comparison of the velowire''s site''s ([www.velowire.com](http://www.velowire.com))
    KML marked in purple (accurate) and the bikemap site''s progression highlighted
    by yellow line (simplified). If you sum up the differences, the length and elevation
    are both significantly different for both. For a race that''s 237.5 km long, every
    meter counts when you''re planning and attacking on the course. In the following
    screenshot, you can see the comparison of the velowire site''s KML marked in purple
    and the bikemap site''s progression highlighted by the yellow line:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解准确和简化数据看起来像什么，请看看这个紫色（准确）标记的velowire网站（[www.velowire.com](http://www.velowire.com)）的KML和用黄色线条突出显示的bikemap网站的进度（简化）。如果你把差异加起来，长度和海拔对于237.5公里长的比赛来说都显著不同。在规划和对阵过程中，每米都很重要。在下面的屏幕截图中，你可以看到紫色标记的velowire网站的KML和用黄色线条突出显示的bikemap网站的进度：
- en: '![Getting ready](img/B03543_05_08.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/B03543_05_08.jpg)'
- en: 'Data source: [http://www.mapcycle.com.au/LeTour2014/#](http://www.mapcycle.com.au/LeTour2014/#)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 数据来源：[http://www.mapcycle.com.au/LeTour2014/#](http://www.mapcycle.com.au/LeTour2014/#)
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We'll start with looping through each vertex and calculating the 3D distance
    from one vertex to another in our LineString. Each vertex is nothing more than
    a point with *x*, *y*, and *z* (3D Cartesian) values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从遍历每个顶点并计算LineString中从一个顶点到另一个顶点的3D距离开始。每个顶点不过是一个具有*x*、*y*和*z*（3D笛卡尔）值的点。
- en: 'Here is the code to calculate each vertex:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是计算每个顶点的代码：
- en: '[PRE8]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We need to transform our original KML file stored in EPSG: 4326 to a planar
    coordinate system to facilitate our calculations (refer to the upcoming table).
    So, we''ll begin by transforming the KML into EPSG: 27563 NTF Paris / Lambert
    Sud France. For further information on this, refer to [http://epsg.io/27563](http://epsg.io/27563).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要将存储在EPSG: 4326中的原始KML文件转换为平面坐标系，以方便我们的计算（参考即将到来的表格）。因此，我们将首先将KML转换为EPSG:
    27563 NTF Paris / Lambert Sud France。有关此信息的更多信息，请参阅[http://epsg.io/27563](http://epsg.io/27563)。'
- en: To begin with, we'll define three functions for our calculations starting with
    the `pairs()` function that takes a list and then uses the Python yield generator
    function to yield two sets of values. The first set of values is the starting
    x, y, and z coordinates, and the second set includes the ending x, y, and z coordinates
    of the coordinate pairs that we want to measure.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义三个用于计算的函数，从`pairs()`函数开始，它接受一个列表，然后使用Python yield生成器函数来产生两组值。第一组值是起始x、y和z坐标，第二组包括我们想要测量的坐标对的结束x、y和z坐标。
- en: The `calc_3d_distancte_2pts()` function takes the two coordinate pairs, including
    the important z value, and calculates the distance between two points in 3D space
    using the Pythagorean theorem.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc_3d_distancte_2pts()`函数接受两个坐标对，包括重要的z值，并使用勾股定理计算3D空间中两点之间的距离。'
- en: Our `readin_json()` function inputs a path to a file, and in this case, we can
    point it to our GeoJSON file stored in the `/ch05/geodata` folder. This will return
    a Python dictionary object for us to work with within the next few steps.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`readin_json()`函数输入一个文件路径，在这种情况下，我们可以将其指向存储在`/ch05/geodata`文件夹中的GeoJSON文件。这将返回一个Python字典对象，我们可以在接下来的几个步骤中使用它。
- en: Now, let's define the variables to hold our GeoJSON file, load this file, and
    set the starting 3D/2D lengths to zero for initialization.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义变量来保存我们的GeoJSON文件，加载此文件，并将起始3D/2D长度初始化为零。
- en: Next up, let's iterate through the GeoJSON LineString features and convert them
    into a Shapely object so that we can use Shapely to tell us the inherent 2D length
    as used by our `length_2d` variable and read the coordinates. This is followed
    by our `for` loop where all the action occurs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将遍历GeoJSON LineString特征并将它们转换为Shapely对象，以便我们可以使用Shapely来告诉我们`length_2d`变量所使用的固有2D长度并读取坐标。这之后是我们的`for`循环，所有的动作都发生在这里。
- en: Looping over our new list created by our `pairs()` function, we can loop over
    each vertex of a LineString. We define the `line_start` and `line_end` variables
    to identify the start of each new line segment that we need to access with a single
    LineString feature. We'll follow up by then defining our input parameters to do
    the 3D distance calculations by parsing our list object with standard Python positional
    slicing. At last, we'll call the `calc_3d_distance_2pts()` function to give us
    our distance in 3D.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遍历由我们的`pairs()`函数创建的新列表，我们可以遍历LineString的每个顶点。我们定义`line_start`和`line_end`变量来识别我们需要通过单个LineString特征访问的每个新线段的开头。然后，我们将通过解析我们的列表对象来定义我们的输入参数，使用标准的Python位置切片进行3D距离计算。最后，我们将调用`calc_3d_distance_2pts()`函数来给出我们的3D距离。
- en: We need to iteratively sum the distances together from one segment to the next.
    We can do this by adding the distance to our `length_3d` with `+=` operator. Now,
    our `length_3d` variable is updated for each segment in the loop, giving us our
    desired 3D length.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要迭代地将从一个段落到下一个段落的距离相加。我们可以通过使用`+=`运算符将距离添加到我们的`length_3d`中来实现这一点。现在，`length_3d`变量在循环中的每个段落都会更新，从而给出我们想要的3D长度。
- en: The remaining part of the loop calculates our elevation gain. Our `z1` and `z2`
    elevation values need to be constantly compared to additively add the total elevation
    gain only if the next value is greater than the last. If not, set them to equal
    each other and continue to the next *z* value. The `elevation_gain` variable is
    then constantly updated to itself if there's no change; otherwise not, the difference
    between the two elevations is added.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的剩余部分计算我们的海拔升高。我们的`z1`和`z2`海拔值需要不断比较，只有当下一个值大于上一个值时，才将总海拔升高累加。如果不是，将它们设置为相等，并继续到下一个*z*值。然后，如果没有任何变化，`elevation_gain`变量会不断更新为自己；否则，两个海拔之间的差值会被累加。
- en: 'At last, we''ll print out our results to the screen; they should look like
    this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将结果打印到屏幕上；它们应该看起来像这样：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With our data transformed and converted to GeoJSON, the 2D length according
    to our script is 243.558 km from the velowire KML as compared to 237.5 km from
    the official race page, which is a difference of 6.058 km. The original KML in
    EPSG:4326 was 302.805 km long, a difference of over 65 km, hence the necessary
    transformation. For a better comparison, take a look at this table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的数据转换并转换为GeoJSON，根据我们的脚本，2D长度为从velowire KML的243.558 km，与官方比赛页面上的237.5 km相比，差异为6.058
    km。原始EPSG:4326的KML长度为302.805 km，差异超过65 km，因此需要进行转换。为了更好地比较，请查看以下表格：
- en: '| Source + EPSG | 2D length | 3D length | Difference |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 来源 + EPSG | 2D长度 | 3D长度 | 差异 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Velowire EPSG:4326 | 302.805 km | This is not calculated |   |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| Velowire EPSG:4326 | 302.805 km | 这不是计算得出的 |   |'
- en: '| **Velowire EPSG:27563** | **243.558 km** | **244.12** | **561.14 m** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **Velowire EPSG:27563** | **243.558 km** | **244.12** | **561.14 m** |'
- en: '| Mapcycle EPSG:4326 | 293.473 km | This data is not available |   |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| Mapcycle EPSG:4326 | 293.473 km | 此数据不可用 |   |'
- en: '| Mapcylce EPSG:27563 | 236.216 km | This data is not available |   |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| Mapcylce EPSG:27563 | 236.216 km | 此数据不可用 |   |'
- en: '| Letour official | 237.500 km (approximate) | 237.500 km (approximate) |  
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| Letour官方 | 237.500 km（近似） | 237.500 km（近似） |   |'
- en: The elevation gain is also very different between different sources.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 海拔升高在不同来源之间也非常不同。
- en: '| Source | Elevation gain |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 来源 | 海拔升高 |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Strava ([http://blog.strava.com/](http://blog.strava.com/)) | 4715 m |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| Strava ([http://blog.strava.com/](http://blog.strava.com/)) | 4715 m |'
- en: '| Los Angeles Times | 3895 m |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| Los Angeles Times | 3895 m |'
- en: '| TrainingPeaks ([www.trainingpeaks.com](http://www.trainingpeaks.com)) | 3243
    m |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| TrainingPeaks ([www.trainingpeaks.com](http://www.trainingpeaks.com)) | 3243
    m |'
- en: '| The Velowire KML data analysis | 4322 m |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| Velowire KML数据分析 | 4322 m |'
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The accuracy of all these calculations is based on the original KML data source.
    Each data source is/was derived by different people and, possibly, different methods.
    The more you know about your data source, the more you know about its accuracy.
    In this case, I assume that the Velowire data source was digitized by hand using
    Google Earth. Thus, the accuracy is only as accurate as that of the underlying
    Google Earth imagery and coordinate system, which is EPSG:3857.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些计算的准确性都基于原始的KML数据源。每个数据源都是由不同的人以及可能不同的方法推导出来的。你对你的数据源了解得越多，你对它的准确性了解得就越多。在这种情况下，我假设Velowire数据源是使用Google
    Earth手动数字化的。因此，准确性只能与底层Google Earth影像和坐标系统（EPSG:3857）的准确性相当。
