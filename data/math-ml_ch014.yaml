- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Matrices and Graphs
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵与图
- en: Now that we have gotten past the hard part (that is, the singular value decomposition
    and other matrix factorizations), it’s time to finish our journey through linear
    algebra with a bang. In my teaching experience, one of students’ most common concerns
    is the apparent disconnect between practice and theory. Among machine learning
    practitioners and software engineers, there’s often a reluctance to touch anything
    that is not immediately valuable in practice.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经度过了困难的部分（即奇异值分解和其他矩阵分解），是时候以一个震撼的结尾完成我们的线性代数之旅了。在我的教学经验中，学生们最常见的一个担忧是实践与理论之间的明显脱节。在机器学习从业者和软件工程师中，通常有一种不愿接触那些在实践中不立即有价值的内容的倾向。
- en: As a mathematician, I completely get where this dread comes from. We are often
    taught arcane topics of no practical importance, taking valuable time away from
    hacking and slashing our way through data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名数学家，我完全理解这种恐惧的来源。我们常常被教授一些无实际意义的深奥话题，浪费了宝贵的时间，而这些时间本可以用来通过数据进行快速的分析和处理。
- en: In this chapter, we’ll look at a subject that is not immediately useful for
    your machine learning practice, but will pay serious dividends in the future.
    Considering how beautiful it is, it might be the inspiration for your next genius
    idea. (No promises, though.)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一个对你的机器学习实践不立即有用，但未来会带来丰厚回报的主题。考虑到它的美丽，它或许会成为你下一个天才创意的灵感来源。（不过不敢保证。）
- en: 'Let me introduce you to the single most undervalued fact of linear algebra:
    matrices are graphs, and graphs are matrices. Encoding matrices as graphs is a
    cheat code, making complex behavior simple to study.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你介绍线性代数中最被低估的事实：矩阵就是图，图就是矩阵。将矩阵编码为图是一种作弊方式，使得复杂的行为变得容易研究。
- en: Check out Figure [8.1](#) below.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看下面的图[8.1](#)。
- en: '![PIC](img/file806.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file806.png)'
- en: 'Figure 8.1: A matrix and its directed graph'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：一个矩阵及其有向图
- en: 'Can you figure out how it was constructed? Can you guess why it is useful?
    We’ll answer these questions in the next couple of pages. Specifically, we’ll
    see:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你能弄明白它是如何构建的吗？你能猜到它为什么有用吗？我们将在接下来的几页中回答这些问题。具体来说，我们将看到：
- en: What the relationship between graphs and matrices is
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图与矩阵之间的关系是什么
- en: How matrix multiplication can be translated to walks on the graph
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵乘法如何转化为图上的路径
- en: What the connectivity structure of a graph reveals about its corresponding matrix
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的连通结构揭示了其对应矩阵的什么信息
- en: Let’s get to it!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 8.1 The directed graph of a nonnegative matrix
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 非负矩阵的有向图
- en: If you look carefully at Figure [8.1](#), you can probably figure out how to
    construct a weighted graph from a matrix. Just compare each row and the outgoing
    edge weights for nodes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察图[8.1](#)，你可能会弄明白如何从矩阵构建一个加权图。只需比较每一行和节点的出边权重。
- en: Each row is a node, and each element represents a directed and weighted edge.
    Edges of zero elements are omitted. The element in the i-th row and j-th column
    corresponds to an edge going from i to j. The resulting graph is called the directed
    graph (or digraph) of the matrix.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行是一个节点，每个元素代表一条有向且加权的边。零元素的边会被省略。第i行第j列的元素对应着一条从i到j的边。得到的图叫做矩阵的有向图（或称为有向图）。
- en: To unwrap the definition a bit, let’s check out the previous graph of the matrix
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了稍微展开定义，让我们看一下之前的矩阵图
- en: '![ ⌊ ⌋ 0.5 1 0 | | 3×3 A = |⌈0.2 0 2.2|⌉ ∈ ℝ . 1.8 2 0 ](img/file807.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ 0.5 1 0 | | 3×3 A = |⌈0.2 0 2.2|⌉ ∈ ℝ . 1.8 2 0 ](img/file807.png)'
- en: Here’s the first row, corresponding to the edges coming out from the first node.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一行，对应于从第一个节点出来的边。
- en: '![PIC](img/file808.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file808.png)'
- en: 'Figure 8.2: The first row corresponds to the edges coming out from the first
    node'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：第一行对应于从第一个节点出来的边
- en: Similarly, the first column corresponds to the edges coming into the first node.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，第一列对应于进入第一个节点的边。
- en: '![PIC](img/file809.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file809.png)'
- en: 'Figure 8.3: The first column corresponds to the edges coming into the first
    node'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：第一列对应于进入第一个节点的边
- en: Now, we can put all of this together. Figure 8.4 shows the full picture, with
    the nodes explicitly labeled.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将所有这些内容结合起来。图8.4展示了完整的图像，节点被明确标注。
- en: '![PIC](img/file810.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file810.png)'
- en: 'Figure 8.4: Constructing the graph of a matrix'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：构建矩阵的图
- en: It’s time to check the formal definition, which we’ll split into two parts.
    First, let’s talk about weighted and directed graphs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候查看正式定义了，我们将其分为两部分。首先，让我们讨论有权的有向图。
- en: Definition 29\.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 定义29\。
- en: Let V = {v[1],v[2],…,v[n]} be an arbitrary finite set. We say that G = (V,E,w)
    is a weighted and directed graph, if
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 令 V = {v[1],v[2],…,v[n]} 为一个任意有限集合。我们说 G = (V,E,w) 是一个加权有向图，如果
- en: '(a) V represents the set of vertices (also called nodes). (b) E ⊆V ×V represents
    the set of directed edges. (c) The function w : E →ℝ represents the edge weights.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '（a）V 表示顶点集合（也称为节点）。(b) E ⊆V ×V 表示有向边集合。 (c) 函数 w : E →ℝ 表示边的权重。'
- en: For example, check out Figure 8.4, which we can formalize as (V,E,w) with V
    = {v[1],v[2],v[3]},
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查看图 8.4，我们可以将其形式化为（V,E,w），其中 V = {v[1],v[2],v[3]}，
- en: '![E = {(v1,v1),(v1,v2), (v2,v1),(v2,v3), (v3,v1),(v3,v2)}, ](img/file811.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![E = {(v1,v1),(v1,v2), (v2,v1),(v2,v3), (v3,v1),(v3,v2)}, ](img/file811.png)'
- en: and
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 并且
- en: '![w(v1,v1) = 0.5, w (v1,v2) = 1, w(v2,v1) = 0.2, w (v2,v2) = 2.2, w(v3,v1)
    = 1.8, w (v3,v2) = 2\. ](img/file812.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![w(v1,v1) = 0.5, w (v1,v2) = 1, w(v2,v1) = 0.2, w (v2,v2) = 2.2, w(v3,v1)
    = 1.8, w (v3,v2) = 2\. ](img/file812.png)'
- en: Now, we are ready to talk about matrices.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始讨论矩阵了。
- en: Definition 30\. (Irreducible and reducible matrices)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 30.（不可约和可约矩阵）
- en: 'Let A ∈ℝ^(n×n) be a nonnegative matrix, i.e., a matrix with only nonnegative
    elements. The directed weighted graph G = (V,E,w) is said to be the directed graph
    (or digraph for short) of A if:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 令 A ∈ℝ^(n×n) 为一个非负矩阵，即只含有非负元素的矩阵。如果有向加权图 G = (V,E,w)，则称其为 A 的有向图（或简称有向图），当且仅当：
- en: (a) V = {1,2,…,n}, (b) (i,j) ∈E if, and only if, a[i,j]/span>0, (c) w(i,j) =
    a[i,j].
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: （a）V = {1,2,…,n}，（b）当且仅当，a[i,j]/span>0 时，（i,j) ∈E，（c）w(i,j) = a[i,j]。
- en: (Sometimes, for illustrative purposes, we’ll just omit the weights and assume
    all of them to be equal to 1.) Again, why is this useful? Because this way, we
    can translate algebraic questions into graph-theoretic ones. Thus, we gain access
    to the vast toolkit of graph theory.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: （有时为了说明问题，我们会省略权重，并假设它们都等于1。）那么，这有什么用呢？因为这样，我们可以将代数问题转化为图论问题。因此，我们可以使用图论的强大工具集。
- en: 8.2 Benefits of the graph representation
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 图表示法的好处
- en: Let’s talk about the concrete advantages that the graph representation offers.
    For one, the powers of the matrix correspond to walks in the graph. Say, for any
    let ![A = (ai,j)ni,j=1 ∈ ℝn×n ](img/file813.png). Its square is denoted by ![A2
    = (a(2))ni,j=1 ∈ ℝn ×n i,j ](img/file814.png), where the elements ![ (2) ai,j
    ](img/file815.png) are defined by
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来讨论图表示法的具体优势。首先，矩阵的幂对应于图中的行走。假设，对于任意的，![A = (ai,j)ni,j=1 ∈ ℝn×n ](img/file813.png)。它的平方记为
    ![A2 = (a(2))ni,j=1 ∈ ℝn ×n i,j ](img/file814.png)，其中元素 ![ (2) ai,j ](img/file815.png)
    的定义为
- en: '![ n a(2) = ∑ a a . i,j i,k k,j k=1 ](img/file816.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![ n a(2) = ∑ a a . i,j i,k k,j k=1 ](img/file816.png)'
- en: (Note that the (2) in the superscript of a[i,j]^((2)) is not an exponent; this
    is just an index indicating that a[i,]^((2)) is the element of A².)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，a[i,j]^((2)) 上标中的(2)不是指数，它只是一个索引，表示 a[i,j]^((2)) 是 A² 的元素。）
- en: 'Figure 8.5 shows the elements of the square matrix and its graph: all possible
    two-step walks are accounted for in the sum defining the elements of A².'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 显示了矩阵平方和其图的元素：所有可能的两步行走都包含在定义 A² 元素的和中。
- en: '![PIC](img/file817.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file817.png)'
- en: 'Figure 8.5: Powers of the matrix describe walks on its directed graph'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5：矩阵的幂描述了其有向图上的行走
- en: There is much more to this connection; for instance, it gives us a deep insight
    into the structure of nonnegative matrices. To see how, let’s talk about the concept
    of strongly connected components.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个连接性有更多的内容；例如，它让我们深入理解非负矩阵的结构。为了更好理解这一点，我们来讨论强连通分量的概念。
- en: 8.2.1 The connectivity of graphs
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 图的连通性
- en: Intuitively, we can think of connectivity as the ability to reach every node
    from the others. To formalize this, we’ll need a couple of definitions. First,
    the “reach every node from the others” part.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地说，我们可以将连通性视为从一个节点到达其他所有节点的能力。为了形式化这一点，我们需要几个定义。首先是“从其他节点到达每个节点”这一部分。
- en: Definition 31\. (Walks on a graph)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 31.（图上的行走）
- en: Let G = (V,E,w) be a weighted and directed graph. The sequence v[k[1]]v[k[2]]…v[k[l]]
    is a (directed) walk on G if (v[k[i]],v[k[i+1]]) ∈E for all i.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 令 G = (V,E,w) 为一个加权有向图。序列 v[k[1]]v[k[2]]…v[k[l]] 是 G 上的（有向）行走，当且仅当对所有 i，(v[k[i]],v[k[i+1]])
    ∈E。
- en: (For consistency, we define walks for weighted and directed graphs, but the
    definition holds for simple graphs – i.e., graphs without edges and directional
    edges – as well. The same goes for most of the upcoming concepts.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: （为了保持一致性，我们定义了加权有向图的行走，但该定义同样适用于简单图——即没有边或没有方向的图——大多数即将出现的概念也是如此。）
- en: In general, we say that the walk v[k[1]]v[k[2]]…v[k[l]] starts at v[k[1]] and
    ends at v[k[l]].
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们说从 v[k[1]]v[k[2]]…v[k[l]] 开始的行走是从 v[k[1]] 出发并以 v[k[l]] 结束。
- en: The term walk is surprisingly descriptive, as it truly describes a walk on the
    directed edges, going from node to node. However, a graph-theoretic walk is a
    properly defined mathematical object, not just a vague intuition. Pick up a pen
    and a paper once again and sketch up a graph, then a couple of its walks, to understand
    the concept better.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “步行”这个术语出奇地形象，因为它真正描述了在有向边上从一个节点到另一个节点的过程。然而，图论中的步行是一个定义明确的数学对象，而不仅仅是一个模糊的直觉。再次拿起笔和纸，画出一个图，并画出它的几个步行，来更好地理解这个概念。
- en: 'What do walks have to do with connectivity? Simple: If you can reach every
    node from every other node, the graph is said to be connected. Since we are talking
    about directed graphs, let’s add a bit of nuance to the discussion and conjure
    up a formal definition.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 步行和连通性有什么关系？很简单：如果你能从每个节点到达其他所有节点，那么这个图就被称为连通图。由于我们在讨论有向图，让我们在讨论中加入一些细微的差别，并给出一个正式的定义。
- en: Definition 32\.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 32\.
- en: (Strong connectivity)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: （强连通性）
- en: Let G = (V,E,w) be a weighted and directed graph. We say that G is strongly
    connected if for every u,v ∈V , there exists a walk that starts at u and ends
    at v.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 设 G = (V,E,w) 是一个加权有向图。我们说 G 是强连通的，如果对于每个 u,v ∈V ，都存在一条从 u 开始到 v 结束的步行。
- en: In other words, a directed graph is strongly connected if every node can be
    reached from every other node. If this is not true, the graph is not strongly
    connected. Figure 8.6 shows you an example of both.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果每个节点都可以从其他任何节点到达，那么一个有向图就是强连通的。如果这一点不成立，那么这个图就不是强连通的。图 8.6 展示了这两种情况的例子。
- en: Figure 8.6 also illustrates that strong connectivity does not match the connectivity
    concept for simple graphs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 还说明了，强连通性与简单图的连通性概念不完全相同。
- en: It’s not enough to reach u from v; you have to be able to go back as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅能从 v 到达 u 还不够；你还必须能够从 u 回到 v。
- en: '![PIC](img/file818.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file818.png)'
- en: 'Figure 8.6: Connected vs. strongly connected'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6：连通与强连通
- en: Now, let’s translate what we’ve learned to the language of matrices. Matrices
    that correspond to strongly connected graphs are called irreducible. All other
    nonnegative matrices are called reducible. Soon, we’ll see why, but first, here’s
    the formal definition.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把我们学到的知识转化为矩阵语言。与强连通图对应的矩阵叫做不可约矩阵。所有其他非负矩阵都叫做可约矩阵。稍后我们会看到为什么，但首先，这里是正式的定义。
- en: Definition 33\.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 33\.
- en: (Irreducible and reducible matrices)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: （不可约和可约矩阵）
- en: Let A ∈ℝ^(n×n) be a nonnegative matrix.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 设 A ∈ℝ^(n×n) 是一个非负矩阵。
- en: (a) A is called irreducible if its digraph is strongly connected. (b) A is called
    reducible if it is not irreducible.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 如果 A 的有向图是强连通的，那么称 A 为不可约的。(b) 如果 A 不是不可约的，那么称 A 为可约的。
- en: Let’s see an example! Figure 8.7 shows an irreducible matrix.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子！图 8.7 展示了一个不可约矩阵。
- en: '![PIC](img/file819.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file819.png)'
- en: 'Figure 8.7: Strongly connected digraphs and their matrices'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7：强连通有向图及其矩阵
- en: Back to the general case! Even though not all digraphs are strongly connected,
    we can partition the nodes into strongly connected components (as Figure 8.8 illustrates).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 回到一般情况！尽管并非所有有向图都是强连通的，我们可以将节点划分为强连通分量（如图 8.8 所示）。
- en: '![PIC](img/file820.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file820.png)'
- en: 'Figure 8.8: Strongly connected components'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8：强连通分量
- en: Let’s label the nodes of this graph and construct the corresponding matrix!
    If you assume that the weights are simply equal to 1 and translate all the edges
    into rows and columns as we have learned, you’ll get
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给这个图的节点标上标签，并构建相应的矩阵！如果你假设权重简单地等于 1，并且将所有的边转化为我们已经学习过的行列式形式，你将得到：
- en: '![ ⌊ ⌋ |0 1 1 0 0 0| ||0 0 1 0 0 0|| | | ||1 0 0 1 0 0|| A = ||0 0 0 0 1 1||.
    || || |⌈0 0 0 0 0 1|⌉ 0 0 0 1 0 0 ](img/file821.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ |0 1 1 0 0 0| ||0 0 1 0 0 0|| | | ||1 0 0 1 0 0|| A = ||0 0 0 0 1 1||.
    || || |⌈0 0 0 0 0 1|⌉ 0 0 0 1 0 0 ](img/file821.png)'
- en: 'That’s just a big block of ones and zeroes, but you shouldn’t be disappointed:
    there is a pattern! By dividing A into blocks, the matrix of our example graph
    can be reduced to a simpler form:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一大块 1 和 0 的矩阵，但你不应该感到失望：其中有规律！通过将 A 分成块，我们可以将这个示例图的矩阵简化为更简单的形式：
- en: '![ ⌊ | ⌋ 0 1 1 |0 0 0 || | || || 0 0 1 |0 0 0 || ⌊ | ⌋ || 1 0 0 |1 0 0 || A1,1|A1,2
    A = ||---------|--------|| = ⌈ -----|-----⌉ , | 0 0 0 |0 1 1 | A2,1|A2,2 || 0
    0 0 |0 0 1 || ⌈ | ⌉ 0 0 0 |1 0 0 ](img/file822.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ | ⌋ 0 1 1 |0 0 0 || | || || 0 0 1 |0 0 0 || ⌊ | ⌋ || 1 0 0 |1 0 0 || A1,1|A1,2
    A = ||---------|--------|| = ⌈ -----|-----⌉ , | 0 0 0 |0 1 1 | A2,1|A2,2 || 0
    0 0 |0 0 1 || ⌈ | ⌉ 0 0 0 |1 0 0 ](img/file822.png)'
- en: where
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '![ ⌊ ⌋ ⌊ ⌋ 0 1 1 0 0 0 || || || || A1,1 = ⌈ 0 0 1⌉, A1,2 = ⌈0 0 0⌉ , 1 0 0
    1 0 0 ⌊ ⌋ ⌊ ⌋ 0 0 0 0 1 1 A = || ||, A = || || . 2,1 ⌈ 0 0 0⌉ 2,2 ⌈0 0 1⌉ 0 0
    0 1 0 0 ](img/file823.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ ⌊ ⌋ 0 1 1 0 0 0 || || || || A1,1 = ⌈ 0 0 1⌉, A1,2 = ⌈0 0 0⌉ , 1 0 0
    1 0 0 ⌊ ⌋ ⌊ ⌋ 0 0 0 0 1 1 A = || ||, A = || || . 2,1 ⌈ 0 0 0⌉ 2,2 ⌈0 0 1⌉ 0 0
    0 1 0 0 ](img/file823.png)'
- en: The diagonal blocks A[1,1] and A[2,2] represent graphs that are strongly connected
    (that is, the blocks are irreducible). Furthermore, the block below the diagonal
    is 0\. Is this true for all nonnegative matrices?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对角块 A[1,1] 和 A[2,2] 表示的是强连通的图（即这些块是不可约的）。此外，对角线下方的块是 0。对于所有非负矩阵，这个结论都成立吗？
- en: You bet. Let’s see!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当然。我们来看看！
- en: 8.3 The Frobenius normal form
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 Frobenius 正常形
- en: In general, the block-matrix structure that we have just seen is called the
    Frobenius normal form. Here’s the precise definition.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们刚才看到的块矩阵结构被称为 Frobenius 正常形。下面是它的精确定义。
- en: Definition 34\.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 34.
- en: (Frobenius normal form)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: （Frobenius 正常形）
- en: Let A ∈ℝ^(n×n) be a nonnegative matrix. A is said to be in Frobenius normal
    form if it can be written in the block matrix form
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 令 A ∈ ℝ^(n×n) 为一个非负矩阵。如果它能写成块矩阵形式，则称 A 为 Frobenius 正常形。
- en: '![L(U,V ) = {f : U → V | f is linear}](img/equation_(15).png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![L(U,V ) = {f : U → V | f 是线性的}](img/equation_(15).png)'
- en: where A[1],…,A[k] are irreducible matrices.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 A[1],…,A[k] 是不可约矩阵。
- en: 'Let’s reverse the question: can we transform an arbitrary nonnegative matrix
    into the Frobenius normal form? Yes, and with the help of directed graphs, this
    is much easier to show than purely using algebra. Here is the famous theorem in
    full form.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们反过来问这个问题：我们能否将一个任意的非负矩阵转化为 Frobenius 正常形？是的，并且借助有向图，这比单纯使用代数要容易展示得多。以下是这个著名定理的完整形式。
- en: Theorem 54\. (The existence of the Frobenius normal form)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 54.（Frobenius 正常形的存在性）
- en: Let A ∈ℝ^(n×n) be a nonnegative matrix. There exists a permutation matrix P
    ∈ℝ^(n×n) such that P^T AP is in Frobenius normal form.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 令 A ∈ ℝ^(n×n) 为一个非负矩阵。存在一个置换矩阵 P ∈ ℝ^(n×n)，使得 P^T AP 处于 Frobenius 正常形。
- en: Rigorously spelling out the proof of Theorem [54](ch014.xhtml#x1-137003r54)
    is quite complicated. However, the ideas behind the proof are simple to show.
    Thus, we’ll take the less rigorous, more fun route.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 严格地说明定理 [54](ch014.xhtml#x1-137003r54)的证明相当复杂。然而，证明背后的思想很容易展示。因此，我们将采用一种不那么严谨但更有趣的方法。
- en: So, why is the Frobenius normal form a big deal and what on Earth is a permutation
    matrix? Let’s dive into it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么 Frobenius 正常形如此重要，置换矩阵到底是什么？让我们深入了解一下。
- en: 8.3.1 Permutation matrices
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 置换矩阵
- en: 'Mathematics is often done from concrete to abstract. That’s why we are often
    start with special cases: what happens if we multiply a 2 x 2 matrix by'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 数学通常是从具体到抽象进行的。这就是为什么我们经常从特殊情况开始：如果我们将一个 2 x 2 矩阵与
- en: '![ ⌊ ⌋ P1,2 = ⌈0 1⌉ , 1 0 ](img/file825.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ P1,2 = ⌈0 1⌉ , 1 0 ](img/file825.png)'
- en: a simple zero-one matrix? With a quick calculation, we can verify that
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的零一矩阵？通过快速计算，我们可以验证
- en: '![⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌈0 1⌉ ⌈a b⌉ = ⌈c d⌉ , 1 0 c d a b ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ a b 0 1 b a ⌈ ⌉
    ⌈ ⌉ = ⌈ ⌉ , c d 1 0 d c ](img/file826.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌈0 1⌉ ⌈a b⌉ = ⌈c d⌉ , 1 0 c d a b ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ a b 0 1 b a ⌈ ⌉
    ⌈ ⌉ = ⌈ ⌉ , c d 1 0 d c ](img/file826.png)'
- en: that is,
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，
- en: it switches the rows when multiplied from the left,
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从左侧乘时会交换行，
- en: and it switches the columns when multiplied from the right.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从右侧乘时会交换列。
- en: 'Multiplying by P from both the left and right compounds the effects: it switches
    rows and columns, as'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从左右两侧同时乘以 P 会复合其效果：它交换了行和列，如下所示
- en: '![⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ 0 1 a b 0 1 d c ⌈ ⌉ ⌈ ⌉ ⌈ ⌉ = ⌈ ⌉ 1 0 c d 1 0 b a ](img/file827.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![⌊ ⌋ ⌊ ⌋ ⌊ ⌋ ⌊ ⌋ 0 1 a b 0 1 d c ⌈ ⌉ ⌈ ⌉ ⌈ ⌉ = ⌈ ⌉ 1 0 c d 1 0 b a ](img/file827.png)'
- en: shows. (By the way, this is a similarity transformation, as our special zero-one
    matrix is its own inverse. This is not an accident; more about it later.)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示。（顺便说一句，这是一个相似变换，因为我们特殊的零一矩阵是它自身的逆。这并非偶然，稍后我们会详细讲解。）
- en: Why are we looking at this? Because behind the scenes, this transformation doesn’t
    change the underlying graph structure, just relabels its nodes!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要看这个？因为在幕后，这个变换并不会改变底层的图结构，只是重新标记了它的节点！
- en: You can easily verify this by hand, but Figure 8.9 illustrates this as well.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地手动验证这一点，图 8.9 也进行了说明。
- en: '![PIC](img/file828.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file828.png)'
- en: 'Figure 8.9: Relabeling the nodes'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9：重新标记节点
- en: 'A similar phenomenon is true in the general n×n case. Here, we define the so-called
    transposition matrices by switching the i-th and j-th rows of the identity matrix,
    for example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般的 n×n 情况下也存在类似的现象。在这里，我们通过交换单位矩阵的第 i 行和第 j 行来定义所谓的转置矩阵，例如：
- en: '![ ⌊ ⌋ ⌊ ⌋ |0 1 0 0 0| |1 0 0 0 0| ||1 0 0 0 0|| ||0 1 0 0 0|| || || 5×5 ||
    || 5×5 P1,2 = |0 0 1 0 0| ∈ ℝ , P3,5 = |0 0 0 0 1| ∈ ℝ . ||0 0 0 1 0|| ||0 0 0
    1 0|| ⌈ ⌉ ⌈ ⌉ 0 0 0 0 1 0 0 1 0 0 ](img/file829.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ ⌊ ⌋ |0 1 0 0 0| |1 0 0 0 0| ||1 0 0 0 0|| ||0 1 0 0 0|| || || 5×5 ||
    || 5×5 P1,2 = |0 0 1 0 0| ∈ ℝ , P3,5 = |0 0 0 0 1| ∈ ℝ . ||0 0 0 1 0|| ||0 0 0
    1 0|| ⌈ ⌉ ⌈ ⌉ 0 0 0 0 1 0 0 1 0 0 ](img/file829.png)'
- en: The two most important properties of the permutation matrices are P[i,j]^T =
    P[i,j] and P[i,j]^T P[i,j] = I. That is, their inverse is their transpose.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 排列矩阵的两个最重要的属性是 P[i,j]^T = P[i,j] 和 P[i,j]^T P[i,j] = I。也就是说，它们的逆矩阵就是它们的转置矩阵。
- en: 'Multiplication with a transposition matrix has the same effect: it switches
    rows from the left and columns from the right. To be precise,'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与转置矩阵相乘具有相同的效果：它交换左侧的行和右侧的列。更确切地说，
- en: P[i,j]A switches the i-th and j-th rows of A,
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: P[i,j]A 交换 A 的第 i 和第 j 行，
- en: and AP[i,j] switches the i-th and j-th columns of A.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且 AP[i,j] 交换 A 的第 i 和第 j 列。
- en: Most importantly, the similarity transformation
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，相似性变换
- en: '![Pi,jAPi,j ](img/file830.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Pi,jAPi,j ](img/file830.png)'
- en: relabels the i-th and j-th nodes of A’s digraph, leaving the graph structure
    invariant.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重新标记 A 的有向图中的第 i 和第 j 个节点，保持图形结构不变。
- en: 'Now, about the aforementioned permutation matrices. A permutation matrix is
    simply a product of transposition matrices:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于上述排列矩阵。排列矩阵只是转置矩阵的乘积：
- en: '![P = Pi1,i2Pi3,i4 ...Pi2k−1,i2k. ](img/file831.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![P = Pi1,i2Pi3,i4 ...Pi2k−1,i2k. ](img/file831.png)'
- en: Permutation matrices inherit some properties from their building blocks. Most
    importantly,
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 排列矩阵继承了它们构建块的一些特性。最重要的是，
- en: their inverse is their transpose,
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们的逆矩阵就是它们的转置矩阵，
- en: and a similarity transformation with them is just a relabeling of nodes that
    leave the graph structure invariant.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与它们的相似性变换只是一个重新标记节点的过程，保持图形结构不变。
- en: To see this latter one, consider that
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要看这一点，可以考虑
- en: '![P TAP = (Pi1,i2Pi3,i4 ...Pi2k−1,i2k)TA (Pi1,i2Pi3,i4 ...Pi2k− 1,i2k) = (Pi2k−
    1,i2k ...(Pi1,i2APi1,i2)...Pi2k−1,i2k), ](img/file832.png)='
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![P TAP = (Pi1,i2Pi3,i4 ...Pi2k−1,i2k)TA (Pi1,i2Pi3,i4 ...Pi2k− 1,i2k) = (Pi2k−
    1,i2k ...(Pi1,i2APi1,i2)...Pi2k−1,i2k), ](img/file832.png)='
- en: succesively relabeling the nodes. (Recall that transposing a matrix product
    switches up the order, and transposition matrices are their own transposes.) Conversely,
    every node relabeling is equivalent to a similarity transformation with a well-constructed
    permutation matrix.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 依次重新标记节点。（回想一下，转置矩阵的乘积顺序会发生变化，而且转置矩阵是其自身的转置。）相反，每一个节点的重新标记都等同于一个与构建良好的排列矩阵相似性变换。
- en: Why are we talking about this? Because the proper labeling of nodes is key to
    the Frobenius normal form.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要讨论这个？因为节点的正确标记是 Frobenius 正常形式的关键。
- en: 8.3.2 Directed graphs and their strongly connected components
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 有向图及其强连通分量
- en: 'Now, let’s talk about graphs. We’ll see how every digraph decomposes into strongly
    connected components. Let’s see a concrete example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈图。我们将看到每个有向图如何分解成强连通分量。让我们看一个具体的例子：
- en: '![PIC](img/file833.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file833.png)'
- en: 'Figure 8.10: A directed graph (that is complex enough for us to study)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10：一个足够复杂供我们研究的有向图
- en: This’ll be our textbook example. How many nodes can be reached from a given
    node? Not necessarily all. Say, for the point highlighted in Figure 8.11, only
    a portion of the graph is accessible.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的教材示例。给定一个节点，能到达多少个节点呢？不一定是全部。例如，对于图 8.11 中高亮的点，只有部分图形是可达的。
- en: '![PIC](img/file834.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file834.png)'
- en: 'Figure 8.11: Downstream nodes for a single starting point'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11：从一个起始点出发的下游节点
- en: 'However, the set of mutually reachable nodes is much smaller: Figure 8.12 shows
    that in our example, it consists of only two points.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，互相可达的节点集要小得多：图 8.12 显示，在我们的示例中，它只包含两个点。
- en: '![PIC](img/file835.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file835.png)'
- en: 'Figure 8.12: Mutually reachable nodes'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12：互相可达的节点
- en: Algebraically speaking, “![a ](img/file836.png) and ![b ](img/file837.png) are
    mutually reachable from each other“ is a special relation that partitions the
    set of nodes into disjoint subsets such that
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从代数的角度来说，“![a ](img/file836.png) 和 ![b ](img/file837.png) 是彼此可达的”是一种特殊的关系，它将节点集合划分为互不重叠的子集，使得
- en: two nodes from the same subset are mutually reachable from each other,
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自同一子集的两个节点是彼此可达的，
- en: and two nodes from different subsets are not mutually reachable.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自不同子集的两个节点是不可相互到达的。
- en: The subsets of this partition are called the strongly connected components,
    and we can always decompose a directed graph in this way.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个划分的子集称为强连通分量，我们总是可以通过这种方式分解一个有向图。
- en: '![PIC](img/file838.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file838.png)'
- en: 'Figure 8.13: Strongly connected components of our example graph'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：我们示例图的强连通组件
- en: Now, let’s connect everything together (not in a graph way but, you know, in
    a wholesome mathematical one)!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把所有东西连接起来（不是以图的方式，而是以一个完整的数学方式来连接）！
- en: 8.3.3 Putting graphs and permutation matrices together
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 将图形和置换矩阵结合起来
- en: We are two steps away from proving that every nonnegative square matrix can
    be transformed into the Frobenius normal form with a permutation matrix. Here
    is the plan.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们距离证明每个非负方阵都可以通过一个置换矩阵转换为 Frobenius 正常形只有两步之遥。以下是计划。
- en: Construct the graph for our nonnegative matrix.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建我们非负矩阵的图形。
- en: Find the strongly connected components.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到强连通组件。
- en: Relabel the nodes in a clever way.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以巧妙的方式重新标记节点。
- en: 'And that’s it! Why? Because, as we have seen, relabeling is the same as a similarity
    transform with a permutation matrix. There’s just one tiny snag: what is the clever
    way? I’ll show you.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！为什么？因为，正如我们所见，重新标记等同于通过置换矩阵进行相似变换。唯一的小问题是：巧妙的方式是什么？我来展示给你看。
- en: 'First, we “skeletonize” the graph: merge the components together, as well as
    any edges between them.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们“骨架化”图形：将组件合并在一起，以及它们之间的所有边。
- en: 'Consider each component as a black box: we don’t care what’s inside, only about
    their external connections.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 把每个组件视为一个黑盒子：我们不关心内部的内容，只关心它们的外部连接。
- en: '![PIC](img/file839.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file839.png)'
- en: 'Figure 8.14: Strongly connected components'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：强连通组件
- en: In this skeleton, we can find components that cannot be entered from other components.
    These will be our starting points, the zeroth-class components. In our example,
    we only have one.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个骨架中，我们可以找到无法从其他组件进入的组件。这些将是我们的起始点，即零类组件。在我们的例子中，我们只有一个。
- en: '![PIC](img/file840.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file840.png)'
- en: 'Figure 8.15: Finding the ”zeroth” component'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：寻找“零类”组件
- en: Now, things get a bit tricky. We number each component by the longest path from
    the farthest zero-class component from which it can be reached.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，事情变得有点棘手。我们通过从最远的零类组件开始，按最长路径对每个组件进行编号。
- en: This is hard to even read, let alone understand. Figure 8.16 illustrates the
    process.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至很难阅读，更不用说理解了。图8.16展示了这个过程。
- en: '![PIC](img/file841.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file841.png)'
- en: 'Figure 8.16: Numbering the components'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16：组件编号
- en: The gist is that if you can reach an m-th class from an n-th class, then n <m.
    In the end, we have something like Figure 8.17.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，如果你能够从第n类到达第m类，那么n < m。最终，我们会得到类似于图8.17的结果。
- en: '![PIC](img/file842.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file842.png)'
- en: 'Figure 8.17: Numbered components'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：已编号的组件
- en: This defines an ordering on the components (a partial ordering, if you would
    like to be precise).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了组件的一个顺序（如果你想精确一点，它是一个偏序）。
- en: Now, we label the nodes inside such that
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为节点标记，使得
- en: higher-order classes come first,
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高阶类排在前面，
- en: and consecutive indices are labeling nodes from the same component if possible.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连续的索引如果可能，表示来自同一组件的节点。
- en: This is how it goes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。
- en: '![PIC](img/file843.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file843.png)'
- en: 'Figure 8.18: Labeling the nodes'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18：标记节点
- en: 'Here is the matrix in this particular example, with zeros and ones for simplicity:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个特定例子中的矩阵，为了简化，使用了零和一：
- en: '![⌊ | | | | ⌋ 0 1 1 |1 0 0 0 |0 0 | 0 |0 0 0 || | | | | || || 0 0 1 |0 0 1
    0 |0 0 | 1 |0 0 0 || || 1 0 0 |0 0 0 0 |1 0 | 0 |0 0 0 || | ---------|-----------|----|---|-------|
    || 0 0 0 |0 1 0 1 |0 0 | 0 |0 0 0 || || 0 0 0 |0 0 1 0 |0 0 | 0 |0 0 0 || || |
    | | | || || 0 0 0 |1 0 0 0 |0 0 | 0 |0 0 0 || || 0 0 0 |0 1 1 0 |0 0 | 0 |0 0
    0 || | ---------|-----------|----|---|-------| || 0 0 0 |0 0 0 0 |0 1 | 1 |0 0
    0 || || 0 0 0 |0 0 0 0 |1 0 | 0 |0 0 0 || || ---------|-----------|----|---|-------||
    || -0--0--0-|0--0--0--0-|0-0-|-0-|1-0--0-|| || 0 0 0 |0 0 0 0 |0 0 | 0 |0 1 0
    || | | | | | | || 0 0 0 |0 0 0 0 |0 0 | 0 |0 0 1 || || 0 0 0 |0 0 0 0 |0 0 | 0
    |1 0 0 || ⌈ ⌉ ](img/file844.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![⌊ | | | | ⌋ 0 1 1 |1 0 0 0 |0 0 | 0 |0 0 0 || | | | | || || 0 0 1 |0 0 1
    0 |0 0 | 1 |0 0 0 || || 1 0 0 |0 0 0 0 |1 0 | 0 |0 0 0 || | ---------|-----------|----|---|-------|
    || 0 0 0 |0 1 0 1 |0 0 | 0 |0 0 0 || || 0 0 0 |0 0 1 0 |0 0 | 0 |0 0 0 || || |
    | | | || || 0 0 0 |1 0 0 0 |0 0 | 0 |0 0 0 || || 0 0 0 |0 1 1 0 |0 0 | 0 |0 0
    0 || | ---------|-----------|----|---|-------| || 0 0 0 |0 0 0 0 |0 1 | 1 |0 0
    0 || || 0 0 0 |0 0 0 0 |1 0 | 0 |0 0 0 || || ---------|-----------|----|---|-------||
    || -0--0--0-|0--0--0--0-|0-0-|-0-|1-0--0-|| || 0 0 0 |0 0 0 0 |0 0 | 0 |0 1 0
    || | | | | | | || 0 0 0 |0 0 0 0 |0 0 | 0 |0 0 1 || || 0 0 0 |0 0 0 0 |0 0 | 0
    |1 0 0 || ⌈ ⌉ ](img/file844.png)'
- en: 'With that, the ideas behind the proof of Theorem [54](ch014.xhtml#x1-137003r54)
    are clear! Now, we also finally understand why irreducible matrices are called
    irreducible: as they describe strongly connected graphs, they cannot be further
    decomposed into smaller blocks in a meaningful way.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，定理[54](ch014.xhtml#x1-137003r54)的证明思路就清晰了！现在，我们也终于明白了为什么不可约矩阵被称为不可约：因为它们描述的是强连通图，因此不能以有意义的方式进一步分解成更小的块。
- en: 8.4 Summary
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 总结
- en: With the study of the connections between linear algebra and graph theory, our
    journey through linear algebra is over.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 随着线性代数与图论之间关系的研究，我们的线性代数学习之旅已经结束。
- en: In this and the previous seven chapters, we have learned that vectors and matrices
    are not merely data structures that store observations and measurements. Vectors
    and matrices possess a rich and beautiful geometric structure, describing data
    and their transformations at the same time!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及前七章中，我们学到，向量和矩阵不仅仅是存储观察值和测量数据的数据结构。向量和矩阵具有丰富而美丽的几何结构，能够同时描述数据及其变换！
- en: First, we learned that vectors live in so-called vector spaces, the high-dimensional
    generalizations of the three-dimensional space we are living in (which might be
    26-dimensional, according to some string theorists, but let’s stick to the Earth
    for now). We can measure lengths and distances via norms, most often defined by
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们了解到，向量存在于所谓的向量空间中，它们是我们所处的三维空间的高维推广（根据一些弦理论学者的说法，可能是26维，但我们暂且只讨论地球上的空间）。我们可以通过范数来测量长度和距离，范数通常定义为
- en: '![ ∑n ∥x ∥ = x2, x ∈ ℝn, i=1 i ](img/file845.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n ∥x ∥ = x2, x ∈ ℝn, i=1 i ](img/file845.png)'
- en: or measure angles (among others) via inner products, most often defined by
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 或通过内积来测量角度（等等），内积通常定义为
- en: '![ ∑n ⟨x, y⟩ = xiyi i=1 = cos(α)∥x ∥∥y∥. ](img/file846.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n ⟨x, y⟩ = xiyi i=1 = cos(α)∥x ∥∥y∥. ](img/file846.png)'
- en: 'From a mathematical perspective, matrices originate from the linear transformation
    of vector spaces, i.e., functions of the form f : U →V , satisfying the linearity
    relation f(ax + by) = af(x) + bf(y). Matrices arise from the algebraic representation
    of linear transformations by expressing them in the form'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '从数学的角度来看，矩阵来源于向量空间的线性变换，即满足线性关系 f(ax + by) = af(x) + bf(y) 的函数 f : U →V 。矩阵通过代数方式表示线性变换，具体表现为'
- en: '![ ⌊ ⌋ ⌊ ∑n ⌋ ⌊a a ... a ⌋| x1| | i=1 a1,ixi| | 1,1 1,2 1,m ||| x2|| || ∑n
    a2,ixi|| ||a2,1 a2,2 ... a2,m ||| .| | i=1\. | f(x) = Af x = || .. .. .. .. ||||
    ..|| = || .. || , ⌈ . . . . ⌉|| x || || ∑n a x || an,1 an,2 ... an,m, ⌈ n⌉ ⌈ i=1
    n,i i⌉ ](img/file847.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ ⌊ ∑n ⌋ ⌊a a ... a ⌋| x1| | i=1 a1,ixi| | 1,1 1,2 1,m ||| x2|| || ∑n
    a2,ixi|| ||a2,1 a2,2 ... a2,m ||| .| | i=1\. | f(x) = Af x = || .. .. .. .. ||||
    ..|| = || .. || , ⌈ . . . . ⌉|| x || || ∑n a x || an,1 an,2 ... an,m, ⌈ n⌉ ⌈ i=1
    n,i i⌉ ](img/file847.png)'
- en: 'allowing us to reason about data transformations from a geometric perspective.
    This is an extremely powerful tool in machine learning. Think about it: Ax can
    be a regression model, a layer in a neural network, or various other machine learning
    building blocks. Ultimately, this is why we want to study vector spaces: the data
    lives there, and data transformations are described by matrices.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们能够从几何角度推理数据变换。这在机器学习中是一个极其强大的工具。想想看：Ax 可以是回归模型、神经网络中的一层，或其他各种机器学习构建模块。归根结底，这就是我们要学习向量空间的原因：数据存在于其中，而数据变换则通过矩阵来描述。
- en: However, building a model doesn’t stop at linear algebra. To capture more complex
    patterns, we need nonlinearities. For instance, consider the famous Sigmoid function,
    defined by
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，建立模型并不止步于线性代数。为了捕捉更复杂的模式，我们需要引入非线性。例如，考虑著名的 Sigmoid 函数，它由以下公式定义
- en: '![σ(x) = ---1---. 1+ e− x ](img/file848.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![σ(x) = ---1---. 1+ e− x ](img/file848.png)'
- en: The transformation defined by σ(Ax) (where σ is applied elementwise) is a simple
    logistic regression model, allowing us to perform binary classification on our
    multidimensional feature space. Iterating on this idea, the expression
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由σ(Ax)定义的变换（其中σ是按元素应用的）是一个简单的逻辑回归模型，使我们能够对多维特征空间进行二分类。基于这一思路，我们得到的表达式
- en: '![N (x) = σ(B σ(Ax)) ](img/file849.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![N (x) = σ(B σ(Ax)) ](img/file849.png)'
- en: defines a two-layer neural network.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个两层神经网络。
- en: So, the next part of our journey is into the domain of calculus, where we’ll
    learn what functions really are, how we build predictive models from them, and
    how we fit these models by tuning the parameters with gradient descent.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们接下来的旅程将进入微积分的领域，我们将学习函数到底是什么，如何从函数构建预测模型，以及如何通过梯度下降调节参数来拟合这些模型。
- en: Let’s go!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 8.5 Problems
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 问题
- en: Problem 1\. Let G = (V,E) be a directed graph and let u,v ∈V be two of its nodes.
    Show that if there exists a walk from u to v, then there exists a walk without
    repeated edges and repeated vertices.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 1\. 设 G = (V,E) 是一个有向图，u,v ∈V 是其两个节点。证明如果从 u 到 v 存在一条路径，则存在一条没有重复边和重复顶点的路径。
- en: Problem 2\. Let G = (V,E) be a strongly connected directed graph. Show that
    jEj ≥jV j, where jSj denotes the number of elements in the set S. (In other words,
    show that in order to be strongly connected, G must have at least as many edges
    as nodes.)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 2\. 设 G = (V,E) 是一个强连通有向图。证明 jEj ≥ jV j，其中 jSj 表示集合 S 中元素的个数。（换句话说，证明为了强连通，G
    至少需要有与节点数相等或更多的边。）
- en: Problem 3\. Let A ∈ℝ^(n×n) be an irreducible matrix. Is A² also reducible? (If
    yes, prove it. If no, show a counterexample.)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 3\. 设 A ∈ℝ^(n×n) 是一个不可约矩阵。A² 也不可约吗？（如果是，请证明。如果不是，请给出反例。）
- en: Problem 4\. Let A ∈ℝ^(4×4) be the matrix defined by
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 4\. 设 A ∈ℝ^(4×4) 是一个矩阵，其定义如下：
- en: '![ ⌊ ⌋ | 0 0 1 0| | 0 0 0 1| A = || || . |⌈ 1 0 0 0|⌉ 0 1 0 0 ](img/file850.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ | 0 0 1 0| | 0 0 0 1| A = || || . |⌈ 1 0 0 0|⌉ 0 1 0 0 ](img/file850.png)'
- en: Find the permutation matrix P that transforms A to a Frobenius normal form!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 找到将 A 转换为 Frobenius 标准型的置换矩阵 P！
- en: Join our community on Discord
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、机器学习专家和作者本人一起阅读本书。提出问题、为其他读者提供解决方案、通过“问我任何问题”环节与作者互动等等。扫描二维码或访问链接加入社区。[https://packt.link/math](https://packt.link/math)
- en: '![PIC](img/file1.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
