- en: Chapter 2. Integrity and Inspection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 完整性与检查
- en: 'This chapter will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Trimming excess whitespace
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去除多余的空格
- en: Ignoring punctuation and specific characters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略标点符号和特定字符
- en: Coping with unexpected or missing input
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理意外或缺失的输入
- en: Validating records by matching regular expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过匹配正则表达式验证记录
- en: Lexing and parsing an e-mail address
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对电子邮件地址进行词法分析和解析
- en: Deduplication of nonconflicting data items
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去重无冲突的数据项
- en: Deduplication of conflicting data items
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去重有冲突的数据项
- en: Implementing a frequency table using Data.List
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Data.List 实现频率表
- en: Implementing a frequency table using Data.MultiSet
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Data.MultiSet 实现频率表
- en: Computing the Manhattan distance
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算曼哈顿距离
- en: Computing the Euclidean distance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算欧几里得距离
- en: Comparing scaled data using the Pearson correlation coefficient
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pearson 相关系数比较缩放后的数据
- en: Comparing sparse data using cosine similarity
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用余弦相似度比较稀疏数据
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '![Introduction](img/ch02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/ch02.jpg)'
- en: The conclusions drawn from data analysis are only as robust as the quality of
    the data itself. After obtaining raw text, the next natural step is to validate
    and clean it carefully. Even the slightest bias may risk the integrity of the
    results. Therefore, we must take great precautionary measures, which involve thorough
    inspection, to ensure sanity checks are performed on our data before we begin
    to understand it. This section should be the starting point for cleaning data
    in Haskell.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据分析中得出的结论的稳健性仅取决于数据本身的质量。在获得原始文本后，下一步自然是仔细验证和清理它。即使是最轻微的偏差也可能危及结果的完整性。因此，我们必须采取严格的预防措施，包括全面检查，以确保在开始理解数据之前对数据进行合理性检查。本节应为在
    Haskell 中清理数据的起点。
- en: Real-world data often has an impurity that needs to be addressed before it can
    be processed. For example, extraneous whitespaces or punctuation could clutter
    data, making it difficult to parse. Duplication and data conflicts are another
    area of unintended consequences of reading real-world data. Sometimes it's just
    reassuring to know that data makes sense by conducting sanity checks. Some examples
    of sanity checks include matching regular expressions as well as detecting outliers
    by establishing a measure of distance. In this chapter, we will cover each of
    these topics.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的数据通常带有一些杂质，需要在处理之前进行清理。例如，多余的空格或标点符号可能会使数据混乱，难以解析。重复和数据冲突是读取现实世界数据时常见的意外后果。有时，通过执行合理性检查来确保数据是有意义的，这会令人放心。一些合理性检查的例子包括匹配正则表达式以及通过建立距离度量来检测离群值。本章将涵盖这些主题。
- en: Trimming excess whitespace
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去除多余的空格
- en: The text obtained from sources may unintentionally include beginning or trailing
    whitespace characters. When parsing such an input, it is often wise to trim the
    text. For example, when Haskell source code contains trailing whitespace, the
    **GHC** compiler ignores it through a process called **lexing**. The lexer produces
    a sequence of tokens, effectively ignoring meaningless characters such as excess
    whitespace.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从源获取的文本可能会无意中包含开头或结尾的空格字符。在解析此类输入时，通常明智的做法是修剪文本。例如，当 Haskell 源代码包含尾部空格时，**GHC**
    编译器会通过称为 **词法分析** 的过程忽略它。词法分析器生成一系列标记，实际上忽略了像多余空格这样的无意义字符。
- en: In this recipe, we will use built-in libraries to make our own `trim` function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用内置库来制作我们自己的 `trim` 函数。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create a new file, which we will call `Main.hs`, and perform the following
    steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件，我们称之为 `Main.hs`，并执行以下步骤：
- en: 'Import the `isSpace :: Char -> Bool` function from the built-in `Data.Char`
    package:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从内置的 `Data.Char` 包中导入 `isSpace :: Char -> Bool` 函数：'
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Write a trim function that removes the beginning and trailing whitespace:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 `trim` 函数，去除开头和结尾的空格：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Test it out within `main`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 中测试：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running the code will result in the following trimmed string:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码将得到以下修剪后的字符串：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our `trim` function lazily strips the whitespace from the beginning and ending
    parts of the string. It starts by dropping whitespace letters from the beginning.
    Then, it reverses the string to apply the same function again. Finally, it reverses
    the string one last time to bring it back to the original form. Fortunately, the
    `isSpace` function from `Data.Char` handles any **Unicode** space character as
    well as the control characters `\t`, `\n`, `\r`, `\f`, and `\v`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`trim`函数懒加载地去除了字符串开头和结尾的空白。它首先删除字符串开头的空白字符。然后，它会将字符串反转，再次应用同样的函数。最后，它会将字符串再反转一次，使其恢复到原来的形式。幸运的是，`Data.Char`中的`isSpace`函数处理了所有**Unicode**空白字符以及控制字符`\t`、`\n`、`\r`、`\f`和`\v`。
- en: There's more…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Ready-made parser combinator libraries such as `parsec` or `uu-parsinglib` could
    be used to do this instead, rather than reinventing the wheel. By introducing
    a `Token` type and parsing to this type, we can elegantly ignore the whitespace.
    Alternatively, we can use the alex lexing library (package name, `alex`) for this
    task. These libraries are overkill for this simple task, but they allow us to
    perform a more generalized tokenizing of text.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现成的解析器组合库，如`parsec`或`uu-parsinglib`，可以用来实现这一功能，而不是重新发明轮子。通过引入`Token`类型并解析为该类型，我们可以优雅地忽略空白字符。或者，我们可以使用alex词法分析库（包名`alex`）来完成此任务。虽然这些库对于这个简单的任务来说有些过于复杂，但它们允许我们对文本进行更通用的标记化处理。
- en: Ignoring punctuation and specific characters
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略标点符号和特定字符
- en: Usually in natural language processing, some uninformative words or characters,
    called **stop words**, can be filtered out for easier handling. When computing
    word frequencies or extracting sentiment data from a corpus, punctuation or special
    characters might need to be ignored. This recipe demonstrates how to remove these
    specific characters from the body of a text.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在自然语言处理（NLP）中，一些没有信息量的单词或字符，被称为**停用词**，可以被过滤掉，以便更容易处理。在计算单词频率或从语料库中提取情感数据时，可能需要忽略标点符号或特殊字符。本示例演示了如何从文本主体中去除这些特定字符。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'There are no imports necessary. Create a new file, which we will call `Main.hs`,
    and perform the following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要任何导入。创建一个新文件，我们称之为`Main.hs`，并执行以下步骤：
- en: 'Implement `main` and define a string called `quote`. The back slashes (`\`)
    represent multiline strings:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`main`并定义一个名为`quote`的字符串。反斜杠（`\`）表示多行字符串：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Replace all punctuation marks with an empty string, and replace all special
    symbols with a space:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有标点符号替换为空字符串，并将所有特殊符号替换为空格：
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By running the code, we will find that all special characters and punctuation
    are appropriately removed to facilitate dealing with the text''s corpus:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行代码，我们将发现所有特殊字符和标点符号已被适当移除，以便处理文本语料库。
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'For more powerful control, we can install `MissingH`, which is a very helpful
    utility we can use to deal with strings:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更强大的控制，我们可以安装`MissingH`，这是一款非常有用的工具，可用于处理字符串：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It provides a `replace` function that takes three arguments and produces a
    result as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了一个`replace`函数，接受三个参数并产生如下结果：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It replaces all occurrences of the first string with the second string in the
    third argument. We can also compose multiple `replace` functions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 它将第一个字符串的所有出现位置替换为第三个参数中的第二个字符串。我们还可以组合多个`replace`函数：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By folding the composition `(.)` function over a list of these `replace` functions,
    we can generalize the `replace` function to an arbitrary list of tokens:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将组合函数`(.)`应用于这些`replace`函数的列表，我们可以将`replace`函数推广到任意的符号列表：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The list of punctuation marks can now be arbitrarily long. We can modify our
    recipe to use our new and more generalized functions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，标点符号的列表可以是任意长度的。我们可以修改我们的示例，使用新的、更通用的函数：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Coping with unexpected or missing input
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应对意外或缺失的输入
- en: Data sources often contain incomplete and unexpected data. One common approach
    to parsing such data in Haskell is using the `Maybe` data type.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源通常包含不完整和意外的数据。在 Haskell 中处理这种数据的一种常见方法是使用`Maybe`数据类型。
- en: Imagine designing a function to find the nth element in a list of characters.
    A naïve implementation may have the type `Int -> [Char] -> Char`. However, if
    the function is trying to access an index out of bounds, we should try to indicate
    that an error has occurred.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下设计一个函数来查找字符列表中的第 n 个元素。一个简单的实现可能是类型为`Int -> [Char] -> Char`。然而，如果该函数试图访问一个越界的索引，我们应该尝试指示发生了错误。
- en: 'A common way to deal with these errors is by encapsulating the output `Char`
    into a `Maybe` context. Having the type `Int -> [Char] -> Maybe Char` allows for
    some better error handling. The constructors for `Maybe` are `Just a` or `Nothing`,
    which will become apparent by running GHCi and testing out the following commands:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些错误的一种常见方法是将输出的`Char`封装在`Maybe`上下文中。拥有`Int -> [Char] -> Maybe Char`类型可以提供更好的错误处理。`Maybe`的构造函数是`Just
    a`或`Nothing`，通过运行GHCi并测试以下命令会变得明显：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will set each field as a `Maybe` data type so that whenever a field cannot
    be parsed, it will simply be represented as `Nothing`. This recipe will demonstrate
    how to read the CSV data with faulty and missing info.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个字段设置为`Maybe`数据类型，这样当某个字段无法解析时，它将简单地表示为`Nothing`。这个食谱将演示如何读取包含错误和缺失信息的CSV数据。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We create an input set of CSV files to read in. The first column will be for
    laptop brands, the next column will be for their models, and the third column
    will be for the base cost. We should leave some fields blank to simulate an incomplete
    input. We name the file `input.csv`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个CSV文件输入集来读取。第一列是笔记本品牌，第二列是其型号，第三列是基础费用。我们应该留下一些字段为空，以模拟不完整的输入。我们将文件命名为`input.csv`：
- en: '![Getting ready](img/6331OS_02_01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6331OS_02_01.jpg)'
- en: 'Also, we must install the csv library:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们还必须安装csv库：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new file, which we will call `Main.hs`, and perform the following
    steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，我们将其命名为`Main.hs`，并执行以下步骤：
- en: 'Import the CSV library:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入CSV库：
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a data type corresponding to the CSV fields:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个对应于CSV字段的数据类型：
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define and implement `main` to read the CSV input and parse relevant info:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并实现`main`来读取CSV输入并解析相关信息：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'From a list of records, create a list of laptop data types:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从记录列表中创建一个笔记本数据类型列表：
- en: '[PRE17]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Parse each field, producing `Nothing` if there is an unexpected or missing
    item:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析每个字段，如果出现意外或缺失的项，则生成`Nothing`：
- en: '[PRE18]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `Maybe` monad allows you to have two states: `Just` something or `Nothing`.
    It provides a useful abstraction to produce an error state. Each field in these
    data types exists in a `Maybe` context. If a field doesn''t exist, then we simply
    regard it as `Nothing` and move on.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe`单子允许你有两种状态：`Just`某物或`Nothing`。它提供了一种有用的抽象来产生错误状态。这些数据类型中的每个字段都存在于`Maybe`上下文中。如果字段不存在，我们简单地将其视为`Nothing`并继续。'
- en: There's more...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'If a more descriptive error state is desired, the `Either` monad may be more
    useful. It also has two states, but they are more descriptive: `Left` something,
    or `Right` something. The `Left` state is often used to describe the error type,
    whereas the `Right` state holds the desired result. We can use the `Left` state
    to describe different types of errors instead of just one behemoth `Nothing`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望有更具描述性的错误状态，`Either`单子可能更有用。它也有两种状态，但它们更具描述性：`Left`某物，或`Right`某物。`Left`状态通常用来描述错误类型，而`Right`状态则包含期望的结果。我们可以使用`Left`状态来描述不同类型的错误，而不仅仅是一个庞大的`Nothing`。
- en: See also
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: To review CSV data input, see the *Keeping and representing data from a CSV
    file* recipe in [Chapter 1](ch01.html "Chapter 1. The Hunt for Data"), *The Hunt
    for Data*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要复习CSV数据输入，请参阅[第1章](ch01.html "第1章. 数据探索")中的*保存和表示CSV文件中的数据*食谱，*数据探索*。
- en: Validating records by matching regular expressions
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过匹配正则表达式验证记录
- en: A regular expression is a language for matching patterns in a string. Our Haskell
    code can process a regular expression to examine a text and tell us whether or
    not it matches the rules described by the expression. Regular expression matching
    can be used to validate or identify a pattern in the text.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一种用于匹配字符串中模式的语言。我们的Haskell代码可以处理正则表达式来检查文本并告诉我们它是否符合表达式描述的规则。正则表达式匹配可用于验证或识别文本中的模式。
- en: In this recipe, we will read a corpus of English text to find possible candidates
    of full names in a sea of words. Full names usually consist of two words that
    start with a capital letter. We use this heuristic to extract all the names from
    an article.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将读取一篇英文文本语料库，从大量的单词中找出可能的全名。全名通常由两个以大写字母开头的单词组成。我们利用这个启发式方法从文章中提取所有的名字。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Create an `input.txt` file with some text. In this example, we use a snippet
    from a New York Times article on dinosaurs ([http://www.nytimes.com/2013/12/17/science/earth/outsider-challenges-papers-on-growth-of-dinosaurs.html](http://www.nytimes.com/2013/12/17/science/earth/outsider-challenges-papers-on-growth-of-dinosaurs.html))
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含文本的`input.txt`文件。在此示例中，我们使用来自《纽约时报》关于恐龙的文章片段（[http://www.nytimes.com/2013/12/17/science/earth/outsider-challenges-papers-on-growth-of-dinosaurs.html](http://www.nytimes.com/2013/12/17/science/earth/outsider-challenges-papers-on-growth-of-dinosaurs.html)）
- en: '*Other co-authors of Dr. Erickson''s include Mark Norell, chairman of paleontology
    at the American Museum of Natural History; Philip Currie, a professor of dinosaur
    paleobiology at the University of Alberta; and Peter Makovicky, associate curator
    of paleontology at the Field Museum in Chicago.*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*埃里克森博士的其他合著者包括美国自然历史博物馆古生物学主席马克·诺雷尔；阿尔伯塔大学恐龙古生物学教授菲利普·卡里；以及芝加哥田野博物馆古生物学副馆长彼得·马科维基。*'
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a new file, which we will call `Main.hs`, and perform the following
    steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，我们将其命名为`Main.hs`，并执行以下步骤：
- en: 'Import the regular expression library:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入正则表达式库：
- en: '[PRE19]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Match a string against a regular expression to detect words that look like
    names:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串与正则表达式进行匹配，以检测看起来像名字的单词：
- en: '[PRE20]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create functions that remove unnecessary punctuation and special symbols. We
    will use the same functions defined in the previous recipe entitled *Ignoring
    punctuation and specific characters*:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建去除不必要标点符号和特殊符号的函数。我们将使用前一个食谱中定义的相同函数，标题为*忽略标点符号和特定字符*：
- en: '[PRE21]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Pair adjacent words together and form a list of possible full names:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相邻的单词配对，并形成一个可能的全名列表：
- en: '[PRE22]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Retrieve the input and find possible names from a corpus of text:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索输入并从文本语料库中查找可能的名称：
- en: '[PRE23]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The resulting output after running the code is as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码后的结果输出如下：
- en: '[PRE24]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `=~` function takes in a string and a regular expression and returns a target
    that we parse as `Bool`. In this recipe, the `^[A-Z][a-z]{1,30}$` regular expression
    matches the words that start with a capital letter and are between 2 and 31 letters
    long.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`=~`函数接受一个字符串和一个正则表达式，并返回我们解析为`Bool`的目标。在本食谱中，`^[A-Z][a-z]{1,30}$`正则表达式匹配以大写字母开头、长度在2到31个字母之间的单词。'
- en: 'In order to determine the usefulness of the algorithm presented in this recipe,
    we will introduce two metrics of relevance: **precision** and **recall**. Precision
    is the percent of retrieved data that is relevant. Recall is the percent of relevant
    data that is retrieved.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定本食谱中所呈现算法的有效性，我们将引入两个相关性指标：**精确度**和**召回率**。精确度是指检索到的数据中相关数据所占的百分比。召回率是指相关数据中被检索到的百分比。
- en: Out of a total of 45 words in the `input.txt` file, four correct names are produced
    and a total eight candidates are retrieved. It has a precision of 50 percent and
    a recall of 100 percent. This is not bad at all for a simple regular expression
    trick.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`input.txt`文件中的45个单词中，产生了四个正确的名字，并且总共检索到八个候选项。它的精确度为50%，召回率为100%。对于一个简单的正则表达式技巧来说，这个结果相当不错。
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Instead of running regular expressions on a string, we can pass them through
    a lexical analyzer. The next recipe entitled *Lexing and parsing an e-mail address*
    will cover this in detail.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过词法分析器而不是直接在字符串上运行正则表达式。下一个名为*词法分析和解析电子邮件地址*的食谱将详细讲解这一点。
- en: Lexing and parsing an e-mail address
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词法分析和解析电子邮件地址
- en: An elegant way to clean data is by defining a lexer to split up a string into
    tokens. In this recipe, we will parse an e-mail address using the `attoparsec`
    library. This will naturally allow us to ignore the surrounding whitespace.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 清理数据的一种优雅方法是定义一个词法分析器，将字符串拆分成标记。在本食谱中，我们将使用`attoparsec`库解析电子邮件地址。这自然允许我们忽略周围的空格。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Import the `attoparsec` parser combinator library:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`attoparsec`解析器组合器库：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How to do it…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a new file, which we will call `Main.hs`, and perform the following
    steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，我们将其命名为`Main.hs`，并执行以下步骤：
- en: 'Use the GHC `OverloadedStrings` language extension to more legibly use the
    `Text` data type throughout the code. Also, import the other relevant libraries:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用GHC的`OverloadedStrings`语言扩展，以便在代码中更清晰地使用`Text`数据类型。同时，导入其他相关库：
- en: '[PRE26]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Declare a data type for an e-mail address:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个电子邮件地址的数据类型：
- en: '[PRE27]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define how to parse an e-mail address. This function can be as simple or as
    complicated as required:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义如何解析电子邮件地址。这个函数可以根据需要简单或复杂：
- en: '[PRE28]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Parse an e-mail address to test the code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析电子邮件地址以测试代码：
- en: '[PRE29]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the code to print out the parsed e-mail address:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码打印出解析后的电子邮件地址：
- en: '[PRE30]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: We create an e-mail parser by matching the string against multiple tests. An
    e-mail address must contain some alphanumerical username, followed by the 'at'
    sign (`@`), then an alphanumerical hostname, a period, and lastly the top-level
    domain.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将字符串与多个测试匹配来创建电子邮件解析器。电子邮件地址必须包含一个字母数字的用户名，后跟“at”符号（`@`），然后是字母数字的主机名，一个句点，最后是顶级域名。
- en: The various functions used from the `attoparsec` library can be found in the
    `Data.Attoparsec.Text` documentation, which is available at [https://hackage.haskell.org/package/attoparsec/docs/Data-Attoparsec-Text.html](https://hackage.haskell.org/package/attoparsec/docs/Data-Attoparsec-Text.html).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的各种`attoparsec`库函数可以在`Data.Attoparsec.Text`文档中找到，文档地址为[https://hackage.haskell.org/package/attoparsec/docs/Data-Attoparsec-Text.html](https://hackage.haskell.org/package/attoparsec/docs/Data-Attoparsec-Text.html)。
- en: Deduplication of nonconflicting data items
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无冲突数据项去重
- en: Duplication is a common problem when collecting large amounts of data. In this
    recipe, we will combine similar records in a way that ensures no information is
    lost.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 数据重复是收集大量数据时常见的问题。在本篇中，我们将以确保不丢失信息的方式合并相似的记录。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Create an `input.csv` file with repeated data:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含重复数据的`input.csv`文件：
- en: '![Getting ready](img/6331OS_02_02.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6331OS_02_02.jpg)'
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Create a new file, which we will call `Main.hs`, and perform the following
    steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件，我们将其命名为`Main.hs`，并执行以下步骤：
- en: 'We will be using the `CSV`, `Map`, and `Maybe` packages:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`CSV`、`Map`和`Maybe`包：
- en: '[PRE31]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define the `Item` data type corresponding to the CSV input:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义与CSV输入对应的`Item`数据类型：
- en: '[PRE32]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Get each record from CSV and put them in a map by calling our `doWork` function:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从CSV获取每条记录，并通过调用我们的`doWork`函数将它们放入映射中：
- en: '[PRE33]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we''re unable to parse CSV, print an error message; otherwise, define the
    `doWork` function that creates a map from an association list with a collision
    strategy defined by `combine`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果无法解析CSV，打印错误消息；否则，定义`doWork`函数，该函数根据由`combine`定义的碰撞策略从关联列表创建映射：
- en: '[PRE34]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Use the `<|>` function from `Control.Applicative` to merge the nonconflicting
    fields:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Control.Applicative`中的`<|>`函数合并无冲突字段：
- en: '[PRE35]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define the helper functions to create an association list from a CSV record:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义辅助函数，从CSV记录创建关联列表：
- en: '[PRE36]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Executing the code shows a map filled with combined results:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码显示一个填充了合并结果的映射：
- en: '[PRE37]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The `Map` data type offers a convenient function `fromListWith :: Ord k =>
    (a -> a -> a) -> [(k, a)] -> Map k a` to easily combine data in the map. We use
    it to find out whether a key already exists. If so, we combine the fields in the
    old and new items and store them under the key.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`数据类型提供了一个便捷的函数`fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map
    k a`，用于轻松地合并映射中的数据。我们使用它来检查一个键是否已经存在。如果存在，我们将旧项目和新项目中的字段合并，并将它们存储在该键下。'
- en: 'The true hero in this recipe is the `<|>` function form `Control.Applicative`.
    The `<|>` function takes its arguments and returns the first one that is not *empty*.
    Since both `String` and `Maybe` implement `Applicative typeclass`, we can reuse
    the `<|>` function for a more manageable code. Here are a couple of examples of
    it in use:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本篇的真正英雄是`Control.Applicative`中的`<|>`函数。`<|>`函数接受其参数，并返回第一个非*空*的参数。由于`String`和`Maybe`都实现了`Applicative`类型类，我们可以复用`<|>`函数来简化代码。以下是几个使用示例：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There's more...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: If you're dealing with larger numbers, it may be wise to use `Data.Hashmap.Map`
    instead because the running time for *n* items is *O(min(n, W))*, where *W* is
    the number of bits in an integer (32 or 64).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处理的是较大的数字，可能明智之举是改用`Data.Hashmap.Map`，因为对*n*项的运行时间是*O(min(n, W))*，其中*W*是整数的位数（32或64）。
- en: For even better performance, `Data.Hashtable.Hashtable` provides *O(1)* performance
    for lookups but adds complexity by being in an I/O monad.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的性能，`Data.Hashtable.Hashtable`提供了*O(1)*的查找性能，但通过位于I/O单子中的复杂性增加了使用的难度。
- en: See also
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见：
- en: If the corpus contains inconsistent information about duplicated data, see the
    next recipe on *Deduplication of conflicting data items*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语料库中包含关于重复数据的不一致信息，请参阅下一篇关于*冲突数据项去重*的内容。
- en: Deduplication of conflicting data items
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冲突数据项去重
- en: Unfortunately, information about an item may be inconsistent throughout the
    corpus. Collision strategies are often domain-dependent, but one common way to
    manage this conflict is by simply storing all variations of the data. In this
    recipe, we will read a CSV file that contains information about musical artists
    and store all of the information about their songs and genres in a set.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，关于某一项的信息在语料库中可能是不一致的。冲突策略通常依赖于领域，但一种常见的管理冲突的方式是简单地存储所有数据的变体。在本示例中，我们将读取一个包含音乐艺术家信息的CSV文件，并将关于他们的歌曲和流派的所有信息存储在一个集合中。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Create a CSV input file with the following musical artists. The first column
    is for the name of the artist or band. The second column is the song name, and
    the third is the genre. Notice how some musicians have multiple songs or genres.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个CSV输入文件，包含以下音乐艺术家。第一列是艺术家或乐队的名称，第二列是歌曲名称，第三列是流派。请注意，一些音乐人有多首歌曲或多种流派。
- en: '![Getting ready](img/6331OS_02_03.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6331OS_02_03.jpg)'
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new file, which we will call `Main.hs`, and perform the following
    steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件，我们将其命名为`Main.hs`，并执行以下步骤：
- en: 'We will be using the `CSV`, `Map`, and `Set` packages:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`CSV`、`Map`和`Set`包：
- en: '[PRE39]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Define the `Artist` data type corresponding to the CSV input. For fields that
    may contain conflicting data, store the value in its corresponding list. In this
    case, song- and genre-related data are stored in a set of strings:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义与CSV输入对应的`Artist`数据类型。对于可能包含冲突数据的字段，将其存储在相应的列表中。在这种情况下，与歌曲和流派相关的数据存储在一个字符串集合中：
- en: '[PRE40]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Extract data from CSV and insert it in a map:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从CSV中提取数据并将其插入到映射中：
- en: '[PRE41]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Print out any error that might occur:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出可能发生的任何错误：
- en: '[PRE42]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If no error occurs, then combine the data from the CSV and print it out:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有错误发生，那么就将CSV中的数据合并并打印出来：
- en: '[PRE43]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a map from an association list with a collision strategy defined by
    `combine`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从关联列表创建一个映射，碰撞策略由`combine`定义：
- en: '[PRE44]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Make the helper functions create an association list from the CSV records:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让辅助函数从CSV记录中创建关联列表：
- en: '[PRE45]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of the program will be a map with the following information that
    will be collected:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序的输出将是一个映射，包含将收集的以下信息：
- en: '[PRE46]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `Map` data type offers a convenient function `fromListWith :: Ord k =>
    (a -> a -> a) -> [(k, a)] -> Map k a` to easily combine data in `Map`. We use
    it to find out whether a key already exists. If so, we combine the fields in the
    old and new items and store them under the key.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`数据类型提供了一个方便的函数`fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map
    k a`，可以轻松地在`Map`中合并数据。我们使用它来查找键是否已存在。如果存在，则将旧项和新项中的字段合并，并将其存储在该键下。'
- en: We use a set to efficiently combine these data fields.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用集合来高效地组合这些数据字段。
- en: There's more...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: If dealing with larger numbers, it may be wise to use `Data.Hashmap.Map` instead
    because the running time for *n* items is *O(min(n, W))*, where *W* is the number
    of bits in an integer (32 or 64).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理较大的数字，可能明智地使用`Data.Hashmap.Map`，因为处理* n *个项目的运行时间是* O(min(n, W)) *，其中* W
    *是整数中的位数（32或64）。
- en: For even better performance, `Data.Hashtable.Hashtable` provides *O(1)* performance
    for lookups but adds complexity by being in an I/O monad.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更好的性能，`Data.Hashtable.Hashtable`为查找提供了*O(1)*性能，但通过处于I/O monad中增加了复杂性。
- en: See also
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: If the corpus contains nonconflicting information about duplicated data, see
    the previous section on *Deduplication of nonconflicting data items*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语料库包含关于重复数据的无冲突信息，请参阅前一节关于*去重无冲突数据项*的内容。
- en: Implementing a frequency table using Data.List
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Data.List 实现频率表
- en: A frequency map of values is often useful to detect outliers. We can use it
    to identify frequencies that seem out of the ordinary. In this recipe, we will
    be counting the number of different colors in a list.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 值的频率映射通常用于检测异常值。我们可以用它来识别看起来不寻常的频率。在这个例子中，我们将计算列表中不同颜色的数量。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new file, which we will call `Main.hs`, and perform the following
    steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件，我们将其命名为`Main.hs`，并执行以下步骤：
- en: 'We will use the `group` and `sort` functions from `Data.List`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`Data.List`中的`group`和`sort`函数：
- en: '[PRE47]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Define a simple data type for colors:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为颜色定义一个简单的数据类型：
- en: '[PRE48]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a list of these colors:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下颜色的列表：
- en: '[PRE49]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Implement the frequency map and print it out:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现频率映射并打印出来：
- en: '[PRE50]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Grouping identical items after sorting the list is the central idea.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对列表进行排序后，分组相同的项是核心思想。
- en: 'See the following step-by-step evaluation in ghci:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下在ghci中的逐步评估：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As we may expect, sorting the list is the most expensive step.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的那样，排序列表是最昂贵的步骤。
- en: See also
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: A cleaner version of the code is possible by using `Data.MultiSet` described
    in the next recipe, *Implementing a frequency table using Data.MultiSet*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用下一个食谱中描述的 `Data.MultiSet`，代码可以更简洁，*使用 Data.MultiSet 实现频率表*。
- en: Implementing a frequency table using Data.MultiSet
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Data.MultiSet 实现频率表
- en: A frequency map of values is often useful to detect outliers. We will use an
    existing library that does much of the work for us.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 值的频率图常常用于检测离群值。我们将使用一个现有的库，它为我们完成了大部分工作。
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will be using the `multiset` package from Hackage:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自 Hackage 的 `multiset` 包：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new file, which we will call `Main.hs`, and perform the following
    steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，我们将其命名为 `Main.hs`，并执行以下步骤：
- en: 'We will use the `fromList` and `toOccurList` functions from `Data.MultiSet`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `Data.MultiSet` 中的 `fromList` 和 `toOccurList` 函数：
- en: '[PRE53]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Define a simple data type for colors:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个简单的颜色数据类型：
- en: '[PRE54]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create a list of these colors:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建这些颜色的列表：
- en: '[PRE55]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Implement the frequency map and print it out:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现频率图并将其打印出来：
- en: '[PRE56]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Run the code to display the frequency list:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以显示频率列表：
- en: '[PRE57]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `toOccurList :: MultiSet a -> [(a, Int)]` function creates a frequency
    map from a list. We construct `MuliSet` using the provided `fromList` function.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`toOccurList :: MultiSet a -> [(a, Int)]` 函数从列表创建频率图。我们使用提供的 `fromList` 函数构造
    `MultiSet`。'
- en: See also
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: If importing a new library is not desired, see the previous recipe on *Implementing
    a frequency map using Data.List*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不希望导入新的库，请参阅前一个食谱 *使用 Data.List 实现频率图*。
- en: Computing the Manhattan distance
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算曼哈顿距离
- en: Defining a distance between two items allows us to easily interpret clusters
    and patterns. The Manhattan distance is one of the easiest to implement and is
    used primarily due to its simplicity.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 定义两个物体之间的距离使我们能够轻松地解释簇和模式。曼哈顿距离是最容易实现的距离之一，主要由于其简单性。
- en: '![Computing the Manhattan distance](img/6331OS_02_04.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![计算曼哈顿距离](img/6331OS_02_04.jpg)'
- en: The Manhattan distance (or Taxicab distance) between two items is the sum of
    the absolute differences of their coordinates. So if we are given two points (1,
    1) and (5, 4), then the Manhattan distance will be *|1-5| + |1-4| = 4 + 3 = 7*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 曼哈顿距离（或出租车距离）是两个物体坐标差的绝对值之和。因此，如果给定两个点（1, 1）和（5, 4），则曼哈顿距离为 *|1-5| + |1-4| =
    4 + 3 = 7*。
- en: We can use this distance metric to detect whether an item is unusually *far
    away* from everything else. In this recipe, we will detect outliers using the
    Manhattan distance. The calculations merely involve addition and subtraction,
    and therefore, it performs exceptionally well for a very large amount of data.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个距离度量来检测一个物体是否异常 *远离* 其他所有物体。在本食谱中，我们将使用曼哈顿距离来检测离群值。计算仅涉及加法和减法，因此，它在处理大量数据时表现异常优异。
- en: Getting ready
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a list of comma-separated points. We will compute the smallest distance
    between these points and a test point:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个由逗号分隔的点列表。我们将计算这些点与测试点之间的最小距离：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new file, which we will call `Main.hs`, and perform the following
    steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，我们将其命名为 `Main.hs`，并执行以下步骤：
- en: 'Import the CSV and List packages:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 CSV 和 List 包：
- en: '[PRE59]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Read in the following points:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取以下点：
- en: '[PRE60]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Represent the data as a list of floating point numbers:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据表示为浮动点数的列表：
- en: '[PRE61]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Define a couple of points to test the function:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义几个点来测试该函数：
- en: '[PRE62]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Compute the Manhattan distance on each of the points and find the smallest
    result:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每个点的曼哈顿距离并找到最小的结果：
- en: '[PRE63]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a helper function to convert a list of strings to a list of floating
    point numbers:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个辅助函数将字符串列表转换为浮动点数列表：
- en: '[PRE64]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Compute the Manhattan distance between two points:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算两个点之间的曼哈顿距离：
- en: '[PRE65]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Filter out records that are of incorrect size:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤掉尺寸不正确的记录：
- en: '[PRE66]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output will be the shortest distance between the test points and the list
    of points:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将是测试点与点列表之间的最短距离：
- en: '[PRE67]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: See also
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: If the distance matches more closely to the traditional geometric space, then
    read the next recipe on *Computing the Euclidean distance*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该距离与传统几何空间的距离更加接近，那么请阅读下一个食谱 *计算欧几里得距离*。
- en: Computing the Euclidean distance
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算欧几里得距离
- en: Defining a distance between two items allows us to easily interpret clusters
    and patterns. The Euclidean distance is one of the most geometrically natural
    forms of distance to implement. It uses the Pythagorean formula to compute how
    far away two items are, which is similar to measuring the distance with a physical
    ruler.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 定义两个项目之间的距离允许我们轻松解释聚类和模式。欧氏距离是最自然的几何距离之一，它使用勾股定理来计算两个项目之间的距离，类似于使用物理尺子测量距离。
- en: '![Computing the Euclidean distance](img/6331OS_02_05.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![计算欧氏距离](img/6331OS_02_05.jpg)'
- en: We can use this distance metric to detect whether an item is unusually *far
    away* from everything else. In this recipe, we will detect outliers using the
    Euclidean distance. It is slightly more computationally expensive than measuring
    the Manhattan distance since it involves multiplication and square roots; however,
    depending on the dataset, it may provide more accurate results.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个距离度量来检测一个项目是否与其他所有项目*相隔甚远*。在这个示例中，我们将使用欧氏距离检测异常值。与曼哈顿距离测量相比，它稍微更消耗计算资源，因为涉及乘法和平方根运算；然而，根据数据集的不同，它可能提供更准确的结果。
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a list of comma-separated points. We will compute the smallest distance
    between these points and a test point.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个逗号分隔的点列表。我们将计算这些点与测试点之间的最小距离。
- en: '[PRE68]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How to do it...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new file, which we will call `Main.hs`, and perform the following
    steps:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Main.hs`的新文件，并执行以下步骤：
- en: 'Import the CSV and List packages:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入CSV和List包：
- en: '[PRE69]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Read in the following points:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取以下点：
- en: '[PRE70]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Represent the data as a list of floating point numbers:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据表示为浮点数列表：
- en: '[PRE71]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Define a couple of points to test out the function:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一对点以测试该函数：
- en: '[PRE72]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Compute the Euclidean distance on each of the points and find the smallest
    result:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个点上计算欧氏距离并找到最小结果：
- en: '[PRE73]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create a helper function to convert a list of strings to a list of floating
    point numbers:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个辅助函数将字符串列表转换为浮点数列表：
- en: '[PRE74]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Compute the Euclidean distance between two points:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算两点之间的欧氏距离：
- en: '[PRE75]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Filter out records that are of incorrect size:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤掉尺寸不正确的记录：
- en: '[PRE76]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output will be the shortest distance between the test points and the list
    of points:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将是测试点与点列表之间的最短距离：
- en: '[PRE77]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: See also
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If a more computationally efficient distance calculation is required, then take
    a look at the previous recipe, *Computing the Manhattan distance*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更高效的距离计算，则查看前一个示例，*计算曼哈顿距离*。
- en: Comparing scaled data using the Pearson correlation coefficient
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用皮尔逊相关系数比较缩放数据
- en: Another way to measure how closely two items relate to each other is by examining
    their individual trends. For example, two items that both show an upward trend
    are more closely related. Likewise, two items that both show a downward trend
    are also closely related. To simplify the algorithm, we will only consider linear
    trends. This calculation of correlation is called the Pearson correlation coefficient.
    The closer the coefficient is to zero, the less correlated the two data sets will
    be.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种衡量两个项目相关性的方法是检查它们各自的趋势。例如，显示上升趋势的两个项目更密切相关。同样，显示下降趋势的两个项目也密切相关。为简化算法，我们只考虑线性趋势。这种相关性计算称为皮尔逊相关系数。系数越接近零，两个数据集的相关性就越低。
- en: 'The Pearson correlation coefficient for a sample is calculated using the following
    formula:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于样本，皮尔逊相关系数的计算公式如下：
- en: '![Comparing scaled data using the Pearson correlation coefficient](img/6331OS_02_06.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![使用皮尔逊相关系数比较缩放数据](img/6331OS_02_06.jpg)'
- en: How to do it...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new file, which we will call `Main.hs`, and perform the following
    steps:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Main.hs`的新文件，并执行以下步骤：
- en: 'Implement `main` to compute the correlation coefficient between two lists of
    numbers:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`main`以计算两个数字列表之间的相关系数：
- en: '[PRE78]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Define the function to compute the Pearson coefficient:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义计算皮尔逊系数的函数：
- en: '[PRE79]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Run the code to print the coefficient.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以打印系数。
- en: '[PRE80]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理如下...
- en: The Pearson correlation coefficient measures the degree of linear relationship
    between two variables. The magnitude of this coefficient describes how strongly
    the variables are related. If positive, the two variables change together. If
    negative, as one variable increases, the other decreases.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 皮尔逊相关系数衡量的是两个变量之间的线性关系程度。这个系数的大小描述了变量之间的相关程度。如果为正，表示两个变量一起变化；如果为负，表示一个变量增加时，另一个变量减少。
- en: Comparing sparse data using cosine similarity
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用余弦相似度比较稀疏数据
- en: When a data set has multiple empty fields, comparing the distance using the
    Manhattan or Euclidean metrics might result in skewed results. Cosine similarity
    measures how closely two vectors are oriented with each other. For example, the
    vectors (82, 86) and (86, 82) essentially point in the same direction. In fact,
    their cosine similarity is equivalent to the cosine similarity between (41, 43)
    and (43, 41). A cosine similarity of 1 corresponds to vectors that point in the
    exact same direction, and 0 corresponds to vectors that are completely orthogonal
    to each other.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据集有多个空字段时，使用曼哈顿距离或欧几里得距离进行比较可能会导致偏差结果。余弦相似度衡量的是两个向量之间的方向相似度。例如，向量（82, 86）和（86,
    82）本质上指向相同的方向。实际上，它们的余弦相似度等同于（41, 43）和（43, 41）之间的余弦相似度。余弦相似度为1时，表示向量指向完全相同的方向，而为0时，表示向量彼此完全正交。
- en: '![Comparing sparse data using cosine similarity](img/6331OS_02_07.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![使用余弦相似度比较稀疏数据](img/6331OS_02_07.jpg)'
- en: As long as the angles between the two vectors are equal, their cosine similarity
    is equivalent. Applying a distance metric such as the Manhattan distance or Euclidean
    distance in this case produces a significant difference between the two sets of
    data.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 只要两个向量之间的角度相等，它们的余弦相似度就是相等的。在这种情况下，应用曼哈顿距离或欧几里得距离等距离度量会导致两组数据之间产生显著的差异。
- en: The cosine similarity between the two vectors is the dot product of the two
    vectors divided by the product of their magnitudes.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量之间的余弦相似度是两个向量的点积除以它们各自的模长的乘积。
- en: '![Comparing sparse data using cosine similarity](img/6331OS_02_08.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![使用余弦相似度比较稀疏数据](img/6331OS_02_08.jpg)'
- en: How to do it...
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new file, which we will call `Main.hs`, and perform the following
    steps:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件，我们将其命名为`Main.hs`，并执行以下步骤：
- en: Implement `main` to compute the cosine similarity between two lists of numbers.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`main`以计算两个数字列表之间的余弦相似度。
- en: '[PRE81]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Compute the cosine similarity.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算余弦相似度。
- en: '[PRE82]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Define the dot product and Euclidean length helper functions.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义点积和欧几里得长度的辅助函数。
- en: '[PRE83]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Run the code to print the cosine similarity.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以打印余弦相似度。
- en: '[PRE84]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: See also
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: If the data set is not sparse, consider using the Manhattan or Euclidean distance
    metrics instead, as detailed in the recipes *Computing the Manhattan distance*
    and *Computing the Euclidean distance*.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据集不是稀疏的，考虑使用曼哈顿距离或欧几里得距离度量，详细内容见配方*计算曼哈顿距离*和*计算欧几里得距离*。
