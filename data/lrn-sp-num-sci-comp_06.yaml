- en: Chapter 6. SciPy for Data Mining
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 SciPy数据挖掘
- en: 'This chapter covers those branches of mathematics and statistics that treat
    the collection, organization, analysis, and interpretation of data. There are
    different applications and operations that spread over several modules and submodules:
    `scipy.stats` (for purely statistical tools), `scipy.ndimage.measurements` (for
    analysis and organization of data), `scipy.spatial` (for spatial algorithms and
    data structures), and finally the clustering package `scipy.cluster`. The `scipy.cluster`
    clustering package consists of two submodules: `scipy.cluster.vq` (vector quantization)
    and `scipy.cluster.hierarchy` (for hierarchical and **agglomerative** clustering).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了数学和统计学中处理数据收集、组织、分析和解释的分支。这些应用和操作分布在多个模块和子模块中：`scipy.stats`（纯统计工具）、`scipy.ndimage.measurements`（数据分析和组织）、`scipy.spatial`（空间算法和数据结构），以及最终的聚类包`scipy.cluster`。`scipy.cluster`聚类包包括两个子模块：`scipy.cluster.vq`（矢量量化）和`scipy.cluster.hierarchy`（用于层次和**聚合**聚类）。
- en: As in the previous chapters, fluency with the subject matter is assumed. Our
    emphasis is to show you some of the SciPy functions available to perform statistical
    computations, not to teach it. Accordingly, you are welcome to read this chapter
    along side your preferred book(s) on the subject so that you can fully explore
    the examples provided in this chapter on additional data sets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，假设读者对主题熟悉。我们的重点是向您展示一些可用于执行统计计算的SciPy函数，而不是教授它。因此，您可以在阅读您喜欢的相关书籍的同时阅读本章，以便您可以全面探索本章中提供的示例以及额外的数据集。
- en: We should mention, however, that there are other specialized modules in Python
    that can be used to explore this subject from different perspectives. Some of
    them (not covered by any means in this book) are the **Modular Toolkit for Data
    Processing** (**MDP**) ([http://mdp-toolkit.sourceforge.net/install.html](http://mdp-toolkit.sourceforge.net/install.html)),
    **scikit-learn** ([http://scikit-learn.org/](http://scikit-learn.org/)), and **Statsmodels**
    ([http://statsmodels.sourceforge.net/](http://statsmodels.sourceforge.net/)).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该提到，Python中还有其他专门模块可以用于从不同角度探索这个主题。其中一些（本书中未涉及）是**模块化数据处理工具包**（**MDP**）([http://mdp-toolkit.sourceforge.net/install.html](http://mdp-toolkit.sourceforge.net/install.html))、**scikit-learn**([http://scikit-learn.org/](http://scikit-learn.org/))和**Statsmodels**([http://statsmodels.sourceforge.net/](http://statsmodels.sourceforge.net/))。
- en: 'In this chapter, we will cover the following things:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: The standard descriptive statistics measures computed via SciPy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过SciPy计算的标准描述性统计量
- en: The built-in functions in SciPy that deal with statistical distributions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SciPy中处理统计分布的内置函数
- en: The Scipy functionality to find interval estimation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scipy查找区间估计的功能
- en: Performing computations of statistical correlations and some statistical tests,
    the fitting of distributions, and statistical distances
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行统计相关性和一些统计测试的计算，分布拟合和统计距离
- en: A clustering example
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚类示例
- en: Descriptive statistics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述性统计
- en: We often require the analysis of data in which certain features are grouped
    in different regions, each with different sizes, values, shapes, and so on. The
    `scipy.ndimage.measurements` submodule has the right tools for this task, and
    the best way to illustrate the capabilities of the module is by means of exhaustive
    examples. For example, for binary images of zeros and ones, it is possible to
    label each blob (areas of contiguous pixels with value one) and obtain the number
    of these with the `label` command. If we desire to obtain the center of mass of
    the blobs, we may do so with the `center_of_mass command`. We may see these operations
    in action once again in the application to obtain the structural model of oxides
    in [Chapter 7](ch07.html "Chapter 7. SciPy for Computational Geometry"), *SciPy
    for Computational Geometry*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要分析数据，其中某些特征被分组在不同的区域，每个区域具有不同的尺寸、值、形状等。`scipy.ndimage.measurements`子模块具有完成此任务的正确工具，最佳方式是通过详尽的示例来展示模块的功能。例如，对于零和一的二值图像，可以使用`label`命令标记每个连通区域（值为一的连续像素区域），并使用该命令获取这些区域的数量。如果我们希望获取这些区域的质心，可以使用`center_of_mass`命令。我们可以在[第7章](ch07.html
    "第7章. SciPy计算几何") *SciPy计算几何*的应用中再次看到这些操作的实际应用。
- en: For nonbinary data, the `scipy.ndimage.measurements` submodule provides the
    usual basic statistical measurements (value and location of extreme values, mean,
    standard deviation, sum, variance, histogram, and so on).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非二进制数据，`scipy.ndimage.measurements`子模块提供了通常的基本统计测量（极值值和位置，均值，标准差，总和，方差，直方图等）。
- en: For more advanced statistical measurements, we must access functions from the
    `scipy.stats` module. We may now use geometric and harmonic means (`gmean`, `hmean`),
    median, mode, skewness, various moments, or kurtosis (`median`, `mode`, `skew`,
    `moment`, `kurtosis`). For an overview of the most significant statistical properties
    of the dataset, we prefer to use the `describe` routine. We may also compute item
    frequencies (`itemfreq`), percentiles (`scoreatpercentile`, `percentileofscore`),
    histograms (`histogram`, `histogram2`), cumulative and relative frequencies (`cumfreq`,
    `relfreq`), standard error (`sem`), and the signal-to-noise ratio (`signaltonoise`),
    which is always useful.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的统计测量，我们必须访问来自`scipy.stats`模块的函数。我们现在可以使用几何平均数和调和平均数（`gmean`，`hmean`），中位数，众数，偏度，各种矩，或峰度（`median`，`mode`，`skew`，`moment`，`kurtosis`）。为了概述数据集最重要的统计特性，我们更喜欢使用`describe`过程。我们还可以计算项目频率（`itemfreq`），百分位数（`scoreatpercentile`，`percentileofscore`），直方图（`histogram`，`histogram2`），累积频率和相对频率（`cumfreq`，`relfreq`），标准误差（`sem`），以及信噪比（`signaltonoise`），这些总是很有用的。
- en: Distributions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布
- en: One of the main strengths of the `scipy.stats` module is the great number of
    distributions coded, both continuous and discrete. The list is impressively large
    and has at least 80 continuous distributions and 10 discrete distributions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.stats`模块的主要优势之一是编码了大量的分布，包括连续和离散。列表令人印象深刻，至少有80个连续分布和10个离散分布。'
- en: 'One of the most common ways to employ these distributions is the generation
    of random numbers. We have been employing this technique to *contaminate* our
    images with noise, for example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些分布最常见的方法是生成随机数。我们一直在使用这种技术来*污染*我们的图像，例如：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is shown as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s see the SciPy way of handling distributions. First, a random variable
    class is created (in SciPy there is the `rv_continuous` class for continuous random
    variables and the `rv_discrete` class for the discrete case). Each continuous
    random variable has an associated probability density function (`pdf`), a cumulative
    distribution function (`cdf`), a survival function along with its inverse (`sf`,
    `isf`), and all possible descriptive statistics. They also have associated the
    random variable, `rvs`, which is what we used to actually generate the random
    instances. For example, with a Pareto continuous random variable with parameter
    *b = 5*, to check these properties, we could issue the following commands:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看SciPy处理分布的方法。首先，创建一个随机变量类（在SciPy中，对于连续随机变量有`rv_continuous`类，对于离散情况有`rv_discrete`类）。每个连续随机变量都有一个相关的概率密度函数（`pdf`），累积分布函数（`cdf`），生存函数及其逆函数（`sf`，`isf`），以及所有可能的描述性统计。它们还关联了随机变量`rvs`，这是我们实际生成随机实例所用的。例如，对于一个参数*b
    = 5*的帕累托连续随机变量，为了检查这些特性，我们可以发出以下命令：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This gives the following graphs, showing probability density function (left),
    cumulative distribution function (center), and random generation (right):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下图表，显示了概率密度函数（左），累积分布函数（中间），和随机生成（右）：
- en: '![Distributions](img/7702OS_06_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![分布](img/7702OS_06_01.jpg)'
- en: Interval estimation, correlation measures, and statistical tests
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区间估计，相关度量，和统计测试
- en: 'We briefly covered interval estimation as an introductory example of SciPy:
    `bayes_mvs`, in [Chapter 1](ch01.html "Chapter 1. Introduction to SciPy"), *Introduction
    to SciPy*, with very simple syntax, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章。SciPy简介")中简要介绍了SciPy的区间估计作为入门示例：`bayes_mvs`，语法非常简单，如下所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It returns a tuple of three arguments in which each argument has the form `(center,
    (lower, upper))`. The first argument refers to the mean; the second refers to
    the variance; and the third to the standard deviation. All intervals are computed
    according to the probability given by `alpha`, which is `0.9` by default.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个包含三个参数的元组，其中每个参数的形式为`(center, (lower, upper))`。第一个参数指的是均值；第二个指的是方差；第三个指的是标准差。所有区间都是根据`alpha`给出的概率计算的，默认值为`0.9`。
- en: We may use the `linregress` routine to compute the regression line of some two-dimensional
    data *x*, or two sets of one-dimensional data, *x* and *y*. We may compute different
    correlation coefficients, with their corresponding p-values, as well. We have
    the **Pearson correlation coefficient** (`pearsonr`), **Spearman's rank-order
    correlation** (`spearmanr`), **point biserial correlation** (`pointbiserialr`),
    and **Kendall's tau** for ordinal data (`kendalltau`). In all cases, the syntax
    is the same, as it is only required either a two-dimensional array of data, or
    two one-dimensional arrays of data with the same length.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `linregress` 程序来计算二维数据 *x* 的回归线，或者两组一维数据，*x* 和 *y*。我们还可以计算不同的相关系数，以及它们对应的
    p 值。我们有 **皮尔逊相关系数**（`pearsonr`），**斯皮尔曼秩相关**（`spearmanr`），**点二列相关**（`pointbiserialr`），以及
    **肯德尔tau**（`kendalltau`）用于有序数据。在所有情况下，语法都是相同的，因为它只需要一个二维数据数组，或者两个长度相同的一维数据数组。
- en: 'SciPy also has most of the best-known statistical tests and procedures: **t-tests**
    (`ttest_1samp` for one group of scores, `ttest_ind` for two independent samples
    of scores, or `ttest_rel` for two related samples of scores), **Kolmogorov-Smirnov
    tests** for goodness of fit (`kstest`, `ks_2samp`), one-way **Chi-square test**
    (`chisquare`), and many more.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 也包含了大多数已知的统计测试和程序：**t 检验**（`ttest_1samp` 用于一组分数，`ttest_ind` 用于两个独立样本的分数，或
    `ttest_rel` 用于两个相关样本的分数），**柯尔莫哥洛夫-斯米尔诺夫检验**（`kstest`，`ks_2samp`）用于拟合优度，单因素 **卡方检验**（`chisquare`），以及更多。
- en: Let us illustrate some of the routines of this module with a textbook example,
    based on Timothy Sturm's studies on control design.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个教科书上的例子来说明这个模块的一些常规操作，这个例子基于Timothy Sturm对控制设计的 研究。
- en: 'To turn a knob that moved an indicator by the screw action, 25 right-handed
    individuals were asked to use their right hands. There were two identical instruments,
    one with a right-handed thread where the knob turned clockwise, and the other
    with a left-hand thread where the knob turned counter-clockwise. The following
    table gives the times in seconds each subject took to move the indicator to a
    fixed distance:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了转动一个通过螺丝动作移动指示器的旋钮，25 名右手使用者被要求使用他们的右手。有两种相同的仪器，一个有右手螺纹，旋钮顺时针转动，另一个有左手螺纹，旋钮逆时针转动。以下表格给出了每个受试者将指示器移动到固定距离所需的时间（秒）：
- en: '| **Subject** | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **受试者** | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |'
- en: '| **Right thread** | 113 | 105 | 130 | 101 | 138 | 118 | 87 | 116 | 75 | 96
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **右螺纹** | 113 | 105 | 130 | 101 | 138 | 118 | 87 | 116 | 75 | 96 |'
- en: '| **Left thread** | 137 | 105 | 133 | 108 | 115 | 170 | 103 | 145 | 78 | 107
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **左螺纹** | 137 | 105 | 133 | 108 | 115 | 170 | 103 | 145 | 78 | 107 |'
- en: '| **Subject** | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **受试者** | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 |'
- en: '| **Right thread** | 122 | 103 | 116 | 107 | 118 | 103 | 111 | 104 | 111 |
    89 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **右螺纹** | 122 | 103 | 116 | 107 | 118 | 103 | 111 | 104 | 111 | 89 |'
- en: '| **Left thread** | 84 | 148 | 147 | 87 | 166 | 146 | 123 | 135 | 112 | 93
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **左螺纹** | 84 | 148 | 147 | 87 | 166 | 146 | 123 | 135 | 112 | 93 |'
- en: '| **Subject** | 21 | 22 | 23 | 24 | 25 |   |   |   |   |   |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **受试者** | 21 | 22 | 23 | 24 | 25 |   |   |   |   |   |'
- en: '| **Right thread** | 78 | 100 | 89 | 85 | 88 |   |   |   |   |   |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **右螺纹** | 78 | 100 | 89 | 85 | 88 |   |   |   |   |   |'
- en: '| **Left thread** | 76 | 116 | 78 | 101 | 123 |   |   |   |   |   |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **左螺纹** | 76 | 116 | 78 | 101 | 123 |   |   |   |   |   |'
- en: 'We may perform an analysis that leads to a conclusion about right-handed people
    finding right-hand threads easier to use, by a simple one-sample t-statistic.
    We will load the data in memory, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个简单的单样本 t 统计量分析来得出结论，即右手使用者发现右手螺纹更容易使用。我们将如下方式将数据加载到内存中：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The difference of each row indicates which knob was faster, and for how much
    time. We can obtain that information easily and perform some basic statistical
    analysis on it. We will start by computing the mean, standard deviation, and a
    histogram with 10 bins:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行的差异表示哪个旋钮更快，以及快了多少时间。我们可以轻松地获得这些信息，并对它进行一些基本的统计分析。我们将从计算平均值、标准差和具有 10 个分箱的直方图开始：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is shown as:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s plot the histogram by issuing the following set of commands:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下一系列命令绘制直方图：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This produces the following histogram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下直方图：
- en: '![Interval estimation, correlation measures, and statistical tests](img/7702OS_06_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![区间估计、相关度量统计测试](img/7702OS_06_02.jpg)'
- en: In light of this histogram, it is not far-fetched to assume a normal distribution.
    If we assume that this is a proper simple random sample, the use of t-statistics
    is justified. We would like to prove that it takes longer to turn the left thread
    than the right, so we set the mean of `dataDiff` to be contrasted against the
    zero mean (which would indicate that it takes the same time for both threads).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这个直方图，假设数据服从正态分布并不牵强。如果我们假设这是一个合适的简单随机样本，使用t统计量是合理的。我们想要证明左旋螺纹的转动时间比右旋螺纹长，因此我们将`dataDiff`的均值设定为与零均值（这表明两种螺纹所需时间相同）进行对比。
- en: 'The two-sample t-statistics and p-value for the two-sided test are computed
    by the simple command, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的命令计算双样本t统计量和双样本检验的p值，如下所示：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The p-value for the one-sided test is then calculated:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后计算单侧检验的p值：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is shown as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that this p-value is much smaller than either of the usual thresholds `alpha
    = 0.05` or `alpha = 0.1`. We can thus guarantee that we have enough evidence to
    support the claim that right-handed threads take less time to turn than left-handed
    threads.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个p值比通常的阈值`alpha = 0.05`或`alpha = 0.1`都要小得多。因此，我们可以保证我们有足够的证据来支持以下说法：右旋螺纹比左旋螺纹转动所需时间更短。
- en: Distribution fitting
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布拟合
- en: 'In Timothy Sturm''s example, we claim that the histogram of some data seemed
    to fit a normal distribution. SciPy has a few routines to help us approximate
    the best distribution to a random variable, together with the parameters that
    best approximate this fit. For example, for the data in that problem, the mean
    and standard deviation of the normal distribution that realizes the best fit can
    be found in the following way:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在Timothy Sturm的例子中，我们声称某些数据的直方图似乎符合正态分布。SciPy有几个例程可以帮助我们近似随机变量的最佳分布，以及最佳拟合的参数。例如，对于那个问题中的数据，实现最佳拟合的正态分布的均值和标准差可以通过以下方式找到：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now plot the (`normed`) histogram of the data, together with the computed
    probability density function, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以绘制数据的（归一化）直方图，以及计算出的概率密度函数，如下所示：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will obtain the following graph showing the maximum likelihood estimate
    to the normal distribution that best fits `dataDiff`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得以下图表，显示对`dataDiff`最佳拟合的正态分布的最大似然估计：
- en: '![Distribution fitting](img/7702OS_06_03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![分布拟合](img/7702OS_06_03.jpg)'
- en: 'We may even fit the best probability density function without specifying any
    particular distribution, thanks to a non-parametric technique, **kernel density
    estimation**. We can find an algorithm to perform Gaussian kernel density estimation
    in the `scipy.stats.kde` submodule. Let us show by example with the same data
    as before:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以不指定任何特定的分布来拟合最佳概率密度函数，这要归功于一种非参数技术，**核密度估计**。我们可以在`scipy.stats.kde`子模块中找到一个执行高斯核密度估计的算法。让我们通过以下示例来展示，使用与之前相同的数据：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A slightly different plotting session as given before, offers us the following
    graph, showing probability density function obtained by kernel density estimation
    on `dataDiff`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的稍微不同的绘图会给出以下图表，显示通过核密度估计在`dataDiff`上获得的概率密度函数：
- en: '![Distribution fitting](img/7702OS_06_04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![分布拟合](img/7702OS_06_04.jpg)'
- en: 'The full piece of code is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为完整的代码块：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For comparative purposes, the last two plots can be combined into one:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较目的，最后两个图表可以合并成一个：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is the combined plot as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是以下综合图表：
- en: '![Distribution fitting](img/7702OS_06_05.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![分布拟合](img/7702OS_06_05.jpg)'
- en: Distances
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 距离
- en: 'In the field of data mining, it is often required to determine which members
    of a training set are closest to unknown test instances. It is imperative to have
    a good set of different distance functions for any of the algorithms that perform
    the search, and SciPy has, for this purpose, a huge collection of optimally coded
    functions in the distance submodule of the scipy.spatial module. The list is long.
    Besides Euclidean, squared Euclidean, or standardized Euclidean, we have many
    more—**Bray-Curtis**, **Canberra**, **Chebyshev**, **Manhattan**, correlation
    distance, cosine distance, **dice dissimilarity**, **Hamming**, **Jaccard-Needham**,
    **Kulsinski**, **Mahalanobis**, and so on. The syntax in most cases is simple:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据挖掘领域，经常需要确定训练集中哪些成员与未知测试实例最接近。对于任何执行搜索的算法，拥有一个好的不同距离函数集是必不可少的，SciPy为此目的在`scipy.spatial`模块的距离子模块中提供了一个巨大的优化编码函数集合。列表很长。除了欧几里得、平方欧几里得或标准化欧几里得之外，我们还有许多其他函数——**Bray-Curtis**、**Canberra**、**Chebyshev**、**Manhattan**、相关距离、余弦距离、**dice不相似性**、**Hamming**、**Jaccard-Needham**、**Kulsinski**、**Mahalanobis**等等。在大多数情况下，语法都很简单：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only three cases in which the syntax is different are the Minkowski, Mahalanobis,
    and standardized Euclidean distances, in which the distance function requires
    either an integer number (for the order of the norm in the definition of Minkowski
    distance), a covariance for the Mahalanobis case (but this is an optional requirement),
    or a variance matrix to standardize the Euclidean distance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 语法不同的只有三种情况，即闵可夫斯基、马氏和标准化欧几里得距离，其中距离函数需要整数（用于闵可夫斯基距离定义中范数的阶数），马氏距离的情况需要协方差（但这是一个可选要求），或者方差矩阵来标准化欧几里得距离。
- en: 'Let us see now a fun exercise to visualize the unit balls in Minkowski metrics:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个有趣的练习，用于可视化Minkowski度量中的单位球：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have created a function, `Ball`, which creates a grid of 512 x 512 Boolean
    values. The grid represents a square of length 2.2 centered at the origin, with
    sides parallel to the coordinate axis, and the true values on it represent all
    those points of the grid inside of the unit ball for the Minkowksi metric, for
    the parameter `p`. All we have to do is show it graphically, as in the following
    example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个函数`Ball`，它创建一个512 x 512的布尔值网格。该网格代表一个以原点为中心、边平行于坐标轴的长度为2.2的正方形，其上的真实值代表所有在Minkowski度量中参数`p`的单位球内的网格点。我们只需将其图形化展示，如下例所示：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This produces the following, where `Ball(3)` is a unit ball in the Minkowski
    metric with parameter `p = 3`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下结果，其中`Ball(3)`是参数`p = 3`的Minkowski度量的单位球：
- en: '![Distances](img/7702OS_06_06.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![距离](img/7702OS_06_06.jpg)'
- en: 'We feel the need to issue the following four important warnings:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们觉得有必要发出以下四个重要警告：
- en: '**First warning**: We must use these routines instead of creating our own definitions
    of the corresponding distance functions whenever possible. They guarantee a faster
    result and optimal coding to take care of situations in which the inputs are either
    too large or too small.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一次警告**：只要可能，我们必须使用这些过程而不是创建我们自己的对应距离函数的定义。它们保证了更快的结果，并优化了处理输入过大或过小的情况的编码。'
- en: '**Second warning**: These functions work great when comparing two vectors;
    however, for the pairwise computation of many vectors, we must resort to the `pdist`
    routine. This command takes an *m x n* array representing *m* vectors of dimension
    *n*, and computes the distance of each of them to each other. We indicate the
    distance function to be used with the option metric and additional parameters
    as needed. For example, for the Manhattan (`cityblock`) distance for five randomly
    selected randomly selected four-dimensional vectors with integer values `1`, `0`,
    or `-1`, we could issue the following command:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二次警告**：这些函数在比较两个向量时工作得很好；然而，对于许多向量的成对计算，我们必须求助于`pdist`过程。此命令接受一个表示*m*个维度为*n*的向量的*m
    x n*数组，并计算它们之间的距离。我们使用选项metric和所需的附加参数来指示要使用的距离函数。例如，对于五个随机选择的四维向量（整数值为`1`、`0`或`-1`）的曼哈顿（`cityblock`）距离，我们可以发出以下命令：'
- en: '[PRE19]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is shown as follows:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE20]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s take a look at the following `pdist` command:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看以下`pdist`命令：
- en: '[PRE21]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is shown as follows:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE22]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This means, if `v1 = [1,0,1,-1]`, `v2 = [-1,0,-1,0]`, `v3 = [1,1,1,-1]`, `v4
    = [1,1,-1,0]`, and `v5 = [0,0,1,-1]`, then the Manhattan distance of `v1` from
    `v2` is 5\. The distance from `v1` to `v3` is 1; from `v1` to `v4`, 4; and from
    `v1` to `v5`, 1\. From `v2` to `v3` the distance is 6; from `v2` to `v4`, 3; and
    from `v2` to `v5`, 4\. From `v3` to `v4` the distance is 3; and from `v3` to `v5`,
    2\. And finally, the distance from `v4` to `v5` is 5, which is the last entry
    of the output.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着，如果`v1 = [1,0,1,-1]`，`v2 = [-1,0,-1,0]`，`v3 = [1,1,1,-1]`，`v4 = [1,1,-1,0]`，`v5
    = [0,0,1,-1]`，那么`v1`到`v2`的曼哈顿距离是5。`v1`到`v3`的距离是1；到`v1`到`v4`，4；到`v1`到`v5`，1。从`v2`到`v3`的距离是6；从`v2`到`v4`，3；从`v2`到`v5`，4。从`v3`到`v4`的距离是3；从`v3`到`v5`，2。最后，`v4`到`v5`的距离是5，这是输出的最后一个条目。
- en: '**Third warning**: When computing the distance between each pair of two collections
    of inputs, we should use the `cdist` routine, which has a similar syntax. For
    instance, for the two collections of three randomly selected four-dimensional
    Boolean vectors, the corresponding Jaccard-Needham dissimilarities are computed,
    as follows:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三次警告**：在计算两个输入集合中每对之间的距离时，我们应该使用`cdist`过程，它具有类似的语法。例如，对于两个由随机选择的四维布尔向量组成的集合，相应的Jaccard-Needham不相似度计算如下：'
- en: '[PRE23]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That is, if the three vectors in `V` are labeled `v1`, `v2`, and `v3` and if
    the two vectors in `W` are labeled as `w1` and `w2`, then the dissimilarity between
    `v1` and `w1` is 0.75; between `v1` and `w2`, 1; and so on.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即，如果`V`中的三个向量分别标记为`v1`、`v2`和`v3`，而`W`中的两个向量分别标记为`w1`和`w2`，那么`v1`和`w1`之间的不相似度为0.75；`v1`和`w2`之间的不相似度为1；依此类推。
- en: '**Fourth warning**: When we have a large amount of data points and we need
    to address the problem of nearest neighbors (for example, to locate the closest
    element of the data to a new instance point), we seldom do it by brute force.
    The optimal algorithm to perform this search is based on the idea of k-dimensional
    trees. SciPy has two classes to handle these objects – `KDTree` and `cKDTree`.
    The latter is a subset of the former, a little faster since it is wrapped from
    C code, but with very limited use. It only has the `query` method to find the
    nearest neighbors of the input. The syntax is simple, as follows:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第四次警告**：当我们有大量数据点并且需要解决最近邻问题（例如，定位数据中与新的实例点最近的元素）时，我们很少通过暴力方法来做。执行此搜索的最佳算法基于k维树的概念。SciPy有两个类来处理这些对象—`KDTree`和`cKDTree`。后者是前者的子集，由于它是用C代码包装的，所以稍微快一点，但用途非常有限。它只有`query`方法来查找输入的最近邻。语法简单，如下所示：'
- en: '[PRE24]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This creates a structure containing a binary tree, very apt for the design of
    fast search algorithms. The `leafsize` option indicates at what level the search
    based on the structure of the binary tree must be abandoned in favor of brute
    force.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这创建了一个包含二叉树的结构，非常适合快速搜索算法的设计。`leafsize`选项表示在什么级别上必须放弃基于二叉树结构的搜索，转而使用暴力搜索。
- en: The other methods associated with the `KDTree` class are—`count_neighbors`,
    to compute the number of nearby pairs that can be formed with another `KDTree`;
    `query_ball_point`, to find all points at a given distance from the input; `query_ball_tree`
    and `query_pairs`, to find all pairs of points within certain distance; and `sparse_distance_matrix`,
    that computes a sparse matrix with the distances between two `KDTree` classes.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与`KDTree`类相关联的其他方法包括—`count_neighbors`，用于计算可以与另一个`KDTree`形成的邻近对的数量；`query_ball_point`，用于查找给定距离内的所有点；`query_ball_tree`和`query_pairs`，用于查找一定距离内的所有点对；以及`sparse_distance_matrix`，它计算两个`KDTree`类之间的距离稀疏矩阵。
- en: 'Let us see it in action, with a small dataset of 10 randomly generated four-dimensional
    points with integer entries:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们用一个包含10个随机生成的四维整数点的数据集来看看它的实际应用：
- en: '[PRE25]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is shown as follows:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is shown as follows:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE27]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This means, among all the points in the dataset, the closest one in the Euclidean
    distance to the origin is the fifth one (index 4), and the distance is precisely
    about 4.6 units.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，在数据集中的所有点中，到原点欧几里得距离最近的是第五个点（索引4），距离恰好是4.6个单位。
- en: We can have an input of more than one point; the output will still be a tuple,
    where the first entry is an array that indicates the smallest distance to each
    of the input points. The second entry is another array that indicates the indices
    of the nearest neighbors.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一个包含多个点的输入；输出仍然是一个元组，其中第一个条目是一个数组，指示每个输入点的最小距离。第二个条目是另一个数组，指示最近邻的索引。
- en: Clustering
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚类
- en: Another technique used in data mining is clustering. SciPy has two modules to
    deal with any problem in this field, each of them addressing a different clustering
    tool—`scipy.cluster.vq` for k-means and `scipy.cluster.hierarchy` for hierarchical
    clustering.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 数据挖掘中使用的另一种技术是聚类。SciPy有两个模块来处理这个领域的任何问题，每个模块都针对不同的聚类工具——`scipy.cluster.vq`用于k-means聚类和`scipy.cluster.hierarchy`用于层次聚类。
- en: Vector quantization and k-means
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量量化与k-means
- en: 'We have two routines to divide data into clusters using the k-means technique—`kmeans`
    and `kmeans2`. They correspond to two different implementations. The former has
    a very simple syntax:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个例程使用k-means技术将数据划分为聚类——`kmeans`和`kmeans2`。它们对应于两种不同的实现。前者具有非常简单的语法：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `obs` parameter is an `ndarray` with the data we wish to cluster. If the
    dimensions of the array are *m* x *n*, the algorithm interprets this data as *m*
    points in the n-dimensional Euclidean space. If we know the number of clusters
    in which this data should be divided, we enter so with the `k_or_guess` option.
    The output is a tuple with two elements. The first is an `ndarray` of dimension
    *k* x *n*, representing a collection of points—as many as clusters were indicated.
    Each of these locations indicates the centroid of the found clusters. The second
    entry of the tuple is a floating-point value indicating the distortion between
    the passed points, and the centroids generated previously.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`obs`参数是一个包含我们希望聚类的数据的`ndarray`。如果数组的维度是*m* x *n*，则算法将此数据解释为*n*维欧几里得空间中的*m*个点。如果我们知道这些数据应该被划分为多少个聚类，我们通过`k_or_guess`选项输入这个数字。输出是一个包含两个元素的元组。第一个是一个*k*
    x *n*维的`ndarray`，表示一个点的集合——与指示的聚类数量一样多。这些位置中的每一个都表示找到的聚类的质心。元组的第二个条目是一个表示传递的点与先前生成的质心之间的畸变的浮点值。'
- en: If we wish to impose an initial guess for the centroids of the clusters, we
    may do so with the `k_or_guess` parameter again, by sending a *k* x *n* `ndarray`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望为聚类的质心指定一个初始猜测，我们可以再次通过`k_or_guess`参数这样做，通过发送一个*k* x *n*的`ndarray`。
- en: The data we pass to `kmeans` need to be normalized with the `whiten` routine.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`kmeans`的数据需要通过`whiten`例程进行归一化。
- en: 'The second option is much more flexible, as its syntax indicates:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选项更加灵活，正如其语法所表明的：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `data` and `k` parameters are the same as `obs` and `k_or_guess`, respectively.
    The difference in this routine is the possibility of choosing among different
    initialization algorithms, hence providing us with the possibility to speed up
    the process and use fewer resources if we know some properties of our data. We
    do so by passing to the `minit` parameter, one of the strings such as `'random'`
    (initialization centroids are constructed randomly using a Gaussian), `'points'`
    (initialization is done by choosing points belonging to our data), or `'uniform'`
    (if we prefer uniform distribution to Gaussian).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`和`k`参数分别与`obs`和`k_or_guess`相同。这个例程的不同之处在于可以选择不同的初始化算法，因此，如果我们知道我们数据的一些属性，我们可以通过将一个字符串传递给`minit`参数来加速过程并使用更少的资源。我们可以通过传递一个*k*
    x *n*的`ndarray`来这样做，例如`''random''`（使用高斯随机构建初始化质心），`''points''`（通过选择属于我们数据的点进行初始化），或`''uniform''`（如果我们更喜欢均匀分布而不是高斯分布）。'
- en: In case we would like to provide the initialization centroids ourselves with
    the `k` parameter, we must indicate our choice to the algorithm by passing `'matrix'`
    to the `minit` option as well.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望使用`k`参数自己提供初始化质心，我们必须通过将`'matrix'`传递给`minit`选项来向算法指示我们的选择。
- en: 'In any case, if we wish to classify the original data by assigning to each
    point the cluster to which it belongs; we do so with the `vq` routine (for vector
    quantization). The syntax is pretty simple as well:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，如果我们希望通过将每个点分配到它所属的聚类来对原始数据进行分类；我们使用`vq`例程（用于向量量化）。语法同样简单：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The output is a tuple with two entries. The first entry is a one-dimensional
    `ndarray` of size *n* holding for each point in `obs`, the cluster to which it
    belongs. The second entry is another one-dimensional `ndarray` of the same size,
    but containing floating-point values indicating the distance from each point to
    the centroid of its cluster.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个包含两个条目的元组。第一个条目是一个包含*n*个元素的二维`ndarray`，对于`obs`中的每个点，它表示该点所属的聚类。第二个条目是另一个同样大小的二维`ndarray`，但它包含表示每个点到其聚类质心的距离的浮点值。
- en: 'Let us illustrate with a classical example, the mouse dataset. We will create
    a big dataset with randomly generated points in three disks, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个经典的例子来说明，即鼠标数据集。我们将创建一个包含在三个圆盘内随机生成的点的大数据集，如下所示：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once created, we will request the data to be separated into three clusters:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，我们将请求数据被分成三个簇：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let us present the results:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示结果：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This gives the following plot showing the mouse dataset with three clusters
    from left to right—red (squares), blue (pluses), and black (dots):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下从左到右显示包含三个簇的鼠标数据集的图——红色（正方形）、蓝色（加号）和黑色（点）：
- en: '![Vector quantization and k-means](img/7702OS_06_07.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![矢量量化与k均值](img/7702OS_06_07.jpg)'
- en: Hierarchical clustering
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层次聚类
- en: 'There are several different algorithms to perform hierarchical clustering.
    SciPy has routines for the following methods:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的算法可以进行层次聚类。SciPy 提供了以下方法的例程：
- en: '**Single/min/nearest method**: `single`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单/最小/最近方法**：`single`'
- en: '**Complete/max/farthest method**: `complete`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全/最大/最远方法**：`complete`'
- en: '**Average/UPGMA method**: `average`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平均/UPGMA方法**：`average`'
- en: '**Weighted/WPGMA method**: `weighted`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加权/WPGMA方法**：`weighted`'
- en: '**Centroid/UPGMC method**: `centroid`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质心/UPGMC方法**：`centroid`'
- en: '**Median/WPGMC method**: `median`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中位数/WPGMC方法**：`median`'
- en: '**Ward''s linkage method**: `ward`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沃德链接方法**：`ward`'
- en: In any of the previous cases, the syntax is the same; the only input is the
    dataset, which can be either an *m* x *n* `ndarray` representing *m* points in
    the n-dimensional Euclidean space, or a condensed distance matrix obtained from
    the previous data using the `pdist` routine from `scipy.spatial`. The output is
    always an `ndarray` representing the corresponding linkage matrix of the clustering
    obtained.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何上述情况下，语法都是相同的；唯一的输入是数据集，它可以是表示 n 维欧几里得空间中 *m* 个点的 *m* x *n* `ndarray`，或者是从之前数据使用
    `scipy.spatial` 中的 `pdist` 例程获得的压缩距离矩阵。输出始终是一个表示聚类获得的对应链接矩阵的 `ndarray`。
- en: 'Alternatively, we may call the clustering with the generic routine `linkage`.
    This routine accepts a dataset/distance matrix, and a string indicating the method
    to use. The strings coincide with the names introduced. The advantage of `linkage`
    over the previous routines is that we are also allowed to indicate a different
    metric than the usual Euclidean distance. The complete syntax for `linkage` is
    then as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用通用的 `linkage` 例程进行聚类。这个例程接受一个数据集/距离矩阵，以及一个表示要使用的方法的字符串。这些字符串与之前引入的名称相匹配。`linkage`
    相比之前的例程的优势在于，我们还可以指定不同于通常欧几里得距离的不同度量。`linkage` 的完整语法如下：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Different statistics on the resulting linkage matrices may be performed with
    the routines such as Cophenetic distances between observations (`cophenet`); inconsistency
    statistics (`inconsistent`); maximum inconsistency coefficient for each non-singleton
    cluster with its descendants (`maxdists`); and maximum statistic for each non-singleton
    cluster with its descendants (`maxRstat`).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用诸如观察之间的柯芬特距离（`cophenet`）、不一致性统计（`inconsistent`）、每个非单簇及其后代的最大不一致系数（`maxdists`）以及每个非单簇及其后代的最大统计量（`maxRstat`）等例程对结果链接矩阵执行不同的统计操作。
- en: 'It is customary to use binary trees to represent linkage matrices, and the
    `scipy.cluster.hierachy` submodule has a large number of different routines to
    manipulate and extract information from these trees. The most useful of these
    routines is the visualization of these trees, often called dendrograms. The corresponding
    routine in SciPy is dendrogram, and has the following imposing syntax:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二叉树来表示关联矩阵是惯例，`scipy.cluster.hierachy` 子模块提供了大量不同的例程来操作和从这些树中提取信息。其中最有用的例程是这些树的可视化，通常称为树状图。SciPy
    中对应的例程是 `dendrogram`，其语法如下：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first obvious parameter, `Z`, is a linkage matrix. This is the only non-optional
    variable. The other options control the style of the output (colors, labels, rotation,
    and so on), and since they are technically nonmathematical in nature, we will
    not explore them in detail in this monograph, other than through the simple application
    to animal clustering shown next.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个明显的参数，`Z`，是一个链接矩阵。这是唯一的非可选变量。其他选项控制输出样式（颜色、标签、旋转等），由于它们在技术上是非数学性质，我们不会在本专著中详细探讨它们，除了通过以下简单应用于动物聚类的示例。
- en: Clustering mammals by their dentition
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根据牙齿排列聚类哺乳动物
- en: Mammals' teeth are divided into four groups such as incisors, canines, premolars,
    and molars. The dentition of several mammals has been collected, and is available
    for download at [http://www.uni-koeln.de/themen/statistik/data/cluster/dentitio.dat](http://www.uni-koeln.de/themen/statistik/data/cluster/dentitio.dat).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 哺乳动物的牙齿被分为四组，如门齿、犬齿、前臼齿和臼齿。已经收集了多种哺乳动物的牙齿数据，可在[http://www.uni-koeln.de/themen/statistik/data/cluster/dentitio.dat](http://www.uni-koeln.de/themen/statistik/data/cluster/dentitio.dat)下载。
- en: This file presents the name of the mammal, together with the number of top incisors,
    bottom incisors, top canines, bottom canines, top premolars, bottom premolars,
    top molars, and bottom molars.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件展示了哺乳动物的名称，以及顶门齿、底门齿、顶犬齿、底犬齿、顶前臼齿、底前臼齿、顶臼齿和底臼齿的数量。
- en: We wish to use hierarchical clustering on that dataset to assess which species
    are closer to each other by these features.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用层次聚类对数据集进行聚类，以评估哪些物种在这些特征上更接近。
- en: 'We will start by preparing the dataset and store the relevant data in ndarrays.
    The original data is given as a text file, where each line represents a different
    mammal. The first four lines are as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先准备数据集并将相关数据存储在ndarrays中。原始数据以文本文件的形式给出，其中每行代表不同的哺乳动物。以下是前四行：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The first 27 characters of each line hold the name of the animal. The characters
    in positions 28 to 35 are the number of respective kinds of dentures. We need
    to prepare this data into something that SciPy can handle. We will collect the
    names apart, since we will be using them as labels in the dendrogram. The rest
    of the data will be forced into an array of integers:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行的前27个字符包含动物的名称。第28至35位的字符表示各自种类的牙齿数量。我们需要将此数据准备成SciPy可以处理的形式。我们将单独收集名称，因为我们将在树状图中使用它们作为标签。其余的数据将被强制转换为整数数组：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will proceed to compute the linkage matrix and its posterior dendrogram,
    making sure to use the Python list, mammals, as labels:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续计算连接矩阵及其后继树状图，确保使用Python列表mammals作为标签：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This gives us the following dendrogram showing clustering of mammals according
    to their dentition:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下树状图，显示了根据牙齿聚类哺乳动物：
- en: '![Clustering mammals by their dentition](img/7702OS_06_08.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![根据牙齿聚类哺乳动物](img/7702OS_06_08.jpg)'
- en: Note how all the bats are clustered together. The mice are also clustered together,
    but far from the bats. Sheep, goats, antelopes, deer, and moose have similar dentures
    too, and they appear clustered at the bottom of the tree, next to the opossum
    and the armadillo. Note how all felines are also clustered together, on the top
    of the tree.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有蝙蝠都被聚在一起。老鼠也聚在一起，但离蝙蝠很远。绵羊、山羊、羚羊、鹿和驼鹿也有类似的牙齿，它们在树的底部聚集，靠近负鼠和犰狳。注意所有猫科动物也聚在一起，在树的顶部。
- en: Experts in data analysis can obtain more information from dendrograms; they
    are able to interpret the lengths of the branches or the different colors used
    in the composition, and give us more insightful explanations about the way the
    clusters differ from each other.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析专家可以从树状图中获得更多信息；他们能够解释分支的长度或组成中使用的不同颜色，并给我们更多关于簇之间差异的深入解释。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter dealt with tools appropriate for data mining and explored modules
    such as `stats` (for statistics), `spatial` (for data structures), and `cluster`
    (for clustering and vector quantization). In the next chapter, additional functionalities
    included in the SciPy module, `scipy.spatial`, will be studied, complementing
    the ones already explored in previous chapters. As usual, each function introduced
    will be illustrated via non-trivial examples which can be enriched modifying the
    IPython Notebook corresponding to this chapter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了适用于数据挖掘的工具，并探讨了`stats`（用于统计）、`spatial`（用于数据结构）和`cluster`（用于聚类和向量量化）等模块。在下一章中，将研究SciPy模块`scipy.spatial`中包含的附加功能，以补充前几章中已经探讨的功能。像往常一样，每个介绍的功能将通过非平凡示例进行说明，这些示例可以通过修改与本章对应的IPython
    Notebook来丰富。
