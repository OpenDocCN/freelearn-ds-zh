- en: Chapter 1. Python for Data Science
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章：Python 数据科学
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Using dictionary objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字典对象
- en: Working with a dictionary of dictionaries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作字典中的字典
- en: Working with tuples
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作元组
- en: Using sets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合
- en: Writing a list
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入一个列表
- en: Creating a list from another list - list comprehension
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从另一个列表创建列表 - 列表推导式
- en: Using iterators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器
- en: Generating an iterator and a generator
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成迭代器和生成器
- en: Using iterables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可迭代对象
- en: Passing a function as a variable
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为变量传递
- en: Embedding functions in another function
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一个函数中嵌入函数
- en: Passing a function as a parameter
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为参数传递
- en: Returning a function
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回函数
- en: Altering the function behavior with decorators
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器更改函数行为
- en: Creating anonymous functions with lambda
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 lambda 创建匿名函数
- en: Using the map function
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 map 函数
- en: Working with filters
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过滤器
- en: Using zip and izip
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 zip 和 izip
- en: Processing arrays from the tabular data
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理表格数据中的数组
- en: Preprocessing the columns
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理列
- en: Sorting lists
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序列表
- en: Sorting with a key
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用键排序
- en: Working with itertools
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 itertools
- en: Introduction
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The Python programming language provides a lot of built-in data structures and
    functions that are very handy for data science programming. In this chapter, we
    will look at some that are most frequently used. In the subsequent chapters, you
    will see that these will be used in various sections for different topics. A good
    grasp of these will help you in the long run to quickly bootstrap a program in
    order to handle data and develop algorithms.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python 编程语言提供了许多内建的数据结构和函数，这些对于数据科学编程非常有用。在本章中，我们将介绍一些最常用的结构和函数。在随后的章节中，你会看到这些将在不同主题的各个部分中使用。掌握这些结构和函数将有助于你快速启动程序，以便处理数据和开发算法。
- en: While this chapter is a quick overview of handy data structures and methods,
    you will start discovering your own ways of combining these data structures to
    achieve your requirements as you become a seasoned Python user.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章是对常用数据结构和方法的快速概览，但随着你成为熟练的 Python 用户，你将开始发现自己的方法，将这些数据结构结合使用，以满足你的需求。
- en: Each of these data structures have an utility, though different circumstances
    may require using two or more data structures in tandem to achieve your requirements.
    You will see this in action in some of the examples in this book.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据结构都有其用途，虽然不同的情况可能需要同时使用两个或多个数据结构来满足需求。你将在本书的一些示例中看到这一点。
- en: Using dictionary objects
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字典对象
- en: In Python, containers are objects that can hold any number of arbitrary objects.
    They provide a way to access the child objects and iterate over them. Dictionary,
    tuple, list, and set are container objects in Python. More container types are
    available with the `collections` module. Let's look at the dictionary object in
    detail in this section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，容器是可以容纳任意数量对象的对象。它们提供了一种访问子对象并对其进行迭代的方式。字典、元组、列表和集合是 Python 中的容器对象。`collections`
    模块提供了更多的容器类型。让我们在本节中详细了解字典对象。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's look at an example Python script to understand how a dictionary operates.
    So, with a text, this script tries to get the word count, that is, how many times
    each word has appeared in the given text.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个 Python 脚本示例，理解字典是如何操作的。这个脚本试图获取文本中的单词计数，即每个单词在给定文本中出现的次数。
- en: How to do it…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作它……
- en: 'Let''s proceed to demonstrate how to operate a dictionary in Python. Let''s
    use a simple sentence to demonstrate the use of a dictionary. We will follow it
    up with an actual dictionary creation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续演示如何在 Python 中操作字典。我们将使用一个简单的句子来演示字典的使用。然后我们将进行实际的字典创建：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The preceding code builds a word frequency table; every word and its frequency
    is calculated. The final print statement produces the following output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码构建了一个单词频率表；每个单词及其频率都被计算出来。最终的打印语句会输出以下内容：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding output is a key value pair. For each word (key), we have a frequency
    (value). A dictionary data structure is a hash map where values are stored against
    a key. In the preceding example, we used a string as a key; however, any other
    immutable data type can also be used as a key.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出是一个键值对。对于每个单词（键），我们有一个频率（值）。字典数据结构是一个哈希映射，其中值是按键存储的。在上面的示例中，我们使用了字符串作为键；然而，任何其他不可变的数据类型也可以用作键。
- en: 'Refer to the following URL for a detailed discussion about mutable and immutable
    objections in Python:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 参阅以下 URL，了解 Python 中可变和不可变对象的详细讨论：
- en: '[https://docs.python.org/2/reference/datamodel.html](https://docs.python.org/2/reference/datamodel.html)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/reference/datamodel.html](https://docs.python.org/2/reference/datamodel.html)'
- en: Similarly, values can be any data type including custom classes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，值可以是任何数据类型，包括自定义类。
- en: 'In step 2, we initialized the dictionary. Its empty when initialized. When
    a new key is added to a dictionary, accessing the dictionary through the new key
    will throw `KeyError`. In the preceding example in step 3, we included an if statement
    in the for loop to handle this situation. However, we can also use the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 步中，我们初始化了字典。它在初始化时是空的。当向字典中添加新键时，通过新键访问字典将抛出 `KeyError`。在前面的示例第 3 步中，我们在
    for 循环中包含了一个 if 语句来处理这种情况。然而，我们也可以使用以下方法：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With every key access to the dictionary, this statement has to be repeated
    if we are adding elements to a dictionary in a loop, as in a loop, we are not
    aware of new keys. Rewriting step 3 using `setdefault` will look as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每次访问字典的键时，如果我们在循环中向字典添加元素，这个语句必须重复，因为在循环中我们无法预知新的键。使用 `setdefault` 重写第 3 步如下所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There's more…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'Python 2.5 and above has a class named `defaultdict`; it''s in the `collections`
    module. This takes care of the `setdefault` action. A `defaultdict` class is invoked
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.5 及以上版本有一个名为 `defaultdict` 的类，它位于 `collections` 模块中。这个类处理了 `setdefault`
    操作。`defaultdict` 类的调用方法如下：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you have noticed, we included `collections.defaultdict` in our code and initialized
    our dictionary. Note that the `int` parameter, `defaultdict`, takes a function
    as an argument. In this case, we passed the `int()` function and thus, when the
    dictionary encounters a key that was not seen before, it initializes the key with
    a value returned by the `int()` function, in this case, zero. We will use `defaultdict`
    later in this book.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在代码中包含了 `collections.defaultdict` 并初始化了字典。请注意，`defaultdict` 需要一个函数作为参数。这里我们传递了
    `int()` 函数，因此当字典遇到一个之前未出现的键时，它会使用 `int()` 函数返回的值来初始化该键，在本例中是零。稍后我们将在本书中使用 `defaultdict`。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A typical dictionary does not remember the order in which the keys were inserted.
    In its collections module, Python provides a container called `OrderedDict` that
    can remember the order in which the keys were inserted. See the following Python
    documentation for more details:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 普通字典不会记住键插入的顺序。而在 `collections` 模块中，Python 提供了一个名为 `OrderedDict` 的容器，它可以记住键插入的顺序。更多细节请查看以下
    Python 文档：
- en: '[https://docs.python.org/2/library/collections.html#collections.OrderedDict](https://docs.python.org/2/library/collections.html#collections.OrderedDict)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/library/collections.html#collections.OrderedDict](https://docs.python.org/2/library/collections.html#collections.OrderedDict)'
- en: 'Looping through a dictionary is very easy; using the keys() function provided
    in the dictionary, we can loop through the key and using values(), we can loop
    through the values or using items(), we can loop through both the keys and values.
    Look at the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历字典非常简单；使用字典中提供的 keys() 函数，我们可以遍历键，使用 values() 函数，我们可以遍历值，或者使用 items() 函数，我们可以同时遍历键和值。请看以下示例：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, using `dict.items()`, we can iterate through the keys and values
    present in the dictionary.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，使用 `dict.items()`，我们可以遍历字典中存在的键和值。
- en: 'The Python documentation for dictionaries is very exhaustive and is a handy
    companion when working with dictionaries:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的字典文档非常详尽，是处理字典时的得力助手：
- en: '[https://docs.python.org/2/tutorial/datastructures.html#dictionaries](https://docs.python.org/2/tutorial/datastructures.html#dictionaries)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/tutorial/datastructures.html#dictionaries](https://docs.python.org/2/tutorial/datastructures.html#dictionaries)'
- en: Dictionaries are very useful as an intermediate data structure. If your program
    uses JSON as a way to move around information between modules, dictionary is the
    right data type for the job. It is very convenient to load a dictionary from a
    JSON file and similarly dump a dictionary as JSON strings.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 字典作为中间数据结构非常有用。如果你的程序使用 JSON 在模块之间传递信息，字典是适合的正确数据类型。将字典从 JSON 文件中加载进来，或者将字典转储为
    JSON 字符串，都非常方便。
- en: 'Python provides us with libraries to handle JSON very efficiently:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Python 为我们提供了非常高效的处理 JSON 的库：
- en: '[https://docs.python.org/2/library/json.html](https://docs.python.org/2/library/json.html)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/library/json.html](https://docs.python.org/2/library/json.html)'
- en: Counter is a dictionary subclass to count the hashable objects. Our example
    of the word count can be easily done using counter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Counter 是字典的子类，用于计数可哈希对象。我们用词频计数的例子可以轻松通过 Counter 来实现。
- en: 'Look at the following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看以下示例：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows and you can verify this output with the previous one:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下，你可以将这个输出与你之前的输出进行对比：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can go through the following link to understand more about Counters:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下链接了解更多关于 Counter 的信息：
- en: '[https://docs.python.org/2/library/collections.html#collections.Counter](https://docs.python.org/2/library/collections.html#collections.Counter)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/library/collections.html#collections.Counter](https://docs.python.org/2/library/collections.html#collections.Counter)'
- en: See also
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with Dictionary of Dictionaries* recipe in [Chapter 1](ch01.xhtml
    "Chapter 1. Python for Data Science"), *Using Python for Data Science*'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第一章](ch01.xhtml "第一章. Python 数据科学")中的 *使用字典的字典* 章节，*使用 Python 进行数据科学*'
- en: Working with a dictionary of dictionaries
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字典的字典
- en: As we mentioned earlier, the real power of these data structures lies in how
    creatively you can use them to achieve your tasks. Let's look at an example to
    understand how to use dictionaries in a dictionary.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这些数据结构的真正力量在于你如何创造性地使用它们来完成任务。让我们通过一个例子来理解如何在字典中使用字典。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: 'Look at the following table:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的表格：
- en: '![Getting ready](img/B04041_01_1.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![准备开始](img/B04041_01_1.jpg)'
- en: In the first column, we have three users and the rest of the columns are movies.
    The cell values are ratings given by a user for a movie. Let's say we want to
    represent this in memory so that some other part of a larger code base can easily
    access this information. We will use a dictionary of dictionaries to achieve this
    objective.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一列，我们有三个用户，其他列是电影。单元格中的值是用户对电影的评分。假设我们想要在内存中表示这些数据，以便更大代码库的其他部分可以轻松访问这些信息。我们将使用字典的字典来实现这个目标。
- en: How to do it…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: We will create the `user_movie_rating` dictionary using an anonymous function
    to demonstrate the concept of a dictionary of dictionaries.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用匿名函数创建 `user_movie_rating` 字典，演示字典的字典的概念。
- en: 'We will fill it with data to show the effective use of a dictionary of dictionaries:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将填充数据以展示字典的字典的有效使用：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The `user_movie_rating` is a dictionary of dictionaries. As explained in the
    previous section, `defaultdict` takes a function for argument; in this case, we
    passed a built-in anonymous function, `lambda`, which returns a dictionary. So,
    every time a new key is passed to `user_movie_rating`, a new dictionary will be
    created for this key. We will see more about the `lambda` function in the subsequent
    section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`user_movie_rating` 是一个字典的字典。如前一节所述，`defaultdict` 接受一个函数作为参数；在这个例子中，我们传入了一个内置的匿名函数
    `lambda`，它返回一个字典。因此，每次传入新键到 `user_movie_rating` 时，都会为该键创建一个新的字典。我们将在后续章节中深入了解
    `lambda` 函数。'
- en: This way, we can access the rating of any user movie combination very quickly.
    Similarly, there are plenty of use cases where a dictionary of dictionaries comes
    in very handy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以非常快速地访问任何用户-电影组合的评分。类似地，在很多场景中，字典的字典也非常有用。
- en: 'As a closing note on the dictionary, I would like to mention that having a
    good grasp of the dictionary data structure will help ease a lot of your data
    science programming tasks. As we will see later, dictionaries are frequently used
    to store features and labels in machine learning. The Python NLTK library uses
    a dictionary extensively to store features in text mining:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对字典的总结，我想提到的是，熟练掌握字典数据结构将有助于简化你在数据科学编程中的许多任务。正如我们稍后将看到的，字典常用于在机器学习中存储特征和标签。Python
    的 NLTK 库在文本挖掘中广泛使用字典来存储特征：
- en: '[http://www.nltk.org/book/ch05.html](http://www.nltk.org/book/ch05.html)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.nltk.org/book/ch05.html](http://www.nltk.org/book/ch05.html)'
- en: The section titled *Mapping words to Properties using Python Dictionaries* is
    a good read to understand how effectively dictionaries can be used.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 章节标题为 *使用 Python 字典将单词映射到属性* 是一本很好的阅读材料，有助于理解字典如何有效地使用。
- en: See also
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating Anonymous Functions* recipe in [Chapter 1](ch01.xhtml "Chapter 1. Python
    for Data Science"), *Using Python for Data Science*'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第一章](ch01.xhtml "第一章. Python 数据科学")中的 *创建匿名函数* 章节，*使用 Python 进行数据科学*'
- en: Working with tuples
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元组
- en: 'A tuple is a type of container object known as sequence types in Python. Tuples
    are immutable and can have a heterogeneous sequence of elements separated by a
    comma and enclosed in parentheses. They support the following operations:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是 Python 中的一种容器类型，属于序列类型。元组是不可变的，可以包含由逗号分隔并用圆括号括起来的异构元素序列。它们支持以下操作：
- en: '`in` and `not in`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in` 和 `not in`'
- en: Comparision, concatenation, slicing, and indexing
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较、连接、切片和索引
- en: '`min()` and `max()`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min()` 和 `max()`'
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Rather than having a full program as we did with dictionaries, we will see tuples
    as fragmented codes where we will concentrate on the creation and manipulation
    activities.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们使用字典时构建完整程序的方式不同，我们将在这里将元组视为碎片化代码，集中于创建和操作的过程。
- en: How to do it…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到……
- en: 'Let''s see some scripts demonstrating the creation and manipulation of tuples:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些示例，演示如何创建和操作元组：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'In step 1, we created a tuple. Though strictly speaking, the parentheses are
    not needed, still it''s an option for better readability. As you can see, we created
    a heterogeneous tuple with numeric and string values. Step 2 details how the elements
    of a tuple can be accessed through the index. Indices start from zero. A negative
    number can be used to access the tuple in reverse. The output of the print statement
    is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们创建了一个元组。严格来说，圆括号并非必需，但为了更好的可读性，使用圆括号是一个选项。如你所见，我们创建了一个包含数字和字符串值的异构元组。第
    2 步详细说明了如何通过索引访问元组中的元素。索引从零开始。可以使用负数来反向访问元组。打印语句的输出如下：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Python tuple indices start from 0\. Tuples are immutable.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Python 元组的索引从 0 开始。元组是不可变的。
- en: 'In step 3, we will look at the most important property of a tuple called immutability.
    It is not possible to change the value of an item in a tuple; step 3 will result
    in an error thrown by the interpreter:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 步中，我们将查看元组的最重要特性——不可变性。无法更改元组中某个元素的值；第 3 步会导致解释器抛出错误：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This may look restrictive; however, the immutable feature has immense value
    from a data science perspective.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能有些局限；然而，从数据科学的角度来看，不可变特性具有巨大的价值。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While building programs for machine learning, in particular during the feature
    generation from raw data, creating feature tuples ensures that values cannot be
    changed by downstream programs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建机器学习程序时，特别是在从原始数据生成特征时，创建特征元组可以确保值不会被下游程序更改。
- en: As these features reside in a tuple, no downstream program can accidently change
    the feature values.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些特征存在于元组中，因此没有下游程序可以意外地更改特征值。
- en: 'However, we want to point out that a tuple can have a mutable object as its
    member, for example, a list. If we have a tuple as shown in step 4, the third
    element of the tuple is a list. Now, let''s try to change an element in the list:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们要指出，元组可以包含可变对象作为其成员，例如列表。如果我们有一个像第 4 步所示的元组，元组的第三个元素是一个列表。现在，让我们尝试更改列表中的一个元素：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will print the tuple as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如下打印元组：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will get the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到如下输出：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the value of the first element in the list is changed to `100`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，列表中第一个元素的值已被更改为`100`。
- en: In step 5, we concatenated two tuples. Another interesting way to use tuples
    is when different modules are creating different features for a machine learning
    program.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 步中，我们连接了两个元组。另一种有趣的使用元组的方式是，当不同的模块为机器学习程序创建不同的特征时。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For example, let's say that you have one module that is creating a bag-of-words
    kind of feature and another module that is working on creating numerical features
    for a typical text classification program. These models can output the tuples
    and a final module can concatenate these tuples to get a full feature vector.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你有一个模块正在创建类似词袋的特征，另一个模块正在为典型的文本分类程序创建数值特征。这些模型可以输出元组，最终模块可以将这些元组连接起来，得到完整的特征向量。
- en: Due to its immutable property, unlike a list, a tuple cannot be extended after
    its creation. It does not support an `append` function. Another advantage of this
    immutable property is that a tuple can be used as a key in a dictionary.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其不可变特性，与列表不同，元组在创建后无法扩展。它不支持 `append` 函数。这个不可变特性的另一个好处是，元组可以作为字典中的键。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Typically, when creating keys, we may need to concatenate different string values
    using custom separators to create a unique key. Instead, a tuple with these string
    values can be created to be used as a key.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在创建键时，我们可能需要使用自定义分隔符将不同的字符串值连接起来，形成一个唯一的键。而是可以创建一个包含这些字符串值的元组，作为键来使用。
- en: This improves the program output readability and also avoids bugs from creeping
    in when the keys are combined manually.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这提高了程序输出的可读性，并且避免了在手动组合键时引入错误。
- en: 'In step 6, we will detail the slicing operations in a tuple. Typically, there
    are three numbers provided for the slicing and they are separated by a colon.
    The first number decides which index to start the slicing, the second one decides
    the ending index, and the last one is for step. The examples in step 6 will clarify
    this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 步中，我们将详细介绍元组中的切片操作。通常，切片操作有三个数字，并用冒号分隔。第一个数字决定切片的起始索引，第二个数字决定结束索引，最后一个数字是步长。第
    6 步的例子将会说明这一点：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It prints the output as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印出的结果如下：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this case, we specified only the start index number, `1`. (Remember that
    indices start with zero.) We got a slice of the tuple starting from index, `1`.
    Let''s see another example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只指定了起始索引 `1`。（记住，索引从零开始。）我们得到了一个从索引 `1` 开始的元组切片。让我们看另一个例子：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It prints the output as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印出的结果如下：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we specified the start index as `1` and end index as `3`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了起始索引为 `1`，结束索引为 `3`。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Slicing operations are right-ended.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 切片操作是右闭合的。
- en: 'Though we specified the end index as `3`, the output will be returned till
    index `2`, that is, one before. Hence, we have `2` and `3` as a part of our output
    slice. Finally, let''s provide all three parameters and the start and end indices
    followed by the step size:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们指定了结束索引为 `3`，输出会返回到索引 `2`，即结束前一个索引。所以，`2` 和 `3` 都是我们输出切片的一部分。最后，让我们提供三个参数，包括起始和结束索引，以及步长：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It displays the output as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示出的结果如下：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, our step size is `2`. In addition to the start and end indices, we also
    specified the step size. Hence, it jumps two indices every time and produces the
    output as shown previously.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的步长为 `2`。除了起始和结束索引外，我们还指定了步长。因此，每次跳过两个索引，产生之前所示的输出。
- en: 'Let''s look at the negative indexing:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下负索引：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we used the negative index. The output is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了负索引。输出结果如下：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Everything except the last element is returned in the slice:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后一个元素外，切片返回的是所有元素：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Food for thought, the output of the preceding statement is as follows—a curious
    reader should be able to figure out how we got the following output:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 值得思考的是，前述语句的输出结果如下——一个好奇的读者应该能搞清楚我们是如何得到以下输出的：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In step 7, we will show that we can use the `min()` and `max()` functions on
    a tuple to get the minimum and maximum value out of a tuple:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 7 步中，我们将展示如何使用 `min()` 和 `max()` 函数来获取元组中的最小值和最大值：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In step 8, we will show the conditional operators in and not in; this can be
    effectively used to find out if an element is part of a tuple or not:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 步中，我们将展示条件运算符 `in` 和 `not in`；这可以有效地用于判断一个元素是否属于元组：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'As we saw in the preceding section, we accessed the elements of a tuple by
    their indices. For better program readability, say that we want to have a name
    assigned to each of the elements of a tuple and access the elements by their names.
    This is where namedtuple comes to our rescue. The following URL gives a good documentation
    of namedtuple:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面一节中看到的，我们通过索引访问元组中的元素。为了提高程序的可读性，假设我们希望为元组中的每个元素分配一个名称，并通过名称访问这些元素。这就是
    `namedtuple` 发挥作用的地方。以下链接提供了 `namedtuple` 的详细文档：
- en: '[https://docs.python.org/2/library/collections.html#collections.namedtuple](https://docs.python.org/2/library/collections.html#collections.namedtuple)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/library/collections.html#collections.namedtuple](https://docs.python.org/2/library/collections.html#collections.namedtuple)'
- en: 'Let''s look at a simple example to illustrate the use of a namedtuple:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来说明如何使用 `namedtuple`：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can see that we accessed the elements of `vec_1` and `vec_2` using object
    notation, `vec_1.x`, `vec_1.y`, and so on. Instead of using their indices, we
    now have a better readable program. `Vec_1.x` is equivalent to `vec_1[0]`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们使用对象表示法访问了 `vec_1` 和 `vec_2` 的元素，`vec_1.x`、`vec_1.y` 等等。现在，我们不再使用索引，而是编写了更易读的程序。`Vec_1.x`
    相当于 `vec_1[0]`。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*Data Analysis – Explore and Wrangle* recipe in [Chapter 3](ch03.xhtml "Chapter 3. Data
    Analysis – Explore and Wrangle"), *Analyzing Data - Explore & Wrangle* which represents
    the text as a Bag-of-words.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据分析 – 探索与清洗*配方在[第3章](ch03.xhtml "Chapter 3. 数据分析 – 探索与清洗")，*分析数据 - 探索与清洗*中将文本表示为词袋模型（Bag-of-words）。'
- en: Using sets
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集合
- en: Sets are very similar to list data structures except that they do not allow
    duplicates. It's an unordered collection of homogeneous elements. Typically, sets
    are used to remove the duplicate elements from a list. However, a set supports
    operations such as intersection, union, difference, and symmetric difference.
    These operations are very handy in a lot of use cases.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 集合与列表数据结构非常相似，除了它不允许重复元素外。集合是一个无序的同类元素集合。通常，集合用于从列表中删除重复的元素。然而，集合支持诸如交集、并集、差集和对称差集等操作。这些操作在很多应用场景中非常实用。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: In this section, we will write a small program to understand the various utilities
    of set data structures. In our example, we will calculate a similarity score between
    two sentences using Jaccard's coefficient. We will see in detail about Jaccard's
    coefficient and similar other measures in later chapters. Here is a quick introduction
    to this measure. Jaccard's coefficient is a number between zero and one, where
    one indicates a high similarity. It's calculated based on how many elements are
    common between the two sets.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将编写一个小程序来了解集合数据结构的各种实用功能。在我们的示例中，我们将使用杰卡德系数（Jaccard's coefficient）计算两句话之间的相似度分数。我们将在后续章节中详细讲解杰卡德系数以及其他类似的度量方法。这里是对该度量的简要介绍。杰卡德系数是一个介于零和一之间的数字，其中一表示高度相似。它是基于两个集合之间有多少元素是相同的来计算的。
- en: How to do it…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Let''s see some Python scripts that are used for the set creation and manipulation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些用于集合创建和操作的Python脚本：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In steps 1 and 2, we took two sentences, split them into words, and created
    two sets using the `set()` function. The `set` function can be used to convert
    a list or tuple to a set. Look at the following code snippet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1和步骤2中，我们取了两句话，将它们分割成单词，并使用`set()`函数创建了两个集合。`set`函数可以用于将列表或元组转换为集合。请看下面的代码片段：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, `a` is a tuple and `b` is a list. With the `set()` function,
    the duplicates are eliminated and a set object is returned. The `st_1.split()`
    and `st_2.split()` method return a list and we will pass it to a set function
    to get the set objects.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`a`是一个元组，`b`是一个列表。通过使用`set()`函数，重复的元素被移除，返回一个集合对象。`st_1.split()`和`st_2.split()`方法返回一个列表，我们将它传递给`set()`函数，以获得集合对象。
- en: Let's now calculate the similarity score between two sentences using Jaccard's
    coefficient. We will see in detail about Jaccard's coefficient and similar other
    measures in the similarity measures section in a later chapter. We will leverage
    the `union()` and `intersection()` functions available with the sets to calculate
    the similarity score.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用杰卡德系数计算两句话之间的相似度分数。我们将在后续章节的相似度度量部分详细讨论杰卡德系数以及其他类似的度量方法。我们将利用集合的`union()`和`intersection()`函数来计算相似度分数。
- en: In step 4, we will perform two operations. First, using the `intersection()`
    function, we will try to find out what words are common between the sets. The
    common words between the two sentences are `'cats'` and `'dogs'`. Followed by
    this, we will find out the count of the common words, which is two. In the next
    step, we will find out the list of unique words between the two sets using the
    `union()` function. The unique words between these two sentences are `'cats'`,
    `'hate'`, `'dogs'`, and `'chase'`. This is sometimes referred to as vocabulary
    in natural language processing. Finally, we will calculate Jaccard's coefficient
    in step 6, which is the ratio of a count of the common words between the two sets
    to a count of the unique words between the two sets.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤4中，我们将执行两个操作。首先，通过使用`intersection()`函数，我们将尝试找出两个集合之间共有的单词。两句话之间的共同单词是`'cats'`和`'dogs'`。接着，我们将找出共同单词的数量，这个数量是2。在下一步中，我们将使用`union()`函数找出两个集合之间唯一单词的列表。这两句话之间唯一的单词是`'cats'`、`'hate'`、`'dogs'`和`'chase'`。这在自然语言处理领域有时被称为词汇表。最后，我们将在步骤6中计算杰卡德系数，它是两个集合之间共同单词的数量与两个集合之间唯一单词的数量之比。
- en: 'The output of this program looks as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出如下所示：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There's more…
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'We gave the preceding example to represent the usage of the set functions.
    However, you can use the built-in functions from libraries such as scikit-learn.
    Going forward, we will leverage as much of these functions from libraries as possible,
    instead of hand coding these utility functions:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给出前面的示例是为了展示集合函数的使用。然而，你也可以使用像 scikit-learn 这样的库中的内置函数。接下来，我们将尽可能多地利用这些库中的函数，而不是手动编写这些工具函数：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Writing a list
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个列表
- en: A list is a container object and sequence type. They are similar to tuples except
    that they are homogenous and mutable. A list allows append operations. They can
    also be used as either a stack or queue. Unlike tuples, lists are expandable;
    you can add elements to a list using the append function after its creation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一个容器对象和序列类型。它们与元组相似，但不同之处在于它们是同质的并且是可变的。列表允许执行添加操作。它们也可以用作堆栈或队列。与元组不同，列表是可扩展的；你可以在创建列表后使用
    `append` 函数向列表中添加元素。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: Similar to how we saw tuples, we will see lists as fragmented codes where we
    will concentrate on the creation and manipulation activity instead of having a
    full program as we did with dictionaries.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们看到元组的方式，我们将看到列表作为碎片化的代码，在这些代码中我们将集中于创建和操作活动，而不是像处理字典那样编写完整的程序。
- en: How to do it…
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Let''s look at some Python scripts demonstrating the list creation and manipulation
    activities:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些演示列表创建和操作活动的 Python 脚本：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In step 1, we saw different ways of creating a list. Note that we have only
    homogeneous elements. There can be duplicates unlike a set. Steps 2,3,4,5,6, and
    7 are similar to the tuple steps. We will not elaborate on these steps. They cover
    the indexing, slicing, concatenation, minmax, and in and not in operations similar
    to a tuple.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们看到了创建列表的不同方式。请注意，我们只有同质元素。列表中可以有重复元素，而不像集合那样没有重复。第 2、3、4、5、6 和 7 步与元组的操作相似。我们不再详细讨论这些步骤。它们包括索引、切片、拼接、最小值最大值以及
    `in` 和 `not in` 操作，这些都与元组相似。
- en: 'Step 8 presents the append and extend operations. This is where a list starts
    to differ from a tuple. (Of course, we know that these lists are homogeneous.)
    Let''s look at the output of the first part of the code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 步展示了 `append` 和 `extend` 操作。这是列表与元组开始有所不同的地方。（当然，我们知道这些列表是同质的。）让我们来看一下代码第一部分的输出：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can see that 10 is added to the `a` list.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 10 已经被添加到 `a` 列表中。
- en: 'The following output is of the second part where extend is shown:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第二部分的输出，其中展示了 `extend`：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We extended the original `a` list by another list, `b`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过另一个列表 `b` 扩展了原来的 `a` 列表。
- en: 'In step 9, we will show how a list can be used as a stack. The `pop()` function
    helps to retrieve the last element appended to the list. The output is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 9 步中，我们将展示如何将列表用作堆栈。`pop()` 函数帮助检索列表中最后一个添加的元素。输出如下：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The last element to be appended is the first element to be retrieved **Last
    In, First Out** (**LIFO**) style as in stacks.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个被添加的元素是第一个被检索的元素，遵循**后进先出**（**LIFO**）的堆栈方式。
- en: 'In step 10, we will implement a queue using a list. The `pop()` function with
    zero as a parameter indicates that the index of the element to be retrieved has
    been passed. The output is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 10 步中，我们将使用列表实现一个队列。将 0 作为参数传递给 `pop()` 函数表示要获取的元素的索引。输出如下：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The output adheres to the LIFO style of a queue. However, this is not a very
    efficient method. Popping the first element is not optimal because of the way
    a list is implemented. An efficient way to perform this operation is to use the
    deque data structure explained in the next section.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 输出遵循队列的 LIFO 样式。然而，这并不是一种高效的方法。弹出第一个元素并不最优，因为列表的实现方式。执行此操作的高效方法是使用下一个小节中解释的
    deque 数据结构。
- en: The final step details the sort and reverse operations in a list. A list has
    a built-in function, `sort()`, to sort the elements of a list. By default, it
    sorts in an ascending order. Sorting is explained in detail in a later section
    of this chapter. The `reverse()` function will reverse the elements of a list.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步详细介绍了列表中的排序和反转操作。列表有一个内置函数，`sort()`，用于对列表的元素进行排序。默认情况下，它会按升序排序。排序的详细内容将在本章后面的小节中解释。`reverse()`
    函数将反转列表中的元素。
- en: 'We will first create a list with elements from 1 to 19:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个包含从 1 到 19 的元素的列表：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will shuffle the elements using the `shuffle()` function from a module random.
    This shuffles the elements so that we can demonstrate the sort operations. The
    shuffled output is as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`random`模块中的`shuffle()`函数对元素进行洗牌。这样我们就能展示排序操作。洗牌后的输出如下：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, `a.sort()` does an in-place sort and when we print a, we will get the
    following output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`a.sort()`进行就地排序，当我们打印`a`时，将得到以下输出：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `a.reverse()` is also an in-place operation that produces the following
    output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`a.reverse()`也是一个就地操作，产生以下输出：'
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There's more…
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The deque stands for double-ended queue. Unlike stack and queues, which can
    be appended and popped in only one direction, the append and pop operations can
    be done at both ends with deque:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`deque`代表双端队列。与只能在一个方向进行附加和弹出的栈和队列不同，`deque`可以在两端进行`append`和`pop`操作：'
- en: '[https://docs.python.org/2/library/collections.html#collections.deque](https://docs.python.org/2/library/collections.html#collections.deque)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/library/collections.html#collections.deque](https://docs.python.org/2/library/collections.html#collections.deque)'
- en: Creating a list from another list - list comprehension
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从另一个列表创建列表——列表推导式
- en: 'Comprehension is a way to create a sequence from another sequence. For example,
    we can create a list from another list or tuple. Let''s look at a list comprehension.
    Typically, a list comprehension involves the following features:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 推导式是一种从另一个序列创建序列的方式。例如，我们可以从另一个列表或元组创建一个列表。让我们来看一个列表推导式。通常，列表推导式包括以下几个特点：
- en: A sequence, say a list whose elements we are interested in
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个序列，比如我们感兴趣的元素列表
- en: A variable representing the elements of the sequence
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示序列元素的变量
- en: An output expression that is responsible for producing the output sequence using
    the elements of the input sequence
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输出表达式，负责使用输入序列的元素生成输出序列
- en: An optional predicate expression
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的谓词表达式
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: Let's define a simple problem in order to understand all the different elements
    involved in comprehension. With an input list with positive and negative numbers,
    we need an output list that is the square of all the negative elements.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个简单的问题，以便理解推导式中涉及的所有不同元素。给定一个包含正负数的输入列表，我们需要一个输出列表，该列表包含所有负数元素的平方。
- en: How to do it…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In the following script, we will show a simple example of list comprehension:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下脚本中，我们将展示一个简单的列表推导式示例：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'This example is written in a way to explain the various components of comprehension.
    Let''s look at step 2:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是用来解释推导式的各个组成部分的。让我们来看第2步：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This code is explained as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的解释如下：
- en: Our input list is `a` and output list is `b`
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的输入列表是`a`，输出列表是`b`
- en: We will use a variable `x` to represent each element in the list
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用变量`x`表示列表中的每个元素
- en: The `pow(x,2)` is the output expression, which uses the elements in the input
    to produce the output list
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pow(x, 2)`是输出表达式，它使用输入中的元素生成输出列表'
- en: Finally, `if` `x < 0` is the predicate expression that controls which elements
    of the input list are used to produce the output list
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`if x < 0`是谓词表达式，控制哪些输入列表中的元素将用于生成输出列表
- en: There's more…
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The comprehension syntax is exactly the same as a dictionary. A simple example
    will illustrate the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 推导式的语法与字典完全相同。一个简单的示例将说明如下：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding example, we created a new dictionary, b from the input dictionary,
    a. The output is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们从输入字典`a`创建了一个新的字典`b`。输出如下：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can see that we retained the keys of the `a` dictionary, but now the new
    values are a square of the original values in a. A point to note is the use of
    curly bracelets instead of brackets during the comprehension.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们保留了`a`字典的键，但是现在新值是`a`中原始值的平方。需要注意的一点是在推导式中使用了花括号而不是方括号。
- en: 'We can do comprehension for tuples with a small trick. See the following example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个小技巧对元组进行推导。请参见以下示例：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Instead of the `pow()` function, we used a new process function. I will leave
    it to you as an exercise to decipher what the process function does. Note that
    we followed the same syntax for a comprehension list; however, we used braces
    instead of brackets. The output of this program is as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用`pow()`函数，而是用了一个新的过程函数。我会留给你作为练习来解读这个过程函数的作用。请注意，我们遵循了与列表推导式相同的语法；不过，我们使用了花括号而非方括号。该程序的输出如下：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Oops! We wanted a tuple but ended up with a generator (more on generators in
    the later sections). The right way to do it is as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们想要一个元组，但最终得到了一个生成器（更多关于生成器的内容将在后续章节中讨论）。正确的方法如下：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, the print b statement will produce the following output:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打印 `b` 语句将输出以下内容：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Python comprehension is based on the set builder notation:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Python 推导式基于集合构造符号：
- en: '[http://en.wikipedia.org/wiki/Set-builder_notation](http://en.wikipedia.org/wiki/Set-builder_notation)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Set-builder_notation](http://en.wikipedia.org/wiki/Set-builder_notation)'
- en: 'Itertools.dropwhile:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Itertools.dropwhile：
- en: '[https://docs.python.org/2/library/itertools.html#itertools.dropwhile](https://docs.python.org/2/library/itertools.html#itertools.dropwhile)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/library/itertools.html#itertools.dropwhile](https://docs.python.org/2/library/itertools.html#itertools.dropwhile)'
- en: With a predicate and sequence, dropwhile will return only those items in the
    sequence that satisfies the predicate.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用谓词和序列，dropwhile 将只返回序列中满足谓词条件的项。
- en: Using iterators
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器
- en: It's a no-brainer that a key input for a data science program is data. Data
    may vary in size—some of them may fit into memory and some may not. The record
    access mechanism can vary from one data format to another. Interestingly, different
    algorithms may demand chunks of varying length to process. For example, let's
    say that you are writing a stochastic gradient descent algorithm and you want
    to pass chunks of 5,000 records in each epoch, it will be very nice to have an
    abstraction that can handle the accessing of the data, understanding the data
    format, looping through the data, and providing the caller with the required data.
    This will result in a clean code. Most of the time, the interesting part lies
    in what we do with the data and not how we access the data. Python provides us
    with an elegant way in the form of iterators to handle all of these requirements.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据科学程序来说，数据是一个显而易见的关键输入。数据的大小可能不同——有些数据可能适合存入内存，而有些则不行。记录访问机制可能因数据格式而异。有趣的是，不同的算法可能要求以不同长度的块进行处理。例如，假设你正在编写一个随机梯度下降算法，并希望在每个
    epoch 中传递 5000 条记录，那么能够处理数据访问、理解数据格式、遍历数据并向调用者提供所需数据的抽象会非常有用。这样可以使代码更加简洁。大多数时候，重点在于我们如何使用数据，而不是如何访问数据。Python
    为我们提供了一种优雅的方式——迭代器，来处理所有这些需求。
- en: Getting ready
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: An iterator in Python implements an iterator pattern. It allows us to go over
    a sequence one by one without materializing the whole sequence!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的迭代器实现了迭代器模式。它允许我们逐一遍历序列，而无需将整个序列实例化！
- en: How to do it…
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Let''s create a simple iterator called simple counter and provide it with some
    code on how to effectively use the iterator:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的迭代器，称为 simple counter，并提供一些代码来有效使用该迭代器：
- en: '[PRE50]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works…
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In step 1, we defined a class by the name of `SimpleCounter`. The `__init__`
    constructor takes two parameters, `start` and `end,` defining the beginning and
    end of our sequence. Note the two methods, `__iter__` and `next`. Any object in
    Python that is meant to be an iterator object should support these two functions.
    The `__iter__` returns the complete class object as an iterator object. The `next`
    method returns the next value in the iterator.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 中，我们定义了一个名为 `SimpleCounter` 的类。`__init__` 构造函数接受两个参数，`start` 和 `end`，定义了序列的开始和结束。注意这两个方法，`__iter__`
    和 `next`。任何旨在作为迭代器对象的 Python 对象都应该支持这两个函数。`__iter__` 返回整个类对象作为迭代器对象。`next` 方法返回迭代器中的下一个值。
- en: As shown in step 2, we can access the successive elements in the iterator using
    the `next()` function. Python also provides us with a convenient function, `iter()`,
    which can be used in a loop to access elements sequentially as shown in step 3\.
    The `iter()` uses the `next()` function internally.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如步骤 2 所示，我们可以使用 `next()` 函数访问迭代器中的连续元素。Python 还为我们提供了一个方便的函数 `iter()`，它可以在循环中依次访问元素，如步骤
    3 所示。`iter()` 内部使用 `next()` 函数。
- en: 'A point to note is that an iterator object can be used only once. After running
    the preceding code, we will try to access the iterator as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，迭代器对象只能使用一次。运行上述代码后，我们将尝试如下访问迭代器：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It will throw the StopIteration exception. Calling `c.next()` after the sequence
    has exhausted will result in a StopIteration exception:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 它会抛出 StopIteration 异常。在序列耗尽后，调用 `c.next()` 会导致 StopIteration 异常：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `iter()` function handles this exception and exits the loop once the data
    has been exhausted.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`iter()` 函数处理此异常，并在数据耗尽后退出循环。'
- en: There's more…
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Let''s see another example of an iterator. Let''s say that we need to access
    a very large file in our program; however, in our program, we will work through
    it only one line at a time:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个迭代器的例子。假设我们需要在程序中访问一个非常大的文件；然而，在程序中，我们每次只处理一行：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In Python, a file object is an iterator; it supports the `iter()` and `next()`
    functions. Hence, instead of loading the whole file in memory, we can work with
    a single line at a time.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，文件对象是一个迭代器；它支持`iter()`和`next()`函数。因此，我们可以避免将整个文件加载到内存中，而是每次处理一行。
- en: An iterator gives you the power to write custom code in order to access your
    data sources in a manner that your application demands.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器让你能够编写自定义代码，以一种应用程序所需的方式访问数据源。
- en: 'The following link provides more information about how iterators can be used
    in various ways in Python:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接提供了有关在Python中以多种方式使用迭代器的更多信息：
- en: 'Infinite iterators, `count()`, `cycle()` and `repeat()` in itertools:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 无限迭代器，`count()`，`cycle()`和`repeat()`在itertools中的使用：
- en: '[https://docs.python.org/2/library/itertools.html#itertools.cycle](https://docs.python.org/2/library/itertools.html#itertools.cycle)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/library/itertools.html#itertools.cycle](https://docs.python.org/2/library/itertools.html#itertools.cycle)'
- en: Generating an iterator and a generator
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成迭代器和生成器
- en: We saw what an iterator is in the previous recipe; now in this one, let's see
    how to generate an iterator.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中看到迭代器是什么；现在在这一节中，让我们看看如何生成一个迭代器。
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: Generators provide a clean syntax to loop through a sequence of values eliminating
    the need to have the two functions, __iter__ and next(). We don't have to write
    a class. A point to note is that both generators and iterables produce an iterator.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器提供了一种简洁的语法来遍历一系列值，省去了需要同时使用__iter__和next()两个函数的麻烦。我们不需要编写类。需要注意的一点是，生成器和可迭代对象都能生成一个迭代器。
- en: How it do it…
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何做到的……
- en: 'Let''s have a look the following example; it should be easy to follow if you
    understood comprehension from the previous section. In this case, we have a generator
    comprehension. If you recall, we tried doing a tuple comprehension in this way
    and got a generator object:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例；如果你理解了上一节的推导式内容，应该很容易跟上。在这个例子中，我们使用了生成器推导式。如果你还记得，我们曾尝试用这种方式做一个元组推导式，结果得到了一个生成器对象：
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works…
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There's more…
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Let''s look at how to use the yield statement to create a generator:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用yield语句来创建生成器：
- en: '[PRE56]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the preceding example, the `my_gen()` function is a generator; we used the
    yield statement to return the output in a sequence.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`my_gen()`函数是一个生成器；我们使用了yield语句以序列的形式返回输出。
- en: 'In the previous section, we mentioned that both a generator and iterables produce
    an iterator. Let''s validate this by trying to call the generator using the `iter`
    function:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们提到过，生成器和可迭代对象都生成一个迭代器。让我们通过尝试使用`iter`函数来调用生成器，来验证这一点：
- en: '[PRE57]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Before we move on to iterables in our next recipe, a key point to note with
    a generator is that once we have gone through the sequence, we are done—no more
    data.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节关于可迭代对象的内容之前，需要注意的一点是，生成器一旦遍历完序列，就结束了——没有更多数据。
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With a generator object, we can go over the sequence only once.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成器对象，我们只能遍历序列一次。
- en: Using iterables
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可迭代对象
- en: Iterables are similar to generators except for a key difference, we can go on
    and on with an iterable, that is, once we have exhausted all the elements in a
    sequence, we can again start accessing it from the beginning unlike a generator.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象与生成器类似，除了一个关键区别：我们可以一直使用一个可迭代对象，也就是说，一旦我们遍历完序列中的所有元素，我们可以从头再开始访问它，而不像生成器那样只能遍历一次。
- en: They are object-based generators that do not hold any state. Any class with
    the `iter` method that yields data can be used as a stateless object generator.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是基于对象的生成器，不保存任何状态。任何具有`iter`方法并且能够生成数据的类，都可以作为一个无状态的对象生成器使用。
- en: Getting ready
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: Let's try to understand iterables with a simple example. This recipe should
    be easy to follow if you have understood the previous recipes on generators and
    iterators.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来理解可迭代对象。如果你已经理解了前面的生成器和迭代器的示例，那么这个步骤应该很容易跟上。
- en: How to do it…
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何做到的……
- en: 'Let''s create a simple iterable called SimpleIterable and show some scripts
    that manipulate it:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的可迭代对象，叫做SimpleIterable，并展示一些操作它的脚本：
- en: '[PRE58]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works..
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In step 1, we created a simple class that is our iterable. The init constructor
    takes two arguments, start and end, similar to our earlier example. We defined
    a function called iter, which will give us our required sequence. In this given
    range of numbers, the square of these numbers will be returned.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们创建了一个简单的类，它是我们的可迭代对象。初始化构造函数接受两个参数，start 和 end，类似于我们之前的例子。我们定义了一个名为
    iter 的函数，它将返回我们所需的序列。在这个给定的数字范围内，将返回这些数字的平方。
- en: Next, we have two loops. We iterated through our range of numbers, 1 to 10,
    in the first loop. When we will run the second for loop, you will notice that
    it once again iterates through the sequence and doesn't raise any exceptions.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有两个循环。在第一个循环中，我们遍历了从 1 到 10 的数字范围。当我们运行第二个循环时，你会注意到它再次遍历序列，并且没有抛出任何异常。
- en: See also
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*Using Iterators* recipe in [Chapter 1](ch01.xhtml "Chapter 1. Python for Data
    Science"), *Using Python for Data Science*'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第一章](ch01.xhtml "第一章：Python 数据科学")中的*使用迭代器*食谱，*使用 Python 进行数据科学*'
- en: '*Generating an Iterator - Generators* recipe in [Chapter 1](ch01.xhtml "Chapter 1. Python
    for Data Science"), *Using Python for Data Science*'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第一章](ch01.xhtml "第一章：Python 数据科学")中的*生成迭代器 - 生成器*食谱，*使用 Python 进行数据科学*'
- en: Passing a function as a variable
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数作为变量传递
- en: Python supports functional programming in addition to imperative paradigms.
    In the previous sections, we have seen some functional programming constructs
    without an explicit explanation. Let's go over them in this section. Functions
    are first-class citizens in Python. They have attributes and they can be referenced
    and assigned to a variable.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Python 除了支持命令式编程范式外，还支持函数式编程。在前面的部分中，我们已经看到了几个函数式编程构造，但没有明确解释。让我们在这一节中回顾它们。函数在
    Python 中是头等公民。它们具有属性，可以被引用并赋值给变量。
- en: Getting ready
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's look at the paradigm of passing a function as a variable in Python in
    this section.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这一节中将函数作为变量传递的范式。
- en: How to do it…
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s define a simple function and see how it can be used as a variable:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个简单的函数，看看它如何作为变量使用：
- en: '[PRE59]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works…
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We defined a simple function in step 1; with an input, the function returns
    the square of the input. We assigned this function to a `square_me` variable.
    Finally, we were able to invoke the function by calling `square_me` with a valid
    parameter. This demonstrates how a function can be treated as a variable in Python.
    This is a very import functional programming construct.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 1 步中定义了一个简单的函数；它接受一个输入，返回该输入的平方。我们将这个函数赋值给 `square_me` 变量。最后，我们可以通过调用 `square_me`
    并传入有效参数来调用该函数。这演示了如何在 Python 中将函数作为变量处理。这是一个非常重要的函数式编程构造。
- en: Embedding functions in another function
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数嵌套在另一个函数中
- en: This recipe will explain yet another functional programming construct; defining
    a function in another function.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将解释另一个函数式编程构造：在另一个函数中定义函数。
- en: Getting ready
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's take a simple example of writing a function, which will return the sum
    of the squares of the given input list.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个简单的例子，编写一个函数，返回给定输入列表的平方和。
- en: How to do it…
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s write a simple function to demonstrate a function in another function:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的函数，演示在另一个函数中使用函数：
- en: '[PRE60]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works…
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In step 1, you can see that we defined a `square_input()` function in the `sum_square()`
    function. The parent function uses it to perform the sum of squares operation.
    In the next step, we called the function and printed its output.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，你可以看到我们在 `sum_square()` 函数中定义了一个 `square_input()` 函数。父函数使用它来执行平方和操作。在下一步中，我们调用了该函数并打印了它的输出。
- en: 'The output produced was as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE61]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Passing a function as a parameter
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数作为参数传递
- en: '[PRE62]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s now demonstrate how to pass a function as a parameter:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们演示如何将一个函数作为参数传递：
- en: '[PRE63]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works…
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In step 1, we defined a `apply_func` function with two variables. The first
    variable is a function and second one is a sequence. As you can see, we used the
    map function (more on this function in the recipes to follow) to apply the given
    function to all the elements of the sequence.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们定义了一个 `apply_func` 函数，接受两个变量。第一个变量是一个函数，第二个变量是一个序列。如你所见，我们使用了 map
    函数（后续的食谱中将详细介绍该函数）将给定的函数应用于序列中的所有元素。
- en: 'Next, we invoked `apply_func` on a list a; first with the `square_input` function
    followed by a `log` function. The output is as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对列表 a 调用了 `apply_func`；首先使用 `square_input` 函数，然后是 `log` 函数。输出结果如下：
- en: '[PRE64]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As you can see, the elements of a are all squared. The map applies the square_input
    function to all the elements in the sequence:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，a中的所有元素都是平方的。map函数将`square_input`函数应用于序列中的所有元素：
- en: '[PRE65]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Similarly, log is applied on all the elements in the sequence.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，log函数也应用于序列中的所有元素。
- en: Returning a function
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回一个函数
- en: In this section, let's look at the functions that will return another function.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们看看那些会返回另一个函数的函数。
- en: Getting ready
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's take a high school example and try to explain the use of functions returning
    functions.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个高中例子来尝试解释函数返回函数的用法。
- en: 'Our problem is we are given a cylinder of radius r and we would like to know
    the volume of it for different heights:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的问题是，给定一个半径为r的圆柱体，我们想知道它在不同高度下的体积：
- en: '[http://www.mathopenref.com/cylindervolume.html](http://www.mathopenref.com/cylindervolume.html)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.mathopenref.com/cylindervolume.html](http://www.mathopenref.com/cylindervolume.html)'
- en: '[PRE66]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding formula gives the exact cubic units that will fill a cylinder.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 上述公式给出了填充圆柱体的确切立方单位。
- en: How to do it…
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Let''s write a simple function to demonstrate the concept of a function returning
    a function. In addition, we will write a small piece of code to show the usage:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的函数来演示函数返回函数的概念。此外，我们将编写一小段代码来展示用法：
- en: '[PRE67]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works…
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In step 1, we defined a function called `cylinder_vol()`; it takes a single
    parameter, `r`, radius.In this function, we defined another function, `get_vol()`.
    The `get_vol()` function has access to r and pi, takes the height as an argument.
    For the given radius, r, which was the parameter to `cylinder_vol()`, different
    heights were passed as a parameter to `get_vol()`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们定义了一个名为`cylinder_vol()`的函数；它接受一个参数`r`，即半径。在这个函数中，我们定义了另一个函数`get_vol()`。`get_vol()`函数可以访问r和pi，并以高度作为参数。对于给定的半径r，作为`cylinder_vol()`的参数，传递不同的高度作为参数给`get_vol()`。
- en: In step 2, we defined a radius; in this case, as ten and invoke the `cylinder_vol()`
    functionwith it. It returns the `get_vol()` function, which we stored in a variable
    named `find_volume`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们定义了一个半径；在这个例子中，定义为10，并用它调用`cylinder_vol()`函数。它返回`get_vol()`函数，我们将其存储在名为`find_volume`的变量中。
- en: In step 3,we invoked `find_volume` with different heights, 10 and 20\. Note
    that we didn't give the radius.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步，我们用不同的高度10和20调用了`find_volume`。请注意，我们没有提供半径。
- en: 'The output produced is as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE68]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: There's more…
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Functools is a module for higher order functions:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Functools是一个用于高阶函数的模块：
- en: '[https://docs.python.org/2/library/functools.html](https://docs.python.org/2/library/functools.html)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/library/functools.html](https://docs.python.org/2/library/functools.html)'
- en: Altering the function behavior with decorators
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装饰器改变函数的行为
- en: Decorators wrap a function and alter their behavior. They are best understood
    with some working examples. Let's see some decorators in action in this recipe.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器包装一个函数并改变其行为。通过一些实际示例更容易理解它们。让我们在这个示例中看看一些装饰器是如何工作的。
- en: Getting ready
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Do you recall the section where we explained a function as an argument to another
    function, function as a variable, and function returning a function? Most important
    of all, do you remember the cylinder example? If you followed it, decorators should
    be a piece of cake. In this exercise, we will do a pipeline of cleaning activity
    on a given string. With a string with mixed casing and punctuation, we will use
    decorators to write a cleaning routine, which can be extended very easily.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们解释函数作为参数传递给另一个函数，函数作为变量，以及函数返回函数的部分吗？最重要的是，你还记得圆柱体的例子吗？如果你跟上了，装饰器应该不难。在这个练习中，我们将对给定字符串进行一系列清理操作。对于一个含有混合大小写和标点符号的字符串，我们将使用装饰器编写一个清理程序，这个程序可以非常容易地扩展。
- en: How to do it…
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Let''s write a simple decorator for the text manipulation:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为文本处理编写一个简单的装饰器：
- en: '[PRE69]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How it works…
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Let''s start from the last two lines:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最后两行开始：
- en: '[PRE70]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We declared a string variable. We want to clean the string. In our case, we
    want the following features:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个字符串变量，想要清理这个字符串。在我们的例子中，我们希望具备以下功能：
- en: We want the string to be in lowercase
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望字符串转换为小写
- en: We want to strip the punctuation
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望去除标点符号
- en: We want to return a list of words
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望返回一个单词列表
- en: 'You can see that we called the `tokenize_whitespace` function with the string,
    s, as a parameter. Let''s look at the `tokenize_whitespace` function:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们调用了`tokenize_whitespace`函数，并将字符串s作为参数传递。让我们来看一下`tokenize_whitespace`函数：
- en: '[PRE71]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We see that this is very simple function and with a string input, the function
    splits it by a space and returns a list of words. We will alter the behavior of
    this function using decorators. You can see that the decorator that we will use
    for this function is `@pipeline_wrapper`. This is an easier way of calling the
    following:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到这是一个非常简单的函数，输入一个字符串，函数会通过空格将其拆分，并返回一个单词列表。我们将使用装饰器改变这个函数的行为。你可以看到，我们将为此函数使用的装饰器是
    `@pipeline_wrapper`。这是一种更简便的调用方式：
- en: '`tokenize_whitespace` = `pipeline_wrapper (clean_tokens)`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokenize_whitespace` = `pipeline_wrapper (clean_tokens)`'
- en: 'Now, let''s look at the decorator function:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下装饰器函数：
- en: '[PRE72]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can see that `pipeline_wrapper` returns the `wrapper` function. In the
    `wrapper` function, you can see that the final return statement returns `func`;
    this is the original function passed by us to the wrapper.The `wrapper` modifies
    the behavior of our original `tokenize_whitespace` function. The input to `tokenize_whitespace`
    is modified first by the `to_lower()` function, which changes the input string
    to lowercase, followed by the `remove_punc()` function, which removes the punctuation.
    The final output is as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`pipeline_wrapper` 返回了 `wrapper` 函数。在 `wrapper` 函数中，你可以看到最后的返回语句返回了 `func`；这是我们传递给
    `wrapper` 的原始函数。`wrapper` 修改了我们原始的 `tokenize_whitespace` 函数的行为。`tokenize_whitespace`
    的输入首先被 `to_lower()` 函数修改，将输入字符串转换为小写，然后是 `remove_punc()` 函数，去除标点符号。最终输出如下：
- en: '[PRE73]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Exactly what we wanted—the punctuation stripped, strings converted to lowercase,
    and finally, a list of words.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 完全是我们想要的——去除标点符号，将字符串转换为小写，最后得到一个单词列表。
- en: Creating anonymous functions with lambda
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 lambda 创建匿名函数
- en: Anonymous functions are created using the lambda statement in Python. Functions
    that are not bound to a name are called anonymous functions.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数是在 Python 中通过 `lambda` 语句创建的。未绑定到名称的函数被称为匿名函数。
- en: Getting ready
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了吗
- en: If you followed the section on passing functions as a parameter, the example
    in this section is very similar to it. We passed a predefined function in that
    section; here we will pass a lambda function.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟随了关于将函数作为参数传递的部分，那么这一节的示例和之前的非常相似。我们在那一节传递了一个预定义函数；在这里，我们将传递一个 lambda 函数。
- en: How to do it…
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'We will see a simple example with a toy dataset to explain anonymous functions
    in Python:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个简单的示例，使用玩具数据集来解释 Python 中的匿名函数：
- en: '[PRE74]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works…
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In step 1, we have a function called `do_list` that accepts another function
    as an argument. With a list and function, `do_list` applies the input function
    over the elements of the given list, sums up the transformed values, and returns
    the results.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们有一个名为`do_list`的函数，它接受另一个函数作为参数。`do_list`使用一个列表和一个函数，将输入函数应用于给定列表的元素，累加转换后的值并返回结果。
- en: 'Next, we will invoke the do-list function, the first parameter is our input
    list a, and the second parameter is our lambda function. Let''s decode our lambda
    function:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调用 `do_list` 函数，第一个参数是我们的输入列表 `a`，第二个参数是我们的 lambda 函数。让我们解码我们的 lambda
    函数：
- en: '[PRE75]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: An anonymous function is declared using the keyword, lambda; it's followed by
    defining a parameter for the function. In this case, x is the name of the parameter
    passed to this anonymous function. The expression succeeding the colon operator
    is the return value. The input parameter is evaluated using the expression and
    returned as the output. In this input, the square of the input is returned as
    the output. In the next print statement, we have a lambda function, which returns
    the cube of the given input.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数是通过关键字 `lambda` 声明的；紧跟其后的是为函数定义的参数。在这个例子中，`x` 是传递给这个匿名函数的参数的名称。冒号操作符后面的表达式是返回值。输入参数通过该表达式进行计算，并作为输出返回。在这个输入中，返回的是输入的平方。在接下来的
    `print` 语句中，我们有一个 lambda 函数，它返回给定输入的立方值。
- en: Using the map function
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `map` 函数
- en: 'Map is a built-in Python function. It takes a function and an iterable for
    an argument:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 是一个内置的 Python 函数。它接受一个函数和一个可迭代对象作为参数：'
- en: '[PRE76]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The function is applied on all the elements of the iterable and results are
    returned as a list. As a function is passed to map, lambda is most commonly used
    along with map.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数会作用于可迭代对象的所有元素，并将结果作为列表返回。由于将一个函数传递给 `map`，所以 `lambda` 通常与 `map` 一起使用。
- en: Getting ready
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了吗
- en: Let's look at a very simple example using the map function.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个非常简单的使用 `map` 函数的示例。
- en: How to do it…
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Let''s see an example on how to use a map function:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `map` 函数的示例：
- en: '[PRE77]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: How it works…
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'This is very similar to the code in the previous recipe. A map functions takes
    two parameters. The first one is a function and second one is a sequence. In our
    example code, we used an anonymous function:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前一个例子中的代码非常相似。`map` 函数接受两个参数，第一个是函数，第二个是序列。在我们的示例代码中，我们使用了一个匿名函数：
- en: '[PRE78]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This function squares the given input. We also passed a list to map.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数对给定输入进行平方操作。我们还将一个列表传递给了 `map`。
- en: Map applies a function that squares all the elements in the given list and returns
    the result as a list.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 函数应用于列表中的所有元素，计算它们的平方，并将结果作为列表返回。'
- en: 'The output is as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE79]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: There's more…
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'Similarly, any other function can be applied to a list:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，任何其他函数也可以应用于列表：
- en: '[PRE80]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Using map, we can replace the code snippet in the previous recipe with a single
    line:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map`，我们可以用一行代码替换前面例子中的代码：
- en: '[PRE81]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Map expects an N-argument function if we have N-sequences. Let''s see an example
    to understand this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有 N 个序列，`map` 函数需要一个 N 参数的函数。让我们看一个例子来理解这一点：
- en: '[PRE82]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We passed two sequences a and b to our map function. Notice that the function
    passed is the power function. It takes two arguments. Let''s see the result of
    the preceding code snippet:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个序列 `a` 和 `b` 传递给 `map` 函数。注意，传递的函数是幂函数，它接受两个参数。让我们看一下前面代码片段的结果：
- en: '[PRE83]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As you can see, the elements of list `a` is raised to the power of value in
    the same position in list b. A point to note is that both the lists should be
    of the same size; if not, Python will fill the smaller list with None. Though
    our examples are operating on a list, any iterable can be passed to a map function.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，列表 `a` 中的元素被提升为列表 `b` 中相同位置的值的幂。需要注意的是，两个列表应该具有相同的大小；如果不相同，Python 会用 `None`
    填充较小的列表。虽然我们的示例操作的是列表，但任何可迭代对象都可以传递给 `map` 函数。
- en: Working with filters
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过滤器
- en: 'True to its name, filter filters elements from a sequence based on the given
    function. With a sequence of negative and positive numbers, we can use a filter
    function to, say, filter out all the negative numbers. Filter is a built-in Python
    function. It takes a function and an iterable for an argument:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借其名字，`filter` 函数根据给定的函数从序列中过滤元素。对于包含负数和正数的序列，我们可以使用 `filter` 函数，例如，筛选出所有负数。`filter`
    是一个内置的 Python 函数，它接受一个函数和一个可迭代对象作为参数：
- en: '[PRE84]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The function that is passed as an argument is returned as a Boolean value based
    on a test.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参数传递的函数根据测试返回布尔值。
- en: The function is applied on all the elements of the iterable and all the items
    that are returned as true when the function is applied over them are returned
    as a list. An anonymous function, lambda, is most commonly used along with filter.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数应用于可迭代对象的所有元素，所有经过函数处理后返回 `True` 的项都会以列表的形式返回。匿名函数 `lambda` 是与 `filter` 一起使用的最常见方式。
- en: Getting ready
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's look at a simple code to see the filter function in action.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的代码，看看 `filter` 函数是如何工作的。
- en: How to do it…
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Let''s see an example on how to use a filter function:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个关于如何使用 `filter` 函数的例子：
- en: '[PRE85]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: How it works…
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何运作…
- en: 'The lambda function that we use here is very simple; it returns true if the
    given value is greater than ten, false otherwise. Our print statement gives the
    following result:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的 `lambda` 函数非常简单；如果给定的值大于十，它返回 `True`，否则返回 `False`。我们的打印语句给出如下结果：
- en: '[PRE86]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As you can see, only elements greater than ten are returned.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，只有大于十的元素被返回。
- en: Using zip and izip
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `zip` 和 `izip`
- en: Zip takes two equal length collections and merges them together in pairs. Zip
    is a built-in Python function.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip` 函数接受两个等长的集合，并将它们成对地合并在一起。`zip` 是一个内置的 Python 函数。'
- en: Getting ready
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's demonstrate zip using a very simple example.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个非常简单的示例演示 `zip`。
- en: How to do it…
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Let''s pass two sequences to a zip function and print the output:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将两个序列传递给 `zip` 函数并打印输出：
- en: '[PRE87]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How it works…
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何运作…
- en: The two parameters to our zip function are two lists, both with values ranging
    from `1` to `5`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给 `zip` 函数的两个参数是两个列表，它们的值都在 `1` 到 `5` 之间。
- en: 'A range function takes three parameters. The starting value of the list, ending
    value of the list, and a step value. The default step value is one. In our case,
    we passed 1 and 5 as the starting and ending values of the list. Remember that
    Python is right-closed, so the range (`1`, `5`) will return a list as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 函数接受三个参数：列表的起始值、结束值和步长值。默认的步长值为 1。在我们的例子中，我们传递了 1 和 5 作为列表的起始和结束值。记住，Python
    的范围是右闭的，所以 `range(1, 5)` 会返回如下列表：'
- en: '[PRE88]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We pass the two sequences to the zip function and the result is as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个序列传递给 `zip` 函数，结果如下：
- en: '[PRE89]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Keep in mind that both the collections should be of the same size; if not, then
    the output is truncated to the size of the shortest collection.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，两个集合的大小应该相同；如果不同，则输出会被截断为最小集合的大小。
- en: There's more…
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Now, look at the following code:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看以下代码：
- en: '[PRE90]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Can you guess what the output is?
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到输出是什么吗？
- en: 'Let''s see what the * operator does. A `*` operator unpacks a collection in
    their positional arguments:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `*` 运算符的作用。`*` 运算符将集合解包到位置参数中：
- en: '[PRE91]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The `**` operator unpacks a dictionary as a set of named arguments. In this
    case, we will get an output,6, when we apply the `**` operator to a dictionary.
    Look at the following function, which takes six arguments:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`**` 运算符将字典解包为一组命名参数。在这种情况下，当我们将 `**` 运算符应用于字典时，输出将是 6。看看以下接受六个参数的函数：'
- en: '[PRE93]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The output of the print statement is zero.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: print 语句的输出为零。
- en: 'Armed with these two operators, we can write a function without any restrictions
    on the number of variables that it can ingest:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个运算符，我们可以编写一个没有变量数量限制的函数：
- en: '[PRE94]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Back to the zip utility. One drawback with zip is that it can compute the list
    all at once. This may be an issue when we have two very large lists. The `izip`
    comes to the rescue in these cases. They compute the elements only when requested.
    The `izip` is a part of `itertools`. Please refer to the itertools recipe for
    more details.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 zip 工具。zip 的一个缺点是它会一次性计算出整个列表。当我们有两个非常大的列表时，这可能会成为问题。这时，`izip` 会派上用场。它们只有在需要时才计算元素。`izip`
    是 `itertools` 的一部分。有关更多详细信息，请参考 itertools 的相关文档。
- en: See also
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: '*Working with Itertools* recipe in [Chapter 1](ch01.xhtml "Chapter 1. Python
    for Data Science"), *Using Python for Data Science*'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.xhtml "第 1 章. Python 数据科学")中的 *与 Itertools 一起工作* 配方，*使用 Python
    进行数据科学*
- en: Processing arrays from the tabular data
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从表格数据处理中处理数组
- en: The meat of any data science application is to find an appropriate data handling
    routine for a given problem. In the case of machine learning, it's either the
    supervised or unsupervised method to predict or classify the data. Even before
    this step, a good amount of time is spent in the data transformation and making
    the data suitable for these methods.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数据科学应用的核心是为特定问题找到合适的数据处理方法。在机器学习的情况下，方法要么是监督学习，要么是无监督学习，用于预测或分类数据。在这一步骤之前，会花费大量时间进行数据转换，使数据适合这些方法。
- en: Usually, data is made available to a data science program in many ways. A data
    science programmer is faced with the challenge of accessing the data and making
    it available to a later part of his code using the Python data structure. Mastering
    ways to access data through Python will be very handy when writing a data science
    program as it will allow you to jump to the meat of the problem very quickly.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数据以多种方式提供给数据科学程序。数据科学程序员面临的挑战是如何访问数据，并将其通过 Python 数据结构传递给后续代码部分。掌握通过 Python
    访问数据的方法，在编写数据科学程序时非常有用，因为它能让你快速进入问题的核心。
- en: Typically, data is available as a text file, separated by either a comma or
    tab. A Python built-in file object utility can be used in this case. As we saw
    earlier, a file object implements the `__iter__()` and `next()` methods. This
    allows us to work on very large files, which do not fit into memory, by reading
    only a small chunk of the files at a time.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数据以文本文件的形式提供，数据项之间用逗号或制表符分隔。此时可以使用 Python 内建的文件对象工具。如我们之前所见，文件对象实现了 `__iter__()`
    和 `next()` 方法。这使得我们能够处理非常大的文件，这些文件无法完全加载到内存中，而是每次读取文件的一小部分。
- en: Python machine learning libraries such as scikit-learn works on the NumPy libraries.
    In this section, we will see ways of efficiently reading external data and converting
    it to numPy arrays for the downstream data processing.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: Python 机器学习库如 scikit-learn 依赖于 NumPy 库。在本节中，我们将介绍高效读取外部数据并将其转换为 NumPy 数组以便进行后续数据处理的方法。
- en: Getting ready
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: NumPy provides us with a function called `genfromtext` to create NumPy arrays
    from tabular data. Once the data is available as NumPy arrays, it's much easier
    for the downstream systems to process this data. Let's look at how we can leverage
    `genfromtext`. The following code was written using the NumPy version 1.8.0.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了一个名为 `genfromtext` 的函数，用于从表格数据创建 NumPy 数组。一旦数据以 NumPy 数组的形式提供，后续的系统处理这些数据就变得更加容易。让我们看看如何利用
    `genfromtext`。以下代码是使用 NumPy 版本 1.8.0 编写的。
- en: How to do it…
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: Let's import the necessary libraries to start with. We will proceed to define
    a sample input. Finally, we will demonstrate how to process tabular data.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入必要的库。接下来，我们将定义一个示例输入。最后，我们将展示如何处理表格数据。
- en: '[PRE96]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: How it works…
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In step 1, we simulated a tabulated data using the `StringIO` utility. We have
    three rows and three columns. The rows are new line-delimited and columns are
    comma-delimited.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们使用 `StringIO` 工具模拟了一个表格数据。我们有三行三列。行是以换行符分隔的，列是以逗号分隔的。
- en: In step 2, we used `genfromtxt` from NumPy to ingest the data as a NumPy array.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 步中，我们使用了 NumPy 中的 `genfromtxt` 将数据加载为 NumPy 数组。
- en: 'The first argument to genfromtxt is the source of the file and filename; in
    our case, it''s the StringIO object. The input is comma-delimited; the delimiter
    argument allows us to specify the same. After running the preceding code, the
    data value is as follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`genfromtxt` 的第一个参数是文件的来源和文件名；在我们的案例中，它是 `StringIO` 对象。输入是以逗号为分隔符的；`delimiter`
    参数允许我们指定分隔符。在运行前面的代码后，数据值如下所示：'
- en: '[PRE97]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: As you can see, we successfully loaded the data from the string in a NumPy array.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们成功地将数据从字符串加载到 NumPy 数组中。
- en: There's more…
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Various parameters and default values of the same are shown here for the `genfromtxt`
    function:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `genfromtxt` 函数的各种参数和默认值：
- en: '[PRE98]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The only mandatory argument is the name of the source of the data. In our case,
    we used a StringIO object. It can be a string corresponding to the name of a file
    or an object similar to a file with a read method. It can also be a URL of a remote
    file.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的必需参数是数据来源的名称。在我们的案例中，我们使用了一个 `StringIO` 对象。它可以是对应文件名的字符串，或者是一个具有读取方法的类似文件的对象。它也可以是远程文件的
    URL。
- en: The first step is to split the given line into columns. Once the file is open
    to be read, genfromtxt splits the non-empty lines into a sequence of strings.
    Empty lines are ignored and so are the commented lines. The comments option helps
    gentext decide which are the comment lines. The strings are split into columns
    based on a delimiter specified by the delimiter option. In our example case, we
    used a `,` delimiter. A `/t` is also a very popular delimiter. By default, the
    delimiter is `None` in gentext, which means that it assumes that the line is split
    into columns through whitespaces.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将给定的行拆分成列。一旦文件打开以供读取，`genfromtxt` 会将非空行拆分成一系列字符串。空行会被忽略，注释行也会被忽略。`comments`
    选项帮助 `gentext` 判断哪些是注释行。字符串根据由 `delimiter` 选项指定的分隔符被拆分成列。在我们的示例中，我们使用了 `,` 作为分隔符。`/t`
    也是一个常用的分隔符。在默认情况下，`gentext` 中的分隔符是 `None`，这意味着它假设行是通过空格来分隔成列的。
- en: Typically, when lines are changed to a sequence of strings and subsequently
    the columns are extracted, the individual columns are not stripped of the leading
    or trailing whitespaces. In a later part of the code, this needs to be handled,
    especially if some of the variables are used as keys in a dictionary. For example,
    if the leading or trailing whitespaces are not handled consistently, this may
    lead to a bug/error in the code. Setting `autostrip=True` helps avoid this problem.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当行被转换为字符串序列并随后提取列时，单独的列不会去除前导或尾随的空格。在代码的后面部分，必须处理这个问题，特别是当某些变量被用作字典的键时。例如，如果前导或尾随空格没有一致地处理，可能会导致代码中的错误。设置
    `autostrip=True` 可以帮助避免这个问题。
- en: Many times, we want to skip, say, top n rows or bottom n rows while reading
    a file. This may be due to the presence of headers or footers. The `skip_header
    = n` will skip the first n lines while reading and similarly, `skip_footer = n`
    will skip the last n lines.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，我们希望在读取文件时跳过前 n 行或后 n 行。这可能是由于文件中存在头部或尾部信息。`skip_header = n` 会在读取时跳过前 n
    行，同样，`skip_footer = n` 会跳过最后 n 行。
- en: 'Similar to unwanted rows, we may encounter many cases where we may not need
    to use some columns. The `usecols` argument is used to specify the list of columns
    that we are interested in:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于不需要的行，我们可能会遇到很多情况，在这些情况下我们不需要使用某些列。`usecols` 参数用于指定我们感兴趣的列列表：
- en: '[PRE99]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'As you can see in the preceding example, we selected only two columns, column
    0 and 1\. The data object looks as follows:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们仅选择了两列，第 0 列和第 1 列。数据对象如下所示：
- en: '[PRE100]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Custom column names can be provided using the `names` argument. A string argument
    with comma-separated column names looks as follows:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `names` 参数提供自定义的列名。一个由逗号分隔的列名字符串如下所示：
- en: '[PRE101]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'By having `names` to true, the first row in the input data is used as a column
    header:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `names` 设置为 `True`，输入数据中的第一行将作为列头：
- en: '[PRE102]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Another simple method from NumPy to create NumPy arrays from the text input
    is `loadtxt`:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 还有另一种简单的方法可以从文本输入创建 NumPy 数组，即 `loadtxt`：
- en: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html)'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html)'
- en: This is less sophisticated than genfromtxt; if you need a simple reader without
    any sophisticated data handling mechanisms such as handling missing values, you
    can opt for loadtxt.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这比 `genfromtxt` 要简单一些；如果你需要一个简单的读取器，而不需要任何复杂的数据处理机制（如处理缺失值），你可以选择 `loadtxt`。
- en: 'However, if we are not interested in loading the data as a NumPy array but
    want to load it as a list, Python provides us with a default csv library:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们不想将数据加载为 NumPy 数组，而是希望加载为列表，Python 为我们提供了一个默认的 csv 库：
- en: '[https://docs.python.org/2/library/csv.html](https://docs.python.org/2/library/csv.html)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/library/csv.html](https://docs.python.org/2/library/csv.html)'
- en: An interesting method in the preceding csv library is `csv.Sniffer.sniff()`.
    If we have a very large csv file and we want to understand its structure, we can
    use `sniff()`. This will return a dialect subclass, which has most of the properties
    of the csv file.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 csv 库中的一个有趣方法是 `csv.Sniffer.sniff()`。如果我们有一个非常大的 csv 文件，并且想要了解其结构，我们可以使用
    `sniff()`。这将返回一个方言子类，包含 csv 文件的大部分属性。
- en: Preprocessing the columns
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理列
- en: Often the data that we get is not in the format we can consume. A lot of data
    processing called data preprocessing steps in machine learning terminology has
    to be applied. One way to work through this hurdle is to ingest all the input
    as strings and carry on with the required data transformation at the later stages.
    Another way is to perform these changes at the source. The `genfromtext` provides
    us with some functionalities in order to perform this data transformation while
    reading from the source.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得的数据通常不是我们可以直接使用的格式。在机器学习术语中，需要应用很多数据处理步骤，这些步骤通常被称为数据预处理。一种处理方法是将所有输入作为字符串导入，并在后续阶段进行必要的数据转换。另一种方法是直接在源头进行这些转换。`genfromtext`
    提供了一些功能，可以在从源读取数据时执行这些数据转换。
- en: Getting ready
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Consider the following lines of text:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下文本行：
- en: '[PRE103]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This is a typical example of how we get data in real life. The first two columns
    have a string kg and inr attached to the rear and front of the actual values.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在现实生活中获取数据的典型例子。前两列包含字符串 kg 和 inr，分别附加在实际数值的前后。
- en: 'Let''s try to ingest this data in a NumPy array as follows:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将这些数据按如下方式导入到一个 NumPy 数组中：
- en: '[PRE104]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This results in the following:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '[PRE105]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: As you can see, the first two columns are not read.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前两列没有被读取。
- en: How to do it…
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's import the necessary libraries to start with. We will proceed to define
    a sample input. Finally, we will demonstrate data preprocessing.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导入必要的库并开始。我们将继续定义一个示例输入，最后展示数据预处理过程。
- en: '[PRE106]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: How it works…
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In step 1, we defined two lambda functions, one for column 1 where we need to
    strip the string 'kg' from the right-hand side and another to strip the string
    'inr' from the left-hand side of column 2.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们定义了两个 lambda 函数，一个用于第 1 列，需要去掉右侧的字符串 'kg'，另一个用于第 2 列，需要去掉左侧的字符串 'inr'。
- en: In step 2, we will go ahead and define a dictionary where the key is the column
    name to which the function has to be applied and the value is the function. This
    dictionary is passed as a parameter with the `converters` name in `genfromtext`.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 步中，我们将定义一个字典，其中键是需要应用函数的列名，值是该函数。这个字典作为参数传递给 `genfromtext`，参数名为 `converters`。
- en: 'Now the output is as follows:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出结果如下：
- en: '[PRE107]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Note that Nan has vanished, giving way to an actual value from the input.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Nan 已经消失，取而代之的是输入中的实际值。
- en: There's more…
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Converters can also be used to handle the missing values in an input record
    through a lambda function:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器还可以通过 lambda 函数处理输入记录中的缺失值：
- en: '[PRE108]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The lambda function returns -999 for the missing values. In our input, the
    second column of the second row is empty and this should be replaced by -999\.
    The final output looks as follows:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 函数将为缺失值返回 -999。在我们的输入中，第二行的第二列为空，应将其替换为 -999。最终输出如下：
- en: '[PRE109]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Refer to the SciPy documentations given here for more details:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考此处提供的 SciPy 文档以获取更多详细信息：
- en: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html)'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html)'
- en: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html)'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html)'
- en: Sorting lists
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序列表
- en: We will start with sorting a list and then move on to sorting other iterables.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从排序一个列表开始，然后继续排序其他可迭代对象。
- en: Getting ready
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: There are two ways to proceed with the sorting. The first way is to use the
    built-in sort function in the list and the other way is to use the sorted function.
    Let's work it out through an example.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法进行排序。第一种是使用列表中的内建`sort`函数，另一种是使用`sorted`函数。让我们通过一个示例来操作一下。
- en: How to do it…
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s see how to leverage the sort and sorted functions:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何利用`sort`和`sorted`函数：
- en: '[PRE110]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: How it works…
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We declared two lists, a and b, with the same elements. As a convenience way
    to verify the output, we will print list `a`:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个列表，`a`和`b`，它们具有相同的元素。为了方便验证输出，我们将打印列表`a`：
- en: '[PRE111]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We used the sort function available with the list data type, `a.sort()`, to
    perform an in-place sort. The following print statement shows that the list has
    now been sorted:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了列表数据类型提供的`sort`函数，`a.sort()`，来进行就地排序。以下的打印语句表明列表已经排序完成：
- en: '[PRE112]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, we will use the sorted function. This function performs the sorting on
    the list and returns a new sorted list. You can see that we invoked it as `sorted(b)`
    and stored the output in `b_s`. The print statement against `b_s` yields a sorted
    output:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`sorted`函数。该函数对列表进行排序并返回一个新的已排序列表。你可以看到，我们通过`sorted(b)`调用了它，并将输出存储在`b_s`中。对`b_s`进行打印时，输出是排序后的结果：
- en: '[PRE113]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: There's more…
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'The `sort` function is only available for a list data type. By default, sorting
    is done in an ascending order; this can be controlled by a reverse parameter to
    the sort function. By default, reverse is set to `False`:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`函数仅适用于列表数据类型。默认情况下，排序是按升序进行的；可以通过`reverse`参数控制排序顺序。默认情况下，`reverse`设置为`False`：'
- en: '[PRE114]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Sorting with a key
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按键排序
- en: Till now, we saw all the examples where a list or sequence was sorted by elements.
    Let's now proceed to see if we can sort it using keys. In the previous example,
    elements were the keys. In the real world, there are more complicated records
    where a record contains multiple columns and we would like to sort with one or
    more columns). We will work out our examples through a list of tuples and the
    same applies to the other sequence objects.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到所有示例都是通过元素来排序列表或序列。现在，我们继续看看是否可以使用键来排序。在前面的示例中，元素就是键。在现实世界中，存在更复杂的记录，其中记录包含多个列，我们可能希望按一列或多列进行排序。我们将通过一系列元组来演示这一点，其他序列对象也是如此。
- en: Getting ready
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In our example, a single tuple represents a person's record, which includes
    his name, ID, and age. Let's write a sorting in order to sort by the various fields.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，一个元组表示一个人的记录，包括他的名字、ID和年龄。我们来编写一个排序程序，按不同字段排序。
- en: How to do it…
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s define a record-like structure using a list and tuples. We will use
    this data to demonstrate the data sorting with a key:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用列表和元组来定义一个类似记录的结构。我们将使用这些数据来演示如何通过键进行数据排序：
- en: '[PRE115]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: How it works…
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In our example, each record has three fields: name, identification, and age.
    We used the lambda function to pass a key by which we need to sort the given records.
    In step 2, we passed the name as the key to sort. Similarly, in steps 2 and 3,
    we passed the ID and age as the keys. We can see the outputs in various steps;
    the outputs are sorted by the particular key that we want them to.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，每个记录有三个字段：姓名、身份证和年龄。我们使用了`lambda`函数来传递一个排序键，用来排序给定的记录。在步骤2中，我们将姓名作为键进行排序。同样，在步骤2和3中，我们将ID和年龄作为键进行排序。我们可以看到在各个步骤中，输出按我们希望的特定键进行排序。
- en: There's more…
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'Due to the importance of sorting by a key, Python provides a convenient function
    to access keys instead of writing lambdas. The operator module has the `itemgetter`,
    `attrgetter`, and `methodcaller` functions. The sorting example that we saw can
    be written as follows using `itemgetter`:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 由于按键排序的重要性，Python提供了一个方便的函数来访问键，而无需编写`lambda`。`operator`模块提供了`itemgetter`、`attrgetter`和`methodcaller`函数。我们看到的排序示例可以使用`itemgetter`这样编写：
- en: '[PRE116]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Note that we have not used the lambda functions, rather used `itemgetter` to
    specify the key by which we need to sort. More than one field can be given as
    an input to `itemgetter` when we need multiple level sorting; for example, let''s
    say that we need to sort by name and then by age, our code would be as follows:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有使用 lambda 函数，而是使用 `itemgetter` 来指定排序的键。若需要多级排序，可以向 `itemgetter` 提供多个字段；例如，假设我们需要按姓名排序，然后按年龄排序，我们的代码如下：
- en: '[PRE117]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The `attrgetter` and `methodcaller` comes in handy when the elements of our
    iterable are class objects. Look at the following example:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`attrgetter` 和 `methodcaller` 在我们的可迭代元素是类对象时非常有用。看下面的例子：'
- en: '[PRE118]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The constructor initializes the class with three variables: name, age, and
    ID. We also have the `pretty_print` method to print the values of the class object`.`'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数使用三个变量初始化类：姓名、年龄和 ID。我们还拥有 `pretty_print` 方法来打印类对象的值。
- en: 'Next, let''s populate a list with these class objects:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们用这些类对象填充一个列表：
- en: '[PRE119]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now, we have a list of employee objects. There are three variables in each
    object: name, ID, and age. Let''s print the list to see the order:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个员工对象列表。每个对象中有三个变量：姓名、ID 和年龄。让我们打印出列表，查看其顺序：
- en: '[PRE120]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'As you can see, the order of the insertion has been preserved. Now, let''s
    use `attrgetter` to sort the list with the age field:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，插入顺序已经被保留。现在，让我们使用 `attrgetter` 按年龄字段对列表进行排序：
- en: '[PRE121]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Let's print the sorted list.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印排序后的列表。
- en: 'The output is as follows:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE122]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: You can see that the records are now sorted by age.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，现在记录已经按年龄排序。
- en: 'The `methodcaller` can be used to sort when we want to use a method in our
    class to decide the sorting. For demonstration purposes, let''s add a random method,
    which divides the age by the ID:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '`methodcaller` 可用于排序，当我们希望使用类中的方法来决定排序时。为了演示，我们添加一个随机方法，它将年龄除以 ID：'
- en: '[PRE123]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We can now sort the list by calling this method:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过调用此方法来对列表进行排序：
- en: '[PRE124]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Let''s now print the list in a sorted order and see the output:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按排序顺序打印列表并查看输出：
- en: '[PRE125]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Working with itertools
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 itertools 进行工作
- en: Itertools includes functions to work with iterables; it is inspired by a functional
    programming language such as Haskell. They promise to be memory-efficient and
    very fast.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: Itertools 包括处理可迭代对象的函数；它的灵感来源于如 Haskell 这样的函数式编程语言。它们承诺内存高效且非常快速。
- en: Getting ready
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: There are a lot of functions available in Itertools; we will go through some
    of them as we work it out through examples. A link to the full list of functions
    has been provided.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: Itertools 中有很多函数可以使用；我们将在通过例子进行讲解时逐一介绍其中的一些。已提供完整函数列表的链接。
- en: How to do it…
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Let''s proceed to see a set of Python scripts used to demonstrate the usage
    of itertools:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看一组 Python 脚本，用于演示如何使用 itertools：
- en: '[PRE126]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: How it works…
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Step 1 is pretty straightforward, where two iterables are combined using `chain()`.
    A point to note is that `chain()` is not realized till it''s actually called.
    Check the following command line:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 步是非常直接的，其中两个可迭代对象通过 `chain()` 被合并。需要注意的是，`chain()` 直到实际调用时才会被实现。请看以下命令行：
- en: '[PRE127]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Calling chain(a,b) returns the chain object. However, when we run the following
    command, the actual output is produced:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `chain(a,b)` 返回链对象。然而，当我们运行以下命令时，实际输出是：
- en: '[PRE128]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Step 2 describes `compress`. In this example, elements of a are selected based
    on elements in b. You can see that in b, the second value is zero and hence, the
    second value in a is also not selected.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 步介绍了 `compress`。在这个例子中，a 的元素根据 b 中的元素来选择。你可以看到，b 中的第二个值是零，因此 a 中的第二个值也没有被选中。
- en: Step 3 does simple mathematical combinations. We have an input list, a, and
    want the elements of a in combinations of two.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 步进行简单的数学组合。我们有一个输入列表 a，并希望将 a 中的元素进行两两组合。
- en: 'Step 4 explains a counter object, which can serve as an infinite resource of
    a sequence number given a start number. Running the code, we will get the following
    output:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 第 4 步解释了计数器对象，它可以作为一个无限序列号资源，给定一个起始号码。运行代码后，我们将得到如下输出：
- en: '[PRE129]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: You can see that we used izip here. (Zip and izip have been covered in previous
    sections.) Our output is a tuple where the first element is provided by counter
    and second element is provided by our input list, a.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们在这里使用了 `izip`。 (`zip` 和 `izip` 在前面的章节中已经介绍过。) 我们的输出是一个元组，其中第一个元素由计数器提供，第二个元素由我们的输入列表
    a 提供。
- en: Step 5 details the islice operation; islice is the same as slice, which we covered
    in the previous section, except that islice is memory-efficient and does not realize
    the complete output unless called upon.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 第5步详细介绍了islice操作；islice与我们在前一节中讲解的slice相同，唯一的区别是islice更节省内存，且除非被调用，否则不会生成完整的输出。
- en: Refer to [https://docs.python.org/2/library/itertools.html](https://docs.python.org/2/library/itertools.html)
    for a complete list of the itertools.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[https://docs.python.org/2/library/itertools.html](https://docs.python.org/2/library/itertools.html)获取完整的itertools列表。
