- en: 5\. Performing Your First Cluster Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 执行您的第一次聚类分析
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will introduce you to unsupervised learning tasks, where algorithms
    have to automatically learn patterns from data by themselves as no target variables
    are defined beforehand. We will focus specifically on the k-means algorithm, and
    see how to standardize and process data for use in cluster analysis.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍无监督学习任务，在这种任务中，算法必须自动从数据中学习模式，因为没有事先定义目标变量。我们将特别关注k-means算法，并学习如何标准化和处理数据，以便用于聚类分析。
- en: By the end of this chapter, you will be able to load and visualize data and
    clusters with scatter plots; prepare data for cluster analysis; perform centroid
    clustering with k-means; interpret clustering results and determine the optimal
    number of clusters for a given dataset.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，您将能够加载和可视化数据与聚类散点图；为聚类分析准备数据；使用k-means执行质心聚类；解释聚类结果并确定给定数据集的最优聚类数。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: 'The previous chapters introduced you to very popular and extremely powerful
    machine learning algorithms. They all have one thing in common, which is that
    they belong to the same category of algorithms: supervised learning. This kind
    of algorithm tries to learn patterns based on a specified outcome column (target
    variable) such as sales, employee churn, or class of customer.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的章节向您介绍了非常流行且极其强大的机器学习算法。它们有一个共同点，那就是它们都属于同一类算法：有监督学习。这类算法试图基于指定的结果列（目标变量），例如销售、员工流失率或客户类别，来学习模式。
- en: But what if you don't have such a variable in your dataset or you don't want
    to specify a target variable? Will you still be able to run some machine learning
    algorithms on it and find interesting patterns? The answer is yes, with the use
    of clustering algorithms that belong to the unsupervised learning category.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您的数据集中没有这样的变量，或者您不想指定目标变量呢？您还能在数据上运行一些机器学习算法并发现有趣的模式吗？答案是肯定的，借助属于无监督学习类别的聚类算法，您仍然可以做到这一点。
- en: 'Clustering algorithms are very popular in the data science industry for grouping
    similar data points and detecting outliers. For instance, clustering algorithms
    can be used by banks for fraud detection by identifying unusual clusters from
    the data. They can also be used by e-commerce companies to identify groups of
    users with similar browsing behaviors, as in the following figures:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类算法在数据科学行业中非常受欢迎，用于将相似的数据点分组并检测异常值。例如，银行可以使用聚类算法进行欺诈检测，通过识别数据中的异常群体。电子商务公司也可以使用聚类算法来识别具有相似浏览行为的用户群体，如下图所示：
- en: '![Figure 5.1: Example of data on customers with similar browsing behaviors'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1：具有相似浏览行为的客户数据示例'
- en: without clustering analysis performed
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 未执行聚类分析
- en: '](img/B15019_05_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_01.jpg)'
- en: 'Figure 5.1: Example of data on customers with similar browsing behaviors without
    clustering analysis performed'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：具有相似浏览行为的客户数据示例，未执行聚类分析
- en: 'Clustering analysis performed on this data would uncover natural patterns by
    grouping similar data points such that you may get the following result:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对该数据进行聚类分析将揭示自然的模式，通过将相似的数据点分组，从而可能得到以下结果：
- en: '![Figure 5.2: Clustering analysis performed on the data on customers'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2：对具有相似浏览行为的客户数据执行的聚类分析'
- en: with similar browsing behaviors
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相似浏览行为
- en: '](img/B15019_05_02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_02.jpg)'
- en: 'Figure 5.2: Clustering analysis performed on the data on customers with similar
    browsing behaviors'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：对具有相似浏览行为的客户数据执行的聚类分析
- en: The data is now segmented into three customer groups depending on their recurring
    visits and time spent on the website, and different marketing plans can then be
    used for each of these groups in order to maximize sales.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据现在被分为三个客户群体，分别根据他们的重复访问和在网站上花费的时间进行划分，之后可以为这些群体制定不同的营销计划，以最大化销售。
- en: In this chapter, you will learn how to perform such analysis using a very famous
    clustering algorithm called k-means.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用一种非常著名的聚类算法——k-means算法，来执行这种分析。
- en: Clustering with k-means
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用k-means进行聚类
- en: k-means is one of the most popular clustering algorithms (if not the most popular)
    among data scientists due to its simplicity and high performance. Its origins
    date back as early as 1956, when a famous mathematician named Hugo Steinhaus laid
    its foundations, but it was a decade later that another researcher called James
    MacQueen named this approach k-means.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: k-means 是数据科学家中最流行的聚类算法之一（如果不是最流行的话），因其简单且高效。它的起源可以追溯到 1956 年，当时著名数学家 Hugo Steinhaus
    为其奠定了基础，但十年后，另一位研究人员 James MacQueen 给这种方法命名为 k-means。
- en: The objective of k-means is to group similar data points (or observations) together
    that will form a cluster. Think of it as grouping elements close to each other
    (we will define how to measure closeness later in this chapter). For example,
    if you were manually analyzing user behavior on a mobile app, you might end up
    grouping customers who log in quite frequently, or users who make bigger in-app
    purchases, together. This is the kind of grouping that clustering algorithms such
    as k-means will automatically find for you from the data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: k-means 的目标是将相似的数据点（或观察值）分在一起，从而形成一个聚类。可以把它看作是将彼此接近的元素分到一起（我们将在本章稍后定义如何衡量“接近”）。例如，如果你在手动分析一个移动应用的用户行为，你可能会把那些频繁登录的客户，或者那些进行较大应用内购买的用户分到一起。这就是像
    k-means 这样的聚类算法能够自动从数据中找到的分组。
- en: In this chapter, we will be working with an open source dataset shared publicly
    by the **Australian Taxation Office** (**ATO**). The dataset contains statistics
    about each postcode (*also known as a zip code, which is an identification code
    used for sorting mail by area*) in Australia during the financial year of 2014-15.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将使用由**澳大利亚税务局**（**ATO**）公开分享的开源数据集。该数据集包含了澳大利亚 2014-15 财政年度内每个邮政编码（*也称为邮政区号，是用于按地区排序邮件的识别码*）的统计数据。
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: 'The Australian Taxation Office (ATO) dataset can be found in the Packt GitHub
    repository here: [https://packt.live/340xO5t](https://packt.live/340xO5t).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 澳大利亚税务局（ATO）数据集可以在 Packt 的 GitHub 仓库中找到：[https://packt.live/340xO5t](https://packt.live/340xO5t)。
- en: 'The source of the dataset can be found here: [https://packt.live/361i1p3](https://packt.live/361i1p3).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集的来源可以在这里找到：[https://packt.live/361i1p3](https://packt.live/361i1p3)。
- en: 'We will perform cluster analysis on this dataset for two specific variables
    (or columns): `Average net tax` and `Average total deductions`. Our objective
    is to find groups (or clusters) of postcodes sharing similar patterns in terms
    of tax received and money deducted. Here is a scatter plot of these two variables:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对这个数据集进行聚类分析，分析两个特定的变量（或列）：`平均净税额`和`平均总扣除额`。我们的目标是找到具有相似税收和扣除模式的邮政编码（或称邮政区号）的分组（或聚类）。以下是这两个变量的散点图：
- en: '![Figure 5.3: Scatter plot of the ATO dataset'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3：ATO 数据集的散点图'
- en: '](img/B15019_05_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_03.jpg)'
- en: 'Figure 5.3: Scatter plot of the ATO dataset'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：ATO 数据集的散点图
- en: 'As part of being a data scientist, you need to analyze the graphs achieved
    from this dataset and come to conclusions. Let''s say you have to analyze manually
    potential groupings of observations from this dataset. One potential result could
    be as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据科学家的一个重要任务，你需要分析从这个数据集中获得的图表并得出结论。假设你需要手动分析数据集中可能的观察值分组。一个潜在的结果可能如下：
- en: All the data points in the bottom-left corner could be grouped together (average
    net tax from 0 to 40,000).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有位于左下角的数据点可以归为一组（平均净税额从 0 到 40,000）。
- en: A second group could be all the data points in the center area (average net
    tax from 40,000 to 60,000 and average total deductions below 10,000).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二组可能是所有位于中心区域的数据点（平均净税额从 40,000 到 60,000，平均总扣除额低于 10,000）。
- en: Finally, all the remaining data points could be grouped together.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，所有剩余的数据点可以归为一组。
- en: But rather having you to manually guess these groupings, it will be better if
    we can use an algorithm to do it for us. This is what we are going to see in practice
    in the following exercise, where we'll perform clustering analysis on this dataset.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，既然我们可以使用算法来自动进行这些分组，为什么还需要你手动去猜测呢？这就是我们将在接下来的练习中实践的内容，我们将在此数据集上进行聚类分析。
- en: 'Exercise 5.01: Performing Your First Clustering Analysis on the ATO Dataset'
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.01：在 ATO 数据集上进行第一次聚类分析
- en: 'In this exercise, we will be using k-means clustering on the ATO dataset and
    observing the different clusters that the dataset divides itself into, after which
    we will conclude by analyzing the output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将对ATO数据集进行k-means聚类，并观察数据集划分出的不同簇，之后我们将通过分析输出结果得出结论：
- en: Open a new Colab notebook.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Colab笔记本。
- en: 'Next, load the required Python packages: `pandas` and `KMeans` from `sklearn.cluster`.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，加载所需的Python包：`pandas`和`KMeans`，来自`sklearn.cluster`。
- en: 'We will be using the `import` function from Python:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用Python中的`import`功能：
- en: '[PRE0]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We will be looking into `KMeans` (from `sklearn.cluster`), which you have used
    in the code here, later in the chapter for a more detailed explanation of it.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在本章后续详细解释`KMeans`（来自`sklearn.cluster`），你在这里的代码中已经使用了它。
- en: 'Next, create a variable containing the link to the file. We will call this
    variable `file_url`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个变量来保存文件链接。我们将这个变量称为`file_url`：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the next step, we will use the `pandas` package to load our data into a DataFrame
    (think of it as a table, like on an Excel spreadsheet, with a row index and column
    names).
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一步中，我们将使用`pandas`包将数据加载到DataFrame中（可以把它看作一个表格，类似于Excel中的电子表格，具有行索引和列名）。
- en: Our input file is in `CSV` format, and `pandas` has a method that can directly
    read this format, which is `.read_csv()`.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的输入文件是`CSV`格式，`pandas`有一个方法可以直接读取这种格式，即`.read_csv()`。
- en: 'Use the `usecols` parameter to subset only the columns we need rather than
    loading the entire dataset. We just need to provide a list of the column names
    we are interested in, which are mentioned in the following code snippet:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`usecols`参数仅选择我们需要的列，而不是加载整个数据集。我们只需要提供一个我们感兴趣的列名列表，这些列名在以下代码片段中提到：
- en: '[PRE2]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we have loaded the data into a `pandas` DataFrame.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经将数据加载到`pandas` DataFrame中。
- en: 'Next, let''s display the first 5 rows of this DataFrame , using the method
    `.head()`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`.head()`方法显示DataFrame的前5行：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should get the following output:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.4: The first five rows of the ATO DataFrame'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.4：ATO数据框的前五行'
- en: '](img/B15019_05_04.jpg)'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_04.jpg)'
- en: 'Figure 5.4: The first five rows of the ATO DataFrame'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.4：ATO数据框的前五行
- en: 'Now, to output the last 5 rows, we use `.tail()`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`.tail()`输出最后5行：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should get the following output:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.5: The last five rows of the ATO DataFrame'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.5：ATO数据框的最后五行'
- en: '](img/B15019_05_05.jpg)'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_05.jpg)'
- en: 'Figure 5.5: The last five rows of the ATO DataFrame'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.5：ATO数据框的最后五行
- en: 'Now that we have our data, let''s jump straight to what we want to do: find
    clusters.'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经有了数据，直接进入我们想要做的事情：寻找聚类。
- en: 'As you saw in the previous chapters, `sklearn` provides the exact same APIs
    for training different machine learning algorithms, such as:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如你在前几章中看到的，`sklearn`提供了相同的API用于训练不同的机器学习算法，比如：
- en: Instantiate an algorithm with the specified hyperparameters (here it will be
    KMeans(hyperparameters)).
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指定的超参数实例化一个算法（这里是KMeans(超参数)）。
- en: Fit the model with the training data with the method `.fit()`.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.fit()`方法用训练数据拟合模型。
- en: Predict the result with the given input data with the method `.predict()`.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.predict()`方法预测给定输入数据的结果。
- en: Note
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Here, we will use all the default values for the k-means hyperparameters except
    for the `random_state` one. Specifying a fixed random state (also called a **seed**)
    will help us to get reproducible results every time we have to rerun our code.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将使用k-means超参数的所有默认值，除了`random_state`。指定一个固定的随机状态（也叫**种子**）将帮助我们每次重新运行代码时获得可重复的结果。
- en: 'Instantiate k-means with a random state of `42` and save it into a variable
    called `kmeans`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用随机状态`42`实例化k-means，并将其保存到名为`kmeans`的变量中：
- en: '[PRE5]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now feed k-means with our training data. To do so, we need to get only the
    variables (or columns) used for fitting the model. In our case, the variables
    are `''Average net tax''` and `''Average total deductions''`, and they are saved
    in a new variable called `X`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将k-means与我们的训练数据进行拟合。为此，我们需要只获取用于拟合模型的变量（或列）。在我们的例子中，变量是`'Average net tax'`和`'Average
    total deductions'`，它们保存在一个名为`X`的新变量中：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now fit `kmeans` with this training data:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用这些训练数据拟合`kmeans`：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should get the following output:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.6: Summary of the fitted kmeans and its hyperparameters'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.6：拟合的k-means及其超参数的总结'
- en: '](img/B15019_05_06.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_06.jpg)'
- en: 'Figure 5.6: Summary of the fitted kmeans and its hyperparameters'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.6：拟合的k-means及其超参数的总结
- en: We just ran our first clustering algorithm in just a few lines of code.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们仅用几行代码就运行了第一个聚类算法。
- en: 'See which cluster each data point belongs to by using the `.predict()` method:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`.predict()`方法查看每个数据点属于哪个聚类：
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should get the following output:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到如下输出：
- en: '![Figure 5.7: Output of the k-means predictions'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.7：k-means预测输出](img/B15019_05_07.jpg)'
- en: '](img/B15019_05_07.jpg)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_08.jpg)'
- en: 'Figure 5.7: Output of the k-means predictions'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.7：k-means预测输出
- en: Note
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'Although we set a `random_state` value, you may still get an output with different
    cluster numbers than the one shown above. This will depend on the version of scikit-learn
    you are using. The output above was generated using version 0.22.2\. You can find
    out which version you are using by executing the following code:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管我们设置了一个`random_state`值，但你仍然可能得到与上述不同的聚类编号。这取决于你所使用的scikit-learn版本。上述输出是使用版本0.22.2生成的。你可以通过执行以下代码来查看你使用的版本：
- en: '`import sklearn`'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`import sklearn`'
- en: '`sklearn.__version__`'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sklearn.__version__`'
- en: 'Now, add these predictions into the original DataFrame and take a look at the
    first five postcodes:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将这些预测结果添加到原始DataFrame中，看看前五个邮政编码：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The predictions from the sklearn `predict()` method are in the exact same order
    as the input data. So, the first prediction will correspond to the first row of
    your DataFrame.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 来自sklearn `predict()`方法的预测与输入数据的顺序完全相同。因此，第一个预测将对应于DataFrame中的第一行。
- en: 'You should get the following output:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到如下输出：
- en: '![Figure 5.8: Cluster number assigned to the first five postcodes'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.8：分配给前五个邮政编码的聚类编号](img/B15019_05_08.jpg)'
- en: '](img/B15019_05_08.jpg)'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_08.jpg)'
- en: 'Figure 5.8: Cluster number assigned to the first five postcodes'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：分配给前五个邮政编码的聚类编号
- en: Our k-means model has grouped the first two rows into the same cluster, `6`.
    We can see these two observations both have average net tax values around 28,000\.
    The last three data points have been assigned to different clusters (`5`, `7`,
    and `2`, respectively) and we can see their values for both average total deductions
    and average net tax are very different from each other. It seems that lower values
    are grouped into cluster `5` while higher values are classified into cluster `7`.
    We are starting to build our understanding of how k-means has decided to group
    the observations from this dataset.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的k-means模型已经将前两行分配到了同一个聚类中，`6`。我们可以看到，这两个观测值的平均净税值大约为28,000。最后三条数据点被分配到不同的聚类中（分别是`5`、`7`和`2`），我们可以看到它们的平均总扣除和平均净税值有很大差异。似乎较低的值被分到聚类`5`，而较高的值被分类到聚类`7`。我们开始逐步理解k-means是如何决定将这个数据集的观测值分组的。
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2DUCWAZ](https://packt.live/2DUCWAZ).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问该特定部分的源代码，请参见[https://packt.live/2DUCWAZ](https://packt.live/2DUCWAZ)。
- en: You can also run this example online at [https://packt.live/2EgduFS](https://packt.live/2EgduFS).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/2EgduFS](https://packt.live/2EgduFS)在线运行这个示例。
- en: This is a great start. You have learned how to train (or fit) a k-means model
    in a few lines of code. Now we can start diving deeper into the magic behind k-means.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的开始。你已经学会了如何用几行代码训练（或拟合）一个k-means模型。接下来，我们可以开始深入探讨k-means背后的魔力。
- en: Interpreting k-means Results
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释k-means结果
- en: After training our k-means algorithm, we will likely be interested in analyzing
    its results in more detail. Remember, the objective of cluster analysis is to
    group observations with similar patterns together. But how can we see whether
    the groupings found by the algorithm are meaningful? We will be looking at this
    in this section by using the dataset results we just generated.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在训练我们的k-means算法后，我们可能会对其结果进行更详细的分析。记住，聚类分析的目标是将具有相似模式的观测值分组在一起。但是，如何判断算法找到的分组是否有意义呢？我们将在本节中通过使用刚刚生成的数据集结果来探讨这个问题。
- en: One way of investigating this is to analyze the dataset row by row with the
    assigned cluster for each observation. This can be quite tedious, especially if
    the size of your dataset is quite big, so it would be better to have a kind of
    summary of the cluster results.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 调查此问题的一种方法是逐行分析数据集，并查看每个观测值的分配聚类。这可能会相当繁琐，特别是当数据集非常大时，因此最好有一个聚类结果的总结。
- en: If you are familiar with Excel spreadsheets, you are probably thinking about
    using a pivot table to get the average of the variables for each cluster. In SQL,
    you would have probably used a `GROUP BY` statement. If you are not familiar with
    either of these, you may think of grouping each cluster together and then calculating
    the average for each of them. The good news is that this can be easily achieved
    with the `pandas` package in Python. Let's see how this can be done with an example.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉Excel电子表格，你可能会想到使用透视表来计算每个簇的变量平均值。在SQL中，你可能会使用`GROUP BY`语句。如果你不熟悉这两者，你可能会想到将每个簇分组，然后计算它们的平均值。好消息是，这可以通过Python中的`pandas`包轻松实现。让我们通过一个示例来看如何完成这项任务。
- en: 'To create a pivot table similar to an Excel one, we will be using the `pivot_table()`
    method from `pandas`. We need to specify the following parameters for this method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建类似于Excel的透视表，我们将使用`pandas`的`pivot_table()`方法。我们需要为该方法指定以下参数：
- en: '`values`: This parameter corresponds to the numerical columns you want to calculate
    summaries for (or aggregations), such as getting averages or counts. In an Excel
    pivot table, it is also called `values`. In our dataset, we will use the `Average
    net tax` and `Average total deductions` variables.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values`：此参数对应于你想要计算摘要（或聚合）的数值列，如获取平均值或计数。在Excel透视表中，它也被称为`values`。在我们的数据集中，我们将使用`Average
    net tax`和`Average total deductions`变量。'
- en: '`index`: This parameter is used to specify the columns you want to see summaries
    for. In our case, it will be the `cluster` column. In a pivot table in Excel,
    this corresponds with the `Rows` field.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`：此参数用于指定你想要查看汇总的列。在我们的例子中，它是`cluster`列。在Excel透视表中，这对应于`Rows`字段。'
- en: '`aggfunc`: This is where you will specify the aggregation functions you want
    to summarize the data with, such as getting averages or counts. In Excel, this
    is the `Summarize by` option in the `values` field. An example of how to use the
    `aggfunc` method is shown below.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aggfunc`：在这里，你将指定用于总结数据的聚合函数，如获取平均值或计数。在Excel中，这是`values`字段中的`Summarize by`选项。下面展示了如何使用`aggfunc`方法的示例。'
- en: Note
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Run the code below in the same notebook as you used for the previous exercise.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在与你进行先前练习的同一本笔记本中运行下面的代码。
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will be using the `numpy` implementation of `mean()` as it is more optimized
    for pandas DataFrames.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`numpy`实现的`mean()`函数，因为它对pandas DataFrame进行了更多优化。
- en: '![Figure 5.9: Output of the pivot_table function'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9：透视表函数的输出'
- en: '](img/B15019_05_09.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_09.jpg)'
- en: 'Figure 5.9: Output of the pivot_table function'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：透视表函数的输出
- en: In this summary, we can see that the algorithm has grouped the data into eight
    clusters (clusters 0 to 7). Cluster 0 has the lowest average net tax and total
    deductions amounts among all the clusters, while cluster 4 has the highest values.
    With this pivot table, we are able to compare clusters between them using their
    summarized values.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个总结中，我们可以看到算法已经将数据分为八个簇（簇0到簇7）。簇0的平均净税和总扣除金额在所有簇中最低，而簇4的值最高。通过这个透视表，我们可以使用总结值对簇进行相互比较。
- en: Using an aggregated view of clusters is a good way of seeing the difference
    between them, but it is not the only way. Another possibility is to visualize
    clusters in a graph. This is exactly what we are going to do now.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用聚合视图来查看簇之间的差异是一种很好的方式，但这并不是唯一的方式。另一种可能性是将簇可视化成图表。这正是我们接下来要做的。
- en: 'You may have heard of different visualization packages, such as `matplotlib`,
    `seaborn`, and `bokeh`, but in this chapter, we will be using the `altair` package
    because it is quite simple to use (its API is very similar to `sklearn`). Let''s
    import it first:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过不同的可视化包，例如`matplotlib`、`seaborn`和`bokeh`，但在本章中，我们将使用`altair`包，因为它非常简单易用（它的API与`sklearn`非常相似）。首先让我们导入它：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we will instantiate a `Chart()` object with our DataFrame and save it
    into a variable called `chart`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将实例化一个`Chart()`对象，并将其与我们的DataFrame一起保存到一个名为`chart`的变量中：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we will specify the type of graph we want, a scatter plot, with the `.mark_circle()`
    method and will save it into a new variable called `scatter_plot`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过`.mark_circle()`方法指定我们想要的图表类型，即散点图，并将其保存到一个名为`scatter_plot`的新变量中：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we need to configure our scatter plot by specifying the names of the
    columns that will be our `x`- and `y`-axes on the graph. We also tell the scatter
    plot to color each point according to its cluster value with the `color` option:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要通过指定将作为图表中`x`轴和`y`轴的列名来配置我们的散点图。我们还告诉散点图根据每个点的聚类值使用`color`选项来为每个点着色：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that we added `:N` at the end of the `cluster` column name.
    This extra parameter is used in `altair` to specify the type of value for this
    column. `:N` means the information contained in this column is categorical. `altair`
    automatically defines the color scheme to be used depending on the type of a column.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在`cluster`列名的末尾添加了`:N`。这个额外的参数在`altair`中用于指定该列的值类型。`:N`意味着该列中的信息是类别型的。`altair`会根据列的类型自动定义要使用的颜色方案。
- en: 'You should get the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.10: Scatter plot of the clusters'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10：聚类的散点图](img/B15019_05_10.jpg)'
- en: '](img/B15019_05_10.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_10.jpg)'
- en: 'Figure 5.10: Scatter plot of the clusters'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：聚类的散点图
- en: We can now easily see what the clusters in this graph are and how they differ
    from each other. We can clearly see that k-means assigned data points to each
    cluster mainly based on the x-axis variable, which is `Average net tax`. The boundaries
    of the clusters are vertical straight lines. For instance, the boundary separating
    the yellow and orange clusters is roughly around 18,000\. Observations below this
    limit are assigned to the red cluster (2) and those above to the purple cluster
    (6).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以轻松地看到这个图中的聚类及其相互之间的差异。我们可以清楚地看到，k-means主要根据x轴变量（即`平均净税`）将数据点分配到每个聚类中。聚类的边界是垂直的直线。例如，分隔黄色和橙色聚类的边界大约在18,000左右。低于这个限制的观测值被分配到红色聚类（2），高于这个限制的则被分配到紫色聚类（6）。
- en: Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can see the high quality color images for this Workshop at: [https://packt.live/30O91Bd](https://packt.live/30O91Bd%20)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接查看本工作坊的高质量彩色图片：[https://packt.live/30O91Bd](https://packt.live/30O91Bd%20)
- en: If you have used visualization tools such as **Tableau** or **Power BI**, you
    might feel a bit frustrated as this graph is static, you can't hover over each
    data point to get more information and find, for instance, what is the limit separating
    the orange cluster from the pink one. But this can be easily achieved with altair
    and this is one of the reasons we chose to use it We can add some interactions
    to your chart with minimal code changes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过**Tableau**或**Power BI**等可视化工具，你可能会感到有些沮丧，因为这个图表是静态的，你无法悬停在每个数据点上获取更多信息，无法找到例如橙色聚类和粉色聚类之间的分界线。但是，使用altair，这可以轻松实现，这也是我们选择使用它的原因之一。我们可以通过最小的代码更改来为图表添加一些交互功能。
- en: 'Let''s say we want to add a tooltip that will display the values for the two
    columns of interest: the postcode and the assigned cluster. With `altair`, we
    just need to add a parameter called `tooltip` in the `encode()` method with a
    list of corresponding column names and call the `interactive()` method just after,
    as seen in the following code snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要添加一个工具提示，显示我们关心的两个列的值：邮政编码和分配的聚类。使用`altair`，我们只需要在`encode()`方法中添加一个名为`tooltip`的参数，并列出相应的列名，然后在后面调用`interactive()`方法，代码片段如下所示：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should get the following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.11: Interactive scatter plot of the clusters with tooltip'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11：带工具提示的交互式散点图](img/B15019_05_10.jpg)'
- en: '](img/B15019_05_11.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_11.jpg)'
- en: 'Figure 5.11: Interactive scatter plot of the clusters with tooltip'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：带工具提示的交互式散点图
- en: Now we can easily hover over and inspect the data points near the cluster boundaries
    and find out that the threshold used to differentiate the purple cluster (6) from
    the red one (2) is close to 32,000 in `'Average Net Tax'`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松地悬停并检查接近聚类边界的数据点，发现区分紫色聚类（6）和红色聚类（2）的阈值接近于32,000的`平均净税`。
- en: 'Exercise 5.02: Clustering Australian Postcodes by Business Income and Expenses'
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.02：按商业收入和支出对澳大利亚邮政编码进行聚类
- en: 'In this exercise, we will learn how to perform clustering analysis with k-means
    and visualize its results based on postcode values sorted by business income and
    expenses. The following steps will help you complete this exercise:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将学习如何使用k-means进行聚类分析，并根据按商业收入和支出排序的邮政编码值可视化其结果。以下步骤将帮助你完成本练习：
- en: Open a new Colab notebook for this exercise.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Colab笔记本来进行这个练习。
- en: 'Now `import` the required packages (`pandas`, `sklearn`, `altair`, and `numpy`):'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`import`所需的包（`pandas`、`sklearn`、`altair`和`numpy`）：
- en: '[PRE16]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Assign the link to the ATO dataset to a variable called `file_url`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ATO数据集的链接赋值给一个名为`file_url`的变量：
- en: '[PRE17]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using the `read_csv` method from the pandas package, load the dataset with
    only the following columns with the `use_cols` parameter: `''Postcode''`, `''Average
    total business income''`, and `''Average total business expenses''`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pandas`包中的`read_csv`方法，只加载以下列，并使用`use_cols`参数：`'Postcode'`、`'Average total
    business income'`和`'Average total business expenses'`：
- en: '[PRE18]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Display the last 10 rows from the ATO dataset using the `.tail()` method from
    pandas:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用pandas的`.tail()`方法显示ATO数据集的最后10行：
- en: '[PRE19]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should get the following output:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.12: The last 10 rows of the ATO dataset'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.12：ATO数据集的最后10行'
- en: '](img/B15019_05_12.jpg)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_12.jpg)'
- en: 'Figure 5.12: The last 10 rows of the ATO dataset'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.12：ATO数据集的最后10行
- en: 'Extract the `''Average total business income''` and `''Average total business
    expenses''` columns using the following pandas column subsetting syntax: `dataframe_name[<list_of_columns>]`.
    Then, save them into a new variable called `X`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下pandas列子集语法提取`'Average total business income'`和`'Average total business
    expenses'`列：`dataframe_name[<list_of_columns>]`。然后，将其保存到一个名为`X`的新变量中：
- en: '[PRE20]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now fit `kmeans` with this new variable using a value of `8` for the `random_state`
    hyperparameter:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用一个`random_state`超参数值为`8`，用这个新变量来拟合`kmeans`：
- en: '[PRE21]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should get the following output:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.13: Summary of the fitted kmeans and its hyperparameters'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.13：拟合的kmeans及其超参数摘要'
- en: '](img/B15019_05_13.jpg)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_13.jpg)'
- en: 'Figure 5.13: Summary of the fitted kmeans and its hyperparameters'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.13：拟合的kmeans及其超参数摘要
- en: 'Using the `predict` method from the `sklearn` package, predict the clustering
    assignment from the input variable, `(X)`, save the results into a new variable
    called `y_preds`, and display the last `10` predictions:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sklearn`包中的`predict`方法，从输入变量`(X)`预测聚类分配结果，将结果保存到一个名为`y_preds`的新变量中，并显示最后`10`个预测值：
- en: '[PRE22]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should get the following output:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.14: Results of the clusters assigned to the last 10 observations'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.14：分配给最后10个观测值的聚类结果'
- en: '](img/B15019_05_14.jpg)'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_14.jpg)'
- en: 'Figure 5.14: Results of the clusters assigned to the last 10 observations'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.14：分配给最后10个观测值的聚类结果
- en: 'Save the predicted clusters back to the DataFrame by creating a new column
    called `''cluster''` and print the last `10` rows of the DataFrame using the `.tail()`
    method from the `pandas` package:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将预测的聚类结果保存回数据框，通过创建一个名为`'cluster'`的新列，并使用`pandas`包的`.tail()`方法打印数据框的最后`10`行：
- en: '[PRE23]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should get the following output:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.15: The last 10 rows of the ATO dataset with the added cluster column'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.15：添加聚类列后的ATO数据集最后10行'
- en: '](img/B15019_05_15.jpg)'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_15.jpg)'
- en: 'Figure 5.15: The last 10 rows of the ATO dataset with the added cluster column'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.15：添加聚类列后的ATO数据集最后10行
- en: 'Generate a pivot table with the averages of the two columns for each cluster
    value using the `pivot_table` method from the `pandas` package with the following
    parameters:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pandas`包中的`pivot_table`方法，根据以下参数生成每个聚类值的两个列的平均值透视表：
- en: Provide the names of the columns to be aggregated, `'Average total business
    income'` and `'Average total business expenses'`, to the parameter values.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将要聚合的列名`'Average total business income'`和`'Average total business expenses'`提供给参数`values`。
- en: Provide the name of the column to be grouped, `'cluster'`, to the parameter
    index.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将要分组的列名`'cluster'`提供给参数`index`。
- en: 'Use the `.mean` method from NumPy (`np`) as the aggregation function for the
    `aggfunc` parameter:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用NumPy（`np`）的`.mean`方法作为`aggfunc`参数的聚合函数：
- en: '[PRE24]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should get the following output:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.16: Output of the pivot_table function'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.16：`pivot_table`函数的输出'
- en: '](img/B15019_05_16.jpg)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_16.jpg)'
- en: 'Figure 5.16: Output of the pivot_table function'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.16：`pivot_table`函数的输出
- en: 'Now let''s plot the clusters using an interactive scatter plot. First, use
    `Chart()` and `mark_circle()` from the `altair` package to instantiate a scatter
    plot graph:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来绘制聚类结果，使用交互式散点图。首先，使用`altair`包中的`Chart()`和`mark_circle()`来实例化散点图：
- en: '[PRE25]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use the `encode` and `interactive` methods from `altair` to specify the display
    of the scatter plot and its interactivity options with the following parameters:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`altair`的`encode`和`interactive`方法，指定散点图的显示和交互选项，使用以下参数：
- en: Provide the name of the `'Average total business income'` column to the `x`
    parameter (the x-axis).
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`'Average total business income'`列的名称提供给`x`参数（x轴）。
- en: Provide the name of the `'Average total business expenses'` column to the `y`
    parameter (the y-axis).
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`'Average total business expenses'`列的名称提供给`y`参数（y轴）。
- en: Provide the name of the `cluster:N` column to the `color` parameter (providing
    a different color for each group).
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`cluster:N`列的名称提供给`color`参数（为每个组提供不同的颜色）。
- en: 'Provide these column names – `''Postcode''`, `''cluster''`, `''Average total
    business income''`, and `''Average total business expenses''` – to the `''tooltip''`
    parameter (this being the information displayed by the tooltip):'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将这些列名——`'Postcode'`、`'cluster'`、`'Average total business income'`和`'Average
    total business expenses'`——提供给`'tooltip'`参数（这是提示框显示的信息）：
- en: '[PRE26]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should get the following output:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '![Figure 5.17: Interactive scatter plot of the clusters'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.17：聚类的交互式散点图'
- en: '](img/B15019_05_17.jpg)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_17.jpg)'
- en: 'Figure 5.17: Interactive scatter plot of the clusters'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17：聚类的交互式散点图
- en: Note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3hacbXA](https://packt.live/3hacbXA).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/3hacbXA](https://packt.live/3hacbXA)。
- en: This section does not currently have an online interactive example, but can
    be run as usual on Google Colab.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本节目前没有在线交互式示例，但可以像往常一样在Google Colab上运行。
- en: We can see that k-means has grouped the observations into eight different clusters
    based on the value of the two variables (`'Average total business income'` and
    `'Average total business expense'`). For instance, all the low-value data points
    have been assigned to cluster 0, while the ones with extremely high values belong
    to cluster 4\. So, k-means has grouped the data points that share similar behaviors.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，k-means根据两个变量（`'Average total business income'`和`'Average total business
    expense'`）的值将观测值分为八个不同的簇。例如，所有低值数据点都被分配到簇0，而具有极高值的数据点则属于簇4。因此，k-means将具有相似行为的数据点进行了分组。
- en: You just successfully completed a cluster analysis and visualized its results.
    You learned how to load a real-world dataset, fit k-means, and display a scatter
    plot. This is a great start, and we will be delving into more details on how to
    improve the performance of your model in the sections to come in this chapter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚成功地完成了聚类分析并可视化了其结果。你学习了如何加载真实世界的数据集，拟合k-means并显示散点图。这是一个很好的开始，我们将在本章接下来的部分中深入探讨如何提高模型的性能。
- en: Choosing the Number of Clusters
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择聚类数目
- en: In the previous sections, we saw how easy it is to fit the k-means algorithm
    on a given dataset. In our ATO dataset, we found 8 different clusters that were
    mainly defined by the values of the `Average net tax` variable.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到将k-means算法应用于给定数据集是多么简单。在我们的ATO数据集中，我们发现了8个主要由`Average net tax`变量的值定义的不同簇。
- en: 'But you may have asked yourself: "*Why 8 clusters? Why not 3 or 15 clusters?*"
    These are indeed excellent questions. The short answer is that we used k-means''
    default value for the hyperparameter `n_cluster`, defining the number of clusters
    to be found, as 8.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能会问自己：“*为什么是8个簇？为什么不是3个或15个簇？*”这些确实是很好的问题。简短的回答是我们使用了k-means的默认超参数`n_cluster`值，定义了要找到的簇数为8。
- en: As you will recall from *Chapter 2*, *Regression*, and *Chapter 4*, *Multiclass
    Classification with RandomForest*, the value of a hyperparameter isn't learned
    by the algorithm but has to be set arbitrarily by you prior to training. For k-means,
    `n_cluster` is one of the most important hyperparameters you will have to tune.
    Choosing a low value will lead k-means to group many data points together, even
    though they are very different from each other. On the other hand, choosing a
    high value may force the algorithm to split close observations into multiple ones,
    even though they are very similar.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从*第2章*《回归》和*第4章*《使用随机森林进行多类分类》中回忆的那样，超参数的值不是由算法学习的，而是在训练前由你随意设置的。对于k-means，`n_cluster`是你需要调整的最重要的超参数之一。选择一个较小的值会导致k-means将许多数据点分组在一起，即使它们彼此非常不同。另一方面，选择一个较大的值可能会迫使算法将相似的观测值分割成多个簇，即使它们非常相似。
- en: Looking at the scatter plot from the ATO dataset, eight clusters seems to be
    a lot. On the graph, some of the clusters look very close to each other and have
    similar values. Intuitively, just by looking at the plot, you could have said
    that there were between two and four different clusters. As you can see, this
    is quite suggestive, and it would be great if there was a function that could
    help us to define the right number of clusters for a dataset. Such a method does
    indeed exist, and it is called the **Elbow** method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ATO 数据集的散点图来看，八个集群似乎有点多。在图上，一些集群看起来彼此非常接近，并且具有相似的值。凭直觉，仅通过查看图形，你本可以说数据中有两个到四个不同的集群。如你所见，这一点很有启发性，如果有一个函数能够帮助我们定义数据集的正确集群数，那该有多好。确实存在这样一个方法，叫做**肘部**法则。
- en: This method assesses the compactness of clusters, the objective being to minimize
    a value known as **inertia**. More details and an explanation about this will
    be provided later in this chapter. For now, think of inertia as a value that says,
    for a group of data points, how far from each other or how close to each other
    they are.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法评估集群的紧凑性，目标是最小化一个称为**惯性**的值。更多的细节和解释将在本章后面提供。现在，可以将惯性视为一个值，表示对于一组数据点，它们之间有多远或有多近。
- en: Let's apply this method to our ATO dataset. First, we will define the range
    of cluster numbers we want to evaluate (between 1 and 10) and save them in a DataFrame
    called `clusters`. We will also create an empty list called `inertia`, where we
    will store our calculated values.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此方法应用于我们的 ATO 数据集。首先，我们将定义一个我们希望评估的聚类数量范围（1到10之间），并将其保存在一个名为`clusters`的数据框中。我们还将创建一个空列表`inertia`，在其中存储计算得到的值。
- en: Note
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Open the notebook you were using for *Exercise 5.01*, *Performing Your First
    Clustering Analysis on the ATO Dataset*, execute the code you already entered,
    and then continue at the end of the notebook with the following code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你用于*练习 5.01*的笔记本，*在 ATO 数据集上执行你的第一次聚类分析*，执行你已输入的代码，然后在笔记本末尾继续以下代码。
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we will create a `for` loop that will iterate over the range, fit a k-means
    model with the specified number of `clusters`, extract the `inertia` value, and
    store it in our list, as in the following code snippet:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`for`循环，遍历范围，使用指定数量的`clusters`拟合k-means模型，提取`inertia`值，并将其存储在我们的列表中，如以下代码片段所示：
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we can use our list of `inertia` values in the `clusters` DataFrame:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`clusters`数据框中的`inertia`值：
- en: '[PRE29]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should get the following output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.18: Dataframe containing inertia values for our clusters'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.18：包含我们集群惯性值的数据框'
- en: '](img/B15019_05_18.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_18.jpg)'
- en: 'Figure 5.18: Dataframe containing inertia values for our clusters'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18：包含我们集群惯性值的数据框
- en: 'Then, we need to plot a line chart using `altair` with the `mark_line()` method.
    We will specify the `''cluster_range''` column as our x-axis and `''inertia''`
    as our y-axis, as in the following code snippet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用`altair`绘制一张折线图，使用`mark_line()`方法。我们将指定`'cluster_range'`列作为x轴，`'inertia'`作为y轴，如以下代码片段所示：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should get the following output:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.19: Plotting the Elbow method'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.19：绘制肘部法则'
- en: '](img/B15019_05_19.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_19.jpg)'
- en: 'Figure 5.19: Plotting the Elbow method'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19：绘制肘部法则
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You don't have to save each of the `altair` objects in a separate variable;
    you can just append the methods one after the other with "`.".`
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要将每个`altair`对象保存在一个单独的变量中；你可以将方法一个接一个地附加，用"`。`"。
- en: Now that we have plotted the inertia value against the number of clusters, we
    need to find the optimal number of clusters. What we need to do is to find the
    inflection point in the graph, where the inertia value starts to decrease more
    slowly (that is, where the slope of the line almost reaches a 45-degree angle).
    Finding the right **inflection point** can be a bit tricky. If you picture this
    line chart as an arm, what we want is to find the center of the Elbow (now you
    know where the name for this method comes from). So, looking at our example, we
    will say that the optimal number of clusters is three. If we kept adding more
    clusters, the inertia would not decrease drastically and add any value. This is
    the reason why we want to find the middle of the Elbow as the inflection point.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经绘制了惯性值与簇数量的关系图，我们需要找到最优的簇数量。我们需要做的是找到图中的拐点，即惯性值开始变得较慢下降的地方（也就是曲线斜率几乎达到45度的地方）。找到正确的**拐点**可能有些困难。如果你把这条折线图想象成一只手臂，我们要做的就是找到肘部的中心（现在你知道这个方法的名字来源于哪里了）。因此，看看我们的例子，我们可以说最优的簇数量是三个。如果我们继续增加簇的数量，惯性值就不会大幅度下降，也不会带来任何价值。这就是为什么我们要找到肘部的中间点作为拐点的原因。
- en: 'Now let''s retrain our `Kmeans` with this hyperparameter and plot the clusters
    as shown in the following code snippet:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个超参数重新训练`Kmeans`并绘制簇，如下代码片段所示：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should get the following output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.20: Scatter plot of the three clusters'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.20：三个簇的散点图'
- en: '](img/B15019_05_20.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_20.jpg)'
- en: 'Figure 5.20: Scatter plot of the three clusters'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20：三个簇的散点图
- en: 'This is very different compared to our initial results. Looking at the three
    clusters, we can see that:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们最初的结果非常不同。观察这三个簇，我们可以看到：
- en: The first cluster (red) represents postcodes with low values for both average
    net tax and total deductions.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个簇（红色）表示那些在平均净税和总扣除方面都较低的邮政编码。
- en: The second cluster (blue) is for medium average net tax and low average total
    deductions.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个簇（蓝色）表示中等的平均净税和低的平均总扣除。
- en: The third cluster (orange) is grouping all postcodes with average net tax values
    above 35,000.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个簇（橙色）将所有平均净税值超过35,000的邮政编码归为一类。
- en: Note
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: It is worth noticing that the data points are more spread in the third cluster;
    this may indicate that there are some outliers in this group.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值得注意的是，第三个簇的数据点分布较广，这可能表明该组中有一些离群值。
- en: This example showed us how important it is to define the right number of clusters
    before training a k-means algorithm if we want to get meaningful groups from data.
    We used a method called the Elbow method to find this optimal number.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例向我们展示了在训练k-means算法之前，定义正确的簇数量有多么重要，特别是当我们希望从数据中获得有意义的分组时。我们使用了一种叫做肘部法则的方法来找到这个最优数量。
- en: 'Exercise 5.03: Finding the Optimal Number of Clusters'
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.03：寻找最优簇的数量
- en: 'In this exercise, we will apply the Elbow method to the same data as in *Exercise
    5.02*, *Clustering Australian Postcodes by Business Income and Expenses*, to find
    the optimal number of clusters, before fitting a k-means model:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将应用肘部法则，使用与*练习5.02*中相同的数据集，即*通过商业收入和支出对澳大利亚邮政编码进行聚类*，以找到最优的簇数量，然后再拟合k-means模型：
- en: Open a new Colab notebook for this exercise.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Colab笔记本进行此练习。
- en: 'Now `import` the required packages (`pandas`, `sklearn`, and `altair`):'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`import`所需的包（`pandas`、`sklearn`和`altair`）：
- en: '[PRE32]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, we will load the dataset and select the same columns as in *Exercise 5.02*,
    *Clustering Australian Postcodes by Business Income and Expenses*, and print the
    first five rows.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将加载数据集，并选择与*练习5.02*中相同的列，即*通过商业收入和支出对澳大利亚邮政编码进行聚类*，并打印前五行。
- en: 'Assign the link to the ATO dataset to a variable called `file_url`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ATO数据集的链接赋值给一个名为`file_url`的变量：
- en: '[PRE33]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Using the `.read_csv()` method from the pandas package, load the dataset with
    only the following columns using the `use_cols` parameter: `''Postcode''`, `''Average
    total business income''`, and `''Average total business expenses''`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用pandas包中的`.read_csv()`方法，加载数据集并仅使用`use_cols`参数选择以下列：`'Postcode'`、`'Average
    total business income'`和`'Average total business expenses'`：
- en: '[PRE34]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Display the first five rows of the DataFrame with the `.head()` method from
    the pandas package:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用pandas包中的`.head()`方法显示数据框的前五行：
- en: '[PRE35]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should get the following output:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.21: The first five rows of the ATO DataFrame'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.21：ATO数据框的前五行'
- en: '](img/B15019_05_21.jpg)'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_21.jpg)'
- en: 'Figure 5.21: The first five rows of the ATO DataFrame'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.21：ATO数据框的前五行
- en: 'Assign the `''Average total business income''` and `''Average total business
    expenses''` columns to a new variable called `X`:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `'Average total business income'` 和 `'Average total business expenses'` 列分配给一个新变量，命名为
    `X`：
- en: '[PRE36]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create an empty pandas DataFrame called `clusters` and an empty list called
    `inertia`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的 pandas DataFrame，命名为 `clusters`，并创建一个空的列表，命名为 `inertia`：
- en: '[PRE37]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, use the `range` function to generate a list containing the range of cluster
    numbers, from `1` to `15`, and assign it to a new column called `''cluster_range''`
    from the `''clusters''` DataFrame:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，使用 `range` 函数生成一个包含集群数量范围的列表，从 `1` 到 `15`，并将其分配到来自 `'clusters'` DataFrame
    的名为 `'cluster_range'` 的新列：
- en: '[PRE38]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create a `for` loop to go through each cluster number and fit a k-means model
    accordingly, then append the `inertia` values using the `''inertia_''` parameter
    with the `''inertia''` list:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `for` 循环，遍历每个集群编号，并相应地拟合一个 k-means 模型，然后使用 `'inertia_'` 参数将 `inertia` 值附加到
    `'inertia'` 列表中：
- en: '[PRE39]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Assign the `inertia` list to a new column called `''inertia''` from the `clusters`
    DataFrame and display its content:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `inertia` 列分配到名为 `'inertia'` 的新列中，该列来自 `clusters` DataFrame，并显示其内容：
- en: '[PRE40]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should get the following output:'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.22: Plotting the Elbow method'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.22：绘制肘部法则'
- en: '](img/B15019_05_22.jpg)'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_22.jpg)'
- en: 'Figure 5.22: Plotting the Elbow method'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.22：绘制肘部法则
- en: 'Now use `mark_line()` and `encode()` from the `altair` package to plot the
    Elbow graph with `''cluster_range''` as the x-axis and `''inertia''` as the y-axis:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `altair` 包中的 `mark_line()` 和 `encode()` 绘制肘部图，`'cluster_range'` 为 x 轴，`'inertia'`
    为 y 轴：
- en: '[PRE41]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should get the following output:'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.23: Plotting the Elbow method'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.23：绘制肘部法则'
- en: '](img/B15019_05_23.jpg)'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_23.jpg)'
- en: 'Figure 5.23: Plotting the Elbow method'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.23：绘制肘部法则
- en: 'Looking at the Elbow plot, identify the optimal number of clusters, and assign
    this value to a variable called `optim_cluster`:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看肘部图，确定最优集群数量，并将此值分配给名为 `optim_cluster` 的变量：
- en: '[PRE42]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Train a k-means model with this number of clusters and a `random_state` value
    of `42` using the `fit` method from `sklearn`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `sklearn` 中的 `fit` 方法，训练一个具有此集群数量和 `random_state` 值为 `42` 的 k-means 模型：
- en: '[PRE43]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, using the `predict` method from `sklearn`, get the predicted assigned
    cluster for each data point contained in the `X` variable and save the results
    into a new column called `''cluster2''` from the `df` DataFrame:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `sklearn` 中的 `predict` 方法，为 `X` 变量中包含的每个数据点获取预测的分配集群，并将结果保存到名为 `'cluster2'`
    的新列中，该列来自 `df` DataFrame：
- en: '[PRE44]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Display the first five rows of the `df` DataFrame using the `head` method from
    the `pandas` package:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `pandas` 包中的 `head` 方法显示 `df` DataFrame 的前五行：
- en: '[PRE45]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You should get the following output:'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.24: The first five rows with the cluster predictions'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.24：前五行与集群预测'
- en: '](img/B15019_05_24.jpg)'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_24.jpg)'
- en: 'Figure 5.24: The first five rows with the cluster predictions'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.24：前五行与集群预测
- en: 'Now plot the scatter plot using the `mark_circle()` and `encode()` methods
    from the `altair` package. Also, to add interactiveness, use the `tooltip` parameter
    and the `interactive()` method from the `altair` package as shown in the following
    code snippet:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用 `altair` 包中的 `mark_circle()` 和 `encode()` 方法绘制散点图。同时，为了增加交互性，使用 `tooltip`
    参数和 `altair` 包中的 `interactive()` 方法，如以下代码片段所示：
- en: '[PRE46]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You should get the following output:'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.25: Scatter plot of the four clusters'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.25：四个集群的散点图'
- en: '](img/B15019_05_25.jpg)'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_25.jpg)'
- en: 'Figure 5.25: Scatter plot of the four clusters'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.25：四个集群的散点图
- en: Note
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3iK1rPQ](https://packt.live/3iK1rPQ).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考 [https://packt.live/3iK1rPQ](https://packt.live/3iK1rPQ)。
- en: This section does not currently have an online interactive example, but can
    be run as usual on Google Colab.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分目前没有在线交互示例，但可以像往常一样在 Google Colab 上运行。
- en: 'You just learned how to find the optimal number of clusters before fitting
    a k-means model. The data points are grouped into four different clusters in our
    output here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学习了如何在拟合 k-means 模型之前找到最优集群数量。数据点在我们的输出中被分成了四个不同的集群：
- en: Cluster 0 (blue) is for all the observations with average total business income
    values lower than 100,000 and average total business expense values lower than
    80,000.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群 0（蓝色）包含所有平均总营业收入低于 100,000 且平均总营业支出低于 80,000 的观察值。
- en: Cluster 1 (orange) is grouping data points that have an average total business
    income value lower than 180,000 and average total business expense values lower
    than 160,000.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 簇 1（橙色）包含那些总商业收入值低于 180,000，且总商业支出值低于 160,000 的数据点。
- en: Cluster 3 (cyan) is for data points that have an average total business income
    value lower than 370,000 and average total business expense values lower than
    330,000.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 簇 3（青色）适用于那些总商业收入值低于 370,000，且总商业支出值低于 330,000 的数据点。
- en: Cluster 2 (red) is for data points with extreme values – those with average
    total business income values higher than 370,000 and average total business expense
    values higher than 330,000.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 簇 2（红色）适用于那些具有极端值的数据点——其总商业收入值高于 370,000，且总商业支出值高于 330,000。
- en: The results from *Exercise 5.02*, *Clustering Australian Postcodes by Business
    Income and Expenses*, have eight different clusters, and some of them are very
    similar to each other. Here, you saw that having the optimal number of clusters
    provides better differentiation between the groups, and this is why it is one
    of the most important hyperparameters to be tuned for k-means. In the next section,
    we will look at two other important hyperparameters for initializing k-means.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*练习 5.02* 中的结果，*根据商业收入和支出对澳大利亚邮政编码进行聚类*，有八个不同的簇，其中一些簇之间非常相似。在这里，你看到拥有最优簇数能更好地区分各个组，这也是为什么它是
    k-means 中最重要的超参数之一。接下来的部分，我们将研究初始化 k-means 时的另外两个重要超参数。'
- en: Initializing Clusters
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化簇
- en: Since the beginning of this chapter, we've been referring to k-means every time
    we've fitted our clustering algorithms. But you may have noticed in each model
    summary that there was a hyperparameter called `init` with the default value as
    k-means++. We were, in fact, using k-means++ all this time.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们每次拟合聚类算法时都提到了 k-means。但你可能已经注意到，在每个模型总结中都有一个叫做 `init` 的超参数，其默认值为 k-means++。事实上，我们一直在使用
    k-means++。
- en: 'The difference between k-means and k-means++ is in how they initialize clusters
    at the start of the training. k-means randomly chooses the center of each cluster
    (called the **centroid**) and then assigns each data point to its nearest cluster.
    If this cluster initialization is chosen incorrectly, this may lead to non-optimal
    grouping at the end of the training process. For example, in the following graph,
    we can clearly see the three natural groupings of the data, but the algorithm
    didn''t succeed in identifying them properly:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: k-means 和 k-means++ 之间的区别在于它们在训练开始时如何初始化簇。k-means 随机选择每个簇的中心（称为**质心**），然后将每个数据点分配到最近的簇。如果簇初始化选择不当，可能会导致训练过程结束时分组不理想。例如，在下图中，我们可以清晰地看到数据的三个自然分组，但算法并未成功地正确识别它们：
- en: '![Figure 5.26: Example of non-optimal clusters being found'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.26：非最优簇的示例'
- en: '](img/B15019_05_26.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_26.jpg)'
- en: 'Figure 5.26: Example of non-optimal clusters being found'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.26：非最优簇的示例
- en: k-means++ is an attempt to find better clusters at initialization time. The
    idea behind it is to choose the first cluster randomly and then pick the next
    ones, those further away, using a probability distribution from the remaining
    data points. Even though k-means++ tends to get better results compared to the
    original k-means, in some cases, it can still lead to non-optimal clustering.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: k-means++ 是一种尝试在初始化时找到更好簇的算法。它的基本思路是随机选择第一个簇，然后通过从剩余的数据点中使用概率分布选择距离更远的其他簇。尽管
    k-means++ 相较于原始的 k-means 通常能得到更好的结果，但在某些情况下，它仍然可能导致不理想的聚类。
- en: Another hyperparameter data scientists can use to lower the risk of incorrect
    clusters is `n_init`. This corresponds to the number of times k-means is run with
    different initializations, the final model being the best run. So, if you have
    a high number for this hyperparameter, you will have a higher chance of finding
    the optimal clusters, but the downside is that the training time will be longer.
    So, you have to choose this value carefully, especially if you have a large dataset.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家可以使用的另一个超参数来降低错误聚类的风险是 `n_init`。这对应于 k-means 运行的次数，每次使用不同的初始化，最终模型是最佳运行结果。因此，如果这个超参数设置得很高，你将有更大的机会找到最优簇，但缺点是训练时间会更长。所以，你必须仔细选择这个值，特别是在数据集较大的情况下。
- en: Let's try this out on our ATO dataset by having a look at the following example.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例在 ATO 数据集上尝试一下。
- en: Note
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Open the notebook you were using for *Exercise 5.01*, *Performing Your First
    Clustering Analysis on the ATO Dataset,* and earlier examples. Execute the code
    you already entered, and then continue at the end of the notebook with the following
    code.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你为*练习5.01*，*对ATO数据集进行第一次聚类分析*，以及之前的示例所用的笔记本。执行你已输入的代码，然后继续执行笔记本末尾的以下代码。
- en: 'First, let''s run only one iteration using random initialization:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们仅使用随机初始化运行一次迭代：
- en: '[PRE47]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As usual, we want to visualize our clusters with a scatter plot, as defined
    in the following code snippet:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，我们希望通过散点图来可视化我们的聚类，正如以下代码片段所定义的那样：
- en: '[PRE48]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You should get the following output:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到以下输出：
- en: '![Figure 5.27: Clustering results with n_init as 1 and init as random'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.27：使用n_init为1和init为random的聚类结果]'
- en: '](img/B15019_05_27.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_27.jpg)'
- en: 'Figure 5.27: Clustering results with n_init as 1 and init as random'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.27：使用n_init为1和init为random的聚类结果
- en: Overall, the result is very close to that of our previous run. It is worth noticing
    that the boundaries between the clusters are slightly different.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来看，结果与我们之前的运行非常接近。值得注意的是，聚类之间的边界略有不同。
- en: 'Now let''s try with five iterations (using the `n_init` hyperparameter) and
    k-means++ initialization (using the `init` hyperparameter):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用五次迭代（通过`n_init`超参数）和k-means++初始化（通过`init`超参数）：
- en: '[PRE49]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You should get the following output:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到以下输出：
- en: '![Figure 5.28: Clustering results with n_init as 5 and init as k-means++'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.28：使用n_init为5和init为k-means++的聚类结果]'
- en: '](img/B15019_05_28.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_28.jpg)'
- en: 'Figure 5.28: Clustering results with n_init as 5 and init as k-means++'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.28：使用n_init为5和init为k-means++的聚类结果
- en: Here, the results are very close to the original run with 10 iterations. This
    means that we didn't have to run so many iterations for k-means to converge and
    could have saved some time with a lower number.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，结果与使用10次迭代的原始运行非常接近。这意味着我们不必运行这么多迭代就能使k-means收敛，本可以通过较少的迭代节省一些时间。
- en: 'Exercise 5.04: Using Different Initialization Parameters to Achieve a Suitable
    Outcome'
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.04：使用不同的初始化参数来获得合适的结果
- en: 'In this exercise, we will use the same data as in *Exercise 5.02*, *Clustering
    Australian Postcodes by Business Income and Expenses*, and try different values
    for the `init` and `n_init` hyperparameters and see how they affect the final
    clustering result:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将使用与*练习5.02*，*按商业收入和支出聚类澳大利亚邮政编码*中相同的数据，并尝试不同的`init`和`n_init`超参数值，观察它们如何影响最终的聚类结果：
- en: Open a new Colab notebook.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Colab笔记本。
- en: 'Import the required packages, which are `pandas`, `sklearn`, and `altair`:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的包，包括`pandas`，`sklearn`和`altair`：
- en: '[PRE50]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Assign the link to the ATO dataset to a variable called `file_url`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ATO数据集的链接赋值给一个名为`file_url`的变量：
- en: '[PRE51]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Load the dataset and select the same columns as in *Exercise 5.02*, *Clustering
    Australian Postcodes by Business Income and Expenses*, and *Exercise 5.03*, *Finding
    the Optimal Number of Clusters*, using the `read_csv()` method from the `pandas`
    package:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载数据集，并选择与*练习5.02*，*按商业收入和支出聚类澳大利亚邮政编码*，以及*练习5.03*，*寻找最佳聚类数*中相同的列，使用`pandas`包中的`read_csv()`方法：
- en: '[PRE52]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Assign the `''Average total business income''` and `''Average total business
    expenses''` columns to a new variable called `X`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`'Average total business income'`和`'Average total business expenses'`列赋值给一个新变量`X`：
- en: '[PRE53]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Fit a k-means model with `n_init` equal to `1` and a random `init`:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`n_init`等于`1`和随机`init`来拟合一个k-means模型：
- en: '[PRE54]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Using the `predict` method from the `sklearn` package, predict the clustering
    assignment from the input variable, `(X)`, and save the results into a new column
    called `''cluster3''` in the DataFrame:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sklearn`包中的`predict`方法，从输入变量`(X)`中预测聚类分配，并将结果保存到名为`'cluster3'`的新列中：
- en: '[PRE55]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Plot the clusters using an interactive scatter plot. First, use `Chart()` and
    `mark_circle()` from the `altair` package to instantiate a scatter plot graph,
    as shown in the following code snippet:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用交互式散点图绘制聚类。首先，使用`altair`包中的`Chart()`和`mark_circle()`来实例化散点图，如以下代码片段所示：
- en: '[PRE56]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Use the `encode` and `interactive` methods from `altair` to specify the display
    of the scatter plot and its interactivity options with the following parameters:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`altair`中的`encode`和`interactive`方法，指定散点图的显示方式及其交互选项，使用以下参数：
- en: Provide the name of the `'Average total business income'` column to the `x`
    parameter (x-axis).
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`'Average total business income'`列的名称传递给`x`参数（x轴）。
- en: Provide the name of the `'Average total business expenses'` column to the `y`
    parameter (y-axis).
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `'Average total business expenses'` 列的名称提供给 `y` 参数（y 轴）。
- en: Provide the name of the `'cluster3:N'` column to the `color` parameter (which
    defines the different colors for each group).
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `'cluster3:N'` 列的名称提供给 `color` 参数（用于定义每个组的不同颜色）。
- en: 'Provide these column names – `''Postcode''`, `''cluster3''`, `''Average total
    business income''`, and `''Average total business expenses''` – to the `tooltip`
    parameter:'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下列名 `'Postcode'`、`'cluster3'`、`'Average total business income'` 和 `'Average
    total business expenses'` 提供给 `tooltip` 参数：
- en: '[PRE57]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You should get the following output:'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.29: Clustering results with n_init as 1 and init as random'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.29：使用 `n_init` 为 1 和 `init` 为随机的聚类结果'
- en: '](img/B15019_05_29.jpg)'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_29.jpg)'
- en: 'Figure 5.29: Clustering results with n_init as 1 and init as random'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.29：使用 `n_init` 为 1 和 `init` 为随机的聚类结果
- en: 'Repeat *Steps 5* to *8* but with different k-means hyperparameters, `n_init=10`
    and random `init`, as shown in the following code snippet:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤 5* 到 *步骤 8*，但使用不同的 k-means 超参数 `n_init=10` 和随机 `init`，如以下代码片段所示：
- en: '[PRE58]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You should get the following output:'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.30: Clustering results with n_init as 10 and init as random'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.30：使用 `n_init` 为 10 和 `init` 为随机的聚类结果'
- en: '](img/B15019_05_30.jpg)'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_30.jpg)'
- en: 'Figure 5.30: Clustering results with n_init as 10 and init as random'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.30：使用 `n_init` 为 10 和 `init` 为随机的聚类结果
- en: 'Again, repeat *Steps 5* to *8* but with different k-means hyperparameters –
    `n_init=100` and random `init`:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次重复 *步骤 5* 到 *步骤 8*，但使用不同的 k-means 超参数 — `n_init=100` 和随机 `init`：
- en: '[PRE59]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You should get the following output:'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.31: Clustering results with n_init as 10 and init as random'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.31：使用 `n_init` 为 10 和 `init` 为随机的聚类结果'
- en: '](img/B15019_05_31.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_31.jpg)'
- en: 'Figure 5.31: Clustering results with n_init as 10 and init as random'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.31：使用 `n_init` 为 10 和 `init` 为随机的聚类结果
- en: Note
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/315yGqP](https://packt.live/315yGqP).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考 [https://packt.live/315yGqP](https://packt.live/315yGqP)。
- en: This section does not currently have an online interactive example, but can
    be run as usual on Google Colab.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 本节目前没有在线交互示例，但可以像往常一样在 Google Colab 上运行。
- en: You just learned how to tune the two main hyperparameters responsible for initializing
    k-means clusters. You have seen in this exercise that increasing the number of
    iterations with `n_init` didn't have much impact on the clustering result for
    this dataset.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学会了如何调整负责初始化 k-means 聚类的两个主要超参数。你在这个练习中看到，增加 `n_init` 的迭代次数对这个数据集的聚类结果影响不大。
- en: In this case, it is better to use a lower value for this hyperparameter as it
    will speed up the training time. But for a different dataset, you may face a case
    where the results differ drastically depending on the `n_init` value. In such
    a case, you will have to find a value of `n_init` that is not too small but also
    not too big. You want to find the sweet spot where the results do not change much
    compared to the last result obtained with a different value.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最好使用较低的超参数值，因为这将加速训练时间。但对于不同的数据集，你可能会遇到一个案例，其中结果会根据 `n_init` 值的不同而发生巨大变化。在这种情况下，你需要找到一个既不太小也不太大的
    `n_init` 值。你想找到一个最佳值，使得结果与之前使用不同值获得的结果相比变化不大。
- en: Calculating the Distance to the Centroid
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算到质心的距离
- en: 'We''ve talked a lot about similarities between data points in the previous
    sections, but we haven''t really defined what this means. You have probably guessed
    that it has something to do with how close or how far observations are from each
    other. You are heading in the right direction. It has to do with some sort of
    distance measure between two points. The one used by k-means is called **squared
    Euclidean distance** and its formula is:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中讨论了数据点之间的相似性，但实际上并没有定义这意味着什么。你可能已经猜到，这与观察值彼此之间的接近程度或远离程度有关。你猜对了。这与两点之间某种距离的度量有关。k-means
    使用的距离度量称为 **平方欧几里得距离**，其公式为：
- en: '![Figure 5.32: The squared Euclidean distance formula'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.32：平方欧几里得距离公式'
- en: '](img/B15019_05_32.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_32.jpg)'
- en: 'Figure 5.32: The squared Euclidean distance formula'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.32：平方欧几里得距离公式
- en: If you don't have a statistical background, this formula may look intimidating,
    but it is actually very simple. It is the sum of the squared difference between
    the data coordinates. Here, *x* and *y* are two data points and the index, *i*,
    represents the number of coordinates. If the data has two dimensions, *i* equals
    2\. Similarly, if there are three dimensions, then *i* will be 3.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有统计学背景，这个公式可能看起来有点吓人，但实际上它非常简单。它是数据坐标之间平方差的总和。这里，*x*和*y*是两个数据点，索引*i*表示坐标的数量。如果数据是二维的，*i*等于2。同样，如果是三维数据，*i*将是3。
- en: Let's apply this formula to the ATO dataset.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此公式应用于ATO数据集。
- en: 'First, we will grab the values needed – that is, the coordinates from the first
    two observations – and print them:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将抓取所需的值——也就是来自前两个观测值的坐标——并打印出来：
- en: Note
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Open the notebook you were using for *Exercise 5.01*, *Performing Your First
    Clustering Analysis on the ATO Dataset*, and earlier examples. Execute the code
    you already entered, and then continue at the end of the notebook with the following
    code.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你在*练习 5.01*中使用的笔记本，*在ATO数据集上执行第一次聚类分析*，以及之前的示例。执行你已经输入的代码，然后在笔记本的末尾继续输入以下代码。
- en: '[PRE60]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You should get the following output:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.33: Extracting the first two observations from the ATO dataset'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.33：从ATO数据集中提取前两个观测值](img/B15019_05_33.jpg)'
- en: '](img/B15019_05_33.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_33.jpg)'
- en: 'Figure 5.33: Extracting the first two observations from the ATO dataset'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.33：从ATO数据集中提取前两个观测值
- en: Note
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In pandas, the `iloc` method is used to subset the rows or columns of a DataFrame
    by index. For instance, if we wanted to grab row number 888 and column number
    6, we would use the following syntax: `dataframe.iloc[888, 6]`.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在pandas中，`iloc`方法用于通过索引子集化DataFrame的行或列。例如，如果我们想获取第888行和第6列，我们可以使用以下语法：`dataframe.iloc[888,
    6]`。
- en: 'The coordinates for `x` are `(27555, 2071)` and the coordinates for `y` are
    `(28142, 3804)`. Here, the formula is telling us to calculate the squared difference
    between each axis of the two data points and sum them:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`的坐标是`(27555, 2071)`，`y`的坐标是`(28142, 3804)`。这里，公式告诉我们计算两个数据点在每个坐标轴上的平方差并将它们相加：'
- en: '[PRE61]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You should get the following output:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE62]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'k-means uses this metric to calculate the distance between each data point
    and the center of its assigned cluster (also called the centroid). Here is the
    basic logic behind this algorithm:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: k-means使用此度量计算每个数据点与其分配的聚类中心（也称为质心）之间的距离。以下是该算法的基本逻辑：
- en: Choose the centers of the clusters (the centroids) randomly.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机选择聚类的中心（质心）。
- en: Assign each data point to the nearest centroid using the squared Euclidean distance.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用平方欧几里得距离将每个数据点分配给最近的质心。
- en: Update each centroid's coordinates to the newly calculated center of the data
    points assigned to it.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新每个质心的坐标为分配给它的数据点的新计算中心。
- en: Repeat *Steps 2* and *3* until the clusters converge (that is, until the cluster
    assignment doesn't change anymore) or until the maximum number of iterations has
    been reached.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤 2*和*步骤 3*，直到聚类收敛（即直到聚类分配不再变化）或直到达到最大迭代次数为止。
- en: That's it. The k-means algorithm is as simple as that. We can extract the centroids
    after fitting a k-means model with `cluster_centers_`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。k-means算法就是这么简单。我们可以在拟合k-means模型后，通过`cluster_centers_`提取质心。
- en: Let's see how we can plot the centroids in an example.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在一个示例中绘制质心。
- en: 'First, we fit a k-means model as shown in the following code snippet:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们拟合一个k-means模型，如以下代码片段所示：
- en: '[PRE63]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now extract the `centroids` into a DataFrame and print them:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将`centroids`提取到一个DataFrame并打印出来：
- en: '[PRE64]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You should get the following output:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.34: Coordinates of the three centroids'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.34：三个质心的坐标](img/B15019_05_33.jpg)'
- en: '](img/B15019_05_34.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_34.jpg)'
- en: 'Figure 5.34: Coordinates of the three centroids'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.34：三个质心的坐标
- en: 'We will plot the usual scatter plot but will assign it to a variable called
    `chart1`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制常规的散点图，但将其分配给一个名为`chart1`的变量：
- en: '[PRE65]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You should get the following output:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.35: Scatter plot of the clusters'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.35：聚类的散点图](img/B15019_05_35.jpg)'
- en: '](img/B15019_05_35.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_35.jpg)'
- en: 'Figure 5.35: Scatter plot of the clusters'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.35：聚类的散点图
- en: 'Now, to create a second scatter plot only for the centroids called `chart2`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为质心创建第二个散点图，命名为`chart2`：
- en: '[PRE66]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You should get the following output:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.36: Scatter plot of the centroids'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.36：质心的散点图](img/B15019_05_36.jpg)'
- en: '](img/B15019_05_36.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_36.jpg)'
- en: 'Figure 5.36: Scatter plot of the centroids'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.36：质心的散点图
- en: 'And now we combine the two charts, which is extremely easy with `altair`:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将这两个图表组合在一起，使用`altair`非常简单：
- en: '[PRE67]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You should get the following output:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到如下输出：
- en: '![Figure 5.37: Scatter plot of the clusters and their centroids'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.37：簇及其质心的散点图'
- en: '](img/B15019_05_37.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_37.jpg)'
- en: 'Figure 5.37: Scatter plot of the clusters and their centroids'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.37：簇及其质心的散点图
- en: Now we can easily see which centroids the observations are closest to.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松地看到观测值最接近哪些质心。
- en: 'Exercise 5.05: Finding the Closest Centroids in Our Dataset'
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.05：寻找我们数据集中的最近质心
- en: 'In this exercise, we will be coding the first iteration of k-means in order
    to assign data points to their closest cluster centroids. The following steps
    will help you complete the exercise:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将编写k-means的第一轮代码，以将数据点分配给它们最近的簇质心。以下步骤将帮助你完成练习：
- en: Open a new Colab notebook.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Colab笔记本。
- en: 'Now `import` the required packages, which are `pandas`, `sklearn`, and `altair`:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`import`所需的包，它们是`pandas`、`sklearn`和`altair`：
- en: '[PRE68]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Load the dataset and select the same columns as in *Exercise 5.02*, *Clustering
    Australian Postcodes by Business Income and Expenses*, using the `read_csv()`
    method from the `pandas` package:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载数据集，并选择与*练习 5.02*、*按商业收入和支出对澳大利亚邮政编码进行聚类*中相同的列，使用`pandas`包中的`read_csv()`方法：
- en: '[PRE69]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Assign the `''Average total business income''` and `''Average total business
    expenses''` columns to a new variable called `X`:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`'Average total business income'`和`'Average total business expenses'`列赋值给一个名为`X`的新变量：
- en: '[PRE70]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, calculate the minimum and maximum using the `min()` and `max()` values
    of the `''Average total business income''` and `''Average total business income''`
    variables, as shown in the following code snippet:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，计算`'Average total business income'`和`'Average total business income'`变量的最小值和最大值，使用`min()`和`max()`方法，如下代码片段所示：
- en: '[PRE71]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Print the values of these four variables, which are the minimum and maximum
    values of the two variables:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印这四个变量的值，它们是这两个变量的最小值和最大值：
- en: '[PRE72]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You should get the following output:'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到如下输出：
- en: '[PRE73]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now import the `random` package and use the `seed()` method to set a seed of
    `42`, as shown in the following code snippet:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在导入`random`包并使用`seed()`方法将种子设置为`42`，如下代码片段所示：
- en: '[PRE74]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Create an empty pandas DataFrame and assign it to a variable called `centroids`:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的pandas数据框，并将其赋值给名为`centroids`的变量：
- en: '[PRE75]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Generate four random values using the `sample()` method from the `random` package
    with possible values between the minimum and maximum values of the `''Average
    total business expenses''` column using `range()` and store the results in a new
    column called `''Average total business income''` from the `centroids` DataFrame:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`random`包中的`sample()`方法生成四个随机值，可能的取值范围在 `'Average total business expenses'`
    列的最小值和最大值之间，使用`range()`，并将结果存储在名为 `'Average total business income'` 的新列中，该列位于`centroids`数据框中：
- en: '[PRE76]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Repeat the same process to generate `4` random values for `''Average total
    business expenses''`:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复相同的过程，为`'Average total business expenses'`生成`4`个随机值：
- en: '[PRE77]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Create a new column called `''cluster''` from the `centroids` DataFrame using
    the `.index` attributes from the pandas package and print this DataFrame:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用pandas包中的`.index`属性从`centroids`数据框中创建一个名为`'cluster'`的新列，并打印该数据框：
- en: '[PRE78]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You should get the following output:'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到如下输出：
- en: '![Figure 5.38: Coordinates of the four random centroids'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.38：四个随机质心的坐标'
- en: '](img/B15019_05_38.jpg)'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_38.jpg)'
- en: 'Figure 5.38: Coordinates of the four random centroids'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.38：四个随机质心的坐标
- en: 'Create a scatter plot with the `altair` package to display the data contained
    in the `df` DataFrame and save it in a variable called `''chart1''`:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`altair`包创建一个散点图，显示`df`数据框中的数据，并将其保存在名为`'chart1'`的变量中：
- en: '[PRE79]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now create a second scatter plot using the `altair` package to display the
    centroids and save it in a variable called `''chart2''`:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`altair`包创建第二个散点图，显示质心，并将其保存在名为`'chart2'`的变量中：
- en: '[PRE80]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Display the two charts together using the altair syntax: `<chart> + <chart>`:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用altair语法将两个图表显示在一起：`<chart> + <chart>`：
- en: '[PRE81]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You should get the following output:'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到如下输出：
- en: '![Figure 5.39: Scatter plot of the random centroids and the first five observations'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.39：随机质心和前五个观测值的散点图'
- en: '](img/B15019_05_39.jpg)'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_39.jpg)'
- en: 'Figure 5.39: Scatter plot of the random centroids and the first five observations'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.39：随机质心和前五个观测值的散点图
- en: 'Define a function that will calculate the `squared_euclidean` distance and
    return its value. This function will take the `x` and `y` coordinates of a data
    point and a centroid:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，用于计算 `squared_euclidean` 距离并返回其值。此函数将接受一个数据点的 `x` 和 `y` 坐标以及一个质心：
- en: '[PRE82]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Using the `.at` method from the pandas package, extract the first row''s `x`
    and `y` coordinates and save them in two variables called `data_x` and `data_y`:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 pandas 包的 `.at` 方法，提取第一行的 `x` 和 `y` 坐标，并将其保存在两个变量 `data_x` 和 `data_y` 中：
- en: '[PRE83]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Using a `for` loop or list comprehension, calculate the `squared_euclidean`
    distance of the first observation (using its `data_x` and `data_y` coordinates)
    against the `4` different centroids contained in `centroids`, save the result
    in a variable called `distance`, and display it:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `for` 循环或列表推导，计算第一条观测值（使用其 `data_x` 和 `data_y` 坐标）与 `centroids` 中 `4` 个不同质心的
    `squared_euclidean` 距离，将结果保存在名为 `distance` 的变量中并显示出来：
- en: '[PRE84]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You should get the following output:'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE85]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Use the `index` method from the list containing the `squared_euclidean` distances
    to find the cluster with the shortest distance, as shown in the following code
    snippet:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用包含 `squared_euclidean` 距离的列表的 `index` 方法，找到距离最短的簇，如以下代码片段所示：
- en: '[PRE86]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Save the `cluster` index in a column called `''cluster''` from the `df` DataFrame
    for the first observation using the `.at` method from the pandas package:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 pandas 包的 `.at` 方法，在 `df` 数据框中为第一条观测值将 `cluster` 索引保存在名为 `'cluster'` 的列中：
- en: '[PRE87]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Display the first five rows of `df` using the `head()` method from the `pandas`
    package:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 pandas 包的 `head()` 方法显示 `df` 的前五行：
- en: '[PRE88]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You should get the following output:'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.40: The first five rows of the ATO DataFrame with the assigned'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.40：ATO 数据框前五行的分配'
- en: cluster number for the first row
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一行的簇编号
- en: '](img/B15019_05_40.jpg)'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_40.jpg)'
- en: 'Figure 5.40: The first five rows of the ATO DataFrame with the assigned cluster
    number for the first row'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.40：ATO 数据框前五行及其分配的第一行簇编号
- en: 'Repeat *Steps 15* to *19* for the next `4` rows to calculate their distances
    from the centroids and find the cluster with the smallest distance value:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤 15*至*步骤 19*，对接下来的 `4` 行计算它们与质心的距离，并找出距离值最小的簇：
- en: '[PRE89]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'You should get the following output:'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.41: The first five rows of the ATO DataFrame and their assigned
    clusters'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.41：ATO 数据框的前五行及其分配的簇'
- en: '](img/B15019_05_41.jpg)'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_41.jpg)'
- en: 'Figure 5.41: The first five rows of the ATO DataFrame and their assigned clusters'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.41：ATO 数据框的前五行及其分配的簇
- en: 'Finally, plot the centroids and the first `5` rows of the dataset using the
    `altair` package as in *Steps 12* to *13*:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 `altair` 包绘制质心和数据集的前 `5` 行，如*步骤 12*至*步骤 13*所示：
- en: '[PRE90]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'You should get the following output:'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.42: Scatter plot of the random centroids and the first five observations'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.42：随机质心和前五条观测值的散点图'
- en: '](img/B15019_05_42.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_42.jpg)'
- en: 'Figure 5.42: Scatter plot of the random centroids and the first five observations'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.42：随机质心和前五条观测值的散点图
- en: Note
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3iPQo7L](https://packt.live/3iPQo7L).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考 [https://packt.live/3iPQo7L](https://packt.live/3iPQo7L)。
- en: This section does not currently have an online interactive example, but can
    be run as usual on Google Colab.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 本节目前没有在线互动示例，但可以在 Google Colab 上正常运行。
- en: 'In this final result, we can see where the four clusters have been placed in
    the graph and which cluster the five data points have been assigned to:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最终结果中，我们可以看到四个簇在图中的位置，以及五个数据点被分配到哪个簇：
- en: The two data points in the bottom-left corner have been assigned to cluster
    2, which corresponds to the one with a centroid of coordinates of 26,000 (average
    total business income) and 234,000 (average total business expense). It is the
    closest centroid for these two points.
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左下角的两个数据点已分配给簇 2，该簇的质心坐标为 26,000（平均总商业收入）和 234,000（平均总商业支出）。对于这两个点，它是最接近的质心。
- en: The two observations in the middle are very close to the centroid with coordinates
    of 116,000 (average total business income) and 256,000 (average total business
    expense), which corresponds to cluster 1.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间的两个观测值非常接近坐标为 116,000（平均总商业收入）和 256,000（平均总商业支出）的质心，该质心对应簇 1。
- en: The observation at the top has been assigned to cluster 0, whose centroid has
    coordinates of 670,000 (average total business income) and 288,000 (average total
    business expense).
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上方的观察数据被分配到了聚类0，该聚类的质心坐标为670,000（平均总营业收入）和288,000（平均总营业支出）。
- en: You just re-implemented a big part of the k-means algorithm from scratch. You
    went through how to randomly initialize centroids (cluster centers), calculate
    the squared Euclidean distance for some data points, find their closest centroid,
    and assign them to the corresponding cluster. This wasn't easy, but you made it.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚重新实现了k-means算法的大部分内容。你了解了如何随机初始化质心（聚类中心）、计算某些数据点的平方欧几里得距离、找到它们最近的质心并将它们分配到相应的聚类中。这并不容易，但你做到了。
- en: Standardizing Data
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准化数据
- en: 'You''ve already learned a lot about the k-means algorithm, and we are close
    to the end of this chapter. In this final section, we will not talk about another
    hyperparameter (you''ve already been through the main ones) but a very important
    topic: **data processing**.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学到了很多关于k-means算法的内容，我们也接近本章的结尾了。在这一节，我们将不讨论另一个超参数（你已经学习过主要的超参数），而是一个非常重要的话题：**数据处理**。
- en: Fitting a k-means algorithm is extremely easy. The trickiest part is making
    sure the resulting clusters are meaningful for your project, and we have seen
    how we can tune some hyperparameters to ensure this. But handling input data is
    as important as all the steps you have learned about so far. If your dataset is
    not well prepared, even if you find the best hyperparameters, you will still get
    some bad results.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 拟合k-means算法非常简单。最棘手的部分是确保得到的聚类对你的项目有意义，我们已经看到如何调整一些超参数来确保这一点。但处理输入数据和你迄今为止学到的所有步骤一样重要。如果你的数据集没有很好地准备，即使你找到了最佳的超参数，你依然会得到不好的结果。
- en: Let's have another look at our ATO dataset. In the previous section, *Calculating
    the Distance to the Centroid*, we found three different clusters, and they were
    mainly defined by the `'Average net tax'` variable. It was as if k-means didn't
    take into account the second variable, `'Average total deductions'`, at all. This
    is in fact due to these two variables having very different ranges of values and
    the way that squared Euclidean distance is calculated.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看我们的ATO数据集。在上一节中，*计算到质心的距离*，我们发现了三个不同的聚类，它们主要是由`'平均净税额'`变量定义的。就好像k-means完全没有考虑到第二个变量`'平均总扣除额'`。实际上，这是因为这两个变量具有非常不同的值范围，以及平方欧几里得距离的计算方式。
- en: 'Squared Euclidean distance is weighted more toward high-value variables. Let''s
    take an example to illustrate this point with two data points called A and B with
    respective x and y coordinates of (1, 50000) and (100, 100000). The squared Euclidean
    distance between A and B will be (100000 - 50000)^2 + (100 - 1)^2\. We can clearly
    see that the result will be mainly driven by the difference between 100,000 and
    50,000: 50,000^2\. The difference of 100 minus 1 (99^2) will account for very
    little in the final result.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 平方欧几里得距离对高值变量的加权影响较大。让我们通过一个例子来说明这一点，假设有两个数据点A和B，分别具有坐标(1, 50000)和(100, 100000)。A和B之间的平方欧几里得距离将是(100000
    - 50000)^2 + (100 - 1)^2。我们可以清楚地看到，结果将主要受到100,000与50,000差异的驱动：50,000^2。而100与1的差异（99^2）在最终结果中的影响微乎其微。
- en: But if you look at the ratio between 100,000 and 50,000, it is a factor of 2
    (100,000 / 50,000 = 2), while the ratio between 100 and 1 is a factor of 100 (100
    / 1 = 100). Does it make sense for the higher-value variable to "dominate" the
    clustering result? It really depends on your project, and this situation may be
    intended. But if you want things to be fair between the different axes, it's preferable
    to bring them all into a similar range of values before fitting a k-means model.
    This is the reason why you should always consider standardizing your data before
    running your k-means algorithm.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你看一下100,000与50,000的比值，它是一个2的倍数（100,000 / 50,000 = 2），而100与1的比值是100的倍数（100
    / 1 = 100）。对于数值较大的变量“主导”聚类结果是否有意义呢？这真的取决于你的项目，这种情况可能是故意的。但如果你希望不同轴之间的结果公平，最好在拟合k-means模型之前将它们标准化到一个相似的数值范围。这就是为什么在运行k-means算法之前，你总是需要考虑标准化数据的原因。
- en: 'There are multiple ways to standardize data, and we will have a look at the
    two most popular ones: `sklearn` package has an implementation for both methods.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以对数据进行标准化，我们将重点介绍两种最常用的方法：`sklearn`库中实现了这两种方法。
- en: 'The formula for min-max scaling is very simple: on each axis, you need to remove
    the minimum value for each data point and divide the result by the difference
    between the maximum and minimum values. The scaled data will have values ranging
    between 0 and 1:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 最小-最大标准化的公式非常简单：在每个轴上，你需要将每个数据点的最小值减去，并将结果除以最大值和最小值之间的差异。标度化后的数据将在0到1之间：
- en: '![Figure 5.43: Min-max scaling formula'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.43：最小-最大标准化公式'
- en: '](img/B15019_05_43.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_43.jpg)'
- en: 'Figure 5.43: Min-max scaling formula'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.43：最小-最大标准化公式
- en: Let's look at min-max scaling with `sklearn` in the following example.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在下面的示例中使用`sklearn`进行最小-最大标准化。
- en: Note
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Open the notebook you were using for *Exercise 5.01*, *Performing Your First
    Clustering Analysis on the ATO Dataset*, and earlier examples. Execute the code
    you already entered, and then continue at the end of the notebook with the following
    code.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你用于*练习5.01*，*在ATO数据集上执行你的第一个聚类分析*和之前的例子的笔记本。执行你已经输入的代码，然后继续在笔记本的末尾使用以下代码。
- en: 'First, we import the relevant class and instantiate an object:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入相关的类并实例化一个对象：
- en: '[PRE91]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Then, we fit it to our dataset:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将其适配到我们的数据集中：
- en: '[PRE92]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'You should get the following output:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该获得以下输出：
- en: '![Figure 5.44: Min-max scaling summary'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.44：最小-最大标准化摘要'
- en: '](img/B15019_05_44.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_44.jpg)'
- en: 'Figure 5.44: Min-max scaling summary'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.44：最小-最大标准化摘要
- en: 'And finally, call the `transform()` method to standardize the data:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`transform()`方法来标准化数据：
- en: '[PRE93]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'You should get the following output:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该获得以下输出：
- en: '![Figure 5.45: Min-max-scaled data'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.45：最小-最大标准化数据'
- en: '](img/B15019_05_45.jpg)'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_45.jpg)'
- en: 'Figure 5.45: Min-max-scaled data'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.45：最小-最大标准化数据
- en: 'Now we print the minimum and maximum values of the min-max-scaled data for
    both axes:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们打印最小和最大值的最小-最大标准化数据的每个轴：
- en: '[PRE94]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'You should get the following output:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该获得以下输出：
- en: '![Figure 5.46: Minimum and maximum values of the min-max-scaled data'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.46：最小和最大值的最小-最大标准化数据'
- en: '](img/B15019_05_46.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_46.jpg)'
- en: 'Figure 5.46: Minimum and maximum values of the min-max-scaled data'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.46：最小和最大值的最小-最大标准化数据
- en: We can see that both axes now have their values sitting between 0 and 1.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到现在两个轴的值都在0到1之间。
- en: 'The **z-score** is calculated by removing the overall average from the data
    point and dividing the result by the standard deviation for each axis. The distribution
    of the standardized data will have a mean of 0 and a standard deviation of 1:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '**z-score**是通过将数据点从总体平均值中移除并将结果除以每个轴的标准差来计算的。标准化数据的分布将具有平均值为0和标准差为1：'
- en: '![Figure 5.47: Z-score formula'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.47：Z-score公式'
- en: '](img/B15019_05_47.jpg)'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_47.jpg)'
- en: 'Figure 5.47: Z-score formula'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.47：Z-score公式
- en: 'To apply it with `sklearn`, first, we have to import the relevant `StandardScaler`
    class and instantiate an object:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`sklearn`中应用它，首先我们必须导入相关的`StandardScaler`类并实例化一个对象：
- en: '[PRE95]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This time, instead of calling `fit()` and then `transform()`, we use the `fit_transform()`
    method:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不再调用`fit()`然后调用`transform()`，而是使用`fit_transform()`方法：
- en: '[PRE96]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You should get the following output:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该获得以下输出：
- en: '![Figure 5.48: Z-score-standardized data'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.48：Z-score标准化数据'
- en: '](img/B15019_05_48.jpg)'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_48.jpg)'
- en: 'Figure 5.48: Z-score-standardized data'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.48：Z-score标准化数据
- en: 'Now we''ll look at the minimum and maximum values for each axis:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看每个轴的最小和最大值：
- en: '[PRE97]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You should get the following output:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该获得以下输出：
- en: '![Figure 5.49: Minimum and maximum values of the z-score-standardized data'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.49：Z-score标准化数据的最小和最大值'
- en: '](img/B15019_05_49.jpg)'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_49.jpg)'
- en: 'Figure 5.49: Minimum and maximum values of the z-score-standardized data'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.49：Z-score标准化数据的最小和最大值
- en: The value ranges for both axes are much lower now and we can see that their
    maximum values are around 9 and 18, which indicates that there are some extreme
    outliers in the data.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个轴的值域大大降低，我们可以看到它们的最大值约为9和18，这表明数据中存在一些极端异常值。
- en: 'Now, to fit a k-means model and plot a scatter plot on the z-score-standardized
    data with the following code snippet:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下代码片段拟合k-means模型并在Z-score标准化数据上绘制散点图：
- en: '[PRE98]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You should get the following output:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该获得以下输出：
- en: '![Figure 5.50: Scatter plot of the standardized data'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.50：标准化数据的散点图'
- en: '](img/B15019_05_50.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_50.jpg)'
- en: 'Figure 5.50: Scatter plot of the standardized data'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.50：标准化数据的散点图
- en: k-means results are very different from the standardized data. Now we can see
    that there are two main clusters (blue and red) and their boundaries are not straight
    vertical lines anymore but diagonal. So, k-means is actually taking into consideration
    both axes now. The orange cluster contains much fewer data points compared to
    previous iterations, and it seems it is grouping all the extreme outliers with
    high values together. If your project was about detecting anomalies, you would
    have found a way here to easily separate outliers from "normal" observations.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: k-means结果与标准化数据有很大的不同。现在我们可以看到有两个主要的簇（蓝色和红色），它们的边界不再是直的垂直线，而是对角线。所以，k-means现在实际上考虑了两个轴。橙色簇包含的数据点比之前的迭代要少得多，似乎它将所有高值的极端异常值都归为一组。如果你的项目是关于检测异常的，你可以在这里找到一种方法，轻松将异常值与“正常”观测值分离。
- en: 'Exercise 5.06: Standardizing the Data from Our Dataset'
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '练习 5.06: 标准化我们的数据集中的数据'
- en: 'In this final exercise, we will standardize the data using min-max scaling
    and the z-score and fit a k-means model for each method and see their impact on
    k-means:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最终练习中，我们将使用最小-最大缩放和z-score标准化来标准化数据，并为每种方法拟合一个k-means模型，查看它们对k-means的影响：
- en: Open a new Colab notebook.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Colab笔记本。
- en: 'Now import the required `pandas`, `sklearn`, and `altair` packages:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在导入所需的`pandas`、`sklearn`和`altair`包：
- en: '[PRE99]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Load the dataset and select the same columns as in *Exercise 5.02*, *Clustering
    Australian Postcodes by Business Income and Expenses*, using the `read_csv()`
    method from the `pandas` package:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载数据集并选择与*练习 5.02*中相同的列，*通过商业收入和支出对澳大利亚邮政编码进行聚类*，使用`pandas`包中的`read_csv()`方法：
- en: '[PRE100]'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Assign the `''Average total business income''` and `''Average total business
    expenses''` columns to a new variable called `X`:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`'Average total business income'`和`'Average total business expenses'`列分配给一个名为`X`的新变量：
- en: '[PRE101]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Import the `MinMaxScaler` and `StandardScaler` classes from `sklearn`:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`sklearn`导入`MinMaxScaler`和`StandardScaler`类：
- en: '[PRE102]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Instantiate and fit `MinMaxScaler` with the data:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化并用数据拟合`MinMaxScaler`：
- en: '[PRE103]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You should get the following output:'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.51: Summary of the min-max scaler'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.51: 最小-最大缩放器总结'
- en: '](img/B15019_05_51.jpg)'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_51.jpg)'
- en: 'Figure 5.51: Summary of the min-max scaler'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '图 5.51: 最小-最大缩放器总结'
- en: 'Perform the min-max scaling transformation and save the data into a new variable
    called `X_min_max`:'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行最小-最大缩放变换并将数据保存到一个新变量`X_min_max`中：
- en: '[PRE104]'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'You should get the following output:'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.52: Min-max-scaled data'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.52: 最小-最大缩放后的数据'
- en: '](img/B15019_05_52.jpg)'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_52.jpg)'
- en: 'Figure 5.52: Min-max-scaled data'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '图 5.52: 最小-最大缩放后的数据'
- en: 'Fit a k-means model on the scaled data with the following hyperparameters:
    `random_state=1`, `n_clusters=4, init=''k-means++'', n_init=5`, as shown in the
    following code snippet:'
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在缩放后的数据上拟合一个k-means模型，使用以下超参数：`random_state=1`, `n_clusters=4, init='k-means++',
    n_init=5`，如下所示的代码片段：
- en: '[PRE105]'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Assign the k-means predictions of each value of `X` in a new column called
    `''cluster8''` in the `df` DataFrame:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`df`数据框中为`X`的每个值分配k-means预测到一个新列，名为`'cluster8'`：
- en: '[PRE106]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Plot the k-means results into a scatter plot using the `altair` package:'
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`altair`包将k-means结果绘制成散点图：
- en: '[PRE107]'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'You should get the following output:'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.53: Scatter plot of k-means results using the min-max-scaled data'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.53: 使用最小-最大缩放后的数据的k-means结果散点图'
- en: '](img/B15019_05_53.jpg)'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_53.jpg)'
- en: 'Figure 5.53: Scatter plot of k-means results using the min-max-scaled data'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '图 5.53: 使用最小-最大缩放后的数据的k-means结果散点图'
- en: 'Re-train the k-means model but on the z-score-standardized data with the same
    hyperparameter values, `random_state=1, n_clusters=4, init=''k-means++'', n_init=5`:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新训练k-means模型，但使用z-score标准化后的数据，并保持相同的超参数值，`random_state=1, n_clusters=4, init='k-means++',
    n_init=5`：
- en: '[PRE108]'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Assign the k-means predictions of each value of `X_scaled` in a new column
    called `''cluster9''` in the `df` DataFrame:'
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`df`数据框中为`X_scaled`的每个值分配k-means预测到一个新列，名为`'cluster9'`：
- en: '[PRE109]'
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Plot the k-means results in a scatter plot using the `altair` package:'
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`altair`包绘制k-means结果的散点图：
- en: '[PRE110]'
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'You should get the following output:'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 5.54: Scatter plot of k-means results using the z-score-standardized
    data'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.54: 使用z-score标准化数据的k-means结果散点图'
- en: '](img/B15019_05_54.jpg)'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_05_54.jpg)'
- en: 'Figure 5.54: Scatter plot of k-means results using the z-score-standardized
    data'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '图 5.54: 使用z-score标准化数据的k-means结果散点图'
- en: Note
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Q2BSND](https://packt.live/2Q2BSND).
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 若要访问此特定部分的源代码，请参考 [https://packt.live/2Q2BSND](https://packt.live/2Q2BSND)。
- en: This section does not currently have an online interactive example, but can
    be run as usual on Google Colab.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 本节目前没有在线互动示例，但可以像往常一样在Google Colab上运行。
- en: 'The k-means clustering results are very similar between min-max and z-score
    standardization, which are the outputs for *Steps 10* and *13*. Compared to the
    results in *Exercise 5.04*, *Using Different Initialization Parameters to Achieve
    a Suitable Outcome*, we can see that the boundaries between clusters 1 and 2 are
    slightly lower after standardization. The reason why these results are very close
    to each other is due to the fact that the range of values for the two variables
    (average total business income and average total business expenses) are almost
    identical: between 0 and 900,000\. Therefore, k-means is not putting more weight
    toward one of these variables.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: k-means聚类结果在min-max标准化和z-score标准化之间非常相似，它们分别是*步骤10*和*13*的输出。与*练习5.04*中使用不同初始化参数以实现合适结果的对比，我们可以看到，标准化后，第1类和第2类之间的边界略微下降。结果如此接近的原因在于，这两个变量（平均总营业收入和平均总营业支出）的数值范围几乎相同：介于0和900,000之间。因此，k-means并没有给予这两个变量其中之一更多的权重。
- en: 'You''ve completed the final exercise of this chapter. You have learned how
    to preprocess data before fitting a k-means model with two very popular methods:
    min-max scaling and z-score.'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 你已完成本章的最终练习。你已经学会了如何在拟合k-means模型之前使用两种非常流行的方法来预处理数据：min-max缩放和z-score标准化。
- en: 'Activity 5.01: Perform Customer Segmentation Analysis in a Bank Using k-means'
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动5.01：使用k-means在银行中执行客户细分分析
- en: You are working for an international bank. The credit department is reviewing
    its offerings and wants to get a better understanding of its current customers.
    You have been tasked with performing customer segmentation analysis. You will
    perform cluster analysis with k-means to identify groups of similar customers.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在为一家国际银行工作。信用部门正在审查其产品，并希望更好地了解当前的客户。你被分配了进行客户细分分析的任务。你将使用k-means聚类分析来识别相似客户的群体。
- en: 'The following steps will help you complete this activity:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成此活动：
- en: Download the dataset and load it into Python.
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载数据集并将其加载到Python中。
- en: Read the CSV file using the `read_csv()` method.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`read_csv()`方法读取CSV文件。
- en: Note
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'This dataset is in the `.dat` file format. You can still load the file using
    `read_csv()` but you will need to specify the following parameter: `header=None,
    sep= ''\s\s+'' and prefix=''X''`.'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该数据集采用`.dat`文件格式。你仍然可以使用`read_csv()`加载文件，但需要指定以下参数：`header=None, sep= '\s\s+'
    和 prefix='X'`。
- en: You will be using the fourth and tenth columns (`X3` and `X9`). Extract these.
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将使用第四列和第十列（`X3`和`X9`）。提取这些数据。
- en: Perform data standardization by instantiating a `StandardScaler` object.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实例化`StandardScaler`对象来执行数据标准化。
- en: Analyze and define the optimal number of clusters.
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析并确定最优的聚类数。
- en: Fit a k-means algorithm with the number of clusters you've defined.
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你定义的聚类数来拟合k-means算法。
- en: Create a scatter plot of the clusters.
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建聚类的散点图。
- en: Note
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: This is the German Credit Dataset from the UCI Machine Learning Repository.
    It is available from the Packt repository at [https://packt.live/31L2c2b](https://packt.live/31L2c2b).Even
    though all the columns in this dataset are integers, most of them are actually
    categorical variables. The data in these columns is not continuous. Only two variables
    are really numeric. Those are the ones you will use for your clustering.
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是来自UCI机器学习库的德国信用数据集。可以从Packt库下载，网址为[https://packt.live/31L2c2b](https://packt.live/31L2c2b)。尽管该数据集中的所有列都是整数，但大多数实际上是分类变量。这些列中的数据并不是连续的。只有两个变量是真正的数值型数据。你将使用这些变量进行聚类分析。
- en: 'You should get something similar to the following output:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似于以下的输出：
- en: '![Figure 5.55: Scatter plot of the four clusters found'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.55：四个聚类的散点图]'
- en: '](img/B15019_05_55.jpg)'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_05_55.jpg)'
- en: 'Figure 5.55: Scatter plot of the four clusters found'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.55：四个聚类的散点图
- en: Note
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/2GbJloz](https://packt.live/2GbJloz).'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在以下地址找到：[https://packt.live/2GbJloz](https://packt.live/2GbJloz)。
- en: Summary
  id: totrans-643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You are now ready to perform cluster analysis with the k-means algorithm on
    your own dataset. This type of analysis is very popular in the industry for segmenting
    customer profiles as well as detecting suspicious transactions or anomalies.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好在自己的数据集上使用 k-means 算法进行聚类分析。这种类型的分析在行业中非常流行，用于细分客户档案以及检测可疑交易或异常。
- en: 'We learned about a lot of different concepts, such as centroids and squared
    Euclidean distance. We went through the main k-means hyperparameters: `init` (initialization
    method), `n_init` (number of initialization runs), `n_clusters` (number of clusters),
    and `random_state` (specified seed). We also discussed the importance of choosing
    the optimal number of clusters, initializing centroids properly, and standardizing
    data. You have learned how to use the following Python packages: `pandas`, `altair`,
    `sklearn`, and `KMeans`.'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了许多不同的概念，例如质心和平方欧几里得距离。我们介绍了主要的 k-means 超参数：`init`（初始化方法）、`n_init`（初始化运行次数）、`n_clusters`（簇的数量）和`random_state`（指定的种子）。我们还讨论了选择最佳簇数、正确初始化质心和标准化数据的重要性。你已经学会了如何使用以下
    Python 包：`pandas`、`altair`、`sklearn` 和 `KMeans`。
- en: In this chapter, we only looked at k-means, but it is not the only clustering
    algorithm. There are quite a lot of algorithms that use different approaches,
    such as hierarchical clustering, principal component analysis, and the Gaussian
    mixture model, to name a few. If you are interested in this field, you now have
    all the basic knowledge you need to explore these other algorithms on your own.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只讨论了 k-means，但它并不是唯一的聚类算法。还有许多其他算法使用不同的方法，例如层次聚类、主成分分析和高斯混合模型等。如果你对这一领域感兴趣，现在你已经掌握了所有基本知识，可以自主探索这些其他算法。
- en: Next, you will see how we can assess the performance of these models and what
    tools can be used to make them even better.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将看到我们如何评估这些模型的表现，以及可以使用哪些工具使它们更好。
