- en: gpx_dict = xmltodict.parse(gpx_file.read())
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: gpx_dict = xmltodict.parse(gpx_file.read())
- en: print("Waypoint:")
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: print("Waypoint:")
- en: print(gpx_dict['gpx']['wpt'][0].keys())
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: print(gpx_dict['gpx']['wpt'][0].keys())
- en: print("Geocache:")
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: print("Geocache:")
- en: print(gpx_dict['gpx']['wpt'][0]['geocache'].keys())
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: print(gpx_dict['gpx']['wpt'][0]['geocache'].keys())
- en: '3\. Now, edit the if __name__ == ''__main__'': block to test the code: if __name__
    == "__main__":'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '3. 现在，编辑if __name__ == ''__main__'':块以测试代码：if __name__ == "__main__":'
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: gdal.PushErrorHandler('CPLQuietErrorHandler')
- en: read_gpx_file("../../data/geocaching.gpx")
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: read_gpx_file("../../data/geocaching.gpx")
- en: '4\. Run the code again with *Shift* + *F10* and look at the results: Waypoint:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '4. 再次使用*Shift* + *F10*运行代码并查看结果：Waypoint:'
- en: '[u''@lat'', u''@lon'', u''time'', u''name'', u''desc'', u''src'', u''url'',
    u''urlname'', u''sym'', u''type'', u''geocache'']'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[u''@lat'', u''@lon'', u''time'', u''name'', u''desc'', u''src'', u''url'',
    u''urlname'', u''sym'', u''type'', u''geocache'']'
- en: 'Geocache:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 'Geocache:'
- en: '[u''@status'', u''@xmlns'', u''name'', u''owner'', u''locale'', u''state'',
    u''country'', u''type'', u''container'', u''difficulty'', u''terrain'', u''summary'',
    u''description'', u''hints'', u''licence'', u''logs'', u''geokrety'']'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[u''@status'', u''@xmlns'', u''name'', u''owner'', u''locale'', u''state'',
    u''country'', u''type'', u''container'', u''difficulty'', u''terrain'', u''summary'',
    u''description'', u''hints'', u''licence'', u''logs'', u''geokrety'']'
- en: Process finished with exit code 0
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完成，退出代码为0
- en: With the print(gpx_dict['gpx']['wpt'][0].keys())statement, we obtained the value
    of gpx and then that of wpt, which is a list. Then, we got the keys of the first
    element on this list and printed it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过print(gpx_dict['gpx']['wpt'][0].keys())语句，我们获得了gpx的值，然后是wpt，它是一个列表。然后，我们获得了此列表的第一个元素的键并打印了它。
- en: Next, through print(gpx_dict['gpx']['wpt'][0]['geocache'].keys()), we got the
    value of geocache and also printed its keys.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过print(gpx_dict['gpx']['wpt'][0]['geocache'].keys())，我们获得了geocache的值并打印了其键。
- en: Look at the output and note that it’s the same thing that we did when we were
    exploring the GPX file structure in PyCharm. The structure is now available as
    a dictionary, including the tag’s properties, which are represented in the dictionary
    with an @ symbol.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看输出并注意，这与我们在PyCharm中探索GPX文件结构时所做的是同一件事。现在结构作为字典可用，包括标签的属性，这些属性在字典中以@符号表示。
- en: 'Now that we have a nice and easy way to handle the dictionary of the GPX file,
    let’s extract and flatten the relevant information and make the function return
    it. Edit the read_gpx_file function, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了处理GPX文件字典的简单且方便的方法，让我们提取和展平相关信息，并使函数返回它。编辑read_gpx_file函数，如下所示：
- en: 'def read_gpx_file(file_path):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_gpx_file(file_path):'
- en: '"""Reads a GPX file containing geocaching points.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '"""读取包含寻宝点的GPX文件。'
- en: ':param str file_path: The full path to the file.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ':param str file_path: 文件的完整路径。'
- en: '"""'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'with open(file_path) as gpx_file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(file_path) as gpx_file:'
- en: gpx_dict = xmltodict.parse(gpx_file.read())
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: gpx_dict = xmltodict.parse(gpx_file.read())
- en: output = []
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: output = []
- en: 'for wpt in gpx_dict[''gpx''][''wpt'']:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 'for wpt in gpx_dict[''gpx''][''wpt'']:'
- en: geometry = [wpt.pop('@lat'), wpt.pop('@lon')]
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: geometry = [wpt.pop('@lat'), wpt.pop('@lon')]
- en: If geocache is not on the dict, skip this wpt.
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果geocache不在字典中，则跳过此wpt。
- en: 'try:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: geocache = wpt.pop('geocache')
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: geocache = wpt.pop('geocache')
- en: 'except KeyError:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 'except KeyError:'
- en: continue
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: 'attributes = {''status'': geocache.pop(''@status'')}'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'attributes = {''status'': geocache.pop(''@status'')}'
- en: Merge the dictionaries.
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并字典。
- en: attributes.update(wpt)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: attributes.update(wpt)
- en: attributes.update(geocache)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: attributes.update(geocache)
- en: Construct a GeoJSON feature and append to the list.
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个GeoJSON特征并将其追加到列表中。
- en: feature = {
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: feature = {
- en: '"type": "Feature",'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "Feature",'
- en: '"geometry": {'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '"geometry": {'
- en: '"type": "Point",'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "Point",'
- en: '"coordinates": geometry},'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '"coordinates": geometry},'
- en: '"properties": attributes}'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '"properties": attributes}'
- en: output.append(feature)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: output.append(feature)
- en: return output
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: return output
- en: Note that here, we used the dictionary’s pop method; this method returns the
    value of a given key and removes the key from the dictionary. The objective is
    to have two dictionaries only with attributes (properties) that can be merged
    into a single dictionary of attributes; the merging is done with the update method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里，我们使用了字典的pop方法；此方法返回给定键的值并从字典中删除该键。目标是只保留具有属性（properties）的字典，这些属性可以合并成一个包含属性的单一字典；合并是通过update方法完成的。
- en: Some waypoints doesn’t have the geocache key, when this happens, we catch the
    exception and skip this point.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当某些航点没有geocache键时，我们会捕获异常并跳过此点。
- en: 'Finally, the information is combined in a dictionary with a GeoJSON-like structure.
    You can do this as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将信息组合成一个具有GeoJSON结构的字典。你可以这样做：
- en: '1\. Edit the if __name__ == ''__main__'': block using the following code: if
    __name__ == "__main__":'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '1. 使用以下代码编辑if __name__ == ''__main__'':块：if __name__ == "__main__":'
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: gdal.PushErrorHandler('CPLQuietErrorHandler')
- en: points = read_gpx_file("../../data/geocaching.gpx") print points[0]['properties'].keys()
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: points = read_gpx_file("../../data/geocaching.gpx") print points[0]['properties'].keys()
- en: '2\. Run the code, and you will see the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 运行代码，你将看到以下输出：
- en: '[''status'', u''logs'', u''locale'', u''terrain'', u''sym'', u''geokrety'',
    u''difficulty'', u''licence'', u''owner'', u''urlname'', u''desc'', u''@xmlns'',
    u''src'', u''container'', u''name'', u''url'', u''country'', u''description'',
    u''summary'', u''state'', u''time'', u''hints'', u''type'']'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[''status'', u''logs'', u''locale'', u''terrain'', u''sym'', u''geokrety'',
    u''difficulty'', u''licence'', u''owner'', u''urlname'', u''desc'', u''@xmlns'',
    u''src'', u''container'', u''name'', u''url'', u''country'', u''description'',
    u''summary'', u''state'', u''time'', u''hints'', u''type'']'
- en: Process finished with exit code 0
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: That’s great! Now, all the geocache attributes are contained inside the *properties*
    of the feature.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 非常好！现在，所有地理藏点的属性都包含在特征的 *properties* 中。
- en: '**Returning the homogeneous data**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回同质数据**'
- en: We have a read_gpx_file function that returns a list of features in a dictionary
    and an open_vector_file function that returns an OGR datasource. We also have
    a get_datasource_information function that returns the information that we need
    about the file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 read_gpx_file 函数，它返回字典中的特征列表，以及一个 open_vector_file 函数，它返回 OGR 数据源。我们还有一个
    get_datasource_information 函数，它返回关于文件所需的信息。
- en: 'Now, it’s time to combine these functions in order to be able to read multiple
    types of data (GPX, Shapefiles, and many more). To do this, we will change the
    open_vector_file function so that it can make decisions depending on the file
    format and convert the data in order to always return the same structure. Perform
    the following steps: 1\. First, make sure that the functions inside geo_function.py
    are in the correct order; if not, rearrange them to be in this order:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将这些函数结合起来，以便能够读取多种类型的数据（GPX、Shapefiles 等）。为此，我们将更改 open_vector_file 函数，使其能够根据文件格式做出决策，并转换数据，以确保始终返回相同的结构。执行以下步骤：1.
    首先，确保 geo_function.py 中的函数顺序正确；如果不正确，请重新排列以符合以下顺序：
- en: 'def read_gpx_file(file_path):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_gpx_file(file_path):'
- en: 'def get_datasource_information(datasource, print_results=False): def open_vector_file(file_path):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_datasource_information(datasource, print_results=False): def open_vector_file(file_path):'
- en: 'def create_transform(src_epsg, dst_epsg):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_transform(src_epsg, dst_epsg):'
- en: 'def transform_geometries(datasource, src_epsg, dst_epsg):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transform_geometries(datasource, src_epsg, dst_epsg):'
- en: 'def transform_points(points, src_epsg=4326, dst_epsg=3395): 2\. Now, add a
    new function to transform OGR features into dictionaries as we did with the GPX
    file. This function can be inserted anywhere before open_vector_file, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transform_points(points, src_epsg=4326, dst_epsg=3395): 2. 现在，添加一个新函数，将
    OGR 特征转换为字典，就像我们对 GPX 文件所做的那样。此函数可以插入在 open_vector_file 之前，如下所示：'
- en: 'def read_ogr_features(layer):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_ogr_features(layer):'
- en: '"""Convert OGR features from a layer into dictionaries.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将图层中的 OGR 特征转换为字典。'
- en: ':param layer: OGR layer.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ':param layer: OGR 图层。'
- en: '"""'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: features = []
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: features = []
- en: layer_defn = layer.GetLayerDefn()
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: layer_defn = layer.GetLayerDefn()
- en: layer.ResetReading()
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: layer.ResetReading()
- en: type = ogr.GeometryTypeToName(layer.GetGeomType())
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: type = ogr.GeometryTypeToName(layer.GetGeomType())
- en: 'for item in layer:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in layer:'
- en: attributes = {}
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: attributes = {}
- en: 'for index in range(layer_defn.GetFieldCount()):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'for index in range(layer_defn.GetFieldCount()):'
- en: field_defn = layer_defn.GetFieldDefn(index)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: field_defn = layer_defn.GetFieldDefn(index)
- en: key = field_defn.GetName()
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: key = field_defn.GetName()
- en: value = item.GetFieldAsString(index)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: value = item.GetFieldAsString(index)
- en: attributes[key] = value
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: attributes[key] = value
- en: feature = {
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: feature = {
- en: '"type": "Feature",'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "Feature",'
- en: '"geometry": {'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '"geometry": {'
- en: '"type": type,'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": type,'
- en: '"coordinates": item.GetGeometryRef().ExportToWkt()},'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '"coordinates": item.GetGeometryRef().ExportToWkt()},'
- en: '"properties": attributes}'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '"properties": attributes}'
- en: features.append(feature)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: features.append(feature)
- en: return features
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: return features
- en: '3\. Now, edit the open_vector_file function via the following code: def open_vector_file(file_path):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '3. 现在，通过以下代码编辑 open_vector_file 函数：def open_vector_file(file_path):'
- en: '"""Opens an vector file compatible with OGR or a GPX file.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开与 OGR 兼容的矢量文件或 GPX 文件。'
- en: Returns a list of features and informations about the file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 返回特征列表和关于文件的信息。
- en: ':param str file_path: The full path to the file.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ':param str file_path: 文件的完整路径。'
- en: '"""'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: datasource = ogr.Open(file_path)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: datasource = ogr.Open(file_path)
- en: Check if the file was opened.
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件是否已打开。
- en: 'if not datasource:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not datasource:'
- en: 'if not os.path.isfile(file_path):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not os.path.isfile(file_path):'
- en: message = "Wrong path."
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: message = "路径错误。"
- en: 'else:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: message = "File format is invalid."
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: message = "文件格式无效。"
- en: raise IOError('Error opening the file {}\n{}'.format(
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: raise IOError('Error opening the file {}\n{}'.format(
- en: file_path, message))
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: file_path, message))
- en: metadata = get_datasource_information(datasource)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: metadata = get_datasource_information(datasource)
- en: file_name, file_extension = os.path.splitext(file_path)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: file_name, file_extension = os.path.splitext(file_path)
- en: Check if it's a GPX and read it if so.
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查是否为 GPX 文件，如果是则读取。
- en: 'if file_extension in [''.gpx'', ''.GPX'']:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'if file_extension in [''.gpx'', ''.GPX'']:'
- en: features = read_gpx_file(file_path)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: features = read_gpx_file(file_path)
- en: If not, use OGR to get the features.
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果没有，则使用 OGR 获取特征。
- en: 'else:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: features = read_ogr_features(
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: features = read_ogr_features(
- en: datasource.GetLayerByIndex(0))
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: datasource.GetLayerByIndex(0))
- en: return features, metadata
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: return features, metadata
- en: '4\. Just to make sure that everything is fine, let’s test the code by opening
    two different file types. Edit the if __name__ == ''__main__'': block, as follows:
    if __name__ == "__main__":'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '4. 为了确保一切正常，让我们通过打开两种不同的文件类型来测试代码。编辑 if __name__ == ''__main__'': 块，如下所示：if
    __name__ == "__main__":'
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: gdal.PushErrorHandler('CPLQuietErrorHandler')
- en: points, metadata = open_vector_file(
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: points, metadata = open_vector_file(
- en: '"../../data/geocaching.shp")'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '"../../data/geocaching.shp")'
- en: print points[0]['properties'].keys()
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 points[0]['properties'].keys()
- en: points, metadata = open_vector_file(
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: points, metadata = open_vector_file(
- en: '"../../data/geocaching.gpx")'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '"../../data/geocaching.gpx")'
- en: print points[0]['properties'].keys()
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 points[0]['properties'].keys()
- en: '5\. Run the code and take a look at the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 运行代码并查看以下输出：
- en: '[''src'', ''dgpsid'', ''vdop'', ''sat'', ''name'', ''hdop'', ''url'', ''fix'',
    ''pdop'','
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[''src'', ''dgpsid'', ''vdop'', ''sat'', ''name'', ''hdop'', ''url'', ''fix'',
    ''pdop'','
- en: '''sym'', ''ele'', ''ageofdgpsd'', ''time'', ''urlname'', ''magvar'', ''cmt'',
    ''type'','
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '''sym'', ''ele'', ''ageofdgpsd'', ''time'', ''urlname'', ''magvar'', ''cmt'',
    ''type'','
- en: '''geoidheigh'', ''desc'']'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '''geoidheigh'', ''desc'']'
- en: '[''status'', u''logs'', u''locale'', u''terrain'', u''sym'', u''geokrety'',
    u''difficulty'', u''licence'', u''owner'', u''urlname'', u''desc'', u''@xmlns'',
    u''src'', u''container'', u''name'', u''url'', u''country'', u''description'',
    u''summary'', u''state'', u''time'', u''hints'', u''type'']'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[''status'', u''logs'', u''locale'', u''terrain'', u''sym'', u''geokrety'',
    u''difficulty'', u''licence'', u''owner'', u''urlname'', u''desc'', u''@xmlns'',
    u''src'', u''container'', u''name'', u''url'', u''country'', u''description'',
    u''summary'', u''state'', u''time'', u''hints'', u''type'']'
- en: Process finished with exit code 0
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码 0 完成
- en: '**Converting the data into Geocache objects** So far, we have defined the Geocache
    class; it has the latitude and longitude properties and a method to return this
    pair of coordinates. PointCollection is a collection of geocaches.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**将数据转换为 Geocache 对象** 到目前为止，我们已经定义了 Geocache 类；它具有纬度和经度属性以及一个返回这对坐标的方法。PointCollection
    是一个包含地标的集合。'
- en: We also have the open_vector_file function that returns a list of dictionaries
    representing features.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个 open_vector_file 函数，它返回表示特征的字典列表。
- en: Now, we will reach a higher level of abstraction by implementing the process
    of importing data into the PointCollection class by making use of the open_vector_file
    function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过利用 open_vector_file 函数实现将数据导入 PointCollection 类的过程来达到更高的抽象层次。
- en: 'Perform the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: '1\. Open your models.py file and edit the imports at the beginning of the file
    by executing the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 打开 models.py 文件，并在文件开头执行以下代码以编辑导入：
- en: coding=utf-8
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: Import gdal
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 gdal
- en: import os
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 os 模块
- en: from pprint import pprint
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: from pprint import pprint
- en: from utils.geo_functions import open_vector_file
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: from utils.geo_functions import open_vector_file
- en: 2\. Now, let’s make PointCollection automatically import a file when it’s instantiated.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在，让我们让 PointCollection 在实例化时自动导入文件。
- en: 'Go to the models.py file, change your class __init__ method, and add the import_data
    and _parse_data methods. Run this script:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 models.py 文件，更改类 __init__ 方法，并添加 import_data 和 _parse_data 方法。运行此脚本：
- en: 'class PointCollection(object):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'class PointCollection(object):'
- en: 'def __init__(self, file_path=None):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, file_path=None):'
- en: '"""This class represents a group of vector data."""'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '"""此类表示一组矢量数据。”'
- en: self.data = []
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = []
- en: self.epsg = None
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: self.epsg = None
- en: 'if file_path:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'if file_path:'
- en: self.import_data(file_path)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: self.import_data(file_path)
- en: 'def import_data(self, file_path):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'def import_data(self, file_path):'
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开与 OGR 兼容的矢量文件并解析数据。”'
- en: ':param str file_path: The full path to the file.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ':param str file_path: 文件的完整路径。'
- en: '"""'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: features, metadata = open_vector_file(file_path)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: features, metadata = open_vector_file(file_path)
- en: self._parse_data(features)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: self._parse_data(features)
- en: self.epsg = metadata['epsg']
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: self.epsg = metadata['epsg']
- en: 'print("File imported: {}".format(file_path))'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '打印 "导入的文件: {}".format(file_path)'
- en: 'def _parse_data(self, features):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _parse_data(self, features):'
- en: '"""Transforms the data into Geocache objects.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将数据转换为 Geocache 对象。”'
- en: ':param features: A list of features.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ':param features: 特征列表。'
- en: '"""'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'for feature in features:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in features:'
- en: geom = feature['geometry']['coordinates']
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: geom = feature['geometry']['coordinates']
- en: attributes = feature['properties']
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: attributes = feature['properties']
- en: cache_point = Geocache(geom[0], geom[1],
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: cache_point = Geocache(geom[0], geom[1],
- en: attributes = attributes) self.data.append(cache_point)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: attributes = attributes) self.data.append(cache_point)
- en: 3\. Now, we will just need to adapt the Geocache class to receive and store
    the attributes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 现在，我们只需要将Geocache类调整为接收和存储属性。
- en: 'Replace it with the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换它：
- en: 'class Geocache(object):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Geocache(object):'
- en: '"""This class represents a single geocaching point."""'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '"""此类表示单个地理藏宝点。”'
- en: 'def __init__(self, lat, lon, attributes=None):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, lat, lon, attributes=None):'
- en: self.lat = lat
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: self.lat = lat
- en: self.lon = lon
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: self.lon = lon
- en: self.attributes = attributes
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: self.attributes = attributes
- en: '@property'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def coordinates(self):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'def coordinates(self):'
- en: return self.lat, self.lon
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: return self.lat, self.lon
- en: The attribute arguments are called **keyword arguments**. Keyword arguments
    are optional, and the default value is the value defined after the equal symbol.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 属性参数被称为**关键字参数**。关键字参数是可选的，默认值是等号后面的值。
- en: As at this moment there is no standardization in data format for geocaching,
    we will store all the attributes that are read from the source file unchanged.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目前没有对地理藏宝数据格式的标准化，我们将保留从源文件中读取的所有属性不变。
- en: In Python, you are not obliged to define which properties a class instance will
    have in advance; the properties can be added during the code’s execution. However,
    it’s good practice to define them in the __init __ method because it avoids mistakes,
    such as trying to access undefined properties. PyCharm can track these properties
    and warn you about typos. It also serves as documentation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你不必提前定义类实例将具有哪些属性；属性可以在代码执行期间添加。然而，在__init__方法中定义它们是一个好习惯，因为它可以避免错误，例如尝试访问未定义的属性。PyCharm可以跟踪这些属性并警告你关于拼写错误。它还充当文档。
- en: '1\. Before we test the code, edit the PointCollection class and add a method
    that shows some information for us, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在测试代码之前，编辑PointCollection类并添加一个显示一些信息的方法，如下所示：
- en: '#...'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def describe(self):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'def describe(self):'
- en: 'print("SRS EPSG code: {}".format(self.epsg))'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: print("SRS EPSG代码：{}".format(self.epsg))
- en: 'print("Number of features: {}".format(len(self.data))) 2\. In order to test
    your code, edit the if __name__ == ''__main__'' block via the following lines
    of code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: print("特征数量：{}".format(len(self.data))) 2. 为了测试你的代码，通过以下代码行编辑if __name__ ==
    '__main__'块：
- en: 'if __name__ == ''__main__'':'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: gdal.PushErrorHandler('CPLQuietErrorHandler')
- en: '**vector_data = PointCollection("../data/geocaching.gpx")** vector_data.print_information()'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**vector_data = PointCollection("../data/geocaching.gpx")** vector_data.print_information()'
- en: '3\. Now, run the code. You should see the following output: File imported:
    ../data/geocaching.gpx'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 现在，运行代码。你应该看到以下输出：导入文件：../data/geocaching.gpx
- en: 'SRS EPSG code: 4326'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: SRS EPSG代码：4326
- en: 'Number of features: 112'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 特征数量：112
- en: Process finished with exit code 0
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码0结束
- en: '**Merging multiple sources of data**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**合并多个数据源**'
- en: Now that our data is in the form of PointCollection containing Geocache objects,
    merging data from multiple files or multiple PointCollection data should be easy.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据以PointCollection形式包含Geocache对象，从多个文件或多个PointCollection数据中合并数据应该很容易。
- en: 'Perform the following steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: '1\. Make another test. First, we will see whether we can import multiple files
    and edit the if __name__ == ''__main__'' block of the models.py file. Execute
    the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 进行另一次测试。首先，我们将查看是否可以导入多个文件并编辑models.py文件的if __name__ == '__main__'块。执行以下代码：
- en: 'if __name__ == ''__main__'':'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: gdal.PushErrorHandler('CPLQuietErrorHandler')
- en: vector_data = PointCollection("../data/geocaching.gpx") vector_data.describe()
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: vector_data = PointCollection("../data/geocaching.gpx") vector_data.describe()
- en: vector_data.import_data("../data/geocaching.shp") vector_data.describe()
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: vector_data.import_data("../data/geocaching.shp") vector_data.describe()
- en: '2\. Run the code again. Now, you should see the number of features double after
    you import another file, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 再次运行代码。现在，在导入另一个文件后，你应该看到特征数量翻倍，如下所示：
- en: 'File imported: ../data/geocaching.gpx'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 导入文件：../data/geocaching.gpx
- en: 'SRS EPSG code: 4326'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: SRS EPSG代码：4326
- en: 'Number of features: 112'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 特征数量：112
- en: 'File imported: ../data/geocaching.shp'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 导入文件：../data/geocaching.shp
- en: 'SRS EPSG code: None'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: SRS EPSG代码：None
- en: 'Number of features: 242'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 特征数量：242
- en: Process finished with exit code 0
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码0结束
- en: 3\. Let’s implement something very elegant. We will add a magic method to our
    PointCollection class so that we can merge the content of two instances.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 让我们实现一些非常优雅的功能。我们将向PointCollection类添加一个魔法方法，以便我们可以合并两个实例的内容。
- en: 4\. Edit the PointCollection class and add the __add__ method just after the
    __init__
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 编辑PointCollection类，并在__init__方法之后添加__add__方法
- en: 'method via the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下代码实现方法：
- en: 'class PointCollection(object):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'class PointCollection(object):'
- en: 'def __init__(self, file_path=None):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, file_path=None):'
- en: '"""This class represents a group of vector data."""'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '"""此类表示一组矢量数据。”'
- en: self.data = []
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = []
- en: self.epsg = None
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: self.epsg = None
- en: 'if file_path:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'if file_path:'
- en: self.import_data(file_path)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: self.import_data(file_path)
- en: 'def __add__(self, other):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __add__(self, other):'
- en: self.data += other.data
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: self.data += other.data
- en: return self
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: Similar to the __init__ method, the __add__ method is one of Python’s *magic
    methods*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 与__init__方法类似，__add__方法是Python的*魔法方法*之一。
- en: 'These methods are not called directly; they are automatically called when something
    specific happens. The __init__ method is called when the class is instantiated,
    and the __add__ method is called when the plus (+) operator is used. So, to merge
    the data of two PointCollection instances, we just need to sum them. Here’s what
    we need to do for this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法不是直接调用的；它们在特定事件发生时自动调用。__init__方法在类实例化时调用，__add__方法在使用加号（+）运算符时调用。因此，为了合并两个PointCollection实例的数据，我们只需要将它们相加。以下是我们需要做的：
- en: '1\. Edit the if __name__ == ''__main__'': block, as follows: if __name__ ==
    ''__main__'':'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '1. 编辑if __name__ == ''__main__'':块，如下所示：if __name__ == ''__main__'':'
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: gdal.PushErrorHandler('CPLQuietErrorHandler')
- en: my_data = PointCollection("../data/geocaching.gpx") my_other_data = PointCollection("../data/geocaching.shp")
    merged_data = my_data + my_other_data
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: my_data = PointCollection("../data/geocaching.gpx") my_other_data = PointCollection("../data/geocaching.shp")
    merged_data = my_data + my_other_data
- en: merged_data.describe()
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: merged_data.describe()
- en: '2\. Then, run the code and take a look at the results:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 然后，运行代码并查看结果：
- en: 'File imported: ../data/geocaching.gpx'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的文件：../data/geocaching.gpx
- en: 'File imported: ../data/geocaching.shp'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的文件：../data/geocaching.shp
- en: 'SRS EPSG code: 4326'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: SRS EPSG代码：4326
- en: 'Number of features: 242'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 特征数量：242
- en: Process finished with exit code 0
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完成，退出代码为0
- en: '**Integrating new functionality into the**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**将新功能集成到**'
- en: '**application**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序**'
- en: In [Chapter 2,](index_split_000.html#p103) *The Geocaching App*, we developed
    the application so that it could find points close to your location. However,
    the data was organized differently inside the application; although it was a very
    efficient way of handling data, it became very hard for us to understand how to
    perform operations on this data.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章，](index_split_000.html#p103)《Geocaching App》中，我们开发了应用程序，使其能够找到靠近你位置的点。然而，在应用程序内部，数据组织方式不同；虽然这是一种处理数据非常有效的方法，但它使我们很难理解如何对此数据进行操作。
- en: Through abstraction, we implemented a new form of data representation—one that
    is very intuitive and easy to use.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过抽象，我们实现了一种新的数据表示形式——这是一种非常直观且易于使用的形式。
- en: Now, we will change the application so that it can use this new type of data
    to perform its functions and also to aggregate the new capability of combining
    multiple sources of data.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改应用程序，使其能够使用这种新的数据类型来执行其功能，并且还可以聚合结合多个数据源的新功能。
- en: Take a look at the GeocachingApp and PointCollection classes; you may notice
    that they have some parts that look similar to each other. Both of them store
    data and have methods to open data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 查看GeocachingApp和PointCollection类；你可能注意到它们有一些部分看起来彼此相似。这两个类都存储数据，并且有打开数据的方法。
- en: At this point, with little modification, if we transfer methods from one class
    to another, we could end up with a functional application, and that’s what we
    will do. However, instead of copying and pasting, we will use Python’s class inheritance.
    We will take the GeocachingApp class and make it inherit all the functionality
    of the PointCollection class.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，经过少量修改，如果我们将一个类的方法转移到另一个类中，我们最终可以得到一个功能性的应用程序，这正是我们将要做的。然而，我们不会复制和粘贴，而是使用Python的类继承。我们将使用GeocachingApp类，使其继承PointCollection类的所有功能。
- en: For a complete understanding, we will go through the processes one method at
    a time.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全理解，我们将逐个方法地通过这些过程。
- en: 'Open your geocaching_app.py file, and now, let’s focus on the class declarations
    and __init__ method. Make the following changes on the imports section, and in
    the class, you can keep the other methods as they are; don’t delete them:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的geocaching_app.py文件，现在，让我们专注于类声明和__init__方法。在导入部分进行以下更改，在类中，你可以保留其他方法不变；不要删除它们：
- en: coding=utf-8
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: from pprint import pprint
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: from pprint import pprint
- en: import gdal
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 导入gdal
- en: import numpy as np
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 导入numpy as np
- en: import math
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 导入math
- en: from utils.geo_functions import transform_geometries
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从`utils.geo_functions`导入`transform_geometries`
- en: from utils.geo_functions import transform_points
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 从`utils.geo_functions`导入`transform_points`
- en: from models import Geocache, PointCollection
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 从`models`导入`Geocache`，`PointCollection`
- en: 'class GeocachingApp(PointCollection):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 'class GeocachingApp(PointCollection):'
- en: 'def __init__(self, data_file=None, my_location=None):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, data_file=None, my_location=None):'
- en: '"""Application class.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用程序类。'
- en: ':param data_file: An OGR compatible file'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ':param data_file: 一个与OGR兼容的文件'
- en: with geocaching points.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与地理藏点一起。
- en: ':param my_location: Coordinates of your location.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ':param my_location: 您的位置坐标。'
- en: '"""'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: super(GeocachingApp, self).__init__(file_path=data_file)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: super(GeocachingApp, self).__init__(file_path=data_file)
- en: self._datasource = None
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: self._datasource = None
- en: self._transformed_geoms = None
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: self._transformed_geoms = None
- en: self._my_location = None
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: self._my_location = None
- en: self.distances = None
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: self.distances = None
- en: '#Delete the code containing "if data_file…"'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '# 删除包含 "if data_file…" 的代码'
- en: 'if my_location:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'if my_location:'
- en: self.my_location = my_location
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: self.my_location = my_location
- en: In the class declaration (class GeocachingApp(PointCollection)), we added GeocachingClass,
    which tells Python that the GeocachingApp class should inherit methods and properties
    from PointCollection. However, as both classes have an __init__ method, unless
    we do something, the Geocaching app’s __init__ method will completely overwrite
    the PointCollection method.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明（`class GeocachingApp(PointCollection)`）中，我们添加了`GeocachingClass`，这告诉Python`GeocachingApp`类应该从`PointCollection`继承方法和属性。然而，由于两个类都有一个`__init__`方法，除非我们做些什么，否则地理藏应用（Geocaching
    app）的`__init__`方法将完全覆盖`PointCollection`方法。
- en: 'We want both of the __init__ methods called, so we will use the super() function.
    This tells Python to call the __init__ method of the inherited class. Also, as
    the PointCollection class handles the files importing now, we will pass the data_file
    argument to it. Perform the following steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望调用两个`__init__`方法，因此我们将使用`super()`函数。这告诉Python调用继承类的`__init__`方法。此外，由于`PointCollection`类现在处理文件导入，我们将`data_file`参数传递给它。执行以下步骤：
- en: 1\. Let’s test it and check whether the inheritance works. Go to the if __name__
    ==
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 让我们测试它并检查继承是否工作。转到`if __name__ == "__main__":`
- en: '''__main__'': block at the end of the file and edit it as follows: if __name__
    == "__main__":'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '''__main__'': 文件末尾的代码块，并按以下方式编辑：if __name__ == "__main__":'
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: gdal.PushErrorHandler('CPLQuietErrorHandler')
- en: 'Create the application:'
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序：
- en: my_app = GeocachingApp()
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: my_app = GeocachingApp()
- en: 'Now we will call a method from the PointCollection class: my_app.import_data("../data/geocaching.gpx")'
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在，我们将调用`PointCollection`类的一个方法：`my_app.import_data("../data/geocaching.gpx")`
- en: 2\. In fact, as you type the code, you may notice that PyCharm’s auto-completion
    feature now includes methods and properties from the inherited class.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 实际上，当你编写代码时，你可能注意到PyCharm的自动完成功能现在包括继承类的方法和属性。
- en: '3\. Run the code, and you should see this output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 运行代码，你应该看到以下输出：
- en: 'File imported: ../data/geocaching.gpx'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的文件：../data/geocaching.gpx
- en: Process finished with exit code 0
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码0结束
- en: Congratulations! You have just used class inheritance with success. This is
    a very powerful and handy feature of Python.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚成功使用了类继承。这是Python的一个非常强大且实用的特性。
- en: '**Summary**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: In this chapter, the challenge was to find a way to combine data from multiple
    sources.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，挑战在于找到一种方法来组合来自多个来源的数据。
- en: The solution for this is to make code that can take different types of data
    and transform it into a common type of object.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是编写可以接受不同类型的数据并将其转换为通用类型对象的代码。
- en: In order to achieve this, we first created two new Python classes. The first
    was the Geocache class, which represents a single geocache location and contains
    its coordinates, a name, and a description. The second was the PointCollection
    class, which represents a collection of Geocache objects. This class has the ability
    to import and convert the information from as many files as needed.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们首先创建了两个新的Python类。第一个是`Geocache`类，它代表一个单独的地理藏点位置，包含其坐标、名称和描述。第二个是`PointCollection`类，它代表一组`Geocache`对象。这个类具有从所需文件中导入和转换信息的
    ability。
- en: This technique that we used is called **abstraction**; its foundations reside
    in hiding complex procedures behind objects that can be easily understood by humans.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的这种技术被称为**抽象**；其基础在于隐藏复杂的过程，使其可以通过人类易于理解的对象来实现。
- en: Finally, we integrated this new layer of abstraction into the application using
    class inheritance. The GeocachingApp class inherited the PointCollection, and
    in the end, it could behave similarly to any and both of them at the same time.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过类继承将这一新的抽象层集成到应用程序中。GeocachingApp类继承了PointCollection，最终它可以同时表现出任何一种或两种行为。
- en: In the next chapter, while we will improve the application’s capability to search
    for points, you will also learn other ways of combining classes.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，虽然我们将提高应用程序搜索点的功能，但你还将学习其他组合类的方法。
- en: '**Chapter 4\. Improving the App Search**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4章\. 提高应用程序搜索功能**'
- en: '**Capabilities**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**能力**'
- en: So far, our app is capable of simply searching points that are close to a defined
    location. In this chapter, we are going to make a huge steep and make our app
    filter the data by geographic boundaries and by any field in the data.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序能够简单地搜索接近定义位置的点。在本章中，我们将进行一次巨大的飞跃，使我们的应用程序能够通过地理边界和数据的任何字段来过滤数据。
- en: By the end of this chapter, you will be able to search geocaching points that
    are inside a given city, state, country, or any boundary defined by you. In addition,
    you will be able to search points by any of its properties such as difficult levels,
    name, user, and so on. It will also be possible to combine multiple filters.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够搜索位于给定城市、州、国家或任何你定义的边界内的地理藏点。此外，你还可以通过其属性（如难度级别、名称、用户等）进行搜索。还可以组合多个过滤器。
- en: In the process, we will see how to work with polygons and how the relations
    between geometries can be analyzed in a geoprocessing application.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将看到如何处理多边形以及如何在地理处理应用程序中分析几何形状之间的关系。
- en: 'To achieve these goals, we will go through the following topics: How to describe
    polygons using well-known text'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些目标，我们将探讨以下主题：如何使用众所周知的文本描述多边形
- en: Using the Shapely package to handle geometries
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Shapely包处理几何形状
- en: Importing polygon data
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 导入多边形数据
- en: Importing line data
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 导入线数据
- en: The use of base classes and inheritance
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 基类和继承的使用
- en: The types of geometry relationships
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 几何关系类型
- en: Filtering by multiple properties and method chaining
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通过多个属性进行过滤和链式方法调用
- en: '![Image 19](img/index-176_1.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![Image 19](img/index-176_1.jpg)'
- en: '**Working with polygons**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理多边形**'
- en: Supposing we want to filter our data by a given region, it’s possible to assume
    that this region is represented by a polygon.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要通过一个给定的区域来过滤我们的数据，那么这个区域可能是由一个多边形表示的。
- en: For example, the following image represents the world counties’ borders, it
    was rendered from a Shapefile where each feature is a country and it’s geometry
    is a polygon.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下图像表示世界各国的边界，它是由一个Shapefile渲染的，其中每个特征是一个国家，其几何形状是一个多边形。
- en: Differently from the geocaching point, whose geometries are only a pair of coordinates,
    a polygon is a sequence of at least three-point coordinates beginning and ending
    at the same point.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 与仅有一对坐标的地理藏点不同，多边形是一系列至少有三个点的坐标，起点和终点在同一个点上。
- en: By now, you can assume that we won’t be able to store the polygon’s coordinates
    with the same structure that we had with the geocaching point. We will need to
    store the whole OGR geometry or store something that can be transformed from or
    to it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可以假设我们无法使用与地理藏点相同的结构来存储多边形的坐标。我们需要存储整个OGR几何形状或存储可以从中或转换到它的东西。
- en: How these polygons are represented is an important subject, because mastering
    it allows you to manipulate them any way you need to do any kind of work. It also
    allows you to build polygons from point coordinates (from a GPS for example) or
    form shapes such as a rectangle.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这些多边形是如何表示的，这是一个重要的主题，因为掌握它可以使你以任何你需要的方式操纵它们。它还允许你从点坐标（例如从GPS）或形成矩形等形状中构建多边形。
- en: '![Image 20](img/index-177_1.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![Image 20](img/index-177_1.jpg)'
- en: '**Knowing well-known text**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**了解众所周知的文本**'
- en: '**Well-known text** (**WKT**) is a human readable markup language to represent
    geometries in a spatial application. It was originally defined by the **Open Geospatial
    Consortium** (**OGC**) and is accepted by many software as a form of data exchange.
    The WKT has a binary equivalent called **well-known binary** (**WKB**). It is
    used for data storage and transfer where human readability is not required.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**众所周知的文本**（**WKT**）是一种人类可读的标记语言，用于在空间应用程序中表示几何形状。它最初由**开放地理空间联盟**（**OGC**）定义，并被许多软件作为数据交换的形式所接受。WKT有一个二进制等效物，称为**众所周知的二进制**（**WKB**）。它用于数据存储和传输，在这些情况下不需要人类可读性。'
- en: Let’s go through some examples to see how WKT works. First, we will create an
    OGR
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些示例来了解WKT是如何工作的。首先，我们将创建一个OGR
- en: 'geometry of the polygon shown in the following image:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下图所示的多边形几何体：
- en: 1\. Make a copy of your Chapter3 folder inside the geopy project and rename
    it to Chapter4\.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 在geopy项目中复制您的Chapter3文件夹，并将其重命名为Chapter4\。
- en: 2\. Locate the Chapter4\experiments directory and delete the files inside it.
    If you don’t have this directory, create it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 定位Chapter4\experiments目录并删除其中的文件。如果您没有这个目录，请创建它。
- en: 3\. Inside the Chapter4\experiments folder, create a new Python file. To do
    this in PyCharm, right-click on the folder and choose **New** | **Python File**.
    Name this file wkt_experiments.py.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 在Chapter4\experiments文件夹内，创建一个新的Python文件。在PyCharm中，右键点击文件夹并选择**新建** | **Python文件**。将此文件命名为wkt_experiments.py。
- en: '4\. Type the following code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 输入以下代码：
- en: coding=utf-8
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import ogr
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: import ogr
- en: wkt_rectangle = "POLYGON ((1 1, 1 9, 8 9, 8 1, 1 1))"
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: wkt_rectangle = "POLYGON ((1 1, 1 9, 8 9, 8 1, 1 1))"
- en: geometry = ogr.CreateGeometryFromWkt(wkt_rectangle)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: geometry = ogr.CreateGeometryFromWkt(wkt_rectangle)
- en: print(geometry.__class__)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: print(geometry.__class__)
- en: print(geometry.Area())
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: print(geometry.Area())
- en: print(8*7)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: print(8*7)
- en: '5\. Now run it ( *Alt* + *Shift* + *F10* and choose wkt_experiments). You should
    see the following output:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 现在运行它（ *Alt* + *Shift* + *F10* 并选择wkt_experiments）。你应该看到以下输出：
- en: <class 'osgeo.ogr.Geometry'>
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'osgeo.ogr.Geometry'>
- en: '56.0'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '56.0'
- en: '56'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '56'
- en: '![Image 21](img/index-178_1.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![Image 21](img/index-178_1.jpg)'
- en: Process finished with exit code 0
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 进程已结束，退出代码为0
- en: What we did here was to define the WKT representation of a polygon in a Python
    string. Note that it started from coordinate 1.1 and listed all the coordinates
    clockwise ending at 1.1 again (the direction is not important; it could also be
    counter clockwise).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是在Python字符串中定义了多边形的WKT表示。请注意，它从坐标1.1开始，按顺时针方向列出所有坐标，最后又回到1.1（方向不重要；也可以是逆时针）。
- en: In the next line, we called OGR’s CreateGeometryFromWkt function that passed
    the string as a parameter. Internally, it converted the string into a OGR geometry
    object.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们调用了OGR的CreateGeometryFromWkt函数，该函数将字符串作为参数传递。内部，它将字符串转换为OGR几何对象。
- en: To make sure that everything went fine in the next three lines, we printed the
    class name of the object, the area calculated by OGR, and the manually calculated
    area.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保接下来的三行一切顺利，我们打印了对象的类名、OGR计算的区域以及手动计算的区域。
- en: Now, a more complicated polygon, one with a hole in the middle or an *island*.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个更复杂的多边形，中间有一个洞或一个*岛屿*。
- en: '6\. Edit your code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 编辑你的代码：
- en: coding=utf-8
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import ogr
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: import ogr
- en: wkt_rectangle = "POLYGON ((1 1, 1 9, 8 9, 8 1, 1 1))"
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: wkt_rectangle = "POLYGON ((1 1, 1 9, 8 9, 8 1, 1 1))"
- en: geometry = ogr.CreateGeometryFromWkt(wkt_rectangle)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: geometry = ogr.CreateGeometryFromWkt(wkt_rectangle)
- en: print(geometry.__class__)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: print(geometry.__class__)
- en: print(geometry.Area())
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: print(geometry.Area())
- en: print(8*7)
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: print(8*7)
- en: wkt_rectangle2 = "POLYGON ((1 1, 8 1, 8 9, 1 9, 1 1)," \
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: wkt_rectangle2 = "POLYGON ((1 1, 8 1, 8 9, 1 9, 1 1)," \
- en: '"(4 2, 4 5, 7 5, 7 2, 4 2))"'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '"(4 2, 4 5, 7 5, 7 2, 4 2))"'
- en: geometry2 = ogr.CreateGeometryFromWkt(wkt_rectangle2)
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: geometry2 = ogr.CreateGeometryFromWkt(wkt_rectangle2)
- en: print(geometry.__class__)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: print(geometry.__class__)
- en: print(geometry2.Area())
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: print(geometry2.Area())
- en: print((8*7) - (3*3))
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: print((8*7) - (3*3))
- en: '7\. Now run it again ( *Shift* + *F10*). You should see the following output:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. 现在再次运行它（ *Shift* + *F10*）。你应该看到以下输出：
- en: <class 'osgeo.ogr.Geometry'>
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'osgeo.ogr.Geometry'>
- en: '56.0'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '56.0'
- en: '56'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '56'
- en: <class 'osgeo.ogr.Geometry'>
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'osgeo.ogr.Geometry'>
- en: '47.0'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '47.0'
- en: '47'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '47'
- en: Every polygon ring comes inside the parenthesis separated by commas. The exterior
    ring should be described first, then all the interior rings.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 每个多边形环都位于括号内，由逗号分隔。外部环应该首先描述，然后是所有内部环。
- en: Managing geometries with WKT gets complicated as the complexity and the number
    of coordinates increase. To solve this and other problems, we will use another
    package that will make things a lot easier for us.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当复杂性和坐标数量增加时，使用WKT管理几何体变得复杂。为了解决这个问题和其他问题，我们将使用另一个包，这将使事情变得容易得多。
- en: '**Using Shapely to handle geometries**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Shapely处理几何体**'
- en: Shapely is a Python package for the analysis of planar features. It uses functions
    from the GEOS library and a port of the **Java Topology Suite** (**JTS**).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely是一个用于平面特征分析的Python包。它使用GEOS库中的函数以及Java拓扑套件（**JTS**）的移植版本。
- en: It has mainly the same classes and functions as OGR while dealing with geometries.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 它在处理几何体时主要具有与OGR相同的类和函数。
- en: Although it’s not a replacement for OGR, it has a more *pythonic* and a very
    intuitive interface, it is better optimized, and it has a well-developed documentation.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它不能替代OGR，但它有一个更*Pythonic*和非常直观的接口，它优化得更好，并且拥有完善的文档。
- en: To make things clear, Shapely is intended to analyze geometries and only geometries.
    It does not handle features’ attributes, neither is it capable of reading and
    writing geospatial files.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更清晰，Shapely旨在分析几何体，仅限于几何体。它不处理要素的属性，也不具备读取和写入地理空间文件的能力。
- en: 'For a direct comparison of Shapely and OGR, we are going to rewrite the previous
    examples:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了直接比较Shapely和OGR，我们将重写之前的示例：
- en: '1\. Add the following lines to the wkt_experiments.py file (you can keep or
    remove the previous code, it’s up to you):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 将以下行添加到wkt_experiments.py文件中（你可以保留或删除之前的代码，由你决定）：
- en: from shapely.geometry import Polygon
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: from shapely.geometry import Polygon
- en: print('Examples with Shapely')
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: print('使用Shapely的示例')
- en: polygon1 = Polygon([(1, 1), (1, 9), (8, 9), (8, 1), (1, 1)]) print(polygon1.__class__)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: polygon1 = Polygon([(1, 1), (1, 9), (8, 9), (8, 1), (1, 1)]) print(polygon1.__class__)
- en: print(polygon1.area)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 打印多边形1的面积
- en: polygon2 = Polygon([(1, 1), (1, 9), (8, 9), (8, 1), (1, 1)], [[(4, 2), (4, 5),(7,
    5), (7, 2), (4, 2)]])
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: polygon2 = Polygon([(1, 1), (1, 9), (8, 9), (8, 1), (1, 1)], [[(4, 2), (4, 5),(7,
    5), (7, 2), (4, 2)]])
- en: print(polygon2.__class__)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: print(polygon2.__class__)
- en: print(polygon2.area)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: print(polygon2.area)
- en: '2\. Now run the code again and look at the output:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在再次运行代码并查看输出：
- en: Examples with Shapely
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Shapely的示例
- en: <class 'shapely.geometry.polygon.Polygon'>
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'shapely.geometry.polygon.Polygon'>
- en: '56.0'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '56.0'
- en: <class 'shapely.geometry.polygon.Polygon'>
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'shapely.geometry.polygon.Polygon'>
- en: '47.0'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '47.0'
- en: Process finished with exit code 0
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: Everything worked as expected, but you may notice a few differences. First,
    in order to create the polygon, we passed a list of tuples (it could be a list
    of lists) where each tuple is a point coordinate. This small change makes a big
    difference; lists are much easier to manipulate than strings.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都按预期工作，但你可能注意到一些差异。首先，为了创建多边形，我们传递了一个元组的列表（它可以是列表的列表），其中每个元组是一个点坐标。这个小小的变化带来了很大的不同；列表比字符串更容易操作。
- en: Secondly, when we print the name of the class of the object created by Shapely,
    we see that it’s a Polygon class and not a Geometry as it was with OGR. This represents
    a higher level of abstraction as explained in [Chapter 3](index_split_000.html#p142),
    *Combining Multiple Data Sources*. With it comes all the goodies of abstraction
    and less worries about the internal functionality.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，当我们打印由Shapely创建的对象的类名时，我们看到它是一个多边形类，而不是像OGR那样是一个几何体。这代表了一个更高的抽象级别，如[第3章](index_split_000.html#p142)中解释的*结合多个数据源*。随着它而来的是抽象的所有好处和减少对内部功能的担忧。
- en: As you typed the code, specifically print(polygon1.area), PyCharm showed you
    a list
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入代码时，特别是print(polygon1.area)，PyCharm显示给你一个列表
- en: of methods for the Polygon class. This is another feature of Shapely, it is
    a well-written and IDE-friendly Python package. The consequence is that it allows
    you to take autocompletion, code inspections, refactoring, and a lot of the other
    features that come with modern IDEs.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Polygon类的多种方法。这是Shapely的另一个特性，它是一个编写良好且IDE友好的Python包。结果是，它允许你使用自动完成、代码检查、重构以及现代IDE带来的许多其他功能。
- en: '**Importing polygons**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**导入多边形**'
- en: Now that we have the basics on how to work with polygons and we know how to
    represent and store them, we will go back to our app and add the ability to import
    geospatial files containing polygons. As we did with the points, we will abstract
    the features into the Python objects and we will also use class inheritance.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何处理多边形以及如何表示和存储它们，我们将回到我们的应用程序中，添加导入包含多边形的地形文件的功能。就像我们处理点一样，我们将抽象要素到Python对象中，并且我们还将使用类继承。
- en: 'First, let’s look at the code we already wrote. In the models.py file, we have
    the PointCollection class:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们已编写的代码。在models.py文件中，我们有PointCollection类：
- en: 'class PointCollection(object):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 'class PointCollection(object):'
- en: 'def __init__(self, file_path=None):'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, file_path=None):'
- en: '"""This class represents a group of vector data."""'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '"""这个类表示一组矢量数据。”'
- en: self.data = []
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = []
- en: self.epsg = None
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: self.epsg = None
- en: 'if file_path:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 'if file_path:'
- en: self.import_data(file_path)
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: self.import_data(file_path)
- en: 'def __add__(self, other):'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __add__(self, other):'
- en: self.data += other.data
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: self.data += other.data
- en: return self
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: 'def import_data(self, file_path):'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 'def import_data(self, file_path):'
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开与OGR兼容的矢量文件并解析数据。”'
- en: ':param str file_path: The full path to the file.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ':param str file_path: 文件的完整路径。'
- en: '"""'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: features, metadata = open_vector_file(file_path)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: features, metadata = open_vector_file(file_path)
- en: self._parse_data(features)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: self._parse_data(features)
- en: self.epsg = metadata['epsg']
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: self.epsg = metadata['epsg']
- en: 'print("File imported: {}".format(file_path))'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("File imported: {}".format(file_path))'
- en: 'def _parse_data(self, features):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _parse_data(self, features):'
- en: '"""Transforms the data into Geocache objects.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将数据转换为Geocache对象。'
- en: ':param features: A list of features.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ':param features: 特征列表。'
- en: '"""'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'for feature in features:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in features:'
- en: geom = feature['geometry']['coordinates']
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: geom = feature['geometry']['coordinates']
- en: attributes = feature['properties']
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: attributes = feature['properties']
- en: cache_point = Geocache(geom[0], geom[1],
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: cache_point = Geocache(geom[0], geom[1],
- en: attributes = attributes)
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: attributes = attributes)
- en: self.data.append(cache_point)
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: self.data.append(cache_point)
- en: 'def describe(self):'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 'def describe(self):'
- en: 'print("SRS EPSG code: {}".format(self.epsg))'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("SRS EPSG code: {}".format(self.epsg))'
- en: 'print("Number of features: {}".format(len(self.data))) This class represents
    a collection of geocaching points and is responsible for importing these points
    and converting and storing them. These are exactly the same functionality that
    we want to implement to import polygons.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("Number of features: {}".format(len(self.data))) 这个类代表了一组地理藏点，并负责导入这些点以及转换和存储它们。这些正是我们想要实现以导入多边形的功能。'
- en: In the previous chapter, you saw how it’s possible, through inheritance, to
    make a class inherit functionalities from other classes. We will use this same
    technique to use what we already have to import the polygons.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你看到了如何通过继承，使一个类从其他类继承功能。我们将使用同样的技术来使用我们已有的内容来导入多边形。
- en: Since the processing of geocaching points and polygons may have its particularities,
    it will need some of the things to be specific for each one. A specific example
    is the _parse_data method that, for now, converts features into geocaching points.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 由于地理藏点和多边形的处理可能有其特殊性，因此需要针对每个对象具体指定一些内容。一个具体的例子是_parse_data方法，目前它将特征转换为地理藏点。
- en: So, it’s not a good idea to make the class that represents polygons to inherit
    directly from the PointCollection class. Instead, the idea is to have two base
    classes, one that represents a single object and other that represents a collection
    of that object. These base classes will contain methods that are common to the
    points and the polygons, then the child classes will contain methods specific
    for each case.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，直接从PointCollection类继承来表示多边形类不是一个好主意。相反，想法是拥有两个基类，一个表示单个对象，另一个表示该对象的集合。这些基类将包含点和多边形共有的方法，然后子类将包含针对每种情况的特定方法。
- en: The polygons that we will import could be countries, boundaries, states, or
    provinces of a country, city, district regions, and so on. Since it’s not clear
    yet, let’s call it *boundaries*.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要导入的多边形可能是国家、边界、州或省、城市、区域等。由于目前还不清楚，让我们称它为*boundaries*。
- en: 'This is explained in the following steps:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在以下步骤中解释：
- en: 1\. We will start creating the BaseGeoObject object and adapting from the Geocache
    class. Open the models.py file in the Chapter4 folder.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 我们将开始创建BaseGeoObject对象，并从Geocache类进行适配。打开Chapter4文件夹中的models.py文件。
- en: 2\. Make a copy of the Geocache class with all its methods (copy and paste).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 创建Geocache类的副本，包含所有方法（复制粘贴）。
- en: 3\. Rename the first copy to BaseGeoObject and change docstring to something
    like
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 将第一个副本重命名为BaseGeoObject，并更改文档字符串为类似
- en: '"Base class for single geo objects.". You should have this: class BaseGeoObject(object):'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '"Base class for single geo objects.". 你应该有这个：class BaseGeoObject(object):'
- en: '"""Base class for a single geo object."""'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '"""Base class for a single geo object."""'
- en: 'def __init__(self, lat, lon, attributes=None):'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, lat, lon, attributes=None):'
- en: self.lat = lat
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: self.lat = lat
- en: self.lon = lon
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: self.lon = lon
- en: self.attributes = attributes
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: self.attributes = attributes
- en: '@property'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def coordinates(self):'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 'def coordinates(self):'
- en: return self.lat, self.lon
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: return self.lat, self.lon
- en: 'class Geocache(object):'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Geocache(object):'
- en: '"""This class represents a single geocaching point."""'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '"""这个类代表了一个单个的地理藏点。”'
- en: 'def __init__(self, lat, lon, attributes=None):'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, lat, lon, attributes=None):'
- en: self.lat = lat
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: self.lat = lat
- en: self.lon = lon
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: self.lon = lon
- en: self.attributes = attributes
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: self.attributes = attributes
- en: '@property'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def coordinates(self):'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 'def coordinates(self):'
- en: return self.lat, self.lon
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: return self.lat, self.lon
- en: Now try to think, looking at both of the classes, what is specific for the Geocache,
    what doesn’t belong to a generic GeoObject or what belongs to it, and what properties
    and methods every type of geospatial object could have.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试思考，看着这两个类，Geocache有什么是特定的，什么不属于通用GeoObject或属于它，以及每种类型的地理空间对象可能有哪些属性和方法。
- en: This separation could lead to some debate, and sometimes, depending on the complexity
    of the project and the nature of what you are dealing with, it may be hard to
    reach a final
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离可能会引起一些争议，有时，根据项目的复杂性和你处理的事物的性质，可能很难达成最终
- en: state in the first iteration through the code. In your projects, you may need
    to come back and change how the classes are organized more than once.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第一遍迭代中。在你的项目中，你可能需要多次回来更改类的组织方式。
- en: 'For now, I’m going to propose the following logic:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将提出以下逻辑：
- en: '**Lat, lon**: These properties are for the Geocache only. As we saw, we may
    have other types of geometries and we want to generalize how the geometries are
    stored.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**纬度，经度**: 这些属性仅适用于Geocache。正如我们所见，我们可能有其他类型的几何形状，我们希望泛化几何形状的存储方式。'
- en: '**Attributes**: All the objects should have this property.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**: 所有对象都应该具有这个属性。'
- en: '**A __repr__ method**: This is another *magic method* like __init__ and __add__
    that we had in the previous chapter. __repr__ is called when you use the print()
    function on an object. We will add it and set it to not be implemented on the
    base class, because every type of object should have its own representation.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个 __repr__ 方法**: 这是另一个像 __init__ 和 __add__ 一样的“魔法方法”，我们在上一章中提到过。当你在对象上使用print()函数时，会调用__repr__。我们将添加它，并将其设置为在基类中不实现，因为每种类型的对象都应该有自己的表示。'
- en: '**Coordinates property**: All geo objects should have coordinates, but how
    it is implemented here is specific to the Geocache. We will change that to a generic
    form: a geom property that will contain the object geometry.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**坐标属性**: 所有地理对象都应该有坐标，但在这里的实现方式是针对Geocache特定的。我们将将其改为通用形式：一个包含对象几何形状的geom属性。'
- en: 'Let’s make the first changes to these classes. Edit your code to be as follows:
    class BaseGeoObject(object):'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们对这些类进行第一次修改。编辑你的代码如下：class BaseGeoObject(object):'
- en: '"""Base class for a single geo object."""'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '"""单个地理对象的基类。”'
- en: 'def __init__(self, geometry, attributes=None):'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, geometry, attributes=None):'
- en: self.geom = geometry
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: self.geom = geometry
- en: self.attributes = attributes
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: self.attributes = attributes
- en: '@property'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def coordinates(self):'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 'def coordinates(self):'
- en: raise NotImplementedError
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: 'def __repr__(self):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: raise NotImplementedError
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: 'class Geocache(BaseGeoObject):'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Geocache(BaseGeoObject):'
- en: '"""This class represents a single geocaching point."""'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '"""这个类表示单个地理藏点。”'
- en: 'def __init__(self, geometry, attributes=None):'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, geometry, attributes=None):'
- en: super(Geocache, self).__init__(geometry, attributes)
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: super(Geocache, self).__init__(geometry, attributes)
- en: 'def __repr__(self):'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: name = self.attributes.get('name', 'Unnamed')
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: name = self.attributes.get('name', 'Unnamed')
- en: return "{} {} - {}".format(self.geom.x,
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: return "{} {} - {}".format(self.geom.x,
- en: self.geom.y, name)
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: self.geom.y, name)
- en: A geom property was added to the class as a required argument while instantiating
    it. In this property, we will store the Shapely object. The lat and lon properties
    were removed; they can be accessed directly from the Shapely object (geom) and
    we will adapt PointCollection to do this.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化时，向类中添加了一个geom属性作为必需参数。在这个属性中，我们将存储Shapely对象。lat和lon属性已被删除；它们可以直接从Shapely对象（geom）访问，我们将调整PointCollection以实现这一点。
- en: The __repr__ method of the Geocache class returns a string containing the coordinates
    of the point and the name attribute when it’s available or Unnamed.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: Geocache类的__repr__方法返回一个包含点的坐标和名称属性（如果可用）或“Unnamed”的字符串。
- en: 'Now add the Boundary class:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加Boundary类：
- en: 'class Boundary(BaseGeoObject):'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Boundary(BaseGeoObject):'
- en: '"""Represents a single political Boundary."""'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '"""表示单个政治边界。”'
- en: 'def __repr__(self):'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: return self.name
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: return self.name
- en: For now, the Boundary class is almost the same as the BaseGeoObject class, so
    we only change the __repr__ method, so it returns only the name of the boundary.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Boundary类几乎与BaseGeoObject类相同，所以我们只更改__repr__方法，使其只返回边界的名称。
- en: 'The next step is to edit the collection classes. Our PointCollection class
    is almost compatible with the new organization. We only need to make a few changes
    to the _parse_data method, transform this class into a base class, and create
    the classes that will inherit from it:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编辑集合类。我们的PointCollection类几乎与新组织兼容。我们只需要对_parse_data方法进行一些修改，将这个类转换为基类，并创建从它继承的类：
- en: 1\. First, like we did earlier, make a copy of the PointCollection class.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 首先，就像我们之前做的那样，复制PointCollection类。
- en: '2\. Now, rename the first occurrence of this class and change its docstring:
    class BaseGeoCollection(object):'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '2\. 现在，重命名这个类的第一次出现并更改其文档字符串：class BaseGeoCollection(object):'
- en: '"""This class represents a collection of spatial data."""'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '"""这个类代表了一个空间数据的集合。”'
- en: '...'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '3\. Go to the _parse_data method and alter it to be as follows:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 前往 _parse_data 方法并修改它如下：
- en: '#...'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def _parse_data(self, features):'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _parse_data(self, features):'
- en: raise NotImplementedError
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: 'What we did here was we explicitly told that this method is not implemented
    in the base class. This is a good practice for two reasons: first it is a hint
    for the programmer that this method needs to be implemented when this class is
    inherited and it also states the *signature* for the method (the arguments that
    it should receive). Secondly, if it is not implemented, Python will raise NotImplementedError
    instead of AttributeError, leading to a better debugging experience.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里明确指出，这个方法在基类中未实现。这样做有两个原因：首先，它向程序员提供了一个提示，即当这个类被继承时需要实现这个方法；它还声明了方法的 *签名*（它应该接收的参数）。其次，如果没有实现，Python
    将引发 NotImplementedError 而不是 AttributeError，这会导致更好的调试体验。
- en: '1\. Before we continue, edit the imported modules at the beginning of the file
    to match the following code:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在我们继续之前，编辑文件开头的导入模块以匹配以下代码：
- en: coding=utf-8
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: from __future__ import print_function
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 从 __future__ 导入 print_function
- en: import gdal
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 gdal
- en: from shapely.geometry import Point
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 从 shapely.geometry 导入 Point
- en: from shapely import wkb, wkt
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 从 shapely 导入 wkb 和 wkt
- en: from utils.geo_functions import open_vector_file
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 从 utils.geo_functions 导入 open_vector_file
- en: 2\. The base class is ready and now we are going to edit the PointCollection
    class.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 基类已经准备好了，现在我们将编辑 PointCollection 类。
- en: Firstly, you can remove all the methods from this class. Leave only the docstring
    and the _parse_data method.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以从这个类中删除所有方法。只留下文档字符串和 _parse_data 方法。
- en: 3\. Edit the class declaration and make it inherit from BaseGeoCollection.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 编辑类声明并使其继承自 BaseGeoCollection。
- en: '4\. Finally, edit the _parse_data method to be compliant with the geometry
    represented by Shapely objects. Your code should be as follows:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 最后，编辑 _parse_data 方法以符合 Shapely 对象表示的几何形状。您的代码应如下所示：
- en: 'class PointCollection(BaseGeoCollection):'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 'class PointCollection(BaseGeoCollection):'
- en: '"""This class represents a collection of'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '"""这个类代表了一个空间数据的集合。'
- en: geocaching points.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 地理藏宝点。
- en: '"""'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'def _parse_data(self, features):'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _parse_data(self, features):'
- en: '"""Transforms the data into Geocache objects.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将数据转换为 Geocache 对象。'
- en: ':param features: A list of features.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: ':param features: 特征列表。'
- en: '"""'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'for feature in features:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in features:'
- en: coords = feature['geometry']['coordinates']
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: coords = feature['geometry']['coordinates']
- en: point = Point(float(coords[1]), float(coords[0]))
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: point = Point(float(coords[1]), float(coords[0]))
- en: attributes = feature['properties']
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: attributes = feature['properties']
- en: cache_point = Geocache(point, attributes = attributes)
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: cache_point = Geocache(point, attributes = attributes)
- en: self.data.append(cache_point)
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: self.data.append(cache_point)
- en: Note that the difference is that while instancing the Geocache, instead of passing
    the coordinates, we are now passing a Point object, which is an instance of the
    Point class provided by Shapely.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，区别在于在实例化 Geocache 时，我们不再传递坐标，而是现在传递一个 Point 对象，它是 Shapely 提供的 Point 类的实例。
- en: '5\. Next we are going to create the BoundaryCollection class. Insert this code
    anywhere after the base classes:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 接下来，我们将创建 BoundaryCollection 类。在任何基类之后插入此代码：
- en: 'class BoundaryCollection(BaseGeoCollection):'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 'class BoundaryCollection(BaseGeoCollection):'
- en: '"""This class represents a collection of'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '"""这个类代表了一个空间数据的集合。'
- en: geographic boundaries.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 地理边界。
- en: '"""'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'def _parse_data(self, features):'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _parse_data(self, features):'
- en: 'for feature in features:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in features:'
- en: geom = feature['geometry']['coordinates']
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: geom = feature['geometry']['coordinates']
- en: attributes = feature['properties']
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: attributes = feature['properties']
- en: polygon = wkt.loads(geom)
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: polygon = wkt.loads(geom)
- en: boundary = Boundary(geometry=polygon,
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: boundary = Boundary(geometry=polygon,
- en: attributes=attributes)
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: attributes=attributes)
- en: self.data.append(boundary)
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: self.data.append(boundary)
- en: The difference from PointCollection is that we are now creating polygons and
    instances of the Boundary class. Note how the polygon is created with the statement
    wkt.loads(geom).
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 与 PointCollection 的区别在于我们现在正在创建多边形和 Boundary 类的实例。注意多边形是如何通过语句 wkt.loads(geom)
    创建的。
- en: '6\. We are almost done. Check whether everything is correct. The complete models.py
    file should contain the following code:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 我们几乎完成了。检查是否一切正确。完整的 models.py 文件应包含以下代码：
- en: coding=utf-8
  id: totrans-516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: from __future__ import print_function
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 从 __future__ 导入 print_function
- en: import gdal
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 gdal
- en: from shapely.geometry import Point
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 从 shapely.geometry 导入 Point
- en: from shapely import wkb, wkt
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 从 shapely 导入 wkb 和 wkt
- en: from utils.geo_functions import open_vector_file
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 从 utils.geo_functions 导入 open_vector_file
- en: 'class BaseGeoObject(object):'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 'class BaseGeoObject(object):'
- en: '"""Base class for a single geo object."""'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '"""Base class for a single geo object."""'
- en: 'def __init__(self, geometry, attributes=None):'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, geometry, attributes=None):'
- en: self.geom = geometry
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: self.geom = geometry
- en: self.attributes = attributes
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: self.attributes = attributes
- en: '@property'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def coordinates(self):'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 'def coordinates(self):'
- en: raise NotImplementedError
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: 'def __repr__(self):'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: raise NotImplementedError
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: 'class Geocache(BaseGeoObject):'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Geocache(BaseGeoObject):'
- en: '"""This class represents a single geocaching point."""'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '"""This class represents a single geocaching point."""'
- en: 'def __init__(self, geometry, attributes=None):'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, geometry, attributes=None):'
- en: super(Geocache, self).__init__(geometry, attributes)
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: super(Geocache, self).__init__(geometry, attributes)
- en: 'def __repr__(self):'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: name = self.attributes.get('name', 'Unnamed')
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: name = self.attributes.get('name', 'Unnamed')
- en: return "{} {} - {}".format(self.geom.x,
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: return "{} {} - {}".format(self.geom.x,
- en: self.geom.y, name)
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: self.geom.y, name)
- en: 'class Boundary(BaseGeoObject):'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Boundary(BaseGeoObject):'
- en: '"""Represents a single geographic boundary."""'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '"""Represents a single geographic boundary."""'
- en: 'def __repr__(self):'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: return self.attributes.get('name', 'Unnamed')
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: return self.attributes.get('name', 'Unnamed')
- en: 'class BaseGeoCollection(object):'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 'class BaseGeoCollection(object):'
- en: '"""This class represents a collection of spatial data."""'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '"""This class represents a collection of spatial data."""'
- en: 'def __init__(self, file_path=None):'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, file_path=None):'
- en: self.data = []
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = []
- en: self.epsg = None
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: self.epsg = None
- en: 'if file_path:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 'if file_path:'
- en: self.import_data(file_path)
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: self.import_data(file_path)
- en: 'def __add__(self, other):'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __add__(self, other):'
- en: self.data += other.data
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: self.data += other.data
- en: return self
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: 'def import_data(self, file_path):'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 'def import_data(self, file_path):'
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '"""Opens an vector file compatible with OGR and parses the data.'
- en: ':param str file_path: The full path to the file.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: ':param str file_path: The full path to the file.'
- en: '"""'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: features, metadata = open_vector_file(file_path)
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: features, metadata = open_vector_file(file_path)
- en: self._parse_data(features)
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: self._parse_data(features)
- en: self.epsg = metadata['epsg']
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: self.epsg = metadata['epsg']
- en: 'print("File imported: {}".format(file_path))'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("File imported: {}".format(file_path))'
- en: 'def _parse_data(self, features):'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _parse_data(self, features):'
- en: raise NotImplementedError
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: 'def describe(self):'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 'def describe(self):'
- en: 'print("SRS EPSG code: {}".format(self.epsg))'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("SRS EPSG code: {}".format(self.epsg))'
- en: 'print("Number of features: {}".format(len(self.data))) class PointCollection(BaseGeoCollection):'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("Number of features: {}".format(len(self.data))) class PointCollection(BaseGeoCollection):'
- en: '"""This class represents a collection of'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '"""This class represents a collection of'
- en: geocaching points.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: geocaching points.
- en: '"""'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'def _parse_data(self, features):'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _parse_data(self, features):'
- en: '"""Transforms the data into Geocache objects.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '"""Transforms the data into Geocache objects.'
- en: ':param features: A list of features.'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: ':param features: A list of features.'
- en: '"""'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'for feature in features:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in features:'
- en: coords = feature['geometry']['coordinates']
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: coords = feature['geometry']['coordinates']
- en: point = Point(coords)
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: point = Point(coords)
- en: attributes = feature['properties']
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: attributes = feature['properties']
- en: cache_point = Geocache(point, attributes=attributes)
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: cache_point = Geocache(point, attributes=attributes)
- en: self.data.append(cache_point)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: self.data.append(cache_point)
- en: 'class BoundaryCollection(BaseGeoCollection):'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 'class BoundaryCollection(BaseGeoCollection):'
- en: '"""This class represents a collection of'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '"""This class represents a collection of'
- en: geographic boundaries.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: geographic boundaries.
- en: '"""'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'def _parse_data(self, features):'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _parse_data(self, features):'
- en: 'for feature in features:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in features:'
- en: geom = feature['geometry']['coordinates']
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: geom = feature['geometry']['coordinates']
- en: attributes = feature['properties']
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: attributes = feature['properties']
- en: polygon = wkt.loads(geom)
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: polygon = wkt.loads(geom)
- en: boundary = Boundary(geometry=polygon,
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: boundary = Boundary(geometry=polygon,
- en: attributes=attributes)
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: attributes=attributes)
- en: self.data.append(boundary)
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: self.data.append(boundary)
- en: 7\. Now, in order to test it, go to the end of the file and edit the if __name__
    ==
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. Now, in order to test it, go to the end of the file and edit the if __name__
    ==
- en: '''__main__'': block:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '''__main__'': block:'
- en: 'if __name__ == ''__main__'':'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: 'world = BoundaryCollection("../data/world_borders_simple.shp") for item in
    world.data:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 'world = BoundaryCollection("../data/world_borders_simple.shp") for item in
    world.data:'
- en: print(item)
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: print(item)
- en: '8\. Now run it, press *Alt* + *Shift* + *F10*, and select models. If everything
    is OK, you should see a long list of the unnamed countries:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '8\. Now run it, press *Alt* + *Shift* + *F10*, and select models. If everything
    is OK, you should see a long list of the unnamed countries:'
- en: 'File imported: ../data/world_borders_simple.shp'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 'File imported: ../data/world_borders_simple.shp'
- en: Unnamed
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 未命名
- en: Unnamed
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 未命名
- en: Unnamed
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 未命名
- en: Unnamed…
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 未命名…
- en: Process finished with exit code 0
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: This is disappointing. We expected to see the names of the countries, but for
    some reason, the program failed to get it from the attributes. We will solve this
    problem in the next topic.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: This is disappointing. We expected to see the names of the countries, but for
    some reason, the program failed to get it from the attributes. We will solve this
    problem in the next topic.
- en: '**Getting the attributes’ values**'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取属性值**'
- en: Let’s explore the attributes of the world borders to find out why we were unable
    to get the names.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索世界边界的属性，以了解为什么我们无法获取名称。
- en: '1\. Edit the if __name__ == ''__main__'': block:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 编辑if __name__ == '__main__'块：
- en: 'if __name__ == ''__main__'':'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: world = BoundaryCollection("../data/world_borders_simple.shp") print(world.data[0].attributes.keys())
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: world = BoundaryCollection("../data/world_borders_simple.shp") print(world.data[0].attributes.keys())
- en: '2\. Run the code and look at the output:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 运行代码并查看输出：
- en: 'File imported: ../data/world_borders_simple.shp'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 'File imported: ../data/world_borders_simple.shp'
- en: '[''SUBREGION'', ''POP2005'', ''REGION'', ''ISO3'', ''ISO2'', ''FIPS'', ''UN'','
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '[''SUBREGION'', ''POP2005'', ''REGION'', ''ISO3'', ''ISO2'', ''FIPS'', ''UN'','
- en: '''NAME'']'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '''NAME'']'
- en: Process finished with exit code 0
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: What we did was we got the first item in world.data and then printed its attribute
    keys. The list shown in the output has a NAME key, but it is all in the uppercase.
    This is very common for Shapefiles whose data is contained in the DBF files.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是获取world.data中的第一个项目，然后打印其属性键。输出中显示的列表有一个NAME键，但它全部是大写的。这对于包含在DBF文件中的数据Shapefiles来说非常常见。
- en: 'Since we don’t want to worry if the attributes’ names are in the uppercase
    or lowercase, we have two possible solutions: convert the names at the moment
    of the import or convert the names on the fly when the attribute value is requested.'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望担心属性名称是大写还是小写，我们有两个可能的解决方案：在导入时转换名称，或者在请求属性值时即时转换名称。
- en: Depending on your application, you may achieve better performance with one or
    the other method. Here, for didactic purposes, we will opt for the on-the-fly
    conversion and add a little spice to it.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的应用程序，您可能可以使用其中一种方法获得更好的性能。在这里，为了教学目的，我们将选择即时转换并给它添加一点趣味。
- en: 3\. Instead of accessing the attributes directly, let’s make a method that will
    do it for us.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 而不是直接访问属性，让我们创建一个为我们完成这项工作的方法。
- en: 'Edit the BaseGeoObject class’ __init__ method and also add a get_attribute
    method:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑BaseGeoObject类的__init__方法，并添加一个get_attribute方法：
- en: 'class BaseGeoObject(object):'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 'class BaseGeoObject(object):'
- en: '"""Base class for a single geo object."""'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '"""Base class for a single geo object."""'
- en: 'def __init__(self, geometry, attributes=None):'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, geometry, attributes=None):'
- en: self.geom = geometry
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: self.geom = geometry
- en: self.attributes = attributes
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: self.attributes = attributes
- en: '**# Makes a lookup table of case insensitive attributes.**'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '**# 创建不区分大小写的属性查找表。**'
- en: '**self._attributes_lowercase = {}**'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**self._attributes_lowercase = {}**'
- en: '**for key in self.attributes.keys():**'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '**for key in self.attributes.keys():**'
- en: '**self._attributes_lowercase[key.lower()] = key**'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**self._attributes_lowercase[key.lower()] = key**'
- en: '@property'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def coordinates(self):'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 'def coordinates(self):'
- en: raise NotImplementedError
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: 'def get_attribute(self, attr_name, case_sensitive=False):'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_attribute(self, attr_name, case_sensitive=False):'
- en: '"""Gets an attribute by its name.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过名称获取属性。'
- en: ':param attr_name: The name of the attribute.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: ':param attr_name: 属性的名称。'
- en: ':param case_sensitive: True or False.'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: ':param case_sensitive: True或False。'
- en: '"""'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if not case_sensitive:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not case_sensitive:'
- en: attr_name = attr_name.lower()
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: attr_name = attr_name.lower()
- en: attr_name = self._attributes_lowercase[attr_name]
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: attr_name = self._attributes_lowercase[attr_name]
- en: return self.attributes[attr_name]
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: return self.attributes[attr_name]
- en: 'def __repr__(self):'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: raise NotImplementedError
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: In the __init__ method, we made a dictionary that contains the equivalence between
    lowercase attribute names and the original names. If you search the Internet,
    there is a number of techniques to implement case-insensitive dictionaries. But
    the one we implemented here allows us to preserve the original names, giving the
    user the option to choose whether he wants the search to be case-sensitive or
    not.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 在__init__方法中，我们创建了一个包含小写属性名称与原始名称之间等价的字典。如果您在互联网上搜索，会发现有许多技术可以实现不区分大小写的字典。但我们在这里实现的方法允许我们保留原始名称，使用户可以选择是否希望搜索区分大小写。
- en: '4\. Now, edit the Boundary class to use the new method:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 现在，编辑Boundary类以使用新方法：
- en: 'class Boundary(BaseGeoObject):'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Boundary(BaseGeoObject):'
- en: '"""Represents a single geographic boundary."""'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '"""Represents a single geographic boundary."""'
- en: 'def __repr__(self):'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: return self.get_attribute('name')
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: return self.get_attribute('name')
- en: '5\. Edit the if __name__ == ''__main__'': block:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 编辑if __name__ == '__main__'块：
- en: 'if __name__ == ''__main__'':'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: 'world = BoundaryCollection("../data/world_borders_simple.shp") for item in
    world.data:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 'world = BoundaryCollection("../data/world_borders_simple.shp") for item in
    world.data:'
- en: print(item)
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: print(item)
- en: '6\. Run the code again. Now, you should have a beautiful list of country names:
    File imported: ../data/world_borders_simple.shp'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 再次运行代码。现在，你应该有一个漂亮的国籍名称列表：导入的文件：../data/world_borders_simple.shp
- en: Antigua and Barbuda
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 安提瓜和巴布达
- en: Algeria
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 阿尔及利亚
- en: Azerbaijan
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 阿塞拜疆
- en: Albania
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 阿尔巴尼亚
- en: Armenia…
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 亚美尼亚…
- en: Process finished with exit code 0
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码 0 完成
- en: '**Importing lines**'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '**导入线**'
- en: As we did with the geocaching points and political boundaries, we will implement
    the ability of the program to import lines (that is, linestrings). These lines
    can represent roads, rivers, power lines, and so on. With this kind of features,
    we will be able to search for points that are close to a given road for example.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在地理藏宝点和政治边界中所做的那样，我们将实现程序导入线（即线字符串）的能力。这些线可以代表道路、河流、电力线等。有了这类特性，我们将能够搜索靠近给定道路的点等。
- en: 'The lines and the collection of lines will also be the subclasses of BaseGeoObject
    and BaseGeoCollection. Let’s start by making a LineString and a LineStringCollection
    class, as follows:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 线和线集合也将是 BaseGeoObject 和 BaseGeoCollection 的子类。让我们首先创建一个 LineString 和 LineStringCollection
    类，如下所示：
- en: '1\. Insert this new class into the models.py file. It could be anywhere after
    the base classes’ definition:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 将这个新类插入到 models.py 文件中。它可以在基类定义之后任何位置：
- en: 'class LineString(BaseGeoObject):'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 'class LineString(BaseGeoObject):'
- en: '"""Represents a single linestring."""'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '"""表示单个线字符串。”'
- en: 'def __repr__(self):'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: return self.get_attribute('name')
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: return self.get_attribute('name')
- en: Again, we only implement the __repr__ method. The other functionalities are
    inherited from the BaseGeoObject class.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们只实现了 __repr__ 方法。其他功能是从 BaseGeoObject 类继承的。
- en: '2\. Now, add the class representing a collection of linestrings and its _parse_data
    method:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在，添加一个表示线字符串集合的类及其 _parse_data 方法：
- en: 'class LineStringCollection(BaseGeoCollection):'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 'class LineStringCollection(BaseGeoCollection):'
- en: '"""Represents a collection of linestrings."""'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '"""表示线字符串的集合。”'
- en: 'def _parse_data(self, features):'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _parse_data(self, features):'
- en: 'for feature in features:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in features:'
- en: geom = feature['geometry']['coordinates']
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: geom = feature['geometry']['coordinates']
- en: attributes = feature['properties']
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: attributes = feature['properties']
- en: line = wkt.loads(geom)
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: line = wkt.loads(geom)
- en: linestring = LineString(geometry=line,
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: linestring = LineString(geometry=line,
- en: attributes=attributes)
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: attributes=attributes)
- en: self.data.append(linestring)
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: self.data.append(linestring)
- en: In order to test our new classes, we are going to use a shapefile containing
    USA’s main roads.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们新的类，我们将使用包含美国主要道路的 shapefile。
- en: '![Image 22](img/index-196_1.jpg)'
  id: totrans-681
  prefs: []
  type: TYPE_IMG
  zh: '![Image 22](img/index-196_1.jpg)'
- en: '3\. Edit the if __name__ == ''__main__'': block at the end of the file. You
    can comment the previous code if you wish instead of deleting it:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 编辑文件末尾的 if __name__ == '__main__' 块。如果你愿意，可以注释掉之前的代码而不是删除它：
- en: 'if __name__ == ''__main__'':'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: usa_roads = LineStringCollection('../data/roads.shp')
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: usa_roads = LineStringCollection('../data/roads.shp')
- en: 'for item in usa_roads.data:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in usa_roads.data:'
- en: print(item)
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: print(item)
- en: '4\. Run the code. You should get a big list of the road names in the output
    console: File imported: ../data/roads.shp'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 运行代码。你应该会在输出控制台中看到一个包含道路名称的大列表：导入文件：../data/roads.shp
- en: State Route 131
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路 131
- en: State Route 3
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路 3
- en: State Route 3
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路 3
- en: State Route 3
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路 3
- en: State Route 411
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路 411
- en: State Route 3
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路 3
- en: State Route 3
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路 3
- en: State Route 5, State Route 786…
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路 5，州际公路 786…
- en: Process finished with exit code 0
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码 0 完成
- en: In order to make our output more meaningful, we can change how each LineString
    class is printed. Remember that the special method named __repr__ is called when
    you use the print() function on an object, and it should return a string to be
    printed.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的输出更有意义，我们可以更改每个 LineString 类的打印方式。记住，当你在对象上使用 print() 函数时，会调用名为 __repr__
    的特殊方法，并且它应该返回一个要打印的字符串。
- en: Let’s return more information when LineString is printed.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在打印 LineString 时返回更多信息。
- en: '5\. Edit your LineString class and change the __repr__ method, so it returns
    the road name and length:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 编辑你的 LineString 类并更改 __repr__ 方法，使其返回道路名称和长度：
- en: 'class LineString(BaseGeoObject):'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 'class LineString(BaseGeoObject):'
- en: '"""Represents a single linestring."""'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '"""表示单个线字符串。”'
- en: 'def __repr__(self):'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: length = self.geom.length
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: length = self.geom.length
- en: return "{} - {}".format(self.get_attribute('name'), length)
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: return "{} - {}".format(self.get_attribute('name'), length)
- en: Here, we used Python’s string formatting to compose a string that can be returned
    by this method.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 Python 的字符串格式化来组成一个可以由此方法返回的字符串。
- en: '6\. Run the code and see the new output:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 运行代码并查看新的输出：
- en: 'File imported: ../data/roads.shp'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 导入文件：../data/roads.shp
- en: US Route 395-0.16619770512
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 美国公路 395-0.16619770512
- en: US Route 30-0.0432070790491
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 美国公路 30-0.0432070790491
- en: State Route 84-0.0256320861143
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路 84-0.0256320861143
- en: US Route 6-0.336460513878
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 美国公路 6-0.336460513878
- en: US Route 40-0.107844768871
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 美国公路 40-0.107844768871
- en: State Route 272-0.0264889614357…
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路272-0.0264889614357…
- en: Process finished with exit code 0
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 进程结束，退出代码为0
- en: Although it’s much better than before, it still has a problem. The length is
    in degrees, and it means little or nothing to us because we are used to meters,
    miles, or any other linear unity. So, we need to convert the unity before we print
    the length.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它比以前好得多，但它仍然有一个问题。长度是以度为单位，对我们来说意义不大，因为我们习惯于以米、英里或其他线性单位来衡量。因此，在打印长度之前，我们需要转换单位。
- en: '**Converting the spatial reference system**'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换空间参考系统**'
- en: '**and units**'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '**以及单位**'
- en: Fortunately, we already did this kind of operation before and now we are going
    to adapt it to our data model.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们之前已经执行过此类操作，现在我们将将其适应到我们的数据模型中。
- en: 'We will transform the coordinates of the geometries only when they are needed.
    To perform the transformation, we will create a new utility function, as follows:
    1\. Open geo_functions.py in our utils folder and create a new function: def transform_geometry(geom,
    src_epsg=4326, dst_epsg=3395):'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将在需要时才转换几何形状的坐标。为了执行转换，我们将创建一个新的实用函数，如下所示：1. 在我们的utils文件夹中打开geo_functions.py并创建一个新的函数：def
    transform_geometry(geom, src_epsg=4326, dst_epsg=3395):'
- en: '"""Transforms a single wkb geometry.'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将单个wkb几何形状进行转换。"""'
- en: ':param geom: wkb geom.'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: ':param geom: WKB几何形状.'
- en: ':param src_epsg: EPSG code for the source geometry.'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: ':param src_epsg: 源几何形状的EPSG代码。'
- en: ':param dst_epsg: EPSG code for the destination geometry.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: ':param dst_epsg: 目标几何形状的EPSG代码.'
- en: '"""'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ogr_geom = ogr.CreateGeometryFromWkb(geom)
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: ogr_geom = ogr.CreateGeometryFromWkb(geom)
- en: ogr_transformation = create_transform(src_epsg, dst_epsg)
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: ogr_transformation = create_transform(src_epsg, dst_epsg)
- en: ogr_geom.Transform(ogr_transformation)
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: ogr_geom.Transform(ogr_transformation)
- en: return ogr_geom.ExportToWkb()
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: return ogr_geom.ExportToWkb()
- en: It takes as arguments geometries in the WKB format, its EPSG code, and the EPSG
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受WKB格式的几何形状、其EPSG代码和EPSG
- en: code for the desired coordinate system for the output. It performs the transformation
    and returns a WKB geometry again.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 返回具有所需输出坐标系代码的WKB几何形状。它执行转换并返回一个WKB几何形状。
- en: Now back to the models; let’s import this function and use it.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到模型；让我们导入这个函数并使用它。
- en: '2\. Edit the import at the beginning of the models.py file:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在models.py文件的开始处编辑导入：
- en: coding=utf-8
  id: totrans-733
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: from __future__ import print_function
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: from __future__ import print_function
- en: import gdal
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: import gdal
- en: from shapely.geometry import Point
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: from shapely.geometry import Point
- en: from shapely import wkb, wkt
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: from shapely import wkb, wkt
- en: from utils.geo_functions import open_vector_file
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: from utils.geo_functions import open_vector_file
- en: '**from utils.geo_functions import transform_geometry**'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '**从utils.geo_functions导入transform_geometry**'
- en: '3\. Now, edit BaseGeoObject, so our classes can inherit this new functionality:
    class BaseGeoObject(object):'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '3. 现在，编辑BaseGeoObject，以便我们的类可以继承这个新功能：class BaseGeoObject(object):'
- en: '"""Base class for a single geo object."""'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '"""单个地理对象的基类。"""'
- en: 'def __init__(self, geometry, attributes=None):'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, geometry, attributes=None):'
- en: self.geom = geometry
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: self.geom = geometry
- en: self.attributes = attributes
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: self.attributes = attributes
- en: '**self.wm_geom = None**'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '**self.wm_geom = None**'
- en: Makes a lookup table of case insensitive attributes.
  id: totrans-746
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个不区分大小写的属性查找表。
- en: self._attributes_lowercase = {}
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: self._attributes_lowercase = {}
- en: 'for key in self.attributes.keys():'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 'for key in self.attributes.keys():'
- en: self._attributes_lowercase[key.lower()] = key
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: self._attributes_lowercase[key.lower()] = key
- en: '**def transformed_geom(self):**'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '**def transformed_geom(self):**'
- en: '**"""Returns the geometry transformed into WorldMercator** **coordinate system.**'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '**"""返回转换为WorldMercator坐标系统的几何形状。**'
- en: '**"""**'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '**"""**'
- en: '**if not self.wm_geom:**'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果self.wm_geom不存在：**'
- en: '**geom = transform_geometry(self.geom.wkb)**'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '**geom = transform_geometry(self.geom.wkb)**'
- en: '**self.wm_geom = wkb.loads(geom)**'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '**self.wm_geom = wkb.loads(geom)**'
- en: '**return self.wm_geom**'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '**return self.wm_geom**'
- en: 'def get_attribute(self, attr_name, case_sensitive=False):'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_attribute(self, attr_name, case_sensitive=False):'
- en: '"""Gets an attribute by its name.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过名称获取属性。"""'
- en: ':param attr_name: The name of the attribute.'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: ':param attr_name: 属性的名称。'
- en: ':param case_sensitive: True or False.'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: ':param case_sensitive: True或False.'
- en: '"""'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if not case_sensitive:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not case_sensitive:'
- en: attr_name = attr_name.lower()
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: attr_name = attr_name.lower()
- en: attr_name = self._attributes_lowercase[attr_name]
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: attr_name = self._attributes_lowercase[attr_name]
- en: return self.attributes[attr_name]
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: return self.attributes[attr_name]
- en: 'def __repr__(self):'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: raise NotImplementedError
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: Note that we opted to keep the geometries in both the coordinate systems. The
    geometry in WorldMercator is stored in the wm_geom property the first time the
    transformation occurs. The next time transformed_geom is called, it will only
    get the property value. This is called **memorization** and we will see more of
    this technique later in the book.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们选择保留几何形状在两个坐标系中。在第一次转换时，WorldMercator 中的几何形状存储在 wm_geom 属性中。下一次调用 transformed_geom
    时，它将只获取属性值。这被称为 **记忆化**，我们将在本书的后面部分看到更多关于这种技术的例子。
- en: Depending on your application, this may be a good practice because you may want
    to use different coordinate systems for specific purposes. For example, to draw
    a map, you may want to use lat/lon and, to perform calculation, you would need
    the coordinates in meters. The downside is that the memory consumption is higher,
    because you will be storing two sets of geometry.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的应用程序，这可能是一个好习惯，因为您可能希望为特定目的使用不同的坐标系。例如，为了绘制地图，您可能希望使用经纬度，而为了进行计算，您将需要以米为单位的坐标。缺点是内存消耗更高，因为您将存储两组几何形状。
- en: '4\. Finally, we go back to the LineString class and change its __repr__ method
    to use transformed_geom to calculate the length:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 最后，我们回到 LineString 类，并更改其 __repr__ 方法以使用 transformed_geom 来计算长度：
- en: 'class LineString(BaseGeoObject):'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 'class LineString(BaseGeoObject):'
- en: '"""Represents a single linestring."""'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '"""表示单个线字符串。”'
- en: 'def __repr__(self):'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: 'return "{}-{}".format(self.get_attribute(''name''), **self.transformed_geom().length)**
    5\. Run the code and see the new output:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: return "{}-{}".format(self.get_attribute('name'), **self.transformed_geom().length)**
    5. 运行代码并查看新的输出：
- en: 'File imported: ../data/roads.shp'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 导入文件：../data/roads.shp
- en: State Route 3-100928.690515
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路 3-100928.690515
- en: State Route 411-3262.29448315
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路 411-3262.29448315
- en: State Route 3-331878.76971
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路 3-331878.76971
- en: State Route 3-56013.8246795.73…
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路 3-56013.8246795.73…
- en: Process finished with exit code 0
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完成，退出代码为 0
- en: It’s much better now as we can see the road lengths in meters. But it is still
    not perfect
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 现在好多了，因为我们现在可以看到以米为单位的道路长度。但仍然不完美
- en: because, normally, we would want the lengths in kilometres or miles. So, we
    need to convert the unit.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: because, normally, we would want the lengths in kilometres or miles. So, we
    need to convert the unit.
- en: In [Chapter 1,](index_split_000.html#p45) *Preparing the Work Environment*,
    we made a beautiful function capable of performing these transformations; we used
    it to convert area units. Using it as a template, we are going to implement it
    to convert length units.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第1章，](index_split_000.html#p45) *准备工作环境* 中，我们创建了一个美丽的函数，能够执行这些转换；我们用它来转换面积单位。以它为模板，我们将实现它以转换长度单位。
- en: Since it’s a function that can be used in other parts of any application, we
    are going to put it into the geo_functions.py module in the utils package (that
    is, directory).
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个可以在任何应用程序的任何部分使用的函数，我们将将其放入 utils 包（即目录）中的 geo_functions.py 模块中。
- en: 1\. Edit the geo_functions.py files and copy and paste the function that we
    used in
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 编辑 geo_functions.py 文件，并复制粘贴我们使用的函数
- en: '[Chapter 1,](index_split_000.html#p45) *Preparing the Work Environment*, to
    calculate and transform area units.'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章，](index_split_000.html#p45) *准备工作环境*，用于计算和转换面积单位。'
- en: 'We will keep it there for later use:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留它以供以后使用：
- en: 'def calculate_areas(geometries, unity=''km2''):'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 'def calculate_areas(geometries, unity=''km2''):'
- en: '"""Calculate the area for a list of ogr geometries."""'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '"""计算一系列 ogr 几何形状的面积。”'
- en: conversion_factor = {
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: conversion_factor = {
- en: '''sqmi'': 2589988.11,'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '''sqmi'': 2589988.11,'
- en: '''km2'': 1000000,'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '''km2'': 1000000,'
- en: '''m'': 1}'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '''m'': 1}'
- en: 'if unity not in conversion_factor:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 'if unity not in conversion_factor:'
- en: raise ValueError(
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: raise ValueError(
- en: '"This unity is not defined: {}".format(unity))'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '"此单位未定义：{}".format(unity))'
- en: areas = []
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: areas = []
- en: 'for geom in geometries:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 'for geom in geometries:'
- en: area = geom.Area()
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: area = geom.Area()
- en: areas.append(area / conversion_factor[unity])
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: areas.append(area / conversion_factor[unity])
- en: return areas
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: return areas
- en: '2\. Duplicate this function (copy and paste) and edit it to make it like the
    following code: def convert_length_unit(value, unit=''km'', decimal_places=2):'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '2. 复制此函数（复制并粘贴）并编辑它，使其类似于以下代码：def convert_length_unit(value, unit=''km'', decimal_places=2):'
- en: '"""Convert the leng unit of a given value.'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将给定值的长度单位进行转换。'
- en: The input is in meters and the output is set by the unity
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是以米为单位，输出由单位设定
- en: argument.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 参数.
- en: ':param value: Input value in meters.'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: ':param value: 以米为单位的输入值。'
- en: ':param unit: The desired output unit.'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: ':param unit: 所需的输出单位。'
- en: ':param decimal_places: Number of decimal places of the output.'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: ':param decimal_places: 输出的小数位数。'
- en: '"""'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: conversion_factor = {
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: conversion_factor = {
- en: '''mi'': 0.000621371192,'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '''mi'': 0.000621371192,'
- en: '''km'': 0.001,'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '''km'': 0.001,'
- en: '''m'': 1.0}'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '''m'': 1.0}'
- en: 'if unit not in conversion_factor:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 'if unit not in conversion_factor:'
- en: raise ValueError(
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: raise ValueError(
- en: '"This unit is not defined: {}".format(unit))'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '"此单位未定义：{}".format(unit))'
- en: return round(value * conversion_factor[unit], decimal_places) Again, it’s a
    very versatile function because you can easily change its code to add more conversion
    factors to it. Here, we also introduced the round() function, so we can see a
    more readable result. By default, it will round the result to two decimal places,
    which in most cases, is enough for a good representation of length.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: return round(value * conversion_factor[unit], decimal_places) 再次，这是一个非常通用的函数，因为你可以轻松地更改其代码以向其中添加更多的转换因子。在这里，我们还引入了round()函数，因此我们可以看到更易读的结果。默认情况下，它将结果四舍五入到两位小数，这在大多数情况下，足以很好地表示长度。
- en: '3\. Go back to the models and import this new function after the other imports:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 返回模型并在此其他导入之后导入此新函数：
- en: coding=utf-8
  id: totrans-819
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: from __future__ import print_function
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: from __future__ import print_function
- en: import gdal
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: import gdal
- en: from shapely.geometry import Point
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: from shapely.geometry import Point
- en: from shapely import wkb, wkt
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: from shapely import wkb, wkt
- en: from utils.geo_functions import open_vector_file
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: from utils.geo_functions import open_vector_file
- en: from utils.geo_functions import transform_geometry
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: from utils.geo_functions import transform_geometry
- en: '**from utils.geo_functions import convert_length_unit**'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '**from utils.geo_functions import convert_length_unit**'
- en: '4\. Now edit the LineString class. We will add a *convenience method* (we will
    see more about this later in the chapter) that will return the length in a converted
    unit, change the __repr__ value to use it, and also improve the string formatting
    to display the unit and get a better output:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 现在编辑LineString类。我们将添加一个*方便方法*（我们将在本章后面了解更多关于此的内容），该方法将返回转换后的单位长度，更改__repr__值以使用它，并改进字符串格式化以显示单位并获得更好的输出：
- en: 'class LineString(BaseGeoObject):'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 'class LineString(BaseGeoObject):'
- en: '"""Represents a single linestring."""'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '"""表示单个线字符串。”'
- en: 'def __repr__(self):'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: '**unit = ''km''**'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '**unit = ''km''**'
- en: '**return "{} ({}{})".format(self.get_attribute(''name''),** **self.length(unit),
    unit)**'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '**return "{} ({}{})".format(self.get_attribute(''name''),** **self.length(unit),
    unit)**'
- en: '**def length(self, unit=''km''):**'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '**def length(self, unit=''km''):**'
- en: '**"""Convenience method that returns the length of the** **linestring in a
    given unit.**'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '**"""这是一个方便的方法，它返回给定单位中线的长度。"""'
- en: '**:param unit: The desired output unit.**'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '**:param unit: 所需的输出单位。**'
- en: '**"""**'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '**"""**'
- en: '**return convert_length_unit(self.transformed_geom().length,** **unit)**'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '**return convert_length_unit(self.transformed_geom().length,** **unit)**'
- en: '5\. Run the code again and see what we have accomplished:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 再次运行代码，看看我们取得了什么成果：
- en: 'File imported: ../data/roads.shp'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 导入文件：../data/roads.shp
- en: State Route 146 (10.77km)
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路146（10.77公里）
- en: US Route 7, US Route 20 (5.81km)
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 美国公路7，美国公路20（5.81公里）
- en: State Route 295 (13.67km)
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路295（13.67公里）
- en: Interstate Route 90 (3.55km)
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路90（3.55公里）
- en: State Route 152 (18.22km)
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路152（18.22公里）
- en: State Route 73 (65.19km)
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路73（65.19公里）
- en: State Route 20 (53.89km)
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路20（53.89公里）
- en: State Route 95 (10.38km)
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 州际公路95（10.38公里）
- en: '...'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Process finished with exit code 0
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码0结束
- en: '**Geometry relationships**'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '**几何关系**'
- en: We want to filter the geocaching points that fall inside a given boundary (a
    country, state, city, and so on.). In order to perform this kind of filtering,
    we need to verify every point and see whether it’s inside the polygon representing
    the boundary.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望过滤掉落在给定边界（一个国家、州、城市等）内的地理缓存点。为了执行此类过滤，我们需要验证每个点，看看它是否在表示边界的多边形内部。
- en: In geoprocessing, the relations between the two geometries are described by
    a set of known predicates. These relationships are very important because they
    allow conditions to be made, so one can perform operations and calculations.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 在地理处理中，两个几何体之间的关系由一组已知的谓词描述。这些关系非常重要，因为它们允许建立条件，从而可以进行操作和计算。
- en: Shapely comes with a complete set of predicates that analyze the relation of
    the two geometries. Before we go further in our app, let’s take a look at the
    possible relation checks.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely附带了一套完整的谓词，用于分析两个几何体之间的关系。在我们进一步开发应用程序之前，让我们看看可能的关系检查。
- en: '![Image 23](img/index-205_1.jpg)'
  id: totrans-854
  prefs: []
  type: TYPE_IMG
  zh: '![Image 23](img/index-205_1.jpg)'
- en: '**Touches**'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '**接触**'
- en: This is true if the geometries have one or more points in common without their
    interiors intersecting.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 如果几何体有一个或多个共同点，但它们的内部不相交，则这是正确的。
- en: '![Image 24](img/index-206_1.jpg)'
  id: totrans-857
  prefs: []
  type: TYPE_IMG
  zh: '![Image 24](img/index-206_1.jpg)'
- en: '**Crosses**'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '**交叉**'
- en: This is true if there is an intersection between the two objects without one
    containing the other.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个对象相交但没有一个包含另一个，则这是正确的。
- en: '![Image 25](img/index-207_1.jpg)'
  id: totrans-860
  prefs: []
  type: TYPE_IMG
  zh: '![Image 25](img/index-207_1.jpg)'
- en: '**Contains**'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '**包含**'
- en: This indicates if one object completely contains the other object; all the boundaries,
    lines, or points must be inside the first object.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示一个对象是否完全包含另一个对象；所有边界、线条或点都必须在第一个对象内部。
- en: '**Within**'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '**包含**'
- en: This is true if one geometry is contained in another geometry. It’s the same
    as *Contains*, but if you switch the two geometries.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个几何形状包含在另一个几何形状中，则这是真的。它与*包含*相同，但如果您交换这两个几何形状。
- en: '![Image 26](img/index-209_1.jpg)'
  id: totrans-865
  prefs: []
  type: TYPE_IMG
  zh: '![Image 26](img/index-209_1.jpg)'
- en: '**Equals or almost equals**'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '**等于或几乎相等**'
- en: This is true if the two objects have the same boundary and interior. Almost
    equals allows a configurable tolerance in the precision of the test.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个对象具有相同的边界和内部，则这是真的。几乎相等允许在测试精度的精度中配置容差。
- en: '![Image 27](img/index-210_1.jpg)'
  id: totrans-868
  prefs: []
  type: TYPE_IMG
  zh: '![Image 27](img/index-210_1.jpg)'
- en: '**Intersects**'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '**相交**'
- en: 'This indicates that one geometry intersects the other in any way. It is true
    if any of these relations are true: contains, crosses, equals, touches, and within.'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示一个几何形状以任何方式与另一个几何形状相交。如果以下任何关系为真，则这是真的：包含、交叉、相等、接触和包含。
- en: '![Image 28](img/index-211_1.jpg)'
  id: totrans-871
  prefs: []
  type: TYPE_IMG
  zh: '![Image 28](img/index-211_1.jpg)'
- en: '**Disjoint**'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '**不相交**'
- en: This returns true if the two geometries have no relation between them.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回true，如果两个几何形状之间没有关系。
- en: '**Filtering by attributes and relations**'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '**按属性和关系过滤**'
- en: Now that we know how geometries relate to each other, we can search points using
    these relations. We already have the means for importing the points and the polygons
    that represent any kind of boundaries that may be of our interest.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道几何形状是如何相互关联的，我们可以使用这些关系来搜索点。我们已经有导入点和表示任何可能对我们感兴趣的各种边界的多边形的方法。
- en: The data that comes with the book files contains examples of world countries’
    boundaries, but you are free to search the Internet for any data that is significant
    to you. Remember only that the data coordinates should be in latitudes and longitudes,
    and they need to have a name field.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 随书文件附带的数据包含世界国家边界的示例，但您可以自由地在互联网上搜索对您有意义的任何数据。请记住，数据坐标应以纬度和经度表示，并且它们需要有一个名称字段。
- en: For our tests, I prepared a special set of geocaching points that spans the
    whole globe, and as an exercise, we will filter these points by a country.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的测试，我准备了一套特殊的全球地理藏宝点，我们将通过一个国家来过滤这些点。
- en: 'The proposed workflow is as follows:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 建议的工作流程如下：
- en: Import the points and boundaries
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 导入点和边界
- en: Find the boundary that we want to use
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 找到我们想要使用的边界
- en: Filter the points by that boundary
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 通过该边界过滤点
- en: Return the points to the user
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 将点返回给用户
- en: To find the points that we want, we will iterate over the data until it hits
    a match. Iterations can be costly in terms of processing depending on the amount
    of data and on the operations that are performed on each loop. Let’s keep this
    in mind.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到我们想要的点，我们将遍历数据直到找到匹配项。迭代可能会根据数据量和每个循环上执行的操作而变得昂贵。让我们记住这一点。
- en: 'The first step in the workflow is already done, so let’s write the code to
    find the boundary of our interest. If you are using the data provided, we can
    find the boundary of your country as follows:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程的第一步已经完成，所以让我们编写代码来找到我们感兴趣的边界。如果您使用提供的数据，我们可以如下找到您国家的边界：
- en: '1\. Go to the BoundaryCollection class and add a new method get_by_name: class
    BoundaryCollection(BaseGeoCollection):'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '1. 前往BoundaryCollection类并添加一个新的方法get_by_name: class BoundaryCollection(BaseGeoCollection):'
- en: '"""This class represents a collection of'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '"""此类表示一组'
- en: geographic boundaries.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 地理边界。
- en: '"""'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'def _parse_data(self, features):'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _parse_data(self, features):'
- en: 'for feature in features:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in features:'
- en: geom = feature['geometry']['coordinates']
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: geom = feature['geometry']['coordinates']
- en: attributes = feature['properties']
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: attributes = feature['properties']
- en: polygon = wkt.loads(geom)
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: polygon = wkt.loads(geom)
- en: boundary = Boundary(geometry=polygon,
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: boundary = Boundary(geometry=polygon,
- en: attributes=attributes)
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: attributes=attributes)
- en: self.data.append(boundary)
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: self.data.append(boundary)
- en: 'def get_by_name(self, name):'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_by_name(self, name):'
- en: '"""Find an object by its name attribute and returns it."""'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过其名称属性查找对象并返回它。”'
- en: 'for item in self.data:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in self.data:'
- en: 'if item.get_attribute(''name'') == name:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 'if item.get_attribute(''name'') == name:'
- en: return item
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: return item
- en: raise LookupError(
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: raise LookupError(
- en: '"Object not found with the name: {}".format(name)) This very simple method
    iterates over the data. When it finds the first boundary'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '"未找到名为：{}".format(name)) 这种非常简单的方法遍历数据。当它找到第一个边界'
- en: whose name property matches the name passed as an argument, the function execution
    stops and the object is returned. If nothing is found, LookupError will be raised.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 其名称属性与传递给参数的名称匹配的对象，函数执行停止并返回对象。如果没有找到任何内容，将引发 LookupError。
- en: '2\. Let’s play with it. Go to the if __name__ == ''__main__'': block at the
    end of the file and edit it:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 让我们玩玩它。转到文件末尾的 if __name__ == '__main__' 块并编辑它：
- en: 'if __name__ == ''__main__'':'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: world = BoundaryCollection("../data/world_borders_simple.shp") print(world.get_by_name('Brazil'))
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: world = BoundaryCollection("../data/world_borders_simple.shp") print(world.get_by_name('Brazil'))
- en: '3\. Try the different countries’ names and see the results. If it’s found,
    you should have an output similar to this:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 尝试不同的国家名称并查看结果。如果找到了，你应该得到类似以下输出：
- en: 'File imported: ../data/world_borders_simple.shp'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '文件已导入: ../data/world_borders_simple.shp'
- en: Brazil
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 巴西
- en: Process finished with exit code 0
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 进程结束，退出代码为 0
- en: '4\. If it’s not found, you should get a nice exception:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 如果没有找到，你应该得到一个很好的异常：
- en: 'Traceback (most recent call last):'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "Chapter 4/code/models.py", line 153, in <module> print(world_Boundarys.get_by_name('Foo'))
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "Chapter 4/code/models.py"，第 153 行，在 <module> 中 print(world_Boundarys.get_by_name('Foo'))
- en: File "Chapter 4/code/models.py", line 148, in get_by_name
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "Chapter 4/code/models.py"，第 148 行，在 get_by_name 中
- en: '''Object not found with the name: {}''.format(name))'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '''Object not found with the name: {}''.format(name))'
- en: 'LookupError: Object not found with the name: Foo'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 'LookupError: Object not found with the name: Foo'
- en: Process finished with exit code 1
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 进程结束，退出代码为 1
- en: 'Very well, our method works nice and with an additional (almost) unexpected
    feature: it’s not specific for the boundaries; it can be used to find any type
    of GeoObject. Take a look and notice how it only uses properties that are available
    in our base classes.'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 非常好，我们的方法工作得很好，并且还有一个额外的（几乎）意外的特性：它不仅对边界有效；它可以用来查找任何类型的 GeoObject。看看它如何只使用我们基类中可用的属性。
- en: '5\. Move the get_by_name method to the BaseGeoCollection class and test you
    code again. Remember that the order of the methods inside a class is irrelevant
    for the class’ behavior, but the best practices recommend you to put the magic
    methods first, then the private ones, and then the others. Your complete BaseGeoCollection
    class should be as follows:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 将 get_by_name 方法移动到 BaseGeoCollection 类中，并再次测试你的代码。记住，类内部方法的顺序对类的行为是无关紧要的，但最佳实践建议你首先放置魔法方法，然后是私有方法，最后是其他方法。你的完整
    BaseGeoCollection 类应该如下所示：
- en: 'class BaseGeoCollection(object):'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 'class BaseGeoCollection(object):'
- en: '"""This class represents a collection of spatial data."""'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '"""此类表示空间数据集合。”'
- en: 'def __init__(self, file_path=None):'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, file_path=None):'
- en: self.data = []
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = []
- en: self.epsg = None
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: self.epsg = None
- en: 'if file_path:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 'if file_path:'
- en: self.import_data(file_path)
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: self.import_data(file_path)
- en: 'def __add__(self, other):'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __add__(self, other):'
- en: self.data += other.data
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: self.data += other.data
- en: return self
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: 'def _parse_data(self, features):'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _parse_data(self, features):'
- en: raise NotImplementedError
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: 'def import_data(self, file_path):'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 'def import_data(self, file_path):'
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开与 OGR 兼容的矢量文件并解析数据。”'
- en: ':param str file_path: The full path to the file.'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: ':param str file_path: 文件的完整路径。'
- en: '"""'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: features, metadata = open_vector_file(file_path)
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: features, metadata = open_vector_file(file_path)
- en: self._parse_data(features)
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: self._parse_data(features)
- en: self.epsg = metadata['epsg']
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: self.epsg = metadata['epsg']
- en: 'print("File imported: {}".format(file_path))'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("File imported: {}".format(file_path))'
- en: 'def describe(self):'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 'def describe(self):'
- en: 'print("SRS EPSG code: {}".format(self.epsg))'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("SRS EPSG code: {}".format(self.epsg))'
- en: 'print("Number of features: {}".format(len(self.data))) def get_by_name(self,
    name):'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("Number of features: {}".format(len(self.data))) def get_by_name(self,
    name):'
- en: '"""Find an object by its name attribute and returns it."""'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过名称属性查找对象并返回它。”'
- en: 'for item in self.data:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in self.data:'
- en: 'if item.get_attribute(''name'') == name:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 'if item.get_attribute(''name'') == name:'
- en: return item
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: return item
- en: raise LookupError(
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: raise LookupError(
- en: '"Object not found with the name: {}".format(name)) Now, in the next step, we
    will search for the points that are within the boundary that we found. This time,
    we will create a method directly inside the BaseGeoCollection class, so it becomes
    available to the PointCollection and the BoundaryCollection classes through inheritance.
    By doing this, we will get a bonus feature—we are able to filter the boundaries
    by another boundary.'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '"Object not found with the name: {}".format(name)) 现在，在下一步中，我们将搜索位于我们找到的边界内的点。这次，我们将在
    BaseGeoCollection 类中直接创建一个方法，这样它就通过继承对 PointCollection 和 BoundaryCollection 类可用。通过这样做，我们将获得一个额外功能——我们能够通过另一个边界来过滤边界。'
- en: '6\. Go to the BaseGeoCollection class and add the method filter_by_boundary:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 前往BaseGeoCollection类并添加filter_by_boundary方法：
- en: '#...'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def filter_by_boundary(self, boundary):'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 'def filter_by_boundary(self, boundary):'
- en: '"""Filters the data by a given boundary"""'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过给定边界过滤数据"""'
- en: result = []
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: result = []
- en: 'for item in self.data:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in self.data:'
- en: 'if item.geom.within(boundary.geom):'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 'if item.geom.within(boundary.geom):'
- en: result.append(item)
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: result.append(item)
- en: return result
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: return result
- en: Here, we created a variable result containing a list to store the objects that
    passes the test. The within predicate is used to test every item if it is inside
    the boundary that is passed as an argument. In this case, if nothing is found,
    no exception is raised and an empty list is returned.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为result的变量，它包含一个列表来存储通过测试的对象。使用within谓词来测试每个项目是否在作为参数传递的边界内。在这种情况下，如果没有找到任何内容，则不会引发异常，并返回一个空列表。
- en: '7\. Edit the testing code in the if __name__ == ''__main__'': block: if __name__
    == ''__main__'':'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '7. 编辑if __name__ == ''__main__'':块中的测试代码：if __name__ == ''__main__'':'
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: gdal.PushErrorHandler('CPLQuietErrorHandler')
- en: world = BoundaryCollection("../data/world_borders_simple.shp") geocaching_points
    = PointCollection("../data/geocaching.gpx") usa_boundary = world.get_by_name('United
    States')
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: world = BoundaryCollection("../data/world_borders_simple.shp") geocaching_points
    = PointCollection("../data/geocaching.gpx") usa_boundary = world.get_by_name('United
    States')
- en: 'result = geocaching_points.filter_by_boundary(usa_boundary) for item in result:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 'result = geocaching_points.filter_by_boundary(usa_boundary) for item in result:'
- en: print(item)
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: print(item)
- en: While testing, two instances are created, one from the BoundaryCollection class
    and one from the PointCollection class. The data files are passed as arguments.
    Then, the country of interest is found and stored in the usa_boundary variable.
    This variable is then passed to the filter_by_boundary method.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试过程中，创建了两个实例，一个来自BoundaryCollection类，另一个来自PointCollection类。数据文件作为参数传递。然后找到感兴趣的国家的信息，并存储在usa_boundary变量中。然后，将此变量传递给filter_by_boundary方法。
- en: '8\. Run the code. You should see a long list of geocaches as follows:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 8. 运行代码。你应该会看到一个长长的geocache列表，如下所示：
- en: -78.90175 42.89648 - LaSalle Park No 1
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: -78.90175 42.89648 - LaSalle Park No 1
- en: -78.89818 42.89293 - LaSalle Park No 2
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: -78.89818 42.89293 - LaSalle Park No 2
- en: -78.47808 43.02617 - A Unique Walk in Akron
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: -78.47808 43.02617 - A Unique Walk in Akron
- en: -78.93865 42.95982 - A view of Strawberry Island
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: -78.93865 42.95982 - A view of Strawberry Island
- en: -78.90007 42.7484 - A View to a Windmill
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: -78.90007 42.7484 - A View to a Windmill
- en: -79.07533 43.08133 - A Virtual Made in the Mist
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: -79.07533 43.08133 - A Virtual Made in the Mist
- en: -74.43207 43.86942 - Adirondack Museum Guestbook…
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: -74.43207 43.86942 - Adirondack Museum Guestbook…
- en: Process finished with exit code 0
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: As expected, it prints a list of Geocache objects whose representation given
    by the __repr__ method is their coordinates and names.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，它打印了一个Geocache对象的列表，其表示由__repr__方法给出，即它们的坐标和名称。
- en: '**Filtering by multiple attributes**'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过多个属性过滤**'
- en: The next step is to search the geocaching points by their attributes. For example,
    we may want to filter the points by the author of the geocache, by the level of
    difficulty to find the geocache, and so on.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是通过它们的属性搜索geocaching点。例如，我们可能想要通过geocache的作者、找到geocache的难度等级等来过滤点。
- en: We will borrow the techniques used in the methods that allowed us to get a GeoObject
    by its name property and the method that filtered by a polygon. The difference
    here is that we must allow the attribute that we want to filter by to be passed
    as a parameter, and we want to have the capability to combine multiple fields.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将借鉴那些允许我们通过GeoObject的名称属性获取GeoObject和通过多边形过滤的方法所使用的技巧。这里的区别是我们必须允许我们想要过滤的属性作为参数传递，并且我们希望有组合多个字段的能力。
- en: '1\. Let’s start adding a simple filter method in the BaseGeoCollection class:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 让我们从在BaseGeoCollection类中添加一个简单的过滤方法开始：
- en: '#...'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def filter(self, attribute, value):'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 'def filter(self, attribute, value):'
- en: '"""Filters the collection by an attribute.'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过属性过滤集合。'
- en: ':param attribute: The name of the attribute to filter by.'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: ':param attribute: 要过滤的属性名称。'
- en: ':param value: The filtering value.'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: ':param value: 过滤值。'
- en: '"""'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: result = []
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: result = []
- en: 'for item in self.data:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in self.data:'
- en: 'if item.get_attribute(attribute) == value:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 'if item.get_attribute(attribute) == value:'
- en: result.append(item)
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: result.append(item)
- en: return result
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: return result
- en: 'This method takes two arguments: the attribute name that we want to filter
    by and the value that this attribute needs to have to pass the filter. Different
    from get_by_name, this filtering function accumulates every object found into
    a list and returns this list.'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受两个参数：我们想要过滤的属性名称以及该属性需要具有的值以通过过滤。与get_by_name不同，此过滤函数将找到的每个对象累积到一个列表中，并返回此列表。
- en: '2\. To test the filtering method, edit the if __name__ == ''__main__'': block.
    We will filter the geocache points whose level of difficulty is 1:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 要测试过滤方法，编辑if __name__ == '__main__':块。我们将过滤难度级别为1的地理藏点：
- en: 'if __name__ == ''__main__'':'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: gdal.PushErrorHandler('CPLQuietErrorHandler')
- en: points = PointCollection("../data/geocaching.gpx") result = points.filter('difficulty',
    '1')
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: points = PointCollection("../data/geocaching.gpx") result = points.filter('difficulty',
    '1')
- en: points.describe()
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: points.describe()
- en: print("Found {} points".format(len(result)))
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: print("找到 {} 个点".format(len(result)))
- en: '3\. Run the code. You should have this output:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 运行代码。你应该得到以下输出：
- en: 'File imported: ../data/geocaching.gpx'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的文件：../data/geocaching.gpx
- en: 'SRS EPSG code: 4326'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: SRS EPSG代码：4326
- en: 'Number of features: 112'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 特征数量：112
- en: Found 38 points
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 找到38个点
- en: Process finished with exit code 0
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完成，退出代码为0
- en: From a total of 112 points, 38 match our criteria.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 在总共112个点中，有38个符合我们的标准。
- en: '**Chaining filters**'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '**链式过滤**'
- en: This part deserves a topic because we are going to use a very handy Python technique
    that you will most certainly need more than once to solve your geoprocessing challenges.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分值得单独说明，因为我们将要使用一个非常实用的Python技术，你很可能不止一次需要它来解决你的地理处理挑战。
- en: So far, we can apply a single filter that will return a list of objects. If
    we want to apply more than one filter, we can simply make the filter function
    return another collection object with the results, instead of returning a list.
    This way, we can make it possible to take the results from one filtering and filter
    them again, thus narrowing the results.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以应用单个过滤器，它将返回一个对象列表。如果我们想应用多个过滤器，我们可以简单地让过滤器函数返回另一个包含结果的集合对象，而不是返回一个列表。这样，我们可以使从一次过滤的结果中再次过滤成为可能，从而缩小结果范围。
- en: Besides being surprisingly simple, this solution is also very efficient in terms
    of processing, because at each filtering pass, the results are smaller and the
    number of iterations reduces.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 除了出奇地简单外，这个解决方案在处理效率方面也非常高，因为在每次过滤过程中，结果都会更小，迭代次数也会减少。
- en: 'Python allows function calls to be chained. This means that we don’t need to
    store each step into a variable. We can simply put each call one after another
    in a very elegant and intuitive pattern as exemplified here:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许函数调用链式操作。这意味着我们不需要将每个步骤存储到变量中。我们可以简单地以非常优雅和直观的模式将每个调用依次放置，如下所示：
- en: 'my_points = points.filter(''difficulty'', ''1'').filter(''status'', ''Available'')
    Note that this is an and condition. It will return the points that satisfy both
    the filters. But since we implemented the __add__ method to the BaseGeoCollection
    class, we can easily achieve an or type of filtering:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: my_points = points.filter('difficulty', '1').filter('status', 'Available') 注意这是一个“与”条件。它将返回同时满足两个过滤条件的点。但由于我们在BaseGeoCollection类中实现了__add__方法，我们可以轻松地实现“或”类型的过滤：
- en: my_points = points.filter('difficulty', '1') + points.filter('difficulty',
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: my_points = points.filter('difficulty', '1') + points.filter('difficulty',
- en: '''2'')'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '''2'')'
- en: '1\. Let’s make our method return a new instance to make this work. Edit the
    filter method in the BaseGeoCollection class:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 让我们的方法返回一个新的实例以使这成为可能。编辑BaseGeoCollection类的filter方法：
- en: '#...'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def filter(self, attribute, value):'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 'def filter(self, attribute, value):'
- en: '"""Filters the collection by an attribute.'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过属性过滤集合。'
- en: ':param attribute: The name of the attribute to filter by.'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: ':param attribute: 要过滤的属性名称。'
- en: ':param value: The filtering value.'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: ':param value: 过滤值。'
- en: '"""'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: result = self.__class__()
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: result = self.__class__()
- en: 'for item in self.data:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in self.data:'
- en: 'if getattr(item, attribute) == value:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 'if getattr(item, attribute) == value:'
- en: result.data.append(item)
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: result.data.append(item)
- en: return result
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: return result
- en: 'Now, the result is an instance of the same class that originated the instance
    where the method was called, because __class__ is a property that contains the
    class that originated the instance. Since we are using inheritance, this ensures
    that we have the result in the same type and the data. Although this is a very
    simple solution, it works very well. Let’s try it:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结果是一个与调用该方法的原实例相同的类的实例，因为__class__是一个包含创建实例的类的属性。由于我们正在使用继承，这确保了结果与数据类型相同。尽管这是一个非常简单的解决方案，但它非常有效。让我们试试：
- en: '2\. Edit the if __name__ == ''__main__'': block, so we can filter the points
    that match the two conditions (the and condition):'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 编辑if __name__ == '__main__':块，以便我们可以过滤出符合两个条件（且条件）的点：
- en: 'if __name__ == ''__main__'':'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: gdal.PushErrorHandler('CPLQuietErrorHandler') points = PointCollection("../data/geocaching.gpx")
    result = points.filter('difficulty', '1').filter('container',
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: gdal.PushErrorHandler('CPLQuietErrorHandler') points = PointCollection("../data/geocaching.gpx")
    result = points.filter('difficulty', '1').filter('container',
- en: '''Virtual'')'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '''Virtual'')'
- en: points.describe()
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: points.describe()
- en: result.describe()
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: result.describe()
- en: '3\. Run the following code:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 运行以下代码：
- en: 'File imported: ../data/geocaching.gpx'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的文件：../data/geocaching.gpx
- en: 'SRS EPSG code: 4326'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: SRS EPSG代码：4326
- en: 'Number of features: 112'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 特征数量：112
- en: 'SRS EPSG code: None'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: SRS EPSG代码：None
- en: 'Number of features: 34'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 特征数量：34
- en: Process finished with exit code 0
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: From the previous test, we know that 38 points are of difficulty 1, now we got
    34
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一个测试中，我们知道有38个难度为1的点，现在我们有34个
- en: points because of those 38 points, four does not have a container = Virtual.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: points因为那些38个点，其中四个没有容器 = 虚拟。
- en: '4\. Try another test this time using an or condition:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 这次尝试使用或条件再进行另一个测试：
- en: 'if __name__ == ''__main__'':'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: gdal.PushErrorHandler('CPLQuietErrorHandler')
- en: points = PointCollection("../data/geocaching.gpx") result = points.filter('difficulty',
    '1') + points.filter(
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: points = PointCollection("../data/geocaching.gpx") result = points.filter('difficulty',
    '1') + points.filter(
- en: '''difficulty'', ''2'')'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '''difficulty'', ''2'')'
- en: points.describe()
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: points.describe()
- en: result.describe()
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: result.describe()
- en: '5\. Run the code:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 运行以下代码：
- en: 'File imported: ../data/geocaching.gpx'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的文件：../data/geocaching.gpx
- en: 'SRS EPSG code: 4326'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: SRS EPSG代码：4326
- en: 'Number of features: 112'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 特征数量：112
- en: 'SRS EPSG code: None'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: SRS EPSG代码：None
- en: 'Number of features: 50'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 特征数量：50
- en: Process finished with exit code 0
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: This time, these 38 points of difficulty 1 were combined with another 12 points
    of difficulty 2\.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，这些难度为1的38个点与另外12个难度为2的点合并。
- en: '**Integrating with the app**'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成到应用程序中**'
- en: As we continue to work with increasing levels of abstraction, think of our app’s
    organization. We have two types of data and we have the GeocachingApp class with
    high level functionality. At this point, what we want is to enable the app to
    filter like we did in the tests, but in a simple and straightforward way.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续使用更高层次的抽象级别工作，想想我们的应用程序组织。我们有两种类型的数据，并且有一个具有高级功能的GeocachingApp类。在这个阶段，我们想要的是使应用程序能够以我们在测试中做的方式过滤，但要以简单直接的方式进行。
- en: 'Take a look at the app as it is at this point:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 看看应用程序现在的样子：
- en: 'class GeocachingApp(PointCollection):'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 'class GeocachingApp(PointCollection):'
- en: 'def __init__(self, data_file=None, my_location=None):'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, data_file=None, my_location=None):'
- en: '"""Application class.'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用程序类。'
- en: ':param data_file: An OGR compatible file'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: ':param data_file: 一个与OGR兼容的文件'
- en: with geocaching points.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: with geocaching points.
- en: ':param my_location: Coordinates of your location.'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: ':param my_location: 您的位置坐标。'
- en: '"""'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: super(GeocachingApp, self).__init__(file_path=data_file)
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: super(GeocachingApp, self).__init__(file_path=data_file)
- en: self._datasource = None
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: self._datasource = None
- en: self._transformed_geoms = None
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: self._transformed_geoms = None
- en: self._my_location = None
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: self._my_location = None
- en: self.distances = None
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: self.distances = None
- en: 'if my_location:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 'if my_location:'
- en: self.my_location = my_location
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: self.my_location = my_location
- en: '@property'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def my_location(self):'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 'def my_location(self):'
- en: return self._my_location
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: return self._my_location
- en: '@my_location.setter'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '@my_location.setter'
- en: 'def my_location(self, coordinates):'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 'def my_location(self, coordinates):'
- en: self._my_location = transform_points([coordinates])[0]
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: self._my_location = transform_points([coordinates])[0]
- en: 'def calculate_distances(self):'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 'def calculate_distances(self):'
- en: '"""Calculates the distance between a'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '"""计算两点之间的距离。'
- en: set of points and a given location.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 一组点和给定位置。
- en: ':return: A list of distances in the same order as'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: ':return: 按相同顺序返回距离列表'
- en: the points.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点。
- en: '"""'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: xa = self.my_location[0]
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: xa = self.my_location[0]
- en: ya = self.my_location[1]
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: ya = self.my_location[1]
- en: points = self._transformed_geoms
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: points = self._transformed_geoms
- en: distances = []
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: distances = []
- en: 'for geom in points:'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 'for geom in points:'
- en: point_distance = math.sqrt(
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: point_distance = math.sqrt(
- en: (geom.GetX() - xa)**2 + (geom.GetY() - ya))
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: (geom.GetX() - xa)**2 + (geom.GetY() - ya))
- en: distances.append(point_distance)
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: distances.append(point_distance)
- en: return distances
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: return distances
- en: 'def find_closest_point(self):'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 'def find_closest_point(self):'
- en: '"""Find the closest point to a given location and'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '"""找到给定位置最近的点。'
- en: return the cache that's on that point.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 返回该点上的缓存。
- en: ':return: OGR feature containing the point.'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: ':return: 包含点的OGR要素。'
- en: '"""'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: Part 1\.
  id: totrans-1099
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分。
- en: distances = self.calculate_distances()
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: distances = self.calculate_distances()
- en: index = np.argmin(distances)
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: index = np.argmin(distances)
- en: Part 2\.
  id: totrans-1102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分。
- en: layer = self._datasource.GetLayerByIndex(0)
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: layer = self._datasource.GetLayerByIndex(0)
- en: feature = layer.GetFeature(index)
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: feature = layer.GetFeature(index)
- en: 'print "Closest point at: {}m".format(distances[index]) return feature'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 "最近点在：{}m".format(distances[index]) return feature
- en: Inheritance was used to give the app the functionality contained in the PointCollection
    class. But this schema won’t work anymore because we now have two types of data.
    We have to remove the inheritance and make a different approach.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承来给应用程序提供 PointCollection 类中包含的功能。但这个模式将不再适用，因为我们现在有两种类型的数据。我们必须移除继承并采取不同的方法。
- en: What we will do is store instances of the collection classes (PointCollection
    and BoundaryCollection), and implement the methods that will relate them in the
    same way it was done in the tests of the chaining filters topic.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的就是存储集合类（PointCollection 和 BoundaryCollection）的实例，并实现将它们联系起来的方法，就像在链式过滤器主题的测试中做的那样。
- en: 'Let’s start with the imports and the class’ definition:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入和类的定义开始：
- en: '1\. Open your geocaching_app.py file and edit the imports section at the beginning
    of the file to include new classes:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 打开 geocaching_app.py 文件，并编辑文件开头的导入部分，以包含新的类：
- en: coding=utf-8
  id: totrans-1110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码格式：utf-8
- en: import gdal
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 gdal
- en: import numpy as np
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 numpy as np
- en: import math
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 math
- en: from utils.geo_functions import transform_points
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 从 utils.geo_functions 导入 transform_points
- en: from models import PointCollection, BoundaryCollection
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 从 models 导入 PointCollection, BoundaryCollection
- en: '2\. Now, edit the GeocachingApp class definition and the __init__ method to
    be as follows:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在，编辑 GeocachingApp 类定义和 __init__ 方法，如下所示：
- en: 'class GeocachingApp(object):'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 'class GeocachingApp(object):'
- en: def __init__(self,
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: def __init__(self,
- en: geocaching_file=None,
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: geocaching_file=None,
- en: boundary_file=None,
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: boundary_file=None,
- en: 'my_location=None):'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 'my_location=None):'
- en: '"""Application class.'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用程序类。'
- en: ':param geocaching_file: An OGR compatible file'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: ':param geocaching_file: 一个 OGR 兼容的文件'
- en: with geocaching points.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 与地理藏宝点。
- en: ':param boundary_file: A file with boundaries.'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: ':param boundary_file: 一个包含边界的文件。'
- en: ':param my_location: Coordinates of your location.'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: ':param my_location: 你的位置坐标。'
- en: '"""'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: self.geocaching_data = PointCollection(geocaching_file)
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: self.geocaching_data = PointCollection(geocaching_file)
- en: self.boundaries = BoundaryCollection(boundary_file)
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: self.boundaries = BoundaryCollection(boundary_file)
- en: self._my_location = None
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: self._my_location = None
- en: 'if my_location:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 my_location:'
- en: self.my_location = my_location
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: self.my_location = my_location
- en: The inheritance was removed and now the data is stored in the geocaching_data
    and
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 继承已被移除，现在数据存储在 geocaching_data 和
- en: boundaries properties. Optionally, if the user passes a file with geocaching
    data or with boundary data to the GeocachingApp class, these same files are passed
    as an argument to the PointCollection and BoundaryCollection creations.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: boundaries 属性。如果用户将包含地理藏宝数据或边界数据的文件传递给 GeocachingApp 类，这些相同的文件将作为参数传递给 PointCollection
    和 BoundaryCollection 的创建。
- en: With what you have now, you can already do any type of filtering. You just need
    to access geocaching_data and boundaries and do exactly what we did before. Let’s
    try it.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你现在拥有的，你已经开始做任何类型的过滤了。你只需要访问 geocaching_data 和 boundaries，并做我们之前所做的那样。让我们试试。
- en: '3\. Go to the end of the file where there is a line with if __name__ == "__main__":
    and edit the code:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '3. 前往文件末尾的 if __name__ == "__main__": 行，并编辑代码：'
- en: 'if __name__ == "__main__":'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == "__main__":'
- en: my_app = GeocachingApp("../data/geocaching.gpx",
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: my_app = GeocachingApp("../data/geocaching.gpx",
- en: '"../data/world_borders_simple.shp")'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '"../data/world_borders_simple.shp")'
- en: usa_boundary = my_app.boundaries.get_by_name('United States') result = my_app.geocaching_data.filter_by_boundary(
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: usa_boundary = my_app.boundaries.get_by_name('United States') result = my_app.geocaching_data.filter_by_boundary(
- en: usa_boundary)
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: usa_boundary)
- en: print(result)
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(result)
- en: 4\. Now run it. Remember that whenever you want to run a different file, you
    need to press *Alt* + *Shift* + *F10* and choose the file in the popup. You should
    see the output with the list of geocaching points again.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 现在运行它。记住，每次你想运行不同的文件时，你需要按 *Alt* + *Shift* + *F10* 并在弹出窗口中选择文件。你应该再次看到包含地理藏宝点的列表输出。
- en: But let’s suppose that there is a kind of filtering that is expected to be needed
    multiple times or, maybe, there is a filtering that you want to make explicit.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们假设存在一种需要多次使用的过滤功能，或者，也许有一种你希望明确的过滤功能。
- en: Following the same example, suppose that we are filtering by a country name
    in this case.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的示例，假设我们正在按国家名称进行过滤。
- en: We can use the GeocachingApp class, which stands in the highest level of abstraction
    in our code to implement this or any other high level filtering method.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 GeocachingApp 类，这是我们代码中抽象层次最高的一层，来实现这个或任何其他高级过滤方法。
- en: '5\. Add this method to the GeocachingApp class:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 将此方法添加到 GeocachingApp 类：
- en: '#...'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def filter_by_country(self, name):'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 'def filter_by_country(self, name):'
- en: '"""Filter by a country with a given name.'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过给定的名称筛选国家。'
- en: ':param name: The name of the boundary (ex. county name)'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: ':param name: 边界的名称（例如，县名）'
- en: ':return: PointCollection'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: ':return: PointCollection'
- en: '"""'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: boundary = self.boundaries.get_by_name(name)
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: boundary = self.boundaries.get_by_name(name)
- en: return self.geocaching_data.filter_by_boundary(boundary)
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: return self.geocaching_data.filter_by_boundary(boundary)
- en: In computer programming, this is also called **convenience method**. It’s a
    method created for convenience in order to solve a more complex task or to avoid
    boilerplate code (that is, to avoid code repetition).
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，这也被称为**便利方法**。它是为了方便解决更复杂的问题或避免样板代码（即避免代码重复）而创建的方法。
- en: '**Summary**'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we saw that the different types of relationships between geometries
    can be tested, and that these tests can be used in the program to solve problems.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了几何形状之间不同类型的关系可以被测试，并且这些测试可以在程序中用来解决问题。
- en: In order to filter by polygons, first we used the same code to import these
    polygons into the system like we did with the points, but this time we used Shapely
    to abstract the geometries of the polygons and points. Finally, we used geometry
    relationships to search for points inside the polygons.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过多边形进行筛选，我们首先使用与点相同的代码将这些多边形导入系统，但这次我们使用了Shapely来抽象多边形和点的几何形状。最后，我们使用几何关系来搜索多边形内的点。
- en: Then, we implemented a way to filter the data by the name property and we made
    it filter the data by any property of the object or any combination of properties.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现了一种通过名称属性筛选数据的方法，并使其能够通过对象的任何属性或任何属性组合进行筛选。
- en: Finally, we adapted the app class to work with the new changes and saw that
    it’s possible to add convenience methods to it in order to simplify some tasks.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将应用程序类适配到新的更改，并看到我们可以在其中添加便利方法以简化一些任务。
- en: In the next chapter, we will start working on the Map Maker App and create means
    to visualize our data.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将开始着手制作地图制作应用程序，并创建可视化我们数据的方法。
- en: '**Chapter 5\. Making Maps**'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '**第五章：制作地图**'
- en: In this chapter, we will start a new application and use it to produce nice
    maps from vector data.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将启动一个新的应用程序，并使用它从矢量数据生成漂亮的地图。
- en: In order to produce these maps, we will use Mapnik, one of the world’s most
    used mapping packages. The objective is to understand how it works and adapt it
    to make an easy-to-use mapping application.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成这些地图，我们将使用Mapnik，这是世界上使用最广泛的地图包之一。目标是了解它是如何工作的，并使其适应制作易于使用的地图应用程序。
- en: In the previous chapters, we produced some very functional classes that abstract
    geographic data; we will make this app capable of consuming this type of data.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们创建了一些非常实用的类来抽象地理数据；我们将使这个应用程序能够消费此类数据。
- en: 'We will cover the following topics:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Getting to know Mapnik and see how it works
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Mapnik及其工作原理
- en: Seeing the differences between pure Python and XML when defining a map Experimenting
    with different styles
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 比较使用纯Python和XML定义地图时的差异
- en: Using Python objects as a source of data for Mapnik
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python对象作为Mapnik的数据源
- en: Abstracting Mapnik into a high-level application
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 将Mapnik抽象为高级应用程序
- en: '**Knowing Mapnik**'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '**了解Mapnik**'
- en: Mapnik is the tool that we will use to produce our maps. It’s a very powerful
    mapping library used by many websites.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: Mapnik是我们用来制作地图的工具。它是一个非常强大的地图库，被许多网站使用。
- en: In this first topic, we will go through some experiments to get to know Mapnik’s
    features.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节第一个主题中，我们将进行一些实验来了解Mapnik的功能。
- en: Now we will perform a few experiments with Mapnik in order to know how it works.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过几个实验来了解Mapnik的工作原理。
- en: 'First, let’s organize the code for this chapter:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们组织本章的代码：
- en: 1\. Inside your geopy project, copy the Chapter4 folder and rename it to Chapter5\.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在你的geopy项目中，复制Chapter4文件夹并将其重命名为Chapter5。
- en: 2\. Inside the Chapter5 folder, create a new folder named mapnik_experiments.
    To do that, right-click in your Chapter5 folder and choose **New** | **Directory**.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在Chapter5文件夹内，创建一个名为mapnik_experiments的新文件夹。为此，在Chapter5文件夹中右键单击并选择**新建**
    | **目录**。
- en: 3\. Still in Chapter5, create another folder named output; we will place the
    maps and images we create into that folder.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 仍然在Chapter5中，创建一个名为output的新文件夹；我们将把创建的地图和图像放入该文件夹。
- en: '**Making a map with pure Python**'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用纯Python制作地图**'
- en: Mapnik has two ways to define a map; one uses pure Python code, the other an
    XML file.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: Mapnik有两种定义地图的方式；一种使用纯Python代码，另一种使用XML文件。
- en: Mapnik’s Python API is very extensive and wraps almost all of the package’s
    functionalities. In the next steps we will experiment with making a map with Python
    code only.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: Mapnik的Python API非常广泛，几乎封装了该包的所有功能。在接下来的步骤中，我们将仅使用Python代码进行地图制作实验。
- en: 1\. Inside mapnik_experiments, create a Python file named mapnik_python.py.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 在mapnik_experiments文件夹内创建一个名为mapnik_python.py的Python文件。
- en: '2\. Type the following code into mapnik_python.py:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 将以下代码输入到mapnik_python.py文件中：
- en: coding=utf-8
  id: totrans-1185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import mapnik
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 导入mapnik库
- en: Create a Map
  id: totrans-1187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建地图
- en: map = mapnik.Map(800, 600)
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: map = mapnik.Map(800, 600)
- en: Set the background color of the map.
  id: totrans-1189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置地图的背景颜色。
- en: map.background = mapnik.Color('white')
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: map.background = mapnik.Color('white')
- en: Create a Style and a Rule.
  id: totrans-1191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个样式和一个规则。
- en: style = mapnik.Style()
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: style = mapnik.Style()
- en: rule = mapnik.Rule()
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: rule = mapnik.Rule()
- en: Create a PolygonSymbolizer to fill the polygons and
  id: totrans-1194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个PolygonSymbolizer来填充多边形。
- en: add it to the rule.
  id: totrans-1195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将其添加到规则中。
- en: polygon_symbolizer = mapnik.PolygonSymbolizer(
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: polygon_symbolizer = mapnik.PolygonSymbolizer(
- en: mapnik.Color('#f2eff9'))
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.Color('#f2eff9'))
- en: rule.symbols.append(polygon_symbolizer)
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: rule.symbols.append(polygon_symbolizer)
- en: Create a LineSymbolizer to style the polygons borders and
  id: totrans-1199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个LineSymbolizer来设置多边形的边框样式。
- en: add it to the rule.
  id: totrans-1200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将其添加到规则中。
- en: line_symbolizer = mapnik.LineSymbolizer(
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: line_symbolizer = mapnik.LineSymbolizer(
- en: mapnik.Color('rgb(50%,50%,50%)'), 0.1)
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.Color('rgb(50%,50%,50%)'), 0.1)
- en: rule.symbols.append(line_symbolizer)
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: rule.symbols.append(line_symbolizer)
- en: Add the rule to the style.
  id: totrans-1204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将规则添加到样式。
- en: style.rules.append(rule)
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: style.rules.append(rule)
- en: Add the Style to the Map.
  id: totrans-1206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将样式添加到地图。
- en: map.append_style('My Style', style)
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: map.append_style('My Style', style)
- en: Create a data source from a shapefile.
  id: totrans-1208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: </Parameter>
- en: data = mapnik.Shapefile(file='../../data/world_borders_simple.shp')
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: data = mapnik.Shapefile(file='../../data/world_borders_simple.shp')
- en: Create a layer giving it the name 'world'.
  id: totrans-1210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个名为'world'的图层。
- en: layer = mapnik.Layer('world')
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: layer = mapnik.Layer('world')
- en: Set the layer data source and add the style to the layer.
  id: totrans-1212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置图层数据源并将样式添加到图层。
- en: layer.datasource = data
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: layer.datasource = data
- en: layer.styles.append('My Style')
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: layer.styles.append('My Style')
- en: Add the layer to the map.
  id: totrans-1215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图层添加到地图。
- en: map.layers.append(layer)
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: map.layers.append(layer)
- en: Zoom the map to the extent of all layers.
  id: totrans-1217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将地图缩放到所有图层范围。
- en: map.zoom_all()
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: map.zoom_all()
- en: '![Image 29](img/index-231_1.jpg)'
  id: totrans-1219
  prefs: []
  type: TYPE_IMG
  zh: '![Image 29](img/index-231_1.jpg)'
- en: Write the map to a image.
  id: totrans-1220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将地图写入图像。
- en: mapnik.render_to_file(map,'../output/world.png', 'png')
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.render_to_file(map,'../output/world.png', 'png')
- en: 3\. Now run the code; press *Alt* + *Shift* + *F10* and select mapnik_python.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 现在运行代码；按*Alt* + *Shift* + *F10*并选择mapnik_python。
- en: '4\. There should be a new file named world.png inside your output folder. You
    can view this image in PyCharm; just double-click it. You should see this: Congratulations
    on creating this first beautiful map; note the superior quality of this rendering
    and how quickly Mapnik does its job.'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 在您的输出文件夹中应该有一个名为world.png的新文件。您可以在PyCharm中查看此图像；只需双击它。您应该看到这个：恭喜您创建了这张第一张美丽的地图；注意渲染的优越质量和Mapnik完成工作的速度。
- en: '**Making a map with a style sheet**'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用样式表制作地图**'
- en: 'Instead of using only Python code, the map styles, layers, and other definitions
    can be put inside an XML file. Let’s try this:'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用Python代码外，地图样式、图层和其他定义也可以放在一个XML文件中。让我们试试这个：
- en: 1\. Inside the mapnik_experiments folder, create a new file named map_style.xml.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 在mapnik_experiments文件夹内，创建一个名为map_style.xml的新文件。
- en: '2\. Type the following code:'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 输入以下代码：
- en: <Map background-color="white">
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: <Map background-color="white">
- en: <Style name="My Style">
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: <Style name="My Style">
- en: <Rule>
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: <Rule>
- en: <PolygonSymbolizer fill="#f2eff9" />
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: <PolygonSymbolizer fill="#f2eff9" />
- en: <LineSymbolizer stroke="rgb(50%,50%,50%)" stroke-width="0.1" />
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: <LineSymbolizer stroke="rgb(50%,50%,50%)" stroke-width="0.1" />
- en: </Rule>
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: </Rule>
- en: </Style>
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: </Style>
- en: <Layer name="world">
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: <Layer name="world">
- en: <StyleName>My Style</StyleName>
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: <StyleName>My Style</StyleName>
- en: <Datasource>
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: <Datasource>
- en: <Parameter name="file">
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: <Parameter name="file">
- en: ../../data/world_borders_simple.shp
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: ../../data/world_borders_simple.shp
- en: </Parameter>
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: </Parameter>
- en: <Parameter name="type">shape</Parameter>
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: <Parameter name="type">shape</Parameter>
- en: </Datasource>
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: </Datasource>
- en: </Layer>
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: </Layer>
- en: </Map>
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: </Map>
- en: This is the style definition of your map. Although PyCharm is a Python IDE,
    it’s also capable of recognizing a lot of file types including XML; it should
    help you with the tags and should apply a nice coloring to the code.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您地图的样式定义。尽管PyCharm是一个Python IDE，但它也能识别许多文件类型，包括XML；它应该会帮助您处理标签，并给代码应用漂亮的颜色。
- en: 'Now you need the Python code to generate this map:'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要Python代码来生成此地图：
- en: '3\. Create a Python file named mapnik_xml.py inside the mapnik_experiments
    folder and type this code:'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 在mapnik_experiments文件夹内创建一个名为mapnik_xml.py的Python文件，并输入以下代码：
- en: coding=utf-8
  id: totrans-1248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import mapnik
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: import mapnik
- en: map = mapnik.Map(800, 600)
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: map = mapnik.Map(800, 600)
- en: mapnik.load_map(map, 'map_style.xml')
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.load_map(map, 'map_style.xml')
- en: map.zoom_all()
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: map.zoom_all()
- en: mapnik.render_to_file(map, '../output/world2.png')
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.render_to_file(map, '../output/world2.png')
- en: 4\. Run this file. Remember that, to run a different file from the previous
    one, you need to press *Alt* + *Shift* + *F10* and select it.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 运行此文件。请记住，要运行上一个文件之外的不同文件，您需要按 *Alt* + *Shift* + *F10* 并选择它。
- en: 5\. Open the generated image (world2.png) that is inside the output folder;
    you should see exactly the same result as before.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 打开输出文件夹中的生成图像（world2.png）；你应该看到与之前完全相同的结果。
- en: Styling maps in Python and XML has almost the same features. Except for a few
    very specific situations, you can obtain exactly the same results using either
    of them.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 和 XML 中设置地图样式几乎具有相同的功能。除了少数非常具体的情况外，你可以使用其中任何一个来获得完全相同的结果。
- en: 'In those simple examples, there are two things to be noticed while using Python
    or XML: code readability and organization. Looking at the XML code, you should
    see that the map, styles, and rules have a tree-like organization; this is very
    clear here but in the pure Python definition this get confusing and can lead to
    mistakes.'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些简单的示例中，使用 Python 或 XML 时需要注意两件事：代码可读性和组织。查看 XML 代码，你应该看到地图、样式和规则具有树状结构；这里非常清晰，但在纯
    Python 定义中可能会变得混乱，并可能导致错误。
- en: This is a very simple map but, as you add more rules and symbolizers, things
    starts to get very confusing and hard to understand using pure Python.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的地图，但随着你添加更多的规则和符号化器，使用纯 Python 来理解事情开始变得非常混乱。
- en: Another important point is that it’s a good idea to separate the map creation
    logic from the style. We will see how that helps to keep your code very clean
    and reusable in the next topic.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个重要点是，将地图创建逻辑与样式分开是一个好主意。我们将在下一个主题中看到这样做如何帮助保持代码非常干净和可重用。 '
- en: '**Creating utility functions to generate**'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建生成实用函数**'
- en: '**maps**'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: '**maps**'
- en: Now we will create the first function that will compose our application.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建第一个将组成我们应用程序的函数。
- en: '1\. Still in the mapnik_experiments folder, create a new file: map_functions.py.'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 仍然在 mapnik_experiments 文件夹中，创建一个新的文件：map_functions.py。
- en: '2\. Insert the code as follows into that file:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 将以下代码插入到该文件中：
- en: coding=utf-8
  id: totrans-1265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import mapnik
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: import mapnik
- en: 'def create_map(style_file, output_image, size=(800, 600)):'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_map(style_file, output_image, size=(800, 600)):'
- en: '"""Creates a map from a XML file and writes it to an image.'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '"""从 XML 文件创建地图并将其写入图像。'
- en: ':param style_file: Mapnik XML file.'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: ':param style_file: Mapnik XML 文件。'
- en: ':param output_image: Name of the output image file.'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: ':param output_image: 输出图像文件的名称。'
- en: ':param size: Size of the map in pixels.'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: ':param size: 地图的像素大小。'
- en: '"""'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: map = mapnik.Map(*size)
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: map = mapnik.Map(*size)
- en: mapnik.load_map(map, style_file)
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.load_map(map, style_file)
- en: map.zoom_all()
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: map.zoom_all()
- en: mapnik.render_to_file(map, output_image)
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.render_to_file(map, output_image)
- en: 'if __name__ == ''__main__'':'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: create_map('map_style.xml', '../output/world3.png',
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: create_map('map_style.xml', '../output/world3.png',
- en: size=(400, 400))
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: size=(400, 400))
- en: 'What we did here is pack the map generation code into a function that we can
    reuse in the future. It takes two required arguments: the XML style file and the
    name of the image file that Mapnik will write the results to.'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是将地图生成代码打包到一个函数中，我们可以在将来重用它。它接受两个必需参数：XML 样式文件和 Mapnik 将结果写入的图像文件名。
- en: The third optional parameter is the size of the map that will be created; you
    can pass a list or a tuple with the width and height of the map in pixels. This
    tuple or list is then unpacked with the * symbol into mapnik.Map arguments.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个可选参数是创建的地图的大小；你可以传递一个包含地图宽度和高度的像素值的列表或元组。这个元组或列表随后使用 * 符号解包到 mapnik.Map 参数中。
- en: 'Finally, again we used the if __name__ == ''__main__'': technique to test the
    code.'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们再次使用了 `if __name__ == '__main__':` 技巧来测试代码。
- en: Remember that everything that is inside this if block is run only if the file
    is called directly. On the other hand, if this file is imported as a module, this
    code will be ignored.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个 if 块内部的所有内容仅在文件直接调用时运行。另一方面，如果这个文件作为模块导入，则此代码将被忽略。
- en: Look at the *Creating the application entry point* section in [Chapter 2](index_split_000.html#p103),
    *The Geocaching* *App*, if you need more information on that technique.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多关于该技术的信息，请查看[第 2 章](index_split_000.html#p103)中的*创建应用程序入口点*部分，*Geocaching*
    *应用程序*。
- en: '**Changing the data source at runtime**'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: '**在运行时更改数据源**'
- en: 'This is a useful function; now we can create maps from XML files with a single
    line of code. But there is a flaw: the data source (the shapefile that will be
    used) is hardcoded inside the XML. Suppose that we want to generate maps for a
    bunch of shapefiles; for every file we would need to change the XML, impeding
    the execution of batch operations.'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的函数；现在我们可以用一行代码从XML文件创建地图。但是有一个缺陷：数据源（将要使用的shapefile）在XML中是硬编码的。假设我们想要为多个shapefile生成地图；对于每个文件，我们都需要更改XML，这阻碍了批处理操作的执行。
- en: Fortunately, there are two ways that we can change the data source file that
    Mapnik will use without manually changing the XML. We can make code to edit the
    XML for us, or we can mix XML and Python in the map definition.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有两种方法可以更改Mapnik将使用的数据源文件，而无需手动更改XML。我们可以编写代码来为我们编辑XML，或者我们可以在地图定义中混合XML和Python。
- en: Mapnik’s Map object has a couple of properties that can be accessed. At the
    moment, we are interested in accessing the layer, because the layer contains the
    data source that we want to define or change.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: Mapnik的Map对象有几个属性可以访问。目前，我们感兴趣的是访问层，因为层包含我们想要定义或更改的数据源。
- en: 'Every Map instance contains a layers property that returns a Layers object
    containing all the layers defined in the map. This object behaves like a list
    of Layer objects in which its items could be iterated or retrieved by an index.
    In turn, the Layer object contains the name and the data source properties. Let’s
    take a look how this works: **Note**'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Map实例都包含一个layers属性，该属性返回一个包含地图中定义的所有层的Layers对象。这个对象的行为类似于一个Layer对象的列表，其项可以通过迭代或通过索引检索。反过来，Layer对象包含名称和数据源属性。让我们看看它是如何工作的：**注意**
- en: 'Check the Mapnik API documentation at: [http://mapnik.org/docs/v2.2.0/api/python/.](http://mapnik.org/docs/v2.2.0/api/python/)'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Mapnik API文档：[http://mapnik.org/docs/v2.2.0/api/python/](http://mapnik.org/docs/v2.2.0/api/python/)
- en: There you can find all the classes, methods, and properties that are available.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里你可以找到所有可用的类、方法和属性。
- en: '1\. Change your function so we can inspect the properties of the map object:
    def create_map(style_file, output_image, size=(800, 600)):'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: '1. 修改你的函数，以便我们可以检查地图对象的属性：def create_map(style_file, output_image, size=(800,
    600)):'
- en: '"""Creates a map from a XML file and writes it to an image.'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: '"""从XML文件创建地图并将其写入图像。'
- en: ':param style_file: Mapnik XML file.'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: ':param style_file: Mapnik XML文件。'
- en: ':param output_image: Name of the output image file.'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: ':param output_image: 输出图像文件名。'
- en: ':param size: Size of the map in pixels.'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: ':param size: 地图像素大小。'
- en: '"""'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: map = mapnik.Map(*size)
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: map = mapnik.Map(*size)
- en: mapnik.load_map(map, style_file)
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.load_map(map, style_file)
- en: '**layers = map.layers**'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: '**layers = map.layers**'
- en: '**layer = layers[0]**'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: '**layer = layers[0]**'
- en: '**print(layer)**'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: '**print(layer)**'
- en: '**print(layer.name)**'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: '**print(layer.name)**'
- en: '**print(layer.datasource)**'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: '**print(layer.datasource)**'
- en: map.zoom_all()
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: map.zoom_all()
- en: mapnik.render_to_file(map, output_image)
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.render_to_file(map, output_image)
- en: The highlighted code gets the layers object and the first layer in it (at index
    0), then prints it, its name, and the data source properties.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码获取layers对象及其中的第一个层（索引为0），然后打印它、它的名称和数据源属性。
- en: '2\. Just rerun the code and you should get this output:'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 重新运行代码，你应该得到以下输出：
- en: <mapnik._mapnik.Layer object at 0x01E579F0>
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: <mapnik._mapnik.Layer 对象在 0x01E579F0>
- en: world
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: world
- en: <mapnik.Datasource object at 0x01F3E9F0>
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: <mapnik.Datasource 对象在 0x01F3E9F0>
- en: Process finished with exit code 0
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完成，退出代码为0
- en: As you see in the output, the first layer is the world layer defined in the
    XML and it has a data source. This data source is what we want to set or modify
    during code execution.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在输出中看到的，第一层是XML中定义的世界层，它有一个数据源。这个数据源就是我们希望在代码执行期间设置或修改的内容。
- en: '3\. Make another test. Open the map_style.xml file and remove the data source
    from the definition, like this:'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 再次进行测试。打开map_style.xml文件，从定义中删除数据源，如下所示：
- en: <Map background-color="white">
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: <Map 背景颜色="白色">
- en: <Style name="My Style">
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: <Style 名称="我的样式">
- en: <Rule>
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: <Rule>
- en: <PolygonSymbolizer fill="#f2eff9" />
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: <PolygonSymbolizer 填充="#f2eff9" />
- en: <LineSymbolizer stroke="rgb(50%,50%,50%)" stroke-width="0.1" />
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: <LineSymbolizer 边框颜色="rgb(50%,50%,50%)" 边框宽度="0.1" />
- en: </Rule>
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: </Rule>
- en: </Style>
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: </Style>
- en: <Layer name="world">
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: <Layer 名称="world">
- en: <StyleName>My Style</StyleName>
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: <StyleName>我的样式</StyleName>
- en: </Layer>
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: </Layer>
- en: </Map>
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: </Map>
- en: '4\. Run the code again and see the output:'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 再次运行代码并查看输出：
- en: <mapnik._mapnik.Layer object at 0x01DD79F0>
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: <mapnik._mapnik.Layer 对象在 0x01DD79F0>
- en: world
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: world
- en: None
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: None
- en: Process finished with exit code 0
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完成，退出代码为0
- en: Now, when we print the data source property, it shows None because we removed
    it from the definition; also the image (world3.png) is empty because there is
    no data to display. Now we are going to define it in the Python code.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们打印数据源属性时，它显示为None，因为我们从定义中移除了它；此外，图像（world3.png）为空，因为没有数据要显示。现在我们将在Python代码中定义它。
- en: '5\. Edit the map_functions.py file:'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 编辑`map_functions.py`文件：
- en: coding=utf-8
  id: totrans-1333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import mapnik
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: import mapnik
- en: 'def create_map(shapefile, style_file, output_image, size=(800, 600)):'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_map(shapefile, style_file, output_image, size=(800, 600)):'
- en: '"""Creates a map from a XML file and writes it to an image.'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: '"""从XML文件创建地图并将其写入图像。'
- en: ':param shapefile: Shapefile containing the data for the map.'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: ':param shapefile: 包含地图数据的Shapefile。'
- en: ':param style_file: Mapnik XML file.'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: ':param style_file: Mapnik XML文件。'
- en: ':param output_image: Name of the output image file.'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: ':param output_image: 输出图像文件的名称。'
- en: ':param size: Size of the map in pixels.'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: ':param size: 地图在像素中的大小。'
- en: '"""'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: map = mapnik.Map(*size)
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: map = mapnik.Map(*size)
- en: mapnik.load_map(map, style_file)
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.load_map(map, style_file)
- en: data source = mapnik.Shapefile(file=shapefile)
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: data source = mapnik.Shapefile(file=shapefile)
- en: layers = map.layers
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: layers = map.layers
- en: layer = layers[0]
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: layer = layers[0]
- en: layer.datasource = data source
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: layer.datasource = data source
- en: map.zoom_all()
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: map.zoom_all()
- en: mapnik.render_to_file(map, output_image)
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.render_to_file(map, output_image)
- en: 'if __name__ == ''__main__'':'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: create_map('../../data/world_borders_simple.shp',
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: create_map('../../data/world_borders_simple.shp',`
- en: '''map_style.xml'', ''../output/world3.png'','
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: '''map_style.xml'', ''../output/world3.png'','
- en: size=(400, 400))
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: size=(400, 400))
- en: The new required argument in the function is the name of the shapefile containing
    the data. In the code we create a Mapnik data source from this file, get the first
    layer, and set its data source to the one that was created. Run the code and look
    at the output, you should see the rendered world map. Besides setting the data
    source, it is possible to combine XML and Python to change the map definition
    any way you want.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中新增的必需参数是包含数据的shapefile的名称。在代码中，我们从这个文件创建一个Mapnik数据源，获取第一层，并将其数据源设置为创建的那个。运行代码并查看输出，你应该会看到一个渲染好的世界地图。除了设置数据源外，还可以结合XML和Python以任何方式更改地图定义。
- en: '**Automatically previewing the map**'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动预览地图**'
- en: As we start to play with the map style, it could get a little boring to manually
    open the image every time we want to see the results. So we will write a function
    that will automatically open and display the image for us when we run the code.
    To do that we will use the **Open Computer Vision** (**OpenCV**) package.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始玩转地图样式时，每次想要查看结果时手动打开图像可能会有些无聊。因此，我们将编写一个函数，在运行代码时自动为我们打开并显示图像。为此，我们将使用**Open
    Computer Vision**（**OpenCV**）包。
- en: '1\. Import the package at the beginning of the map_functions.py file: import
    mapnik'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在`map_functions.py`文件的开始处导入包：`import mapnik`
- en: import cv2
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: import cv2
- en: '2\. Create this new function before the create_map function: def display_map(image_file):'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在`create_map`函数之前创建这个新函数：`def display_map(image_file):`
- en: '"""Opens and displays a map image file.'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开并显示地图图像文件。'
- en: ':param image_file: Path to the image.'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: ':param image_file: 图片的路径。'
- en: '"""'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: image = cv2.imread(image_file)
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: image = cv2.imread(image_file)
- en: cv2.imshow('image', image)
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.imshow('image', image)
- en: cv2.waitKey(0)
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.waitKey(0)
- en: cv2.destroyAllWindows()
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.destroyAllWindows()
- en: 3\. Now change our tests to call the function; to do that, edit the if __name__
    ==
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 现在将我们的测试改为调用该函数；为此，编辑`if __name__ == '__main__':`块：
- en: '''__main__'': block:'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: '''__main__'': block:'
- en: 'if __name__ == ''__main__'':'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: map_image = '../output/world3.png'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: map_image = '../output/world3.png'
- en: create_map('../../data/world_borders_simple.shp',
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 创建地图(`create_map('../../data/world_borders_simple.shp',`)
- en: '''map_style.xml'',map_image, size=(400, 400))'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: '''map_style.xml'',map_image, size=(400, 400))'
- en: display_map(map_image)
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: display_map(map_image)
- en: '4\. Run the code. Now you should see a window pop up with the map image:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 运行代码。现在你应该会看到一个包含地图图像的窗口弹出：
- en: '![Image 30](img/index-240_1.jpg)'
  id: totrans-1375
  prefs: []
  type: TYPE_IMG
  zh: '![Image 30](img/index-240_1.jpg)'
- en: We won’t explore OpenCV functionality in depth now; just note that cv2.waitKey(0)
    halts code execution until any key is pressed or the window is closed.
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会深入探讨OpenCV的功能；只需注意cv2.waitKey(0)会暂停代码执行，直到按下任意键或窗口关闭。
- en: '**Styling maps**'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '**地图样式**'
- en: 'Now that we have a function to generate the map and an easy way to preview
    them, we will experiment with the style options:'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个生成地图的函数以及预览它们的一种简单方法，我们将尝试不同的样式选项：
- en: '1\. First, lets produce a bigger map so we can better see the changes. Edit
    the if __name__ == ''__main__'': block at the end of the map_functions.py file,
    changing the size argument of the create_map function call:'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 首先，让我们生成一个更大的地图，这样我们可以更好地看到变化。编辑map_functions.py文件末尾的if __name__ == '__main__':块，更改create_map函数调用的大小参数：
- en: 'if __name__ == ''__main__'':'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: map_image = '../output/world3.png'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: map_image = '../output/world3.png'
- en: create_map('../../data/world_borders_simple.shp',
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: create_map('../../data/world_borders_simple.shp',
- en: '''map_style.xml'',map_image, size=(1024, 500))'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: '''map_style.xml'',map_image, size=(1024, 500))'
- en: display_map(map_image)
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: display_map(map_image)
- en: '![Image 31](img/index-243_1.jpg)'
  id: totrans-1385
  prefs: []
  type: TYPE_IMG
  zh: '![Image 31](img/index-243_1.jpg)'
- en: '**Map style**'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: '**地图样式**'
- en: The map is the canvas for the drawing; it is possible to change the background
    color or the background image, the coordinate reference system, and a few other
    options.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 地图是绘图的画布；可以更改背景颜色或背景图像、坐标参考系统以及一些其他选项。
- en: 'Let’s try changing the background:'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试更改背景：
- en: '1\. In the file map_style.xml edit the map tag to change the background color.
    You can use a hexadecimal value, a color name, or an RGB combination. Try this
    as an example:'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在文件map_style.xml中编辑地图标签以更改背景颜色。你可以使用十六进制值、颜色名称或RGB组合。以下是一个示例：
- en: <Map background-color="#f8be78">
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: <Map background-color="#f8be78">
- en: 2\. Run the code and see the changes.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 运行代码并查看更改。
- en: '3\. Now try using an image as the background for the map. I provided one as
    an example that will resemble old paper; change the map tag again:'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 现在尝试使用图像作为地图的背景。我提供了一个示例，它将类似于旧纸张；再次更改地图标签：
- en: <Map background-color="#f8be78"
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: <Map background-color="#f8be78"
- en: 'background-image="../../data/images/old-paper.png"> 4\. Run the code, you should
    see this output:'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: background-image="../../data/images/old-paper.png"> 4. 运行代码，你应该看到以下输出：
- en: '**Note**'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Note that background-image supersedes background-color in order of importance
    when the map is generated.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当生成地图时，背景图像的重要性高于背景颜色。
- en: '![Image 32](img/index-244_1.jpg)'
  id: totrans-1397
  prefs: []
  type: TYPE_IMG
  zh: '![Image 32](img/index-244_1.jpg)'
- en: '**Polygon style**'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: '**多边形样式**'
- en: In the XML tree that you have in your map_style.xml file, you should notice
    that, after the <Map> tag, you have the <Style> tag and then the <Rule> tag. We
    will explore them later; for now we will go directly to the symbolizers.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的map_style.xml文件中的XML树中，你应该注意到，在<Map>标签之后，你有<Style>标签，然后是<Rule>标签。我们将在稍后探索它们；现在我们将直接进入符号化器。
- en: Each symbolizer is used to style a different type of geometry or part of the
    map. The first one that we used is the PolygonSymbolizer tag, which is used to
    style the internal area of the polygon with a solid color.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 每个符号化器用于样式化不同类型的几何形状或地图的一部分。我们首先使用的是PolygonSymbolizer标签，它用于使用纯色样式多边形的内部区域。
- en: 'The polygon has also another possible symbolizer: the PolygonPatternSymbolizer
    tag, which fills the polygon with an image pattern. Let’s see how it works: 1\.
    Change the style again; let’s include a pattern symbolizer after the PolygonSymbolizer
    tag:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形还有一个可能的符号化器：PolygonPatternSymbolizer标签，它使用图像图案填充多边形。让我们看看它是如何工作的：1. 再次更改样式；让我们在PolygonSymbolizer标签之后包含一个图案符号化器：
- en: <Map background-color="#f8be78"
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: <Map background-color="#f8be78"
- en: background-image="../../data/images/old-paper.png">
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: background-image="../../data/images/old-paper.png">
- en: <Style name="My Style">
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: <Style name="My Style">
- en: <Rule>
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: <Rule>
- en: <PolygonSymbolizer fill="#f2eff9" />
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: <PolygonSymbolizer fill="#f2eff9" />
- en: <PolygonPatternSymbolizer
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: <PolygonPatternSymbolizer
- en: file="../../data/images/tree_pattern.png"/>
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: file="../../data/images/tree_pattern.png"/>
- en: <LineSymbolizer stroke="rgb(50%,50%,50%)" stroke-width="0.1" />
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: <LineSymbolizer stroke="rgb(50%,50%,50%)" stroke-width="0.1" />
- en: </Rule>
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: </Rule>
- en: </Style>
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: </Style>
- en: <Layer name="world">
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: <Layer name="world">
- en: <StyleName>My Style</StyleName>
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: <StyleName>My Style</StyleName>
- en: </Layer>
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: </Layer>
- en: </Map>
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: </Map>
- en: 2\. Run the code and see the results.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 运行代码并查看结果。
- en: The style follows the **painter model**. This means that things are *painted*
    in the order that they are in the file, so the pattern was painted over the polygon
    fill.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 样式遵循**画家模型**。这意味着事物是按照它们在文件中的顺序**绘制**的，因此图案是在多边形填充上绘制的。
- en: '![Image 33](img/index-246_1.jpg)'
  id: totrans-1418
  prefs: []
  type: TYPE_IMG
  zh: '![Image 33](img/index-246_1.jpg)'
- en: '**Line styles**'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: '**线条样式**'
- en: 'The lines (including polygon boundaries) are styled by the LineSymbolizer tag
    and the LinePatternSymbolizer tag. For the next examples, we will return the map
    to its initial style and zoom it so we can see better how the options influence
    the generated map, as follows:'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 线条（包括多边形边界）是通过LineSymbolizer标签和LinePatternSymbolizer标签进行样式的。在接下来的示例中，我们将地图恢复到其初始样式并放大，以便更好地看到选项如何影响生成的地图，如下所示：
- en: '1\. Edit the style by removing the background image and the polygon pattern.
    Also, zoom in by changing maximum-extent:'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 通过删除背景图像和多边形图案来编辑样式。通过更改最大范围进行放大：
- en: <Map background-color="white" maximum-extent="-21,68,66,28">
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: <地图 背景颜色="white" 最大范围="-21,68,66,28">
- en: <Style name="My Style">
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: <样式 name="My Style">
- en: <Rule>
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: <规则>
- en: <PolygonSymbolizer fill="#f2eff9" />
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: <多边形符号izer fill="#f2eff9" />
- en: <LineSymbolizer stroke="rgb(50%,50%,50%)" stroke-width="0.1" />
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: <线符号izer stroke="rgb(50%,50%,50%)" stroke-width="0.1" />
- en: </Rule>
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: </规则>
- en: </Style>
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: </样式>
- en: <Layer name="world">
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: <图层 name="world">
- en: <StyleName>My Style</StyleName>
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: <样式名称>My Style</样式名称>
- en: </Layer>
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: </图层>
- en: </Map>
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: </地图>
- en: '2\. Now change the LineSymbolizer tag:'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在更改LineSymbolizer标签：
- en: <LineSymbolizer stroke="red" stroke-width="3.0" /> 3\. Run the code and see
    how the lines got thicker and red.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: <线符号izer stroke="red" stroke-width="3.0" /> 3. 运行代码并查看线条如何变粗并变为红色。
- en: You may notice some strange edges and points because it’s a low-resolution map
    of the world and the lines are too thick. We can improve this map by reducing
    the thickness and by using the smooth parameter.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到一些奇怪的边缘和点，因为这是一张低分辨率的全球地图，线条太粗。我们可以通过减少厚度和使用平滑参数来改进这张地图。
- en: '4\. Edit the LineSymbolizer tag again and run the code. Now you should have
    a much clearer map:'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 再次编辑LineSymbolizer标签并运行代码。现在你应该有一个更清晰的地图：
- en: '![Image 34](img/index-247_1.jpg)'
  id: totrans-1437
  prefs: []
  type: TYPE_IMG
  zh: '![图像34](img/index-247_1.jpg)'
- en: <LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" />
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: <线符号izer stroke="red" stroke-width="1.0" smooth="0.5" />
- en: '![Image 35](img/index-248_1.jpg)'
  id: totrans-1439
  prefs: []
  type: TYPE_IMG
  zh: '![图像35](img/index-248_1.jpg)'
- en: '**Text styles**'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本样式**'
- en: 'Now, let’s add the country names to our map. To do that, we will use the TextSymbolizer
    tag:'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将国家名称添加到我们的地图中。为此，我们将使用文本符号izer标签：
- en: '1\. Change the map_style.xml file with the following code:'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 使用以下代码更改map_style.xml文件：
- en: <Map background-color="white" maximum-extent="-21,68,66,28">
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: <地图 背景颜色="white" 最大范围="-21,68,66,28">
- en: <Style name="My Style">
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: <样式 name="My Style">
- en: <Rule>
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: <规则>
- en: <PolygonSymbolizer fill="#f2eff9" />
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: <多边形符号izer fill="#f2eff9" />
- en: <LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" />
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: <线符号izer stroke="red" stroke-width="1.0" smooth="0.5" />
- en: <TextSymbolizer face-name="DejaVu Sans Book" size="10"
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: <文本符号izer face-name="DejaVu Sans Book" size="10"
- en: fill="black" halo-fill= "white"
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 填充="black" 外围填充= "white"
- en: halo-radius="1" placement="interior"
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 外围半径="1" 位置="内部"
- en: allow-overlap="false">[NAME]
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: allow-overlap="false">[姓名]
- en: </TextSymbolizer>
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: </文本符号izer>
- en: </Rule>
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: </规则>
- en: </Style>
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: </样式>
- en: <Layer name="world">
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: <图层 name="world">
- en: <StyleName>My Style</StyleName>
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: <样式名称>My Style</样式名称>
- en: </Layer>
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: </图层>
- en: </Map>
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: </地图>
- en: '2\. Run the code and see the results:'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 运行代码并查看结果：
- en: '**Adding layers to the map**'
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: '**向地图添加图层**'
- en: We saw that it’s possible to change the data source of the map with Python.
    In a Mapnik map, the data source resides inside a layer or inside the map; to
    keep it simple we will use only layers to hold the data sources.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到可以使用Python更改地图的数据源。在Mapnik地图中，数据源位于图层内部或地图内部；为了简化，我们将仅使用图层来保存数据源。
- en: If we want to add more than one data source (for example, points, lines, polygons,
    or images) we need to add more layers. As an example, we will add the geocaching
    points, which we saw in the previous chapters, to the map.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想添加多个数据源（例如，点、线、多边形或图像），我们需要添加更多图层。作为一个例子，我们将添加我们在前几章中看到的地理藏宝点到地图上。
- en: 'The first step is to completely remove the layer definition from the XML file.
    This will complete the separation of the code into two categories: the XML contains
    only the styling and the Python code handles the data and map creation.'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是完全从XML文件中删除图层定义。这将完成将代码分为两个类别的分离：XML仅包含样式，而Python代码处理数据和地图创建。
- en: 'Secondly, we will change the create_map function so it adds layers to the map.
    This change will only be an experiment before we fully implement this functionality
    on the app:'
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们将更改create_map函数，使其向地图添加图层。这个更改将只在我们完全在应用程序上实现此功能之前作为一个实验：
- en: '1\. In the mapnik_xml.xml file, remove the layer from the definition, change
    the style name to style1, and add a new style for the points. Also change the
    extent of the map to focus on the points. It should be like this:'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在mapnik_xml.xml文件中，从定义中删除图层，将样式名称更改为style1，并为点添加新的样式。同时，更改地图的范围以聚焦于点。它应该像这样：
- en: <Map background-color="white" maximum-extent="-81,45,-69,40">
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: <地图 背景颜色="white" 最大范围="-81,45,-69,40">
- en: <Style name="style1">
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: <样式 name="style1">
- en: <Rule>
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: <规则>
- en: <PolygonSymbolizer fill="#f2eff9" />
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: <多边形符号izer fill="#f2eff9" />
- en: <LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" />
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: <线符号izer stroke="red" stroke-width="1.0" smooth="0.5" />
- en: <TextSymbolizer face-name="DejaVu Sans Book" size="10"
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: <文本符号izer face-name="DejaVu Sans Book" size="10"
- en: fill="black" halo-fill= "white"
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: fill="black" halo-fill= "white"
- en: halo-radius="1" placement="interior"
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: halo-radius="1" placement="interior"
- en: allow-overlap="false">[NAME]
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: allow-overlap="false">[NAME]
- en: </TextSymbolizer>
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: </TextSymbolizer>
- en: </Rule>
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: </Rule>
- en: </Style>
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: </Style>
- en: <Style name="style2">
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: <Style name="style2">
- en: <Rule>
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: <Rule>
- en: <PointSymbolizer/>
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: <PointSymbolizer/>
- en: </Rule>
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: </Rule>
- en: </Style>
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: </Style>
- en: </Map>
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: </Map>
- en: '2\. In the map_functions.py file, change your create_map function and the if
    __name__ == ''__main__'': block. The complete code should look like this:'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: '2\. 在 map_functions.py 文件中，更改你的 create_map 函数和 if __name__ == ''__main__'':
    块。完整的代码应如下所示：'
- en: coding=utf-8
  id: totrans-1485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import mapnik
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: import mapnik
- en: import cv2
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: import cv2
- en: 'def display_map(image_file):'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 'def display_map(image_file):'
- en: '"""Opens and displays a map image file.'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开并显示地图图像文件。'
- en: ':param image_file: Path to the image.'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: ':param image_file: 图像的路径。'
- en: '"""'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: image = cv2.imread(image_file)
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: image = cv2.imread(image_file)
- en: cv2.imshow('image', image)
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.imshow('image', image)
- en: cv2.waitKey(0)
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.waitKey(0)
- en: cv2.destroyAllWindows()
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.destroyAllWindows()
- en: 'def create_map(shapefile, gpx_file, style_file, output_image, size=(800, 600)):'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_map(shapefile, gpx_file, style_file, output_image, size=(800, 600)):'
- en: '"""Creates a map from a XML file and writes it to an image.'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: '"""从 XML 文件创建地图并将其写入图像。'
- en: ':param shapefile: Shapefile containing the data for the map.'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: ':param shapefile: 包含地图数据的形状文件。'
- en: ':param style_file: Mapnik XML file.'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: ':param style_file: Mapnik XML 文件。'
- en: ':param output_image: Name of the output image file.'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: ':param output_image: 输出图像文件的名称。'
- en: ':param size: Size of the map in pixels.'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: ':param size: 地图像素大小。'
- en: '"""'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: map = mapnik.Map(*size)
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: map = mapnik.Map(*size)
- en: mapnik.load_map(map, style_file)
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.load_map(map, style_file)
- en: layers = map.layers
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: layers = map.layers
- en: Add the shapefile.
  id: totrans-1506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加形状文件。
- en: world_datasource = mapnik.Shapefile(file=shapefile)
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: world_datasource = mapnik.Shapefile(file=shapefile)
- en: world_layer = mapnik.Layer('world')
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: world_layer = mapnik.Layer('world')
- en: world_layer.datasource = world_datasource
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: world_layer.datasource = world_datasource
- en: world_layer.styles.append('style1')
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: world_layer.styles.append('style1')
- en: layers.append(world_layer)
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: layers.append(world_layer)
- en: Add the shapefile.
  id: totrans-1512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加形状文件。
- en: points_datasource = mapnik.Ogr(file=gpx_file, layer='waypoints') points_layer
    = mapnik.Layer('geocaching_points')
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: points_datasource = mapnik.Ogr(file=gpx_file, layer='waypoints') points_layer
    = mapnik.Layer('geocaching_points')
- en: points_layer.datasource = points_datasource
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: points_layer.datasource = points_datasource
- en: points_layer.styles.append('style2')
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: points_layer.styles.append('style2')
- en: layers.append(points_layer)
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: layers.append(points_layer)
- en: map.zoom_all()
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: map.zoom_all()
- en: mapnik.render_to_file(map, output_image)
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.render_to_file(map, output_image)
- en: 'if __name__ == ''__main__'':'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: map_image = '../output/world3.png'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: map_image = '../output/world3.png'
- en: create_map('../../data/world_borders_simple.shp',
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: create_map('../../data/world_borders_simple.shp',
- en: '''../../data/geocaching.gpx'','
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/geocaching.gpx'','
- en: '''map_style.xml'',map_image, size=(1024, 500))'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: '''map_style.xml'',map_image, size=(1024, 500))'
- en: display_map(map_image)
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: display_map(map_image)
- en: 'Now the function accepts two files: one shapefile with the world borders and
    one GPX file containing waypoints. For each file, a data source and a layer containing
    it are created and added to the map list of layers. We also define the styles
    for the layer using the style names defined in the XML.'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数接受两个文件：一个包含世界边界的形状文件和一个包含航点的 GPX 文件。对于每个文件，创建一个包含它的数据源和图层，并将其添加到地图图层列表中。我们还使用在
    XML 中定义的样式名称定义图层样式。
- en: '3\. Run the code; you should see the points rendered over the world borders
    with the default PointSymbolizer style:'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 运行代码；你应该会看到默认的点符号化样式下渲染在世界边界上的点：
- en: '![Image 36](img/index-251_1.jpg)'
  id: totrans-1527
  prefs: []
  type: TYPE_IMG
  zh: '![Image 36](img/index-251_1.jpg)'
- en: '**Point styles**'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: '**点样式**'
- en: 'Now we are going to improve the visual representation of the points: 1\. Edit
    the map_style.xml file and change the point style:'
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将改进点的视觉表示：1\. 编辑 map_style.xml 文件并更改点样式：
- en: <Map background-color="white" maximum-extent="-81,45,-69,40">
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: <Map background-color="white" maximum-extent="-81,45,-69,40">
- en: <Style name="style1">
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: <Style name="style1">
- en: <Rule>
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: <Rule>
- en: <PolygonSymbolizer fill="#f2eff9" />
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: <PolygonSymbolizer fill="#f2eff9" />
- en: <LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" />
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: <LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" />
- en: <TextSymbolizer face-name="DejaVu Sans Book" size="10"
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: <TextSymbolizer face-name="DejaVu Sans Book" size="10"
- en: fill="black" halo-fill= "white"
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: fill="black" halo-fill= "white"
- en: halo-radius="1" placement="interior"
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: halo-radius="1" placement="interior"
- en: allow-overlap="false">[NAME]
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: allow-overlap="false">[NAME]
- en: </TextSymbolizer>
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: </TextSymbolizer>
- en: </Rule>
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: </Rule>
- en: </Style>
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: </Style>
- en: <Style name="style2">
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: <Style name="style2">
- en: <Rule>
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: <Rule>
- en: <PointSymbolizer file="../../data/images/marker.svg"
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: <PointSymbolizer file="../../data/images/marker.svg"
- en: transform="scale(0.3)"/>
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: transform="scale(0.3)"/>
- en: </Rule>
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: </Rule>
- en: </Style>
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: </Style>
- en: </Map>
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: </Map>
- en: We introduce the use of a **Scalable Vector Graphics** (**SVG**) file to represent
    the point; the advantage of this kind of file is that it can be scaled or zoomed
    without distortions because it is composed of vectors and not pixels.
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了使用可缩放矢量图形（**SVG**）文件来表示点的用法；这种文件的优势在于，由于它由矢量组成而不是像素，因此可以缩放或缩放而不会失真。
- en: Since the SVG that we used is too big for our map, it was used with the transform
    parameter to scale the image.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的SVG文件太大，不适合我们的地图，因此使用了transform参数来缩放图像。
- en: '**Note**'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find more about SVG transformations at
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置了解更多关于SVG转换的信息
- en: '[http://www.w3.org/TR/SVG/coords.html.](http://www.w3.org/TR/SVG/coords.html)'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.w3.org/TR/SVG/coords.html](http://www.w3.org/TR/SVG/coords.html)'
- en: '2\. Run your code and take a look at the results:'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 运行你的代码并查看结果：
- en: '![Image 37](img/index-253_1.jpg)'
  id: totrans-1555
  prefs: []
  type: TYPE_IMG
  zh: '![Image 37](img/index-253_1.jpg)'
- en: '**Note**'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: If you need symbols for your projects, you can find a good collection in the
    **Noun** **Project**, which aggregates creations from the community around the
    world at
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目需要符号，你可以在**名词**项目中找到一个很好的集合，该项目汇集了来自世界各地的社区创作，网址为
- en: '[https://thenounproject.com/.](https://thenounproject.com/)'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://thenounproject.com/](https://thenounproject.com/)'
- en: We have a beautiful representation of the points, and now we are going to add
    more information on them.
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个漂亮的点表示，现在我们将添加更多关于它们的信息。
- en: '**Using Python objects as a source of data**'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Python对象作为数据源**'
- en: '**Tip**'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Mapnik for Windows does not come with the Python Datasource plugin and a workaround
    will be provided for Windows users; just follow the steps.
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: Mapnik for Windows没有附带Python数据源插件，将为Windows用户提供一个解决方案；只需按照以下步骤操作。
- en: Data is represented internally on Mapnik by a Datasource object. This object
    is responsible for accessing the source of the data (for example, a file containing
    the data, a database, and so on) and transforming the features provided by this
    source of data into Feature objects. In turn, the Feature object contains a geometry
    and a number of properties (attributes). This organization is very similar to
    what we have seen in [Chapter 4](#p174), *Improving the App Search Capabilities*,
    in the topic *How geographic data is represented*.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mapnik内部，数据通过数据源对象表示。该对象负责访问数据源（例如，包含数据的文件、数据库等）并将该数据源提供的功能转换为特征对象。反过来，特征对象包含几何形状和多个属性（属性）。这种组织方式与我们之前在[第4章](#p174)，“改进应用搜索功能”主题中看到的非常相似，即*地理数据的表示*。
- en: If we could hack into a Datasource and provide the features the way we want,
    we would be able to make Mapnik use Python objects that we provide as a source
    of data.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够黑入数据源并提供我们想要的功能，我们就能够使Mapnik使用我们提供的Python对象作为数据源。
- en: The advantage of using a Python object as a Datasource, instead of a file for
    example, is that we can perform any kind of transformation and analysis on the
    data and then feed it to Mapnik without needing to save it to disk. By doing that,
    we keep the data in memory, increase the performance of the application, and make
    it more versatile and easy-to-use.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python对象作为数据源（例如，而不是文件）的优点是，我们可以在数据上执行任何类型的转换和分析，然后将它馈送到Mapnik，而无需将其保存到磁盘。通过这样做，我们保持数据在内存中，提高应用程序的性能，并使其更加灵活和易于使用。
- en: Fortunately, Mapnik comes with a class already prepared for this kind of operation;
    as you may have guessed, it’s called PythonDatasource.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Mapnik已经提供了一个用于此类操作的类；正如你可能已经猜到的，它被称为PythonDatasource。
- en: As we prepare to build our application, in this step we will produce a class
    that inherits from mapnik.PythonDatasource and implements the required methods
    for it to work.
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们准备构建应用程序的过程中，在这一步中，我们将创建一个继承自mapnik.PythonDatasource并实现其所需方法的类。
- en: First, we are going to take a look at Mapnik’s source code in order to understand
    the logic behind the PythonDatasource class.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看Mapnik的源代码，以便了解PythonDatasource类的逻辑。
- en: 1\. Go to your Chapter5 folder and create a file named my_datasource.py.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 前往你的Chapter5文件夹，创建一个名为my_datasource.py的文件。
- en: '2\. Insert this code in that file:'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 将此代码插入该文件：
- en: coding=utf-8
  id: totrans-1571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import mapnik
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: import mapnik
- en: test_datasource = mapnik.PythonDatasource()
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: test_datasource = mapnik.PythonDatasource()
- en: 3\. Now click anywhere on PythonDatasource to place your cursor on it and press
    *Ctrl*
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 现在点击PythonDatasource上的任何位置，将光标放在它上面，然后按*Ctrl*
- en: + *B*. Or, right-click anywhere on PythonDatasource then select **Go To** |
    **Declaration**.
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: + *B*. 或者，在PythonDatasource上的任何位置右键单击，然后选择**转到** | **声明**。
- en: This will open and show the class declaration for you.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您打开并显示类声明。
- en: '4\. I will go through each part of the class, commenting the code. Don’t worry
    if you are not near a computer. I’ll place excerpts of the class before each explanation:
    class PythonDatasource(object):'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: '4. 我将逐部分讲解这个类，并在每个解释前放置类的摘录。如果您不在电脑附近，请不要担心。我会在每个解释前放置类的摘录：class PythonDatasource(object):'
- en: '"""A base class for a Python data source.'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: '"""这是一个Python数据源的基类。'
- en: 'Optional arguments:'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数：
- en: envelope—a mapnik.Box2d (minx, miny, maxx, maxy) envelope
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: envelope：mapnik.Box2d (minx, miny, maxx, maxy) 边界
- en: of the data source, default (-180,-90,180,90)
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 的数据源，默认为(-180,-90,180,90)
- en: geometry_type—one of the DataGeometryType enumeration values, default Point
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: geometry_type：DataGeometryType枚举值之一，默认为Point
- en: data_type—one of the DataType enumerations, default Vector
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: data_type：DataType枚举之一，默认为Vector
- en: '"""'
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: def __init__(self, envelope=None, geometry_type=None,
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: def __init__(self, envelope=None, geometry_type=None,
- en: 'data_type=None):'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 'data_type=None):'
- en: self.envelope = envelope or Box2d(-180, -90, 180, 90)
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: self.envelope = envelope or Box2d(-180, -90, 180, 90)
- en: self.geometry_type = geometry_type or DataGeometryType.Point self.data_type
    = data_type or DataType.Vector
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: self.geometry_type = geometry_type or DataGeometryType.Point self.data_type
    = data_type or DataType.Vector
- en: 'This is the class declaration and the __init__ method; the arguments to create
    the class are all optional but if we need to we can define the envelope (that
    is, the bounding box) and two important parameters:'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类的声明和__init__方法；创建类的参数都是可选的，但如果我们需要，我们可以定义边界（即边界框）和两个重要参数：
- en: 'geometry_type: Can be Collection, LineString, Point, or Polygon data_type:
    Can be Vector or Raster'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 'geometry_type: 可以是Collection、LineString、Point或Polygon数据类型：可以是Vector或Raster'
- en: 'def features(self, query):'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 'def features(self, query):'
- en: '"""Return an iterable which yields instances of Feature for features within
    the passed query.'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: '"""返回一个可迭代对象，该对象生成在传递的查询内的Feature实例。'
- en: 'Required arguments:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 必要参数：
- en: query—a Query instance specifying the region for which
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: query：指定区域的Query实例
- en: features should be returned
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: features应该返回
- en: '"""'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: return None
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: return None
- en: This is the key method for PythonDatasource to work. This method should return
    an *iterable* containing the features.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 这是PythonDatasource工作的关键方法。该方法应返回一个包含特征的*可迭代对象*。
- en: An iterable is any Python object that can be used in a for loop or, as described
    in the Python glossary, any object capable of returning its members one at a time.
    It can be a list, a tuple, a dictionary, and so on.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象是任何可以在for循环中使用的Python对象，或者，如Python词汇表所述，任何能够一次返回其成员的对象。它可以是一个列表、一个元组、一个字典等等。
- en: 'Despite the description in the docstring, this method is empty and returns
    None. It’s an indication that it should be implemented on the child classes and
    that how this iterable is created is entirely up to the programmer:'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管文档字符串中的描述，此方法为空并返回None。它是表明它应该在子类中实现，以及如何创建此可迭代对象完全取决于程序员的指示：
- en: '**Note**'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'Take a look at the Python glossary for information on new terms or terms that
    are still confusing for you: [https://docs.python.org/2/glossary.html.](https://docs.python.org/2/glossary.html)'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Python词汇表以获取有关新术语或您仍然感到困惑的术语的信息：[https://docs.python.org/2/glossary.html.](https://docs.python.org/2/glossary.html)
- en: 'def features_at_point(self, point):'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: 'def features_at_point(self, point):'
- en: '"""Rarely uses. Return an iterable which yields instances of Feature for the
    specified point."""'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: '"""很少使用。返回一个可迭代对象，该对象生成指定点的Feature实例。”'
- en: return None
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: return None
- en: This is more of a convenience method, so we won’t use it.
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更方便的方法，所以我们不会使用它。
- en: '@classmethod'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: '@classmethod'
- en: 'def wkb_features(cls, keys, features):'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 'def wkb_features(cls, keys, features):'
- en: '"""A convenience function to wrap an iterator yielding pairs'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: '"""这是一个包装迭代器生成对的便利函数'
- en: of WKB format geometry and dictionaries of key-value pairs into mapnik features.
    Return this from
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 将WKB格式的几何形状和键值对字典转换为mapnik特征。返回此值。
- en: PythonDatasource.features() passing it a sequence of keys
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: PythonDatasource.features()传递给它一个键序列
- en: to appear in the output and an iterator yielding features.
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 以出现在输出中，以及生成特征的迭代器。
- en: 'For example. One might have a features() method in a derived class like the
    following:'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个派生类可能有一个如下的features()方法：
- en: 'def features(self, query):'
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 'def features(self, query):'
- en: '... create WKB features feat1 and feat2'
  id: totrans-1615
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '... 创建WKB特征feat1和feat2'
- en: return mapnik.PythonDatasource.wkb_features(
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: return mapnik.PythonDatasource.wkb_features(
- en: keys = ( 'name', 'author' ),
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: keys = ( 'name', 'author' ),
- en: features = [
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: features = [
- en: '(feat1, { ''name'': ''feat1'', ''author'': ''alice'' }),'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: '(feat1, { ''name'': ''feat1'', ''author'': ''alice'' }),'
- en: '(feat2, { ''name'': ''feat2'', ''author'': ''bob'' }),'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: '(feat2, { ''name'': ''feat2'', ''author'': ''bob'' }),'
- en: ']'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: )
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '"""'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ctx = Context()
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: ctx = Context()
- en: '[ctx.push(x) for x in keys]'
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: '[ctx.push(x) for x in keys]'
- en: 'def make_it(feat, idx):'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 'def make_it(feat, idx):'
- en: f = Feature(ctx, idx)
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: f = Feature(ctx, idx)
- en: geom, attrs = feat
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: geom, attrs = feat
- en: f.add_geometries_from_wkb(geom)
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: f.add_geometries_from_wkb(geom)
- en: 'for k, v in attrs.iteritems():'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 'for k, v in attrs.iteritems():'
- en: f[k] = v
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: f[k] = v
- en: return f
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: return f
- en: return itertools.imap(make_it, features, itertools.count(1))
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: return itertools.imap(make_it, features, itertools.count(1))
- en: '@classmethod'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: '@classmethod'
- en: 'def wkt_features(cls, keys, features):'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 'def wkt_features(cls, keys, features):'
- en: '"""A convenience function to wrap an iterator yielding pairs of WKT format
    geometry and dictionaries of key-value pairs'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: '"""一个便利函数，用于包装一个生成 WKT 格式几何形状和键值对字典对的迭代器'
- en: into mapnik features. Return this from
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为 mapnik 特征。从
- en: PythonDatasource.features() passing it a sequence of keys
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: PythonDatasource.features()，传递一个键序列
- en: to appear in the output and an iterator yielding features.
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 以便出现在输出中，并生成特征迭代器。
- en: For example. One might have a features() method in a
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可能有一个 features() 方法在
- en: 'derived class like the following:'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 类似以下的派生类：
- en: 'def features(self, query):'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 'def features(self, query):'
- en: '... create WKT features feat1 and feat2'
  id: totrans-1643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '... 创建 WKT 特征 feat1 和 feat2'
- en: return mapnik.PythonDatasource.wkt_features(
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: return mapnik.PythonDatasource.wkt_features(
- en: keys = ( 'name', 'author' ),
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: keys = ( 'name', 'author' ),
- en: features = [
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: features = [
- en: '(feat1, { ''name'': ''feat1'', ''author'': ''alice'' }),'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: '(feat1, { ''name'': ''feat1'', ''author'': ''alice'' }),'
- en: '(feat2, { ''name'': ''feat2'', ''author'': ''bob'' }),'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: '(feat2, { ''name'': ''feat2'', ''author'': ''bob'' }),'
- en: ']'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: )
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '"""'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ctx = Context()
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: ctx = Context()
- en: '[ctx.push(x) for x in keys]'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: '[ctx.push(x) for x in keys]'
- en: 'def make_it(feat, idx):'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 'def make_it(feat, idx):'
- en: f = Feature(ctx, idx)
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: f = Feature(ctx, idx)
- en: geom, attrs = feat
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: geom, attrs = feat
- en: f.add_geometries_from_wkt(geom)
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: f.add_geometries_from_wkt(geom)
- en: 'for k, v in attrs.iteritems():'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 'for k, v in attrs.iteritems():'
- en: f[k] = v
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: f[k] = v
- en: return f
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: return f
- en: return itertools.imap(make_it, features, itertools.count(1)) These are two convenience
    functions (or methods). Take a look at the section *Integrating* *with the app*
    in [Chapter 4,](#p174) *Improving the App Search Capabilities*, if you don’t remember
    what a convenience method is. We created one there.
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: return itertools.imap(make_it, features, itertools.count(1)) 这些是两个便利函数（或方法）。如果你不记得便利方法是什么，可以查看
    [第 4 章](#p174)，*Improving the App Search Capabilities*) 中的 *Integrating* *with
    the app* 部分。我们在那里创建了一个。
- en: Those methods are an easy shortcut to creating an iterable of Mapnik features
    from a list of lists (or tuples) containing the geometries and the attributes
    in a dictionary, one from WKT geometries and one from WKB geometries (again, if
    you need, take a look at the section *Knowing well-known text* in [Chapter 4](#p174),
    *Improving the App Search Capabilities*).
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是从包含几何形状和字典中属性列表（或元组）的列表创建 Mapnik 特征的可迭代对象的简单快捷方式，一个来自 WKT 几何形状，另一个来自 WKB
    几何形状（如果你需要，可以查看 [第 4 章](#p174)，*Improving the App Search Capabilities*) 中的 *Knowing
    well-known text* 部分）。
- en: One caveat is that these are not instance methods; they are class methods. Note
    the
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 一个注意事项是，这些不是实例方法；它们是类方法。注意
- en: '@classmethod before the method name; this is a decorator that changes the method’s
    behavior.'
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: '@classmethod 在方法名之前；这是一个装饰器，它改变了方法的行为。'
- en: I won’t go into details about class methods and decorators (it would require
    an entire chapter). All we need to know is that we call this method from the class
    and not from the instance, using PythonDatasource.wkt_features() or
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入讲解类方法和装饰器（那需要整整一章的内容）。我们只需要知道，我们是从类而不是从实例调用这个方法，使用 PythonDatasource.wkt_features()
    或
- en: PythonDatasource.wkb_features().
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: PythonDatasource.wkb_features().
- en: 'Putting this into practice, what we need to do is create a class that inherits
    from PythonDatasource and reimplements its feature method. Let’s start from the
    class skeleton and then later we will go back to the classes that we built in
    [Chapter 2](index_split_000.html#p103), *The* *Geocaching App*, [Chapter 3,](index_split_000.html#p142)
    *Combining Multiple Data Sources*, and [Chapter 4](#p174), *Improving* *the App
    Search Capabilities*, and use them as a source for the features: 1\. Edit my_datasource.py;
    remove the previous code and add the new class:'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们需要做的是创建一个从 PythonDatasource 继承并重新实现其特征方法的类。让我们从类骨架开始，然后稍后我们将回到我们在 [第
    2 章](index_split_000.html#p103)，*The* *Geocaching App*，[第 3 章](index_split_000.html#p142)，*Combining
    Multiple Data Sources*，和 [第 4 章](#p174)，*Improving* *the App Search Capabilities*
    中构建的类，并将它们用作特征的来源：1\. 编辑 my_datasource.py；删除之前的代码并添加新的类：
- en: coding=utf-8
  id: totrans-1668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import mapnik
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: import mapnik
- en: 'class MapDatasource(mapnik.PythonDatasource):'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MapDatasource(mapnik.PythonDatasource):'
- en: '"""Implementation of Mapinik''s PythonDatasource."""'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: '"""Mapinik 的 PythonDatasource 的实现。”'
- en: 'def features(self, query=None):'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: 'def features(self, query=None):'
- en: raise NotImplementedError
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: The first thing we did was to make the query an optional argument; we won’t
    remove it because there is a risk of breaking compatibility. Then the function
    only raises an exception to the effect that it’s not implemented yet.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是将查询参数设置为可选参数；我们不会移除它，因为存在破坏兼容性的风险。然后函数仅抛出一个异常，表示尚未实现。
- en: '**Exporting geo objects**'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: '**导出地理对象**'
- en: Before we continue, as part of the workaround for windows users we will need
    to export our geo objects as files.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，作为为Windows用户解决方法的一部分，我们需要将我们的地理对象导出为文件。
- en: 'We will use the GeoJSON file format. It’s a good choice of format for exporting
    geographic data because:'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用GeoJSON文件格式。它是导出地理数据的好选择，因为：
- en: It’s human-readable
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 它是可读的
- en: It’s an open standard
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个开放标准
- en: It’s easy to make code that exports GeoJSON
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 编写导出GeoJSON的代码很容易
- en: Mapnik can import it
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: Mapnik可以导入它
- en: The properties/attributes can have multiple levels
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 属性/属性可以有多个级别
- en: Here you can see the same example of a GeoJSON file that we saw in [Chapter
    3,](index_split_000.html#p142)
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到我们之前在[第3章](index_split_000.html#p142)中看到的GeoJSON文件示例
- en: '*Combining Multiple Data Sources – How Geographic Data is Represented*. You
    don’t need to type it, we are just going to use it as a reference to write our
    export code:'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: '*结合多个数据源 – 地理数据是如何表示的*。你不需要输入它，我们只是用它作为参考来编写我们的导出代码：'
- en: '{"type": "FeatureCollection",'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: '{"type": "FeatureCollection",'
- en: '"features": ['
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: '"features": ['
- en: '{"type": "Feature",'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: '{"type": "Feature",'
- en: '"geometry": {'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: '"geometry": {'
- en: '"type": "Point",'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "Point",'
- en: '"coordinates": [102.0, 0.5]},'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: '"coordinates": [102.0, 0.5]},'
- en: '"properties": {"prop0": "value0"}'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: '"properties": {"prop0": "value0"}'
- en: '},'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '{"type": "Feature",'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: '{"type": "Feature",'
- en: '"geometry": {'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: '"geometry": {'
- en: '"type": "LineString",'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "LineString",'
- en: '"coordinates": [[102.0, 0.0], [103.0, 1.0], [104.0, 0.0]]'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: '"coordinates": [[102.0, 0.0], [103.0, 1.0], [104.0, 0.0]]'
- en: '},'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"properties": {'
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: '"properties": {'
- en: '"prop0": "value0", "prop1": 0.0'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: '"prop0": "value0", "prop1": 0.0'
- en: '}'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '},'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '{"type": "Feature",'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: '{"type": "Feature",'
- en: '"geometry": {'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: '"geometry": {'
- en: '"type": "Polygon",'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "Polygon",'
- en: '"coordinates": ['
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: '"coordinates": ['
- en: '[ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: '[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0],'
- en: '[100.0, 1.0], [100.0, 0.0] ]'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: '[100.0, 1.0], [100.0, 0.0] ]'
- en: ']'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '},'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"properties": {"prop0": "value0",'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: '"properties": {"prop0": "value0",'
- en: '"prop1": {"this": "that"}'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: '"prop1": {"this": "that"}'
- en: '}'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ']'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Looking at the file, we can see that the geo objects that we created have characteristics
    that conveniently make it very easy to export them to this file format. If we
    think of a BaseGeoObject being a GeoJSON "Feature" and a BaseGeoCollection being
    a
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: 查看文件，我们可以看到我们创建的地理对象具有便于将其导出为该文件格式的特性。如果我们认为BaseGeoObject是一个GeoJSON "Feature"，而BaseGeoCollection是一个
- en: '"FeatureCollection", it’s easy to get started: 1\. Open your models.py file
    and go to the BaseGeoObject class. Add the export_geojson_feature method:'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: '"FeatureCollection"，它很容易开始：1. 打开你的models.py文件，转到BaseGeoObject类。添加export_geojson_feature方法：'
- en: '#...'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def export_geojson_feature(self):'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 'def export_geojson_feature(self):'
- en: '"""Exports this object as dictionary formatted as a GeoJSON feature.'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将此对象导出为字典格式，作为GeoJSON特征。'
- en: '"""'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: feature = {
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: feature = {
- en: '"type": "Feature",'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "Feature",'
- en: '"geometry": mapping(self.geom),'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: '"geometry": mapping(self.geom),'
- en: '"properties": self.attributes}'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: '"properties": self.attributes}'
- en: return feature
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: return feature
- en: The mapping function calls a *magic method* that every shapely geometry has;
    it returns the geometry as a GeoJSON representation.
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 映射函数调用每个shapely几何体都有的一个“魔法方法”；它返回几何体的GeoJSON表示。
- en: '2\. Now, edit the BaseGeoCollection class. Add the export_geojson method:'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在，编辑BaseGeoCollection类。添加export_geojson方法：
- en: '#...'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def export_geojson(self, file):'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: 'def export_geojson(self, file):'
- en: '"""Exports the collection to a GeoJSON file."""'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将集合导出为GeoJSON文件。”'
- en: features = [i.export_geojson_feature() for i in self.data]
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: features = [i.export_geojson_feature() for i in self.data]
- en: 'geojson = {"type": "FeatureCollection",'
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 'geojson = {"type": "FeatureCollection",'
- en: '"features": features}'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: '"features": features}'
- en: 'with open(file, ''w'') as out_file:'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(file, ''w'') as out_file:'
- en: json.dump(geojson, out_file, indent=2)
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: json.dump(geojson, out_file, indent=2)
- en: 'print("File exported: {}".format(file))'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("文件已导出: {}".format(file))'
- en: Here we used a *list comprehension* ([i.export_geojson_feature() for i in self.data])
    to generate a list of features, then used the json module to serialize the dictionary
    into a JSON.
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了一个列表推导式([i.export_geojson_feature() for i in self.data])来生成特征列表，然后使用json模块将字典序列化为JSON。
- en: '3\. Import the mapping function from shapely and add the json module to your
    imports at the beginning of the file:'
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 从shapely导入mapping函数，并将json模块添加到文件开头的导入中：
- en: coding=utf-8
  id: totrans-1740
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: from __future__ import print_function
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: from __future__ import print_function
- en: import json
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 导入json
- en: from shapely.geometry import Point, mapping
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: from shapely.geometry import Point, mapping
- en: from shapely import wkb, wkt
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: 从shapely导入wkb, wkt
- en: import gdal
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 导入gdal库
- en: from utils.geo_functions import open_vector_file
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 从utils.geo_functions导入open_vector_file
- en: from utils.geo_functions import transform_geometry
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 从utils.geo_functions导入transform_geometry
- en: from utils.geo_functions import convert_length_unit
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 从utils.geo_functions导入convert_length_unit
- en: '4\. Finally, let’s test it. Edit your if __name__ == ''__main__'': block: if
    __name__ == ''__main__'':'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: '4. 最后，让我们测试它。编辑您的if __name__ == ''__main__'':块：if __name__ == ''__main__'':'
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: gdal.PushErrorHandler('CPLQuietErrorHandler')
- en: points = PointCollection("../data/geocaching.gpx") points.export_geojson("output/data.json")
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: points = PointCollection("../data/geocaching.gpx") points.export_geojson("output/data.json")
- en: '5\. Run the code and open the output/data.json file to check the results:'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 运行代码并打开output/data.json文件以检查结果：
- en: '{'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"type": "FeatureCollection",'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "FeatureCollection",'
- en: '"features": ['
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: '"features": ['
- en: '{'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"geometry": {'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: '"geometry": {'
- en: '"type": "Point",'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "Point",'
- en: '"coordinates": ['
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: '"coordinates": ['
- en: -78.90175,
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: -78.90175,
- en: '42.89648'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: '42.89648'
- en: ']'
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '},'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"type": "Feature",'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "Feature",'
- en: '"properties": {'
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: '"properties": {'
- en: '"status": "Available",'
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: '"status": "Available",'
- en: '"logs": {'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: '"logs": {'
- en: '"log": ['
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: '"log": ['
- en: '{'
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"@id": "1",'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: '"@id": "1",'
- en: '"time": "05/09/2015T11:04:05",'
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: '"time": "05/09/2015T11:04:05",'
- en: '"geocacher": "SYSTEM",'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: '"geocacher": "SYSTEM",'
- en: '"text": "Attributes: Quick Cache | Kid Friendly |\n'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: '"text": "属性：快速缓存 | 适合儿童 |\n'
- en: '},'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '...'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Everything was neatly exported, including all the properties and logs. PyCharm
    can also inspect JSON files, so you can use the Structure panel ( *Alt* + *7*)
    to explore the file structure as you did with the GPX file.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内容都整齐地导出，包括所有属性和日志。PyCharm还可以检查JSON文件，因此您可以使用结构面板（*Alt* + *7*）来探索文件结构，就像您处理GPX文件时那样。
- en: '**Creating the Map Maker app**'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建地图制作应用程序**'
- en: Now we will prepare an environment that is capable of using this data source.
    We are going to adapt the previous experiments into building blocks for the application
    and put them inside an application class, just as we did with the Geocaching app.
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将准备一个能够使用此数据源的环境。我们将把之前的实验改编成构建块，并将它们放入应用程序类中，就像我们处理Geocaching应用程序时那样。
- en: First let’s organize the folder and files.
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们整理文件夹和文件。
- en: 1\. Create a new package called map_maker inside your Chapter5 folder. To do
    this, right-click on the folder and chose **New** | **Python Package**.
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在您的Chapter5文件夹中创建一个名为map_maker的新包。为此，右键单击文件夹，选择**新建** | **Python包**。
- en: 2\. Move the my_datasource.py file to the map_make folder (drag and drop it).
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 将my_datasource.py文件移动到map_make文件夹中（拖放）。
- en: 3\. Copy the map_style.xml and map_functions.py files that are inside the mapnik_experiments
    folder to the map_maker folder.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 将mapnik_experiments文件夹中的map_style.xml和map_functions.py文件复制到map_maker文件夹中。
- en: 4\. Rename map_style.xml to styles.xml.
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 将map_style.xml重命名为styles.xml。
- en: '5\. In the Chapter5 root, create a file named map_maker_app.py. The complete
    tree structure should look like this:'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 在Chapter5根目录下创建一个名为map_maker_app.py的文件。完整的树结构应如下所示：
- en: Chapter5
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter5
- en: │ geocaching_app.py
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: │ geocaching_app.py
- en: '| map_maker_app.py'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: '| map_maker_app.py'
- en: │ models.py
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: │ models.py
- en: │
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: │
- en: ├───mapnik_experiments
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: ├───mapnik_experiments
- en: │
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: │
- en: ├───map_maker
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: ├───map_maker
- en: │ __init__.py
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: │ __init__.py
- en: │ my_datasource.py
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: │ my_datasource.py
- en: '| styles.xml'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: '| styles.xml'
- en: '| map_functions.py'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: '| map_functions.py'
- en: │
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: │
- en: ├───utils
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: ├───utils
- en: Now we create the class that represents the application.
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个代表应用程序的类。
- en: '6\. In the map_maker_app.py file, create this new class and its __init__ method:'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 在map_maker_app.py文件中，创建这个新类及其__init__方法：
- en: coding=utf-8
  id: totrans-1801
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import cv2
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 导入cv2
- en: import mapnik
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 导入mapnik
- en: 'class MapMakerApp(object):'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MapMakerApp(object):'
- en: 'def __init__(self, output_image=None):'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, output_image=None):'
- en: '"""Application class."""'
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用程序类."""'
- en: self.output_image = output_image
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: self.output_image = output_image
- en: output_image will be the image that the app will write to the maps. It’s not
    private because we may want to change it during the application execution.
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: output_image将是应用程序将写入地图的图像。它不是私有的，因为在应用程序执行期间我们可能想要更改它。
- en: '7\. Copy the display_map function from the map_functions.py file, and adapt
    it to work as a method of our new class:'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 从map_functions.py文件中复制display_map函数，并将其适配为我们的新类的方法：
- en: 'class MapMakerApp(object):'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MapMakerApp(object):'
- en: 'def __init__(self, output_image=None):'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, output_image=None):'
- en: '"""Application class."""'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用程序类."""'
- en: self.output_image = output_image
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: self.output_image = output_image
