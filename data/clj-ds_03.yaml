- en: Chapter 3. Correlation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章. 相关性
- en: '|   | *"The more I learn about people, the better I like my dog."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *“我越了解人类，就越喜欢我的狗。”* |   |'
- en: '|   | --*Mark Twain* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*马克·吐温* |'
- en: 'In previous chapters, we''ve considered how to describe samples in terms of
    summary statistics and how population parameters can be inferred from them. Such
    analysis tells us something about a population in general and a sample in particular,
    but it doesn''t allow us to make very precise statements about individual elements.
    This is because so much information has been lost by reducing the data to just
    two statistics: the mean and standard deviation.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经讨论了如何通过总结统计量来描述样本，以及如何从这些统计量推断出总体参数。这种分析能告诉我们一些关于总体和样本的情况，但它并不能让我们对个别元素做出非常精确的描述。这是因为将数据简化为仅有的两个统计量：均值和标准差，导致了大量信息的丢失。
- en: We often want to go further and establish a relationship between two or more
    variables or to predict one variable given another. This takes us into the study
    of correlation and regression. Correlation concerns the strength and direction
    of the relationship between two or more variables. Regression determines the nature
    of this relationship and enables us to make predictions from it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常希望进一步分析，建立两个或更多变量之间的关系，或者在给定一个变量的情况下预测另一个变量。这就引出了相关性和回归的研究。相关性关注两个或更多变量之间关系的强度和方向。回归则确定这种关系的性质，并使我们能够根据它做出预测。
- en: Linear regression is our first machine learning algorithm. Given a sample of
    data, our model will learn a linear equation that allows it to make predictions
    about new, unseen data. To do this, we'll return to Incanter and study the relationship
    between height and weight for Olympic athletes. We'll introduce the concept of
    matrices and show how Incanter can be used to manipulate them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归是我们的第一个机器学习算法。给定一组数据样本，我们的模型将学习一个线性方程，使其能够对新的、未见过的数据进行预测。为了实现这一点，我们将回到Incanter，研究奥运运动员的身高与体重之间的关系。我们将介绍矩阵的概念，并展示如何使用Incanter对其进行操作。
- en: About the data
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于数据
- en: This chapter will make use of data on athletes in the London 2012 Olympic Games,
    courtesy of Guardian News and Media Ltd. The data was originally sourced from
    the Guardian's excellent data blog at [http://www.theguardian.com/data](http://www.theguardian.com/data).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用伦敦2012年奥运会运动员的数据，感谢《卫报新闻与传媒有限公司》的支持。数据最初来源于《卫报》的优秀数据博客，网址是 [http://www.theguardian.com/data](http://www.theguardian.com/data)。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Download the example code for this chapter from the publisher's website or from
    [https://github.com/clojuredatascience/ch3-correlation](https://github.com/clojuredatascience/ch3-correlation).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从出版商网站或 [https://github.com/clojuredatascience/ch3-correlation](https://github.com/clojuredatascience/ch3-correlation)
    下载本章的示例代码。
- en: Consult the `Readme` file in this chapter's sample code or the book's wiki at
    [http://wiki.clojuredatascience.com](http://wiki.clojuredatascience.com) for more
    information on the data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章示例代码中的`Readme`文件，或访问本书的维基 [http://wiki.clojuredatascience.com](http://wiki.clojuredatascience.com)
    了解有关数据的更多信息。
- en: Inspecting the data
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查数据
- en: The first task when confronted with a new dataset is to study it to ensure that
    we understand what it contains.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 面对一个新的数据集时，首要任务是研究它，确保我们理解它所包含的内容。
- en: 'The `all-london-2012-athletes.xlsx` file is small enough that it''s been provided
    with the sample code for this chapter. We can inspect the data with Incanter,
    as we did in [Chapter 1](ch01.xhtml "Chapter 1. Statistics"), *Statistics* using
    the `incanter.excel/read-xls` and `incanter.core/view` functions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`all-london-2012-athletes.xlsx`文件足够小，因此它与本章的示例代码一起提供。我们可以像在[第一章](ch01.xhtml
    "第一章. 统计学")中那样使用Incanter来检查数据，使用`incanter.excel/read-xls`和`incanter.core/view`函数：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you run this code (either in the REPL or on the command line with `lein
    run –e 3.1`), you should see the following output:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码（无论是在REPL中，还是通过命令行使用`lein run –e 3.1`），你应该会看到以下输出：
- en: '![Inspecting the data](img/7180OS_03_100.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![检查数据](img/7180OS_03_100.jpg)'
- en: 'We''re fortunate that the data is clearly labeled in the columns and contains
    the following information:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很幸运，数据在列中有明确的标签，包含以下信息：
- en: Name of the athlete
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运动员姓名
- en: Country for which they are competing
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们参赛的国家
- en: Age in years
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年龄（年）
- en: Height in centimeters
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身高（厘米）
- en: Weight in kilograms
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 体重（千克）
- en: Sex as the string "M" or "F"
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性别（字符串“M”或“F”）
- en: Date of birth as a string
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出生日期（字符串）
- en: Place of birth as a string (with country)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出生地（字符串，包含国家）
- en: Gold medals won
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得的金牌数量
- en: Silver medals won
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得的银牌数量
- en: Bronze medals won
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得的铜牌数量
- en: Total gold, silver, and bronze medals won
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总共获得的金、银、铜奖牌数
- en: Sport in which they competed
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们参加的运动
- en: Event as a comma-separated list
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件作为逗号分隔的列表
- en: Even though the data is clearly labeled, gaps are evident in the data for height,
    weight, and place of birth. We'll have to be careful to make sure these don't
    trip us up.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 即使数据已经清晰标注，身高、体重和出生地数据中仍然存在明显的空缺。我们必须小心，确保这些不会影响我们的分析。
- en: Visualizing the data
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据可视化
- en: 'First, we''ll consider the spread of the heights of the London 2012 athletes.
    Let''s plot our height values as a histogram to see how the data is distributed,
    remembering to filter the nil values first:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将考虑伦敦2012年奥运会运动员身高的分布。让我们将身高值绘制为直方图，看看数据是如何分布的，记得先过滤掉空值：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code generates the following histogram:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了以下的直方图：
- en: '![Visualizing the data](img/7180OS_03_110.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![数据可视化](img/7180OS_03_110.jpg)'
- en: 'The data is approximately normally distributed, as we have come to expect.
    The mean height of our athletes is around 177 cm. Let''s take a look at the distribution
    of weights of swimmers from the 2012 Olympics:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 数据大致符合正态分布，正如我们预期的那样。我们的运动员的平均身高大约是177厘米。让我们看看2012年奥运会游泳运动员的体重分布：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code generates the following histogram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了以下的直方图：
- en: '![Visualizing the data](img/7180OS_03_120.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![数据可视化](img/7180OS_03_120.jpg)'
- en: 'This data shows a pronounced skew. The tail is much longer to the right of
    the peak than to the left, so we say the skew is positive. We can quantify the
    skewness of the data with Incanter''s `incanter.stats/skewness` function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据呈现出明显的偏斜。尾部远长于峰值右侧，而左侧较短，因此我们说偏斜是正向的。我们可以使用Incanter的`incanter.stats/skewness`函数来量化数据的偏斜程度：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Fortunately, this skew can be effectively mitigated by taking the logarithm
    of the weight using Incanter''s `incanter.core/log` function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以通过使用Incanter的`incanter.core/log`函数对体重取对数，来有效减轻这种偏斜：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code results in the following histogram:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会生成以下的直方图：
- en: '![Visualizing the data](img/7180OS_03_130.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![数据可视化](img/7180OS_03_130.jpg)'
- en: This is much closer to the normal distribution. This suggests that weight is
    distributed according to a **log-normal distribution**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这与正态分布非常接近。这表明体重是按照**对数正态分布**分布的。
- en: The log-normal distribution
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对数正态分布
- en: The log-normal distribution is simply the distribution of a set of values whose
    logarithm is normally distributed. The base of the logarithm can be any positive
    number except for one. Like the normal distribution, the log-normal distribution
    is important in the description of many naturally occurring phenomena.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对数正态分布就是一个值集的分布，这些值的对数是正态分布的。对数的底数可以是任何大于零的数，除了1。与正态分布一样，对数正态分布在描述许多自然现象时非常重要。
- en: 'A logarithm represents the power to which a fixed number (the base) must be
    raised to produce a given number. By plotting the logarithms as a histogram, we''ve
    shown that these powers are approximately normally distributed. Logarithms are
    usually taken to base 10 or base *e*: the transcendental number that''s equal
    to approximately 2.718\. Incanter''s `log` function and its inverse `exp` both
    use base *e*. *log[e]* is also called the **natural logarithm** or *ln*, because
    of the properties that make it particularly suitable in calculus.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对数表示的是一个固定数（底数）必须提高到什么幂才能得到一个给定的数。通过将对数值绘制为直方图，我们展示了这些幂值大致符合正态分布。对数通常以底数10或底数*e*（一个大约等于2.718的超越数）来计算。Incanter的`log`函数及其逆函数`exp`都使用底数*e*。*log[e]*也叫做**自然对数**或*ln*，因为它在微积分中的特殊性质使其特别适用。
- en: The log-normal distribution tends to occur in processes of growth where the
    growth rate is independent of size. This is known as *Gibrat's law* and was formally
    defined in 1931 by Robert Gibrat, who noticed that it applied to the growth of
    firms. Since the growth rate is a proportion of the size, larger firms tend to
    grow more quickly than smaller firms.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对数正态分布通常出现在增长过程当中，其中增长速率与大小无关。这被称为*吉布拉特法则*，由罗伯特·吉布拉特于1931年正式定义，他注意到这一定律适用于企业的增长。由于增长速率是规模的一个比例，较大的企业往往增长得比较小的企业更快。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The normal distribution occurs in situations where many small variations have
    an additive effect, whereas the log-normal distribution occurs in situations where
    many small variations have a multiplicative effect.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布出现在许多小变化具有加法效应的情况，而对数正态分布出现在许多小变化具有乘法效应的情况。
- en: Gibrat's law has since been found to be applicable to lots of situations, including
    the sizes of cities and, according to Wolfram MathWorld, the numbers of words
    in sentences by George Bernard Shaw.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 吉布拉特法则（Gibrat's law）已被发现适用于许多情况，包括城市的规模，以及根据Wolfram MathWorld，乔治·伯纳德·肖（George
    Bernard Shaw）句子中单词的数量。
- en: For the rest of this chapter, we'll be using the natural logarithm of the weight
    data so that our data is approximately normally distributed. We'll choose a population
    of athletes with roughly similar body types, say Olympic swimmers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将使用体重数据的自然对数，以便使我们的数据近似正态分布。我们将选择一群大致相似体型的运动员，比如奥运游泳运动员。
- en: Visualizing correlation
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化相关性
- en: 'One of the quickest and simplest ways of determining if two variables are correlated
    is to view them on a scatter plot. We''ll filter our data to select only swimmers
    and then plot the heights against the weights:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 确定两个变量是否相关的最快和最简单的方法之一是将它们绘制在散点图上。我们将筛选数据，仅选择游泳运动员，然后将身高与体重进行绘制：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code yields the following plot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了以下图表：
- en: '![Visualizing correlation](img/7180OS_03_140.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![可视化相关性](img/7180OS_03_140.jpg)'
- en: 'The output clearly shows a relationship between the two variables. The chart
    has the characteristically skewed elliptical shape of two correlated, normally
    distributed variables centered on the means. The following diagram compares the
    scatter plot against probability distributions of the height and log weight:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示了两个变量之间的关系。该图表具有两个相关的、正态分布的变量围绕均值居中的典型偏斜椭圆形状。下图将散点图与身高和对数体重的概率分布进行比较：
- en: '![Visualizing correlation](img/7180OS_03_150.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![可视化相关性](img/7180OS_03_150.jpg)'
- en: Points close to the tail of one distribution also tend to be close to the same
    tail of the other distribution, and vice versa. Thus, there is a relationship
    between the two distributions that we'll show how to quantify over the next several
    sections. If we look closely at the previous scatter plot though, we'll see that
    the points are packed into columns and rows due to the measurements being rounded
    (to centimeters and kilograms for height and weight, respectively). Where this
    occurs, it is sometimes preferable to *jitter* the data to make the strength of
    the relationship clearer. Without jittering, it could be that what appears to
    be one point is actually many points that share exactly the same pair of values.
    Introducing some random noise makes this possibility less likely.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 靠近一个分布尾部的点通常也会靠近另一个分布的相同尾部，反之亦然。因此，两个分布之间存在一种关系，我们将在接下来的几节中展示如何量化这种关系。不过，如果仔细观察之前的散点图，你会发现这些点因测量值四舍五入（身高和体重分别以厘米和千克为单位）而集中排列成列和行。在这种情况下，有时最好对数据进行*抖动*，以使关系的强度更加明显。如果不进行抖动，可能看似是一个点的地方实际上是许多个共享相同数值对的点。引入一些随机噪声可以减少这种可能性。
- en: Jittering
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抖动
- en: Since each value is rounded to the nearest centimeter, a value captured as 180
    could actually have been anywhere between 179.5 cm and 180.5 cm. To unwind this
    effect, we can add random noise in the -0.5 to 0.5 range to each of the height
    data points.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个值都四舍五入到最接近的厘米，捕获的值为180时，实际上可能在179.5厘米到180.5厘米之间。为了消除这个效应，我们可以在-0.5到0.5的范围内为每个身高数据点添加随机噪声。
- en: 'The weight data point was captured to the nearest kilogram, so a value of 80
    could actually have been anywhere between 79.5 kg and 80.5 kg. We can add random
    noise in the same range to unwind this effect (though clearly, this must be done
    before we take the logarithm):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 体重数据点是按最接近的千克捕获的，因此80这个值实际上可能在79.5千克到80.5千克之间。我们可以在相同范围内添加随机噪声来消除这个效应（尽管显然，这必须在我们取对数之前完成）：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The jittered graph appears as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 抖动后的图表如下所示：
- en: '![Jittering](img/7180OS_03_160.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![抖动](img/7180OS_03_160.jpg)'
- en: As with introducing transparency to the scatter plot in [Chapter 1](ch01.xhtml
    "Chapter 1. Statistics"), *Statistics*, jittering is a mechanism to ensure that
    we don't let incidental factors—such as data volume or rounding artifacts—obscure
    our ability to see patterns in the data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[第1章](ch01.xhtml "第1章. 统计学") *统计学* 中对散点图引入透明度一样，抖动也是一种机制，确保我们不让偶然因素——例如数据量或四舍五入的伪影——掩盖我们发现数据模式的能力。
- en: Covariance
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协方差
- en: One way of quantifying the strength of the relationship between two variables
    is their covariance. This measures the tendency of two variables to change together.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 量化两个变量之间关系强度的一种方法是它们的协方差。协方差衡量的是两个变量一起变化的趋势。
- en: 'If we have two series, *X* and *Y*, their deviations from the mean are:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个序列，*X*和*Y*，它们的偏差是：
- en: '![Covariance](img/7180OS_03_01.jpg)![Covariance](img/7180OS_03_02.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![协方差](img/7180OS_03_01.jpg)![协方差](img/7180OS_03_02.jpg)'
- en: 'Where *x[i]* is the value of *X* at index *i*, *y[i]* is the value of *Y* at
    index *i*, ![Covariance](img/7180OS_03_03.jpg) is the mean of *X*, and ![Covariance](img/7180OS_03_04.jpg)
    is the mean of *Y*. If *X* and *Y* tend to vary together, their deviations from
    the mean tend to have the same sign: negative if they''re less than the mean,
    positive if they''re greater. If we multiply them together, the product is positive
    when they have the same sign and negative when they have different signs. Adding
    up the products gives a measure of the tendency of the two variables to deviate
    from the mean in the same direction for each given sample.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*x[i]*是索引*i*处*X*的值，*y[i]*是索引*i*处*Y*的值，![协方差](img/7180OS_03_03.jpg)是*X*的均值，![协方差](img/7180OS_03_04.jpg)是*Y*的均值。如果*X*和*Y*倾向于一起变化，它们的偏差通常会有相同的符号：当它们低于均值时为负，超过均值时为正。如果我们将它们相乘，当它们具有相同符号时，积为正，当它们具有不同符号时，积为负。将这些积加起来，就得到了一个衡量两个变量在每个给定样本中倾向于朝相同方向偏离均值的程度的指标。
- en: 'Covariance is defined as the mean of these products:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差被定义为这些积的均值：
- en: '![Covariance](img/7180OS_03_05.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![协方差](img/7180OS_03_05.jpg)'
- en: 'Covariance can be calculated in Clojure using the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差可以使用以下代码在Clojure中计算：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Alternatively, we could use the `incanter.stats/covariance` function. The covariance
    of height and log-weight for our Olympic swimmers is `1.354`, but this is a hard
    number to interpret. The units are the product of the units of the inputs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`incanter.stats/covariance`函数。我们的奥运游泳运动员的身高和对数体重的协方差为`1.354`，但这是一个难以解释的数字。单位是输入单位的乘积。
- en: Because of this, covariance is rarely reported as a summary statistic on its
    own. A solution to make the number more comprehensible is to divide the deviations
    by the product of the standard deviations. This transforms the units to standard
    scores and constrains the output to a number between `-1` and `+1`. The result
    is called **Pearson's correlation**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，协方差通常不会单独作为总结性统计量报告。为了使这个数字更易于理解，可以将偏差除以标准差的乘积。这样可以将单位转换为标准分数，并将输出限制在`-1`和`+1`之间。结果被称为**皮尔逊相关性**。
- en: Pearson's correlation
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 皮尔逊相关性
- en: 'Pearson''s correlation is often given the variable name *r* and is calculated
    in the following way, where *dx[i]* and *dy[i]* are calculated as before:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 皮尔逊相关性通常用变量名*r*表示，并通过以下方式计算，其中*dx[i]*和*dy[i]*的计算方法与之前相同：
- en: '![Pearson''s correlation](img/7180OS_03_06.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![皮尔逊相关性](img/7180OS_03_06.jpg)'
- en: 'Since the standard deviations are constant values for the variables *X* and
    *Y* the equation can be simplified to the following, where *σ[x]* and *σ[y]* are
    the standard deviations of *X* and *Y* respectively:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标准差是变量*X*和*Y*的常数值，方程可以简化为以下形式，其中*σ[x]*和*σ[y]*分别是*X*和*Y*的标准差：
- en: '![Pearson''s correlation](img/7180OS_03_07.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![皮尔逊相关性](img/7180OS_03_07.jpg)'
- en: This is sometimes referred to as Pearson's product-moment correlation coefficient
    or simply just the *correlation coefficient* and is usually denoted by the letter
    *r*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时被称为皮尔逊的乘积矩相关系数，或简称为*相关系数*，通常用字母*r*表示。
- en: 'We have previously written functions to calculate the standard deviation. Combining
    with our function to calculate covariance yields the following implementation
    of Pearson''s correlation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经写过计算标准差的函数。结合我们用来计算协方差的函数，得出了以下皮尔逊相关性的实现：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Alternately, we can make use of the `incanter.stats/correlation` function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以使用`incanter.stats/correlation`函数。
- en: Because standard scores are dimensionless, so is *r*. If *r* is -1.0 or 1.0,
    the variables are perfectly negatively or perfectly positively correlated.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标准分数是无单位的，因此*r*也是无单位的。如果*r*为-1.0或1.0，则表示变量之间完全负相关或完全正相关。
- en: 'If *r* is zero though, it doesn''t necessarily follow that the variables are
    uncorrelated. Pearson''s correlation only measures linear relationships. There
    could still be some nonlinear relationship between variables that isn''t captured
    by *r*, as demonstrated by the following plots:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果*r*为零，并不意味着变量之间没有相关性。皮尔逊相关性只衡量线性关系。变量之间可能仍然存在一些非线性关系，而这些关系并未被*r*捕捉到，正如以下图示所示：
- en: '![Pearson''s correlation](img/7180OS_03_170.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![皮尔逊相关性](img/7180OS_03_170.jpg)'
- en: Note that the correlation of the central example is undefined because the standard
    deviation of *y* is zero. Since our equation for *r* would involve dividing the
    covariance by zero, the result is meaningless. In this case, there can't be any
    correlation between the variables; the value for *y* is always the mean. A simple
    inspection of standard deviations would confirm this.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于*y*的标准差为零，中心示例的相关性是未定义的。由于我们的*r*方程会涉及将协方差除以零，因此结果是没有意义的。在这种情况下，变量之间不能存在任何相关性；*y*的值始终是均值。通过简单检查标准差可以确认这一点。
- en: 'The correlation coefficient can be calculated for the height and log-weight
    data for our swimmers:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为我们游泳选手的身高和对数体重数据计算相关系数：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This yields the answer `0.867`, which quantifies the strong, positive correlation
    we already observed on the scatter plot.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这得出了答案`0.867`，它量化了我们在散点图中已经观察到的强正相关。
- en: Sample r and population rho
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本r与总体rho
- en: 'Like the mean or standard deviation, the correlation coefficient is a statistic.
    It describes a sample; in this case, a sample of paired values: height and weight.
    While our known sample correlation coefficient is given the letter *r*, the unknown
    population correlation coefficient is given the Greek letter rho: ![Sample r and
    population rho](img/7180OS_03_08.jpg).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像均值或标准差一样，相关系数是一种统计量。它描述了一个样本；在这种情况下，是一组配对值：身高和体重。虽然我们已知的样本相关系数用字母*r*表示，但未知的总体相关系数用希腊字母rho表示：![样本r与总体rho](img/7180OS_03_08.jpg)。
- en: As we discovered in the last chapter, we should not assume that what we measured
    in our sample applies to the population as a whole. In this case, our population
    might be all swimmers from all recent Olympic Games. It would not be appropriate
    to generalize, for example, to other Olympic sports such as weightlifting or to
    noncompetitive swimmers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中发现的，我们不应假设在样本中测得的内容适用于整个总体。在这种情况下，我们的总体可能是所有最近奥运会的游泳选手。例如，不应将结论推广到其他奥林匹克项目，如举重，或者非竞技游泳选手。
- en: 'Even within an appropriate population—such as swimmers from the recent Olympic
    Games—our sample is just one of many potential samples of different correlation
    coefficients. How far we can trust our *r* as an estimate of ![Sample r and population
    rho](img/7180OS_03_08.jpg) will depend on two factors:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在一个适当的群体中——例如最近奥运会的游泳选手——我们的样本只是众多潜在样本中的一个，具有不同的相关系数。我们能多大程度上信任我们的*r*作为![样本r与总体rho](img/7180OS_03_08.jpg)的估计，将取决于两个因素：
- en: The size of the sample
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样本的大小
- en: The magnitude of *r*
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r*的大小'
- en: Clearly, for a fair sample, the larger it is the more we can trust it to be
    a representative of the population as a whole. It may not be intuitively obvious
    to you that the magnitude of *r* also affects how confident we can be of it representing
    ![Sample r and population rho](img/7180OS_03_08.jpg). The reason is that large
    coefficients are less likely to have arisen by chance or by random sampling error.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，对于一个公平的样本，它越大，我们就越能信任它代表整个总体。也许你不会直观地意识到*r*的大小也会影响我们有多大信心它代表![样本r与总体rho](img/7180OS_03_08.jpg)。原因是，大的相关系数较不可能是偶然或随机抽样误差造成的。
- en: Hypothesis testing
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设检验
- en: In the previous chapter, we introduced hypothesis testing as a means to quantify
    the probability that a given hypothesis (such as that the two samples were from
    a single population) is true. We will use the same process to quantify the probability
    that a correlation exists in the wider population based on our sample.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了假设检验作为量化给定假设（例如两个样本来自同一人群）为真的概率的方法。我们将使用相同的过程来量化基于我们样本的相关性在更广泛人群中存在的概率。
- en: 'First, we must formulate two hypotheses, a null hypothesis and an alternate
    hypothesis:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须提出两个假设：一个零假设和一个备择假设：
- en: '![Hypothesis testing](img/7180OS_03_09.jpg)![Hypothesis testing](img/7180OS_03_10.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![假设检验](img/7180OS_03_09.jpg)![假设检验](img/7180OS_03_10.jpg)'
- en: '*H[0]* is the hypothesis that the population correlation is zero. In other
    words, our conservative view is that the measured correlation is purely due to
    chance sampling error.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*H[0]*是假设人群相关性为零。换句话说，我们的保守观点是测得的相关性纯粹是由于随机抽样误差。'
- en: '*H[1]* is the alternative possibility that the population correlation is not
    zero. Notice that we don''t specify the direction of the correlation, only that
    there is one. This means we are performing a two-tailed test.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*H[1]*是备择假设，即总体相关性不为零。请注意，我们并没有指定相关性的方向，只是说明存在相关性。这意味着我们正在进行双尾检验。'
- en: 'The standard error of the sample *r* is given by:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 样本*r*的标准误差为：
- en: '![Hypothesis testing](img/7180OS_03_11.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![假设检验](img/7180OS_03_11.jpg)'
- en: This formula is only accurate when ![Hypothesis testing](img/7180OS_03_08.jpg)
    is close to zero (recall that the magnitude of *r* influences our confidence),
    but fortunately, this is exactly what we're assuming under our null hypothesis.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式只有在![假设检验](img/7180OS_03_08.jpg)接近零时才准确（记住*r*的大小会影响我们的置信度），但幸运的是，这正是我们在原假设下假设的情况。
- en: 'Once again, we can make use of the *t*-distribution and calculate our *t*-statistic:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次可以利用*t*-分布并计算我们的*t*-统计量：
- en: '![Hypothesis testing](img/7180OS_03_12.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![假设检验](img/7180OS_03_12.jpg)'
- en: 'The term *df* is the degree of freedom of our data. For correlation testing,
    the degree of freedom is *n - 2* where *n* is the size of the sample. Putting
    this value into the formula, we obtain:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*df*是我们数据的自由度。对于相关性检验，自由度是*n - 2*，其中*n*是样本的大小。将该值代入公式，我们得到：'
- en: '![Hypothesis testing](img/7180OS_03_13.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![假设检验](img/7180OS_03_13.jpg)'
- en: 'This gives us a *t*-value of `102.21`. To convert this into a *p* value, we
    need to refer to the *t*-distribution. Incanter provides the **cumulative distribution
    function** (**CDF**) for the *t*-distribution with the `incanter.stats/cdf-t`
    function. The value of the CDF corresponds to the *p*-value for a one-tailed test.
    We multiply the value by two because we''re performing a two-tailed test:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个*t*-值为`102.21`。要将其转换为*p*值，我们需要参考*t*-分布。Incanter提供了*t*-分布的**累积分布函数**（**CDF**），可以通过`incanter.stats/cdf-t`函数获得。CDF的值对应于单尾检验的*p*-值。由于我们进行的是双尾检验，因此我们将值乘以二：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The *p*-value is so small as to be essentially zero, meaning that the chances
    of the null hypothesis being true is essentially non-existent. We are forced to
    accept the alternate hypothesis.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*-值非常小，几乎为零，意味着原假设为真的可能性几乎不存在。我们必须接受备择假设。'
- en: Confidence intervals
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 置信区间
- en: Having established that there certainly is a correlation in the wider population,
    we might want to quantify the range of values we expect ![Confidence intervals](img/7180OS_03_08.jpg)
    to lie within by calculating a confidence interval. As in the previous chapter
    with the mean, the confidence interval of *r* expresses the probability (expressed
    as a percentage) that the population parameter ![Confidence intervals](img/7180OS_03_08.jpg)
    lies between two specific values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了在更广泛的人群中确实存在相关性后，我们可能希望通过计算置信区间来量化我们期望![置信区间](img/7180OS_03_08.jpg)落入的值范围。就像前一章中均值的情况一样，*r*的置信区间表达了*r*在两特定值之间落入的概率（以百分比表示），即该总体参数![置信区间](img/7180OS_03_08.jpg)落入这两个值之间的概率。
- en: However, a complication arises when trying to calculate the standard error of
    the correlation coefficient that didn't exist for the mean. Because the absolute
    value of *r* cannot exceed **1**, the distribution of possible samples of *r*
    is skewed as *r* approaches the limit of its range.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当试图计算相关系数的标准误差时，问题出现了，这个标准误差在均值的情况下并不存在。因为*r*的绝对值不能超过**1**，所以当*r*接近其范围的极限时，*r*的可能样本分布会发生偏斜。
- en: '![Confidence intervals](img/7180OS_03_180.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![置信区间](img/7180OS_03_180.jpg)'
- en: The previous graph shows the negatively skewed distribution of *r* samples for
    a ![Confidence intervals](img/7180OS_03_08.jpg) of 0.6.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图表展示了对于![置信区间](img/7180OS_03_08.jpg)为0.6的*r*样本的负偏态分布。
- en: Fortunately, a transformation called the **Fisher z-transformation** will stabilize
    the variance of *r* throughout its range. This is analogous to how our weight
    data became normally distributed when we took the logarithm.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一种名为**费舍尔z变换**的转换方法可以稳定*r*在其范围内的方差。这类似于我们在取对数后，体重数据变得呈正态分布的情况。
- en: 'The equation for the *z*-transformation is:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*z*-变换的公式为：'
- en: '![Confidence intervals](img/7180OS_03_14.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![置信区间](img/7180OS_03_14.jpg)'
- en: 'The standard error of *z* is:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*z*的标准误差为：'
- en: '![Confidence intervals](img/7180OS_03_15.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![置信区间](img/7180OS_03_15.jpg)'
- en: Thus, the process to calculate confidence intervals is to convert *r* to *z*
    using the *z*-transformation, compute a confidence interval in terms of *SE[z]*,
    and then convert the confidence interval back to *r*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，计算置信区间的过程是将*r*通过*z*-变换转换为*z*，计算以*SE[z]*为单位的置信区间，然后再将置信区间转换回*r*。
- en: To calculate a confidence interval in terms of *SE[z]*, we can take the number
    of standard deviations away from the mean that gives us the desired confidence.
    1.96 is a common number to use, because it is the number of standard deviations
    away from the mean that contains 95 percent of the area. In other words, 1.96
    standard errors from the mean of the sample *r* contains the true population correlation
    *ρ* with 95 percent certainty.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算以*SE[z]*为单位的置信区间，我们可以计算从均值开始，给出所需置信度的标准差数。1.96是常用的数值，因为它是离均值1.96个标准差的距离，包含了95%的区域。换句话说，离样本*r*均值1.96个标准误差的范围包含了真实的总体相关性*ρ*，其置信度为95%。
- en: '![Confidence intervals](img/7180OS_03_190.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![置信区间](img/7180OS_03_190.jpg)'
- en: We can verify this using Incanter's `incanter.stats/quantile-normal` function.
    This will return the standard score associated with a given cumulative probability,
    assuming a one-tailed test.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Incanter的`incanter.stats/quantile-normal`函数来验证这一点。该函数将返回与给定累积概率相关的标准分数，假设是单尾检验。
- en: 'However, as shown in the previous diagram, we''d like to subtract the same
    amount— 2.5 percent—from each tail, so that the 95 percent confidence interval
    is centered on zero. A simple translation is to halve the difference to 100 percent
    while performing a two-tailed test. So, a desired confidence of 95 percent means
    we look up the critical value of 97.5 percent:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如前面的图示所示，我们希望从每一侧减去相同的值——2.5%——这样95%的置信区间就会以零为中心。一个简单的变换是，在执行双尾检验时，将差值的一半平移到100%的范围内。因此，95%的置信度意味着我们查找97.5%临界值：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, our 95 percent confidence interval in *z*-space for ![Confidence intervals](img/7180OS_03_08.jpg)
    is given by:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在*z*-空间中，95%置信区间对于![置信区间](img/7180OS_03_08.jpg)为：
- en: '![Confidence intervals](img/7180OS_03_16.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![置信区间](img/7180OS_03_16.jpg)'
- en: 'Substituting our formulae for *z[r]* and *SE[z]* gives:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的*z[r]*和*SE[z]*公式代入后得到：
- en: '![Confidence intervals](img/7180OS_03_17.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![置信区间](img/7180OS_03_17.jpg)'
- en: 'For `r = 0.867` and `n = 859`, this gives a lower and upper bound of `1.137`
    and `1.722`, respectively. To convert these from *z*-scores back to *r*-values,
    we use the following equation, the inverse of the *z*-transformation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`r = 0.867`和`n = 859`，这给出了下限和上限分别为`1.137`和`1.722`。要将这些从*z*-分数转换回*r*-值，我们使用以下公式，它是*z*-变换的逆运算：
- en: '![Confidence intervals](img/7180OS_03_18.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![置信区间](img/7180OS_03_18.jpg)'
- en: 'The transformations and confidence interval can be calculated with the following
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码计算变换和置信区间：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This gives a 95 percent confidence interval for ![Confidence intervals](img/7180OS_03_08.jpg)
    being between `0.850` and `0.883`. We can be very confident that there is a strong
    positive correlation between the height and weight in the wider population of
    Olympic-class swimmers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了95%置信度区间，对于![置信区间](img/7180OS_03_08.jpg)，区间为`0.850`到`0.883`。我们可以非常有信心地认为，奥林匹克级游泳运动员身高与体重之间存在较强的正相关关系。
- en: Regression
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归
- en: While it may be useful to know that two variables are correlated, we can't use
    this information alone to predict the weights of Olympic swimmers given their
    height or vice versa. In establishing a correlation, we have measured the strength
    and sign of a relationship, but not the slope. Knowing the expected rate of change
    for one variable given a unit change in the other is required in order to make
    predictions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管知道两个变量之间存在相关性可能是有用的，但仅凭此信息我们无法预测奥林匹克游泳选手的体重是否由身高决定，反之亦然。在建立相关性时，我们测量的是关系的强度和符号，而不是斜率。要进行预测，必须知道给定单位变化下，一个变量的预期变化率。
- en: What we'd like to determine is an equation that relates the specific value of
    one variable, called the **independent** **variable**, to the expected value of
    the other, the **dependent** **variable**. For example, if our linear equation
    predicts the weight given the height, then the height is our independent variable
    and the weight is our dependent variable.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望确定一个方程，关联一个变量的具体值，称为**自变量**，与另一个变量的期望值，称为**因变量**。例如，如果我们的线性方程根据身高预测体重，那么身高就是自变量，体重则是因变量。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The lines described by these equations are called **regression lines**. The
    term was introduced by the 19th century British polymath Sir Francis Galton. He
    and his student Karl Pearson (who defined the correlation coefficient) developed
    a variety of methods to study linear relationships in the 19th century and these
    collectively became known as regression techniques.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程式描述的直线被称为**回归线**。这一术语由19世纪英国博学家弗朗西斯·高尔顿爵士提出。他和他的学生卡尔·皮尔逊（定义了相关系数）在19世纪发展了多种方法来研究线性关系，这些方法统称为回归技术。
- en: Remember that correlation does not imply causation and there is no implied causation
    by the terms dependent and independent—they're just the names for mathematical
    inputs and outputs. A classic example is the highly positive correlation between
    the number of fire engines sent to a fire and the damage done by the fire. Clearly,
    sending fire engines to a fire does not itself cause damage. No one would recommend
    reducing the number of engines sent to a fire as a way of reducing damage. In
    situations like these, we should look for an additional variable, which is causally
    connected with the other variables, and explains the correlation between them.
    In the previous example, this might be the *size of fire*. Such hidden causes
    are called **confounding** **variables**, because they confound our ability to
    determine the relationship between their dependent variables.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，相关性并不意味着因果关系，且依赖与独立这两个术语并不暗示因果关系——它们只是数学输入和输出的名称。一个经典的例子是消防车派遣数量与火灾造成损失之间的高度正相关。显然，派遣消防车本身并不会造成损失。没有人会建议减少派遣到火灾现场的消防车数量来减少损失。在这种情况下，我们应寻找一个与其他变量因果相关的额外变量，来解释它们之间的相关性。在前一个例子中，这个变量可能是*火灾的规模*。这种隐藏的原因被称为**混杂**
    **变量**，因为它们混淆了我们确定依赖变量之间关系的能力。
- en: Linear equations
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性方程式
- en: 'Two variables, which we can signify as *x* and *y*, may be related to each
    other exactly or inexactly. The simplest relationship between an independent variable
    labeled *x* and a dependent variable labeled *y* is a straight line expressed
    in the formula:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 两个变量，记作 *x* 和 *y*，可能是精确或不精确地相互关联的。最简单的关系是一个独立变量 *x* 和一个依赖变量 *y* 之间的直线关系，公式如下：
- en: '![Linear equations](img/7180OS_03_19.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![线性方程式](img/7180OS_03_19.jpg)'
- en: 'Here, the values of the parameters *a* and *b* determine respectively the precise
    height and steepness of the line. The parameter *a* is referred to as the intercept
    or constant and *b* as the gradient or slope. For example, in the mapping between
    Celsius and Fahrenheit temperature scales, *a = 32* and *b = 1.8*. Substituting
    these values of *a* and *b* into our equation yields:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，参数 *a* 和 *b* 的值分别决定了直线的精确高度和陡峭度。参数 *a* 被称为截距或常数，*b* 被称为梯度或斜率。例如，在摄氏度与华氏度之间的映射中，*a
    = 32* 且 *b = 1.8*。将这些 *a* 和 *b* 的值代入我们的方程式中，得到：
- en: '![Linear equations](img/7180OS_03_20.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![线性方程式](img/7180OS_03_20.jpg)'
- en: 'To calculate 10 degrees Celsius in Fahrenheit, we substitute 10 for *x*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算10摄氏度对应的华氏度，我们将10代入 *x*：
- en: '![Linear equations](img/7180OS_03_21.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![线性方程式](img/7180OS_03_21.jpg)'
- en: 'Thus, our equation tells us that 10 degrees Celsius is 50 degrees Fahrenheit,
    which is indeed the case. Using Incanter, we can easily write a function that
    maps Celsius to Fahrenheit and plot it as a graph using `incanter.charts/function-plot`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的方程式告诉我们，10摄氏度等于50华氏度，这确实是正确的。使用Incanter，我们可以轻松编写一个将摄氏度转换为华氏度的函数，并使用 `incanter.charts/function-plot`
    绘制其图形：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code yields the following line graph:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了以下线性图：
- en: '![Linear equations](img/7180OS_03_200.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![线性方程式](img/7180OS_03_200.jpg)'
- en: Notice how the red line crosses zero on the Celsius scale at 32 on the Fahrenheit
    scale. The intercept *a* is the value of *y*, where *x* is zero.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，红色线在摄氏度刻度上的零点与华氏度刻度上的32度交叉。截距 *a* 是 *x* 为零时 *y* 的值。
- en: The slope of the line is determined by *b*; it is close to 2 for this equation.
    See how the range of the Fahrenheit scale is almost double the range of the Celsius
    scale. In other words, the line sweeps almost twice as fast vertically as it does
    horizontally.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 直线的斜率由 *b* 决定；在这个方程式中，斜率接近2。可以看到，华氏度的范围几乎是摄氏度范围的两倍。换句话说，这条直线在竖直方向的变化几乎是水平方向变化的两倍。
- en: Residuals
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 残差
- en: 'Unfortunately few relationships we will study are as tidy as the mapping between
    Celsius and Fahrenheit. The straight-line equation rarely allows us to specify
    *y* exactly in terms of *x*. There will ordinarily be an error, thus:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们研究的大多数关系并不像摄氏温度与华氏温度之间的映射那样简洁。直线方程很少允许我们精确地用 *x* 来表示 *y*。通常会存在误差，因此：
- en: '![Residuals](img/7180OS_03_22.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![残差](img/7180OS_03_22.jpg)'
- en: 'Here, *ε* is an error term standing for the difference between the value calculated
    by the parameters *a* and *b* for a given value of *x* and the actual value of
    *y*. If our predicted value of *y* is ![Residuals](img/7180OS_03_23.jpg) (pronounced
    "y-hat"), then the error is the difference between the two:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*ε* 是误差项，表示给定 *x* 值时，由参数 *a* 和 *b* 计算的值与实际 *y* 值之间的差异。如果我们预测的 *y* 值是 ![残差](img/7180OS_03_23.jpg)（读作“y-hat”），那么误差就是两者之间的差异：
- en: '![Residuals](img/7180OS_03_24.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![残差](img/7180OS_03_24.jpg)'
- en: This error is referred to as the residual. The residual might be due to random
    factors like measurement error or non-random factors that are unknown. For example,
    if we are trying to predict weight as a function of height, unknown factors might
    include diet, level of fitness, and body type (or simply the effect of rounding
    to the nearest kilogram).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个误差被称为残差。残差可能是由于随机因素（如测量误差）或非随机因素（如未知的因素）造成的。例如，如果我们试图将体重作为身高的函数进行预测，未知的因素可能包括饮食、健康水平和体型（或简单地四舍五入到最近的千克）。
- en: If we select parameters for *a* and *b* that are not ideal, then the residual
    for each *x* will be larger than it needs to be. Therefore, it follows that the
    parameters we'd like to find are the ones that minimize the residuals across all
    values of *x* and *y*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择了不理想的 *a* 和 *b* 参数，那么每个 *x* 的残差将比必要的要大。因此，可以得出结论，我们希望找到的参数是那些在所有 *x* 和
    *y* 值中最小化残差的参数。
- en: Ordinary least squares
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 普通最小二乘法
- en: In order to optimize the parameters of our linear model, we'd like to devise
    a cost function, also called a **loss function**, that quantifies how closely
    our predictions fit the data. We cannot simply sum up the residuals, positive
    and negative, because even large residuals will cancel each other out if their
    signs are in opposite directions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化我们线性模型的参数，我们希望设计一个成本函数，也称为**损失函数**，来量化我们的预测与数据的契合程度。我们不能简单地将正负残差相加，因为即使是大的残差，如果它们的符号方向相反，也会互相抵消。
- en: We could square the values before calculating the sum so that positive and negative
    residuals both count towards the cost. This also has the effect of penalizing
    large errors more than smaller errors, but not so much that the largest residual
    always dominates.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在计算总和之前对值进行平方，以便正负残差都能计入成本。这还具有对大误差进行更大惩罚的效果，但并不会导致最大的残差总是主导。
- en: 'Expressed as an optimization problem, we seek to identify the coefficients
    that minimize the sum of the residual squares. This is called **Ordinary Least
    Squares** (**OLS**), and the formula to calculate the slope of the regression
    line using OLS is:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个优化问题，我们寻求识别能够最小化残差平方和的系数。这叫做**普通最小二乘法**（**OLS**），使用 OLS 计算回归线斜率的公式是：
- en: '![Ordinary least squares](img/7180OS_03_25.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![普通最小二乘法](img/7180OS_03_25.jpg)'
- en: 'Although this looks more complicated than the previous equations, it''s really
    just the sum of squared residuals divided by the sum of squared differences from
    the mean. This shares a number of terms from the equations we have already looked
    at and can be simplified to:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这看起来比之前的方程复杂，但它实际上只是残差平方和除以与均值的平方差之和。它与我们之前看到的方程式有许多相同的项，并且可以简化为：
- en: '![Ordinary least squares](img/7180OS_03_26.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![普通最小二乘法](img/7180OS_03_26.jpg)'
- en: 'The intercept is the term that allows a line of this slope to pass through
    the mean of both *X* and *Y*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 截距是允许具有这种斜率的直线通过 *X* 和 *Y* 的均值的项：
- en: '![Ordinary least squares](img/7180OS_03_27.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![普通最小二乘法](img/7180OS_03_27.jpg)'
- en: These values of *a* and *b* are the coefficients of our least squares estimates.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 *a* 和 *b* 的值是我们最小二乘估计的系数。
- en: Slope and intercept
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 斜率和截距
- en: 'We''ve already written the `covariance`, `variance`, and `mean` functions we
    need to calculate the slope and intercept for the swimming height and weight data.
    Therefore, the slope and intercept calculations are trivial:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了计算游泳身高和体重数据的斜率和截距所需的 `协方差`、`方差` 和 `均值` 函数。因此，斜率和截距的计算是简单的：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The output gives a slope of approximately `0.0143` and an intercept of approximately
    `1.6910`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 输出给出的斜率大约是`0.0143`，截距大约是`1.6910`。
- en: Interpretation
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释
- en: The **intercept value** is the value of the dependent variable (log weight)
    when the independent variable (`height`) is zero. To find out what this value
    equates to in kilograms, we can use the `incanter.core/exp` function, which performs
    the inverse of the `incanter.core/log` function. Our model seems to suggest that
    the best guess for the weight of an Olympic swimmer of zero height is 5.42 kg.
    This is meaningless, and it is unwise to extrapolate beyond the bounds of your
    training data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**截距值**是当自变量（`height`）为零时因变量（log体重）的值。为了知道这个值对应的公斤数，我们可以使用`incanter.core/exp`函数，它是`incanter.core/log`函数的逆运算。我们的模型似乎表明，零身高的奥运游泳运动员的体重最佳估计值为5.42公斤。这没有实际意义，因此在没有数据支持的情况下，外推训练数据之外的预测是不明智的。'
- en: The slope value shows how much *y* changes for each unit change in *x*. Our
    model suggests that each additional centimeter of height adds on an average of
    1.014 kg to the weight of our Olympic swimmers. Since our model is based on all
    Olympic swimmers, this is the average effect of a unit increase in height without
    taking into account any other factor, such as age, gender, or body type.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 斜率值显示了每单位*x*变化时，*y*的变化量。我们的模型表明，每增加一厘米的身高，奥运游泳运动员的体重大约增加1.014公斤。由于我们的模型基于所有奥运游泳运动员，这表示身高增加一个单位的平均效应，而没有考虑其他因素，如年龄、性别或体型。
- en: Visualization
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化
- en: We can visualize the output of our linear equation with `incanter.charts/function-plot`
    and a simple function of *x* that calculates ![Visualization](img/7180OS_03_23.jpg)
    based on the coefficients *a* and *b*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`incanter.charts/function-plot`和一个简单的*x*函数来可视化我们的线性方程输出，该函数根据系数*a*和*b*计算
    ![可视化](img/7180OS_03_23.jpg)。
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `regression-line` function returns a function of *x* that calculates ![Visualization](img/7180OS_03_28.jpg).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`regression-line`函数返回一个关于*x*的函数，用于计算 ![可视化](img/7180OS_03_28.jpg)。'
- en: '![Visualization](img/7180OS_03_210.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![可视化](img/7180OS_03_210.jpg)'
- en: We can also use the `regression-line` function to calculate each residual, showing
    how far our estimate ![Visualization](img/7180OS_03_23.jpg) deviates from each
    measured *y*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`regression-line`函数来计算每个残差，展示我们估算的 ![可视化](img/7180OS_03_23.jpg)与每个测量的*y*之间的偏差。
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A **residual plot** is a graph that shows the residuals on the *y*-axis and
    the independent variable on the *x*-axis. If the points in the residual plot are
    randomly dispersed around the horizontal axis, a linear model is a good fit for
    the data:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**残差图**是一个图表，展示了*y*轴上的残差和*x*轴上的自变量。如果残差图中的点在水平轴周围随机分布，则说明线性模型对数据拟合良好：'
- en: '![Visualization](img/7180OS_03_220.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![可视化](img/7180OS_03_220.jpg)'
- en: With the exception of some outliers on the left side of the chart, the residual
    plot appears to indicate that a linear model is a good fit for the data. Plotting
    the residuals is important to verify that the linear model is appropriate. There
    are certain assumptions that a linear model makes about your data that will, if
    violated, invalidate models you build.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了图表左侧的一些离群点外，残差图似乎表明线性模型对数据拟合良好。绘制残差图对于验证线性模型是否合适非常重要。线性模型对数据有某些假设，如果这些假设被违反，所构建的模型将失效。
- en: Assumptions
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 假设
- en: Obviously, the primary assumption of linear regression is that there is a linear
    relationship between the dependent and independent variable. In addition, the
    residuals must not be correlated with each other or with the independent variable.
    In other words, we expect the errors to have a zero mean and constant variance
    versus the dependent and independent variable. A residual plot allows us to quickly
    determine if this is the case.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，线性回归的主要假设是因变量和自变量之间存在线性关系。此外，残差不能相互相关，也不能与自变量相关。换句话说，我们期望误差相对于因变量和自变量的均值为零且方差恒定。残差图可以帮助我们快速判断是否符合这一假设。
- en: The left side of our residual plot has greater residuals than the right side.
    This corresponds to greater variance of weight amongst shorter athletes. The variables
    are said to be **heteroscedastic** when the variance of one variable changes with
    respect to another. This is a concern in regression analysis, because it invalidates
    the assumption that modeling errors are uncorrelated and normally distributed
    and that their variances do not vary with the effects being modeled.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的残差图左侧的残差大于右侧，这对应于较矮运动员的体重方差较大。当一个变量的方差随着另一个变量的变化而变化时，这些变量被称为**异方差**。在回归分析中，这是一个需要关注的问题，因为它会使得假设建模误差不相关、正态分布，并且它们的方差不随建模效应变化的假设失效。
- en: The heteroscedasticity of our residuals are fairly small and should not influence
    the quality of our model very much. If the variance on the left side of the graph
    were more pronounced, it would cause the least squares estimate of variance to
    be incorrect, which in turn would affect inferences we make based on the standard
    error.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的残差的异方差性相对较小，应该不会对模型的质量产生太大影响。如果图表左侧的方差更为明显，则会导致最小二乘法估计的方差不准确，进而影响我们基于标准误差所做的推断。
- en: Goodness-of-fit and R-square
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拟合优度与R平方
- en: Although we can see from the residual plot that a linear model is a good fit
    for our data, it would be desirable to quantify just how good it is. Also called
    the **coefficient of determination**, *R²* varies between zero and one and indicates
    the explanatory power of the linear regression model. It calculates the proportion
    of variation in the dependent variable explained, or accounted for, by the independent
    variable.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们从残差图中可以看出线性模型很好地拟合了我们的数据，但我们仍然希望量化其拟合程度。**决定系数**（也称为*R²*）的值介于零和一之间，表示线性回归模型的解释能力。它计算了因变量的变化比例，其中由自变量解释或解释的部分。
- en: 'Generally, the closer *R²* is to 1, the better the regression line fits the
    points and the more the variation in *Y* is explained by *X*. *R²* can be calculated
    using the following formula:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，*R²* 越接近 1，回归线对数据点的拟合程度越好，*Y* 的变化越多地被 *X* 解释。*R²* 可以通过以下公式计算：
- en: '![Goodness-of-fit and R-square](img/7180OS_03_29.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![拟合优度与R平方](img/7180OS_03_29.jpg)'
- en: Here, *var(ε)* is the variance of the residuals and *var(Y)* is the variance
    in *Y*. To understand what this means, let's suppose you're trying to guess someone's
    weight. If you don't know anything else about them, your best strategy would be
    to guess the mean of the weights within the population in general. This way, the
    mean squared error of your guess compared to their true weight would be *var(Y)*
    or the variance of the weights in the population.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*var(ε)* 是残差的方差，*var(Y)* 是 *Y* 的方差。为了理解这意味着什么，假设你正在尝试猜测某人的体重。如果你对他们没有任何其他了解，你最好的策略是猜测该人群体重的均值。这样，你的猜测与他们真实体重之间的均方误差将是
    *var(Y)*，即该人群体重的方差。
- en: But if I told you their height, you would guess ![Goodness-of-fit and R-square](img/7180OS_03_28.jpg)
    as per the regression model. In this case, your mean squared error would be *var(ε)*
    or the variance of the residuals of the model.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我告诉你他们的身高，你就可以根据回归模型猜测 ![拟合优度与R平方](img/7180OS_03_28.jpg)。在这种情况下，你的均方误差将是
    *var(ε)*，即模型残差的方差。
- en: The term *var(ε)/ var(Y)* is the ratio of mean squared error with and without
    the explanatory variable, which is the fraction of variability left unexplained
    by the model. The complement *R²* is the fraction of variability explained by
    the model.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *var(ε)/ var(Y)* 是带有和不带有解释变量的均方误差的比率，它表示模型未能解释的变异部分。补充的 *R²* 是模型解释的变异部分的比例。
- en: Note
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: As with *r*, a low *R²* does not mean that the two variables are uncorrelated.
    It might simply be that their relationship is not linear.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *r* 一样，低 *R²* 并不意味着这两个变量不相关。它可能仅仅是因为它们之间的关系不是线性的。
- en: The *R²* value describes how well the line fits the data. The line of *best
    fit* is the line that minimizes the value of *R²*. As the coefficients increase
    or decrease away from their optimum values, *R²* will always increase.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*R²* 值描述了拟合线与数据的吻合度。*最佳拟合线*是使 *R²* 值最小化的那条线。随着系数远离最优值，*R²* 会始终增加。'
- en: '![Goodness-of-fit and R-square](img/7180OS_03_240.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![拟合优度与R平方](img/7180OS_03_240.jpg)'
- en: 'The left graph shows the variance for a model that always guesses the mean
    of *y* and the right one shows smaller squares associated with the residuals left
    unexplained by the model *f*. In purely geometric terms, you can see the how the
    model has explained most of the variance in *y*. The following code calculates
    *R²* by dividing the variance of the residuals with the variance of the *y* values:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的图表展示了一个始终猜测*y*均值的模型的方差，右边的图表显示了与模型*f*未能解释的残差相关的较小的方块。从几何上看，你可以看到模型已经解释了*y*的大部分方差。以下代码通过将残差的方差与*y*值的方差相除来计算*R²*：
- en: '[PRE17]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This gives a value of `0.753`. In other words, over 75 percent of the variance
    of the weight of 2012 Olympic swimmers can be explained by the height.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了`0.753`的值。换句话说，2012年奥运会游泳选手体重的超过75%的方差可以通过身高来解释。
- en: 'In the case of a simple regression model (with a single independent variable),
    the relationship between the coefficient of determination *R²* and the correlation
    coefficient *r* is a straightforward one:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单回归模型的情况下（只有一个自变量），决定系数*R²*和相关系数*r*之间的关系是直接的：
- en: '![Goodness-of-fit and R-square](img/7180OS_03_30.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![拟合优度与R平方](img/7180OS_03_30.jpg)'
- en: A correlation coefficient of 0.5 might suggest that half the variability in
    *Y* is explained by *X*, but actually, *R²* would be 0.5² or 0.25.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 0.5的相关系数可能意味着*Y*的变化性有一半是由*X*解释的，但实际上，*R²*将是0.5²，或者是0.25。
- en: Multiple linear regression
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多元线性回归
- en: We've seen so far in this chapter how to build a regression line with one independent
    variable. However, it is often desirable to build a model with several independent
    variables. This is called **multiple linear regression**.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在本章中已经介绍了如何使用一个自变量建立回归线。然而，通常我们希望建立一个包含多个自变量的模型。这就是**多元线性回归**。
- en: 'Each independent variable is going to need its own coefficient. Rather than
    working our way through the alphabet to represent each one, let''s designate a
    new variable *β*, pronounced "beta", to hold all of our coefficients:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每个自变量都需要它自己的系数。为了不通过字母表来表示每一个变量，我们可以指定一个新的变量*β*，发音为“beta”，用来表示我们所有的系数：
- en: '![Multiple linear regression](img/7180OS_03_31.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![多元线性回归](img/7180OS_03_31.jpg)'
- en: This model is equivalent to our **bivariate linear regression** model, where
    ![Multiple linear regression](img/7180OS_03_32.jpg) and ![Multiple linear regression](img/7180OS_03_33.jpg)
    so long as we ensure that *x[1]* is always equal to one. This ensures that *β[1]*
    is always a constant factor representing our intercept. *x[1]* is called the **bias**
    **term**.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型相当于我们的**双变量线性回归**模型，只要我们确保*x[1]*始终等于1，就可以像![多元线性回归](img/7180OS_03_32.jpg)和![多元线性回归](img/7180OS_03_33.jpg)那样。这确保了*β[1]*始终是一个常数因子，表示我们的截距。*x[1]*被称为**偏置**
    **项**。
- en: 'Having generalized the linear equation in terms of beta, easy to extend to
    as many coefficients as we''d like:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用beta来推广线性方程，容易扩展到任意数量的系数：
- en: '![Multiple linear regression](img/7180OS_03_34.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![多元线性回归](img/7180OS_03_34.jpg)'
- en: Each of the values of *x[1]* up to *x[n]* correspond to an independent variable
    that might help explain the value of *y*. Each of the values of *β[1]* up to *β[n]*
    correspond to a coefficient that determines the relative contribution of this
    independent variable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*x[1]*到*x[n]*的每个值对应一个可能有助于解释*y*值的自变量。*β[1]*到*β[n]*的每个值对应一个系数，决定了这个自变量的相对贡献。'
- en: 'Our simple linear regression aimed to explain weight only in terms of height,
    but many other factors help to explain someone''s weight: their age, gender, diet,
    and body type. We know the ages of our Olympic swimmers, so we could build a model
    that incorporates this additional data too.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单线性回归旨在仅通过身高来解释体重，但还有许多其他因素有助于解释一个人的体重：他们的年龄、性别、饮食和体型。我们知道奥运游泳选手的年龄，所以我们也可以建立一个包含这些附加数据的模型。
- en: 'We''ve been providing the independent variable as a single sequence of values,
    but with multiple parameters, we''ll need to provide several values for each *x*.
    We can use Incanter''s `i/$` function to select multiple columns and manipulate
    each *x* as a Clojure vector, but there is a better way: matrices.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直提供作为一个单一序列的自变量值，但有多个参数时，我们需要为每个*x*提供多个值。我们可以使用Incanter的`i/$`函数来选择多个列并将每个*x*作为Clojure向量来处理，但有一种更好的方法：矩阵。
- en: Matrices
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵
- en: A matrix is a two-dimensional grid of numbers. The dimensions are expressed
    as the number of rows and columns in the matrix.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是一个二维的数字网格。它的维度是通过矩阵中的行和列的数量来表示的。
- en: 'For example, *A* is a matrix with four rows and two columns:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*A* 是一个有四行两列的矩阵：
- en: '![Matrices](img/7180OS_03_35.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![Matrices](img/7180OS_03_35.jpg)'
- en: In mathematical notation, a matrix will usually be assigned to a variable with
    an upper-case letter to distinguish it from other variables in an equation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学符号中，矩阵通常会分配给一个大写字母变量，以区分它与方程式中的其他变量。
- en: 'We can construct a matrix from our dataset using Incanter''s `incanter.core/to-matrix`
    function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Incanter 的 `incanter.core/to-matrix` 函数从数据集构建一个矩阵：
- en: '[PRE18]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Incanter also defines the `incanter.core/matrix` function that will take a
    sequence of scalar values or a sequence of sequences and convert them into a matrix
    if it can:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Incanter 还定义了 `incanter.core/matrix` 函数，该函数可以将一个标量值序列或一个序列的序列转换为矩阵（如果可能的话）：
- en: '[PRE19]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you run this in the REPL, the output will be a summary of the contents of
    the matrix:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 REPL 中运行此代码，输出将是矩阵内容的摘要：
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Incanter returns a representation exactly as shown in the preceding example,
    presenting only the top and bottom three rows of the matrix. Matrices can often
    become very large and Incanter takes care not to inundate the REPL with information.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Incanter 返回的表示形式与前面的例子完全相同，仅展示矩阵的前三行和后三行。矩阵往往非常大，Incanter 会确保不会让 REPL 被大量信息淹没。
- en: Dimensions
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维度
- en: 'The element in the *i^(th)* row *j^(th)* column is referred to as *A[ij]*.
    Therefore, in our earlier example:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*i^(th)* 行 *j^(th)* 列的元素被称为 *A[ij]*。因此，在我们之前的例子中：'
- en: '![Dimensions](img/7180OS_03_36.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![Dimensions](img/7180OS_03_36.jpg)'
- en: One of the most fundamental attributes of a matrix is its size. Incanter provides
    the `incanter.core/dim`, `ncol`, and `nrow` functions to query matrices dimensions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的一个最基本的属性是它的大小。Incanter 提供了 `incanter.core/dim`、`ncol` 和 `nrow` 函数来查询矩阵的维度。
- en: Vectors
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量
- en: 'A vector is a special case of matrix with only one column. The number of rows
    in the vector are referred to as its dimension:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是只有一列的特殊矩阵。向量的行数被称为它的维度：
- en: '![Vectors](img/7180OS_03_37.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![Vectors](img/7180OS_03_37.jpg)'
- en: Here, *y* is a four-dimensional vector. The *i^(th)* element is referred to
    as *y[i]*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*y* 是一个四维向量。*i^(th)* 元素被称为 *y[i]*。
- en: Vectors in mathematical literature are one-indexed unless otherwise specified.
    So, *y[1]* refers to the first element, not the second. Vectors are generally
    assigned to lowercase variables in equations. Incanter's API doesn't distinguish
    between vectors and single column matrices and we can create a vector by passing
    a single sequence to the `incanter.core/matrix` function.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 数学文献中的向量通常是从 1 开始索引的，除非另有说明。所以，*y[1]* 是指第一个元素，而不是第二个。向量在方程式中通常分配给小写字母变量。Incanter
    的 API 并不区分向量和单列矩阵，我们可以通过传递一个单一序列给 `incanter.core/matrix` 函数来创建一个向量。
- en: Construction
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建
- en: As we've seen, it's possible to build matrices out of Clojure sequences and
    Incanter datasets. It's also possible to build matrices out of smaller building
    blocks, provided the dimensions are compatible. Incanter provides the `incanter.core/bind-columns`
    and `incanter.core/bind-rows` functions to stack matrices above one another or
    side by side.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，可以通过 Clojure 序列和 Incanter 数据集来构建矩阵。也可以通过更小的构建块来构建矩阵，前提是维度兼容。Incanter 提供了
    `incanter.core/bind-columns` 和 `incanter.core/bind-rows` 函数，可以将矩阵堆叠在一起或并排放置。
- en: 'For example, we could add a column of 1s to the front of another matrix in
    the following way:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过以下方式将一个全是 1 的列加到另一个矩阵的前面：
- en: '[PRE21]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In fact, we'll want to do this for our bias term. Recall that *β[1]* will represent
    a constant value, so we must ensure that our corresponding *x[1]* is constant
    too. Without the bias term, *y* would have to be zero when the values of *x* are
    zero.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们会希望这样做来处理我们的偏置项。回忆一下，*β[1]* 将代表一个常数值，因此我们必须确保相应的 *x[1]* 也是常数。如果没有偏置项，当
    *x* 的值为零时，*y* 也必须为零。
- en: Addition and scalar multiplication
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加法和标量乘法
- en: A scalar is a name for a simple number. When we add a scalar to a matrix, it's
    as if we added the number to each element of the matrix, individually. Incanter
    provides the `incanter.core/plus` function to add scalars and matrices together.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 标量是一个简单数字的名称。当我们将标量加到矩阵时，就好像我们将该数字加到矩阵的每个元素上一样，逐个元素。Incanter 提供了 `incanter.core/plus`
    函数来将标量和矩阵相加。
- en: Matrix-matrix addition works by adding the elements in each corresponding position.
    Only matrices of the same dimensions can be added together. If the matrices are
    of the same dimensions, they are said to be compatible.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵加法是通过将每个对应位置的元素相加来实现的。只有维度相同的矩阵才能相加。如果矩阵的维度相同，则称它们是兼容的。
- en: '![Addition and scalar multiplication](img/7180OS_03_38.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![加法和标量乘法](img/7180OS_03_38.jpg)'
- en: The `plus` function will also add compatible matrices. The `minus` function
    will subtract scalars or compatible matrices. Multiplying a matrix by a scalar
    results in each of the elements in the matrix being multiplied by the scalar.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`plus`函数也可以相加兼容的矩阵。`minus`函数会减去标量或兼容的矩阵。将矩阵与标量相乘会导致矩阵中的每个元素都与该标量相乘。'
- en: '![Addition and scalar multiplication](img/7180OS_03_39.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![加法和标量乘法](img/7180OS_03_39.jpg)'
- en: The `incanter.core/mult` performs matrix-scalar multiplication, while `incanter.core/div`
    performs the inverse.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`incanter.core/mult`执行矩阵与标量的乘法，而`incanter.core/div`执行逆运算。'
- en: We can also use `mult` and `div` on compatible matrices, but this element-wise
    method of multiplying and dividing is not what we normally intend to do when we
    speak of matrix multiplication.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在兼容的矩阵上使用`mult`和`div`，但这种逐元素的乘法和除法并不是我们通常在谈论矩阵乘法时所指的内容。
- en: Matrix-vector multiplication
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵-向量乘法
- en: 'The standard way to multiply matrices is handled by the `incanter.core/mmult`
    function, which applies the complex matrix multiplication algorithm. For example,
    the result of multiplying a 3 x 2 matrix with a 2 x 1 matrix is a 3 x 1 matrix.
    The number of columns on the left has to match the number of rows on the right
    of the multiplication:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘法的标准方法是通过`incanter.core/mmult`函数来处理的，该函数应用了复杂的矩阵乘法算法。例如，将一个3 x 2的矩阵与一个2 x
    1的矩阵相乘，结果是一个3 x 1的矩阵。乘法的左边列数必须与右边的行数匹配：
- en: '![Matrix-vector multiplication](img/7180OS_03_40.jpg)![Matrix-vector multiplication](img/7180OS_03_41.jpg)![Matrix-vector
    multiplication](img/7180OS_03_42.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵-向量乘法](img/7180OS_03_40.jpg)![矩阵-向量乘法](img/7180OS_03_41.jpg)![矩阵-向量乘法](img/7180OS_03_42.jpg)'
- en: 'To get *Ax*, multiply each row of *A* element-by-element with the corresponding
    element of *x* and sum the results. For example, the first row of matrix *A* contains
    the elements *1* and *3*. These are multiplied pairwise by the elements in vector
    *x*: *1* and *5*. Then, the products are added together to produce *16*. This
    is called the **dot product** and is what is commonly intended by matrix multiplication.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到*Ax*，需要将*A*的每一行与*x*的对应元素逐一相乘并求和。例如，矩阵*A*的第一行包含元素*1*和*3*，这些元素分别与向量*x*中的元素*1*和*5*相乘。然后，将这些乘积相加得到*16*。这就是**点积**，也是我们通常所说的矩阵乘法。
- en: Matrix-matrix multiplication
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵-矩阵乘法
- en: Matrix-matrix multiplication proceeds very similarly to matrix-vector multiplication.
    The sum of the products is taken pairwise, row by row and column by column, from
    the corresponding elements of matrices *A* and *B*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵-矩阵乘法的过程与矩阵-向量乘法非常相似。通过逐行逐列地从矩阵*A*和*B*的对应元素中求得乘积之和。
- en: '![Matrix-matrix multiplication](img/7180OS_03_40.jpg)![Matrix-matrix multiplication](img/7180OS_03_43.jpg)![Matrix-matrix
    multiplication](img/7180OS_03_44.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵乘法](img/7180OS_03_40.jpg)![矩阵乘法](img/7180OS_03_43.jpg)![矩阵乘法](img/7180OS_03_44.jpg)'
- en: As before, we can only multiply matrices together when the number of columns
    in the first matrix is equal to the number of rows in the second matrix. If the
    first matrix *A* is of dimensions ![Matrix-matrix multiplication](img/7180OS_03_45.jpg)
    and the second matrix *B* is of dimensions ![Matrix-matrix multiplication](img/7180OS_03_46.jpg),
    *n[a]* and *m[B]* must be equal if the matrices are to be multiplied.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，只有当第一个矩阵的列数等于第二个矩阵的行数时，我们才能将矩阵相乘。如果第一个矩阵*A*的维度是![矩阵乘法](img/7180OS_03_45.jpg)，而第二个矩阵*B*的维度是![矩阵乘法](img/7180OS_03_46.jpg)，则只有当*n[a]*和*m[B]*相等时，矩阵才能相乘。
- en: '![Matrix-matrix multiplication](img/7180OS_03_250.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵乘法](img/7180OS_03_250.jpg)'
- en: 'In the previous visual example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的视觉示例中：
- en: '![Matrix-matrix multiplication](img/7180OS_03_47.jpg)![Matrix-matrix multiplication](img/7180OS_03_48.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵乘法](img/7180OS_03_47.jpg)![矩阵乘法](img/7180OS_03_48.jpg)'
- en: Luckily, we don't have to remember the process ourselves. Incanter uses very
    efficient algorithms to perform matrix algebra for us.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要自己记住这个过程。Incanter使用非常高效的算法为我们执行矩阵代数运算。
- en: Transposition
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转置
- en: 'Transposing a matrix means flipping the matrix over the main diagonal running
    from the top-left to the bottom-right corner. The transpose of matrix *A* is represented
    as *A^T*:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 转置一个矩阵意味着将矩阵沿从左上角到右下角的主对角线翻转。矩阵*A*的转置表示为*A^T*：
- en: '![Transposition](img/7180OS_03_49.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![转置](img/7180OS_03_49.jpg)'
- en: 'The columns and rows have been changed such that:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列和行已经发生了变化，因此：
- en: '![Transposition](img/7180OS_03_50.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![转置](img/7180OS_03_50.jpg)'
- en: 'Therefore, if:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果：
- en: '![Transposition](img/7180OS_03_36.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![转置](img/7180OS_03_36.jpg)'
- en: 'Then:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然后：
- en: '![Transposition](img/7180OS_03_51.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![转置](img/7180OS_03_51.jpg)'
- en: Incanter provides the `incanter.core/trans` function to transpose a matrix.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Incanter 提供了 `incanter.core/trans` 函数来转置矩阵。
- en: The identity matrix
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单位矩阵
- en: 'Certain matrices have special properties and are used regularly in matrix algebra.
    One of the most important of these is the identity matrix. It''s a square matrix
    with ones along the main diagonal and zeros everywhere else:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 某些矩阵具有特殊的性质，并且在矩阵代数中经常使用。最重要的其中之一就是单位矩阵。它是一个方阵，主对角线上的元素为 1，其他位置的元素为 0：
- en: '![The identity matrix](img/7180OS_03_52.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![单位矩阵](img/7180OS_03_52.jpg)'
- en: The identity matrix is the identity for matrix multiplication. As with a scalar
    multiplication by the number one, a matrix multiplication by the identity matrix
    has no effect.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵是矩阵乘法的单位元。就像用数字 1 进行标量乘法一样，使用单位矩阵进行矩阵乘法没有任何影响。
- en: Incanter provides the `incanter.core/identity-matrix` function to construct
    identity matrices. Since they're always square, we only provide a single argument
    corresponding to both, the width and height.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Incanter 提供了 `incanter.core/identity-matrix` 函数来构造单位矩阵。由于单位矩阵总是方阵，因此我们只需要提供一个参数，它同时对应宽度和高度。
- en: Inversion
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 求逆
- en: 'If we have a square matrix *A*, the inverse of *A* is denoted as *A^(-1)* and
    it will have the following properties, where *I* is the identity matrix:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个方阵 *A*，则 *A* 的逆矩阵记作 *A^(-1)*，它将具有以下性质，其中 *I* 是单位矩阵：
- en: '![Inversion](img/7180OS_03_53.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![求逆](img/7180OS_03_53.jpg)'
- en: The identity matrix is its own inverse. Not all matrices are invertible and
    noninvertible matrices are also called **singular** or **degenerate** matrices.
    We can calculate the inverse of a matrix with the `incanter.core/solve` function.
    `solve` will raise an exception if passed a singular matrix.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵是它自身的逆矩阵。并非所有矩阵都有可逆性，不可逆矩阵也称为**奇异矩阵**或**退化矩阵**。我们可以使用 `incanter.core/solve`
    函数来计算矩阵的逆。如果传入奇异矩阵，`solve` 会引发异常。
- en: The normal equation
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正规方程
- en: 'Now that we''ve covered the basics of matrix and vector manipulation we''re
    in a position to study the **normal equation**. This is an equation that uses
    matrix algebra to calculate the coefficients of our OLS linear regression model:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了矩阵和向量操作的基础，可以开始研究**正规方程**。这是一个利用矩阵代数来计算 OLS 线性回归模型系数的方程：
- en: '![The normal equation](img/7180OS_03_54.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![正规方程](img/7180OS_03_54.jpg)'
- en: We read "to find *β*, multiply the inverse of *X* transpose *X*, by *X* transpose
    *y*" where *X* is the matrix of independent variables (including the intercept
    term) for our sample and *y* is a vector containing the dependent variables for
    our sample. The result *β* contains the calculated coefficients. This normal equation
    is relatively easy to derive from the equation of multiple regression, applying
    the rules of matrix multiplication, but the mathematics is beyond the scope of
    this book.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读作“为了找到 *β*，将 *X* 转置的逆矩阵乘以 *X* 转置，再乘以 *y*”，其中 *X* 是包含独立变量（包括截距项）的矩阵，*y* 是包含样本依赖变量的向量。结果
    *β* 包含了计算出的系数。这个正规方程相对容易从多元回归方程中推导出来，应用矩阵乘法规则，但其数学内容超出了本书的讨论范围。
- en: 'We can implement the normal equation with Incanter using only the functions
    we have just encountered:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用刚才遇到的函数，在 Incanter 中实现正规方程：
- en: '[PRE22]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This normal equation expresses the mathematics of least squares linear regression
    in a very succinct way. We can use it as follows (remembering to add the bias
    term):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正规方程以非常简洁的方式表达了最小二乘法线性回归的数学原理。我们可以如下使用它（记得添加偏置项）：
- en: '[PRE23]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This yields the following matrix:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这会得到以下矩阵：
- en: '[PRE24]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These are the values of *β[1]* and *β[2]* corresponding to the intercept and
    slope parameters. Happily, they agree with the values we calculated previously.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 *β[1]* 和 *β[2]* 的值，分别对应截距和斜率参数。幸运的是，它们与我们之前计算出的值一致。
- en: More features
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多功能
- en: 'Part of the strength of the normal equation is that we''ve now implemented
    everything we need in order to support multiple linear regression. Let''s write
    a function to convert the features of interest to a matrix:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 正规方程的一个强大之处在于，我们现在已经实现了支持多元线性回归所需的所有内容。让我们写一个函数，将感兴趣的特征转换为矩阵：
- en: '[PRE25]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This function will allow us to select specific columns as a matrix in one step.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将允许我们一步选择特定的列作为矩阵。
- en: Note
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A feature is a synonym for an independent variable and is popularly used in
    machine learning. Other synonyms are predictor, regressor, and explanatory variable,
    or simply input variable.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 特征是自变量的同义词，通常在机器学习中使用。其他同义词包括预测变量、回归变量、解释变量，或简称输入变量。
- en: 'To start with, let''s select height and age as our two features:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们选择身高和年龄作为我们的两个特征：
- en: '[PRE26]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This returns the following matrix of two columns:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下两列矩阵：
- en: '[PRE27]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our normal equation function will accept this new matrix without any further
    change:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的普通方程函数将接受这个新的矩阵，且无需进一步修改：
- en: '[PRE28]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It will return the following coefficients:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回以下系数：
- en: '[PRE29]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These three numbers correspond to the intercept, the slope for height, and the
    slope for age, respectively. To determine whether our model has significantly
    improved by this new data, we could calculate the *R²* value of our new model
    and compare it to the earlier one.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个数字分别对应截距、身高的斜率和年龄的斜率。为了确定通过这些新数据我们的模型是否有显著改进，我们可以计算新模型的 *R²* 值，并与之前的模型进行比较。
- en: Multiple R-squared
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个 R 平方
- en: 'While calculating *R²* previously, we saw how it was the amount of variance
    explained by the model:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前计算 *R²* 时，我们看到了它是模型解释的方差量：
- en: '![Multiple R-squared](img/7180OS_03_55.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![多个 R 平方](img/7180OS_03_55.jpg)'
- en: 'Since the variance is the mean squared error, we can multiply both the *var(ε)*
    and *var(y)* terms by the sample size and arrive at the following alternative
    equation for R²:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 由于方差即为均方误差，我们可以将 *var(ε)* 和 *var(y)* 两项分别乘以样本大小，得到 R² 的另一种计算公式：
- en: '![Multiple R-squared](img/7180OS_03_56.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![多个 R 平方](img/7180OS_03_56.jpg)'
- en: 'This is simply the sum of squared residuals over the sum of squared differences
    from the mean. Incanter contains the `incanter.core/sum-of-squares` function that
    makes this very simple to express:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是残差平方和与均值平方差之和的比值。Incanter 包含了 `incanter.core/sum-of-squares` 函数，使得这一表达变得非常简单：
- en: '[PRE30]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We use the variable names `rss` for **residual sum of squares** and `ess` for
    **explained sum of squares**. We can calculate the matrix *R²* for our new model
    as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用变量名 `rss` 表示**残差平方和**，`ess` 表示**解释平方和**。我们可以按以下方式计算新模型的矩阵 *R²*：
- en: '[PRE31]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This yields the value `0.757`. Our *R²* value has increased by a small amount
    by including the age value. Because we have used multiple independent variables,
    *R²* is now called the **coefficient of** **multiple determination**.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这得出了值 `0.757`。通过加入年龄值，我们的 *R²* 值略有增加。因为我们使用了多个自变量，所以 *R²* 现在被称为**多重决定系数**。
- en: Adjusted R-squared
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整 R 平方
- en: As we add more independent variables to our regression, we might be encouraged
    by the fact that our *R²* value always increases. Adding a new independent variable
    isn't going to make it harder to predict the dependent variable—if the new variable
    has no explanatory power, then its coefficient will simply be zero and the R²
    will remain the same as it was without the independent variable.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们向回归模型中添加更多自变量，我们可能会受到 *R²* 值总是增加这一现象的鼓舞。添加一个新的自变量不会使得预测因变量变得更困难——如果新变量没有解释能力，那么它的系数将会是零，R²
    也将保持不变。
- en: 'However, this doesn''t tell us whether a model has been improved by the addition
    of a new variable. If we want to know whether our new variable is really helping
    it to generate a better fit, we can use the adjusted *R²*, often written as ![Adjusted
    R-squared](img/7180OS_03_57.jpg) and pronounced as "R-bar squared." Unlike *R²*,
    ![Adjusted R-squared](img/7180OS_03_57.jpg) will only increase if the new independent
    variable increases *R²* more than would be expected due to chance:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不能告诉我们模型是否因为添加了新变量而得到改进。如果我们想知道新变量是否真的帮助生成了更好的拟合度，我们可以使用调整后的 *R²*，通常写作
    ![调整后的 R 平方](img/7180OS_03_57.jpg)，并读作 "R-bar 平方"。与 *R²* 不同，![调整后的 R 平方](img/7180OS_03_57.jpg)
    只有在新自变量增加的 *R²* 超过由于偶然因素所期望的增幅时，它才会增加：
- en: '[PRE32]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The adjusted *R²* depends on two additional parameters, *n* and *p*, corresponding
    to the sample size and number of model parameters, respectively:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 调整后的 *R²* 依赖于两个附加参数，*n* 和 *p*，分别对应样本大小和模型参数的数量：
- en: '[PRE33]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This example returns a value of `0.756`. This is still greater than the original
    model, so age certainly carries some explanatory power.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例返回了值 `0.756`。这仍然大于原始模型，因此年龄无疑具有一定的解释力。
- en: Incanter's linear model
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Incanter 的线性模型
- en: While implementing our own version of the normal equation and *R²* provides
    a valuable opportunity to introduce matrix algebra, it's important to note that
    Incanter provides the `incanter.stats/linear-model` function that does everything
    we've covered and more.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管实现我们自己的标准方程和 *R²* 为引入矩阵代数提供了宝贵的机会，但值得注意的是，Incanter 提供了 `incanter.stats/linear-model`
    函数，涵盖了我们所讲的所有内容，甚至更多。
- en: The function expects to be called with *y* and *x* (as either sequences or,
    in the case of multiple regression, matrices). We can also pass in an optional
    keyword argument—`intercept` with a Boolean value—indicating whether we'd like
    Incanter to add the intercept term for us. The function will return a map containing
    the coefficients of the linear model—`:coefs` and the fitted data—`:fitted`, as
    well as `:residuals`, `:r-square`, and `:adj-r-square`, amongst others.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数期望以 *y* 和 *x*（可以是序列，或在多元回归的情况下是矩阵）作为输入。我们还可以传入一个可选的关键字参数 `intercept`，其值为布尔型，指示是否希望
    Incanter 为我们添加截距项。该函数将返回一个包含线性模型系数的映射—`:coefs` 和拟合数据—`:fitted`，以及 `:residuals`、`:r-square`
    和 `:adj-r-square` 等。
- en: It will also return significance tests and 95 percent confidence intervals for
    the coefficients as the `:t-probs` and `:coefs-ci` keys, respectively, as well
    as the `:f-prob` keys, corresponding to a significance test on the regression
    model as a whole.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会返回显著性测试和系数的 95% 置信区间，分别作为 `:t-probs` 和 `:coefs-ci` 键，以及 `:f-prob` 键，后者对应于整个回归模型的显著性测试。
- en: The F-test of model significance
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型显著性的 *F* 检验
- en: The `:f-prob` key returned by `linear-model` is a significance test of the entire
    model using an *F*-test. As we discovered in the previous chapter, an *F*-test
    is appropriate when performing multiple significance tests at once. In the case
    of multiple linear regression, we are testing whether any of the coefficients
    of the model, except for the intercept term, are statistically indistinguishable
    from zero.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`linear-model` 返回的 `:f-prob` 键是对整个模型进行的显著性测试，使用的是 *F* 检验。正如我们在上一章中发现的，*F* 检验适用于同时进行多个显著性检验。在多元线性回归的情况下，我们检验的是除截距项外，模型中的任何系数是否与零在统计上不可区分。'
- en: 'Our null and alternate hypotheses are therefore:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的原假设和备择假设为：
- en: '![The F-test of model significance](img/7180OS_03_58.jpg)![The F-test of model
    significance](img/7180OS_03_59.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![模型显著性的 *F* 检验](img/7180OS_03_58.jpg)![模型显著性的 *F* 检验](img/7180OS_03_59.jpg)'
- en: 'Here, *j* is some index in the parameter''s vector excluding the intercept.
    The *F*-statistic we calculate is the ratio of explained variance over the unexplained
    (residual) variance. This can be expressed as the **mean square model** (**MSM**)
    over the **mean** **square error** (**MSE**):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*j* 是参数向量中的某个索引，不包括截距项。我们计算的 *F* 统计量是已解释方差与未解释（残差）方差的比率。可以表示为 **模型均方** (**MSM**)
    与 **均方误差** (**MSE**) 的比值：
- en: '![The F-test of model significance](img/7180OS_03_60.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![模型显著性的 *F* 检验](img/7180OS_03_60.jpg)'
- en: The MSM is equal to the **explained sum of squares** (**ESS**) divided by the
    model degree of freedom, where the model degree of freedom is the number of parameters
    in the model excluding the intercept term. The MSE is equal to the **sum of**
    **residual squares** (**RSS**) divided by the residual degree of freedom, where
    the residual degree of freedom is the size of the sample minus the number of model
    parameters.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: MSM 等于 **解释平方和** (**ESS**) 除以模型的自由度，其中模型自由度是模型中参数的数量，不包括截距项。MSE 等于 **残差平方和**
    (**RSS**) 除以残差自由度，其中残差自由度是样本大小减去模型参数的数量。
- en: 'Once we''ve calculated the *F*-statistic, we look it up in an *F*-distribution
    parameterized by the same two degrees of freedom:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们计算出 *F* 统计量，就可以在具有相同两个自由度的 *F* 分布中查找它：
- en: '[PRE34]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The test returns a result of `1.11x10e-16`. This is a tiny number; as a result,
    we can be certain that the model is significant.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 测试返回结果 `1.11x10e-16`。这是一个非常小的数字；因此，我们可以确信模型是显著的。
- en: Note that with smaller samples of data, the *F*-test quantifies increasing uncertainty
    that a linear model is appropriate. With a random sample of five, for example,
    the data sometimes shows barely any linear relationship at all and the *F*-test
    judges the data insignificant at even a 50 percent confidence interval.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于较小的样本数据，*F* 检验量化了线性模型是否合适的不确定性。例如，对于一个五个数据点的随机样本，数据有时几乎没有任何线性关系，*F* 检验在
    50% 置信区间下甚至认为数据不显著。
- en: Categorical and dummy variables
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别变量和虚拟变量
- en: 'We might attempt at this point to include `"Sex"` as a feature in our regression
    analysis, but we''ll encounter a problem. The input is expressed as `"M"` or `"F"`
    rather than a number. This is an example of a categorical variable: a variable
    that can take one of a finite set of values that are unordered and (usually) not
    numeric. Other examples of categorical variables are the sport that the athlete
    participates in or the particular event in which they are most proficient.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可能会尝试将`"Sex"`作为回归分析中的特征，但我们会遇到一个问题。输入是以`"M"`或`"F"`表示的，而不是数字。这是一个分类变量的例子：一个可以取有限集无序且通常非数字的值的变量。其他分类变量的例子包括运动员参与的体育项目或他们最擅长的具体项目。
- en: Ordinary least squares relies on a numerical value of residual distance to minimize.
    What could the numeric distance between swimming and athletics be? This might
    imply that it is impossible to include categorical variables in our regression
    equation.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 普通最小二乘法依赖于残差距离的数值来最小化。那么，游泳和田径之间的数值距离可能是多少呢？这可能意味着无法将分类变量包含在回归方程中。
- en: Note
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Categorical or nominal variables are distinct from continuous variables, because
    they don't sit on the number line. Sometimes categories are represented by numbers
    like for ZIP codes, but we shouldn't assume that numeric categories are necessarily
    ordered or that the interval between categories are equal.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 分类变量或名义变量与连续变量不同，因为它们不在数轴上。有时类别会用数字表示，比如邮政编码，但我们不应假设数字类别一定是有序的，或者类别之间的间隔是相等的。
- en: Fortunately, many categorical variables can be considered dichotomies and, in
    fact, our sample data contains two categories for `sex`. These can be included
    in our regression model provided we transform them into two numbers, for example,
    zero and one.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，许多分类变量可以视为二分变量，实际上，我们的样本数据包含了`sex`的两个类别。只要我们将它们转化为两个数字（例如0和1），这些变量就可以包含在我们的回归模型中。
- en: When a category such as sport takes on more than two values, we could include
    an independent variable for each type of sport. We would create a variable for
    swimming and another for weightlifting, and so on. The value of swimming would
    be one for swimmers and zero otherwise.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当像体育项目这样的类别有多个取值时，我们可以为每种体育类型包含一个独立的变量。我们可以为游泳创建一个变量，为举重创建另一个变量，依此类推。游泳的值对游泳者为1，其他为0。
- en: Since `sex` might be a useful explanatory variable for our regression model,
    let's convert female to `0` and male to `1`. We can add a derived column containing
    our dummy variable using Incanter's `incanter.core/add-derived-column` function.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`sex`可能是我们回归模型中有用的解释变量，让我们将女性转换为`0`，男性转换为`1`。我们可以使用Incanter的`incanter.core/add-derived-column`函数添加一个包含虚拟变量的派生列。
- en: 'Let''s calculate our ![Categorical and dummy variables](img/7180OS_03_57.jpg)
    value to see if it has improved:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算我们的![分类变量和虚拟变量](img/7180OS_03_57.jpg)的值，看看是否有所改善：
- en: '[PRE35]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The code yields the value `0.809`. Using the height, age, and gender features,
    we have successfully explained over 80 percent of the variance in weight of our
    Olympic swimmers.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码的输出值为`0.809`。通过使用身高、年龄和性别特征，我们成功解释了奥运游泳运动员体重超过80%的差异。
- en: Relative power
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相对力量
- en: 'At this point, it might be useful to ask what is the most important feature
    to explain the observed weight: is it age, gender, or height? We could make use
    of our adjusted *R²* and see how much the value changes, but this would require
    us to re-run the regression for each variable we want to test.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，提出一个问题可能会很有帮助：哪个特征最能解释观测到的体重：是年龄、性别还是身高？我们可以利用调整后的*R²*来查看数值变化，但这将要求我们为每个需要测试的变量重新运行回归。
- en: 'We can''t look at the magnitude of the coefficients, because the ranges of
    the data they apply to are vastly different: height in centimeters, age in years,
    and gender measured as a dummy variable in the range zero to one.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能仅看回归系数的大小，因为它们适用的数据范围差异巨大：身高以厘米为单位，年龄以年为单位，性别作为虚拟变量的取值范围为0到1。
- en: In order to compare the relative contributions of the coefficients, we can calculate
    the standardized regression coefficient, or beta weight.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较回归系数的相对贡献，我们可以计算标准化回归系数或贝塔权重。
- en: '![Relative power](img/7180OS_03_62.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![相对力量](img/7180OS_03_62.jpg)'
- en: 'To calculate the beta weight we multiply each coefficient by the ratio of the
    standard deviations for the associated independent variable and the model''s dependent
    variable. This can be accomplished with the following Clojure code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 beta 权重时，我们将每个系数乘以相关独立变量和模型的因变量的标准差比值。这可以通过以下 Clojure 代码实现：
- en: '[PRE36]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This outputs (rounded to three decimal places):'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这输出的结果（四舍五入到三位小数）是：
- en: '[PRE37]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This indicates that height is the most important explanatory variable, followed
    by gender and then age. Transforming it into standardized coefficients tells us
    that with an increase of one standard deviation in height, the mean weight increases
    by `0.65` standard deviations.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明身高是最重要的解释变量，其次是性别，再次是年龄。将其转化为标准化系数告诉我们，身高增加一个标准差时，平均体重增加`0.65`个标准差。
- en: Collinearity
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共线性
- en: We might try at this point to keep adding features to our model in an attempt
    to increase its explanatory power.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，我们可能会尝试继续向模型中添加特征，试图提高其解释能力。
- en: 'For example, we also have a `"Date of birth"` column and we may be tempted
    to try and include this too. It is a date, but we could easily convert it into
    a number suitable for use in regression. We could do this simply by extracting
    the year from their birth date using the `clj-time` library:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们还有一个“出生日期”列，可能会被诱使尝试将其也包括在内。它是一个日期，但我们可以很容易地将其转换为适合回归使用的数字。我们可以通过使用 `clj-time`
    库从出生日期中提取年份来实现这一点：
- en: '[PRE38]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The new "Year of Birth" feature has a beta weight of only `0.038`, less than
    the weight of the age feature we calculated earlier. However, the age weight of
    the age feature is now showing a value of `0.096`. Its relative importance has
    increased by over 65 percent since we added `"Year of birth"` as a feature. The
    fact that the addition of a new feature has altered the importance of an existing
    feature indicates that we have a problem.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 新的“出生年份”特征的 beta 权重只有 `0.038`，低于我们之前计算的年龄特征的权重。然而，年龄特征的年龄权重现在显示为 `0.096`。自从我们将“出生年份”作为特征添加进来后，它的相对重要性已增加超过
    65%。新特征的加入改变了现有特征的重要性，这表明我们遇到了问题。
- en: 'By including the additional `"Year of birth"` parameter, we have inadvertently
    broken a rule of the regression estimator. Let''s see why:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加额外的“出生年份”参数，我们不小心打破了回归估计器的一个规则。让我们来看看为什么：
- en: '[PRE39]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following scatter plot shows the age of swimmers (with jittering) plotted
    against their year of birth. As you would expect, the two variables are very closely
    correlated:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了游泳运动员的年龄（带有抖动）与他们的出生年份的散点图。正如你所预期的，这两个变量之间的相关性非常高：
- en: '![Collinearity](img/7180OS_03_260.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![共线性](img/7180OS_03_260.jpg)'
- en: The two features are so highly correlated that the algorithm is unable to determine
    which of them best explains the observed changes in *y*. This is an undesirable
    issue when we deal with multivariate linear regression called **collinearity**.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个特征高度相关，以至于算法无法确定哪一个更能解释 *y* 的变化。这是我们处理多元线性回归时的一个不良问题，称为**共线性**。
- en: Multicollinearity
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重共线性
- en: For multiple regression to produce the best coefficient estimates, the underlying
    data must conform to the same assumptions as simple regression plus one additional
    assumption— the absence of perfect **multicollinearity**. This means that the
    independent variables should not be exactly linearly correlated with each other.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使多元回归产生最佳的系数估计，数据必须符合简单回归的相同假设，再加上一个额外的假设——没有完美的**多重共线性**。这意味着独立变量之间不应存在完全线性相关性。
- en: Note
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In practice, independent variables are often collinear in some way. Consider,
    for example, that age and height or gender and height are themselves correlated
    with each other. It's only when this condition becomes extreme that serious coefficient
    errors can arise.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 实际中，独立变量常常以某种方式存在共线性。例如，考虑年龄和身高，或者性别和身高，它们之间本身就存在相关性。只有当这种情况变得极端时，才可能导致严重的系数错误。
- en: If the independent variables are, in fact, not independent, then linear regression
    can't determine the relative contribution of each independent variable. If two
    features are so strongly correlated that they always vary together, how can the
    algorithm distinguish their relative importance? As a result, there may be high
    variance in the coefficient estimates and a high standard error.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自变量实际上并不独立，那么线性回归就无法确定每个自变量的相对贡献。如果两个特征强烈相关，始终一起变化，那么算法怎么区分它们的相对重要性呢？因此，回归系数的估计可能会有较大的方差，并且标准误差较高。
- en: 'We''ve already seen one symptom of high multicollinearity: regression coefficients
    that change significantly when independent variables are added or removed from
    the equation. Another symptom is when there is an insignificant coefficient in
    a multiple regression for a particular independent variable, but a substantial
    *R²* for the simple regression model using the same independent variable.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到高多重共线性的一个症状：当自变量被添加或从方程中移除时，回归系数发生显著变化。另一个症状是，当一个特定的自变量在多重回归中没有显著系数时，但使用相同自变量的简单回归模型却有较大的*R²*值。
- en: While these offer clues of multicollinearity, to confirm, we must look directly
    at the intercorrelation of the independent variables. One way to determine the
    intercorrelation is to examine the correlation between each of the independent
    variables, looking for coefficients of 0.8 or more. While this simple approach
    often works, it may fail to take into account situations where an independent
    variable has a linear relationship with the other variables taken together.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些迹象提供了多重共线性的线索，但要确认，我们必须直接查看自变量之间的相互关系。一种确定相互关系的方法是检查各自变量之间的相关性，寻找相关系数为0.8或以上的情况。虽然这种简单的方法通常有效，但它可能未能考虑到自变量与其他变量联合的线性关系。
- en: The surest method to assess multicollinearity is to regress each independent
    variable on all the other independent variables. When any of the *R²* from these
    equations is near 1.0, there is high-multicollinearity. In fact, the largest of
    these *R²* serves as an indicator of the degree of multicollinearity that exists.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 评估多重共线性最可靠的方法是将每个自变量与所有其他自变量进行回归。当这些方程中的任何一个*R²*接近1.0时，就说明存在高多重共线性。事实上，这些*R²*中的最大值可以作为存在的多重共线性程度的指标。
- en: 'Once identified, there are several ways to address multicollinearity:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦识别出多重共线性，有几种方法可以处理：
- en: Increase the sample size. More data can produce more precise parameter estimates
    with smaller standard errors.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加样本量。更多的数据可以产生更精确的参数估计，标准误差也会更小。
- en: Combine the features into one. If you have several features that measure essentially
    the same attribute, find a way to unify them into a single feature.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个特征合并为一个。如果你有多个特征测量的是基本相同的属性，找出一种方法将它们统一成一个特征。
- en: Discard the offending variable(s).
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 舍弃有问题的变量。
- en: Limit the equation of prediction. Collinearity affects the coefficients of the
    model, but the result may still be a good fit for the data.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制预测方程。共线性会影响模型的系数，但结果仍可能对数据有良好的拟合。
- en: Since age and year of birth carry essentially the same information, we may as
    well discard one. We can easily see which of the two contains more explanatory
    power by calculating the bivariate regression for each feature and the dependent
    variable.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 由于年龄和出生年份基本包含相同的信息，我们不妨舍弃其中一个。我们可以通过计算每个特征与因变量的双变量回归，轻松看出哪个特征具有更多的解释力。
- en: '"Age" *R²* = 0.1049, whereas "Year of birth" *R²* = 0.1050.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: “年龄”*R²* = 0.1049，而“出生年份”*R²* = 0.1050。
- en: As expected, there is virtually no difference between the two features, both
    explaining around 10 percent of the variance in weight. Since the year of birth
    marginally explains marginally more of the variance, we'll keep it and discard
    the age feature.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，这两个特征几乎没有区别，都大约解释了体重方差的10%。由于出生年份略微解释了更多的方差，我们将保留它并舍弃年龄特征。
- en: Prediction
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测
- en: 'Finally, we arrive at one of the most important uses of linear regression:
    prediction. We''ve trained a model capable of predicting the weight of Olympic
    swimmers given the data about their height, gender, and year of birth.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们得出了线性回归的一个重要应用：预测。我们已经训练了一个能够根据奥运游泳运动员的身高、性别和出生年份数据预测体重的模型。
- en: Mark Spitz is a nine-time Olympic swimming champion, and he won seven gold medals
    at the 1972 Olympics. He was born in 1950 and, according to his Wikipedia page,
    is 183cm tall and weighs 73kg. Let's see what our model predicts as his weight.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Mark Spitz是九届奥运游泳冠军，他在1972年奥运会上获得了七枚金牌。他出生于1950年，根据他的维基百科页面，他身高183厘米，体重73公斤。让我们看看我们的模型预测他的体重是多少。
- en: 'Our multiple regression model requires these values to be presented as a matrix
    form. Each of the parameters needs to be provided in the order in which the model
    learned the features so that the correct coefficient is applied. After the bias
    term, our feature vector needs to contain height, gender, and year of birth in
    the same units as our model was trained:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的多重回归模型要求这些值以矩阵形式呈现。每个参数需要按模型学习特征的顺序提供，以便正确地应用系数。在偏置项之后，我们的特征向量需要包含身高、性别和出生年份，并且这些单位与我们的模型训练时保持一致：
- en: '![Prediction](img/7180OS_03_63.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![预测](img/7180OS_03_63.jpg)'
- en: 'Our *β* matrix contains the coefficients for each of these features:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的*β*矩阵包含了这些特征的系数：
- en: '![Prediction](img/7180OS_03_64.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![预测](img/7180OS_03_64.jpg)'
- en: 'The prediction of our model will be the sum of the products of the *β* coefficients
    and features *x* for each row:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模型的预测将是每行*β*系数和特征*x*的乘积之和：
- en: '![Prediction](img/7180OS_03_65.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![预测](img/7180OS_03_65.jpg)'
- en: Since matrix multiplication produces each element by adding up the products
    of the rows and columns of each matrix respectively, producing our result is as
    simple as multiplying the transpose of *β* with the *x[spitz]* vector.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 由于矩阵乘法是通过分别加总每个矩阵的行和列的乘积来生成每个元素，因此生成我们的结果和将*β*的转置与*x[spitz]*向量相乘一样简单。
- en: 'Recall that the dimensions of the resulting matrix will be the number of rows
    from the first matrix and the number of columns from the second matrix:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，结果矩阵的维度将是第一个矩阵的行数和第二个矩阵的列数：
- en: '![Prediction](img/7180OS_03_66.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![预测](img/7180OS_03_66.jpg)'
- en: '![Prediction](img/7180OS_03_67.jpg) is a product of a ![Prediction](img/7180OS_03_68.jpg)
    matrix and an ![Prediction](img/7180OS_03_69.jpg) matrix. The result is a ![Prediction](img/7180OS_03_70.jpg)
    matrix:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![预测](img/7180OS_03_67.jpg) 是一个![预测](img/7180OS_03_68.jpg)矩阵和一个![预测](img/7180OS_03_69.jpg)矩阵的乘积。结果是一个![预测](img/7180OS_03_70.jpg)矩阵：'
- en: '![Prediction](img/7180OS_03_270.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![预测](img/7180OS_03_270.jpg)'
- en: 'Calculating this in code is very simple:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 用代码计算这个非常简单：
- en: '[PRE40]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We call `first` to return the first (and only) element from the matrix rather
    than the matrix itself:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`first`来返回矩阵中的第一个（也是唯一的）元素，而不是整个矩阵：
- en: '[PRE41]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This returns `84.21`, corresponding to a expected weight of 84.21 kg. This is
    much heavier than Mark Spitz's reported weight of 73 kg. Our model doesn't appear
    to have performed very well.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了`84.21`，对应于预期体重为84.21公斤。这比Mark Spitz报告的体重73公斤要重得多。我们的模型似乎表现得不太好。
- en: The confidence interval of a prediction
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预测的置信区间
- en: We previously calculated confidence intervals for population parameters. It's
    also possible to construct confidence intervals for a specific prediction called
    **prediction interval**. The prediction interval quantifies the amount of uncertainty
    in the prediction by providing a minimum and a maximum value between which the
    true value is expected to fall with a certain probability.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前计算了总体参数的置信区间。也可以为一个特定的预测构建置信区间，称为**预测区间**。预测区间通过提供一个最小值和最大值，量化了预测中的不确定性，表示真实值将在一定概率下落在这两个值之间。
- en: The prediction interval for ![The confidence interval of a prediction](img/7180OS_03_23.jpg)
    is wider than the confidence interval for a population parameter such as *µ*,
    the mean. This is because the confidence interval simply needs to account for
    our uncertainty in estimating the mean, while the prediction interval must also
    take into account the variance of *y* from the mean.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '![预测的置信区间](img/7180OS_03_23.jpg)的预测区间比总体参数如*µ*（均值）的置信区间更宽。这是因为置信区间仅需考虑我们在估计均值时的不确定性，而预测区间则必须考虑*
    y*的方差与均值的偏差。'
- en: '![The confidence interval of a prediction](img/7180OS_03_280.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![预测的置信区间](img/7180OS_03_280.jpg)'
- en: 'The previous image shows the relationship between the outer prediction interval
    and the inner confidence interval. We can calculate the prediction interval using
    the following formula:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片展示了外部预测区间与内部置信区间之间的关系。我们可以使用以下公式计算预测区间：
- en: '![The confidence interval of a prediction](img/7180OS_03_71.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![预测的置信区间](img/7180OS_03_71.jpg)'
- en: 'Here, ![The confidence interval of a prediction](img/7180OS_03_72.jpg) is the
    prediction, plus or minus the interval. We''re making use of the *t*-distribution,
    where the degree of freedom is ![The confidence interval of a prediction](img/7180OS_03_73.jpg),
    the sample size minus the number of parameters. This is the same as we calculated
    for the *F*-test previously. While the formula may look intimidating, it''s relatively
    straightforward to translate into the code shown in the following example, which
    calculates the 95 percent prediction interval:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![预测的置信区间](img/7180OS_03_72.jpg)是预测值，正负区间。我们使用的是*t*-分布，其中自由度为![预测的置信区间](img/7180OS_03_73.jpg)，即样本大小减去参数数量。这与我们之前为*F*检验计算的自由度相同。尽管公式看起来可能令人生畏，但实际上它可以相对容易地转化为以下代码示例，这段代码计算了95%的预测区间：
- en: '[PRE42]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Since the *t*-statistic is parameterized by the degree of freedom of the error,
    it takes into account the uncertainty present in the model.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*t*-统计量是由误差的自由度来参数化的，因此它考虑了模型中的不确定性。
- en: If we'd like to calculate the confidence interval for the mean instead of the
    prediction interval, we can simply omit the addition of one to `se-y` while calculating
    `t-stat`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想计算均值的置信区间而不是预测区间，只需在计算`t-stat`时省略将1加到`se-y`这一操作。
- en: 'The preceding code can be used to generate the following chart, showing how
    the prediction interval varies with the value of the independent variable:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以用来生成以下图表，展示了预测区间如何随着自变量的值变化：
- en: '![The confidence interval of a prediction](img/7180OS_03_290.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![预测的置信区间](img/7180OS_03_290.jpg)'
- en: 'In the preceding graph, a model trained on a sample size of five shows how
    the 95 percent prediction interval increases as we move further from the mean
    height. Applying the previous formula to Mark Spitz yields the following:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，基于样本大小为五的模型显示了当我们离均值身高越来越远时，95%预测区间如何增大。将之前的公式应用于马克·斯皮茨，得到如下结果：
- en: '[PRE43]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This returns the range from 72.7 kg to 97.4 kg. This range just includes Mark's
    weight of 73 kg, so our prediction is within the 95 percent prediction interval.
    It's uncomfortably close to the bounds though.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回的体重范围是从72.7千克到97.4千克。这个范围恰好包括了马克的体重73千克，因此我们的预测在95%的预测区间内。尽管如此，这个预测结果仍然非常接近区间的边界。
- en: Model scope
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型范围
- en: Mark Spitz was born in 1950, decades before even the oldest swimmer in the 2012
    Olympic Games. By trying to predict Mark's weight using his year of birth, we're
    guilty of trying to extrapolate too far beyond our training data. We have exceeded
    the scope of our model.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 马克·斯皮茨出生于1950年，比2012年奥运会中最年长的游泳选手还要早几十年。试图用马克的出生年份来预测他的体重，我们就是在尝试超出训练数据的范围进行外推。这超出了我们模型的范围。
- en: There is a second way in which this is problematic. Our data was based entirely
    on swimmers currently competing at international standard, whereas Mark has not
    competed for many years. In other words, Mark is now not a part of the population
    we have trained our model on. To fix both of these problems, we need to look up
    Mark's details from 1979, when he was a competition swimmer.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第二个问题。我们的数据完全基于目前在国际标准比赛中竞争的游泳选手，而马克已经多年没有参加比赛。换句话说，马克现在不属于我们训练模型时的样本群体。为了解决这两个问题，我们需要查找1979年马克作为比赛游泳选手的详细资料。
- en: According to [http://www.topendsports.com/athletes/swimming/spitz-mark.htm](http://www.topendsports.com/athletes/swimming/spitz-mark.htm),
    in 1972, 22-year-old Mark Spitz was 185 cm tall and he weighed 79 kg.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[http://www.topendsports.com/athletes/swimming/spitz-mark.htm](http://www.topendsports.com/athletes/swimming/spitz-mark.htm)，1972年，22岁的马克·斯皮茨身高185厘米，体重79千克。
- en: Note
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Selecting the right features is one of the most important prerequisites to get
    good results from any predictive algorithm.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的特征是从任何预测算法中获得良好结果的最重要前提之一。
- en: You should strive to select features not only on the basis of their predictive
    power, but also on their relevance to the domain being modeled.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在选择特征时，不仅依据其预测能力，还要考虑它们与所建模领域的相关性。
- en: The final model
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终模型
- en: Although it has a slightly lower *R²*, let's retrain our model with age in place
    of year of birth as a feature. This will allow us to easily predict weights for
    past and future unseen data, as it models more closely the variable we suspect
    of having a causal relationship with weight.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它的*R²*稍低，但让我们将模型重新训练，将年龄替代出生年份作为特征。这将使我们能够轻松预测过去和未来未见数据的体重，因为它更贴近我们怀疑与体重有因果关系的变量。
- en: 'This yields *β* of approximately:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了大约*β*的值：
- en: '![The final model](img/7180OS_03_74.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![The final model](img/7180OS_03_74.jpg)'
- en: 'Our features for Mark in the 1972 games are:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在1972年比赛中的马可特征是：
- en: '![The final model](img/7180OS_03_75.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![The final model](img/7180OS_03_75.jpg)'
- en: 'We can use them to predict his competitive weight with the following code:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码预测他的竞争体重：
- en: '[PRE44]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This returns `78.47`, corresponding to a prediction of 78.47 kg. This is now
    very close to Mark's true competition weight of 79 kg.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回`78.47`，对应于78.47公斤的预测值。这个值现在非常接近马可的真实比赛体重79公斤。
- en: Summary
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've learned about how to determine whether two or more variables
    share a linear relationship. We've seen how to express the strength of their correlation
    with *r* and how well a linear model explains the variance with *R²* and ![Summary](img/7180OS_03_57.jpg).
    We've also performed hypothesis tests and calculated confidence intervals to infer
    the range of the true population parameter for correlation, ![Summary](img/7180OS_03_08.jpg).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何确定两个或多个变量是否存在线性关系。我们看到了如何用*r*来表达它们之间的相关强度，以及如何用*R²*和![Summary](img/7180OS_03_57.jpg)来衡量线性模型解释方差的效果。我们还进行了假设检验并计算了置信区间，以推断相关性的真实总体参数范围，![Summary](img/7180OS_03_08.jpg)。
- en: Having established a correlation between variables, we were able to build a
    predictive model using ordinary least squares regression and simple Clojure functions.
    We then generalized our approach using Incanter's matrix functionality and the
    normal equation. This simple model demonstrated the principles of machine learning
    by determining the model parameters *β*, inferred from our sample data, that could
    be used to make predictions. Our model was able to predict an expected weight
    for a new athlete that fell well within the prediction interval of the true value.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了变量之间的相关性后，我们使用普通最小二乘回归和简单的Clojure函数构建了一个预测模型。然后，我们使用Incanter的矩阵功能和正态方程推广了我们的方法。这个简单的模型通过确定从样本数据推断出的模型参数*β*来展示机器学习的原理，这些参数可以用来进行预测。我们的模型能够预测一个新运动员的预期体重，并且该预测值完全落在真实值的预测区间内。
- en: In the next chapter, we'll see how similar techniques can be used to classify
    data into discrete classes. We'll demonstrate a variety of different approaches
    particular to classification as well as introduce a very general technique for
    parameter optimization that works for a variety of machine learning models, including
    linear regression.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用类似的技术将数据分类为离散类别。我们将展示多种与分类相关的不同方法，并介绍一种适用于多种机器学习模型的非常通用的参数优化技术，包括线性回归。
