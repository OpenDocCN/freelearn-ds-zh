- en: <st c="0">5</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">5</st>
- en: <st c="2">Solving Recurrence Functions</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">解决递归函数</st>
- en: '<st c="30">In the previous chapter, we discussed the challenges of analyzing
    recursive algorithms, particularly in estimating their computational complexity.</st>
    <st c="178">In this chapter, we will explore three primary methods for solving
    recurrence functions: substitution method, master theorem, and visualization techniques
    using</st> <st c="339">recursion trees.</st>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30">在上一章中，我们讨论了分析递归算法的挑战，特别是在估算其计算复杂度时。</st> <st c="178">在本章中，我们将探索三种解决递归函数的主要方法：代入法、主定理以及使用</st>
    <st c="339">递归树的可视化技术。</st>
- en: <st c="355">The substitution method involves constructing rigorous proofs to
    solve recurrence functions.</st> <st c="449">This method, while sometimes intricate,
    is versatile and can handle a wide range of recurrence functions.</st> <st c="555">In
    the substitution method, we employ various techniques, including mathematical
    induction, to validate</st> <st c="659">our solutions.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="355">代入法通过构造严谨的证明来解决递归函数。</st> <st c="449">该方法虽然有时较为复杂，但具有很高的通用性，能够处理多种类型的递归函数。</st>
    <st c="555">在代入法中，我们使用了多种技术，包括数学归纳法，来验证</st> <st c="659">我们的解法。</st>
- en: <st c="673">The master theorem, also known as the master method, provides a
    systematic approach to determining the complexity of a recursive algorithm based
    on the parameters of its recurrence function.</st> <st c="865">This theorem offers
    a set of straightforward rules, making it a powerful tool for analyzing many common</st>
    <st c="969">recurrence functions.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="673">主定理，也称为主方法，为确定递归算法的复杂度提供了一种系统化的方式，依据递归函数的参数。</st> <st c="865">该定理提供了一套简明的规则，成为分析许多常见</st>
    <st c="969">递归函数的强大工具。</st>
- en: <st c="990">Lastly, recursion trees help visualize the complexity of a problem
    by breaking down the recurrence into a tree structure.</st> <st c="1113">Although
    recursion trees do not provide direct proofs, they offer valuable insights and
    intuitive understanding that can guide us toward a</st> <st c="1252">formal solution.</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="990">最后，递归树通过将递归分解为树状结构，帮助可视化问题的复杂度。</st> <st c="1113">虽然递归树并未提供直接的证明，但它们提供了有价值的洞察和直观理解，可以引导我们找到</st>
    <st c="1252">正式的解决方案。</st>
- en: <st c="1268">Throughout this chapter, we will thoroughly examine the limitations
    of each method and present a comprehensive set of examples for practical application.</st>
    <st c="1423">By the end, readers will have a deeper understanding of how to effectively
    solve recurrence functions using</st> <st c="1531">these techniques.</st>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1268">在本章中，我们将彻底审视每种方法的局限性，并展示一整套实际应用的综合示例。</st> <st c="1423">到最后，读者将更加深入地理解如何有效地使用</st>
    <st c="1531">这些技术解决递归函数。</st>
- en: <st c="1548">We will discuss the following topics in</st> <st c="1589">this
    chapter:</st>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1548">我们将在</st> <st c="1589">本章中讨论以下主题：</st>
- en: <st c="1602">The</st> <st c="1607">substitution method</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1602">代入法</st> <st c="1607">方法</st>
- en: <st c="1626">Recursion tree as a</st> <st c="1647">visualization technique</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1626">递归树作为一种</st> <st c="1647">可视化技术</st>
- en: <st c="1670">The</st> <st c="1675">master theorem</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1670">主定理</st> <st c="1675">方法</st>
- en: <st c="1689">Beyond the master theorem – the</st> <st c="1722">Akra-Bazzi method</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1689">超越主定理——</st> <st c="1722">Akra-Bazzi 方法</st>
- en: <st c="1739">The substitution method</st>
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1739">代入法</st>
- en: <st c="1763">The</st> **<st c="1768">substitution method</st>** <st c="1787">encompasses</st>
    <st c="1800">a variety of techniques, including induction, to provide proofs for
    recurrence functions.</st> <st c="1890">Often, we need to be innovative in making
    variable substitutions to transform the recurrence function into a form for which
    we already know the solution.</st> <st c="2044">One key characteristic of this
    method is its flexibility – there can be multiple approaches to solving the same
    recurrence.</st> <st c="2168">Although it does not offer a uniform solution for
    all problems, the substitution method is a powerful tool.</st> <st c="2276">In
    fact, even the master theorem (discussed in the next section) is proven using</st>
    <st c="2357">this method.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1763">**<st c="1768">替换法</st>**<st c="1787">包括</st><st c="1800">一系列技术，包括归纳法，用于为递归函数提供证明。</st><st
    c="1890">通常情况下，我们需要在进行变量替换时富有创新性，将递归函数转化为我们已知解的形式。</st><st c="2044">这种方法的一个关键特征是其灵活性
    - 解决同一递归可能有多种方法。</st><st c="2168">虽然它并非为所有问题提供统一解决方案，但替换法是一个强大的工具。</st><st c="2276">事实上，即使是主定理（在下一节中讨论）也是通过</st><st
    c="2357">这种方法证明的。</st>
- en: <st c="2369">By employing the substitution method, we can address a wide range
    of recurrence functions.</st> <st c="2461">The process typically involves hypothesizing
    a solution, substituting it into the original recurrence, and then using induction
    to prove that the hypothesis is correct.</st> <st c="2630">This approach allows
    for creativity and adaptability, making it a valuable technique in algorithm analysis.</st>
    <st c="2738">While the substitution method may require careful thought and ingenuity,
    it provides a robust framework for tackling complex recurrences.</st> <st c="2876">This
    method’s versatility and power underscore its importance in the broader context
    of algorithm design</st> <st c="2981">and analysis.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2369">通过采用替换法，我们可以处理各种递归函数。</st><st c="2461">这个过程通常涉及假设一个解，将其代入原始递归，然后使用归纳法证明假设是正确的。</st><st
    c="2630">这种方法允许创造性和适应性，使其成为算法分析中宝贵的技术。</st><st c="2738">虽然替换法可能需要深思熟虑和机智，但它为处理复杂递归提供了一个稳健的框架。</st><st
    c="2876">这种方法的多功能性和强大性突显了它在算法设计</st><st c="2981">和分析中的重要性。</st>
- en: <st c="2994">Perhaps the best way to explore the substitution method is through
    practical application with several examples.</st> <st c="3107">By working through
    a variety of recurrence functions, we can better understand the nuances and techniques
    involved in this method.</st> <st c="3238">This hands-on approach will not only
    illustrate the versatility and power of the substitution method but also demonstrate
    how it can be applied to solve different types of problems effectively.</st> <st
    c="3432">Let’s examine some examples to see this method in action and gain a deeper
    appreciation of its utility in algorithm analysis.</st> <st c="3558">Readers should
    note that in this chapter, and throughout the rest of the book, when we refer
    to</st> *<st c="3654">solving a recurrence function</st>*<st c="3683">, we mean
    estimating the complexity or rate of growth.</st> <st c="3738">This generally
    involves determining</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/524.png)
    <st c="3774"><st c="3775">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/525.png)<st
    c="3779"><st c="3785">, and in rare</st> <st c="3799">cases,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="normal">Ω</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/526.png)<st
    c="3806"><st c="3807">.</st></st></st></st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2994">探索替代法的最好方式，也许是通过实践应用多个例子。</st> <st c="3107">通过处理各种递归函数，我们可以更好地理解这一方法中的细节和技巧。</st>
    <st c="3238">这种实践方式不仅能展示替代法的多样性和强大功能，还能证明它如何有效地应用于解决不同类型的问题。</st> <st c="3432">让我们通过一些例子来观察这种方法的实际应用，从而更深刻地理解它在算法分析中的价值。</st>
    <st c="3558">读者应注意，在本章以及本书的其他章节中，当我们提到</st> *<st c="3654">解决递归函数</st>*<st c="3683">时，我们指的是估算复杂度或增长速率。</st>
    <st c="3738">这通常涉及到确定</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/524.png)
    <st c="3774"><st c="3775">或</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/525.png)<st
    c="3779"><st c="3785">，在少数</st> <st c="3799">情况下，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">Ω</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/526.png)<st
    c="3806"><st c="3807">。</st></st></st></st>
- en: <st c="3808">Iteration approach or unrolling the recurrence</st>
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3808">迭代法或展开递归</st>
- en: <st c="3855">In the</st> <st c="3863">upcoming examples, the substitution method
    is applied by using the iterative approach, also known as</st> **<st c="3964">unrolling
    the recurrence function</st>**<st c="3997">. This</st> <st c="4004">technique
    involves expanding the recurrence step by step to reveal a pattern, which helps
    in deriving a closed-form solution.</st> <st c="4130">By iteratively substituting
    back into the original recurrence, we can systematically identify how the terms
    evolve and</st> <st c="4249">accumulate, leading to a clearer understanding of
    the function’s growth behavior.</st> <st c="4331">This method is particularly
    useful for solving and simplifying complex</st> <st c="4402">recurrence functions.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3855">在接下来的例子中，替代法通过使用迭代法应用，也称为</st> **<st c="3964">展开递归函数</st>**<st
    c="3997">。这一技术涉及逐步展开递归，揭示出一种模式，有助于推导出闭式解。</st> <st c="4004">通过将递归逐步代入原始递归，我们可以系统地识别项是如何发展的，并</st>
    <st c="4249">积累，进而更清楚地理解函数的增长行为。</st> <st c="4331">这种方法对于解决和简化复杂的</st> <st c="4402">递归函数尤其有用。</st>
- en: '**<st c="4423">Example 5.1</st>**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="4423">示例 5.1</st>**'
- en: <st c="4435">Solve the following subtractive recurrence function:</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/527.png)<st
    c="4489"><st c="4505">.</st></st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4435">求解以下减法递归函数：</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/527.png)<st
    c="4489"><st c="4505">.</st></st>
- en: '**<st c="4506">Solution</st>**<st c="4515">: To solve the recurrence function,
    we can use the iteration method to find a pattern and derive a closed-form solution.</st>
    <st c="4637">Let’s start by expanding the recurrence step</st> <st c="4682">by
    step:</st>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="4506">解答</st>**<st c="4515">：为了求解递归函数，我们可以使用迭代法找到模式，并推导出闭式解。</st>
    <st c="4637">我们从扩展递归步骤开始</st> <st c="4682">逐步进行：</st>'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/528.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/528.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>4</mn><mo>)</mo><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo></mrow></mrow></mrow></math>](img/529.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>4</mn><mo>)</mo><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo></mrow></mrow></mrow></math>](img/529.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>4</mn><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>6</mn><mo>)</mo><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>4</mn><mo>)</mo></mrow></mrow></mrow></math>](img/530.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>4</mn><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>6</mn><mo>)</mo><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>4</mn><mo>)</mo></mrow></mrow></mrow></math>](img/530.png)'
- en: <st c="4760">...</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4760">...</st>
- en: <st c="4763">Substitute the following back into the</st> <st c="4803">original
    recurrence:</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4763">将以下内容代入</st> <st c="4803">原始递归中：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/527.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/527.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/532.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/532.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/533.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/533.png)'
- en: <st c="4900">...</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4900">...</st>
- en: <st c="4903">Continuing this pattern, we get</st> <st c="4936">the following:</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4903">继续这个模式，我们得到</st> <st c="4936">如下结果：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mo>⋯</mml:mo><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/534.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mo>⋯</mml:mo><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/534.png)'
- en: <st c="4952">We stop when</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:math>](img/535.png)
    <st c="4965"><st c="4966">reaches the base case, which we assume is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:math>](img/536.png)
    <st c="5009"><st c="5010">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/537.png)<st
    c="5014"><st c="5020">. For simplicity, let’s assume</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>0</mn></mrow></mrow></mrow></math>](img/538.png)<st
    c="5051"><st c="5052">. So, the pattern becomes</st> <st c="5078">the following:</st></st></st></st></st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4952">我们在</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:math>](img/535.png)
    <st c="4965"><st c="4966">到达基准情况时停止，我们假设基准情况是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:math>](img/536.png)
    <st c="5009"><st c="5010">或</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/537.png)<st
    c="5014"><st c="5020">。为了简化，假设</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>0</mn></mrow></mrow></mrow></math>](img/538.png)<st
    c="5051"><st c="5052">。所以，模式变为</st> <st c="5078">如下：</st></st></st></st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/539.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/539.png)'
- en: <st c="5094">Since</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>0</mn></mrow></mrow></mrow></math>](img/538.png)<st
    c="5100"><st c="5101">, we have</st> <st c="5111">the following:</st></st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5094">由于</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>0</mn></mrow></mrow></mrow></math>](img/538.png)<st
    c="5100"><st c="5101">，我们得到</st> <st c="5111">如下：</st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/541.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/541.png)'
- en: <st c="5155">To find the number of terms in the sum, we solve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>−</mo><mn>2</mn><mi>k</mi><mo>=</mo><mn>0</mn></mrow></mrow></math>](img/542.png)<st
    c="5204"><st c="5205">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/543.png)<st
    c="5207"><st c="5208">.</st></st></st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5155">为了求和的项数，我们解方程</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>−</mo><mn>2</mn><mi>k</mi><mo>=</mo><mn>0</mn></mrow></mrow></math>](img/542.png)<st
    c="5204"><st c="5205">：</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/543.png)<st
    c="5207"><st c="5208">。</st></st></st>
- en: <st c="5209">Thus, the sum becomes</st> <st c="5232">the following:</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5209">因此，和为</st> <st c="5232">如下：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/544.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/544.png)'
- en: <st c="5273">This is an</st> <st c="5284">arithmetic series where the first
    term</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mi>n</mi></mrow></mrow></math>](img/545.png)
    <st c="5323"><st c="5324">and the last term</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:math>](img/546.png)<st
    c="5343"><st c="5344">. The number of terms</st> <st c="5366">is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/547.png)<st
    c="5369"><st c="5370">.</st></st></st></st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5273">这是一个</st> <st c="5284">等差数列，其中第一项</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mi>n</mi></mrow></mrow></math>](img/545.png)
    <st c="5323"><st c="5324">和最后一项</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:math>](img/546.png)<st
    c="5343"><st c="5344">。项数</st> <st c="5366">是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/547.png)<st
    c="5369"><st c="5370">。</st></st></st></st>
- en: <st c="5371">The sum of an arithmetic series is given by</st> <st c="5416">the
    following:</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5371">一个等差数列的和由以下公式给出：</st> <st c="5416">如下所示：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>S</mi><mo>=</mo><mfrac><mrow><mtext>number</mtext><mtext>of</mtext><mtext>terms</mtext></mrow><mn>2</mn></mfrac><mo>×</mo><mfenced
    open="(" close=")"><mrow><mtext>first</mtext><mtext>term</mtext><mo>+</mo><mtext>last</mtext><mtext>term</mtext></mrow></mfenced></mrow></mrow></math>](img/548.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>S</mi><mo>=</mo><mfrac><mrow><mtext>项数</mtext><mtext>的</mtext><mtext>总和</mtext></mrow><mn>2</mn></mfrac><mo>×</mo><mfenced
    open="(" close=")"><mrow><mtext>第一项</mtext><mtext>的</mtext><mtext>和</mtext><mo>+</mo><mtext>最后一项</mtext><mtext>的</mtext><mtext>和</mtext></mrow></mfenced></mrow></mrow></math>](img/548.png)'
- en: <st c="5480">So, the following is</st> <st c="5501">the case:</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，以下是<st c="5480">情况：</st><st c="5501">所示：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>×</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/549.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>×</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/549.png)'
- en: <st c="5528">Therefore, the closed-form solution for the recurrence function
    is</st> <st c="5595">as follows:</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，递推函数的闭式解为<st c="5528">如下：</st><st c="5595">所示：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mfrac><msup><mi>n</mi><mn>2</mn></msup><mn>4</mn></mfrac><mo>+</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow></mrow></math>](img/550.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mfrac><msup><mi>n</mi><mn>2</mn></msup><mn>4</mn></mfrac><mo>+</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow></mrow></math>](img/550.png)'
- en: <st c="5608">This provides us with the</st> <st c="5634">asymptotic complexity</st>![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced open="("
    close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">θ</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mn>2</mn></msup></mfenced></mrow></mrow></math>](img/551.png)<st
    c="5655"><st c="5657">.</st></st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了<st c="5608">渐近复杂度</st><st c="5634">的分析</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">θ</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mn>2</mn></msup></mfenced></mrow></mrow></math>](img/551.png)<st
    c="5655"><st c="5657">。</st></st>
- en: <st c="5658">In the previous example, we demonstrated how to prove a subtractive
    recurrence function using the</st> <st c="5757">substitution method.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们演示了如何使用<st c="5658">替代法证明一个递减递推函数。</st><st c="5757">替代法。</st>
- en: '**<st c="5777">Example 5.2</st>**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 5.2**'
- en: <st c="5789">Solve the following subtractive recurrence function:</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/552.png)<st
    c="5843"><st c="5863">.</st></st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 解以下递减递推函数：！[<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/552.png)<st
    c="5843"><st c="5863">。</st></st>
- en: '**<st c="5864">Solution</st>**<st c="5873">: This recurrence function describes
    an algorithm where the problem of size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="5950"><st c="5999">is reduced to a subproblem of size</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:math>](img/554.png)<st
    c="6034"><st c="6035">. The work done outside of the recursive call is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/555.png)<st
    c="6084"><st c="6085">. We can solve this recurrence using the substitution method
    using iteration or unrolling</st> <st c="6175">the recurrence.</st></st></st></st>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="5864">解法</st>**<st c="5873">：这个递归函数描述了一个算法，其中大小为</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="5950"><st c="5999">的问题被减少到大小为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:math>](img/554.png)<st
    c="6034"><st c="6035">的子问题。递归调用外部的工作量是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/555.png)<st
    c="6084"><st c="6085">。我们可以使用迭代或展开法通过替换法来解决这个递归。</st></st></st></st>'
- en: <st c="6190">Let’s expand the recurrence a</st> <st c="6221">few times:</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6190">让我们展开这个递归</st> <st c="6221">几次：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/552.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/552.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/557.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/557.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/558.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/558.png)'
- en: <st c="6288">...</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6288">...</st>
- en: <st c="6291">If we continue</st> <st c="6306">this pattern, we eventually reach
    the base case</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/559.png)
    <st c="6355"><st c="6356">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:math>](img/560.png)
    <st c="6360"><st c="6361">(depending on how the base case is defined).</st> <st
    c="6407">Notice that we get a sum</st> <st c="6432">of squares:</st></st></st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6291">如果我们继续</st> <st c="6306">这个模式，我们最终会得到基本情况</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/559.png)
    <st c="6355"><st c="6356">或</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:math>](img/560.png)
    <st c="6360"><st c="6361">(取决于基本情况是如何定义的)。</st> <st c="6407">请注意，我们得到一个</st> <st
    c="6432">平方和：</st></st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>T</mi><mfenced open="(" close=")"><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></mfenced><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mo>…</mo><mo>+</mo><msup><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></mfenced><mn>2</mn></msup><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup></mrow></mrow></math>](img/561.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>T</mi><mfenced open="(" close=")"><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></mfenced><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mo>…</mo><mo>+</mo><msup><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></mfenced><mn>2</mn></msup><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup></mrow></mrow></math>](img/561.png)'
- en: <st c="6492">The sum of squares from 1 to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="6521"><st c="6570">is a</st> <st c="6575">well-known formula:</st></st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6492">从1到</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="6521"><st c="6570">的平方和是一个</st> <st c="6575">著名的公式：</st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mo>…</mo><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup><mo>=</mo><mfrac><mrow><mi>n</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mfenced
    open="(" close=")"><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced></mrow><mn>6</mn></mfrac></mrow></mrow></math>](img/563.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mo>…</mo><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup><mo>=</mo><mfrac><mrow><mi>n</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mfenced
    open="(" close=")"><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced></mrow><mn>6</mn></mfrac></mrow></mrow></math>](img/563.png)'
- en: <st c="6638">Therefore, the following is</st> <st c="6666">the case:</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6638">因此，以下是</st> <st c="6666">情况：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>T</mi><mfenced open="(" close=")"><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></mfenced><mo>+</mo><mfrac><mrow><mi>n</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mfenced
    open="(" close=")"><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced></mrow><mn>6</mn></mfrac></mrow></mrow></math>](img/564.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>T</mi><mfenced open="(" close=")"><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></mfenced><mo>+</mo><mfrac><mrow><mi>n</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mfenced
    open="(" close=")"><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced></mrow><mn>6</mn></mfrac></mrow></mrow></math>](img/564.png)'
- en: <st c="6712">The exact solution depends on the value of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>)</mo></mrow></mrow></mrow></math>](img/565.png)<st
    c="6755"><st c="6769">, which is in constant time (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/566.png)<st
    c="6798"><st c="6800">).</st> <st c="6803">Then, asymptotically, we can say</st>
    <st c="6836">the following:</st></st></st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6712">精确解依赖于</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>)</mo></mrow></mrow></mrow></math>](img/565.png)<st
    c="6755"><st c="6769">，它是常数时间（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/566.png)<st
    c="6798"><st c="6800">）。</st> <st c="6803">然后，从渐近意义上讲，我们可以说</st> <st c="6836">如下：</st></st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/567.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/567.png)'
- en: <st c="6864">In this example, to implement the substitution method, we iterate
    or unroll the recursion to identify the growth pattern.</st> <st c="6986">The
    recurrence function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/552.png)
    <st c="7010"><st c="7030">has a time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/569.png)<st
    c="7055"><st c="7062">. This indicates that the algorithm’s runtime grows cubically
    with the</st> <st c="7133">input size.</st></st></st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6864">在这个例子中，为了实现替代方法，我们对递归进行迭代或展开，以识别增长模式。</st> <st c="6986">递归函数</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/552.png)
    <st c="7010"><st c="7030">的时间复杂度为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/569.png)<st
    c="7055"><st c="7062">。这表明算法的运行时间随着输入规模的增加而立方增长。</st>
- en: '**<st c="7144">Example 5.3</st>**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="7144">示例 5.3</st>**'
- en: <st c="7156">Solve the following subtractive recurrence</st> <st c="7200">function:</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/570.png)<st
    c="7210"><st c="7227">.</st></st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7156">解决以下减法递归</st> <st c="7200">函数：</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/570.png)<st
    c="7210"><st c="7227">。</st></st>
- en: '**<st c="7228">Solution</st>**<st c="7237">: We can solve it by unrolling the
    recurrence and finding</st> <st c="7296">a pattern.</st>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="7228">解答</st>**<st c="7237">：我们可以通过展开递归并找到</st> <st c="7296">一个模式来解决它。</st>'
- en: <st c="7306">Let’s explain the recurrence function.</st> <st c="7346">This recurrence
    function involves a logarithmic decrease in the subproblem size.</st> <st c="7427">The
    recurrence function</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/571.png)
    <st c="7451"><st c="7469">describes an algorithm where the following is</st> <st
    c="7515">the case:</st></st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7306">让我们解释递归函数。</st> <st c="7346">这个递归函数涉及子问题规模的对数递减。</st> <st c="7427">递归函数</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/571.png)
    <st c="7451"><st c="7469">描述了一个算法，其中以下内容为</st> <st c="7515">情况：</st></st>
- en: <st c="7524">The problem of size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="7545"><st c="7594">is reduced to a subproblem of</st> <st c="7624">size</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/573.png)</st>
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="7524">问题的规模</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="7545"><st c="7594">被缩减为一个子问题，规模为</st> <st c="7624">大小为</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/573.png)</st>
- en: <st c="7636">The work done outside of the recursive call</st> <st c="7680">is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="7636">递归调用外的工作</st> <st c="7680">是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
- en: <st c="7732">Let’s use an iterative approach by unrolling the recurrence to
    understand the behavior of</st> <st c="7822">the function:</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7732">让我们通过展开递归来使用迭代方法，以理解</st> <st c="7822">该函数的行为：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/570.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/570.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/576.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/576.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/577.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/577.png)'
- en: <st c="7881">...</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7881">...</st>
- en: <st c="7884">Note that each</st> <st c="7900">iteration applies the logarithm
    function to the argument of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi></mml:math>](img/578.png)<st
    c="7960"><st c="7964">. The number of iterations before we reach a base case (such
    as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/579.png)<st
    c="8028"><st c="8029">) is roughly the number of times we can take the logarithm
    of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="8091"><st c="8140">before it becomes a constant.</st> <st c="8170">This
    is approximately</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msup><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mi
    mathvariant="normal">*</mi></msup><mi>n</mi></mrow></mrow></math>](img/581.png)<st
    c="8192"><st c="8193">(the</st> <st c="8198">iterated logarithm).</st></st></st></st></st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7884">注意，每次</st> <st c="7900">迭代都会将对数函数应用于</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi></mml:math>](img/578.png)<st
    c="7960"><st c="7964">的参数。达到基准情况（例如</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/579.png)<st
    c="8028"><st c="8029">）之前的迭代次数大约是我们可以对</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="8091"><st c="8140">进行对数运算的次数。</st> <st c="8170">这个次数大约是</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msup><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mi
    mathvariant="normal">*</mi></msup><mi>n</mi></mrow></mrow></math>](img/581.png)<st
    c="8192"><st c="8193">(迭代对数)。</st></st></st></st></st>
- en: <st c="8218">The total work done in all iterations is approximately</st> <st
    c="8274">the following:</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8218">所有迭代中的总工作量大约是</st> <st c="8274">如下所示：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>n</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mo>…</mo><mfenced
    open="(" close=")"><mrow><msup><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mi
    mathvariant="normal">*</mi></msup><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>s</mi></mrow></mfenced></mrow></mrow></math>](img/582.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>n</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mo>…</mo><mfenced
    open="(" close=")"><mrow><msup><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mi
    mathvariant="normal">*</mi></msup><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>s</mi></mrow></mfenced></mrow></mrow></math>](img/582.png)'
- en: <st c="8340">The dominant term in the preceding sum is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="8382"><st c="8383">. Each subsequent term grows much slower than the previous
    one due to the repeated application of the logarithm.</st> <st c="8496">Therefore,
    we can say</st> <st c="8518">the following:</st></st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8340">前述和式中的主导项是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="8382"><st c="8383">。由于重复应用对数运算，后续每个项的增长速度远慢于前一个项。</st> <st c="8496">因此，我们可以说</st>
    <st c="8518">如下所示：</st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/584.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/584.png)'
- en: <st c="8534">In the previous example, the algorithm’s runtime is primarily dominated
    by the work done outside the recursive calls (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/585.png)<st
    c="8652"><st c="8654">).</st> <st c="8657">The recursive calls do not significantly
    contribute to the overall runtime because the problem size decreases very rapidly
    with each recursion (logarithmically).</st> <st c="8819">The iterated logarithm
    (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>*</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:math>](img/586.png)<st
    c="8843"><st c="8850">) is a very slow-growing function.</st> <st c="8885">For
    all practical purposes, it can be considered a constant.</st> <st c="8946">This
    is why we can say that the time complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/587.png)
    <st c="8997"><st c="8998">even though there are</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>*</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:math>](img/588.png)
    <st c="9021"><st c="9027">terms in</st> <st c="9036">the summation.</st></st></st></st></st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8534">在前面的例子中，算法的运行时间主要由递归调用之外的工作决定（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/585.png)<st
    c="8652"><st c="8654">）。</st> <st c="8657">递归调用对总体运行时间的贡献不大，因为每次递归时问题规模会非常快速地减少（对数级别）。</st>
    <st c="8819">迭代对数（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>*</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:math>](img/586.png)<st
    c="8843"><st c="8850">) 是一个增长非常缓慢的函数。</st> <st c="8885">在所有实际应用中，它可以视为常数。</st>
    <st c="8946">这就是为什么我们可以说时间复杂度是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/587.png)
    <st c="8997"><st c="8998">尽管在</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>*</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:math>](img/588.png)
    <st c="9021"><st c="9027">求和中有</st> <st c="9036">项。</st></st></st></st></st>
- en: <st c="9050">Guessing and induction approach</st>
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="9050">猜测和归纳法</st>
- en: '*<st c="9082">Example 5.3</st>* <st c="9094">can be</st> <st c="9102">solved
    by guessing and induction approach.</st> <st c="9145">We solve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/589.png)
    <st c="9154"><st c="9171">using the substitution method by guessing that</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/590.png)
    <st c="9218"><st c="9219">and proving it by induction.</st> <st c="9249">In</st>
    *<st c="9252">Example 5.4</st>*<st c="9263">, we demonstrate how to solve a recurrence
    function using the guessing and</st> <st c="9338">induction approach.</st></st></st>'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="9082">示例 5.3</st>* <st c="9094">可以通过猜测和归纳法求解。</st> <st c="9102">我们通过猜测并使用替代法解决</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/589.png)
    <st c="9154"><st c="9171">假设</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/590.png)
    <st c="9218"><st c="9219">并通过归纳法证明它。</st> <st c="9249">在</st> *<st c="9252">示例
    5.4</st>*<st c="9263">中，我们展示了如何使用猜测和</st> <st c="9338">归纳法求解递归函数。</st></st></st>'
- en: '**<st c="9357">Example 5.4</st>**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="9357">示例 5.4</st>**'
- en: <st c="9369">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/591.png)
    <st c="9376"><st c="9394">by guessing</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/592.png)<st
    c="9406"><st c="9407">.</st></st></st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9369">求解</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/591.png)
    <st c="9376"><st c="9394">通过猜测</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/592.png)<st
    c="9406"><st c="9407">。</st></st></st>
- en: <st c="9408">We solve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/589.png)
    <st c="9418"><st c="9435">using the substitution method by guessing that</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/584.png)
    <st c="9482"><st c="9483">and then proving it</st> <st c="9504">by induction.</st></st></st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过猜测<st c="9408">来解决</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/589.png)
    <st c="9418"><st c="9435">使用替代法，假设</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/584.png)
    <st c="9482"><st c="9483">然后通过归纳法证明它</st> <st c="9504">来完成。</st></st></st>
- en: <st c="9517">Here is the</st> <st c="9530">step-by-step solution:</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9517">这是</st> <st c="9530">逐步解决方案：</st>
- en: '**<st c="9552">Guess</st>** **<st c="9559">the form</st>**<st c="9567">:</st>'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="9552">猜测</st>** **<st c="9559">形式</st>**<st c="9567">:</st>'
- en: <st c="9569">We guess that</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/584.png)<st
    c="9583"><st c="9584">. Specifically, let’s assume</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>n</mml:mi></mml:math>](img/596.png)
    <st c="9613"><st c="9614">for some</st> <st c="9624">constant</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo>></mml:mo><mml:mn>0</mml:mn></mml:math>](img/597.png)<st
    c="9633"><st c="9635">.</st></st></st></st>
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="9569">我们假设</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/584.png)<st
    c="9583"><st c="9584">。具体地，假设</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>n</mml:mi></mml:math>](img/596.png)
    <st c="9613"><st c="9614">对于某个</st> <st c="9624">常数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo>></mml:mo><mml:mn>0</mml:mn></mml:math>](img/597.png)<st
    c="9633"><st c="9635">。</st></st></st></st>
- en: '**<st c="9636">Base case</st>**<st c="9646">:</st>'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="9636">基础情况</st>**<st c="9646">:</st>'
- en: <st c="9648">We need to establish a base case.</st> <st c="9682">For small values
    of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)
    <st c="9702"><st c="9703">(e.g.,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/599.png)<st
    c="9711"><st c="9712">), the recurrence function simplifies.</st> <st c="9751">Assume</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/600.png)
    <st c="9758"><st c="9759">is a constant</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math>](img/601.png)<st
    c="9774"><st c="9775">. Since we are concerned with asymptotic behavior, we focus
    on larger values</st> <st c="9852">of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="9855"><st c="9904">.</st></st></st></st></st></st>
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="9648">我们需要建立一个基例。</st> <st c="9682">对于较小的</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)
    <st c="9702"><st c="9703">(例如，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/599.png)<st
    c="9711"><st c="9712">)，递推函数会简化。</st> <st c="9751">假设</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/600.png)
    <st c="9758"><st c="9759">是一个常数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math>](img/601.png)<st
    c="9774"><st c="9775">。</st> 由于我们关心的是渐进行为，我们专注于较大的</st> <st c="9852">值</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="9855"><st c="9904">。</st></st></st></st></st></st>
- en: '**<st c="9905">Induction hypothesis</st>**<st c="9926">:</st>'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="9905">归纳假设</st>**<st c="9926">：</st>'
- en: <st c="9928">Assume that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>k</mml:mi></mml:math>](img/603.png)
    <st c="9940"><st c="9941">holds for all</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>≤</mo><mi>n</mi></mrow></mrow></math>](img/604.png)<st
    c="9956"><st c="9957">. We need to show that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>n</mml:mi></mml:math>](img/596.png)
    <st c="9980"><st c="9981">also holds.</st></st></st></st>
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="9928">假设</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>k</mml:mi></mml:math>](img/603.png)
    <st c="9940"><st c="9941">对于所有</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>≤</mo><mi>n</mi></mrow></mrow></math>](img/604.png)<st
    c="9956"><st c="9957">成立。</st></st> 我们需要证明</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>n</mml:mi></mml:math>](img/596.png)
    <st c="9980"><st c="9981">也成立。</st></st></st></st>
- en: '**<st c="9992">Induction step</st>**<st c="10007">:</st>'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="9992">归纳步骤</st>**<st c="10007">：</st>'
- en: <st c="10009">Using the recurrence function, we</st> <st c="10043">have</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/570.png)<st
    c="10048"><st c="10065">.</st></st>
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="10009">使用递推函数，我们</st> <st c="10043">得出</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/570.png)<st
    c="10048"><st c="10065">。</st></st>
- en: <st c="10066">By the induction hypothesis,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/607.png)<st
    c="10096"><st c="10097">. Substituting this into the recurrence function, we</st>
    <st c="10150">get</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/608.png)<st
    c="10154"><st c="10155">.</st></st></st>
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据归纳假设，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/607.png)。将其代入递归函数中，我们得到![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/608.png)。
- en: <st c="10156">For our assumption</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>n</mml:mi></mml:math>](img/596.png)
    <st c="10176"><st c="10177">to hold, we need</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>n</mi><mo>≤</mo><mi>c</mi><mi>n</mi></mrow></mrow></math>](img/610.png)<st
    c="10195"><st c="10196">.</st></st></st>
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们的假设![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>n</mml:mi></mml:math>](img/596.png)，我们需要![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>n</mi><mo>≤</mo><mi>c</mi><mi>n</mi></mrow></mrow></math>](img/610.png)。
- en: '**<st c="10197">Simplify</st>** **<st c="10207">the inequality</st>**<st c="10221">:</st>'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**简化**不等式：'
- en: <st c="10223">To satisfy the inequality, we</st> <st c="10253">need</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>c</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math>](img/611.png)<st
    c="10258"><st c="10274">.</st></st>
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了满足这个不等式，我们需要![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>c</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math>](img/611.png)。
- en: <st c="10275">As</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/13.png)
    <st c="10279"><st c="10280">grows large,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/613.png)
    <st c="10294"><st c="10302">approaches</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>0</mml:mn></mml:math>](img/614.png)<st
    c="10313"><st c="10314">. Therefore, there exists a sufficiently large</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/13.png)
    <st c="10361"><st c="10362">such</st> <st c="10368">that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mo>≤</mml:mo><mml:mfrac><mml:mrow><mml:mi>c</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/616.png)<st
    c="10373"><st c="10374">.</st></st></st></st></st></st>
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随着![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/13.png)
    增大，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/613.png)
    接近![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>0</mml:mn></mml:math>](img/614.png)。因此，存在一个充分大的![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/13.png)，使得：
- en: '**<st c="10375">Choosing</st>** **<st c="10385">the constant</st>**<st c="10397">:</st>'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择** **常数**：'
- en: <st c="10399">We can choose</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi></mml:math>](img/233.png)
    <st c="10413"><st c="10414">such that the preceding condition holds for sufficiently
    large</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="10478"><st c="10527">. For instance, for</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/619.png)<st
    c="10547"><st c="10548">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mo>≤</mml:mo><mml:mn>1</mml:mn></mml:math>](img/620.png)<st
    c="10550"><st c="10551">.</st></st></st></st></st>
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以选择![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi></mml:math>](img/233.png)
    使得前述条件在充分大的![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)下成立。例如，对于![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/619.png)，有：
- en: <st c="10552">This</st> <st c="10558">inequality holds for sufficiently large</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="10598"><st c="10599">. Therefore, our assumption that</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/622.png)
    <st c="10632"><st c="10633">is valid.</st> <st c="10644">Thus, we have shown that
    the solution to the</st> <st c="10689">recurrence is</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>T</mi><mfenced open="(" close=")"><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfenced><mo>+</mo><mi>n</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi>T</mi><mfenced open="("
    close=")"><mi>n</mi></mfenced><mo>=</mo><mi>O</mi><mfenced open="(" close=")"><mi>n</mi></mfenced></mrow></mrow></math>](img/623.png)<st
    c="10702"><st c="10735">.</st></st></st></st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10552">这个</st> <st c="10558">不等式在足够大的</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="10598"><st c="10599">时成立。因此，我们的假设</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/622.png)
    <st c="10632"><st c="10633">是有效的。</st> <st c="10644">因此，我们已经证明了该递归的解是</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced open="("
    close=")"><mi>n</mi></mfenced><mo>=</mo><mi>T</mi><mfenced open="(" close=")"><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfenced><mo>+</mo><mi>n</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi>T</mi><mfenced open="("
    close=")"><mi>n</mi></mfenced><mo>=</mo><mi>O</mi><mfenced open="(" close=")"><mi>n</mi></mfenced></mrow></mrow></math>](img/623.png)<st
    c="10702"><st c="10735">。</st></st></st></st>
- en: <st c="10736">By this method of guessing and using induction, we confirmed that
    our initial guess was correct and that the complexity of the recurrence is linear
    in terms</st> <st c="10894">of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="10897"><st c="10946">.</st></st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10736">通过这种猜测和归纳的方法，我们确认了最初的猜测是正确的，并且该递归的复杂度是线性的</st> <st c="10894">关于</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="10897"><st c="10946">。</st></st>
- en: <st c="10947">The guessing step in the guessing and induction method is a critical
    part of solving recurrence functions It involves making an educated hypothesis
    about the form of the solution based on the structure of the recurrence function.</st>
    <st c="11178">Here’s how the guessing step is</st> <st c="11210">typically done:</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10947">猜测与归纳法中的猜测步骤是求解递归函数的关键部分。它涉及根据递归函数的结构对解的形式做出有根据的假设。</st> <st c="11178">以下是猜测步骤的</st>
    <st c="11210">常规操作：</st>
- en: '**<st c="11225">Understanding the recurrence function</st>**<st c="11263">:
    We begin by closely examining the recurrence function.</st> <st c="11321">We look
    at the components, such as how the problem size reduces in each recursive call
    and the non-recursive cost function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/625.png)<st
    c="11444"><st c="11450">. Then, we compare the recurrence to familiar patterns,
    such as those seen in common algorithms (e.g., divide-and-conquer algorithms such
    as merge sort or</st> <st c="11605">binary search).</st></st>'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="11225">理解递归函数</st>**<st c="11263">：我们首先仔细检查递归函数。</st> <st c="11321">我们查看其中的各个组成部分，例如在每次递归调用中问题规模的变化以及非递归的成本函数</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/625.png)<st
    c="11444"><st c="11450">。然后，我们将递归函数与熟悉的模式进行比较，比如常见算法中的模式（例如，归并排序或</st> <st c="11605">二分查找）</st></st>'
- en: '**<st c="11620">Analyzing the growth rate</st>**<st c="11646">: We consider
    the terms in the recurrence function to infer how they might contribute to the
    overall complexity.</st> <st c="11760">For instance, if the recurrence involves
    terms such as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/626.png)
    <st c="11815"><st c="11816">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/627.png)<st
    c="11820"><st c="11821">, we might guess a logarithmic component in the solution
    since each step reduces the problem size by a factor.</st> <st c="11932">If the
    recurrence includes an additive linear term, such as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="11992"><st c="12041">, this suggests the solution might involve a linear or
    non-linear</st> <st c="12107">growth</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:math>](img/629.png)<st
    c="12114"><st c="12120">.</st></st></st></st></st>'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="11620">分析增长率</st>**<st c="11646">：我们考虑递归函数中的项，以推测它们如何贡献于整体复杂度。</st>
    <st c="11760">例如，如果递归涉及如下项</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/626.png)
    <st c="11815"><st c="11816">或</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/627.png)<st
    c="11820"><st c="11821">，我们可能会猜测解中包含一个对数项，因为每一步都将问题规模减少一个倍数。</st> <st c="11932">如果递归包括一个加法线性项，例如</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="11992"><st c="12041">，这表明解可能涉及线性或非线性的</st> <st c="12107">增长</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:math>](img/629.png)<st
    c="12114"><st c="12120">。</st></st></st></st></st>'
- en: '**<st c="12121">Leveraging experience and patterns</st>**<st c="12156">: We
    use our knowledge of common recurrence functions and their solutions.</st> <st
    c="12232">For example, if the recurrence looks like</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mi>n</mml:mi></mml:math>](img/630.png)<st
    c="12274"><st c="12287">, we might guess</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/631.png)
    <st c="12304"><st c="12320">because this form is typical for divide-and-conquer
    algorithms.</st> <st c="12384">For the recurrence</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mn>1</mml:mn></mml:math>](img/632.png)<st
    c="12403"><st c="12404">, we might guess</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/633.png)
    <st c="12421"><st c="12422">because each step reduces the problem size by one
    with a</st> <st c="12480">constant cost.</st></st></st></st></st>'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12121">利用经验和模式</st>**<st c="12156">：我们使用对常见递推函数及其解的了解。</st> <st c="12232">例如，如果递推式看起来像</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mi>n</mml:mi></mml:math>](img/630.png)<st
    c="12274"><st c="12287">，我们可能猜测</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/631.png)
    <st c="12304"><st c="12320">，因为这个形式对于分治算法来说是典型的。</st> <st c="12384">对于递推式</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mn>1</mml:mn></mml:math>](img/632.png)<st
    c="12403"><st c="12404">，我们可能猜测</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/633.png)
    <st c="12421"><st c="12422">，因为每一步都会将问题规模减少 1，且具有</st> <st c="12480">常数成本。</st></st></st></st></st>'
- en: '**<st c="12494">Making an educated guess</st>**<st c="12519">: Based on our
    analysis, we hypothesize a potential form for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/43.png)<st
    c="12581"><st c="12582">. This could be</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/635.png)<st
    c="12598"><st c="12611">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/636.png)<st
    c="12613"><st c="12629">, or even</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/637.png)<st
    c="12639"><st c="12654">. The guess should reflect the expected behavior of the
    recurrence’s growth.</st> <st c="12731">For example, if we see a recursive call
    with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/626.png)
    <st c="12776"><st c="12777">and a linear term,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/78.png)
    <st c="12797"><st c="12798">might be a</st> <st c="12810">reasonable guess.</st></st></st></st></st></st></st>'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12494">做出有根据的猜测</st>**<st c="12519">：基于我们的分析，我们假设一个可能的形式为</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/43.png)<st
    c="12581"><st c="12582">。这可能是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:r></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced>'
- en: '**<st c="12827">Refining the guess</st>**<st c="12846">: Sometimes, we might
    need to refine our guess after initial attempts to validate it using induction.</st>
    <st c="12949">For example, if our guess</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/640.png)
    <st c="12975"><st c="12976">doesn’t satisfy the induction step, we might need
    to consider a higher-order term, such</st> <st c="13065">as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/78.png)<st
    c="13068"><st c="13069">.</st></st></st>'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12827">细化猜测</st>**<st c="12846">：有时，在通过归纳法验证初步猜测后，我们可能需要对猜测进行细化。</st>
    <st c="12949">例如，如果我们的猜测</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/640.png)
    <st c="12975"><st c="12976">未满足归纳步骤，我们可能需要考虑一个更高阶的项，如</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mo>⁡<mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/78.png)<st
    c="13068"><st c="13069">。</st></st></st>'
- en: <st c="13070">By following</st> <st c="13084">these steps, we systematically
    arrive at a plausible solution that can be rigorously validated.</st> <st c="13180">The
    guessing step combines intuition, experience, and analysis to propose a solution
    that you can then confirm</st> <st c="13291">through induction.</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13070">通过遵循</st> <st c="13084">这些步骤，我们系统地得出了一个合理的解决方案，可以通过严格的验证。</st>
    <st c="13180">猜测步骤结合了直觉、经验和分析，提出一个解决方案，然后你可以通过</st> <st c="13291">归纳法进行验证。</st>
- en: <st c="13309">Variable change approach</st>
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="13309">变量变换方法</st>
- en: <st c="13334">There are</st> <st c="13345">irregular recurrence functions that
    conventional methods, such as those outlined in</st> *<st c="13429">The master
    th</st>**<st c="13442">eorem</st>* <st c="13448">section or even the</st> *<st
    c="13469">Recursion tree as a visualization technique</st>* <st c="13512">section,
    are unable to solve.</st> <st c="13543">In these cases, the substitution method
    offers an alternative solution, alongside advanced, generalized methods, such
    as</st> <st c="13663">the</st> **<st c="13668">Akra-Bazzi method</st>** <st c="13685">(see
    the</st> *<st c="13695">Beyond the master theorem – the Akra-Bazzi</st>* *<st
    c="13738">method</st>* <st c="13744">section).</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13334">存在</st> <st c="13345">一些不规则的递归函数，传统方法，如</st> *<st c="13429">主定理</st>**<st
    c="13442">定理</st>* <st c="13448">部分，甚至</st> *<st c="13469">递归树作为可视化技术</st>* <st
    c="13512">部分，无法解决。</st> <st c="13543">在这些情况下，替代法提供了一种替代解决方案，还有一些先进的、广义的方法，比如</st>
    <st c="13663">Akra-Bazzi</st> **<st c="13668">方法</st>** <st c="13685">(见</st>
    *<st c="13695">超越主定理——Akra-Bazzi</st>* *<st c="13738">方法</st>* <st c="13744">部分)。</st>
- en: <st c="13754">The</st> **<st c="13759">substitution method</st>** <st c="13778">involves
    transforming the original recurrence into a more manageable form through variable
    change.</st> <st c="13878">This approach can reveal patterns and simplify the
    analysis, making it easier to find a closed-form solution.</st> <st c="13988">By
    carefully choosing new variables, we can convert complex recurrence functions
    into forms that are more straightforward</st> <st c="14110">to solve.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13754">替代法</st> **<st c="13759">方法</st>** <st c="13778">涉及通过变量变换将原始递归转化为更易处理的形式。</st>
    <st c="13878">这种方法可以揭示模式并简化分析，使得找到闭式解变得更加容易。</st> <st c="13988">通过仔细选择新变量，我们可以将复杂的递归函数转换为更直接</st>
    <st c="14110">易于求解的形式。</st>
- en: <st c="14119">In the next example, we demonstrate how to implement the substitution
    method using variable change to tackle irregular recurrence functions effectively.</st>
    <st c="14273">This example will illustrate the power and flexibility of the substitution
    method in dealing with complex recurrence functions that other methods</st> <st
    c="14419">cannot handle.</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14119">在下一个示例中，我们演示了如何使用变量替换方法有效地解决不规则的递推函数。</st> <st c="14273">这个例子将展示替换法在处理其他方法无法应对的复杂递推函数时的威力与灵活性。</st>
- en: '**<st c="14433">Example 5.5</st>**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="14433">例 5.5</st>**'
- en: <st c="14445">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/642.png)<st
    c="14452"><st c="14473">.</st></st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14445">求解</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/642.png)<st
    c="14452"><st c="14473">。</st></st>
- en: '<st c="14474">In the previous</st> <st c="14491">chapter, we categorized recurrence
    functions into two groups: subtracting (decreasing) and divide-and-conquer (dividing)
    recurrence functions.</st> <st c="14634">While the function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/643.png)
    <st c="14653"><st c="14673">could be considered a sub-category of divide-and-conquer
    recurrence functions, it more accurately belongs to a family of</st> **<st c="14794">substitution</st>**
    **<st c="14807">recurrence functions</st>**<st c="14827">.</st></st>'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14474">在前一章中，我们将递推函数分为两类：减法（递减）递推函数和分治法（递分）递推函数。</st> <st c="14634">虽然函数</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/643.png)
    <st c="14653"><st c="14673">可以被视为分治递推函数的一个子类，但它更准确地属于</st> **<st c="14794">替换法</st>**
    **<st c="14807">递推函数</st>**<st c="14827">的一类。</st>
- en: <st c="14828">To solve this recurrence function, we can use a change of variables
    to simplify the recurrence and make it easier</st> <st c="14943">to analyze.</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14828">为了解决这个递推函数，我们可以使用变量替换的方法来简化递推，从而更容易进行分析。</st> <st c="14943">这将使分析变得更加简便。</st>
- en: <st c="14954">Let</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:math>](img/644.png)<st
    c="14959"><st c="14960">.</st></st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14954">令</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:math>](img/644.png)<st
    c="14959"><st c="14960">。</st></st>
- en: <st c="14961">Then,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>=</mo><mi>m</mi></mrow></mrow></math>](img/645.png)<st
    c="14968"><st c="14975">.</st></st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14961">然后，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>=</mo><mi>m</mi></mrow></mrow></math>](img/645.png)<st
    c="14968"><st c="14975">。</st></st>
- en: <st c="14976">Rewriting the recurrence in terms of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)<st
    c="15014"><st c="15015">, we get</st> <st c="15024">the following:</st></st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14976">将递归关系重新表达为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)<st
    c="15014"><st c="15015">，我们得到</st> <st c="15024">以下结果：</st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi></mml:math>](img/647.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi></mml:math>](img/647.png)'
- en: <st c="15040">To simplify notation, let</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/648.png)<st
    c="15066"><st c="15067">. Then we have</st> <st c="15082">the following:</st></st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15040">为了简化符号，设</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/648.png)<st
    c="15066"><st c="15067">。那么我们得到</st> <st c="15082">以下结果：</st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi></mml:math>](img/649.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi></mml:math>](img/649.png)'
- en: <st c="15114">This is a familiar form of recurrence function for algorithms
    such as the merge sort algorithm (see</st> [*<st c="15214">Chapter 6</st>*](B22248_06.xhtml#_idTextAnchor081)<st
    c="15223">), which has the recurrence</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/650.png)
    <st c="15252"><st c="15253">with an asymptotic bound of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/651.png)<st
    c="15282"><st c="15283">. Therefore,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/652.png)<st
    c="15296"><st c="15297">. By substituting</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/653.png)
    <st c="15315"><st c="15316">with</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/654.png)<st
    c="15322"><st c="15323">, we get</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/655.png)<st
    c="15332"><st c="15354">. However, for the sake of thoroughness, let’s assume
    we do not know this result and solve it</st> <st c="15448">in detail.</st></st></st></st></st></st></st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15114">这是一个常见的递归函数形式，适用于像归并排序算法（参见</st> [*<st c="15214">第6章</st>*](B22248_06.xhtml#_idTextAnchor081)<st
    c="15223">)，其递归关系为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/650.png)
    <st c="15252"><st c="15253">，其渐近界为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/651.png)<st
    c="15282"><st c="15283">。因此，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/652.png)<st
    c="15296"><st c="15297">。通过将</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/653.png)
    <st c="15315"><st c="15316">替换为</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/654.png)<st
    c="15322"><st c="15323">，我们得到</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/655.png)<st
    c="15332"><st c="15354">。然而，为了彻底性，我们假设我们不知道这个结果，并详细求解。</st></st></st></st></st></st></st>
- en: <st c="15458">Now, we solve this new recurrence function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>)</mml:mo></mml:math>](img/656.png)<st
    c="15502"><st c="15503">. Let’s unroll the recurrence a few steps to identify</st>
    <st c="15557">a pattern:</st></st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们解这个新的递推函数！[<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>)</mml:mo></mml:math>](img/656.png)。让我们展开递推几步，找出其中的模式：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/657.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/657.png)'
- en: <st c="15569">Substitute</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:math>](img/658.png)
    <st c="15580"><st c="15585">into the</st> <st c="15594">first equation:</st></st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 替换为![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:math>](img/658.png)进入第一个方程：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi></mml:math>](img/659.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi></mml:math>](img/659.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>m</mml:mi></mml:math>](img/660.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>m</mml:mi></mml:math>](img/660.png)'
- en: <st c="15632">Unroll it one</st> <st c="15646">more step:</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 再展开一步：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/661.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/661.png)'
- en: <st c="15658">Substitute</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>:</mml:mo></mml:math>](img/662.png)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15658">替换</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>:</mml:mo></mml:math>](img/662.png)
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>m</mml:mi></mml:math>](img/663.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>m</mml:mi></mml:math>](img/663.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>8</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mi>m</mml:mi></mml:math>](img/664.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>8</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mi>m</mml:mi></mml:math>](img/664.png)'
- en: <st c="15688">By unrolling</st> <st c="15701">this pattern, we can see that
    at each level, the coefficient of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi></mml:math>](img/665.png)
    <st c="15765"><st c="15766">decreases exponentially, while the coefficient of</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)
    <st c="15817"><st c="15818">increases linearly.</st></st></st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过展开这个模式，我们可以看到在每个层级中，**S**的系数![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi></mml:math>](img/665.png)
    <st c="15765"><st c="15766">呈指数性下降，而</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)
    <st c="15817"><st c="15818">的系数则呈线性增加。</st></st></st>
- en: <st c="15837">We can generalize this pattern after</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="15875"><st c="15876">steps:</st></st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在经过![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="15875"><st c="15876">步后概括这个模式：</st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mi>m</mml:mi></mml:math>](img/668.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mi>m</mml:mi></mml:math>](img/668.png)'
- en: <st c="15884">When</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:math>](img/669.png)
    <st c="15889"><st c="15890">becomes 1, we have</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:math>](img/670.png)
    <st c="15910"><st c="15911">, which means</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi></mrow></mrow></math>](img/671.png)<st
    c="15925"><st c="15926">.</st> <st c="15928">Substitute</st></st></st></st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:math>](img/669.png)
    <st c="15889"><st c="15890">变为 1 时，我们得到</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math>](img/670.png)
    <st c="15910"><st c="15911">，这意味着</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi></mrow></mrow></math>](img/671.png)<st
    c="15925"><st c="15926">。</st> <st c="15928">代入</st></st></st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi></mrow></mrow></math>](img/672.png)<st
    c="15938"><st c="15940">:</st></st>'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi></mrow></mrow></math>](img/672.png)<st
    c="15938"><st c="15940">：</st></st>'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:msup><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mi>m</mml:mi></mml:math>](img/673.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:msup><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mi>m</mml:mi></mml:math>](img/673.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>m</mml:mi></mml:math>](img/674.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>m</mml:mi></mml:math>](img/674.png)'
- en: <st c="15974">Given that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/675.png)<st
    c="15985"><st c="15986">, a constant, we denote it</st> <st c="16013">as</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi></mml:math>](img/233.png)<st
    c="16016"><st c="16017">.</st></st></st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15974">已知</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/675.png)<st
    c="15985"><st c="15986">，为常数，我们表示为</st> <st c="16013">c</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi></mml:math>](img/233.png)<st
    c="16016"><st c="16017">。</st></st></st>
- en: <st c="16018">Thus, we have</st> <st c="16033">the following:</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16018">因此，我们得到</st> <st c="16033">如下结果：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>S</mi><mo>(</mo><mi>m</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>c</mi><mo>+</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi></mrow></mrow></mrow></math>](img/677.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>S</mi><mo>(</mo><mi>m</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>c</mi><mo>+</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi></mrow></mrow></mrow></math>](img/677.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>S</mi><mo>(</mo><mi>m</mi><mo>)</mo><mo>=</mo><mi>m</mi><mo>(</mo><mi>c</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>)</mo></mrow></mrow></mrow></math>](img/678.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>S</mi><mo>(</mo><mi>m</mi><mo>)</mo><mo>=</mo><mi>m</mi><mo>(</mo><mi>c</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>)</mo></mrow></mrow></mrow></math>](img/678.png)'
- en: <st c="16050">Substitute</st> <st c="16061">back</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>m</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/679.png)<st
    c="16066"><st c="16078">:</st></st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16050">代入</st> <st c="16061">返回</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>m</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/679.png)<st
    c="16066"><st c="16078">：</st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>c</mml:mi><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/680.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>c</mml:mi><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/680.png)'
- en: <st c="16080">Therefore, the solution to the recurrence function</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/642.png)
    <st c="16131"><st c="16152">is</st> <st c="16155">as follows:</st></st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16080">因此，递推函数的解</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/642.png)
    <st c="16131"><st c="16152">为</st> <st c="16155">如下所示：</st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">Θ</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfenced></mrow></mrow></math>](img/682.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">Θ</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfenced></mrow></mrow></math>](img/682.png)'
- en: <st c="16190">In this section, we explained a powerful technique for solving
    recurrence functions by hypothesizing a solution and proving its correctness through
    mathematical induction.</st> <st c="16362">The method involves substituting the
    guessed solution back into the recurrence function to verify if it satisfies the
    original equation.</st> <st c="16499">This approach allows for flexibility and
    creativity in handling a wide variety of recurrence forms, including those that
    are not easily addressed by other methods, such as the master theorem or recursion
    trees.</st> <st c="16710">By iteratively refining the guess and employing induction,
    substitution methods provide a structured way to derive closed-form solutions
    and understand the growth behavior of</st> <st c="16885">recursive algorithms.</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16190">在这一部分，我们解释了一种强大的技术，通过假设一个解并通过数学归纳法证明其正确性来解决递推函数。</st> <st c="16362">该方法包括将猜测的解代回递推函数中，以验证它是否满足原方程。</st>
    <st c="16499">这种方法允许在处理各种递推形式时具有灵活性和创造性，特别是对于那些其他方法（如主定理或递归树）无法轻松处理的递推形式。</st>
    <st c="16710">通过反复精炼猜测并使用归纳法，替代方法提供了一种有结构的方式来推导闭式解，并理解</st> <st c="16885">递归算法的增长行为。</st>
- en: <st c="16906">Recursion tree as a visualization technique</st>
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="16906">递归树作为一种可视化技术</st>
- en: <st c="16950">The</st> **<st c="16955">recursion tree method</st>** <st c="16976">is
    a</st> <st c="16982">powerful technique for solving and visualizing recurrence
    functions, particularly those that arise in the analysis of divide-and-conquer
    algorithms.</st> <st c="17131">It involves visualizing the recursive process as
    a tree, where each node represents a subproblem, and the edges represent the recursive
    calls.</st> <st c="17274">By summing the costs at each level of the tree, we can
    determine the overall complexity of</st> <st c="17365">the algorithm.</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16950">该</st> **<st c="16955">递归树方法</st>** <st c="16976">是一种强大的技术，用于解决和可视化递归函数，尤其是在分析分治算法时非常有效。</st>
    <st c="17131">它通过将递归过程可视化为一棵树来实现，每个节点代表一个子问题，而边表示递归调用。</st> <st c="17274">通过求和树中每一层的成本，我们可以确定该算法的整体复杂度。</st>
- en: <st c="17379">Here’s the step-by-step</st> <st c="17404">explanation of the
    recursion</st> <st c="17433">tree method:</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17379">这是递归树方法的逐步</st> <st c="17404">解释：</st>
- en: '**<st c="17445">Construct the</st>** **<st c="17460">recursion tree</st>**<st
    c="17474">:</st>'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="17445">构建</st>** **<st c="17460">递归树</st>**<st c="17474">：</st>'
- en: <st c="17476">Begin by writing down the original</st> <st c="17511">recurrence
    function</st>
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="17476">首先写下原始的</st> <st c="17511">递归函数</st>
- en: <st c="17530">Each node in the tree represents a call to</st> <st c="17574">the
    recurrence</st>
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="17530">树中的每个节点代表一次对</st> <st c="17574">递归的调用</st>
- en: <st c="17588">The root of the tree corresponds to the original</st> <st c="17638">problem</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="17588">树的根节点对应于原始的</st> <st c="17638">问题</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
- en: <st c="17647">The children of a node represent the subproblems generated by
    the</st> <st c="17713">recursive calls</st>
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="17647">一个节点的子节点表示由</st> <st c="17713">递归调用</st> <st c="17713">生成的子问题</st>
- en: '**<st c="17728">Identify</st>** **<st c="17738">the costs</st>**<st c="17747">:</st>'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="17728">识别</st>** **<st c="17738">成本</st>**<st c="17747">：</st>'
- en: <st c="17749">Determine the cost at each node.</st> <st c="17782">This cost
    typically corresponds to the non-recursive work done at that step, often denoted</st>
    <st c="17873">as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="17876"><st c="17879">.</st></st>
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="17749">确定每个节点的成本。</st> <st c="17782">此成本通常对应于该步骤中的非递归工作，通常表示为</st> <st
    c="17873">f(n)</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="17876"><st c="17879">。</st></st>
- en: <st c="17880">Write down the cost at the root and propagate it through</st>
    <st c="17938">the tree.</st>
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="17880">写下根节点的成本并将其传播到</st> <st c="17938">树中。</st>
- en: '**<st c="17947">Expand</st>** **<st c="17955">the tree</st>**<st c="17963">:</st>'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="17947">展开</st>** **<st c="17955">树</st>**<st c="17963">：</st>'
- en: <st c="17965">Continue expanding the tree by breaking down each subproblem into
    its constituent parts according to the</st> <st c="18070">recurrence function</st>
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="17965">通过根据</st> <st c="18070">递归函数</st> <st c="18070">将每个子问题拆解成其组成部分，继续展开树。</st>
- en: <st c="18089">This process continues until the subproblems reach the base case
    of</st> <st c="18158">the recursion</st>
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="18089">此过程会持续进行，直到子问题达到</st> <st c="18158">递归的基本情况</st>
- en: '**<st c="18171">Calculate the total cost at</st>** **<st c="18200">each level</st>**<st
    c="18210">:</st>'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="18171">计算每一层的总成本</st>** **<st c="18200">每一层</st>**<st c="18210">：</st>'
- en: <st c="18212">Sum the</st> <st c="18219">costs of all nodes at each level of</st>
    <st c="18256">the tree</st>
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="18212">求出</st> <st c="18219">每一层中所有节点的</st> <st c="18256">成本</st>
- en: <st c="18264">Identify the number of nodes at each level and the cost</st> <st
    c="18321">per node</st>
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="18264">确定每一层的节点数量和每个节点的成本</st> <st c="18321">每个节点</st>
- en: '**<st c="18329">Sum the costs across</st>** **<st c="18351">all levels</st>**<st
    c="18361">:</st>'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="18329">求和各层的成本</st>** **<st c="18351">所有层级的成本</st>**<st c="18361">：</st>'
- en: <st c="18363">Add the costs from all levels of the tree to get the</st> <st
    c="18416">total cost</st>
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="18363">将树中所有层的成本加起来，得到</st> <st c="18416">总成本</st>
- en: <st c="18426">Analyze the sum to determine the overall</st> <st c="18468">asymptotic
    complexity</st>
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析求和以确定整体<st c="18468">渐进复杂度</st>
- en: <st c="18489">The recursion tree method involves visualizing the breakdown of
    a recursive problem into smaller subproblems in the form of a tree to analyze
    its complexity.</st> <st c="18648">Starting with the original problem at the root,
    the method entails drawing each level of recursion, where each node represents
    a subproblem and the edges represent recursive calls.</st> <st c="18829">At each
    level, the cost of solving all subproblems is calculated and summed.</st> <st
    c="18906">By expanding the tree until the base case is reached, and summing the
    costs across all levels, the total complexity of the algorithm can be determined.</st>
    <st c="19058">This method provides a clear and systematic way to understand the
    distribution of costs and the overall behavior of recursive algorithms, often
    resulting in identifying the asymptotic complexity of the recurrence.</st> <st
    c="19272">Let’s explore the method in the</st> <st c="19304">next example.</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 递归树方法通过将递归问题分解为较小的子问题并以树形结构进行可视化，来分析其复杂度。<st c="18489">从根节点开始，方法包括绘制每一层递归，其中每个节点代表一个子问题，而边表示递归调用。</st>
    <st c="18648">在每一层，计算并汇总解决所有子问题的成本。</st> <st c="18829">通过展开树直到达到基准情况，并汇总所有层级的成本，可以确定算法的总复杂度。</st>
    <st c="18906">该方法提供了一种清晰且系统化的方式来理解成本的分布及递归算法的整体行为，通常能够识别出递归的渐进复杂度。</st> <st c="19058">让我们在</st>
    <st c="19272">下一个示例中进一步探索该方法。</st>
- en: '**<st c="19317">Example 5.6</st>**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 5.6**'
- en: <st c="19329">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/685.png)
    <st c="19336"><st c="19355">using the recursion</st> <st c="19375">tree method.</st></st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 求解 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/685.png)
    使用递归树方法。
- en: <st c="19387">Here is</st> <st c="19396">the solution:</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是<st c="19387">解决方案：</st>
- en: '**<st c="19409">Construct the</st>** **<st c="19424">recursion tree</st>**<st
    c="19438">:</st>'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构造<st c="19409">递归树</st>**<st c="19424">：</st>'
- en: <st c="19440">The root of the tree</st> <st c="19461">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树的根是 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
- en: <st c="19465">This breaks down into 4 subproblems, each of</st> <st c="19510">size</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/626.png)
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将分解为4个子问题，每个子问题的<st c="19510">大小</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/626.png)
- en: <st c="19516">...</st>
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: <st c="19519">Level 0:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第0层：![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
- en: <st c="19530">/ | | \</st>
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19530">/ | | \</st>
- en: <st c="19538">Level 1:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mn>4</mn><mi
    mathvariant="normal">*</mi><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mn>2</mn><mo>)</mo></mrow></mrow></mrow></math>](img/689.png)
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19538">第1级：</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mn>4</mn><mi
    mathvariant="normal">*</mi><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mn>2</mn><mo>)</mo></mrow></mrow></mrow></math>](img/689.png)
- en: <st c="19558">/ / / / | | | | \ \ \ \</st>
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19558">/ / / / | | | | \ \ \ \</st>
- en: <st c="19581">Level 2:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mn>4</mn><mi
    mathvariant="normal">*</mi><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mn>4</mn><mo>)</mo></mrow></mrow></mrow></math>](img/690.png)
    <st c="19591"><st c="19628">(</st><st c="19629">16 subproblems)</st></st>
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19581">第2级：</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mn>4</mn><mi
    mathvariant="normal">*</mi><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mn>4</mn><mo>)</mo></mrow></mrow></mrow></math>](img/690.png)
    <st c="19591"><st c="19628">(16个子问题)</st></st>
- en: <st c="19644">...</st>
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19644">...</st>
- en: '**<st c="19647">Identify</st>** **<st c="19657">the costs</st>**<st c="19666">:</st>'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="19647">识别</st>** **<st c="19657">成本</st>**<st c="19666">：</st>'
- en: <st c="19668">The cost</st> <st c="19676">at the root (Level 0)</st> <st c="19699">is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="19668">根节点（第0级）处的成本</st> <st c="19676">是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
- en: <st c="19751">At Level 1, each of the 4 subproblems</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/626.png)<st
    c="19789"><st c="19790">has a cost</st> <st c="19801">of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle></mrow></math>](img/693.png)</st>
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="19751">在第1级，每个4个子问题</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/626.png)<st
    c="19789"><st c="19790">的成本是</st> <st c="19801">!</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle></mrow></math>](img/693.png)</st>
- en: <st c="19805">At Level 2, each of the 16 subproblems</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/627.png)<st
    c="19844"><st c="19845">has a cost</st> <st c="19856">of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>4</mn></mfrac></mstyle></mrow></math>](img/695.png)</st>
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="19805">在第2级，每个16个子问题</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/627.png)<st
    c="19844"><st c="19845">的成本是</st> <st c="19856">!</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>4</mn></mfrac></mstyle></mrow></math>](img/695.png)</st>
- en: <st c="19860">...</st>
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19860">...</st>
- en: '**<st c="19863">Expand</st>** **<st c="19871">the tree</st>**<st c="19879">:</st>'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="19863">展开</st>** **<st c="19871">树</st>**<st c="19879">：</st>'
- en: <st c="19881">Continue expanding until the subproblems reach the base case (</st><st
    c="19943">e.g.,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/579.png)<st
    c="19950"><st c="19951">)</st></st>
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="19881">继续展开，直到子问题达到基本情况（</st><st c="19943">例如，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/579.png)<st
    c="19950"><st c="19951">)</st></st>
- en: <st c="19952">The number of levels in the tree is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/697.png)
    <st c="19988"><st c="19989">because the problem size is halved at</st> <st c="20028">each
    level</st></st>
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="19952">树的层数是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/697.png)
    <st c="19988"><st c="19989">因为每一层</st> <st c="20028">问题大小会减少一半</st></st>
- en: '**<st c="20038">Calculate the total cost at</st>** **<st c="20067">each level</st>**<st
    c="20077">:</st>'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="20038">计算每一层的总成本</st>** **<st c="20067">每一层</st>**<st c="20077">：</st>'
- en: '**<st c="20079">Level 0</st>**<st c="20086">: Cost =</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="20079">第 0 层</st>**<st c="20086">: 成本 =</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)'
- en: '**<st c="20145">Level 1</st>**<st c="20152">: Cost =</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>4</mml:mn><mml:mo>⋅</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:math>](img/699.png)'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="20145">第 1 层</st>**<st c="20152">: 成本 =</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>4</mml:mn><mml:mo>⋅</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:math>](img/699.png)'
- en: '**<st c="20172">Level 2</st>**<st c="20179">: Cost =</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>16</mml:mn><mml:mo>⋅</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mi>n</mml:mi></mml:math>](img/700.png)'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="20172">第 2 层</st>**<st c="20179">: 成本 =</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>16</mml:mn><mml:mo>⋅</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mi>n</mml:mi></mml:math>](img/700.png)'
- en: '**<st c="20196">General Level</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)**<st
    c="20211">: Cost =</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>⋅</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:math>](img/702.png)'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="20196">一般层级</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)**<st
    c="20211">: 成本 =</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>⋅</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:math>](img/702.png)'
- en: '**<st c="20221">Sum the costs across</st>** **<st c="20242">all levels</st>**<st
    c="20252">:</st>'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="20221">总计各层级的成本</st>** **<st c="20242">所有层级</st>**<st c="20252">：</st>'
- en: <st c="20254">The total cost</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
    <st c="20269"><st c="20270">is the sum of the costs at</st> <st c="20298">all
    levels:</st>
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="20254">总成本</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
    <st c="20269"><st c="20270">是所有层级的成本之和：</st> <st c="20298">所有层级：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>4</mml:mn><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>8</mml:mn><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:math>](img/704.png)</st>'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>4</mml:mn><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>8</mml:mn><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:math>](img/704.png)</st>'
- en: <st c="20342">This is a geometric series with the first term</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mi>n</mi></mrow></mrow></math>](img/705.png)
    <st c="20389"><st c="20390">and the common</st> <st c="20406">ratio</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>r</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/706.png)<st
    c="20412"><st c="20413">:</st>
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="20342">这是一个等比数列，其首项为</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mi>n</mi></mrow></mrow></math>](img/705.png)
    <st c="20389"><st c="20390">和公比为</st> <st c="20406">比例</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>r</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/706.png)<st
    c="20412"><st c="20413">：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>S</mi><mo>=</mo><mi>a</mi><mstyle
    scriptlevel="+1"><mfrac><mrow><msup><mi>r</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mstyle></mrow></mrow></math>](img/707.png)</st></st>'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>S</mi><mo>=</mo><mi>a</mi><mstyle
    scriptlevel="+1"><mfrac><mrow><msup><mi>r</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mstyle></mrow></mrow></math>](img/707.png)</st></st>'
- en: <st c="20415">In our case,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mi>n</mi></mrow></mrow></math>](img/705.png)<st
    c="20428"><st c="20429">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>r</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/706.png)<st
    c="20431"><st c="20432">,</st> <st c="20434">and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/710.png)<st
    c="20438"><st c="20439">:</st>
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="20415">在我们的例子中，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mi>n</mi></mrow></mrow></math>](img/705.png)<st
    c="20428"><st c="20429">，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>r</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/706.png)<st
    c="20431"><st c="20432">，</st> <st c="20434">并且</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/710.png)<st
    c="20438"><st c="20439">：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/711.png)</st></st></st>'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/711.png)</st></st></st>'
- en: <st c="20441">Simplifying, we get the following:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:mi>n</mml:mi></mml:math>](img/712.png)
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="20441">简化后，我们得到以下结果：</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:mi>n</mml:mi></mml:math>](img/712.png)
- en: <st c="20494">Asymptotically, the dominant term is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/713.png)<st
    c="20531"><st c="20535">, so we have the</st> <st c="20552">following:</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/714.png)</st>
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="20494">渐近地，主导项是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/713.png)<st
    c="20531"><st c="20535">，因此我们得到以下结果：</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/714.png)</st>
- en: <st c="20564">The recursion tree method</st> <st c="20590">provides a clear
    visual representation of how a recursive algorithm breaks down a problem into
    subproblems.</st> <st c="20698">By summing the costs at each level of the tree,
    we can determine the total complexity of the algorithm.</st> <st c="20802">This
    method is particularly useful for understanding and solving complex recurrence
    functions, offering insight into the behavior and efficiency of</st> <st c="20950">divide-and-conquer
    algorithms.</st>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20564">递归树方法</st> <st c="20590">提供了递归算法如何将一个问题分解成子问题的清晰视觉表示。</st> <st
    c="20698">通过对树中每一层的成本求和，我们可以确定算法的总复杂度。</st> <st c="20802">这种方法特别有助于理解和解决复杂的递归函数，能够为</st>
    <st c="20950">分治算法</st> <st c="20980">提供洞察。</st>
- en: <st c="20980">The master theorem</st>
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="20980">主定理</st>
- en: <st c="20999">In the</st> <st c="21007">analysis of algorithms, the</st> **<st
    c="21035">master theorem</st>** <st c="21049">plays a crucial role in solving
    recurrences for divide-and-conquer algorithms.</st> <st c="21129">Introduced in
    1980, it has become a mainstream approach for estimating the complexity of a wide
    range of recurrence functions.</st> <st c="21256">The master theorem provides
    a straightforward framework for determining the asymptotic behavior of recurrences
    of the</st> <st c="21374">following form:</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20999">在</st> <st c="21007">算法分析中，</st> **<st c="21035">主定理</st>** <st
    c="21049">在求解分治算法的递归方程中起着关键作用。</st> <st c="21129">主定理于1980年提出，现已成为估算各种递归函数复杂度的主流方法。</st>
    <st c="21256">主定理提供了一个简洁的框架，用于确定以下形式递归的渐近行为：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/715.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/715.png)'
- en: <st c="21410">Here,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:math>](img/716.png)
    <st c="21416"><st c="21417">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mo>></mml:mo><mml:mn>1</mml:mn></mml:math>](img/717.png)
    <st c="21422"><st c="21426">are constants, and</st> *<st c="21445">f(n)</st>*<st
    c="21449">, the driving function, is an asymptotically positive function bounded
    by polynomial functions.</st> <st c="21545">This means there exist two polynomial
    functions</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/718.png)
    <st c="21593"><st c="21594">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/719.png)
    <st c="21599"><st c="21600">such that the following is</st> <st c="21628">the
    case:</st></st></st></st></st>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21410">这里，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:math>](img/716.png)
    <st c="21416"><st c="21417">并且</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mo>></mml:mo><mml:mn>1</mml:mn></mml:math>](img/717.png)
    <st c="21422"><st c="21426">是常数，并且</st> *<st c="21445">f(n)</st>*<st c="21449">，驱动函数，是一个渐近正函数，由多项式函数界定。</st>
    <st c="21545">这意味着存在两个多项式函数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/718.png)
    <st c="21593"><st c="21594">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/719.png)
    <st c="21599"><st c="21600">使得以下等式成立：</st> <st c="21628">情况如下：</st></st></st></st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>g</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>h</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/720.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>g</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>h</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/720.png)'
- en: <st c="21639">The</st> <st c="21643">importance of the master theorem lies in
    its ability to simplify the complexity analysis of many common algorithms, such
    as merge sort, quicksort, and binary search, among others.</st> <st c="21823">By
    categorizing the behavior of the recurrence based on the relationship between</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)
    <st c="21904"><st c="21907">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:math>](img/722.png)<st
    c="21911"><st c="21912">, the master theorem allows for quick and accurate complexity
    estimation without requiring detailed,</st> <st c="22013">case-by-case analysis.</st></st></st>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21639">主定理的重要性在于它能够简化许多常见算法（如归并排序、快速排序和二分查找等）的复杂度分析。</st> <st c="21823">通过基于</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)
    <st c="21904"><st c="21907">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:math>](img/722.png)<st
    c="21911"><st c="21912">之间的关系来对递归行为进行分类，主定理使得复杂度估计变得快速且准确，而无需详细的逐个分析。</st></st></st>
- en: <st c="22035">Although we do not provide proof of the master theorem here, readers
    can refer to the references at the end of this chapter for detailed proof and
    further reading.</st> <st c="22200">Understanding the master theorem and its applications
    is essential for anyone studying algorithm design and analysis, as it forms the
    foundation for evaluating the efficiency of many</st> <st c="22383">recursive
    algorithms.</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22035">虽然我们在这里没有提供主定理的证明，但读者可以参考本章末尾的文献，获取详细的证明和进一步的阅读资料。</st> <st c="22200">理解主定理及其应用对于任何学习算法设计与分析的人来说都是至关重要的，因为它为评估许多</st>
    <st c="22383">递归算法的效率奠定了基础。</st>
- en: <st c="22404">Let’s explore the key concepts of the master theorem, which are
    essential for understanding and describing the different cases of</st> <st c="22535">this
    method:</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22404">让我们来探索主定理的关键概念，这些概念对于理解和描述这种方法的不同情况是必不可少的：</st>
- en: '**<st c="22547">Critical exponent (</st>****![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi></mml:math>](img/723.png)****<st
    c="22569">)</st>**<st c="22570">: This value,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>w</mi><mo>=</mo><msub><mi>log</mi><mi>b</mi></msub><mi>a</mi></mrow></mrow></math>](img/724.png)<st
    c="22584"><st c="22585">, represents a threshold for comparing the</st> <st c="22628">growth
    rates of the driving function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)
    <st c="22665"><st c="22668">and the recursive part of the</st> <st c="22698">recurrence
    function.</st></st></st>'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22547">临界指数（</st>****![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi></mml:math>](img/723.png)****<st
    c="22569">）</st>**<st c="22570">：这个值，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>w</mi><mo>=</mo><msub><mi>log</mi><mi>b</mi></msub><mi>a</mi></mrow></mrow></math>](img/724.png)<st
    c="22584"><st c="22585">，代表了一个阈值，用于比较驱动函数</st> <st c="22628">的增长速率</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)
    <st c="22665"><st c="22668">与递归部分的</st> <st c="22698">递归函数的增长速率。</st></st></st>'
- en: '**<st c="22718">Watershed function (</st>****![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math>](img/726.png)****<st
    c="22741">)</st>**<st c="22742">: This function,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:math>](img/727.png)<st
    c="22759"><st c="22770">, serves as a</st> *<st c="22784">dividing line</st>*
    <st c="22797">between the cases of</st> <st c="22818">the master theorem.</st>
    <st c="22839">It tells us the growth rate of the recursion if the driving function</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/494.png)
    <st c="22908"><st c="22913">were negligible.</st></st></st>'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22718">分水岭函数（</st>****![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math>](img/726.png)****<st
    c="22741">）</st>**<st c="22742">：这个函数,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:math>](img/727.png)<st
    c="22759"><st c="22770">，作为</st> *<st c="22784">分界线</st>* <st c="22797">区分了</st>
    <st c="22818">主定理的不同情况。</st> <st c="22839">它告诉我们递归的增长速率，假如驱动函数</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/494.png)
    <st c="22908"><st c="22913">被忽略时。</st></st></st>'
- en: <st c="22929">Case 1 – dominance of recursive calls or leaf-heavy recursion
    trees</st>
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="22929">案例 1 – 递归调用的主导作用或叶子重的递归树</st>
- en: <st c="22997">In</st> *<st c="23001">Case 1</st>*<st c="23007">, the</st> <st
    c="23013">work done outside the recursive calls (the driving function</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/494.png)<st
    c="23073"><st c="23078">) is dominated by the work done within the recursive calls.</st>
    <st c="23138">The driving function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)
    <st c="23159"><st c="23164">grows polynomially but at a slower rate than the watershed
    function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math>](img/731.png)<st
    c="23232"><st c="23233">. More formally, this is</st> <st c="23258">as follows:</st></st></st></st>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22997">在</st> *<st c="23001">案例 1</st>*<st c="23007">中，</st> <st c="23013">递归调用之外的工作量（驱动函数</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/494.png)<st
    c="23073"><st c="23078">）被递归调用中的工作量所主导。</st> <st c="23138">驱动函数</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)
    <st c="23159"><st c="23164">以多项式的方式增长，但增长速度比分水岭函数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math>](img/731.png)<st
    c="23232"><st c="23233">）慢。</st> <st c="23258">更正式的表达是：</st></st></st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>f</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>O</mi><mfenced open="(" close=")"><msup><mi>n</mi><mi>c</mi></msup></mfenced></mrow></mrow></math>](img/732.png)<st
    c="23269"><st c="23271">where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo><</mml:mo><mml:mi>w</mml:mi></mml:math>](img/733.png)</st>'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>f</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>O</mi><mfenced open="(" close=")"><msup><mi>n</mi><mi>c</mi></msup></mfenced></mrow></mrow></math>](img/732.png)<st
    c="23269"><st c="23271">其中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo><</mml:mo><mml:mi>w</mml:mi></mml:math>](img/733.png)</st>'
- en: <st c="23278">Or, equivalently, this is</st> <st c="23304">as follows:</st>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23278">或者，等效地，这是</st> <st c="23304">如下所示：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo>-</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/734.png)
    <st c="23315"><st c="23328">for some</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>ε</mi><mo>></mo><mn>0</mn></mrow></mrow></math>](img/735.png)</st>'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo>-</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/734.png)
    <st c="23315"><st c="23328">对于某些</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>ε</mi><mo>></mo><mn>0</mn></mrow></mrow></math>](img/735.png)</st>'
- en: <st c="23338">This means that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/736.png)
    <st c="23354"><st c="23358">is upper-bounded by a polynomial with a smaller exponent
    than</st> <st c="23420">the watershed.</st></st>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23338">这意味着</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/736.png)
    <st c="23354"><st c="23358">的上界是一个多项式，其指数小于</st> <st c="23420">分水岭。</st></st>
- en: <st c="23434">Why is</st> *<st c="23442">Case 1</st>* <st c="23448">leaf-heavy?</st>
    <st c="23461">To</st> <st c="23463">understand why</st> *<st c="23479">Case 1</st>*
    <st c="23485">is called</st> *<st c="23496">leaf-heavy</st>*<st c="23506">, imagine
    a recursion tree representing the algorithm’s execution.</st> <st c="23573">Each
    node represents a recursive call, and its children are the subproblems.</st> <st
    c="23650">In this case, the work done at each level of the tree (represented by</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)<st
    c="23720"><st c="23725">) is relatively small compared to the number of recursive
    calls.</st> <st c="23790">As a result, the majority of the work is done on the
    leaves of the recursion tree, hence the</st> <st c="23883">term</st> **<st c="23888">leaf-heavy</st>**<st
    c="23898">.</st></st>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23434">为什么</st> *<st c="23442">情况1</st>* <st c="23448">是叶节点重的？</st> <st
    c="23461">为了</st> <st c="23463">理解为什么</st> *<st c="23479">情况1</st>* <st c="23485">被称为</st>
    *<st c="23496">叶节点重</st>*<st c="23506">，请想象一个递归树来表示算法的执行过程。</st> <st c="23573">每个节点代表一次递归调用，其子节点代表子问题。</st>
    <st c="23650">在这种情况下，树中每一层所做的工作（由</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)<st
    c="23720"><st c="23725">）与递归调用的次数相比相对较小。</st> <st c="23790">因此，大部分的工作都在递归树的叶节点上完成，因此称为</st>
    <st c="23883">术语</st> **<st c="23888">叶节点重</st>**<st c="23898">。</st></st>
- en: <st c="23899">When the recursive calls dominate, the overall time complexity
    of the algorithm is determined by the number of leaves in the recursion tree.</st>
    <st c="24041">This number grows exponentially with the depth of the tree.</st>
    <st c="24101">Since the depth of the tree is logarithmic in the input size (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>n</mml:mi></mml:math>](img/738.png)<st
    c="24163"><st c="24170">), the overall time complexity becomes</st> <st c="24209">the
    following:</st></st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23899">当递归调用占主导时，算法的整体时间复杂度由递归树中的叶子节点数量决定。</st> <st c="24041">这个数量随着树的深度呈指数增长。</st>
    <st c="24101">由于树的深度与输入大小的对数成正比（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>n</mml:mi></mml:math>](img/738.png)<st
    c="24163"><st c="24170">)，因此，整体时间复杂度变为：</st> <st c="24209">以下形式：</st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/739.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/739.png)'
- en: <st c="24247">In other words, the time complexity is dominated by the recursive
    splitting of the problem into smaller subproblems.</st> <st c="24364">If the work
    done outside the recursive calls (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="24410"><st c="24414">) is small compared to the work done inside</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>)</mml:mo></mml:math>](img/741.png)<st
    c="24458"><st c="24459">, then most of the time is spent in the recursive calls,
    making the recursion tree leaf-heavy.</st> <st c="24554">In this scenario, the
    overall runtime is primarily determined by how many times you can divide the problem
    before reaching the base case.</st> <st c="24692">This is captured by the exponent</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:math>](img/742.png)<st
    c="24725"><st c="24737">.</st></st></st></st>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24247">换句话说，时间复杂度主要由递归将问题拆分成更小的子问题来主导。</st> <st c="24364">如果递归调用外的工作量（</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="24410"><st c="24414">）相比于递归内部的工作量</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>)</mml:mo></mml:math>](img/741.png)<st
    c="24458"><st c="24459">时，绝大部分时间都花费在递归调用中，从而使递归树呈现出叶子结点较重的特点。</st> <st c="24554">在这种情况下，总的运行时间主要由在达到基本情况之前，可以将问题分割多少次来决定。</st>
    <st c="24692">这一点由指数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:math>](img/742.png)<st
    c="24725"><st c="24737">来表示。</st></st></st></st>
- en: '**<st c="24738">Example 5.7</st>**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="24738">示例 5.7</st>**'
- en: <st c="24750">Consider this recurrence:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo>(</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/743.png)<st
    c="24777"><st c="24778">.</st></st>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24750">考虑这个递归：</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo>(</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/743.png)<st
    c="24777"><st c="24778">。</st></st>
- en: <st c="24779">Here,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/744.png)<st
    c="24786"><st c="24787">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)<st
    c="24789"><st c="24790">, and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>n</mi></mrow></mrow></mrow></math>](img/746.png)<st
    c="24796"><st c="24797">. We have</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>w</mi><mo>=</mo><msub><mi>log</mi><mn>2</mn></msub><mn>2</mn><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/747.png)<st
    c="24807"><st c="24808">. Since</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/748.png)<st
    c="24816"><st c="24817">,</st> *<st c="24819">Case 1</st>* <st c="24825">applies,
    and the time complexity is</st> <st c="24862">as follows:</st></st></st></st></st></st>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24779">在这里，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/744.png)<st
    c="24786"><st c="24787">，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)<st
    c="24789"><st c="24790">，和</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>n</mi></mrow></mrow></mrow></math>](img/746.png)<st
    c="24796"><st c="24797">。我们有</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>w</mi><mo>=</mo><msub><mi>log</mi><mn>2</mn></msub><mn>2</mn><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/747.png)<st
    c="24807"><st c="24808">。由于</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/748.png)<st
    c="24816"><st c="24817">，</st> *<st c="24819">情况 1</st>* <st c="24825">适用，时间复杂度如下：</st></st></st></st></st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/749.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/749.png)'
- en: <st c="24875">Case 2 – balanced growth or balanced recursion trees</st>
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="24875">情况 2 – 平衡增长或平衡递归树</st>
- en: '*<st c="24927">Case 2</st>* <st c="24934">of the</st> <st c="24942">master
    theorem deals with scenarios where the work done outside the recursive calls (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/750.png)<st
    c="25027"><st c="25033">) grows at roughly the same rate as the work done within
    the recursive calls.</st> <st c="25111">This leads to a balanced recursion tree,
    where each level contributes a comparable amount of work.</st> <st c="25210">In</st>
    *<st c="25213">Case 2</st>*<st c="25219">, the driving function</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/751.png)
    <st c="25242"><st c="25247">grows polynomially at the same rate as the watershed
    function, potentially with an additional logarithmic factor.</st> <st c="25361">More
    formally, this is</st> <st c="25384">as follows:</st></st></st>'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="24927">情况 2</st>* <st c="24934">中的</st> <st c="24942">主定理处理的场景是，递归调用外部的工作量（</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/750.png)<st
    c="25027"><st c="25033">）以与递归调用内部的工作量大致相同的速率增长。</st> <st c="25111">这导致了一个平衡的递归树，其中每一层贡献相同量的工作。</st>
    <st c="25210">在</st> *<st c="25213">情况 2</st>*<st c="25219">中，驱动函数</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/751.png)
    <st c="25242"><st c="25247">以与水分界函数相同的速率多项式增长，可能还带有附加的对数因子。</st> <st c="25361">更正式地，这表示如下：</st> '
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/752.png)
    <st c="25395"><st c="25397">for</st> <st c="25402">some</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>≥</mo><mn>0</mn></mrow></mrow></math>](img/753.png)</st>'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/752.png)
    <st c="25395"><st c="25397">对于</st> <st c="25402">某些</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>≥</mo><mn>0</mn></mrow></mrow></math>](img/753.png)</st>'
- en: <st c="25408">This</st> <st c="25413">means that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/754.png)
    <st c="25424"><st c="25428">is tightly bounded (both above and below) by a function
    proportional to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math>](img/755.png)
    <st c="25500"><st c="25501">multiplied by a</st> <st c="25518">logarithmic factor.</st></st></st>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25408">这</st> <st c="25413">意味着</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/754.png)
    <st c="25424"><st c="25428">被一个与</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math>](img/755.png)
    <st c="25500"><st c="25501">成比例的函数（上下界）紧密界定。</st> <st c="25518">并乘以一个</st> <st
    c="25518">对数因子。</st></st></st>
- en: <st c="25537">Why is</st> *<st c="25545">Case 2</st>* *<st c="25551">balanced</st>*<st
    c="25560">? In a recursion tree for</st> *<st c="25586">Case 2</st>*<st c="25592">,
    the work done at each level is roughly proportional to the number of nodes at
    that level.</st> <st c="25684">Since the number of nodes at each level increases
    exponentially with depth, the work done at each level also increases exponentially.</st>
    <st c="25818">However, the logarithmic factor in</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/756.png)
    <st c="25853"><st c="25858">slows down this increase, leading to a more</st> **<st
    c="25902">balanced</st>** <st c="25910">distribution of work throughout</st> <st
    c="25943">the tree.</st></st>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25537">为什么</st> *<st c="25545">Case 2</st>* *<st c="25551">是平衡的</st>*<st
    c="25560">？在递归树中，每个级别的工作量大致与该级别的节点数成比例。</st> *<st c="25586">Case 2</st>*<st c="25592">。随着深度增加，每个级别的节点数呈指数增长，因此每个级别的工作量也呈指数增长。</st>
    <st c="25684">然而，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/756.png)
    <st c="25853"><st c="25858">中的对数因子减缓了这种增长，导致工作在递归树中更</st> **<st c="25902">均衡</st>**
    <st c="25910">地分布。</st></st>
- en: <st c="25952">When the work is balanced across the levels of the recursion tree,
    the overall time complexity is determined by the total work done across all levels.</st>
    <st c="26104">This can be calculated by summing the work at each level, which
    turns out to be</st> <st c="26184">the following:</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25952">当工作在递归树的各级别间平衡时，整体时间复杂度由所有级别的总工作量决定。</st> <st c="26104">这可以通过计算每个级别的工作量之和来计算，其结果如下：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/757.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/757.png)'
- en: <st c="26242">In other words, the time complexity is the product of the watershed
    function and an additional logarithmic factor that accounts for the work done
    at</st> <st c="26391">each level.</st>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26242">换句话说，时间复杂度是分水岭函数的乘积，再加上一个考虑每个级别工作量的额外对数因子。</st> <st c="26391">每个级别。</st>
- en: <st c="26402">If the work done outside the recursive calls (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)<st
    c="26449"><st c="26455">) grows at roughly the same rate as the work done inside
    (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/759.png)<st
    c="26513"><st c="26521">, then the recursion tree is balanced.</st> <st c="26560">Each
    level contributes significantly to the overall runtime.</st> <st c="26621">The
    logarithmic factor in</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/760.png)
    <st c="26647"><st c="26648">represents the extra work done at each level due to
    the balanced nature of</st> <st c="26724">the recursion.</st></st></st></st>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26402">如果递归调用外的工作（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)<st
    c="26449"><st c="26455">）与递归内部的工作（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/759.png)<st
    c="26513"><st c="26521">）大致以相同的速度增长，那么递归树是平衡的。</st> <st c="26560">每一层对总体运行时间的贡献都很大。</st>
    <st c="26621">在</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/760.png)
    <st c="26647"><st c="26648">中的对数因子代表了由于递归的平衡性质，在每一层上所做的额外工作。</st></st></st></st>
- en: '**<st c="26738">Example 5.8</st>**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="26738">示例 5.8</st>**'
- en: <st c="26750">Consider this</st> <st c="26765">recurrence:</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/761.png)<st
    c="26777"><st c="26782">.</st></st>
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26750">考虑这个</st> <st c="26765">递推关系：</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/761.png)<st
    c="26777"><st c="26782">。</st></st>
- en: <st c="26783">Here,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/762.png)<st
    c="26790"><st c="26791">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/763.png)<st
    c="26793"><st c="26794">, and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></mrow></math>](img/764.png)<st
    c="26800"><st c="26801">. We have</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/765.png)<st
    c="26811"><st c="26823">. Since</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/766.png)<st
    c="26831"><st c="26857">,</st> *<st c="26859">Case 2</st>* <st c="26865">applies
    with k = 1, and the time complexity is</st> <st c="26913">as follows:</st></st></st></st></st></st>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26783">在这里，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/762.png)<st
    c="26790"><st c="26791">，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/763.png)<st
    c="26793"><st c="26794">，以及</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></mrow></math>](img/764.png)<st
    c="26800"><st c="26801">。我们有</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/765.png)<st
    c="26811"><st c="26823">。由于</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/766.png)<st
    c="26831"><st c="26857">，</st> *<st c="26859">情况 2</st>* <st c="26865">适用于 k =
    1，时间复杂度如下：</st> <st c="26913">如下所示：</st></st></st></st></st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/767.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/767.png)'
- en: <st c="26955">Case 3 – dominance of non-recursive work or root-heavy recursion
    trees</st>
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="26955">情况 3 – 非递归工作或根重递归树的主导作用</st>
- en: '*<st c="27025">Case 3</st>* <st c="27032">of the</st> <st c="27039">master
    theorem addresses scenarios where the work done outside the recursive calls (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/494.png)<st
    c="27124"><st c="27130">) significantly dominates the work done within the recursive
    calls.</st> <st c="27198">This leads to a “root-heavy” recursion tree, where the
    majority of the work is concentrated at the</st> <st c="27297">top levels.</st></st>'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="27025">情况 3</st>* <st c="27032">的</st> <st c="27039">主定理处理的是递归调用外部的工作（</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/494.png)<st
    c="27124"><st c="27130">）明显主导了递归调用中的工作量。</st> <st c="27198">这导致了一个“根重”的递归树，其中大部分工作集中在</st>
    <st c="27297">树的顶层。</st>'
- en: <st c="27308">In</st> *<st c="27312">Case 3</st>*<st c="27318">, the driving
    function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)
    <st c="27341"><st c="27344">grows polynomially at a faster rate than the watershed
    function, potentially with an additional logarithmic factor.</st> <st c="27460">More
    formally, this is</st> <st c="27483">as follows:</st></st>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27308">在</st> *<st c="27312">情况 3</st>*<st c="27318">中，驱动函数</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)
    <st c="27341"><st c="27344">以比临界点函数更快的速度多项式增长，可能还带有额外的对数因子。</st> <st c="27460">更正式地说，这是</st>
    <st c="27483">如下：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Ω</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo>+</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/770.png)
    <st c="27494"><st c="27509">for</st> <st c="27513">some</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>ε</mi><mo>></mo><mn>0</mn></mrow></mrow></math>](img/735.png)</st>'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Ω</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo>+</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/770.png)
    <st c="27494"><st c="27509">对于某些</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>ε</mi><mo>></mo><mn>0</mn></mrow></mrow></math>](img/735.png)</st>'
- en: <st c="27519">This means that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)
    <st c="27535"><st c="27538">is lower-bounded by a polynomial with a larger exponent
    than</st> <st c="27599">the watershed.</st></st>
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27519">这意味着</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)
    <st c="27535"><st c="27538">被一个比</st> <st c="27599">临界点</st> <st c="27599">的多项式下界所限制，该多项式的指数更大。</st>
- en: <st c="27613">In addition to the growth rate condition,</st> *<st c="27656">Case
    3</st>* <st c="27662">also requires a regularity condition to hold:</st>![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi mathvariant="normal">
    </mi><mi>a</mi><mi>f</mi><mfenced open="(" close=")"><mstyle scriptlevel="+1"><mfrac><mi>n</mi><mi>b</mi></mfrac></mstyle></mfenced><mo>≤</mo><mi>c</mi><mi>f</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced></mrow></mrow></math>](img/773.png) <st
    c="27708"><st c="27710">for some constant</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/774.png)
    <st c="27729"><st c="27730">and sufficiently</st> <st c="27748">large</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="27754"><st c="27803">.</st></st></st></st>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 除了增长率条件外，*<st c="27656">案例3</st>* <st c="27662">还需要满足一个规则性条件：</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi
    mathvariant="normal"> </mi><mi>a</mi><mi>f</mi><mfenced open="(" close=")"><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mi>b</mi></mfrac></mstyle></mfenced><mo>≤</mo><mi>c</mi><mi>f</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced></mrow></mrow></math>](img/773.png) <st
    c="27708"><st c="27710">对于某个常数</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/774.png)
    <st c="27729"><st c="27730">和足够</st> <st c="27748">大的</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="27754"><st c="27803">。</st></st></st></st>
- en: <st c="27804">This condition ensures that the work done at each level of the
    recursion tree does not grow too quickly as we move down</st> <st c="27925">the
    tree.</st>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27804">此条件确保递归树每一层的工作量不会随着我们向下遍历树而增长得过快。</st>
- en: <st c="27934">Why is</st> *<st c="27942">Case 3</st>* <st c="27948">root-heavy?</st>
    <st c="27961">Imagine the recursion tree again.</st> <st c="27995">In</st> *<st
    c="27998">Case 3</st>*<st c="28004">, the work done at the root of the tree (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)<st
    c="28045"><st c="28051">) is much larger than the work done in the subproblems.</st>
    <st c="28107">As we go down the tree, the work done at each level decreases significantly.</st>
    <st c="28184">This concentration of work at the top levels is why</st> *<st c="28236">Case
    3</st>* <st c="28242">is</st> <st c="28246">called</st> **<st c="28253">root-heavy</st>**<st
    c="28263">.</st></st>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27934">为什么</st> *<st c="27942">案例3</st>* <st c="27948">是根部集中型的？</st>
    <st c="27961">再想象一下递归树。</st> <st c="27995">在</st> *<st c="27998">案例3</st>*<st
    c="28004">中，树根的工作量（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)<st
    c="28045"><st c="28051">）远大于子问题中的工作量。</st> <st c="28107">随着我们向下遍历树，每一层的工作量显著减少。</st>
    <st c="28184">这种工作量在树顶层集中的现象就是为什么</st> *<st c="28236">案例3</st>* <st c="28242">被称为</st>
    **<st c="28253">根部集中型</st>**<st c="28263">。</st></st>
- en: <st c="28264">When the non-recursive work dominates, the overall time complexity
    of the algorithm is primarily determined by the work done at the root of the recursion
    tree, which is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/777.png)<st
    c="28434"><st c="28439">. Therefore, the time complexity becomes</st> <st c="28480">the
    following:</st></st>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28264">当非递归工作占主导时，算法的整体时间复杂度主要由递归树根部的工作量决定，即</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/777.png)<st
    c="28434"><st c="28439">。因此，时间复杂度变为</st> <st c="28480">以下形式：</st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>Θ</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow></mrow></mrow></math>](img/778.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>Θ</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow></mrow></mrow></math>](img/778.png)'
- en: <st c="28510">If the work done outside the recursive calls (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/779.png)<st
    c="28556"><st c="28562">) is much larger than the work</st> <st c="28593">done
    inside</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/780.png)<st
    c="28604"><st c="28608">), then most of the time is spent at the beginning, making
    the recursion tree “root-heavy.” In this scenario, the overall runtime is primarily
    determined by how much work is done before you start splitting the problem</st>
    <st c="28826">into subproblems.</st></st></st>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28510">如果递归调用外的工作量（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/779.png)<st
    c="28556"><st c="28562">）远大于</st> <st c="28593">递归内部的工作量</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/780.png)<st
    c="28604"><st c="28608">），那么大部分时间都花费在开始时，使得递归树呈现“根重”形态。在这种情况下，整体运行时间主要由在开始拆分问题之前完成的工作量决定</st>
    <st c="28826">进入子问题的处理。</st></st></st>
- en: '**<st c="28843">Example 5.9</st>**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="28843">示例 5.9</st>**'
- en: <st c="28855">Consider the</st> <st c="28869">following recurrence:</st>
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28855">考虑以下递归：</st> <st c="28869">以下递归：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/781.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/781.png)'
- en: <st c="28892">Here,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn><mo>,</mo><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/782.png)<st
    c="28898"><st c="28899">, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/783.png)<st
    c="28905"><st c="28911">. We have</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/784.png)<st
    c="28921"><st c="28933">. Since</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>Ω</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/785.png)
    <st c="28941"><st c="28964">and if the regularity condition holds,</st> *<st c="29003">Case
    3</st>* <st c="29009">applies, and the time complexity is</st> <st c="29046">as
    follows:</st></st></st></st></st>
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28892">这里，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn><mo>,</mo><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/782.png)<st
    c="28898"><st c="28899">，和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/783.png)<st
    c="28905"><st c="28911">。我们有</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/784.png)<st
    c="28921"><st c="28933">。由于</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>Ω</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/785.png)
    <st c="28941"><st c="28964">并且如果正则条件成立，</st> *<st c="29003">情况 3</st>* <st c="29009">适用，时间复杂度为</st>
    <st c="29046">如下：</st></st></st></st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/786.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/786.png)'
- en: <st c="29071">To evaluate</st> <st c="29083">the regularity condition, we check
    if</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/787.png)
    <st c="29121"><st c="29127">where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo>≤</mml:mo><mml:mn>0.5</mml:mn></mml:math>](img/788.png)<st
    c="29133"><st c="29136">. The regularity condition holds and</st> *<st c="29173">Case
    3</st>* <st c="29179">applies to</st> <st c="29191">this problem.</st></st></st>
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29071">为了评估</st> <st c="29083">正则性条件，我们检查是否</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/787.png)
    <st c="29121"><st c="29127">其中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo>≤</mml:mo><mml:mn>0.5</mml:mn></mml:math>](img/788.png)<st
    c="29133"><st c="29136">. 正则性条件成立，且</st> *<st c="29173">情况 3</st>* <st c="29179">适用于</st>
    <st c="29191">该问题。</st></st></st>
- en: <st c="29204">The regularity condition is crucial for</st> *<st c="29245">Case
    3</st>*<st c="29251">. Without it, the theorem’s conclusions might not hold.</st>
    <st c="29307">Some functions, such as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)<st
    c="29331"><st c="29336">, might appear to fit</st> *<st c="29358">Case 3</st>*
    <st c="29364">at first but fail the</st> <st c="29387">regularity condition.</st></st>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29204">正则性条件对于</st> *<st c="29245">情况 3</st>*<st c="29251">至关重要。如果没有它，定理的结论可能不成立。</st>
    <st c="29307">一些函数，如</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)<st
    c="29331"><st c="29336">，可能看起来最初符合</st> *<st c="29358">情况 3</st>* <st c="29364">，但无法满足</st>
    <st c="29387">正则性条件。</st></st>
- en: <st c="29408">Modified master theorem to solve subtracting recurrence functions</st>
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="29408">修改后的主定理用于解决递减递归函数</st>
- en: <st c="29474">The master theorem</st> <st c="29494">can be extended to handle
    a special case of subtracting recurrence functions of the</st> <st c="29578">following
    form:</st>
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29474">主定理</st> <st c="29494">可以扩展以处理以下形式的递减递归函数的特例：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/790.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/790.png)'
- en: <st c="29595">Here,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/791.png)
    <st c="29601"><st c="29602">with</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>≥</mo><mn>0</mn></mrow></mrow></math>](img/753.png)<st
    c="29608"><st c="29609">. Let’s break this</st> <st c="29628">down further:</st></st></st>
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29595">这里，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/791.png)
    <st c="29601"><st c="29602">其中</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>≥</mo><mn>0</mn></mrow></mrow></math>](img/753.png)<st
    c="29608"><st c="29609">. 让我们进一步分析：</st></st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>></mo><mn>0</mn></mrow></mrow></math>](img/793.png)
    <st c="29641"><st c="29643">represents the number of subproblems in the subtracting</st>
    <st c="29700">recursive function</st></st>'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>></mo><mn>0</mn></mrow></mrow></math>](img/793.png)
    <st c="29641"><st c="29643">表示减法递归函数中的子问题数量</st></st>'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>></mo><mn>0</mn></mrow></mrow></math>](img/794.png)
    <st c="29718"><st c="29720">is the size of the reduction for each subproblem,
    with</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>−</mo><mi>b</mi></mrow></mrow></math>](img/795.png)
    <st c="29776"><st c="29794">being the size of</st> <st c="29812">each subproblem</st></st></st>'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>></mo><mn>0</mn></mrow></mrow></math>](img/794.png)
    <st c="29718"><st c="29720">是每个子问题的规模缩小程度，其中</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>−</mo><mi>b</mi></mrow></mrow></math>](img/795.png)
    <st c="29776"><st c="29794">表示</st> <st c="29812">每个子问题的大小</st></st></st>'
- en: <st c="29827">In this type of problem, we have three</st> <st c="29867">distinct
    cases:</st>
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29827">在这类问题中，我们有三种</st> <st c="29867">不同的情况：</st>
- en: '**<st c="29882">Case 1</st>**<st c="29889">: If</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/796.png)<st
    c="29895"><st c="29900">,</st> <st c="29902">then</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">θ</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mi>k</mi></msup></mfenced></mrow></mrow></math>](img/797.png)<st
    c="29906"><st c="29920">.</st></st></st>'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="29882">情况 1</st>**<st c="29889">：如果</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/796.png)<st
    c="29895"><st c="29900">，</st> <st c="29902">那么</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">θ</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mi>k</mi></msup></mfenced></mrow></mrow></math>](img/797.png)<st
    c="29906"><st c="29920">。</st></st></st>'
- en: <st c="29921">When the number of subproblems</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/798.png)
    <st c="29953"><st c="29954">is less than 1, the recurrence is dominated by the
    driving function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="30023"><st c="30026">. Thus, the overall complexity is directly given</st>
    <st c="30075">by</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/800.png)<st
    c="30078"><st c="30081">.</st></st></st></st>
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29921">当子问题的数量</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/798.png)
    <st c="29953"><st c="29954">小于 1 时，递推式的主导项是驱动函数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="30023"><st c="30026">。因此，整体复杂度直接由</st> <st c="30075">给出</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/800.png)<st
    c="30078"><st c="30081">。</st></st></st></st>
- en: '**<st c="30082">Case 2</st>**<st c="30089">: If</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/801.png)<st
    c="30095"><st c="30096">,</st> <st c="30098">then</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">θ</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup></mfenced></mrow></mrow></math>](img/802.png)<st
    c="30102"><st c="30117">.</st></st></st>'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="30082">案例 2</st>**<st c="30089">：如果</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/801.png)<st
    c="30095"><st c="30096">，</st> <st c="30098">则</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">θ</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup></mfenced></mrow></mrow></math>](img/802.png)<st
    c="30102"><st c="30117">。</st></st></st>'
- en: <st c="30118">When</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/803.png)
    <st c="30124"><st c="30125">equals 1, each subproblem contributes equally to the
    overall complexity, leading to an additional factor of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="30234"><st c="30283">in the final solution.</st> <st c="30306">Therefore,
    the complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/805.png)
    <st c="30335"><st c="30336">.</st></st></st></st>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30118">当</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/803.png)
    <st c="30124"><st c="30125">等于 1 时，每个子问题对整体复杂度的贡献是相同的，从而导致最终解中的附加因子</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="30234"><st c="30283">。因此，复杂度是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/805.png)
    <st c="30335"><st c="30336">。</st></st></st></st>
- en: '**<st c="30337">Case 3</st>**<st c="30344">: If</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>></mo><mn>1</mn></mrow></mrow></math>](img/806.png)<st
    c="30350"><st c="30357">,</st> <st c="30359">then</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">θ</mi><mfenced
    open="(" close=")"><mrow><msup><mi>a</mi><mrow><mi>n</mi><mo>/</mo><mi>b</mi></mrow></msup><mo>.</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced></mrow></mfenced></mrow></mrow></math>](img/807.png)<st
    c="30363"><st c="30386">.</st></st></st>'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="30337">情况 3</st>**<st c="30344">：如果</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>></mo><mn>1</mn></mrow></mrow></math>](img/806.png)<st
    c="30350"><st c="30357">，</st> <st c="30359">那么</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">θ</mi><mfenced
    open="(" close=")"><mrow><msup><mi>a</mi><mrow><mi>n</mi><mo>/</mo><mi>b</mi></mrow></msup><mo>.</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced></mrow></mfenced></mrow></mrow></math>](img/807.png)<st
    c="30363"><st c="30386">。</st></st></st>'
- en: <st c="30387">When the</st> <st c="30397">number of subproblems</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/460.png)
    <st c="30419"><st c="30439">is greater than 1, the recurrence function grows exponentially.</st>
    <st c="30503">The overall complexity is then influenced by the combination of
    the exponential growth factor</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msup></mml:math>](img/809.png)
    <st c="30597"><st c="30598">and the driving function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="30624"><st c="30627">, leading</st> <st c="30637">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/811.png)<st
    c="30640"><st c="30651">.</st></st></st></st></st>
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30387">当子问题的数量</st> <st c="30397">![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/460.png)
    <st c="30419"><st c="30439">大于 1 时，递归函数呈指数增长。</st> <st c="30503">总体复杂度受指数增长因子</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msup></mml:math>](img/809.png)
    <st c="30597"><st c="30598">和驱动函数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="30624"><st c="30627">的组合影响</st> <st c="30637">导致</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/811.png)<st
    c="30640"><st c="30651">。</st></st></st></st></st>
- en: '**<st c="30652">Example 5.10</st>**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="30652">例子 5.10</st>**'
- en: <st c="30665">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/812.png)<st
    c="30672"><st c="30694">.</st></st>
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30665">解</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/812.png)<st
    c="30672"><st c="30694">。</st></st>
- en: '**<st c="30695">Solution</st>**<st c="30704">: Let’s identify the</st> <st
    c="30726">key parameters:</st>'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="30695">解决方案</st>**<st c="30704">：让我们确定</st> <st c="30726">关键参数：</st>'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>0.5</mn></mrow></mrow></math>](img/813.png)
    <st c="30741"><st c="30743">is the factor by which the number of subproblems decreases
    with</st> <st c="30808">each recursion</st></st>'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>0.5</mn></mrow></mrow></math>](img/813.png)
    <st c="30741"><st c="30743">是每次递归时子问题数量减少的因子</st> <st c="30808">每次递归</st></st>'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/814.png)
    <st c="30822"><st c="30824">is the amount by which the problem size decreases
    with</st> <st c="30880">each recursion</st></st>'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/814.png)
    <st c="30822"><st c="30824">是每次递归时问题规模减少的量</st> <st c="30880">每次递归</st></st>'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/470.png)
    <st c="30894"><st c="30896">is the exponent of the polynomial</st> <st c="30931">term</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)</st>'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/470.png)
    <st c="30894"><st c="30896">是多项式</st> <st c="30931">项的指数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)</st>'
- en: <st c="30985">Since</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/796.png)<st
    c="30991"><st c="30996">, we can apply</st> *<st c="31011">Case 1</st>*<st c="31017">:</st></st>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30985">由于</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/796.png)<st
    c="30991"><st c="30996">，我们可以应用</st> *<st c="31011">案例 1</st>*<st c="31017">：</st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/818.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/818.png)'
- en: <st c="31020">In our example, we have</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>0.5</mn></mrow></mrow></math>](img/819.png)<st
    c="31044"><st c="31045">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/820.png)<st
    c="31047"><st c="31048">, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/821.png)<st
    c="31054"><st c="31070">. Since all the conditions are met,</st> *<st c="31106">Case
    1</st>* <st c="31112">tells us</st> <st c="31122">the following:</st></st></st></st>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31020">在我们的例子中，已知</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>0.5</mn></mrow></mrow></math>](img/819.png)<st
    c="31044"><st c="31045">，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/820.png)<st
    c="31047"><st c="31048">，以及</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/821.png)<st
    c="31054"><st c="31070">。由于所有条件都已满足，</st> *<st c="31106">案例 1</st>* <st c="31112">告诉我们</st>
    <st c="31122">以下内容：</st></st></st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/749.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/749.png)'
- en: <st c="31138">This means that the time complexity of the algorithm described
    by the recurrence function is linear (i.e., it grows proportionally to the input
    size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/823.png)<st
    c="31287"><st c="31288">).</st> <st c="31291">The cost of the recursive calls
    diminishes rapidly due to the factor of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>0.5</mml:mn></mml:math>](img/824.png)<st
    c="31363"><st c="31364">, and the linear term</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="31386"><st c="31435">ultimately dominates</st> <st c="31456">the runtime.</st></st></st></st>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31138">这意味着由递归函数描述的算法的时间复杂度是线性的（即，它与输入大小成正比增长）</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/823.png)<st
    c="31287"><st c="31288">）。</st> <st c="31291">由于</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>0.5</mml:mn></mml:math>](img/824.png)<st
    c="31363"><st c="31364">的因素，递归调用的成本迅速降低，而线性项</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="31386"><st c="31435">最终主导了</st> <st c="31456">运行时间。</st></st></st></st>
- en: '**<st c="31468">Example 5.11</st>**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="31468">例 5.11</st>**'
- en: <st c="31481">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/552.png)<st
    c="31488"><st c="31508">.</st></st>
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31481">解：</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/552.png)<st
    c="31488"><st c="31508">。</st></st>
- en: '**<st c="31509">Solution</st>**<st c="31518">: Let’s identify the key parameters:</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/469.png)<st
    c="31556"><st c="31557">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:math>](img/512.png)<st
    c="31559"><st c="31560">,</st> <st c="31562">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:math>](img/829.png)<st
    c="31566"><st c="31567">.</st></st></st></st>'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="31509">解答</st>**<st c="31518">：让我们识别关键参数：</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/469.png)<st
    c="31556"><st c="31557">，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:math>](img/512.png)<st
    c="31559"><st c="31560">，</st> <st c="31562">以及</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:math>](img/829.png)<st
    c="31566"><st c="31567">。</st></st></st></st>'
- en: <st c="31568">Since</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/469.png)<st
    c="31575"><st c="31576">, we can apply</st> *<st c="31591">Case 2</st>*<st c="31597">:</st></st>
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31568">由于</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/469.png)<st
    c="31575"><st c="31576">，我们可以应用</st> *<st c="31591">情况 2</st>*<st c="31597">：</st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/831.png)<st
    c="31599"><st c="31600">.</st></st>'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/831.png)<st
    c="31599"><st c="31600">。</st></st>'
- en: '**<st c="31601">Example 5.12</st>**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="31601">示例 5.12</st>**'
- en: <st c="31614">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/832.png)<st
    c="31621"><st c="31622">.</st></st>
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31614">解答</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/832.png)<st
    c="31621"><st c="31622">.</st></st>
- en: '**<st c="31623">Solution</st>**<st c="31632">: Let’s identify the key parameters:</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:math>](img/833.png)<st
    c="31670"><st c="31671">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/834.png)<st
    c="31673"><st c="31674">,</st> <st c="31676">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/835.png)<st
    c="31680"><st c="31681">.</st></st></st></st>'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="31623">解法</st>**<st c="31632">：让我们确定关键参数：</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:math>](img/833.png)<st
    c="31670"><st c="31671">，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/834.png)<st
    c="31673"><st c="31674">，</st> <st c="31676">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/835.png)<st
    c="31680"><st c="31681">。</st></st></st></st>'
- en: <st c="31682">In our</st> <st c="31690">problem, we have</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>4</mn></mrow></mrow></math>](img/836.png)<st
    c="31707"><st c="31732">, which is greater than 1\.</st> <st c="31759">Therefore,
    we fall into</st> *<st c="31783">Case 3</st>* <st c="31789">of the modified master
    theorem.</st> <st c="31822">Substituting our values, we get</st> <st c="31854">the
    following:</st></st>
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31682">在我们的</st> <st c="31690">问题中，我们有</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>4</mn></mrow></mrow></math>](img/836.png)<st
    c="31707"><st c="31732">，它大于1\。</st> <st c="31759">因此，我们属于</st> *<st c="31783">情况
    3</st>* <st c="31789">修改后的主定理。</st> <st c="31822">代入我们的值，我们得到</st> <st c="31854">如下结果：</st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mi
    mathvariant="normal">*</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mi
    mathvariant="normal">*</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/837.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mi
    mathvariant="normal">*</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mi
    mathvariant="normal">*</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/837.png)'
- en: <st c="31881">The time complexity of this algorithm is exponential, specifically</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mi>*</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/838.png)<st
    c="31948"><st c="31964">. This means that the runtime grows incredibly quickly
    as the input size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/823.png)
    <st c="32037"><st c="32038">increases.</st> <st c="32050">The exponential term</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/840.png)
    <st c="32071"><st c="32072">dominates the growth, and the linear term</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="32115"><st c="32164">becomes negligible as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="32186"><st c="32235">gets larger.</st></st></st></st></st></st>
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31881">该算法的时间复杂度是指数级的，具体为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mi>*</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/838.png)<st
    c="31948"><st c="31964">。这意味着随着输入大小的增加，运行时间增长得非常快</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/823.png)
    <st c="32037"><st c="32038">。</st> <st c="32050">指数项</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/840.png)
    <st c="32071"><st c="32072">主导着增长，而线性项</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="32115"><st c="32164">随着</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="32186"><st c="32235">增大而变得可以忽略不计。</st></st></st></st></st></st>
- en: <st c="32247">Master theorem limitations</st>
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="32247">主定理的限制</st>
- en: <st c="32274">The</st> <st c="32278">master theorem is a powerful tool for analyzing
    divide-and-conquer algorithms.</st> <st c="32358">However, its effectiveness is
    confined to a specific class of recurrence functions.</st> <st c="32442">Recognizing
    these limitations is crucial for choosing the right approach when analyzing more</st>
    <st c="32535">complex algorithms:</st>
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32274">主定理是分析分治算法的强大工具。</st> <st c="32278">然而，它的有效性仅限于特定类型的递归函数。</st>
    <st c="32358">认识到这些限制对于选择分析更复杂算法时合适的方法至关重要：</st>
- en: '**<st c="32554">Restrictions on the driving</st>** **<st c="32583">function</st>**
    **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="bold-italic">f</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/843.png)**<st
    c="32593">:</st>'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="32554">驱动函数的限制</st>** **<st c="32583">函数</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">f</mml:mi><mml:mo>(</mml:mo><mml:mi
    mathvariant="bold-italic">n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/843.png)**<st
    c="32593">：</st>'
- en: '**<st c="32594">Non-polynomial functions</st>**<st c="32618">: The master theorem
    assumes that the work done outside the recursive calls (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)<st
    c="32696"><st c="32702">) is a polynomial function (e.g.,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/845.png)<st
    c="32736"><st c="32737">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/846.png)<st
    c="32739"><st c="32748">).</st> <st c="32751">If</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)
    <st c="32754"><st c="32759">is exponential (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/848.png)<st
    c="32775"><st c="32777">), logarithmic (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/849.png)<st
    c="32793"><st c="32799">), factorial (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:math>](img/850.png)<st
    c="32813"><st c="32817">), or another non-polynomial form, the master theorem
    cannot be</st> <st c="32881">directly applied.</st></st></st></st></st></st></st></st>'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="32594">非多项式函数</st>**<st c="32618">：主定理假设递归调用之外的工作（</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)<st
    c="32696"><st c="32702">）是一个多项式函数（例如，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/845.png)<st
    c="32736"><st c="32737">，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/846.png)<st
    c="32739"><st c="32748">）</st>。 <st c="32751">如果</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)
    <st c="32754"><st c="32759">是指数函数（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/848.png)<st
    c="32775"><st c="32777">），对数函数（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/849.png)<st
    c="32793"><st c="32799">），阶乘函数（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:math>](img/850.png)<st
    c="32813"><st c="32817">），或其他非多项式形式，主定理不能</st> <st c="32881">直接应用。</st></st></st></st></st></st></st></st>'
- en: '**<st c="32898">Non-positive functions</st>**<st c="32921">: The master theorem
    requires</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/777.png)
    <st c="32952"><st c="32957">to be strictly positive for all relevant input sizes.</st>
    <st c="33011">If</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi></mml:math>](img/852.png)<st
    c="33014"><st c="33016">) becomes negative or zero, the theorem’s assumptions</st>
    <st c="33070">are violated.</st></st></st>'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="32898">非正函数</st>**<st c="32921">：主定理要求</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/777.png)
    <st c="32952"><st c="32957">对于所有相关的输入大小，必须严格为正。</st> <st c="33011">如果</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi></mml:math>](img/852.png)<st
    c="33014"><st c="33016">) 变为负数或零，定理的假设</st> <st c="33070">将被违反。</st></st></st>'
- en: '**<st c="33083">Non-smooth functions</st>**<st c="33104">: The master theorem
    assumes a certain level of smoothness in</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/853.png)<st
    c="33167"><st c="33168">. Functions with abrupt changes, discontinuities, or piecewise
    definitions may not fit within the</st> <st c="33266">theorem’s framework.</st></st>'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="33083">非光滑函数</st>**<st c="33104">：主定理假设</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/853.png)<st
    c="33167"><st c="33168">具有一定的光滑性。具有突变、间断或分段定义的函数可能不符合该定理的框架。</st></st>'
- en: '**<st c="33286">Irregular functions</st>**<st c="33306">: The theorem’s effectiveness
    hinges on</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/754.png)
    <st c="33347"><st c="33351">having a regular growth pattern compared to the recursive
    part of the function.</st> <st c="33431">Functions</st> <st c="33441">with oscillatory
    behavior or variable exponents can challenge the</st> <st c="33507">theorem’s
    applicability.</st></st>'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="33286">不规则函数</st>**<st c="33306">：该定理的有效性取决于</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/754.png)
    <st c="33347"><st c="33351">与函数的递归部分相比，具有规则的增长模式。</st> <st c="33431">具有振荡行为或可变指数的函数可能会挑战该定理的适用性。</st></st>'
- en: '**<st c="33531">Constraints on recurrence parameters (</st>****![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="bold-italic">a</mml:mi></mml:math>](img/855.png)****<st c="33572">and</st>**
    **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="bold-italic">b</mml:mi></mml:math>](img/856.png)****<st c="33577">)</st>**<st
    c="33578">:</st>'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="33531">递归参数的约束（</st>****![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">a</mml:mi></mml:math>](img/855.png)****<st
    c="33572">和</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">b</mml:mi></mml:math>](img/856.png)****<st
    c="33577">)</st>**<st c="33578">：</st>'
- en: '**<st c="33579">Non-constant parameters</st>**<st c="33602">: The master theorem
    assumes that the number of subproblems (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/857.png)<st
    c="33664"><st c="33671">) and the factor by which the input size decreases (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/858.png)<st
    c="33723"><st c="33725">) are constants.</st> <st c="33742">If either of these
    depends on the input size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="33787"><st c="33836">, the master theorem is no</st> <st c="33863">longer applicable.</st></st></st></st>'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="33579">非恒定参数</st>**<st c="33602">：主定理假设子问题的数量（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/857.png)<st
    c="33664"><st c="33671">）以及输入规模减少的因子（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/858.png)<st
    c="33723"><st c="33725">）是常数。</st> <st c="33742">如果这些中的任何一个依赖于输入规模</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="33787"><st c="33836">，则主定理不再适用。</st> <st c="33863">。</st></st></st></st>'
- en: '**<st c="33881">Non-integer divisors</st>**<st c="33902">: The theorem assumes
    that the input is divided evenly into subproblems (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:math>](img/860.png)<st
    c="33976"><st c="33978">).</st> <st c="33981">Fractional or irrational values
    for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/861.png)
    <st c="34017"><st c="34018">can lead to complications that the theorem is not
    equipped</st> <st c="34078">to handle.</st></st></st>'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="33881">非整数除数</st>**<st c="33902">：该定理假设输入被均匀地划分为子问题（</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:math>](img/860.png)<st
    c="33976"><st c="33978">）。</st> <st c="33981">如果</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/861.png)
    <st c="34017"><st c="34018">是分数或无理数，</st> <st c="34078">则可能会导致定理无法处理的复杂情况。</st></st></st>'
- en: '**<st c="34088">Limitations on the recurrence</st>** **<st c="34119">function</st>**
    **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="bold-italic">T</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/862.png)**<st
    c="34129">:</st>'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="34088">递推函数的限制</st>** **<st c="34119">函数</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">T</mml:mi><mml:mo>(</mml:mo><mml:mi
    mathvariant="bold-italic">n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/862.png)**<st
    c="34129">：</st>'
- en: '**<st c="34130">Non-monotonic functions</st>**<st c="34153">: The master theorem
    assumes that the time complexity function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
    <st c="34217"><st c="34218">is monotonically increasing, meaning the algorithm’s
    runtime doesn’t decrease as the input size increases.</st> <st c="34326">Functions
    such as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/864.png)
    <st c="34344"><st c="34358">violate</st> <st c="34366">this assumption.</st></st></st>'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="34130">非单调函数</st>**<st c="34153">：主定理假设时间复杂度函数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
    <st c="34217"><st c="34218">是单调递增的，这意味着随着输入大小的增加，算法的运行时间不会减少。</st> <st c="34326">像</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/864.png)
    <st c="34344"><st c="34358">等函数</st> <st c="34366">违反了这一假设。</st></st></st>'
- en: <st c="34382">Alternative approaches</st>
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="34382">替代方法</st>
- en: <st c="34405">When the master</st> <st c="34421">theorem’s conditions are not
    met, alternative methods can be used to analyze the</st> <st c="34503">recurrence
    function:</st>
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34405">当主定理的条件不满足时，可以使用替代方法来分析</st> <st c="34503">递推函数：</st>
- en: '**<st c="34523">The Akra-Bazzi method</st>**<st c="34545">: This</st> <st c="34552">method
    generalizes the master theorem and can handle a wider range of recurrence functions,
    including those with non-polynomial differences.</st> <st c="34694">It provides
    a systematic way to calculate the asymptotic complexity of</st> <st c="34765">these
    recurrences.</st>'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="34523">Akra-Bazzi方法</st>**<st c="34545">：该</st> <st c="34552">方法推广了主定理，并能够处理更广泛的递推函数，包括那些具有非多项式差异的函数。</st>
    <st c="34694">它提供了一种系统化的方式来计算</st> <st c="34765">这些递推的渐近复杂度。</st>'
- en: '**<st c="34783">The substitution method</st>**<st c="34807">: This</st> <st
    c="34814">involves guessing a solution for the recurrence and then proving its
    correctness using</st> <st c="34902">mathematical induction.</st>'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="34783">代入法</st>**<st c="34807">：该</st> <st c="34814">方法涉及猜测递推的解，并通过</st>
    <st c="34902">数学归纳法</st> <st c="34807">来证明其正确性。</st>'
- en: '**<st c="34925">The iteration method</st>**<st c="34946">: This involves repeatedly
    expanding the recurrence function to uncover a pattern that leads to a</st> <st
    c="35045">closed-form solution.</st>'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="34925">迭代法</st>**<st c="34946">：这涉及到反复展开递推函数，揭示出一种模式，从而得到一个</st> <st
    c="35045">闭式解。</st>'
- en: '**<st c="35066">The recursive tree method</st>**<st c="35092">: This</st> <st
    c="35099">visual approach helps understand the structure of the recursive calls
    and estimate the overall work done at</st> <st c="35208">each level.</st>'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="35066">递归树方法</st>**<st c="35092">：这种</st> <st c="35099">可视化方法帮助理解递归调用的结构，并估计每一层的整体工作量。</st>'
- en: <st c="35219">In the</st> <st c="35227">next section, we introduce the Akra-Bazzi
    method, which is a generalization of the master theorem.</st> <st c="35326">This
    method extends our capability to solve a broader range of recurrence functions,
    addressing many of the limitations found in the</st> <st c="35459">master theorem.</st>
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35219">在下节中，我们将介绍 Akra-Bazzi 方法，这是对主定理的推广。</st> <st c="35326">该方法扩展了我们解决更广泛递推函数的能力，克服了主定理中的许多局限。</st>
- en: <st c="35474">Let’s review several examples that demonstrate the limitations
    of the</st> <st c="35545">master theorem.</st>
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35474">我们来看几个例子，这些例子展示了主定理的局限性。</st>
- en: '**<st c="35560">Example 5.13</st>**'
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**<st c="35560">例子 5.13</st>**'
- en: <st c="35573">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/865.png)<st
    c="35580"><st c="35581">.</st></st>
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35573">求解</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/865.png)<st
    c="35580"><st c="35581">。</st></st>
- en: '**<st c="35582">Solution</st>**<st c="35591">: The master theorem does not
    apply here since</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/866.png)
    <st c="35639"><st c="35640">is</st> <st c="35644">not constant.</st></st>'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="35582">解法</st>**<st c="35591">：主定理在这里不适用，因为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/866.png)
    <st c="35639"><st c="35640">不是常数。</st></st>'
- en: <st c="35657">To solve this</st> <st c="35671">recurrence, we need to explore
    other methods such as the substitution method, the iteration method, or the Akra-Bazzi
    method, which can handle the variable nature of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>a</mi></mrow></math>](img/867.png)<st
    c="35838"><st c="35839">and the complex form</st> <st c="35860">of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/868.png)<st
    c="35863"><st c="35872">.</st></st></st>
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35657">为了求解这个</st> <st c="35671">递推关系，我们需要探索其他方法，如代入法、迭代法或 Akra-Bazzi
    方法，这些方法能够处理</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>a</mi></mrow></math>](img/867.png)<st
    c="35838"><st c="35839">以及复杂的</st> <st c="35860">形式</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/868.png)<st
    c="35863"><st c="35872">的</st></st></st>
- en: '**<st c="35873">Example 5.14</st>**'
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**<st c="35873">例子 5.14</st>**'
- en: <st c="35886">Solve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>(</mo><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mn>2</mn><mi>T</mi><mfenced
    open="(" close=")"><mstyle scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle></mfenced><mo>+</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle></mrow></mrow></mrow></math>](img/869.png)<st
    c="35893"><st c="35894">.</st></st>
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35886">求解</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>(</mo><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mn>2</mn><mi>T</mi><mfenced
    open="(" close=")"><mstyle scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle></mfenced><mo>+</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle></mrow></mrow></mrow></math>](img/869.png)<st
    c="35893"><st c="35894">。</st></st>
- en: '**<st c="35895">Solution</st>**<st c="35904">:</st>'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="35895">解答</st>**<st c="35904">：</st>'
- en: <st c="35906">Before examining each case of the master theorem, let’s review
    the components of the</st> <st c="35991">recurrence function:</st>
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35906">在分析每种情况之前，我们先复习一下</st> <st c="35991">递归函数的组件：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/870.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/870.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)'
- en: <st c="36014">The critical exponent is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math>](img/731.png)
    <st c="36039"><st c="36040">where</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>0</mn><mo><</mo><mi>w</mi><mo><</mo><msub><mi>log</mi><mn>2</mn></msub><mn>2</mn><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/873.png)
    <st c="36047"><st c="36059">.</st></st></st>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36014">临界指数是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math>](img/731.png)
    <st c="36039"><st c="36040">其中</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>0</mn><mo><</mo><mi>w</mi><mo><</mo><msub><mi>log</mi><mn>2</mn></msub><mn>2</mn><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/873.png)
    <st c="36047"><st c="36059">。</st></st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mrow></mrow></mrow></math>](img/874.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mrow></mrow></mrow></math>](img/874.png)'
- en: <st c="36062">Now, let’s evaluate each case in the</st> <st c="36099">master
    theorem:</st>
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36062">现在，让我们评估</st> <st c="36099">主定理中的每种情况：</st>
- en: '**<st c="36114">Case 1</st>**<st c="36121">:</st>'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="36114">情况 1</st>**<st c="36121">：</st>'
- en: <st c="36123">Check if</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle><mo>=</mo><mi>O</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mrow><mn>1</mn><mo>−</mo><mi>ε</mi></mrow></msup></mfenced></mrow></mrow></math>](img/875.png)
    <st c="36132"><st c="36149">.</st></st>
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36123">检查是否</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle><mo>=</mo><mi>O</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mrow><mn>1</mn><mo>−</mo><mi>ε</mi></mrow></msup></mfenced></mrow></mrow></math>](img/875.png)
    <st c="36132"><st c="36149">。</st></st>
- en: <st c="36150">This is</st> <st c="36159">not true because</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="36176"><st c="36181">grows faster</st> <st c="36194">than</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msup></mml:math>](img/877.png)<st
    c="36199"><st c="36203">.</st></st></st>
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36150">这不成立，因为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="36176"><st c="36181">增长速度比</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msup></mml:math>](img/877.png)<st
    c="36199"><st c="36203">更快。</st></st></st>
- en: '**<st c="36204">Case 2</st>**<st c="36211">:</st>'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="36204">案例 2</st>**<st c="36211">:</st>'
- en: <st c="36213">Check if</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle><mo>=</mo><mi>θ</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mi>k</mi></msup><mi>n</mi></mrow></mfenced></mrow></mrow></math>](img/878.png)<st
    c="36222"><st c="36240">. We need to find a</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="36260"><st c="36261">such that the following</st> <st c="36286">is true:</st></st></st>
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否<st c="36213">Check if</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle><mo>=</mo><mi>θ</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mi>k</mi></msup><mi>n</mi></mrow></mfenced></mrow></mrow></math>](img/878.png)<st
    c="36222"><st c="36240">。我们需要找到一个</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="36260"><st c="36261">使得以下条件</st> <st c="36286">成立：</st></st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mi>k</mi></msup><mi>n</mi><mo>≤</mo><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac><mo>≤</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mrow><mfenced
    open="{" close="}"><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mi>n</mi></mrow></msup></mrow></mrow></math>](img/880.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mi>k</mi></msup><mi>n</mi><mo>≤</mo><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac><mo>≤</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mrow><mfenced
    open="{" close="}"><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mi>n</mi></mrow></msup></mrow></mrow></math>](img/880.png)'
- en: <st c="36298">There is no such</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="36315"><st c="36316">that can sandwich</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="36335"><st c="36340">between</st> <st c="36348">these functions.</st></st></st>
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36298">不存在这样一个</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="36315"><st c="36316">能够夹住</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="36335"><st c="36340">在这些函数之间。</st></st></st>
- en: '**<st c="36364">Case 3</st>**<st c="36371">:</st>'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="36364">案例 3</st>**<st c="36371">:</st>'
- en: <st c="36373">Check if</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle><mo>=</mo><mi
    mathvariant="normal">Ω</mi><mfenced open="(" close=")"><msup><mi mathvariant="normal">n</mi><mrow><mn>1</mn><mo>+</mo><mi>ε</mi></mrow></msup></mfenced></mrow></mrow></math>](img/883.png)<st
    c="36382"><st c="36400">. This might seem applicable because</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfrac></mml:math>](img/884.png)
    <st c="36437"><st c="36442">grows faster than</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msup></mml:math>](img/885.png)<st
    c="36460"><st c="36461">. However, we must also evaluate the</st> <st c="36498">regularity
    condition:</st></st></st></st>
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36373">检查是否</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle><mo>=</mo><mi
    mathvariant="normal">Ω</mi><mfenced open="(" close=")"><msup><mi mathvariant="normal">n</mi><mrow><mn>1</mn><mo>+</mo><mi>ε</mi></mrow></msup></mfenced></mrow></mrow></math>](img/883.png)<st
    c="36382"><st c="36400">. 这可能适用，因为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfrac></mml:math>](img/884.png)
    <st c="36437"><st c="36442">增长得比</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msup></mml:math>](img/885.png)<st
    c="36460"><st c="36461">要快</st> <st c="36498">然而，我们还必须评估</st> <st c="36498">规律性条件：</st></st></st></st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>a</mml:mi><mml:mi>f</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/886.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>a</mml:mi><mml:mi>f</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/886.png)'
- en: <st c="36531">Substituting, we get</st> <st c="36552">the following:</st>
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36531">代入后，我们得到</st> <st c="36552">以下结果：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>2</mml:mn><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="italic">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mfrac><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="italic">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfrac></mml:math>](img/887.png)
    <st c="36566"><st c="36588">for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/888.png)</st>'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>2</mml:mn><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="italic">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mfrac><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="italic">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfrac></mml:math>](img/887.png)
    <st c="36566"><st c="36588">对于</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/888.png)</st>'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mn>1</mn><mrow><mi>log</mi><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>≤</mo><mfrac><mi>c</mi><mrow><mi>log</mi><mi>n</mi></mrow></mfrac></mrow></mrow></math>](img/889.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mn>1</mn><mrow><mi>log</mi><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>≤</mo><mfrac><mi>c</mi><mrow><mi>log</mi><mi>n</mi></mrow></mfrac></mrow></mrow></math>](img/889.png)'
- en: <st c="36604">For large</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="36614"><st c="36663">, there is no constant</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/888.png)
    <st c="36686"><st c="36696">that satisfies this condition.</st> <st c="36727">Thus,</st>
    *<st c="36733">Case 3</st>* <st c="36739">does</st> <st c="36745">not apply.</st></st></st>
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36604">对于较大的</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="36614"><st c="36663">，不存在一个常数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/888.png)
    <st c="36686"><st c="36696">能够满足此条件。</st> <st c="36727">因此，</st> *<st c="36733">案例
    3</st>* <st c="36739">不适用。</st></st></st>
- en: '<st c="36755">The recurrence function of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="italic">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfrac></mml:math>](img/892.png)
    <st c="36783"><st c="36803">in the previous example does not fit any case of the
    master theorem.</st> <st c="36872">This demonstrates a limitation of the master
    theorem: it requires</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/893.png)
    <st c="36938"><st c="36943">to be bounded by polynomial functions and to have
    a polynomial difference with the critical exponent</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="italic">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:math>](img/722.png)<st
    c="37044"><st c="37045">. Here,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/895.png)
    <st c="37053"><st c="37062">does not fit within these bounds, highlighting the
    need for alternative methods, such as the substitution method, the iteration method,
    or the Akra-Bazzi method to solve</st> <st c="37232">this recurrence.</st></st></st></st></st>'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36755">前面例子中的递归函数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="italic">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfrac></mml:math>](img/892.png)
    <st c="36783"><st c="36803">不符合主定理的任何情况。</st> <st c="36872">这展示了主定理的一个局限性：它要求</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/893.png)
    <st c="36938"><st c="36943">被多项式函数有界，并且与临界指数之间有多项式差异</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="italic">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:math>](img/722.png)<st
    c="37044"><st c="37045">。在这里，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/895.png)
    <st c="37053"><st c="37062">不符合这些界限，这突显了需要使用替代方法，如代入法、迭代法或 Akra-Bazzi 方法来求解</st>
    <st c="37232">这个递归。</st></st></st></st></st>
- en: '**<st c="37248">Example 5.15</st>**'
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**<st c="37248">示例 5.15</st>**'
- en: <st c="37261">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/896.png)<st
    c="37268"><st c="37273">.</st></st>
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37261">求解</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/896.png)<st
    c="37268"><st c="37273">。</st></st>
- en: '**<st c="37274">Solution</st>**<st c="37283">: The master theorem does not
    apply</st> <st c="37320">since</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/897.png)<st
    c="37326"><st c="37327">.</st></st>'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="37274">解答</st>**<st c="37283">：主定理不适用</st> <st c="37320">因为</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/897.png)<st
    c="37326"><st c="37327">。</st></st>'
- en: '**<st c="37328">Example 5.16</st>**'
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**<st c="37328">例 5.16</st>**'
- en: <st c="37341">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>64</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/898.png)<st
    c="37348"><st c="37371">.</st></st>
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37341">求解</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>64</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/898.png)<st
    c="37348"><st c="37371">。</st></st>
- en: '**<st c="37372">Solution</st>**<st c="37381">: The</st> <st c="37388">master
    theorem does not apply</st> <st c="37418">because</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/899.png)<st
    c="37426"><st c="37435">.</st></st>'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="37372">解答</st>**<st c="37381">：主定理不适用</st> <st c="37388">因为</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/899.png)<st
    c="37426"><st c="37435">。</st></st>'
- en: '**<st c="37436">Example 5.17</st>**'
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**<st c="37436">例 5.17</st>**'
- en: <st c="37449">Solve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mi>n</mi><mo>(</mo><mn>2</mn><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/900.png)<st
    c="37456"><st c="37457">.</st></st>
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37449">求解</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mi>n</mi><mo>(</mo><mn>2</mn><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/900.png)<st
    c="37456"><st c="37457">。</st></st>
- en: '**<st c="37458">Solution</st>**<st c="37467">:</st>'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="37458">解答</st>**<st c="37467">：</st>'
- en: <st c="37469">This recurrence function describes a divide-and-conquer algorithm
    where the following is</st> <st c="37558">the case:</st>
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37469">该递归函数描述了一个分治算法，其中以下情况成立：</st>
- en: <st c="37567">The problem of size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="37588"><st c="37637">is divided into one subproblem of</st> <st c="37671">size</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:math>](img/902.png)</st>
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="37567">大小为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="37588"><st c="37637">的问题被分解为一个大小为</st> <st c="37671">的子问题</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:math>](img/902.png)</st>
- en: <st c="37680">The work done outside the recursive call</st> <st c="37721">is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mo>-</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/903.png)
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="37680">递归调用外的工作</st> <st c="37721">是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mo>-</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/903.png)
- en: <st c="37736">Why doesn’t the master theorem</st> <st c="37767">directly apply?</st>
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37736">为什么主定理</st> <st c="37767">不能直接应用？</st>
- en: <st c="37782">The master theorem works best with functions that have simple
    polynomial growth.</st> <st c="37864">In this case, the term</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mo>-</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/903.png)
    <st c="37887"><st c="37899">isn’t a straightforward polynomial due to the presence
    of the</st> <st c="37961">cosine function.</st></st>
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37782">主定理最适用于具有简单多项式增长的函数。</st> <st c="37864">在这种情况下，项</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mo>-</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/903.png)
    <st c="37887"><st c="37899">由于存在余弦函数，它不是一个简单的多项式。</st>
- en: <st c="37977">One alternative approach is to simplify the non-recursive part
    of the recurrence function.</st> <st c="38069">We can leverage the fact that the
    cosine function oscillates between -1</st> <st c="38141">and 1:</st>
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37977">一种替代方法是简化递归函数中的非递归部分。</st> <st c="38069">我们可以利用余弦函数在-1</st> <st
    c="38141">和1之间震荡的事实：</st>
- en: <st c="38147">-</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>1</mn><mo>≤</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>≤</mo><mn>1</mn></mrow></mrow></math>](img/905.png)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38147">-</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>1</mn><mo>≤</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>≤</mo><mn>1</mn></mrow></mrow></math>](img/905.png)
- en: <st c="38150">Multiplying by -1 and adding 2, we get</st> <st c="38189">the
    following:</st>
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38150">乘以-1并加上2，我们得到</st> <st c="38189">如下：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mn>1</mn><mo>≤</mo><mn>2</mn><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>≤</mo><mn>3</mn></mrow></mrow></math>](img/906.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mn>1</mn><mo>≤</mo><mn>2</mn><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>≤</mo><mn>3</mn></mrow></mrow></math>](img/906.png)'
- en: <st c="38205">Therefore, the following is</st> <st c="38233">the case:</st>
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38205">因此，以下是</st> <st c="38233">这种情况：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>n</mi><mo>≤</mo><mi>n</mi><mo>(</mo><mn>2</mn><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>)</mo><mo>≤</mo><mn>3</mn><mi>n</mi></mrow></mrow></mrow></math>](img/907.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>n</mi><mo>≤</mo><mi>n</mi><mo>(</mo><mn>2</mn><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>)</mo><mo>≤</mo><mn>3</mn><mi>n</mi></mrow></mrow></mrow></math>](img/907.png)'
- en: <st c="38269">This tells us</st> <st c="38282">that</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>n</mi><mo>(</mo><mn>2</mn><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/908.png)
    <st c="38288"><st c="38298">is bounded above and below by linear functions.</st>
    <st c="38346">Now, we apply the master theorem to the function with bounds.</st>
    <st c="38408">We can create two new recurrence functions based on the lower and
    upper bounds of the</st> <st c="38494">non-recursive term:</st></st>
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38269">这告诉我们</st> <st c="38282">即</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>n</mi><mo>(</mo><mn>2</mn><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/908.png)
    <st c="38288"><st c="38298">上下有线性函数的界限。</st> <st c="38346">现在，我们将主定理应用于带界限的函数。</st>
    <st c="38408">我们可以基于非递归项的上下界创建两个新的递归函数：</st>
- en: '**<st c="38513">Lower bound</st>****![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>:</mo><mi>T</mi><mi
    mathvariant="normal">⁻</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mi
    mathvariant="normal">⁻</mi><mo>(</mo><mstyle scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/909.png)**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="38513">下界</st>** **![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>:</mo><mi>T</mi><mi
    mathvariant="normal">⁻</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mi
    mathvariant="normal">⁻</mi><mo>(</mo><mstyle scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/909.png)**'
- en: '**<st c="38527">Upper</st>** **<st c="38533">bound</st>**<st c="38538">:</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mi>n</mml:mi></mml:math>](img/910.png)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="38527">上界</st>** **<st c="38533">:</st>** ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mi>n</mml:mi></mml:math>](img/910.png)'
- en: <st c="38561">Now, both of these recurrences fit the form of the</st> <st c="38612">master
    theorem:</st>
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38561">现在，这两个递归都符合</st> <st c="38612">主定理的形式：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/801.png)
    <st c="38627"><st c="38629">(number</st> <st c="38638">of subproblems)</st></st>'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/801.png)
    <st c="38627"><st c="38629">(子问题的数量)</st></st>'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)
    <st c="38653"><st c="38655">(factor by which the input</st> <st c="38683">size
    decreases)</st></st>'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)
    <st c="38653"><st c="38655">(输入大小的减少因子)</st></st>'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>n</mi></mrow></mrow></mrow></math>](img/746.png)
    <st c="38698"><st c="38700">(for the lower bound) and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>3</mn><mi>n</mi></mrow></mrow></mrow></math>](img/914.png)
    <st c="38727"><st c="38736">(for the</st> <st c="38745">upper bound)</st></st></st>'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>n</mi></mrow></mrow></mrow></math>](img/746.png)
    <st c="38698"><st c="38700">(用于下界) 和</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>3</mn><mi>n</mi></mrow></mrow></mrow></math>](img/914.png)
    <st c="38727"><st c="38736">(用于</st> <st c="38745">上界)</st></st></st>'
- en: <st c="38757">In both cases, we</st> <st c="38776">have</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/915.png)<st
    c="38781"><st c="38782">.</st></st>
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们都有![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/915.png)。
- en: <st c="38783">Applying</st> *<st c="38793">Case 2</st>* <st c="38799">of the
    master theorem to both</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>⁻</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/916.png)
    <st c="38830"><st c="38850">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>⁺</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/917.png)<st
    c="38854"><st c="38874">, we get</st> <st c="38883">the following:</st></st></st>
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 应用主定理的*案例 2*，我们对![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>⁻</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/916.png)
    和![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>⁺</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/917.png)，得到如下结果：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mi
    mathvariant="normal">⁻</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>Θ</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/918.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mi
    mathvariant="normal">⁻</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>Θ</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/918.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mi
    mathvariant="normal">⁺</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>Θ</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/919.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mi
    mathvariant="normal">⁺</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>Θ</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/919.png)'
- en: <st c="38935">Since</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mi
    mathvariant="normal">⁻</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>≤</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>≤</mo><mi>T</mi><mi
    mathvariant="normal">⁺</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/920.png)
    <st c="38941"><st c="38962">and</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/921.png)
    <st c="38965"><st c="38967">are sandwiched between two other functions, and both</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>⁻</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/922.png)
    <st c="39021"><st c="39038">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>⁺</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/917.png)
    <st c="39042"><st c="39062">are</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>Θ</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/924.png)<st
    c="39066"><st c="39077">, we can conclude</st> <st c="39095">the following:</st></st></st></st></st></st>
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 由于![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mi
    mathvariant="normal">⁻</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>≤</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>≤</mo><mi>T</mi><mi
    mathvariant="normal">⁺</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/920.png)和![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/921.png)被夹在两个其他函数之间，并且这两个![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>⁻</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/922.png)和![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>⁺</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/917.png)是![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>Θ</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/924.png)，因此我们可以得出以下结论：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>Θ</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/925.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>Θ</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/925.png)'
- en: <st c="39128">You should note that the oscillating nature of the cosine function
    in the previous example does not significantly affect the overall growth rate
    of the recurrence function.</st> <st c="39301">In the long run, the linear term</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/926.png)
    <st c="39334"><st c="39335">dominates the behavior, and the algorithm’s time complexity
    is primarily determined by the recursive splitting and the linear work done in</st>
    <st c="39475">each step.</st></st>
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到，前一个例子中余弦函数的振荡特性并不会显著影响递归函数的整体增长率。长期来看，线性项![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/926.png)主导了行为，而算法的时间复杂度主要由递归拆分和每步中执行的线性工作决定。
- en: '**<st c="39485">Example 5.18</st>**'
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**例 5.18**'
- en: <st c="39498">Solve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>4</mn><mi>T</mi><mo>(</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle></mrow></mrow></mrow></math>](img/927.png)<st
    c="39505"><st c="39523">.</st></st>
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 求解![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>4</mn><mi>T</mi><mo>(</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle></mrow></mrow></mrow></math>](img/927.png)。
- en: '**<st c="39524">Solution</st>**<st c="39533">: At first glance, the master
    theorem seems like the right tool.</st> <st c="39599">We have</st> <st c="39607">the
    following:</st>'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="39524">解法</st>**<st c="39533">：乍一看，主定理似乎是正确的工具。</st> <st c="39599">我们有</st>
    <st c="39607">以下内容：</st>'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>4</mn></mrow></mrow></math>](img/836.png)
    <st c="39621"><st c="39647">(number</st> <st c="39655">of subproblems)</st></st>'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>4</mn></mrow></mrow></math>](img/836.png)
    <st c="39621"><st c="39647">(子问题的数量)</st></st>'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)
    <st c="39670"><st c="39672">(factor by which the input</st> <st c="39700">size
    decreases)</st></st>'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)
    <st c="39670"><st c="39672">(输入大小减少的因子)</st></st>'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle></mrow></mrow></mrow></math>](img/930.png)
    <st c="39715"><st c="39717">(work done outside of the</st> <st c="39744">recursive
    calls)</st></st>'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle></mrow></mrow></mrow></math>](img/930.png)
    <st c="39715"><st c="39717">(递归调用外的工作量)</st></st>'
- en: <st c="39760">This gives</st> <st c="39772">us a</st> **<st c="39777">watershed</st>**
    <st c="39786">function</st> <st c="39796">of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mn>4</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/931.png)<st
    c="39799"><st c="39808">.</st></st>
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39760">这给我们带来了</st> <st c="39772">一个</st> **<st c="39777">分界点</st>**
    <st c="39786">函数</st> <st c="39796">为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mn>4</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/931.png)<st
    c="39799"><st c="39808">。</st></st>
- en: <st c="39809">Now, we compare</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/932.png)
    <st c="39826"><st c="39835">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/231.png)<st
    c="39838"><st c="39839">.</st></st></st>
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39809">现在，我们比较</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/932.png)
    <st c="39826"><st c="39835">与</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/231.png)<st
    c="39838"><st c="39839">进行比较。</st></st></st>
- en: <st c="39840">Similar to</st> *<st c="39852">Example 5.17</st>*<st c="39864">,
    the function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/934.png)
    <st c="39879"><st c="39884">doesn’t fit neatly into any of the three cases of
    the</st> <st c="39938">master theorem:</st></st>
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39840">与</st> *<st c="39852">示例 5.17</st>*<st c="39864">相似，函数</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/934.png)
    <st c="39879"><st c="39884">无法整齐地适配</st> <st c="39938">主定理的三个情况之一：</st></st>
- en: '**<st c="39953">Case 1</st>**<st c="39960">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi><mml:mo>-</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/935.png)
    <st c="39963"><st c="39985">but</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="39989"><st c="39994">grows faster than the</st> <st c="40016">watershed
    function</st></st></st>'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="39953">案例 1</st>**<st c="39960">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi><mml:mo>-</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/935.png)
    <st c="39963"><st c="39985">但是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="39989"><st c="39994">增长速度比</st> <st c="40016">分水岭函数</st></st></st>'
- en: '**<st c="40034">Case 2</st>**<st c="40041">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/937.png)
    <st c="40044"><st c="40055">but</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="40059"><st c="40064">doesn’t fit</st> <st c="40076">this form</st></st></st>'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="40034">案例 2</st>**<st c="40041">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/937.png)
    <st c="40044"><st c="40055">但是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="40059"><st c="40064">不符合</st> <st c="40076">该形式</st></st></st>'
- en: '**<st c="40085">Case 3</st>****![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>:</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Ω</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi><mml:mo>+</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/939.png)**
    <st c="40102">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="40106"><st c="40111">grows slower than the</st> <st c="40133">watershed
    function</st></st>'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="40085">案例 3</st>****![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>:</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Ω</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi><mml:mo>+</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/939.png)**
    <st c="40102">并且</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="40106"><st c="40111">增长速度慢于</st> <st c="40133">分水岭函数</st></st>'
- en: <st c="40151">Even though</st> *<st c="40164">Case 3</st>* <st c="40170">seems
    like a potential fit, the regularity condition fails.</st> <st c="40231">The condition
    requires that</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mi>f</mi><mfenced
    open="(" close=")"><mstyle scriptlevel="+1"><mfrac><mi>n</mi><mi>b</mi></mfrac></mstyle></mfenced><mo>≤</mo><mi>c</mi><mi>f</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced></mrow></mrow></math>](img/941.png) <st
    c="40258"><st c="40269">for some constant</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/774.png)
    <st c="40287"><st c="40288">and sufficiently large n.</st> <st c="40315">In this
    case, it becomes</st> <st c="40340">the following:</st></st></st>
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*<st c="40164">案例 3</st>* <st c="40170">看起来是一个潜在的适配，但是正则性条件不成立。</st> <st c="40231">该条件要求</st>![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mi>f</mi><mfenced
    open="(" close=")"><mstyle scriptlevel="+1"><mfrac><mi>n</mi><mi>b</mi></mfrac></mstyle></mfenced><mo>≤</mo><mi>c</mi><mi>f</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced></mrow></mrow></math>](img/941.png) <st
    c="40258"><st c="40269">对于某个常数</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/774.png)
    <st c="40287"><st c="40288">以及足够大的n。</st> <st c="40315">在这种情况下，它变为</st> <st c="40340">以下内容：</st></st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mn>4</mn><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo><mo>/</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo><mo>≤</mo><mi>c</mi><mo>(</mo><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac><mo>)</mo></mrow></mrow></mrow></math>](img/943.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mn>4</mn><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo><mo>/</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo><mo>≤</mo><mi>c</mi><mo>(</mo><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac><mo>)</mo></mrow></mrow></mrow></math>](img/943.png)'
- en: <st c="40356">Simplifying, we get</st> <st c="40376">the following:</st>
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40356">简化后，我们得到</st> <st c="40376">如下结果：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/944.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/944.png)'
- en: <st c="40418">For large values of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/945.png)<st
    c="40438"><st c="40439">, we cannot find a constant</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/946.png)
    <st c="40467"><st c="40468">that satisfies this inequality.</st> <st c="40501">Therefore,</st>
    *<st c="40512">Case 3</st>* <st c="40518">of the master theorem</st> <st c="40541">doesn’t
    hold.</st></st></st>
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40418">当</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/945.png)<st
    c="40438"><st c="40439">的值较大时，我们无法找到一个常数</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/946.png)
    <st c="40467"><st c="40468">来满足这个不等式。</st> <st c="40501">因此，</st> *<st c="40512">主定理的情况
    3</st>* <st c="40518">不成立。</st> <st c="40541">。</st>
- en: <st c="40554">This section explains a systematic approach for solving recurrences
    that commonly appear in the analysis of divide-and-conquer algorithms.</st> <st
    c="40694">The master method provides a set of straightforward rules to determine
    the asymptotic behavior of recurrences.</st> <st c="40805">It categorizes the
    recurrences into three cases based on the relative growth rates of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/947.png)
    <st c="40891"><st c="40894">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow/></mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msup></mml:math>](img/948.png)<st
    c="40898"><st c="40907">, allowing for quick and accurate complexity estimation.</st>
    <st c="40964">The method’s utility lies in its ability to handle a wide range
    of problems without requiring detailed, case-by-case analysis, making it a valuable
    tool in algorithm design</st> <st c="41137">and analysis.</st></st></st>
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40554">本节介绍了解决在分析分治算法中常见的递归关系的系统方法。</st> <st c="40694">主方法提供了一组简单的规则，用于确定递归关系的渐近行为。</st>
    <st c="40805">它根据</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/947.png)
    <st c="40891"><st c="40894">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow/></mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msup></mml:math>](img/948.png)<st
    c="40898"><st c="40907">的相对增长速度将递归关系分类为三种情况，从而可以快速准确地估算复杂度。</st> <st c="40964">该方法的实用性在于它能够处理广泛的问题，而无需详细的逐案例分析，使其成为算法设计和分析中的宝贵工具。</st>
    <st c="41137">。</st>
- en: <st c="41150">Beyond the master theorem – the Akra-Bazzi method</st>
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="41150">超越主定理 – Akra-Bazzi 方法</st>
- en: <st c="41200">In the previous section, we</st> <st c="41229">discussed the limitations
    of the master theorem in solving recurrence functions.</st> <st c="41310">Although
    the master theorem can address a wide range of problems and is the most common
    approach, it does have its constraints.</st> <st c="41438">For example, it only
    applies to a specific class of divide-and-conquer</st> <st c="41509">recurrence
    functions:</st>
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41200">在上一节中，我们</st> <st c="41229">讨论了主定理在解决递归函数时的局限性。</st> <st c="41310">尽管主定理能够处理广泛的问题，并且是最常见的方法，但它确实有一些局限性。</st>
    <st c="41438">例如，它仅适用于特定类型的分治法</st> <st c="41509">递归函数：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>a</mi><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mi>b</mi><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/949.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>a</mi><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mi>b</mi><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/949.png)'
- en: <st c="41552">Here, the subproblem sizes are equal (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:math>](img/950.png)<st
    c="41590"><st c="41595">).</st> <st c="41598">As we showed in the previous section,
    we can solve special cases of subtracting recurrence functions using the master
    theorem.</st> <st c="41725">It also has limitations on the form of the function</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="41777"><st c="41780">. Specifically, the master theorem struggles with</st>
    <st c="41830">the following:</st></st></st>
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41552">在这里，子问题规模是相等的（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:math>](img/950.png)<st
    c="41590"><st c="41595">）。</st> <st c="41598">正如我们在上一节所展示的，我们可以使用主定理解决减法递归函数的特殊情况。</st>
    <st c="41725">它对函数形式</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="41777"><st c="41780">也有局限。</st> <st c="41830">具体来说，主定理在处理以下问题时会遇到困难：</st></st></st>
- en: '**<st c="41844">Unequal subproblem sizes</st>**<st c="41869">: The recurrence
    splits into subproblems of significantly</st> <st c="41928">different sizes</st>'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="41844">不等的子问题规模</st>**<st c="41869">：递归拆分成大小差异显著的子问题</st> <st c="41928">不同的规模</st>'
- en: '**<st c="41943">More complex splitting</st>**<st c="41966">: There are more
    than two subproblems in</st> <st c="42008">the recursion</st>'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="41943">更复杂的拆分</st>**<st c="41966">：递归中有超过两个子问题</st> <st c="42008">的情况</st>'
- en: '**<st c="42021">Non-polynomial work</st>**<st c="42041">: The function</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)
    <st c="42057"><st c="42062">representing the work done outside the recursive calls
    isn’t easily categorized as polynomial</st> <st c="42156">or logarithmic</st></st>'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="42021">非多项式工作量</st>**<st c="42041">：函数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)
    <st c="42057"><st c="42062">表示递归调用外部工作量的函数，并不能轻易归类为多项式</st> <st c="42156">或对数形式</st></st>'
- en: <st c="42170">For cases where the master theorem falls short, the</st> **<st
    c="42223">Akra-Bazzi method</st>** <st c="42240">offers solutions for a broader
    spectrum of recurrence functions.</st> <st c="42306">This method extends our ability
    to solve more complex recurrences, providing a valuable tool for algorithm analysis.</st>
    <st c="42423">The Akra-Bazzi method can handle recurrences of the following more</st>
    <st c="42490">general form:</st>
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42170">对于主定理无法解决的情况，</st> **<st c="42223">Akra-Bazzi方法</st>** <st c="42240">为更广泛的递归函数提供了解决方案。</st>
    <st c="42306">该方法扩展了我们解决更复杂递归问题的能力，是算法分析中的一项有价值工具。</st> <st c="42423">Akra-Bazzi方法能够处理以下更</st>
    <st c="42490">一般形式的递归：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>](img/953.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>](img/953.png)'
- en: <st c="42536">Here, the following is</st> <st c="42559">the case:</st>
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42536">在这里，以下是</st> <st c="42559">的情况：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="42568"><st c="42570">is the number of subproblems (can be greater</st>
    <st c="42616">than 2)</st></st>'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="42568"><st c="42570">是子问题的数量（可以大于</st> <st c="42616">2）</st></st>'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>></mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math>](img/955.png)
    <st c="42623"><st c="42628">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math>](img/227.png)
    <st c="42632"><st c="42633">is</st> <st c="42637">a constant</st></st></st>'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>></mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math>](img/955.png)
    <st c="42623"><st c="42628">并且</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math>](img/227.png)
    <st c="42632"><st c="42633">是</st> <st c="42637">一个常数</st></st></st>'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>></mml:mo><mml:mn>0</mml:mn></mml:math>](img/957.png)<st
    c="42647"><st c="42649">, a constant for all</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="42670"><st c="42671">, is the number of times the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="42700"><st c="42701">th</st> <st c="42704">subproblem appears</st></st></st></st>'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>></mml:mo><mml:mn>0</mml:mn></mml:math>](img/957.png)<st
    c="42647"><st c="42649">，一个对所有的常数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="42670"><st c="42671">，表示第</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="42700"><st c="42701">个子问题出现的次数</st></st></st></st>'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>0</mml:mn><mml:mo><</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/960.png)<st
    c="42722"><st c="42733">, a constant for all</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="42754"><st c="42755">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math>](img/962.png)<st
    c="42760"><st c="42761">, is the size of the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="42782"><st c="42783">th subproblem (different subproblems can have</st> <st
    c="42829">different sizes)</st></st></st></st></st>'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>0</mml:mn><mml:mo><</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/960.png)<st
    c="42722"><st c="42733">，对于所有的</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="42754"><st c="42755">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math>](img/962.png)<st
    c="42760"><st c="42761">，是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="42782"><st c="42783">的子问题大小（不同的子问题可以有</st> <st c="42829">不同的大小）</st></st></st></st></st>'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>f</mml:mi><mml:mi>’</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>∈</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:math>](img/964.png)
    <st c="42845"><st c="42861">where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi></mml:math>](img/233.png)
    <st c="42867"><st c="42868">is</st> <st c="42872">a constant</st></st></st>'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>f</mml:mi><mml:mi>’</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>∈</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:math>](img/964.png)
    <st c="42845"><st c="42861">其中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi></mml:math>](img/233.png)
    <st c="42867"><st c="42868">是</st> <st c="42872">一个常数</st></st></st>'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfenced><mml:mo>∈</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:math>](img/966.png)<st
    c="42882"><st c="42901">, for</st> <st c="42907">all</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)</st>'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfenced><mml:mo>∈</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:math>](img/966.png)<st
    c="42882"><st c="42901">，对于</st> <st c="42907">所有</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)</st>'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/968.png)
    <st c="42912"><st c="42915">is the non-recursive part of the recurrence or driving
    function and represents the work done outside the recursive calls, which has a
    wider range of</st> <st c="43064">allowable forms</st></st>'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/968.png)
    <st c="42912"><st c="42915">是递归的非递归部分或驱动函数，表示递归调用外的工作，并且具有更广泛的</st> <st c="43064">可允许形式</st></st>'
- en: <st c="43079">The following</st> <st c="43093">are the steps to solve a recurrence
    function using the</st> <st c="43149">Akra-Bazzi method:</st>
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43079">以下</st> <st c="43093">是使用 Akra-Bazzi 方法解递归函数的步骤：</st>
- en: '**<st c="43167">Find</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)**<st
    c="43174">: Solve</st> <st c="43182">the equation:</st>'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="43167">求</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)**<st
    c="43174">：解以下方程：</st>'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:math>](img/970.png)'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:math>](img/970.png)'
- en: <st c="43197">This</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)
    <st c="43202"><st c="43203">is crucial; it represents a “balancing point” for</st>
    <st c="43254">the recurrence.</st></st>
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="43197">这个</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)
    <st c="43202"><st c="43203">是至关重要的；它代表了递归的“平衡点”。</st></st>
- en: '**<st c="43269">Calculate the integral</st>**<st c="43292">: Find the value
    of the</st> <st c="43317">following integral:</st>'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="43269">计算积分</st>**<st c="43292">：求以下积分的值：</st>'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>I</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mrow></mml:math>](img/972.png)'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>I</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mrow></mml:math>](img/972.png)'
- en: '**<st c="43348">Asymptotic bound</st>**<st c="43364">: The asymptotic complexity
    of T(n) is then</st> <st c="43409">the following:</st>'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="43348">渐近界</st>**<st c="43364">：T(n)的渐近复杂度如下：</st> <st c="43409">如下：</st>'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>∈</mml:mo><mml:mi>θ</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mfrac><mml:mrow><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mrow><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/973.png)'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>∈</mml:mo><mml:mi>θ</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mfrac><mml:mrow><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mrow><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/973.png)'
- en: <st c="43440">Please note the following about the</st> <st c="43476">Akra-Bazzi
    method:</st>
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43440">请注意以下关于</st> <st c="43476">Akra-Bazzi方法的事项：</st>
- en: <st c="43494">The Akra-Bazzi method is a generalization of the</st> <st c="43544">master
    theorem</st>
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="43494">Akra-Bazzi方法是</st> <st c="43544">主定理</st> <st c="43672">的一种推广。</st>
- en: <st c="43558">It handles recurrences with unequal subproblem sizes, more complex
    splitting, and broader types of</st> <st c="43658">work functions</st>
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="43558">它处理具有不等子问题大小、更复杂分割以及更广泛工作函数类型的递归关系。</st>
- en: <st c="43672">The</st> <st c="43676">method involves finding a balancing exponent</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/974.png)
    <st c="43722"><st c="43723">and integrating the work function to determine the</st>
    <st c="43775">asymptotic complexity</st></st>
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="43676">该方法涉及寻找一个平衡指数</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/974.png)
    <st c="43722"><st c="43723">并对工作函数进行积分，从而确定</st> <st c="43775">渐近复杂度</st></st>
- en: <st c="43796">Why does it work?</st> <st c="43815">Intuition behind Akra-Bazzi</st>
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="43796">为什么它有效？</st> <st c="43815">Akra-Bazzi背后的直觉</st>
- en: <st c="43842">Think of the recurrence function as a tree.</st> <st c="43887">Each
    node represents a recursive call, and its children are the subproblems.</st> <st
    c="43964">The value</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)
    <st c="43974"><st c="43975">acts like a weight balancing the contributions of
    different branches of the tree.</st> <st c="44058">The integral then aggregates
    the work done at each level of the tree, taking into account</st> <st c="44148">this
    balancing.</st></st>
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43842">将递归函数看作一棵树。</st> <st c="43887">每个节点代表一个递归调用，其子节点则是子问题。</st> <st
    c="43964">值</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)
    <st c="43974"><st c="43975">起到平衡树的不同分支贡献的权重作用。</st> <st c="44058">积分然后汇总了树的每一层的工作量，考虑了</st>
    <st c="44148">这种平衡。</st></st>
- en: '**<st c="44163">Example 5.19</st>**'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="44163">示例 5.19</st>**'
- en: <st c="44176">Let’s consider the</st> <st c="44196">following recurrence:</st>
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44176">让我们考虑以下递归：</st> <st c="44196">
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mn>3</mn><mo>)</mo><mo>+</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mn>4</mn><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/976.png)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mn>3</mn><mo>)</mo><mo>+</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mn>4</mn><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/976.png)'
- en: '**<st c="44247">Find</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)**<st
    c="44253">:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mfenced
    open="(" close=")"><mrow><mn>2</mn><mo>×</mo><msup><mn>3</mn><mi>p</mi></msup></mrow></mfenced><mo>+</mo><mfenced
    open="(" close=")"><mrow><mn>1</mn><mo>×</mo><msup><mn>4</mn><mi>p</mi></msup></mrow></mfenced><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/978.png)<st
    c="44255"><st c="44256">. Solving this (numerically) gives</st> <st c="44291">us</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>p</mi><mo>≈</mo><mn>1.207</mn></mrow></mrow></math>](img/979.png)<st
    c="44294"><st c="44302">.</st></st></st>'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="44247">求解</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)**<st
    c="44253">：</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mfenced
    open="(" close=")"><mrow><mn>2</mn><mo>×</mo><msup><mn>3</mn><mi>p</mi></msup></mrow></mfenced><mo>+</mo><mfenced
    open="(" close=")"><mrow><mn>1</mn><mo>×</mo><msup><mn>4</mn><mi>p</mi></msup></mrow></mfenced><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/978.png)<st
    c="44255"><st c="44256">. 求解此方程（数值方法）得到</st> <st c="44291">我们得到</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>p</mi><mo>≈</mo><mn>1.207</mn></mrow></mrow></math>](img/979.png)<st
    c="44294"><st c="44302">。</st></st></st>'
- en: '**<st c="44303">Calculate</st>** **<st c="44314">the integral</st>**<st c="44326">:</st>'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="44303">计算</st>** **<st c="44314">该积分</st>**<st c="44326">：</st>'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><munderover><mo>∫</mo><mn>1</mn><mi>n</mi></munderover><mrow><mfenced
    open="(" close=")"><mfrac><mi>u</mi><msup><mi>u</mi><mrow><mn>1</mn><mo>+</mo><mn>1.207</mn></mrow></msup></mfrac></mfenced><mi>d</mi><mi>u</mi></mrow></mrow><mo>≈</mo><mn>0.828</mn><msup><mi>n</mi><mn>0.207</mn></msup></mrow></mrow></math>](img/980.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><munderover><mo>∫</mo><mn>1</mn><mi>n</mi></munderover><mrow><mfenced
    open="(" close=")"><mfrac><mi>u</mi><msup><mi>u</mi><mrow><mn>1</mn><mo>+</mo><mn>1.207</mn></mrow></msup></mfrac></mfenced><mi>d</mi><mi>u</mi></mrow></mrow><mo>≈</mo><mn>0.828</mn><msup><mi>n</mi><mn>0.207</mn></msup></mrow></mrow></math>](img/980.png)'
- en: <st c="44354">Asymptotic Bound:</st>
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44354">渐进界限：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>Θ</mi><mfenced open="(" close=")"><mrow><msup><mi>n</mi><mn>1.207</mn></msup><mfenced
    open="(" close=")"><mrow><mn>1</mn><mo>+</mo><mn>0.828</mn><msup><mi>n</mi><mn>0.207</mn></msup></mrow></mfenced></mrow></mfenced><mo>=</mo><mi>Θ</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mn>1.207</mn></msup></mfenced></mrow></mrow></math>](img/981.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>Θ</mi><mfenced open="(" close=")"><mrow><msup><mi>n</mi><mn>1.207</mn></msup><mfenced
    open="(" close=")"><mrow><mn>1</mn><mo>+</mo><mn>0.828</mn><msup><mi>n</mi><mn>0.207</mn></msup></mrow></mfenced></mrow></mfenced><mo>=</mo><mi>Θ</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mn>1.207</mn></msup></mfenced></mrow></mrow></math>](img/981.png)'
- en: '**<st c="44415">Example 5.20</st>**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="44415">示例 5.20</st>**'
- en: <st c="44427">Solve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>4</mn><mi>T</mi><mo>(</mo><mstyle
    scriptlevel="+1"><mfrac><mi mathvariant="normal">n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mstyle
    scriptlevel="+1"><mfrac><mi mathvariant="normal">n</mi><mrow><mi mathvariant="normal">l</mi><mi
    mathvariant="normal">o</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">n</mi></mrow></mfrac></mstyle></mrow></mrow></mrow></math>](img/982.png)<st
    c="44434"><st c="44453">.</st></st>
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44427">求解</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>4</mn><mi>T</mi><mo>(</mo><mstyle
    scriptlevel="+1"><mfrac><mi mathvariant="normal">n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mstyle
    scriptlevel="+1"><mfrac><mi mathvariant="normal">n</mi><mrow><mi mathvariant="normal">l</mi><mi
    mathvariant="normal">o</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">n</mi></mrow></mfrac></mstyle></mrow></mrow></mrow></math>](img/982.png)<st
    c="44434"><st c="44453">。</st></st>
- en: '**<st c="44454">Solution</st>**<st c="44463">: In the previous section, we
    saw that this recurrence function cannot be solved using the master theorem.</st>
    <st c="44571">On the other hand, the Akra-Bazzi method is a generalization of
    the master theorem that handles a broader class of recurrences.</st> <st c="44699">Let’s
    apply</st> <st c="44711">it here:</st>'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="44454">解答</st>**<st c="44463">：在上一节中，我们看到这个递归函数无法使用主定理求解。</st> <st
    c="44571">另一方面，Akra-Bazzi 方法是主定理的推广，能够处理更广泛的递归类型。</st> <st c="44699">让我们在这里应用</st>
    <st c="44711">它：</st>'
- en: '**<st c="44719">Find</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)**<st
    c="44726">: Solve the equation:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/984.png)<st
    c="44748"><st c="44752">. This gives</st> <st c="44765">us</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>p</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/985.png)<st
    c="44768"><st c="44769">.</st></st></st>'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="44719">求解</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)**<st
    c="44726">：解方程：</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/984.png)<st
    c="44748"><st c="44752">. 这给我们带来</st> <st c="44765">结果</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>p</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/985.png)<st
    c="44768"><st c="44769">。</st></st></st>'
- en: '**<st c="44770">Calculate</st>** **<st c="44781">the integral</st>**<st c="44793">:</st>'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="44770">计算</st>** **<st c="44781">积分</st>**<st c="44793">：</st>'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mfrac><mml:mrow><mml:mi>u</mml:mi><mml:mo>/</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mrow><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mfrac><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mrow></mml:math>](img/986.png)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mfrac><mml:mrow><mml:mi>u</mml:mi><mml:mo>/</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mrow><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mfrac><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mrow></mml:math>](img/986.png)'
- en: <st c="44811">This integral is a bit tricky, but it evaluates to</st> <st c="44862">approximately</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/987.png)<st
    c="44876"><st c="44885">.</st></st>
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这个积分有点复杂，但它的近似值是 ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/987.png)。
- en: '**<st c="44886">Asymptotic bound</st>**<st c="44903">:</st>'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**渐近界限**：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>u</mml:mi><mml:mo>/</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mfenced><mml:mo>/</mml:mo></mml:mrow></mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/988.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>u</mml:mi><mml:mo>/</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mfenced><mml:mo>/</mml:mo></mml:mrow></mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/988.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/989.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/989.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/990.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/990.png)'
- en: <st c="44984">This section detailed an</st> <st c="45009">advanced and generalized
    approach for solving more complex recurrence functions that cannot be addressed
    by the master theorem.</st> <st c="45137">This method is particularly useful for
    recurrences where the subproblem sizes are not uniform or when dealing with more
    intricate forms of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/991.png)<st
    c="45276"><st c="45281">. The Akra-Bazzi method extends the applicability of traditional
    recurrence-solving techniques by providing a framework that accommodates a broader
    range of functions and splitting ratios.</st> <st c="45470">By leveraging this
    method, one can derive precise asymptotic bounds for complex recurrences, making
    it a powerful tool for analyzing the performance of sophisticated recursive algorithms.</st>
    <st c="45658">The section includes practical examples to illustrate the method’s
    application and effectiveness in resolving recurrences beyond the reach of</st>
    <st c="45800">simpler methods.</st></st>
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44984">本节详细介绍了一种</st> <st c="45009">用于解决无法通过主定理处理的更复杂递归函数的先进且通用的方法。</st>
    <st c="45137">该方法特别适用于子问题规模不统一的递归，或者在处理更复杂形式的</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/991.png)<st
    c="45276"><st c="45281">时。Akra-Bazzi 方法通过提供一个框架，扩展了传统递归求解技术的适用性，能够处理更广泛的函数和分裂比。</st>
    <st c="45470">通过利用此方法，能够为复杂递归推导出精确的渐近界限，使其成为分析复杂递归算法性能的强大工具。</st> <st c="45658">本节包括实际示例，展示了该方法在解决超出</st>
    <st c="45800">简化方法范围的递归问题中的应用和效果。</st></st>
- en: <st c="45816">Summary</st>
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="45816">总结</st>
- en: '<st c="45824">In</st> [*<st c="45828">Chapter 5</st>*](B22248_05_split_000.xhtml#_idTextAnchor062)<st
    c="45837">, the methods for solving recurrence functions in the context of algorithm
    analysis were discussed.</st> <st c="45937">The chapter outlined three primary
    techniques: the substitution method, the master theorem, and recursion trees.</st>
    <st c="46050">The substitution method involves constructing proofs through variable
    substitution and induction to solve recurrence functions.</st> <st c="46178">The
    master theorem provides a systematic approach to determining the complexity of
    recursive algorithms based on their recurrence functions.</st> <st c="46319">Recursion
    trees help visualize the breakdown of problems into subproblems, providing insights
    into their complexity without</st> <st c="46443">direct proof.</st>'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45824">在</st> [*<st c="45828">第五章</st>*](B22248_05_split_000.xhtml#_idTextAnchor062)<st
    c="45837">中，讨论了在算法分析背景下解决递归函数的方法。</st> <st c="45937">本章概述了三种主要技术：替代法、主定理和递归树。</st>
    <st c="46050">替代法通过变量替代和归纳法构造证明，来解决递归函数。</st> <st c="46178">主定理提供了一种系统的方法，基于递归函数来确定递归算法的复杂性。</st>
    <st c="46319">递归树有助于将问题分解为子问题，从而在没有直接证明的情况下，提供对复杂性的洞察。</st> <st c="46443">证明。</st>
- en: <st c="46456">The substitution method was elaborated upon, highlighting its
    flexibility and power in addressing various recurrence functions.</st> <st c="46585">The
    method involves hypothesizing a solution, substituting it into the recurrence,
    and using induction to prove its correctness.</st> <st c="46714">Practical examples
    illustrated the iterative approach, showing how unrolling the recurrence can reveal
    patterns and lead to closed-form solutions.</st> <st c="46861">This method’s versatility
    is emphasized through multiple examples, demonstrating its utility in solving
    complex recurrences that other methods might not</st> <st c="47014">handle effectively.</st>
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46456">替代法被详细阐述，突出了它在处理各种递归函数时的灵活性和强大功能。</st> <st c="46585">该方法包括假设一个解，将其代入递归公式，并通过归纳法证明其正确性。</st>
    <st c="46714">实践例子展示了迭代方法，展示了如何通过展开递归来揭示模式并得出封闭形式的解。</st> <st c="46861">通过多个例子强调了该方法的多功能性，展示了它在解决其他方法可能无法有效处理的复杂递归问题中的应用。</st>
    <st c="47014">处理效果。</st>
- en: <st c="47033">The chapter also explored the limitations of the master theorem,
    especially in dealing with non-polynomial, non-positive, non-smooth, or irregular
    driving functions, and when</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/992.png)
    <st c="47209"><st c="47210">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/993.png)
    <st c="47214"><st c="47215">are not constants.</st> <st c="47235">The Akra-Bazzi
    method was introduced as a generalization of the master theorem, capable of handling
    a wider range of recurrence functions, including those with unequal subproblem
    sizes or more complex splitting.</st> <st c="47447">Examples were provided to
    show the application of these methods, emphasizing the need for alternative approaches
    when the master theorem’s conditions are not met.</st> <st c="47610">The chapter
    concluded with the application of these advanced methods, ensuring a comprehensive
    understanding of solving recurrence functions in</st> <st c="47754">algorithm
    analysis.</st></st></st>
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47033">本章还探讨了主定理的局限性，特别是在处理非多项式、非正、非平滑或不规则的驱动函数时，以及当</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/992.png)
    <st c="47209"><st c="47210">或</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/993.png)
    <st c="47214"><st c="47215">不是常数时。</st> <st c="47235">Akra-Bazzi方法被介绍为主定理的推广，能够处理更广泛的递归函数，包括那些具有不等子问题大小或更复杂分裂的递归函数。</st>
    <st c="47447">提供了示例，展示了这些方法的应用，强调了当主定理的条件不满足时需要采用替代方法。</st> <st c="47610">本章总结了这些高级方法的应用，确保了对递归函数求解的全面理解，特别是在</st>
    <st c="47754">算法分析中的应用。</st>
- en: '<st c="47773">In the next chapter, we will discuss one of the most fundamental
    families of algorithms: sorting.</st> <st c="47872">The skills we learned in this
    chapter, particularly in analyzing recurrence functions, will be utilized to analyze
    sorting algorithms and estimate</st> <st c="48019">their complexities.</st>'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47773">在下一章，我们将讨论算法中最基础的几种类型：排序。</st> <st c="47872">我们在本章中学到的技巧，特别是在分析递归函数时，将被用来分析排序算法并估算</st>
    <st c="48019">它们的复杂度。</st>
- en: <st c="48038">References and further reading</st>
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="48038">参考文献与进一步阅读资料</st>
- en: '*<st c="48069">Introduction to Algorithms</st>*<st c="48096">. By Thomas H.</st>
    <st c="48111">Cormen, Charles E.</st> <st c="48130">Leiserson, Ronald L.</st>
    <st c="48151">Rivest, and Clifford Stein.</st> <st c="48179">Fourth Edition.</st>
    <st c="48195">MIT</st> <st c="48199">Press.</st> <st c="48206">2022:</st>'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="48069">算法导论</st>*<st c="48096">。作者：Thomas H.</st> <st c="48111">Cormen,
    Charles E.</st> <st c="48130">Leiserson, Ronald L.</st> <st c="48151">Rivest,
    和 Clifford Stein。</st> <st c="48179">第四版。</st> <st c="48195">MIT</st> <st c="48199">Press。</st>
    <st c="48206">2022年：</st>'
- en: '*<st c="48211">Chapter</st>* *<st c="48220">4,</st>* *<st c="48222">Recurrences</st>*'
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="48211">第四章，</st>* *<st c="48220">递归</st>*'
- en: '*<st c="48234">Algorithms</st>*<st c="48245">. By R.</st> <st c="48253">Sedgewick,
    K.</st> <st c="48267">Wayne.</st> <st c="48274">Fourth Edition.</st> <st c="48290">Addison-Wesley.</st>
    <st c="48306">2011:</st>'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="48234">算法</st>*<st c="48245">。作者：R.</st> <st c="48253">Sedgewick, K.</st>
    <st c="48267">Wayne。</st> <st c="48274">第四版。</st> <st c="48290">Addison-Wesley。</st>
    <st c="48306">2011年：</st>'
- en: '*<st c="48311">Chapter 2, Principles of</st>* *<st c="48337">Algorithm Analysis</st>*'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="48311">第二章，算法分析原理</st>* *<st c="48337">算法分析</st>*'
- en: '*<st c="48355">Chapter</st>* *<st c="48364">5, Sorting</st>*'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="48355">第五章，排序</st>*'
- en: '*<st c="48374">The Algorithm Design Manual</st>*<st c="48402">. By S.</st>
    <st c="48410">S.</st> <st c="48413">Skiena.</st> <st c="48421">Second Edition.</st>
    <st c="48437">Springer.</st> <st c="48447">2008:</st>'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="48374">算法设计手册</st>*<st c="48402">。作者：S.</st> <st c="48410">S.</st>
    <st c="48413">Skiena。</st> <st c="48421">第二版。</st> <st c="48437">Springer。</st>
    <st c="48447">2008年：</st>'
- en: '*<st c="48452">Chapter 3, Data Structures</st>* *<st c="48480">and Recursion</st>*'
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="48452">第三章，数据结构</st>* *<st c="48480">与递归</st>*'
- en: '*<st c="48493">Chapter 5,</st>* *<st c="48505">Graph Algorithms</st>*'
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="48493">第五章，</st>* *<st c="48505">图算法</st>*'
- en: '*<st c="48521">Algorithm Design</st>*<st c="48538">. By Jon Kleinberg and Éva
    Tardos.</st> <st c="48573">First Edition.</st> <st c="48588">Pearson.</st> <st
    c="48597">2005:</st>'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="48521">算法设计</st>*<st c="48538">。作者：Jon Kleinberg 和 Éva Tardos。</st>
    <st c="48573">第一版。</st> <st c="48588">Pearson。</st> <st c="48597">2005年：</st>'
- en: '*<st c="48602">Chapter 5, Divide</st>* *<st c="48621">and Conquer</st>*'
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="48602">第五章，分治法</st>* *<st c="48621">与征服</st>*'
- en: '*<st c="48632">Chapter</st>* *<st c="48641">7, Recurrences</st>*'
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="48632">第七章，递归</st>*'
- en: '*<st c="48655">On the solution of linear recurrence equations</st>*<st c="48702">.
    Mohamad Akra, Louay Bazzi.</st> *<st c="48731">Computational Optimization and
    Applications</st>*<st c="48774">. Vol.</st> <st c="48781">10, No 2,</st> <st c="48791">pp.195–210\.</st>
    <st c="48803">1998.</st>'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="48655">线性递归方程的解法</st>*<st c="48702">。Mohamad Akra, Louay Bazzi。</st>
    *<st c="48731">计算优化与应用</st>*<st c="48774">。第</st> <st c="48781">10卷，第2期，</st>
    <st c="48791">第195–210页。</st> <st c="48803">1998年。</st>'
