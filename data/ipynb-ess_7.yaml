- en: Appendix B. A Brief Review of Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B. Python简要回顾
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'This appendix will give you a brief tour of the Python syntax. This is not
    intended to be a course on Python programming, but can be used by readers who
    are unfamiliar with the language as a quick introduction. The following topics
    will be covered in this appendix:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录将简要介绍Python语法。这并不是一个Python编程课程，而是供不熟悉该语言的读者作为快速入门使用。以下主题将在本附录中涵盖：
- en: Basic types, expressions, and variables and their assignment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本类型、表达式、变量及其赋值
- en: Sequence types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列类型
- en: Dictionaries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: Control structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结构
- en: Functions, objects, and methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数、对象和方法
- en: Basic types, expressions, and variables and their assignment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类型、表达式、变量及其赋值
- en: Any data that can be referred to in a Python code is considered an **object**.
    Objects are used to represent everything from *atomic* data, such as numbers,
    to very complex data structures, such as multidimensional arrays, database connections,
    and documents in several formats.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以在Python代码中引用的数据都被视为**对象**。对象用于表示从*原子*数据（如数字）到非常复杂的数据结构（如多维数组、数据库连接和各种格式的文档）。
- en: 'At the root of the object hierarchy are the numeric data types. These include
    the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象层次结构的根部是数值数据类型。这些包括以下内容：
- en: '**Integers**: There are three types of integers in Python.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数**：Python中有三种类型的整数。'
- en: '**Plain integers**: They are represented in the native architecture, which,
    in most systems, will be either 32- or 64-bit signed values.'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**普通整数**：它们在本地架构中表示，大多数系统中通常是32位或64位的有符号值。'
- en: '**Long integers**: They are integers with unlimited range, subject to available
    memory. Most of the time, the programmer does not need to be concerned with the
    distinction between plain and long integers. Python deals with conversions between
    the types in a transparent way.'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长整型**：它们是具有无限范围的整数，取决于可用内存。大多数情况下，程序员不需要关心普通整数和长整型之间的区别。Python会透明地处理这两种类型之间的转换。'
- en: '**Booleans**: They represent the values `False` and `True`. In most situations,
    they are equivalent to `0` and `1`, respectively.'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔值**：它们表示`False`和`True`两个值。在大多数情况下，它们分别等价于`0`和`1`。'
- en: '**Floats**: They represent the native double-precision floating-point numbers.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点数**：它们表示本地的双精度浮点数。'
- en: '**Complex**: They represent complex numbers, represented as a pair of double-precision
    floating-point numbers.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复数**：它们表示复数，表示为一对双精度浮点数。'
- en: 'The following table has examples of **literals** (that is, **constants**) for
    each data type:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了每种数据类型的**字面量**（即**常量**）示例：
- en: '| Data type | Literals |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 字面量 |'
- en: '| --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Integers** | `0`, `2`, `4`, …, `43882838388``5L`, `5l` (long integer)`0xFE4`
    (hexadecimal)`03241` (octal) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **整数** | `0`, `2`, `4`, …, `43882838388``5L`, `5l`（长整型）`0xFE4`（十六进制）`03241`（八进制）
    |'
- en: '| **Real numbers (float)** | `5.34`, `1.2`, `3.`, `0``1.4e-32` (scientific
    notation) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **实数（float）** | `5.34`, `1.2`, `3.`, `0``1.4e-32`（科学记数法） |'
- en: '| **Complex** | `1.0+3.4j`, `1+2j`, `1j`, `0j`, `complex(4.3, 2.5)` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **复数** | `1.0+3.4j`, `1+2j`, `1j`, `0j`, `complex(4.3, 2.5)` |'
- en: The imaginary unit is represented by `j`, but only if it follows a number literal
    (otherwise, it represents the variable named `j`). So, to represent the imaginary
    unit we must use `1j` and the complex zero is `0j`. The real and imaginary part
    of a complex number are always stored as double-precision floating-point values.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虚数单位由`j`表示，但只有在它跟随数字字面量时（否则它表示名为`j`的变量）。因此，要表示虚数单位，必须使用`1j`，复数零为`0j`。复数的实部和虚部总是以双精度浮点值存储。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the set of numeric types is greatly extended by `NumPy` to allow efficient
    numeric computations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`NumPy`大大扩展了数值类型的集合，以便进行高效的数值计算。
- en: 'The assignment statement is used to store values in variables, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值语句用于将值存储到变量中，如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Python supports *multiple simultaneous assignments* of values, so the previous
    four lines of code could be equivalently written in a single line as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持*多重同时赋值*，因此前四行代码可以等效地写成一行，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In a multiple assignment, all expressions in the right-hand side are evaluated
    before the assignments are made. For example, a common idiom to exchange the values
    of two variables is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在多重赋值中，右侧的所有表达式都会在赋值之前被求值。例如，交换两个变量的值的常见惯用法如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As an exercise, the reader can try to predict the result of the following statement,
    given the preceding variable assignments:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，读者可以尝试预测以下语句的结果，前提是已知前面的变量赋值：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following example shows how to compute the two solutions of a quadratic
    equation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何计算二次方程的两个解：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that we force the variables `a`, `b`, and `c` to be floating-point values
    by using a decimal point. This is good practice when performing numerical computations.
    The following table contains a partial list of Python operators:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过使用小数点强制将变量 `a`、`b` 和 `c` 转换为浮点值。在进行数值计算时，这是一种良好的实践。下表包含了 Python 运算符的部分列表：
- en: '| Operators | Python operators |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | Python 运算符 |'
- en: '| --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Arithmetic** | `+` (Addition)`-` (Subtraction, unary minus)`*` (Multiplication)`/`
    (Division, *see the note below the table*)`//` (Integer division)`%` (Remainder)
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **算术** | `+`（加法）`-`（减法，取负）`*`（乘法）`/`（除法，*见表格下方的注释*）`//`（整数除法）`%`（余数） |'
- en: '| **Comparison** | `==` (Equal to)`>` (Greater than)`<` (Less than)`>=` (Greater
    than or equal to)`<=` (Less than or equal to)`!=` (Not equal to) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **比较** | `==`（等于）`>`（大于）`<`（小于）`>=`（大于或等于）`<=`（小于或等于）`!=`（不等于） |'
- en: '| **Boolean** | `and``or``not` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **布尔** | `and` `or` `not` |'
- en: '| **Bitwise Boolean** | `&` (AND)`&#124;` (OR)`^` (XOR)`~` (NOT) |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **位运算布尔** | `&`（与）`&#124;`（或）`^`（异或）`~`（非） |'
- en: '| **Bitwise shift** | `<<` (Left shift)`>>` (Right shift) |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **位移** | `<<`（左移）`>>`（右移） |'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'Care should be taken with the division operator (`/`). If the operands are
    integers, the result of this operation is the integer quotient. For example, `34/12`
    results `2`. To get the floating point result, we must either enter floating point
    operands, as in `34./12.`, or add the following statement:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用除法运算符（`/`）时需要小心。如果操作数是整数，则此操作的结果是整数商。例如，`34/12` 结果为 `2`。要获得浮点结果，我们必须输入浮点操作数，例如
    `34./12.`，或者添加以下语句：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `//` operator always represents integer division.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`//` 运算符始终表示整数除法。'
- en: 'Arithmetic operators follow the rules for the order of operations that may
    be altered with the use of parenthesis. Comparison operators have lower precedence
    than arithmetic operators, and the `or`, `and`, and `not` operators have even
    lower precedence. So, an expression like the following one produces the expected
    result:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符遵循运算顺序规则，括号可以改变该顺序。比较运算符的优先级低于算术运算符，而 `or`、`and` 和 `not` 运算符的优先级更低。因此，像以下的表达式会得到预期的结果：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In other words, the preceding command line is parsed as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，前面的命令行被解析如下：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The logical operators `and` and `or` short circuit, so, for example, the second
    comparison is never evaluated in the command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符 `and` 和 `or` 采用短路求值，因此，例如，命令中的第二个比较不会被评估：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The precedence rules for the bitwise and shift operators may not be as intuitive,
    so it is recommended to always use parenthesis to specify the order of operations,
    which also adds clarity to the code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算符和移位运算符的优先级规则可能不像直观那样清晰，因此建议始终使用括号来指定运算顺序，这也有助于代码的清晰度。
- en: 'Python also supports augmented assignments. For example, the following command
    lines first assign the value `5` to `a`, and then increment the value of `a` by
    one:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还支持增强赋值。例如，以下命令行首先将值 `5` 赋给 `a`，然后将 `a` 的值加一：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Python does not have increment/decrement operators, such as a++ and ++a, as
    in the C language.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Python 不支持递增/递减运算符，如 C 语言中的 a++ 和 ++a。
- en: 'All Python operators have a corresponding augmented assignment statement. The
    general semantic for any operator `$` is the following statement:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Python 运算符都有对应的增强赋值语句。任何运算符 `$` 的一般语义如下所示：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding statement is equivalent to the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句等价于以下：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Note that `$` is not a valid Python operator, it is just being used as a placeholder
    for a generic operator.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`$` 不是一个有效的 Python 运算符，它仅作为一个占位符表示通用运算符。
- en: Sequence types
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列类型
- en: Python sequence types are used to represent ordered collections of objects.
    They are classified into **mutable** and **immutable** sequence types. Here, we
    will only discuss `lists` (mutable) and `tuples` and `strings` (both immutable).
    Other sequence types are mentioned at the end of this section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python 序列类型用于表示有序的对象集合。它们分为**可变**序列类型和**不可变**序列类型。在这里，我们只讨论`lists`（可变）和`tuples`与`strings`（均为不可变）。其他序列类型将在本节末尾提到。
- en: Lists
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'The following example shows how to construct a list in Python and assign it
    to a variable:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示如何在Python中构造一个列表并将其赋值给变量：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Individual entries in the list are accessed with index notation as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的个别条目可以通过索引表示法访问，如下所示：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that indexing always starts with `0`. Negative indices are allowed and
    they represent positions starting at the end of the list. For example, `numbers[-1]`
    is the last entry, `numbers[-2]` is the next-to-last entry, and so forth.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，索引总是从`0`开始。允许使用负索引，它们表示从列表末尾开始的位置。例如，`numbers[-1]`是最后一个元素，`numbers[-2]`是倒数第二个元素，以此类推。
- en: 'Since lists are a mutable sequence type, we are allowed to modify the entries
    in-place:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表是可变的序列类型，我们可以就地修改其中的条目：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Another important way to refer to elements in a Python sequence type is slices,
    which allow the extraction of sublists from a list. Since this topic is very important
    for `NumPy` arrays, we defer the discussion to [Appendix C](apc.html "Appendix C. NumPy
    Arrays"), *NumPy Arrays*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种重要的引用Python序列类型元素的方法是切片，它允许从列表中提取子列表。由于这个话题对`NumPy`数组非常重要，我们将讨论延迟到[附录C](apc.html
    "附录C：NumPy数组")，*NumPy数组*。
- en: 'Python lists have a nice set of features, a few of which are illustrated in
    the following code examples:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Python列表具有一组非常实用的功能，其中一些在以下代码示例中得到了体现：
- en: 'To find the length of a list, use the following command:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查找列表的长度，请使用以下命令：
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To reverse a list in place, use the following command:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要就地反转列表，请使用以下命令：
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To append a new element, use the following command:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要添加一个新元素，请使用以下命令：
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To sort the list in-place, use the following command:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要就地对列表进行排序，请使用以下命令：
- en: '[PRE18]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To insert a value at a position, use the following command:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在指定位置插入一个值，请使用以下命令：
- en: '[PRE19]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To extend a list, use the following command:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要扩展列表，请使用以下命令：
- en: '[PRE20]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Python has a few handy ways to construct frequently used lists. The `range()`
    function returns a list of equally spaced integers. The simplest form returns
    a list of successive integers starting at `0`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一些便捷的方式来构造常用的列表。`range()`函数返回一个等间隔的整数列表。最简单的形式返回一个从`0`开始的连续整数列表：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding command returns the following list:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令返回以下列表：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that the last element is one less than the argument given in the function
    call. The rule of thumb is that `range(n)` returns a list with `n` elements starting
    at zero so that the last element is `n-1`. To start at a nonzero value, use the
    two-argument version as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最后一个元素比函数调用中给出的参数少1。通常规则是，`range(n)`返回一个包含`n`个元素的列表，从零开始，因此最后一个元素是`n-1`。要从非零值开始，请使用以下带有两个参数的版本：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A third argument specifies an *increment*. The following command line produces
    a list of all positive multiples of 6 that are less than 100:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数指定一个*增量*。以下命令行会生成一个包含所有小于100的正6的倍数的列表：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Negative increments can also be used:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用负增量：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Lists support concatenation, which is represented by the `+` operator:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表支持连接，表示为`+`运算符：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that for the `NumPy` arrays, the `+` operator is redefined to represent
    vector/matrix addition.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于`NumPy`数组，`+`运算符被重新定义为表示向量/矩阵加法。
- en: 'The multiplication operator (`*`) can be used to construct a list by repeating
    the elements of a given list, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法运算符（`*`）可用于通过重复给定列表的元素来构造一个新列表，如下所示：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The most flexible way to construct a list in Python is to use a list comprehension.
    A full discussion is beyond the scope of this appendix, but the following examples
    illustrate some of the possibilities:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中构造列表的最灵活方法是使用列表推导式。完整的讨论超出了本附录的范围，但以下示例说明了其中的一些可能性：
- en: 'To display the list of the squares of the integers from `0` to `10` (inclusive),
    use the following command line:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要显示从`0`到`10`（包括`10`）的整数的平方列表，请使用以下命令行：
- en: '[PRE28]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To display the list of divisors of an integer, use the following command lines:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要显示一个整数的所有除数列表，请使用以下命令行：
- en: '[PRE29]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To display the list of prime numbers up to 100, use the following command line
    (very inefficient):'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要显示小于100的所有素数列表，请使用以下命令行（效率较低）：
- en: '[PRE30]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To display the list of tuples of points with integers coordinates and their
    distances to the origin, use the following command line:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要显示具有整数坐标的点的元组列表及其与原点的距离，请使用以下命令行：
- en: '[PRE31]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tuples
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: Tuples are similar to lists, but are immutable—once created, their elements
    cannot
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与列表类似，但它们是不可变的——一旦创建，其元素就不能修改。
- en: 'be changed. The following command lines will result in an error message:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 会发生变化。以下命令行将导致错误信息：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Tuples have a few specialized uses in Python. They can be used as indexes in
    dictionaries (because they are immutable). They also consist of the mechanism
    that Python uses to return more than one value from a function. For example, the
    built-in function `divmod()` returns both the integer quotient and remainder in
    a tuple:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 元组在 Python 中有一些特殊用途。它们可以作为字典中的索引（因为它们是不可变的）。它们还构成了 Python 用来从函数返回多个值的机制。例如，内建函数
    `divmod()` 返回一个元组，其中包含整数商和余数：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tuples support the same sequence interface as lists, except for methods that
    would modify the tuple. For example, there is no method named `sort()` that sorts
    a tuple in place.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 元组支持与列表相同的序列接口，除了会修改元组的那些方法。例如，没有名为 `sort()` 的方法可以就地对元组进行排序。
- en: Strings
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'A Python string represents an immutable sequence of characters. There are two
    string types: `str`, representing ASCII strings, and `unicode`, representing Unicode
    strings.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python 字符串表示一个不可变的字符序列。有两种字符串类型：`str`，表示 ASCII 字符串，和 `unicode`，表示 Unicode 字符串。
- en: 'A string literal is a sequence of characters enclosed by either single quotes
    or double quotes, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串文字是由单引号或双引号括起来的字符序列，如下所示：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There is no semantic difference between single quotes and double quotes, except
    that a single-quoted string can contain double quotes and a double quoted string
    can contain single quotes. For example, the following command lines are correct:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号和双引号之间没有语义上的区别，唯一的不同是单引号字符串可以包含双引号，而双引号字符串可以包含单引号。例如，以下命令行是正确的：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Strings are used for two main purposes: as dictionary indexes and to print
    messages. When printing messages, strings have the `format()` method that allows
    easy display of information. We use this feature frequently to add annotations
    to graphics. Here is an example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串有两个主要用途：作为字典的索引和打印信息。当打印信息时，字符串有一个 `format()` 方法，可以轻松地显示信息。我们经常使用这个功能为图形添加注释。这里有一个例子：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding example, there are two format specifiers:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，有两个格式说明符：
- en: '`{:d}`: This specifies a decimal format for an integer value'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{:d}`：这指定了整数值的十进制格式'
- en: '`{:8.5f}`: This specifies a field of width `8` and `5` decimals for a floating-point
    value'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{:8.5f}`：这指定了一个宽度为 `8`，小数点后有 `5` 位的浮点数格式'
- en: The format specifications are matched (in order) with the arguments, in this
    case `n` and `n ** 0.5`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 格式说明符会按顺序与参数匹配，在这个例子中是 `n` 和 `n ** 0.5`。
- en: Strings have a rich interface. If you need to code something with strings, it
    is very likely that there is a built-in function that does the job with very little
    modification. A list of all available string methods, as well as formatting features,
    is available at [https://docs.python.org/2/library/stdtypes.html#string-methods](https://docs.python.org/2/library/stdtypes.html#string-methods).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串有丰富的接口。如果你需要编写与字符串相关的代码，很可能有一个内建函数可以实现，且只需要很少的修改。所有可用字符串方法的列表以及格式化功能，可以参考
    [https://docs.python.org/2/library/stdtypes.html#string-methods](https://docs.python.org/2/library/stdtypes.html#string-methods)。
- en: Dictionaries
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: 'Python dictionaries are a data structure that contains key-item pairs. The
    keys must be immutable types, usually strings or tuples. Here is an example that
    shows how to construct a dictionary:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Python 字典是一种包含键值对的数据结构。键必须是不可变类型，通常是字符串或元组。以下是一个构建字典的示例：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To access an item, we provide the key as an index as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问某个项，我们提供键作为索引，如下所示：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Dictionaries are mutable, so we can change the item values using them. If Jodi
    does extra work to improve her grade, we can change it as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是可变的，所以我们可以使用它们来更改条目的值。如果 Jodi 做了额外的工作来提高她的成绩，我们可以这样更改：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To add an entry to a dictionary, just assign a value to a new key:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加条目，只需为新键赋值：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: However, attempting to access a nonexistent key yields an error.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尝试访问一个不存在的键会导致错误。
- en: 'An important point to realize is that dictionaries are not ordered. The following
    code is a standard idiom to iterate over a dictionary:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的重要点是，字典是无序的。以下代码是迭代字典的标准惯用法：
- en: '[PRE41]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The main point here is that the output is not at all related to the order in
    which the entries were added to the dictionary.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键点是，输出与字典中条目的添加顺序完全无关。
- en: For more details on the dictionary interface, you can refer to [https://docs.python.org/2/library/stdtypes.html#mapping-types-dict](https://docs.python.org/2/library/stdtypes.html#mapping-types-dict).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多字典接口的细节，可以参考[https://docs.python.org/2/library/stdtypes.html#mapping-types-dict](https://docs.python.org/2/library/stdtypes.html#mapping-types-dict)。
- en: Control structures
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制结构
- en: 'Control structures allow changes to the flow of the execution of code. There
    are two types of structures that are of interest to us: **branching** and **looping**.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构允许改变代码执行的流程。我们关注的有两种结构：**分支**和**循环**。
- en: 'Branching allows the execution of different code depending on the result of
    a test. The following example shows an improved version of code to solve quadratic
    equations. An `if-then-else` structure is used to handle the cases of real and
    imaginary solutions, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 分支结构根据测试结果执行不同的代码。以下示例展示了一个改进版的代码，用于求解二次方程。使用了`if-then-else`结构来处理实数解和虚数解的情况，如下所示：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding code starts by computing the discriminant of the quadratic. Then,
    an `if-then-else` statement is used to decide if the roots are real or imaginary,
    according to the sign of the discriminant. Note the indentation of the code. Indentation
    is used in Python to define the boundaries of blocks of statements. The general
    form of the `if-then-else` structure is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码首先计算二次方程的判别式。然后，使用`if-then-else`语句来判断根是实数还是虚数，这取决于判别式的符号。注意代码的缩进，Python通过缩进来定义语句块的边界。`if-then-else`结构的一般形式如下：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: First, the condition `<condition>` is evaluated. If it is `True`, the statement
    `<statement block T>` is executed. Otherwise, `<statement block F>` is executed.
    The `else:` clause can be omitted.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，条件`<condition>`被评估。如果为`True`，则执行语句`<statement block T>`；否则，执行语句`<statement
    block F>`。`else:`子句可以省略。
- en: 'The most common looping structure in Python is the `for` statement. Here is
    an example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Python中最常见的循环结构是`for`语句。下面是一个示例：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We start by defining a list of integers. The `for` statement makes the variable
    `n` assume each value in the list numbers in succession and execute the indented
    block for each value. Note that there is an `if-then-else` structure inside the
    `for` loop. Also, the `print` statements are doubly-indented.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个整数列表。`for`语句使得变量`n`依次取列表中的每个值，并对每个值执行缩进块的代码。注意，`for`循环内部有一个`if-then-else`结构。此外，`print`语句是双重缩进的。
- en: 'A `for` loop is frequently used to perform simple searches. A common scenario
    is the need to step out of the loop when a certain condition is met. The following
    code finds the first perfect square in a range of integers:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环常用于执行简单的搜索。一个常见的场景是，当满足某个条件时需要跳出循环。以下代码查找整数范围内的第一个完全平方数：'
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For each value of `n` in the given range, we take the square root of `n`, take
    the integer part, and then calculate its square. If the result is equal to `n`,
    then we go into the `if` block, print `n`, and then break out of the loop.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定范围内的每个`n`值，我们先计算`n`的平方根，取其整数部分，再计算平方。如果结果等于`n`，则进入`if`块，打印`n`，然后跳出循环。
- en: 'What if there are no perfect squares in the range? Change the preceding function,
    `range(30, 60)`, to `range(125, 140)`. When the command line is run, nothing is
    printed, since there are no perfect squares between `125` and `140`. Now, change
    the command line to the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在范围内没有完全平方数怎么办？将前面的函数`range(30, 60)`改为`range(125, 140)`。运行命令行时不会输出任何内容，因为在`125`到`140`之间没有完全平方数。现在，将命令行改为如下：
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `else` clause is only executed if the execution does not break out of the
    loop, in which case the message is printed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`子句只有在执行没有跳出循环时才会被执行，此时会打印出相应的消息。'
- en: 'Another frequent situation is when some values in the iteration must be skipped.
    In the following example, we print the square roots of a sequence of random numbers
    between `-1` and `1`, but only if the numbers are positive:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的情况是某些值在迭代过程中需要跳过。以下示例中，我们打印一系列`-1`到`1`之间随机数的平方根，但只有当这些数为正时才打印：
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When Python meets the `continue` statement in a loop, it skips the rest of the
    execution block and continues with the next value of the control variable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python遇到`continue`语句时，它会跳过当前执行块的剩余部分，并继续执行控制变量的下一个值。
- en: 'Another control structure that is frequently used is the `while` loop. This
    structure executes a block of commands as long as a condition is true. For example,
    suppose we want to compute the running sum of a list of randomly generated values,
    but only until the sum is above a certain value. This can be done with the following
    code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个经常使用的控制结构是`while`循环。该结构在条件为真时执行一组命令。例如，假设我们想计算一组随机生成的值的累加和，但仅当和超过某个值时才停止。可以使用以下代码来实现：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Another common situation that occurs more often than one might expect requires
    a pattern known as the **forever loop**. This happens when the condition to be
    checked is not available at the beginning of the loop. The following code, for
    example, implements the famous `3n+1` game:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种比预期更常见的情况需要一种叫做**永远循环**的模式。这种情况发生在循环开始时需要检查的条件不可用时。例如，下面的代码实现了著名的`3n+1`游戏：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The game starts with an arbitrary integer, `7` in this case. Then, in each
    iteration, we test whether `n` is even. If it is, we divide it by `2`; otherwise,
    multiply it by `3` and add `1`. Then, we check whether we reached `1`. If yes,
    we break from the loop. Since we don''t know if we have to break until the end
    of the loop, we use a forever loop as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏从一个任意整数开始，这里是`7`。然后，在每次迭代中，我们测试`n`是否为偶数。如果是，我们将其除以`2`；否则，将其乘以`3`并加上`1`。然后，我们检查是否达到了`1`。如果是，我们退出循环。由于我们不知道是否需要在循环结束前退出，因此我们使用一个永远循环，如下所示：
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Some programmers avoid this construct, since it may easily lead to infinite
    loops if one is careless. However, it turns out to be very handy in certain situations.
    By the way, it is an open problem if the loop in the `3n+1` problem stops for
    all initial values! Readers may have some fun trying the initial value `n=27`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员避免使用这种结构，因为如果不小心，很容易导致无限循环。然而，它在某些情况下确实非常有用。顺便说一下，`3n+1`问题中的循环是否对所有初始值都会停止还是一个开放性问题！读者可以尝试使用初始值`n=27`来感受一下。
- en: Functions, objects, and methods
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数、对象和方法
- en: We now come to the constructs that really make Python so flexible and powerful,
    its object-oriented features. We have already seen some examples of object-oriented
    code in the previous sections (the object-oriented paradigm is so integral to
    Python that is hardly possible to write any code without using it), but now we
    will have a more specific treatment of these features.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来介绍使Python如此灵活和强大的构造，它的面向对象特性。我们在前面的章节中已经看到了一些面向对象的代码示例（面向对象的范式是Python的核心，很难写出不使用它的代码），但现在我们将对这些特性进行更具体的讨论。
- en: Functions
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: 'We have already seen many examples of functions being used. For example, the
    `len()` function is used to compute the length of a list:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到许多使用函数的例子。例如，`len()`函数用于计算列表的长度：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The most basic syntax for calling a function is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数的最基本语法如下：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In this case, `arg1`, `arg2`, …, `argn` are called **positional arguments**,
    since they are matched according to the position in which they appear. As an example,
    let''s consider the built-in function, `pow()`. This function takes up to three
    arguments:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`arg1`、`arg2`、…、`argn`被称为**位置参数**，因为它们是根据出现的位置进行匹配的。例如，我们考虑内置函数`pow()`。这个函数最多接受三个参数：
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In this form, the preceding function uses an optimized algorithm to compute
    `b` raised to the power `n` modulo `m`. (If you are wondering, this is an important
    operation in public key cryptography, for example.) The arguments `b`, `n`, and
    `m` are associated by their position. For example, to compute `12` raised to the
    tenth power modulo `15`, we use the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种形式下，前面的函数使用优化算法来计算`b`的`n`次方模`m`。（如果你想知道，这是公共密钥密码学中的一个重要操作。）参数`b`、`n`和`m`是根据它们的位置来关联的。例如，要计算`12`的十次方模`15`，我们使用以下命令：
- en: '[PRE54]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Python also supports sequences of arguments of arbitrary size. For example,
    the `max()` function computes the maximum of an arbitrary sequence of values:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Python还支持任意大小的参数序列。例如，`max()`函数计算任意序列中的最大值：
- en: '[PRE55]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding command returns the value `8`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令返回值`8`。
- en: A third way to pass arguments to a function is to use **keyword arguments**.
    This turns out to be very useful, since it is in general difficult to remember
    the exact order of positional arguments. (I would prefer not to write a function
    with more than three or four positional arguments, for example.)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 传递参数给函数的第三种方式是使用**关键字参数**。这非常有用，因为通常很难记住位置参数的准确顺序。（例如，我不太愿意编写超过三个或四个位置参数的函数。）
- en: 'For example, the built-in `int()` function can be used to convert a string
    to an integer. The optional keyword argument, `base`, lets us specify the base
    for conversion. For example, the following command line assigns to `n`, an integer
    given in base `2`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，内置的`int()`函数可以用于将字符串转换为整数。可选的关键字参数`base`让我们可以指定转换的进制。例如，以下命令行将给定的`2`进制整数赋值给`n`：
- en: '[PRE56]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Keyword arguments always have a default value. In our example, if the base is
    not specified, it is assumed to be `10`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数总是有默认值。在我们的示例中，如果没有指定基数，默认假设为`10`。
- en: 'We often need to write our own functions. This is done with the keyword, `def`.
    As an example, let''s consider writing code to implement the well-known `bisection`
    method to solve equations numerically. A possible solution is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要编写自己的函数。这是通过关键字`def`来实现的。作为示例，假设我们要编写代码来实现著名的`bisection`方法以数值求解方程。一个可能的解决方案如下：
- en: '[PRE57]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding function takes three important and necessary arguments:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数需要三个重要且必要的参数：
- en: The `f` function accepts a float value as input and returns a float value as
    output
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`函数接受一个浮点值作为输入，并返回一个浮点值作为输出。'
- en: The floating-point values, `a` and `b`, which specify an interval that contains
    a zero of the function
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点值`a`和`b`，它们指定一个包含函数零点的区间。
- en: 'The other two arguments are optional. The argument `tol` specifies the desired
    tolerance in the result and `itermax` specifies the maximum number of iterations.
    To use the `bisection()` function, we must first define the function `f`. We will
    take the opportunity to display another way to define a function in Python, as
    follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个参数是可选的。参数`tol`指定结果所需的容差，`itermax`指定最大迭代次数。要使用`bisection()`函数，必须先定义函数`f`。我们将借此机会展示另一种定义Python函数的方式，如下：
- en: '[PRE58]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We are now ready to call the function with the following command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备通过以下命令来调用函数：
- en: '[PRE59]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding function returns the following output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数返回以下输出：
- en: '[PRE60]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Note that we designed the function to return an interval containing the zero.
    The length of the interval is less than `tol`, unless the maximum number of iterations
    is reached. If we want a smaller tolerance, we could use the following function:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们设计了该函数返回一个包含零的区间。该区间的长度小于`tol`，除非达到了最大迭代次数。如果我们希望更小的容差，可以使用以下函数：
- en: '[PRE61]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, suppose that we are concerned with the time the computation is taking.
    We can limit the maximum number as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们关注计算所花费的时间。我们可以通过以下方式限制最大次数：
- en: '[PRE62]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that the order in which the keyword arguments are given is irrelevant and
    the desired tolerance is not reached in the preceding example.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关键字参数的顺序是无关紧要的，并且在前面的示例中没有达到所需的容差。
- en: Objects and methods
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象和方法
- en: Objects are the most general data abstraction in Python. Actually, in Python,
    everything is an object from the point of view of the programmer.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是Python中最通用的数据抽象。实际上，从程序员的角度来看，Python中的一切都是对象。
- en: An object is nothing more than a collection of structured data, together with
    an interface to operate on this data. Objects are defined using the `class` construct,
    but our goal here is not to show how to define classes. Although designing a new
    class is an advanced topic, using existing classes is pretty straightforward.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对象不过是结构化数据的集合，并且有一个操作这些数据的接口。对象是通过`class`构造定义的，但我们这里的目标并不是展示如何定义类。尽管设计新类是一个高级话题，但使用现有类却相当简单。
- en: 'As an example, let''s explore the built-in type `str`. Let''s start by defining
    a `str` object we can play with as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们探索内置类型`str`。首先，我们定义一个可以操作的`str`对象，如下所示：
- en: '[PRE63]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To start, let''s convert the message to uppercase as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将消息转换为大写，如下所示：
- en: '[PRE64]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We say that the preceding statement calls the `upper()` method of the `message`
    object. A method is simply a function that is associated to an object. The following
    are a few other methods of the `str` objects:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说前述语句调用了`message`对象的`upper()`方法。方法仅仅是与对象关联的函数。以下是`str`对象的其他一些方法：
- en: 'To find the first occurrence of a substring (returns `-1` if the string is
    not found), use the following command line:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查找子字符串的第一次出现（如果未找到该字符串，返回`-1`），请使用以下命令行：
- en: '[PRE65]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To split the string in words, use the following command line:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将字符串拆分为单词，请使用以下命令行：
- en: '[PRE66]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: To count the number of occurrences of `s` substring, use the following command
    line
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要计算`s`子字符串出现的次数，请使用以下命令行：
- en: '[PRE67]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To replace a substring by something else, use the following command line:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要用其他内容替换子字符串，请使用以下命令行：
- en: '[PRE68]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the preceding methods do not change the original string object, but
    return new modified strings. Strings are immutable. For mutable objects, methods
    are free to change the data in the object.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前述方法不会改变原始字符串对象，而是返回新的修改过的字符串。字符串是不可变的。对于可变对象，方法可以自由地改变对象中的数据。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this appendix, we gave an overview of the Python syntax and features, covering
    basic types, expressions, variables, and assignment, basic data structures, functions,
    objects, and methods.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们概述了 Python 语法和特性，涵盖了基本类型、表达式、变量和赋值、基本数据结构、函数、对象和方法。
