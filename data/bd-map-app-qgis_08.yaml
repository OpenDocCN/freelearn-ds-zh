- en: Chapter 8. Building a Complete Mapping Application using Python and QGIS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 使用Python和QGIS构建完整的地图应用程序
- en: In this chapter, we will design and start building a complete turnkey mapping
    application. While our example application might seem somewhat specialized, the
    process of designing and implementing this application, and much of the code that
    we use, will apply to all sorts of mapping applications that you might like to
    write yourself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设计和开始构建一个完整的交钥匙地图应用程序。虽然我们的示例应用程序可能看起来有些专业，但设计和实现这个应用程序的过程以及我们使用的很大一部分代码，将适用于你可能会自己编写的所有类型的地图应用程序。
- en: 'Due to the complexity of the application we''re creating, we will split the
    implementation across two chapters. In this chapter, we will lay the groundwork
    for the mapping application by:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建的应用程序复杂，我们将分两章实现。在本章中，我们将通过以下方式为地图应用程序打下基础：
- en: Designing the application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计应用程序
- en: Building the high-resolution basemap on which our vector data will be displayed
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建高分辨率底图，我们的矢量数据将在底图上显示
- en: Implementing the overall structure of the application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现应用程序的整体结构
- en: Defining the application's user interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序的用户界面
- en: In the following chapter, we will implement the map tools that let the user
    enter and manipulate map data, edit attributes, and calculate the shortest path
    between two points.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现地图工具，使用户能够输入和操作地图数据，编辑属性，并计算两点之间的最短路径。
- en: Introducing ForestTrails
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍ForestTrails
- en: 'Imagine that you work for a company responsible for developing and maintaining
    a large recreational forest. People use the various access roads and purpose-built
    trails in the forest for walking, biking and horse riding. Your task is to write
    a computer program that lets the user create a database of access roads and trails
    to assist with the ongoing maintenance of the forest. For simplicity, we will
    use the term **track** to refer to either an access road or a trail. Each track
    will have the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你为一家负责开发和维护大型娱乐森林的公司工作。人们使用森林中的各种通道和专门建造的小径进行步行、骑自行车和骑马。你的任务是编写一个计算机程序，让用户创建一个数据库，包含通道和路径，以协助森林的持续维护。为了简单起见，我们将使用**路径**一词来指代通道或小径。每个路径都将具有以下属性：
- en: '**Type**: Whether the track is a walking trail, a bike trail, a horse trail,
    or an access road'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：轨道是步行小径、自行车小径、马术小径还是通道'
- en: '**Name**: Not all trails and access roads are named, though some are'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：并非所有小径和通道都有名称，尽管有些有'
- en: '**Direction**: Some trails and access roads are one-way, while others can be
    travelled in both directions'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向**：一些小径和通道是单向的，而其他则可以双向通行'
- en: '**Status**: Whether the track is currently open or closed'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：轨道目前是否开放或关闭'
- en: Since the recreational forest is continually being developed, new tracks are
    being regularly added, while existing tracks are sometimes modified or even removed
    if they are no longer needed. This means that you can't hardwire the set of tracks
    into your program; you will need to include a *track editing* mode so that the
    user can add, edit, and remove tracks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于娱乐森林持续发展，新的路径正在定期添加，而现有的路径有时会被修改，甚至在不再需要时被移除。这意味着你不能将路径集硬编码到你的程序中；你需要包含一个*路径编辑*模式，以便用户可以添加、编辑和删除路径。
- en: A specific request you have been given is to produce a set of directions that
    the track maintenance team can follow in order to go from a given starting point
    to any place in the forest. To implement this, the program will have to let the
    user choose the starting and ending points, and calculate and display the **shortest
    available path** between those two points.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你被赋予的特定要求是制作一套方向指南，以便轨道维护团队可以从一个给定的起点到达森林中的任何地方。为了实现这一点，程序将允许用户选择起点和终点，并计算并显示这两个点之间的**最短可用路径**。
- en: Designing the ForestTrails application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计ForestTrails应用程序
- en: 'Based on our set of requirements, it seems clear that tracks can be represented
    by LineString geometries. We will also need an appropriate basemap on which these
    geometries will be displayed. This means that our application will have at least
    the following two map layers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的需求集，很明显，路径可以用LineString几何形状来表示。我们还需要一个合适的底图，这些几何形状将在底图上显示。这意味着我们的应用程序至少将包含以下两个地图层：
- en: '![Designing the ForestTrails application](img/00088.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![设计ForestTrails应用程序](img/00088.jpeg)'
- en: Since we want the data to be persistent, we will use a SpatiaLite database to
    hold our track data, while the basemap is simply a GeoTIFF raster image that we
    load and display.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望数据持久化，我们将使用SpatiaLite数据库来存储我们的轨迹数据，而底图则是一个我们加载并显示的GeoTIFF栅格图像。
- en: 'Along with these two main map layers, we will make use of memory-based layers
    to display the following temporary information on top of the map:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个主要地图层之外，我们还将使用基于内存的层来在地图上显示以下临时信息：
- en: The currently selected starting point
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前选定的起点
- en: The currently selected ending point
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前选定的终点
- en: The shortest available path between these two points
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两点之间的最短路径
- en: 'To keep things easier, we''re going to display each of these in a separate
    map layer. This means that our application is going to have a total of five map
    layers:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更简单，我们将将这些信息分别显示在不同的地图层中。这意味着我们的应用程序将总共拥有五个地图层：
- en: '`basemapLayer`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basemapLayer`'
- en: '`trackLayer`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trackLayer`'
- en: '`startPointLayer`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startPointLayer`'
- en: '`endPointLayer`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endPointLayer`'
- en: '`shortestPathLayer`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shortestPathLayer`'
- en: 'Along with the map itself, our application will sport a toolbar and a menu
    bar, both of which let the user access the various features of the system. The
    following actions will be available in the toolbar and menu bar:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了地图本身之外，我们的应用程序还将具有一个工具栏和一个菜单栏，这两个栏都允许用户访问系统的各种功能。以下操作将在工具栏和菜单栏中可用：
- en: '**Zoom in**: This will let the user zoom in on the map.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**放大**：这将允许用户放大地图。'
- en: '**Zoom out**: This lets the user zoom out.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩小**：这允许用户缩小地图。'
- en: '**Pan**: This is the pan mode we implemented earlier, which allows the user
    to move around on the map.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平移**：这是我们之前实现的平移模式，允许用户在地图上移动。'
- en: '**Edit**: Clicking on this item will turn on the track editing mode. If we
    are already in the track editing mode, clicking on it again will prompt the user
    to save their changes before turning off the editing mode.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑**：单击此项目将打开轨迹编辑模式。如果我们已经在轨迹编辑模式中，再次单击它将提示用户在关闭编辑模式之前保存他们的更改。'
- en: '**Add track**: This lets the user add a new track. Note that this item is only
    available while in the track editing mode.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加轨迹**：这允许用户添加新轨迹。请注意，此项目仅在轨迹编辑模式下可用。'
- en: '**Edit track**: This lets the user edit an existing track. This is only enabled
    if the user is in the track editing mode.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑轨迹**：这允许用户编辑现有轨迹。只有当用户处于轨迹编辑模式时，此功能才可用。'
- en: '**Delete track**: This lets the user delete a track. This is only available
    in the track editing mode.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除轨迹**：这允许用户删除轨迹。此功能仅在轨迹编辑模式下可用。'
- en: '**Get info**: This enables the Get Info map tool. When the user clicks on a
    track, this tool will display the attributes for that track, and allow the user
    to make changes to those attributes.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取信息**：这启用了获取信息地图工具。当用户点击一个轨迹时，此工具将显示该轨迹的属性，并允许用户更改这些属性。'
- en: '**Set start point**: This lets the user set the current starting point for
    the shortest path calculation.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置起点**：这允许用户为最短路径计算设置当前起点。'
- en: '**Set end point**: This item lets the user click on the map to set the ending
    point for the shortest path calculation.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置终点**：此项目允许用户在地图上单击以设置最短路径计算的目标点。'
- en: '**Find the shortest path**: This displays the shortest available path between
    the current starting and ending points. Clicking on this item again will hide
    the path.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**找到最短路径**：这将显示当前起始点和终点之间的最短可用路径。再次单击此项目将隐藏路径。'
- en: This gives us a good idea of what our application should look like, and how
    it will work. Let's now start writing our ForestTrails program by implementing
    the basic logic for the application and its main window.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们对我们的应用程序的外观和工作方式有了很好的了解。现在，让我们开始编写ForestTrails程序，通过实现应用程序及其主窗口的基本逻辑。
- en: Creating the application
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: 'Our application is going to be a standalone Python program built using PyQt
    and the PyQGIS library. Taking the Lex application we implemented in [Chapter
    5](part0033_split_000.html#page "Chapter 5. Using QGIS in an External Application"),
    *Using QGIS in an External Application*, as a starting point, let''s see how we
    can organize the source files for the ForestTrails system. We''ll start with the
    following basic structure:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将是一个独立的Python程序，使用PyQt和PyQGIS库构建。以我们在[第5章](part0033_split_000.html#page
    "第5章。在外部应用程序中使用QGIS")中实现的Lex应用程序为起点，*在外部应用程序中使用QGIS*，让我们看看我们如何组织ForestTrails系统的源文件。我们将从以下基本结构开始：
- en: '![Creating the application](img/00089.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![创建应用程序](img/00089.jpeg)'
- en: 'This is very similar to the structure we used for the Lex application, so most
    of this should be familiar to you. The main difference is that we''re using two
    subdirectories to hold additional files. Let''s take a look at what each of these
    files and directories will be used for:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在 Lex 应用程序中使用的结构非常相似，所以其中大部分内容对你来说应该是熟悉的。主要区别在于我们使用两个子目录来存放额外的文件。让我们看看每个文件和目录将用于什么：
- en: '`constants.py`: This module will hold various constants used throughout the
    ForestTrails system.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constants.py`：这个模块将包含 ForestTrails 系统中使用的各种常量。'
- en: '`data`: This is a directory that we will use to hold our raster basemap as
    well as the SpatiaLite database that holds our tracks.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是一个目录，我们将用它来存放我们的栅格底图以及包含我们轨迹的 SpatiaLite 数据库。'
- en: '`forestTrails.py`: This is the main program for our application.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forestTrails.py`：这是我们的应用程序的主程序。'
- en: '`Makefile`: This file tells the make tool how to compile the `resources.qrc`
    file into a `resources.py` module that our application can use.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Makefile`：这个文件告诉 make 工具如何将 `resources.qrc` 文件编译成我们的应用程序可以使用的 `resources.py`
    模块。'
- en: '`mapTools.py`: This module implements our various map tools.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapTools.py`：这个模块实现了我们的各种地图工具。'
- en: '`resources`: This is a directory where we will place our various icons and
    other resources. Since we have so many icon files, it makes sense to put these
    into a subdirectory rather than cluttering up the main directory with all these
    files.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`：这是一个目录，我们将在这里放置各种图标和其他资源。由于我们有这么多图标文件，将这些文件放入子目录而不是让主目录充斥着这些文件是有意义的。'
- en: '`resources.qrc`: This is the resource description file for our application.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources.qrc`：这是我们的应用程序的资源描述文件。'
- en: '`run_lin.sh`: This bash shell script is used to run our application on Linux
    systems.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run_lin.sh`：这个 bash shell 脚本用于在 Linux 系统上运行我们的应用程序。'
- en: '`run_mac.sh`: This bash shell script is used to run our application on Mac
    OS X systems.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run_mac.sh`：这个 bash shell 脚本用于在 Mac OS X 系统上运行我们的应用程序。'
- en: '`run_win.bat`: This batch file is used to run our application on MS Windows
    machines.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run_win.bat`：这个批处理文件用于在 MS Windows 机器上运行我们的应用程序。'
- en: '`ui_mainWindow.py`: This Python module defines the user interface for our main
    window.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ui_mainWindow.py`：这个 Python 模块定义了我们主窗口的用户界面。'
- en: Laying out the application
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局应用程序
- en: 'Let''s implement the ForestTrails system one small step at a time. Create a
    directory to hold the source code for the ForestTrails system, and then create
    the `data` and `resources` subdirectories within it. As many of the files in the
    main directory are straightforward, let''s just go ahead and create the following
    files:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地实现 ForestTrails 系统。创建一个目录来存放 ForestTrails 系统的源代码，然后在其中创建 `data` 和 `resources`
    子目录。由于主目录中的许多文件都很直接，我们不妨直接创建以下文件：
- en: 'The `Makefile` should look like this:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Makefile` 应该看起来像这样：'
- en: '[PRE0]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that if your `pyrcc4` command is in a nonstandard location, you might need
    to modify this file so that `make` can find it.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果你的 `pyrcc4` 命令在非标准位置，你可能需要修改此文件，以便 `make` 可以找到它。
- en: 'Create the `resources.qrc` file as follows:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下方式创建 `resources.qrc` 文件：
- en: '[PRE1]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we've included various image files that will be used for our toolbar
    actions. All these files are in our `resources` subdirectory. We'll look at how
    to obtain these image files shortly.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们已经包含了将被用于我们的工具栏动作的各种图像文件。所有这些文件都在我们的 `resources` 子目录中。我们将在稍后查看如何获取这些图像文件。
- en: 'The `run-lin.sh` file should look like this:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run-lin.sh` 文件应该看起来像这样：'
- en: '[PRE2]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Similarly, `run-mac.sh` should contain the following:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，`run-mac.sh` 应该包含以下内容：
- en: '[PRE3]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `run-win.bat` file should contain:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run-win.bat` 文件应该包含：'
- en: '[PRE4]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If your QGIS installation is in a nonstandard place, you might need to modify
    the appropriate script so that the required libraries can be found.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你的 QGIS 安装在一个非标准位置，你可能需要修改相应的脚本，以便可以找到所需的库。
- en: Since the `resources.qrc` file imports our various toolbar icons and makes them
    available to the application, we'll want to set up those icon files. Let's do
    that now.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `resources.qrc` 文件导入了我们的各种工具栏图标并使它们可供应用程序使用，我们将想要设置这些图标文件。现在让我们来做这件事。
- en: Defining the toolbar icons
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义工具栏图标
- en: 'There are a total of 11 toolbar actions that we will want to display icons
    for:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总共需要为 11 个工具栏动作显示图标：
- en: '![Defining the toolbar icons](img/00090.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![定义工具栏图标](img/00090.jpeg)'
- en: Feel free to create or download your own icons for these toolbar actions, or
    you can use the icon files included in the source code provided with this chapter.
    The file format isn't important, just as long as you include the right suffix
    in the `resoures.qrc` file, and in `ui_mainWindow.py` when the toolbar action
    is initialized.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自由创建或下载这些工具栏动作的自定义图标，或者您可以使用本章提供的源代码中包含的图标文件。文件格式并不重要，只要在`resoures.qrc`文件中包含正确的后缀，并在`ui_mainWindow.py`中初始化工具栏动作时即可。
- en: Make sure you place these files into the `resources` subdirectory, and run `make`
    to build the `resources.py` module so that these icons are available for your
    application to use.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将这些文件放入`resources`子目录中，并运行`make`来构建`resources.py`模块，以便这些图标可供您的应用程序使用。
- en: With this groundwork done, we're ready to start defining the application code
    itself. Let's start with the `constants.py` module.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些基础工作后，我们就可以开始定义应用程序代码本身了。让我们从`constants.py`模块开始。
- en: The constants.py module
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`constants.py`模块'
- en: 'This module will hold various constants that we use to represent the track
    attribute values; by defining them in one place, we make sure that the attribute
    values are used consistently, and we don''t have to remember exactly what the
    values are. For example, the `type` attribute for the tracks layer can have the
    following values:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块将包含我们用来表示轨道属性值的各种常量；通过在同一个地方定义它们，我们确保属性值被一致地使用，我们不必记住确切的值。例如，轨道层的`type`属性可以有以下值：
- en: '`ROAD`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROAD`'
- en: '`WALKING`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WALKING`'
- en: '`BIKE`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BIKE`'
- en: '`HORSE`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HORSE`'
- en: 'Rather than hardwiring these values every time we need them, we''re going to
    define these values in the `constants.py` module. Create this module and enter
    the following code into it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是每次需要这些值时都硬编码它们，我们将定义这些值在`constants.py`模块中。创建此模块并将以下代码输入其中：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We'll be adding a few more constants as we go along, but this is enough to get
    us started.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在继续的过程中添加更多常量，但这已经足够我们开始了。
- en: The forestTrails.py module
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`forestTrails.py`模块'
- en: 'This module defines the main program for the ForestTrails application. It looks
    very similar to the `lex.py` module we defined in [Chapter 5](part0033_split_000.html#page
    "Chapter 5. Using QGIS in an External Application"), *Using QGIS in an External
    Application*. Create your `forestTrails.py` file, and enter the following `import`
    statements into it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块定义了ForestTrails应用程序的主程序。它看起来与我们在第5章中定义的`lex.py`模块非常相似，即*在外部应用程序中使用QGIS*。创建您的`forestTrails.py`文件，并将以下`import`语句输入其中：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, we want to define the main window for our application in a class, which
    we will call `ForestTrailsWindow`. This is where the bulk of the application code
    will be implemented; this class will get quite complicated, but we're going to
    start easy and just define the window itself, and have empty placeholder methods
    for all the toolbar actions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想在类中定义我们应用程序的主窗口，我们将称之为`ForestTrailsWindow`。这是应用程序代码的大部分将得到实现的地方；这个类将变得相当复杂，但我们将从简单开始，只定义窗口本身，并为所有工具栏动作定义空占位符方法。
- en: 'Let''s define the class itself and the `__init__()` method to initialize a
    new window:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义类本身和`__init__()`方法来初始化一个新窗口：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is very similar to the `__init__()` method for the Lex application; we'll
    define the `Ui_MainWindow` class in the `ui_mainWindow.py` module to set up the
    application's user interface. This is where all those `actionXXX` instance variables
    will be defined. In our `__init__()` method, we're connecting these actions to
    various methods, which will respond when the user selects the action from the
    toolbar or menu bar.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这与Lex应用程序的`__init__()`方法非常相似；我们将在`ui_mainWindow.py`模块中定义`Ui_MainWindow`类来设置应用程序的用户界面。这就是所有那些`actionXXX`实例变量将被定义的地方。在我们的`__init__()`方法中，我们将这些动作连接到各种方法，当用户从工具栏或菜单栏选择动作时，这些方法将做出响应。
- en: 'The rest of the `__init__()` method simply sets up a map canvas and lays it
    out within the window. With this method behind us, we can now define all those
    action-handling methods. We can borrow two of these directly from `lex.py`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`方法的其余部分只是设置地图画布并将其布局在窗口内。有了这个方法，我们现在可以定义所有那些动作处理方法。我们可以直接从`lex.py`借用其中两个：'
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For the rest, we''ll hold off on implementing them until the application is
    a bit more complete. To allow our program to run, we''ll set up empty placeholder
    methods for the remaining action handlers:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余部分，我们将推迟实现它们，直到应用程序更加完整。为了允许我们的程序运行，我们将为剩余的动作处理程序设置空占位符方法：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The last part of the `forestTrails.py` module is the `main()` function, which
    is called when the program is run:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`forestTrails.py`模块的最后部分是`main()`函数，当程序运行时会被调用：'
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once again, this is almost identical to the code we saw earlier in the Lex application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这与我们在Lex应用程序中看到的代码几乎相同。
- en: This completes our initial implementation of the `forestTrails.py` module. Our
    next step is to create the module that will hold all our map tools.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了`forestTrails.py`模块的初始实现。我们的下一步是创建一个模块，用于存放我们所有的地图工具。
- en: The mapTools.py module
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mapTools.py模块
- en: 'We used `mapTools.py` in the Lex application to define our various map tools
    separately from the main program. We''re going to do the same here. For now, though,
    our `mapTools.py` module is almost empty:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Lex应用程序中使用了`mapTools.py`来分别定义我们的各种地图工具，而不在主程序中定义。我们在这里也将这样做。不过，目前我们的`mapTools.py`模块几乎是空的：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Obviously, we'll be adding to this as we start to implement our various map
    tools, but for now, this is enough.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，随着我们开始实现各种地图工具，我们还将添加更多内容，但就目前而言，这已经足够了。
- en: The ui_mainWindow.py module
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ui_mainWindow.py模块
- en: 'This is the last module we need to define for our initial implementation of
    the ForestTrails system. As in the Lex application, this module defines a `Ui_MainWindow`
    class, which implements the application''s user interface, and defines `QAction`
    objects for the various menu and toolbar items. We''ll start by importing the
    modules that our class will need:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要为ForestTrails系统的初始实现定义的最后一个模块。与Lex应用程序一样，这个模块定义了一个`Ui_MainWindow`类，它实现了应用程序的用户界面，并为各种菜单和工具栏项定义了`QAction`对象。我们将首先导入我们的类需要的模块：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we''ll define the `Ui_MainWindow` class and the `setupUi()` method that
    will do all the work:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义`Ui_MainWindow`类和`setupUi()`方法，它将完成所有工作：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first part of the `setupUi()` method sets the title for the window, creates
    a `centralWidget` instance variable to hold the map view, and initializes the
    application''s menus and toolbar:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupUi()`方法的第一部分设置了窗口的标题，创建了一个`centralWidget`实例变量来保存地图视图，并初始化应用程序的菜单和工具栏：'
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we want to define all the `QAction` objects for the various toolbar and
    menu items. For each action, we''ll define the action''s icon and keyboard shortcut,
    and check whether or not the action is **checkable** (that is, stays on when the
    user clicks on it):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要定义各种工具栏和菜单项的`QAction`对象。对于每个动作，我们将定义动作的图标和键盘快捷键，并检查动作是否**可勾选**（即用户点击时保持选中状态）：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then add the various actions to our application''s menus:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将各种动作添加到应用程序的菜单中：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we''ll add the actions to our toolbar and tell the window to resize
    itself to fit its contents:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将动作添加到工具栏中，并告诉窗口根据内容调整大小：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This completes our implementation of the `ui_mainWindow.py` module. We now have
    a complete mini application that should be able to run. Let's try it out.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了`ui_mainWindow.py`模块的实现。我们现在有一个完整的小型应用程序，应该能够运行。让我们试试它。
- en: Running the application
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: Now that you've entered all this code, it's time to check whether it works.
    Let's try to run the application using the appropriate startup script. Open a
    terminal or command-line window, navigate into the `forestTrails` directory, and
    run the appropriate startup script.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经输入了所有这些代码，是时候检查它是否工作。让我们尝试使用适当的启动脚本运行应用程序。打开一个终端或命令行窗口，导航到`forestTrails`目录，并运行相应的启动脚本。
- en: 'If all goes well, you should see the application''s main window along with
    the toolbar and menu items:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到应用程序的主窗口以及工具栏和菜单项：
- en: '![Running the application](img/00091.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用程序](img/00091.jpeg)'
- en: Of course, the main window's map view is empty, and none of the toolbar or menu
    items do anything yet, but at least we have a working framework for our application.
    Our next steps are to obtain the basemap for our application, set up our map layers,
    and then start implementing the various toolbar and menu bar items.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，主窗口的地图视图是空的，工具栏或菜单项还没有任何功能，但至少我们为我们的应用程序提供了一个工作的框架。我们的下一步是获取应用程序的基础地图，设置我们的地图层，然后开始实现各种工具栏和菜单栏项。
- en: Obtaining the basemap
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取基础地图
- en: To follow through this section of the chapter, you are going to need access
    to the GDAL command-line tools. GDAL is probably already installed on your computer,
    as QGIS makes use of it. If you don't already have GDAL installed, go to [www.gdal.org](http://www.gdal.org)
    and click on the **Downloads** link to download and install a copy onto your machine.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续本章的这一部分，您将需要访问GDAL命令行工具。GDAL可能已经安装在您的计算机上，因为QGIS使用了它。如果您还没有安装GDAL，请访问[www.gdal.org](http://www.gdal.org)并点击**下载**链接，将副本下载并安装到您的机器上。
- en: One of the challenges of writing a mapping application is to obtain a high-quality
    basemap on top of which your geospatial data will be displayed. In our case, we
    want our basemap to show an aerial photograph of the forest. We're going to use
    the Whakarewarewa Forest in Rotorua, New Zealand, for our ForestTrails application.
    Fortunately, suitable aerial photographs are available from the *Land Information
    New Zealand* website.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 编写地图应用的一个挑战是在上面显示您的地理空间数据的优质底图。在我们的案例中，我们希望底图显示森林的航空照片。我们将使用新西兰罗托鲁瓦的Whakarewarewa森林作为我们的ForestTrails应用。幸运的是，*新西兰土地信息网站*提供了合适的航空照片。
- en: 'Go to the following web page, which provides high-resolution aerial photos
    for the Bay of Plenty, New Zealand:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 访问以下网页，该网页提供了新西兰丰盛湾的高分辨率航空照片：
- en: '[https://data.linz.govt.nz/layer/1760-bay-of-plenty-025m-rural-aerial-photos-2011-2012/](https://data.linz.govt.nz/layer/1760-bay-of-plenty-025m-rural-aerial-photos-2011-2012/)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://data.linz.govt.nz/layer/1760-bay-of-plenty-025m-rural-aerial-photos-2011-2012/](https://data.linz.govt.nz/layer/1760-bay-of-plenty-025m-rural-aerial-photos-2011-2012/)'
- en: 'We want to download a basemap that covers the Whakarewarewa forest, which is
    just south of the city of Rotorua. In the map on the right-hand side of the page,
    pan and zoom until the following area of the map is visible:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要下载一个覆盖Whakarewarewa森林的底图，该森林位于罗托鲁瓦市以南。在页面右侧的地图上，平移并缩放到以下地图区域：
- en: '![Obtaining the basemap](img/00092.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![获取底图](img/00092.jpeg)'
- en: 'The dark circular area in the center of the map is Lake Rotorua. Zoom in further
    and pan down to the area just south of Rotorua:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 地图中心黑暗的圆形区域是罗托鲁阿湖。进一步放大并向下平移到罗托鲁阿以南的区域：
- en: '![Obtaining the basemap](img/00093.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![获取底图](img/00093.jpeg)'
- en: 'This map shows the Whakarewarewa forest image we want to download. Next, click
    on the **crop** tool (![Obtaining the basemap](img/00094.jpeg)) in the upper right-hand
    corner and select the following area of the map:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这张地图显示了我们要下载的Whakarewarewa森林图像。接下来，点击右上角的**裁剪**工具 (![获取底图](img/00094.jpeg))
    并选择以下地图区域：
- en: '![Obtaining the basemap](img/00095.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![获取底图](img/00095.jpeg)'
- en: 'With the appropriate area of the map selected, click on the **"Download or
    Order"** link in the upper right-hand corner. The window that appears gives you
    the option to download the basemap. Make sure you select the following options:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了适当的地图区域后，点击右上角的**“下载或订购”**链接。出现的窗口为您提供下载底图的选择。请确保您选择以下选项：
- en: Map Projection will be NZGD2000
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图投影将为NZGD2000
- en: Image format will be TIFF in the original resolution
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始图像格式将为TIFF，保持原始分辨率
- en: Note
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will need to register to download the file, but the registration process
    only takes a few seconds, and it doesn't cost anything.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您需要注册才能下载文件，但注册过程只需几秒钟，且不收费。
- en: The resulting download should be about 2.8 GB, just under the 3 GB limit for
    file downloads from this site. If it's too big, you'll have to select a smaller
    area to download.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的下载文件大小约为2.8 GB，略低于本站文件下载的3 GB限制。如果文件太大，您将不得不选择较小的区域进行下载。
- en: 'Once you''ve downloaded the file, you will end up with a ZIP archive that contains
    a number of TIFF format raster image files. Next, we need to combine these images
    into a single `.tif` file for our basemap. To do this, we''ll use the `gdal_merge.py`
    command that comes with GDAL:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件后，您将得到一个包含多个TIFF格式栅格图像文件的ZIP存档。接下来，我们需要将这些图像合并成一个单独的`.tif`文件作为我们的底图。为此，我们将使用GDAL附带的`gdal_merge.py`命令：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Choose an appropriate destination for the `basemap.tif` file (by replacing `/dst/path`
    with a sensible location, for example, the path to your desktop). If the current
    directory is not set to the folder that contains the downloaded `.tif` files,
    you'll need to also specify the source path in the command.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`basemap.tif`文件的适当目的地（例如，通过将`/dst/path`替换为合理的位置，例如桌面路径）。如果当前目录未设置为包含下载的`.tif`文件的文件夹，您还需要在命令中指定源路径。
- en: It will take a while for this command to stitch together the various images,
    but the result should be a single large file named `basemap.tif`. This is a TIFF-format
    raster image that contains the aerial photograph you selected, geo referenced
    to the appropriate portion of the Earth's surface.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将需要一段时间来拼接各种图像，但结果应该是一个名为 `basemap.tif` 的单个大文件。这是一个包含您所选航空照片的TIFF格式栅格图像，并且地理参考到地球表面的适当部分。
- en: 'Unfortunately, we can''t use this file directly. To see why, run the `gdalinfo`
    command on the downloaded file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法直接使用此文件。要了解原因，请在下载的文件上运行`gdalinfo`命令：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Among other things, this tells us which coordinate reference system the file
    is using:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这告诉我们文件使用的是哪个坐标参考系统：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, the downloaded basemap uses the **New Zealand Transverse Mercator
    2000** coordinate system. We need to translate this into the WGS84 (geographic
    latitude/longitude coordinate) coordinate system so that we can use it in the
    ForestTrails program. To do this, we''ll use the `gdalwarp` command, like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，下载的底图使用的是**新西兰横轴墨卡托2000**坐标系。我们需要将其转换为WGS84（地理纬度/经度坐标）坐标系，以便在ForestTrails程序中使用。为此，我们将使用`gdalwarp`命令，如下所示：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you look at the resulting image using `gdalinfo`, you''ll see that it has
    been converted into the lat/long coordinate system:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`gdalinfo`查看生成的图像，您会看到它已被转换为纬度/经度坐标系：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might wonder why we didn't download the file directly in the WGS84 coordinate
    system. We downloaded the file in its original CRS because this gives us more
    control over the final image. Reprojecting the image ourselves also makes it easier
    to see how the image was changed when it was reprojected.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么我们没有直接以WGS84坐标系下载文件。我们以原始CRS下载文件，因为这使我们能够更好地控制最终图像。自己重新投影图像也更容易看到图像在重新投影时发生了哪些变化。
- en: 'So far, so good. However, if we look at the resulting image, we''ll see another
    problem:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。然而，如果我们查看生成的图像，我们会看到另一个问题：
- en: '![Obtaining the basemap](img/00096.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![获取底图](img/00096.jpeg)'
- en: 'The translation from NZGD2000 into WGS84 rotated the basemap slightly, so the
    borders of the map don''t look good. Now, we need to trim the map to get rid of
    the unwanted borders. To do this, we''ll use the `gdal_warp` command again, this
    time with a target extent:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从NZGD2000到WGS84的转换使底图略微旋转，因此地图的边界看起来不太好。现在，我们需要裁剪地图以去除不需要的边界。为此，我们将再次使用`gdal_warp`命令，这次带有目标范围：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You might need to adjust the lat/long values if you have selected slightly different
    bounds when downloading the basemap. The corner coordinate values displayed by
    `gdalinfo` will give you a clue as to what values have to be used.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在下载底图时选择了略微不同的边界，您可能需要调整纬度/经度值。`gdalinfo`显示的角落坐标值将为您提供有关要使用哪些值的线索。
- en: 'The resulting file is a good raster basemap for us to use for our ForestTrails
    program:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件是我们用于ForestTrails程序的理想栅格底图：
- en: '![Obtaining the basemap](img/00097.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![获取底图](img/00097.jpeg)'
- en: Copy the final image into your `forestTrails/data` directory and rename it back
    to `basemap.tif`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将最终图像复制到您的`forestTrails/data`目录，并将其重命名为`basemap.tif`。
- en: Defining the map layers
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义地图层
- en: We know that we want to have a total of five map layers in our application.
    The basemap layer will display the `basemap.tif` file we just downloaded, while
    the track layer will use a SpatiaLite database to store and display the track
    data entered by the user. The remaining map layers will display temporary features
    held in memory.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们希望在应用程序中总共拥有五个地图层。底图层将显示我们刚刚下载的`basemap.tif`文件，而轨迹层将使用SpatiaLite数据库来存储和显示用户输入的轨迹数据。其余的地图层将显示内存中持有的临时特征。
- en: 'Let''s start by defining a new method in our `forestTrails.py` module to initialize
    the SpatiaLite database we will use for the track layer:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`forestTrails.py`模块中定义一个新的方法开始，以初始化我们将用于轨迹层的SpatiaLite数据库：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, we check to see whether the SpatiaLite database file exists
    in our `data` subdirectory, and create a new database if necessary. We define
    the various fields that will hold the various track attributes, and use a `QgsVectorFileWriter`
    object to create the database.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们检查我们的`data`子目录中是否存在SpatiaLite数据库文件，并在必要时创建一个新的数据库。我们定义了将保存各种轨迹属性的各种字段，并使用`QgsVectorFileWriter`对象创建数据库。
- en: 'You will also need to modify the `main()` function to call the `setupDatabase()`
    method. Add the following line to this function after the call to `window.raise_()`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要修改 `main()` 函数以调用 `setupDatabase()` 方法。在调用 `window.raise_()` 之后添加以下行到这个函数中：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we''ve set up our database for the track layer, we can define our
    various map layers. We''ll create a new method called `setupMapLayers()` to do
    this. Let''s start by defining a `layers` variable to hold the various map layers,
    and initialize our base map layer:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为轨迹层设置了数据库，我们可以定义我们的各种地图层。我们将创建一个名为 `setupMapLayers()` 的新方法来完成这个任务。让我们首先定义一个
    `layers` 变量来保存各种地图层，并初始化我们的基础地图层：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we want to set up our **tracks** layer. Since this is stored in a SpatiaLite
    database, we have to use a `QgsDataSourceURI` object to connect the database to
    the map layer. The following code shows how this is done:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要设置我们的 **tracks** 层。由于这个层存储在 SpatiaLite 数据库中，我们必须使用 `QgsDataSourceURI`
    对象将数据库连接到地图层。以下代码展示了如何完成这个操作：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now set up a memory-based map layer to display the shortest path:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以设置一个基于内存的地图层来显示最短路径：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We saw how to create memory-based map layers in [Chapter 6](part0047_split_000.html#page
    "Chapter 6. Mastering the QGIS Python API"), *Mastering the QGIS Python API*,
    so there shouldn't be any surprises here; we're simply defining the shortest path
    layer to hold a LineString geometry.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第6章](part0047_split_000.html#page "第6章. 掌握QGIS Python API") 中看到了如何创建基于内存的地图层，*掌握QGIS
    Python API*，所以这里不应该有任何惊喜；我们只是在定义一个用于保存LineString几何的最短路径层。
- en: 'Next, we want to set up another memory-based map layer to show the user''s
    selected starting point:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要设置另一个基于内存的地图层来显示用户的选定起点：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Also, we want to set another map layer for the ending point:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还想为终点设置另一个地图层：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This completes all five of our map layers. The final part of the `setupMapLayers()`
    method adds these various layers to the map canvas. Note that because we defined
    the map layers in back-to-front order (in other words, the first entry in `layers`
    is the basemap, which should appear at the back), we have to reverse the layers
    before we add them to the map canvas. Here is the relevant code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们五个地图层的所有设置。`setupMapLayers()` 方法的最后一部分将这些各种层添加到地图画布上。请注意，因为我们按从后向前的顺序定义了地图层（换句话说，`layers`
    中的第一个条目是底图，它应该出现在后面），在将它们添加到地图画布之前，我们必须反转这些层。以下是相关代码：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The last thing we have to do is add a call to `setupMapLayers()` from within
    our `main()` function. Add the following immediately after the `window.setupDatabase()`
    line:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要做的就是从我们的 `main()` 函数中添加对 `setupMapLayers()` 的调用。在 `window.setupDatabase()`
    行之后立即添加以下内容：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that our map layers are set up, we can run our program again. There''s
    no vector data yet, but the basemap should be visible, and we can zoom in and
    out using the toolbar icons:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了地图层，我们可以再次运行我们的程序。目前还没有矢量数据，但底图应该是可见的，我们可以使用工具栏图标进行缩放：
- en: '![Defining the map layers](img/00098.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![定义地图层](img/00098.jpeg)'
- en: Defining the map renderers
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义地图渲染器
- en: 'Now that we have the map layers, we''ll want to set up appropriate symbols
    and renderers to draw the vector data onto the map. Let''s start by defining a
    method called `setupRenderers()`, which creates the renderers for our various
    map layers. Our first renderer will display the track layer, where we use a `QgsRuleBasedRendererV2`
    object to display the tracks in different ways depending on the type of track,
    whether or not the track is open, and whether it is bidirectional or can only
    be used in one direction. Here is the relevant code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了地图层，我们将想要设置适当的符号和渲染器来将矢量数据绘制到地图上。让我们首先定义一个名为 `setupRenderers()` 的方法，它为我们的各种地图层创建渲染器。我们的第一个渲染器将显示轨迹层，我们使用
    `QgsRuleBasedRendererV2` 对象根据轨迹类型、轨迹是否开放以及是否为双向或只能单向使用来以不同的方式显示轨迹。以下是相关代码：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, we iterate over all the possible track types. Based on the track
    type, we choose a suitable line width. We also choose a color to use for the line
    and the arrowheads—for now, we're simply using the same color for every type of
    track. We then iterate over all the possible status and direction values, and
    call a helper method named `createTrackSymbol()` to create a suitable symbol for
    this track type, status, and direction. We then create a `QgsRuleBasedRendererV2.Rule`
    object that uses that symbol for those tracks with the given type, status, and
    direction. Finally, we define an "else" rule for the renderer, displaying the
    track as a simple black line if the track doesn't have any of the expected attribute
    values.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们遍历所有可能的轨迹类型。根据轨迹类型，我们选择合适的线宽。我们还选择用于线条和箭头的颜色——目前，我们只是为每种轨迹类型使用相同的颜色。然后，我们遍历所有可能的状态和方向值，并调用名为`createTrackSymbol()`的辅助方法来为该轨迹类型、状态和方向创建合适的符号。然后，我们创建一个`QgsRuleBasedRendererV2.Rule`对象，该对象使用该符号为给定类型、状态和方向的轨迹。最后，我们为渲染器定义一个“else”规则，如果轨迹没有预期的属性值，则将其显示为简单的黑色线条。
- en: 'Our remaining map layers will use straightforward line or marker symbols to
    display the shortest path, and the starting and ending points. Here''s the remainder
    of the `setupRenderers()` method, which defines these map renderers:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩余的地图层将使用简单的线条或标记符号来显示最短路径以及起点和终点。以下是`setupRenderers()`方法的其余部分，它定义了这些地图渲染器：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that we''ve defined the `setupRenderers()` method itself, let''s modify
    our `main()` function to call it. Add the following line immediately after the
    call to `setupMapLayers()`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`setupRenderers()`方法本身，让我们修改我们的`main()`函数来调用它。在调用`setupMapLayers()`之后立即添加以下行：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are a few more things we need to do to finish implementing our map renderers.
    Firstly, we need to define the `createTrackSymbol()` helper method that we used
    to set up the track renderer. Add the following to your `ForestTrailsWindow` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的地图渲染器的实现，我们还需要做一些其他的事情。首先，我们需要定义我们用来设置轨迹渲染器的`createTrackSymbol()`辅助方法。将以下内容添加到您的`ForestTrailsWindow`类中：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The complex part of this method is the code to draw an arrowhead onto the track
    to indicate the track's direction. Apart from this, we simply draw a line to represent
    the track using the specified color and width, and if the track is closed, we
    draw the track as a dotted line.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的复杂部分是绘制箭头到轨迹上以指示轨迹方向的代码。除此之外，我们只是使用指定的颜色和宽度绘制线条来表示轨迹，如果轨迹是闭合的，我们将其绘制为虚线。
- en: 'Our final task here is to add some more entries to our `constants.py` module
    to represent the various sizes and line widths used by our renderers. Add the
    following to the end of this module:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的最终任务是向我们的`constants.py`模块添加一些条目来表示我们的渲染器使用的各种大小和线宽。将以下内容添加到该模块的末尾：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: All of these values are in map units.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些值都在地图单位中。
- en: Unfortunately, we can't see these renderers being used yet, as we don't have
    any vector features to display, but we need to implement them now so that our
    code will work when the time comes. We won't see these renderers in action until
    the next chapter, when the user starts adding tracks and selecting start/end points
    on the map.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们目前看不到这些渲染器被使用，因为我们还没有任何矢量要素来显示，但我们需要现在实现它们，以便我们的代码在需要时能够工作。我们将在下一章中看到这些渲染器的实际效果，当用户开始添加轨迹并在地图上选择起点和终点时。
- en: The Pan Tool
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平移工具
- en: 'To let the user move around the map, we''ll make use of the `PanTool` class
    we implemented in an earlier chapter. Add the following class definition to the
    `mapTools.py` module:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户在地图上移动，我们将使用我们在早期章节中实现的`PanTool`类。将以下类定义添加到`mapTools.py`模块中：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Back in our `forestTrails.py` module, add the following new method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`forestTrails.py`模块中，添加以下新方法：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This method will initialize the various map tools that our application will
    use; we''ll add to this method as we go along. For now, add the following to your
    `main()` function, after the call to `window.setupRenderers()`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将初始化我们的应用程序将使用的各种地图工具；我们将随着进展添加到这个方法中。现在，在调用`window.setupRenderers()`之后，向您的`main()`函数中添加以下内容：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can now replace our dummy implementation of `setPanMode()` with the real
    thing:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以用真实的东西替换我们的`setPanMode()`的模拟实现：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you run your program now, you'll see that the user can now zoom in and out
    and use the pan tool to move around the basemap.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行程序，您会看到用户现在可以放大和缩小，并使用平移工具在基本地图上移动。
- en: Implementing the track editing mode
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现轨迹编辑模式
- en: Our final task for this chapter is to implement the track editing mode. We learned
    in the previous chapter how we can turn on the editing mode for a map layer and
    then use various map tools to let the user add, edit, and delete features. We'll
    start to implement the actual map tools in [Chapter 9](part0072_split_000.html#page
    "Chapter 9. Completing the ForestTrails Application"), *Completing the ForestTrails
    Application*, but for now, let's define our track editing mode itself.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个任务是实现轨道编辑模式。我们在上一章学习了如何为地图层打开编辑模式，然后使用各种地图工具让用户添加、编辑和删除功能。我们将在[第9章](part0072_split_000.html#page
    "第9章。完成ForestTrails应用程序")，*完成ForestTrails应用程序*中开始实现实际的地图工具，但现在，让我们定义我们的轨道编辑模式本身。
- en: 'The `setEditMode()` method is used to enter and leave the track editing mode.
    Replace the placeholder method you defined earlier with this new implementation:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`setEditMode()`方法用于进入和退出轨道编辑模式。用这个新实现替换你之前定义的占位符方法：'
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If the user is currently editing the tracks and has made some changes, we ask
    the user whether they want to save their changes, and either commit the changes
    or roll them back. If no changes have been made, we roll back (to turn off the
    vector layer's editing mode) and switch back to the panning mode.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户目前正在编辑轨道并已进行了某些更改，我们将询问用户他们是否想要保存更改，然后提交更改或撤销更改。如果没有进行任何更改，我们将撤销（关闭矢量层的编辑模式）并切换回平移模式。
- en: 'There are a couple of instance variables that we use here to monitor the state
    of our track editing: `self.editing` will be set to `True` if we''re currently
    editing the tracks, and `self.modified` is set to `True` if the user has changed
    anything in the track layer. We''ll have to add the following to our `ForestTrailsWindow.__init__()`
    method to initialize these two instance variables:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一些实例变量来监控轨道编辑的状态：`self.editing`将在我们正在编辑轨道时设置为`True`，而`self.modified`将在用户在轨道层中更改了任何内容时设置为`True`。我们必须在我们的`ForestTrailsWindow.__init__()`方法中添加以下内容来初始化这两个实例变量：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'There''s another method that we haven''t seen before: `adjustActions()`. This
    method will enable/disable and check/uncheck the various actions: depending on
    the application''s current state. For example, when we enter the track editing
    mode, our `adjustActions()` method will enable the add, edit, and delete tools,
    and these tools will be disabled again when the user leaves the track-editing
    mode.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个我们之前没有见过的方法：`adjustActions()`。这个方法将根据应用程序的当前状态启用/禁用和检查/取消选中各种操作：例如，当我们进入轨道编辑模式时，我们的`adjustActions()`方法将启用添加、编辑和删除工具，当用户离开轨道编辑模式时，这些工具将再次被禁用。
- en: 'We can''t implement all of `adjustActions()`at the moment because we haven''t
    yet defined the various map tools that our application will use. For now, we''ll
    write the first half of this method:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前无法实现所有的`adjustActions()`，因为我们还没有定义应用程序将使用的各种地图工具。现在，我们将编写这个方法的前半部分：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We''ll also need to add a call to `adjustActions()` in our `main()` function
    after the call to `setPanMode()`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在调用`setPanMode()`之后在我们的`main()`函数中添加对`adjustActions()`的调用：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With the track editing mode implemented, the user can click on the **Edit**
    toolbar icon to enter the track editing mode, and click on it again to leave that
    mode. Of course, we can't make any changes yet, but the code itself is in place.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了轨道编辑模式后，用户可以点击**编辑**工具栏图标进入轨道编辑模式，再次点击它以退出该模式。当然，我们目前还不能进行任何更改，但代码本身已经就位。
- en: 'There''s one more feature we''d like to add to our application; if the user
    makes some changes to the track layer and then tries to quit the application,
    we''d like to give the user the chance to save their changes. To do this, we''ll
    implement the `quit()` method, which we linked to the `actionQuit` action:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想在我们的应用程序中添加一个功能；如果用户对轨道层进行了某些更改然后尝试退出应用程序，我们希望给用户一个保存更改的机会。为此，我们将实现一个`quit()`方法，并将其链接到`actionQuit`操作：
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is very similar to the part of the `setEditMode()` method that lets the
    user leave the track editing mode, except that we call `qApp.quit()` to quit the
    application at the end. We have one more method to define, which intercepts an
    attempt to close the window and calls `self.quit()`. This prompts the user to
    save their changes if they close the window while editing. Here is the definition
    for this method:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`setEditMode()`方法中允许用户退出轨道编辑模式的部分非常相似，只不过我们在最后调用`qApp.quit()`来退出应用程序。我们还有一个方法需要定义，它拦截关闭窗口的尝试并调用`self.quit()`。这会在用户在编辑时关闭窗口时提示用户保存他们的更改。以下是此方法的定义：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we designed and started to implement a complete mapping application
    for maintaining a map of tracks and roads within a recreational forest. We implemented
    the application itself, defined our map layers, obtained a high-resolution basemap
    for our application, and implemented zooming, panning, and the code necessary
    for editing the track layer.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设计和开始实施了一个完整的映射应用程序，用于维护休闲森林内轨迹和道路的地图。我们实现了应用程序本身，定义了我们的地图层，为我们的应用程序获取了高分辨率的基础地图，并实现了缩放、平移以及编辑轨迹层所需的代码。
- en: In the next chapter, we will round out the implementation of our ForestTrails
    system by implementing the map tools to let the user add, edit, and delete tracks.
    We will also implement the code for editing track attributes and finding the shortest
    available path between two points.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过实现地图工具来完善我们的ForestTrails系统的实施，使用户能够添加、编辑和删除轨迹。我们还将实现编辑轨迹属性和查找两点之间最短可用路径的代码。
