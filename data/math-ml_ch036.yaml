- en: Appendix B
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 B
- en: The Structure of Mathematics
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数学的结构
- en: 'We’ve come a long way from the start: we’ve studied propositions, logical connectives,
    predicates, quantifiers, and all the formal logic. This was to be able to talk
    about mathematics. However, ultimately, we want to do mathematics.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走过了很长的路程：我们研究了命题、逻辑联结词、谓词、量词和所有形式逻辑。这是为了能够谈论数学。然而，最终，我们希望做的是数学。
- en: As the only exact science, mathematics is built on top of definitions, theorems,
    and proofs. We precisely define objects, formulate conjectures about them, then
    prove those with mathematically correct arguments. You can think of mathematics
    as a colossal building made of propositions, implications, and modus ponens. If
    one theorem fails, all others that build upon it fail too.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为唯一的精确科学，数学建立在定义、定理和证明的基础上。我们精确地定义对象，对它们提出猜想，然后用数学上正确的论证证明这些猜想。你可以把数学看作是由命题、蕴涵和
    modus ponens 组成的庞大建筑。如果一个定理失败，那么所有依赖于它的其他定理也都会失败。
- en: In other fields of science, the modus operandi is to hypothesize, experiment,
    and validate. However, experiments are not enough in mathematics. For instance,
    think about the famous Fermat numbers, that is, numbers of the form F[n] := 2^(2^n)
    + 1\. Fermat conjectured them all to be prime numbers, as F[0], F[1], F[2], F[3],
    and F[4] are primes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他科学领域，操作方式是假设、实验和验证。然而，在数学中，实验并不足够。例如，考虑著名的费马数，即形如 F[n] := 2^(2^n) + 1 的数。费马曾猜测它们都是素数，因为
    F[0]、F[1]、F[2]、F[3] 和 F[4] 都是素数。
- en: Five affirmative “experiments” might have been enough to accept the hypothesis
    as true in certain fields of science. Not in mathematics. In 1732, Euler showed
    that F[5] = 4,294,967,297 is not a prime, as 4,294,967,297 = 641 × 6,700,417\.
    (Imagine calculating that in the 18th century, long before the age of computing.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些科学领域，五次肯定的“实验”可能足以接受假设为真。然而在数学中却不行。1732年，欧拉证明了 F[5] = 4,294,967,297 不是素数，因为
    4,294,967,297 = 641 × 6,700,417。（想象一下在18世纪计算这个数字，计算机时代还远未到来。）
- en: So far, we’ve seen some definitions, theorems, and even proofs when talking
    about mathematical logic. It’s time to put them under the magnification glass
    and see what they are!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在讨论数学逻辑时已经看到了若干定义、定理，甚至证明。现在是时候放大镜下审视它们，看看它们究竟是什么！
- en: B.1 What is a definition?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 什么是定义？
- en: Ambiguity is the drawback of natural languages. How would you define, say, the
    concept of “hot”? Upon several attempts, you would soon discover that no two people
    have the same definition.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊性是自然语言的缺点。例如，如何定义“热”这一概念？经过几次尝试，你会很快发现没有两个人对其有相同的定义。
- en: In mathematics, there is no room for ambiguity. Every object and every property
    must be precisely defined. It’s best to look at a good example instead of philosophizing
    about it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，没有模糊性存在的余地。每个对象和每个属性必须被精确定义。最好通过一个好的例子来理解，而不是进行哲学思考。
- en: Definition 103\. (Divisors)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 103.（约数）
- en: Let b ∈ℤ be an integer. We say that a ∈ℤ is a divisor of b if there exists an
    integer k ∈ℤ such that b = ka.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 设 b ∈ ℤ 是一个整数。我们说 a ∈ ℤ 是 b 的约数，当且仅当存在一个整数 k ∈ ℤ，使得 b = ka。
- en: The property “a is a divisor of b” is denoted by a∣b.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “a 是 b 的约数”这一属性用 a∣b 表示。
- en: For example, 2∣10 and 5∣10, but 7 ∤ 10\. (Crossed symbols mean the negation
    of the said property.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，2∣10 和 5∣10，但 7 ∤ 10。（交叉符号表示所述属性的否定。）
- en: In terms of our formal language, the definition of “a is a divisor of b” can
    be written as
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用我们正式语言来表达，“a 是 b 的约数”的定义可以写作：
- en: '*a* ∣ *b* : ∃ *k* ∈ ℤ, *b* = *k**a*. (B.1)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* ∣ *b* ：∃ *k* ∈ ℤ，*b* = *k**a*。（B.1）'
- en: Don’t let the a∣b notation deceive you; this is a predicate in disguise. We
    could have denoted a∣b by
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让 a∣b 的符号迷惑了你；这实际上是一个伪装的谓词。我们本可以用其他方式表示 a∣b，例如：
- en: '![divisor(a,b) : ∃k ∈ ℤ, b = ka. ](img/file2112.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![divisor(a,b) : ∃k ∈ ℤ, b = ka. ](img/file2112.png)'
- en: Although every mathematical definition can be formalized, we’ll prefer our natural
    language because it is much easier to understand. (At least for humans. Not so
    much for computers.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每一个数学定义都可以形式化，但我们更倾向于使用自然语言，因为它更容易理解。（至少对人类来说是这样，对计算机来说则不然。）
- en: Like building blocks, definitions build on top of each other.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就像积木一样，定义是层层叠加的。
- en: (If you have a sharp eye for details, you noticed that even Definition [103](ch036.xhtml#x1-364003r103)
    is built upon other concepts such as numbers, multiplication, and equality. We
    haven’t defined them precisely, just assumed they are there. Since our goal is
    not to rebuild mathematics from scratch, we’ll let this one slide.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你有敏锐的细节观察力，你会注意到，即使是定义[103](ch036.xhtml#x1-364003r103)也建立在其他概念之上，比如数字、乘法和等式。我们没有精确定义这些概念，只是假设它们是存在的。由于我们的目标不是从零开始重建数学，因此我们会对此略过不提。）
- en: Again, it’s best to see an example here. Let’s see what even and odd numbers
    are!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，最好在这里看一个例子。让我们来看一下偶数和奇数！
- en: Definition 104\. (Even and odd numbers)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 104. （偶数和奇数）
- en: Let n ∈ℤ be an integer. We say that n is even if 2∣n.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 设 n ∈ℤ 是一个整数。我们说 n 是偶数，当且仅当 2∣n。
- en: In turn, we say that n is odd if 2 ∤ n. (The notation a ∤ b is the negation
    of the “a is a divisor of b” predicate.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，我们说 n 是奇数，当且仅当 2 ∤ n。（符号 a ∤ b 表示“a 不是 b 的约数”的否定。）
- en: One more time, with our formal language. For an integer n ∈ℤ, the predicates
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，用我们正式的语言。对于整数 n ∈ℤ，谓词
- en: '![even(n) : 2 | n ](img/file2113.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![even(n) : 2 | n ](img/file2113.png)'
- en: and
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 并且
- en: '![odd (n ) : 2 ∤ n ](img/file2114.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![odd(n) : 2 ∤ n ](img/file2114.png)'
- en: express the same as Definition [104](ch036.xhtml#x1-364005r104).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表示与定义[104](ch036.xhtml#x1-364005r104)相同。
- en: These examples are not that exciting, so let’s see something more interesting!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子并不太吸引人，所以让我们看看更有趣的内容！
- en: Definition 105\. (Prime numbers)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 105. （质数）
- en: Let p ∈ℕ be a positive integer. We say that p is a prime number if
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 设 p ∈ℕ 是一个正整数。我们说 p 是质数，如果
- en: (a) p/span>1,
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: （a）p/span>1，
- en: (b) and if a∣p, then a = 1 or a = p.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: （b）如果 a∣p，则 a = 1 或 a = p。
- en: In other words, primes have no integer divisors other than themselves. The first
    few primes are 2,3,5,7,11,13,17, and many more. Non-prime integers are called
    composite numbers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，质数除了它们自己之外没有其他整数约数。前几个质数是 2、3、5、7、11、13、17 等等。非质数整数称为合成数。
- en: '![PIC](img/file2115.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file2115.png)'
- en: 'Figure B.1: Definition of primality in predicate logic, decomposed into its
    parts'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.1：谓词逻辑中质数定义的分解
- en: The definition of primality can be written as
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 质数的定义可以写成：
- en: 'P (p) : (p >1)∧ (∀a ∈ ℤ,(a | p → ((a = 1) ∨ (a = p)))).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 'P (p) : (p >1)∧ (∀a ∈ ℤ,(a | p → ((a = 1) ∨ (a = p))))。'
- en: This might look complicated, but we can decompose it into parts, as shown by
    Figure [B.1](#).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能很复杂，但我们可以将其分解成几个部分，如图[B.1](#)所示。
- en: Primes play an essential role in our everyday lives! For instance, many mainstream
    cryptographic methods use large primes to cipher and decipher messages. Without
    them, you wouldn’t be able to initiate financial transactions securely.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 质数在我们日常生活中起着至关重要的作用！例如，许多主流的加密方法使用大质数来加密和解密信息。没有它们，你就无法安全地发起金融交易。
- en: Their usefulness is guaranteed by their various properties, established in the
    form of theorems. We’ll see a few of them soon enough, but first, let’s talk about
    what theorems really are.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的有用性通过它们的各种性质得到保证，这些性质以定理的形式被建立起来。我们很快就会看到其中的一些，但首先，让我们谈谈定理到底是什么。
- en: B.2 What is a theorem?
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.2 什么是定理？
- en: So, a definition is essentially a predicate whose truth set consists of our
    objects of interest. The whole point of mathematics is to find true propositions
    involving those objects, most often in the form A →B. Consider the following theorem.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，定义本质上是一个谓词，它的真值集由我们关心的对象组成。数学的核心就是发现涉及这些对象的真命题，通常以 A → B 的形式。考虑以下定理。
- en: Theorem 144\. (Existence of global minima for convex functions)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 144. （凸函数的全局最小值存在性）
- en: 'Let ![f : [0,1] → ℝ ](img/file2117.png) be a function. If ![f ](img/file2118.png)
    is continuous, then there exists an ![x∗ ](img/file2119.png) such that ![f ](img/file2120.png)
    assumes its minimum at ![x∗ ](img/file2121.png) on ![[0,1] ](img/file2122.png).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '设 ![f : [0,1] → ℝ ](img/file2117.png) 是一个函数。如果 ![f ](img/file2118.png) 是连续的，则存在一个
    ![x∗ ](img/file2119.png)，使得 ![f ](img/file2120.png) 在 ![x∗ ](img/file2121.png)
    处达到最小值，且该点属于区间 ![[0,1] ](img/file2122.png)。'
- en: (That is, for all ![x ∈ [0,1] ](img/file2123.png), we have ![f(x∗) ≤ f(x) ](img/file2124.png).)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: （即，对于所有 ![x ∈ [0,1] ](img/file2123.png)，我们有 ![f(x∗) ≤ f(x)](img/file2124.png)。）
- en: Don’t worry if you are unfamiliar with the concepts of continuity and minimum;
    it’s beside the point. The gist is that Theorem [144](ch036.xhtml#x1-365002r144)
    can be written as
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对连续性和最小值的概念不熟悉，不用担心；这不是重点。关键是，定理[144](ch036.xhtml#x1-365002r144)可以写成：
- en: '![∀f ∈ F,(C (f ) → M (f)), ](img/file2125.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![∀f ∈ F,(C(f) → M(f))](img/file2125.png)'
- en: where F denotes the set of all functions [0,1] →ℝ, and the predicates C(f) and
    M(f) are defined by
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，F 表示所有函数的集合 [0,1] →ℝ，谓词 C(f) 和 M(f) 定义如下：
- en: '![ C (f ) : f is continuous on [0,1], ∗ ∗ M (f ) : ∃x ,∀x ∈ [0,1],f (x ) ≤
    f(x). ](img/file2126.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![ C (f ) : f 在 [0,1] 上是连续的， ∗ ∗ M (f ) : ∃x ,∀x ∈ [0,1],f (x ) ≤ f(x). ](img/file2126.png)'
- en: 'Notice the structure of the theorem: “Let x ∈A. If B(x), then C(x).” With the
    first sentence, we are setting the domains of the predicates A(x) and B(x), and
    putting a universal quantifier in front of the conditional “if B(x), then C(x).”'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意定理的结构：“设 x ∈A。如果 B(x)，则 C(x)。” 在第一句中，我们确定了谓词 A(x) 和 B(x) 的定义域，并且在条件句“如果 B(x)，则
    C(x)”前放置了一个全称量词。
- en: B.3 What is a proof?
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.3 什么是证明？
- en: Now that we understand what theorems are, it’s time to look at proofs. We have
    just seen that theorems are true propositions. Proofs are deductions that establish
    the truth of a proposition. Let’s see an example instead of talking like a philosopher!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了什么是定理，是时候看看证明了。我们刚刚看到，定理是正确的命题。证明是建立命题真理的推理过程。让我们来看一个例子，而不是像哲学家那样讨论！
- en: 'The proof of Theorem [144](ch036.xhtml#x1-365002r144) is not within our reach
    yet, so let’s look at something much simpler: the sum of even numbers.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 定理[144](ch036.xhtml#x1-365002r144)的证明我们还无法完成，因此让我们看看一个更简单的例子：偶数之和。
- en: Theorem 145\. (The sum of even numbers)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 145\. （偶数之和）
- en: Let n,m ∈ℤ be two integers. If n and m are even, then n + m is even.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 设 n,m ∈ℤ 为两个整数。如果 n 和 m 都是偶数，那么 n + m 也是偶数。
- en: Proof. Since n is even, 2∣n. According to Definition [103](ch036.xhtml#x1-364003r103),
    this means that there exists an integer k ∈ℤ such that n = 2k.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。由于 n 是偶数，2∣n。根据定义[103](ch036.xhtml#x1-364003r103)，这意味着存在一个整数 k ∈ℤ，使得 n =
    2k。
- en: Similarly, as m is also even, there exists an integer l ∈ ℤ such that m = 2l.
    Summing up the two, we obtain
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，由于 m 也是偶数，存在一个整数 l ∈ ℤ，使得 m = 2l。将两者相加，我们得到
- en: '![n + m = 2k + 2l = 2(k + l), ](img/file2127.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![n + m = 2k + 2l = 2(k + l), ](img/file2127.png)'
- en: giving that n + m is indeed even.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 n + m 确实是偶数。
- en: If you read the above proof carefully, you might notice that it is a chain of
    implications and modus ponens. These two form the backbone of our deductive skills.
    What is proven is set in stone.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细阅读上面的证明，你可能会注意到它是一系列的蕴含和模态推理。正是这两者构成了我们推理技能的支柱。所证明的结论已经铁定。
- en: Understanding what proofs are is one of the biggest skill gaps in mathematics.
    Don’t worry if you don’t get it immediately; this is a deep concept. You’ll get
    used to proofs eventually.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 理解什么是证明是数学中最大的技能差距之一。如果你没有马上理解，别担心；这是一个深奥的概念。你最终会习惯证明的。
- en: B.4 Equivalences
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.4 等价命题
- en: The building blocks of mathematics are propositions of the form A →B; at least,
    this is what I emphasized throughout this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 数学的基本构建块是形式为 A →B 的命题；至少，这是我在本章中强调的内容。
- en: I was not precise. The proposition A →B translates to “if A, then B,” but sometimes,
    we know much more. Quite frequently, A and B have the same truth values. In natural
    language, we express this by saying “A if and only if B.” (Although this is much
    rarer than the simple conditional.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有说得很准确。命题 A →B 翻译为“如果 A，那么 B”，但有时，我们知道得更多。通常，A 和 B 具有相同的真值。在自然语言中，我们通过说“当且仅当
    B 时 A”来表达这一点。（尽管这种情况比简单的条件句要少得多。）
- en: In logic, we express this relation with the biconditional connective ↔︎, defined
    by
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑中，我们用双条件连接词 ↔︎ 来表示这种关系，其定义为
- en: '![A ↔ B ≡ (A → B) ∧ (B → A ). ](img/file2128.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![A ↔ B ≡ (A → B) ∧ (B → A ). ](img/file2128.png)'
- en: Theorems of the “if and only if” type are called equivalences, and they play
    an essential role in mathematics. When proving an equivalence, we must show both
    A →B and B →A.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: “当且仅当”类型的定理称为等价命题，它们在数学中起着至关重要的作用。在证明等价命题时，我们必须同时证明 A →B 和 B →A。
- en: To see an example, let’s go back to elementary geometry. As you probably learned
    in high school, we can describe geometric objects on the plane with vectors that
    are represented by a tuple of two real numbers. This way, geometric properties
    can be translated into analytic ones, and we can often prove hard theorems by
    simple calculations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到一个例子，让我们回到初等几何学。正如你可能在高中学到的那样，我们可以用由两个实数构成的元组来描述平面上的几何对象。通过这种方式，几何性质可以转化为分析性质，并且我们通常可以通过简单的计算证明困难的定理。
- en: For instance, let’s talk about orthogonality, one of the most important concepts
    in mathematics. Here is how orthogonality is defined for two planar vectors.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们讨论正交性，这是数学中最重要的概念之一。这里是平面上两个向量的正交性定义。
- en: Definition 106\. (Orthogonality)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 106\. （正交性）
- en: Let a and b be two nonzero vectors on the plane. We say that a and b are orthogonal
    if their enclosed angle is π∕2.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 设 a 和 b 是平面上的两个非零向量。如果它们夹角为 π∕2，则称 a 和 b 互相正交。
- en: Orthogonality is denoted by the ⊥ symbol; that is, a ⊥b means that a and b are
    orthogonal.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正交性用 ⊥ 符号表示；也就是说，a ⊥ b 意味着 a 和 b 是正交的。
- en: For the sake of simplicity, we always assume that the enclosed angle is between
    0 and π. (An angle of π radians is 180 degrees, but we’ll always use radians.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便起见，我们总是假设夹角在 0 和 π 之间。（π 弧度等于 180 度，但我们总是使用弧度。）
- en: However, measuring the angle enclosed by two arbitrary vectors is not as easy
    as it sounds. We need a tractable formula, and this is where the dot product comes
    in.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测量两个任意向量之间的夹角并不像听起来那么简单。我们需要一个可操作的公式，这就是点积的用武之地。
- en: Definition 107\. (Dot product of planar vectors)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 107\. （平面向量的点积）
- en: Let a = (a[1],a[2]) and b = (b[1],b[2]) be two vectors on the plane. Their dot
    product a ⋅b is defined by
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 设 a = (a[1], a[2]) 和 b = (b[1], b[2]) 是平面上的两个向量。它们的点积 a ⋅ b 定义为
- en: '![a ⋅b := |a||b|cosα, ](img/file2129.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![a ⋅ b := |a||b|cosα, ](img/file2129.png)'
- en: where α is the angle enclosed by the two vectors, and |⋅| denotes the magnitude
    of a vector.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，α 是两个向量之间的夹角，|⋅| 表示向量的大小。
- en: Dot products give an equivalent definition of orthogonality in the form of an
    “if and only if” theorem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 点积提供了一个关于正交性的等价定义，以“当且仅当”定理的形式表达。
- en: Theorem 146\.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 146\。
- en: Let a = (a[1],a[2]) and b = (b[1],b[2]) be two nonzero vectors in the plane.
    Then, a and b are orthogonal if and only if a ⋅b = 0.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 设 a = (a[1], a[2]) 和 b = (b[1], b[2]) 是平面上的两个非零向量。那么，当且仅当 a ⋅ b = 0 时，a 和 b
    是正交的。
- en: Let’s see the proof of this equivalence!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个等价关系的证明！
- en: 'Proof. We have to prove two implications:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。我们需要证明两个命题：
- en: (a) a ⊥b ⇒a ⋅b = 0,
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: (a) a ⊥ b ⇒ a ⋅ b = 0，
- en: (b) a ⋅b = 0 ⇒a ⊥b.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: (b) a ⋅ b = 0 ⇒ a ⊥ b。
- en: Let’s start with (a). If a ⊥ b, then their enclosed angle α equals to π∕2\.
    Thus,
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 (a) 开始。如果 a ⊥ b，那么它们之间的夹角 α 等于 π∕2。于是，
- en: '![ π- a⋅b = |a||b |cos2 = |a||b |0 = 0, ](img/file2132.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![ π- a⋅b = |a||b |cos2 = |a||b |0 = 0, ](img/file2132.png)'
- en: which is what we needed to show.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们需要展示的内容。
- en: To prove (b), we have to notice that since a and b are nonzero, their magnitudes
    jaj, jbj are also nonzero. Thus,
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明 (b)，我们必须注意到，由于 a 和 b 都是非零向量，它们的大小 |a|、|b| 也都是非零的。因此，
- en: '![a ⋅b = |a ||b|cosα = 0 ](img/file2133.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![a ⋅ b = |a ||b|cosα = 0 ](img/file2133.png)'
- en: can only hold if cosα = 0\. In turn, this means that α = π∕2; that is, a ⊥b.
    (Recall that we assumed the enclosed angle α to be between 0 and π.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 cosα = 0 时，这个式子才成立。反过来，这意味着 α = π∕2；也就是说，a ⊥ b。（回想一下，我们假设夹角 α 在 0 和 π 之间。）
- en: So, we know all about what theorems and proofs are. But how do we find proofs
    in practice? Let’s see the essential techniques.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经知道了关于定理和证明的一切。那么，如何在实际中找到证明呢？让我们来看看基本的技巧。
- en: B.5 Proof techniques
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.5 证明技巧
- en: 'There is no way around it: proving theorems is hard. Some took the smartest
    of minds decades, and some conjectures remain unresolved after a century. (That
    is, they are not proven nor disproven.)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有捷径可走：证明定理是困难的。有些最聪明的人花了几十年，有些猜想在一个世纪后仍未解决。（也就是说，它们既未被证明也未被反驳。）
- en: 'A few basic yet powerful tools can get one push through the difficulties. In
    the following, we’ll look at the three most important ones: proof by induction,
    proof by contradiction, and the principle of contraposition.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基本而强大的工具可以帮助人们克服困难。接下来，我们将看看三种最重要的工具：数学归纳法、反证法和对立命题原则。
- en: B.5.1 Proof by induction
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5.1 数学归纳法证明
- en: How do you climb a set of stairs? Simple. You climb the first step, then climb
    the next one, and so on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何爬一段楼梯？很简单。你先爬第一步，然后爬下一步，依此类推。
- en: You might be surprised, but this is something we frequently use in mathematics
    all the time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会感到惊讶，但这正是我们在数学中经常使用的东西。
- en: Let’s illuminate this by an example.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来阐明这一点。
- en: Theorem 147\. (Sum of natural numbers)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 147\. （自然数之和）
- en: Let n ∈ℕ be an arbitrary integer. Then,
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 设 n ∈ℕ 为任意整数。那么，
- en: 1 + 2 + ⋯ + *n* = *n*(*n* + 1) 2 (B.2)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 1 + 2 + ⋯ + *n* = *n*(*n* + 1) 2 (B.2)
- en: holds.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 成立。
- en: 'Proof. For ![n = 1 ](img/file2136.png), the case is clear: the left-hand side
    of ([B.2](ch036.xhtml#x1-369002r147)) evaluates to 1, while the right-hand side
    is'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。对于 ![n = 1 ](img/file2136.png)，情况很明确：([B.2](ch036.xhtml#x1-369002r147)) 的左侧计算结果为
    1，而右侧是
- en: '![1(1-+-1) 2 = 1\. ](img/file2138.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![1(1-+-1) 2 = 1\. ](img/file2138.png)'
- en: Thus, our proposition holds for n = 1, which is called the base case.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的命题对于 n = 1 成立，这叫做基本情况。
- en: Here comes the magic, that is, the induction step. Let’s assume that ([B.2](ch036.xhtml#x1-369002r147))
    holds for a given n; that is, we have
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是关键步骤，即归纳步骤。我们假设 ([B.2](ch036.xhtml#x1-369002r147)) 对给定的 n 成立；也就是说，我们有
- en: '![1+ 2 + ⋅⋅⋅+ n = n(n-+-1). 2 ](img/file2139.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![1+ 2 + ⋅⋅⋅+ n = n(n-+-1). 2 ](img/file2139.png)'
- en: This is what’s called the induction hypothesis. Using this assumption, we are
    going to prove that ([B.2](ch036.xhtml#x1-369002r147)) holds for n+1 as well.
    In other words, our goal is to show that
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的归纳假设。使用这个假设，我们将证明 ([B.2](ch036.xhtml#x1-369002r147)) 对 n+1 也成立。换句话说，我们的目标是证明：
- en: '![ (n-+-1)(n-+-2) 1+ 2 + ⋅⋅⋅+ n+ (n + 1) = 2 . ](img/file2140.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![ (n-+-1)(n-+-2) 1+ 2 + ⋅⋅⋅+ n+ (n + 1) = 2 . ](img/file2140.png)'
- en: Due to our induction hypothesis, we have
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的归纳假设，我们有：
- en: '![ [ ] 1 + 2+ ⋅⋅⋅+ n + (n + 1) = 1+ 2 + ⋅⋅⋅+ n + (n + 1) n(n + 1) = --------+
    (n + 1). 2 ](img/file2141.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![ [ ] 1 + 2+ ⋅⋅⋅+ n + (n + 1) = 1+ 2 + ⋅⋅⋅+ n + (n + 1) n(n + 1) = --------+
    (n + 1). 2 ](img/file2141.png)'
- en: Continuing the calculation, we obtain
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 继续计算，我们得到：
- en: '![n(n + 1) n(n + 1) 2(n+ 1) --------+ (n + 1) = --------+ -------- 2 2 2 =
    n(n-+-1)+-2(n-+-1) 2 = (n-+-1)(n-+-2), 2 ](img/file2142.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![n(n + 1) n(n + 1) 2(n+ 1) --------+ (n + 1) = --------+ -------- 2 2 2 =
    n(n-+-1)+-2(n-+-1) 2 = (n-+-1)(n-+-2), 2 ](img/file2142.png)'
- en: which is what we had to show.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要证明的。
- en: To sum up what happened, let’s denote the equation ([B.2](ch036.xhtml#x1-369002r147))
    by the predicate
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下发生了什么，我们用谓词来表示方程 ([B.2](ch036.xhtml#x1-369002r147))：
- en: '![S(n) : 1+ 2 + ⋅⋅⋅+ n = n(n-+-1). 2 ](img/file2143.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![S(n) : 1+ 2 + ⋅⋅⋅+ n = n(n-+-1). 2 ](img/file2143.png)'
- en: 'Proof by induction consists of two main steps. First, we establish that the
    base case S(1) is true. Then, we show that for arbitrary n, the implication S(n)
    →S(n + 1) holds. Starting from the induction step, this implies that S(n) is indeed
    true for all n: the chain of implications'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳证明分为两个主要步骤。首先，我们证明基本情况 S(1) 是成立的。然后，我们证明对于任意 n，蕴含式 S(n) → S(n + 1) 成立。从归纳步骤出发，这意味着
    S(n) 对所有 n 都成立：这一系列的蕴含
- en: '![S (1) → S (2), S (2) → S (3), S (3) → S (4), ... ](img/file2144.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![S (1) → S (2), S (2) → S (3), S (3) → S (4), ... ](img/file2144.png)'
- en: combined with S(1) and the almighty modus ponens (Theorem [143](ch035.xhtml#x1-358009r143))
    yields the truth of S(n). We took the first step S(1), then proved that we can
    take the next step from anywhere.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 结合 S(1) 和强大的模态推理（定理 [143](ch035.xhtml#x1-358009r143)）得出 S(n) 为真。我们首先完成了第一步 S(1)，然后证明我们可以从任意位置进行下一步。
- en: Induction is not simple to grasp, so here is another example. (It is slightly
    more complex than the previous one.) Follow through with the proof and see if
    you can identify the marks of induction.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳法并不容易理解，因此这里提供另一个例子。（它比之前的稍微复杂一些。）跟随证明过程，看看你是否能识别出归纳法的痕迹。
- en: Theorem 148\. (The fundamental theorem of number theory)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 148.（数论的基本定理）
- en: Let n ∈ℤ be an integer and suppose that n/span>1\. Then, n can be uniquely represented
    as the product of prime numbers; that is, there exists prime numbers p[1],p[2],…,p[l]
    and exponents k[1],k[2],…,k[l]/span>1 such that
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 设 n ∈ ℤ 是一个整数，并假设 n > 1。那么，n 可以唯一地表示为素数的乘积；即，存在素数 p[1], p[2], ..., p[l] 和指数
    k[1], k[2], ..., k[l]，使得：
- en: '*n* = *p*[1]^(*k*[1]) *p*[2]^(*k*[2]) ⋯ *p*[*l*]^(*k*[*l*]). (B.3)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* = *p*[1]^(*k*[1]) *p*[2]^(*k*[2]) ⋯ *p*[*l*]^(*k*[*l*])。（B.3）'
- en: Furthermore, this representation is unique.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个表示是唯一的。
- en: For example, 24 = 2³3, and 24 cannot be written as a different product of primes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，24 = 2³3，且 24 不能写成其他素数的乘积。
- en: The presence of natural language masks it, but in essence, Theorem [148](ch036.xhtml#x1-369007r148)
    can be translated to the sentence
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 自然语言的表达掩盖了它的本质，但事实上，定理 [148](ch036.xhtml#x1-369007r148) 可以转化为以下句子：
- en: '![ [ k1 k2 kl ] ∀n ∈ ℤ (n >1) → (∃p1,...,pl,k1,...,kl ∈ ℤ,(∀i,pi is a prime
    )∧(n = p1 p2 ...pl )) . ](img/file2145.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![ [ k1 k2 kl ] ∀n ∈ ℤ (n >1) → (∃p1,...,pl,k1,...,kl ∈ ℤ,(∀i,pi 是素数 )∧(n =
    p1 p2 ...pl )) . ](img/file2145.png)'
- en: For simplicity, we’ll only prove the existence of the prime factorization, not
    the unicity.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们只证明素因数分解的存在性，而不证明唯一性。
- en: Proof. (Existence.) For n = 2, the theorem is trivially true, as 2 is a prime
    itself.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。（存在性）对于 n = 2，定理显然成立，因为 2 本身就是一个素数。
- en: Now, let n/span>2 and suppose that ([B.3](ch036.xhtml#x1-369007r148)) is true
    for all integers m that are smaller or equal to n. (This is our induction hypothesis.)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，设 n > 2，并假设 ([B.3](ch036.xhtml#x1-369007r148)) 对所有小于或等于 n 的整数 m 都成立。（这是我们的归纳假设。）
- en: Our goal is to show that ([B.3](ch036.xhtml#x1-369007r148)) also holds for n
    + 1.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是证明 ([B.3](ch036.xhtml#x1-369007r148)) 对 n + 1 也成立。
- en: 'There are two possibilities: either n + 1 is a prime or a composite number.
    If it is a prime, we are done, as n + 1 is by itself in the form ([B.3](ch036.xhtml#x1-369007r148)).
    Otherwise, if n + 1 is a composite number, we can find a divisor that is not 1
    or n + 1:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种可能性：要么 n + 1 是一个素数，要么是一个合成数。如果它是素数，那么我们已经完成了，因为 n + 1 本身就是 ([B.3](ch036.xhtml#x1-369007r148))
    的形式。否则，如果 n + 1 是一个合成数，我们可以找到一个不是 1 或 n + 1 的约数：
- en: '![n + 1 = ab ](img/file2146.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![n + 1 = ab ](img/file2146.png)'
- en: for some a,b ∈ ℤ. Since a,b ≤ n, we can apply the induction hypothesis! Spelling
    it out, it means that we can write them as
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些 a,b ∈ ℤ。由于 a,b ≤ n，我们可以应用归纳假设！展开来说，这意味着我们可以把它们写成
- en: '![a = pα1...pαl, 1 l b = qβ11...qβmm, ](img/file2147.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![a = pα1...pαl, 1 l b = qβ11...qβmm, ](img/file2147.png)'
- en: where the p[i],q[i] are the primes and the α[i],β[i] are the exponents. Thus,
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 p[i],q[i] 是质数，α[i],β[i] 是指数。因此，
- en: '![n + 1 = ab α α β = p11...pll q11 ...qβmm , ](img/file2148.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![n + 1 = ab α α β = p11...pll q11 ...qβmm , ](img/file2148.png)'
- en: which is just ([B.3](ch036.xhtml#x1-369007r148)), with a bit more symbols.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是([B.3](ch036.xhtml#x1-369007r148))，不过符号多了一些。
- en: Induction is like a power tool in mathematics. It is extremely powerful, and
    when it is applicable, it’ll almost always do the job.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 数学中的归纳法就像是一把电动工具。它非常强大，只要适用，几乎总能完成任务。
- en: B.5.2 Proof by contradiction
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5.2 反证法证明
- en: Sometimes, it is easier to prove theorems by assuming that their conclusion
    is false, then deduce a contradiction.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，通过假设结论为假，然后推导出矛盾，证明定理会更容易。
- en: Again, it’s best to see a quick example. Let’s revisit our good old friends,
    the prime numbers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，最好看一个快速的例子。让我们重新回顾一下我们亲爱的老朋友——质数。
- en: Theorem 149\.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 149\。
- en: There are infinitely many prime numbers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有无限多个质数。
- en: 'Proof. Assume that there are finitely many prime numbers: p[1],p[2],…,p[n].'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。假设质数是有限个：p[1],p[2],…,p[n]。
- en: Is the integer p[1]p[2]…p[n] + 1 a prime? If p[1],p[2],…,p[n] are all of the
    prime numbers, it is enough to check if
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 整数 p[1]p[2]…p[n] + 1 是质数吗？如果 p[1],p[2],…,p[n] 是所有质数，那么只需检查是否
- en: '![pi ∤ p1p2...pn + 1\. ](img/file2149.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![pi ∤ p1p2...pn + 1\. ](img/file2149.png)'
- en: This holds indeed, as by definition, p[1]p[2]…p[n] + 1 = p[i]k + 1, where k
    is simply the product of the prime numbers other than p[i].
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实成立，因为根据定义，p[1]p[2]…p[n] + 1 = p[i]k + 1，其中 k 只是除 p[i] 之外的质数的乘积。
- en: Since no p[i] is a divisor of p[1]p[2]…p[n] + 1, it must be a prime. We have
    found a new prime that is not on our list! This means that our assumption (that
    there are finitely many prime numbers) has led to a contradiction.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有 p[i] 是 p[1]p[2]…p[n] + 1 的约数，它必须是一个质数。我们发现了一个新的质数，它不在我们的列表中！这意味着我们的假设（即质数是有限个）导致了矛盾。
- en: Thus, there must be infinitely many prime numbers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，质数必须是无限多个。
- en: 'If you have a sharp eye, you probably noticed that the above example is not
    of the form A →B; it’s just a simple proposition:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你眼光敏锐，你可能已经注意到，上面的例子并不是 A →B 的形式；它只是一个简单的命题：
- en: '![A = ”there are in finitely many prime numbers.” ](img/file2150.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![A = ”有无限多个质数。” ](img/file2150.png)'
- en: In these cases, showing that ¬A is false yields the desired conclusion. However,
    this technique works for A →B -style propositions as well. (By the way, the existence
    part of Theorem [148](ch036.xhtml#x1-369007r148) can also be shown via contradiction;
    I’ll leave this for you as an exercise.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，证明 ¬A 为假会得到所需的结论。然而，这种技巧对于 A →B 风格的命题同样适用。（顺便说一句，定理 [148](ch036.xhtml#x1-369007r148)
    的存在部分也可以通过反证法证明；我将这个留给你作为练习。）
- en: B.5.3 Contraposition
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5.3 逆命题
- en: The final technique we will study is contraposition, a clever method that puts
    a twist into the classic A →B-style thinking.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要学习的最后一个技巧是逆命题，这是一个巧妙的方法，它给经典的 A →B 风格的思维方式带来了变化。
- en: We should get to know the implication connective a bit better to see what it
    is. As it turns out, A →B can be written in terms of negation and disjunction.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该更好地了解蕴含连接词，看看它是什么。事实证明，A →B 可以通过否定和析取来表示。
- en: Theorem 150\.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 150\。
- en: Let A and B two propositions. Then,
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 设 A 和 B 为两个命题。那么，
- en: '![A → B ≡ ¬A ∨ B. ](img/file2151.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![A → B ≡ ¬A ∨ B. ](img/file2151.png)'
- en: Proof. The truth table
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。真值表
- en: '![| | | | | |A |B |¬A |¬A ∨ B | |--|---|----|--------| |0 |0 | 1 | 1 | | |
    | | | |0 |1 | 1 | 1 | |1 |0 | 0 | 0 | | | | | | |1 |1 | 0 | 1 | | | ](img/file2152.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![| | | | | |A |B |¬A |¬A ∨ B | |--|---|----|--------| |0 |0 | 1 | 1 | | |
    | | | |0 |1 | 1 | 1 | |1 |0 | 0 | 0 | | | | | | |1 |1 | 0 | 1 | | | ](img/file2152.png)'
- en: provides a proof.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一个证明。
- en: Why is this relevant? Simple. Take a look at the following corollary.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这与我们有关呢？很简单。看一下以下的推论。
- en: Corollary 4\. (Principle of contraposition)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 推论 4\。 （逆命题原理）
- en: Let A and B be two propositions. Then,
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 设 A 和 B 为两个命题。那么，
- en: '![A → B ≡ ¬B → ¬A. ](img/file2153.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![A → B ≡ ¬B → ¬A. ](img/file2153.png)'
- en: Proof. Theorem [150](ch036.xhtml#x1-371003r150) implies that
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。定理 [150](ch036.xhtml#x1-371003r150) 说明
- en: '![A → B ≡ ¬A ∨ B ≡ B ∨ ¬A ≡ ¬B → ¬A, ](img/file2154.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![A → B ≡ ¬A ∨ B ≡ B ∨ ¬A ≡ ¬B → ¬A, ](img/file2154.png)'
- en: which is what we had to prove.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要证明的内容。
- en: Here is a simple proposition about integers to give you a mathematical example.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的整数命题，给你一个数学例子。
- en: Theorem 151\.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 151\。
- en: Let ![n ∈ ℤ ](img/file2155.png) be an integer. If ![2 ∤ n ](img/file2156.png),
    then ![4 ∤ n ](img/file2157.png).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让![n ∈ ℤ ](img/file2155.png)表示一个整数。如果![2 ∤ n ](img/file2156.png)，则![4 ∤ n ](img/file2157.png)。
- en: Proof. We should prove this via contraposition. Thus, assume that 4∣n. This
    means that
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。我们应该通过对立命题来证明这一点。因此，假设4∣n。这意味着
- en: '![n = 4k ](img/file2158.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![n = 4k ](img/file2158.png)'
- en: for some integer k ∈ℤ. However, this implies that
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某个整数k ∈ℤ。然而，这意味着
- en: '![n = 2(2k), ](img/file2159.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![n = 2(2k), ](img/file2159.png)'
- en: which shows that 2∣n. Due to the principle of contraposition, (4∣n) → (2∣n)
    is logically equivalent to (2 ∤ n) → (4 ∤ n), which is what we had to prove.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明2∣n。由于对立命题的原理，（4∣n）→（2∣n）与（2∤ n）→（4∤ n）在逻辑上是等价的，这就是我们需要证明的内容。
- en: 'Contraposition is not only useful in mathematics, it is a valuable thinking
    tool in general. Let’s consider our recurring proposition: “if it is raining outside,
    then the sidewalk is wet.” We know this to be true, but this also means that “if
    the sidewalk is not wet, then it is not raining” (because, otherwise, the sidewalk
    would be wet).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对立命题不仅在数学中有用，它还是一种非常有价值的思维工具。我们来考虑一个反复出现的命题：“如果外面下雨，那么人行道是湿的。”我们知道这是对的，但这也意味着“如果人行道不湿，那么外面就没有下雨”（因为如果下雨的话，人行道应该是湿的）。
- en: You perform these types of arguments every day without even noticing it. Now
    you have a name for them and can start to apply this pattern consciously.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你每天都会不自觉地进行这类推理。现在你有了一个名字，可以开始有意识地应用这个模式了。
- en: Join our community on Discord
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、机器学习专家和作者本人一起阅读这本书。提出问题，为其他读者提供解决方案，通过“问我任何问题”环节与作者交流，还有更多内容。扫描二维码或访问链接加入社区。[https://packt.link/math](https://packt.link/math)
- en: '![PIC](img/file1.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
