- en: '*Chapter 11*: URLs and Multi-Page Apps'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：URL 和多页面应用'
- en: So far, we have been building everything on one page. We kept adding new charts
    and interactive components to a single div and incorporated them as we saw fit.
    Adding new URLs can be useful for space-saving purposes, so that we don't end
    up having too many components on a single page. URLs also serve as a tool for
    classifying content and providing context, so users know "where" they are and
    what they are doing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在一个页面上构建所有内容。我们不断将新的图表和交互组件添加到一个 div 中，并根据需要将其整合。添加新的 URL 有助于节省空间，以免在一个页面上放置过多的组件。URL
    还可以作为分类内容和提供上下文的工具，让用户知道他们“在哪里”，以及他们在做什么。
- en: Even more interesting is the ability to programmatically generate many additional
    pages to your app, simply by displaying content based on the URL (or any part
    of it). This is what we will do in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，能够通过编程生成应用程序的许多附加页面，只需根据 URL（或其任何部分）显示内容。这正是我们在本章中要做的。
- en: Once we get to know how the **Location** and **Link** components work, we will
    then make a slight change to the structure of the app, by making and isolating
    new layouts. Then, it will be clear how easy it is to make a multi-page app. We
    will have a general layout with an empty area in the middle, and using a simple
    rule, content will be displayed based on the URL.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了 **Location** 和 **Link** 组件的工作原理，我们将对应用程序的结构进行一些小的改动，创建并隔离新的布局。这样，我们就能清楚地看到，制作一个多页面应用是多么简单。我们将有一个通用布局，中间有一个空白区域，使用一个简单的规则，内容将根据
    URL 显示。
- en: All the functionality we have built was mainly based on indicators. We created
    many charts for those indicators, showing how they vary in time and across countries.
    Our users might also be interested in country-oriented reports. So, we will create
    a page for each country, where users can check whichever indicator they want for
    the country of interest and optionally compare with other countries. With a few
    simple changes, we will add 169 new pages to our app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的所有功能主要基于指标。我们为这些指标创建了许多图表，展示了它们在时间和各国之间的变化。我们的用户也可能对面向特定国家的报告感兴趣。因此，我们将为每个国家创建一个页面，用户可以查看感兴趣国家的任何指标，并可以选择与其他国家进行比较。通过一些简单的更改，我们将为应用程序添加
    169 个新页面。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Getting to know the `Location` and `Link` components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 `Location` 和 `Link` 组件
- en: Extracting and using attributes of URLs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取和使用 URL 的属性
- en: Parsing URLs and using their components to modify parts of the app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析 URL 并使用其组件来修改应用程序的部分内容
- en: Restructuring your app to cater to multiple layouts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新构建应用程序以适应多个布局
- en: Adding dynamically generated URLs to the app
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将动态生成的 URL 添加到应用程序中
- en: Incorporating the new URL interactivity into the app
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新的 URL 交互功能融入到应用程序中
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the new components that we will introduce, we will still be using the same
    tools. Dash, Dash Core Components, Dash HTML Components, and Dash Bootstrap Components
    will be used to build our new functionality and add it to our app. We will also
    be using pandas for data manipulation, JupyterLab and `jupyter_dash` for experimenting
    with isolated functionality, and Plotly and Plotly Express for data visualization.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们将引入的新组件，我们仍然会使用相同的工具。Dash、Dash Core Components、Dash HTML Components 和 Dash
    Bootstrap Components 将用于构建我们的新功能并将其添加到我们的应用程序中。我们还将使用 pandas 进行数据处理，使用 JupyterLab
    和 `jupyter_dash` 来尝试隔离功能，并使用 Plotly 和 Plotly Express 进行数据可视化。
- en: The main topic of this chapter will be manipulating parts of the URLs and using
    them as inputs to modify other components. This is the same as using any other
    element of our app to create the functionality that we want. Let's start by getting
    to know the two components that make this possible.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要内容将是操作 URL 的各个部分，并将其作为输入来修改其他组件。这与使用我们应用程序的任何其他元素来创建我们所需的功能是一样的。让我们从了解这两个使其成为可能的组件开始。
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_11](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_11).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：[https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_11](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_11)。
- en: Check out the following video to see the Code in Action at [https://bit.ly/3eks3GI](https://bit.ly/3eks3GI).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下视频，查看代码的实际应用：[https://bit.ly/3eks3GI](https://bit.ly/3eks3GI)。
- en: Getting to know the Location and Link components
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解`Location`和`Link`组件：
- en: 'These components are part of Dash Core Components, and their names make quite
    clear what they are and what they might do. The `Location` component refers to
    the browser''s location bar. It is also referred to as the address bar or the
    URL bar. We typically place a `Location` component in the app, and it doesn''t
    produce anything visible. We mainly use it to discover where we are in the app,
    and based on that, we induce some functionality. Let''s create a simple example
    to see how it can be used in its simplest form:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件是Dash Core Components的一部分，它们的名称已经非常清晰地表明了它们的功能。`Location`组件指的是浏览器的位置栏，也称为地址栏或URL栏。我们通常在应用中放置一个`Location`组件，它本身不会产生任何可见的内容。我们主要用它来发现我们在应用中的位置，基于这个信息，我们可以引入一些功能。让我们创建一个简单的示例，看看它如何在最简单的形式下使用：
- en: 'Create a simple app:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的应用：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a simple layout for the app containing a `Location` component and, right
    underneath it, an empty `div`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的布局，其中包含一个`Location`组件，并在其下方放置一个空的`div`：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a callback function that takes the `href` attribute of the `Location`
    component and prints it to the empty div:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个回调函数，获取`Location`组件的`href`属性，并将其打印到空的`div`中：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the app and observe its output:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用并观察其输出：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It's quite straightforward and clear. We simply ask the `Location` component
    to tell us where it is, and we display it in the empty div. In this example, we
    asked for the `href` attribute, and we got the full URL of the current page. For
    various reasons, we might be interested in other attributes, for more nuanced
    functionality. Let's build another simple app to extract the other available attributes
    of the `Location` component and get to know how to use the `Link` component as
    well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常直接明了。我们只需请求`Location`组件告诉我们当前位置，并将其显示在空的`div`中。在这个例子中，我们请求了`href`属性，获得了当前页面的完整URL。出于各种原因，我们可能对其他属性感兴趣，以实现更细致的功能。让我们再构建一个简单的应用，提取`Location`组件的其他可用属性，并了解如何使用`Link`组件。
- en: Getting to know the Link component
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解`Link`组件：
- en: As the name suggests, this component produces links. Another way of creating
    links is by using the HTML `<a>` tag, which is available in the Dash HTML Components
    package. While `<a>` is more suitable for external links, `Link` is better suited
    for internal ones. A nice advantage is that it simply changes the pathname attribute
    and does so without refreshing the page. So, it is fast and responsive, just like
    changing the value in any other interactive component.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，这个组件用于生成链接。另一种创建链接的方式是使用HTML的`<a>`标签，这个标签在Dash HTML Components包中可用。虽然`<a>`标签更适合外部链接，但`Link`组件更适合内部链接。一个很好的优点是它仅仅改变`pathname`属性，而且是在不刷新页面的情况下进行的。所以它快速且响应迅速，就像在其他交互式组件中更改值一样。
- en: 'In the update to our simple app, we will add an `<a>` link, as well as a few
    `Link` component links, so you can experience the difference in refreshing and
    also get to know both types of link. Our `Location` component will now get the
    location of the current page, but we will also use it to extract all the available
    attributes and discuss some ideas about how they might be used. Let''s create
    the elements that will go into our app''s layout:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新的简单应用中，我们将添加一个`<a>`链接，以及几个`Link`组件链接，这样你就可以体验刷新时的不同效果，并了解两种链接的不同。我们的`Location`组件现在将获取当前页面的位置，同时我们还将用它来提取所有可用的属性，并讨论它们可能的使用方式。让我们创建一些元素来构建我们应用的布局：
- en: 'Add a `Location` component:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Location`组件：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add an `<a>` component through Dash HTML Components, pointing to an internal
    page using a relative path:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Dash HTML Components添加一个`<a>`组件，指向一个使用相对路径的内部页面：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add a `Link` component pointing to a page with a search attribute (query parameters):'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个指向带有查询参数（search attribute）的页面的`Link`组件：
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add another `Link` component pointing to a page with a hash, which is also
    known as a fragment:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个指向带有哈希值的页面的`Link`组件，也叫做片段：
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add an empty div where the output will be displayed:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个空的`div`来显示输出：
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is similar to the previous app, as you can see; we only added a few links.
    These will be displayed as regular links on the page. We will now extract and
    display the parts that we are interested in, using a new callback function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的应用类似，正如你所看到的；我们只添加了几个链接。它们将作为普通的链接显示在页面上。接下来，我们将提取并显示我们感兴趣的部分，使用一个新的回调函数：
- en: 'Create the decorator of the function, adding a separate `Input` element for
    each attribute of the `Location` component. As you will see, the location is the
    full URL, but each part gets automatically extracted for us depending on what
    we specify:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建函数的装饰器，为 `Location` 组件的每个属性添加一个单独的 `Input` 元素。正如你将看到的，位置是完整的 URL，但根据我们指定的内容，每个部分都会自动提取：
- en: '[PRE9]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create the signature of the callback function, taking each of the `Location`
    component''s attributes as `Input` elements. Note that we append an underscore
    to the `hash` argument, to make it clear that we are not using the built-in Python
    function of the same name:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建回调函数的签名，将每个 `Location` 组件的属性作为 `Input` 元素传递。请注意，我们在 `hash` 参数后加上下划线，以明确表示我们没有使用同名的内置
    Python 函数：
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Return the different attributes of the URL we are in, in the empty div:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空 div 中返回我们所在的 URL 的不同属性：
- en: '[PRE11]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running the preceding code and clicking on the links we have created shows
    different URL attributes shown in the div, as you can see in *Figure 11.1*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码并点击我们创建的链接，可以在 div 中显示不同的 URL 属性，如*图 11.1*所示：
- en: '![Figure 11.1 – The Location component showing various URL parts for different
    URLs](img/B16780_11_1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – Location 组件显示不同 URL 的各个部分](img/B16780_11_1.jpg)'
- en: Figure 11.1 – The Location component showing various URL parts for different
    URLs
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – Location 组件显示不同 URL 的各个部分
- en: 'As you can see, we have used the `Link` component to change the URL and used
    `Location` to extract whichever attribute we wanted. You can easily see how this
    might be used in other types of callback functions that do more than just display
    those attributes. Let''s take a look at how we can parse and extract query parameters
    and their values using Python''s `parse_qs` (parse query string) function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用 `Link` 组件来更改 URL，并使用 `Location` 提取我们想要的属性。你可以很容易地看到，这在其他类型的回调函数中如何使用，这些回调函数不仅仅是显示这些属性。让我们看看如何使用
    Python 的 `parse_qs`（解析查询字符串）函数来解析和提取查询参数及其值：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now do whatever we want with those values. A more practical application,
    taking our dataset as an example, is that you can create specific and shareable
    URLs, where users can share a specific chart with a certain set of options, simply
    by providing a URL for it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以随意处理这些值。一个更实际的应用，以我们的数据集为例，是你可以创建特定的可共享 URL，用户可以通过提供 URL 来共享特定的图表及其选项：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once you get a country name, a year, and an indicator, you can easily take this
    as an input to a callback function and produce the desired chart based on those
    selections. You can also imagine making it easier for your users, where the selections
    they make in the interactive components change the `Location` component, making
    it very easy to share those URLs. The great thing about this, as mentioned already,
    is that it works without refreshing the page, so it won't slow down the process
    in any way.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你得到国家名称、年份和指标，你可以轻松地将其作为输入传递给回调函数，并根据这些选择生成所需的图表。你还可以想象，简化用户操作，使得他们在交互式组件中的选择会改变
    `Location` 组件，从而轻松分享这些 URL。正如已经提到的，最棒的是，这个过程在不刷新页面的情况下工作，因此不会拖慢流程。
- en: Let's see how this works in a practical application, using our dataset.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个在实际应用中如何工作，使用我们的数据集。
- en: Parsing URLs and using their components to modify parts of the app
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析 URL 并使用其组件来修改应用的部分内容
- en: Having established some working knowledge about how `Location` and `Link` components
    work, we want to use this in our app. The plan is to add 169 new pages using three
    callbacks and adding a few new layout elements. The user will have a drop-down
    menu of countries to choose from. Selecting a country modifies the URL, which
    will render the country layout. This layout will include a heading, a chart, and
    a table about the country in the URL.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了关于 `Location` 和 `Link` 组件如何工作的基础知识后，我们希望在应用中使用它。计划是通过三个回调函数添加 169 个新页面，并添加一些新的布局元素。用户将有一个可以选择的国家下拉菜单。选择一个国家后，URL
    会发生变化，从而渲染该国家的布局。该布局将包括一个标题、一个图表和一个关于该国家的表格。
- en: '*Figure 11.2* shows a sample of a country page that we will build:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11.2* 展示了我们将构建的一个国家页面的示例：'
- en: '![Figure 11.2 – A sample country page showing a chart including other countries
    as well](img/B16780_11_2.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 一个展示包括其他国家的图表的示例国家页面](img/B16780_11_2.jpg)'
- en: Figure 11.2 – A sample country page showing a chart including other countries
    as well
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 一个展示包括其他国家的图表的示例国家页面
- en: As you can see, we now have a template for a country page. This was triggered
    because the URL contained a country that is one of the available countries in
    the dataset. Otherwise, it will display the main app, containing all the components
    that we have built so far. Users can also click on the **Home** link to go there.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在有了一个国家页面的模板。之所以触发此模板，是因为 URL 中包含了数据集中可用的某个国家。如果没有，它将显示包含我们迄今为止创建的所有组件的主应用程序。用户还可以点击
    **Home** 链接返回主页。
- en: Let's first see how to restructure our app.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何重新构建我们的应用。
- en: Restructuring your app to cater to multiple layouts
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了适应多种布局，重构您的应用
- en: 'At this stage, we haven''t moved from the basic structure that we discussed
    in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015), *Overview of
    the Dash Ecosystem*, and as a reminder, *Figure 11.3* shows a simplified representation
    of the current structure:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，我们还没有脱离我们在[*第 1 章*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015)中讨论的基本结构，*Dash
    生态系统概述*，并且作为提醒，*图 11.3* 展示了当前结构的简化表示：
- en: '![Figure 11.3 – The structure of a Dash app](img/B16780_11_3.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – Dash 应用的结构](img/B16780_11_3.jpg)'
- en: Figure 11.3 – The structure of a Dash app
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – Dash 应用的结构
- en: 'Everything will remain the same, with the exception of the layout part. Right
    now, we only have one layout attribute, and everything was added to the main div.
    We used tabs to efficiently utilize space in some cases, and from Dash Bootstrap
    Components we used the `Row` and `Col` components to flexibly manage how components
    are displayed. To create the new layout structure, we need to create one main
    layout, which will serve as the skeleton of our app. In this layout, we will have
    an empty div, which will get populated with the appropriate content, depending
    on the URL we are on. *Figure 11.4* shows how this skeleton might look. This is
    just to make it easy to visualize; it would never show an empty page like this.
    Note that we also added a navigation bar, to which we can add several other elements,
    and this can be thought of as another addition to our app:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了布局部分之外，其他都将保持不变。目前，我们只有一个布局属性，所有内容都被添加到了主 div 中。在某些情况下，我们使用了标签页来高效地利用空间，并且从
    Dash Bootstrap 组件中使用了 `Row` 和 `Col` 组件，以灵活地管理组件的显示方式。为了创建新的布局结构，我们需要创建一个主布局，它将作为我们应用的骨架。在这个布局中，我们将有一个空
    div，根据当前的 URL，适当的内容将被填充进来。*图 11.4* 展示了这个骨架的可能样子。这里只是为了让大家更容易可视化；它永远不会显示一个这样的空白页面。请注意，我们还添加了一个导航栏，可以在其中添加多个其他元素，这可以被视为我们应用的另一项新增功能：
- en: '![Figure 11.4 – The new skeleton layout of the app showing an empty main content
    area](img/B16780_11_4.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 应用的新骨架布局，显示一个空的主内容区域](img/B16780_11_4.jpg)'
- en: Figure 11.4 – The new skeleton layout of the app showing an empty main content
    area
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 应用的新骨架布局，显示一个空的主内容区域
- en: Tip
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As you can see on the skeleton page with the empty body, you can use Dash for
    very fast prototyping and designing apps. Before you start coding, you can quickly
    build the layout you want, share with other stakeholders, get feedback, and only
    then start coding the interactivity.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在带有空主体的骨架页面上看到的，您可以使用 Dash 进行非常快速的原型设计和应用设计。在开始编码之前，您可以快速构建您想要的布局，与其他利益相关者分享，获取反馈，然后再开始编写交互性代码。
- en: As we did with the same figure, you can also isolate or remove certain elements,
    to make it easier for your audience to understand the structure of the app you
    are building.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在同一图示中所做的，您还可以隔离或删除某些元素，以便让您的受众更容易理解您正在构建的应用结构。
- en: 'Let''s now code the different parts that we need to upgrade our app with country
    URLs and a navigation bar. We start by first creating a few separate layouts:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写代码，升级我们的应用，添加国家 URL 和导航栏。首先我们创建几个独立的布局：
- en: '`NavbarSimple` component and discuss its details in the following section.
    Our layout will also contain the footer that has tabs, which we previously created.
    The body of this layout, like our simple app at the beginning of the chapter,
    will have a `Location` component, as well as an empty div that will display the
    required layout:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NavbarSimple` 组件，并在接下来的章节中详细讨论其细节。我们的布局还将包含脚部，其中有我们之前创建的标签页。这个布局的主体，就像本章开头的简单应用一样，将包含一个
    `Location` 组件，并且还有一个空 div 用于显示所需的布局：'
- en: '[PRE14]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`main_content` div when the right condition is met (if the URL does not contain
    a country name):'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当满足正确条件时（如果 URL 不包含国家名称），`main_content` div 将被填充：
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Country dashboard**: This will also be saved to a variable and displayed
    when its condition is met, which is when there is a country name in the URL. The
    content of this layout (chart and table) will be for the country in the URL:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**国家仪表盘**：这也将被保存为一个变量，并在满足条件时显示，即当 URL 中有国家名称时。此布局的内容（图表和表格）将针对 URL 中的国家：'
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`validation_layout` attribute solves this issue for us. It''s also a nice and
    easy way to know and manage the layout of our app as a whole. This can come in
    handy with more complex apps that have many more layouts. You can think of it
    as the app''s table of contents:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`validation_layout` 属性为我们解决了这个问题。这也是一个很好的、简单的方式，帮助我们了解并管理应用程序的整体布局。对于更复杂的应用程序，有更多的布局时，这会很有用。你可以把它当作应用程序的目录：'
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We still need to specify the app''s `layout` attribute, so Dash knows which
    one to use as the default layout. This is very simple:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要指定应用程序的 `layout` 属性，这样 Dash 才知道使用哪个作为默认布局。这非常简单：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's now see how to manage the content that will be displayed in the `main_layout`
    part.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何管理将在 `main_layout` 部分显示的内容。
- en: Displaying content based on the URL
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于 URL 显示内容
- en: Once our layouts have been set up the way we did, we need a very simple function
    to manage the content.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的布局按照之前的方式设置好，我们需要一个非常简单的函数来管理内容。
- en: The function checks if the path name attribute of the `Location` component is
    one of the available countries or not. If it is, it returns the `country_dashboard`
    layout. Otherwise, it returns `indicators_layout`. Note that the second condition
    includes anything other than a country from the available countries. Since we
    don't have any other functionality in this app, and to catch any URL errors, it's
    good to send anything else to the home page. In more elaborate apps, though, it
    might be better to create error pages.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数检查 `Location` 组件的路径名属性是否是可用国家之一。如果是，它将返回 `country_dashboard` 布局。否则，它将返回 `indicators_layout`。注意，第二个条件包括除可用国家之外的任何内容。由于我们在这个应用中没有其他功能，为了捕捉任何
    URL 错误，最好将其他所有内容引导到主页。不过，在更复杂的应用中，创建错误页面可能更为合适。
- en: 'We need to take note of two simple points. First, that the pathname attribute
    returns the path which contains `"/<country_name>"`, so we need to extract everything
    but the first character. Second, when we change the URL, if it contains special
    characters, such as spaces, they are automatically URL-encoded. This can be easily
    handled with the `unquote` function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意两个简单的要点。首先，pathname 属性返回包含 `"/<country_name>"` 的路径，因此我们需要提取除了第一个字符之外的所有内容。其次，当我们更改
    URL 时，如果它包含特殊字符，如空格，它们会被自动 URL 编码。可以使用 `unquote` 函数轻松处理：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Choosing a country with spaces, as in this case, converts spaces to their URL-encoded
    equivalent `%20`, so we need to use `unquote` on the name to be able to handle
    it as normal text.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 选择带有空格的国家（如本例所示）时，会将空格转换为其 URL 编码的等效形式 `%20`，因此我们需要使用 `unquote` 来处理名称，使其能够作为普通文本处理。
- en: 'Here is the code that creates a `countries` list, containing all available
    countries, and the simple callback that manages the display of the content, based
    on the URL:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建 `countries` 列表的代码，包含所有可用的国家，以及根据 URL 管理内容显示的简单回调：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We just went through a high-level description of the new layout and structure
    of the app, and we now need to fill in some blanks and discuss some details about
    how to create the navigation bar, the drop-down menu, and its links.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚概述了应用程序的新布局和结构的高层次描述，现在我们需要填补一些空白，并讨论如何创建导航栏、下拉菜单及其链接的细节。
- en: Adding dynamically generated URLs to the app
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向应用程序中添加动态生成的 URL
- en: We now want to complete our main layout with a navigation bar, a home page link,
    as well as a drop-down menu for the countries. To achieve that, we introduce the
    `NavbarSimple` component from Dash Bootstrap Components and see how we can use
    it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要通过添加一个导航栏、主页链接以及一个国家下拉菜单来完成我们的主要布局。为此，我们引入了 Dash Bootstrap 组件中的 `NavbarSimple`
    组件，来看我们如何使用它。
- en: 'The `NavbarSimple` component will take a few elements to create the structure
    we want as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavbarSimple` 组件将包含一些元素，以创建我们想要的结构，具体如下：'
- en: 'We first create the navigation bar and give it `brand` and `brand_href` arguments,
    to indicate what the name would be and where it would link to:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建导航栏，并为其提供 `brand` 和 `brand_href` 参数，以指示名称以及它将链接到的位置：
- en: '[PRE21]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For its `children` argument, we will add a `dbc.DropdownMenu` component. We
    will also give it a `label` value so users know what to expect when they click
    on the menu. We will fill its `children` argument in the next step:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于它的 `children` 参数，我们将添加一个 `dbc.DropdownMenu` 组件。我们还将为它提供一个 `label` 值，以便用户点击菜单时知道会发生什么。在下一步中，我们将填充它的
    `children` 参数：
- en: '[PRE22]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We now need to supply a list of `dbc.DropdownMenuItem` components to the drop-down
    menu. Those items will each get `children` and `href` arguments. Both of these
    will be for a country from the list of countries we created in the previous section:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要为下拉菜单提供一系列 `dbc.DropdownMenuItem` 组件。每个项目将获得 `children` 和 `href` 参数。两个参数都会对应我们在上一节创建的国家列表中的一个国家：
- en: '[PRE23]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Putting together the code for the full `NavbarSimple` component, you can see
    it here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将完整的`NavbarSimple`组件代码整理在一起，你可以在这里看到它：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With this, we have implemented our navigation bar, and we can also add the `Tabs`
    component to the same layout, which we implemented in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015),
    *Overview of the Dash Ecosystem*. Now it is very easy to modify or add any navigational
    elements you want, whenever you want, which will take effect on the website as
    a whole.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经实现了导航栏，我们还可以将 `Tabs` 组件添加到相同的布局中，这是我们在 [*第1章*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015)
    中实现的，*Dash 生态系统概述*。现在，修改或添加任何导航元素变得非常简单，无论何时你想要，它都会对整个网站生效。
- en: Note that the children of the navigation bar contained links that act the same
    way as the `Link` component, so we also have this option when needed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，导航栏中的子项包含与`Link`组件相同功能的链接，因此在需要时，我们也可以使用此选项。
- en: With the full layout of the whole app ready and the correct layout being loaded
    based on the URL, we are now ready to implement the last two callback functions
    that will generate the `country_dashboard` layout for us.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 随着整个应用程序的完整布局已经准备好，并且根据 URL 加载了正确的布局，我们现在准备实现最后两个回调函数，它们将为我们生成 `country_dashboard`
    布局。
- en: But here is the situation. I, your former colleague, wrote the code and created
    the functionality. I left the company without explaining anything, and you cannot
    get in touch with me. You need to figure out the structure for yourself, and you
    want to make some changes to my code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但情况是这样的。我，你以前的同事，编写了代码并创建了功能。我在没有任何解释的情况下离开了公司，你无法与我取得联系。你需要自己弄清楚结构，并且你想对我的代码做一些修改。
- en: This is a typical situation that you will probably face, so let's see how we
    can approach it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可能会遇到的典型情况，接下来我们看看如何解决它。
- en: Incorporating the new URL interactivity into the app
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将新的 URL 交互性整合到应用程序中
- en: Having created a dropdown that automatically changes the URL based on the selected
    value, we have allowed our users to go from page to page as they please. We now
    need to manage the display of the right content based on the selected country.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个下拉菜单，自动根据所选的值更改 URL，我们已经允许用户根据自己的需求在页面间切换。现在，我们需要根据选定的国家/地区来管理正确内容的显示。
- en: Since the code was already written, one thing you can do is run the app in debug
    mode and get a visual representation of all the available components and see how
    they are connected with callbacks.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码已经编写完成，你可以做的事情之一是以调试模式运行应用程序，并获取所有可用组件的可视化表示，查看它们如何通过回调函数连接。
- en: '*Figure 11.5* shows the graph of the callbacks that have been created. Let''s
    use it to understand how this functionality was implemented:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.5* 显示了已经创建的回调函数图。让我们用它来理解这个功能是如何实现的：'
- en: '![Figure 11.5 – The various components and callbacks managing the URL functionality](img/B16780_11_5.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5 – 管理 URL 功能的各种组件和回调函数](img/B16780_11_5.jpg)'
- en: Figure 11.5 – The various components and callbacks managing the URL functionality
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – 管理 URL 功能的各种组件和回调函数
- en: 'Let''s go through the figure from left to right and see what is going on here.
    You can refer to *Figure 11.2* to see how this graph corresponds to visible components
    in the app:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从左到右浏览这张图，看看这里发生了什么。你可以参考 *图11.2* 来查看这张图如何与应用程序中的可见组件对应：
- en: Everything starts with the **pathname** attribute of the component with the
    ID **location**. This can be induced by the user selecting a country from the
    drop-down menu, directly entering the full URL containing a country name, or clicking
    on a link from a web page.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切从组件的 **pathname** 属性开始，该组件的 ID 为 **location**。这可以通过用户选择下拉菜单中的一个国家、直接输入包含国家名称的完整
    URL，或点击网页中的链接来触发。
- en: The URL (its pathname attribute) influences three components, as you can see.
    Most importantly, it determines what goes into the `country_dashboard` layout
    will be displayed, using the **display_content** callback. This would display
    certain components that would make the two other callbacks relevant.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL（它的 pathname 属性）会影响三个组件，如你所见。最重要的是，它决定了哪些内容会显示在 `country_dashboard` 布局中，使用
    **display_content** 回调来显示。这将展示某些组件，使得另外两个回调变得相关。
- en: Assuming a country was selected, our second callback, **set_dropdown_values**,
    will take this country and use it to populate the dropdown that selects the country
    to plot on this page.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设已选择一个国家，我们的第二个回调 **set_dropdown_values** 将使用该国家的值来填充下拉框，以便在此页面上选择要绘制的国家。
- en: The `<h1>` component that says `"<country name> Poverty Data"`. `dbc.Table`
    component showing various details about the country, extracted from the country
    CSV file that contains data about each country in the dataset.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<h1>` 组件显示 `"<country name> 贫困数据"`。`dbc.Table` 组件展示关于该国家的各种详细信息，这些信息从包含数据的国家
    CSV 文件中提取，该文件包含数据集中的每个国家。'
- en: 'After this, you get the code from the repository to see how this was implemented,
    and you see two callbacks that you want to review and eventually change:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你从代码库中获取代码，查看这是如何实现的，你会看到两个回调，你想要审查并最终修改它们：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By now, it should be easy for you to figure out how to read new code, even code
    that contains components that you have never seen before. The general structure
    of apps has been covered and modified so many times, with so many components,
    and I think you are now comfortable with figuring this out for yourself.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该能轻松地弄懂如何阅读新的代码，即使是包含你从未见过的组件的代码。应用程序的一般结构已经讲解和修改了很多次，涉及了很多组件，我相信你现在能自己搞清楚这些内容了。
- en: This is the last coding exercise in the book, and the last functionality that
    we will add. It doesn't mean that the app is complete. On the contrary, there
    are many things that can be modified and added. One thing you might consider doing
    is implementing a special URL for each indicator and having a special page for
    it, just like we did with countries. The difference is that this may not be as
    straightforward as the case with countries. We have some indicators that are percentages
    and others that are simple numbers. Some indicators should be taken together as
    a group, such as the ones showing different income quantiles. You can really get
    creative with what you want to change and how.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是书中的最后一个编码练习，也是我们将要添加的最后一个功能。这并不意味着应用已经完成。相反，还有许多可以修改和添加的地方。你可能考虑做的一件事是为每个指标实现一个特殊的
    URL，并为其设置一个专门的页面，就像我们对国家做的那样。不同之处在于，这可能不像国家那样直接。我们有些指标是百分比，而另一些则是简单的数字。一些指标应该作为一个组一起考虑，比如显示不同收入分位数的那些。你可以在修改和添加时发挥创意，尝试不同的方式。
- en: Let's now recap what we covered in this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下这一章中涵盖的内容。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We first got to know the two main components that are responsible for modifying,
    reading, and parsing URLs, the **Location** and **Link** components. We created
    two simple apps in which we saw how to extract the part of the URL that we are
    interested in and experimented with several options for what can be done with
    them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先了解了两个主要的组件，它们负责修改、读取和解析 URL，即 **Location** 和 **Link** 组件。我们创建了两个简单的应用，看到如何提取我们感兴趣的
    URL 部分，并尝试了几种可以使用它们的方式。
- en: We then saw how to modify parts of an app by taking values from parsed URLs.
    With this knowledge, we were able to restructure our app. We created a skeleton
    layout with an empty div, in which the right content would then be displayed based
    on the URL.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着学习了如何通过解析的 URL 获取值并修改应用的部分内容。有了这些知识，我们能够重新构建我们的应用。我们创建了一个骨架布局，并使用一个空的 div，在其中根据
    URL 显示右侧的内容。
- en: We then incorporated the new functionality into our app. We were left with a
    final exercise that you can expect to go through in real life, which is a colleague
    handing you some code that you have to figure out and modify yourself.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将新功能整合进了我们的应用。接着，我们进行了一项最终的练习，这个练习你可以预见在实际工作中会遇到，那就是同事交给你一些代码，要求你自己搞明白并进行修改。
- en: Now that we have explored many options, layouts, components, and functionality,
    the next natural step is to deploy our app on a public server, so we can share
    it with the world.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经探索了许多选项、布局、组件和功能，下一步自然就是将我们的应用部署到公共服务器上，这样我们就能与世界分享它了。
- en: This will be the topic of the next chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是下一章的主题。
