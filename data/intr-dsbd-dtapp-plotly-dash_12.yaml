- en: '*Chapter 9*: Letting Your Data Speak for Itself with Machine Learning'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：让你的数据为自己发声，利用机器学习'
- en: While making histograms we got a glimpse of a technique that visualizes aggregates,
    and not data points directly. In other words, we visualized data about our data.
    We will take this concept several steps further in this chapter, by using a machine
    learning technique to demonstrate some options that can be used to categorize
    or cluster our data. As you will see in this chapter, and even while using a single
    technique, there are numerous options and combinations of options that can be
    explored. This is where the value of interactive dashboards comes into play. It
    would be very tedious if users were to explore every single option by manually
    creating a chart for it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作直方图时，我们已经看到了一种可视化聚合数据而不是直接可视化数据点的技术。换句话说，我们可视化了关于我们数据的数据。在本章中，我们将进一步拓展这个概念，使用机器学习技术演示一些可用于分类或聚类数据的选项。正如你在本章中所看到的，甚至使用单一技术时，也有许多选项和组合可以探索。这就是交互式仪表板价值所在。如果用户需要通过手动创建图表来探索每一个选项，那将是非常繁琐的。
- en: This chapter is not an introduction to machine learning, nor does it assume
    any prior knowledge of it. We will explore a clustering technique called `sklearn`
    machine learning package. This will help us in grouping our data into clusters
    of observations that are similar to one another, and yet distinct from observations
    in other clusters. We will build a very simple model with a single-dimensional
    dataset, and then see how this can be applied to clustering countries in our `poverty`
    dataset.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不是机器学习的介绍，也不假设你有任何先前的知识。我们将探索一种叫做`sklearn`的聚类技术。这将帮助我们将数据分组为相似的观察集合，同时与其他集合中的观察有所不同。我们将用一个简单的一维数据集来构建模型，然后看看如何将其应用于聚类我们`贫困`数据集中的国家。
- en: If you are familiar with machine learning, then this chapter will hopefully
    give you some ideas of how to empower your users and allow them to tune and explore
    several aspects of the models used. If not, you should be able to complete the
    chapter, and it will hopefully inspire you to explore more machine learning concepts
    and techniques.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉机器学习，那么本章应该能为你提供一些思路，帮助你为用户提供更多的能力，允许他们调节和探索模型的多个方面。如果不熟悉，依然可以完成本章内容，并且希望它能激发你进一步探索更多机器学习的概念和技术。
- en: 'We will go through the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding clustering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解聚类
- en: Finding the optimal number of clusters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到最佳的聚类数量
- en: Clustering countries by population
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按人口对国家进行聚类
- en: Preparing data with `scikit-learn`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`scikit-learn`准备数据
- en: Creating an interactive K-Means clustering app
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个交互式K均值聚类应用
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will be exploring a few options from `sklearn`, as well as `NumPy`. Otherwise,
    we will be using the same tools we have been using. For visualization and building
    interactivity, Dash, JupyterDash, the Dash Core Component library, Dash HTML Components,
    Dash Bootstrap Components, Plotly, and Plotly Express will be used. For data manipulation
    and preparation, we will use `pandas` and `NumPy`. JupyterLab will be used for
    exploring and building independent functionality. Finally, `sklearn` will be used
    for building our machine learning models, as well as for preparing our data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索一些来自`sklearn`和`NumPy`的选项。此外，我们将继续使用之前所用的工具。为了实现可视化和交互功能，我们将使用Dash、JupyterDash、Dash核心组件库、Dash
    HTML组件、Dash Bootstrap组件、Plotly和Plotly Express。对于数据处理和准备，我们将使用`pandas`和`NumPy`。JupyterLab将用于探索和构建独立功能。最后，`sklearn`将用于构建机器学习模型，并准备我们的数据。
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_09](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_09).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到，网址为[https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_09](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_09)。
- en: Check out the following video to see the Code in Action at [https://bit.ly/3x8PAmt](https://bit.ly/3x8PAmt).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际演示：[https://bit.ly/3x8PAmt](https://bit.ly/3x8PAmt)。
- en: Understanding clustering
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解聚类
- en: 'So, what exactly is clustering and when might it be helpful? Let''s start with
    a very simple example. Imagine you have a group of people for whom we want to
    make T-shirts. We can make a T-shirt for each one of them, in whatever size required.
    The main restriction is that we can only make one size. The sizes are as follows:
    [1, 2, 3, 4, 5, 7, 9, 11]. Think how you might tackle this problem. We will use
    the `KMeans` algorithm for that, so let''s start right away, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是聚类，何时它可能会有帮助呢？让我们从一个非常简单的例子开始。假设你有一群人，我们想为他们制作T恤。我们可以为每个人制作一件T恤，按需求的尺寸制作。主要的限制是我们只能制作一种尺寸。尺寸如下：[1,
    2, 3, 4, 5, 7, 9, 11]。想一想你会如何解决这个问题。我们将使用`KMeans`算法来解决这个问题，下面我们就开始吧：
- en: 'Import the required packages and models. `NumPy` will be imported as a package,
    but from `sklearn` we will import the only model that we will be using for now,
    as illustrated in the following code snippet:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的包和模型。`NumPy`将作为包导入，但我们从`sklearn`只会导入当前将要使用的唯一模型，如下代码片段所示：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a dataset of sizes in the required format. Note that each observation
    (person''s size) should be represented as a list, so we use the `reshape` method
    of `NumPy` arrays to get the data in the required format, as follows:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个所需格式的尺寸数据集。请注意，每个观察（个人的尺寸）应表示为一个列表，因此我们使用`NumPy`数组的`reshape`方法来获取所需格式的数据，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create an instance of the `KMeans` model with the required number of clusters.
    An important feature of this model is that we provide the desired number of clusters
    for it. In this case, we were given a constraint, which is that we can only make
    T-shirts in one size, so we want to discover a single point that would be the
    center of our discovered cluster. We will explore the effect of the chosen number
    of clusters after that. Run the following code:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`KMeans`模型实例，并指定所需的聚类数量。该模型的一个重要特性是，我们需要为其提供所需的聚类数量。在这个例子中，我们面临一个限制，就是只能制作一种尺寸的T恤，所以我们想要找到一个单一的点，它将是我们发现的聚类的中心。之后我们将探索所选聚类数量的效果。运行以下代码：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Fit the model to the data using the `fit` method. This means that we want the
    model we just created to "learn" the dataset based on this particular algorithm,
    and with the provided parameters/options. This is the code you will need:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fit`方法将模型拟合到数据。这意味着我们希望刚创建的模型根据这个特定的算法和提供的参数/选项“学习”数据集。这是你需要的代码：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We now have a model that has been trained on this dataset, and we can go on
    to check some of its attributes. As a convention, the resulting attributes of
    the fitted models have a trailing underscore to them, as we will see now. We can
    now ask for the clusters that we asked for. The `cluster_centers_` attribute provides
    the answer to this. The centers (in this case, one center) are basically the means
    of the clusters of our data points. Let''s check the result, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个在该数据集上训练好的模型，可以继续检查它的一些属性。按照惯例，拟合模型的结果属性会带有一个下划线，如我们接下来所看到的。我们现在可以询问我们请求的聚类。`cluster_centers_`属性给出了答案。聚类中心（在这个例子中是一个中心）基本上是我们数据点聚类的均值。让我们查看结果，如下所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We received the attribute in the form of a list of lists. The center of our
    cluster is `5.25`, apparently. You might be thinking that this is a convoluted
    way of calculating the mean of our dataset, and you would be right. Have a look
    at the following code snippet:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以列表形式接收到特征数据。显然，我们的聚类中心是`5.25`。你可能会认为这是一种复杂的方式来计算我们数据集的均值，你说得对。看看以下代码片段：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Indeed, our cluster center happens to be the mean of our dataset, which is
    exactly what we asked for. To visualize this, the following screenshot shows the
    relative position of the cluster center, related to our data points:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，我们的聚类中心恰好是我们数据集的均值，这正是我们所期望的。为了可视化这个结果，以下截图显示了聚类中心相对于数据点的位置：
- en: '![Figure 9.1 – The Sizes data points, with the cluster center provided by KMeans](img/B16780_09_1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 尺寸数据点，KMeans提供的聚类中心](img/B16780_09_1.jpg)'
- en: Figure 9.1 – The Sizes data points, with the cluster center provided by KMeans
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 尺寸数据点，KMeans提供的聚类中心
- en: The chart depicted in the previous screenshot is very simple—we simply plot
    the sizes on the *x* axis, and an arbitrary constant value for the *y* axis.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面截图中显示的图表非常简单——我们只是将尺寸绘制在*X*轴上，*Y*轴则是一个任意的常数值。
- en: 'In order to evaluate the performance of our model and how well it fits the
    data, there are several ways to do this—one way is by checking the `inertia_`
    attribute. This is an attribute of the instance we created and can be accessed
    after fitting it to the data, using dot notation, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估我们模型的表现以及它与数据的拟合程度，有几种方法可以做到这一点——一种方法是检查`inertia_`属性。这是我们创建的实例的一个属性，在将其拟合到数据后，可以使用点符号来访问，如下所示：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `inertia_` metric is the sum of squared distances of samples, to their closest
    cluster center. If the model performs well, the distances of the samples to the
    provided cluster centers should be as short as possible (data points are close
    to the cluster centers). A perfect model would have an inertia rate of `0`. Also,
    looking at it from the other side, we also know that asking for one cluster would
    give us the worst possible outcome because it is just one cluster, and to be the
    average point it has to be very far from the extreme data points.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`inertia_`度量是样本到其最近聚类中心的平方距离的总和。如果模型表现良好，样本到提供的聚类中心的距离应该尽可能短（数据点离聚类中心很近）。一个完美的模型的惯性率将是`0`。从另一个角度看，我们也知道，要求只有一个聚类会给我们最差的结果，因为它只是一个聚类，要成为平均点，它必须远离极端数据点。'
- en: Accordingly, we can improve the performance of the model simply by adding more
    clusters, because their distances to the centers would be reduced.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过添加更多的聚类来提高模型的性能，因为它们与中心的距离会减少。
- en: 'Now, imagine that I called you and shared some good news. We have an additional
    budget for one more size, and now we want to make T-shirts in two sizes. Translating
    to machine learning language, this means we need to create a new model with two
    clusters. We repeat the same steps and modify the `n_clusters` argument, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我给你打电话并分享一些好消息。我们有额外的预算来增加一个新的尺寸，现在我们希望制作两种尺寸的T恤。用机器学习语言来说，这意味着我们需要创建一个包含两个聚类的新模型。我们重复相同的步骤并修改`n_clusters`参数，如下所示：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We now have two new centers, as specified.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了两个新的聚类中心，如指定的那样。
- en: It's not enough to know the centers of our clusters. For each point, we need
    to know which cluster it belongs to, or we want to know the size of T-shirt that
    we will give to each person in our group. We can also count them and check the
    number of points in each cluster.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅知道聚类中心是不够的。对于每个点，我们需要知道它属于哪个聚类，或者我们想知道给我们组内每个人的T恤尺寸。我们还可以对它们进行计数，并检查每个聚类中的数据点数量。
- en: 'The `labels_` attribute contains this information, and can be seen here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`labels_`属性包含了这些信息，可以在这里看到：'
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the labels are given using integers starting at `0`. Also note that
    the numbers don't mean anything quantitative. Points that have a zero label are
    not from the first cluster; nor are points with the label 1 "more" than the others
    in any way. These are just labels, such as calling them `group A`, `group B`,
    and so on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，标签是从`0`开始的整数给出的。还要注意，这些数字并不代表任何量化的意义。标签为零的点并不来自第一个聚类；同样，标签为1的点在某种意义上也不“比”其他点更多。这些只是标签，例如将它们称为`A组`、`B组`，依此类推。
- en: 'We can map the labels to their respective values by using the `zip` function,
    as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`zip`函数将标签映射到它们各自的值，如下所示：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will be very important later when use those labels in our charts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在稍后使用这些标签绘制图表时非常重要。
- en: 'Let''s also visualize the two centers to get a better idea of how this works.
    The following screenshot shows where the cluster centers are located relative
    to other data points:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也可视化这两个聚类中心，以便更好地理解这个过程。以下截图显示了聚类中心相对于其他数据点的位置：
- en: '![ Figure 9.2 – The Sizes data points, with two cluster centers provided by
    KMeans](img/B16780_09_2.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 尺寸数据点，KMeans提供了两个聚类中心](img/B16780_09_2.jpg)'
- en: Figure 9.2 – The Sizes data points, with two cluster centers provided by KMeans
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 尺寸数据点，KMeans提供了两个聚类中心
- en: 'The centers make sense visually. We can see that the first five points are
    close to each other and that the last three are distinct and far from them, with
    larger gaps. Having 3 and 9 as cluster centers makes sense, because each of them
    is the mean of the values of its own cluster. Let''s now numerically validate
    that we have improved the performance of our model by checking the inertia rate,
    as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些聚类中心在视觉上是合理的。我们可以看到前五个点彼此接近，而最后三个点则彼此分离，远离前五个点，且间隙较大。将3和9作为聚类中心是合理的，因为每个聚类中心都是其所在聚类值的平均值。现在让我们通过检查惯性率来数值验证我们是否提高了模型的性能，如下所示：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Indeed, the performance was tremendously improved and reduced from 85.5 to 18.0\.
    Nothing surprising here. As you can expect, every additional cluster would improve
    the performance until we reach the perfect result with an inertia rate of `0`.
    So, how do we evaluate the best options available for the number of clusters?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，性能得到了极大的提升，从85.5降至18.0。这里没有什么令人惊讶的地方。正如你所预期的那样，每增加一个聚类，性能都会改善，直到我们达到惯性为`0`的完美结果。那么，我们该如何评估选择聚类数的最佳选项呢？
- en: Finding the optimal number of clusters
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找最优的聚类数
- en: 'We will now see the options we have in choosing the optimal number of clusters
    and what that entails, but let''s first take a look at the following screenshot
    to visualize how things progress from having one cluster to eight clusters:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到选择最优聚类数的可选项及其含义，但首先让我们看一下下面的截图，以可视化从一个聚类到八个聚类的进展：
- en: '![Figure 9.3 – Data points and cluster centers for all possible cluster numbers](img/B16780_09_3.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 所有可能的聚类数的 数据点和聚类中心](img/B16780_09_3.jpg)'
- en: Figure 9.3 – Data points and cluster centers for all possible cluster numbers
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 所有可能聚类数的 数据点和聚类中心
- en: We can see the full spectrum of possible clusters and how they relate to data
    points. At the end, when we specified 8, we got the perfect solution, where every
    data point is a cluster center.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有可能聚类数的完整范围，以及它们与数据点的关系。在最后，当我们指定8时，得到了完美的解决方案，每个数据点都是一个聚类中心。
- en: In reality, you might not want to go for the full solution, for two main reasons.
    Firstly, it is probably going to be prohibitive from a cost perspective. Imagine
    making 1,000 T-shirts with a few hundred sizes. Secondly, in practical situations,
    it usually wouldn't add much value to add more clusters after a certain fit has
    been achieved. Using our T-shirt example, imagine if we have two people with sizes
    5.3 and 5.27\. They would most likely wear the same size anyway.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可能不想选择完整的解决方案，主要有两个原因。首先，从成本的角度来看，这可能是不可行的。想象一下，如果要制作1000件T恤，而T恤有几百种尺寸。其次，在实际情况下，通常在达成某种适配后，继续增加聚类并不会带来太大的价值。以我们的T恤示例为例，假设有两个人的尺寸分别为5.3和5.27，他们可能仍然会穿相同的尺寸。
- en: So, we know that the optimal number of clusters is between one and the number
    of unique data points we have. We now want to explore the trade-offs and options
    of figuring out that optimal number. One of the strategies we can use is to check
    the value of additional—or incremental—clusters. When adding a new cluster, does
    it result in a meaningful reduction (improvement) in inertia? One such technique
    is called the "elbow technique." We plot the inertia values against the number
    of clusters and see where there is a sharp change in the direction of the curve.
    Let's do this now.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们知道最优的聚类数介于1和我们拥有的唯一数据点数之间。接下来，我们想要探索如何确定这个最优数量的权衡和选择。我们可以采用的一个策略是检查新增（或增量）聚类的值。当增加一个新聚类时，它是否带来了惯性的显著下降（改善）？一种这样的技术叫做“肘部法”。我们将惯性值与聚类数进行绘制，看看曲线方向发生急剧变化的地方。现在让我们来做一下这个操作。
- en: 'We loop through the numbers from 1 to 8, and for each number we go through
    the same process of instantiating a `KMeans` object and getting the inertia for
    that number of clusters. We then add that value to our `inertia` list, as illustrated
    in the following code snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从1到8进行循环，对于每个数字，我们都经历相同的过程：实例化一个`KMeans`对象，并获取该聚类数的惯性值。然后，我们将该值添加到我们的`inertia`列表中，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As expected, our inertia improved from 85.5 to a perfect zero at the end.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们的惯性从85.5改善到了最后的零。
- en: 'We now plot those to see where the elbow lies, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将这些值绘制出来，看看“肘部”位置在哪里，如下所示：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running the preceding code produces the chart shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会生成如下截图所示的图表：
- en: '![Figure 9.4 – The "elbow" method, showing inertia values for all possible
    cluster numbers](img/B16780_09_4.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – “肘部”方法，显示所有可能聚类数的惯性值](img/B16780_09_4.jpg)'
- en: Figure 9.4 – The "elbow" method, showing inertia values for all possible cluster
    numbers
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – “肘部”方法，显示所有可能聚类数的惯性值
- en: 'You can clearly see a sudden drop when moving from 1 to 2 and that inertia
    keeps decreasing, but at a lower rate as we move toward the final value. So, three
    or maybe four clusters might be the point where we start to get diminishing returns,
    and that could be our optimal number of clusters. We also cheated a little by
    including one cluster, because we already knew that it would be the worst-performing
    number of clusters. You can see the same plot without the first value in the following
    screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到，当聚类数量从1变为2时，惯性突然下降，随着聚类数量趋向最终值，惯性继续下降，但下降的速度变慢。所以，三个或许四个聚类可能是我们开始获得递减回报的点，这可能是我们聚类的最佳数量。我们也稍微作弊了一下，包含了一个聚类，因为我们已经知道它将是最差的聚类数量。你可以在以下截图中看到没有第一个值的相同图形：
- en: '![Figure 9.5 – The "elbow" method, showing inertia values for all possible
    cluster numbers excluding 1](img/B16780_09_5.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – “肘部”法则，展示了所有可能的聚类数量的惯性值（不包括1）](img/B16780_09_5.jpg)'
- en: Figure 9.5 – The "elbow" method, showing inertia values for all possible cluster
    numbers excluding 1
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – “肘部”法则，展示了所有可能的聚类数量的惯性值（不包括1）
- en: This looks quite different and also shows that we cannot mechanically make a
    decision without knowing more about the data, the use case, and whatever constraints
    we might have.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来完全不同，并且表明我们不能在不了解数据、使用场景以及可能存在的任何限制条件的情况下，机械地做出决策。
- en: 'The example we explored was extremely simple in terms of the number of observations,
    as well as the number of dimensions, which was one dimension. `KMeans` clustering
    (and machine learning in general) usually handles multiple dimensions, and the
    concept is basically the same: we try to find centers of clusters that minimize
    the distance between them and the data points. For example, the following screenshot
    shows what a similar problem might look like in two dimensions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索的这个示例在观察数量和维度数量上非常简单，只有一个维度。`KMeans` 聚类（以及一般的机器学习）通常处理多个维度，概念基本相同：我们尝试找到聚类的中心，使得它们与数据点之间的距离最小。例如，下面的截图展示了在二维空间中，类似问题的样子：
- en: '![Figure 9.6 – Clustered points in two dimensions](img/B16780_09_6.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 二维空间中的聚类点](img/B16780_09_6.jpg)'
- en: Figure 9.6 – Clustered points in two dimensions
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 二维空间中的聚类点
- en: This could correspond to additional measurements relating to our group of people.
    So, we might have their height on the *x* axis and their weight on the *y* axis,
    for example. You can imagine what `KMeans` would give us in this case. Of course,
    in real life, data is rarely so neatly clustered. You can also see how much accuracy
    we might lose by selecting the wrong number of clusters. If we specify three clusters,
    for example, the three blobs in the middle would probably be considered a single
    cluster, even though we can see that they are quite distinct from one another
    and that their points are quite close to each other. Also, if we specify seven
    or eight clusters, we could get unnecessary divisions between clusters, or we
    would have passed the elbow on the elbow chart in this case.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对应于与我们的人群相关的额外测量值。例如，我们可能将他们的身高放在 *x* 轴上，体重放在 *y* 轴上。你可以想象 `KMeans` 在这种情况下会给我们什么结果。当然，现实中数据很少如此整齐地聚集在一起。你也可以看到，如果选择错误的聚类数量，我们可能会损失多少准确性。例如，如果我们指定三个聚类，图中的三个中间块可能会被认为是一个单一的聚类，尽管我们可以看到它们之间有明显的差异，而且它们的点非常接近彼此。此外，如果我们指定七个或八个聚类，我们可能会在聚类之间得到不必要的划分，或者我们已经越过了“肘部”图中的肘部。
- en: We are now ready to use this understanding of clustering in our dataset.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好在我们的数据集中使用这一聚类理解了。
- en: Clustering countries by population
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按人口对国家进行聚类
- en: We will first understand this with one indicator that we are familiar with (population),
    and then make it interactive. We will cluster groups of countries based on their
    population.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过一个我们熟悉的指标（人口）来理解这个问题，然后使其具有互动性。我们将根据各国的人口对其进行聚类。
- en: Let's start with a possible practical situation. Imagine you were asked to group
    countries by population. You are supposed to have two groups of countries, of
    high and low populations. How do you do that? Where do you draw the line(s), and
    what does the total of the population have to be in order for it to qualify as
    "high"? Imagine that you were then asked to group countries into three or four
    groups based on their population. How would you update your clusters?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个可能的实际情境开始。假设你被要求按人口将国家分组。你需要将国家分成两组：人口高的和人口低的。你该怎么做呢？你会在哪些地方画分界线，人口总数多少才算是“高”？假设你被要求将国家根据人口分成三组或四组。那么你将如何更新你的聚类呢？
- en: We can easily see how `KMeans` clustering is ideal for that.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松看到，`KMeans`聚类非常适合这种情况。
- en: 'Let''s now do the same exercise with `KMeans` using one dimension, and then
    combine that with our knowledge of mapping, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们用一个维度进行`KMeans`聚类，并将其与我们的地图绘制知识结合，操作如下：
- en: 'Import `pandas` and open the `poverty` dataset, like this:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`pandas`并打开`poverty`数据集，如下所示：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create variables for the year and desired indicators, as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建年份和所需指标的变量，如下所示：
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Instantiate a `KMeans` object with the desired number of clusters, like this:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`KMeans`对象，指定所需的簇数，如下所示：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a `df` object, which is the `poverty` DataFrame containing only countries
    and data from the selected year only. Run the following code to do this:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`df`对象，这是包含所选年份的国家和数据的`poverty`数据框。运行以下代码来实现这一点：
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a `data` object, which is a list of columns that we choose (in this
    case, we only chose one). Note in the following code snippet that we get its `values`
    attribute, which returns the underlying `NumPy` array:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`data`对象，这是我们选择的列的列表（在这种情况下，我们只选择了一列）。请注意，下面的代码片段中我们获取了它的`values`属性，这会返回底层的`NumPy`数组：
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Fit the model to the data, as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型拟合到数据，如下所示：
- en: '[PRE18]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have now trained the model on our data and are ready to visualize the results.
    Remember our discussion in [*Chapter 7*](B16780_07_Final_NM_ePub.xhtml#_idTextAnchor106),
    *Exploring Map Plots and Enriching Your Dashboards with Markdown*, that in order
    to create a map, we simply need a DataFrame with a column containing country names
    (or codes)? This is enough to produce a map. If we want to color our countries,
    we need another column (or any list-like object) containing corresponding values.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在数据上训练了模型，并准备好可视化结果。记得我们在[*第7章*](B16780_07_Final_NM_ePub.xhtml#_idTextAnchor106)中讨论过，*探索地图绘图并通过Markdown丰富你的仪表盘*，为了创建一张地图，我们只需要一个包含国家名称（或代码）的列的DataFrame？这就足够生成一张地图。如果我们想要为国家上色，我们需要另一列（或任何类似列表的对象），其中包含相应的值。
- en: 'The `kmeans` object we just trained contains the labels of the countries and
    would tell us which country belongs to which cluster. We will use that to color
    countries, so we do this with one function call. Note that we can convert the
    labels to strings, which would cause Plotly Express to treat them as categorical
    and not continuous variables. The code is shown in the following snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚训练的`kmeans`对象包含了各个国家的标签，并告诉我们哪个国家属于哪个簇。我们将利用这个信息来给国家上色，所以我们通过一次函数调用来完成这一操作。请注意，我们可以将标签转换为字符串，这会导致Plotly
    Express将它们视为分类变量，而非连续变量。代码如下所示：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code produces the chart shown in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了如下截图所示的图表：
- en: '![Figure 9.7 – Countries clustered by population](img/B16780_09_7.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 按人口聚类的国家](img/B16780_09_7.jpg)'
- en: Figure 9.7 – Countries clustered by population
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 按人口聚类的国家
- en: 'Since we have already developed a template of options for maps, we can copy
    this and use it to enhance this map and make it consistent with the theme of our
    app. Let''s use that and see the effect of having **1**, **2**, **3**, and **4**
    clusters on the same map, and discuss the details. The following screenshot shows
    four maps, each with a different number of clusters:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经开发了地图选项的模板，我们可以复制这个模板并用它来增强此地图，使其与我们应用程序的主题保持一致。让我们使用它，并查看在同一张地图上显示**1**、**2**、**3**和**4**个簇的效果，并讨论细节。下方截图显示了四张地图，每张地图的簇数不同：
- en: '![Figure 9.8 – Countries clustered by population using different numbers of
    clusters](img/B16780_09_8.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 按人口聚类的国家，使用不同数量的簇](img/B16780_09_8.jpg)'
- en: Figure 9.8 – Countries clustered by population using different numbers of clusters
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 按人口聚类的国家，使用不同数量的簇
- en: Important note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The colors may not be easy to distinguish on these maps if you are reading the
    grayscale version, and I encourage you to check out the online version and repository.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在查看灰度版本，这些地图上的颜色可能不容易区分，我建议你查看在线版本和代码库。
- en: As you can see, coloring the map with one cluster (one label for all countries)
    produces a map with a single color. Things start to get interesting when there
    are two clusters involved, and this also makes intuitive sense. The two countries
    forming the cluster with a higher population (namely, China and India) have very
    large populations that are also close to each other—1.39 billion and 1.35 billion,
    in this case. The third country, the **United States** (**US**), has a population
    of 327 million. This is exactly what KMeans is supposed to do. It gave us two
    groups of countries where countries in each cluster are very close to each other
    and far from countries in the other cluster. Of course, we introduced an important
    bias by selecting two as the number of clusters, and we saw how that might not
    be the optimal case.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，将地图着色为一个簇（所有国家使用同一标签）会生成一个单一颜色的地图。当涉及到两个簇时，事情就变得有趣了，这也符合直觉。组成具有较高人口的簇的两个国家（即中国和印度）有着非常庞大的人口，而且彼此非常接近——分别为13.9亿和13.5亿。第三个国家，**美国**（**US**），人口为3.27亿。这正是KMeans应该做的事情。它将我们分成了两个国家群体，在每个簇中的国家彼此非常接近，而与其他簇的国家则相距较远。当然，我们通过选择两个簇数引入了一个重要的偏差，并且我们看到了这种选择可能并不是最优的情况。
- en: When we chose three clusters, we can see that we have a medium-population cluster,
    with the US being one of them. Then, when we chose four, you can see that Russia
    and Japan were moved to the third category, even though they were in the second
    category when we had three clusters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择三个簇时，可以看到我们有一个中等人口的簇，其中美国是其中之一。然后，当我们选择四个簇时，你会看到俄罗斯和日本被移到了第三类，尽管它们在三个簇时属于第二类。
- en: We now have enough code and knowledge to take this to the next level. We want
    to give our users the option to select the number of clusters and indicator(s)
    that they want. We need to address some issues in our data first, so let's explore
    that.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有足够的代码和知识来将其提升到一个新的层次。我们希望为用户提供选择簇的数量和他们想要的指标的选项。我们需要首先解决数据中的一些问题，所以让我们来探讨一下。
- en: Preparing data with scikit-learn
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用scikit-learn准备数据
- en: '`scikit-learn` is one of the most widely used and comprehensive machine learning
    libraries in Python. It plays very well with the rest of the data-science ecosystem
    libraries, such as `NumPy`, `pandas`, and `matplotlib`. We will be using it for
    modeling our data and for some preprocessing as well.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-learn`是Python中最广泛使用且最全面的机器学习库之一。它与数据科学生态系统中的其他库（如`NumPy`、`pandas`和`matplotlib`）兼容得很好。我们将使用它来对我们的数据进行建模和预处理。'
- en: 'We now have two issues that we need to tackle first: missing values and scaling
    data. Let''s see two simple examples for each, and then tackle them in our dataset.
    Let''s start with missing values.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个问题需要首先解决：缺失值和数据缩放。让我们分别看两个简单示例，然后在我们的数据集中解决这些问题。首先从缺失值开始。
- en: Handling missing values
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理缺失值
- en: Models need data, and they can't know what to do with a set of numbers containing
    missing values. In such cases (and there are many in our dataset), we need to
    make a decision on what to do with those missing values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 模型需要数据，它们无法处理包含缺失值的一组数字。在这种情况下（我们的数据集中有很多类似情况），我们需要决定如何处理这些缺失值。
- en: There are several options, and the right choice depends on the application as
    well as the nature of the data, but we won't get into those details. For simplicity,
    we will make a generic choice of replacing missing data with suitable values.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种选择，正确的选择取决于应用场景以及数据的性质，但我们不会深入讨论这些细节。为了简化，我们将做出一个通用选择，用合适的值替换缺失数据。
- en: 'Let''s explore how we can impute missing values with a simple example, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的示例来探索如何填补缺失值，如下所示：
- en: 'Create a simple dataset containing a missing value, in a suitable format, as
    illustrated in the following code snippet:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含缺失值的简单数据集，格式合适，如以下代码片段所示：
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Import the `SimpleImputer` for `scikit-learn`, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`scikit-learn`中的`SimpleImputer`，如下所示：
- en: '[PRE21]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create an instance of this class with a `mean` strategy, which is the default.
    As you might have guessed, there are other strategies for imputing missing values.
    The code is shown in the following snippet:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mean`策略创建此类的实例，这是默认策略。正如你可能猜到的，除了这个策略，还有其他策略用于填补缺失值。以下代码片段展示了这一点：
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Fit the model to the data. This is where the model learns the data, given the
    conditions and options we set while instantiating it. The code is shown in the
    following snippet:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型拟合到数据。这是模型根据我们在实例化时设置的条件和选项来学习数据的地方。代码如以下片段所示：
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Transform the data. Now that the model has learned the data, it is able to
    transform it according to the rules that we set. The `transform` method exists
    in many models and has a different meaning, depending on the context. In this
    case, transforming means imputing the missing data, using the `mean` strategy.
    The code can be seen in the following snippet:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换数据。现在，模型已经学习了数据，它能够根据我们设置的规则对数据进行转换。`transform` 方法在许多模型中都有，其含义取决于上下文。在此情况下，转换是指使用
    `mean` 策略填充缺失数据。代码见下列代码片段：
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, the model has transformed the data by replacing the missing
    value with 1.5\. If you look at the other non-missing values [`1`, `2`, `1`, `2`],
    you can easily see that their mean is 1.5, and this is the result that we got.
    We could have specified a different strategy for imputing missing values, such
    as the median or the most frequent strategy. Each has its own advantages and disadvantages;
    we are simply exploring what can be done with machine learning in Dash.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，模型已通过将缺失值替换为 1.5 来转换数据。如果您查看其他非缺失值 [`1`, `2`, `1`, `2`]，您会发现它们的均值为 1.5，这正是我们得到的结果。我们本可以指定不同的缺失值填充策略，如中位数或最频繁值策略。每种策略都有其优缺点；我们这里只是探索在
    Dash 中通过机器学习可以做什么。
- en: Next, we move on to scaling our data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始对数据进行标准化处理。
- en: Scaling data with scikit-learn
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 scikit-learn 对数据进行标准化
- en: In *Figure 9.6*, we saw how clustering might look in two dimensions. If we want
    to cluster our poverty data by two indicators, one of them would be on the *x*
    axis and the other would be on the *y* axis. Now, imagine if we had a population
    on one of the axes and a percentage indicator on the other axis. The data on the
    population axis would range from 0 to 1.4 billion, and the data on the other axis
    would range from 0 to 1 (or from 0 to 100). Any differences in the percentage
    indicator would have negligible influence on the distances, and the means would
    mainly be calculated using the disproportionate size of the population numbers.
    One solution to this problem is to scale values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 9.6* 中，我们看到了二维数据聚类的效果。如果我们想根据两个指标对贫困数据进行聚类，一个指标会在 *x* 轴上，另一个则在 *y* 轴上。现在，假设我们在一个轴上有人口数据，另一个轴上有百分比指标。人口轴上的数据范围是
    0 到 14 亿，而另一个轴上的数据范围是 0 到 1（或 0 到 100）。百分比指标的任何差异对距离的影响可以忽略不计，均值主要通过人口数量的不成比例大小来计算。解决这个问题的一种方法是对数据进行标准化。
- en: 'There are different strategies for scaling data and we will explore one of
    them—namely, standard scaling. The `StandardScaler` class assigns `z`-scores (or
    standard scores) to the data points and normalizes them. The z-score is simply
    calculated by subtracting each value from the mean and dividing by the standard
    deviation. There are other ways of calculating this but we will focus on a simple
    example to better illustrate this concept, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的策略来缩放数据，我们将探索其中一种——即标准化缩放。`StandardScaler` 类为数据点分配 `z` 分数（或标准分数）并对其进行标准化。z
    分数的计算方式是将每个值减去均值，然后除以标准差。虽然有其他计算方法，但我们将专注于一个简单的示例来更好地说明这一概念，如下所示：
- en: 'Create a simple dataset, like this:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的数据集，如下所示：
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Import `StandardScaler` and create an instance of it, like this:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `StandardScaler` 并创建其实例，如下所示：
- en: '[PRE26]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Fit `scaler` to the data and transform it. For convenience, many models that
    have a `fit` and a `transform` method and also have a `fit_transform` method,
    which we will use now, as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `scaler` 拟合到数据并进行转换。为了方便，许多具有 `fit` 和 `transform` 方法的模型，也有一个 `fit_transform`
    方法，我们将使用这个方法，如下所示：
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have now transformed our numbers to their equivalent z-scores. Note that
    the mean value 3 has now become 0\. Anything higher than 3 is positive, and anything
    lower is negative. The numbers also indicate how far (high or low) the corresponding
    value is from the mean.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已将数据转换为其相应的 z 分数。请注意，均值 3 现在变成了 0。大于 3 的数值为正，小于 3 的为负。这些数值还表示了对应数值与均值的距离（高或低）。
- en: This way, when we have multiple features in our dataset, we can normalize them,
    compare them, and use them together. At the end of the day, what we care about
    is how extreme a certain value is and how close it is to the mean. A country with
    a Gini index of 90 is a very extreme case. It's as extreme as a country with a
    population of 1 billion. If we use those two together, the 1 billion will dominate
    and distort the calculation. Standardization helps us achieve a better way of
    dealing with data at different scales. It's still not perfect but is a very big
    improvement over using data in different scales. Now, we are able to use more
    than one feature while clustering our data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当我们的数据集包含多个特征时，我们可以对它们进行标准化，进行比较，并一起使用。最终，我们关心的是某个值的极端程度以及它与均值的接近度。一个基尼指数为
    90 的国家是一个极端案例。这就像一个人口达到 10 亿的国家。如果我们将这两者结合使用，10 亿的人口将主导并扭曲计算。标准化帮助我们以更好的方式处理不同尺度的数据。它仍然不是完美的，但比使用不同尺度的数据要好得多。现在，我们可以在聚类数据时使用多个特征。
- en: Creating an interactive KMeans clustering app
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个互动式 KMeans 聚类应用程序
- en: Let's now put everything together and make an interactive clustering application
    using our dataset. We will give users the option to choose the year, as well as
    the indicator(s) that they want. They can also select the number of clusters and
    get a visual representation of those clusters, in the form of a colored choropleth
    map, based on the discovered clusters.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将所有内容整合起来，使用我们的数据集创建一个互动式聚类应用程序。我们将让用户选择年份，以及他们想要的指标。用户还可以选择聚类数，并根据发现的聚类以有色分区地图的形式获得聚类的可视化表示。
- en: Please note that it is challenging to interpret such results with multiple indicators
    because we will be handling more than one dimension. It can also be difficult
    if you are not an economist and don't know which indicators make sense to be checked
    with which other indicators, and so on.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用多个指标时，解读这些结果是具有挑战性的，因为我们将处理多个维度。如果你不是经济学家，并且不清楚哪些指标应该与其他哪些指标进行比较，那么理解这些结果也会很困难。
- en: 'The following screenshot shows what we will be working toward:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了我们将要实现的效果：
- en: '![Figure 9.9 – An interactive KMeans clustering application](img/B16780_09_9.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 一个互动式 KMeans 聚类应用程序](img/B16780_09_9.jpg)'
- en: Figure 9.9 – An interactive KMeans clustering application
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 一个互动式 KMeans 聚类应用程序
- en: As you can see, this is a fairly rich application in terms of the combinations
    of options that it provides. As I also mentioned, it's not straightforward to
    interpret, but as mentioned several times in the chapter, we are simply exploring
    what can be done with only one technique and using only some of its options.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是一个非常丰富的应用程序，提供了多种选项组合。正如我之前提到的，这并不是一个直接易懂的过程，但正如本章多次提到的，我们只是在探索如何仅使用一种技术和其部分选项来实现目标。
- en: 'We have created many sliders and dropdowns so far in the book, so we won''t
    go into how to make them. We will simply make sure we have descriptive IDs for
    them, and I''ll leave it to you to fill in the blanks. As shown in the preceding
    screenshot, we have two sliders, one dropdown, and one graph component, so let''s
    set ID names for them. As usual, the following components should go wherever you
    want them to be in `app.layout`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们已经创建了许多滑块和下拉框，所以我们不会再讲解如何创建它们。我们只需要确保它们具有描述性的 ID，我将留给你填充空白。正如前面的截图所示，我们有两个滑块，一个下拉框和一个图形组件，因此我们需要为它们设置
    ID 名称。像往常一样，以下组件应该放置在 `app.layout` 中你想要的位置：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will now go through creating our callback function step by step, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将逐步介绍如何创建回调函数，如下所示：
- en: 'Associate the inputs and outputs in the callback, as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在回调函数中关联输入和输出，如下所示：
- en: '[PRE29]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create the signature of the function with suitable parameter names, as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有合适参数名称的函数签名，如下所示：
- en: '[PRE30]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Instantiate a missing values imputer, a standard scaler, and a `KMeans` object.
    Note that with `SimpleImputer`, we also specify how missing values are encoded.
    In this case, they are encoded as `np.nan`, but in other cases they might be encoded
    differently, such as `N/A`, `0`, `-1`, or others. The code is shown in the following
    snippet:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个缺失值填充器、一个标准化缩放器和一个 `KMeans` 对象。请注意，使用 `SimpleImputer` 时，我们还指定了缺失值的编码方式。在本例中，缺失值编码为
    `np.nan`，但在其他情况下，可能会使用不同的编码方式，比如 `N/A`、`0`、`-1` 或其他。代码如下所示：
- en: '[PRE31]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create `df`, a subset of `poverty` that has only country''s data and data from
    the selected year, and then select the `year` and `Country Name` columns, and
    the selected indicators. The code is shown in the following snippet:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`df`，它是`poverty`的一个子集，仅包含国家数据和所选年份的数据，然后选择`year`和`Country Name`列，以及所选指标。代码如下所示：
- en: '[PRE32]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create `data`, a subset of `df` that only contains the selected indicators''
    columns. The reason we have two distinct objects is that `df` is going to be used
    for plotting the map and will also use the year and country name. At the same
    time, `data` will only contain numeric values in order for our models to work
    with it. The code can be seen here:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`data`，它是`df`的一个子集，仅包含所选指标的列。我们有两个不同的对象是因为`df`将用于绘制地图，并且还会使用年份和国家名称。同时，`data`仅包含数值，以便我们的模型能够处理它。代码如下所示：
- en: '[PRE33]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In some cases, as we saw several times in the book, we might come across a
    situation where we have a column that is completely empty. In this case, we can''t
    impute any missing values because we don''t have a mean, and we have absolutely
    no clue what to do with it. In this case, I think it''s best to not produce a
    chart and inform the user that for the selected combination of options, there
    is not enough data to run the models. We first check if we have such a situation.
    DataFrame objects have an `isna` method. When we run it, it returns the same DataFrame
    filled with `True` and `False` values, indicating whether or not the respective
    value is missing. We then run the `all` method on the resulting DataFrame. This
    will tell us if all values are missing for each column. Now, we have a pandas
    Series with `True` and `False` values. We check if any of them is `True` by using
    the `any` method. In this case, we create an empty chart with an informative title,
    as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某些情况下，正如我们在书中多次看到的，我们可能会遇到某一列完全为空的情况。在这种情况下，我们无法填充任何缺失值，因为没有均值，并且我们完全不知道该如何处理它。在这种情况下，我认为最好的做法是不要生成图表，并告知用户，对于所选的选项组合，数据不足以运行模型。我们首先检查是否存在这种情况。DataFrame对象有一个`isna`方法。当我们运行它时，它会返回一个填充了`True`和`False`值的DataFrame，表示相应的值是否缺失。然后，我们对结果DataFrame运行`all`方法。这将告诉我们每列是否所有值都缺失。现在，我们有一个包含`True`和`False`值的pandas
    Series。我们通过使用`any`方法检查其中是否有`True`。在这种情况下，我们创建一个空的图表，并附上说明性标题，如下所示：
- en: '[PRE34]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If everything went fine, and we don''t have a column with all its values missing,
    we proceed by creating a variable that has no missing values (imputed if some
    are missing), as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，且我们没有一个列的所有值都缺失，我们继续创建一个没有缺失值的变量（如果有缺失值，则进行填充），如下所示：
- en: '[PRE35]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we scale `data_no_na` using our instance of `StandardScaler`, like this:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`StandardScaler`实例对`data_no_na`进行标准化，如下所示：
- en: '[PRE36]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we fit the model to our scaled data, as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将模型拟合到我们的标准化数据，如下所示：
- en: '[PRE37]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We now have everything we need to produce our chart—most importantly, the `labels_`
    attribute—and we can do so with a single call to `px.choropleth`. There is nothing
    new in the options we use in this function, as you can observe in the following
    code snippet:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在拥有生成图表所需的一切——最重要的是`labels_`属性——并且我们可以通过一次调用`px.choropleth`来生成图表。正如你在下面的代码片段中看到的，我们在此函数中使用的选项没有任何新内容：
- en: '[PRE38]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After that, we copy the geographic attributes we already used to customize the
    map and make it consistent with the app as a whole.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们复制已经用于自定义地图的地理属性，并使其与应用程序整体保持一致。
- en: 'Here is the full function, including the geographic options for your reference:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的函数，包括地理选项，供你参考：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We have made a big jump in this chapter in what can be visualized and interactively
    explored. We also got a minimal introduction to a single machine learning technique
    to cluster our data. Ideally, the options provided to your users will depend on
    the discipline you are working in. You might be an expert yourself in the domain
    you are dealing with, or you might work closely with such an expert. It is not
    only a matter of visualization and statistics, but domain knowledge is also a
    crucial aspect of analyzing data, and with machine learning this is critical.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们在可视化和交互探索方面取得了很大的进展。我们还简要介绍了一种机器学习技术，用于对我们的数据进行聚类。理想情况下，提供给用户的选项将取决于你所从事的学科。你可能自己是处理领域的专家，或者你可能与这样的专家密切合作。这不仅仅是可视化和统计的问题，领域知识也是分析数据的关键方面，尤其在机器学习中，这一点至关重要。
- en: I encourage you to learn more and see what you can achieve. Having the skills
    to create interactive dashboards is a big advantage for running machine learning
    models, as we saw, and allows you to discover trends and make decisions at a much
    faster rate. Eventually, you will be able to create automated solutions that provide
    recommendations, or make certain decisions based on certain inputs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你进一步学习，看看你能取得什么成就。正如我们所看到的，掌握创建互动式仪表板的技能对运行机器学习模型是一个巨大的优势，它让你能够以更快的速度发现趋势并做出决策。最终，你将能够创建自动化解决方案，提供建议或基于特定输入做出决策。
- en: Let's now recap on what we learned in this chapter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下本章所学的内容。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We first got an idea of how clustering works. We built the simplest possible
    model for a tiny dataset. We ran the model a few times and evaluated the performance
    and outcomes for each of the numbers of clusters that we chose.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先了解了聚类是如何工作的。我们为一个小型数据集构建了最简单的模型。我们多次运行模型，并评估了每次选择不同聚类数量时的性能和结果。
- en: We then explored the elbow technique to evaluate different clusters and saw
    how we might discover the point of diminishing returns, where not much improvement
    is achieved by adding new clusters. With that knowledge, we used the same technique
    for clustering countries by a metric with which most of us are familiar and got
    firsthand experience in how it might work on real data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们探索了肘部法则来评估不同的聚类，并看到了如何发现收益递减点，在这个点之后，增加新的聚类不会带来显著的改进。通过这些知识，我们使用相同的技术根据一个大多数人都熟悉的指标对国家进行聚类，并亲身体验了它如何在真实数据上运作。
- en: After that, we planned an interactive KMeans app and explored two techniques
    for preparing data before running our model. We mainly explored imputing missing
    values and scaling data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们设计了一个互动式 KMeans 应用，并探索了在运行模型之前准备数据的两种技术。我们主要探讨了填补缺失值和数据标准化。
- en: This gave us enough knowledge to get our data in a suitable format for us to
    create our interactive app, which we did at the end of the chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了足够的知识，将数据整理成适合创建互动应用的格式，正如我们在本章末尾所做的那样。
- en: We next explored advanced features of Dash callbacks—most notably, pattern-matching
    callbacks. The callbacks we have run so far have been straightforward and fixed.
    Many times, we want to create more dynamic interfaces for our users. For example,
    based on the selection of a certain value in a dropdown, we might want to display
    a special type of chart or create another dropdown. We will explore how this works
    in the next chapter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了 Dash 回调的高级功能——最显著的是模式匹配回调。到目前为止，我们运行的回调都是直接且固定的。许多时候，我们希望为用户创建更动态的界面。例如，基于在下拉框中选择的某个值，我们可能希望显示一种特殊类型的图表或创建另一个下拉框。我们将在下一章探讨这种方式的工作原理。
