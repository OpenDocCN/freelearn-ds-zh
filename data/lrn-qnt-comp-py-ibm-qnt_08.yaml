- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Optimizing and Visualizing Quantum Circuits
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化和可视化量子电路
- en: In the previous chapter, you learned how to program with **Qiskit**, using both
    circuits and pulse schedules. We’ll continue with the topic of circuits in this
    chapter, specifically some new features that optimize and speed up the end-to-end
    process by reducing the overhead between the classical and quantum systems during
    heavy computation cycles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何使用**Qiskit**进行编程，包括电路和脉冲时序。在本章中，我们将继续探讨电路的话题，特别是通过减少在重计算周期中经典和量子系统之间的开销，来优化和加速端到端过程的一些新特性。
- en: Luckily, Qiskit provides plenty of features to allow us to do this with ease.
    Additionally, Qiskit provides a set of classes and features to optimize and enhance
    the visualizations of your circuits. Learning about these features will help optimize
    your circuit results and allow you to render the circuits in various styles and
    representations, such as a **directed acyclic graph** (**DAG**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Qiskit提供了大量功能，使我们能够轻松地做到这一点。此外，Qiskit还提供了一套类和功能，用于优化和增强电路的可视化。了解这些功能将有助于优化你的电路结果，并允许你以各种风格和表示方式渲染电路，例如**有向无环图**（**DAG**）。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍以下主题：
- en: Optimizing circuits using Preset Passmanager
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预设Passmanager优化电路
- en: Visualizing and enhancing circuit graphs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化和增强电路图
- en: After reading this chapter, you will be able to optimize your circuits by using
    various visual and programmatic representations of the backend systems and visualization
    tools. You’ll also have some insights into the various transpiler features available
    that help optimize the transpilation of your circuit for a given quantum backend
    system. You’ll have learned about **Preset Passmanagers** and how they can be
    leveraged to generate custom pass managers used to execute the circuit transformations
    inside the transpiler at varying optimization levels.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，你将能够通过使用后端系统的各种视觉和程序表示以及可视化工具来优化你的电路。你还将对可帮助优化电路针对特定量子后端系统的转换的各种转换器特性有所了解。你将学习到**预设Passmanagers**以及它们如何被利用来生成用于在转换器中执行电路转换的自定义pass
    managers，这些转换器在不同的优化级别上运行。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, it is expected that you are familiar with creating and executing
    quantum circuits on both a simulator and a quantum computer. Knowledge of quantum
    hardware, such as qubits and connectivity between qubits, is also recommended.
    You may also need to install **Graphviz**, **LaTeX**, and perhaps other dependencies
    in your Python development environment if indicated while running some cells.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们假设你已经熟悉在模拟器和量子计算机上创建和执行量子电路。了解量子硬件，如量子比特和量子比特之间的连接性，也是推荐的。如果你在运行某些单元格时需要，你可能还需要在Python开发环境中安装**Graphviz**、**LaTeX**以及可能的其他依赖项。
- en: 'Here is the full source code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本书中使用的完整源代码：[https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).
- en: Optimizing circuits using Preset Passmanager
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预设Passmanager优化电路
- en: We need to ensure that when a quantum circuit is mapped to the quantum system
    (transpiled), it is done in the most efficient and effective way. This includes
    things such as mapping each qubit to those on the quantum system with the least
    amount of noise affected by decoherence or any other noise source that could introduce
    errors to your results. To accomplish this, we will learn about the **Preset Passmanager**,
    its usage, and the various features it makes available for us to create and execute
    optimal circuits. By optimizing the execution of the circuit to match the topology
    of the quantum device, we reduce the noise and its effect on our results.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保当量子电路映射到量子系统（转换）时，是以最有效和最有效的方式进行。这包括将每个量子比特映射到量子系统上，以最小化由退相干或任何可能引入错误的其他噪声源影响的噪声。为了实现这一点，我们将学习**预设Passmanager**、其用法以及它为我们提供的各种功能，以创建和执行最优电路。通过将电路的执行与量子设备的拓扑结构相匹配，我们减少了噪声及其对我们结果的影响。
- en: In this section, we will learn about transforming a quantum circuit so that
    it is best matched to the quantum device. We will also learn how to optimize the
    circuit by using the layout optimizer. We will then learn about the backend configuration
    and its optimization, along with the pass manager and passes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何将量子电路转换为与量子设备最佳匹配的形式。我们还将学习如何通过使用布局优化器来优化电路。然后我们将了解后端配置及其优化，以及传递管理器和传递。
- en: Transpiling a quantum circuit
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译量子电路
- en: When you create a circuit and run it on a quantum device, there are many things
    that occur between the time you send the circuit to be executed on the quantum
    device and the time the results are returned. We looked at a few of those steps
    when we discussed Qiskit Runtime in *Chapter 7*, *Programming with Qiskit*. In
    this chapter, we will look at the various features included in Qiskit Runtime,
    including those introduced in the latest version of Qiskit 1.0\. First, let’s
    look at a basic overview of just a few of the processes that occur when transpiling
    a circuit.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在量子设备上创建一个电路并运行它时，在你将电路发送到量子设备执行和结果返回之间，会发生很多事情。在我们讨论 *第 7 章*，*使用 Qiskit 编程*
    中的 Qiskit 运行时的时候，我们查看了一些那些步骤。在本章中，我们将查看 Qiskit 运行时包含的各种功能，包括在 Qiskit 1.0 最新版本中引入的功能。首先，让我们看看在编译电路时发生的一些基本过程概述。
- en: 'The following flowchart illustrates the general process in which the circuit
    is transpiled so that it can run on the specified backend and be optimized as
    per the provided settings:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的流程图说明了电路编译的一般过程，以便它可以在指定的后端上运行并根据提供的设置进行优化：
- en: '![Figure 9.2 – The transpiler process of a circuit from the initial circuit,
    with passes ](img/B18420_08_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 - 从初始电路到编译器过程的电路](img/B18420_08_01.png)'
- en: 'Figure 8.1: The transpiler process of a circuit from the initial circuit, with
    passes'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：从初始电路到编译器过程的电路，包含传递
- en: 'We’ll begin by introducing the general steps taken, as shown in the preceding
    flowchart, during the execution process:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从介绍执行过程中显示在前面流程图中的基本步骤开始：
- en: First, the transpiler will unroll the gates in the circuit down to the basis
    gates of the specified backend system.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编译器将电路中的门展开到指定后端系统的基门。
- en: Next, it will set the layout of the circuit to the device. One example of a
    layout is the *trivial layout* in which the circuit maps the qubits on your circuit
    to the same physical qubits on the quantum device. For example, qubit 0 on your
    circuit is mapped to the same qubit index, in this case, qubit 0 on the physical
    device.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它将电路布局设置为设备。布局的一个例子是*平凡布局*，其中电路将电路上的量子比特映射到量子设备上的相同物理量子比特。例如，你的电路上的量子比特
    0 映射到相同的量子比特索引，在这种情况下，物理设备上的量子比特 0。
- en: Next, it will map the circuit to the hardware topology. This is to ensure that
    the logic of your circuit is mapped onto the quantum hardware. For example, let’s
    say you have a CNOT that connects the control qubit to the target qubit. However,
    if there is not a direct connection between the control and target qubits, then
    the transpiler will add some SWAP gates to ensure that the connection between
    the two qubits is made by swapping information between qubits in between the control
    and target qubits.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它将电路映射到硬件拓扑。这是为了确保你的电路逻辑映射到量子硬件上。例如，假设你有一个连接控制量子比特到目标量子比特的 CNOT。然而，如果控制量子比特和目标量子比特之间没有直接连接，那么编译器将添加一些
    SWAP 门以确保通过在控制量子比特和目标量子比特之间交换量子比特之间的信息来建立两个量子比特之间的连接。
- en: Finally, the circuit mapping will be optimized to ensure that the circuit depth
    is contained to a minimum for the given quantum system. Steps 2 and 3 can be mapped
    to any combination of qubits on the physical device; as you can imagine, finding
    the right combination of qubits to use that reduces the depth of the circuit is
    very difficult. Thankfully, the transpiler handles this for us.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，电路映射将被优化以确保对于给定的量子系统，电路深度被限制在最小值。步骤 2 和 3 可以映射到物理设备上的任意组合的量子比特；正如你可以想象的那样，找到正确的量子比特组合以减少电路深度是非常困难的。幸运的是，编译器为我们处理了这一点。
- en: 'The transpiler is made up of two primary components – that is, the **pass**
    and the **pass manager**:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器由两个主要组件组成——即**传递**和**传递管理器**：
- en: 'A transpiler **pass** is the component that transforms the circuit from its
    current state into a new state. For example, some passes mentioned in the previous
    steps are focused on layout selection, routing, optimizations, circuit analysis,
    and many others. To see an exhaustive list of available passes, you can run the
    following:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: transpiler的**pass**是转换电路从当前状态到新状态的组件。例如，前述步骤中提到的某些pass专注于布局选择、布线、优化、电路分析等。要查看所有可用pass的详尽列表，您可以运行以下命令：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code will list all the passes available. For a detailed description
    of Pass Manager, I recommend reviewing the API documentation under `qiskit.transpiler.PassManager`.
    To ensure you have the latest code information, check the main API documentation
    page found here: [https://docs.quantum.ibm.com/api/qiskit/transpiler](https://docs.quantum.ibm.com/api/qiskit/transpiler).'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将列出所有可用的pass。要详细了解Pass Manager，我建议您查看`qiskit.transpiler.PassManager`下的API文档。为确保您拥有最新的代码信息，请检查以下主API文档页面：[https://docs.quantum.ibm.com/api/qiskit/transpiler](https://docs.quantum.ibm.com/api/qiskit/transpiler)。
- en: 'Additional examples can also be found in the guide here: [https://docs.quantum.ibm.com/guides/transpile](https://docs.quantum.ibm.com/guides/transpile).'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还可以在以下指南中找到更多示例：[https://docs.quantum.ibm.com/guides/transpile](https://docs.quantum.ibm.com/guides/transpile)。
- en: The **pass manager** is the component that is available to you to specify which
    passes you wish to use. The pass manager also allows the passes themselves to
    communicate with other passes. This is ideal for scenarios where one pass would
    provide or obtain information from other passes to ensure the final circuit adheres
    to any configuration or optimization requirements. The pass manager also has some
    preset passes that it makes available to simplify the optimization of a circuit.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pass manager**是您可以用来指定希望使用的pass的组件。pass manager还允许pass之间相互通信。这在一种pass需要从其他pass提供或获取信息以确保最终电路符合任何配置或优化要求的情况下是理想的。pass
    manager还有一些预设的pass，它使电路优化简化。'
- en: Generating preset passmanagers
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成预设的passmanagers
- en: To ease the use of these passes and passmanagers, Qiskit comes with a few pre-built
    transpilation pipelines (four at the time of this writing). Each can be found
    in the `qiskit.transpiler.preset_passmanagers` module. These pre-built preset
    pass managers are based on the optimization level selected. These four are currently
    numbered from 0 to 3\. Generating these is also simplified by using the `generate_preset_pass_manager()`
    function. The preset pass managers are the default pass managers used by the `transpile()`
    function, which constructs a standalone passmanager that mirrors the `transpile()`
    function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这些pass和passmanagers的使用，Qiskit提供了一些预构建的转换管道（在撰写本文时共有四个）。每个都可以在`qiskit.transpiler.preset_passmanagers`模块中找到。这些预构建的预设pass
    manager基于选定的优化级别。这四个目前编号为0到3。使用`generate_preset_pass_manager()`函数生成这些pass manager也简化了。预设pass
    manager是`transpile()`函数使用的默认pass manager，该函数构建一个与`transpile()`函数相对应的独立passmanager。
- en: In the following section, we will create a simple circuit and transpile it by
    using the preset passmanager generator, which leverages existing preset pass manager
    pipelines. We’ll also run the same circuit with two different optimization levels
    to see how the resulting circuit differentiates between the two. Finally, we will
    create a custom topology to transpile the circuit and compare the results of that
    to a circuit created via the preset optimizer. This will illustrate the consequences
    of selecting a layout that has not been optimized.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将创建一个简单的电路，并使用预设的passmanager生成器对其进行转换，该生成器利用现有的预设pass manager管道。我们还将使用两个不同的优化级别运行相同的电路，以查看生成的电路如何区分这两种情况。最后，我们将创建一个自定义拓扑来转换电路，并将该结果与通过预设优化器创建的电路进行比较。这将说明选择未经优化的布局所带来的后果。
- en: Comparing circuit mappings on different backend devices
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较不同后端设备上的电路映射
- en: 'To visualize information on the backend, we learned earlier that we can call
    the configuration and properties functions to output all the information. That
    can be handy if we want to extract specific data from the results; however, it
    is quite difficult to read. This is where the visualization tool comes in very
    handy. Let’s first pick two backend systems to compare. In this example, I’ll
    choose `ibm_brisbane`, and `ibm_nazca`, but you can select whichever quantum device
    you have available by running the `service.backends()` to get a list of available
    devices:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在后端可视化信息，我们之前了解到可以通过调用配置和属性函数来输出所有信息。如果我们想从结果中提取特定数据，这可能会很有用；然而，阅读起来相当困难。这就是可视化工具大显身手的地方。让我们首先挑选两个后端系统进行比较。在这个例子中，我将选择`ibm_brisbane`和`ibm_nazca`，但你可以通过运行`service.backends()`来获取可用设备列表，以选择你拥有的任何量子设备：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have selected both backend views, let’s look at a visual representation
    of the gates and how they are physically connected using the coupling map. You
    can see the coupling map by calling the `plot_gate_map` visualization function
    as illustrated in the following code snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了两个后端视图，让我们看看使用耦合图来表示门和它们如何通过耦合连接的物理连接的视觉表示。你可以通过调用以下代码片段中所示的`plot_gate_map`可视化函数来查看耦合图：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will print out the full connection map of all the qubits for the specified
    backend, as shown in the following figure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出指定后端所有量子比特的完整连接图，如图下所示：
- en: '![](img/B18420_08_02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_08_02.png)'
- en: 'Figure 8.2: Cropped view of the ibm_brisbane connection map'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：ibm_brisbane连接图的裁剪视图
- en: 'In *Figure 8.2*, with `ibm_brisbane` (we’ll refer to this backend device as
    `Brisbane` moving forward for simplicity), we can see that not only is it a 127-qubit
    device (cropped so it is easier to read), but also the qubits are connected in
    a heavy-hex formation. You can find details about this here: [https://www.ibm.com/quantum/blog/heavy-hex-lattice](https://www.ibm.com/quantum/blog/heavy-hex-lattice).
    Due to the size of the processor, some of the qubit numbers are not clear, so
    you may need to zoom in to view these up close. Also, note that signals can travel
    in both directions between each qubit via the connections.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.2*中，使用`ibm_brisbane`（我们将从现在开始将这个后端设备称为`Brisbane`以简化说明），我们可以看到它不仅是一个127量子比特的设备（裁剪以便更容易阅读），而且量子比特以重六边形的形式连接。你可以在这里找到有关此信息的详细信息：[https://www.ibm.com/quantum/blog/heavy-hex-lattice](https://www.ibm.com/quantum/blog/heavy-hex-lattice)。由于处理器的尺寸，一些量子比特的编号可能不清楚，因此你可能需要放大以近距离查看这些内容。此外，请注意，信号可以通过连接在各个量子比特之间双向传输。
- en: 'Let’s now visualize the coupling directional map of `ibm_nazca`, hereafter
    referred to as just Nazca. Run the following cell:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们可视化`ibm_nazca`的耦合方向图，之后我们将仅称为Nazca。运行以下单元格：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can see the gate map with the coupling directional mapping between
    each qubit, as illustrated here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到带有每个量子比特之间耦合方向映射的门图，如图所示：
- en: '![A grid of numbers and letters  Description automatically generated](img/B18420_08_03.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![一个数字和字母的网格  自动生成的描述](img/B18420_08_03.png)'
- en: 'Figure 8.3: Qubit plot view with the coupling directional map enabled (ibm_nazca)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：启用耦合方向图的量子比特图视图（ibm_nazca）
- en: You may notice that the coupling maps have some similarities between the two
    systems.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到耦合图在这两个系统之间有一些相似之处。
- en: Because of the different configurations of the qubits, the layout of the qubits
    from the quantum circuit we created might not be defined in the most optimal way
    when mapping the qubits on the quantum circuit to the qubits on the hardware device.
    Luckily for us, we have transpilation features, which include a parameter setting
    that allows us to set the level of optimization of the circuit layout. The next
    section will cover the various passes available, and the pass manager used to
    manage their usage.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于量子比特的不同配置，当我们把量子电路上的量子比特映射到硬件设备上的量子比特时，我们创建的量子电路中量子比特的布局可能不是最优的。幸运的是，我们有编译功能，其中包括一个参数设置，允许我们设置电路布局的优化级别。下一节将介绍可用的各种传递，以及用于管理它们使用的传递管理器。
- en: Understanding passes and pass managers
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解传递和传递管理器
- en: 'Passes are generally used to transform circuits so that they are set up to
    perform as optimally as desired. There are five general types of passes that transform
    circuits:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 传递通常用于转换电路，以便它们能够以最佳方式运行。有五种通用的传递类型可以转换电路：
- en: '**Layout selection** determines how the qubit layout mapping will align with
    the selected backend configuration.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局选择**确定量子位布局映射如何与所选的后端配置对齐。'
- en: '**Routing** maps the placement of SWAP gates onto the circuit based on the
    selected swap mapping type, which can be set by providing a coupling map or backend
    topology, or by using stochastic methods, where the system will not assume the
    input state to the circuit is the ground/zero state to simplify the circuit.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**根据所选的交换映射类型将SWAP门的位置映射到电路中，这可以通过提供耦合图或后端拓扑结构来设置，或者通过使用随机方法来实现，在这种方法中，系统不会假设电路的输入状态是基态/零态，以简化电路。'
- en: '**Basis change** offers various ways to decompose, or unroll, the gates down
    to the basis gates of the backend or using the circuit’s decomposition rules.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基变换**提供各种方法来分解或展开门，直到后端的基础门或使用电路的分解规则。'
- en: '**Optimizations** optimize the circuits themselves by removing redundant gates,
    such as having two of the same reversible gates, such as a Hadamard gate, back
    to back, which reverts the qubit to the original state.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化**通过移除冗余门（例如，将两个相同的可逆门，如Hadamard门，连续放置，从而将量子位恢复到原始状态）来优化电路本身。'
- en: '**Circuit analysis** provides circuit information, such as the depth, width,
    number of operations, and other details about the circuit.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电路分析**提供电路信息，例如深度、宽度、操作数量以及有关电路的其他细节。'
- en: '**Additional passes** are those that offer some other form of optimization,
    such as the various **check maps**, which check whether the layout of the CNOT
    gates is in the direction stated in the coupling maps and rearrange the directions
    if needed.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**附加过程**是那些提供某种其他形式的优化，例如各种**检查映射**，这些映射检查CNOT门的布局是否与耦合图中声明的方向一致，并在必要时重新排列方向。'
- en: We covered most of the **circuit analysis** information in *Chapter 7*, *Programming
    with Qiskit*, to detect the size, width, and number of operations in a circuit.
    Let’s look at the first pass type, Layout Selection, to see how we can leverage
    the provided layouts and learn the difference between the various optimization
    levels.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第7章*，*使用Qiskit编程*中涵盖了大多数**电路分析**信息，以检测电路的大小、宽度和操作数量。让我们看看第一种过程类型，布局选择，看看我们如何利用提供的布局并了解不同优化级别之间的差异。
- en: Learning about the Layout Selection type
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解布局选择类型
- en: 'Let’s dig down into one of these types of passes to get a little more detail.
    Since we must map the qubits from the circuit to the specified hardware each time,
    and we want to execute our circuit on a quantum system, we’ll view the layout
    pass. There are various layout passes to choose from when you want to map the
    qubits to the physical device. Reasons for this could include wanting your qubits
    to be as close as possible to avoid having multiple SWAP gates, or if you are
    working on error correction or mitigation, then you may want to map your gates
    exactly to the physical qubits to ensure your experiments are consistent. Let’s
    look at a few of the basic layout options:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这些类型之一，以获取更多细节。由于我们必须每次将量子位从电路映射到指定的硬件，并且我们希望在量子系统上执行我们的电路，我们将查看布局过程。当您想要将量子位映射到物理设备时，可以选择各种布局过程。这样做的原因可能包括希望您的量子位尽可能靠近以避免有多个SWAP门，或者如果您正在从事错误纠正或缓解工作，那么您可能希望将您的门精确映射到物理量子位上，以确保您的实验是一致的。让我们看看一些基本的布局选项：
- en: '`TrivialLayout`: This layout assigns the circuit qubits to the physical device’s
    qubits in the same order as stated in the original quantum circuit. So, qubit
    0 is mapped directly to qubit 0 on the physical device.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TrivialLayout`：这种布局将电路量子位按原量子电路中声明的顺序分配给物理设备的量子位。因此，量子位0直接映射到物理设备上的量子位0。'
- en: '`DenseLayout`: This layout selects the layout that has the most connected subset
    of qubits. If there is a need for many entangled qubits, this layout will find
    a subset in which qubits are closely connected to each other so as to avoid long
    distances and swaps.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DenseLayout`：这种布局选择具有最多连接量子位子集的布局。如果需要许多纠缠量子位，这种布局将找到一个量子位彼此紧密连接的子集，以避免长距离和交换。'
- en: '`Sabre`: This layout leverages a qubit mapping technique that looks at the
    reversibility of the quantum circuit where it will try to interpret the global
    circuit information to choose the optimal initial layout.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sabre`：这种布局利用一种量子位映射技术，它查看量子电路的可逆性，它将尝试解释全局电路信息以选择最佳初始布局。'
- en: For each of the passes described above, there is a different default setting
    for the optimization level of the transpiler. The optimization level is comprised
    of 4 levels that range from 0 to 3, which specifies whether to not optimize the
    circuit at all (level 0) up to full optimization (level 3). The higher the optimization
    level, the more optimized the resulting circuit will be; however, it will of course
    require a bit more time to run.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述描述的每个传递，转换器的优化级别都有一个不同的默认设置。优化级别由4个级别组成，范围从0到3，指定是否完全不优化电路（级别0）到完全优化（级别3）。优化级别越高，生成的电路就越优化；然而，当然需要更多的时间来运行。
- en: In this section, you will learn how to apply and differentiate between each
    level.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何应用和区分每个级别。
- en: Applying default layouts
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用默认布局
- en: 'Let’s start with the default layouts. We’ll set the various optimization levels
    in the transpiler function parameter and apply it to the two backend devices,
    `Brisbane` and `Nazca`, in the following steps. One thing to keep in mind is that
    at the time of writing, all systems available have the same connectivity between
    qubits and very similar properties. However, by the time this book is published,
    there will be varying systems with varying properties, so even though the results
    here might look the same, the results you see (if the systems you are comparing
    are different) will vary:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从默认布局开始。我们将在transpiler函数参数中设置各种优化级别，并在以下步骤中将它应用于两个后端设备，`Brisbane`和`Nazca`。需要注意的是，在撰写本文时，所有可用的系统在量子比特之间都有相同的连接性，并且具有非常相似的性质。然而，到本书出版时，将会有具有不同性质的系统，因此，尽管这里的结果可能看起来相同，但您看到的结果（如果您比较的系统不同）可能会有所不同：
- en: 'We’ll reuse the same four-qubit quantum circuit we created earlier. I’ll include
    it again here for your convenience:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重用之前创建的相同的四量子比特量子电路。我将再次包括它，以便于您的使用：
- en: '[PRE4]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will result in our basic circuit where each of the 4 qubits is entangled
    via the CX gates to the first qubit, q[0].
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致我们的基本电路，其中每个4个量子比特都通过CX门与第一个量子比特，q[0]纠缠。
- en: We’ll start with `Brisbane` and set the optimization level to `0`, which is
    to say we will not use any optimization techniques on the circuit. What this will
    result in is the qubit on our quantum circuit `[0,1,2,3]`, which will map to the
    same qubit index values on the backend device, `Brisbane [0,1,2,…,126]`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`Brisbane`开始，将优化级别设置为`0`，这意味着我们不会在电路中使用任何优化技术。这将导致我们量子电路中的量子比特 `[0,1,2,3]`
    映射到后端设备`Brisbane [0,1,2,…,126]`上的相同的量子比特索引值。
- en: 'In the following code, we will leverage the `qc` circuit and use it to test
    the various optimization levels. We’ll then print out the transpiled circuit depth
    and visualize the layout with the mapped qubits drawn as an overlay over the backend
    device. This will illustrate how the different methods are applied to the backend
    device:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将利用`qc`电路，并使用它来测试各种优化级别。然后我们将打印出转换后的电路深度，并使用映射的量子比特作为叠加在后台设备上的覆盖来可视化布局。这将说明不同的方法是如何应用于后台设备的：
- en: Note that your results might be different due to the stochastic parts of the
    transpiler. So, whatever result you get is the optimal result at the time of execution.
    To ensure you get the same results, you will need to set the `seed_transpiler`
    parameter of the `transpiler()` function to a random integer value.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，由于转换器的随机部分，您得到的结果可能会有所不同。因此，无论您得到什么结果，都是执行时的最佳结果。为了确保您得到相同的结果，您需要将`transpiler()`函数的`seed_transpiler`参数设置为一个随机整数值。
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result, as follows, is as expected, where the qubits are mapped with no
    layout optimization at all, and there is the direct mapping of qubits from the
    quantum circuit to the hardware device. Note also that the depth is `6464`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下，正如预期的那样，其中量子比特没有进行布局优化，并且量子电路到硬件设备的量子比特有直接的映射。请注意，深度为`6464`：
- en: '![A blue lines with black dots  Description automatically generated](img/B18420_08_04.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![一条带有黑色点的蓝色线条  自动生成的描述](img/B18420_08_04.png)'
- en: 'Figure 8.4: Transpiled quantum circuit on Brisbane with optimization = 0; direct
    qubit mapping with no changes'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：优化级别为0的Brisbane上的转换量子电路；直接量子比特映射，无变化
- en: 'Now, let’s draw the transpiled circuit on `Brisbane`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`Brisbane`上绘制转换后的电路：
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will render the transpiled circuit using the basis gates available on `Brisbane`;
    it has been truncated in the following figure to save space.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`Brisbane`上可用的基门渲染转换后的电路；以下图中的电路已被截断以节省空间。
- en: '![A diagram of a mathematical equation  Description automatically generated
    with medium confidence](img/B18420_08_05.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![一个数学方程的图，描述自动生成，置信度中等](img/B18420_08_05.png)'
- en: 'Figure 8.5: Transpiled circuit of basis gates on Brisbane'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：在Brisbane上的基本门编译电路
- en: Please note that the unused qubits are not visible due to our use of the `idle_wires=False`
    parameter when calling the `circuit_drawer()` function. If we remove this parameter,
    you will see all qubits, even those that are not in use. Also note that the qubit
    mappings are depicted on the left side of the circuit diagram where the circuit
    mapping is pointing to the physical device’s qubit. In the previous figure, we
    can see that from the circuit, q[0] maps to the 0^(th) qubit on the physical device
    (as shown by the indicator q[0] -> 0).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们在调用`circuit_drawer()`函数时使用了`idle_wires=False`参数，因此未使用的量子比特不可见。如果我们移除此参数，你将看到所有量子比特，即使那些未使用的量子比特。此外，请注意，量子比特映射在电路图的左侧表示，其中电路映射指向物理设备的量子比特。在前面的图中，我们可以看到从电路中，q[0]映射到物理设备上的0^(th)量子比特（如指示器q[0]
    -> 0所示）。
- en: 'Now, let’s run the same thing on `Nazca` with the same level of optimization
    set to `0`. We should see the same results, in that the transpiled circuit is
    mapped to the same qubits as our quantum circuit:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`Nazca`上以相同的优化级别设置为`0`运行相同的内容。我们应该看到相同的结果，即编译电路映射到与我们的量子电路相同的量子比特：
- en: '[PRE7]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code will result in the following depth information:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下深度信息：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The resulting layout mapping, as follows, is also displayed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，结果布局映射也显示出来：
- en: '![A blue lines with black dots  Description automatically generated](img/B18420_08_06.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![蓝色线条带有黑色圆点，描述自动生成](img/B18420_08_06.png)'
- en: 'Figure 8.6: Transpiled circuit on Nazca'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：在Nazca上的编译电路
- en: Let’s now look at the transpiled circuit for the `Nazca` quantum device.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Nazca`量子设备的编译电路。
- en: 'We’ll now draw the transpiled circuit using the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将使用以下代码绘制编译电路：
- en: '[PRE9]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code will display the following circuit:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将显示以下电路：
- en: '![A line of blue squares with black lines  Description automatically generated](img/B18420_08_07.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![一行蓝色方块，带有黑色线条，描述自动生成](img/B18420_08_07.png)'
- en: 'Figure 8.7: Transpiled circuit on Nazca'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：在Nazca上的编译电路
- en: One thing to note is the set of multi-qubit gates between q[0] and q[1] after
    the first set of single-qubit gates. These multi-qubit gates can be used to create
    a CNOT, SWAP, or ROTX gate, represented by the red block labeled **Ecr**. This
    routing of information between qubits is the result of the routing pass, which
    looks for the most optimal connection between qubits. The following figure shows
    the decomposed SWAP gate.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在第一组单量子比特门之后，q[0]和q[1]之间的多量子比特门集合。这些多量子比特门可以用来创建一个CNOT、SWAP或ROTX门，由标记为**Ecr**的红色方块表示。这种量子比特之间的信息路由是路由传递的结果，它寻找量子比特之间最优化连接。下图显示了分解后的SWAP门。
- en: '![A picture containing text, clock  Description automatically generated](img/B18420_08_08.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本和时钟的图片，描述自动生成](img/B18420_08_08.png)'
- en: 'Figure 8.8: SWAP gate decomposed'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：SWAP门分解
- en: 'Let’s now maximize the optimization level to `3`, which performs the highest
    optimization of the quantum circuit:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将优化级别最大化到`3`，这将对量子电路进行最高优化：
- en: '[PRE10]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code will print out the total circuit depth and the total number
    of operators (`Ops count`) in the transpiled circuit, along with the rendering
    of the transpiled mapping of the qubits onto `Brisbane`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在编译电路中打印出总电路深度和操作符总数（`Ops count`），以及量子比特映射到`Brisbane`的渲染。
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, you’ll notice some gates you might not have seen before; you can find
    details about each gate in the circuit library on the Qiskit API documentation
    page here: [https://docs.quantum-computing.ibm.com/api/qiskit/circuit_library](https://docs.quantum-computing.ibm.com/api/qiskit/circuit_library).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你会注意到一些你可能之前没有见过的门；你可以在Qiskit API文档页面上的电路库中找到每个门的详细信息：[https://docs.quantum-computing.ibm.com/api/qiskit/circuit_library](https://docs.quantum-computing.ibm.com/api/qiskit/circuit_library)。
- en: 'The following diagram shows the rendering of the transpiled mapping of the
    qubits, as mentioned earlier:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了之前提到的量子比特映射的渲染：
- en: '![A diagram of a network  Description automatically generated](img/B18420_08_09.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![一个网络图，描述自动生成](img/B18420_08_09.png)'
- en: 'Figure 8.9: Transpiled circuit with the optimization level set to 3 for Brisbane'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：将优化级别设置为3的Brisbane编译电路
- en: As you can see in the preceding diagram, to optimize the quantum circuit, the
    qubit order is adjusted from the previous example on `Brisbane`. This is due to
    the `optimization_level` parameter being set to 3 (highest), which includes mapping
    to the most optimal qubits. This also highlights the difference in circuit depth
    between the two.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在先前的图中所见，为了优化量子电路，量子位顺序从`Brisbane`上的先前的示例中调整。这是由于将`optimization_level`参数设置为3（最高），它包括映射到最优化量子位。这也突出了两个电路深度之间的差异。
- en: 'Let’s now draw the transpiled circuit to review the circuit layout to the backend:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们绘制编译后的电路，以审查电路布局到后端：
- en: '[PRE12]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result, as follows, is the same circuit that is now mapped to different
    qubits compared to the circuit in *Figure 8.6*. The difference between this circuit
    and the previous one is simply that the transpiler has the maximum optimization
    level set, so it will map the qubit operators to the most optimal qubits. For
    example, here we see qubit 0 is mapped to qubit 4, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，如下所示，是与*图8.6*中的电路相同的电路，但现在映射到不同的量子位上。这个电路与上一个电路的不同之处仅仅在于，编译器将最大优化级别设置为，因此它将量子位操作符映射到最优化量子位上。例如，我们可以看到量子位0被映射到量子位4，如下所示：
- en: '![A diagram of a circuit  Description automatically generated](img/B18420_08_10.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![电路图  自动生成的描述](img/B18420_08_10.png)'
- en: 'Figure 8.10: Transpiled circuit with the optimization level set to 3'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：将优化级别设置为3的编译电路
- en: 'We’ll set the same optimization level on `Nazca` to `3` and then transpile
    the circuit:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`Nazca`上设置相同的优化级别为`3`，然后编译电路：
- en: '[PRE13]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, the total depth is the same, as is the number and type of operators:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，总深度相同，操作符的数量和类型也相同：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, note that the layout is not necessarily linear; it seems *T-shaped*,
    where qubit 0 is connected to 3 qubits, like that of `Brisbane`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意布局不一定是线性的；它看起来像**T形**，其中量子位0连接到3个量子位，就像`Brisbane`那样：
- en: '![A grid with dots and lines  Description automatically generated](img/B18420_08_11.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![带有点和线的网格  自动生成的描述](img/B18420_08_11.png)'
- en: 'Figure 8.11: Transpiled circuit with the optimization level set to 3'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：将优化级别设置为3的编译电路
- en: As you can see, to optimize the circuit depth and reduce noise, the qubit order
    is reversed from the previous example run on `Nazca`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为了优化电路深度并减少噪声，量子位顺序与在`Nazca`上运行的先前的示例相反。
- en: 'Let’s draw the circuit using the transpiled circuit and see how this mapping
    looks compared to the previous circuit mapping:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用编译后的电路绘制电路，看看这种映射与先前的电路映射相比如何：
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![A diagram of a mathematical equation  Description automatically generated
    with medium confidence](img/B18420_08_12.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![数学方程的图  使用中等置信度自动生成的描述](img/B18420_08_12.png)'
- en: 'Figure 8.12: Transpiled circuit with the optimization level set to 3'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：将优化级别设置为3的编译电路
- en: Note the use of qubit **0**, now qubit **44** on the hardware, which was mapped
    as the qubit on which to base the connections to the other qubits, **0**, **3**,
    and **2** in the ECR at the end of the circuit. This is a good example, where
    the optimizer mapped the ECR gates to the physical qubits, for example, qubit
    **45** to qubits **44**, **46**, and **54** on the device, to optimize based on
    other passes used besides the routing pass. One reason for this case could be
    that one of the passes considered the coherence time (relaxation time, T1) of
    the qubits, which is the time a qubit can maintain its quantum state, where the
    qubit with the longest coherence time, at the time the circuit was transpiled,
    is qubit `1`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用量子位**0**，现在硬件上的量子位**44**，它被映射为电路末尾ECR（环境控制反转）中连接到其他量子位**0**、**3**和**2**的量子位。这是一个很好的例子，其中优化器将ECR门映射到物理量子位上，例如，量子位**45**映射到设备上的量子位**44**、**46**和**54**，以优化除路由之外的其他传递。这种情况的一个原因可能是其中一个传递考虑了量子位的相干时间（弛豫时间，T1），这是量子位可以保持其量子状态的时间，在电路编译时，相干时间最长的量子位是量子位`1`。
- en: Applying custom layouts
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用自定义布局
- en: 'Finally, let’s now create our own custom mapping, or **topology**, as it is
    often referred to:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在让我们创建我们自己的自定义映射，或称为**拓扑**：
- en: 'Let’s begin by reviewing the coupling map of an existing device; in this case,
    let’s continue using `brisbane`, which has 127 qubits. We’ll review the configuration
    of the backend first:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先回顾现有设备的耦合图；在这种情况下，让我们继续使用具有127个量子位的`brisbane`，我们首先将审查后端的配置：
- en: '[PRE16]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code sets the backend so we can obtain the configuration and property
    values of the quantum device.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码设置了后端，以便我们可以获取量子设备的配置和属性值。
- en: 'Let’s examine the coupling map for `ibm_brisbane` by calling the backend configuration’s
    `coupling_map` field:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过调用后端配置的 `coupling_map` 字段来检查 `ibm_brisbane` 的耦合映射：
- en: '[PRE17]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code will result in displaying an array of the coupling layout
    of `ibm_brisbane`. You can verify this by comparing it to the backend view:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将导致显示 `ibm_brisbane` 的耦合布局数组。您可以通过将其与后端视图进行比较来验证这一点：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we will draw the coupling map to see how efficient our circuit is with
    the default map:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将绘制耦合映射，以查看默认映射下电路的效率：
- en: '[PRE19]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our circuit, using this topology, is now different from what we saw in `brisbane`
    in *Figure 8.10*. Here, we see that the same circuit is now transpiled based on
    earlier results of the `brisbane` topology, as follows (note that this can vary
    depending on the calibration of the system):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此拓扑，我们的电路现在与我们在 *图8.10* 中看到的 `brisbane` 不同。在这里，我们看到相同的电路现在基于 `brisbane` 拓扑的早期结果进行编译，如下所示（请注意，这可能会根据系统的校准而变化）：
- en: '![A diagram of a circuit  Description automatically generated](img/B18420_08_13.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![电路图](img/B18420_08_13.png) 描述自动生成'
- en: 'Figure 8.13: The custom circuit using the topology provided by the ibm_brisbane
    coupling map'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：使用ibm_brisbane耦合映射提供的拓扑的自定义电路
- en: Up to now, you have extracted the coupling map from existing backend systems,
    in this case, `ibm_brisbane`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，您已经从现有的后端系统中提取了耦合映射，在本例中为 `ibm_brisbane`。
- en: 'Now, let’s create our own custom topology. For simplicity, we will create a
    simple linear topology, where the qubits are joined together in a line, as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们自己的自定义拓扑。为了简单起见，我们将创建一个简单的线性拓扑，其中量子比特以直线形式连接，如下所示：
- en: '[PRE20]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The result from the preceding circuit code is clearly not ideal:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述电路代码的结果显然并不理想：
- en: '![A diagram of a diagram  Description automatically generated](img/B18420_08_14.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图解图](img/B18420_08_14.png) 描述自动生成'
- en: 'Figure 8.14: Custom linear topology of our circuit'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：我们电路的自定义线性拓扑
- en: The circuit requires many gates and is quite deep, which increases the risk
    of having noisy results. This is a good illustration of the importance of optimizers,
    which handle many of these potential issues. It’s no surprise that there is so
    much research in identifying better ways to optimize circuits to avoid inefficient
    and noisy circuits. However, having the ability to customize your own topology
    allows you to create optimal passes that could find unique and effective ways
    to optimize the mapping of circuits for testing and experimental purposes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 电路需要许多门，并且相当深，这增加了产生噪声结果的风险。这是优化器重要性的一个很好的说明，优化器处理了许多这些潜在问题。毫不奇怪，在寻找更好的方法来优化电路以避免低效和噪声电路方面，有如此多的研究。然而，拥有自定义拓扑的能力允许您创建最优通行，这可能找到独特和有效的方法来优化电路的映射，用于测试和实验目的。
- en: There are many passes that optimize the circuit (we’ve just covered the layouts
    as it is easy to see the differences). If you were to look at the full list of
    passes, you would see that if you change the order of the passes, it will change
    the results of the circuit when mapped to the physical device. To account for
    this, we need to look at the pass manager.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多通行可以优化电路（我们刚刚覆盖了布局，因为它很容易看出差异）。如果您查看通行的完整列表，您会看到，如果您更改通行的顺序，它将改变映射到物理设备时的电路结果。为了解决这个问题，我们需要查看通行管理器。
- en: Leveraging the pass manager
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用通行管理器
- en: 'The pass manager is what allows the passes to communicate with each other,
    schedules which passes should execute first, and allows for custom passes to be
    included in the list of passes. This is not as simple as it sounds, as there may
    be a significant difference if one pass is used before another or perhaps is unable
    to communicate with another pass. We’ll conclude this section with a simple example
    of the pass manager, using the following steps to create it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通行管理器允许通行之间进行通信，安排哪些通行应该首先执行，并允许将自定义通行包括在通行列表中。这并不像听起来那么简单，因为如果先使用一个通行然后再使用另一个，或者可能无法与其他通行通信，可能会有很大的差异。我们将通过以下步骤使用一个简单的例子来结束本节，创建通行管理器：
- en: 'We’ll first append `TrivialLayout` to `PassManager` and execute the circuit:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将 `TrivialLayout` 添加到 `PassManager` 并执行电路：
- en: '[PRE21]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The resulting circuit is as follows. Note the specifics of this circuit as
    we will be comparing the differences between the layouts of this circuit and the
    upcoming circuit (in *Figure 8.16*):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 结果电路如下。注意这个电路的细节，因为我们将会比较这个电路和即将到来的电路（*图8.16*）的布局差异：
- en: '![Figure 9.22 – PassManager with the appended TrivialLayout Pass circuit ](img/B18420_08_15.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图9.22 – 附加了TrivialLayout传递的PassManager电路](img/B18420_08_15.png)'
- en: 'Figure 8.15: PassManager with the appended TrivialLayout Pass circuit'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：附加了TrivialLayout传递的PassManager电路
- en: Soon we will explore the functionality of the pass manager using the routing
    pass type. We saw a little bit of this when the SWAP gates were added to connect
    qubits when they are not directly connected on the physical device. In the following
    steps, we will look at passes that optimize the routing of these SWAP gates.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很快我们将通过路由传递类型探索传递管理器的功能。当添加SWAP门来连接未直接连接在物理设备上的量子位时，我们看到了一些这方面的内容。在以下步骤中，我们将查看优化这些SWAP门路由的传递。
- en: 'In the following code, we will create a `BasicSwap` pass, rerun `PassManager`
    on the circuit, and compare the results to the previous circuit:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将创建一个`BasicSwap`传递，在电路上重新运行`PassManager`，并将结果与之前的电路进行比较：
- en: '[PRE22]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The previous code will create a `BasicSwap` router and add it to `PassManager`
    upon construction. The executed circuit result is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将在构造时创建一个`BasicSwap`路由器并将其添加到`PassManager`。执行后的电路结果如下：
- en: '![A diagram of a circuit  Description automatically generated](img/B18420_08_16.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![电路图  描述自动生成](img/B18420_08_16.png)'
- en: 'Figure 8.16: PassManager with a BasicSwap router pass circuit'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16：带有BasicSwap路由器传递的PassManager电路
- en: As you can see, the circuit will adapt to each of the passes called from `PassManager`
    – in this case, we added the `BasicSwap` pass to the PassManager in the code,
    which then rendered the circuit mapping in one form, whereas the `TrivialLayout`
    pass rendered in a different form. Doing this gives you the ability to order how
    the various passes are run during the optimization process of the PassManager.
    Having this ability provides you with options to test out, should you be researching
    ways to optimize how your circuit is mapped and run on a backend device.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，电路将适应从`PassManager`调用的每个传递过程 - 在这种情况下，我们在代码中将`BasicSwap`传递添加到`PassManager`中，然后以一种形式渲染了电路映射，而`TrivialLayout`传递则以不同的形式渲染。这样做可以让你在`PassManager`的优化过程中对各种传递的执行顺序进行排序。拥有这种能力为你提供了测试如何优化电路在后台设备上的映射和运行方式的方法。
- en: Let’s take a moment to digest what we’ve learned so far. When using the `optimization_level`
    option to execute our circuit on a backend, the PassManager uses the preset passes
    based on the specific level selected (i.e., 0, 1, 2, or 3). What we managed to
    do here is customize which passes to use and in what order, as we did when we
    added the BasicSwap pass to the previous code. Having this ability not only provides
    you with the flexibility to experiment with various sequences of passes, but you
    can also create your own pass and compare it with those existing passes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间消化一下我们到目前为止所学的内容。当使用`optimization_level`选项在后台执行我们的电路时，`PassManager`会根据所选的具体级别使用预设的传递（即，0、1、2或3）。我们在这里做到的是自定义要使用哪些传递以及它们的顺序，就像我们在之前的代码中添加BasicSwap传递时做的那样。拥有这种能力不仅为你提供了实验各种传递序列的灵活性，你还可以创建自己的传递并与现有的传递进行比较。
- en: Now that you are familiar with pass managers, you can see that they can be very
    helpful if you want to use a combination of passes in a way that, when leveraged
    one after the other, improves the optimization of the circuit as it is modified
    along the way.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了传递管理器，你可以看到，如果你想以某种方式组合使用传递，从而在修改过程中提高电路的优化，它们可以非常有帮助。
- en: In this section, we also learned about the transpiler and how it provides ways
    to optimize circuits. We also learned about transforming and optimizing the circuit
    using the layout optimizer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还学习了编译器以及它如何提供优化电路的方法。我们还学习了使用布局优化器转换和优化电路。
- en: The next section of this chapter is a bit more visual, by rendering the circuits
    in different styles and operational flows such as **DAGs**. These features provide
    a way to view the circuits and their functionality in a different form rather
    than the default view of the circuits, which is how we have seen them so far.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的下一段内容更加直观，通过以不同的样式和操作流程（如**DAGs**）渲染电路。这些功能提供了一种以不同形式查看电路及其功能的方法，而不是默认的电路视图，这是我们迄今为止所看到的方式。
- en: Visualizing and enhancing circuit graphs
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化和增强电路图
- en: This section will focus on the various visualizations available in Qiskit. The
    graphs we have been using so far were from the default visualization library in
    Qiskit. However, we can specify other drawing tools that may be better suited
    for your documentation purposes. Say, for example, that you are authoring a research
    paper with **LaTeX** and you want to use the LaTeX content.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点介绍Qiskit中可用的各种可视化。我们迄今为止所使用的图表来自Qiskit的默认可视化库。然而，我们可以指定其他更适合你文档目的的绘图工具。比如说，如果你正在编写一篇使用**LaTeX**的研究论文，并且想使用LaTeX内容。
- en: By simply adding style parameters from the Qiskit visualization library, you
    can then leverage the many features included with the visualization library. We’ll
    cover a few of those now to get you started.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地添加来自Qiskit可视化库的样式参数，然后你可以利用可视化库中包含的许多功能。我们现在将介绍其中的一些，以帮助你入门。
- en: Learning about customized visual circuits
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解定制可视化电路
- en: 'When rendering a circuit, it is often necessary or convenient to have the results
    in a format that suits the format of your document. It’s here where the Qiskit
    `circuit_drawer` comes in handy with various features. Let’s begin with a simple
    quantum circuit to illustrate the various visual rendering examples:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染电路时，通常需要或方便以适合你文档格式的格式呈现结果。这就是Qiskit的`circuit_drawer`功能派上用场的地方，它具有各种功能。让我们从一个简单的量子电路开始，以说明各种视觉渲染示例：
- en: 'First, let’s create a quantum circuit with various operators to get a good
    representation of all the visual components in the various formats:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个包含各种操作符的量子电路，以获得各种格式中所有视觉组件的良好表示：
- en: '[PRE23]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will render the following circuit drawing, which is just a random representation
    of gates. This circuit does not do anything special; it’s just used to represent
    various components. As an option, you can use the `random_circuit` method to create
    a random circuit:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染以下电路图，它只是门的一个随机表示。这个电路并没有做任何特别的事情；它只是用来表示各种组件。作为一个选项，你可以使用`random_circuit`方法来创建一个随机电路：
- en: '![Chart, line chart  Description automatically generated](img/B18420_08_17.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图表，折线图  自动生成的描述](img/B18420_08_17.png)'
- en: 'Figure 8.17: Circuit rendering using the default library'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：使用默认库进行电路渲染
- en: 'Next, we will render the preceding circuit using `latex`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`latex`渲染前面的电路：
- en: '[PRE24]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will render the `latex` version of the circuit:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染电路的`latex`版本：
- en: If you’re running this on your local machine and not on the platform, you may
    have some warnings or errors indicating you need to install some file dependencies,
    such as installing `pylatexenc`. To install this library you will need to run
    `pip install pylatexenc` in a cell first, and then restart the kernel.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个平台上运行的不是本地机器，你可能会收到一些警告或错误，表明你需要安装一些文件依赖项，例如安装`pylatexenc`。要安装这个库，你需要在单元格中首先运行`pip
    install pylatexenc`，然后重新启动内核。
- en: '![Diagram  Description automatically generated](img/B18420_08_18.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图表  自动生成的描述](img/B18420_08_18.png)'
- en: 'Figure 8.18: Circuit rendering using the latex library'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18：使用latex库进行电路渲染
- en: 'If you are planning to post your circuit onto a website, blog, or social media
    and would like to include some styles on the image, you can do that as well by
    passing in the style contents as a parameter, such as `backgroundcolor`, `gatetextcolor`,
    and `fontsize`, just to name a few:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你计划将你的电路发布到网站、博客或社交媒体上，并且想在图片中包含一些样式，你也可以通过传递样式内容作为参数来实现，例如`backgroundcolor`、`gatetextcolor`和`fontsize`，仅举几个例子：
- en: '[PRE25]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code results in adjusting the background, gate color schemes,
    and font size, as illustrated here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码结果是对背景、门颜色方案和字体大小进行调整，如图所示：
- en: '![Chart  Description automatically generated](img/B18420_08_19.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图表  自动生成的描述](img/B18420_08_19.png)'
- en: 'Figure 8.19: Rendered circuit with the custom style dictionary on matplotlib'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19：在matplotlib上使用自定义样式字典渲染的电路
- en: To use the style setting, you must use the output `matplotlib` as this is the
    only library that supports the styles.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用样式设置，你必须使用输出`matplotlib`，因为这这是唯一支持样式的库。
- en: Details on the available list of styles can be found in the *Style Dict Details*
    section of the Qiskit API documentation ([https://docs.quantum-computing.ibm.com/api/qiskit/qiskit.visualization.circuit_drawer](https://docs.quantum-computing.ibm.com/api/qiskit/qiskit.visualization.circuit_drawer)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可用样式列表的详细信息可以在Qiskit API文档的*样式字典详细信息*部分找到（[https://docs.quantum-computing.ibm.com/api/qiskit/qiskit.visualization.circuit_drawer](https://docs.quantum-computing.ibm.com/api/qiskit/qiskit.visualization.circuit_drawer)）。
- en: Finally, we will cover a full view of the circuit as a DAG, which will be helpful
    to see the circuit as a graph to understand how it flows.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将涵盖电路作为DAG的完整视图，这将有助于将电路作为图来理解其流程。
- en: Drawing the directed acyclic graph of a circuit
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制电路的有向无环图
- en: As circuits get larger, they will naturally get more complex, and even visualizing
    a circuit can get complicated. Imagine a circuit with thousands of qubits and
    with a depth of over 1,000\. This would be difficult to render and almost impossible
    to read. This is where DAGs may help. Let’s create one based on the circuit that
    we previously created to illustrate rendering and see how the DAG of that circuit
    looks.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 随着电路变大，它们自然会变得更加复杂，甚至可视化电路也可能变得复杂。想象一下有数千个量子比特且深度超过1,000的电路。这将很难渲染，几乎不可能阅读。这就是DAG可能有所帮助的地方。让我们基于之前创建的电路创建一个DAG来展示渲染，并看看该电路的DAG看起来如何。
- en: 'In the following code, you will need two components; the first is the circuit-to-DAG
    converter. This will convert the circuit into a DAG. The second component is the
    DAG drawer, which will draw out the DAG where the nodes are represented as quantum
    registers, classical registers, quantum gates, barriers, and measurement operators.
    The edges are directional, which illustrates the flow of the circuit:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，你需要两个组件；第一个是电路到DAG转换器。这将把电路转换成一个DAG。第二个组件是DAG绘制器，它将绘制出DAG，其中节点表示量子寄存器、经典寄存器、量子门、屏障和测量算子。边是有方向的，这说明了电路的流程：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This results in the following rendering of the DAG:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下DAG的渲染：
- en: '![Figure 9.28 – The DAG rendering of a quantum circuit ](img/B18420_08_20.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图9.28 – 量子电路的DAG表示](img/B18420_08_20.png)'
- en: 'Figure 8.20: The DAG rendering of a quantum circuit'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20：量子电路的DAG表示
- en: The DAG can help illustrate the flow and expected paths of the circuit in order
    from top to bottom, where the top level is the first operation, and each operation
    is appended as you traverse down the graph. For example, the preceding graph starts
    at the top with the qubits in green, then following the graph, we see that each
    qubit (represented by the edge labels between the nodes) is operated upon by a
    specified operation (represented by the nodes). The graph terminates at the end
    in red, where the measurement applied on the qubit is mapped to the specified
    classical bit, represented by the parameter values.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: DAG可以帮助从上到下说明电路的流程和预期路径，其中顶层是第一个操作，并且随着你遍历图，每个操作都会附加。例如，前面的图从顶部的绿色量子比特开始，然后跟随图，我们看到每个量子比特（由节点之间的边标签表示）都受到一个指定的操作（由节点表示）的作用。图在红色的末端结束，其中对量子比特应用的测量映射到指定的经典比特，由参数值表示。
- en: In this section, we learned about visualizing circuit graphs with the help of
    customized visual circuits. We also learned how to use DAGs to enhance our circuit
    graphs and visualize the path of our circuit.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了在自定义可视化电路的帮助下可视化电路图。我们还学习了如何使用DAG来增强我们的电路图并可视化电路的路径。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned various ways to optimize your circuits when they
    are running on one of the many quantum computers that currently exist. You also
    learned about the different passes available to optimize the execution of your
    circuit on a specified quantum device. This includes generating a pass manager,
    which allows you to customize which passes to leverage based on the selected optimization
    level and allows you to choose their order.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了在当前存在的许多量子计算机上运行电路时优化电路的各种方法。你还了解了可用于优化指定量子设备上电路执行的不同遍历。这包括生成遍历管理器，它允许你根据所选的优化级别自定义要利用的遍历，并允许你选择它们的顺序。
- en: We then covered topology and coupling maps, which helped you understand the
    importance of knowing the device configurations should you want to create your
    own passes. By visualizing the circuits in various formats, you now have the skills
    to customize the rendering of images, particularly if you are documenting your
    work and would like to keep a certain look and feel. Finally, we covered alternative
    rendering of the circuit operation flow by using DAGs.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后介绍了拓扑和耦合图，这有助于你理解了解设备配置的重要性，尤其是当你想要创建自己的传递函数时。通过以各种格式可视化电路，你现在拥有了自定义图像渲染的技能，尤其是如果你在记录你的工作并希望保持某种外观和感觉时。最后，我们通过使用
    DAGs 来介绍了电路操作流程的替代渲染方式。
- en: In the next chapter, we will learn about various noises associated with quantum
    systems to understand how we can create noise models that we can use to simulate
    and identify ways to mitigate and run more efficient algorithms.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习与量子系统相关的各种噪声，以了解我们如何创建可以用于模拟和识别减轻和运行更高效算法的噪声模型。
- en: Questions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can you name the two components of the transpiler?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能说出 transpiler 的两个组件吗？
- en: Which component allows you to specify the passes to use?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个组件允许你指定要使用的传递函数？
- en: What is the default `optimization_level` value when running the transpile()
    function?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 transpile() 函数时，默认的 `optimization_level` 值是多少？
- en: Name the three Layout Selection Passes.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出三个布局选择传递函数。
- en: Join us on Discord
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/3FyN1](Chapter_8.xhtml)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/3FyN1](Chapter_8.xhtml)'
- en: '![](img/QR_Code261762599683826593.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code261762599683826593.png)'
