- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Graph Construction and Cleaning
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形构建与清洗
- en: We have covered quite a lot of ground up to this point. In the previous chapters,
    we introduced NLP, network science, and social network analysis, and we learned
    how to convert raw text into network data. We even visualized a few of these networks.
    I hope that seeing text converted into a visualized network had the same impact
    on you as it did on me. The first time I attempted this, I used the book of Genesis,
    from the Bible, and being able to convert text from thousands of years ago into
    an actual interactive network took my breath away.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经覆盖了很多内容。在前几章中，我们介绍了自然语言处理（NLP）、网络科学和社交网络分析，并学习了如何将原始文本转换为网络数据。我们甚至还可视化了其中的一些网络。我希望看到文本转化为可视化网络对你产生的影响和我当时的感觉一样强烈。第一次尝试时，我使用的是《创世纪》一书（来自《圣经》），能将几千年前的文本转换为一个实际的交互式网络，真是让我大吃一惊。
- en: In the previous two chapters, we learned a few different ways to collect text
    data from websites and social networks on the internet and to use that text data
    to create networks. The good news is that I don’t need to show you more ways to
    scrape text. You have enough options, and you should be able to use this knowledge
    as a foundation for other kinds of scraping.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们学习了从互联网上的网站和社交网络收集文本数据的几种不同方式，并利用这些文本数据创建网络。好消息是，我不需要再展示更多的文本抓取方法了。你已经有了足够的选择，应该能够将这些知识作为其他类型抓取的基础。
- en: 'The bad news is that it is time to get to everybody’s “favorite” topic: cleaning
    data! In all honesty, this is my favorite part of working with network data. Cleaning
    takes work, but it’s pretty simple. This is a good time to throw on some music,
    make a hot beverage, relax, and hunt for little problems to fix.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 坏消息是，现在该讨论每个人的“最爱”话题：数据清洗！说实话，这是我处理网络数据时最喜欢的部分。清洗工作需要一些努力，但其实并不复杂。现在是时候播放一些音乐，泡一杯热饮，放松一下，开始寻找需要修复的小问题了。
- en: To make this chapter especially fun, we will be using the social network from
    *Alice’s Adventures in Wonderland*. I have created this network using the process
    described in previous chapters. As we have gone over the steps a few times now,
    I’m going to skip explaining how to convert text into entities, entities into
    network data, and network data into graphs. The raw network data has been pushed
    to my GitHub, and we’ll use that for this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让本章特别有趣，我们将使用来自 *《爱丽丝梦游仙境》* 的社交网络。我已经按照前几章中描述的过程创建了这个网络。由于我们已经讨论了几遍如何将文本转换为实体、实体转换为网络数据以及网络数据转换为图形的步骤，所以这次我将跳过这些内容的解释。原始的网络数据已经上传到我的
    GitHub，我们将在本章中使用这些数据。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: Creating a graph from an edge list
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从边列表创建图形
- en: Listing nodes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出节点
- en: Removing nodes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除节点
- en: Quick visual inspection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速视觉检查
- en: Renaming nodes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名节点
- en: Removing edges
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除边
- en: Persisting the network
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化网络
- en: Simulating an attack
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟攻击
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be using the NetworkX and pandas Python libraries.
    We will also import an NLTK tokenizer. By now, all of these libraries should be
    installed, so they should be ready for your use.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将使用 NetworkX 和 pandas Python 库。我们还将导入一个 NLTK 分词器。到现在为止，这些库应该已经安装好了，所以它们应该可以立即使用。
- en: All the code for this chapter is available in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Network-Science-with-Python](https://github.com/PacktPublishing/Network-Science-with-Python).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可以在本书的 GitHub 仓库中找到，地址是 [https://github.com/PacktPublishing/Network-Science-with-Python](https://github.com/PacktPublishing/Network-Science-with-Python)。
- en: Creating a graph from an edge list
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从边列表创建图形
- en: 'We are going to be using this file as our original edge list: [https://raw.githubusercontent.com/itsgorain/datasets/main/networks/alice/edgelist_alice_original.csv](https://raw.githubusercontent.com/itsgorain/datasets/main/networks/alice/edgelist_alice_original.csv).
    Let’s take a look:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个文件作为我们的原始边列表：[https://raw.githubusercontent.com/itsgorain/datasets/main/networks/alice/edgelist_alice_original.csv](https://raw.githubusercontent.com/itsgorain/datasets/main/networks/alice/edgelist_alice_original.csv)。让我们来看一下：
- en: 'Before we can create our graph, we must import the two libraries we will be
    working with: `pandas` and `networkx`. We use `pandas` to read the edge list into
    a DataFrame, and we pass that DataFrame to `networkx` to create a graph. You can
    import both like so:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建图形之前，我们必须导入两个我们将使用的库：`pandas` 和 `networkx`。我们使用 `pandas` 将边列表读取到一个 DataFrame
    中，然后将该 DataFrame 传递给 `networkx` 来创建图形。你可以按如下方式导入这两个库：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the libraries imported, let’s use pandas to read the CSV file into a DataFrame
    and then display it, as shown in the following code block:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入库后，让我们使用 pandas 将 CSV 文件读取为 DataFrame，然后显示它，如下代码块所示：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you run this in a Jupyter notebook, you should see the following DataFrame:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Jupyter notebook 中运行这个，你应该会看到以下的 DataFrame：
- en: '![Figure 6.1 – pandas DataFrame of the Alice in Wonderland edgelist](img/B17105_06_001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 《爱丽丝梦游仙境》边列表的 pandas DataFrame](img/B17105_06_001.jpg)'
- en: Figure 6.1 – pandas DataFrame of the Alice in Wonderland edge list
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 《爱丽丝梦游仙境》边列表的 pandas DataFrame
- en: 'Before we move on, I want to say that if you can represent any two things as
    having a relationship, you can use that as network data. In our DataFrame, the
    source and target entities are people, places, and organizations, as we configured
    in our **Named-Entity Recognition** (**NER**) work, but you could also make networks
    of the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我想说的是，如果你能将任何两个事物表示为具有某种关系的形式，那么你就可以将它们作为网络数据。在我们的 DataFrame 中，源节点和目标节点是人、地点和组织，就像我们在
    **命名实体识别**（**NER**）工作中配置的那样，但你也可以制作以下类型的网络：
- en: Ingredients and dishes
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配料和菜肴
- en: Students and teachers
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学生和老师
- en: Planets and star systems
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行星和星系
- en: 'I could go on and on forever. Realizing just how prevalent networks are around
    us and then seeing them in everything: that’s the precursor to unlocking the power
    of network analysis. This is about understanding the relationships between things.
    I am interested in literature and security, and most of my network analysis has
    to do with the overlap between human language and security. You may have other
    interests, so you will find more use in other types of networks. Try to take from
    this book and use it to inspire you toward new ways of researching topics of interest.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以一直说下去。意识到网络在我们周围是如此普遍，并且在所有事物中都能看到它们：这就是解锁网络分析力量的前奏。这是关于理解事物之间关系的。我对文学和安全感兴趣，我的大部分网络分析都涉及人类语言和安全之间的交集。你可能有其他的兴趣，因此你会在其他类型的网络中找到更多的用处。试着从本书中汲取灵感，激发你去研究感兴趣的话题的新方式。
- en: 'Now that that’s out of the way, we have our edge list DataFrame, so let’s convert
    this into a graph. In its simplest form, this is as easy as the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这一点已经说清楚了，我们有了边列表的 DataFrame，接下来让我们把它转换成图形。最简单的形式就是下面这样：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Really? That’s it? Yes, that’s it. When I first learned that it was this easy
    to go from a `pandas` DataFrame to a usable graph, I was instantly hooked. It’s
    this easy. But it is this easy for a few reasons:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 真的吗？就这样？是的，就是这样。当我第一次了解到从 `pandas` DataFrame 转换为可用的图形竟然这么简单时，我立刻被吸引住了。就是这么简单。但它之所以如此简单，有几个原因：
- en: First, this `networkx` function expects `.csv` file came with those columns,
    we didn’t need to rename any columns or specify to the function which columns
    were our sources and targets.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`networkx` 函数期望 `.csv` 文件包含这些列，我们不需要重命名任何列或指定哪些列是源节点和目标节点。
- en: Second, we aren’t specifying what kind of graph to use, so `networkx` defaults
    to `nx.Graph()`. This is the simplest form of graph, allowing only a single edge
    between nodes, and not including directionality.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们没有指定使用哪种图，因此 `networkx` 默认使用 `nx.Graph()`。这是最简单的图形形式，只允许节点之间有一条边，并且不包括方向性。
- en: 'In a notebook, if we were to inspect `G`, we would see the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本中，如果我们检查 `G`，我们会看到以下内容：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This verifies that we are working with the default graph type of `Graph`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这验证了我们正在使用默认的图类型 `Graph`。
- en: 'There are several ways to load network data into `networkx`, but I prefer to
    use edge list. At their simplest, edge lists are tabular data with two fields:
    *source* and *target*. Because of this simplicity, they can easily be stored as
    raw text or in databases. You don’t need a fancy graph database to store an edge
    list.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将网络数据加载到 `networkx` 中，但我更喜欢使用边列表。边列表最简单的形式是带有两个字段的表格数据：*source* 和 *target*。由于这种简单性，它们可以轻松地存储为纯文本或数据库中。你不需要一个复杂的图形数据库来存储边列表。
- en: Others prefer to use an adjacency matrix when working with network data. Adjacency
    matrices cannot be stored easily in a database, nor do they scale out well. Use
    whatever you prefer, but edge lists are very easy to work with, so I recommend
    learning to use, create, and store them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人在处理网络数据时更喜欢使用邻接矩阵。邻接矩阵不容易存储在数据库中，而且也不易扩展。你可以选择你喜欢的方式，但边列表非常容易使用，所以我建议你学习如何使用、创建和存储它们。
- en: Types of graphs
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图的类型
- en: 'NetworkX offers four different types of graphs:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX 提供了四种不同类型的图：
- en: '**Graph**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Graph**'
- en: '**DiGraph**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DiGraph**'
- en: '**MultiGraph**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MultiGraph**'
- en: '**MultiDiGraph**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MultiDiGraph**'
- en: 'You can learn more about them here: [https://networkx.org/documentation/stable/reference/classes/](https://networkx.org/documentation/stable/reference/classes/).
    I will give a short overview and my thoughts on each type of graph as to when
    it is useful.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于它们的信息：[https://networkx.org/documentation/stable/reference/classes/](https://networkx.org/documentation/stable/reference/classes/)。我将简要概述每种图的类型，并分享我对何时使用它们的看法。
- en: Graph
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图
- en: '**Graph** is the default and simplest form of a graph that NetworkX provides.
    In a simple graph, nodes can have only a single edge between them and another
    node. If your edge list contains multiple edges between a source and a target,
    it’ll be reduced to a single edge. This isn’t always a bad thing. There are approaches
    to reduce the complexity of networks, and one approach is to aggregate the data
    – for instance, counting the number of edges that exist between two nodes and
    keeping that value as a weighted count, rather than the edge list being the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Graph**是NetworkX提供的默认和最简单的图形式。在一个简单的图中，节点之间只能有一条边。如果你的边列表包含多个源和目标之间的边，它将被简化为一条边。这并不总是坏事。存在减少网络复杂度的方法，其中一种方法就是聚合数据——例如，计算两个节点之间存在的边的数量，并将该值作为加权计数，而不是让边列表如下所示：'
- en: '*source, target*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*source, target*'
- en: 'Instead, it would be like so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 而是像这样：
- en: '*source,* *target, edge_count*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*source,* *target, edge_count*'
- en: In that form, a graph still works well, because multiple edges have been reduced
    to a single edge, and the number of edges that existed has been reduced to a count.
    This is a very good way of simplifying network data while keeping all of the information.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种形式，图依然有效，因为多个边被简化成了一条边，原本存在的边数也被减少到了计数。这是一种非常好的方法，能够在保持所有信息的同时简化网络数据。
- en: For most of my work, a graph works fine. If I’ve decided against a default graph,
    it’s because I needed directionality, so I chose a `DiGraph` instead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的大部分工作，图是非常合适的。如果我没有选择默认的图，那是因为我需要方向性，因此我选择了`DiGraph`。
- en: 'Creating a default graph network can be done with the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 创建默认图网络可以通过以下代码完成：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: DiGraph
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DiGraph
- en: A `DiGraph` is similar to a graph, with the main difference being that it is
    directed. DiGraph stands for **directed graph**. Just as with a graph, each node
    can only have one edge between itself and another node. Most of what I said about
    aggregation still applies, but you may need to handle self-loops if you run into
    them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`DiGraph`类似于图，主要区别在于它是有向的。DiGraph代表**有向图**。就像图一样，每个节点之间只能有一条边。关于聚合的大部分内容仍然适用，但如果遇到自环，你可能需要进行处理。'
- en: These are very useful when you need to understand the directionality and flow
    of information. It isn’t always enough to know that a relationship exists between
    two things. It is often most important to understand the directionality of the
    influence, and how information spreads.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要理解信息的方向性和流动时，这些非常有用。知道两者之间存在关系并不总是足够的。通常，最重要的是理解影响的方向性，以及信息如何传播。
- en: 'For instance, let’s say we have four people named Sarah, Chris, Mark, and John.
    Sarah writes a lot and shares her ideas with her friend Chris. Chris is a bit
    of an influencer and shares information that he receives from Sarah (and others)
    with his following, which includes Mark and John. In this situation, the data
    flows like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有四个人，分别是Sarah、Chris、Mark和John。Sarah写了很多东西，并与她的朋友Chris分享她的想法。Chris有些影响力，并将从Sarah（和其他人）那里获得的信息分享给他的追随者，这些人包括Mark和John。在这种情况下，数据流动是这样的：
- en: '*Sarah -> Chris -> (Mark* *and John)*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sarah -> Chris -> (Mark* *and John)*'
- en: In this data flow, Sarah is an important person, because she is the originator
    of a brand-new piece of information.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数据流中，Sarah是一个重要人物，因为她是全新信息的发起者。
- en: Chris is also an important person because information flows through him to many
    other people. We will learn about how to capture this kind of importance in a
    later chapter, when we discuss betweenness centrality.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Chris也是一个重要人物，因为信息通过他流向了许多其他人。我们将在后续章节中学习如何捕捉这种重要性，当我们讨论“介于中心性”时。
- en: Finally, Mark and John are the receivers of this information.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Mark和John是这些信息的接收者。
- en: If this were not a directed graph, we could not visibly tell who created the
    information or who was the final receiver of the information. This directionality
    allows us to go to the origins and also follow the information flow.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不是一个有向图，我们无法直观地看出是谁创造了信息，或者谁是信息的最终接收者。这种方向性使我们能够追溯到源头，并跟踪信息流动。
- en: Directed graphs are also useful in mapping out production data flows that take
    place on servers and databases in production. When processes are mapped out this
    way, if something stops working, you can step backward until you discover what
    is broken. Using this approach, I have been able to troubleshoot problems in minutes
    that previously took days.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有向图在映射生产数据流方面也非常有用，这些数据流发生在生产中的服务器和数据库上。当流程以这种方式映射时，如果某个环节停止工作，你可以一步步回溯，直到找出问题所在。使用这种方法，我能够在几分钟内排查出以前需要几天时间才能解决的问题。
- en: 'Creating a directed graph is as simple as this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个有向图就像这样简单：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you inspect `G`, you should see the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查`G`，你应该看到如下内容：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: MultiGraph
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MultiGraph
- en: 'A `MultiGraph` can have multiple edges between any two nodes. A MultiGraph
    does not retain any context of directionality. To be truthful, I don’t use `MultiGraphs`.
    I prefer to aggregate the multiple edges down to a count and use either Graph
    or `DiGraph.` However, if you want to create a MultiGraph, you can do so with
    the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`MultiGraph`可以在任意两个节点之间有多个边。`MultiGraph`不保留任何方向性上下文。说实话，我不使用`MultiGraph`。我更喜欢将多个边汇总成计数，并使用`Graph`或`DiGraph`。不过，如果你想创建一个`MultiGraph`，可以使用以下命令：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you inspect `G`, you will see this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查`G`，你会看到如下内容：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: MultiDiGraph
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MultiDiGraph
- en: 'A `MultiDiGraph` can have multiple edges between any two nodes, and these graphs
    also convey the directionality of each edge. I do not use `MultiDiGraphs` as I
    prefer to aggregate multiple edges down to a count and then use either Graph or
    `DiGraph.` If you want to create a `MultiDiGraph,` you can do so with the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`MultiDiGraph`可以在任意两个节点之间有多个边，并且这些图形也传达了每条边的方向性。我不使用`MultiDiGraph`，因为我更喜欢将多个边汇总成计数，然后使用`Graph`或`DiGraph`。如果你想创建一个`MultiDiGraph`，可以使用以下命令：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you inspect `G`, you should see the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查`G`，你应该看到如下内容：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Summarizing graphs
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结图形
- en: 'To make sure we’ve got everything down, let’s go back over these graphs:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们覆盖了所有内容，让我们回顾一下这些图形：
- en: 'Let’s recreate our graph using a default graph:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用默认图形重新创建我们的图：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Great. We’ve loaded all of that data into `G`. This is a tiny network, so it
    loads instantly in a Jupyter notebook, and I imagine it will load quickly for
    you as well. With how fast of an operation that is, I’m often left wanting more,
    like, “That’s it? I did all that work to create all of that data, and that’s it?”
    Well, yes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。我们已经将所有数据加载到`G`中。这是一个很小的网络，因此在Jupyter笔记本中加载速度非常快，我想你也会很快加载完成。考虑到操作速度如此之快，我常常会觉得不过瘾，就会想：“就这些？我花了那么多功夫创建这些数据，结果就这样？”嗯，是的。
- en: 'However, there is one function that is useful for getting a quick overview
    of a graph:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，有一个函数对于快速概览图形非常有用：
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we run that, we’ll see this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个命令，我们会看到如下内容：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Neat. This is a tiny, simple network. With so few nodes and edges, this should
    visualize nicely enough to assist with cleanup.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 整洁。这是一个很小、简单的网络。节点和边数这么少，应该足够清晰地帮助清理。
- en: There are other ways to quickly inspect a graph, but this is the simplest way.
    Now, let’s look at the cleanup; we’ll learn more about analyzing networks in later
    chapters.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以快速检查图形，但这是最简单的一种。现在，让我们来看看清理工作；我们将在后面的章节中了解更多关于网络分析的内容。
- en: Listing nodes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出节点
- en: The first thing I tend to do after constructing a network from text is to list
    the nodes that have been added to the network. This allows me to take a quick
    peek at the node names so that I can gauge the amount of cleanup I will need to
    do to remove and rename nodes. During our entity extraction, we had the opportunity
    to clean the entity output. The entity data is used to create the network data
    that is used to create the graph itself, so there are multiple steps during which
    cleanup and optimization are possible, and the more that you do upstream, the
    less that you have to do later.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在从文本构建网络之后，我通常会列出已添加到网络中的节点。这让我可以快速查看节点名称，从而估算出需要清理和重命名节点的工作量。在我们的实体提取过程中，我们有机会清理实体输出。实体数据用于创建网络数据，而网络数据又用于生成图形本身，因此在多个步骤中都可以进行清理和优化，越是在前期做得好，后期需要做的工作就越少。
- en: 'However, it is still important to take a look at the node names, to identify
    any strangeness that still managed to find a way into the network:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，查看节点名称仍然很重要，目的是识别任何仍然成功进入网络的异常：
- en: 'The simplest way to get a node list is to run the following `networkx` command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取节点列表的最简单方法是运行以下`networkx`命令：
- en: '[PRE17]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will give you a `NodeView`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你一个`NodeView`：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That’s readable, but it could be a little easier on the eyes. This function
    will clean it up a bit:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样是可读的，但看起来可能更容易一些。这个函数将稍微整理一下：
- en: '[PRE19]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This can be run as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以如下运行：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This outputs a cleaner node list:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出一个更清晰的节点列表：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We now have a clean list of nodes that exist in the *Alice’s Adventures in Wonderland*
    social network. Immediately, my eyes are drawn to the last three nodes. These
    don’t even look like names. We’re going to remove them. I can also see that `CHAPTER
    V.`, `Soup`, and a few other non-entity nodes were added. This is a common problem
    when using NLP for Part-of-Speech Tagging (`pos_tagging`) or **NER**. Both of
    these approaches frequently make mistakes on words where the first letter of a
    word is capitalized.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个清理过的*《爱丽丝梦游仙境》*社交网络中的节点列表。立刻，我的目光被最后三个节点吸引。它们甚至不像是名字。我们将删除它们。我还看到`CHAPTER
    V.`, `Soup`和其他一些非实体节点被加入了。这是使用自然语言处理（NLP）进行词性标注（`pos_tagging`）或**命名实体识别**（NER）时常见的问题。这两种方法经常会在单词首字母大写的情况下出错。
- en: We have some work to do. We will remove the nodes that were added by mistake,
    and we will rename a few of the nodes so that they reference the *White Rabbit*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些工作要做。我们将删除错误添加的节点，并重命名一些节点，使它们指向*白兔*。
- en: 'When inspecting graphs, I list nodes, not edges. You can list edges with the
    following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查图时，我列出的是节点，而不是边。你可以使用以下方式列出边：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will give you an `EdgeView`, like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给你一个`EdgeView`，像这样：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: I don’t typically list edges, because when I remove or rename nodes, the edges
    will be corrected. Edges to nodes that have been removed will be removed as well.
    Edges to nodes that have been renamed will be connected to the renamed node. `EdgeView`
    is also more confusing to look at.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常不列出边，因为当我删除或重命名节点时，边会自动修正。指向已删除节点的边会被删除，指向已重命名节点的边会连接到新的节点。`EdgeView`也更难阅读。
- en: 'With our clean nodelist, here is our plan of attack:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有了清理过的节点列表，这是我们的攻击计划：
- en: Remove the bad nodes.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除不良节点。
- en: Rename the *White* *Rabbit* nodes.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名*白兔*节点。
- en: Add any missing nodes that I am aware of.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我知道的任何缺失节点。
- en: Add any missing edges that I can identify.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我能识别的任何缺失的边。
- en: Let’s proceed with the first of those steps.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这些步骤的第一步开始。
- en: Removing nodes
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除节点
- en: The next thing we will do is remove nodes that have made it into the network
    by mistake, usually as a result of false positives from `pos_tagging` or `NER`.
    You may see me refer to these nodes as “bad” nodes. I could as easily refer to
    them as “unwanted” nodes, but the point is that these are nodes that do not belong
    and should be removed. For simplicity, I call them bad nodes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要做的是删除那些错误进入网络的节点，通常是由于`pos_tagging`或**NER**的假阳性结果。你可能会听到我提到这些节点是“不良”节点。我也可以称它们为“无用”节点，但重点是这些节点不属于网络，应该被删除。为了简化，我称它们为不良节点。
- en: One reason to remove nodes is to clean a network so that it closely matches
    reality or the reality described in a piece of text. However, removing nodes can
    also be useful, for simulating an attack. We could, for instance, remove key characters
    from the *Alice in Wonderland* social network, to simulate what the outcome would
    be if the Queen of Hearts had gotten her wish of executing several characters.
    We will do that in this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 删除节点的一个原因是清理网络，使其更贴近现实，或者贴近某段文本中描述的现实。然而，删除节点也可以用于模拟攻击。例如，我们可以从*爱丽丝梦游仙境*社交网络中删除关键角色，模拟如果红心皇后实现她的愿望处决多个角色的结果。我们将在本章中进行此操作。
- en: 'Simulating an attack is also useful for bolstering defenses. If a node is a
    single point of failure and if its removal would be catastrophic to a network,
    you can potentially add nodes in certain positions so that if the critical node
    were removed, the network would remain intact, and information flow would be undisrupted:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟攻击也有助于增强防御。如果一个节点是单点故障，并且它的删除会对网络造成灾难性后果，你可以在某些位置添加节点，这样即使关键节点被删除，网络仍能保持完整，信息流动不受影响：
- en: 'In `networkx`, there are two different ways to remove nodes: one at a time,
    or several at once. You can remove a single node like this:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`networkx`中，有两种删除节点的方法：一次删除一个，或者一次删除多个。你可以像这样删除单个节点：
- en: '[PRE26]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can remove several nodes at once like this:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以一次性删除多个节点，像这样：
- en: '[PRE27]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'I prefer the second approach because it can also be used to remove a single
    node if the `drop_nodes` variable only contains a single node name. You can simply
    keep expanding `drop_nodes` until you have all bad entities listed, and then you
    can keep refreshing the list of remaining nodes. Now that we’ve removed some nodes,
    let’s see which entities remain:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢第二种方法，因为它还可以用来移除单个节点，只要`drop_nodes`变量仅包含一个节点名称。你可以简单地不断扩展`drop_nodes`，直到列出所有不良实体，然后继续刷新剩余节点的列表。现在我们已经移除了一些节点，让我们看看剩下哪些实体：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is already looking much cleaner. Next, we will further clean the network
    by renaming and combining certain nodes, especially the nodes related to the *White
    Rabbit*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来干净多了。接下来，我们将通过重命名和合并某些节点，进一步清理网络，特别是与*白兔*相关的节点。
- en: Quick visual inspection
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速视觉检查
- en: 'Before moving on to more cleaning, let’s do a quick visual inspection of the
    network. We will reuse the `draw_graph` function we have been using throughout
    this book:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行更多清理之前，让我们对网络进行一次快速的视觉检查。我们将重用本书中一直使用的`draw_graph`函数：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This outputs the following network:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这输出了以下网络：
- en: '![Figure 6.2 – Quick visual inspection network](img/B17105_06_002.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 快速视觉检查网络](img/B17105_06_002.jpg)'
- en: Figure 6.2 – Quick visual inspection network
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 快速视觉检查网络
- en: OK, what do we see? I can see that there is one large cluster of connected entities.
    This is the primary component of the Alice in Wonderland network.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们看到什么了？我可以看到有一个大型的连接实体集群。这是《爱丽丝梦游仙境》网络的主要组成部分。
- en: What else do we see? **Alice** is the most central node in the primary component.
    That makes sense, as she is the main character in the story. Thinking about the
    main characters, I see many names that I know, such as **Dormouse**, **Cheshire
    Cat**, and **White Rabbit**. What is interesting to me, though, is that not only
    are they shown but I can also begin to see which characters are most important
    to the story based on the number of entities connected to them. However, I also
    see that the Queen and King of Hearts are missing, which is disappointing. NER
    failed to recognize them as entities. From what I have seen, NER struggles with
    fantasy and ancient names, due to it being trained on more realistic data. It
    would struggle less with real names. We will manually add several members of the
    queen’s court, including the king and queen.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了什么？**爱丽丝**是主要组件中最中心的节点。这很有意义，因为她是故事中的主角。想到主要角色，我看到许多我熟悉的名字，比如**睡鼠**、**柴郡猫**和**白兔**。但令我感兴趣的是，不仅它们被展示出来，而且我还能开始看到哪些角色对故事最重要，基于与它们连接的实体数量。然而，我也注意到红心皇后和红心国王缺席了，这让我有些失望。命名实体识别（NER）未能将它们识别为实体。从我所看到的，NER在处理奇幻和古代名字时存在困难，因为它是基于更现实的数据训练的。它对真实名字的处理要好得多。我们将手动添加皇后宫廷的几位成员，包括国王和皇后。
- en: I can also see a few strange nodes that seem to be part of the story but they
    aren’t connected to the primary component. Why is **Gryphon** disconnected from
    everything? Who does **Gryphon** know? We should look for those relationships
    in the story text. We will manually add the edges.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我还可以看到一些奇怪的节点，它们似乎是故事的一部分，但与主要组件没有连接。为什么**狮鹫**与一切都断开连接？**狮鹫**认识谁？我们应该在故事文本中寻找这些关系。我们将手动添加这些边。
- en: Finally, I see nodes that have to do with places on Earth, such as **Nile**,
    **France**, **England**, **New Zealand**, and **Australia**. We could keep these,
    as they are technically a part of the story, but I’m going to remove them so that
    we can focus more on the social network of character relationships that exist
    in Wonderland. We will remove these.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我看到一些与地球上的地方有关的节点，比如**尼罗河**、**法国**、**英格兰**、**新西兰**和**澳大利亚**。我们可以保留这些，因为它们从技术上讲是故事的一部分，但我打算将它们移除，这样我们就可以更多地关注仙境中的角色关系社交网络。我们将移除这些。
- en: 'Let’s start by removing the non-Wonderland nodes:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从移除非仙境节点开始：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let’s visualize the network again:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次可视化这个网络：
- en: '![Figure 6.3 – Quick visual inspection network (cleaned)](img/B17105_06_003.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 快速视觉检查网络（已清理）](img/B17105_06_003.jpg)'
- en: Figure 6.3 – Quick visual inspection network (cleaned)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 快速视觉检查网络（已清理）
- en: 'That looks a lot better. We still have **Gryphon** floating around like an
    island, but we’ll take care of that soon. Still, where in the world is the Queen
    of Hearts? I wrote a helper function to help with that investigation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好多了。我们仍然有**狮鹫**像孤岛一样漂浮着，但我们很快会处理它。尽管如此，红心皇后到底在哪呢？我写了一个辅助函数来帮助调查这个问题：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this function, we can pass in any text and any search string, and it’ll
    print out any sentences that contain the search string. This will help us find
    entities and relationships that NER failed to find. I am using NLTK’s sentence
    tokenizer rather than spaCy because this is faster and easier to get the results
    I need right now. Sometimes, NLTK is the faster and simpler approach, but not
    in this case.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个函数，我们可以传入任何文本和任何搜索字符串，它将输出包含搜索字符串的句子。这将帮助我们找到NER未能找到的实体和关系。我使用的是NLTK的句子分割器，而不是spaCy，因为它更快且能更容易地得到我目前需要的结果。有时，NLTK是更快且更简便的方式，但在这个情况下不是。
- en: Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To run the following code, you will need to load the `text` variable using one
    of the approaches from [*Chapter 4*](B17105_04.xhtml#_idTextAnchor158) or [*Chapter
    5*](B17105_05.xhtml#_idTextAnchor179). We have shown multiple approaches to loading
    text for Alice in Wonderland.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行以下代码，你需要使用[*第4章*](B17105_04.xhtml#_idTextAnchor158)或[*第5章*](B17105_05.xhtml#_idTextAnchor179)中的一种方法加载`text`变量。我们已经展示了多种加载《爱丽丝梦游仙境》文本的方法。
- en: 'Let’s look for text related to the queen:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找一下与皇后相关的文本：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here are some of the results:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些结果：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Running this function will give many more results than this – these are just
    a few. But we can already see that `Queen of Hearts` knows `Frog-Footman`, and
    that `Frog-Footman` is in our network, so we should add `Queen of Hearts` and
    other missing characters and place an edge between the characters that they interact
    with.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个函数会得到比这些更多的结果——这些只是其中的一些。但我们已经可以看到`Queen of Hearts`认识`Frog-Footman`，而`Frog-Footman`在我们的网络中，因此我们应该添加`Queen
    of Hearts`和其他缺失的角色，并在它们与互动的角色之间添加边。
- en: Adding nodes
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加节点
- en: 'We need to add nodes that are missing. As *Alice in Wonderland* is a fantasy
    story, and NER models tend to be trained with more modern and realistic text,
    the NER struggled to identify some important entities, including the Queen of
    Hearts. There are a few lessons here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加缺失的节点。由于《爱丽丝梦游仙境》是一个幻想故事，而NER模型通常是用更现代和现实的文本进行训练的，因此NER难以识别一些重要的实体，包括红心皇后。这其中有几个教训：
- en: First, don’t blindly trust models, ever. The data that they were trained on
    will have an impact on what they do and don’t do very well.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，永远不要盲目相信模型。它们所训练的数据将对它们做得好或做得不好产生影响。
- en: Second, domain knowledge is very important. If I did not know the story of Alice
    in Wonderland, I might not even have noticed that the royalty was missing.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，领域知识非常重要。如果我不了解《爱丽丝梦游仙境》的故事，我可能根本不会注意到皇家人物的缺失。
- en: Finally, even with flaws, NER and these approaches will do *most* of the work
    in converting text into networks, but your domain knowledge and critical thinking
    will lead to the best results.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，即使有缺陷，NER和这些方法仍然能完成*大部分*的工作，将文本转换为网络，但你的领域知识和批判性思维将带来最佳的结果。
- en: 'Just as with removing nodes, `networkx` has two methods for adding nodes: one
    at a time, or several at once:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 就像删除节点一样，`networkx`有两种添加节点的方法：一次一个，或者一次添加多个：
- en: 'We can add just `''Queen` `of Hearts''`:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以只添加`'Queen` `of Hearts'`：
- en: '[PRE35]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Alternatively, we could add the missing nodes all at once:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，我们也可以一次性添加所有缺失的节点：
- en: '[PRE36]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Again, I prefer the bulk approach, as I can just keep extending the `add_nodes`
    list until I am satisfied with the results. If we visualize the network now, these
    added nodes will appear as islands, because we have not created edges between
    them and other nodes:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然偏好批量处理方式，因为我可以不断扩展`add_nodes`列表，直到我对结果满意。如果我们现在可视化网络，这些新增的节点将呈现为孤岛，因为我们尚未在它们与其他节点之间创建边：
- en: '![Figure 6.4 – Network with missing nodes added](img/B17105_06_004.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 添加缺失节点的网络](img/B17105_06_004.jpg)'
- en: Figure 6.4 – Network with missing nodes added
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 添加缺失节点的网络
- en: This looks good. Next, let’s add those missing edges.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。接下来，我们来添加那些缺失的边。
- en: Adding edges
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加边
- en: 'We used the `search_text` function to identify not only the missing characters
    but also the missing relationships between those characters. The approach taken
    was as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`search_text`函数来识别不仅是缺失的角色，还有这些角色之间缺失的关系。采用的方法如下：
- en: Figure out who the Queen of Hearts knows; take notes as these are missing edges.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出“红心皇后”认识谁；做笔记，因为这些是缺失的边。
- en: Add the Queen of Hearts and any other missing nodes.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加红心皇后和其他任何缺失的节点。
- en: Figure out who each missing character knows; take notes as these are missing
    edges.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出每个缺失角色认识谁；做笔记，因为这些是缺失的边。
- en: 'This involved doing a bunch of lookups with the `search_text` function and
    then keeping track of relationships as comments in my Jupyter notebook. In the
    end, it looked like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及使用`search_text`函数进行大量查找，并在我的Jupyter笔记本中将关系跟踪为注释。最终，它看起来是这样的：
- en: '![Figure 6.5 – Identified missing edges](img/B17105_06_005.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 识别出的缺失边](img/B17105_06_005.jpg)'
- en: Figure 6.5 – Identified missing edges
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 识别出的缺失边
- en: 'These are identified edges that we need to add. We are likely missing some,
    but this is enough for our purposes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要添加的已识别边。我们可能遗漏了一些，但这已经足够满足我们的需求：
- en: 'We can add an edge, one at a time:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以一次性添加一条边：
- en: '[PRE38]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Alternatively, we can add several at once. I prefer the bulk approach, again.
    To do the bulk approach, we will use a list of tuples to describe the edges:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外，我们也可以一次性添加多个。我还是更喜欢批量方式。要使用批量方式，我们将使用一个元组列表来描述边：
- en: '[PRE39]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How does our network look now?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的网络看起来如何？
- en: '![Figure 6.6 – Network with missing edges added](img/B17105_06_006.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 添加了缺失边的网络](img/B17105_06_006.jpg)'
- en: Figure 6.6 – Network with missing edges added
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 添加了缺失边的网络
- en: 'This is looking a lot better, and we now have the queen’s court in place. However,
    Gryphon is still an island, so let’s do a lookup to see what relationship or relationships
    are missing:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来好多了，我们已经把女王的宫廷安排好。不过，Gryphon 仍然是一个孤岛，所以让我们查找一下缺失的关系或关系：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This gives us some text to look at, and I used that to identify missing edges.
    Let’s add them:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一些文本来查看，我用它来识别缺失的边。让我们添加它们：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, let’s visualize the network one more time:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再一次可视化这个网络：
- en: '![Figure 6.7 – Network with missing edges added (final)](img/B17105_06_007.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 添加了缺失边的网络（最终版）](img/B17105_06_007.jpg)'
- en: Figure 6.7 – Network with missing edges added (final)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 添加了缺失边的网络（最终版）
- en: Ah! It’s such a wonderful feeling when a disconnected network is finally connected
    and all islands/isolates are taken care of. This is clean and readable. We have
    successfully removed junk nodes, added missing nodes, and connected the missing
    nodes to nodes that they should share an edge with! We can move on!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！当一个断开的网络终于连接起来，所有的孤岛/孤立节点都得到处理时，真是一种美妙的感觉。这是干净且易于阅读的。我们已经成功地移除了垃圾节点，添加了缺失节点，并将缺失的节点连接到它们应该共享边的节点！我们可以继续前进了！
- en: Renaming nodes
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重命名节点
- en: 'This network looks good enough that we might be tempted to just call it a day
    on our cleaning efforts. However, there is a bit more that we need to do, especially
    for the White Rabbit, but also for a few other characters. I can see three nodes
    having to do with the White Rabbit:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网络看起来足够好，以至于我们可能会忍不住认为我们的清理工作已经完成。然而，还有一些事情需要做，特别是对白兔的处理，还有一些其他角色。我可以看到有三个节点与白兔有关：
- en: '`the` `White Rabbit`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`the` `White Rabbit`'
- en: '`Rabbit`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rabbit`'
- en: '`The` `Rabbit Sends`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`The` `Rabbit Sends`'
- en: 'If we rename all three of these nodes `White Rabbit`, then they will be combined
    into a single node, and their edges will also be correctly connected. There are
    a few other nodes that should be renamed as well. Here is how to rename nodes:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这三个节点都重命名为`White Rabbit`，那么它们将合并成一个节点，它们的边也会正确连接。还有一些其他的节点也应该被重命名。以下是重命名节点的方法：
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We pass in a Python dictionary containing nodes and what we want them relabeled
    as. For instance, we are changing `Cheshire` to `Cheshire Cat`, and `Hatter` to
    `Mad Hatter`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传入一个包含节点及其重命名的Python字典。例如，我们将`Cheshire`改为`Cheshire Cat`，将`Hatter`改为`Mad Hatter`。
- en: How do our nodes look now?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的节点看起来如何？
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Nice. That looks perfect. How does our network look, visually?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。看起来完美。我们的网络在视觉上如何呢？
- en: '![Figure 6.8 – Network with renamed nodes](img/B17105_06_008.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 重命名后的网络](img/B17105_06_008.jpg)'
- en: Figure 6.8 – Network with renamed nodes
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 重命名后的网络
- en: Perfect. **White Rabbit** has been placed correctly, and the node color and
    placement show it as a central character, right next to **Alice**, and not far
    from **Queen of Hearts** and **King** **of Hearts**.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。**White Rabbit** 已经正确放置，节点的颜色和位置表明它是一个核心角色，就在**Alice**旁边，离**Queen of Hearts**和**King
    of Hearts**也不远。
- en: Removing edges
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除边
- en: There will likely be times when you will need to remove edges. This can be useful,
    not just for cleaning networks but also for simulating attacks, or for identifying
    cliques and communities. For instance, I often use what is called **minimum cuts**
    or **minimum edge cuts** to find the fewest number of edges that will split a
    network into two pieces. I use this for community detection, and also to spot
    emerging trends on social media.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你会遇到需要删除边的情况。这不仅对清理网络有用，还可以用于模拟攻击，或者识别团体和社区。例如，我常常使用所谓的**最小割**或**最小边割**来找到将网络分割成两部分所需的最少边数。我用这个方法来进行社区检测，也用它来发现社交媒体上的新兴趋势。
- en: 'With the *Alice in Wonderland* network, there are no edges that we need to
    remove, so I will first show you how to remove some edges, and then I’ll show
    you how to put them back:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*爱丽丝梦游仙境*网络，实际上没有需要删除的边，因此我将首先演示如何删除一些边，然后再演示如何将它们放回去：
- en: 'You can remove edges one at a time:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以逐一删除边：
- en: '[PRE56]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Alternatively, you can remove several at a time:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你也可以一次性删除几条边：
- en: '[PRE57]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How does this look when visualized?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可视化效果怎么样？
- en: '![Figure 6.9 – Network with edges removed](img/B17105_06_009.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 删除边的网络](img/B17105_06_009.jpg)'
- en: Figure 6.9 – Network with edges removed
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 删除边的网络
- en: This looks exactly as it should. If we had removed the nodes for **Elsie**,
    **Tillie**, and **Lacie** instead of their edges, then the nodes as well as the
    edges would have been removed. Instead, we have removed the edges, which is a
    bit like cutting a piece of string. The three nodes are now islands, isolates,
    connected to nothing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来正如预期的那样。如果我们删除的是**Elsie**、**Tillie** 和 **Lacie** 的节点，而不是它们的边，那么节点和边都会被删除。相反，我们删除的是边，这有点像剪断一根绳子。这三个节点现在变成了孤岛，孤立无援，什么也没有连接。
- en: 'Let’s put them back:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把它们放回去：
- en: '[PRE59]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How does the network look now?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在网络看起来怎么样？
- en: '![Figure 6.10 – Network with edges added](img/B17105_06_010.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 添加边的网络](img/B17105_06_010.jpg)'
- en: Figure 6.10 – Network with edges added
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 添加边的网络
- en: Perfect. **Elsie**, **Tillie**, and **Lacie** are right back where they should
    be, connected to **Dormouse**. With that, I think this network is perfect for
    our uses.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。**Elsie**、**Tillie** 和 **Lacie** 已经回到它们应该在的位置，连接到 **Dormouse**。这样一来，我认为这个网络非常适合我们的用途。
- en: Persisting the network
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化网络
- en: 'I want to persist this network so that we can use it in later chapters without
    having to go through all of this work again. We will use this network quite a
    lot in this book:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望将这个网络持久化，以便我们在后面的章节中可以使用它，而无需再次进行所有这些工作。在本书中，我们将多次使用这个网络：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: I’m using Microsoft Windows. Your outfile path may look different.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用微软 Windows。你的输出文件路径可能不同。
- en: Simulating an attack
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟攻击
- en: We already did an end-to-end workflow of converting a rough network edge list
    into a network, cleaning the network, and then persisting the cleaned network’s
    edge list, so for the remainder of this chapter, let’s do a simulation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了将一个粗略的网络边列表转换成网络、清理网络并持久化清理后的网络边列表的端到端工作流，因此接下来让我们进行一个模拟。
- en: 'In most networks, some nodes serve as key hubs. These nodes reveal themselves
    if you look for the number of degrees (edges) that a node has, or by checking
    PageRank or various centrality metrics for nodes. We will use these approaches
    in a later chapter to identify important notes. For now, we have domain knowledge
    that we can use. Those of us who know this story can likely name by heart several
    of the important protagonists of the story: Alice, Mad Hatter, Cheshire Cat, and
    so on. And those of us who are familiar with the story are also likely very aware
    of the Queen of Hearts repeatedly shouting “OFF WITH THEIR HEADS!”'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数网络中，一些节点充当着关键枢纽。这些节点可以通过查看节点的度数（边数），或检查 PageRank 或各种中心性指标来发现。我们将在后面的章节中使用这些方法来识别重要节点。现在，我们有可以利用的领域知识。我们这些知道这个故事的人，可能能够脱口而出几个故事中的重要主角：爱丽丝、疯帽子、柴郡猫等等。而且，我们这些熟悉这个故事的人，也可能非常清楚红心女王反复喊着“砍掉他们的头！”
- en: In a network, if you remove the most connected and important nodes, what often
    happens looks a lot like the scene in *Star Wars*, where the Death Star explodes.
    All at once, many nodes are transformed into isolates, their edges destroyed along
    with the central node that was removed. This is catastrophic to a network, and
    the information flow is disrupted. Can you imagine the real-world impact of what
    happens when key nodes are removed from a network? Your internet goes down. Your
    power goes out. Supply chains are disrupted. Grocery stores are not stocked, and
    on and on and on. Understanding networks and simulating disruption can give ideas
    on how to bolster the supply chain and information flow. That is the point of
    this exercise.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个网络中，如果你移除最连接的和最重要的节点，通常会发生类似于*星球大战*中死亡星爆炸的场景。瞬间，许多节点变成了孤立节点，它们的边缘也与被移除的中央节点一起被摧毁。这对网络来说是灾难性的，信息流被中断。你能想象当关键节点从网络中被移除时，现实世界会带来怎样的影响吗？你的互联网断了。电力中断了。供应链被打乱了。超市没有货物了，等等等等。理解网络并模拟中断可以为如何加强供应链和信息流提供一些思路。这就是这个练习的意义所在。
- en: 'But we are going to have fun. We are just going to give the Queen of Hearts
    one huge win. We are going to let her execute four of the main characters in the
    story and see what happens:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们要玩得开心。我们将让红心皇后大获全胜。我们将让她执行四个故事中的主要角色，然后看看会发生什么：
- en: 'First, let’s execute them:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们执行这些操作：
- en: '[PRE61]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We decided that the Queen of Hearts has successfully executed `Alice`, `Dormouse`,
    `White Rabbit`, and `Mad Hatter`. It would have been a terrible story if this
    had happened, but we’re going to play it out. I am choosing these four because
    I know that they are key characters in the story. Their removal from the network
    should shatter it, which is what I want to demonstrate.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定红心皇后成功执行了`Alice`、`Dormouse`、`White Rabbit`和`Mad Hatter`。如果真的发生了这种情况，那将是一个可怕的故事，但我们要将它演绎出来。我选择这四个角色是因为我知道他们是故事中的关键人物。移除他们应该会摧毁网络，这是我想要展示的。
- en: After removing just four of the key nodes in this network, what does the rest
    of the network look like? What are the consequences?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅仅移除这四个关键节点后，剩余的网络会是什么样子？这会带来什么后果？
- en: '![Figure 6.11 – Shattered Alice network](img/B17105_06_011.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – 被摧毁的爱丽丝网络](img/B17105_06_011.jpg)'
- en: Figure 6.11 – Shattered Alice network
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 被摧毁的爱丽丝网络
- en: Disaster. We can see several nodes that were made into isolates. We still have
    one primary component in the center, and we have two other smaller components
    with two to four nodes. But in general, the network has been shattered, and the
    information flow has been disrupted. New relationships will need to be built.
    New hierarchies will need to be established. The queen’s court has become dominant,
    just by removing four nodes.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 灾难。我们可以看到几个节点被孤立了。中心依然有一个主组件，我们还有两个较小的组件，每个组件包含两到四个节点。但总的来说，网络已经被打碎，信息流被中断。需要重新建立新的关系，新的层级结构也需要建立。女王的宫廷已经变得主导，仅仅通过移除四个节点就实现了这一点。
- en: 'Let’s look closer at the primary component:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们仔细看看主组件：
- en: '[PRE63]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'There are a few things to understand in this code. First, `nx.connected_components(G)`
    has converted the graph into a list of connected components. One of the components
    will be the primary component, but it is not necessarily the first one on the
    list. After some investigation, we will find that the fourth component was the
    primary component, so let’s set that as `main_component` and then visualize the
    subgraph of that component. This is what we see:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有一些需要理解的地方。首先，`nx.connected_components(G)`将图转换成了一个连接组件的列表。列表中的一个组件将是主组件，但它不一定是列表中的第一个组件。经过一些调查，我们发现第四个组件是主组件，所以我们将其设置为`main_component`，然后可视化该组件的子图。我们看到的是这样的：
- en: '![Figure 6.12 – Queen’s court subgraph](img/B17105_06_012.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – 女王的宫廷子图](img/B17105_06_012.jpg)'
- en: Figure 6.12 – Queen’s court subgraph
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 女王的宫廷子图
- en: The queen’s court is intact and contains characters who were unfortunate enough
    to be trapped in the network before the executions happened.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 女王的宫廷完好无损，包含了一些在执行发生之前不幸被困在网络中的角色。
- en: And that’s it for this chapter!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到此为止！
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took raw data, performed a series of steps to clean the
    network, and even carried out a very simple attack simulation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们从原始数据开始，执行了一系列步骤来清理网络，甚至进行了一个非常简单的攻击模拟。
- en: I hope that at this point, looking at and working with networks is starting
    to feel more natural. The more that I work with networks, the more that I see
    them in everything, and they affect my understanding of the world. We are using
    a fantasy story for this chapter because it is of a manageable size to explain
    the construction, cleaning, and some simple analysis. As you learn more about
    networks, you will likely find that real-world networks are usually much messier,
    more complicated, and larger. I hope that this simple network will give you the
    tools and practice you need to eventually chase much more ambitious problems.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望到目前为止，查看和操作网络开始变得更加自然。随着我越来越多地与网络打交道，我开始在每一件事物中看到它们，并且它们影响着我对世界的理解。我们使用一个虚构的故事来展开这一章，因为它的规模适中，便于讲解构建、清理和一些简单的分析。随着你对网络的了解越来越深，你可能会发现现实中的网络通常更加杂乱、复杂且庞大。我希望这个简单的网络能为你提供所需的工具和实践，最终帮助你去解决更加雄心勃勃的问题。
- en: In the next chapter, we’re going to have a lot of fun. Our next chapter is about
    analyzing whole networks. You will learn all kinds of useful things, such as how
    to identify the most influential nodes in a network. From here on out, we will
    do a lot of network analysis and visualization.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将会非常有趣。下一章我们将讨论如何分析整体网络。你将学到各种有用的知识，比如如何识别网络中最有影响力的节点。从现在开始，我们将进行大量的网络分析和可视化。
- en: 'Part 3: Network Science and Social Network Analysis'
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：网络科学与社交网络分析
- en: In these chapters, we learn how to analyze networks and hunt for insights. We
    begin with a discussion on whole network analysis and gradually zoom in to the
    node level, to investigate egocentric networks. We then look for communities and
    subgroups that exist in networks. Finally, we conclude the book by showing how
    graph data can be useful for supervised and unsupervised machine learning.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些章节中，我们学习如何分析网络并寻找洞察。我们从整体网络分析的讨论开始，逐步缩小到节点层面，探讨自我中心网络。接着，我们会寻找网络中存在的社区和子群体。最后，我们通过展示图数据如何对监督式和无监督式机器学习有用来结束本书。
- en: 'This section includes the following chapters:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括以下章节：
- en: '[*Chapter 7*](B17105_07.xhtml#_idTextAnchor261)*, Whole Network Analysis*'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B17105_07.xhtml#_idTextAnchor261)*, 整体网络分析*'
- en: '[*Chapter 8*](B17105_08.xhtml#_idTextAnchor313)*, Egocentric Network Analysis*'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B17105_08.xhtml#_idTextAnchor313)*, 自我中心网络分析*'
- en: '[*Chapter 9*](B17105_09.xhtml#_idTextAnchor364)*, Community Detection*'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B17105_09.xhtml#_idTextAnchor364)*, 社区检测*'
- en: '[*Chapter 10*](B17105_10.xhtml#_idTextAnchor394)*, Supervised Machine Learning
    on Network Data*'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B17105_10.xhtml#_idTextAnchor394)*, 网络数据上的监督式机器学习*'
- en: '[*Chapter 11*](B17105_11.xhtml#_idTextAnchor432)*, Unsupervised Machine Learning
    on Network Data*'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B17105_11.xhtml#_idTextAnchor432)*, 网络数据上的无监督机器学习*'
