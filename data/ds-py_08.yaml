- en: 'Chapter 8. Analytics Study: Prediction - Financial Time Series Analysis and
    Forecasting'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 分析学习：预测 - 金融时间序列分析与预测
- en: '"When making important decisions, it''s ok to trust your instincts but always
    verify with data"'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “在做出重要决策时，依靠直觉是可以的，但始终要用数据进行验证”
- en: – *David Taieb*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – *David Taieb*
- en: The study of time series is a very important field of data science with multiple
    applications in industry, including the weather, medicine, sales, and, of course,
    finance. It is a broad and complex subject and covering it in detail would be
    outside the scope of this book, but we'll try to touch upon a few of the important
    concepts in this chapter, staying sufficiently high level as not to require any
    particular specific knowledge from the reader. We also show how Python is particularly
    well adapted to time series analysis from data manipulation with libraries like
    pandas ([https://pandas.pydata.org](https://pandas.pydata.org)) for data analysis
    and NumPy ([http://www.numpy.org](http://www.numpy.org)) for scientific computation,
    to visualization with Matplotlib ([https://matplotlib.org](https://matplotlib.org))
    and Bokeh ([https://bokeh.pydata.org](https://bokeh.pydata.org)).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列的研究是数据科学中一个非常重要的领域，广泛应用于各行各业，包括天气、医学、销售以及金融等。它是一个广泛且复杂的主题，详尽讨论超出了本书的范围，但我们会在本章中简要提及一些重要的概念，并保持足够的高层次内容，不要求读者具备特定的知识。我们还将展示Python如何特别适合进行时间序列分析，使用诸如pandas
    ([https://pandas.pydata.org](https://pandas.pydata.org))进行数据分析、NumPy ([http://www.numpy.org](http://www.numpy.org))进行科学计算，Matplotlib
    ([https://matplotlib.org](https://matplotlib.org))和Bokeh ([https://bokeh.pydata.org](https://bokeh.pydata.org))进行数据可视化。
- en: This chapter starts with an introduction to the NumPy library and its most important
    APIs that will be put to good use when building descriptive analytics to analyze
    time series representing stock historical financial data. Using Python libraries
    such as `statsmodels` ([https://www.statsmodels.org/stable/index.html](https://www.statsmodels.org/stable/index.html)),
    we'll show how to do statistical exploration and find properties like stationarity,
    **autocorrelation function** (**ACF**), and **partial autocorrelation function**
    (**PACF**). which will be useful to find trends in the data and creating forecasting
    models. We'll then operationalize these analytics by building a PixieApp that
    summarizes all the important statistics and visualizations about stock historical
    financial data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从NumPy库的介绍开始，介绍其最重要的API，这些API将在构建描述性分析时得到充分应用，分析代表股票历史金融数据的时间序列。我们将使用Python库，如`statsmodels`
    ([https://www.statsmodels.org/stable/index.html](https://www.statsmodels.org/stable/index.html))，展示如何进行统计探索，找到如平稳性、**自相关函数**（**ACF**）和**偏自相关函数**（**PACF**）等属性，这些对于发现数据趋势并创建预测模型非常有用。接着，我们将通过构建一个PixieApp来操作这些分析，汇总股票历史金融数据的重要统计信息和可视化。
- en: In the second part, we'll attempt to build a time series forecasting model that
    predicts future trends of a stock. We'll use an autoregressive model with Integrated
    Moving Average called **ARIMA** where we use previous values in the time series
    to predict the next value. ARIMA is one of the most popular models currently used,
    although new models based on recurrent neural networks are starting to gain in
    popularity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们将尝试构建一个时间序列预测模型，预测股票的未来趋势。我们将使用自回归整合滑动平均模型，简称**ARIMA**，通过使用时间序列中的先前值来预测下一个值。ARIMA是目前最流行的模型之一，尽管基于递归神经网络的新模型开始逐渐获得人气。
- en: As usual, we'll conclude the chapter by incorporating the building of an ARIMA
    time series forecasting model in the `StockExplorer` PixieApp.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将在本章结束时，结合在`StockExplorer` PixieApp中构建ARIMA时间序列预测模型。
- en: Getting started with NumPy
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用NumPy
- en: The NumPy library is one of the main reasons why Python has gained so much traction
    in the data scientist community. It is a foundational library upon which a lot
    of the most popular libraries, such as pandas ([https://pandas.pydata.org](https://pandas.pydata.org)),
    Matplotlib ([https://matplotlib.org](https://matplotlib.org)), SciPy ([https://www.scipy.org](https://www.scipy.org)),
    and scikit-learn ([http://scikit-learn.org](http://scikit-learn.org)) are built.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy库是Python在数据科学家社区中获得广泛关注的主要原因之一。它是一个基础库，许多流行库的构建都依赖于它，例如pandas ([https://pandas.pydata.org](https://pandas.pydata.org))、Matplotlib
    ([https://matplotlib.org](https://matplotlib.org))、SciPy ([https://www.scipy.org](https://www.scipy.org))和scikit-learn
    ([http://scikit-learn.org](http://scikit-learn.org))。
- en: 'The key capabilities provided by NumPy are:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供的关键功能包括：
- en: A very powerful multidimensional NumPy array called ndarray with very high-performance
    mathematical operations (at least compared to regular Python lists and arrays)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个功能强大的多维NumPy数组，称为ndarray，具有非常高效的数学运算性能（至少与常规Python列表和数组相比）
- en: Universal functions also called `ufunc` for short, for providing very efficient
    and easy-to-use element by element operations on one or more ndarray
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用函数，也简称`ufunc`，用于提供非常高效且易于使用的逐元素操作，适用于一个或多个ndarray
- en: Powerful ndarray slicing and selection capabilities
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的ndarray切片和选择功能
- en: Broadcasting functions that make it possible to apply arithmetic operations
    on ndarray of different shapes provided that some rules are respected
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广播函数，使得在遵守某些规则的前提下，可以对不同形状的ndarray进行算术运算
- en: 'Before we start exploring the NumPy APIs, there is one API that is absolutely
    essential to know: `lookfor()`. With this method, you can find a function using
    a query string, which is very useful considering the hundreds of powerful APIs
    provided by NumPy.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始探索NumPy APIs之前，有一个API是绝对必须了解的：`lookfor()`。使用此方法，你可以通过查询字符串查找函数，这在NumPy提供的数百个强大API中非常有用。
- en: 'For example, I can look for a function that computes the average mean of an
    array:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我可以查找一个计算数组平均值的函数：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The results are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Within seconds, I can find a few candidate functions without having to leave
    my Notebook to consult the documentation. In the preceding case, I can spot a
    few functions that are interesting— `np.average` and `np.mean`—for which I still
    need to know their arguments. Again, instead of looking up the documentation which
    takes time and breaks the flow of what I was doing, I use a little-known capability
    of Jupyter Notebooks that provides me with the signature and docstring of the
    function inline. To invoke the inline help of a function, simply position the
    cursor at the end of the function and use the *Shift* + *Tab* combination. Calling
    *Shift* + *Tab* a second time will expand the pop-up window to show more of the
    text as shown in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在几秒钟内，我可以找到几个候选函数，而不必离开我的Notebook去查阅文档。在之前的例子中，我可以找到一些有趣的函数——`np.average`和`np.mean`——但我仍然需要了解它们的参数。同样，我不想花时间查阅文档，打断我的工作流，因此我使用Jupyter
    Notebooks的一个不太为人知的功能，提供函数的签名和文档字符串内联显示。要调用函数的内联帮助，只需将光标定位在函数末尾并使用*Shift* + *Tab*组合键。第二次按*Shift*
    + *Tab*时，将展开弹出窗口，显示更多文本，如下截图所示：
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: *Shift* + *Tab* only applies to a function.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：*Shift* + *Tab* 仅适用于函数。'
- en: '![Getting started with NumPy](img/B09699_08_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用NumPy](img/B09699_08_01.jpg)'
- en: Inline help in Jupyter Notebook.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jupyter Notebook中提供内联帮助。
- en: Using this method, I can rapidly iterate over the candidate functions until
    I find the one that fits my needs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，我可以快速地遍历候选函数，直到找到适合我需求的那个。
- en: 'It is important to note that `np.lookfor()` is not limited to querying the
    NumPy module; you could search in other modules as well. For example, the following
    code searches for `acf` (autocorrelation function) related methods in the `statsmodels`
    package:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`np.lookfor()`不仅限于查询NumPy模块；你也可以在其他模块中进行搜索。例如，以下代码在`statsmodels`包中搜索与`acf`（自相关函数）相关的方法：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode1.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode1.py)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode1.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode1.py)'
- en: 'This produces the following results:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating a NumPy array
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个NumPy数组
- en: 'There are many ways to create a NumPy array. Here are the methods most commonly
    used:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以创建NumPy数组。以下是最常用的方法：
- en: From a Python list or tuple using `np.array()`, for example, `np.array([1, 2,
    3, 4])`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Python列表或元组使用`np.array()`，例如，`np.array([1, 2, 3, 4])`。
- en: 'From one of the NumPy factory functions:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自NumPy工厂函数之一：
- en: '`np.random`: A module that provides a very rich set of functions for randomly
    generating values. This module is composed of the following categories:'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.random`：一个提供非常丰富函数集的模块，用于随机生成值。该模块由以下几类组成：'
- en: 'Simple random data: `rand`, `randn`, `randint`, and so on'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简单的随机数据：`rand`、`randn`、`randint`等
- en: 'Permutations: `shuffle`, `permutation`'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 排列：`shuffle`、`permutation`
- en: 'Distributions: `geometric`, `logistic`, and so on'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分布：`geometric`、`logistic`等
- en: Note
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more information on the `np.random` module here:'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在这里找到关于`np.random`模块的更多信息：
- en: '[https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html)'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html)'
- en: '`np.arange`: Return an ndarray with evenly spaced values within a given interval.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.arange`：返回一个在给定区间内均匀分布的ndarray。'
- en: 'Signature: `numpy.arange([start, ]stop, [step, ]dtype=None)`'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数签名：`numpy.arange([start, ]stop, [step, ]dtype=None)`
- en: 'For example: `np.arange(1, 100, 10)`'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：`np.arange(1, 100, 10)`
- en: 'Results: `array([ 1, 11, 21, 31, 41, 51, 61, 71, 81, 91])`'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果：`array([ 1, 11, 21, 31, 41, 51, 61, 71, 81, 91])`
- en: '`np.linspace`: Similar to `np.arange`, it returns an ndarray with evenly spaced
    values within a given interval, the difference being that with `linspace` you
    specify the number of samples you want instead of the number of steps.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.linspace`：与`np.arange`类似，返回一个在给定区间内均匀分布的ndarray，不同之处在于，使用`linspace`时你指定的是想要的样本数量，而不是步长数量。'
- en: 'For example: `np.linspace(1,100,8, dtype=int)`'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：`np.linspace(1,100,8, dtype=int)`
- en: 'Results: `array([ 1, 15, 29, 43, 57, 71, 85, 100])`'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果：`array([ 1, 15, 29, 43, 57, 71, 85, 100])`
- en: '`np.full`, `np.full_like`, `np.ones`, `np.ones_like`, `np.zeros`, `np.zeros_like`:
    Create an ndarray initialized with a constant value.'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.full`, `np.full_like`, `np.ones`, `np.ones_like`, `np.zeros`, `np.zeros_like`：创建一个用常数值初始化的ndarray。'
- en: 'For example: `np.ones( (2,2), dtype=int)`'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：`np.ones( (2,2), dtype=int)`
- en: 'Results: `array([[1, 1], [1, 1]])`'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果：`array([[1, 1], [1, 1]])`
- en: '`np.eye`, `np.identity`, `np.diag`: Creates an ndarray with constant values
    in the diagonal:'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.eye`, `np.identity`, `np.diag`：创建一个对角线元素为常数值的ndarray：'
- en: 'For example: `np.eye(3,3)`'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：`np.eye(3,3)`
- en: 'Results: `array([[1, 0, 0],[0, 1, 0],[0, 0, 1]])`'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果：`array([[1, 0, 0],[0, 1, 0],[0, 0, 1]])`
- en: Note
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: When the `dtype` argument is not provided, NumPy tries to infer it
    from the input argument. However, it may happen that the type returned is not
    the correct one; for example, float is returned when it should be an integer.
    In this case, you should use the `dtype` argument to force the type. For example:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**：当未提供`dtype`参数时，NumPy会尝试从输入参数中推断数据类型。然而，可能会发生返回的类型不是正确的情况；例如，当应该是整数时，返回了浮动类型。此时，你应当使用`dtype`参数强制指定数据类型。例如：'
- en: '[PRE4]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Why NumPy arrays are so much faster than their Python lists and arrays counterpart?
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为什么NumPy数组比Python的列表和数组更快？
- en: As mentioned before, operations on NumPy arrays run much faster than their Python
    counterpart. This is because Python is a dynamic language that doesn't know, a
    priori, the type it's dealing with and therefore has to constantly query the metadata
    associated with it to dispatch it to the right method. On the other hand, NumPy
    is highly optimized to deal with large multidimensional arrays of data by, among
    other things, delegating the execution of the CPU-intensive routine to external
    highly optimized C libraries that have been precompiled.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述，NumPy数组的操作比Python对应的操作要快得多。这是因为Python是动态语言，它不知道所处理数据的类型，因此必须不断查询与数据类型相关的元数据，以便将操作分派到正确的方法。而NumPy经过高度优化，能够处理大型多维数组，尤其是通过将CPU密集型操作委托给外部经过高度优化的C库，这些C库已被预编译。
- en: 'To be able to do that, NumPy places two important constraints on ndarrays:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了能够做到这一点，NumPy对ndarray施加了两个重要的约束：
- en: '**ndarrays are immutable**: Therefore, if you want to change the shape or the
    size of an ndarray or if you want to add/delete elements, you always must create
    a new one. For example, the following code creates an ndarray using the `arange()`
    function which returns a one-dimensional array with evenly spaced values, and
    then reshapes it to fit a 4 by 5 matrix:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ndarray是不可变的**：因此，如果你想改变一个ndarray的形状或大小，或者想添加/删除元素，你必须总是创建一个新的ndarray。例如，下面的代码使用`arange()`函数创建一个包含均匀分布值的一维数组，然后将其重塑为一个4x5的矩阵：'
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode2.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode2.py)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode2.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode2.py)'
- en: 'The results are as follows:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Elements in an ndarray must be of the same type**: ndarray carries the element
    type in the `dtype` member. When creating a new ndarray using the `nd.array()`
    function, NumPy will automatically infer a type that is suitable for all elements.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ndarray中的元素必须是相同类型**：ndarray在其`dtype`成员中存储元素类型。当使用`nd.array()`函数创建新的ndarray时，NumPy会自动推断一个适合所有元素的类型。'
- en: 'For example: `np.array([1,2,3]).dtype` will be `dtype(''int64'')`.'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：`np.array([1,2,3]).dtype` 将返回 `dtype('int64')`。
- en: '`np.array([1,2,''3'']).dtype` will be `dtype(''<U21'')` where `<` means little endian
    (see [https://en.wikipedia.org/wiki/Endianness](https://en.wikipedia.org/wiki/Endianness))
    and `U21` means a 21-character Unicode string.'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`np.array([1,2,''3'']).dtype` 将返回 `dtype(''<U21'')`，其中`<`表示小端字节序（见[https://en.wikipedia.org/wiki/Endianness](https://en.wikipedia.org/wiki/Endianness)），`U21`表示21个字符的Unicode字符串。'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: You can find detailed information about all the supported data types
    here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：你可以在这里找到有关所有支持的数据类型的详细信息：'
- en: '[https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html](https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html](https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html)'
- en: Operations on ndarray
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对ndarray的操作
- en: Most often, we have the need to summarize data over an ndarray. Fortunately,
    NumPy provides a very rich set of functions (also called **reduction functions**)
    that provide out-of-the-box summarization over an ndarray or an axis of the ndarray.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要对ndarray进行数据汇总。幸运的是，NumPy提供了一套非常丰富的函数（也称为**归约函数**），可以直接对ndarray或ndarray的轴进行汇总。
- en: 'For reference, a NumPy axis corresponds to a dimension of the array. For example,
    a two-dimensional ndarray has two axes: one running across rows, which is referred
    to as axis 0 and one running across columns which is called axis 1.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，NumPy的轴对应数组的一个维度。例如，一个二维ndarray有两个轴：一个沿行方向，称为轴0；一个沿列方向，称为轴1。
- en: 'The following diagram illustrates the axes in a two-dimensional array:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了二维数组中的轴：
- en: '![Operations on ndarray](img/B09699_08_02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Operations on ndarray](img/B09699_08_02.jpg)'
- en: Axes in a two-dimensional array
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 二维数组中的轴
- en: 'Most of the reduction functions we''ll discuss next take an axis as an argument.
    They fall into the following categories:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们讨论的大多数归约函数都将接受轴作为参数。它们分为以下几类：
- en: '**Mathematical functions**:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数学函数**：'
- en: 'Trigonometric: `np.sin`, `np.cos`, and so on'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角函数：`np.sin`，`np.cos`，等等
- en: 'Hyperbolic: `np.sinh`, `np.cosh`, and so on'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双曲线函数：`np.sinh`，`np.cosh`，等等
- en: 'Rounding: `np.around`, `np.floor`, and so on'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四舍五入：`np.around`，`np.floor`，等等
- en: 'Sums, products, differences: `np.sum`, `np.prod`, `np.cumsum`, and so on'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和、积、差：`np.sum`，`np.prod`，`np.cumsum`，等等
- en: 'Exponents and logarithms: `np.exp`, `np.log`, and so on'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数和对数：`np.exp`，`np.log`，等等
- en: 'Arithmetic: `np.add`, `np.multiply`, and so on'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算：`np.add`，`np.multiply`，等等
- en: 'Miscellaneous: `np.sqrt`, `np.absolute`, and so on'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杂项：`np.sqrt`，`np.absolute`，等等
- en: Note
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: All these unary functions (functions that take only one argument)
    work directly at the ndarray level. For example, we can use `np.square` to square
    all the values in an array at once:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**：所有这些一元函数（只接受一个参数的函数）都直接作用于ndarray。例如，我们可以使用`np.square`一次性对数组中的所有值进行平方：'
- en: 'Code: `np.square(np.arange(10))`'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码：`np.square(np.arange(10))`
- en: 'Results: `array([ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81])`'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果：`array([ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81])`
- en: 'You can find more information on NumPy mathematical functions here:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在这里找到更多关于NumPy数学函数的信息：
- en: '[https://docs.scipy.org/doc/numpy/reference/routines.math.html](https://docs.scipy.org/doc/numpy/reference/routines.math.html)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://docs.scipy.org/doc/numpy/reference/routines.math.html](https://docs.scipy.org/doc/numpy/reference/routines.math.html)'
- en: '**Statistical functions**:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统计函数**：'
- en: 'Order statistics: `np.amin`, `np.amax`, `np.percentile`, and so on'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序统计：`np.amin`，`np.amax`，`np.percentile`，等等
- en: 'Averages and variances: `np.median`, `np.var`, `np.std`, and so on'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均数和方差：`np.median`，`np.var`，`np.std`，等等
- en: 'Correlating: `np.corrcoef`, `np.correlate`, `np.cov`, and so on'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关性：`np.corrcoef`，`np.correlate`，`np.cov`，等等
- en: 'Histograms: `np.histogram`, `np.bincount`, and so on'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图：`np.histogram`，`np.bincount`，等等
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: pandas provides very tight integration with NumPy and lets you apply
    these NumPy operations on pandas DataFrames. We''ll use this capability quite
    a bit when analyzing time series in the rest of this chapter.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：pandas与NumPy紧密集成，让你能够在pandas的DataFrame上应用这些NumPy操作。在本章接下来的时间序列分析中，我们将充分利用这一功能。'
- en: 'The following code example creates a pandas DataFrame and computes the square
    on all the columns:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例创建一个pandas DataFrame并对所有列进行平方运算：
- en: '![Operations on ndarray](img/B09699_08_03.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![操作示例](img/B09699_08_03.jpg)'
- en: Applying NumPy operations to pandas DataFrames
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将 NumPy 操作应用于 pandas DataFrame
- en: Selections on NumPy arrays
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy 数组的选择
- en: 'NumPy arrays support similar slicing operations as Python arrays and lists.
    So, using an ndarray created with the `np.arrange()` method, we can do the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组支持与 Python 数组和列表类似的切片操作。因此，使用 `np.arrange()` 方法创建的 ndarray，我们可以执行以下操作：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode3.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode3.py)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode3.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode3.py)'
- en: 'Which produces the following results:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Selections using slices also work with NumPy arrays that have multiple dimensions.
    We can use slices for every dimension in the array. This is not the case for Python
    arrays and lists which only allow indexing using integers of slices.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片进行选择也适用于具有多个维度的 NumPy 数组。我们可以对数组的每个维度使用切片操作。而这在 Python 数组和列表中不可行，它们仅允许使用整数或切片进行索引。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: For reference a slice in Python has the following syntax:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：作为参考，Python 中的切片语法如下：'
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As an example, let''s create a NumPy array with the shape `(3,4)`, that is,
    3 rows * 4 columns:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们创建一个形状为 `(3,4)` 的 NumPy 数组，即 3 行 * 4 列：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Returns:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Suppose that I want to select only the middle of the matrix, that is, [5, 6].
    I can simply apply slices on rows and columns, for example, `[1:2]` to select
    the second row and `[1:3]` to select the second and third values in the second
    row:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想选择矩阵的中间部分，即 [5, 6]。我可以简单地对行和列应用切片，例如，`[1:2]` 选择第二行，`[1:3]` 选择第二行的第二和第三个值：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Returns:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Another interesting NumPy feature is that we can also use predicates to index
    an ndarray with Boolean values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的 NumPy 特性是我们还可以使用谓词来用布尔值对 ndarray 进行索引。
- en: 'For example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Returns:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can then use the Boolean ndarray to select subsets of data with a simple
    and elegant syntax.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用布尔 ndarray 以简单优雅的语法选择数据的子集。
- en: 'For example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Returns:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This is only a small preview of all the selection capabilities of NumPy. For more
    information on NumPy selection, you can visit:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 NumPy 所有选择能力的一个小预览。有关更多 NumPy 选择的信息，您可以访问：
- en: '[https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html](https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html](https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html)'
- en: Broadcasting
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广播
- en: Broadcasting is a very convenient feature of NumPy. It lets you perform arithmetic
    operations on ndarrays having different shapes. The term **broadcasting** comes
    from the fact that the smaller array is automatically duplicated to fit the bigger
    array so that they have compatible shapes. There are however a set of rules that
    govern how broadcasting works.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 广播是 NumPy 的一个非常方便的特性，它允许你对具有不同形状的 ndarrays 执行算术运算。**广播**这个术语来源于这样一个事实：较小的数组会自动被复制以适应较大的数组，从而使它们具有兼容的形状。然而，有一套规则决定了广播如何工作。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more information on broadcasting here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到更多关于广播的信息：
- en: '[https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html](https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html](https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)'
- en: The simplest form of NumPy broadcasting is **scalar broadcasting**, which lets
    you perform element-wise arithmetic operations between an ndarray and a scalar
    (that is, a number).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 广播的最简单形式是**标量广播**，它允许你在 ndarray 和标量（即数字）之间执行逐元素的算术操作。
- en: 'For example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Returns:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: In the following discussion, we assume that we want to operate on
    two ndarrays which do not have the same dimensions.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：在接下来的讨论中，我们假设我们要操作的两个 ndarray 具有不同的维度。'
- en: 'Broadcasting with smaller arrays needs to follow only one rule: one of the
    arrays must have at least one of its dimensions equal to 1\. The idea is to duplicate
    the smaller array along the dimensions that don''t match until they do.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 广播操作对于较小的数组仅需要遵循一个规则：其中一个数组必须至少有一个维度等于 1。其思想是沿着不匹配的维度复制较小的数组，直到它们的维度一致。
- en: 'The following diagram, taken from the [http://www.scipy-lectures.org/](http://www.scipy-lectures.org/)
    website, illustrates very nicely the different cases for adding two arrays:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示来自 [http://www.scipy-lectures.org/](http://www.scipy-lectures.org/) 网站，生动地展示了两数组相加的不同情况：
- en: '![Broadcasting](img/B09699_08_04.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Broadcasting](img/B09699_08_04.jpg)'
- en: Broadcasting flow explained
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 广播流的解释
- en: 'Source: [http://www.scipy-lectures.org/_images/numpy_broadcasting.png](http://www.scipy-lectures.org/_images/numpy_broadcasting.png)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://www.scipy-lectures.org/_images/numpy_broadcasting.png](http://www.scipy-lectures.org/_images/numpy_broadcasting.png)
- en: 'The three use cases demonstrated in the preceding diagram are:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示的三种使用情况是：
- en: '**The array''s dimensions match**: Perform the sum element-wise as usual.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组的维度匹配**：按常规执行元素级的求和。'
- en: '**The smaller array has only 1 row**: Duplicate the rows until the dimensions
    fit the first array. The same algorithm would be used if the smaller array had only
    1 column.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**较小的数组只有 1 行**：复制行，直到维度与第一个数组匹配。如果较小的数组只有 1 列，则会使用相同的算法。'
- en: '**The first array has only 1 column and the second array only 1 row**:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一个数组只有 1 列，第二个数组只有 1 行**：'
- en: Duplicate the columns in the first array until we have the same number of columns
    as the second array
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第一个数组中的列复制，直到列数与第二个数组相同。
- en: Duplicate the rows in the second array until we have the same number of rows
    as the first array
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第二个数组中的行复制，直到行数与第一个数组相同。
- en: 'The following code sample shows NumPy broadcasting in action:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了 NumPy 广播的实际应用：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Results:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 结果：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this section, we provided a basic introduction to NumPy, at least enough
    to get us started and follow the code samples that we'll cover in the rest of
    this chapter. In the next section, we will start the discussion on time series
    with statistical data exploration to find patterns that will help us to identify
    underlying structures in the data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们提供了 NumPy 的基础介绍，至少足够让我们入门并跟随接下来章节中涵盖的代码示例。在下一节中，我们将开始讨论时间序列，并通过统计数据探索来寻找模式，帮助我们识别数据中的潜在结构。
- en: Statistical exploration of time series
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列的统计探索
- en: For the sample application, we'll use stock historical financial data provided
    by the Quandl data platform financial APIs ([https://www.quandl.com/tools/api](https://www.quandl.com/tools/api))
    and the `quandl` Python library ([https://www.quandl.com/tools/python](https://www.quandl.com/tools/python)).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于示例应用，我们将使用 Quandl 数据平台金融 API 提供的股票历史金融数据 ([https://www.quandl.com/tools/api](https://www.quandl.com/tools/api))
    和 `quandl` Python 库 ([https://www.quandl.com/tools/python](https://www.quandl.com/tools/python))。
- en: 'To get started, we need to install the `quandl` library by running the following
    command in its own cell:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用，我们需要通过在独立的单元格中运行以下命令来安装 `quandl` 库：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: As always, don''t forget to restart the kernel after the installation
    is complete.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：和往常一样，安装完成后不要忘记重启内核。'
- en: 'Access to the Quandl data is free but limited to 50 calls a day, but you can
    bypass this limit by creating a free account and get an API key:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Quandl 数据是免费的，但每天限 50 次请求，不过你可以通过创建一个免费账户并获取 API 密钥来绕过此限制：
- en: Go to [https://www.quandl.com](https://www.quandl.com) and create a new account
    by clicking on the **SIGN UP** button on the top right.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://www.quandl.com](https://www.quandl.com)，通过点击右上角的 **SIGN UP** 按钮创建一个新账户。
- en: Fill up the form in three steps of the sign-up wizard. (I chose **Personal**,
    but depending on your situation, you may want to choose **Business** or **Academic**.)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在注册向导的三步中填写表单。（我选择了 **Personal**，但根据你的情况，你可能想选择 **Business** 或 **Academic**。）
- en: At the end of the process, you should receive an email confirmation with a link
    to activate the account.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成过程后，你应该会收到一封包含激活账户链接的电子邮件确认。
- en: Once the account is activated, log in to the Quandl platform website and click on
    **Account Settings** in the top right-hand menu, and then go to the **API KEY**
    tab.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户激活后，登录 Quandl 平台网站，在右上角菜单点击 **Account Settings**，然后转到 **API KEY** 标签。
- en: 'Copy the API key provided in this page. This value will be used to programmatically
    set the key in the `quandl` Python library as shown in the following code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制本页面提供的 API 密钥。此值将用于在 `quandl` Python 库中通过编程方式设置密钥，如以下代码所示：
- en: '[PRE23]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `quandl` library is mainly composed of two APIs:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`quandl` 库主要由两个 API 组成：'
- en: '`quandl.get(dataset, **kwargs)`: This returns a pandas DataFrame or a NumPy
    array for the requested dataset(s). The `dataset` argument can be either a string
    (single dataset) or a list of strings (multi dataset). Each dataset follows the
    syntax `database_code/dataset_code` when `database_code` is a data publisher and
    `dataset_code` related to the resource. (See next how to get a full list of all
    the `database_code` and `dataset_code`).'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quandl.get(dataset, **kwargs)`：这将返回一个pandas DataFrame或一个NumPy数组，表示请求的数据集。`dataset`参数可以是一个字符串（单一数据集）或一个字符串列表（多个数据集）。每个数据集遵循`database_code/dataset_code`的语法，其中`database_code`是数据发布者，`dataset_code`与资源相关。（接下来我们将介绍如何获取所有`database_code`和`dataset_code`的完整列表）。'
- en: 'The keyword arguments enable you to refine the query. You can find the full
    list of supported arguments in the `quandl` code on GitHub: [https://github.com/quandl/quandl-python/blob/master/quandl/get.py](https://github.com/quandl/quandl-python/blob/master/quandl/get.py).'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关键字参数使你能够精细化查询。你可以在GitHub上的`quandl`代码中找到支持的所有参数的完整列表：[https://github.com/quandl/quandl-python/blob/master/quandl/get.py](https://github.com/quandl/quandl-python/blob/master/quandl/get.py)。
- en: 'One interesting keyword argument called `returns` controls the data structure
    returned by the method and can take the following two values:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个有趣的关键字参数`returns`控制方法返回的数据结构，它可以取以下两个值：
- en: '`pandas`: Returns a pandas DataFrame'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pandas`：返回一个pandas DataFrame'
- en: '`numpy`: Returns a NumPy array'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy`：返回一个NumPy数组'
- en: '`quandl.get_table(datatable_code, **kwargs)`: Returns a non-time series dataset
    (called `datatable`) about a resource. We will not be using this method in this
    chapter, but you can find out more about it by looking at the code: [https://github.com/quandl/quandl-python/blob/master/quandl/get_table.py](https://github.com/quandl/quandl-python/blob/master/quandl/get_table.py).'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quandl.get_table(datatable_code, **kwargs)`：返回一个非时间序列数据集（称为`datatable`），用于描述某个资源。在本章中我们不会使用这个方法，但你可以通过查看代码了解更多：[https://github.com/quandl/quandl-python/blob/master/quandl/get_table.py](https://github.com/quandl/quandl-python/blob/master/quandl/get_table.py)。'
- en: 'To get the list of `database_code`, we use the Quandl REST API: `https://www.quandl.com/api/v3/databases?api_key=YOUR_API_KEY&page=n`
    which uses pagination.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取`database_code`的列表，我们使用Quandl REST API：`https://www.quandl.com/api/v3/databases?api_key=YOUR_API_KEY&page=n`，它使用了分页功能。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: In the preceding URL, replace the `YOUR_API_KEY` value with your
    actual API key.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：在前面的URL中，将`YOUR_API_KEY`值替换为你实际的API密钥。'
- en: 'The returned payload is in the following JSON format:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的payload是以下JSON格式：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode4.json](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode4.json)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode4.json](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode4.json)'
- en: 'We use a `while` loop to load all the available pages relying on the `payload[''meta''][''next_page'']`
    value to know when to stop. At each iteration, we append the list of `database_code`
    information into an array called `databases` as shown in the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`while`循环加载所有可用的页面，依赖于`payload['meta']['next_page']`值来判断何时停止。在每次迭代中，我们将`database_code`信息的列表追加到一个名为`databases`的数组中，如下所示：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode5.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode5.py)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode5.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode5.py)'
- en: 'The `databases` variable now contains an array of JSON objects containing the
    metadata about each `database_code`. We use the PixieDust `display()` API to look at
    the data in a nice searchable table:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`databases`变量现在包含一个包含每个`database_code`元数据的JSON对象数组。我们使用PixieDust的`display()`
    API以漂亮的可搜索表格形式查看数据：'
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the following screenshot of the PixieDust table, we use the **Filter** button
    described in [Chapter 2](ch02.xhtml "Chapter 2. Python and Jupyter Notebooks to
    Power your Data Analysis"), *Python and Jupyter Notebooks to Power your Data Analysis*,
    to access the statistics about the count of datasets available in each database,
    for example, min, max and mean:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的PixieDust表格截图中，我们使用[第2章](ch02.xhtml "第2章：用Python和Jupyter Notebook驱动数据分析")中描述的**筛选**按钮，*用Python和Jupyter
    Notebook驱动数据分析*，来查看每个数据库中可用数据集的统计信息，例如最小值、最大值和均值：
- en: '![Statistical exploration of time series](img/B09699_08_05.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![时间序列的统计探索](img/B09699_08_05.jpg)'
- en: List of Quandl database codes
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Quandl数据库代码列表
- en: 'After searching for a database that contains stock information from the **New York Stock
    Exchange** (**NYSE**), I found the `XNYS` database as shown here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找包含 **纽约证券交易所**（**NYSE**）股票信息的数据库时，我找到了 `XNYS` 数据库，如下所示：
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: Make sure to increase the number of the value displayed to `300` in the
    chart options dialog, so all the results are shown in the table.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：确保在图表选项对话框中将显示的值数量增加到 `300`，以便所有结果都能在表格中显示。'
- en: '![Statistical exploration of time series](img/B09699_08_06.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![时间序列的统计探索](img/B09699_08_06.jpg)'
- en: Looking for a database with stock data from NYSE
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找包含纽约证券交易所（NYSE）股票数据的数据库
- en: Unfortunately, the `XNYS` database is not public and requires a paid subscription.
    I ended up using the `WIKI` database code, which for some reason was not part
    of the list returned by the preceding API request, but which I found in some code
    examples.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`XNYS` 数据库是私有的，需要付费订阅。我最终使用了 `WIKI` 数据库代码，尽管它没有出现在之前 API 请求返回的列表中，但我在一些代码示例中找到了它。
- en: 'I then used the `https://www.quandl.com/api/v3/databases/{database_code}/codes`
    REST API to get the list of datasets. Fortunately, this API returns a CSV compressed
    in a ZIP file, which the PixieDust `sampleData()` method can handle easily, as
    shown in the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我随后使用 `https://www.quandl.com/api/v3/databases/{database_code}/codes` REST API
    获取数据集列表。幸运的是，这个 API 返回的是一个压缩在 ZIP 文件中的 CSV 文件，PixieDust 的 `sampleData()` 方法可以轻松处理，如下代码所示：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode6.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode6.py)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode6.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode6.py)'
- en: 'In the PixieDust table interface, we click on the **Options** dialog to increase
    the number of values displayed to `4000` so that we can fit the entire dataset
    (which is 3,198) and use the search bar to look for particular stocks as shown
    in the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PixieDust 表格界面中，我们点击 **选项** 对话框，将显示的值数量增加到 `4000`，以便可以显示整个数据集（共有 3,198 条），并使用搜索框查找特定的股票，如下图所示：
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: The search bar only searches for the rows that are displayed in the
    browser, which can be a smaller set when the dataset is too large. Since in this
    case, the dataset is too large, it would be impractical to increase the number
    of rows to display; it is recommended to use the **Filter** instead which guarantees
    to query the entire dataset.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：搜索框只会搜索浏览器中显示的行，当数据集过大时，这可能是一个较小的子集。由于本例中数据集过大，增加显示的行数并不实际；因此，建议使用 **筛选器**，它可以确保查询整个数据集。'
- en: The CSV file returned by the `quandl` API doesn't have a header, but `PixieDust.sampleData()`
    expects one to be there. This is currently a limitation that will be addressed
    in the future.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`quandl` API 返回的 CSV 文件没有表头，但 `PixieDust.sampleData()` 期望文件中包含表头。这是当前的一个限制，将来会进行改进。'
- en: '![Statistical exploration of time series](img/B09699_08_07.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![时间序列的统计探索](img/B09699_08_07.jpg)'
- en: List of datasets for the WIKI database
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: WIKI 数据库的数据集列表
- en: 'For the rest of this section, we load the Microsoft stock (ticker symbol MSFT)
    historical time series data for the last several years and start exploring its
    statistical properties. In the following code, we use `quandl.get()` with the
    `WIKI/MSFT` dataset. We add a column called `daily_spread` that computes the daily
    gain/loss by calling the pandas `diff()` method, which returns the difference
    between the current and previous adjusted close price. Note that the returned
    pandas DataFrame uses the dates as an index, but PixieDust does not support plotting
    time series by the index at this time. Therefore, in the following code, we call
    `reset_index()` to convert the `DateTime` index into a new column called `Date`
    that contains the dates information:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们加载了微软（Microsoft）股票（股票代码 MSFT）过去几年的历史时间序列数据，并开始探索其统计属性。在以下代码中，我们使用
    `quandl.get()` 来获取 `WIKI/MSFT` 数据集。我们添加了一个名为 `daily_spread` 的列，通过调用 pandas 的 `diff()`
    方法计算每日涨跌，这个方法返回当前调整后的收盘价与前一个收盘价之间的差异。请注意，返回的 pandas DataFrame 使用日期作为索引，但 PixieDust
    当前不支持按索引绘制时间序列图表。因此，在以下代码中，我们调用 `reset_index()` 将 `DateTime` 索引转换为一个名为 `Date`
    的新列，其中包含日期信息：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode7.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode7.py)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode7.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode7.py)'
- en: For our first data exploration, we use `display()` to create a line chart of
    the stock adjusted closing price over time using the Bokeh renderer.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一次数据探索，我们使用`display()`创建了一个基于Bokeh渲染器的股票调整后收盘价随时间变化的折线图。
- en: 'The following screenshot shows the **Options** configuration and the resulting
    line chart:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了**选项**配置及其生成的折线图：
- en: '![Statistical exploration of time series](img/B09699_08_08.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![时间序列的统计探索](img/B09699_08_08.jpg)'
- en: MSFT Price over time, adjusted for dividend distribution, stock split, and other
    corporate actions
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: MSFT股价随时间变化，已调整股息分配、股票拆分及其他公司行为
- en: 'We can also generate a chart that shows the daily spread for each day of the
    period, as shown in the following screenshot:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以生成一个图表，显示该期间每天的收益，以下截图展示了该图表：
- en: '![Statistical exploration of time series](img/B09699_08_09.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![时间序列的统计探索](img/B09699_08_09.jpg)'
- en: Daily Spread for the MSFT stock
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: MSFT股票的每日收益
- en: Hypothetical investment
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 假设投资
- en: As an exercise, let's try to create a chart that shows how a hypothetical investment
    of $10,000 in the selected stock (MSFT) would fare over time. To do this, we must
    compute a DataFrame that contains the total investment value for each day of the
    period, factoring in the daily spread that we calculated in the previous paragraph
    and use the PixieDust `display()` API to visualize the data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，我们尝试创建一个图表，显示在所选股票（MSFT）中，假设投资10,000美元随着时间的推移会如何变化。为此，我们必须计算一个数据框，包含每一天的总投资价值，考虑到我们在上一段计算的每日收益，并使用PixieDust的`display()`
    API来可视化数据。
- en: We use pandas ability to select rows using a predicate based on dates to first
    filter the DataFrame to select only the data points in the period we are interested
    in. We then calculate the number of shares bought by dividing the initial investment
    of $10,000 by the closing price on the first day of the period and add the initial
    investment value. All this computation is made very easy, thanks to the efficient
    series computation of pandas and the underlying NumPy foundational library. We use
    the `np.cumsum()` method ([https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.cumsum.html](https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.cumsum.html))
    to compute the cumulative sum of all the daily gains adding the initial investment
    value of $10,000.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用pandas的能力，根据日期条件选择行，首先过滤数据框，只选择我们感兴趣的时间段内的数据点。然后通过将初始投资10,000美元除以该期间第一天的收盘价来计算购买的股票数量，并加上初始投资价值。所有这些计算都变得非常简单，得益于pandas高效的系列计算和底层的NumPy基础库。我们使用`np.cumsum()`方法（[https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.cumsum.html](https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.cumsum.html)）来计算所有每日收益的累积和，并加上初始投资金额10,000美元。
- en: Finally, we make the chart easier to read by using the `resample()` method that
    converts the frequency from daily to monthly computing the new values using the average
    for the month.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过使用`resample()`方法将频率从每日转换为每月，并使用该月的平均值计算新值，从而使图表更易于阅读。
- en: 'The following code computes the growth DataFrame using a period starting in May 2016:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码计算了从2016年5月开始的增长数据框（DataFrame）：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode8.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode8.py)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode8.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode8.py)'
- en: 'The following screenshot shows the graph generated by the `display()` API including
    the configuration options:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`display()` API生成的图表，包括配置选项：
- en: '![Hypothetical investment](img/B09699_08_10.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![假设投资](img/B09699_08_10.jpg)'
- en: Hypothetical portfolio growth
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 假设投资组合增长
- en: Autocorrelation function (ACF) and partial autocorrelation function (PACF)
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自相关函数（ACF）和偏自相关函数（PACF）
- en: Before trying to generate predictive models, it is essential to understand whether
    the time series has identifiable patterns, such as seasonality or trends. One
    popular technique is to look at how data points correlate with previous data points
    according to a specified time lag. The intuition is that the autocorrelation would
    reveal internal structures, such as for example, identifying periods when high
    correlation (positive or negative) occurs. You can experiment with different lag
    values (that is, for each data point, how many previous points are you taking
    into account) to find the right periodicity.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试生成预测模型之前，了解时间序列是否具有可识别的模式（如季节性或趋势）是至关重要的。一种常见的技术是查看数据点如何根据指定的时间滞后与前一个数据点进行关联。直观地说，自相关性会揭示内部结构，例如识别高相关性（正相关或负相关）发生的时期。你可以尝试不同的滞后值（也就是对于每个数据点，你会考虑多少个之前的数据点）来找到合适的周期性。
- en: Computing the ACF usually requires calculating the Pearson R correlation coefficient
    for the set of data points ([https://en.wikipedia.org/wiki/Pearson_correlation_coefficient](https://en.wikipedia.org/wiki/Pearson_correlation_coefficient))
    which is not a trivial thing to do. The good news is that the `statsmodels` Python
    library has a `tsa` package (**tsa** stands for **time series analysis**) that
    provides helper methods for computing the ACF, that are tightly integrated with
    pandas Series.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 计算自相关函数通常需要计算一组数据点的皮尔逊相关系数（[https://en.wikipedia.org/wiki/Pearson_correlation_coefficient](https://en.wikipedia.org/wiki/Pearson_correlation_coefficient)），这并不是一件简单的事情。好消息是，`statsmodels`
    Python库提供了一个`tsa`包（**tsa**代表**时间序列分析**），它提供了紧密集成于pandas Series的辅助方法，用于计算自相关函数（ACF）。
- en: Note
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: If not already done, we install the `statsmodels` package using the following
    command, restarting the kernel after completion:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：如果尚未完成，请使用以下命令安装`statsmodels`包，并在完成后重启内核：'
- en: '[PRE30]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following code uses `plot_acf()` from the `tsa.api.graphics` package to
    compute and visualize the ACF for the adjusted close price of the MSFT stock time series:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用来自`tsa.api.graphics`包的`plot_acf()`函数来计算并可视化MSFT股票时间序列的自相关函数（ACF）：
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following is the result:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果：
- en: '![Autocorrelation function (ACF) and partial autocorrelation function (PACF)](img/B09699_08_11.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![自相关函数（ACF）和偏自相关函数（PACF）](img/B09699_08_11.jpg)'
- en: ACF for MSFT with lags = 100
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 滞后为100时的MSFT自相关函数（ACF）
- en: The preceding chart shows the autocorrelation of the data at a number of previous
    data points (lag) given by the *x* abscissa. So, at lag `0`, you always have an
    autocorrelation of `1.0` (you always correlate perfectly with yourself), lag `1`
    shows the autocorrelation with the previous data point, lag `2` shows the autocorrelation
    with the data point that is two steps behind. We can clearly see that the autocorrelation
    decreases as the lags increase. In the preceding chart, we used only 100 lags,
    and we see that the autocorrelation still remains statistically significant at
    around 0.9, which tells us that data separated by long periods of time is not
    correlated. This suggests that the data has a trend, which is quite obvious when
    glancing at the overall price chart.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图表展示了数据在多个前期数据点（滞后）上的自相关性，这些滞后值由*x*坐标轴表示。因此，在滞后为`0`时，你总是会有一个自相关值为`1.0`（你总是与你自己完全相关），滞后`1`显示的是与前一个数据点的自相关性，滞后`2`显示的是与两个数据点之前的自相关性。我们可以清楚地看到，随着滞后的增加，自相关性逐渐下降。在上面的图表中，我们只使用了100个滞后，并且看到自相关性仍然在0.9左右，表明数据间的长时间间隔并没有关联。这表明数据存在趋势，从整体价格图上来看，这一点非常明显。
- en: 'To confirm this hypothesis, we plot the ACF chart with a bigger `lags` argument,
    say `1000` (which is not unreasonable given the fact that our series has more
    than 10,000 data points), as shown in the following screenshot:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这个假设，我们绘制了一个具有更大`lags`参数的ACF图，例如`1000`（考虑到我们的数据序列有超过10,000个数据点，这并不为过），如下图所示：
- en: '![Autocorrelation function (ACF) and partial autocorrelation function (PACF)](img/B09699_08_12.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![自相关函数（ACF）和偏自相关函数（PACF）](img/B09699_08_12.jpg)'
- en: ACF for MSFT with lags = 1000
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 滞后为1000时的MSFT自相关函数（ACF）
- en: We now clearly see that the autocorrelation falls below the significance level
    at around `600` lags.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以清楚地看到，自相关性在约`600`个滞后值时低于显著性水平。
- en: 'To better illustrate how the ACF works, let''s generate a time series that
    is periodic, without a trend and see what we can learn. For example, we can use
    `np.cos()` on a series of evenly spaced points generated with `np.linspace()`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明 ACF 如何工作，让我们生成一个周期性的时间序列，该序列没有趋势，看看我们可以学到什么。例如，我们可以在用 `np.linspace()`
    生成的一系列均匀间隔的点上使用 `np.cos()`：
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode9.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode9.py)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode9.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode9.py)'
- en: 'The results are as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Autocorrelation function (ACF) and partial autocorrelation function (PACF)](img/B09699_08_13.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![自相关函数（ACF）和偏自相关函数（PACF）](img/B09699_08_13.jpg)'
- en: ACF for a periodic series with no trends
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 没有趋势的周期性序列的 ACF
- en: In the preceding chart, we can see that the autocorrelation spikes again at
    regular intervals (every 5 lags or so), clearly showing periodicity (also called
    seasonality when dealing with real-world data).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到自相关再次在固定间隔（大约每 5 个滞后期）处出现峰值，清晰地显示了周期性（在处理真实世界数据时，这也称为季节性）。
- en: 'Using ACF to detect structure in your time series can sometimes lead to problems,
    especially when you have strong periodicity. In this case, you''ll always see
    a spike in autocorrelation at a multiple of the period, no matter how far back
    you try to autocorrelate your data and this could lead to the wrong interpretation.
    To work around this problem, we use the PACF which uses a shorter lag and unlike
    ACF, doesn''t reuse correlations previously found in shorter time periods. The
    math for ACF and PACF is rather complex, but the reader only needs to understand
    the intuition behind it and happily use libraries such as `statsmodels` to do
    the heavy lifting computation. One resource I used to get more information on
    ACF and PACF can be found here: [https://www.mathworks.com/help/econ/autocorrelation-and-partial-autocorrelation.html](https://www.mathworks.com/help/econ/autocorrelation-and-partial-autocorrelation.html).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ACF 来检测时间序列中的结构有时会导致问题，尤其是当你有强周期性时。在这种情况下，无论你试图多么往回计算自相关，总会看到自相关在周期的倍数处出现一个峰值，这可能会导致错误的解释。为了解决这个问题，我们使用
    PACF，它使用较短的滞后期，且与 ACF 不同，它不会重复使用之前在较短时间段内发现的相关性。ACF 和 PACF 的数学原理相当复杂，但读者只需要理解其背后的直觉，并愉快地使用像
    `statsmodels` 这样的库来进行繁重的计算。我获取有关 ACF 和 PACF 更多信息的一个资源可以在这里找到：[https://www.mathworks.com/help/econ/autocorrelation-and-partial-autocorrelation.html](https://www.mathworks.com/help/econ/autocorrelation-and-partial-autocorrelation.html)。
- en: 'Back to our MSFT stock time series, the following code shows how to plot its
    PACF using the `smt.graphics` package:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 MSFT 股票时间序列，以下代码展示了如何使用 `smt.graphics` 包绘制其 PACF：
- en: '[PRE33]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode10.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode10.py)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode10.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode10.py)'
- en: 'The results are shown in the following screenshot:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在下面的截图中：
- en: '![Autocorrelation function (ACF) and partial autocorrelation function (PACF)](img/B09699_08_14.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![自相关函数（ACF）和偏自相关函数（PACF）](img/B09699_08_14.jpg)'
- en: Partial autocorrelation for the MSFT stock time series
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: MSFT 股票时间序列的偏自相关
- en: We'll get back to ACF and PACF later on in this chapter when we discuss time
    series forecasting with the ARIMA model.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论 ARIMA 模型进行时间序列预测时，再回到 ACF 和 PACF。
- en: In this section, we've discussed multiple ways to explore the data. It is of
    course by no means exhaustive, but we get the idea of how tools such as Jupyter,
    pandas, NumPy, and PixieDust make it easier to experiment and fail fast if necessary.
    In the next section, we will build a PixieApp that brings all these charts together.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了多种探索数据的方法。当然，这些方法绝非详尽无遗，但我们可以看到像 Jupyter、pandas、NumPy 和 PixieDust
    等工具如何让实验变得更容易，并在必要时快速失败。在下一节中，我们将构建一个 PixieApp，将所有这些图表汇聚在一起。
- en: Putting it all together with the StockExplorer PixieApp
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切整合在一起，使用 StockExplorer PixieApp
- en: 'For the first version of our `StockExplorer` PixieApp, we want to operationalize
    the data exploration of a stock data time series selected by the user. Similar
    to the other PixieApps we''ve built, the first screen has a simple layout with
    an input box where the user can enter a list of stock tickers separated by commas,
    and an **Explore** button to start data exploration. The main screen is composed
    of a vertical navigator bar with a menu for each type of data exploration. To
    make the PixieApp code more modular and easier to maintain and extend, we implement
    each data exploration screen in its own child PixieApp which is triggered by the
    vertical navigation bar. Also, each child PixieApp inherits from a base class
    called `BaseSubApp` that provides common functionalities useful to all the subclasses.
    The following diagram shows the overall UI layout as well as a class diagram for
    all the child PixieApps:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们 `StockExplorer` PixieApp 的第一个版本，我们希望实现用户选择的股票数据时间序列的数据探索。与我们构建的其他 PixieApps
    类似，第一个屏幕有一个简单的布局，包含一个输入框，用户可以在其中输入以逗号分隔的股票代码列表，并有一个 **Explore** 按钮来开始数据探索。主屏幕由一个垂直导航栏组成，每个数据探索类型都有一个菜单。为了使
    PixieApp 代码更加模块化，并且更易于维护和扩展，我们将在自己的子 PixieApp 中实现每个数据探索屏幕，这些子 PixieApp 通过垂直导航栏触发。同时，每个子
    PixieApp 都继承自一个名为 `BaseSubApp` 的基类，提供所有子类共有的功能。以下图显示了整体 UI 布局以及所有子 PixieApps 的类图：
- en: '![Putting it all together with the StockExplorer PixieApp](img/B09699_08_15.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![将所有内容整合在一起，使用 StockExplorer PixieApp](img/B09699_08_15.jpg)'
- en: UI layout of the StockExplorer PixieApp
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 股票探索 PixieApp 的 UI 布局
- en: Let's first look at the implementation for the welcome screen. It is implemented
    in the default route for the `StockExplorer` PixieApp class. The following code
    shows a partial implementation of the `StockExplorer` class to include the default
    route only.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先来看一下欢迎屏幕的实现。它是在 `StockExplorer` PixieApp 类的默认路由中实现的。以下代码显示了 `StockExplorer`
    类的部分实现，仅包括默认路由。
- en: Note
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: Do not try to run this code yet, until the full implementation is provided.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：在提供完整实现之前，不要尝试运行此代码。'
- en: '[PRE34]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode11.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode11.py)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode11.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode11.py)'
- en: 'The preceding code is very similar to the other sample PixieApps we''ve seen
    so far. The **Explore** button contains the following two PixieApp attributes:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与我们迄今为止看到的其他示例 PixieApps 非常相似。**Explore** 按钮包含以下两个 PixieApp 属性：
- en: 'A `pd_script` child element, which calls a Python snippet to set the stock
    tickers. We also use the `$val` directive to retrieve the user-entered value for
    the stock tickers:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `pd_script` 子元素，它调用一个 Python 代码片段来设置股票代码。我们还使用 `$val` 指令来获取用户输入的股票代码值：
- en: '[PRE35]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `pd_options` attribute, which points to the `explore` route:'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pd_options` 属性，它指向 `explore` 路由：'
- en: '[PRE36]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `select_tickers` helper method stores the list of tickers in a dictionary
    member variable and selects the first one as the active ticker. For performance
    reasons, we only load the data when needed, that is, when setting the active ticker
    for the first time or when the user clicks on a particular ticker in the UI.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`select_tickers` 辅助方法将股票代码列表存储在字典成员变量中，并选择第一个作为活动股票代码。出于性能考虑，我们只在需要时加载数据，也就是在第一次设置活动股票代码时，或者当用户在
    UI 中点击特定股票代码时。'
- en: Note
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: As in previous chapters, the `[[StockExplorer]]` notation indicates
    that the code that follows is part of the `StockExplorer` class.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：与前几章一样，`[[StockExplorer]]` 表示以下代码是 `StockExplorer` 类的一部分。'
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode12.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode12.py)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode12.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode12.py)'
- en: 'The lazy loading of the stock data for a particular ticker symbol into a pandas
    DataFrame is done in `set_active_ticker()`. We first check whether the DataFrame
    has already been loaded by looking if the `df` key is present and, if not, we call the
    `quandl` API with the `dataset_code`: `''WIKI/{ticker}''`. We also add a column
    that computes the daily spread of the stock that will be displayed in the basic
    exploration screen. Finally, we need to call `reset_index()` ([https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.reset_index.html](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.reset_index.html))
    on the DataFrame to convert the index which is a `DateTimeIndex` into its own column
    called `Date`. The reason is that the PixieDust `display()` doesn''t yet support visualization
    of DataFrame with a `DateTimeIndex`.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 特定股票代码的数据懒加载到pandas DataFrame是在`set_active_ticker()`中完成的。我们首先检查DataFrame是否已经加载，通过查看`df`键是否存在，如果不存在，我们调用`quandl`
    API，传入`dataset_code`：`'WIKI/{ticker}'`。我们还添加了一个列，用于计算股票的每日波动，这将在基本探索界面中显示。最后，我们需要调用`reset_index()`（[https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.reset_index.html](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.reset_index.html)）对DataFrame进行处理，将索引（`DateTimeIndex`）转换为名为`Date`的列。原因是PixieDust的`display()`尚不支持可视化包含`DateTimeIndex`的DataFrame。
- en: In the `explore` route, we return an HTML fragment that builds the layout for
    the whole screen. As shown in the preceding mock-up, we use the `btn-group-vertical`
    and `btn-group-toggle` bootstrap classes to create the vertical navigation bar.
    The list of menus and associated child PixieApp are defined in the `tabs` Python
    variable, and we use Jinja2 `{%for loop%}` to build the content. We also add a
    placeholder `<div>` element with `id ="analytic_screen{{prefix}}"` that will be
    the recipient of the child PixieApp screen.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在`explore`路由中，我们返回一个构建整个屏幕布局的HTML片段。如前面的示意图所示，我们使用`btn-group-vertical`和`btn-group-toggle`的Bootstrap类来创建垂直导航栏。菜单列表及其关联的子PixieApp定义在`tabs`
    Python变量中，并且我们使用Jinja2的`{%for loop%}`来构建内容。我们还添加了一个占位符`<div>`元素，`id ="analytic_screen{{prefix}}"`，它将成为子PixieApp屏幕的接收容器。
- en: 'The `explore` route implementation is shown here:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`explore`路由的实现如下所示：'
- en: '[PRE38]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode13.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode13.py)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode13.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode13.py)'
- en: In the preceding code, notice that we use the `@templateArgs` decorator because
    we want to use the `tabs` variable, which is created locally to the method implementation,
    in the Jinja2 template.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请注意我们使用了`@templateArgs`装饰器，因为我们想在Jinja2模板中使用方法实现局部创建的`tabs`变量。
- en: Each menu in the vertical navigation bar points to the same `analytic_screen{{prefix}}`
    target and invokes the `show_analytic` route with the selected child PixieApp
    class name referenced by `{{subapp}}`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直导航栏中的每个菜单都指向相同的`analytic_screen{{prefix}}`目标，并通过`{{subapp}}`引用的选定子PixieApp类名调用`show_analytic`路由。
- en: In turn, the `show_anatytic` route simply returns an HTML fragment with a `<div>` element
    that has a `pd_app` attribute referencing the child PixieApp class name. We also
    use the `pd_render_onload` attribute to ask PixieApp to render the content of the
    `<div>` element as soon as it is loaded in the browser DOM.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，`show_analytic`路由仅返回一个包含`<div>`元素的HTML片段，该元素具有`pd_app`属性，引用子PixieApp类名。我们还使用`pd_render_onload`属性，要求PixieApp在浏览器DOM加载时立即渲染`<div>`元素的内容。
- en: 'The following code is for the `show_analytic` route:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于`show_analytic`路由：
- en: '[PRE39]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode14.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode14.py)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode14.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode14.py)'
- en: BaseSubApp – base class for all the child PixieApps
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BaseSubApp – 所有子PixieApp的基类
- en: 'Let''s now look at the implementation for each of the child PixieApps and how
    the base class `BaseSubApp` is used to provide common functionalities. For each
    child PixieApp we want the user to be able to select a stock ticker through a
    tabbed interface as shown in the following screenshot:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看每个子PixieApp的实现，以及如何使用基类`BaseSubApp`来提供共享功能。对于每个子PixieApp，我们希望用户能够通过标签页界面选择股票代码，如下图所示：
- en: '![BaseSubApp – base class for all the child PixieApps](img/B09699_08_16.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![BaseSubApp – 所有子 PixieApp 的基类](img/B09699_08_16.jpg)'
- en: Tab widget for MSFT, IBM, AMZN tickers
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: MSFT、IBM、AMZN 股票代码的选项卡小部件
- en: 'Instead of repeating the HTML fragment for every child PixieApp, we use a technique
    that I particularly like which consists of creating a Python decorator called
    `add_ticker_selection_markup` that dynamically changes how the function behaves
    (for more information on Python decorators, see [https://wiki.python.org/moin/PythonDecorators](https://wiki.python.org/moin/PythonDecorators)).
    This decorator is created in the `BaseSubApp` class and will automatically prepend
    the tab selection widget HTML markup for the route, as shown in the following
    code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免为每个子 PixieApp 重复 HTML 片段，我们使用了一种我特别喜欢的技术，即创建一个名为`add_ticker_selection_markup`的
    Python 装饰器，它动态改变函数的行为（有关 Python 装饰器的更多信息，请参见 [https://wiki.python.org/moin/PythonDecorators](https://wiki.python.org/moin/PythonDecorators)）。这个装饰器是在`BaseSubApp`类中创建的，并且会自动为路由预先附加选项卡选择小部件的
    HTML 标记，代码如下所示：
- en: '[PRE40]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode15.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode15.py)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode15.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode15.py)'
- en: 'At first glance, the preceding code may appear very hard to read as the `add_ticker_selection_markup`
    decorator method contains two levels of anonymous nested methods. Let''s try to
    explain the purpose for each of them including the main `add_ticker_selection_markup`
    decorator method:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，上面的代码可能看起来很难读，因为`add_ticker_selection_markup`装饰器方法包含了两层匿名嵌套方法。我们来尝试解释它们的目的，包括主要的`add_ticker_selection_markup`装饰器方法：
- en: '`add_ticker_selection_markup`: This is the main decorator method that takes
    one argument called `refresh_ids` which will be used in the generated markup.
    This method returns an anonymous function called `deco` that takes a function
    argument.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_ticker_selection_markup`：这是主要的装饰器方法，它接受一个名为`refresh_ids`的参数，这个参数将在生成的标记中使用。该方法返回一个名为`deco`的匿名函数，`deco`接收一个函数参数。'
- en: '`deco`: This is the wrapper method that takes one argument called `fn` which
    is a pointer to the original function to which the decorator is applied. This
    method returns an anonymous function called `wrap` which will be called in lieu
    of the original function when it is called in the user code.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deco`：这是一个包装方法，它接受一个名为`fn`的参数，该参数是指向原始函数的指针，装饰器应用于该函数。当用户代码中调用该函数时，该方法返回一个名为`wrap`的匿名函数，`wrap`将在原始函数的地方被调用。'
- en: '`wrap`: This is the final wrapper method that takes three arguments:'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wrap`：这是最终的包装方法，它接受三个参数：'
- en: '`self`: Pointer to the host class for the function'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self`：指向函数所属类的指针'
- en: '`*args`: Any variable arguments that the original method defines (could be
    empty)'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*args`：原方法定义的任意可变参数（可能为空）'
- en: '`**kwargs`: Any keyword arguments that the original method defines (could be
    empty)'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**kwargs`：原方法定义的任意关键字参数（可能为空）'
- en: The `wrap` method can access the variables that are outside its scope through
    the Python closure mechanism. In this case, it uses the `refresh_ids` to generate
    the tab widget markup, and then calls the `fn` function with the `self`, `args`,
    and `kwargs` arguments.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`wrap`方法可以通过 Python 闭包机制访问其作用域外的变量。在这种情况下，它使用`refresh_ids`生成选项卡小部件的标记，然后用`self`、`args`和`kwargs`参数调用`fn`函数。'
- en: Note
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: Do not worry if the preceding explanation is still confusing, even
    after reading it multiple times. You can just use the decorator for now, and it
    won''t affect your ability to understand the rest of the chapter.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：如果上述解释看起来依然让你感到困惑，即使你读了多次，也不用担心。你现在只需使用这个装饰器，它不会影响你理解本章的其他内容。'
- en: StockExploreSubApp – first child PixieApp
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StockExploreSubApp – 第一个子 PixieApp
- en: We can now implement the first child PixieApp called `StockExploreSubApp`. In
    the main screen, we create two `<div>` elements that each have a `pd_options`
    attribute that calls the `show_chart` route with `Adj. Close` and `daily_spread`
    as values. In turn, the `show_chart` route returns a `<div>` element with a `pd_entity`
    attribute pointing to the `parent_pixieapp.get_active_df()` method with a `<pd_options>`
    element that contains a JSON payload for displaying a Bokeh line chart with `Date`
    as the *x* abscissa and whatever value is passed as an argument as the column
    for the *y* ordinate. We also decorate the route with the `BaseSubApp.add_ticker_selection_markup`
    decorator using the ID of the preceding two `<div>` elements as the `refresh_ids`
    argument.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现第一个子PixieApp，名为`StockExploreSubApp`。在主屏幕中，我们创建了两个`<div>`元素，每个元素都有一个`pd_options`属性，该属性调用`show_chart`路由，并将`Adj.
    Close`和`daily_spread`作为值。然后，`show_chart`路由返回一个`<div>`元素，其中`pd_entity`属性指向`parent_pixieapp.get_active_df()`方法，并且包含一个`<pd_options>`元素，里面包含一个JSON负载，用于显示一个Bokeh线图，`Date`作为*
    x *轴，任何作为参数传递的值作为* y *轴的列。我们还用`BaseSubApp.add_ticker_selection_markup`装饰器装饰了该路由，使用前面两个`<div>`元素的ID作为`refresh_ids`参数。
- en: 'The following code shows the implementation for the `StockExplorerSubApp` child PixieApp:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`StockExplorerSubApp`子PixieApp的实现：
- en: '[PRE41]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode16.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode16.py)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode16.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode16.py)'
- en: 'In the preceding `show_chart` route, the `pd_entity` uses the `get_active_df()`
    method from the `parent_pixieapp` which is defined in the `StockExplorer` main
    class as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`show_chart`路由中，`pd_entity`使用了`parent_pixieapp`中定义的`get_active_df()`方法，该方法在`StockExplorer`主类中定义，代码如下：
- en: '[PRE42]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode17.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode17.py)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode17.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode17.py)'
- en: 'As a reminder, the `StockExploreSubApp` is associated with the menu through
    a tuple in the `tabs` array variable declared in the `Explore` route of the `StockExplorer`
    route:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，`StockExploreSubApp`通过`StockExplorer`路由中的`Explore`路由内声明的`tabs`数组变量中的元组与菜单关联：
- en: '[PRE43]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode18.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode18.py)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode18.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode18.py)'
- en: 'The following screenshot shows the `StockExploreSubApp`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了`StockExploreSubApp`：
- en: '![StockExploreSubApp – first child PixieApp](img/B09699_08_17.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![StockExploreSubApp – 第一个子PixieApp](img/B09699_08_17.jpg)'
- en: StockExploreSubApp main screen
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: StockExploreSubApp主屏幕
- en: MovingAverageSubApp – second child PixieApp
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MovingAverageSubApp – 第二个子PixieApp
- en: The second child PixieApp is `MovingAverageSubApp` which displays a line chart
    of the moving average for the selected stock ticker with a lag that is configurable
    through a slider control. Similar to the ticker selection tab, the lag slider
    will be needed in another child PixieApp. We could use the same decorator technique
    we use for the ticker selection tab control, but here we want to be able to position
    the lag slider anywhere on the page. So instead, we'll use a `pd_widget` control
    called `lag_slider` that we define in the `BaseSubApp` class and return an HTML
    fragment for the slider control. It also adds a `<script>` element that uses the
    jQuery `slider` method available in the jQuery UI module (see [https://api.jqueryui.com/slider](https://api.jqueryui.com/slider)
    for more information). We also add a `change` handler function that is called when
    the user has selected a new value. In this handler, we call the `pixiedust.sendEvent`
    function to publish an event of the `lagSlider` type and a payload containing
    the new value for the lag. It is the responsibility of the caller to add a `<pd_event_handler>`
    element to listen to that event and process the payload.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个子 PixieApp 是`MovingAverageSubApp`，它展示了所选股票代码的移动平均线图，并且可以通过滑块控件配置延迟。与股票选择标签类似，延迟滑块将在另一个子
    PixieApp 中使用。我们可以使用与股票选择标签控件相同的装饰器技术，但这里我们希望能将延迟滑块放置在页面的任何位置。因此，我们将使用一个在`BaseSubApp`类中定义的`pd_widget`控件，名为`lag_slider`，并返回一个用于滑块控件的HTML片段。它还添加了一个`<script>`元素，使用jQuery
    UI模块中可用的jQuery `slider`方法（有关更多信息，请参见[https://api.jqueryui.com/slider](https://api.jqueryui.com/slider)）。我们还添加了一个`change`事件处理函数，当用户选择新值时会被调用。在这个事件处理程序中，我们调用`pixiedust.sendEvent`函数，发布一个类型为`lagSlider`的事件，并包含新的延迟值的有效载荷。调用者有责任添加一个`<pd_event_handler>`元素来监听该事件并处理有效载荷。
- en: 'The following code shows the implementation of the `lag_slider` `pd_widget`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`lag_slider` `pd_widget`的实现
- en: '[PRE44]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode19.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode19.py)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode19.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode19.py)'
- en: In the `MovingAverageSubApp` we use the `add_ticker_selection_markup` decorator
    with `chart{{prefix}}` as an argument in the default route to add the ticker selection
    tab and add a `<div>` element with `pd_widget` named `lag_slider`, including a
    `<pd_event_handler>` to set the `self.lag` variable and refresh the `chart` div.
    The `chart` div uses a `pd_entity` attribute with the `get_moving_average_df()`
    method that calls the `rolling` method ([https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.rolling.html](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.rolling.html))
    on the pandas Series returned from the selected pandas DataFrame and calls the
    `mean()` method on it. Because the PixieDust `display()` does not yet support
    pandas Series, we build a pandas DataFrame using the series index as a column
    called `x` and return it in the `get_moving_average_df()` method.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MovingAverageSubApp`中，我们在默认路由中使用`add_ticker_selection_markup`装饰器，并以`chart{{prefix}}`作为参数，添加股票选择标签，并添加一个名为`lag_slider`的`pd_widget`的`<div>`元素，包括一个`<pd_event_handler>`来设置`self.lag`变量并刷新`chart`
    div。`chart` div使用`pd_entity`属性，并调用`get_moving_average_df()`方法，该方法调用来自所选pandas
    DataFrame的pandas Series上的`rolling`方法（[https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.rolling.html](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.rolling.html)）并对其调用`mean()`方法。由于PixieDust的`display()`尚不支持pandas
    Series，我们使用series索引构建一个pandas DataFrame，作为一个名为`x`的列，并在`get_moving_average_df()`方法中返回它。
- en: The following code shows the implementation of the `MovingAverageSubApp` child
    PixieApp
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`MovingAverageSubApp`子 PixieApp的实现
- en: '[PRE45]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode20.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode20.py)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode20.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode20.py)'
- en: 'The following screenshot shows the chart displayed by the `MovingAverageSubApp`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了`MovingAverageSubApp`所显示的图表：
- en: '![MovingAverageSubApp – second child PixieApp](img/B09699_08_18.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![MovingAverageSubApp – 第二个子 PixieApp](img/B09699_08_18.jpg)'
- en: MovingAverageSubApp screenshot
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: MovingAverageSubApp 截图
- en: AutoCorrelationSubApp – third child PixieApp
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AutoCorrelationSubApp – 第三个子 PixieApp
- en: For the third child, PixieApp called `AutoCorrelationSubApp`; we display the
    ACF and PACF of the selected stock DataFrame, which are computed using the `statsmodels`
    package.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三个子PixieApp，我们调用了`AutoCorrelationSubApp`；我们展示了所选股票DataFrame的ACF和PACF，它们是使用`statsmodels`包计算得出的。
- en: 'The following code shows the implementation of the `AutoCorrelationSubApp`
    which also uses the `add_ticker_selection_markup` decorator and the `pd_widget`
    named `lag_slider`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`AutoCorrelationSubApp`的实现，它还使用了`add_ticker_selection_markup`装饰器和名为`lag_slider`的`pd_widget`：
- en: '[PRE46]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode21.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode21.py)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode21.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode21.py)'
- en: 'In the preceding code, we define two routes: `show_acf` and `show_pacf` which
    respectively call the `plot_acf` and `plot_pacf` methods of the `smt.graphics`
    package. We also use the `@captureOutput` decorator to signal the PixieApp framework
    to capture the output generated by `plot_acf` and `plot_pacf`.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了两个路由：`show_acf` 和 `show_pacf`，分别调用`smt.graphics`包中的`plot_acf`和`plot_pacf`方法。我们还使用`@captureOutput`装饰器，告诉PixieApp框架捕获由`plot_acf`和`plot_pacf`生成的输出。
- en: 'The following screenshot shows the charts displayed by `AutoCorrelationSubApp`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了`AutoCorrelationSubApp`所显示的图表：
- en: '![AutoCorrelationSubApp – third child PixieApp](img/B09699_08_19.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![AutoCorrelationSubApp – 第三个子PixieApp](img/B09699_08_19.jpg)'
- en: AutoCorrelationSubApp screenshot
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: AutoCorrelationSubApp 截图
- en: 'In this section, we showed how to put together a sample PixieApp that does
    basic data exploration on a time series and display various statistical charts.
    The complete Notebook can be found here: [https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/StockExplorer%20-%20Part%201.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/StockExplorer%20-%20Part%201.ipynb).'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何组合一个简单的PixieApp，用于对时间序列进行基本的数据探索，并显示各种统计图表。完整的Notebook可以在此找到：[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/StockExplorer%20-%20Part%201.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/StockExplorer%20-%20Part%201.ipynb)。
- en: In the next section, we try to build a time series forecast model using a very
    popular model called **Autoregressive Integrated Moving Average** (**ARIMA**).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们尝试使用一个非常流行的模型来构建一个时间序列预测模型，称为**自回归积分滑动平均**（**ARIMA**）。
- en: Time series forecasting using the ARIMA model
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ARIMA模型的时间序列预测
- en: 'ARIMA is one of the most popular time series forecasting models and as its
    name indicates is made up of three terms:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA是最流行的时间序列预测模型之一，正如其名字所示，它由三个部分组成：
- en: '**AR**: Stands for **autoregression**, which is nothing more than applying
    a linear regression algorithm using one observation and its own lagged observations
    as training data.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR**：代表**自回归**，即应用线性回归算法，使用一个观测值及其自身的滞后观测值作为训练数据。'
- en: 'The AR model uses the following formula:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: AR模型使用以下公式：
- en: '![Time series forecasting using the ARIMA model](img/B09699_08_31.jpg)'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用ARIMA模型的时间序列预测](img/B09699_08_31.jpg)'
- en: Where ![Time series forecasting using the ARIMA model](img/B09699_08_32.jpg)
    are the weights of the models learned from the previous observations and ![Time
    series forecasting using the ARIMA model](img/B09699_08_33.jpg) is the residual
    error for observation *t*.
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 ![使用ARIMA模型的时间序列预测](img/B09699_08_32.jpg) 是从先前的观测中学习到的模型权重，![使用ARIMA模型的时间序列预测](img/B09699_08_33.jpg)
    是观测值*t*的残差误差。
- en: We also call *p* the order of the autoregression model, which is defined as the number
    of lag observations included in the preceding formula.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还称*p*为自回归模型的阶数，定义为前述公式中包含的滞后观测值的数量。
- en: 'For example:'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '*AR(2)* is defined as:'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*AR(2)* 定义为：'
- en: '![Time series forecasting using the ARIMA model](img/B09699_08_34.jpg)'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用ARIMA模型的时间序列预测](img/B09699_08_34.jpg)'
- en: '*AR(1)* is defined as:'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*AR(1)* 定义为：'
- en: '![Time series forecasting using the ARIMA model](img/B09699_08_35.jpg)'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用ARIMA模型的时间序列预测](img/B09699_08_35.jpg)'
- en: '**I**: Stands for **integrated**. For the ARIMA model to work, it is assumed
    that the time series is stationary or can be made stationary. A series is said
    to be stationary ([https://en.wikipedia.org/wiki/Stationary_process](https://en.wikipedia.org/wiki/Stationary_process))
    if its mean and variance doesn''t change over time.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：代表**积分**。为了使ARIMA模型有效，假设时间序列是平稳的，或者可以被转化为平稳的。如果一个序列的均值和方差随时间变化不大，我们称之为平稳序列
    ([https://en.wikipedia.org/wiki/Stationary_process](https://en.wikipedia.org/wiki/Stationary_process))。'
- en: Note
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: There is also the notion of strict stationarity which requires that
    the joint probability distribution of a subset of observations doesn''t change
    when shifted in time.'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**：严格平稳性也有一个概念，要求一组观测值的联合概率分布在时间平移时不发生变化。'
- en: 'Using mathematical notation, strict stationarity translates to:'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用数学符号，严格平稳性转化为：
- en: '![Time series forecasting using the ARIMA model](img/B09699_08_36.jpg) and
    ![Time series forecasting using the ARIMA model](img/B09699_08_37.jpg) are the
    same for any *t*, *m*, and *k,* with *F* being the joint probability distribution.'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![使用ARIMA模型的时间序列预测](img/B09699_08_36.jpg) 和![使用ARIMA模型的时间序列预测](img/B09699_08_37.jpg)
    对于任意的*t*, *m* 和 *k* 都是相同的，*F*是联合概率分布。'
- en: In practice, this condition is too strong, and the preceding weaker definition
    provided is preferred.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际操作中，这个条件太严格，前述较弱的定义通常更为常用。
- en: 'We can make a time series stationary through a transformation that uses differencing
    of the log between an observation and the one before that, as shown in the following
    equation:'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过使用观测值与其前一个值之间的对数差分来对时间序列进行平稳化，如下方的公式所示：
- en: '![Time series forecasting using the ARIMA model](img/B09699_08_38.jpg)'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用ARIMA模型的时间序列预测](img/B09699_08_38.jpg)'
- en: It is possible that multiple log differencing transformations are needed before
    the time series is actually made stationary. We call *d* the number of times we transform
    the series using log differencing.
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能在将时间序列真正转化为平稳序列之前，需要进行多次对数差分转换。我们称*d*为我们使用对数差分转换序列的次数。
- en: 'For example:'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '*I(0)* is defined as no log differencing needed (the model is then called ARMA).'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*I(0)* 定义为不需要对数差分（该模型称为ARMA模型）。'
- en: '*I(1)* is defined as 1 log differencing needed.'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*I(1)* 定义为需要1次对数差分。'
- en: '*I(2)* is defined as 2 log differencing needed.'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*I(2)* 定义为需要2次对数差分。'
- en: Note
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: It is important to remember to do the reverse transformation for
    as many integrations that were made, after predicting a value.'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**：在预测一个值之后，记得做与转换次数相同的反向转换。'
- en: '**MA**: Stands for **moving average**. The MA model uses the residual error
    from the mean of the current observation and the weighted residual errors of the
    lagged observations. We can define the model using the following formula:![Time
    series forecasting using the ARIMA model](img/B09699_08_39.jpg)'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MA**：代表**滑动平均**。MA模型使用当前观测值的均值的残差误差和滞后观测值的加权残差误差。我们可以使用以下公式来定义该模型：![使用ARIMA模型的时间序列预测](img/B09699_08_39.jpg)'
- en: Where
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中
- en: '![Time series forecasting using the ARIMA model](img/B09699_08_40.jpg)'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用ARIMA模型的时间序列预测](img/B09699_08_40.jpg)'
- en: is the mean of the time series, ![Time series forecasting using the ARIMA model](img/B09699_08_33.jpg)
    are the residual errors in the series and ![Time series forecasting using the ARIMA model](img/B09699_08_41.jpg)
    are the weights for the lagged residual errors.
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是时间序列的均值，![使用ARIMA模型的时间序列预测](img/B09699_08_33.jpg) 是序列中的残差误差，![使用ARIMA模型的时间序列预测](img/B09699_08_41.jpg)
    是滞后残差误差的权重。
- en: We call *q* the size of the moving average window.
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们称*q*为滑动平均窗口的大小。
- en: 'For example:'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '*MA(0)* is defined as no moving average needed (the model is then called AR).'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*MA(0)* 定义为不需要滑动平均（该模型称为AR模型）。'
- en: '*MA(1)* is defined as using a moving average window of 1\. The formula becomes:'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*MA(1)* 定义为使用1的滑动平均窗口。公式为：'
- en: '![Time series forecasting using the ARIMA model](img/B09699_08_42.jpg)'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用ARIMA模型的时间序列预测](img/B09699_08_42.jpg)'
- en: As per the preceding definition, we use the notation *ARIMA(p,d,q)* to define
    an ARIMA model with an autoregression model of order *p*, an integration/differencing
    of order *d*, and a moving average window of size *q*.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前述定义，我们使用符号*ARIMA(p,d,q)*来定义一个ARIMA模型，其中*p*为自回归模型的阶数，*d*为积分/差分的阶数，*q*为滑动平均窗口的大小。
- en: 'Implementing all the code to build an ARIMA model can be very time-consuming.
    Fortunately, the `statsmodels` library implements an `ARIMA` class in the `statsmodels.tsa.arima_model`
    package that provides all the computation needed to train a model with the `fit()`
    method and predict values with the `predict()` method. It also takes care of the
    log differencing to make the time series stationary. The trick is to find the
    parameters *p*, *d*, and *q* for building the optimal ARIMA model. For this, we
    use the ACF and PACF chart as follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 实现构建ARIMA模型的所有代码可能非常耗时。幸运的是，`statsmodels`库在`statsmodels.tsa.arima_model`包中实现了一个`ARIMA`类，提供了训练模型所需的所有计算，使用`fit()`方法来训练模型，使用`predict()`方法来预测值。它还处理对数差分，使时间序列变得平稳。诀窍是找到用于构建最佳ARIMA模型的参数*p*、*d*和*q*。为此，我们使用以下的ACF和PACF图：
- en: The *p* value corresponds to the number of lags (on the *x* abscissa) where
    the ACF chart crosses the statistical significance threshold for the first time.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p*值对应于ACF图首次越过统计显著性阈值的滞后数（在*x*坐标轴上）。'
- en: Similarly, the *q* value corresponds to the number of lags (on the *x* abscissa)
    where the PACF chart crosses the statistical significance threshold for the first
    time.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，*q*值对应于PACF图首次越过统计显著性阈值的滞后数（在*x*坐标轴上）。
- en: Build an ARIMA model for the MSFT stock time series
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建MSFT股票时间序列的ARIMA模型
- en: 'As a reminder, the price chart for the MSFT stock time series looks like this:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，MSFT股票时间序列的价格图表如下所示：
- en: '![Build an ARIMA model for the MSFT stock time series](img/B09699_08_20.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![构建MSFT股票时间序列的ARIMA模型](img/B09699_08_20.jpg)'
- en: MSFT stock series chart
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: MSFT股票序列图
- en: Before we start building our model, let's first withhold the last 14 days of
    the data for testing and use the rest for training.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建模型之前，让我们首先保留最后14天的数据用于测试，其余部分用于训练。
- en: 'The following code defines two new variables: `train_set` and `test_set`:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了两个新变量：`train_set`和`test_set`：
- en: '[PRE47]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: If you''re still not familiar with the preceding slicing notation,
    please refer to the section on NumPy at the beginning of this chapter'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：如果你仍然不熟悉前面的切片表示法，请参考本章开头关于NumPy的部分。'
- en: From the preceding chart, we can clearly observe a growth trend starting in
    2012 but no clear seasonality. Therefore, we can safely assume that there is no
    stationarity. Let's first try to apply a log differencing transformation once
    and plot the corresponding ACF and PACF chart.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，我们可以清楚地观察到自2012年起的增长趋势，但没有明显的季节性。因此，我们可以放心地假设没有平稳性。我们首先尝试应用一次对数差分变换，并绘制相应的ACF和PACF图。
- en: 'In the following code, we build the `logmsft` pandas Series by using `np.log()`
    on the `Adj. Close` column and then build the `logmsft_diff` pandas DataFrame
    using the difference between `logmsft` and the lag of 1 (using the `shift()` method).
    As was done before, we also call `reset_index()` to convert the `Date` index into
    a column so that the PixieDust `display()` can process it:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过对`Adj. Close`列使用`np.log()`来构建`logmsft` pandas Series，然后使用`logmsft`与滞后1（使用`shift()`方法）的差异来构建`logmsft_diff`
    pandas DataFrame。像之前一样，我们还调用`reset_index()`将`Date`索引转换为列，以便PixieDust的`display()`可以处理它：
- en: '[PRE48]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode22.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode22.py)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode22.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode22.py)'
- en: 'The results are shown in the following screenshot:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下面的截图所示：
- en: '![Build an ARIMA model for the MSFT stock time series](img/B09699_08_21.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![构建MSFT股票时间序列的ARIMA模型](img/B09699_08_21.jpg)'
- en: MSFT stock series after log differencing applied
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 对数差分后的MSFT股票序列
- en: From looking at the preceding graph, we can reasonably think that we've succeeded
    at making the time series stationary with 0 as the mean. We can also use a more
    rigorous way to test for stationarity by using the Dickey-Fuller test ([https://en.wikipedia.org/wiki/Dickey%E2%80%93Fuller_test](https://en.wikipedia.org/wiki/Dickey%E2%80%93Fuller_test))
    which tests the null hypothesis that a unit root is present in an *AR(1)* model.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图形来看，我们可以合理地认为，我们已成功将时间序列平稳化，且其均值为0。我们还可以使用更严格的方法，通过使用Dickey-Fuller检验（[https://en.wikipedia.org/wiki/Dickey%E2%80%93Fuller_test](https://en.wikipedia.org/wiki/Dickey%E2%80%93Fuller_test)）来检验平稳性，该检验测试*AR(1)*模型中是否存在单位根的原假设。
- en: Note
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: In statistics, statistical hypothesis testing consists of challenging
    whether a proposed hypothesis is true, by taking a sample and deciding whether
    the claim remains true. We look at the p-value ([https://en.wikipedia.org/wiki/P-value](https://en.wikipedia.org/wiki/P-value))
    which helps determine the significance of the results. More details on statistical
    hypothesis testing can be found here:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：在统计学中，统计假设检验是通过取样来挑战假设是否成立，并判断该假设是否成立。我们查看 p 值（[https://en.wikipedia.org/wiki/P-value](https://en.wikipedia.org/wiki/P-value)），它有助于判断结果的显著性。有关统计假设检验的更多细节可以在这里找到：'
- en: '[https://en.wikipedia.org/wiki/Statistical_hypothesis_testing](https://en.wikipedia.org/wiki/Statistical_hypothesis_testing)'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Statistical_hypothesis_testing](https://en.wikipedia.org/wiki/Statistical_hypothesis_testing)'
- en: 'The following code uses the `adfuller` method from the `statsmodels.tsa.stattools`
    package:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 `statsmodels.tsa.stattools` 包中的 `adfuller` 方法：
- en: '[PRE49]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode23.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode23.py)We
    use the `pprint` package which is very useful for *pretty-printing* any Python
    data structures. More info on `pprint` can be found here:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode23.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode23.py)我们使用
    `pprint` 包，它对 *漂亮打印* 任意 Python 数据结构非常有用。有关 `pprint` 的更多信息可以在这里找到：'
- en: '[https://docs.python.org/3/library/pprint.html](https://docs.python.org/3/library/pprint.html)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/pprint.html](https://docs.python.org/3/library/pprint.html)'
- en: 'The results (explained in detail at: [http://www.statsmodels.org/devel/generated/statsmodels.tsa.stattools.adfuller.html](http://www.statsmodels.org/devel/generated/statsmodels.tsa.stattools.adfuller.html))
    are shown here:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 结果（在以下链接详细解释：[http://www.statsmodels.org/devel/generated/statsmodels.tsa.stattools.adfuller.html](http://www.statsmodels.org/devel/generated/statsmodels.tsa.stattools.adfuller.html)）显示在这里：
- en: '[PRE50]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode24.json](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode24.json)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode24.json](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode24.json)'
- en: The p-value is below the significance level; therefore, we can reject the null
    hypothesis that a unit root is present in the *AR(1)* model, which gives us confidence
    that the time series is stationary.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: p 值低于显著性水平；因此，我们可以拒绝零假设，即 *AR(1)* 模型中存在单位根，这使我们有信心认为时间序列是平稳的。
- en: 'We then plot the ACF and PACF chart which will give us the *p* and *q* parameters
    of the ARIMA model:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们绘制 ACF 和 PACF 图，这将为我们提供 ARIMA 模型的 *p* 和 *q* 参数：
- en: 'The following code builds the ACF chart:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码构建了 ACF 图：
- en: '[PRE51]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode25.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode25.py)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode25.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode25.py)'
- en: 'The results are shown in the following screenshot:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在以下截图中：
- en: '![Build an ARIMA model for the MSFT stock time series](img/B09699_08_22.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![构建 MSFT 股票时间序列的 ARIMA 模型](img/B09699_08_22.jpg)'
- en: ACF for the log difference MSFT DataFrame
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 对数差分 MSFT 数据框的 ACF
- en: From the preceding ACF graph, we can see that the correlation crosses the statistical
    significance threshold for the first time at a lag of 1\. Therefore, we'll use
    *p = 1* as the AR order of our ARIMA model.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的 ACF 图中，我们可以看到相关性首次超过统计显著性阈值时，滞后值为 1。因此，我们将使用 *p = 1* 作为 ARIMA 模型的 AR 顺序。
- en: 'We do the same for the PACF:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 PACF 做相同的操作：
- en: '[PRE52]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode26.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode26.py)'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode26.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode26.py)'
- en: 'The results are shown in the following screenshot:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在以下截图中：
- en: '![Build an ARIMA model for the MSFT stock time series](img/B09699_08_23.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![构建 MSFT 股票时间序列的 ARIMA 模型](img/B09699_08_23.jpg)'
- en: PACF for the log difference MSFT DataFrame
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 对数差分 MSFT 数据框的 PACF
- en: From the preceding PACF graph, we can also see that the correlation crosses
    the statistical significance threshold for the first time at a lag of 1\. Therefore,
    we'll use *q = 1* as the MA order of our ARIMA model.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的PACF图中，我们还可以看到在滞后为1时，相关性首次越过了统计显著性阈值。因此，我们将使用*q = 1*作为ARIMA模型的MA阶数。
- en: We also had to apply the log differencing transformation only once. Therefore
    we'll use *d = 1* for the integrated part of the ARIMA model.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还只应用了对数差分转换一次。因此，我们将使用*d = 1*作为ARIMA模型的积分部分。
- en: Note
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: When calling the `ARIMA` class, if you use *d = 0*, then you may
    have to do the log differencing manually and, in this case, you''ll need to revert
    the transformation yourself on the predicted values. If not, the `statsmodels`
    package will take care of reverting the transformation before returning the predicted
    value.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：当调用`ARIMA`类时，如果使用*d = 0*，你可能需要手动进行对数差分，在这种情况下，你需要自己在预测值上恢复转换。如果不进行此操作，`statsmodels`包会在返回预测值之前自动恢复转换。'
- en: 'The following code trains an ARIMA model on the `train_set` time series using
    *p = 1*, *d = 1*, and *q=1* as values to the order tuple argument of the `ARIMA`
    constructor. We then call the `fit()` method to proceed with the training and
    obtain a model:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用*p = 1*、*d = 1*、*q = 1*作为`ARIMA`构造函数的顺序元组参数，对`train_set`时间序列训练ARIMA模型。接着我们调用`fit()`方法进行训练并获取模型：
- en: '[PRE53]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode27.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode27.py)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode27.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode27.py)'
- en: '**Note**: We use the `warnings` package to avoid getting the mutiple deprecation
    warnings that may happen if you are using older versions of NumPy and pandas.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：我们使用`warnings`包来避免在使用较旧版本的NumPy和pandas时可能出现的多个弃用警告。'
- en: In the preceding code, we use `train_set['Adj. Close']` as an argument to the
    `ARIMA` constructor. Since we are using a Series for the data, we also need to
    pass the `train_set['Date']` series for the `dates` argument. Note that if we
    passed a pandas DataFrame instead with a `DateIndex` index, then we wouldn't have
    to use the `dates` argument. The final argument to the `ARIMA` constructor is
    the `order` argument which is a tuple of three values indicating the *p*, *d*,
    and *q* order, as discussed at the beginning of this section.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们使用`train_set['Adj. Close']`作为`ARIMA`构造函数的参数。由于我们使用的是Series数据，因此我们还需要传递`train_set['Date']`系列作为`dates`参数。请注意，如果我们传递的是带有`DateIndex`索引的pandas
    DataFrame，那么就不需要使用`dates`参数了。`ARIMA`构造函数的最后一个参数是`order`参数，它是一个包含*p*、*d*和*q*的元组，正如本节开头所讨论的那样。
- en: We then call the `fit()` method that returns the actual ARIMA model that we'll
    use to predict values. For information purposes, we print statistics about the
    residual errors of the model using `arima_model.resid.describe()`.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`fit()`方法，它返回实际的ARIMA模型，我们将使用该模型来预测数值。为了展示目的，我们使用`arima_model.resid.describe()`打印模型的残差误差统计信息。
- en: 'The results are shown here:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE54]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The mean residual error is ![Build an ARIMA model for the MSFT stock time series](img/B09699_08_43.jpg)
    which is very close to zero and therefore shows that the model may be overfitting
    the training data.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 平均残差误差是 ![构建MSFT股票时间序列的ARIMA模型](img/B09699_08_43.jpg)，该误差非常接近零，因此表明模型可能存在过拟合训练数据的情况。
- en: Now that we have a model let's try to diagnose it. We define a method called
    `plot_predict` that takes a model, a series of dates and a number indicating how
    far back we want to look. We then call the ARIMA `plot_predict()` method to create
    a chart with both the predicted and observed values.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了模型，接下来尝试对其进行诊断。我们定义了一个名为`plot_predict`的方法，它接受一个模型、一个日期系列和一个数字，表示我们想要回溯的时间段。然后我们调用ARIMA的`plot_predict()`方法，绘制一个包含预测值和观察值的图表。
- en: 'The following code shows the implementation for the `plot_predict()` method,
    including calling it twice with `100` and `10`:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`plot_predict()`方法的实现，包括两次调用`100`和`10`：
- en: '[PRE55]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode28.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode28.py)'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode28.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode28.py)'
- en: 'The results are shown here:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Build an ARIMA model for the MSFT stock time series](img/B09699_08_24.jpg)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![为MSFT股票时间序列构建ARIMA模型](img/B09699_08_24.jpg)'
- en: Observations versus Forecast chart
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 观察值与预测值图表
- en: The preceding charts show how close the predictions are to the actual observations
    from the training set. We now use the test set that was withheld before to further
    diagnose the model. For this part, we use the `forecast()` method which predicts
    the next data point. For each value of the `test_set`, we build a new ARIMA model
    from an array of observations called history that contains the training data augmented
    with each predicted value.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表展示了预测值与训练集实际观察值的接近程度。现在我们使用之前被保留的测试集，进一步诊断模型。对于这一部分，我们使用`forecast()`方法来预测下一个数据点。对于`test_set`的每个值，我们从一个叫做history的观察数组中构建一个新的ARIMA模型，这个数组包含了训练数据并增添了每个预测值。
- en: 'The following code shows the implementation for the `compute_test_set_predictions()`
    method that takes a `train_set` and a `test_set` as arguments and returns a pandas
    DataFrame with a `forecast` column containing all the predicted values and a `test`
    column containing the corresponding actual observed values:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`compute_test_set_predictions()`方法的实现，该方法接收`train_set`和`test_set`作为参数，并返回一个包含`forecast`列（包含所有预测值）和`test`列（包含相应实际观察值）的pandas
    DataFrame：
- en: '[PRE56]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode29.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode29.py)'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode29.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode29.py)'
- en: 'The following screenshot shows the result chart:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了结果图表：
- en: '![Build an ARIMA model for the MSFT stock time series](img/B09699_08_25.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![为MSFT股票时间序列构建ARIMA模型](img/B09699_08_25.jpg)'
- en: Chart of predicted versus acutal values
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 预测值与实际值的图表
- en: 'We can measure the error using the popular `mean_squared_error` method ([https://en.wikipedia.org/wiki/Mean_squared_error](https://en.wikipedia.org/wiki/Mean_squared_error))
    of the scikit-learn package ([http://scikit-learn.org](http://scikit-learn.org))
    which is defined as follows:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用流行的`mean_squared_error`方法来衡量误差，该方法来自scikit-learn包（[https://en.wikipedia.org/wiki/Mean_squared_error](https://en.wikipedia.org/wiki/Mean_squared_error)）并定义如下：
- en: '![Build an ARIMA model for the MSFT stock time series](img/B09699_08_44.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![为MSFT股票时间序列构建ARIMA模型](img/B09699_08_44.jpg)'
- en: Where ![Build an ARIMA model for the MSFT stock time series](img/B09699_08_45.jpg)
    is the actual value and ![Build an ARIMA model for the MSFT stock time series](img/B09699_08_46.jpg)is
    the predicted value.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![为MSFT股票时间序列构建ARIMA模型](img/B09699_08_45.jpg) 是实际值，![为MSFT股票时间序列构建ARIMA模型](img/B09699_08_46.jpg)
    是预测值。
- en: 'The following code defines a `compute_mean_squared_error` method that takes a test
    and a forecast series and returns the value of the mean squared error:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了一个`compute_mean_squared_error`方法，该方法接收一个测试集和一个预测集，并返回均方误差的值：
- en: '[PRE57]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode30.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode30.py)'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode30.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode30.py)'
- en: 'The result is shown here:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE58]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: StockExplorer PixieApp Part 2 – add time series forecasting using the ARIMA
    model
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StockExplorer PixieApp 第二部分 - 使用ARIMA模型添加时间序列预测
- en: In this section, we improve the `StockExplorer` PixieApp by adding a menu that
    provides time series forecasting for the selected stock ticker using an ARIMA
    model. We create a new class called `ForecastArimaSubApp` and update the `tabs`
    variable in the main `StockExplorer` class.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过添加一个菜单来改进`StockExplorer` PixieApp，该菜单为选定的股票代码提供基于ARIMA模型的时间序列预测。我们创建了一个名为`ForecastArimaSubApp`的新类，并更新了主`StockExplorer`类中的`tabs`变量。
- en: '[PRE59]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode31.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode31.py)'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode31.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode31.py)'
- en: The `ForecastArimaSubApp` child PixieApp is composed of two screens. The first
    screen displays the time series chart as well as the ACF and the PACF charts.
    The goal of this screen is to provide the user with the necessary data exploration
    to figure out what are the values for the *p*, *d*, and *q* order of the ARIMA
    model, as explained in the previous section. By looking at the time series chart,
    we can figure out whether the time series is stationary (which, as a reminder,
    is a requirement for building the ARIMA model). If not, the user can click on
    the **Add differencing** button to try to make the DataFrame stationery by using
    a log differencing transformation. The three charts are then updated using the
    transformed DataFrame.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForecastArimaSubApp`子PixieApp由两个屏幕组成。第一个屏幕显示时间序列图表以及ACF和PACF图表。这个屏幕的目标是为用户提供必要的数据探索，帮助他们确定ARIMA模型的*p*、*d*和*q*阶数，如前一节所解释的那样。通过查看时间序列图表，我们可以判断时间序列是否平稳（提醒一下，这是构建ARIMA模型的前提条件）。如果不是，用户可以点击**添加差分**按钮，尝试通过对数差分转换使DataFrame平稳。然后，三个图表会使用转换后的DataFrame进行更新。'
- en: 'The following code shows the default route for the `ForecastArimaSubApp` child
    PixieApp:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`ForecastArimaSubApp`子PixieApp的默认路由：
- en: '[PRE60]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode32.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode32.py)'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode32.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode32.py)'
- en: 'The preceding code follows a pattern that we should now be familiar with:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码遵循了我们现在应该熟悉的模式：
- en: Define a `setup` method that is guaranteed to be called when the PixieApp starts.
    In this method, we make a copy of the selected DataFrame obtained from the parent
    PixieApp. We also maintain a variable called `self.differencing` that tracks whether
    the user clicked on the **Add differencing** button.
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个`setup`方法，确保PixieApp启动时会调用。在这个方法中，我们从父级PixieApp复制选中的DataFrame，并维护一个名为`self.differencing`的变量，用于跟踪用户是否点击了**添加差分**按钮。
- en: 'We create a default route that shows the first screen that is composed of the
    following components:'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个默认路由，显示由以下组件组成的第一个屏幕：
- en: 'A header with two buttons: `Add differencing` for making the time series stationary
    and `Continue to forecast` to display the second screen which we''ll discuss later.
    The `Add differencing` button toggles to `Remove differencing` when the differencing
    has been applied.'
  id: totrans-538
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有两个按钮的头部：`添加差分`（用于使时间序列平稳）和`继续预测`（用于显示第二个屏幕，稍后我们将讨论）。当差分已应用时，`添加差分`按钮会切换为`移除差分`。
- en: A `<div>` element that invokes the `show_chart` route to display the time series
    chart.
  id: totrans-539
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`<div>`元素，它调用`show_chart`路由来显示时间序列图表。
- en: A `<div>` element that invokes the `show_acf` route to display the ACF chart.
  id: totrans-540
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`<div>`元素，它调用`show_acf`路由来显示ACF图表。
- en: A `<div>` element that invokes the `show_pacf` route to display the PACF chart.
  id: totrans-541
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`<div>`元素，它调用`show_pacf`路由来显示PACF图表。
- en: 'We use an empty array `[]` as an argument to the `@BaseSubApp.add_ticker_selection_markup`
    decorator to make sure that the entire screen is refreshed when the user selects
    another stock ticker, and to restart from the first screen. We also need to reset
    the internal variables. To achieve this, we made a change to the `add_ticker_selection_markup`
    to define a new method in `BaseSubApp` called `set_active_ticker` that is a wrapper
    method to the `set_active_ticker` from the parent PixieApp. The idea is to let
    subclasses override this method and inject extra code if needed. We also change
    the `pd_script` attribute for the tab element to invoke this method when the user selects
    a new ticker symbol as shown in the following code:'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用一个空数组`[]`作为`@BaseSubApp.add_ticker_selection_markup`装饰器的参数，确保当用户选择另一个股票代码时，整个屏幕会刷新，并且从第一个屏幕重新开始。我们还需要重置内部变量。为此，我们对`add_ticker_selection_markup`进行了修改，定义了`BaseSubApp`中的一个新方法`set_active_ticker`，它是父级PixieApp中的`set_active_ticker`方法的封装。这个设计的目的是让子类能够重写这个方法，并根据需要注入额外的代码。我们还修改了`pd_script`属性，用于当用户选择新的股票代码时调用该方法，如下代码所示：
- en: '[PRE61]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode33.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode33.py)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode33.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode33.py)'
- en: 'In the `ForecastArimaSubApp` child PixieApp, we then override the `set_active_tracker`
    method, first calling the super and then calling the `self.setup()` to reinitialize
    the internal variables:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ForecastArimaSubApp`子PixieApp中，我们覆盖了`set_active_tracker`方法，首先调用父类方法，然后调用`self.setup()`来重新初始化内部变量：
- en: '[PRE62]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note
  id: totrans-549
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode34.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode34.py)'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode34.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode34.py)'
- en: 'The route implementation for the first forecast screen is pretty straightforward.
    The `Add differencing` / `Remove differencing` button has a `pd_script` attribute
    that calls the `self.toggle_differencing()` method and the `pd_refresh` attribute
    to update the entire page. It also defines the three `<div>` elements that respectively
    call the `show_chart`, `show_acf`, and `show_pacf` routes as shown in the following
    code:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个预测屏幕的路由实现非常简单。`Add differencing` / `Remove differencing`按钮具有`pd_script`属性，调用`self.toggle_differencing()`方法，并且具有`pd_refresh`属性来更新整个页面。它还定义了三个`<div>`元素，分别调用`show_chart`、`show_acf`和`show_pacf`路由，如以下代码所示：
- en: '[PRE63]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode35.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode35.py)'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode35.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode35.py)'
- en: 'The `toggle_differencing()` method tracks the current differencing state with
    the `self.differencing` variable and either makes a copy of the active DataFrame
    from the `parent_pixieapp` or applies a log differencing transformation to the
    `self.entity_dataframe` variable as shown in the following code:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`toggle_differencing()`方法通过`self.differencing`变量跟踪当前差分状态，并且要么从`parent_pixieapp`复制活动数据框，要么对`self.entity_dataframe`变量应用对数差分转换，如以下代码所示：'
- en: '[PRE64]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note
  id: totrans-559
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode36.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode36.py)'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode36.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode36.py)'
- en: 'The `show_acf` and `show_pacf` routes are pretty straightforward. They respectively
    call the `smt.graphics.plot_acf` and `smt.graphics.plot_pacf` methods. They also
    use the `@captureOutput` decorator to pass through the chart image to the target widget:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`show_acf`和`show_pacf`路由实现非常简单。它们分别调用`smt.graphics.plot_acf`和`smt.graphics.plot_pacf`方法。它们还使用`@captureOutput`装饰器将图表图像传递到目标小部件：'
- en: '[PRE65]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode37.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode37.py)'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode37.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode37.py)'
- en: 'The following screenshot shows the data exploration page of the forecast child PixieApp
    without the differencing:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了没有差分的预测子PixieApp的数据探索页面：
- en: '![StockExplorer PixieApp Part 2 – add time series forecasting using the ARIMA
    model](img/B09699_08_26.jpg)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![StockExplorer PixieApp Part 2 – 使用ARIMA模型添加时间序列预测](img/B09699_08_26.jpg)'
- en: First forecast screen without applying differencing
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 没有应用差分的第一个预测屏幕
- en: 'As expected, the charts are consistent with a time series that is not stationary.
    When the user clicks on the **Add differencing** button, the following screen
    is shown:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，图表与非平稳的时间序列一致。当用户点击**Add differencing**按钮时，显示以下屏幕：
- en: '![StockExplorer PixieApp Part 2 – add time series forecasting using the ARIMA
    model](img/B09699_08_27.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![StockExplorer PixieApp Part 2 – 使用ARIMA模型添加时间序列预测](img/B09699_08_27.jpg)'
- en: First forecast screen with differencing applied
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 应用差分的第一个预测屏幕
- en: The next step is to implement the `do_forecast` route that is invoked by the
    **Continue to Forecast** button. This route is responsible for building the ARIMA
    model; it starts by showing a configuration page with three input texts that let
    the user enter the *p*, *d*, and *q* orders, which have been inferred by looking
    at the charts in the data exploration screen. We add a `Go` button to proceed
    with the model building using the `build_arima_model` route which we'll discuss
    later in this section. The header also has a `Diagnose Model` button that invokes
    another page responsible for evaluating the accuracy of the model.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现 `do_forecast` 路由，它由 **继续预测** 按钮触发。这个路由负责构建 ARIMA 模型；它首先展示一个配置页面，其中有三个输入框，允许用户输入
    *p*、*d* 和 *q* 顺序，这些顺序是通过查看数据探索界面中的图表推断得出的。我们添加了一个 `Go` 按钮来继续使用 `build_arima_model`
    路由构建模型，稍后我们会在本节中讨论这个路由。页面头部还有一个 `Diagnose Model` 按钮，触发另一个页面，用于评估模型的准确性。
- en: 'The implementation of the `do_forecast` route is shown here. Note that we use
    the `add_ticker_selection_markup` with an empty array to refresh the entire page when
    the user selects another stock ticker:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_forecast` 路由的实现如下所示。请注意，我们使用 `add_ticker_selection_markup` 并传递一个空数组，以便在用户选择另一个股票代码时刷新整个页面：'
- en: '[PRE66]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode38.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode38.py)'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode38.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode38.py)'
- en: 'The following screenshot shows the configuration page of the **Build ARIMA
    model** page:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 **构建 ARIMA 模型** 页面配置的界面：
- en: '![StockExplorer PixieApp Part 2 – add time series forecasting using the ARIMA
    model](img/B09699_08_28.jpg)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
  zh: '![StockExplorer PixieApp 第二部分 – 使用 ARIMA 模型添加时间序列预测](img/B09699_08_28.jpg)'
- en: Configuration page of the Build Arima model page
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 ARIMA 模型页面的配置页面
- en: 'The **Go** button has a `pd_options` attribute that invokes a route with three
    states: `p_order`, `d_order`, and `q_order` with values taken from the three input
    boxes associated with each attribute.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**Go** 按钮有一个 `pd_options` 属性，该属性调用一个有三个状态的路由：`p_order`、`d_order` 和 `q_order`，这些值取自与每个属性相关的三个输入框。'
- en: The route for building the ARIMA model is shown in the following code. It starts
    by splitting the active DataFrame into a training and test set, withholding 14 observations
    for the test set. It then builds the model and computes the residual errors. Once
    the model is successfully built, we return an HTML markup that contains a chart
    showing the predicted values for the training set versus the actual values in
    the training set. This is done by calling the `plot_predict` route. Finally, we
    also show statistics about the residual errors for the model by creating a `<div>`
    element with a `pd_entity` attribute pointing to the residuals variable with a
    `<pd_options>` child element that configures a table view of all the statistics
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 ARIMA 模型的路由在下面的代码中显示。它首先将活动数据框（DataFrame）拆分为训练集和测试集，保留14个观测值作为测试集。然后它构建模型并计算残差误差。一旦模型成功构建，我们返回一个包含图表的
    HTML 标记，图表显示训练集的预测值与实际训练集的值对比。这是通过调用 `plot_predict` 路由实现的。最后，我们还通过创建一个 `<div>`
    元素，并为其设置 `pd_entity` 属性指向残差变量，使用 `<pd_options>` 子元素配置所有统计数据的表格视图，来显示模型的残差误差统计信息。
- en: The chart showing the predictions versus the actual training set is using the
    `plot_predict` route which calls the `plot_predict` method we created earlier
    in the Notebook. We also use the `@captureOutput` decorator to dispatch the chart
    image to the correct widget.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 显示预测与实际训练集的对比图表使用了 `plot_predict` 路由，该路由调用了我们在笔记本中之前创建的 `plot_predict` 方法。我们还使用了
    `@captureOutput` 装饰器，将图表图像发送到正确的组件。
- en: 'The implementation of the `plot_predict` route is shown here:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot_predict` 路由的实现如下所示：'
- en: '[PRE67]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode39.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode39.py)'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode39.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode39.py)'
- en: 'The `build_arima_model` route implementation is shown here:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '`build_arima_model` 路由的实现如下所示：'
- en: '[PRE68]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode40.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode40.py)'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode40.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode40.py)'
- en: 'The following screenshot shows the result for the **Build Arima model** page:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 **构建 ARIMA 模型** 页面结果：
- en: '![StockExplorer PixieApp Part 2 – add time series forecasting using the ARIMA
    model](img/B09699_08_29.jpg)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
  zh: '![StockExplorer PixieApp Part 2 – 使用 ARIMA 模型添加时间序列预测](img/B09699_08_29.jpg)'
- en: Model building page
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 模型构建页面
- en: The final screen of the forecast child app is the *diagnose model* screen invoked
    by the `do_diagnose` route. In this screen, we simply display a line chart for
    the DataFrame returned by the `compute_test_set_predictions` method we created
    earlier in the Notebook with the `train_set` and `test_set` variables. The `<div>`
    element for this chart is using a `pd_entity` attribute that calls an intermediary
    class method called `compute_test_set_predictions`. It also has a `<pd_options>`
    child element with the `display()` options for showing the line chart.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 预测子应用的最终页面是由 `do_diagnose` 路由调用的 *诊断模型* 页面。在这个页面中，我们只是简单地显示了一个由 `compute_test_set_predictions`
    方法返回的 DataFrame 的折线图，这个方法我们之前在 Notebook 中使用 `train_set` 和 `test_set` 变量创建过。这个图表的
    `<div>` 元素使用了 `pd_entity` 属性，调用了一个中介类方法 `compute_test_set_predictions`。它还有一个 `<pd_options>`
    子元素，包含显示折线图的 `display()` 选项。
- en: 'The following code shows the implementation of the `do_diagnose_screen` route:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 `do_diagnose_screen` 路由的实现：
- en: '[PRE69]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode41.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode41.py)'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode41.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/sampleCode41.py)'
- en: 'The following screenshot shows the results of the diagnose page:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了诊断页面的结果：
- en: '![StockExplorer PixieApp Part 2 – add time series forecasting using the ARIMA
    model](img/B09699_08_30.jpg)'
  id: totrans-605
  prefs: []
  type: TYPE_IMG
  zh: '![StockExplorer PixieApp Part 2 – 使用 ARIMA 模型添加时间序列预测](img/B09699_08_30.jpg)'
- en: Model diagnose screen
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 模型诊断页面
- en: In this section, we have shown how to improve the `StockExplorer` sample PixieApp to
    include forecasting capabilities using the ARIMA model. Incidentally, we've demonstrated
    how to use the PixieApp programming model to create a three-step wizard that first
    performs some data exploration, then configures the parameters of the model and
    builds it and finally diagnoses the model against the test set.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们展示了如何改进 `StockExplorer` 示例 PixieApp，加入使用 ARIMA 模型的预测能力。顺便提一下，我们演示了如何使用
    PixieApp 编程模型创建一个三步向导，首先进行一些数据探索，然后配置模型的参数并构建模型，最后对模型进行测试集的诊断。
- en: Note
  id: totrans-608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The complete implementation of the notebook can be found here:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 Notebook 实现可以在此找到：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/StockExplorer%20-%20Part%202.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/StockExplorer%20-%20Part%202.ipynb)'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/StockExplorer%20-%20Part%202.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%208/StockExplorer%20-%20Part%202.ipynb)'
- en: Summary
  id: totrans-611
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we touched upon the topic of time series analysis and forecasting.
    Of course, we've only scratched the surface, and there is certainly much more
    to explore. It is also a very important field for the industry, especially in
    the finance world, with very active research. For example, we see more and more
    data scientists trying to build time series forecasting models based on recurrent
    neural network ([https://en.wikipedia.org/wiki/Recurrent_neural_network](https://en.wikipedia.org/wiki/Recurrent_neural_network))
    algorithms, with great success. We've also demonstrated how Jupyter Notebooks
    combined with PixieDust and the ecosystem of libraries, such as `pandas`, `numpy`,
    and `statsmodels,` help accelerate the development of analytics as well as its
    operationalization into applications that are consumable by the line of business
    user.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们触及了时间序列分析和预测的话题。当然，我们只是略微触及了表面，实际上还有更多内容需要探索。这也是一个对行业非常重要的领域，特别是在金融领域，相关研究非常活跃。例如，我们看到越来越多的数据科学家尝试基于循环神经网络（[https://en.wikipedia.org/wiki/Recurrent_neural_network](https://en.wikipedia.org/wiki/Recurrent_neural_network)）算法构建时间序列预测模型，并取得了巨大成功。我们还展示了如何将
    Jupyter Notebooks 与 PixieDust 以及 `pandas`、`numpy` 和 `statsmodels` 等库的生态系统结合使用，帮助加速分析开发，并将其操作化为可以被业务用户使用的应用。
- en: 'In the next chapter, we will look at another important data science use case:
    graphs. We''ll build a sample application related to flight travel and discuss
    how and when we should apply graph algorithms to solve data problems.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨另一个重要的数据科学应用场景：图形。我们将构建一个与航班旅行相关的示例应用，并讨论我们何时以及如何应用图算法来解决数据问题。
