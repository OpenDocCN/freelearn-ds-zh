- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Selection and Assignment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择和赋值
- en: In the previous chapter, we looked at how to create a `pd.Series` and `pd.DataFrame`,
    and we also looked at their relationship to the `pd.Index`. With a foundation
    in *constructors*, we now shift focus to the crucial processes of *selection*
    and *assignment*. Selection, also referred to as *indexing*, is considered a *getter*;
    i.e., it is used to retrieve values from a pandas object. Assignment, by contrast,
    is a *setter* that is used to update values.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何创建 `pd.Series` 和 `pd.DataFrame`，并且还了解了它们与 `pd.Index` 的关系。在掌握了 *构造函数*
    的基础后，我们现在转向选择和赋值这一关键过程。选择，也称为 *索引*，被认为是 *getter*；即它用于从 pandas 对象中检索值。相比之下，赋值是
    *setter*，用于更新值。
- en: The recipes in this chapter start out by showing you how to retrieve values
    from `pd.Series` and `pd.DataFrame` objects, with ever-increasing complexity.
    We will eventually introduce the `pd.MultiIndex`, which can be used to select
    data hierarchically, before finally ending with an introduction to the assignment
    operators. The pandas API takes great care to reuse many of the same methods for
    selection and assignment, which ultimately allows you to be very expressive in
    how you would like to interact with your data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的内容从教你如何从 `pd.Series` 和 `pd.DataFrame` 对象中检索值开始，逐步增加复杂性。我们最终将介绍 `pd.MultiIndex`，它可以用于层次选择数据，最后我们会介绍赋值运算符。pandas
    API 在选择和赋值方面非常注重复用相同的方法，这使得你可以以非常表达的方式与数据交互。
- en: 'By the end of this chapter, you will be adept at efficiently retrieving data
    from and updating values within your pandas objects. We are going to cover the
    following recipes in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟练掌握如何高效地从 pandas 对象中检索数据并更新其中的值。本章我们将涵盖以下内容：
- en: Basic selection from a Series
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Series 中的基本选择
- en: Basic selection from a DataFrame
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 DataFrame 中的基本选择
- en: Position-based selection of a Series
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Series 中的按位置选择
- en: Position-based selection of a DataFrame
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataFrame 的位置选择
- en: Label-based selection from a Series
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于标签的选择从 Series 中选择
- en: Label-based selection from a DataFrame
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 DataFrame 中基于标签的选择
- en: Mixing position-based and label-based selection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合基于位置和基于标签的选择
- en: DataFrame.filter
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataFrame.filter
- en: Selection by data type
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按数据类型选择
- en: Selection/filtering via Boolean arrays
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过布尔数组进行选择/过滤
- en: Selection with a MultiIndex – A single level
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多级索引选择 – 单级别
- en: Selection with a MultiIndex – Multiple levels
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多级索引选择 – 多级别
- en: Selection with a MultiIndex – a DataFrame
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多级索引选择 – DataFrame
- en: Item assignment with .loc and .iloc
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 .loc 和 .iloc 进行项赋值
- en: DataFrame column assignment
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataFrame 列赋值
- en: Basic selection from a Series
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Series 中的基本选择
- en: Selection from a `pd.Series` involves accessing elements either by their position
    or by their label. This is akin to accessing elements in a list by their index
    or in a dictionary by their key, respectively. The versatility of the `pd.Series`
    object allows intuitive and straightforward data retrieval, making it an essential
    tool for data manipulation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `pd.Series` 中选择涉及通过其位置或标签访问元素。这类似于通过索引访问列表中的元素或通过键访问字典中的元素。`pd.Series` 对象的多功能性使得数据检索直观且简单，是数据操作的基础工具。
- en: The `pd.Series` is considered a *container* in Python, much like the built-in
    `list`, `tuple`, and `dict` objects. As such, for simple selection operations,
    the first place users turn to is the Python index operator, using the `[]` syntax.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.Series` 被认为是 Python 中的 *容器*，就像内建的 `list`、`tuple` 和 `dict` 对象。因此，对于简单的选择操作，用户首先使用的是
    Python 索引运算符，即 `[]` 语法。'
- en: How to do it
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'To introduce the basics of selection, let’s start with a very simple `pd.Series`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍选择的基础知识，我们从一个非常简单的 `pd.Series` 开始：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In Python, you’ve already discovered that the `[]` operator can be used to
    select elements from a *container*; i.e., `some_dictionary[0]` will give you the
    value associated with a key of 0\. With a `pd.Series`, basic selection behaves
    similarly:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你已经发现 `[]` 运算符可以用来从 *容器* 中选择元素；即，`some_dictionary[0]` 会返回与键为 0 相关联的值。对于
    `pd.Series`，基本选择的行为类似：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the expression `ser[3]`, pandas tries to find the label 3 in the index
    of the `pd.Series` and, assuming only one match, returns the value associated
    with that label.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表达式`ser[3]`时，pandas 会尝试在`pd.Series`的索引中找到标签 3，并且假设只有一个匹配项，它会返回与该标签相关联的值。
- en: 'Instead of selecting the associated value from the `pd.Series`, alternatively,
    you may want a `pd.Series` returned, as doing so helps you keep the label 3 associated
    with the data element “a.” With pandas, you can do this by providing a list argument
    that contains a single element:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想从`pd.Series`中选择相关值，而是希望返回一个`pd.Series`，这样可以保持标签3与数据元素“a”关联。在 pandas 中，你可以通过提供包含单个元素的列表参数来实现这一点：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Expanding on the usage of a list argument, you can select multiple values from
    the `pd.Series` if your list contains multiple elements:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展列表参数的用法时，如果列表包含多个元素，你可以从`pd.Series`中选择多个值：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Assuming you use the default index, you can use slice arguments that work very
    similarly to slicing a Python list. For example, to get up to (but not including)
    the element at position 3 of a `pd.Series`, you can use:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你使用默认的索引，你可以使用类似于 Python 列表切片的切片参数。例如，要获取一个`pd.Series`中位置 3 之前的元素（但不包括位置 3），可以使用：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Negative slice indexers are not a problem for pandas. The following code will
    select the last four elements of the `pd.Series`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 负数切片索引对 pandas 来说不是问题。以下代码将选择`pd.Series`的最后四个元素：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can even provide slices with *start* and *stop* arguments. The following
    code will retrieve all elements of the `pd.Series`, starting in position 2 and
    up to (but not including) position 6:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以提供带有*start*和*stop*参数的切片。以下代码将检索`pd.Series`中从位置 2 开始，并直到（但不包括）位置 6 的所有元素：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This final example on slices uses *start*, *stop* and *step* arguments to grab
    every third element, starting at position 1 and stopping when position 8 is encountered:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关于切片的最终示例使用了*start*、*stop*和*step*参数，从位置 1 开始，抓取每隔一个元素，直到遇到位置 8：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Selection still works when providing your own `pd.Index` values. Let’s create
    a small `pd.Series` with string index labels to illustrate:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供你自己的`pd.Index`值时，选择仍然有效。让我们创建一个带有字符串索引标签的小型`pd.Series`来说明：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Selection via `ser["Jill"]` will scan the index for the string `Jill` and return
    the corresponding element:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ser["Jill"]`选择时，将扫描索引查找字符串`Jill`并返回相应的元素：
- en: '[PRE18]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once again, providing a single-element list argument will ensure that you receive
    a `pd.Series` in return instead of a single value:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提供单元素列表参数将确保你收到一个`pd.Series`作为返回值，而不是单一值：
- en: '[PRE20]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There’s more…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: A common pitfall when using the `[]` operator is to assume that selection with
    integer arguments works the same as when selecting from a Python list. This is
    *only* true when you use the default `pd.Index`, which is auto-numbered, starting
    at 0 (this is technically called a `pd.RangeIndex`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`[]`运算符时，一个常见的陷阱是错误地认为使用整数参数的选择方式与从 Python 列表中选择的方式相同。这*仅*在使用默认的`pd.Index`时才成立，默认的`pd.Index`是自动编号的，从0开始（这在技术上称为`pd.RangeIndex`）。
- en: 'When not using a `pd.RangeIndex`, extra attention must be paid to the behavior.
    To illustrate, let’s start with a small `pd.Series`, which still uses integers
    in its `pd.Index`, but does not use an auto-incrementing sequence that starts
    at 0:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用`pd.RangeIndex`时，必须特别注意行为。为了说明这一点，让我们从一个小型`pd.Series`开始，它仍然使用整数作为`pd.Index`，但没有使用从0开始的自动递增序列：
- en: '[PRE22]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It is important to note that an integer argument selects by *label* and not
    by *position*; i.e., the following code will return the value associated with
    a label of 2, not the value in position 2:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，整数参数是按*标签*选择，而不是按*位置*选择；也就是说，以下代码将返回与标签2关联的值，而不是位置2的值：
- en: '[PRE24]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'While the integer argument matches by label and not by position, slicing still
    works positionally. The following example does not stop when encountering the
    number 2 and, instead, gives the first two elements back:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管整数参数按标签匹配，而不是按位置匹配，但切片仍然按位置工作。以下示例在遇到数字2时不会停止，而是返回前两个元素：
- en: '[PRE26]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Users should also be familiar with selection behavior when working with a non-unique
    `pd.Index`. Let’s create a small `pd.Series` where the number 1 appears twice
    in our row index:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还应该了解在处理非唯一的`pd.Index`时的选择行为。让我们创建一个小型`pd.Series`，其中数字1在行索引中出现两次：
- en: '[PRE28]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With this `pd.Series`, attempting to select the number 1 will *not* return
    a single value and, instead, return another `pd.Series`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个`pd.Series`，尝试选择数字1将*不会*返回单一值，而是返回另一个`pd.Series`：
- en: '[PRE30]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The fact that a selection like `ser[1]` can be thought to be done by position
    or label interchangeably when using the default `pd.RangeIndex` but, in actuality,
    selects by label with other `pd.Index` types can be the source of subtle bugs
    in user programs. Many users may *think* they are selecting the *n*^(th) element,
    only to have that assumption break when their data changes. To resolve the ambiguity
    between wanting to select by *label* or by *position* with an integer argument,
    it is **highly recommended** to leverage the `.loc` and `.iloc` methods introduced
    later in this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用默认的`pd.RangeIndex`时，像`ser[1]`这样的选择可以被认为是通过位置或标签进行互换的，但实际上，在使用其他`pd.Index`类型时是通过标签进行选择的，这可能是用户程序中细微bug的来源。许多用户可能*认为*他们在选择第*n*个元素，但当数据发生变化时，这个假设会被打破。为了消除通过整数参数选择*标签*或*位置*的歧义，**强烈建议**利用本章稍后介绍的`.loc`和`.iloc`方法。
- en: Basic selection from a DataFrame
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从DataFrame中进行基本选择
- en: When using the `[]` operator with a `pd.DataFrame`, simple selection typically
    involves selecting data from the *column index* rather than the *row index*. This
    distinction is crucial for effective data manipulation and analysis. Columns in
    a `pd.DataFrame` can be accessed by their labels, making it easy to work with
    named data from a `pd.Series` within the larger `pd.DataFrame` structure.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`[]`运算符与`pd.DataFrame`时，简单的选择通常涉及从*列索引*中选择数据，而不是从*行索引*中选择数据。这个区别对于有效的数据操作和分析至关重要。`pd.DataFrame`中的列可以通过它们的标签进行访问，这使得处理来自更大`pd.DataFrame`结构中的`pd.Series`的命名数据变得容易。
- en: Understanding this fundamental difference in selection behavior is key to utilizing
    the full power of a `pd.DataFrame` in pandas. By leveraging the `[]` operator,
    you can efficiently access and manipulate specific columns of data, setting the
    stage for more advanced operations and analyses.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种选择行为的基本差异是充分利用pandas中`pd.DataFrame`功能的关键。通过利用`[]`运算符，你可以高效地访问和操作特定的列数据，为更高级的操作和分析奠定基础。
- en: How to do it
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'Let’s start by creating a simple 3x3 `pd.DataFrame`. The values of the `pd.DataFrame`
    are not important, but we are intentionally going to provide our own column labels
    instead of having pandas create an auto-numbered column index for us:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单的3x3`pd.DataFrame`开始。`pd.DataFrame`的值并不重要，但我们故意提供自己的列标签，而不是让pandas为我们创建自动编号的列索引：
- en: '[PRE32]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To select a single column, use the `[]` operator with a scalar argument:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择单个列，使用带有标量参数的`[]`运算符：
- en: '[PRE34]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To select a single column but still get back a `pd.DataFrame` instead of a
    `pd.Series`, pass a single-element list:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择单个列，但仍然返回`pd.DataFrame`而不是`pd.Series`，请传递一个单元素列表：
- en: '[PRE36]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Multiple columns can be selected using a list:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用列表选择多个列：
- en: '[PRE38]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In all of these examples, the arguments for `[]` have been selected from the
    columns, but providing a slice argument exhibits different behavior and will actually
    select from rows. Note that the following example selects all columns and the
    first two rows of data, not the other way around:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些示例中，`[]`的参数是从列中选择的，但是提供切片参数会表现出不同的行为，实际上会从行中进行选择。请注意，以下示例选择了所有列和前两行数据，而不是反过来：
- en: '[PRE40]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There’s more…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'When using a list argument for the `[]` operator, you have the flexibility
    to specify the order of columns in the output. This allows you to customize the
    `pd.DataFrame` to suit your needs. The order of columns in the output will exactly
    match the order of labels provided as input. For example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用列表参数时，`[]`运算符使你可以灵活指定输出中列的顺序。这允许你根据需要定制`pd.DataFrame`。输出中列的顺序将完全匹配作为输入提供的标签顺序。例如：
- en: '[PRE42]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Swapping the order of the elements in the list as an argument to `[]` will
    swap the order of the columns in the resulting `pd.DataFrame`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表中的元素顺序交换作为`[]`运算符的参数时，将会交换结果`pd.DataFrame`中列的顺序：
- en: '[PRE44]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This feature is particularly useful when you need to reorder columns for presentation
    purposes, or when preparing data for export to CSV or Excel formats where a specific
    column order is required (see *Chapter 4*, *The pandas I/O System,* for more on
    the pandas I/O system).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在需要为展示目的重新排序列时特别有用，或者在准备导出到CSV或Excel格式时需要特定列顺序时（有关pandas I/O系统的更多信息，请参见*第4章*，*pandas
    I/O系统*）。
- en: Position-based selection of a Series
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于位置的系列选择
- en: As discussed back in the *Basic selection from a DataFrame* section, using `[]`
    as a selection mechanism does not signal the clearest intent and can sometimes
    be downright confusing. The fact that `ser[42]` selects from a *label* matching
    the number 42 and not the 42^(nd) row of a `pd.Series` is a common mistake for
    new users, and such an ambiguity can grow even more complex as you start trying
    to select two dimensions with the `[]` operator from a `pd.DataFrame`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在*DataFrame的基本选择*一节中讨论的那样，使用`[]`作为选择机制并没有明确表达意图，有时甚至可能让人感到困惑。`ser[42]`选择的是与数字42匹配的*标签*，而不是`pd.Series`的第42行，这是新用户常见的错误，而当你开始尝试使用`[]`操作符从`pd.DataFrame`中选择两个维度时，这种模糊性可能会变得更加复杂。
- en: To clearly signal that you are trying to select by *position* instead of by
    *label*, you should use `pd.Series.iloc`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确表明你是在按*位置*选择而不是按*标签*选择，你应该使用`pd.Series.iloc`。
- en: How to do it
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let’s create a `pd.Series` where we have an index using integral labels that
    are also non-unique:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`pd.Series`，其索引使用的是整数标签，并且这些标签不唯一：
- en: '[PRE46]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To select a scalar, you can use `pd.Series.iloc` with an integer argument:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择一个标量，你可以使用带有整数参数的`pd.Series.iloc`：
- en: '[PRE48]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Following the same patterns we have seen before, turning that integer argument
    into a list containing a single element will return a `pd.Series` instead of a
    scalar:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们之前看到的模式，将整数参数转换为包含单一元素的列表将返回一个`pd.Series`，而不是标量：
- en: '[PRE50]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Multiple integers in the list argument will select multiple elements of the
    `pd.Series` by position:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表参数中使用多个整数将按位置选择`pd.Series`的多个元素：
- en: '[PRE52]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Slices are a natural way of expressing a range of elements that you would select,
    and they pair very nicely as an argument to `pd.Series.iloc`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是表达你想选择的元素范围的自然方式，并且它们与`pd.Series.iloc`的参数非常匹配：
- en: '[PRE54]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Position-based selection of a DataFrame
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于位置的DataFrame选择
- en: Much like with a `pd.Series`, integers, lists of integers, and slice objects
    are all valid arguments to `DataFrame.iloc`. However, with a `pd.DataFrame`, two
    arguments are required. The first argument handles selecting from the *rows*,
    and the second is responsible for the *columns*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与`pd.Series`类似，整数、整数列表和切片对象都是`DataFrame.iloc`的有效参数。然而，对于`pd.DataFrame`，需要两个参数。第一个参数负责选择*行*，第二个参数负责选择*列*。
- en: In most use cases, users reach for position-based selection when retrieving
    rows and label-based selection when retrieving columns. We will cover the latter
    in the *Label-based selection from a DataFrame* section and will show you how
    to combine both in the *Mixing position-based and label-based selection* section.
    However, when your row index uses the default `pd.RangeIndex` and the order of
    columns is significant, the techniques shown in this section will be of immense
    value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数使用场景中，用户在获取行时会选择基于位置的选择，而在获取列时会选择基于标签的选择。我们将在*基于标签的DataFrame选择*一节中讲解后者，并且在*混合位置选择和标签选择*一节中展示如何将两者结合使用。然而，当你的行索引使用默认的`pd.RangeIndex`并且列的顺序很重要时，本节中展示的技巧将非常有价值。
- en: How to do it
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let’s create a `pd.DataFrame` with five rows and four columns:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含五行四列的`pd.DataFrame`：
- en: '[PRE56]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Passing two integer arguments to `pd.DataFrame.iloc` will return a scalar from
    that row and column position:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个整数参数传递给`pd.DataFrame.iloc`将返回该行和列位置的标量：
- en: '[PRE58]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In some cases, you may not want to select individual values from a particular
    axis, opting instead for everything that axis has to offer. An empty slice object,
    `:`, allows you to do this; i.e., if you wanted to select *all* rows of data from
    the first column of a `pd.DataFrame`, you would use:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能不想选择特定轴上的单个值，而是希望选择该轴上的所有内容。一个空切片对象`:`可以让你做到这一点；例如，如果你想选择`pd.DataFrame`第一列的*所有*数据行，你可以使用：
- en: '[PRE60]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Flipping the order of the arguments to `pd.DataFrame.iloc` will change behavior.
    Instead of grabbing all rows for the first column, the below code selects all
    columns and only the first row of data:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 翻转`pd.DataFrame.iloc`的参数顺序会改变行为。下面的代码不是选择第一列的所有行，而是选择所有列并且只选择第一行的数据：
- en: '[PRE62]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Because the preceding examples only return one dimension of data, they implicitly
    attempt to *squeeze* the return value from a `pd.DataFrame` down to a `pd.Series`.
    Following the patterns we have seen many times already in this chapter, you can
    prevent that implicit dimensionality reduction by passing a single-element list
    argument for the axis, which is not an empty slice. For example, to select all
    rows for the first column but still get back a `pd.DataFrame`, you would opt for:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因为前述示例仅返回数据的一个维度，它们隐含地尝试将`pd.DataFrame`的返回值“*挤压*”为`pd.Series`。根据本章中我们已经多次看到的模式，您可以通过为轴传递单元素列表参数来防止隐式降维，而不是空切片。例如，要选择第一列的所有行但仍然返回`pd.DataFrame`，您可以选择：
- en: '[PRE64]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Reversing those arguments gives us the first row and all columns back as a
    `pd.DataFrame`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 反转这些参数会给我们返回一个`pd.DataFrame`中的第一行和所有列：
- en: '[PRE66]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Lists can be used to select multiple elements from both the rows and columns.
    If we wanted the first and second rows paired with the last and second-to-last
    columns of our `pd.DataFrame`, you could opt for an expression like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以用来从行和列中选择多个元素。如果我们想要`pd.DataFrame`的第一行和第二行与最后一列和倒数第二列配对，您可以选择一个表达式如下：
- en: '[PRE68]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: There’s more…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Empty slices are valid arguments to `.iloc`. Both `ser.iloc[:]` and `df.iloc[:,
    :]` will return everything from each axis, essentially giving you a copy of the
    object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 空切片是`.iloc`的有效参数。`ser.iloc[:]`和`df.iloc[:, :]`都将返回每个轴上的所有内容，从本质上来说，给您一个对象的副本。
- en: Label-based selection from a Series
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Series中基于标签的选择
- en: In pandas, `pd.Series.loc` is used to perform selection by label instead of
    by position. This method is particularly useful when you consider the `pd.Index`
    of your `pd.Series` to contain lookup values, much like the key in a Python dictionary,
    rather than giving importance to the order or position of data in your `pd.Series`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在pandas中，`pd.Series.loc`用于根据标签而不是位置进行选择。当您考虑您的`pd.Series`的`pd.Index`包含查找值时，此方法特别有用，这些值类似于Python字典中的键，而不是给出数据在`pd.Series`中的顺序或位置的重要性。
- en: How to do it
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'Let’s create a `pd.Series` where we have a row index using integral labels
    that are also non-unique:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`pd.Series`，其中我们使用整数标签作为行索引，这些标签也是非唯一的：
- en: '[PRE70]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`pd.Series.loc` will select all rows where the index has a label of 1:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.Series.loc`将选择所有具有标签1的行：'
- en: '[PRE72]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Of course, you are not limited to integral labels in pandas. Let’s see what
    this looks like with a `pd.Index` composed of string values:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在pandas中，您并不局限于整数标签。让我们看看使用由字符串值组成的`pd.Index`的情况：
- en: '[PRE74]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`pd.Series.loc` can select all rows where the index has a label of `"dog"`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.Series.loc`可以选择所有具有`"dog"`标签的行：'
- en: '[PRE76]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To select all rows where the index has a label of `"dog"` or `"cat"`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择所有具有`"dog"`或`"cat"`标签的行：
- en: '[PRE78]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Finally, to select all rows up to and including the label `"cat"`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要选择直到包括标签`"cat"`的所有行：
- en: '[PRE80]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: There’s more…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Understanding label-based selection with `pd.Series.loc` provides powerful capabilities
    to access and manipulate data in a `pd.Series`. While this method may seem straightforward,
    it offers nuances and behaviors that are important to grasp for effective data
    handling.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pd.Series.loc`进行基于标签的选择提供了强大的功能，用于访问和操作`pd.Series`中的数据。虽然这种方法可能看起来很简单，但它提供了重要的细微差别和行为，对于有效的数据处理是很重要的。
- en: A very common mistake for users of all experience levels with pandas is to overlook
    the differences in behavior that slicing with `pd.Series.loc` has, compared to
    slicing in standard Python and the `pd.Series.iloc` case.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有经验水平的pandas用户来说，一个非常常见的错误是忽视`pd.Series.loc`切片行为与标准Python和`pd.Series.iloc`情况下切片行为之间的差异。
- en: 'To walk through this, let’s create a small Python list and a `pd.Series` with
    the same data:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步进行这一点，让我们创建一个小Python列表和一个具有相同数据的`pd.Series`：
- en: '[PRE82]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'As you have already seen with lists and other containers built into the Python
    language, slicing returns values up to *but not including* the provided position:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的那样，与Python语言内置的列表和其他容器一样，切片返回值直到提供的位置，但不包括：
- en: '[PRE84]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Slicing with `pd.Series.iloc` matches this behavior, returning a `pd.Series`
    with the same exact length and elements as the Python list:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pd.Series.iloc`进行切片与此行为相匹配，返回一个与Python列表具有相同长度和元素的`pd.Series`：
- en: '[PRE86]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'But slicing with `pd.Series.loc` actually produces a different result:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用`pd.Series.loc`进行切片实际上产生了不同的结果：
- en: '[PRE88]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'What is going on here? To try and get a grasp on this, it is important to remember
    that `pd.Series.loc` matches by label, not by position. The pandas library does
    something akin to a loop over each element in the `pd.Series` and its accompanying
    `pd.Index`, stopping at the point where it finds the value of 2 in the index.
    However, pandas cannot guarantee that there is only one value in the `pd.Index`
    with the value of 2, so it must continue going until it finds *something else*.
    You can see that in action if you try the same selection with a `pd.Series` that
    repeats the index label 2:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？为了更好理解这一点，需要记住 `pd.Series.loc` 是通过标签进行匹配，而非位置。pandas 库会对每个 `pd.Series`
    和其对应的 `pd.Index` 元素进行类似循环的操作，直到它在索引中找到值为 2 的元素。然而，pandas 无法保证 `pd.Index` 中只有一个值为
    2 的元素，因此它必须继续搜索直到找到*其他的东西*。如果你尝试对一个重复索引标签为 2 的 `pd.Series` 进行相同的选择，你将看到这一点的实际表现：
- en: '[PRE90]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This can seem downright devious if you expect your row index to contain integers,
    but the main use case for `pd.Series.loc` is for working with a `pd.Index` where
    position/ordering is not important (for that, use `pd.Series.iloc`). Taking string
    labels as a more practical example, the slicing behavior of `pd.Series.loc` becomes
    more natural. The following code can essentially be thought of as asking pandas
    to loop over the `pd.Series` until the label `"xxx"` is found in the row index,
    continuing until a new label is found:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你预期行索引包含整数，可能会觉得这有些狡猾，但`pd.Series.loc`的主要用例是用于处理 `pd.Index`，其中位置/顺序不重要（对于此情况，可以使用
    `pd.Series.iloc`）。以字符串标签作为一个更实际的例子，`pd.Series.loc` 的切片行为变得更加自然。以下代码可以基本理解为在请求
    pandas 遍历 `pd.Series`，直到行索引中找到标签 `"xxx"`，并继续直到找到另一个标签：
- en: '[PRE92]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'In certain cases where you try to slice with `pd.Series.loc` but the index
    labels have no determinate ordering, pandas will end up raising an error:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当你尝试使用 `pd.Series.loc` 切片，但索引标签没有确定的顺序时，pandas 将会抛出错误：
- en: '[PRE94]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Label-based selection from a DataFrame
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于标签的 DataFrame 选择
- en: As we discussed back in the *Position-based selection of a DataFrame* section,
    the most common use case with a `pd.DataFrame` is to use label-based selection
    when referring to columns and position-based selection when referring to rows.
    However, this is not an absolute requirement, and pandas allows you to use label-based
    selection from both the rows and columns.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*基于位置的 DataFrame 选择*部分讨论过的，`pd.DataFrame` 最常见的用例是，在引用列时使用基于标签的选择，而在引用行时使用基于位置的选择。然而，这并不是绝对要求，pandas
    允许你从行和列中使用基于标签的选择。
- en: When compared to other data analysis tools, the ability to select by label from
    the rows of a `pd.DataFrame` is a unique advantage to pandas. For users familiar
    with SQL, there is no real equivalent to this provided by the language; columns
    are very easy to select when placed in a `SELECT` clause, but rows can only be
    filtered via a `WHERE` clause. For users adept at Microsoft Excel, you could create
    two-dimensional structures using a pivot table, with both row labels and column
    labels, but your ability to select or refer to data within that pivot table is
    effectively limited.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他数据分析工具相比，从 `pd.DataFrame` 的行中通过标签进行选择是 pandas 独有的优势。对于熟悉 SQL 的用户，SQL 并没有提供真正相当的功能；在
    `SELECT` 子句中选择列非常容易，但只能通过 `WHERE` 子句过滤行。对于擅长使用 Microsoft Excel 的用户，你可以通过数据透视表创建具有行标签和列标签的二维结构，但你在该透视表内选择或引用数据的能力是有限的。
- en: For now, we will introduce selection for very small `pd.DataFrame` objects to
    get a feel for the syntax. In *Chapter 8*, *Reshaping Data Frames*, we will explore
    ways that you can create meaningful `pd.DataFrame` objects where row and column
    labels are significant. Combined with the knowledge introduced in this section,
    you will come to appreciate how unique this type of selection is to pandas, as
    well as how it can help you explore data in meaningful ways that other tools cannot
    express.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将介绍如何为非常小的 `pd.DataFrame` 对象进行选择，以便熟悉语法。在*第8章*，*数据框重塑*中，我们将探索如何创建有意义的 `pd.DataFrame`
    对象，其中行和列标签是重要的。结合本节介绍的知识，你将会意识到这种选择方式是 pandas 独有的，并且它如何帮助你以其他工具无法表达的方式探索数据。
- en: How to do it
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何进行选择
- en: 'Let’s create a `pd.DataFrame` where we have indices composed of strings in
    both the rows and columns:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `pd.DataFrame`，其行列索引均由字符串组成：
- en: '[PRE96]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '`pd.DataFrame.loc` can select by the row and column label:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.DataFrame.loc` 可以通过行和列标签进行选择：'
- en: '[PRE98]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'To select all rows from the column with the label `"age"`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择来自标签为 `"age"` 列的所有行：
- en: '[PRE100]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'To select all columns from the row with the label `"Jack"`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要从标签为 `"Jack"` 的行中选择所有列：
- en: '[PRE102]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'To select all rows from the column with the label `"age"`, maintaining the
    `pd.DataFrame` shape:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要从标签为 `"age"` 的列中选择所有行，并保持 `pd.DataFrame` 的形状：
- en: '[PRE104]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'To select all columns from the row with the label `"Jack"`, maintaining the
    `pd.DataFrame` shape:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要从标签为 `"Jack"` 的行中选择所有列，并保持 `pd.DataFrame` 的形状：
- en: '[PRE106]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'To select both rows and columns using lists of labels:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签列表选择行和列：
- en: '[PRE108]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Mixing position-based and label-based selection
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合基于位置和标签的选择
- en: Since `pd.DataFrame.iloc` is used for position-based selection and `pd.DataFrame.loc`
    is for label-based selection, users must take an extra step if attempting to select
    by label in one dimension and by position in another. As mentioned in previous
    sections, the majority of `pd.DataFrame` objects constructed will place heavy
    significance on the labels used for the columns, with little care for how those
    columns are ordered. The inverse is true for the rows, so being able to effectively
    mix and match both styles is of immense value.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `pd.DataFrame.iloc` 用于基于位置的选择，而 `pd.DataFrame.loc` 用于基于标签的选择，当用户尝试在一个维度上按标签选择，另一个维度上按位置选择时，必须额外采取一步措施。如前所述，大多数构造的
    `pd.DataFrame` 对象会非常重视用于列的标签，而对这些列的顺序关注较少。行的情况正好相反，因此能够有效地混合和匹配这两种风格是非常有价值的。
- en: How to do it
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let’s start with a `pd.DataFrame` that uses the default auto-numbered `pd.RangeIndex`
    in the rows but has custom string labels for the columns:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个 `pd.DataFrame` 开始，该数据框的行使用默认的自动编号 `pd.RangeIndex`，但列使用自定义的字符串标签：
- en: '[PRE110]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The `pd.Index.get_indexer` method can help us convert a label or list of labels
    into their corresponding positions in a `pd.Index`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.Index.get_indexer` 方法可以帮助我们将标签或标签列表转换为它们在 `pd.Index` 中对应的位置：'
- en: '[PRE112]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'This can subsequently be used as an argument to `.iloc`, ensuring that you
    use position-based selection across both the rows and columns:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这随后可以作为参数传递给 `.iloc`，确保你在行和列上都使用基于位置的选择：
- en: '[PRE114]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: There’s more…
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Instead of using `pd.Index.get_indexer`, you can split this expression up into
    a few steps, with one of the steps performing index-based selection and the other
    performing label-based selection. And if you did this, you’d end up getting the
    exact same result as shown above:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不使用 `pd.Index.get_indexer`，将这个表达式拆分成几个步骤，其中一个步骤进行基于索引的选择，另一个步骤进行基于标签的选择。如果你这样做，你最终会得到与上面相同的结果：
- en: '[PRE116]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: There’s a strong argument to be made that this is more expressive than using
    `pd.Index.get_indexer`, which developers of all experience levels with pandas
    would agree with. So why even bother with `pd.Index.get_indexer`?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有强有力的理由认为，这比使用 `pd.Index.get_indexer` 更具表达力，所有 pandas 用户的开发者都会同意这一点。那么，为什么还要使用
    `pd.Index.get_indexer` 呢？
- en: 'While these appear the same on the surface, how pandas computes the result
    is drastically different. Adding some timing benchmarks to the various methods
    should highlight this. While the exact numbers will vary on your machine, compare
    the timing output of the idiomatic approach described in this section:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些在表面上看起来一样，但 pandas 计算结果的方式却有很大不同。为各种方法添加一些计时基准应该能突出这一点。尽管准确的数字会因你的机器而异，但可以比较本节中描述的惯用方法的计时输出：
- en: '[PRE118]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'to the approach with separate steps to select by label and then by position:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分步方法先按标签选择，再按位置选择：
- en: '[PRE120]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The `pd.Index.get_indexer` approach clocks in faster and should scale better
    to larger datasets. The reason for this is that pandas evaluates its expressions
    *eagerly* or, more specifically, it will do *what you say, when you say it*. The
    expression `df[["age", "eye_color"]].iloc[[0, 1]]` first runs `df[["age", "eye_color"]]`,
    which creates an intermediate `pd.DataFrame`, to which the `.iloc[[0, 1]]` gets
    applied. By contrast, the expression `df.iloc[[0, 1], col_idxer]` performs the
    label-based and position-based selection all in one go, avoiding the creation
    of any intermediate `pd.DataFrame`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.Index.get_indexer` 方法速度更快，并且应该能更好地扩展到更大的数据集。之所以如此，是因为 pandas 采用的是 *贪婪*
    计算方式，或者更具体地说，它会按你说的来做。表达式 `df[["age", "eye_color"]].iloc[[0, 1]]` 首先运行 `df[["age",
    "eye_color"]]`，这会创建一个中间的 `pd.DataFrame`，然后 `.iloc[[0, 1]]` 被应用于这个数据框。相比之下，表达式
    `df.iloc[[0, 1], col_idxer]` 一次性执行了标签和位置的选择，避免了创建任何中间的 `pd.DataFrame`。'
- en: The contrasting approach to the *eager execution* approach that pandas takes
    is often called *lazy execution*. If you’ve used SQL before, the latter is a good
    example of that; you typically do not instruct the SQL engine on what steps to
    take exactly to produce the desired result. Instead, you *declare* what you want
    your result to look like and leave it up to the SQL database to optimize and execute
    your query.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 与pandas采取的*急切执行*方法相对的方式通常被称为*延迟执行*。如果你以前使用过SQL，后者就是一个很好的例子；你通常不会精确指示SQL引擎应该采取什么步骤来产生期望的结果。相反，你*声明*你希望结果是什么样的，然后将优化和执行查询的任务交给SQL数据库。
- en: Will pandas ever support lazy evaluation and optimization? I would posit yes,
    as it would help pandas scale to larger datasets and take the onus away from the
    end user to write optimal queries. However, that capability does not exist today,
    so it is still important for you as a user of the library to understand if the
    code you produce will be processed efficiently or inefficiently.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: pandas是否会支持延迟评估和优化？我认为会，因其有助于pandas扩展到更大的数据集，并减轻最终用户编写优化查询的负担。然而，这种功能目前还不存在，因此作为库的用户，你仍然需要了解你编写的代码是否会高效或低效地处理。
- en: It is also worth considering the context of your data analysis when deciding
    if it is worth trying to combine position/label-based selection in one step, or
    if they are fine as separate steps. In our trivial example, the runtime difference
    of `df.iloc[[0, 1], col_idxer]` versus `df[["age", "eye_color"]].iloc[[0, 1]]`
    is probably not worth caring about in the grander scheme of things, but if you
    were dealing with larger datasets and bottlenecked by performance, the former
    approach could be a lifesaver.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否值得尝试将基于位置/标签的选择合并为一步操作时，也值得考虑你数据分析的上下文，或者它们是否可以作为单独的步骤。在我们这个简单的示例中，`df.iloc[[0,
    1], col_idxer]`与`df[["age", "eye_color"]].iloc[[0, 1]]`之间的运行时差异在整体上可能不值得关注，但如果你处理的是更大的数据集，并且受到性能瓶颈的限制，前一种方法可能是救命稻草。
- en: DataFrame.filter
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DataFrame.filter
- en: '`pd.DataFrame.filter` is a specialized method that allows you to select from
    either the rows or columns of a `pd.DataFrame`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.DataFrame.filter`是一个专门的方法，允许你从`pd.DataFrame`的行或列中进行选择。'
- en: How to do it
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let’s create a `pd.DataFrame` where we have indices composed of strings in
    both the rows and columns:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`pd.DataFrame`，其中行和列的索引都是由字符串组成的：
- en: '[PRE122]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'By default, `pd.DataFrame.filter` will select columns matching the label argument(s),
    similar to `pd.DataFrame[]`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`pd.DataFrame.filter`会选择与标签参数匹配的列，类似于`pd.DataFrame[]`：
- en: '[PRE124]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'However, `pd.DataFrame.filter` also accepts an `axis=` argument, which allows
    you to change the axis being selected from. To select rows instead of columns,
    pass `axis=0`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`pd.DataFrame.filter`也接受一个`axis=`参数，它允许你改变所选择的轴。若要选择行而不是列，传递`axis=0`：
- en: '[PRE126]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'You are not limited to exact string matches against labels. If you would like
    to select any label containing a string, use the `like=` parameter. This example
    will select any column containing an underscore:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你不局限于与标签进行精确字符串匹配。如果你想选择包含某个字符串的标签，可以使用`like=`参数。此示例将选择任何包含下划线的列：
- en: '[PRE128]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'If simple string containment is not enough, you can also use regular expressions
    to match index labels with the `regex=` parameter. The following example will
    select any row labels that start with a `"Ja"` but do not end with `"e"`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果简单的字符串包含检查不够，你也可以使用正则表达式通过`regex=`参数匹配索引标签。以下示例将选择任何以“Ja”开头，但不以“e”结尾的行标签：
- en: '[PRE130]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Selection by data type
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按数据类型选择
- en: So far in this cookbook, we have *seen* data types, but we have not talked too
    much in depth about what they are. We still aren’t quite there; a deep dive into
    the type system of pandas is reserved for *Chapter 3*, *Data Types*. However,
    for now, you should be aware that the column type provides metadata that `pd.DataFrame.select_dtypes`
    can use for selection.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本食谱中，我们*已经看过*数据类型，但我们并没有深入讨论它们到底是什么。我们还没有完全深入探讨；pandas的类型系统将在*第3章*，*数据类型*中进行深入讨论。不过，目前你应该意识到，列类型提供了元数据，`pd.DataFrame.select_dtypes`可以用它来进行选择。
- en: How to do it
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let’s start with a `pd.DataFrame` that uses integral, floating point, and string
    columns:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个包含整数、浮点数和字符串列的`pd.DataFrame`开始：
- en: '[PRE132]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Use `pd.DataFrame.select_dtypes` to select only integral columns:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pd.DataFrame.select_dtypes`仅选择整数列：
- en: '[PRE134]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Multiple types can be selected if you pass a list argument:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递一个列表参数，多个类型可以被选择：
- en: '[PRE136]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The default behavior is to include the data types you pass in as an argument.
    To exclude them, use the `exclude=` parameter instead:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 默认行为是包括你作为参数传递的数据类型。要排除它们，请使用 `exclude=` 参数：
- en: '[PRE138]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Selection/filtering via Boolean arrays
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过布尔数组进行选择/过滤
- en: Using Boolean lists/arrays (also referred to as *masks*) is a very common method
    to select a subset of rows.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔列表/数组（也称为 *遮罩*）是选择子集行的常见方法。
- en: How to do it
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'Let’s create a mask of `True=/=False` values alongside a simple `pd.Series`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `True=/=False` 值的遮罩，并与一个简单的 `pd.Series` 配对：
- en: '[PRE140]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Using the mask as an argument to `pd.Series[]` will return each row where the
    corresponding mask entry is `True`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 将遮罩作为参数传递给 `pd.Series[]` 将返回每一行，其中相应的遮罩条目为 `True`：
- en: '[PRE142]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '`pd.Series.loc` will match the exact same behavior as `pd.Series[]` in this
    particular case:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.Series.loc` 在这种情况下将与 `pd.Series[]` 的行为完全一致：'
- en: '[PRE144]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Interestingly, whereas `pd.DataFrame[]` usually tries to select from the columns
    when provided a list argument, its behavior with a sequence of Boolean values
    is different. Using the mask we have already created, `df[mask]` will actually
    match along the rows rather than the columns:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，尽管 `pd.DataFrame[]` 通常在提供列表参数时尝试从列中选择，但在使用布尔值序列时，它的行为有所不同。使用我们已经创建的遮罩，`df[mask]`
    实际上会沿行匹配，而不是列：
- en: '[PRE146]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'If you need to mask the columns alongside the rows, `pd.DataFrame.loc` will
    accept two mask arguments:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要同时遮蔽行和列，`pd.DataFrame.loc` 将接受两个遮罩参数：
- en: '[PRE148]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: There’s more…
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'Commonly, you will manipulate your masks using some combination of the OR,
    AND, or INVERT operators. To see these in action, let’s start with a slightly
    more complicated `pd.DataFrame`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会使用 OR、AND 或 INVERT 运算符的组合来操作你的遮罩。为了演示这些操作，我们从一个稍微复杂的 `pd.DataFrame` 开始：
- en: '[PRE150]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'If our goal was to filter this only to users with blue or green eyes, we could
    first identify which users have blue eyes:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的目标是只筛选出有蓝眼睛或绿眼睛的用户，我们可以先识别哪些用户有蓝眼睛：
- en: '[PRE152]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Then, we figure out who has green eyes:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们找出哪些人有绿色眼睛：
- en: '[PRE154]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'and combine those together into one Boolean *mask* using the OR operator, `|`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 并将这些结合在一起，使用 OR 运算符 `|` 形成一个布尔 *遮罩*：
- en: '[PRE156]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'before passing that mask in as an indexer of our `pd.DataFrame`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在将该遮罩作为索引器传递给我们的 `pd.DataFrame` 之前：
- en: '[PRE158]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Instead of using the OR operator, `|`, you will often commonly use the AND
    operator, `&`. For example, let’s create a filter for records with an age less
    than 40:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 OR 运算符 `|` 不同，你通常会使用 AND 运算符 `&`。例如，让我们为年龄小于 40 的记录创建一个筛选器：
- en: '[PRE160]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'And also, a height greater than 170:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 还要高度大于 170：
- en: '[PRE162]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'These can be ANDed together to only select records that meet both conditions:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以通过 AND 运算符组合在一起，只选择满足两个条件的记录：
- en: '[PRE164]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'The INVERT operator is useful to think of as a NOT operator; i.e., in the context
    of a mask, it will make any `True` value `False` and any `False` value `True`.
    Continuing with our example above, if we wanted to find records that did not satisfy
    the condition of having an age under 40 and a height over 170, we could simply
    invert our mask using `~`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: INVERT 运算符可以视为 NOT 运算符；也就是说，在遮罩的上下文中，它将使任何 `True` 值变为 `False`，任何 `False` 值变为
    `True`。继续我们上面的例子，如果我们想找到那些没有满足年龄低于 40 且身高超过 170 的条件的记录，我们只需使用 `~` 反转遮罩：
- en: '[PRE166]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Selection with a MultiIndex – A single level
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MultiIndex 进行选择 – 单一层级
- en: A `pd.MultiIndex` is a subclass of a `pd.Index` that supports hierarchical labels.
    Depending on who you ask, this can be one of the best or one of the worst features
    of pandas. After reading this cookbook, I hope you consider it one of the best.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.MultiIndex` 是 `pd.Index` 的一个子类，支持层级标签。根据询问的人不同，这可能是 pandas 最好的特性之一，或者是最差的特性之一。看完这本手册后，我希望你把它视为最好的特性之一。'
- en: Much of the derision toward the `pd.MultiIndex` comes from the fact that the
    syntax used to select from it can easily become ambiguous, especially when using
    `pd.DataFrame[]`. The examples below exclusively use the `pd.DataFrame.loc` method
    and avoid `pd.DataFrame[]` to mitigate confusion.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `pd.MultiIndex` 的大部分贬低来自于这样一个事实：使用它选择时的语法很容易变得模糊，尤其是在使用 `pd.DataFrame[]` 时。以下示例仅使用
    `pd.DataFrame.loc` 方法，避免使用 `pd.DataFrame[]` 以减少混淆。
- en: How to do it
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: '`pd.MultiIndex.from_tuples` can be used to construct a `pd.MultiIndex` from
    a list of tuples. In the following example, we create a `pd.MultiIndex` with two
    levels – `first_name` and `last_name`, sequentially. We will pair this alongside
    a very simple `pd.Series`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.MultiIndex.from_tuples` 可以用来从元组列表构建 `pd.MultiIndex`。在以下示例中，我们创建一个具有两个层级的
    `pd.MultiIndex` – `first_name` 和 `last_name`，依次排列。我们将其与一个非常简单的 `pd.Series` 配对：'
- en: '[PRE168]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Using `pd.Series.loc` with a `pd.MultiIndex` and a scalar argument will match
    against the first level of the `pd.MultiIndex`. The output will not include this
    first level in its result:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pd.Series.loc`与`pd.MultiIndex`以及标量参数将匹配`pd.MultiIndex`的第一个级别。输出将不包含这个第一个级别的结果：
- en: '[PRE170]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: The behavior that drops the first level of the `pd.MultiIndex` in the above
    example is also referred to as *partial slicing*. This concept is similar to the
    dimensionality reduction we saw with `.loc` and `.iloc` in the previous sections,
    with the exception that instead of reducing *dimensions*, pandas here tries to
    reduce the number of *levels* in a `pd.MultiIndex`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 上面示例中删除`pd.MultiIndex`第一个级别的行为也被称为*部分切片*。这个概念类似于我们在前几节看到的`.loc`和`.iloc`中的维度压缩，唯一的不同是，pandas在这里试图减少`pd.MultiIndex`中的*级别*数量，而不是减少*维度*。
- en: 'To prevent this implicit level reduction from occurring, we can once again
    provide a list argument containing a single element:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止发生这种隐式的级别减少，我们可以再次提供一个包含单一元素的列表参数：
- en: '[PRE172]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Selection with a MultiIndex – Multiple levels
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MultiIndex选择 – 多个级别
- en: Things would not be that interesting if you could only select from the first
    level of a `pd.MultiIndex`. Fortunately, `pd.DataFrame.loc` will scale out to
    more than just the first level through the creative use of tuple arguments.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只能从`pd.MultiIndex`的第一个级别进行选择，那么事情就不那么有趣了。幸运的是，`pd.DataFrame.loc`通过巧妙地使用元组参数可以扩展到不仅仅是第一个级别。
- en: How to do it
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行
- en: 'Let’s recreate the `pd.Series` from the previous section:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新创建前面一节中的`pd.Series`：
- en: '[PRE174]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'To select all records where the first index level uses the label `"Jane"` and
    the second uses `"Doe"`, pass the following tuple:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择所有第一个索引级别使用标签`"Jane"`且第二个索引级别使用标签`"Doe"`的记录，请传递以下元组：
- en: '[PRE176]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'To select all records where the first index level uses the label `"Jane"` and
    the second uses `"Doe"`, while maintaining the `pd.MultiIndex` shape, place a
    single element list in the tuple:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择所有第一个索引级别使用标签`"Jane"`且第二个索引级别使用标签`"Doe"`的记录，同时保持`pd.MultiIndex`的形状，请将一个单一元素的列表放入元组中：
- en: '[PRE178]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'To select all records where the first index level uses the label `"John"` and
    the second uses the label `"Smith"`, OR the first level is `"Jane"` and the second
    is `"Doe"`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择所有第一个索引级别使用标签`"John"`且第二个索引级别使用标签`"Smith"`，或者第一个索引级别是`"Jane"`且第二个索引级别是`"Doe"`的记录：
- en: '[PRE180]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'To select all records where the second index level is `"Doe"`, use an empty
    slice as the first tuple element. Note that this drops the second index level
    and reconstructs the result with a simple `pd.Index` from the first index level
    that remains:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择所有第二个索引级别为`"Doe"`的记录，请将一个空切片作为元组的第一个元素。注意，这会删除第二个索引级别，并从剩下的第一个索引级别重建结果，形成一个简单的`pd.Index`：
- en: '[PRE182]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'To select all records where the second index level is `"Doe"` while maintaining
    the `pd.MultiIndex` shape, pass a single-element list as the second tuple element:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择所有第二个索引级别为`"Doe"`的记录，同时保持`pd.MultiIndex`的形状，请将一个单元素列表作为第二个元组元素：
- en: '[PRE184]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'At this point, you might be asking yourself the question, what the heck does
    `slice(None)` mean? This rather cryptic expression actually creates a slice object
    without a *start*, *stop*, or *step* value, which is easier to illustrate with
    a simpler Python list – note that the behavior here:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会问，`slice(None)`到底是什么意思？这个相当隐晦的表达式实际上创建了一个没有*起始*、*停止*或*步长*值的切片对象，这在用更简单的Python列表来说明时会更容易理解——注意，这里的行为：
- en: '[PRE186]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'is exactly the same as with `slice(None)`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与使用`slice(None)`时完全相同：
- en: '[PRE188]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: When a `pd.MultiIndex` expects a tuple argument but doesn’t get one, this issue
    is caused by a slice within a tuple, similar to how `(:,)` is a syntax error in
    Python. The more explicit `(slice(None),)` fixes the issue.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当`pd.MultiIndex`期待一个元组参数却没有得到时，这个问题通常是由元组中的切片引起的，类似于Python中`(:,)`的语法错误。更明确的写法`(slice(None),)`可以修复这个问题。
- en: There’s more…
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: If you find the `slice(None)` syntax to be unwieldy, pandas provides a convenient
    object called the `pd.IndexSlice` that acts like a tuple but allows you to use
    the more natural `:` notation for slicing.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得`slice(None)`语法太繁琐，pandas提供了一个方便的对象叫做`pd.IndexSlice`，它像元组一样工作，但允许你使用更自然的`:`符号进行切片。
- en: '[PRE190]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'thus can become:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以变成：
- en: '[PRE192]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Selection with a MultiIndex – a DataFrame
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MultiIndex选择 – 一个DataFrame
- en: A `pd.MultiIndex` can be used both as a row index and a column index, and selection
    via `pd.DataFrame.loc` works with both.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.MultiIndex`可以同时作为行索引和列索引使用，并且通过`pd.DataFrame.loc`的选择方式在两者中都可以工作。'
- en: How to do it
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行
- en: 'Let’s create a `pd.DataFrame` that uses a `pd.MultiIndex` in both the rows
    and columns:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个既在行也在列使用`pd.MultiIndex`的`pd.DataFrame`：
- en: '[PRE194]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'To select all rows where the second level is `"Smith"` and all columns where
    the second level is `"favorite"`, you will need to pass two tuples where the second
    element in each is the desired label:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择所有第二级为 `"Smith"` 的行以及所有第二级为 `"favorite"` 的列，你需要传递两个元组，其中每个元组的第二个元素是所需的标签：
- en: '[PRE196]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '`pd.DataFrame.loc` always requires two arguments – the first to specify how
    the rows should be indexed and the second to specify how the columns should be
    indexed. When you have a `pd.DataFrame` with a `pd.MultiIndex` in both the rows
    and the columns, you may find it stylistically easier to create separate variables
    for the indexers. The above code could have also been written as:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.DataFrame.loc` 总是需要两个参数——第一个指定如何对行进行索引，第二个指定如何对列进行索引。当你有一个 `pd.DataFrame`，其行列都使用
    `pd.MultiIndex` 时，你可能会发现，将索引器分开定义为变量在风格上更为清晰。上面的代码也可以写成：'
- en: '[PRE198]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Although you could argue that this is more difficult to interpret. As the old
    saying goes, beauty is in the eye of the beholder.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以说这更难以解读。正如古老的说法所说，美在于观者的眼中。
- en: Item assignment with .loc and .iloc
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 .loc 和 .iloc 进行项目赋值
- en: The pandas library is optimized for reading, exploring, and evaluating data.
    Operations that try to *mutate* or change data are far less efficient.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 库针对读取、探索和评估数据进行了优化。试图 *修改* 或改变数据的操作要低效得多。
- en: However, when you must mutate your data, you can use `.loc` and `.iloc` to do
    it.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你必须修改数据时，可以使用 `.loc` 和 `.iloc` 来实现。
- en: How to do it
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做
- en: 'Let’s start with a very small `pd.Series`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常小的 `pd.Series` 开始：
- en: '[PRE200]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '`pd.Series.loc` is useful when you want to assign a value by matching against
    the label of an index. For example, if we wanted to store the value `42` where
    our row index contained a value of `"b"`, we would write:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.Series.loc` 在你想通过匹配索引的标签来赋值时非常有用。例如，如果我们想在行索引包含 `"b"` 的位置存储值 `42`，我们可以写成：'
- en: '[PRE201]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '`pd.Series.iloc` is used when you want to assign a value positionally. To assign
    the value `-42` to the second element in our `pd.Series`, we would write:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.Series.iloc` 用于在你想按位置赋值时。例如，为了将值 `-42` 赋给我们 `pd.Series` 中的第二个元素，我们可以写成：'
- en: '[PRE203]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: There’s more…
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'The cost of mutating data through pandas can depend largely on two factors:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 pandas 修改数据的成本在很大程度上取决于两个因素：
- en: The type of array backing a pandas `pd.Series` (*Chapter 3*, *Data Types*, will
    cover data types in more detail)
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pandas `pd.Series` 支持的数组类型（*第 3 章*，*数据类型*，将在后续章节中详细讲解数据类型）
- en: How many objects reference a `pd.Series`
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少个对象引用了 `pd.Series`
- en: A deep dive into those factors is far beyond the scope of this book. For the
    first point above, my general guidance is that the *simpler* an array type is,
    the better your odds are of being able to mutate it without the array contents
    having to be copied, which for larger datasets may be prohibitively expensive.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些因素的深入探讨远超本书的范围。对于上面的第一个要点，我的普遍建议是，*数组类型越简单*，你就越有可能在不复制数组内容的情况下修改它，对于大型数据集来说，复制可能会非常昂贵。
- en: For the second bullet, a lot of **Copy on Write** (**CoW**) work was involved
    in the pandas 2.x series. CoW is the default behavior in pandas 3.0, and it tries
    to make the behavior of what does and does not get copied when mutating data more
    predictable. For advanced users, I highly encourage giving the pandas CoW documentation
    a read.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个要点，在 pandas 2.x 系列中涉及了大量的 **写时复制** (**CoW**) 工作。CoW 是 pandas 3.0 中的默认行为，它试图使得在修改数据时，哪些内容被复制，哪些内容没有被复制变得更加可预测。对于高级用户，我强烈建议阅读
    pandas CoW 文档。
- en: DataFrame column assignment
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DataFrame 列赋值
- en: While assigning to *data* can be a relatively expensive operation in pandas,
    assigning columns to a `pd.DataFrame` is a common operation.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pandas 中，对 *数据* 的赋值操作可能相对昂贵，但为 `pd.DataFrame` 分配列是常见操作。
- en: How to do it
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做
- en: 'Let’s create a very simple `pd.DataFrame`:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个非常简单的 `pd.DataFrame`：
- en: '[PRE205]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'New columns can be assigned using the `pd.DataFrame[]` operator. The simplest
    type of assignment can take a scalar value and *broadcast* it to every row of
    the `pd.DataFrame`:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 新列可以使用 `pd.DataFrame[]` 操作符进行赋值。最简单的赋值类型可以是一个标量值，并将其 *广播* 到 `pd.DataFrame` 的每一行：
- en: '[PRE207]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'You can also assign a `pd.Series` or sequence as long as the number of elements
    matches the number of rows in the `pd.DataFrame`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以赋值一个 `pd.Series` 或序列，只要元素的数量与 `pd.DataFrame` 中的行数匹配：
- en: '[PRE209]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'If the new sequence does not match the number of rows in the existing `pd.DataFrame`,
    the assignment will fail:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新序列的行数与现有 `pd.DataFrame` 的行数不匹配，赋值将失败：
- en: '[PRE213]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Assignment can also be done to a `pd.DataFrame` with a `pd.MultiIndex` in the
    columns. Let’s take a look at such a `pd.DataFrame`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有`pd.MultiIndex`列的`pd.DataFrame`，也可以进行赋值操作。让我们来看一个这样的`pd.DataFrame`：
- en: '[PRE215]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'To assign a new column under the `"art"` hierarchy for the number of museums
    seen, pass a tuple argument to `pd.DataFrame.loc`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 要在“art”层次下为看到的博物馆数量赋值，可以将元组作为参数传递给`pd.DataFrame.loc`：
- en: '[PRE217]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Assignment with a `pd.DataFrame` follows the same patterns we saw when selecting
    values with `pd.DataFrame[]` and `pd.DataFrame.loc[]`. The main difference is
    that during selection, you would use `pd.DataFrame[]` and `pd.DataFrame.loc[]`
    on the right-hand side of an expression, whereas with assignment, they appear
    on the left-hand side.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pd.DataFrame`进行赋值时遵循与使用`pd.DataFrame[]`和`pd.DataFrame.loc[]`选择值时相同的模式。主要的区别在于，在选择时，你会在表达式的右侧使用`pd.DataFrame[]`和`pd.DataFrame.loc[]`，而在赋值时，它们出现在左侧。
- en: There’s more…
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The `pd.DataFrame.assign` method can be used to allow *method chaining* during
    assignment. Let’s start with a simple `pd.DataFrame` to illustrate the utility:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.DataFrame.assign`方法可用于在赋值时允许*方法链*。我们从一个简单的`pd.DataFrame`开始，来展示这种方法的用法：'
- en: '[PRE219]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '*Method chaining* refers to the ability of pandas to apply many algorithms
    in succession to a pandas data structure (algorithms and how to apply them will
    be covered in more detail in *Chapter 5*, *Algorithms and How to Apply Them*).
    So, to take our `pd.DataFrame`, double it, and add 42 to each element, we could
    do something like:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法链*指的是pandas能够将多个算法连续应用于pandas数据结构的能力（算法及其应用方式将在*第5章*，*算法及其应用*中详细讨论）。所以，要将我们的`pd.DataFrame`进行加倍并为每个元素加上42，我们可以做类似如下的操作：'
- en: '[PRE221]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'But what happens if we want to add a new column as part of this chain of events?
    Unfortunately, with the standard assignment operators, you would have to break
    that chain of events and usually assign a new variable:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想在这个链条中添加一个新列会发生什么呢？不幸的是，使用标准赋值运算符时，你需要打破这个链条，通常需要为新变量赋值：
- en: '[PRE223]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'But with `pd.DataFrame.assign`, you can continue chaining along. Simply pass
    the desired column label as a keyword to `pd.DataFrame.assign`, whose argument
    is the values you would like to see in the new `pd.DataFrame`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 但是通过`pd.DataFrame.assign`，你可以继续链式操作。只需将所需的列标签作为关键字传递给`pd.DataFrame.assign`，其参数是你希望在新的`pd.DataFrame`中看到的值：
- en: '[PRE225]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: In this case, you are limited to using labels that meet Python’s syntax requirements
    for parameter names, and this, unfortunately, does not work with a `pd.MultiIndex`.
    Some users think method chaining makes debugging harder, while others argue that
    method chaining like this makes code easier to read. Ultimately, there is no right
    or wrong answer, and the best advice I can give you for now is to use the form
    you feel most comfortable with.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你只能使用符合Python语法要求的标签作为参数名，而不幸的是，这在`pd.MultiIndex`中无法使用。有些用户认为方法链使调试变得更困难，而另一些人则认为像这样的方法链使代码更容易阅读。归根结底，没有对错之分，我现在能给出的最佳建议是使用你最舒服的形式。
- en: Join our community on Discord
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/pandas](https://packt.link/pandas)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/pandas](https://packt.link/pandas)'
- en: '![](img/QR_Code5040900042138312.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code5040900042138312.png)'
