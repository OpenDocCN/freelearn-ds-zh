- en: From Engagement to Conversion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从参与到转化
- en: In this chapter, we will expand your knowledge of explanatory analysis and show
    you how to use **decision trees** to understand the drivers behind consumer behavior.
    We will start by comparing and explaining the differences between logistic regression
    and decision tree models, and then we will discuss how decision trees are built
    and trained. Next, we will discuss how a trained decision tree model can be used
    to extract information about the relationships between the attributes (or features)
    of individual consumers and the target output variables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展你对说明性分析的知识，并向你展示如何使用**决策树**来理解消费者行为的驱动因素。我们将从比较和解释逻辑回归和决策树模型之间的区别开始，然后我们将讨论决策树是如何构建和训练的。接下来，我们将讨论如何使用训练好的决策树模型来提取有关单个消费者属性（或特征）与目标输出变量之间关系的信息。
- en: For programming exercises, we will use the bank marketing dataset from the UCI
    Machine Learning Repository to understand the drivers behind conversions. We will
    start with some data analysis, so that you can better understand the dataset;
    then, we will build decision tree models by using the `scikit-learn` package in
    Python and the `rpart` package in R. Lastly, you will learn how to interpret these
    trained decision tree models by visualizing them using the `graphviz` package
    in Python and the `rattle` package in R. By the end of this chapter, you will
    be familiar with decision trees and will have a better understanding of when and
    how to use them with Python or R.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程练习中，我们将使用UCI机器学习库中的银行营销数据集来理解转化的驱动因素。我们将从数据分析开始，以便你更好地理解数据集；然后，我们将使用Python中的`scikit-learn`包和R中的`rpart`包构建决策树模型。最后，你将学会如何通过Python中的`graphviz`包和R中的`rattle`包来可视化这些训练过的决策树模型，从而理解它们的解读方式。到本章结束时，你将熟悉决策树，并且更好地理解何时以及如何使用Python或R来应用它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Decision trees
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策树
- en: Decision trees and interpretations with Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策树与Python的解释
- en: Decision trees and interpretations with R
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策树与R的解释
- en: Decision trees
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决策树
- en: In the previous chapter, we discussed explanatory analysis and regression analysis.
    We are going to continue with that theme and introduce another machine learning
    algorithm that we can use to draw insights on customer behavior from data. In
    this chapter, we will be discussing a machine learning algorithm called **decision
    trees**:how they learn from the data and how we can interpret their results.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了说明性分析和回归分析。我们将继续这个主题，并介绍另一个机器学习算法，利用它可以从数据中提取客户行为的洞察。在本章中，我们将讨论一种机器学习算法——**决策树**：它是如何从数据中学习的，以及我们如何解读它们的结果。
- en: Logistic regression versus decision trees
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑回归与决策树的对比
- en: 'If you recall from the previous chapter, a **logistic regression** model learns
    from the data by finding the linear combination of the feature variables that
    best estimates the log odds of an event occurring. Decision trees, as the name
    suggests, learn from the data by growing a tree. We are going to discuss how decision
    tree models grow and to build trees in more detail in the following section, but
    the main difference between the logistic regression and decision tree models is
    the fact that logistic regression algorithms search for a single best linear boundary
    in the feature set, whereas the decision tree algorithm partitions the data to
    find the subgroups of data that have high likelihoods of an event occurring. It
    will be easier to explain this with an example. Let''s take a look at the following
    diagram:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得上一章的内容，**逻辑回归**模型通过找到特征变量的线性组合来学习数据，从而最好地估计事件发生的对数几率。顾名思义，决策树通过生长一棵树来学习数据。我们将在接下来的章节中详细讨论决策树模型是如何生长的以及如何构建树，但逻辑回归和决策树模型之间的主要区别在于：逻辑回归算法在特征集中搜索一个最佳的线性边界，而决策树算法则通过划分数据来找到发生事件可能性较高的数据子群体。通过一个例子来解释会更容易。让我们来看一下以下图示：
- en: '![](img/8d0bb394-1e86-48ec-9bfd-8c8bda7e1d97.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d0bb394-1e86-48ec-9bfd-8c8bda7e1d97.png)'
- en: This is an example of a decision tree model. As you can see in this diagram,
    it partitions the data with certain criteria. In this example, the root node is
    split into child nodes by a criterion of `previous < 0.5`. If this condition is
    met and true, then it traverses to the left child node. If not, then it traverses
    to the right child node. The left child node is then split into its child nodes
    by a criterion of `age < 61`. The tree grows until it finds pure nodes (meaning
    that all of the data points in each node belong to one class) or until it meets
    certain criteria to stop, such as the maximum depth of the tree.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个决策树模型的示例。如你在这个图中所见，它通过某些标准来划分数据。在这个例子中，根节点通过 `previous < 0.5` 这个标准划分成子节点。如果这个条件成立且为真，那么它会遍历到左子节点。如果不成立，它则遍历到右子节点。左子节点随后通过
    `age < 61` 这个标准进一步划分。树会一直生长，直到找到纯净的节点（即每个节点中的所有数据点都属于同一类）或满足某些停止标准，例如树的最大深度。
- en: As you can see in this example, the data are split into seven partitions. The
    leftmost node or partition at the bottom is for those data points with values
    less than `0.5` for the `previous` variable and with values less than `61` for
    the `age` variable. On the other hand, the rightmost node at the bottom is for
    those data points with values greater than `0.5` for the `previous` variable and
    with values other than `yes` for the `housing` variable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这个例子中，数据被划分为七个分区。最左边的节点或分区是针对那些 `previous` 变量值小于 `0.5` 且 `age` 变量值小于 `61`
    的数据点。另一方面，最右边的节点位于底部，针对的是那些 `previous` 变量值大于 `0.5` 且 `housing` 变量值不是 `yes` 的数据点。
- en: One thing that is noticeable here is that there are a lot of interactions between
    different variables. No single leaf node in this example tree is partitioned with
    one condition. Every partition in this tree is formed with more than one criterion
    and interactions between different `feature` variables. This is the main difference
    from logistic regression models. When there is no linear structure in the data,
    logistic regression models will not be able to perform well, as they try to find
    linear combinations among the feature variables. On the other hand, decision tree
    models will perform better for non-linear datasets, as they only try to partition
    the data at the purest levels they can.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，不同变量之间有很多交互作用。在这个示例树中，没有任何一个叶节点是通过一个条件来划分的。树中的每个分区都是通过多个标准以及不同`feature`变量之间的交互作用来形成的。这与逻辑回归模型的主要区别在于，逻辑回归模型在数据中没有线性结构时，表现会很差，因为它们试图在特征变量之间找到线性组合。另一方面，决策树模型对于非线性数据集表现更好，因为它们仅仅是尝试在最纯净的水平上划分数据。
- en: Growing decision trees
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建决策树
- en: When we are growing decision trees, the trees need to come up with a logic to
    split a node into child nodes. There are two main methods that are commonly used
    for splitting the data: **Gini impurity** and **entropy information gain**. Simply
    put, *Gini* impurity measures how impure a partition is, and entropy information
    gain measures how much information it gains from splitting the data with the criteria
    being tested.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建决策树时，树需要提出逻辑来将一个节点划分为子节点。通常用于数据划分的两种主要方法是：**Gini 不纯度**和**熵信息增益**。简而言之，*Gini*
    不纯度度量一个分区的不纯度，而熵信息增益度量的是根据所测试的标准划分数据后，所获得的信息量。
- en: 'Let''s take a quick look at the equation to compute the *Gini* impurity measure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下计算 *Gini* 不纯度度量的公式：
- en: '![](img/dcc06319-5223-49a9-bbff-b4475b53664f.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcc06319-5223-49a9-bbff-b4475b53664f.png)'
- en: Here, *c* stands for the class labels, and *P[i]* stands for the probability
    of a record with the class label *i* being chosen. By subtracting the sum of squared
    probabilities from one, the *Gini* impurity measure reaches zero, that is, when
    all records in each partition or node of a tree are pure with a single target
    class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*c* 代表类标签，*P[i]* 代表记录被选择时属于类标签 *i* 的概率。通过从 1 中减去概率的平方和，*Gini* 不纯度度量达到零，即当树的每个分区或节点中的所有记录都是纯净的，且只有一个目标类时。
- en: 'The equation to compute the *entropy* looks as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 *熵* 的公式如下：
- en: '![](img/85b079d0-d694-434a-a6eb-ae22b25f62f5.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85b079d0-d694-434a-a6eb-ae22b25f62f5.png)'
- en: Like before, *c* stands for the class labels, and *P[i]* stands for the probability
    of a record with the class label *i* being chosen. When growing the tree, the
    entropy of each possible split needs to be calculated and compared against the
    entropy before the split. Then, the split that gives the biggest change in entropy
    measures or the highest information gain will be chosen to grow the tree. This
    process will be repeated until all of the nodes are pure, or until it meets the
    stopping criteria.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，*c*代表类标签，*P[i]*代表记录具有类标签*i*被选择的概率。构建树时，需要计算每个可能分割的熵，并与分割前的熵进行比较。然后，选择熵度量变化最大或信息增益最高的分割来继续构建树。这个过程将重复，直到所有节点都是纯净的，或满足停止标准。
- en: Decision trees and interpretations with Python
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行决策树构建与解释
- en: In this section, you are going to learn how to use the `scikit-learn` package
    in Python to build decision tree models and interpret the results via visualizations
    using Python's `graphviz` package. For those readers that would like to use R
    instead of Python for this exercise, you can skip to the next section. We will
    start this section by analyzing the bank marketing dataset in depth, using the `pandas` and `matplotlib` packages,
    and then we will discuss how to build and interpret decision tree models.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用Python的`scikit-learn`包构建决策树模型，并通过Python的`graphviz`包进行可视化解释结果。对于那些希望使用R而非Python进行此练习的读者，你可以跳过到下一节。我们将从分析银行营销数据集开始，使用`pandas`和`matplotlib`包进行深入分析，随后讨论如何构建和解释决策树模型。
- en: For this exercise, we will be using one of the publicly available datasets from
    the UCI Machine Learning Repository, which can be found at [https://archive.ics.uci.edu/ml/datasets/bank+marketing](https://archive.ics.uci.edu/ml/datasets/bank+marketing).
    You can follow the link and download the data in ZIP format. We will use the `bank.zip`
    file for this exercise. When you unzip this file, you will see two CSV files: `bank.csv`
    and `bank-full.csv`. We are going to use the `bank-full.csv` file for this Python
    exercise.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将使用UCI机器学习库中的一个公开数据集，地址为[https://archive.ics.uci.edu/ml/datasets/bank+marketing](https://archive.ics.uci.edu/ml/datasets/bank+marketing)。你可以通过链接下载ZIP格式的数据。我们将使用`bank.zip`文件进行本次练习。当你解压缩该文件时，你会看到两个CSV文件：`bank.csv`和`bank-full.csv`。我们将在此次Python练习中使用`bank-full.csv`文件。
- en: 'In order to load this data into your Jupyter Notebook, you can run the following
    code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据加载到Jupyter Notebook中，你可以运行以下代码：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see from this code snippet, we use the `%matplotlib inline` command
    to show plots on the Jupyter Notebook. Then, we import the `matplotlib` and `pandas`
    packages that we are going to use for the data analysis step. Lastly, we can easily
    read the data file by using the `read_csv` function in the `pandas` package. One
    thing to note here is the `sep` argument in the `read_csv` function. If you look
    at the data closely, you will notice that the fields in the `bank-full.csv` file
    are separated by semicolons (`;`), not commas (`,`). In order to correctly load
    the data into a `pandas` DataFrame, we will need to tell the `read_csv` function
    to use semicolons as the separators, instead of commas.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码片段可以看出，我们使用`%matplotlib inline`命令在Jupyter Notebook中显示图表。接下来，我们导入了用于数据分析步骤的`matplotlib`和`pandas`包。最后，我们可以通过使用`pandas`包中的`read_csv`函数轻松读取数据文件。这里需要注意的是`read_csv`函数中的`sep`参数。如果仔细查看数据，你会发现`bank-full.csv`文件中的字段是由分号（`;`）分隔的，而不是逗号（`,`）。为了正确地将数据加载到`pandas`数据框中，我们需要告诉`read_csv`函数使用分号作为分隔符，而不是逗号。
- en: 'Once you have loaded the data, it should look like the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了数据，它应该看起来像下图所示：
- en: '![](img/edd8cfd2-6ceb-4846-aab1-752933a982c3.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edd8cfd2-6ceb-4846-aab1-752933a982c3.png)'
- en: Data analysis and visualization
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据分析与可视化
- en: 'Before we start to analyze the data, we will first encode the output variable,
    `y`, which has information about whether a customer has converted or subscribed
    to a term deposit, with numerical values. You can use the following code to encode
    the output variable, `y`, with zeros and ones:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始分析数据之前，我们将首先对输出变量`y`进行编码，`y`包含关于客户是否已转化或订阅定期存款的信息，使用数值表示。你可以使用以下代码将输出变量`y`编码为零和一：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see from this code snippet, you can use the `apply` function to encode
    the output variable. We stored these encoded values in a new column, named `conversion`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码片段可以看出，你可以使用`apply`函数对输出变量进行编码。我们将这些编码后的值存储在一个新列中，命名为`conversion`。
- en: Conversion rate
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转化率
- en: 'Let''s first take a look at the aggregate conversion rate. The **conversion
    rate** is simply the percentage of customers that subscribed to a term deposit.
    Take a look at the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下总的转化率。**转化率**是指订阅定期存款的客户所占的百分比。请看以下代码：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see from this code snippet, we are grouping by a column, `conversion`,
    which is encoded with `1` for those that have subscribed to a term deposit, and
    with `0` for those that have not. Then, we are counting the number of customers
    in each group and dividing it by the total number of customers in the dataset.
    The result looks as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中你可以看到，我们按`conversion`列进行分组，`conversion`列用`1`表示那些已经订阅定期存款的客户，`0`表示那些没有订阅的客户。然后，我们计算每个组别中的客户数量，并将其除以数据集中客户的总数。结果如下所示：
- en: '![](img/99f9f19c-3871-4394-bd59-55c3fce7f530.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99f9f19c-3871-4394-bd59-55c3fce7f530.png)'
- en: To make it easier to view, you can transpose the DataFrame by using the `T`
    attribute of the `pandas` DataFrame. As you can see, only about 11.7% were converted
    or subscribed to a term deposit. From these results, we can see that there is
    a large imbalance between the conversion group and the non-conversion group, which
    is common and is frequently observed among various marketing datasets.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易查看，你可以通过使用`pandas` DataFrame的`T`属性来转置数据框。正如你所看到的，只有大约11.7%的客户进行了转化或订阅了定期存款。从这些结果来看，我们可以发现转化组和非转化组之间存在较大的不平衡，这种情况在各种营销数据集中是常见的，并且经常出现。
- en: Conversion rates by job
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按工作类别的转化率
- en: 'It might be true that certain job categories tend to convert more frequently
    than others. Let''s take a look at the conversion rates across different job categories.
    You can achieve this by using the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可能某些工作类别的转化率确实比其他类别更高。让我们看一下不同工作类别之间的转化率。你可以通过以下代码来实现：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's take a deeper look at this code. We first group by the column, `job`,
    which contains information about the job category that each customer belongs to.
    Then, we sum over the `conversion` column for each job category, from which we
    get the total number of conversions for each job category. Lastly, we divide these
    conversion numbers by the total number of customers in each job category, in order
    to get the conversion rates for each job category.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这段代码。我们首先按`job`列进行分组，`job`列包含了每个客户所属的工作类别信息。然后，我们对每个工作类别的`conversion`列进行求和，从中得到每个工作类别的转化总数。最后，我们将这些转化数除以每个工作类别的客户总数，从而得到每个工作类别的转化率。
- en: 'The results look as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/e5a1ed43-084d-475a-b90a-3346bd87687a.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5a1ed43-084d-475a-b90a-3346bd87687a.png)'
- en: 'As you can see from these results, the `student` group tends to convert much
    more frequently than the others, and the `retired` group comes next. However,
    it is a bit difficult to compare these from the raw output, and we could present
    this data better by using a chart. We can build a horizontal bar chart by using
    the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些结果中你可以看到，`student`组的转化率明显高于其他组，而`retired`组排在其后。然而，从原始输出中进行比较有些困难，我们可以通过使用图表来更好地展示这些数据。我们可以通过以下代码构建一个水平条形图：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you look at this code, we are using the `plot` function of the `pandas` DataFrame,
    and we defined the type of this plot to be a horizontal bar chart by providing
    `barh` as the input to the `kind` argument. You can simply adjust the color, size,
    and title of the chart with the `color`, `figsize`, and `title` arguments, respectively.
    You can also easily change the *x*-axis and *y*-axis labels, using the `set_xlabel`
    and `set_ylabel` functions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这段代码，你会发现我们正在使用`pandas` DataFrame的`plot`函数，并通过将`barh`作为`kind`参数的输入，定义了图表的类型为水平条形图。你可以轻松调整图表的颜色、大小和标题，分别使用`color`、`figsize`和`title`参数。你还可以通过`set_xlabel`和`set_ylabel`函数轻松更改*x*轴和*y*轴的标签。
- en: 'The resulting chart looks as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下所示：
- en: '![](img/3b42d4b7-1d54-4889-977a-3a30c5dd02a4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b42d4b7-1d54-4889-977a-3a30c5dd02a4.png)'
- en: As you can see, it is much easier to spot the differences in the conversion
    rates by each job category with a horizontal bar chart. We can easily see that
    the `student` and `retired` groups are the two groups with the highest conversion
    rates, whereas the `blue-collar` and `entrepreneur` groups are the two groups
    with the lowest conversion rates.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用水平条形图可以更容易地看到不同工作类别之间的转化率差异。我们可以清楚地看到，`student`和`retired`组是转化率最高的两个组，而`blue-collar`和`entrepreneur`组则是转化率最低的两个组。
- en: Default rates by conversions
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按转换情况划分的违约率
- en: 'Another attribute of a customer that would be interesting to see is the default
    rate, and how it differs between those who subscribed to a term deposit and those
    who did not. We are going to use the `pivot_table` function in the `pandas` library
    to analyze the default rates by conversions. Let''s take a look at the following
    code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得关注的客户属性是违约率，看看订阅定期存款的客户与未订阅的客户之间的违约率差异。我们将使用`pandas`库中的`pivot_table`函数来分析按转换情况划分的违约率。让我们来看一下下面的代码：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see from this code, we are pivoting the DataFrame, `df`, by the `y` and
    `default` columns. By using `len` as the aggregation function, we can count how
    many customers fall under each cell of the pivot table. The results look as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这段代码中，我们通过`y`和`default`列对数据框`df`进行透视。通过使用`len`作为聚合函数，我们可以计算每个透视表单元格下的客户数量。结果如下所示：
- en: '![](img/8257487f-4abc-4403-b5d1-6cb79ec4fc94.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8257487f-4abc-4403-b5d1-6cb79ec4fc94.png)'
- en: 'It is a bit difficult to compare how the default rates differ between the conversion
    and non-conversion groups by looking at these raw numbers. One way to visualize
    this data is through a pie chart. You can use the following code to build a pie
    chart:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭这些原始数据，很难比较转换组和非转换组之间的违约率差异。通过饼图来可视化这些数据是一种可行的方式。你可以使用以下代码来生成饼图：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see from this code, we are simply passing `''pie''` as input to
    the `kind` argument of the `plot` function. The resulting pie chart appears as
    follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这段代码中，我们只是将`'pie'`作为输入传递给`plot`函数的`kind`参数。生成的饼图如下所示：
- en: '![](img/eba95421-1547-4767-aadd-5494b5440972.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eba95421-1547-4767-aadd-5494b5440972.png)'
- en: As you can see from these pie charts, it is much easier to compare the default
    rates between the conversion and non-conversion groups. Although the overall percentage
    of the previous default is low in both groups, the default rate in the non-conversion
    group is about twice as high as the conversion group.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些饼图中可以看出，比较转换组和非转换组的违约率要容易得多。尽管两组的总体违约率都较低，但非转换组的违约率大约是转换组的两倍。
- en: Bank balances by conversions
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按转换情况划分的银行余额
- en: 'Next, we will try to see if there are any differences in the distributions
    of bank balances between the conversion and non-conversion groups. A box plot
    is typically a good way to visualize the distribution of a variable. Let''s take
    a look at the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试查看转换组和非转换组之间银行余额分布是否存在差异。箱型图通常是可视化变量分布的好方法。让我们来看一下下面的代码：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should be familiar with this code by now, as we have discussed how to build
    box plots using the `pandas` package. Using the `boxplot` function, we can easily
    build box plots such as the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经熟悉这段代码，因为我们已经讨论了如何使用`pandas`包构建箱型图。通过使用`boxplot`函数，我们可以轻松构建如下的箱型图：
- en: '![](img/f7970841-e6de-49b0-a7b1-1f4c8084aa40.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7970841-e6de-49b0-a7b1-1f4c8084aa40.png)'
- en: 'Because there are so many outliers, it is quite difficult to identify any differences
    between the two distributions. Let''s build another box plot without outliers.
    The only thing that you need to change from the previous code is the `showfliers=True`
    argument in the `boxplot` function, as you can see in the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在许多异常值，很难发现两个分布之间的差异。让我们构建一个不包含异常值的箱型图。你需要做的唯一更改就是在`boxplot`函数中将`showfliers=True`，如下所示：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using this code, you will see the following box plots for the distributions
    of bank balances between the two groups:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，你将看到如下的两个组别银行余额分布箱型图：
- en: '![](img/5c8dbee9-2db5-4d9d-bb6a-c721e18d129b.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c8dbee9-2db5-4d9d-bb6a-c721e18d129b.png)'
- en: From these box plots, we can see that the median of the bank balance is slightly
    higher for the conversion group, as compared to the non-conversion group. Also,
    the bank balances of converted customers seem to vary more than those of non-converted
    customers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些箱型图中，我们可以看到，相比非转换组，转换组的银行余额中位数略高。此外，转换客户的银行余额波动似乎比非转换客户更大。
- en: Conversion rates by number of contacts
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按联系次数划分的转换率
- en: 'Lastly, we will look at how the conversion rates vary by the number of contacts.
    Typically, in marketing, a higher number of marketing touches can result in marketing
    fatigue, where the conversion rates drop as you reach out to your customers more
    frequently. Let''s see whether there is any marketing fatigue in our data. Take
    a look at the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看看转化率如何随联系方式的数量变化。通常在营销中，更多的营销接触可能会导致营销疲劳，即随着您更频繁地联系客户，转化率下降。让我们看看我们的数据中是否存在营销疲劳。请查看以下代码：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this code snippet, you can see that we are grouping by the `campaign` column
    (which has information about the number of contacts performed during the marketing
    campaign for this customer) and computing the conversion rates for each number
    of contacts. The resulting data appears as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，您可以看到我们是通过`campaign`列（该列包含了此客户在营销活动中进行的联系方式数量的信息）进行分组，并计算每个联系方式数量的转化率。结果数据如下所示：
- en: '![](img/db83f22a-027b-4c4c-aac7-b418f88aa2f0.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db83f22a-027b-4c4c-aac7-b418f88aa2f0.png)'
- en: 'Like before, it would be easier to look at a chart, rather than raw numbers.
    We can plot this data by using bar charts, with the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，查看图表比直接查看原始数据更容易。我们可以使用以下代码通过柱状图绘制这些数据：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The plot looks as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图表如下所示：
- en: '![](img/6cbe0312-537f-4600-b2f6-e49f6a64e8ef.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cbe0312-537f-4600-b2f6-e49f6a64e8ef.png)'
- en: There's some noise in a higher numbers of contacts, as the sample size is smaller
    for them, but you can easily see the overall downward trend in this bar chart.
    As the number of contacts increases, the conversion rates slowly decrease. This
    suggests that the expected conversion rate decreases as you contact a client more
    frequently for a given campaign.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在联系方式数量较高的情况下会有一些噪声，因为这些样本的数量较少，但从这张柱状图中您可以很容易看到整体的下降趋势。随着联系方式数量的增加，转化率缓慢下降。这表明，在给定的营销活动中，随着您与客户的联系更频繁，预期的转化率会下降。
- en: Encoding categorical variables
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码类别变量
- en: There are eight categorical variables in this dataset: `job`, `marital`, `education`,
    `default`, `housing`, `loan`, `contact`, and `month`. Before we start to build
    decision trees, we need to encode these categorical variables with numerical values.
    We'll take a look at how we can encode some of these categorical variables in
    this section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据集包含八个类别变量：`job`、`marital`、`education`、`default`、`housing`、`loan`、`contact`和`month`。在我们开始构建决策树之前，需要将这些类别变量编码为数值。在本节中，我们将展示如何编码一些类别变量。
- en: Encoding months
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码月份
- en: 'We all know that there can only be 12 unique values for the `month` variable.
    Let''s take a quick look at what we have in our dataset. Take a look at the following
    code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，`month`变量只能有12个唯一值。让我们快速看看数据集中有哪些值。查看以下代码：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `pandas` function, `unique`, helps you to quickly get the unique values
    in the given column. When you run this code, you will get the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`函数`unique`帮助您快速获取给定列中的唯一值。运行此代码后，您将看到以下输出：'
- en: '![](img/57913c36-6c06-41d1-bea1-943abd0d37bf.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57913c36-6c06-41d1-bea1-943abd0d37bf.png)'
- en: 'As expected, we have 12 unique values for the `month` column, from January
    to December. Since there is a natural ordering in the values of `month`, we can
    encode each of the values with a corresponding number. One way to encode the string
    values of `month` with numbers is shown as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`month`列中有12个唯一值，从一月到十二月。由于`month`值之间有自然的顺序关系，我们可以用相应的数字对每个值进行编码。以下是将`month`的字符串值编码为数字的一种方式：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using this code, the unique values for the column `month` look as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，`month`列的唯一值如下所示：
- en: '![](img/3311d783-0ac2-4a7f-9157-7083a3a88926.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3311d783-0ac2-4a7f-9157-7083a3a88926.png)'
- en: 'To see how many records we have for each month, we can use the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看每个月的记录数，我们可以使用以下代码：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The results are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/aae40fb2-16e3-4a60-ba13-4afb2472f525.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aae40fb2-16e3-4a60-ba13-4afb2472f525.png)'
- en: Encoding jobs
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码作业
- en: 'Next, let''s look at how we can encode the different categories of the `job` column.
    We will first look at the unique values in this column, using the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何编码`job`列中的不同类别。我们首先使用以下代码查看该列中的唯一值：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The unique values in the  `job` column look as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`job`列中的唯一值如下所示：'
- en: '![](img/b7e7b157-3f55-40e3-b11e-01ce1297c386.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7e7b157-3f55-40e3-b11e-01ce1297c386.png)'
- en: 'As you can see in this output, there is no natural ordering for this variable.
    One `job` category does not precede the other, so we cannot encode this variable
    like we did for `month`. We are going to create dummy variables for each of the `job`
    categories. If you recall from the previous chapter, a **dummy variable** is a
    variable that is encoded with `1` if a given record belongs to the category, and
    `0` if not. We can do this easily by using the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中可以看出，该变量没有自然的顺序。一个 `job` 类别并不先于另一个，因此我们不能像对待 `month` 变量那样对该变量进行编码。我们将为每个
    `job` 类别创建虚拟变量。如果你还记得上一章的内容，**虚拟变量**是一个变量，如果给定记录属于该类别，则编码为 `1`，否则编码为 `0`。我们可以使用以下代码轻松完成此操作：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see from this code snippet, the `get_dummies` function in the `pandas`
    package creates one dummy variable for each category in the `job` variable, and
    encodes each record with `1` if the given record belongs to the corresponding
    category, and `0` if not. Then, we rename the columns by prefixing each column
    with `job_`. The result looks as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看出，`pandas` 包中的 `get_dummies` 函数为 `job` 变量中的每个类别创建一个虚拟变量，并且如果给定记录属于相应的类别，则编码为
    `1`，如果不属于则编码为 `0`。然后，我们通过在每个列名前加上 `job_` 前缀来重命名列。结果如下所示：
- en: '![](img/aa02a263-7126-4b15-a075-8e0c219d860d.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa02a263-7126-4b15-a075-8e0c219d860d.png)'
- en: 'As you can see from this screenshot, the first record (or customer) belongs
    to the `management` job category, while the second record belongs to the `technician`
    job category. Now that we have created dummy variables for each job category,
    we need to append this data to the existing DataFrame. Take a look at the following
    code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张截图中可以看出，第一条记录（或客户）属于 `management` 工作类别，而第二条记录属于 `technician` 工作类别。现在我们已经为每个工作类别创建了虚拟变量，我们需要将这些数据附加到现有的
    DataFrame 中。请看下面的代码：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using the `concat` function in the `pandas` package, you can easily add the
    newly created DataFrame with dummy variables, `jobs_encoded_df`, to the original
    DataFrame, `df`. The `axis=1` argument tells the `concat` function to concatenate
    the second DataFrame to the first DataFrame as columns, not as rows. The resulting
    DataFrame looks as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pandas` 包中的 `concat` 函数，您可以轻松地将新创建的包含虚拟变量的 DataFrame `jobs_encoded_df` 添加到原始
    DataFrame `df` 中。`axis=1` 参数告诉 `concat` 函数将第二个 DataFrame 作为列连接到第一个 DataFrame，而不是作为行连接。结果的
    DataFrame 如下所示：
- en: '![](img/0895e1e0-aa45-40b8-9e99-a680449c2c17.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0895e1e0-aa45-40b8-9e99-a680449c2c17.png)'
- en: As you can see, the newly created dummy variables are added to the original
    DataFrame as new columns for each record.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，新创建的虚拟变量被添加到原始 DataFrame 中，作为每条记录的新列。
- en: Encoding marital
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对婚姻状况进行编码
- en: 'Similar to how we encoded the categorical variable, `job`, we are going to
    create dummy variables for each category of the `marital` variable. Like before,
    we are using the following code to encode the `marital` column:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们如何对类别变量 `job` 进行编码，我们将为 `marital` 变量的每个类别创建虚拟变量。与之前一样，我们使用以下代码对 `marital`
    列进行编码：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The encoding results are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 编码结果如下：
- en: '![](img/56513a91-bce6-454c-939a-8a8c3b51cb84.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56513a91-bce6-454c-939a-8a8c3b51cb84.png)'
- en: 'As you can see, three new variables are created for the original variable,
    `marital`: `marital_divorced`, `marital_married`, and `marital_single`, representing
    whether a given customer is divorced, married, or single, respectively. In order
    to add these newly created dummy variables to the original DataFrame, we can use
    the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为原始变量 `marital` 创建了三个新变量：`marital_divorced`、`marital_married` 和 `marital_single`，分别表示客户是否离婚、已婚或单身。为了将这些新创建的虚拟变量添加到原始
    DataFrame 中，我们可以使用以下代码：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once you have come this far, your original DataFrame, `df`, should contain all
    of the original columns, plus newly created dummy variables for the `job` and
    `marital` columns.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，您的原始 DataFrame `df` 应该包含所有原始列，以及为 `job` 和 `marital` 列新创建的虚拟变量。
- en: Encoding the housing and loan variables
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对住房和贷款变量进行编码
- en: 'The last two categorical variables that we are going to encode in this section
    are `housing` and `loan`. The `housing` variable has two unique values, `''yes''`
    and `''no''`, and contains information on whether a customer has a housing loan.
    The other variable, `loan`, also has two unique values, `''yes''` and `''no''`,
    and tells us whether a customer has a personal loan. We can easily encode these
    two variables by using the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们将要编码的最后两个分类变量是`housing`和`loan`。`housing`变量有两个独特的值，`'yes'`和`'no'`，它包含关于客户是否有住房贷款的信息。另一个变量`loan`也有两个独特的值，`'yes'`和`'no'`，它告诉我们客户是否有个人贷款。我们可以通过以下代码轻松编码这两个变量：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, we are using the `apply` function to encode `yes` as `1` and
    `no` as `0` for both the housing and loan variables. For those categorical variables
    that we have not discussed in this section, you can use the same techniques that
    we have discussed to encode them if you wish to explore beyond this exercise.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在使用`apply`函数将`yes`编码为`1`，将`no`编码为`0`，用于`housing`和`loan`两个变量。对于本节未讨论的其他分类变量，如果你希望深入探索，可以使用我们讨论过的相同技术来对其进行编码。
- en: Building decision trees
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建决策树
- en: 'Now that we have encoded all of the categorical variables, we can finally start
    to build decision tree models. We are going to use the following variables as
    features in our decision tree models:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编码了所有分类变量，终于可以开始构建决策树模型了。我们将使用以下变量作为决策树模型的特征：
- en: '![](img/33e32db6-b239-4b18-b1f5-13d2e9086fac.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33e32db6-b239-4b18-b1f5-13d2e9086fac.png)'
- en: 'In order to build and train a decision tree model with Python, we are going
    to use the `tree` module in the `scikit-learn` (`sklearn`) package. You can import
    the required module by using the following line of code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Python构建和训练一个决策树模型，我们将使用`scikit-learn`（`sklearn`）包中的`tree`模块。你可以通过以下代码导入所需的模块：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Under the `tree` module in the `sklearn` package, there is a class named `DecisionTreeClassifier`,
    which we can use to train a decision tree model. Take a look at the following
    code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sklearn`包的`tree`模块下，有一个名为`DecisionTreeClassifier`的类，我们可以使用它来训练决策树模型。请看以下代码：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are many arguments to the `DecisionTreeClassifier` class, aside from the
    one that we are using here, `max_depth`. The`max_depth` argument controls how
    much a tree can grow, and here, we limit it to `4`, meaning that the maximum length
    from the root to a leaf can be `4`. You can also use the `criterion` argument
    to choose between the Gini impurity and the entropy information gain measures
    for the quality of a split. There are many other ways to tune your decision tree
    model, and we recommend that, for more information, you take a closer look at
    the documentation at [http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html](http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在这里使用的`max_depth`参数之外，`DecisionTreeClassifier`类还有许多其他参数。`max_depth`参数控制决策树的最大深度，在这里我们将其限制为`4`，意味着从根节点到叶节点的最大距离为`4`。你还可以使用`criterion`参数在基尼不纯度和信息增益的熵度量之间进行选择，这用于衡量分裂的质量。还有许多其他方法可以调整你的决策树模型，我们建议你查阅[http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html](http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html)的文档以获取更多信息。
- en: 'In order to train this decision tree model, you can use the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了训练这个决策树模型，你可以使用以下代码：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see from this code, the `fit` function takes two arguments: the `predictor`
    or `feature` variables and the `response` or `target` variables. In our case,
    `response_var` is the `conversion` column of the DataFrame, `df`. Once you have
    run this code, the decision tree model will learn how to make classifications.
    In the following section, we will discuss how we can interpret the results of
    this trained decision tree model.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从这段代码中看到的，`fit`函数接受两个参数：`predictor`或`feature`变量和`response`或`target`变量。在我们的例子中，`response_var`是DataFrame
    `df`中的`conversion`列。运行这段代码后，决策树模型将学习如何进行分类。在接下来的部分中，我们将讨论如何解读训练好的决策树模型的结果。
- en: Interpreting decision trees
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释决策树
- en: 'Now that we have trained a decision tree model, we need to extract the insights
    from the model. In this section, we are going to use a package called `graphviz`.
    You can install this package by using the following command in your Terminal:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经训练了一个决策树模型，接下来需要从模型中提取洞察。在这一部分，我们将使用一个名为`graphviz`的包。你可以通过在终端中使用以下命令来安装此包：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once you have installed this package correctly, you should be able to import
    the package as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦正确安装了这个包，你应该能够按如下方式导入该包：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we have set up our environment with the new package, `graphviz`, let''s
    take a look at the following code to see how we can visualize the trained decision
    tree:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经使用新包`graphviz`设置好了环境，接下来让我们看看以下代码，了解如何可视化训练好的决策树：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, we first export the trained decision tree model, `dt_model`,
    using the `export_graphviz` function in the `tree` module of the `sklearn` package.
    We can define the feature variables that we used to train this model by using
    the `feature_names` argument. Then, we can define the classes (conversion versus
    non-conversion) that this model is trained to classify. The `export_graphviz` function
    exports the trained decision tree model in a DOT format, which is a graphic description
    language. You can then pass `dot_data` on to the `graphviz` `Source` class. The
    `graph` variable now contains a renderable graph. The root node and its direct
    children look as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们首先使用`sklearn`包中的`tree`模块的`export_graphviz`函数导出了训练好的决策树模型`dt_model`。我们可以通过`feature_names`参数定义用于训练该模型的特征变量。然后，我们可以定义该模型被训练用于分类的类别（转换与非转换）。`export_graphviz`函数将训练好的决策树模型以DOT格式导出，DOT是一种图形描述语言。然后，你可以将`dot_data`传递给`graphviz`的`Source`类。`graph`变量现在包含了一个可渲染的图。根节点及其直接子节点如下所示：
- en: '![](img/d20c75f2-fa12-4a5b-8ee3-bd4e5fc9d310.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d20c75f2-fa12-4a5b-8ee3-bd4e5fc9d310.png)'
- en: 'The tree on the left half (or the children of the root node''s left child)
    looks as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 左半部分的树（或根节点左子节点的子节点）如下所示：
- en: '![](img/5e156f7d-b72b-4e9f-956c-d646b7f276cf.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e156f7d-b72b-4e9f-956c-d646b7f276cf.png)'
- en: 'The tree on the right half (or the children of the root node''s right child)
    looks as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 右半部分的树（或根节点右子节点的子节点）如下所示：
- en: '![](img/852140bc-7f6a-4553-b94c-b0373d043921.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/852140bc-7f6a-4553-b94c-b0373d043921.png)'
- en: Let's take a closer look at this diagram. Each node contains five lines that
    describe the information that the given node has. The top line tells us the criteria
    of the split. The root node, for example, is split into its child nodes based
    on the value of the `previous` variable. If the value of this `previous` variable
    is less than or equal to `0.5`, then it goes to the left child. On the other hand,
    if the value of this `previous` variable is larger than `0.5`, then it goes to
    the right child.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这个图。每个节点包含五行信息，描述了该节点的相关信息。第一行告诉我们分裂的标准。例如，根节点是基于`previous`变量的值进行分裂的。如果`previous`变量的值小于或等于`0.5`，则它会进入左子节点。另一方面，如果`previous`变量的值大于`0.5`，则它会进入右子节点。
- en: The second line tells us the value of the quality measure for the split. Here,
    we selected the `gini` impurity measure for the criteria, so we can see the changes
    in the impurity measures in each node from the second line. The third line tells
    us the total number of records that belong to the given node. For example, there
    are `45,211` samples in the root node, and there are `8,257` samples in the right
    child of the root node.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行告诉我们分裂的质量度量值。在这里，我们选择了`gini`不纯度作为标准，因此我们可以在第二行中看到每个节点中不纯度度量值的变化。第三行告诉我们属于该节点的记录总数。例如，根节点中有`45,211`个样本，根节点的右子节点中有`8,257`个样本。
- en: The fourth line in each node tells us the composition of the records in two
    different classes. The first element stands for the number of records in the non-conversion
    group, and the second element stands for the number of records in the conversion
    group. For example, in the root node, there are `39,922` records in the non-conversion
    group and `5,289` records in the conversion group. Lastly, the fifth line in each
    node tells us what the prediction or classification will be for the given node.
    For example, if a sample belongs to the leftmost leaf, the classification by this
    decision tree model will be `0`, meaning non-conversion. On the other hand, if
    a sample belongs to the eighth leaf from the left, the classification by this
    decision tree model will be `1`, meaning conversion.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点的第四行告诉我们两个不同类别中的记录组成。第一个元素表示非转化组中的记录数，第二个元素表示转化组中的记录数。例如，在根节点中，非转化组有`39,922`条记录，转化组有`5,289`条记录。最后，每个节点的第五行告诉我们该节点的预测或分类结果是什么。例如，如果一个样本属于最左侧的叶节点，那么该决策树模型的分类结果将是`0`，即非转化。另一方面，如果一个样本属于从左数第八个叶节点，那么该决策树模型的分类结果将是`1`，即转化。
- en: Now that we know what each of the lines in each nodes means, let's discuss how
    we can draw insights from this tree graph. In order to understand the customers
    that belong to each leaf node, we need to follow through the tree. For example,
    those customers that belong to the eighth leaf node from the left are those with
    a `0` value for the `previous` variable, `age` greater than `60.5`, a `marital_divorced`
    variable with a value of `1`, and a `job_self-employed` variable with a value
    of `1`. In other words, those who were not contacted before this campaign and
    who are older than `60.5`, divorced, and self-employed belong to this node, and
    have a high chance of converting.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了每个节点中的每一行意味着什么，让我们来讨论如何从这棵树图中提取洞见。为了理解属于每个叶节点的客户，我们需要沿着树走一遍。例如，那些属于从左数第八个叶节点的客户是`previous`变量值为`0`，`age`大于`60.5`，`marital_divorced`变量值为`1`，以及`job_self-employed`变量值为`1`的客户。换句话说，之前未曾联系过、年龄大于`60.5`、已离婚并且是自雇人士的客户属于这个节点，并且他们有较高的转化几率。
- en: Let's take a look at another example. Those customers that belong to the second
    leaf node from the right are those with a value of `1` for the `previous` variable,
    a value of `1` for the `housing` variable, `age` greater than `60.5`, and `balance`
    less than or equal to `4,660.5`. In other words, those customers that were contacted
    before this campaign and that have a housing loan, are older than `60.5`, and
    have a bank balance less than `4,660.5` belong to this node and `20` out of `29`
    that belong to this node have converted and subscribed to a term deposit.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个例子。那些属于从右数第二个叶节点的客户是`previous`变量值为`1`、`housing`变量值为`1`、`age`大于`60.5`、并且`balance`小于或等于`4,660.5`的客户。换句话说，之前曾联系过、拥有住房贷款、年龄大于`60.5`并且银行存款少于`4,660.5`的客户属于这个节点，并且其中`20`个中的`29`个客户已经转化并订阅了定期存款。
- en: As you will have noticed from these two examples, you can draw useful insights about
    who is more or less likely to convert from trained decision tree models, by visualizing
    the trained tree. You simply need to follow through the nodes and understand what
    kinds of attributes are highly correlated with your target class. For this exercise,
    we restricted the tree to only growing up to a depth of `4`, but you can choose
    to grow a tree larger or smaller than the one we used in this exercise.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从这两个例子中会注意到的，通过可视化训练好的决策树，你可以从中获得关于谁更可能或更不可能转化的有用洞见。你只需要沿着树的节点走一遍，并理解哪些属性与目标类别高度相关。为了这次练习，我们将树的深度限制为`4`，但是你可以选择将树生长得比我们在本次练习中使用的更大或更小。
- en: The full code for this chapter's Python exercise can be found in the repository
    at [https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.4/python/From%20Engagement%20to%20Conversions.ipynb](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.4/python/From%20Engagement%20to%20Conversions.ipynb).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的Python练习完整代码可以在仓库中找到：[https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.4/python/From%20Engagement%20to%20Conversions.ipynb](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.4/python/From%20Engagement%20to%20Conversions.ipynb)。
- en: Decision trees and interpretations with R
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用R语言的决策树及其解释
- en: In this section, you are going to learn how to use the `rpart` package in R
    to build decision tree models and interpret the results via visualizations with
    the R `rattle` package. For those readers that would like to use Python instead
    of R for this exercise, you can work through the Python examples in the previous
    section. We will start this section by analyzing the bank marketing dataset in
    depth, using the `dplyr` and `ggplot2` libraries, and then we will discuss how
    to build and interpret decision tree models.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用R中的`rpart`包构建决策树模型，并通过R的`rattle`包通过可视化来解释结果。对于那些希望使用Python而不是R进行练习的读者，您可以参考上一节中的Python示例。我们将通过使用`dplyr`和`ggplot2`库深入分析银行营销数据集来开始本节，然后我们将讨论如何构建和解释决策树模型。
- en: For this exercise, we will be using one of the publicly available datasets from
    the UCI Machine Learning Repository, which can be found at [https://archive.ics.uci.edu/ml/datasets/bank+marketing](https://archive.ics.uci.edu/ml/datasets/bank+marketing).
    You can follow the link and download the data in ZIP format. We will use the `bank.zip` file
    for this exercise. When you unzip this file, you will see two CSV files: `bank.csv` and `bank-full.csv`.
    We are going to use the `bank-full.csv` file for this exercise.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将使用来自UCI机器学习库的一个公开数据集，您可以在[https://archive.ics.uci.edu/ml/datasets/bank+marketing](https://archive.ics.uci.edu/ml/datasets/bank+marketing)找到。您可以访问该链接并下载ZIP格式的数据。我们将使用`bank.zip`文件进行此练习。当您解压这个文件时，您会看到两个CSV文件：`bank.csv`和`bank-full.csv`。我们将使用`bank-full.csv`文件进行此练习。
- en: 'In order to load this data into your RStudio, you can run the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些数据加载到您的RStudio中，您可以运行以下代码：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see from this code snippet, we can easily read the data file by using the `read.csv` function
    in R. One thing to note here is the `sep` argument in the `read.csv` function.
    If you look at the data closely, you will notice that the fields in the `bank-full.csv` file
    are separated by semicolons (`;`), not commas (`,`). In order to correctly load
    the data into a DataFrame, we will need to tell the `read.csv` function to use
    semicolons as the separators, instead of commas.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从这段代码中看到的，我们可以通过使用R中的`read.csv`函数轻松读取数据文件。需要注意的一点是`read.csv`函数中的`sep`参数。如果仔细查看数据，您会发现`bank-full.csv`文件中的字段是由分号（`;`）而不是逗号（`,`）分隔的。为了正确加载数据到DataFrame中，我们需要告诉`read.csv`函数使用分号作为分隔符，而不是逗号。
- en: 'Once you have loaded this data, it should look like the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您加载了这些数据，它应该看起来像以下截图：
- en: '![](img/de1dbdf1-84f4-4b82-ad07-743d1e2b754f.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de1dbdf1-84f4-4b82-ad07-743d1e2b754f.png)'
- en: Data analysis and visualizations
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据分析和可视化
- en: 'Before we start to analyze the data, we will first encode the output variable, `y`,
    which has information about whether a customer has converted or subscribed to
    a term deposit, with numerical values. You can use the following code to encode
    the output variable, `y`, with zeros and ones:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始分析数据之前，我们将首先对输出变量`y`进行编码，该变量包含关于客户是否已转换或订阅定期存款的信息，并用数值表示。您可以使用以下代码将输出变量`y`编码为零和一：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see from this code snippet, you can use the `as.integer` function
    to encode the output variable. Since this function will encode `no` values in
    the `y` variable  as `1` and `yes` values in the `y` variable as `2`, we subtract
    the values by `1` to encode them as `0` and `1`, respectively. We stored these
    encoded values into a new column, named `conversion`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从这段代码中看到的，您可以使用`as.integer`函数对输出变量进行编码。由于该函数会将`y`变量中的`no`值编码为`1`，而`y`变量中的`yes`值编码为`2`，我们通过减去`1`来将其编码为`0`和`1`，分别存储这些编码值到一个新列中，名为`conversion`。
- en: Conversion rate
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转化率
- en: 'The first thing that we are going to take a look at is the aggregate conversion
    rate. The conversion rate is simply the percentage of customers that subscribed
    to a term deposit, or those encoded with `1` in the column `conversion`. Take
    a look at the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先关注的是汇总的转化率。转化率简单地是那些订阅了定期存款的客户的百分比，或者那些在`conversion`列中被编码为`1`的客户。请查看以下代码：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see from this code snippet, we simply sum all of the values in the
    `conversion` column and divide by the number of records or customers in the DataFrame,
    `df`. Using the `sprintf` function, we format this conversion rate number with
    two decimal point numbers. The result looks as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从这段代码中看到的，我们只是将`conversion`列中的所有值相加，并除以DataFrame `df`中的记录或客户的数量。使用`sprintf`函数，我们将此转化率数字格式化为两位小数。结果如下：
- en: '![](img/c21a0e9b-e719-424d-ba6c-f915041eecc7.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c21a0e9b-e719-424d-ba6c-f915041eecc7.png)'
- en: As you can see from this output, only about `11.7%` were converted or subscribed
    to a term deposit. From these results, we can see that there is a large imbalance
    between the conversion group and the non-conversion group, which is quite common
    and is frequently observed among various marketing datasets.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中可以看到，只有约`11.7%`的客户转化或订阅了定期存款。从这些结果中，我们可以看到转化组和非转化组之间存在较大不平衡，这在各种营销数据集中是常见的现象。
- en: Conversion rates by job
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按职业分类的转化率
- en: 'It might be true that certain job categories tend to convert more frequently
    than others. Let''s take a look at the conversion rates across different job categories.
    You can achieve this by running the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可能确实存在某些职业类别的转化率比其他职业类别更高的情况。让我们看看不同职业类别之间的转化率。你可以通过运行以下代码来实现：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's take a more detailed look at this code. We first group by the column, `job`,
    which contains information about the job category that each customer belongs to.
    Then, we count the total number of customers in a given job category by using
    the `n()` function, and sum over the `conversion` column for each job category
    by using the `sum` function. Lastly, we divide the total number of conversions,
    `NumConversion`, by the total number of customers in each job category, `Count`,
    and multiply these numbers by `100.0` to get the conversion rates for each job
    category.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下这段代码。我们首先根据`job`列进行分组，该列包含每个客户所属的职业类别信息。然后，我们使用`n()`函数计算每个职业类别中的客户总数，并使用`sum`函数对每个职业类别的`conversion`列进行求和。最后，我们将转化总数`NumConversion`除以每个职业类别中的客户总数`Count`，并将结果乘以`100.0`，以计算每个职业类别的转化率。
- en: 'The results look as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/d05fb8b6-299f-466b-b73b-4fb7093fff02.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d05fb8b6-299f-466b-b73b-4fb7093fff02.png)'
- en: 'As you can see from these results, the `student` group tends to convert much
    more frequently than the others, and the `retired` group comes next. However,
    it is a bit difficult to compare these with raw output, and we will be able to
    better present this data by using a chart. We can build a horizontal bar chart
    by using the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些结果可以看出，`student`组的转化频率明显高于其他组，而`retired`组排在其后。然而，直接比较这些数据和原始输出有些困难，我们可以通过使用图表更好地呈现这些数据。我们可以使用以下代码构建一个水平条形图：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you look at this code, we are using the `ggplot` and `geom_bar` functions
    to build a bar chart with the `conversionsByJob` data (which we built in the previous
    code), and with the `Job` variable in the *x*-axis and the `ConversionRate` variable in
    the *y*-axis. Then, we use the `coord_flip` function to flip the vertical bar
    chart to a horizontal bar chart. You can use the `ggtitle`, `xlab`, and `ylab`
    functions to change the title, *x*-axis label, and *y*-axis label as you wish.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这段代码，我们使用了`ggplot`和`geom_bar`函数，利用`conversionsByJob`数据（我们在之前的代码中构建的）生成条形图，并将`Job`变量放在*X*轴，将`ConversionRate`变量放在*Y*轴。然后，我们使用`coord_flip`函数将垂直条形图转换为水平条形图。你可以使用`ggtitle`、`xlab`和`ylab`函数来更改标题、*X*轴标签和*Y*轴标签。
- en: 'The resulting chart looks as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图表如下所示：
- en: '![](img/cbd51610-3022-4180-b258-0618f507ee19.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbd51610-3022-4180-b258-0618f507ee19.png)'
- en: As you can see, it is much easier to see the differences in the conversion rates
    by each job category with a horizontal bar chart. We can easily see that the `student` and `retired` groups
    are the two groups with the highest conversion rates, whereas, the `blue-collar` and `entrepreneur` groups
    are the two groups with the lowest conversion rates.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用水平条形图更容易观察到不同职业类别之间的转化率差异。我们可以清晰地看到，`student`和`retired`组是转化率最高的两个组，而`blue-collar`和`entrepreneur`组则是转化率最低的两个组。
- en: Default rates by conversions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按转化率分类的违约率
- en: 'Another attribute of a customer that would be interesting to see is the default
    rate, and how it differs between those who subscribed to a term deposit and those
    who did not. Let''s take a look at the following R code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得关注的客户属性是违约率，以及已订阅定期存款和未订阅定期存款的客户之间的差异。让我们看一下以下的R代码：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see from this code, we are grouping the DataFrame, `df`, by the
    two columns, `default` and `conversion`, using the `group_by` function. By using `n()` as
    the aggregation function, we can count how many customers fall under each cell
    of the four cases. Let''s look at the following results:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看到，我们使用 `group_by` 函数将 DataFrame `df` 按 `default` 和 `conversion` 两列进行分组。通过使用
    `n()` 作为聚合函数，我们可以统计每个四个情况中的客户数量。让我们来看一下以下结果：
- en: '![](img/320df0e0-2b56-4fc7-8c26-e85a4ed037e9.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/320df0e0-2b56-4fc7-8c26-e85a4ed037e9.png)'
- en: 'It is a bit difficult to compare how the default rates differ between the conversion
    and non-conversion groups from looking at these raw numbers. One way to visualize
    this data is through a pie chart. You can use the following code to build a pie
    chart:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些原始数据来看，比较转化组和非转化组之间的默认率差异有点困难。可视化这个数据的一种方法是通过饼图。你可以使用以下代码来构建饼图：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, we are utilizing three functions here: `ggplot`, `geom_bar`,
    and `coord_polar("y")`. With the `coord_polar("y")` function, we can get the pie
    chart from a bar chart. Then, we can use the `facet_wrap` function to split it
    into two pie charts: one for the conversion group and another for the non-conversion
    group.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在这里使用了三个函数：`ggplot`、`geom_bar` 和 `coord_polar("y")`。通过使用 `coord_polar("y")`
    函数，我们可以从条形图生成饼图。然后，我们可以使用 `facet_wrap` 函数将其拆分成两个饼图：一个是转化组，另一个是非转化组。
- en: 'Take a look at the following pie chart:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的饼图：
- en: '![](img/1fe05b29-dda3-45fa-bd31-a123981a2bc1.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fe05b29-dda3-45fa-bd31-a123981a2bc1.png)'
- en: As you can see from these pie charts, it is much easier to compare the default
    rates between the conversion and non-conversion groups. Although the overall percentage
    of previous default is low in both groups, the default rate in the non-conversion
    group is about twice as high as the conversion group.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些饼图中，你可以更容易地比较转化组和非转化组之间的默认率。尽管两个组中以往的默认比例都较低，但非转化组的默认率大约是转化组的两倍。
- en: Bank balance by conversions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按转化次数划分的银行余额
- en: 'Next, we will try to see whether there are any differences in the distributions
    of the bank balances between the conversion and non-conversion groups. A box plot
    is typically a good way to visualize the distribution of a variable. Let''s take
    a look at the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试查看转化组和非转化组之间的银行余额分布是否存在差异。箱线图通常是一种很好的可视化变量分布的方式。我们来看一下下面的代码：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You should be familiar with this code by now, as we discussed how to build
    box plots in the previous chapter, using the `ggplot` and `geom_boxplot` functions.
    When you run this code, you will see the following box plot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该已经熟悉这段代码了，因为我们在上一章讨论过如何使用 `ggplot` 和 `geom_boxplot` 函数构建箱线图。当你运行这段代码时，你将看到以下箱线图：
- en: '![](img/f3aa26a3-e3d0-4b3d-b3b2-04c62b23b2ab.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3aa26a3-e3d0-4b3d-b3b2-04c62b23b2ab.png)'
- en: 'Because there are so many outliers, it is quite difficult to identify any differences
    between the two distributions. Let''s build another box plot without outliers.
    The only thing that you need to change from the previous code is the `outlier.shape
    = NA` argument in the `geom_boxplot` function, as you can see in the following
    code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有很多异常值，识别两组分布之间的差异变得相当困难。让我们构建另一个没有异常值的箱线图。你只需要修改上一段代码中的 `outlier.shape =
    NA` 参数，如下所示：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Using this code, you will see the following box plots for the distribution
    of bank balances between the two groups:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，你将看到以下关于两组银行余额分布的箱线图：
- en: '![](img/237999b5-a990-408b-8fd1-a96d7a52acbe.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/237999b5-a990-408b-8fd1-a96d7a52acbe.png)'
- en: From these box plots, we can see that the median of the bank balance is slightly
    higher for the conversion group, as compared to the non-conversion group. Also,
    the bank balances of converted customers seem to vary more than those of non-converted
    customers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些箱线图中，我们可以看到转化组的银行余额中位数略高于非转化组。此外，转化客户的银行余额似乎比非转化客户的余额波动更大。
- en: Conversion rates by number of contacts
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按联系人数量划分的转化率
- en: 'Lastly, we will look at how the conversion rates vary by the number of contacts.
    Typically, in marketing, a higher number of marketing contacts can result in marketing
    fatigue, wherein the conversion rates drop as you reach out to your customers
    more frequently. Let''s see whether there is any marketing fatigue in our data.
    Take a look at the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将查看转化率如何随着联系人数的变化而变化。通常在营销中，较高的营销联系人数可能导致营销疲劳，即当你更频繁地联系客户时，转化率会下降。让我们看看我们的数据中是否存在营销疲劳现象。请查看以下代码：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'From this code snippet, you can see that we are grouping by the  `campaign` column (which
    has information about the number of contacts performed during the marketing campaign
    for this customer) and computing the conversion rate for each number of contacts.
    The resulting data looks as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看到，我们是通过 `campaign` 列（该列包含了在该营销活动中对该客户进行的联系次数信息）进行分组，并计算每个联系次数对应的转化率。结果数据如下所示：
- en: '![](img/f126d9cd-bfdd-4aa3-a15e-92f5bf715f6a.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f126d9cd-bfdd-4aa3-a15e-92f5bf715f6a.png)'
- en: 'Like before, it would be easier to look at a chart rather than raw numbers.
    We can plot this data with bar charts by using the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，查看图表比查看原始数据更为直观。我们可以使用以下代码通过柱状图来绘制这些数据：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The plot looks as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图结果如下所示：
- en: '![](img/59b26b80-2ed8-46cf-88e9-c12a1b471cac.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59b26b80-2ed8-46cf-88e9-c12a1b471cac.png)'
- en: There is some noise in higher numbers of contacts, as the sample size is smaller
    for them, but you can easily see the overall downward trend in this bar chart.
    As the number of contacts increases, the conversion rates slowly decrease. This
    suggests that the expected conversion rate decreases as you contact a client more
    frequently for a given campaign.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在较高联系次数的情况下，由于样本量较小，会有一些噪声，但从这张柱状图中可以明显看到总体的下降趋势。随着联系次数的增加，转化率逐渐下降。这表明，当你在一个营销活动中更频繁地联系客户时，预期的转化率会降低。
- en: Encoding categorical variables
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对类别变量进行编码
- en: There are eight categorical variables in this dataset: `job`, `marital`, `education`, `default`, `housing`, `loan`, `contact`,
    and `month`. Before we start to build decision trees, we need to encode some of
    these categorical variables with numerical values. We'll take a look at how we
    can encode some of these categorical variables in this section.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集中有八个类别变量：`job`、`marital`、`education`、`default`、`housing`、`loan`、`contact`
    和 `month`。在构建决策树之前，我们需要将其中一些类别变量编码为数值。我们将在本节中看看如何对这些类别变量进行编码。
- en: Encoding the month
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对月份进行编码
- en: 'We all know that there can only be 12 unique values for the `month` variable.
    Let''s take a quick look at what we have in our dataset. Take a look at the following
    code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，`month` 变量最多只能有 12 个唯一值。让我们快速查看一下数据集中的内容。请查看以下代码：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `unique` function helps you to quickly get the unique values in the given
    column. When you run this code, you will get the following output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique` 函数帮助你快速获取给定列中的唯一值。当你运行这段代码时，你将获得以下输出：'
- en: '![](img/bea193fa-38af-45e1-a779-c06d0491a339.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bea193fa-38af-45e1-a779-c06d0491a339.png)'
- en: 'As we expected, we have 12 unique values for the `month` column, from January
    to December. Since there is a natural order in the values of `month`, we can encode
    each of the values with the corresponding number. One way to encode the string
    values of `month` with numbers is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，`month` 列中有 12 个唯一值，从一月到十二月。由于 `month` 的值有自然顺序，我们可以用对应的数字对每个值进行编码。将
    `month` 的字符串值编码为数字的一种方式如下：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s take a closer look at this code. `month.abb` is a built-in R constant
    that contains the three-letter abbreviated names for the month names, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这段代码。`month.abb` 是一个内置的 R 常量，包含了月份名称的三字母缩写，具体如下：
- en: '![](img/2f8db0b0-9ba1-4eea-8438-57e61afed48d.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f8db0b0-9ba1-4eea-8438-57e61afed48d.png)'
- en: As you can see, the first letters of each abbreviated `month` name are capitalized.
    However, the month names in the `month` column of our data are all in lowercase.
    That is why we use the `tolower` function to make all of the values in the `month.abb`
    constant lowercase. Using the `lapply` function, we can apply this `tolower` function
    across the `month.abb` list. Then, we use the `match` function, which returns
    the position of the matching string in an array, to convert the string values
    in the `month` column of the DataFrame to corresponding numerical values.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个缩写的`month`名称的首字母都被大写。然而，我们数据中的`month`列的月份名称都是小写的。这就是为什么我们使用`tolower`函数将`month.abb`常量中的所有值转换为小写。使用`lapply`函数，我们可以将这个`tolower`函数应用于`month.abb`列表。接着，我们使用`match`函数，它返回匹配字符串在数组中的位置，将DataFrame中`month`列的字符串值转换为对应的数值。
- en: 'Using this code, the unique values for the `month` column look as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，`month`列的唯一值如下所示：
- en: '![](img/423f83ae-563e-48b4-8a30-3c8290e24a1b.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/423f83ae-563e-48b4-8a30-3c8290e24a1b.png)'
- en: 'To see how many records we have for each month, we can use the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看每个月份的记录数量，我们可以使用以下代码：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The results are as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/4271c54d-3965-4a56-a046-162327636d1b.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4271c54d-3965-4a56-a046-162327636d1b.png)'
- en: Encoding the job, housing, and marital variables
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对工作、住房和婚姻变量进行编码
- en: 'Next, we are going to encode the three variables: `job`, `housing`, and `marital`.
    Since these variables do not have natural orders, we do not need to worry about
    which category gets encoded with which value. The simplest way to encode categorical
    variables with no orders in R is to use the `factor` function. Let''s take a look
    at the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编码三个变量：`job`、`housing`和`marital`。由于这些变量没有自然的顺序，我们不需要担心哪个类别被编码为哪个值。编码没有顺序的类别变量在R中的最简单方法是使用`factor`函数。让我们看一下以下代码：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see from this code, we are simply applying the `factor` function
    for these three variables, `job`, `housing`, and `marital`, and storing the encoded
    values back to the DataFrame, `df`. For the categorical variables that we have
    not discussed in this section, you can use the same techniques that we discussed
    in this section to encode them if you wish to explore beyond this exercise.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只是将`factor`函数应用于这三个变量：`job`、`housing`和`marital`，并将编码后的值存储回DataFrame `df`中。对于我们在本节中未讨论的类别变量，如果你希望进一步探索，可以使用我们在本节中讨论的相同技术对它们进行编码。
- en: Building decision trees
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建决策树
- en: 'Now that we have encoded all of the categorical variables, we can finally start
    to build decision tree models. We are going to use these variables as features
    for our decision tree models: `age`, `balance`, `campaign`, `previous`, `housing`, `job`,
    and `marital`. In order to build and train a decision tree model with R, we are
    going to use the `rpart` package. You can import the required library by using
    the following line of code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编码了所有类别变量，终于可以开始构建决策树模型了。我们将使用这些变量作为决策树模型的特征：`age`、`balance`、`campaign`、`previous`、`housing`、`job`和`marital`。为了使用R构建并训练决策树模型，我们将使用`rpart`包。你可以使用以下代码导入所需的库：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you do not have the `rpart` package installed, you can install it by using
    the following command:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装`rpart`包，你可以使用以下命令安装它：
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once you have imported the required library, you can use the following code
    to build a decision tree model:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你导入了所需的库，你可以使用以下代码来构建决策树模型：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, the first argument of the `rpart` model is `formula`, which
    defines the features and the target variable. Here, we are using the aforementioned
    variables as the features and `conversion` as the target variable. Then, we define
    this decision tree model to be a classification model with the `method="class"`
    input. Lastly, you can fine-tune the decision tree model with the `control` input.
    There are many parameters that you can tune with the `control` input. In this
    example, we are only restricting the maximum depth of the tree to be `4` with
    the `maxdepth` argument, and setting the value for `cp`, which is the complexity
    parameter, to be small enough for the tree to be able to be split. There are many
    other ways to tune your decision tree model, and we recommend that you take a
    closer look at the R documentation for more information, by running the `help(rpart)`
    or `help(rpart.control)` commands.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`rpart` 模型的第一个参数是 `formula`，它定义了特征和目标变量。在这里，我们使用上述变量作为特征，`conversion` 作为目标变量。然后，我们将此决策树模型定义为一个分类模型，并使用
    `method="class"` 输入。最后，您可以使用 `control` 输入来微调决策树模型。有许多参数可以通过 `control` 输入进行调整。在此示例中，我们仅通过
    `maxdepth` 参数将树的最大深度限制为 `4`，并将复杂度参数 `cp` 设置为足够小，以便树能够进行分裂。还有许多其他方法可以微调您的决策树模型，我们建议您通过运行
    `help(rpart)` 或 `help(rpart.control)` 命令，详细查看 R 文档以获取更多信息。
- en: Interpreting decision trees
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解读决策树
- en: 'Now that we have trained a decision tree model, we need to extract the insights
    from the model. In this section, we are going to use a library called `rattle`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经训练了一个决策树模型，接下来需要从模型中提取洞察。在本节中，我们将使用一个名为 `rattle` 的库：
- en: 'You can install this package by using the following command in your RStudio:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过在 RStudio 中使用以下命令来安装此包：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once you have installed this library correctly, you should be able to import
    the library as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦正确安装了此库，您应该能够按照以下方式导入该库：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once you have set up your R environment with this new library, `rattle`, it
    requires just one line of code to visualize the trained decision tree. Take a
    look at the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您在 R 环境中设置了这个新的库 `rattle`，只需一行代码就能可视化训练好的决策树。请查看以下代码：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, the `fancyRpartPlot` function takes in an `rpart` model object.
    Here, the model object, `fit`, is the decision tree model that we built in the
    previous step. Once you run this command, it will show the following diagram:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，`fancyRpartPlot` 函数接受一个 `rpart` 模型对象。在这里，模型对象 `fit` 是我们在前一步构建的决策树模型。一旦您运行这个命令，它将显示以下图表：
- en: '![](img/7829b6ee-ce98-41ba-9a99-c0b02ba49e54.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7829b6ee-ce98-41ba-9a99-c0b02ba49e54.png)'
- en: Let's take a closer look at this tree diagram. Each node contains three lines
    that describe the information that the given node has. The number on top of the
    node is the label and the order of the node that was built. We will use this label
    to refer to each of the nodes in this tree graph. Then, the top line in each node
    tells us what the prediction or classification will be for the given node. For
    example, if a sample belongs to the node that is labeled `4`, the classification
    by this decision tree model will be zero, meaning non-conversion. On the other
    hand, if a sample belongs to the node labeled `23`, the classification by this
    decision tree model will be one, meaning conversion.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下这个树形图。每个节点包含三行信息，描述了该节点所具有的信息。节点顶部的数字是标签，表示该节点构建的顺序。我们将使用这个标签来引用树图中的每个节点。然后，每个节点的顶行告诉我们该节点的预测或分类结果。例如，如果一个样本属于标签为
    `4` 的节点，则此决策树模型的分类结果为零，表示未转换。另一方面，如果一个样本属于标签为 `23` 的节点，则此决策树模型的分类结果为一，表示已转换。
- en: The second line in each node tells us the percentage of records in each class
    for the given node. For example, `52%` of the records in node `22` are in the
    class `0`, or the non-conversion group, and the remaining `48%` are in the class
    `1`, or the conversion group. On the other hand, `39%` of the customers in node
    `13` are in the class `0`, and the remaining `61%` of the customers in node `13`
    are in the class `1`. Lastly, the bottom line in each node tells us the percentage
    of the total number of records that belong to each node. For example, about `80%`
    of the customers fall under the category of node `4`, while close to `0%` of the
    customers fall under the category of node `13`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点中的第二行告诉我们该节点中每个类的记录百分比。例如，节点`22`中的`52%`记录属于类`0`，即非转化组，剩下的`48%`属于类`1`，即转化组。另一方面，节点`13`中的`39%`客户属于类`0`，剩下的`61%`属于类`1`。最后，每个节点中的底部行告诉我们属于每个节点的总记录百分比。例如，大约`80%`的客户属于节点`4`，而接近`0%`的客户属于节点`13`。
- en: Now that we know what each of the lines in each nodes means, let's discuss how
    we can draw insights from this tree diagram. In order to understand the customers
    that belong to each leaf node, we need to follow through the tree. For example,
    those customers that belong to node `13` are those with values greater than `0.5`
    for the `previous` variable, with a housing loan and `age` greater than or equal
    to `61`. In other words, those who were contacted before this campaign and who
    are older than `61`, with housing loans, belong to node `13` and have a high chance
    of converting.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道每个节点中每一行的含义了，让我们讨论一下如何从这个树状图中提取见解。为了理解属于每个叶节点的客户，我们需要沿着树走下去。例如，属于节点`13`的客户是那些`previous`变量值大于`0.5`，拥有住房贷款并且`age`大于或等于`61`的客户。换句话说，那些在此活动之前已被联系过、年龄超过`61`且拥有住房贷款的客户属于节点`13`，他们有较高的转化机会。
- en: Let's take a look at another example. In order to get to node `22` from the
    root node, we need to have a `0` value for the `previous` variable, an `age` greater
    than or equal to `61`, a `marital` status other than `married` or `single`, and
    a `job` in one of these categories: `admin`, `blue-collar`, `entrepreneur`, `housemaid`,
    `retired`, or `unknown`. In other words, those customers that have not been contacted
    before this campaign and who are older than `61`, divorced, and have a job in
    one of the previously mentioned categories, belong to the node `22` and have a
    roughly `50%` chance of converting.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个例子。为了从根节点到达节点`22`，我们需要使`previous`变量的值为`0`，`age`大于或等于`61`，`marital`状态不是`married`或`single`，并且`job`属于以下类别之一：`admin`、`blue-collar`、`entrepreneur`、`housemaid`、`retired`或`unknown`。换句话说，那些在此活动之前未被联系过、年龄超过`61`、已离婚并且在上述类别中有工作的客户属于节点`22`，他们有大约`50%`的转化机会。
- en: As you will have noticed from these two examples, you can draw useful insights
    on who is more or less likely to convert from trained decision tree models, by
    visualizing the trained tree. You simply need to follow through the nodes and
    understand what kinds of attributes are highly correlated with your target class.
    For this exercise, we restricted the tree to only growing up to a depth of `4`,
    but you can choose to grow a tree larger or smaller than the one that we used
    in this exercise.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从这两个例子中注意到的，你可以通过可视化训练过的决策树模型，得出关于哪些客户更有可能或更不可能转化的有用见解。你只需沿着节点走下去，理解与目标类高度相关的属性是什么。对于这个练习，我们将树的深度限制为`4`，但你可以选择让树的深度比我们在这个练习中使用的树大或小。
- en: The full code for this chapter's R exercise can be found in the repository at [https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.4/R/FromEngagementToConversions.R](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.4/R/FromEngagementToConversions.R).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节R语言练习的完整代码可以在该仓库中找到：[https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.4/R/FromEngagementToConversions.R](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.4/R/FromEngagementToConversions.R)。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we introduced a new machine learning algorithm, decision trees,
    which we can use for marketing analytics in order to better understand the data
    and draw insights on customer behaviors. We discussed how decision tree models
    are different from logistic regression models, which you learned about in the
    previous chapter. You saw that decision tree models learn the data by partitioning
    the data points based on certain criteria. We also discussed the two measures
    that are frequently used when growing decision trees: the Gini impurity and entropy
    information gain. Using either of these measures, decision trees can grow until
    all of the nodes are pure, or until the stopping criteria are met.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们介绍了一种新的机器学习算法——决策树，它可以用于营销分析，以更好地理解数据并洞察客户行为。我们讨论了决策树模型与上章介绍的逻辑回归模型的不同之处。你了解到，决策树模型通过基于某些标准对数据点进行划分来学习数据。我们还讨论了在生长决策树时常用的两种衡量标准：基尼不纯度和信息增益熵。通过使用这两种衡量标准中的任何一种，决策树可以一直生长，直到所有节点都纯净，或者直到满足停止标准。
- en: During our programming exercises in Python and R, we used the bank marketing
    dataset from the UCI Machine Learning Repository. We started our programming exercised
    by analyzing the data in depth, using the `pandas` and `matplotlib` packages in
    Python and the `dplyr` and `ggplot2` libraries in R. Then, you learned how we
    can train and grow decision trees, using the `sklearn` package in Python and the `rpart`
    library in R. With these trained decision tree models, you also learned how to
    visualize and interpret the results. For visualizations, we used the `graphviz`
    package in Python and the `rattle` library in R. Moreover, you saw how we can
    interpret the decision tree results and understand the customer groups that are
    more likely to convert or subscribe to a term deposit by traversing through the
    trained decision trees, which is useful when we want to conduct an explanatory
    analysis of customer behaviors.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Python 和 R 编程练习中，我们使用了 UCI 机器学习库中的银行营销数据集。我们通过深入分析数据来开始编程练习，使用了 Python
    中的`pandas`和`matplotlib`包，以及 R 中的`dplyr`和`ggplot2`库。接着，你学习了如何使用 Python 中的`sklearn`包和
    R 中的`rpart`库来训练和生长决策树。通过这些训练好的决策树模型，你还学习了如何可视化和解释结果。为了进行可视化，我们使用了 Python 中的`graphviz`包和
    R 中的`rattle`库。此外，你还看到如何通过遍历训练过的决策树来解释决策树结果，理解哪些客户群体更可能转化或订阅定期存款，这在我们进行客户行为的解释性分析时非常有用。
- en: In the following chapters, we are going to switch gears and focus on product
    analytics. In the next chapter, we will discuss the kinds of exploratory analysis
    that we can run to understand and identify patterns and trends in product data.
    With the product analytics results from the next chapter, we will show how we
    can build a product recommendation model.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将改变方向，专注于产品分析。在下一章中，我们将讨论可以进行的探索性分析，以理解和识别产品数据中的模式和趋势。基于下一章的产品分析结果，我们将展示如何构建产品推荐模型。
