- en: Chapter 10. Visualization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 可视化
- en: '|   | *"Numbers have an important story to tell. They rely on you to give them
    a clear and convincing voice."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *“数字有一个重要的故事要告诉我们。它们依赖于你，给它们一个清晰且有说服力的声音。”* |   |'
- en: '|   | --*Stephen Few* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*Stephen Few* |'
- en: Every chapter in this book has made use of visualization in some way, primarily
    using Incanter. Incanter is an effective tool to produce a wide variety of charts
    as we work, and these are often the ones we'll reach out for first while trying
    to understand a dataset. This initial phase is often called **exploratory data
    analysis** and, at this stage, we're interested in summarizing statistics such
    as the distribution of numerical data, the counts of the categorical data, and
    how the attributes in our data are correlated.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的每一章都以某种方式使用了可视化，主要使用Incanter。Incanter是一个有效的工具，可以在工作中制作各种各样的图表，这些图表通常是我们在试图理解数据集时首先会使用的。这个初步阶段通常被称为**探索性数据分析**，在这个阶段，我们感兴趣的是总结数据的统计信息，例如数值数据的分布、类别数据的计数，以及数据中属性之间的相关性。
- en: Having found a meaningful way to interpret data, we'll often want to communicate
    it to others. One of the most important tools for communication is visualization,
    and we may be required to convey subtle or complicated ideas to people without
    a strong analytical background. In this chapter, we'll use the library Quil—which
    grew out of software developed for visual artists—to produce attractive graphics
    that can help bring data to life. Visualization and communication design are large,
    rich fields that we will not cover in detail here. Instead, this chapter will
    offer two case studies showing how Clojure's data abstractions and Quil's drawing
    API can be used together for good effect.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到一种有意义的方式来解读数据后，我们通常会希望将其传达给他人。最重要的沟通工具之一就是可视化，我们可能需要向没有强大分析背景的人传达细微或复杂的概念。在本章中，我们将使用Quil库——这是为视觉艺术家开发的软件的延伸——来制作吸引人的图形，帮助使数据生动起来。可视化和沟通设计是广泛而丰富的领域，我们在这里无法详细覆盖。相反，本章将提供两个案例研究，展示如何将Clojure的数据抽象和Quil的绘图API结合起来，产生良好的效果。
- en: We'll begin this chapter by coming full circle and returning to the data we
    used in [Chapter 1](ch01.xhtml "Chapter 1. Statistics"), *Statistics*. We'll introduce
    Quil by demonstrating how to build a simple two-dimensional histogram from the
    Russian election data. Having covered the basics of drawing in Quil, we'll show
    how a few basic drawing instructions can combine to produce a compelling representation
    of the distribution of wealth in the United States.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的开始，我们将回到[第一章](ch01.xhtml "Chapter 1. Statistics")，*统计学*中使用的数据。我们将通过演示如何从俄罗斯选举数据构建一个简单的二维直方图来介绍Quil。在掌握了Quil绘图的基本知识后，我们将展示如何通过一些基本的绘图指令，结合起来，呈现美国财富分配的引人注目的图示。
- en: Download the code and data
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载代码和数据
- en: 'In this chapter, we''ll return to the data we used in the very first chapter
    of this book: data from the 2011 Russian election. Back, in [Chapter 1](ch01.xhtml
    "Chapter 1. Statistics"), *Statistics*, we used a scatter plot with transparency
    to visualize the relationship between voter turnout and the victor''s percentage
    of the vote. In this chapter, we''ll produce code to render the data as a two-dimensional
    histogram.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回到本书第一章中使用的数据：2011年俄罗斯选举的数据。在[第一章](ch01.xhtml "Chapter 1. Statistics")，*统计学*中，我们使用了带透明度的散点图来可视化选民投票率与胜选者选票百分比之间的关系。在本章中，我们将编写代码，将数据渲染为二维直方图。
- en: 'We''ll also be making use of the data on the distribution of wealth in the
    United States. This data is so small that we won''t have anything to download:
    we''ll type the figures directly into the source code.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用有关美国财富分配的数据。这个数据非常小，以至于我们不需要下载任何东西：我们将直接在源代码中输入这些数据。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code for this chapter is available at [https://github.com/clojuredatascience/ch10-visualization](https://github.com/clojuredatascience/ch10-visualization).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在[https://github.com/clojuredatascience/ch10-visualization](https://github.com/clojuredatascience/ch10-visualization)找到。
- en: 'The example code for this chapter contains a script to download the election
    data we used in [Chapter 1](ch01.xhtml "Chapter 1. Statistics"), *Statistics*.
    Once you''ve downloaded the source code, you can execute the script by running
    the following command line from within the project root:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码包含一个脚本，用于下载我们在[第一章](ch01.xhtml "Chapter 1. Statistics")，*统计学*中使用的选举数据。一旦下载了源代码，你可以通过在项目根目录内运行以下命令来执行脚本：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you downloaded the data for [Chapter 1](ch01.xhtml "Chapter 1. Statistics"),
    *Statistics* previously, you can simply move the data files across into this chapter's
    data directory, if you prefer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前下载了[第1章](ch01.xhtml "第1章 统计学")的*统计学*数据，你可以将数据文件直接移动到本章的数据目录中（如果你愿意的话）。
- en: Exploratory data visualization
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索性数据可视化
- en: At the outset of any data science project, there is likely to be a period of
    iterative data exploration when you gain insight into the data. Throughout this
    book, Incanter has been our primary visualization tool. Although it includes a
    large number of charts there will be occasions when it won't contain the ideal
    chart for the data you seek to represent.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何数据科学项目的初期，通常会有一个迭代数据探索的阶段，你可以在这个阶段获得对数据的洞察。在本书中，Incanter一直是我们的主要可视化工具。尽管它包含了大量的图表，但也会有一些场合，它不包含你想要表示的数据的理想图表。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Other Clojure libraries are stepping in to offer exploratory data visualization
    capabilities. For examples, see **clojurewerkz/envision** [https://github.com/clojurewerkz/envision](https://github.com/clojurewerkz/envision)
    and Karsten Schmidt's **thi-ng/geom** at [https://github.com/thi-ng/geom/tree/master/geom-viz](https://github.com/thi-ng/geom/tree/master/geom-viz).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 其他Clojure库正在提供探索性数据可视化功能。例如，查看**clojurewerkz/envision** [https://github.com/clojurewerkz/envision](https://github.com/clojurewerkz/envision)和Karsten
    Schmidt的**thi-ng/geom**，地址为[https://github.com/thi-ng/geom/tree/master/geom-viz](https://github.com/thi-ng/geom/tree/master/geom-viz)。
- en: 'For example, back in [Chapter 1](ch01.xhtml "Chapter 1. Statistics"), *Statistics*,
    we used a scatter plot with alpha transparency to visualize the voter turnout
    proportion against the proportion of votes for the winner. This wasn''t an ideal
    chart, because we were primarily interested in the density of points in a particular
    area. Alpha transparency helped reveal the structure of the data, but it wasn''t
    an unambiguous representation. Some points were still too feint to be visible
    or so numerous that they appeared as one:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[第1章](ch01.xhtml "第1章 统计学")的*统计学*中，我们使用了带有透明度的散点图来可视化选民投票率与赢家得票比例之间的关系。这不是理想的图表，因为我们主要关注的是某个特定区域内点的密度。透明度有助于揭示数据的结构，但它不是一种明确的表示。一些点仍然太微弱，无法看清，或者数量太多，以至于它们看起来像一个点：
- en: '![Exploratory data visualization](img/7180OS_10_100.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![探索性数据可视化](img/7180OS_10_100.jpg)'
- en: We could have solved these problems with a two-dimensional histogram. This type
    of plot uses color to communicate areas of high and low density over two dimensions.
    The chart is split into a grid with each cell of the grid signifying a range in
    both dimensions. The more the points fall into a cell of the grid, the greater
    is the density within the range.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以通过二维直方图解决这些问题。这种类型的图表使用颜色来传达二维空间中高低密度的区域。图表被划分为一个网格，网格中的每个单元格表示两个维度的一个范围。点越多地落入网格的单元格中，该范围内的密度就越大。
- en: Representing a two-dimensional histogram
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示二维直方图
- en: 'A histogram is simply a representation of a continuous distribution into a
    series of bins. Histograms were introduced in [Chapter 1](ch01.xhtml "Chapter 1. Statistics"),
    *Statistics* and, at the time, we wrote a binning function that would separate
    continuous data into discrete bins:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图只是将连续分布表示为一系列箱子的方式。直方图在[第1章](ch01.xhtml "第1章 统计学")的*统计学*中已经介绍，当时我们编写了一个分箱函数，将连续数据分为离散的箱子：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code will take a range of continuous `xs` and bucket them into distinct
    groups based on the `n-bins` parameter. For example, binning the range between
    0 and 19 into 5 bins yields the following sequence:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将对连续的`xs`范围进行分箱，并根据`n-bins`参数将其分成不同的组。例如，将0到19的范围分为5个箱子，结果如下：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `bin` function returns the bin index for each data point rather than the
    count, so we use Clojure''s `frequencies` function to determine the count of the
    points falling into the bin:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`bin`函数返回每个数据点的箱子索引，而不是计数，因此我们使用Clojure的`frequencies`函数来确定落入该箱子的点的数量：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is a reasonable representation of a one-dimensional histogram: as a map
    of the bins to be counted. To represent a two-dimensional histogram, we can simply
    perform the same calculation on both the *xs* and the *ys*. We map the vector
    function over the bin indices so that each point is converted into a representation
    of `[x-bin y-bin]`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个合理的一维直方图表示：它将计数的箱子映射出来。要表示二维直方图，我们只需要对*xs*和*ys*执行相同的计算。我们将向量函数映射到箱子的索引上，以便将每个点转换为`[x-bin
    y-bin]`的表示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function returns a map keyed by a vector of two values. The `frequencies`
    function will now count all the points that share both an *x* and a *y* bin:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回一个以两个值的向量为键的映射。`frequencies` 函数现在将计数所有在 *x* 和 *y* 轴上都共享同一个区间的点：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ll want to plot real data with our histogram, so let''s load the Russian
    data from [Chapter 1](ch01.xhtml "Chapter 1. Statistics"), *Statistics*. If you''ve
    downloaded the data into the sample code''s `data` directory, you can run the
    following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在直方图中绘制实际数据，因此让我们从 [第 1 章](ch01.xhtml "第 1 章 统计学")加载俄罗斯数据，*统计学*。如果你已经将数据下载到示例代码的
    `data` 目录中，可以运行以下代码：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see the huge range of values in the histogram bins: from just 1 in bin
    `[0 4]` to 24,302 in bin `[2 1]`. These counts will be the density values we plot
    on our histogram.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到直方图区间中的值范围巨大：从区间 `[0 4]` 中的 1 到区间 `[2 1]` 中的 24,302。这些计数值将是我们在直方图上绘制的密度值。
- en: Using Quil for visualization
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Quil 进行可视化
- en: Quil ([https://github.com/quil/quil](https://github.com/quil/quil)) is a Clojure
    library that provides an enormous amount of flexibility to produce custom visualizations.
    It wraps Processing ([https://processing.org/](https://processing.org/)), a Java
    framework that's been actively developed for many years by visual artists and
    designers, which aims promote "software literacy in visual arts and visual literacy
    within technology".
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Quil ([https://github.com/quil/quil](https://github.com/quil/quil)) 是一个 Clojure
    库，提供了大量的灵活性来生成自定义的可视化效果。它封装了 Processing ([https://processing.org/](https://processing.org/))，这是一个
    Java 框架，已被视觉艺术家和设计师积极开发多年，旨在促进“视觉艺术中的软件素养和技术中的视觉素养”。
- en: Any visualization done with Quil involves creating a *sketch*. A sketch is processing's
    term for a running a program that consists of drawing instructions. Most API functions
    are available from the `quil.core` namespace. We'll include it in our code as
    `q`. Calling `q/sketch` without any arguments will cause an empty window to pop
    up (although it may be obscured by other windows).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Quil 进行的任何可视化都涉及创建一个 *sketch*。sketch 是处理程序的术语，指的是运行一个由绘图指令组成的程序。大多数 API 函数都可以从
    `quil.core` 命名空间中调用。我们将其作为 `q` 包含在代码中。调用 `q/sketch` 并不传递任何参数时，将会弹出一个空窗口（尽管它可能会被其他窗口遮挡）。
- en: Drawing to the sketch window
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制到 sketch 窗口
- en: 'The default window size is 500px by 300px. We''d like our two-dimensional histogram
    to be square, so let''s make the window 250px in both directions:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的窗口大小是 500px x 300px。我们希望我们的二维直方图是正方形的，因此将窗口的宽高都设置为 250px：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since we have 5 bins for each of our two axes, it means that each bin will be
    represented by a square that is 50px wide and 50px high.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们每个轴都有 5 个区间，因此每个区间将由一个 50px 宽和 50px 高的正方形表示。
- en: 'Quil provides the standard 2D shape primitives for drawing: points, lines,
    arcs, triangles, quadrilaterals, rectangles, and ellipses. To draw a rectangle,
    we call the `q/rect` function with the location specified as the *x* and *y* coordinates,
    as well as a width and height.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Quil 提供了标准的二维形状原语用于绘制：点、线、弧、三角形、四边形、矩形和椭圆。要绘制一个矩形，我们调用 `q/rect` 函数，并指定 *x* 和
    *y* 坐标，以及宽度和高度。
- en: 'Let''s draw a square at the origin, 50px across. There are a couple of ways
    to supply drawing instructions to Quil but, in this chapter, we''ll pass what''s
    known as a `setup` function. This is a function of no arguments that we pass to
    sketch. Our zero-argument function simply calls `rect` with a position [0, 0]
    and a width and height of 50:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在原点绘制一个宽度为 50px 的正方形。有几种方式可以向 Quil 提供绘图指令，但在本章中，我们将传递一个被称为 `setup` 的函数。这是一个没有参数的函数，我们将其传递给
    sketch。我们的零参数函数仅仅是调用 `rect`，并传入位置 [0, 0] 和宽高为 50：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code generates the following image:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码生成了以下图像：
- en: '![Drawing to the sketch window](img/7180OS_10_110.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![绘制到 sketch 窗口](img/7180OS_10_110.jpg)'
- en: The rectangle may not be where you expected it to be, depending on your familiarity
    with computer graphics.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你对计算机图形学的熟悉程度，矩形的位置可能与预期不同。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Rectangles can also be drawn with rounded corners by passing a radius as the
    fifth argument. Different radii can be used for each corner by passing the values
    as arguments five to eight.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递半径作为第五个参数，也可以绘制带有圆角的矩形。通过传递第五到第八个参数的值，可以为每个角使用不同的半径。
- en: Before we proceed further, we need to understand Quil's coordinate system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要理解 Quil 的坐标系统。
- en: Quil's coordinate system
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Quil 的坐标系统
- en: The coordinate system Quil uses is the same as processing and most other computer
    graphics programs. If you're unfamiliar with drawing, this may seem counter-intuitive
    that the origin is at the top left corner of the display. The *y* axis runs down
    the screen and the *x* axis runs to the right.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Quil 使用的坐标系统与 Processing 和大多数其他计算机图形程序相同。如果你不熟悉绘图，可能会觉得起点位于显示屏左上角是直觉上不对的。*y*
    轴向下延伸，*x* 轴向右延伸。
- en: Clearly, this is not the direction of the *y* axis on most graphs, which means
    that the *y* coordinate will often need to be flipped while drawing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这不是大多数图表中 *y* 轴的方向，这意味着在绘图时，*y* 坐标通常需要被翻转。
- en: '![Quil''s coordinate system](img/7180OS_10_120.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Quil 的坐标系统](img/7180OS_10_120.jpg)'
- en: A common way to do this is to subtract the desired *y* value (as measured from
    the bottom of the sketch) from the height of the sketch. This transformation causes
    a *y* of zero to correspond to the bottom of the sketch. Greater values of *y*
    will correspond to the values higher up the sketch.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的方法是从草图底部测量的 *y* 值中减去所需的值，这样的转换使得 *y* 为零时对应草图的底部。较大的 *y* 值则对应草图中更高的位置。
- en: Plotting the grid
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制网格
- en: 'Let''s put this into practice with a simple grid. The following function accepts
    a number of bins, `n-bins`, and a `size` parameter expressed as a vector of `[width
    height]`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的网格来实践这个。以下函数接受一个箱子的数量 `n-bins` 和一个 `size` 参数，`size` 表示为 `[width height]`
    的向量：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From this, we can calculate `x-scale` and `y-scale`, a factor that enables us
    to convert bin index to pixel offset in each of the *x* and the *y* dimensions.
    These are used by our `setup` function that loops over both the *x* and the *y*
    bins, placing a rectangle for each bin.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从中，我们可以计算出 `x-scale` 和 `y-scale`，这是一个因子，使我们能够将箱子索引转换为 *x* 和 *y* 维度中的像素偏移。这些值被我们的
    `setup` 函数使用，`setup` 函数遍历 *x* 和 *y* 箱子，为每个箱子放置一个矩形。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how we're executing the loop inside `doseq`. Our drawing instructions
    are executed as a side effect. If we don't do this, Clojure's lazy evaluation
    would cause nothing to be drawn.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在 `doseq` 内部执行了循环。我们的绘图指令作为副作用执行。如果我们不这样做，Clojure 的惰性求值将导致没有任何绘制操作。
- en: 'The previous code generates the following graphic:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码生成了以下图形：
- en: '![Plotting the grid](img/7180OS_10_130.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![绘制网格](img/7180OS_10_130.jpg)'
- en: 'Having defined the earlier function, we''ve almost created a histogram. We
    just need to color each square in the grid with a color that represents an appropriate
    value for each bin in the histogram. To achieve this, we''ll need two more functions:
    one to fetch the value from the data corresponding to the bin and the other to
    interpret these values as a color.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了前面的函数后，我们几乎已经创建了一个直方图。我们只需要为网格中的每个方格着色，颜色代表每个箱子的适当值。为了实现这一点，我们需要两个额外的函数：一个从数据中获取与箱子对应的值，另一个将这些值解释为颜色。
- en: Specifying the fill color
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定填充颜色
- en: Filling colors in Quil is achieved with the `q/fill` function. Any fill we specify
    will continue to be used until we specify a new fill.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Quil 中填充颜色是通过 `q/fill` 函数实现的。我们指定的任何填充将在我们指定新的填充之前一直使用。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many functions in Quil affect the current drawing context and are *stateful*.
    For example, when we specify a fill value, it will be used for all subsequent
    drawing instructions until the fill is altered. Other examples are fill, stroke,
    scale, and font.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Quil 中的许多函数会影响当前的绘图上下文，并且是 *有状态的*。例如，当我们指定一个填充值时，它将在后续的所有绘图指令中使用，直到填充值被更改。其他例子包括填充、笔触、缩放和字体。
- en: 'The following code is an adapted version of our `draw-grid` function. The addition
    to `draw-filled-grid` is `fill-fn`: some way of coloring the rectangle at a point
    in the grid. The `fill-fn` function should be a function of two arguments, the
    *x* and *y* indices of the bin. It should return a representation that Quil can
    use as a fill:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是我们 `draw-grid` 函数的一个改编版本。`draw-filled-grid` 的新增部分是 `fill-fn`：用于给网格中的点着色的方式。`fill-fn`
    函数应该是一个接受 *x* 和 *y* 箱子索引作为参数的函数，它应返回 Quil 可以用作填充的表示：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Quil''s fill function accepts multiple arities:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Quil 的填充函数接受多个参数：
- en: '**One argument**: The RGB value (either as a number or the `q/color` representation)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个参数**：RGB 值（可以是一个数字或 `q/color` 表示法）'
- en: '**Two arguments**: The RGB, as with one argument, plus an alpha transparency'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两个参数**：与单个参数的情况一样，除了加上一个 alpha 透明度值'
- en: '**Three arguments**: The red, green, and blue components of the color as numbers
    between 0 and 255 inclusive'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三个参数**：颜色的红、绿、蓝分量，作为 0 到 255 之间的数字（包括 0 和 255）'
- en: '**Four arguments**: The red, green, blue, and alpha components as numbers'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**四个参数**：红色、绿色、蓝色和透明度的数值'
- en: 'We''ll see how to use the `color` representations shortly but, for now, we''ll
    represent colors with a simple numeric representation: as a number between 0 and
    255\. When the same number is used for red, green, and blue (or when `fill` is
    called with one or two arguments), we get a gray color. 0 corresponds to black
    and 255 corresponds to white.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到如何使用 `color` 表示法，但现在，我们将使用一个简单的数字表示法来表示颜色：介于 0 和 255 之间的数字。当红色、绿色和蓝色的数值相同时（或者当调用
    `fill` 函数时传递一个或两个参数），我们得到一种灰色。0 对应黑色，255 对应白色。
- en: 'If we divide the frequency of the value in each bin in the histogram by the
    maximum value, we''ll get a number between 0 and 1.0\. Multiplying by 255 will
    yield a value that Quil will convert into a gray color for us. We do this in the
    following `fill-fn` implementation, passing it to the `draw-filled-grid` function
    that we defined earlier:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将每个柱状图中值的频率除以最大值，我们将得到一个介于 0 和 1.0 之间的数字。将其乘以 255 将得到一个 Quil 会转换为灰色的值。我们在以下
    `fill-fn` 实现中做了这个，并将其传递给我们之前定义的 `draw-filled-grid` 函数：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The previous code generates the following graphic:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成了以下图形：
- en: '![Specifying the fill color](img/7180OS_10_140.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![指定填充颜色](img/7180OS_10_140.jpg)'
- en: 'The chart is doing what we want, but it''s a very crude representation of our
    data. Let''s increase the number of bins to increase the resolution of our histogram:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图表完成了我们想要的功能，但它是我们数据的非常粗略的表示。让我们增加箱子的数量来提高柱状图的分辨率：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code generates the following graphic:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了以下图形：
- en: '![Specifying the fill color](img/7180OS_10_150.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![指定填充颜色](img/7180OS_10_150.jpg)'
- en: With 25 rectangles along each of the *x* and the *y* axes, we have a finer-grained
    picture of the structure of the data. However, a side effect is that it's become
    hard to discern detail in the histogram, because of how dim most of the cells
    are. Part of the problem is that the top right corner has such a high value that
    even the central area (previously the brightest) is now not much more than a gray
    smudge.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *x* 和 *y* 轴上各有 25 个矩形，我们就能获得数据结构的更细粒度的图像。然而，副作用是由于大多数单元格的色调较暗，柱状图的细节变得难以辨认。部分问题在于右上角的值如此之高，以至于即便是中央区域（之前最亮的部分）现在也不过是一个灰色的模糊斑点。
- en: 'There are two solutions to this problem:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有两个解决方案：
- en: Mitigate the effect of the outlier by plotting the *z*-score instead of the
    actual value
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过绘制 *z*-分数而不是实际值来减轻离群值的影响
- en: Diversify the range of visual queues by using a greater range of colors
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用更广泛的颜色范围来多样化视觉线索
- en: We'll discover how to convert values into a full spectrum of colors in the next
    section, but first, let's convert the histogram value to a *z*-score. Plotting
    *z*-scores is a distribution-aware way of coloring the chart that will go a long
    way toward diminishing the effect of the extreme outlier in the top right corner.
    With a *z*-score, we'll be plotting the number of standard deviations away from
    the mean for each cell.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中学习如何将值转换为完整的颜色谱，但首先，让我们将柱状图的值转换为 *z*-分数。绘制 *z*-分数是以分布为意识的方式着色图表，这将大大减小右上角极端离群值的影响。使用
    *z*-分数，我们将绘制每个单元格与均值之间的标准差数量。
- en: 'To accomplish this, we need to know two things: the mean and the standard deviation
    of the frequencies in the histogram:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要知道两件事：柱状图中频率的均值和标准差：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code subtracts the mean from each value in the histogram and divides
    it by the mean. This will yield a value with a mean of zero. `1` will represent
    one standard deviation from the mean, `2` will represent two standard deviations
    from the mean, and so on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码从柱状图中的每个值中减去均值，然后除以均值。这样会得到一个均值为零的值。`1` 将代表离均值一个标准差，`2` 将代表离均值两个标准差，依此类推。
- en: Quil exposes a useful `map-range` function that will take one range of values
    and map it onto another range of values. For example, we could take the desired
    range of standard deviations (-1 to 3 in the earlier example) and map them onto
    the range 0 and 255\. This would correspond to four standard deviations of the
    distribution being represented as the full range of gray from black to white.
    Any data exceeding this range would simply be clipped.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Quil暴露了一个有用的`map-range`函数，它可以将一个值范围映射到另一个值范围。例如，我们可以将所需的标准差范围（在前面的例子中是-1到3）映射到0到255的范围。这样，分布的四个标准差将对应于从黑到白的完整灰度范围。任何超过此范围的数据将被裁剪。
- en: '![Specifying the fill color](img/7180OS_10_160.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![指定填充颜色](img/7180OS_10_160.jpg)'
- en: The result is a much more striking representation of the data in grayscale.
    The use of *z*-scores has brought more detail out in the main body of the histogram
    and we can perceive more of the variation in the tail.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个更引人注目的灰度数据表示方式。使用*z*分数使得直方图的主体部分呈现出更多细节，我们现在能够察觉到尾部的更多变化。
- en: However, the histogram is still not quite as clear as it could be, as distinguishing
    between the different shades of gray can be challenging. Where cells aren't adjacent
    to each other, it can be hard to determine whether they share the same value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管如此，直方图仍然没有达到理想的清晰度，因为区分不同的灰度色调可能会很有挑战性。在某些不相邻的单元格之间，可能很难判断它们是否共享相同的值。
- en: 'We can increase the range open to us by making use of color to represent each
    cell. This makes the histogram more like a heat map: "cooler" colors such as blue
    and green represent low values, while "hotter" colors such as orange and red represent
    the most dense regions of the heatmap.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用颜色来表示每个单元格，从而扩展可用的范围。这使得直方图更像热力图：“较冷”的颜色，如蓝色和绿色，代表低值，而“较热”的颜色，如橙色和红色，则代表热力图中最密集的区域。
- en: Color and fill
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色与填充
- en: To create a heat map version of our two-dimensional histogram, we'll have to
    take our *z*-score and find some way of mapping it to a color value. Rather than
    showing a discrete palette of colors, say 5, our heat map should have a smooth
    palette containing all the colors in the spectrum.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们二维直方图的热力图版本，我们需要将* z *分数与颜色值进行映射。与显示离散的颜色调色板（例如5种颜色）不同，我们的热力图应该有一个平滑的调色板，包含光谱中的所有颜色。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For those reading the print book or in black and white, you can download color
    images from Packt Publishing's website [https://www.packtpub.com/sites/default/files/downloads/Clojure_for_Data_Science_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/Clojure_for_Data_Science_ColorImages.pdf).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些阅读印刷版书籍或黑白版本的读者，你可以从Packt出版社的网站下载彩色图像：[https://www.packtpub.com/sites/default/files/downloads/Clojure_for_Data_Science_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/Clojure_for_Data_Science_ColorImages.pdf)。
- en: 'This is exactly what the Quil function `q/lerp-color` does. Given two colors
    and a ratio between zero and one, `lerp-color` will return a new color that interpolates
    between them. An amount of zero will return the first color and one the second,
    while 0.5 will return a color halfway between the two:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是Quil函数`q/lerp-color`所做的。给定两种颜色和介于0与1之间的比例，`lerp-color`将返回两者之间插值的新颜色。0的比例返回第一个颜色，1的比例返回第二个颜色，而0.5的比例则返回两者之间的颜色：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code makes use of an array of colors in the order of the spectrum. We use
    `q/map-range` to determine which two colors we will interpolate between and call
    `q/lerp-color` with the floating-point portion of the range.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了按光谱顺序排列的颜色数组。我们用`q/map-range`来确定我们将要插值的两个颜色，并使用`q/lerp-color`与范围的小数部分进行插值。
- en: 'We''ve already implemented a `draw-filled-grid` function that accepts `fill-fn`
    to determine which color should be used to fill the grid. Let''s pass our `z-score->heat`
    function to it now:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了一个`draw-filled-grid`函数，它接受`fill-fn`来决定使用哪种颜色填充网格。现在，让我们将`z-score->heat`函数传递给它：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This code generates the following graphic:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了以下图形：
- en: '![Color and fill](img/7180OS_10_170.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![颜色与填充](img/7180OS_10_170.jpg)'
- en: The heat map has exposed even more of the internal structure of the data. In
    particular, while the strong diagonal shape of the data is still evident, we can
    now see more of the variation within it. Details that were previously hard to
    determine (either because the region was too dense or too sparse) have become
    more apparent.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 热力图展示了数据的更多内部结构。尤其是，虽然数据的强烈对角形状依然显现，但我们现在可以看到更多的变化。先前难以确定的细节（无论是因为区域过于密集还是过于稀疏）变得更加明显。
- en: Outputting an image file
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出图像文件
- en: 'Now that we''re happy with the histogram, we want to output a high-quality
    version. By adding a call to `q/save` within the setup function, passing a filename,
    Quil will output to a file as well as the screen. The format of the image created
    will depend on the filename suffix: `.tif` for TIFF files, `.jpg` for JPEG files,
    `.png` for PNG files, and `.tga` for TARGA files:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对直方图感到满意，接下来我们希望输出高质量的版本。通过在设置函数中加入`q/save`命令，并传入文件名，Quil将同时将图表输出到文件和屏幕上。图像创建的格式将取决于文件名的后缀：`.tif`为TIFF文件，`.jpg`为JPEG文件，`.png`为PNG文件，`.tga`为TARGA文件：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We're also able to output to PDF, as we'll show with the next visualization.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将输出结果保存为PDF格式，正如接下来的可视化展示。
- en: Visualization for communication
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于沟通的可视化
- en: In the course of our work as data scientists, we may find ourselves needing
    to communicate with a wide variety of people. Our close colleagues and managers
    may be able to read and interpret our Incanter charts, but they're unlikely to
    impress the CEO. We may also have a role that requires us to communicate with
    the general public.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据科学家，在工作中我们可能需要与各种各样的人沟通。我们身边的同事和经理可能能够阅读并解读我们的Incanter图表，但这不会给CEO留下深刻印象。我们可能还需要与公众沟通。
- en: In either case, we should focus on making visualizations that are simple and
    powerful, but which don't sacrifice the integrity of the data. A lack of statistical
    training is no barrier to being able to understand subtle and nuanced arguments
    and we should respect our audience's intelligence. The challenge for us as data
    scientists is to find a representation that conveys the message effectively to
    them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是哪种情况，我们都应该专注于制作简单且有力的可视化图表，同时又不牺牲数据的完整性。缺乏统计学训练并不妨碍我们理解那些微妙而复杂的论点，我们应该尊重观众的智慧。作为数据科学家，我们面临的挑战是找到一种有效地传达信息的表现形式。
- en: For the remainder of this chapter, we'll work on a visualization that aims to
    communicate a more complex set of data in a succinct and faithful way.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将制作一个可视化图表，旨在以简洁而真实的方式传达更复杂的数据集。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The visualization we're going to create is a version of one of the graphs presented
    in the **Wealth Inequality in America** video online at [https://www.youtube.com/watch?v=QPKKQnijnsM](https://www.youtube.com/watch?v=QPKKQnijnsM).
    Produced by anonymous film maker Politizane, the powerful video has gathered more
    than 16 million hits on YouTube.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的可视化图表是来自于**美国财富不平等**视频中的一个图表版本，视频可以在[https://www.youtube.com/watch?v=QPKKQnijnsM](https://www.youtube.com/watch?v=QPKKQnijnsM)观看。该视频由匿名电影制作人Politizane制作，强有力的视觉冲击使其在YouTube上获得了超过1600万次点击。
- en: As is often the case with graphical representations like these, our data will
    come from several different sources.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的图形展示常常有一个问题，我们的数据将来自多个不同的来源。
- en: Visualizing wealth distribution
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化财富分布
- en: The first dataset we'll make use of is from an article by G. William Domhoff,
    research professor in psychology and sociology at the University of California,
    Santa Cruz. The numbers we will quote next are from an article entitled **Wealth,
    Income, and Power** at [http://www2.ucsc.edu/whorulesamerica/power/wealth.html](http://www2.ucsc.edu/whorulesamerica/power/wealth.html).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的第一个数据集来自加利福尼亚大学圣克鲁兹分校的心理学与社会学研究教授G. William Domhoff的一篇文章。我们接下来引用的数字来自一篇名为**财富、收入与权力**的文章，地址为[http://www2.ucsc.edu/whorulesamerica/power/wealth.html](http://www2.ucsc.edu/whorulesamerica/power/wealth.html)。
- en: 'Although the article is well worth reading in its entirety, a particularly
    striking graphic is a pie chart that shows the financial net worth breakdown of
    people in the U.S. in 2010:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然整篇文章都值得阅读，但其中一张特别引人注目的图表是一张饼图，展示了2010年美国人财务净资产的分布：
- en: '![Visualizing wealth distribution](img/7180OS_10_180.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![可视化财富分布](img/7180OS_10_180.jpg)'
- en: 'The pie chart is striking for several reasons. Firstly, the concept that over
    40 percent of the financial wealth is owned by such a small percentage is hard
    to comprehend. Secondly, each slice of the pie represents not just the vastly
    different quantities of wealth, but vastly different quantities of people, too:
    from 1 percent of the population to 80 percent of the population. Pie charts are
    notoriously difficult to read at the best of times, so this chart is doubly challenging.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这张饼图之所以引人注目，有几个原因。首先，40%以上的财富掌握在如此小的群体手中，这一概念令人难以理解。其次，饼图的每一块不仅代表着截然不同的财富数量，还代表着截然不同的人群数量：从占人口1%的群体到占人口80%的群体。饼图本就因阅读困难而著名，因此这张图表的挑战性更大。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pie charts are generally not a good way to represent data, even where the totals
    do conceptually represent parts of the whole. Author and programmer Steve Fenton
    has documented many of the reasons and provided appropriate alternatives at [https://www.stevefenton.co.uk/2009/04/pie-charts-are-bad/](https://www.stevefenton.co.uk/2009/04/pie-charts-are-bad/).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图通常不是表示数据的好方式，即使总数在概念上代表整体的一部分。作者兼程序员Steve Fenton已经记录了许多原因，并提供了适当的替代方法，详见[https://www.stevefenton.co.uk/2009/04/pie-charts-are-bad/](https://www.stevefenton.co.uk/2009/04/pie-charts-are-bad/)。
- en: 'Let''s see how we could go about reinterpreting this data to make it more comprehensible.
    As a first step, let''s extract the numbers we''ll be working with that are presented
    in the following table:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何重新解读这些数据，让它更易于理解。首先，提取出以下表格中所列的数字：
- en: '| Percentile | Total financial wealth, 2010 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 百分位 | 总金融财富，2010 |'
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0-79 | 5% |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 0-79 | 5% |'
- en: '| 80-89 | 11% |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 80-89 | 11% |'
- en: '| 90-95 | 13% |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 90-95 | 13% |'
- en: '| 96-99 | 30% |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 96-99 | 30% |'
- en: '| 100 | 42% |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 42% |'
- en: 'A small improvement over the pie chart would be to represent the same data
    as a bar chart. While people generally struggle to interpret the relative sizes
    of the pie chart segments successfully, bar charts present no such problem. The
    next example simply creates a bar chart out of the earlier numbers:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 相较于饼图，改进的小方法是将相同的数据表示为条形图。虽然人们通常很难成功地解读饼图中各个扇形的相对大小，条形图则不会遇到此类问题。下一个示例将简单地将之前的数据转换为条形图：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will return the following chart:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下图表：
- en: '![Visualizing wealth distribution](img/7180OS_10_190.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Visualizing wealth distribution](img/7180OS_10_190.jpg)'
- en: 'This is an improvement on the pie chart in the respect that it''s easier to
    compare the relative sizes of the categories. A significant problem remains though:
    the number of people represented by each category are so vastly different. The
    bar to the left represents 80 percent of the population, while the bar to the
    right represents 1 percent of the population.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对饼图的一种改进，因为它更容易比较各类别的相对大小。然而，仍然存在一个显著的问题：每个类别所代表的人数差异巨大。左侧的条形代表了80%的人口，而右侧的条形则代表了1%的人口。
- en: If we wanted to make this data more comprehensible, we could divide up the total
    into 100 equal units, each representing one percentile of the population. The
    width of each bar could be adjusted according to the number of percentiles it
    represents while preserving its area. Since each percentile unit represents an
    equal number of people, the resulting chart would allow us to more easily make
    comparisons across groups.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让这些数据更加易于理解，我们可以将总量划分为100个相等的单位，每个单位代表人口的一个百分位。每个条形的宽度可以根据其所代表的百分位数进行调整，同时保持其面积不变。由于每个百分位单位代表相同数量的人口，因此生成的图表可以让我们更容易地进行不同群体间的比较。
- en: 'One way we could achieve this is by returning a sequence of 100 elements, one
    for each percentile of the population. The value of each element in the sequence
    would be the proportion of overall wealth accounted for by the percentile. We
    already know that the top 1 percent owns 42 percent of overall wealth, but the
    other groups would get a value adjusted downwards for the number of percentiles
    they span:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过返回一个包含100个元素的序列来实现这一目标，每个元素代表一个人口百分位。序列中每个元素的值将是该百分位所占的财富比例。我们已经知道，前1%的人口拥有42%的财富，但其他群体将根据它们所代表的百分位数调整其值：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This example generates the following bar chart:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例生成了以下的条形图：
- en: '![Visualizing wealth distribution](img/7180OS_10_200.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Visualizing wealth distribution](img/7180OS_10_200.jpg)'
- en: By applying a simple transformation, we're able to gain a much better understanding
    of the true distribution. Each bar now represents an equal proportion of the population
    and the area of each bar represents the proportion of wealth owned by the percentile.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用一个简单的转换，我们能够更好地理解真正的分布情况。每个条形现在代表着相同比例的人口，条形的面积代表该百分位所拥有的财富比例。
- en: Bringing data to life with Quil
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Quil使数据更生动
- en: 'The transformation in the previous section results in a chart that shows the
    difference between the extreme ends of the scale almost too starkly: it''s hard
    to interpret anything but the largest bars. One solution would be to display the
    numbers on a log scale or a log-log scale as we did elsewhere in the book. If
    the audience for this chart are statistically literate, this might be the most
    appropriate thing to do, but let''s assume that the intended audience for our
    visualization is the general public.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前一部分的变换结果是一个几乎过于直观显示极端值差异的图表：除了最大条形外，几乎无法解读任何内容。一种解决方案是使用对数刻度或对数-对数刻度来显示数字，正如我们在本书的其他地方所做的那样。如果这个图表的观众是统计学上有素养的人，那么这样做可能是最合适的，但我们假设我们的可视化面向的目标观众是普通大众。
- en: The problem with the chart presented earlier is that the rightmost bar is so
    large that it overwhelms all the other bars. 80 percent of the area is represented
    by nothing more than a few pixels. In the next section, we'll make use of Quil
    to produce a visualization that makes better use of space while it simultaneously
    preserving the integrity of the chart.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的图表的问题是最右侧的条形图过大，压倒了其他所有条形。80%的面积仅由几个像素表示。在下一部分中，我们将利用Quil制作一个更好地利用空间，同时又能保持图表完整性的可视化。
- en: Drawing bars of differing widths
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制不同宽度的条形图
- en: 'Over the next several sections, we''ll build up a visualization in stages.
    Since we''ll be drawing a Quil sketch, we''ll first define some constants that
    will allow us to produce drawing instructions relative to the dimensions of the
    sketch. Some constants are omitted from the next code for brevity:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个部分中，我们将分阶段构建一个可视化。由于我们将绘制一个Quil草图，我们首先会定义一些常数，以便相对于草图的尺寸生成绘图指令。为了简洁起见，下一段代码省略了一些常数：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With these in place, we can begin to represent the bar chart in a more comprehensible
    way. The following code takes the wealth distribution and plots all but the final
    bar as a series of rectangles. The *y*-scale is calculated so that the largest
    bar we will draw will fill the height of the plot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些完成后，我们可以开始以更易于理解的方式呈现条形图。以下代码采用财富分布并将除了最后一条条形以外的所有条形绘制为一系列矩形。*y*轴的刻度被计算出来，以便我们绘制的最大条形图填满整个绘图的高度：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The bars we''ve drawn so far represent the 99 percent. The final bar will represent
    the final 1 percent of the population. So it fits the vertical scale we''ve devised
    without disappearing off the top of the sketch, we will make the bar correspondingly
    wider while preserving its area. As a result, the bar is 5 times shorter—but also
    5 times wider—than the others:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们绘制的条形图代表了99%的比例。最后一条条形将代表人口的最后1%。为了使其适应我们设计的垂直刻度，且不至于从草图的顶部消失，我们将相应地加宽该条形，同时保持其面积。因此，这条条形比其他条形短5倍——但也宽5倍：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The example outputs the following graphic:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 示例输出如下图：
- en: '![Drawing bars of differing widths](img/7180OS_10_210.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![绘制不同宽度的条形图](img/7180OS_10_210.jpg)'
- en: Already, we can see the relationship between largest bars more clearly, but
    it's not clearly apparent yet that it's a chart. In the next section, we'll add
    text to identify the subject of the chart and the range of the axes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经能够更清晰地看到最大条形之间的关系，但还不明显能看出这是一个图表。在接下来的部分中，我们将添加文本，以标明图表的主题和坐标轴的范围。
- en: Adding a title and axis labels
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加标题和坐标轴标签
- en: 'One of the convenient aspects of specialized visualization tools such as Incanter
    is that the axes can be automatically generated for our charts. Quil provides
    no help for us here, but since the bar widths are known, it''s not terribly hard
    for us to achieve. In the following code, we''ll make use of the `text`, `text-align`,
    `text-size` functions to write text to our visualization:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 专用可视化工具（如Incanter）的一大便利之处是，坐标轴可以自动生成。Quil在这里没有提供帮助，但由于条形宽度已知，因此我们并不难实现。在下面的代码中，我们将使用`text`、`text-align`、`text-size`等函数将文本写入我们的可视化中：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What we lose by using a nonspecialist charting library we gain in terms of
    flexibility. Next, we''ll write a function to produce letterpress-style embossing
    on the text:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非专业图表库所失去的，我们在灵活性上得到了补偿。接下来，我们将编写一个函数，在文本上制作凸印风格的压印效果：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We use the `emboss-text` function to draw a large title at the center of our
    chart. Notice how we also specify the alignment of the text with the positions
    being measured optionally from the top, bottom, center, left, or right of the
    text:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`emboss-text`函数在图表的中心绘制一个大标题。注意，我们还指定了文本的对齐方式，可以选择从文本的顶部、底部、中心、左侧或右侧来测量位置：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The earlier example generates the following graphic:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子生成了以下图形：
- en: '![Adding a title and axis labels](img/7180OS_10_220.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![添加标题和轴标签](img/7180OS_10_220.jpg)'
- en: This chart, which is a mix of bar heights and areas, and custom text visualization
    would be very difficult to achieve in a standard charting application. Using Quil,
    we have a toolbox that allows us to freely mix graphics and data with ease.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表结合了条形图高度、面积和自定义文本可视化，使用标准图表应用程序很难实现。使用Quil，我们有一个工具箱，可以轻松地将图形和数据自由混合。
- en: Improving the clarity with illustrations
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过插图提高清晰度
- en: We're getting somewhere with our chart, but it's very spare at the moment. One
    way to add more visual interest would be with images. In the resources directory
    of the example project, are two SVG image files. One is a person icon and the
    other is a map of the United States sourced from Wikipedia.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图表已经有了一些进展，但目前看起来非常简洁。为了增加更多的视觉吸引力，可以使用图像。在示例项目的资源目录中，有两个SVG图像文件，一个是人形图标，另一个是来自维基百科的美国地图。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Wikipedia contains a wide variety of SVG maps issued under a flexible creative
    commons license. For example, maps of the United States at [https://commons.wikimedia.org/wiki/Category:SVG_maps_of_the_United_States](https://commons.wikimedia.org/wiki/Category:SVG_maps_of_the_United_States).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科提供了各种各样的SVG地图，这些地图都可以在灵活的创作共享许可证下使用。例如，[https://commons.wikimedia.org/wiki/Category:SVG_maps_of_the_United_States](https://commons.wikimedia.org/wiki/Category:SVG_maps_of_the_United_States)
    上的美国地图。
- en: The map we're using in this chapter is available at [https://commons.wikimedia.org/wiki/File:Blank_US_Map,_Mainland_with_no_States.svg](https://commons.wikimedia.org/wiki/File:Blank_US_Map,_Mainland_with_no_States.svg)
    and was made available by Lokal_Profil under a CC-BY-SA-2.5 license.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章使用的地图可以在[https://commons.wikimedia.org/wiki/File:Blank_US_Map,_Mainland_with_no_States.svg](https://commons.wikimedia.org/wiki/File:Blank_US_Map,_Mainland_with_no_States.svg)找到，由Lokal_Profil在CC-BY-SA-2.5许可证下提供。
- en: 'Using SVG images in Quil is a two-step process. First, we have to load the
    image into the memory using `q/load-shape`. This function accepts a single argument:
    the path to the SVG file that is to be loaded. Next, we have to actually draw
    the image on the screen. This is accomplished using the `q/shape` function, which
    expects a *x*, *y* position for the image and also an optional width and height.
    If we were using pixel-based images such as JPEGs or PNGs, we would instead use
    the corresponding `q/load-image` and `q/image` functions:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Quil中使用SVG图像是一个两步过程。首先，我们需要使用`q/load-shape`将图像加载到内存中。此函数接受一个参数：要加载的SVG文件的路径。接下来，我们需要将图像实际绘制到屏幕上。这是通过使用`q/shape`函数来完成的，该函数需要一个*
    x *，* y *位置以及可选的宽度和高度。如果我们使用的是基于像素的图像（如JPEG或PNG），我们将使用相应的`q/load-image`和`q/image`函数：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this code, we called `.disableStyle` on both the `usa` and the `person` shapes.
    This is because SVG files may contain embedded style such as fill color, stroke
    color, or border width information that will affect the way Quil draws the shape.
    We'd like complete control over our representation, so we choose to disable all
    the styles.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们对`usa`和`person`形状都调用了`.disableStyle`。这是因为SVG文件可能包含嵌入的样式信息，比如填充颜色、描边颜色或边框宽度，这些都会影响Quil绘制形状的方式。为了完全控制我们的表现形式，我们选择禁用所有样式。
- en: 'Also, note that we''re loading the person shape once and drawing it many times
    with `dotimes`. We are setting the color based on `quintile` in which the user
    falls:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们只加载一次person形状，并通过`dotimes`绘制多次。我们根据用户所处的`quintile`设置颜色：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result is shown in the next image:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下一张图所示：
- en: '![Improving the clarity with illustrations](img/7180OS_10_230.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![通过插图提高清晰度](img/7180OS_10_230.jpg)'
- en: The graphic is beginning to look like one we could show people without blushing.
    The people icons help communicate the idea that each bar represents a percentile
    of the population. The bars are not very attractive yet. Since each bar represents
    the wealth of each person, let's represent each bar as a pile of bank notes. While
    this might appear to be an overly literal interpretation, it would actually make
    it clearer that the 1 percent bar is actually 5 times as wide as everyone else's.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图已经开始看起来像我们可以展示给人们而不感到羞愧的那种。人物图标帮助传达了每个条形代表一个人口百分位的概念。条形图现在看起来还不太吸引人。由于每个条形代表每个人的财富，所以我们把每个条形画成一叠钞票。虽然这可能看起来是一个过于字面化的解释，但实际上会更清晰地传达出1%的条形实际上是其他所有条形的5倍宽。
- en: Adding text to the bars
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向条形图中添加文字
- en: 'By now, it should be no surprise that we can draw the banknotes as a series
    of rectangles:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们已经可以将钞票画成一系列矩形了：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The only slight complexity in the previous code is the need to adjust the starting
    *y* position as an even multiple of `3`. This will ensure that all the banknotes
    meet the *x* axis after an even number of multiples, irrespective of the height
    of the bar on the *y* axis. This is a side-effect of drawing the bars from top
    to bottom, rather than vice versa.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的唯一复杂之处在于需要将起始的*y*位置调整为`3`的偶数倍。这将确保所有的钞票在*y*轴上的高度如何，最终都能与*x*轴对齐。这是从上到下绘制条形的副作用，而不是反向绘制。
- en: 'We''ll add the earlier function to our sketch in the following example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下示例中将之前的函数添加到我们的草图中：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will generates the following chart:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下图表：
- en: '![Adding text to the bars](img/7180OS_10_240.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![向条形图添加文字](img/7180OS_10_240.jpg)'
- en: 'This is now a reasonably complete chart representing the actual distribution
    of wealth in the United States. One of the strengths of the original YouTube video
    link provided earlier is that it contrasts the actual distribution with several
    other distributions: the distribution of wealth people expected and the distribution
    of wealth they would prefer.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这已经是一个相对完整的图表，代表了美国实际的财富分布。之前提供的YouTube视频链接的一个优点是，它将实际分布与几种其他分布进行了对比：人们预期的财富分布和他们理想的财富分布。
- en: Incorporating additional data
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 融入额外数据
- en: Michael Norton, a Harvard Business Professor, and Dan Ariely, a behavioral economist
    performed a study on more than 5,000 Americans to assess their perception of wealth
    distribution. When they were shown a variety of examples on wealth distribution
    and asked to identify which one was sourced from the United States, most chose
    a distribution much more balanced than it actually was. When asked to choose their
    ideal distribution of wealth, 92 percent picked one that was even more equitable.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 哈佛商学院教授迈克尔·诺顿和行为经济学家丹·阿里利对5000多名美国人进行了研究，评估他们对财富分配的看法。当他们展示了各种财富分配的例子，并让他们判断哪个例子来自美国时，大多数人选择了一个比实际情况更加平衡的分布。当被问及理想的财富分配时，92%的人选择了一个更加公平的分配方式。
- en: 'The following graphic shows the results of this study:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图形展示了本研究的结果：
- en: '![Incorporating additional data](img/7180OS_10_250.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![添加额外数据](img/7180OS_10_250.jpg)'
- en: The preceding graphic was published by Mother Jones on [http://www.motherjones.com/politics/2011/02/income-inequality-in-america-chart-graph](http://www.motherjones.com/politics/2011/02/income-inequality-in-america-chart-graph)
    based on the data sourced form [http://www.people.hbs.edu/mnorton/norton%20ariely%20in%20press.pdf](http://www.people.hbs.edu/mnorton/norton%20ariely%20in%20press.pdf).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图形由Mother Jones发布，来源为[http://www.motherjones.com/politics/2011/02/income-inequality-in-america-chart-graph](http://www.motherjones.com/politics/2011/02/income-inequality-in-america-chart-graph)，数据来源于[http://www.people.hbs.edu/mnorton/norton%20ariely%20in%20press.pdf](http://www.people.hbs.edu/mnorton/norton%20ariely%20in%20press.pdf)。
- en: The previous chart does a good job of showing the relative differences between
    people's perceptions and reality for each of the 5 quintiles. We'll be converting
    this data into an alternative representation so, like before, we can convert the
    data into a table representation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图表很好地展示了人们对每个五分位的财富分布的感知与现实之间的相对差异。我们将把这些数据转化为一种替代表示方式，就像之前一样，我们可以将这些数据转化为表格表示。
- en: 'Reading off the earlier chart and with reference to the linked paper, I''ve
    arrived at the following approximate breakdown by quintile:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的图表和参考链接的论文中，我得到了以下按五分位划分的大致数据：
- en: '| Quintile | Ideal % | Expected % | Actual % |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 五分位 | 理想百分比 | 预期百分比 | 实际百分比 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 100th | 32.0% | 58.5% | 84.5% |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 100th | 32.0% | 58.5% | 84.5% |'
- en: '| 80th | 22.0% | 20.0% | 11.5% |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 80th | 22.0% | 20.0% | 11.5% |'
- en: '| 60th | 21.5% | 12.0% | 3.7% |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 60th | 21.5% | 12.0% | 3.7% |'
- en: '| 40th | 14.0% | 6.5% | 0.2% |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 40th | 14.0% | 6.5% | 0.2% |'
- en: '| 20th | 10.5% | 3.0% | 0.1% |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 20th | 10.5% | 3.0% | 0.1% |'
- en: Let's take the *ideal* and *expected* distributions and find a way to plot them
    on our existing wealth distribution chart. Our bar chart already represents the
    relative wealth of different percentiles as an area. In order to make the two
    datasets comparable, we should also do the same with this data. The previous table
    assisted us by already representing the data as five equally sized groups, so
    we don't need to apply a transformation like we did with the data sourced from
    the pie chart.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们取*理想*和*预期*的分布，并找到一种方法将它们绘制在我们现有的财富分布图上。我们的柱状图已经表示了不同百分位的相对财富，作为面积的大小。为了使两个数据集可比，我们也应该对这些数据做相同的处理。之前的表格通过已经将数据表示为五个大小相等的组，帮助我们简化了处理，因此我们无需像处理饼图数据时那样应用转换。
- en: 'However, let''s use this as an opportunity to learn more about drawing complex
    shapes in Quil and see whether we can arrive at a presentation of the data more
    like the following diagram:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们利用这个机会，进一步了解在Quil中绘制复杂形状，看看能否得到如下所示的数据展示：
- en: '![Incorporating additional data](img/7180OS_10_260.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![加入额外数据](img/7180OS_10_260.jpg)'
- en: The table provides the relative areas that we want to represent by the shapes
    labeled **A**, **B**, and **C**. In order to draw the earlier shapes, we'll have
    to calculate the heights *x*, *y*, and *z*. These will give us the coordinates
    that we can plot on our chart.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 该表格提供了我们要通过标签为**A**、**B**和**C**的形状表示的相对面积。为了绘制先前的形状，我们必须计算出高度*x*、*y*和*z*。这些将为我们提供可在图表上绘制的坐标。
- en: 'The width of the areas **A**, **B**, and **C** is **w**. Therefore, the product
    of **x** and **w** will equal the area of **A**:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 区域**A**、**B**和**C**的宽度是**w**。因此，**x**和**w**的乘积将等于**A**的面积：
- en: '![Incorporating additional data](img/7180OS_10_01.jpg)![Incorporating additional
    data](img/7180OS_10_02.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![加入额外数据](img/7180OS_10_01.jpg)![加入额外数据](img/7180OS_10_02.jpg)'
- en: 'It follows that the height of *x* is simply the area of *A* divided by *w*.
    *Y* is a little more complicated, but not much. The area of the triangular component
    of *B* is equal to:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由此可得，*x*的高度仅为*A*的面积除以*w*。*Y*则稍微复杂一点，但也不算太复杂。*B*的三角形部分的面积等于：
- en: '![Incorporating additional data](img/7180OS_10_03.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![加入额外数据](img/7180OS_10_03.jpg)'
- en: 'therefore:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此：
- en: '![Incorporating additional data](img/7180OS_10_04.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![加入额外数据](img/7180OS_10_04.jpg)'
- en: 'We can calculate *z* in the same way:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过相同的方式计算*z*：
- en: '![Incorporating additional data](img/7180OS_10_05.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![加入额外数据](img/7180OS_10_05.jpg)'
- en: 'Expanding our definitions gives the following equation for *z*:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展我们的定义，得到以下*z*的方程：
- en: '![Incorporating additional data](img/7180OS_10_06.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![加入额外数据](img/7180OS_10_06.jpg)'
- en: 'If we assume that *w* is 1 (all our quintiles are of a constant width), then
    we arrive at the following equations and so on for any number of sections:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设*w*为1（所有我们的五分位宽度相等），那么我们可以得到以下方程，适用于任意数量的区间：
- en: '![Incorporating additional data](img/7180OS_10_07.jpg)![Incorporating additional
    data](img/7180OS_10_08.jpg)![Incorporating additional data](img/7180OS_10_09.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![加入额外数据](img/7180OS_10_07.jpg)![加入额外数据](img/7180OS_10_08.jpg)![加入额外数据](img/7180OS_10_09.jpg)'
- en: 'This can be expressed as a simple recursive function. The first of our proportions
    will be assigned the value *x*. Subsequent values can be calculated from it as
    follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过一个简单的递归函数来表示。我们的第一个比例将被赋值为*x*。随后可以通过以下方式计算其他值：
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `reductions` function behaves exactly like `reduce`, but preserves the intermediate
    steps of our calculation. Rather than a single value, we'll get back a sequence
    of values that correspond to the (proportional) heights of our *y*-coordinates.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`reductions`函数的行为与`reduce`完全相同，但会保留我们计算的中间步骤。我们不会只得到一个值，而是会得到一个值序列，对应于我们*y*-坐标的（比例）高度。'
- en: Drawing complex shapes
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制复杂形状
- en: The `area-points` function defined in the previous section will provide a series
    of points for us to plot. However, we haven't yet covered the functions in Quil
    that will allow us to plot them. To draw lines, we could use the `q/line` function.
    The line function will accept a start and an end coordinate and draw a straight
    line between them. We would be able to construct an area graph this way, but it
    would have no fill. Lines simply describe outlines; we are not able to use them
    to construct colored shapes like we did with `q/rect` while making a histogram.
    To give our shapes a fill color, we need to build them up one vertex at a time.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 前面定义的`area-points`函数将为我们提供一系列点以便绘制。然而，我们还没有涉及 Quil 中的函数，这些函数将允许我们绘制它们。要绘制直线，我们可以使用`q/line`函数。线函数将接受起点和终点坐标，并在它们之间绘制一条直线。我们可以通过这种方式构建一个面积图，但它没有填充。线条仅描述轮廓，我们不能像使用`q/rect`绘制直方图时那样构建带有填充色的形状。为了给形状填充颜色，我们需要一个一个顶点地构建它们。
- en: To build arbitrarily complex shapes with Quil, we first call `q/begin-shape`.
    This is a stateful function that lets Quil know that we want to start building
    up a series of vertices. Subsequent calls to `q/vertex` will be associated with
    the shape that we're constructing. Finally, a call to `q/end-shape` will complete
    the shape. We'll draw it with the stroke and fill the styles specified in the
    current drawing context.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要用 Quil 构建任意复杂的形状，首先调用`q/begin-shape`。这是一个有状态的函数，它让 Quil 知道我们想开始构建一系列顶点。随后调用的`q/vertex`将与我们正在构建的形状关联。最后，调用`q/end-shape`将完成形状的构建。我们将根据当前绘图上下文中指定的描边和填充样式来绘制它。
- en: 'Let''s see how it works by drawing some test shapes using the `area-points`
    function defined in the previous section:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过绘制一些使用上一节定义的`area-points`函数的测试形状，看看它是如何工作的：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This example plots the `[3 6.5 12 20 58.5]` series using the area-points function
    defined previously. This is the series of percentage values listed in the data
    table for the `expected` distribution of wealth in the United States. The `plot-area`
    function calls `begin-shape`, iterates over the sequence of *ys* returned by `area-points`,
    and calls `end-shape`. The result is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用之前定义的`area-points`函数绘制了`[3 6.5 12 20 58.5]`序列。这是美国“预期”财富分布数据表中列出的百分比值序列。`plot-area`函数会调用`begin-shape`，遍历由`area-points`返回的`*ys*`序列，并调用`end-shape`。结果如下：
- en: '![Drawing complex shapes](img/7180OS_10_270.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![绘制复杂形状](img/7180OS_10_270.jpg)'
- en: 'This isn''t quite what we want. Although we''re asking to fill the shape, we''re
    not describing the full shape to be filled. Quil doesn''t know how we want to
    close off the shape, so it''s simply drawing an edge from the last point back
    to the first, cutting across the diagonal of our chart. Fortunately, the problem
    can be easily resolved by ensuring there are points at both the bottom corners
    of the diagram:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是我们想要的效果。虽然我们要求填充形状，但我们并没有描述完整的待填充形状。Quil 不知道我们想如何封闭形状，因此它只是从最后一个点画到第一个点，横跨了我们图表的对角线。幸运的是，这个问题可以通过确保图表的底部两个角都有点来轻松解决：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `plot-full-area` function adds an extra call to `vertex` before and after
    iterating over the sequence of *ys*. The points specified ensure that the shape
    is fully described before the call to `end-shape`. The result is shown in the
    following image:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot-full-area`函数在遍历`*ys*`序列之前和之后都会多次调用`vertex`。这些指定的点确保在调用`end-shape`之前，形状已完全描述。结果如下图所示：'
- en: '![Drawing complex shapes](img/7180OS_10_280.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![绘制复杂形状](img/7180OS_10_280.jpg)'
- en: This is better, and it's starting to look like an area plot. In the next section,
    we'll cover how to describe more complex shapes using curves. Although curves
    aren't required for our area plot, it will help make the results a little more
    attractive.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经好多了，开始看起来像一个面积图了。在下一节中，我们将讨论如何使用曲线来描述更复杂的形状。虽然曲线不是我们面积图的必需元素，但它会让结果看起来更有吸引力。
- en: Drawing curves
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制曲线
- en: The area plot is starting to look good, but we could remove those sharp corners
    by making use of Quil's spline curves. Rather than building up the shape by adding
    vertices, we could call `q/curve-vertex` to smoothen out the joins between the
    edges.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 面积图看起来不错，但我们可以通过使用 Quil 的样条曲线来去除那些尖锐的角。与其通过添加顶点来构建形状，我们可以调用`q/curve-vertex`来平滑边缘之间的连接。
- en: 'The `q/curve-vertex` function implements a method of curve drawing known as
    Catmull-Rom splines. To draw a curve, we must specify at least four vertices:
    the first and last will be treated as the control points and the curve will be
    drawn between the middle two.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`q/curve-vertex`函数实现了一种已知的曲线绘制方法，叫做Catmull-Rom样条曲线。要绘制一条曲线，我们必须至少指定四个顶点：第一个和最后一个顶点将作为控制点，曲线将在中间的两个顶点之间绘制。'
- en: 'We visualize how Catmull-Rom splines work in the following diagram, which shows
    the path specified by points *a*, *b*, *c*, and *d*:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过下面的图示来可视化Catmull-Rom样条曲线的工作原理，该图显示了由点*a*、*b*、*c*和*d*指定的路径：
- en: '![Drawing curves](img/7180OS_10_290.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![绘制曲线](img/7180OS_10_290.jpg)'
- en: 'The tangent to the curve at point **c** is parallel to **X**: the line described
    between points **a** and **b**; the tangent to the curve at **b** is parallel
    to **Y**: the line described by points **c** and **d**. Thus, to draw a curve,
    we''ll need ensure we add these additional control points at the beginning and
    the end of our line. Each control point is added with `curve-vertex`, which we
    call once before we iterate over our points and then again at the end:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在**c**点处的曲线切线与**X**平行：由**a**和**b**两点所描述的直线；在**b**点处的曲线切线与**Y**平行：由**c**和**d**两点所描述的直线。因此，要绘制一条曲线，我们需要确保在曲线的起点和终点添加这些额外的控制点。每个控制点都通过`curve-vertex`添加，我们会在迭代点之前先调用一次，然后在结束时再调用一次：
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we''ve defined a `smooth-curve` function, we''ll use it in the following
    two functions, `smooth-stroke` and `smooth-area`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个`smooth-curve`函数，我们将在接下来的两个函数中使用它，分别是`smooth-stroke`和`smooth-area`：
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `smooth-stroke` function will draw the shape defined by the *xs* and *ys*
    by creating vertices for each of them. The `smooth-area` function extends this
    by closing off the shape and avoiding the situation we saw previously with a fill
    that crosses the shape diagonally. Bringing the two functions together is `plot-curve`,
    a function that accepts the *xs* and *ys* to be plotted, plus a fill color, stroke
    color, and stroke weight to use:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`smooth-stroke`函数将通过为每个*xs*和*ys*创建顶点来绘制定义的形状。`smooth-area`函数通过闭合形状并避免之前看到的填充与形状对角线交叉的情况，扩展了这一点。将这两个函数结合起来的是`plot-curve`，该函数接受要绘制的*xs*和*ys*，以及用于绘制的填充颜色、边框颜色和边框粗细：'
- en: '[PRE34]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s call the `plot-curve` function on the same sequence of expected values
    we plotted earlier, and compare the difference:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在之前绘制的相同预期值序列上调用`plot-curve`函数，并比较差异：
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This example generates the following image:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例生成了如下图像：
- en: '![Drawing curves](img/7180OS_10_300.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![绘制曲线](img/7180OS_10_300.jpg)'
- en: The effect of the curve is subtle, but it provides a polish to our chart that
    would otherwise be lacking. The previous chart shows the *expected* distribution
    of wealth from the study by Norton and Ariely. Before we combine this with the
    *actual* wealth distribution plot we created earlier, let's see how it could be
    combined with the *ideal* distribution of wealth from the same study.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线的效果微妙，但它为我们的图表提供了润色，否则图表会显得不完整。前面的图表展示了Norton和Ariely研究中*预期*的财富分布。在将其与之前创建的*实际*财富分布图结合之前，让我们看看它如何与同一研究中的*理想*财富分布结合。
- en: Plotting compound charts
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制复合图表
- en: 'The earlier description shows how to create a single curved graph scaled to
    fit an area. As we''ve defined it, the `plot-smooth-area` function will fill the
    height we specify for every area we draw. This makes sense from a drawing perspective,
    but it doesn''t make sense while trying to draw two comparable charts: we need
    to make sure they use the same scale.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的描述展示了如何创建一个适应区域的单一曲线图。正如我们定义的那样，`plot-smooth-area`函数将在我们绘制的每个区域中填充指定的高度。从绘图的角度看，这样做是合理的，但在尝试绘制两个可比较图表时，这就不太合适了：我们需要确保它们使用相同的缩放比例。
- en: 'In the next block of code, we''ll calculate a scale based on the larger of
    the two graphs and then plot both using this scale. This ensures that all of the
    series we plot will be comparable with each other. The combined chart will fill
    the width and height we allot to it:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码块中，我们将根据两个图形中较大的一个来计算缩放比例，然后使用该比例绘制两个图形。这样可以确保我们绘制的所有系列彼此之间可以进行比较。组合图表将填满我们分配给它的宽度和高度：
- en: '[PRE36]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We plot both the `expected` and `ideal` series using the `plot-areas` function,
    having set a darker background to our sketch with the `background` function. In
    our call to `plot-curve`, we specify semitransparent white as the fill to be used.
    The following image shows the result:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `plot-areas` 函数绘制了 `expected` 和 `ideal` 两个系列，且通过 `background` 函数将背景设为更深的颜色。在调用
    `plot-curve` 时，我们指定使用半透明的白色作为填充颜色。下图展示了结果：
- en: '![Plotting compound charts](img/7180OS_10_310.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![绘制复合图表](img/7180OS_10_310.jpg)'
- en: 'To combine this chart with the chart showing the actuals created previously,
    we simply need to adjust its scale to match. The highest point on this chart at
    the top right corresponds to a probability density of 5 percent. The 96-99^(th)
    percentiles on our actual plot represents 7.5 percent of the total, each on their
    plot. This means that we need to draw the previous chart at 2/3 of the height
    of the plot we already have for the axes to be comparable. Let''s do this now,
    and add a series of labels to the two new series while we''re at it:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个图表与之前创建的实际数据图表结合，我们只需要调整它的尺度以便匹配。此图表右上角的最高点对应于 5% 的概率密度。我们实际图表上的 96-99^(th)
    百分位代表总量的 7.5%，各自对应其图表。这意味着我们需要将之前的图表绘制为现有图表的 2/3 高度，才能使坐标轴可比。现在我们来做这个，并在此过程中为两个新系列添加标签：
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we call the `draw-expected-ideal` function from our sketch along with
    the other functions defined previously:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用草图中的 `draw-expected-ideal` 函数以及之前定义的其他函数：
- en: '[PRE38]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The finished result is shown in the next graphic:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的结果在下图中展示：
- en: '![Plotting compound charts](img/7180OS_10_320.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![绘制复合图表](img/7180OS_10_320.jpg)'
- en: Hopefully, you'll agree that the finished chart is attractive as well as informative.
    Most importantly, we've generated the chart by drawing instructions from actual
    data. The finished result has an integrity to it that would be harder to establish
    if the chart were produced by hand.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你会同意，最终的图表既美观又富有信息性。最重要的是，我们是通过实际数据的绘图指令来生成这张图表。如果这张图表是手工制作的，其完整性将难以建立。
- en: Output to PDF
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出为 PDF
- en: All the elements combined together yield a graphic of the kind that might end
    up in print. The drawing instructions we provided are vector-based—rather than
    pixel-based—so it will scale to any resolution required without loss of quality.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 所有元素组合在一起，最终形成了可能被打印出来的图形。我们提供的绘图指令是基于矢量的——而非基于像素的——因此它将按需要的任何分辨率进行缩放而不失真。
- en: Rather than output to a pixel-based format using `save` as we did with the histogram,
    let's output to a PDF. The PDF format will preserve the scalability of our artwork
    and allow us to output at any resolution desired. To do this, we configure the
    sketch to use the PDF renderer by passing the `:pdf` keyword and also an `:output-file`
    path.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们用 `save` 方法将直方图输出为基于像素的格式不同，我们将输出为 PDF 格式。PDF 格式能够保持我们的艺术作品的可扩展性，并且允许我们在任何所需的分辨率下输出。为此，我们通过传递
    `:pdf` 关键字以及 `:output-file` 路径来配置草图以使用 PDF 渲染器。
- en: '[PRE39]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The final example will output our finished PDF file to the root of the project
    directory.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的示例将把完成的 PDF 文件输出到项目目录的根目录。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've seen how very simple visualizations—using nothing but
    colored rectangles—can bring useful insight from data, and how a combination of
    Clojure core functions and Quil's drawing API can enable us to generate powerful
    graphics that communicate a message.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到通过使用简单的可视化—仅使用彩色矩形—如何从数据中获得有价值的洞察，并且如何结合 Clojure 核心函数与 Quil 的绘图 API，使我们能够生成传递信息的强大图形。
- en: 'We achieved all of this using the Quil library. There''s much more to Quil
    than what we''ve shown here: it enables interactive animation, it supports ClojureScript
    output for the web, and it can produce 3D rendering as well. Visualization is
    a huge topic too, and we couldn''t hope to provide more than a few examples to
    pique your interest in this chapter. By showing how even basic drawing instructions
    using rectangles, curves, and SVGs can combine into powerful graphics, we hope
    to have inspired you with the possibilities to create your own custom visualizations.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 Quil 库实现了这一切。Quil 的功能远不止我们在此展示的内容：它支持交互式动画，支持 ClojureScript 输出到网页，并且还可以进行
    3D 渲染。可视化是一个庞大的主题，我们在本章中只能通过一些示例来激发你对它的兴趣。通过展示即使是使用矩形、曲线和 SVG 的基础绘图指令如何组合成强大的图形，我们希望能激发你创造自定义可视化的可能性。
- en: This was the final chapter of *Clojure for Data Science*. Be sure to visit the
    book's website at [http://clojuredatascience.com](http://clojuredatascience.com)
    for more information on the topics covered and links to further reading. We intend
    to provide an ongoing resource for data scientists in general and Clojure programmers
    in particular.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是《*Clojure 数据科学*》的最后一章。请务必访问本书的网站 [http://clojuredatascience.com](http://clojuredatascience.com)，获取更多关于所涵盖主题的信息和进一步阅读的链接。我们打算为数据科学家，尤其是
    Clojure 程序员，提供一个持续更新的资源。
- en: It was an ambitious task to convey the breadth and depth of a field as diverse
    and quickly evolving as data science using a language whose libraries are quickly
    evolving as well. Nonetheless, we hope *Clojure for Data Science* has given you
    an appreciation for some of the fundamental concepts of statistics, machine learning,
    and big data processing. This conceptual basis should serve you well, even as
    the technical options—and perhaps even your choice of programming language—continue
    evolving into the future.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一种库也在迅速发展的编程语言，来传达数据科学这个多样且迅速发展的领域的广度和深度，确实是一个雄心勃勃的任务。尽管如此，我们希望《*Clojure 数据科学*》能让你对统计学、机器学习和大数据处理的一些基本概念有所了解。这些概念基础应该能为你提供帮助，即使技术选项——甚至可能是你的编程语言选择——未来还会继续演变。
