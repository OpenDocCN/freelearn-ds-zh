- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Visualization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化
- en: Visualization is a critical component in exploratory data analysis, as well
    as presentations and applications. During exploratory data analysis, you are usually
    working alone or in small groups and need to create plots quickly to help you
    better understand your data. Visualizations can help you identify outliers and
    missing data, or they can spark other questions of interest that will lead to
    further analysis and more visualizations. This type of visualization is usually
    not done with the end user in mind. It is strictly to help you better your current
    understanding. The plots do not have to be perfect.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化是探索性数据分析、演示和应用中的关键组成部分。在进行探索性数据分析时，你通常是单独工作或在小组中，需要快速创建图表来帮助你更好地理解数据。可视化可以帮助你识别异常值和缺失数据，或者激发其他有趣的问题，进而进行进一步分析和更多可视化。这种类型的可视化通常不是为了最终用户而设计的，它仅仅是为了帮助你更好地理解当前的数据。图表不必是完美的。
- en: When preparing visualizations for a report or application, a different approach
    must be used. You should pay attention to small details. Also, you usually will
    have to narrow down all possible visualizations to only the select few that best
    represent your data. Good data visualizations have the viewer enjoying the experience
    of extracting information. Almost like movies that viewers can get lost in, good
    visualizations will have lots of information that really sparks interest.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在为报告或应用程序准备可视化时，必须采用不同的方法。你应该关注细节。而且，通常你需要将所有可能的可视化方式缩小到少数几个最能代表数据的方式。好的数据可视化能够让观众享受提取信息的过程。就像让观众沉浸其中的电影一样，好的可视化会包含大量能够激发兴趣的信息。
- en: Out of the box, pandas has the `pd.Series.plot` and `pd.DataFrame.plot` methods
    to help you quickly generate plots. These methods dispatch to a *plotting backend*,
    which by default is Matplotlib ([https://matplotlib.org/](https://matplotlib.org/)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，pandas 提供了 `pd.Series.plot` 和 `pd.DataFrame.plot` 方法，帮助你快速生成图表。这些方法会调度到一个*绘图后端*，默认是
    Matplotlib ([https://matplotlib.org/](https://matplotlib.org/))。
- en: 'We will discuss different backends later in this chapter, but for now, let’s
    start by installing Matplotlib and PyQt5, which Matplotlib uses to draw plots:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章稍后讨论不同的后端，但现在，让我们先安装 Matplotlib 和 PyQt5，Matplotlib 用它们来绘制图表：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All code samples in this chapter are assumed to be preceded by the following
    import:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例假设前面已经导入以下内容：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous command enables Matplotlib’s *interactive mode*, which will create
    and update your plots automatically every time a plotting command is executed.
    If, for whatever reason, you run a plotting command but no plot appears, you likely
    are in non-interactive mode (you can check this with `matplotlib.pyplot.isinteractive()`),
    and you will need to explicitly call `matplotlib.pyplot.show()` to make your plots
    appear.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令启用了 Matplotlib 的*交互模式*，每次执行绘图命令时，它会自动创建和更新图表。如果出于某种原因你运行了绘图命令但图表没有出现，你可能处于非交互模式（你可以通过
    `matplotlib.pyplot.isinteractive()` 来检查），此时你需要显式调用 `matplotlib.pyplot.show()`
    来显示图表。
- en: 'We are going to cover the following recipes in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下几个案例：
- en: Creating charts from aggregated data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从聚合数据中创建图表
- en: Plotting distributions of non-aggregated data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制非聚合数据的分布
- en: Further plot customization with Matplotlib
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 进行进一步的图表定制
- en: Exploring scatter plots
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索散点图
- en: Exploring categorical data
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索分类数据
- en: Exploring continuous data
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索连续数据
- en: Using seaborn for advanced plots
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 seaborn 绘制高级图表
- en: Creating charts from aggregated data
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从聚合数据中创建图表
- en: The pandas library makes it easy to visualize data in `pd.Series` and `pd.DataFrame`
    objects, using the `pd.Series.plot` and `pd.DataFrame.plot` methods, respectively.
    In this recipe we are going to start with relatively basic line, bar, area, and
    pie charts, while also seeing the high-level customization options pandas offers.
    While, these chart types are simple, using them effectively can be immensely helpful
    to explore your data, identify trends, and share your research with non-technical
    associates.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 库使得可视化 `pd.Series` 和 `pd.DataFrame` 对象中的数据变得容易，分别使用 `pd.Series.plot`
    和 `pd.DataFrame.plot` 方法。在本案例中，我们将从相对基础的折线图、条形图、面积图和饼图开始，同时了解 pandas 提供的高级定制选项。虽然这些图表类型较为简单，但有效地使用它们对于探索数据、识别趋势以及与非技术人员分享你的研究结果都非常有帮助。
- en: It is important to note that these chart types expect your data to already be
    aggregated, which our sample data in this recipe will reflect. If you are working
    with data that is not yet aggregated, you will need to use techniques that you
    will encounter in *Chapter 7*, *Reshaping DataFrames*, and *Chapter 8*, *Group
    By*, or use the techniques shown in the *Using Seaborn for advanced plots* recipe
    later in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这些图表类型期望你的数据已经被聚合，我们在本教程中的示例数据也反映了这一点。如果你正在处理的数据尚未聚合，你将需要使用在*第7章*《重塑数据框》与*第8章*《分组》所涉及的技术，或者使用本章后续“使用Seaborn进行高级绘图”教程中展示的技术。
- en: How to do it
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let’s create a simple `pd.Series` showing book sales over the course of a 7-day
    period. We are intentionally going to use row index labels of the form *Day n*,
    which will provide a good visual clue on the different chart types we create:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的`pd.Series`，显示7天内的书籍销售数据。我们故意使用类似*Day n*的行索引标签，这将为我们创建的不同图表类型提供良好的视觉提示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A call to `pd.Series.plot` without any arguments will produce a line chart,
    where the labels used on the *x*-axis come from the row index and the values on
    the *Y*-axis correspond to the data within the `pd.Series`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用`pd.Series.plot`而不传递任何参数，将会生成一张折线图，*x*轴上的标签来自行索引，而*Y*轴上的数值对应`pd.Series`中的数据：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](img/B31091_06_01.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_01.png)'
- en: 'A line chart treats our data as if it is completely continuous, yielding a
    visualization that appears to show values in between each day, even though that
    does not exist in our data. A better visualization for our `pd.Series` would be
    a bar chart that displays each day discretely, which we can get just by passing
    the `kind="bar"` argument to the `pd.Series.plot` method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 折线图将我们的数据视为完全连续的，产生的可视化效果似乎展示了每一天之间的数值，尽管我们的数据中并没有这些值。对于我们的`pd.Series`，更好的可视化是条形图，它将每一天离散地展示，我们只需将`kind="bar"`参数传递给`pd.Series.plot`方法即可获得：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/B31091_06_02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_02.png)'
- en: 'Once again, the row index labels appear on the *X*-axis and the values appear
    on the *Y*-axis. This helps you read the visualization from left to right, but
    in some circumstances, you may find it easier to read values from top to bottom.
    In pandas, such a visualization would be considered a *horizontal bar chart*,
    which can be rendered by using the `kind="barh"` argument:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，行索引标签出现在*X*轴上，数值出现在*Y*轴上。这有助于你从左到右阅读可视化，但在某些情况下，你可能会发现从上到下阅读数值更容易。在pandas中，这种可视化被认为是*横向条形图*，可以通过使用`kind="barh"`参数来渲染：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![A graph with blue bars](img/B31091_06_03.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![一张带有蓝色条形的图表](img/B31091_06_03.png)'
- en: 'A `kind="area"` argument will produce an area chart, which is like a line chart
    but fills in the area underneath the line:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind="area"`参数会生成一个区域图，它像折线图一样，但填充了线下的区域：'
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![A blue line graph with numbers](img/B31091_06_04.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![一张带数字的蓝色折线图](img/B31091_06_04.png)'
- en: 'Last but not least, we have pie charts. Unlike all of the visualizations introduced
    so far, a pie chart does not have both an x- and a y-axis. Instead, each label
    from the row index represents a different slice of the pie, whose size is dictated
    by the associated value in our `pd.Series`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们有饼图。与之前介绍的所有可视化不同，饼图没有x轴和y轴。相反，每个来自行索引的标签代表饼图中的一个不同切片，其大小由我们`pd.Series`中相关的数值决定：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![A pie chart with numbers and a number of days](img/B31091_06_05.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![带有数字和天数的饼图](img/B31091_06_05.png)'
- en: When working with a `pd.DataFrame`, the API through which you generate charts
    stays consistent, although you may find that you need to provide more keyword
    arguments to get the desired visualization.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`pd.DataFrame`时，生成图表的API保持一致，尽管你可能需要提供更多的关键字参数来获得期望的可视化效果。
- en: 'To see this in action, let’s extend our data to show both `book_sales` and
    `book_returns`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这一点，让我们扩展数据，展示`book_sales`和`book_returns`：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Just like we saw with `pd.Series.plot`, the default call to `pd.DataFrame.plot`
    will give us a line plot, with each column represented by its own line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在`pd.Series.plot`中看到的那样，默认调用`pd.DataFrame.plot`会给我们一张折线图，每一列由自己的线表示：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/B31091_06_06.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_06.png)'
- en: 'Once again, to turn this into a bar chart, you would just need to pass `kind="bar"`
    to the plotting method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，要将其转为条形图，你只需向绘图方法传递`kind="bar"`参数：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/B31091_06_07.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_07.png)'
- en: 'By default, pandas will present each column as a separate bar on the chart.
    If you wanted instead to stack the columns on top of one another, pass `stacked=True`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，pandas会将每一列作为单独的条形图呈现。如果您想将这些列堆叠在一起，请传递`stacked=True`：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](img/B31091_06_08.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_08.png)'
- en: 'The same behavior can be seen with a horizontal bar chart. By default, the
    columns will not be stacked:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用水平条形图时也可以看到相同的行为。默认情况下，列不会堆叠：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](img/B31091_06_09.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_09.png)'
- en: 'But passing `stacked=True` will place the bars on top of one another:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但是传递`stacked=True`会将条形图堆叠在一起：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](img/B31091_06_10.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_10.png)'
- en: 'When using a `pd.DataFrame` with an area chart, the default behavior is to
    stack the columns:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`pd.DataFrame`绘制面积图时，默认行为是将列堆叠在一起：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](img/B31091_06_11.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_11.png)'
- en: 'To unstack, pass `stacked=False` and include an `alpha=` argument to introduce
    transparency. The value of this argument should be between 0 and 1, with values
    closer to 0 making the chart more transparent:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消堆叠，传递`stacked=False`并添加`alpha=`参数以引入透明度。此参数的值应在0和1之间，值越接近0，图表的透明度越高：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/B31091_06_12.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_12.png)'
- en: There’s more…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: The examples in this recipe used the minimum amount of arguments to produce
    visuals. However, the plotting methods accept many more arguments to control things
    like titles, labels, colors, etc.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的示例使用了最少的参数来生成可视化图形。然而，绘图方法接受更多的参数，以控制标题、标签、颜色等内容。
- en: 'If you want to add a title to your visualization, simply pass it as the `title=`
    argument:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为可视化添加标题，只需将其作为`title=`参数传递：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/B31091_06_13.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_13.png)'
- en: 'The `color=` argument can be used to change the color of the lines, bars, and
    markers in your chart. Color can be expressed using RGB hex codes (like `#00008B`
    for dark blue) or by using a Matplotlib named color like `seagreen` ([https://matplotlib.org/stable/gallery/color/named_colors.html](https://matplotlib.org/stable/gallery/color/named_colors.html)):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`color=`参数可用于更改图表中线条、条形和标记的颜色。颜色可以通过RGB十六进制代码（例如，`#00008B`表示深蓝色）或使用Matplotlib命名颜色（如`seagreen`）来表示([https://matplotlib.org/stable/gallery/color/named_colors.html](https://matplotlib.org/stable/gallery/color/named_colors.html))：'
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](img/B31091_06_14.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_14.png)'
- en: 'When working with a `pd.DataFrame`, you can pass a dictionary to `pd.DataFrame.plot`
    to control which columns should use which colors:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`pd.DataFrame`时，您可以将字典传递给`pd.DataFrame.plot`，以控制哪些列使用哪些颜色：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/B31091_06_15.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_15.png)'
- en: 'The `grid=` argument controls whether gridlines are shown or not:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid=`参数控制是否显示网格线：'
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](img/B31091_06_16.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_16.png)'
- en: 'You can control how your *x* and *y* axes are labeled with the `xlabel=` and
    `ylabel=` arguments:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`xlabel=`和`ylabel=`参数来控制您的*x*轴和*y*轴的标签：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](img/B31091_06_17.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_17.png)'
- en: 'When working with a `pd.DataFrame`, pandas will default to placing each column’s
    data on the same chart. However, you can easily generate separate charts with
    `subplots=True`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`pd.DataFrame`时，pandas默认将每一列的数据放在同一张图表上。然而，您可以通过`subplots=True`轻松生成独立的图表：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](img/B31091_06_18.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_18.png)'
- en: 'With separate charts, the legend becomes superfluous. To toggle that off, simply
    pass `legend=False`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于独立的图表，图例变得多余。要关闭图例，只需传递`legend=False`：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](img/B31091_06_19.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_19.png)'
- en: 'When using subplots, it is also worth noting that by default, the *x*-axis
    labels are shared, but the *y*-axis value ranges may differ. If you want the *y*
    axis to be shared, simply add `sharey=True` to your method invocation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用子图时，值得注意的是，默认情况下，*x*轴的标签是共享的，但*y*轴的数值范围可能不同。如果您希望*y*轴也共享，只需在方法调用中添加`sharey=True`：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](img/B31091_06_20.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_20.png)'
- en: 'When working with `pd.DataFrame.plot`, the `y=` argument can control which
    columns should be visualized, which can be helpful when you don’t want all of
    the columns to appear:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`pd.DataFrame.plot`时，`y=`参数可以控制哪些列需要可视化，这在您不希望所有列都显示时非常有用：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](img/B31091_06_21.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_21.png)'
- en: As you can see, pandas has a wealth of options to control what is being displayed
    and how. While pandas makes a best effort at figuring out where and how to place
    all of these elements on your visual, it may not always get it right. Later in
    this chapter, the *Further plot customization with Matplotlib* recipe will show
    you how to more finely control the layout of your visualization.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，pandas 提供了丰富的选项来控制显示内容和方式。尽管 pandas 会尽最大努力确定如何在可视化中布置这些元素，但它不一定总能做到完美。在本章后面，*使用
    Matplotlib 进一步定制图表*的示例将向你展示如何更精细地控制你的可视化布局。
- en: Plotting distributions of non-aggregated data
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制非聚合数据的分布
- en: Visualizations can be of immense help in recognizing patterns and trends in
    your data. Is your data normally distributed? Does it skew left? Does it skew
    right? Is it multimodal? While you may be able to work out the answers to these
    questions, a visualization can very easily highlight these patterns for you, yielding
    deeper insight into your data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化在识别数据中的模式和趋势时非常有帮助。你的数据是正态分布的吗？是否偏左？是否偏右？是多峰分布吗？虽然你可能能自己得出这些问题的答案，但可视化能够轻松地突出这些模式，从而深入洞察你的数据。
- en: In this recipe, we are going to see how easy pandas makes it to visualize the
    distribution of your data. Histograms are a very popular choice for plotting distributions,
    so we will start with them before showcasing the even more powerful **Kernel Density
    Estimate** (**KDE**) plot.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到 pandas 如何轻松地帮助我们可视化数据的分布。直方图是绘制分布的非常流行的选择，因此我们将从它们开始，然后展示更强大的**核密度估计**（**KDE**）图。
- en: How to do it
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'Let’s create a `pd.Series` using 10,000 random records that are known to follow
    a normal distribution. NumPy can be used to easily generate this data:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先用 10,000 个随机记录创建一个`pd.Series`，这些数据已知遵循正态分布。NumPy 可以方便地生成这些数据：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A histogram can be used to plot this data with the `kind="hist"` argument:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用直方图来绘制这些数据，方法是使用`kind="hist"`参数：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![A blue graph with numbers](img/B31091_06_22.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![带数字的蓝色图形](img/B31091_06_22.png)'
- en: Rather than attempting to plot every single point, the histogram places our
    values into an automatically generated number of “bins.” The range of each bin
    is plotted along the *X*-axis of the visualization, with the count of occurrences
    within each bin appearing on the y-axis of the histogram.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图并不是尝试绘制每一个单独的点，而是将我们的值放入一个自动生成的数量的“箱子”中。每个箱子的范围绘制在可视化的 *X* 轴上，而每个箱子内的出现次数显示在直方图的
    Y 轴上。
- en: Since we have created the data we are visualizing, we already know that we have
    a normally distributed set of numbers, and the preceding histogram hints at that
    as well. However, we can elect to visualize a different number of bins by providing
    a `bins=` argument to `pd.Series.plot`, which can have a significant impact on
    the visualization and how it is interpreted.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经创建了可视化的数据，并且知道它是一个正态分布的数字集合，因此前面的直方图也显示了这一点。不过，我们可以通过提供`bins=`参数给`pd.Series.plot`来选择不同的箱数，这会显著影响可视化效果及其解释方式。
- en: 'To illustrate, if we were to pass `bins=2`, we would have so few bins that
    our normal distribution would not be obvious:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，如果我们传递 `bins=2`，我们将得到极少的箱子，以至于我们的正态分布不再明显：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](img/B31091_06_23.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_23.png)'
- en: 'On the flip side, passing `bins=100` makes it clear that we generally have
    a normal distribution:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，传递 `bins=100` 可以清楚地看到，我们通常有一个正态分布：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![A blue graph with numbers  Description automatically generated](img/B31091_06_24.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![带数字的蓝色图形，描述自动生成](img/B31091_06_24.png)'
- en: 'This same issue is apparent when making a histogram from a `pd.DataFrame`.
    To illustrate, let’s create a `pd.DataFrame` with two columns, where one column
    is normally distributed and the other uses a triangular distribution:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `pd.DataFrame` 绘制直方图时，同样的问题也会出现。为说明这一点，让我们创建一个包含两列的 `pd.DataFrame`，其中一列是正态分布的，另一列则使用三角分布：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The basic plotting call to `pd.DataFrame.plot` will produce a chart that looks
    as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `pd.DataFrame.plot` 的基本绘图调用将生成如下图表：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![](img/B31091_06_25.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_25.png)'
- en: 'Unfortunately, the bins from one distribution overlap with the bins of the
    other. You can solve this by either introducing some transparency:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，一个分布的箱子与另一个分布的箱子重叠了。你可以通过引入一些透明度来解决这个问题：
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![](img/B31091_06_26.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_26.png)'
- en: 'Or generating subplots:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 或生成子图：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![](img/B31091_06_27.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_27.png)'
- en: 'At first glance, these distributions look pretty much the same, but using more
    bins reveals that they are not:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 初看这些分布似乎差不多，但使用更多的分箱后就会发现它们并不相同：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![](img/B31091_06_28.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_28.png)'
- en: While the histogram is commonly used, the fact that the choice of binning can
    have an impact on the interpretation of the data is rather unfortunate; you would
    not want your interpretation of the data to change just from picking the “wrong”
    number of bins!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直方图很常用，但分箱选择对数据解释的影响确实是个不幸之处；你不希望因为选择了“错误”的分箱数量而改变对数据的解释！
- en: 'Fortunately, there is a similar but arguably more powerful visualization you
    can use that does not require you to choose any type of binning strategy, known
    as the **Kernel Density Estimate** (or **KDE**) plot. To use this plot, you will
    need to have SciPy installed:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用一个类似但更强大的可视化方式，它不需要你选择任何类型的分箱策略，这就是 **核密度估计**（或 **KDE**）图。要使用此图，你需要安装
    SciPy：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After installing SciPy, you can simply pass `kind="kde"` to `pd.Series.plot`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 SciPy 后，你可以简单地将 `kind="kde"` 传递给 `pd.Series.plot`：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![A blue line graph with numbers  Description automatically generated](img/B31091_06_29.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![A blue line graph with numbers  Description automatically generated](img/B31091_06_29.png)'
- en: 'With our `pd.DataFrame`, the KDE plot makes it clear that we have two distinct
    distributions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `pd.DataFrame`，KDE 图清晰地表明我们有两个不同的分布：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![](img/B31091_06_30.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_30.png)'
- en: Further plot customization with Matplotlib
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 进一步自定义图表
- en: For very simple plots, the default layouts may suffice, but you will inevitably
    run into cases where you need to further tweak the generated visualization. To
    go beyond the out-of-the-box features in pandas, it is helpful to understand some
    Matplotlib terminology. In Matplotlib, the *figure* refers to the drawing area,
    and an *axes* or *subplot* is the region on that figure that you can draw upon.
    Be careful not to confuse an **axes**, which is an area for plotting data, with
    an **axis**, which refers to the *X*- or *Y*-axis.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常简单的图表，默认布局可能足够用，但你不可避免地会遇到需要进一步调整生成的可视化的情况。为了超越 pandas 的开箱即用功能，了解一些 Matplotlib
    的术语是很有帮助的。在 Matplotlib 中，*figure* 是指绘图区域，而 *axes* 或 *subplot* 是指你可以绘制的区域。请小心不要将
    **axes**（用于绘制数据的区域）与 **axis**（指的是 *X* 或 *Y* 轴）混淆。
- en: How to do it
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: Let’s start with a `pd.Series` of our book sales data and try to plot it three
    different ways on the same figure – once as a line chart, once as a bar chart,
    and once as a pie chart. To set up our drawing area, we will make a call to `plt.subplots(nrows=1,
    ncols=3)`, essentially telling matplotlib how many rows and columns of visualizations
    we want in our drawing area. This will return a two-tuple containing the figure
    itself and a sequence of the individual Axes objects that we can plot against.
    We will unpack this into two variables, `fig` and `axes`, respectively.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的图书销售数据的 `pd.Series` 开始，尝试在同一张图表上三种不同方式绘制它——一次作为线图，一次作为柱状图，最后一次作为饼图。为了设置绘图区域，我们将调用
    `plt.subplots(nrows=1, ncols=3)`，基本上告诉 matplotlib 我们希望绘制区域有多少行和列。这将返回一个包含图形本身和一个
    Axes 对象序列的二元组，我们可以在这些对象上进行绘制。我们将其解包为 `fig` 和 `axes` 两个变量。
- en: 'Because we asked for one row and three columns, the length of the returned
    `axes` sequence will be three. We can pass the individual Axes we want pandas
    to plot on to the `ax=` argument of `pd.DataFrame.plot`. Our first attempt at
    drawing all of these plots should look as follows, generating a result that is,
    well, hideous:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要求的是一行三列，返回的 `axes` 序列长度将为三。我们可以将 pandas 绘图时使用的单独 Axes 对象传递给 `pd.DataFrame.plot`
    的 `ax=` 参数。我们第一次尝试绘制这些图表的效果应该如下所示，结果是，嗯，简直丑陋：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![](img/B31091_06_31.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_31.png)'
- en: Because we did not tell it any different, Matplotlib gives us three equally
    sized axes objects to draw upon. However, this makes the line/bar charts above
    very tall and skinny, and we end up producing a ton of wasted space above and
    below the pie chart.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有告诉它其他设置，Matplotlib 给了我们三个大小相等的 axes 对象来绘制。然而，这使得上面的线形图和柱状图非常高而窄，最终我们在饼图上下产生了大量的空白区域。
- en: 'To control this more finely, we can use the Matplotlib `GridSpec` to create
    a 2x2 grid. With that, we can place our bar and line charts side by side in the
    first row, and then we can make the pie chart take up the entire second row:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更精细地控制这一点，我们可以使用 Matplotlib 的 `GridSpec` 来创建一个 2x2 的网格。这样，我们可以将柱状图和线形图并排放置在第一行，然后让饼图占据整个第二行：
- en: '[PRE42]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![A graph and pie chart  Description automatically generated](img/B31091_06_32.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![A graph and pie chart  Description automatically generated](img/B31091_06_32.png)'
- en: That looks a little better, but now, we still have an issue with the labels
    of the pie chart overlapping the *X*-axis labels of our bar chart. Fortunately,
    we can still modify each axes object individually to rotate labels, remove labels,
    change titles, etc.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这样看起来好一些，但现在我们依然有一个问题：饼图的标签与条形图的*X*轴标签重叠。幸运的是，我们仍然可以单独修改每个坐标轴对象来旋转标签、移除标签、修改标题等。
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![A graph and pie chart  Description automatically generated](img/B31091_06_33.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![A graph and pie chart  Description automatically generated](img/B31091_06_33.png)'
- en: There is no limit to the amount of customization that can be done to charts
    via Matplotlib, and unfortunately, we cannot hope to even scratch the surface
    in this book. If you have a keen interest in visualizations, I highly encourage
    you to read the Matplotlib documentation or find a dedicated book on the topic.
    However, many users who just want to see their data may find the amount of customizations
    burdensome to handle. For those users (myself included), there are, thankfully,
    higher-level plotting packages like seaborn, which can produce better-looking
    charts with minimal extra effort. The *Using seaborn for advanced plots* recipe
    later in this chapter will give you an idea of just how useful that package can
    be.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Matplotlib绘制图表的定制化程度是没有限制的，遗憾的是，在本书中我们无法触及这一话题的表面。如果你对可视化非常感兴趣，我强烈建议你阅读Matplotlib的文档或找到一本专门的书籍来深入了解。然而，许多仅仅想查看自己数据的用户可能会觉得过多的定制化处理是一个负担。对于这些用户（包括我自己），幸运的是，还有像seaborn这样的高级绘图库，可以用最小的额外努力制作出更美观的图表。本章后面关于*使用seaborn绘制高级图表*的章节将让你了解这个库有多么有用。
- en: Exploring scatter plots
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索散点图
- en: Scatter plots are one of the most powerful types of visualizations that you
    can create. In a very compact area, a scatter plot can help you visualize the
    relationship between two variables, measure the scale of individual data points,
    and even see how these relationships and scales may vary within different categories.
    Being able to effectively visualize data in a scatter plot represents a significant
    leap in analytical capabilities when lined up against some of the more commonplace
    visualizations we have seen so far.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图是你可以创建的最强大的可视化类型之一。在一个非常紧凑的区域内，散点图可以帮助你可视化两个变量之间的关系，衡量单个数据点的规模，甚至看到这些关系和规模如何在不同类别中变化。能够有效地在散点图中可视化数据，代表着分析能力的一大飞跃，相较于我们到目前为止看到的一些更常见的可视化方式。
- en: In this recipe, we will explore how we can measure all of these things at once
    just on one scatter plot.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节中，我们将探索如何仅在一个散点图上同时衡量所有这些内容。
- en: How to do it
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: Scatter plots by definition measure the relationship of at least two variables.
    As such, the scatter plot can only be created with a `pd.DataFrame`. A `pd.Series`
    simply does not have enough variables.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图从定义上讲，衡量至少两个变量之间的关系。因此，散点图只能通过`pd.DataFrame`创建。`pd.Series`简单来说没有足够的变量。
- en: 'With that said, let’s create a sample `pd.DataFrame` that contains four different
    columns of data. Three of these columns are continuous variables, and the fourth
    is a color that we will eventually use to categorize different data points:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们创建一个示例`pd.DataFrame`，其中包含四列不同的数据。三列是连续变量，第四列是颜色，我们最终将用它来对不同的数据点进行分类：
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Alongside `kind="scatter"`, we will want to explicitly control what gets plotted
    on the *X*-axis, what gets plotted on the *Y*-axis, how big a given data point
    should be, and what color a given data point should appear as. These are controlled
    via the `x=`, `y=`, `s=`, and `c=` arguments, respectively:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`kind="scatter"`之外，我们还需要明确控制绘制在*X*轴上的内容，绘制在*Y*轴上的内容，每个数据点的大小，以及每个数据点应该呈现的颜色。这些都可以通过`x=`,
    `y=`, `s=`, 和 `c=` 参数来控制：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![](img/B31091_06_34.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_34.png)'
- en: A simple scatter plot like this is not very interesting, but now that we have
    the basics down, let’s try out a more realistic dataset. The United States Department
    of Energy releases annual reports ([https://www.fueleconomy.gov/feg/download.shtml](https://www.fueleconomy.gov/feg/download.shtml))
    that summarize the results of detailed fuel economy testing for vehicles sold
    in the United States. This book includes a local copy of that dataset covering
    the model years 1985–2025.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的简单散点图并不特别有趣，但现在我们已经掌握了基础知识，让我们试用一个更具现实感的数据集。美国能源部发布了年度报告（[https://www.fueleconomy.gov/feg/download.shtml](https://www.fueleconomy.gov/feg/download.shtml)），总结了对在美国销售的车辆进行的详细燃油经济性测试的结果。这本书包括了一个涵盖1985年至2025年模型年份的本地副本。
- en: 'For now, let’s just read in a select few columns that are of interest to us,
    namely `city08` (city miles-per-gallon), `highway08` (highway miles-per-gallon),
    `VClass` (compact car, SUV, etc). `fuelCost08` (annual fuel cost), and the model
    `year` of each vehicle (for a full definition of terms included with this dataset,
    refer to [www.fueleconomy.gov](https://www.fueleconomy.gov)):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只读取一些对我们有兴趣的列，即 `city08`（城市油耗，英里/加仑）、`highway08`（高速公路油耗，英里/加仑）、`VClass`（紧凑型车、SUV
    等）、`fuelCost08`（年度燃油成本）和每辆车的模型 `year`（有关此数据集包含的所有术语的完整定义，请参阅 [www.fueleconomy.gov](https://www.fueleconomy.gov)）：
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This dataset includes many different vehicle classes, so to keep our analysis
    focused, for now, we are just going to look at different classes of cars from
    2015 onwards. Trucks, SUVs, and vans can be saved for another analysis:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据集包括许多不同的车辆类别，因此为了让我们的分析更集中，暂时我们只关注2015年及之后的不同车型。卡车、SUV 和厢式车可以留到另一个分析中：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A scatter plot can be used to help us answer a question like, *What is the
    relationship between city miles-per-gallon and highway miles-per-gallon?* by plotting
    these columns on the *X*- and *Y*-axis:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图可以帮助我们回答这样一个问题：*城市油耗和高速公路油耗之间的关系是什么？* 通过将这些列分别绘制在 *X* 轴和 *Y* 轴上：
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![](img/B31091_06_35.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_35.png)'
- en: Perhaps not surprisingly, there is a strong linear trend. Chances are that the
    better mileage a vehicle gets on city roads, the better mileage it will get on
    highways.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 也许不令人惊讶的是，存在一个强烈的线性趋势。车辆在城市道路上获得的油耗越好，它在高速公路上的油耗也越好。
- en: Of course, we still see a rather large spread in values; many vehicles are clustered
    down in the range of 10–35 MPG, but some exceed 100\. To dive in a little further,
    we can assign colors to each of our vehicle classes and add them to the visualization.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们仍然看到值的分布相当大；许多车辆集中在 10–35 MPG 范围内，但有些超过 100。为了进一步深入，我们可以为每个车辆类别分配颜色，并将其添加到可视化中。
- en: 'There are quite a few ways to do this, but one of the generally best approaches
    is to ensure that the value you would like to use for a color is a categorical
    data type:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多方法可以实现，但通常最好的方法之一是确保你想要用作颜色值的变量是一个分类数据类型：
- en: '[PRE52]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'With that out of the way, you can pass the categorical column to the `c=` argument
    of `pd.DataFrame.plot`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了这些问题后，你可以将分类列传递给 `pd.DataFrame.plot` 的 `c=` 参数：
- en: '[PRE54]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '![A graph of different sizes and colors  Description automatically generated
    with medium confidence](img/B31091_06_36.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![不同大小和颜色的图形，描述自动生成，信心中等](img/B31091_06_36.png)'
- en: 'Adding a `colormap=` argument may help to visually discern data points. For
    a list of acceptable values for this argument, please refer to the Matplotlib
    documentation ([https://matplotlib.org/stable/users/explain/colors/colormaps.html](https://matplotlib.org/stable/users/explain/colors/colormaps.html)):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `colormap=` 参数可能有助于在视觉上区分数据点。有关该参数可接受的值列表，请参阅 Matplotlib 文档（[https://matplotlib.org/stable/users/explain/colors/colormaps.html](https://matplotlib.org/stable/users/explain/colors/colormaps.html)）：
- en: '[PRE55]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![](img/B31091_06_37.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_37.png)'
- en: From these graphs alone, we can theorize a few things. There are not that many
    “Two Seaters,” but when there are, they tend to do poorly on both city and highway
    mileage. “Midsize Cars” appear to dominate the 40–60 MPG ranges, but as you look
    at the vehicles that produce 100 MPG or better on both highways or cities, “Large
    Cars” and “Midsize Cars” both appear to be reasonably represented.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些图表中，我们可以推测一些事情。虽然“二座车”不多，但当它们出现时，往往在城市和高速公路的油耗表现都较差。“中型车”似乎主导了 40–60 MPG
    范围，但当你查看那些在城市或高速公路上都能达到 100 MPG 或更好的车辆时，“大型车”和“中型车”似乎都相对较好。
- en: 'So far, we have used the *X*-axis, *Y*-axis, and color of our scatter plot
    to dive into data, but we can take this one step further and size each data point
    by fuel cost, passing `fuelCost08` as the `s=` argument:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了*X*轴、*Y*轴和散点图的颜色来深入分析数据，但我们可以更进一步，按燃油成本对每个数据点进行缩放，传递`fuelCost08`作为`
    s=`参数：
- en: '[PRE56]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![A graph of a line of colorful circles  Description automatically generated
    with medium confidence](img/B31091_06_38.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的图表，描述了一行彩色圆圈，具有中等信心](img/B31091_06_38.png)'
- en: 'The size of the individual bubbles here is likely too large to be useful. Our
    fuel economy column has values that are in the range of thousands, which creates
    too large of a plot area to be useful. Simply scaling those values can quickly
    get us to a more reasonable-looking visualization; here, I have chosen to divide
    by 25 and introduce some transparency with the `alpha=` argument to get a more
    pleasing graph:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里每个气泡的大小可能太大，不太实用。我们的燃油经济性列中的值范围是几千，这造成了一个过于庞大的图表区域，难以有效使用。只需对这些值进行缩放，就能快速得到一个更合理的可视化；在这里，我选择将其除以25，并使用`alpha=`参数引入一些透明度，得到一个更令人满意的图表：
- en: '[PRE57]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![](img/B31091_06_39.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_39.png)'
- en: The general trend of larger circles appearing toward the origin confirms that,
    generally, vehicles with worse mileage have a higher annual fuel cost. You may
    find individual points on this scatter plot where a relatively higher mileage
    still has a higher fuel cost compared to other vehicles with a similar range,
    likely due to different fuel type requirements.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 更大圆圈出现接近原点的趋势表明，通常情况下，油耗较差的车辆有更高的年燃油成本。你可能会在这个散点图中找到一些点，其中相对较高的油耗仍然比其他具有相似范围的车辆有更高的燃油成本，这可能是因为不同的燃料类型要求。
- en: There’s more…
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'A nice complement to the scatter plot is the scatter matrix, which generates
    pairwise relationships between all of the continuous columns of data within your
    `pd.DataFrame`. Let’s see what that looks like with our vehicle data:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图的一个很好的补充是散点矩阵，它生成你`pd.DataFrame`中所有连续列数据之间的成对关系。让我们看看使用我们的车辆数据会是什么样子：
- en: '[PRE58]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![A graph of a graph  Description automatically generated with medium confidence](img/B31091_06_40.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的图表描述，具有中等信心](img/B31091_06_40.png)'
- en: This is a lot of information in one chart, so let’s start by digesting just
    the first column of visualizations. If you look at the bottom of the chart, the
    label is `city08`, which means that `city08` is the *Y*-axis for each chart in
    that column.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图表包含了很多信息，所以让我们先消化第一列的可视化。如果你看图表的底部，标签为`city08`，这意味着`city08`是该列每个图表中的*Y*轴。
- en: The visualization in the first row of the first column would give you the combination
    of `city08` on the y-axis with `city08` on the *X*-axis. Rather than a scatter
    plot that graphs the same column against itself, the scatter matrix shows you
    the distribution of `city08` values in this visual. As you can see, the majority
    of vehicles get less than 50 MPG in the city.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列第一行的可视化展示了`city08`在*Y*轴与`city08`在*X*轴上的组合。这不是一个将同一列与自己进行散点图绘制的散点图，而是散点矩阵，展示了在这个可视化中`city08`值的分布。正如你所看到的，大多数车辆的城市油耗低于50
    MPG。
- en: If you look one visual beneath that in the second row of the first column, you
    will see the relationship between fuel cost and city mileage. This would suggest
    that there is an exponential decrease in the amount you spend on fuel annually
    as you opt for cars that get better city mileage.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下第二行第一列中下方的可视化，你会看到燃油成本与城市油耗之间的关系。这表明，随着选择城市油耗更高的汽车，你每年在燃油上的支出会呈指数性减少。
- en: The visualization in the third row of the first column shows `highway08` on
    the *Y*-axis, which is the same visual that we displayed throughout this recipe.
    Once again, there is a linear relationship between city and highway mileage.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列第三行的可视化展示了`highway08`在*Y*轴上的数据，这与我们在整个教程中展示的视觉效果相同。再次强调，城市与高速公路的里程之间存在线性关系。
- en: The visualization in the last row of the first column plots the year on the
    *Y*-axis. From this, it appears that there were more vehicles introduced in the
    model years 2023 and 2024 that achieved city mileage of 75 MPG and above.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列最后一行的可视化展示了年份在*Y*轴上的数据。从中可以看出，2023年和2024年型号的车辆更多，且实现了75 MPG及以上的城市油耗。
- en: Exploring categorical data
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索分类数据
- en: The adjective *categorical* is applied to data that, in a broad sense, is used
    to classify and help navigate your data, but whose values serve little to no purpose
    when aggregated. For example, if you were working with a dataset that contained
    a field called *eye color* with values of `Brown`, `Green`, `Hazel`, `Blue`, etc.,
    you could use this field to navigate your dataset and answer questions like, *For
    rows where the eye color is X, what is the average pupil diameter?* However, you
    would not ask a question like, *What is the summation of eye color?*, as a formula
    like `"Hazel" + "Blue` would not make sense in this context.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 形容词*类别*应用于那些广义上用于分类和帮助导航数据的数据，但这些值在聚合时几乎没有任何实际意义。例如，如果你正在处理一个包含*眼睛颜色*字段的数据集，值为`棕色`、`绿色`、`榛色`、`蓝色`等，你可以使用这个字段来导航数据集，回答类似*眼睛颜色为X的行，平均瞳孔直径是多少？*的问题。然而，你不会问诸如*眼睛颜色的总和是多少？*的问题，因为像`"榛色"
    + "蓝色"`这样的公式在这种情况下没有意义。
- en: By contrast, the adjective *continuous* is applied to data that you typically
    aggregate. With a question like, *What is the average pupil diamenter?*, the *pupil
    diameter* column would be considered continuous. There is value to knowing what
    it aggregates to (i.e., minimum, maximum, average, standard deviation, etc.),
    and there are a theoretically infinite amount of values that can be represented.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，形容词*连续*通常应用于你需要聚合的数据。比如问题是*什么是平均瞳孔直径？*，那么*瞳孔直径*这一列就会被认为是连续的。了解它聚合后的结果（例如最小值、最大值、平均值、标准差等）是有意义的，而且它可以表示理论上无穷多的值。
- en: At times, it can be ambiguous whether your data is categorical or continuous.
    Using a person’s *age* as an example, if you were measuring things like the *average
    age of subjects*, that column would be continuous, although in the context of
    a question like, *How many users do we have between the ages of 20–30?*, that
    same data becomes categorical. Ultimately, whether or not data like *age* is continuous
    or categorical will come down to how you use it in your analysis.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，判断数据是类别数据还是连续数据可能会有些模糊。以一个人的*年龄*为例，如果你测量的是*被试者的平均年龄*，那么这一列就是连续的，但如果问题是*20到30岁之间的用户有多少人？*，那么相同的数据就变成了类别数据。最终，是否将*年龄*这样的数据视为连续数据或类别数据，将取决于你在分析中的使用方式。
- en: In this recipe, we are going to generate visualizations that help quickly identify
    the distribution of categorical data. Our next recipe, *Exploring continuous data*,
    will give you some ideas on how to work with continuous data instead.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实例中，我们将生成有助于快速识别类别数据分布的可视化图表。我们的下一个实例，*探索连续数据*，将为你提供一些处理连续数据的思路。
- en: How to do it
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Back in the *Scatter plots* recipe, we were introduced to the `vehicles` dataset
    distributed by the United States Department of Energy. This dataset has a good
    mix of categorical and continuous data, so let’s once again start by loading it
    into a `pd.DataFrame`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 回到*散点图*的实例，我们介绍了由美国能源部分发的`vehicles`数据集。这个数据集包含了多种类别和连续数据，因此我们再次从将其加载到`pd.DataFrame`开始：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You may have noticed that we received a warning that `Columns (72,74,75,77)
    have mixed types`. Before we jump into visualization, let’s take a quick look
    at these columns:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到我们收到了一个警告，`Columns (72,74,75,77) have mixed types`。在开始进行可视化之前，我们快速看一下这些列：
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: While we can see the column names, our `pd.DataFrame` preview does not show
    us any actual values, so to inspect this a bit further, we can use `pd.Series.value_counts`
    on each column.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以看到列名，但我们的`pd.DataFrame`预览没有显示任何实际值，因此为了进一步检查，我们可以对每一列使用`pd.Series.value_counts`。
- en: 'Here is what we can see for the `rangeA` column:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在`rangeA`列中看到的内容：
- en: '[PRE63]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The values here are… interesting. Without yet knowing what we are looking at,
    the column name `rangeA` and most of the values suggest there is some value to
    treating this as continuous. By doing so, we could answer questions like, *What
    is the average rangeA of vehicles that…?*, but the presence of values like `240/290/290`
    and `230/350` that we see will prevent us from being able to do that. For now,
    we are just going to treat this data as a string.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的值……很有意思。在我们还不清楚具体数据含义的情况下，`rangeA`这一列名和大部分值暗示将其视为连续数据是有价值的。通过这样做，我们可以回答类似*车辆的平均rangeA是多少？*的问题，但我们看到的`240/290/290`和`230/350`等值会阻止我们这样做。目前，我们将把这些数据当作字符串来处理。
- en: 'To bring us full circle on the warning issued by `pd.read_csv`, pandas tries
    to infer the data type while reading the CSV file. If much of the data at the
    beginning of the file shows one type but later in the file you see another type,
    pandas will intentionally throw this warning so that you are aware of any potential
    issues with your data. For this column, we can use `pd.Series.str.isnumeric` alongside
    `pd.Series.idxmax` to quickly determine the first row where a non-integral value
    was encountered in the CSV file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`pd.read_csv`发出的警告，pandas在读取CSV文件时会尝试推断数据类型。如果文件开头的数据显示一种类型，但在文件后面看到另一种类型，pandas会故意发出这个警告，以提醒你数据中可能存在的问题。对于这一列，我们可以结合使用`pd.Series.str.isnumeric`和`pd.Series.idxmax`，快速确定CSV文件中首次出现非整数值的行：
- en: '[PRE65]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If you were to inspect the other columns that `pd.read_csv` warned about, you
    would not see a mix of integral and string data, but you would see that much of
    the data at the beginning of the file is missing, which makes it difficult for
    pandas to infer the data type:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查`pd.read_csv`警告的其他列，你不会看到整型数据和字符串数据混合的情况，但你会发现文件开头的大部分数据都缺失，这使得pandas很难推断出数据类型：
- en: '[PRE67]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Of course, the best solution here would have been to avoid the use of CSV files
    in the first place, opting instead for a data storage format that maintains type
    metadata, like Apache Parquet. However, we have no control over how this data
    is generated, so the best we can do for now is explicitly tell `pd.read_csv` to
    treat all of these columns as strings and suppress any warnings:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最好的解决方案本应是避免使用CSV文件，转而使用一种可以保持类型元数据的数据存储格式，比如Apache Parquet。然而，我们无法控制这些数据是如何生成的，因此目前我们能做的最好的办法是明确告诉`pd.read_csv`将所有这些列当作字符串处理，并抑制任何警告：
- en: '[PRE69]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now that we have loaded the data cleanly, let’s try and identify columns that
    are categorical in nature. Since we know nothing about this dataset, we can make
    the directionally correct assumption that all columns read in as strings by `pd.read_csv`
    are categorical in nature:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清理了数据，让我们尝试识别哪些列是类别性质的。由于我们对这个数据集一无所知，我们可以做出一个方向上正确的假设，即所有通过`pd.read_csv`读取为字符串的列都是类别型的：
- en: '[PRE71]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We could loop over all of these columns and call `pd.Series.value_counts` to
    understand what each column contains, but a more effective way to explore this
    data would be to first understand how many unique values are in each column with
    `pd.Series.nunique`, ordering from low to high. A lower number indicates a *low
    cardinality* (i.e., the number of unique values compared to the value count of
    the `pd.DataFrame` is relatively low). Fields with a higher number would inversely
    be considered to have a *high cardinality*:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遍历所有这些列，并调用`pd.Series.value_counts`来理解每列包含什么，但更有效的探索数据方式是先通过`pd.Series.nunique`来了解每列中有多少个唯一值，并按从低到高排序。较低的数值表示*低基数*（即与`pd.DataFrame`的值计数相比，唯一值的数量较少）。而具有较高数值的字段则反向被认为是*高基数*：
- en: '[PRE73]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: For an easy visualization, we are just going to take the nine columns with the
    lowest cardinality. This is by no means an absolute rule for choosing what to
    visualize or not – ultimately, that decision is up to you. For our particular
    dataset, the nine columns with the lowest cardinality have up to seven unique
    values, which can be reasonably plotted on the *X*-axis of bar charts to help
    visualize value distribution.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于可视化，我们将选择具有最低基数的九列。这并不是一个绝对的规则来决定哪些内容应该可视化，最终这个决定取决于你自己。对于我们这个特定的数据集，基数最低的九列最多有七个唯一值，这些值可以合理地绘制在条形图的*X*轴上，以帮助可视化值的分布。
- en: 'Building on what we learned back in the *Further plot customization with Matplotlib*
    recipe in this chapter, we can use `plt.subplots` to create a simple 3x3 grid
    and, with that, plot each visual to its own space in the grid:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们在本章的*Matplotlib进一步绘图自定义*一节中学到的内容，我们可以使用`plt.subplots`创建一个简单的3x3网格，并在该网格中将每个可视化图表绘制到相应的位置：
- en: '[PRE75]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '![](img/B31091_06_41.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_41.png)'
- en: 'That chart is… very difficult to read. Many of the *X*-axis labels overrun
    the chart area, given their length. One way to fix this would be to assign shorter
    labels to our row index values, using a combination of `pd.Index.str[]` along
    with `pd.Index.set_axis` to use those values in a new `pd.Index`. We can also
    use Matplotlib to rotate and resize our *X*-axis labels:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 那张图表… 很难阅读。许多*X*轴标签超出了图表区域，由于它们的长度。修复这个问题的一种方法是使用`pd.Index.str[]`与`pd.Index.set_axis`将更短的标签分配给我们的行索引值，以使用这些值创建一个新的`pd.Index`。我们还可以使用Matplotlib来旋转和调整*X*轴标签的大小：
- en: '[PRE77]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![](img/B31091_06_42.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_42.png)'
- en: From this visualization, we can more easily understand our dataset at a high
    level. The `mpgData` column appears to be `N` at a much higher frequency than
    `Y`. For the `guzzler` column, we see roughly twice as many `G` values as `T`.
    For the `c240Dscr` column, we can see that the vast majority of entries are `standard`,
    although overall, there are only slightly more than 100 rows in our entire dataset
    that even bother to assign this value, so we may decide that there aren’t enough
    measurements to reliably use it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个可视化，我们可以更容易地从高层次理解我们的数据集。`mpgData`列中的`N`出现频率明显高于`Y`。对于`guzzler`列，我们看到`G`值大约是`T`值的两倍。对于`c240Dscr`列，我们可以看到绝大多数条目都是`standard`，尽管总体上，我们的整个数据集中只有略多于100行分配了这个值，因此我们可能会决定没有足够的测量数据可靠地使用它。
- en: Exploring continuous data
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索连续数据
- en: In the *Exploring categorical* *data* recipe, we provided a definition for *categorical*
    and *continuous* data, while exploring only the former. The same `vehicles` dataset
    we used in that recipe has a good mix of both types of data (most datasets will),
    so we will reuse that same dataset but shift our focus to continuous data for
    this recipe.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在*探索分类数据*的示例中，我们提供了*分类*和*连续*数据的定义，同时仅探索了前者。我们在那个示例中使用的同一个`vehicles`数据集既包含这两种类型的数据（大多数数据集都是如此），所以我们将重复使用同一个数据集，但是将焦点转移到本示例中的连续数据。
- en: Before going through this recipe, I advise you to get familiar with the techniques
    shown in the *Plotting distributions of non-aggregated data* recipe first. The
    actual plotting calls made will be the same, but this recipe will apply them to
    more of a “real-world” dataset instead of artificially created data.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本示例之前，建议您先熟悉*非聚合数据分布绘图*示例中展示的技术。实际的绘图调用将是相同的，但本示例将它们应用于更“真实”的数据集，而不是人为创建的数据。
- en: How to do it
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做
- en: 'Let’s start by loading the `vehicles` dataset:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先加载`vehicles`数据集：
- en: '[PRE78]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In the previous recipe, we used `pd.DataFrame.select_dtypes` with an `include=`
    argument that kept only string columns, which we used as a proxy for categorical
    data. By passing that same argument to `exclude=` instead, we can get a reasonable
    overview of the continuous columns:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了带有`include=`参数的`pd.DataFrame.select_dtypes`来保留只包含字符串列的内容，这些列被用作分类数据的代理。通过将相同的参数传递给`exclude=`，我们可以得到对连续列的合理概述：
- en: '[PRE80]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Using `pd.Series.nunique` does not make as much sense with continuous data,
    as values may take on a theoretically infinite amount of values. Instead, to identify
    good plotting candidates, we may just want to understand which columns have a
    sufficient amount of non-missing data by using `pd.isna`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连续数据，使用`pd.Series.nunique`并不那么合理，因为值可以取理论上无限多的值。相反，为了确定良好的绘图候选列，我们可能只想了解哪些列具有足够数量的非缺失数据，可以使用`pd.isna`：
- en: '[PRE82]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Generally, most of our continuous data is complete, but let’s take a look at
    `cylinders` to see what the missing values are:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们的大多数连续数据是完整的，但是让我们看看`cylinders`，看看缺失值是什么：
- en: '[PRE84]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'These appear to be electric vehicles, so we could reasonably choose to fill
    these missing values with a `0` instead:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些似乎是电动车辆，因此我们可以合理地选择用`0`来填充这些缺失值：
- en: '[PRE86]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We see the same pattern with the `displ` column:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`displ`列中看到了相同的模式：
- en: '[PRE87]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Whether or not we should fill this data with `0` is up for debate. In the case
    of `cylinder`, filling missing values with `0` made sense because our data was
    actually categorical (i.e., there are only so many `cylinder` values that can
    appear, and you cannot simply aggregate those values). If you have one vehicle
    with 2 cylinders and another with 3, it would not make sense to say, “The average
    number of cylinders is 2.5” because a vehicle may not have 2.5 cylinders.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 是否应该用`0`来填充这些数据还有待讨论。在`cylinder`的情况下，用`0`填充缺失值是有道理的，因为我们的数据实际上是分类的（即`cylinder`值只能有那么多种，而且不能简单地聚合这些值）。如果你有一辆车有2个气缸，另一辆车有3个，那么说“平均气缸数为2.5”是没有意义的。
- en: 'However, with a column like `displacement`, it may make more sense to measure
    something like the “average displacement.” In such a case, providing many `0`
    values to an average will skew it downwards, whereas missing values would be ignored.
    There are also many more unique values than what we see with `cylinders`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于像 `displacement` 这样的列，测量“平均排量”可能更有意义。在这种情况下，向平均数提供许多 `0` 值将使其向下偏斜，而缺失值将被忽略。与
    `cylinders` 相比，还有许多更多的唯一值：
- en: '[PRE89]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Ultimately, filling missing values in this field is a judgment call; for our
    analysis, we will leave them as missing.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，在这个字段中填补缺失值是一个判断调用；对于我们的分析，我们将把它们保留为空白。
- en: 'Now that we have validated the missing values in our dataset and feel comfortable
    with our completeness, it is time to start exploring individual fields in more
    detail. When exploring continuous data, a histogram is often the first visualization
    that users reach for. Let’s see what that looks like with our `city08` column:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了数据集中的缺失值，并对我们的完整性感到满意，是时候开始更详细地探索单个字段了。在探索连续数据时，直方图通常是用户首先选择的可视化方式。让我们看看我们的
    `city08` 列是什么样子：
- en: '[PRE91]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '![](img/B31091_06_43.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_43.png)'
- en: 'The plot looks very skewed, so we will increase the number of bins in the histogram
    to see if the skew is hiding behaviors (as skew makes bins wider):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图形看起来非常倾斜，因此我们将增加直方图中的箱数，以查看倾斜是否隐藏了行为（因为倾斜使箱子变宽）：
- en: '[PRE92]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '![A graph with numbers and a blue column  Description automatically generated
    with medium confidence](img/B31091_06_44.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有数字和蓝色柱的图形 自动以中等置信度生成的描述](img/B31091_06_44.png)'
- en: As we discussed back in the *Plotting distributions of non-aggregated data*
    recipe, you can forgo having to find the optimal number of bins if you have SciPy
    installed. With SciPy, a KDE plot will give you an even better view of the distribution.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*绘制非聚合数据的分布*配方中讨论的那样，如果安装了 SciPy，您可以放弃寻找最佳箱数。使用 SciPy，KDE 图将为您提供更好的分布视图。
- en: 'Knowing that, and building from what we saw back in the *Further plot customization
    with Matplotlib* recipe, we can use `plt.subplots` to visualize the KDE plots
    for multiple variables at once, like city and highway mileage:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 知道了这一点，并且从*Matplotlib 进一步的图形定制*配方中得到启发，我们可以使用 `plt.subplots` 来一次可视化多个变量的 KDE
    图，比如城市和高速公路里程：
- en: '[PRE93]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '![A graph of a normal distribution  Description automatically generated with
    medium confidence](img/B31091_06_45.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![一个正态分布图的图形 自动以中等置信度生成的描述](img/B31091_06_45.png)'
- en: As you can see, the city mileage tends to skew slightly left, with the peak
    of the distribution occurring around 16 or 17 mpg. Highway mileage peaks closer
    to 23 or 24, with more values than you would expect for a perfectly normal distribution
    appearing around 17 or 18 mpg.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，城市里程倾向于略微向左倾斜，分布的峰值大约在 16 或 17 英里每加仑。高速公路里程的峰值更接近于 23 或 24，与理想的正态分布相比，在
    17 或 18 英里每加仑处出现更多值。
- en: Using seaborn for advanced plots
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 seaborn 进行高级绘图
- en: The seaborn library is a popular Python library for creating visualizations.
    It does not do any drawing itself, instead deferring the heavy lifting to Matplotlib.
    However, for users working with a `pd.DataFrame`, seaborn offers beautiful visualizations
    out of the box and an API that abstracts a lot of things you would have to do
    when working more directly with Matplotlib.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: seaborn 库是一个流行的 Python 库，用于创建可视化。它本身不进行任何绘制，而是将繁重的工作推迟到 Matplotlib。然而，对于使用 `pd.DataFrame`
    的用户，seaborn 提供了美观的可视化效果和一个抽象了许多工作的 API，这些工作在直接使用 Matplotlib 时必须手动完成。
- en: 'Rather than using `pd.Series.plot` and `pd.DataFrame.plot`, we will use seaborn’s
    own API. All examples in this section assume the following code to import seaborn
    and use its default theme:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用 `pd.Series.plot` 和 `pd.DataFrame.plot`，我们将使用 seaborn 自己的 API。本节中的所有示例假设以下代码导入
    seaborn 并使用其默认主题：
- en: '[PRE94]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: How to do it
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'Let’s create a small `pd.DataFrame` that shows how many stars two GitHub projects
    have received over time:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个小的 `pd.DataFrame`，展示两个 GitHub 项目随时间收到的星数：
- en: '[PRE95]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This simple data makes for a good bar chart, which we can produce with `sns.barplot`.
    Note the difference in the call signature when using seaborn’s API – with seaborn,
    you will provide the `pd.DataFrame` as an argument and explicitly choose the `x`,
    `y`, and `hue` arguments. You will also notice that the seaborn theme uses a different
    color theme than Matplotlib, which you may find more visually appealing:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的数据适合用作柱状图，我们可以使用 `sns.barplot` 来生成。注意，使用 seaborn 的 API 时，调用签名的不同——在 seaborn
    中，你需要将 `pd.DataFrame` 作为参数传递，并明确选择 `x`、`y` 和 `hue` 参数。你还会注意到 seaborn 主题使用了与 Matplotlib
    不同的配色方案，你可能会觉得这种配色更具视觉吸引力：
- en: '[PRE97]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '![](img/B31091_06_46.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_46.png)'
- en: '`sns.lineplot` can be used to produce this same visualization as a line chart:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`sns.lineplot` 可以用来生成与此相同的折线图：'
- en: '[PRE98]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '![A graph with a line and a line  Description automatically generated](img/B31091_06_47.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![一张带有折线的图表，描述自动生成](img/B31091_06_47.png)'
- en: 'An important thing to note when using seaborn is that you will provide your
    data in *long form* instead of wide form. To illustrate the difference, look closely
    at the raw `pd.DataFrame` we just plotted:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 seaborn 时需要注意的一点是，你需要以*长格式*而不是宽格式提供数据。为了说明这一点，请仔细观察我们刚刚绘制的原始 `pd.DataFrame`：
- en: '[PRE99]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If we wanted to make the equivalent line and bar charts with pandas, we would
    have had to structure our data differently before calling `pd.DataFrame.plot`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想用 pandas 绘制等效的折线图和柱状图，我们必须在调用`pd.DataFrame.plot`之前以不同的方式构建数据：
- en: '[PRE101]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: While the default styling that seaborn provides is helpful to make nice-looking
    charts, there are way more powerful visualizations that the library can help you
    build, with no equivalent when using pandas directly.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 seaborn 提供的默认样式有助于制作漂亮的图表，但该库还可以帮助你构建更强大的可视化，而这些在直接使用 pandas 时是没有等效功能的。
- en: 'To see these types of charts in action, let’s once again work with the `movie`
    dataset we explored back in *Chapter 5*, *Algorithms and How to Apply Them*:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这些类型的图表如何运作，让我们再次使用我们在*第 5 章*《算法及其应用》中探讨过的 `movie` 数据集：
- en: '[PRE103]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We need to do some data cleansing before we jump into this dataset. For starters,
    it looks like `title_year` is being read as a floating-point value. An integral
    value would have been much more appropriate, so we are going to reread our data
    while passing that explicitly to the `dtype=` argument:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入分析这个数据集之前，我们需要进行一些数据清理。首先，看起来 `title_year` 被读取为浮动点数值。使用整数值会更为合适，因此我们将重新读取数据，并明确传递
    `dtype=` 参数：
- en: '[PRE105]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'With that out of the way, let’s see when the oldest movie in our dataset was
    released:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这些问题已经解决了，让我们看看我们数据集中最老的电影是什么时候上映的：
- en: '[PRE107]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'And compare that to the last movie:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其与最后一部电影进行比较：
- en: '[PRE109]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'As we think ahead toward visualizing this data, we may not always be so detailed
    as caring about the exact year that a movie was released. Instead, we could place
    each movie into a `decade` bucket by using the `pd.cut` function we covered back
    in *Chapter 5*, *Algorithms and How to Apply Them*, providing a range that will
    start before and extend after the first and last titles in our dataset were released:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始考虑如何可视化这些数据时，我们可能并不总是关心电影确切的上映年份。相反，我们可以通过使用我们在*第 5 章*《算法及其应用》中讲解过的 `pd.cut`
    函数，将每部电影归入一个 `decade`（十年）类别，并提供一个区间，该区间会涵盖数据集中第一部和最后一部电影上映的年份：
- en: '[PRE111]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'If we wanted to understand how the distribution of movie ratings has changed
    over the decades, a boxplot would be a great first step toward visualizing those
    trends. Seaborn exposes an `sns.boxplot` method that makes this trivial to draw:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想了解电影评分在各个十年间的分布变化，箱线图将是可视化这些趋势的一个很好的起点。Seaborn 提供了一个 `sns.boxplot` 方法，可以轻松绘制此图：
- en: '[PRE113]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '![](img/B31091_06_48.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31091_06_48.png)'
- en: If you look at the median movie rating (i.e., the black vertical line toward
    the middle of each box), you can see that movie ratings have generally trended
    downward over time. At the same time, the lines extending from each box (which
    represent the lowest and highest quartiles of ratings) appear to have a wider
    spread over time, which may suggest that the worst movies each decade are getting
    worse, while the best movies may be getting better, at least since the 1980s.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察箱线图中的中位数电影评分（即每个箱体中间的黑色竖线），你会发现电影评分整体上有下降的趋势。与此同时，从每个箱体延伸出来的线条（代表最低和最高四分位数的评分）似乎随着时间的推移有了更宽的分布，这可能表明每个十年的最差电影在变得越来越糟，而最好的电影则可能在变得越来越好，至少自
    1980 年代以来如此。
- en: 'While the boxplot chart provides a decent high-level view into the distribution
    of data by decade, there are other plots that seaborn offers that may be even
    more insightful. One example is the violin plot, which is essentially a KDE plot
    (covered back in the *Plotting distributions of non-aggregated data* recipe) overlaid
    on top of a boxplot. Seaborn allows this via the `sns.violinplot` function:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然箱线图提供了一个不错的高层次视图，显示了每十年的数据分布，但seaborn还提供了其他可能更具洞察力的图表。一个例子是小提琴图，它本质上是一个核密度估计图（在*非聚合数据的分布绘图*一节中已介绍），并叠加在箱线图之上。Seaborn
    通过 `sns.violinplot` 函数来实现这一点：
- en: '[PRE114]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '![A graph of a number of numbers  Description automatically generated with
    medium confidence](img/B31091_06_49.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![一张数字图表，自动生成的描述，信心较中等](img/B31091_06_49.png)'
- en: Many of the decades show a distribution with a single mode, but if you look
    closely at the 1950s, you will notice that the KDE plot has two peaks (one around
    a score of 7 and the other peak slightly north of 8). The 1960s exhibit a similar
    phenomenon, although the peak around a score of 7 is slightly less pronounced.
    For both of these decades, the KDE overlay suggests that a relatively high volume
    of reviews are distributed toward the 25th and 75th percentiles for ratings, whereas
    other decades tend to regress more toward the median.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 许多十年显示出单峰分布，但如果仔细观察1950年代，你会注意到核密度估计图有两个峰值（一个在大约7分左右，另一个峰值稍微高于8分）。1960年代也展示了类似的现象，尽管7分左右的峰值略不明显。对于这两个十年，小提琴图的覆盖层表明，相对较高的评分量分布在25和75百分位之间，而其他十年则更多地回归到中位数附近。
- en: However, the violin plot still makes it difficult to discern how many ratings
    there were per decade. While the distribution in each decade is, of course, important,
    the volume may tell another story. Perhaps movie ratings are higher for older
    decades because of survivorship bias, with only the movies that are deemed good
    for those decades actually getting reviewed, or perhaps newer decades have valued
    quality over quantity.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，小提琴图仍然使得难以辨别每十年有多少条评分数据。虽然每个十年的分布当然很重要，但数量可能会讲述另一个故事。也许旧时代的电影评分较高是因为生存偏差，只有被认为好的电影才会在这些十年里被评价，或者也许是因为现代的十年更注重质量而非数量。
- en: 'Whatever the root cause may be, seaborn can at least help us visually confirm
    the volume alongside our distribution through the use of a swarm plot, which takes
    the KDE portion of the violin plot and scales it vertically, depending on the
    volume of records:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 无论根本原因是什么，seaborn 至少可以通过使用群体图帮助我们直观地确认每个十年的数量分布，这种图表将小提琴图的核密度估计部分按数量纵向缩放：
- en: '[PRE115]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '![A graph with numbers and lines  Description automatically generated](img/B31091_06_50.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![一张包含数字和线条的图表，自动生成的描述](img/B31091_06_50.png)'
- en: As you can see in the visual, much of the volume of reviews happened on reviews
    from the 1990s or later, with most of the reviews coming from the years 2000–2010
    (remember that our dataset only contains movies up until 2016). Decades before
    1990 have a relatively small amount of reviews, to the point of making them almost
    indiscernible on the graph.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图表中看到的，大多数评论的数量集中在1990年代及之后，尤其是2000-2010年间的评论（请记住，我们的数据集仅包含到2016年的电影）。1990年之前的十年，评论的数量相对较少，甚至在图表上几乎不可见。
- en: With a swarm plot, you can go even further into this data by adding more dimensions
    to the visual. So far, we have already discovered that movie ratings have trended
    downward over time, whether it is due to survivorship bias with ratings or a focus
    on quantity over quality. But what if we wanted to know more about different types
    of movies? Are PG-13 movies faring better than R-rated?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用群体图，你可以更进一步地分析数据，通过向可视化中添加更多维度。目前，我们已经发现电影评分随着时间的推移呈现下降趋势，无论是由于评分的生存偏差，还是注重数量而非质量。那么，如果我们想了解不同类型的电影呢？PG-13
    电影的表现是否优于 R 级电影？
- en: 'By controlling the color of each point on a swarm plot, you can add that extra
    dimension to your visuals. To see this in action, let’s drill into just a few
    years of data, as our current plots are getting tough to read. We can also just
    look at movies with ratings, as unrated entries or TV shows are not something
    we care to drill into. As a final data cleansing step, we are going to convert
    our `title_year` column to a categorical data type so that the plotting library
    knows that years like 2013, 2014, 2015, etc. should be treated as discrete values,
    rather than as a continuous range of values from 2013 to 2015:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过控制每个点在散点图上的颜色，你可以为可视化添加额外的维度。为了更好地展示这一点，让我们缩小范围，仅查看一些年份的数据，因为我们当前的图表已经很难阅读了。我们也可以只关注有评分的电影，因为没有评分的条目或电视节目并不是我们需要深入分析的内容。作为最终的数据清洗步骤，我们将把`title_year`列转换为分类数据类型，这样绘图库就能知道像2013年、2014年、2015年等年份应该作为离散值处理，而不是作为2013到2015年的连续范围：
- en: '[PRE116]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'With the data cleansing out of the way, we can go ahead and add the `content_rating`
    to our chart and have seaborn assign each a unique color, via the `hue=` argument:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据清洗完成后，我们可以继续将`content_rating`添加到我们的图表中，并通过`hue=`参数让seaborn为每个数据点分配一个独特的颜色：
- en: '[PRE118]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '![A graph of data analysis  Description automatically generated with medium
    confidence](img/B31091_06_51.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的数据分析图，描述具有中等置信度](img/B31091_06_51.png)'
- en: Adding colors adds another dimension of information to our chart, although an
    alternative approach to use a separate chart for each `content_rating` might make
    this even more readable.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 添加颜色为我们的图表增添了另一个信息维度，尽管另一种方法是为每个`content_rating`使用一个单独的图表，这样可能会让图表更加易读。
- en: 'To achieve that, we are going to use the `sns.catplot` function with some extra
    arguments. The first argument of note is `kind=`, through which we will tell seaborn
    to draw “swarm” plots for us. The `col=` argument dictates the field used to generate
    individual charts, and the `col_wrap=` argument tells us how many charts can be
    put together in a row, assuming a grid-like layout for our charts:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用`sns.catplot`函数并传入一些额外的参数。需要注意的第一个参数是`kind=`，通过这个参数，我们将告诉seaborn绘制“散点图”给我们。`col=`参数决定了用于生成单独图表的字段，而`col_wrap=`参数则告诉我们在一行中可以放几个图表，假设我们的图表是以网格布局方式排列的：
- en: '[PRE119]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '![A group of blue dots  Description automatically generated](img/B31091_06_52.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的一群蓝点，描述](img/B31091_06_52.png)'
- en: This visualization would appear to suggest that 2013 was a good year for movies,
    at least relative to 2014 and 2015\. Within the PG-13 content rating, it appears
    that there were relatively more movies falling in the 7–8 range than any other
    year. For R-rated movies, it appears that the vast majority of movies were given
    a rating of 5 and above in 2013, with more movies falling below that line as the
    years went on.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 该可视化图表似乎表明，2013年是一个适合电影的年份，至少相对于2014年和2015年。在PG-13内容评级下，看起来2013年有相对更多的电影评分在7到8之间，而其他年份的评分则没有这么集中的趋势。对于R级电影来说，2013年大多数电影的评分都在5分以上，而随着年份的推移，更多的电影评分低于这一线。
- en: Join our community on Discord
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/pandas](https://packt.link/pandas)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/pandas](https://packt.link/pandas)'
- en: '![](img/QR_Code5040900042138312.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code5040900042138312.png)'
- en: Leave a Review!
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下你的评论！
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you’ve completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢你从Packt出版社购买这本书——我们希望你喜欢它！你的反馈对于我们至关重要，它帮助我们改进和成长。阅读完成后，请花一点时间在亚马逊上留下评论；这只需一分钟，但对像你这样的读者来说意义重大。
- en: Scan the QR code below to receive a free ebook of your choice.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描下面的二维码，获取你选择的免费电子书。
- en: '[https://packt.link/NzOWQ](Chapter_6.xhtml)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/NzOWQ](Chapter_6.xhtml)'
- en: '![](img/QR_Code1474021820358918656.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1474021820358918656.png)'
