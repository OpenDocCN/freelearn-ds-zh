- en: Chapter 5. The Dance with Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章 树的舞蹈
- en: 'Everything from creating simple binary trees to practical applications such
    as Huffman encoding is covered in this section:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了从创建简单的二叉树到哈夫曼编码等实际应用：
- en: Defining a binary tree data type
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义二叉树数据类型
- en: Defining a rose tree (multiway tree) data type
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义玫瑰树（多路树）数据类型
- en: Traversing a tree depth-first
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度优先遍历树
- en: Traversing a tree breadth-first
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广度优先遍历树
- en: Implementing a Foldable instance for a tree
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为树实现可折叠实例
- en: Calculating the height of a tree
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算树的高度
- en: Implementing a binary search tree data structure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现二叉搜索树数据结构
- en: Verifying the order property of a binary search tree
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证二叉搜索树的顺序属性
- en: Using a self-balancing tree
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自平衡树
- en: Implementing a min-heap data structure
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现最小堆数据结构
- en: Encoding a string using a Huffman tree
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用哈夫曼树对字符串进行编码
- en: Decoding a Huffman code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码哈夫曼编码
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '![Introduction](img/ch05.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/ch05.jpg)'
- en: Trees are a common data structure used in a variety of data analysis techniques.
    A **tree** is a hierarchical connection of nodes under one all-encompassing mighty
    root node. Every node can have zero or more children, but each child node associates
    with only one parent. Also, the root is the only special case that has no parent
    node. All nodes without children are also referred to as **leaf** nodes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 树是广泛应用于各种数据分析技术中的常见数据结构。**树**是一个节点的层次化连接，所有节点都在一个强大的根节点下。每个节点可以有零个或多个子节点，但每个子节点只与一个父节点相关联。此外，根节点是唯一没有父节点的特殊节点。所有没有子节点的节点也称为**叶子**节点。
- en: In Haskell, we can very gracefully represent a tree since the recursive nature
    of the data structure makes use of the recursive nature of functional programming.
    This section will cover creating our own trees as well as using existing implementations
    from libraries.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，我们可以优雅地表示树，因为数据结构的递归性质利用了函数式编程的递归特性。本节将介绍创建我们自己的树以及使用库中现有的实现。
- en: We will implement heaps and Huffman trees, which are some of the most notable
    examples of trees in data analysis. In other chapters throughout the book, we
    also run into HTML/XML traversal, hierarchical clustering, and decision trees,
    which all depend heavily on the tree data structure.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现堆和哈夫曼树，它们是数据分析中最著名的树结构之一。在本书的其他章节中，我们还会遇到 HTML/XML 遍历、层次聚类和决策树，这些都在很大程度上依赖于树数据结构。
- en: Defining a binary tree data type
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义二叉树数据类型
- en: In a binary tree, each node has at most two children. We will define a data
    structure to encompass the left and right subtrees of each node.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉树中，每个节点最多有两个子节点。我们将定义一个数据结构来包含每个节点的左子树和右子树。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code in the recipe will represent the following tree. The root node is labeled
    **n3** with a value of **3**. It has a left node **n1** of value **1**, and a
    right node **n2** of value **2**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码将表示以下树结构。根节点标记为**n3**，值为**3**。它有一个左节点**n1**，值为**1**，和一个右节点**n2**，值为**2**。
- en: '![Getting ready](img/6331OS_05_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6331OS_05_01.jpg)'
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This code requires no imports. We can jump in and define the data structure
    recursively. A tree can either be a node with values or null/empty:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码不需要任何导入。我们可以直接定义数据结构递归地。树可以是一个带有值的节点，也可以是空/null：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In `main`, create the tree shown in the preceding diagram and print it out:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 中，创建如上图所示的树并将其打印出来：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The full tree is printed out as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整的树结构打印结果如下：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: See also
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: If the nodes in a tree need more than two children, then see the next section,
    *Defining a rose tree (multiway tree) data type*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果树中的节点需要超过两个子节点，则请参阅下一节，*定义玫瑰树（多路树）数据类型*。
- en: Defining a rose tree (multiway tree) data type
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义玫瑰树（多路树）数据类型
- en: A rose tree relaxes the limitation of at most two children per node. It can
    have an arbitrary number of elements. Rose trees are common when parsing HTML
    to represent the **Document Object Model** (**DOM**).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 玫瑰树放松了每个节点最多两个子节点的限制。它可以包含任意数量的元素。玫瑰树在解析 HTML 时很常见，用于表示**文档对象模型**（**DOM**）。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will be representing the following tree in this recipe. The root node has
    three children:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中表示以下树结构。根节点有三个子节点：
- en: '![Getting ready](img/6331OS_05_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6331OS_05_02.jpg)'
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will not need any imports for this recipe:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的配方不需要任何导入：
- en: 'The rose tree data type is similar to that of the binary tree, except that
    instead of left and right children, it will store an arbitrary list of children:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玫瑰树数据类型与二叉树的数据类型相似，不同之处在于它不会使用左、右子节点，而是存储一个任意数量的子节点的列表：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Construct the tree from the preceding diagram and print it out:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的图示构建树并将其打印出来：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The printed output will be as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印的输出将如下所示：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Instead of using dedicated left and right fields to represent child nodes, a
    rose tree uses a list data structure to represent an arbitrary number of children.
    A rose tree can be used to emulate a binary tree if each node is restricted to
    have at most two children.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 玫瑰树不像使用专用的左、右字段来表示子节点，而是使用列表数据结构来表示任意数量的子节点。如果每个节点最多只能有两个子节点，则可以使用玫瑰树模拟二叉树。
- en: See also
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: To represent a binary tree, it may be simpler to use the previous recipe, *Defining
    a binary tree data type*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示一个二叉树，使用之前的方案可能会更简单，*定义二叉树数据类型*。
- en: Traversing a tree depth-first
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度优先遍历树
- en: This recipe will demonstrate one way to traverse through a tree. The algorithm
    starts at the root node and continues exploring nodes along the entire length
    of a branch before going back to explore more shallow nodes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本方案将展示一种遍历树的方法。该算法从根节点开始，沿着一条分支深入探索所有节点，直到回到较浅的节点继续探索。
- en: Since we will examine each node before recursively examining its child nodes,
    we call this a **pre-order traversal**. Instead, if we examine each node afterwards,
    then we call this approach **post-order traversal**. Anything in-between is an
    **in-order traversal**, but naturally, there is no unique in-order traversal for
    rose trees.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们会在递归地检查子节点之前检查每个节点，因此我们称之为**先序遍历**。相反，如果我们在检查每个节点之后再检查其子节点，那么我们称这种方法为**后序遍历**。介于两者之间的是**中序遍历**，但自然地，玫瑰树没有唯一的中序遍历。
- en: The biggest advantage in using the depth-first approach is the minimal space
    complexity. Video game AIs often use depth-first approaches in determining the
    ideal move to take against an opponent. However, in enormous or infinite trees,
    a depth-first search may never terminate if we keep visiting subsequent child
    nodes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用深度优先方法的最大优势是最小的空间复杂度。视频游戏中的 AI 常常使用深度优先方法来确定对抗对手时的最佳动作。然而，在庞大或无限的树中，如果我们不断访问后续子节点，深度优先搜索可能永远无法终止。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will traverse the following tree in a depth-first fashion. Starting at node
    **r**, we first explore node **n1**, followed by **n2**, then go back up to find
    **n3**, and backtrack all the way to finally end at **n4**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以深度优先的方式遍历以下树。我们从节点**r**开始，首先探索节点**n1**，然后是**n2**，接着返回查找**n3**，最后回溯到**n4**，并最终结束。
- en: '![Getting ready](img/6331OS_05_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6331OS_05_03.jpg)'
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'We will use an existing rose tree implementation from `Data.Tree`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`Data.Tree`中的现有玫瑰树实现：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This function will traverse a tree depth-first:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数将会深度优先遍历树：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s a depth-first implementation of adding all the values in a tree:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个深度优先实现，目的是将树中的所有值相加：
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define a tree to represent the preceding diagram:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个树来表示前面的图示：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Test out the depth-first functions:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试深度优先函数：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will print the following two lines of output:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打印出以下两行输出：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'In this recipe, we use the built-in rose tree data structure from `Data.Tree`.
    Similar to our implementation in the previous recipe, it has the `Tree` data type
    having the following constructor:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方案中，我们使用了来自`Data.Tree`的内置玫瑰树数据结构。与我们在前一个方案中的实现类似，它的`Tree`数据类型具有以下构造函数：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We recursively run the `depthFirst` algorithm on every child node and append
    it to the node's value, thereby creating a list that represents the tree traversal.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个子节点上递归运行`depthFirst`算法，并将其附加到节点的值上，从而创建一个表示树遍历的列表。
- en: See also
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: If traversing a tree by the tree level is preferred, then take a look at the
    next section, *Traversing a tree breadth-first*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更倾向于按树的层次遍历树，请查看下一节，*广度优先遍历树*。
- en: Traversing a tree breadth-first
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先遍历树
- en: In a breadth-first search approach to traversing a tree, nodes are visited in
    the order of the depth of the tree. The root is visited, then its children, then
    each of their children, and so on and so forth. This process requires a greater
    space complexity than the depth-first traversal but comes in handy for optimizing
    search algorithms.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在树的广度优先搜索方法中，节点按照树的深度顺序被访问。首先访问根节点，然后是它的子节点，再接着是每个子节点的子节点，依此类推。这个过程比深度优先遍历需要更大的空间复杂度，但在优化搜索算法时非常有用。
- en: For example, imagine trying to find all relevant topics from a Wikipedia article.
    Traversing all the links within the article in a breadth-first fashion will help
    ensure the topics start out with relevance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你试图从维基百科文章中找到所有相关的主题。以广度优先的方式遍历文章中的所有链接，有助于确保主题从一开始就具有相关性。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Examine the tree in the following diagram. A breadth-first traversal will start
    at the root node **r**, then continue to the next level, encountering **n1** and
    **n4**, finally followed by **n2** and **n3**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看下图中的树。广度优先遍历将从根节点**r**开始，然后继续到下一级，遇到**n1**和**n4**，最后是**n2**和**n3**。
- en: '![Getting ready](img/6331OS_05_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6331OS_05_03.jpg)'
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We will be using an existing implementation of a rose tree from `Data.Tree`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用来自`Data.Tree`的现有玫瑰树实现：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Implement the breadth-first traversal of a tree:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现树的广度优先遍历：
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For demonstration, implement a function to add the values of each node in a
    tree.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示，实现一个函数来添加树中每个节点的值。
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a tree based on the preceding diagram:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据前面的图表创建一棵树：
- en: '[PRE16]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Test out the breadth-first algorithms in `main`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`中测试广度优先算法：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The printed output is as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we use the built-in rose tree data structure from `Data.Tree`.
    Similar to our implementation in one of the previous recipes, it has the `Tree`
    data type with the following constructors:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了`Data.Tree`中的内置玫瑰树数据结构。与我们之前某个配方中的实现类似，它具有以下构造器的`Tree`数据类型：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We perform the breadth-first search by creating a list that begins with the
    values of the node's direct children. Then, the values of the children's children
    are appended, and so on until the tree is fully traversed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个列表来执行广度优先搜索，该列表从节点的直接子节点的值开始。然后，附加子节点的子节点的值，依此类推，直到树完全遍历。
- en: See also
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: If space complexity becomes an issue, then the previous recipe, *Traversing
    a tree depth-first*, might offer a better approach.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果空间复杂度成为问题，那么之前的配方，*深度优先遍历树*，可能会提供更好的方法。
- en: Implementing a Foldable instance for a tree
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为树实现一个`Foldable`实例
- en: The idea of traversing a tree can be generalized by implementing a `Foldable`
    instance. Usually, folds are used on lists; for example, `foldr1 (+) [1..10]`
    traverses a list of numbers to produce a grand sum. Similarly, we can apply `foldr1
    (+) tree` to find the sum of all nodes in a tree.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历树的概念可以通过实现一个`Foldable`实例来推广。通常，fold操作用于列表；例如，`foldr1 (+) [1..10]`遍历一个数字列表以产生总和。类似地，我们可以应用`foldr1
    (+) tree`来找到树中所有节点的总和。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will be folding through the following tree to obtain a sum of all node values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下树来折叠并获取所有节点值的总和。
- en: '![Getting ready](img/6331OS_05_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6331OS_05_03.jpg)'
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Import the following built-in packages:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下内置包：
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The tree from `Data.Tree` already implements `Foldable`, so we will define
    our own tree data type for demonstration purposes:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Data.Tree`中的树已经实现了`Foldable`，因此我们将定义自己的树数据类型用于演示：'
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement the `foldMap` function for the `Foldable` instance. This implementation
    will give us a post-order traversal of the tree:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Foldable`实例实现`foldMap`函数。这个实现将给我们树的后序遍历：
- en: '[PRE22]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define a function to fold through a tree to find the sum of all nodes:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数通过树折叠以找到所有节点的和：
- en: '[PRE23]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Construct a tree that represents the one in the preceding diagram:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造一个表示前面图表中树的树：
- en: '[PRE24]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Test out the folding by running the `add` function on a tree:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在树上运行`add`函数来测试折叠操作：
- en: '[PRE25]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result gets printed out as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将打印如下：
- en: '[PRE26]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The function that is necessary to define a `Foldable` instance is either `foldMap`
    or `foldr`. In this recipe, we define the `foldMap :: (Foldable t, Data.Monoid.Monoid
    m) => (a -> m) -> t a -> m` function that essentially maps a function `f` over
    every node in a tree, and glues it together using `mappend` from `Data.Monoid`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '定义`Foldable`实例所需的函数是`foldMap`或`foldr`。在本节中，我们定义了`foldMap :: (Foldable t, Data.Monoid.Monoid
    m) => (a -> m) -> t a -> m`函数，该函数实际上将一个函数`f`映射到树中的每个节点，并通过使用`Data.Monoid`中的`mappend`将其连接起来。'
- en: See also
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: Other ways to traverse through elements of a tree are discussed in the previous
    two sections, *Traversing a tree depth-first* and *Traversing a tree breadth-first*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历树的其他方法在前两节中讨论过，*深度优先遍历树*和*广度优先遍历树*。
- en: Calculating the height of a tree
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算树的高度
- en: The height of a tree is the length of the longest downward path from the root
    node. For example, the height of a balanced binary tree should be around log to
    the base 2 of the number of nodes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 树的高度是从根节点到最深路径的长度。例如，一个平衡二叉树的高度应该大约是节点数量的以2为底的对数。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: As long as we're consistent, the height of a tree can be defined as either the
    number of nodes or the number of edges in the longest path. In this recipe, we
    will count by using the number of nodes. The longest path of this tree contains
    three nodes and two edges. Therefore, this tree has a height of three units.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们保持一致，树的高度可以定义为最长路径中节点的数量或边的数量。在本节中，我们将通过节点的数量来计算。该树的最长路径包含三个节点和两条边。因此，这棵树的高度为三个单位。
- en: '![Getting ready](img/6331OS_05_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6331OS_05_05.jpg)'
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Import the `maximum function` from `Data.List` and the built-in tree data structure
    from `Data.Tree`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Data.List`导入`maximum function`，并从`Data.Tree`导入内置的树数据结构：
- en: '[PRE27]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define a function to calculate the height of a tree:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来计算树的高度：
- en: '[PRE28]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Construct a tree on which we will run our algorithm:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一棵树，我们将在其上运行算法：
- en: '[PRE29]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Test out the function in `main`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`中测试该函数：
- en: '[PRE30]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The height of the tree will be printed as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 树的高度将如下所示打印出来：
- en: '[PRE31]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `height` function recursively finds the maximum height among its child trees
    and returns one plus that value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`height`函数通过递归查找其子树中的最大高度，并返回该值加一。'
- en: Implementing a binary search tree data structure
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现二叉搜索树数据结构
- en: A binary search tree restricts an order property on a binary tree. This order
    property requires that among every node, the nodes in the left subtree must not
    be greater, and that the nodes in the right subtree must not be less than the
    current node.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树对二叉树施加了一种顺序属性。这个顺序属性要求在每个节点中，左子树中的节点不能大于当前节点，右子树中的节点不能小于当前节点。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a binary `BSTree` module to expose our binary search tree data structure.
    Insert the following code in a file called `BSTree.hs`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个二叉`BSTree`模块，用于暴露我们的二叉搜索树数据结构。将以下代码插入一个名为`BSTree.hs`的文件中：
- en: '[PRE32]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define the data structure for a binary tree:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义二叉树的数据结构：
- en: '[PRE33]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define a convenience function to create a one-node tree:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个便捷函数来创建一个单节点树：
- en: '[PRE34]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Implement a function to insert new values in the binary search tree:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个函数，用于向二叉搜索树中插入新值：
- en: '[PRE35]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Implement a function to find a node with a specific value in a binary search
    tree:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个函数，用于在二叉搜索树中查找具有特定值的节点：
- en: '[PRE36]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, test out the `BSTree` module by creating a new file that can be called
    `Main.hs` with the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，测试`BSTree`模块，在一个新的文件中写入以下代码，可以命名为`Main.hs`：
- en: '[PRE37]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In `main`, construct a binary search tree by calling the `insert` function
    on various values:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`中，通过对不同的值调用`insert`函数构造一棵二叉搜索树：
- en: '[PRE38]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Print out the tree and test out the `find` function:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印树并测试`find`函数：
- en: '[PRE39]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output should be as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE40]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The core functions of a binary search tree data structure are `insert` and `find`,
    and are used for inserting and finding elements in a binary search tree respectively.
    Finding a node is accomplished by traversing the tree and taking advantage of
    its order property. If the value is lower than expected, it will check the left
    node; otherwise, if the value is greater, it will check the right node. Eventually,
    this recursive algorithm either finds the desired node or ends up at a leaf node
    and consequently does not find the node.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树数据结构的核心功能是`insert`和`find`，分别用于在二叉搜索树中插入和查找元素。查找节点是通过遍历树并利用其顺序性质来完成的。如果值低于预期，它会检查左节点；否则，如果值较大，它会检查右节点。最终，这个递归算法要么找到所需的节点，要么到达叶节点，从而找不到该节点。
- en: A binary search tree does not guarantee the tree to be balanced, and therefore,
    a speedy O(log n) lookup is not to be expected. There is always a possibility
    for a binary search tree to end up looking like a list data structure (consider,
    for example, when we insert nodes in the following order [1,2,3,4,5] and examine
    the resulting structure).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树不保证树是平衡的，因此不能期望有快速的O(log n)查找操作。二叉搜索树总有可能最终看起来像一个列表数据结构（例如，当我们按照[1,2,3,4,5]的顺序插入节点时，检查最终结构）。
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: Given a binary tree, the order property can be verified using the following
    recipe titled *Verifying the order property of a binary search tree*. To use a
    balanced binary tree, refer to the recipe, *Using a self-balancing tree*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一棵二叉树，可以使用以下名为*验证二叉搜索树的顺序性质*的实例来验证顺序性质。如果要使用平衡的二叉树，请参考实例*使用自平衡树*。
- en: Verifying the order property of a binary search tree
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证二叉搜索树的顺序性质
- en: Given a binary tree, this recipe will cover how to verify if it actually satisfies
    the order property such that all elements in the left subtree are of lesser value,
    and that all values of the right subtree are of greater value.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一棵二叉树，本实例将介绍如何验证它是否满足顺序性质，即左子树中的所有元素都较小，而右子树中的所有元素都较大。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will be verifying whether or not the following tree is a binary search tree:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将验证以下树是否为二叉搜索树：
- en: '![Getting ready](img/6331OS_05_06.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6331OS_05_06.jpg)'
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'No imports are necessary for this recipe. Perform the following steps to find
    if the tree is a binary search tree:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本实例无需导入任何包。请按照以下步骤检查树是否为二叉搜索树：
- en: 'Define a data structure for a binary tree:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个二叉树的数据结构：
- en: '[PRE41]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Construct a tree based on the preceding diagram:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据前面的图示构建一棵树：
- en: '[PRE42]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define the function to verify whether or not a tree obeys the binary order
    property:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来验证树是否遵循二叉顺序性质：
- en: '[PRE43]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Test out the function in `main`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`中测试该功能：
- en: '[PRE44]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Clearly, the tree does not obey the order property, and therefore, the output
    is as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很明显，这棵树不遵循顺序性质，因此，输出结果如下：
- en: '[PRE45]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `valid` function recursively checks if the left subtree contains elements
    less than the current node and if the right subtree contains elements greater
    than the current node.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`valid`函数递归地检查左子树是否包含小于当前节点的元素，右子树是否包含大于当前节点的元素。'
- en: Using a self-balancing tree
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自平衡树
- en: An AVL tree is a balanced binary search tree. The heights of each subtree differ
    by at most one. On each insertion or deletion, the tree shifts around its nodes
    through a series of rotations to become balanced. A balanced tree ensures the
    height is minimized, which guarantees lookups and insertions to be within *O(log
    n)* time. In this recipe, we will use an AVL tree package directly, but self-balancing
    trees also exist within the `Data.Set` and `Data.Map` implementations.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树是一种平衡的二叉搜索树。每个子树的高度差最多为一。在每次插入或删除时，树会通过一系列旋转操作调整节点，使其保持平衡。平衡的树确保了高度最小化，从而保证查找和插入操作在*O(log
    n)*时间内完成。在这个实例中，我们将直接使用AVL树包，但自平衡树也可以在`Data.Set`和`Data.Map`实现中找到。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will be using the `AvlTree` package to use `Data.Tree.AVL`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`AvlTree`包来使用`Data.Tree.AVL`：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Import the relevant AVL tree packages:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关的AVL树包：
- en: '[PRE47]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Set up an AVL tree from a list of values and read the minimum and maximum values
    from it:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个值列表中设置一个AVL树，并读取其中的最小值和最大值：
- en: '[PRE48]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The minimum and maximum values are printed out as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小值和最大值如下所示：
- en: '[PRE49]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `asTree :: (e -> e -> COrdering e) -> [e] -> AVL` e-function takes in an
    ordering property and a list of elements to produce an AVL tree out of the corresponding
    elements. The function `fstCC :: Ord a => a -> a -> COrdering a` comes from `Data.Cordering`
    and is defined as:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`asTree :: (e -> e -> COrdering e) -> [e] -> AVL` 函数接受一个排序属性和一个元素列表，生成相应元素的
    AVL 树。`fstCC :: Ord a => a -> a -> COrdering a` 函数来自 `Data.Cordering`，其定义如下：'
- en: '*A combining comparison for an instance of ''Ord'' which keeps the first argument
    if they are deemed equal. The second argument is discarded in this case.*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个为 ''Ord'' 实例提供的组合比较，它在认为两个参数相等时保留第一个参数，第二个参数则被丢弃。*'
- en: There's more…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The implementation of Haskell''s `Data.Set` and `Data.Map` functions efficiently
    uses balanced binary trees. We can rewrite the recipe by simply using `Data.Set`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 的 `Data.Set` 和 `Data.Map` 函数实现高效地使用了平衡二叉树。我们可以通过简单地使用 `Data.Set` 来重写这个方法：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Implementing a min-heap data structure
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个最小堆数据结构
- en: A heap is a binary tree with both a shape property and a heap property. The
    shape property enforces the tree to behave in a balanced way by defining each
    node to have two children unless the node is in the very last level. The heap
    property ensures that each node is less than or equal to either of its child nodes
    if it is a min-heap, and vice versa in case of a max-heap.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是一个具有形状属性和堆属性的二叉树。形状属性通过定义每个节点除非位于最后一层，否则都必须有两个子节点，强制树以平衡的方式表现。堆属性确保如果是最小堆，则每个节点小于或等于其任何子节点，最大堆则相反。
- en: Heaps are used for constant time lookups for maximum or minimum elements. We
    will use a heap in the next recipe to implement our own Huffman tree.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 堆用于常数时间查找最大或最小元素。我们将在下一个示例中使用堆来实现我们自己的霍夫曼树。
- en: Getting started
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'Install the lens library for easy data manipulation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 lens 库以便于数据操作：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Define the `MinHeap` module in a file `MinHeap.hs`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MinHeap.hs` 文件中定义 `MinHeap` 模块：
- en: '[PRE52]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We will use a list to represent a binary tree data structure for demonstration
    purposes only. It is best to implement the heap as an actual binary tree (as we
    have done in the previous sections), or we should use an actual array that will
    give us constant time access to its elements. For simplicity, we will define the
    root node to start at index 1\. Given a node at index `i`, the left child will
    always be located at *2*i*, and the right child at *2*i + 1*:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个列表来表示二叉树数据结构，仅用于演示目的。最好将堆实现为实际的二叉树（如我们在前面的章节中所做的），或者我们应使用实际的数组来提供常数时间访问其元素。为了简化起见，我们将定义根节点从索引
    1 开始。给定一个位于索引 `i` 的节点，左子节点将始终位于 *2*i*，右子节点位于 *2*i + 1*：
- en: '[PRE53]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We define a convenience function to initiate an empty heap:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个方便的函数来初始化一个空堆：
- en: '[PRE54]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Insertion of a node in a heap is done by appending the node to the end of the
    array and percolating it up:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在堆中插入一个节点的方法是将节点添加到数组的末尾，然后将其上浮：
- en: '[PRE55]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Deleting a node from a heap is done by swapping the root node with the last
    element, and then percolating down from the root node:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从堆中删除一个节点的方法是将根节点与最后一个元素交换，然后从根节点开始向下浮动：
- en: '[PRE56]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a function to view the minimum:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来查看最小值：
- en: '[PRE57]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Percolating down from a node means ensuring the heap property holds for the
    current node; otherwise, swap the node with the greater or lesser (depending on
    the max or min heap) child. This process is recursively applied all the way down
    to the leaf nodes:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个节点向下浮动意味着确保当前节点的堆属性成立；否则，将节点与其较大或较小的子节点（根据是最大堆还是最小堆）交换。这个过程会递归地应用直到叶节点：
- en: '[PRE58]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Define the `left`, `right`, `i''`, `l`, and `r` variables:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `left`、`right`、`i'`、`l` 和 `r` 变量：
- en: '[PRE59]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Percolating a node up means to recursively swap a node with its parent until
    the heap property of the tree holds:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上浮一个节点意味着递归地将节点与其父节点交换，直到树的堆属性成立：
- en: '[PRE60]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We define a convenience function to swap items at two indices in a list:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个方便的函数来交换列表中两个索引处的元素：
- en: '[PRE61]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To view the weights of each node in the array representation of a heap, we
    can define the following function:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看堆在数组表示中的每个节点的权重，我们可以定义如下函数：
- en: '[PRE62]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, in a different file that we can name `Main.hs`, we can test out the
    min-heap:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在一个我们可以命名为 `Main.hs` 的不同文件中，我们可以测试最小堆：
- en: '[PRE63]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output of the weights in the array representation of the heap is as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆的数组表示中的权重输出如下：
- en: '[PRE64]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: There's more…
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The code in this recipe is for understanding the heap data structure, but it
    is by no means efficient. Better implementations of heaps exist on Hackage, including
    the `Data.Heap` library that we will explore:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码用于理解堆数据结构，但效率并不高。Hackage 上有更好的堆实现，包括我们将要探索的`Data.Heap`库：
- en: 'Import the heap library:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入堆库：
- en: '[PRE65]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Define a helper function to construct a min-heap from a list:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个辅助函数，从列表构建最小堆：
- en: '[PRE66]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Define a helper function to construct a max-heap from a list:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个辅助函数，从列表构造最大堆：
- en: '[PRE67]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Test out the heaps:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试堆：
- en: '[PRE68]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The view functions return a tuple in a `Maybe` data structure. The first element
    of the tuple is the value from performing a lookup, and the second element is
    the new heap with that value removed:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图函数返回一个`Maybe`数据结构中的元组。元组的第一个元素是执行查找操作后的值，第二个元素是删除该值后的新堆：
- en: '[PRE69]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Encoding a string using a Huffman tree
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用哈夫曼树对字符串进行编码
- en: A **Huffman tree** allows efficient encoding of data by calculating a probability
    distribution of characters to optimize the space taken per character. Imagine
    compressing this book into one piece of paper and back without any information
    loss. Huffman trees allow this type of optimal lossless data compression based
    on statistics.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈夫曼树**通过计算字符的概率分布来优化每个字符所占的空间，从而实现高效的数据编码。想象一下将这本书压缩成一张纸，再恢复回来而不丢失任何信息。哈夫曼树允许这种基于统计数据的最优无损数据压缩。'
- en: In this recipe, we will implement a Huffman tree from a source of text and produce
    a string representation of its Huffman codes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个哈夫曼树，从文本源生成它的哈夫曼编码的字符串表示。
- en: For example, the string "hello world" contains 11 characters, which, depending
    on the encoding and architecture, may take up as few as 11 bytes of space to represent.
    The code in this recipe will transform the string into just 51 bits, or 6.375
    bytes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，字符串“hello world”包含11个字符，这些字符根据编码方式和架构的不同，可能只需要占用11个字节的空间来表示。本节代码将把该字符串转换成51位，或6.375字节。
- en: Getting ready
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure to be connected to the Internet since this recipe will download text
    from [http://norgiv.com/big.txt](http://norgiv.com/big.txt) to analyze probability
    distribution of many characters. We will be using the min-heap that was implemented
    in the previous recipe by importing `MinHeap`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保连接到互联网，因为本节会从[http://norgiv.com/big.txt](http://norgiv.com/big.txt)下载文本以分析许多字符的概率分布。我们将使用前一个食谱中实现的最小堆，通过导入`MinHeap`：
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Import the following packages. We will be using our previous `MinHeap` module,
    so be sure to include the code from the previous recipe:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下包。我们将使用之前的`MinHeap`模块，因此请确保包含之前食谱中的代码：
- en: '[PRE70]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Define a function to return an association list of characters to its frequency:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，返回字符与其频率的关联列表：
- en: '[PRE71]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The data structure of a Huffman tree is simply a binary tree:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈夫曼树的数据结构就是一个二叉树：
- en: '[PRE72]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Construct a Huffman tree with one value:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个值构造哈夫曼树：
- en: '[PRE73]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Define a function to construct a Huffman tree from a min-heap:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，通过最小堆构建哈夫曼树：
- en: '[PRE74]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Get a map of Huffman codes from the Huffman tree:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从哈夫曼树获取哈夫曼编码的映射：
- en: '[PRE75]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Define a function to encode a string to text using the Huffman codes:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，使用哈夫曼编码将字符串编码为文本：
- en: '[PRE76]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Test out the entire process by executing the following in `main`. Downloading
    and calculating the frequency might take a couple of minutes:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`main`中执行以下操作来测试整个过程。下载并计算频率可能需要几分钟：
- en: '[PRE77]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The string representation of the Huffman tree is then printed as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈夫曼树的字符串表示形式如下所示：
- en: '[PRE78]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First, we obtain a source of data to analyze by downloading the text from [http://norvig.com/big.txt](http://norvig.com/big.txt).
    Next, we obtain the frequency map of each character and throw it in a heap. The
    Huffman tree is constructed from this min-heap by combining the two lowest frequency
    nodes until only one node is left in the min-heap. Finally, the Huffman codes
    are used on a sample "hello world" string to see the encoding.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过从[http://norvig.com/big.txt](http://norvig.com/big.txt)下载文本来获取分析数据源。接下来，我们获取每个字符的频率映射并将其放入堆中。哈夫曼树通过将两个最低频率的节点合并，直到最小堆中只剩下一个节点。最后，使用哈夫曼编码对示例字符串“hello
    world”进行编码。
- en: See also
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: To read an encoded Huffman value, see the next section, *Decoding a Huffman
    code*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取编码后的哈夫曼值，请参阅下一节，*解码哈夫曼编码*。
- en: Decoding a Huffman code
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码哈夫曼编码
- en: This code relies heavily on the previous recipe, *Encoding a string using a
    Huffman tree*. The same Huffman tree data structure is used next to decode a string
    representation of a Huffman coding.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在很大程度上依赖于前面的食谱，*使用哈夫曼树编码字符串*。接下来使用相同的哈夫曼树数据结构来解码哈夫曼编码的字符串表示。
- en: Getting ready
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Read the previous recipe, *Encoding a string using a Huffman tree*. The same
    `HTree` data structure is used in this recipe.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读前面的食谱，*使用哈夫曼树编码字符串*。本食谱中使用的是相同的`HTree`数据结构。
- en: How to do it...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We traverse down the tree until we hit a leaf node. Then, we prepend the character
    found and restart from the root node. This process continues until no input is
    available:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们沿着树进行遍历，直到遇到叶子节点。然后，前置找到的字符并从根节点重新开始。这个过程会持续进行，直到没有输入可用为止：
- en: '[PRE79]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: See also
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: To encode data using a Huffman tree, see the previous recipe, *Encoding a string
    using a Huffman tree*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用哈夫曼树编码数据，请参见前面的食谱，*使用哈夫曼树编码字符串*。
