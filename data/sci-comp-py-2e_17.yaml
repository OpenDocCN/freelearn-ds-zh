- en: Interacting with the Operating System
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 与操作系统交互
- en: This section is an add-on to the introduction to Python. It puts Python into
    the context of the operating system on your computer and shows how Python is used
    in a command window, also called a console. We demonstrate how system commands
    and a Python command interact with each other and how you make a new application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是 Python 简介的附加内容。它将 Python 放入计算机操作系统的上下文中，并展示了如何在命令窗口（也称为控制台）中使用 Python。我们演示系统命令和
    Python 命令如何互动以及如何创建新应用程序。
- en: 'Among many other operating systems and various *dialects*, there are three
    main operating systems in use on desktop computers and notebooks: Windows 10,
    macOS, and Linux. In this chapter, we discuss how to use Python within the Linux
    world. All examples are tested in the widely distributed Ubuntu environment. The
    principles presented here apply also to the other big operating systems. The presentation
    is nevertheless restricted to Linux as a completely freely accessible environment.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多其他操作系统和各种 *方言* 中，桌面计算机和笔记本电脑上使用的三个主要操作系统是：Windows 10、macOS 和 Linux。在本章中，我们讨论如何在
    Linux 环境中使用 Python。所有示例均在广泛分发的 Ubuntu 环境中进行测试。这里介绍的原则同样适用于其他大型操作系统。但本章内容仅限于 Linux，作为一个完全自由获取的环境。
- en: First, we assume we have written and tested a Python program and want to run
    it now from a console window directly instead of from a Python shell such as IPython.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设我们已经编写并测试了一个 Python 程序，并且现在希望直接从控制台窗口而不是从诸如 IPython 的 Python shell 运行它。
- en: 'In this chapter, we cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Running a Python program in a Linux shell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux shell 中运行 Python 程序
- en: The module `sys`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块 `sys`
- en: How to execute Linux commands from Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从 Python 执行 Linux 命令
- en: 17.1 Running a Python program in a Linux shell
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.1 在 Linux shell 中运行 Python 程序
- en: 'When you open a terminal window with the terminal app, you obtain a window
    with a command prompt; see *Figure 17.1*:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端应用程序时，会获得一个带有命令提示符的窗口；参见 *图 17.1*：
- en: '![](img/9fe516c1-353a-4ac3-834d-099f2709f28d.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9fe516c1-353a-4ac3-834d-099f2709f28d.png)'
- en: 'Figure 17.1: A terminal window in Ubuntu 20.04'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1：Ubuntu 20.04 中的终端窗口
- en: The terminal windows come with a command prompt, often prefixed by the username
    and the computer's name followed by the directory name. This depends on the individual
    settings.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 终端窗口带有命令提示符，通常由用户名和计算机名称前缀，后跟目录名称。这取决于个人设置。
- en: 'To execute the Python commands written in a file named `myprogram.py`, you
    have two choices:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行名为 `myprogram.py` 的 Python 命令文件，您有两个选择：
- en: Executing the command `python myprogram.py`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行命令 `python myprogram.py`
- en: Executing the command `myprogram.py` directly
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接执行命令 `myprogram.py`
- en: 'The second variant needs some preparation. First, you have to give permission
    to execute that file, and secondly, you have to tell the system which command
    is needed to execute that file. The permission to execute that file is given by
    the command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种变体需要一些准备工作。首先，您必须允许执行该文件，其次，您必须告诉系统需要执行该文件的命令。通过以下命令来允许执行该文件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`chmod` stands for changing the file mode. The command is followed by the filename
    and finally the desired new modes, here `o+x`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`chmod` 代表更改文件模式。该命令后跟文件名，最后是所需的新模式，在这里是 `o+x`。'
- en: The modes that are given in that example stand for "give (`+`) the owner (`o`)
    rights to execute (`x`) that file." We suppose that you are the owner of the file
    and that it is in the current directory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在该示例中给出的模式代表“授予（`+`）文件所有者（`o`）执行（`x`）该文件的权限”。我们假设您是文件的所有者，并且它位于当前目录中。
- en: 'Then, we have to find the location of the command `python` on our computer.
    This is done by running the command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须找到计算机上命令 `python` 的位置。通过运行以下命令来完成：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you installed Python via Anaconda as described in [Section 1.1](cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml):
    *Installation and configuration instructions*, you will get information about
    the location of the command `python` on your system, for example, `/home/claus/anaconda3/bin/python`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您像在 [第 1.1 节](cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml) 中描述的那样通过 Anaconda
    安装 Python，则会获得有关命令 `python` 在您的系统上位置的信息，例如 `/home/claus/anaconda3/bin/python`。
- en: 'This information has to be written in the first line of a Python script to
    tell the system by which program the text file can be transformed into an executable.
    Here is an example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息必须写在 Python 脚本的第一行，以告知系统通过哪个程序可以将文本文件转换为可执行文件。以下是一个示例：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line in Python's view is just a comment and ignored. But Linux takes
    the rest of the first line after the so-called *shebang* combination, `#!`, as
    the command needed to transform the file into an executable. Here, it learns to
    use the command `python` located in the directory `/home/claus/anaconda3/bin/`
    for that purpose.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python视角中的第一行只是一个注释，会被忽略。但是Linux会将第一行中*shebang*组合符号`#!`之后的部分视为将文件转化为可执行文件所需的命令。这里，它学习使用位于目录`/home/claus/anaconda3/bin/`中的`python`命令来实现这一点。
- en: 'Instead of defining the location of the Python interpreter by an absolute path,
    we can define it also by a logical path, which would make the code more portable.
    You can give it to a colleague on a Linux system without any modification:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过逻辑路径来定义Python解释器的位置，而不是通过绝对路径，这样可以使代码更具可移植性。你可以将其提供给使用Linux系统的同事，而无需修改：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now you can execute the example code in the console directly; see *Figure 17.2*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以直接在控制台执行示例代码；见 *图 17.2*：
- en: '![](img/3f3e3e9d-b6e2-48b8-bd74-e9e4387fe99f.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f3e3e9d-b6e2-48b8-bd74-e9e4387fe99f.png)'
- en: 'Figure 17.2: Executing the example file example.py in a Linux terminal'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.2：在Linux终端中执行示例文件example.py
- en: We have to prefix the command with `./`, which tells the operating system that
    it should look in the current directory to find that command. If this prefix is
    not present, Linux expects the file `example.py` in one of the directories listed
    in the search path.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在命令前加上`./`，这告诉操作系统在当前目录中查找该命令。如果没有这个前缀，Linux会在搜索路径中列出的某个目录中查找文件`example.py`。
- en: In the next section, we will show how to provide a Python program with arguments
    given directly from the command line.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将展示如何直接从命令行传递参数给Python程序。
- en: 17.2 The module sys
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.2 sys模块
- en: The module `sys` provides tools to communicate from a Python script with system
    commands. We can provide the Python script as a command directly from the command
    line with arguments and we can output the results to the console.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`sys`提供了与系统命令进行通信的工具。我们可以直接从命令行传递带有参数的Python脚本，并将结果输出到控制台。
- en: 17.2.1 Command-line arguments
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.2.1 命令行参数
- en: 'To illustrate the use of command-line arguments, we consider the following
    piece of code, which we save in a file called `demo_cli.py`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明命令行参数的使用，我们考虑以下代码段，我们将其保存到名为`demo_cli.py`的文件中：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After giving execution permissions to the file by `chmod o+x demo_cli.py`,
    we can execute it in the shell with arguments; see *Figure 17.3*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过`chmod o+x demo_cli.py`给予文件执行权限后，我们可以在Shell中带参数执行它；见 *图 17.3*：
- en: '![](img/31c103d2-92cc-40dc-9de2-7f30adc91fe0.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31c103d2-92cc-40dc-9de2-7f30adc91fe0.png)'
- en: 'Figure 17.3: Executing a Python script with three arguments on a terminal command
    line'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3：在终端命令行上带三个参数执行Python脚本
- en: The three arguments given in the console are accessible in the Python script
    via the list `sys.argv`. The first element in this list—the element with index
    `0`—is the name of the script. The other elements are the given arguments as strings.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台中给出的三个参数可以通过列表`sys.argv`在Python脚本中访问。这个列表中的第一个元素——索引为`0`的元素——是脚本的名称。其他元素是给定的参数，作为字符串形式。
- en: Arguments are given to the call of the Python script. They should not be confounded
    with user input during the execution of a script.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是传递给Python脚本的调用。它们不应与脚本执行过程中用户输入的内容混淆。
- en: 17.2.2 Input and output streams
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.2.2 输入与输出流
- en: In the preceding example, we used the command `print` to display the generated
    message in the terminal (or even in the Python shell). A priory input to the script
    is obtained via arguments and the variable `sys.argv`. The counterpart to `print`
    is the command `input`, which prompts for data from the terminal (or from the
    Python shell).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了命令`print`来显示终端中生成的消息（甚至是在Python Shell中）。脚本的先前输入通过参数和变量`sys.argv`获取。与`print`相对的命令是`input`，它提示从终端（或Python
    Shell）获取数据。
- en: 'In [Section 14.1](f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml): *File handling*,
    we saw how to provide a script with data and how to output data from a script
    by the use of file objects and related methods. The module `sys` makes it possible
    to treat the keyboard as a file object for input (for example, `readline`, `readlines`)
    and the console as a file object for output (for example, `write`, `writelines`).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14.1节](f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml)：*文件处理*中，我们看到了如何通过文件对象和相关方法向脚本提供数据以及如何输出数据。模块`sys`使得可以将键盘当作输入的文件对象（例如，`readline`、`readlines`），而将控制台当作输出的文件对象（例如，`write`、`writelines`）。
- en: 'The information flow is organized in UNIX by three streams:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在UNIX中，信息流通过三个流组织：
- en: The standard input stream: `STDIN`
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准输入流：`STDIN`
- en: The standard output stream: `STDOUT`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准输出流：`STDOUT`
- en: The standard error stream: `STDERR`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准错误流：`STDERR`
- en: These streams correspond to file objects that can be accessed in Python by `sys.stdin`,
    `sys.stdout`, and `sys.stderr`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些流对应于文件对象，可以通过`sys.stdin`、`sys.stdout`和`sys.stderr`在Python中访问。
- en: 'To have an example, we consider a little script, `pyinput.py`, which sums up
    some numbers:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举个例子，我们考虑一个小脚本`pyinput.py`，它计算一些数字的总和：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The statement `sys.stdin.readlines()` establishes a generator. The command
    `array` iterates this generator until the user inputs an end-of-input symbol,
    which is `CTRL-D` on Linux systems or `CTRL-Z` on Windows systems. See the screenshot
    in *Figure 17.4*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 语句`sys.stdin.readlines()`创建了一个生成器。命令`array`会迭代这个生成器，直到用户输入结束符号，该符号在Linux系统上是`CTRL-D`，在Windows系统上是`CTRL-Z`。请参见*图17.4*中的截图：
- en: '![](img/2912df2b-e88e-4910-84d6-349e3d736b04.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2912df2b-e88e-4910-84d6-349e3d736b04.png)'
- en: 'Figure 17.4: Screenshot of the terminal execution of a script using sys.stdin.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.4：使用`sys.stdin`执行脚本的终端截图。
- en: Note, the given end-of-input symbol CTRL-D is not visible
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，给定的结束符号CTRL-D是不可见的。
- en: Redirecting streams
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重定向流
- en: 'The standard input is expecting a data stream from the keyboard. But the input
    can be redirected from a file instead. This is done by using the redirection symbol
    `<` in Linux. We demonstrate this by using the same script as previously, but
    now a data file, `intest.txt`, provides the script with data; see *Figure 17.5*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输入正在等待来自键盘的数据流。但输入可以通过文件进行重定向。通过在Linux中使用重定向符号`<`可以实现这一点。我们通过使用与之前相同的脚本，但这次由数据文件`intest.txt`提供数据来展示这一点；请参见*图17.5*：
- en: '![](img/52af1605-6205-48c6-83b6-7a35b7ff0861.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52af1605-6205-48c6-83b6-7a35b7ff0861.png)'
- en: 'Figure 17.5: Screenshot to demonstrate the redirection of input (sys.stdin)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5：展示输入重定向（`sys.stdin`）的截图
- en: No modification in the script itself is required. It can be used in either way.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本本身无需修改。无论哪种方式都可以使用。
- en: 'The same holds for outputs. By default the output is displayed in the terminal,
    but also here there is the option to redirect the output to a file. In that case,
    the redirect symbol is `>`; see *Figure 17.6*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出也是如此。默认情况下，输出会显示在终端中，但这里也有将输出重定向到文件的选项。在这种情况下，重定向符号是`>`；请参见*图17.6*：
- en: '![](img/088761b9-9929-4da9-a8e6-5a48d3981eaa.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/088761b9-9929-4da9-a8e6-5a48d3981eaa.png)'
- en: 'Figure 17.6: Screenshot of a redirected input and redirected output'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.6：重定向输入和重定向输出的截图
- en: Now, a file with the name `result.txt` is created and the output of the script
    is written to it. If there was already a file with this name, its content is overwritten.
    If instead the output should be appended to an already-existing file, the redirection
    symbol `>>` has to be used.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建了一个名为`result.txt`的文件，并将脚本的输出写入该文件。如果该文件已经存在，其内容将被覆盖。如果输出应该附加到已有文件的末尾，则必须使用重定向符号`>>`。
- en: Finally, it might sometimes be desired to separate the output from an error
    or warning message. That is the reason why Linux provides two stream channels
    for output, `sys.stdout` and `sys.stderr`. By default, both refer to the same
    place, the terminal. But with the use of redirection symbols, error messages can,
    for example, be written into a file while the main output is displayed on the
    screen or vice versa.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有时可能希望将输出与错误或警告信息分开。这就是Linux提供两个输出流通道的原因，分别是`sys.stdout`和`sys.stderr`。默认情况下，两者都指向同一个位置，即终端。但通过使用重定向符号，错误信息可以例如写入文件，而主输出则显示在屏幕上，或者反之亦然。
- en: 'To demonstrate this, we modify the example `pyinput.py` to generate an error
    message in case no input was provided:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们修改示例`pyinput.py`，以便在没有提供输入时生成错误信息：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A typical call of this script in a terminal window with redirected input and
    error output is presented in *Figure 17.7*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中，重定向输入和错误输出的脚本典型调用呈现在*图 17.7*中：
- en: '![](img/f5b7acb2-75d1-4fee-a747-a8b659caad9d.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5b7acb2-75d1-4fee-a747-a8b659caad9d.png)'
- en: 'Figure 17.7: Screenshot of a terminal window with redirection of stdin and
    stderr'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.7：带有标准输入和标准错误输出重定向的终端窗口截图
- en: In the case of an empty input file, an error message is written into the file
    `error.txt` while the output is in the terminal window.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入文件为空，错误信息会写入文件 `error.txt`，而输出则显示在终端窗口中。
- en: Error messages are those from uncaught exceptions, even syntax errors and text
    explicitly written to `sys.stderr`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息是来自未捕获异常的消息，包括语法错误和显式写入 `sys.stderr` 的文本。
- en: 'In *Table 17.1*, the different redirection situations are summarized:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在*表 17.1*中，汇总了不同的重定向情况：
- en: '| **Task** | **Python Object** | **Redirect Symbol** | **Alt. Symbol** |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **任务** | **Python 对象** | **重定向符号** | **替代符号** |'
- en: '| Data input | `sys.stdin` |  < |  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 数据输入 | `sys.stdin` |  < |  |'
- en: '| Data output | `sys.stdout` | > | 1> |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 数据输出 | `sys.stdout` | > | 1> |'
- en: '| Data output append to file | `sys.stdout` | >> | 1>> |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 数据输出附加到文件 | `sys.stdout` | >> | 1>> |'
- en: '| Error output | `sys.stderr` | 2> |  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 错误输出 | `sys.stderr` | 2> |  |'
- en: '| Error output append to file | `sys.stderr` | 2>> |  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 错误输出附加到文件 | `sys.stderr` | 2>> |  |'
- en: '| All output | `sys.stdout`, `sys.stderr` | &> |  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 所有输出 | `sys.stdout`, `sys.stderr` | &> |  |'
- en: '| All output append to file | `sys.stdout`, `sys.stderr` | &>> |  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 所有输出附加到文件 | `sys.stdout`, `sys.stderr` | &>> |  |'
- en: 'Table 17.1: Summary of different redirection scenarios'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表 17.1：不同重定向场景的汇总
- en: Building a pipe between a Linux command and a Python script
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 命令与 Python 脚本之间建立管道
- en: 'In the last section, we saw how to redirect the input and output of Python
    programs to files. The data flow between different Python programs or between
    a Python program and a Linux command goes, in that case, via a file. If the data
    is not used elsewhere or should be saved for later use, this is a tedious process:
    creating, naming, and deleting a file just for directly passing information from
    one piece of code to another. The alternative is to use a Linux **pipe** that
    lets the data flow in a direct stream from one command to another.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们展示了如何将 Python 程序的输入和输出重定向到文件。当不同 Python 程序之间，或者 Python 程序与 Linux 命令之间的数据流时，数据通常通过文件传递。如果数据不在其他地方使用或应当保留供以后使用，这个过程就显得冗长：仅仅为了直接将信息从一段代码传递到另一段代码，需要创建、命名和删除文件。替代方案是使用
    Linux **管道**，让数据从一个命令直接流向另一个命令。
- en: Let's start with a pure Linux example and then apply the pipe construction to
    Python.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个纯 Linux 示例开始，然后将管道构造应用于 Python。
- en: The Linux command `ifconfig` displays a lot of information about the actual
    network configuration of a Linux computer. Among this information, you find the
    IP number(s), which are the current network addresses in use. To automatically
    find out whether a computer, for example, a notebook, is connected via a certain
    network unit to the home network instead of to a foreign network, you would like
    to scan the output of `ifconfig` for a line containing the identifier for the
    network card, for example, `wlp0s20f3`, and some lines below for a string with
    the network prefix, for example, `192.168`. If this string is found, the output
    should be just the line with this string; that is, a line count would return `1`.
    If the computer is not connected to the home network, the line count returns `0`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 命令 `ifconfig` 显示有关 Linux 计算机当前网络配置的大量信息。在这些信息中，你可以找到 IP 地址（即当前使用的网络地址）。例如，要自动判断计算机（如笔记本电脑）是否通过某个网络单元连接到家庭网络，而不是连接到外部网络，你可能需要扫描
    `ifconfig` 的输出，查找包含网络适配器标识符（例如 `wlp0s20f3`）的行，并在其下几行中查找包含网络前缀的字符串（如 `192.168`）。如果找到这个字符串，输出应仅显示包含该字符串的行；即行数计数应返回
    `1`。如果计算机未连接到家庭网络，则行数计数返回 `0`。
- en: 'We use three commands:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用三个命令：
- en: '`ifconfig` for the entire lengthy network information.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifconfig` 用于显示完整的网络配置信息。'
- en: '`grep` for finding lines containing a certain pattern. The line and, if required
    by the parameter `-A`, some following lines are displayed.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep` 用于查找包含特定模式的行。该行及根据参数 `-A` 的要求，显示一些后续行。'
- en: '`wc` for doing various countings on a file. The argument `-l` specifies that
    lines should be counted.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wc` 用于对文件执行各种计数操作。参数 `-l` 指定计数行数。'
- en: 'The output of these commands is directly piped into the next command. This
    is done by using the pipe symbol `|`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令的输出会直接传递给下一个命令。这是通过使用管道符号 `|` 来实现的：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command line displays just `1` on the screen when executed in the home
    network. All the intermediate output is passed directly to the next command without
    displaying anything and without the use of any files to park temporarily the information
    until the next command reads it. The standard output, `stdout`, of one command
    becomes the standard input, `stdin`, of the next.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令行在家庭网络中执行时仅在屏幕上显示 `1`。所有中间输出直接传递到下一个命令，而无需显示任何内容，并且不使用任何文件来临时存放信息，直到下一个命令读取它。一个命令的标准输出，`stdout`，成为下一个命令的标准输入，`stdin`。
- en: This also applies directly to Python scripts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于 Python 脚本直接调用。
- en: 'We continue the previous example by demonstrating a Python script in the pipe.
    Here we simply use Python to generate a nice message:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在管道中演示 Python 脚本来继续上一个示例。在这里，我们简单地使用 Python 生成一个友好的消息：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can extend the pipe by adding this script; see the screenshot in *Figure
    17.8*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过添加此脚本扩展管道；请参见 *图 17.8* 中的截图：
- en: '![](img/bc1a59e2-9485-4ef0-802a-70c614b04370.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc1a59e2-9485-4ef0-802a-70c614b04370.png)'
- en: 'Figure 17.8: A command chain with five pipes and a Python script'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.8：带有五个管道和一个 Python 脚本的命令链
- en: In this example, we executed a chain of Linux programs and a Python script in
    the terminal window. Alternatively, it is possible to let the Python script call
    the UNIX commands. That will be demonstrated in the next section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们在终端窗口中执行了一系列 Linux 程序和一个 Python 脚本。或者，可以让 Python 脚本调用 UNIX 命令。这将在下一节中演示。
- en: 17.3 How to execute Linux commands from Python
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.3 如何从 Python 执行 Linux 命令
- en: We saw in the last section how to execute a Python command from the Linux terminal.
    In this section, we consider the important case of how to execute Linux commands
    within a Python program.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到如何从 Linux 终端执行 Python 命令。在本节中，我们考虑如何在 Python 程序中执行 Linux 命令的重要情况。
- en: 17.3.1 The modules subprocess and shlex
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.3.1 模块 subprocess 和 shlex
- en: To execute system commands within Python, we need to import the module `subprocess`
    first. The high-level tool provided by this module is `run`. With this tool, you
    quickly access Linux commands within Python and can process their output.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Python 中执行系统命令，首先需要导入模块 `subprocess`。此模块提供的高级工具是 `run`。使用此工具，您可以快速访问 Python
    中的 Linux 命令，并处理它们的输出。
- en: The more sophisticated tool is `Popen`, which we will shortly present when explaining
    how to mimic Linux pipes in Python.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的工具是 `Popen`，我们将在解释如何在 Python 中模拟 Linux 管道时进行简要介绍。
- en: 'A complete process: subprocess.run'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整的过程：subprocess.run
- en: We demonstrate this tool with the most standard and simple UNIX command, `ls`—the
    command for listing the content of a directory. It comes with various optional
    arguments; for example, `ls -l` displays the list with extended information.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过最标准和简单的 UNIX 命令 `ls` 来演示此工具——列出目录内容的命令。它带有各种可选参数；例如，`ls -l` 以扩展信息显示列表。
- en: 'To execute this command within a Python script, we use `subprocess.run`. The
    simplest usage is using only one argument, a list with the Linux command split
    into several text strings:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Python 脚本中执行此命令，我们使用 `subprocess.run`。最简单的用法是仅使用一个参数，将 Linux 命令拆分为几个文本字符串的列表：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The module `shlex` provides a special tool for performing this split:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 `shlex` 提供了一个特殊工具来执行此分割：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It also respects empty spaces in filenames and does not use those as separators.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 它还尊重文件名中的空格，并且不将其用作分隔符。
- en: The command `run` displays the result of the Linux command and the `subprocess.CompletedProcess`
    object `res`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `run` 显示 Linux 命令的结果和 `subprocess.CompletedProcess` 对象 `res`。
- en: 'To execute UNIX commands in this way is quite useless. Mostly, you want to
    process the output. Therefore, the output has to be made available to the Python
    script. For this, the optional parameter `capture_output` has to be set to `True`.
    By this, the `stdout` and `stderr` streams of the UNIX command become available
    as attributes of the return object:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式执行 UNIX 命令是相当无用的。大多数情况下，您希望处理输出。因此，必须将输出提供给 Python 脚本。为此，必须将可选参数 `capture_output`
    设置为 `True`。通过这种方式，UNIX 命令的 `stdout` 和 `stderr` 流将作为返回对象的属性可用：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note, the method `decode` is used here to decode a byte string to a standard
    string format.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此处使用方法 `decode` 将字节字符串解码为标准字符串格式。
- en: If the Linux command returns an error, the attribute `res.returncode` gets a
    nonzero value, and `res.stderr` contains the error message.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Linux 命令返回错误，属性 `res.returncode` 将获得非零值，并且 `res.stderr` 包含错误消息。
- en: 'The Python way would be that an error is raised instead. This can be achieved
    by setting the optional parameter `check` to `True`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python的做法是抛出一个错误。可以通过将可选参数`check`设置为`True`来实现：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Creating processes: subprocess.Popen'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建进程：subprocess.Popen
- en: What happens when you apply `subprocess.run` on a Linux command that starts
    a process that requires user input to terminate?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对一个需要用户输入才能终止的进程应用`subprocess.run`时会发生什么？
- en: A simple example of such a program is `xclock`. It opens a new window displaying
    a clock until the window is closed by the user.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个程序的简单示例是`xclock`。它打开一个新窗口，显示一个时钟，直到用户关闭窗口。
- en: 'As the command `subprocess.run` creates a `CompletedProcess` object, the following
    Python script:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命令`subprocess.run`创建了一个`CompletedProcess`对象，下面的Python脚本：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'starts a process and waits until it ends, that is, until somebody closes the
    window with the clock; see *Figure 17.9*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个进程并等待它结束，也就是说，直到有人关闭带有时钟的窗口；参见*图17.9*：
- en: '![](img/48e32eb1-a323-4ac4-b52e-04911dcedb91.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48e32eb1-a323-4ac4-b52e-04911dcedb91.png)'
- en: 'Figure 17.9: The xclock window'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.9：xclock窗口
- en: 'This makes a difference to `subprocess.Popen`. It creates a _`Popen` object.
    The process itself becomes a Python object. It need not be completed to become
    an accessible Python object:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这对`subprocess.Popen`有影响。它创建了一个_`Popen`对象。进程本身变成了一个Python对象。它不需要完成才能成为一个可访问的Python对象：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The process is completed by either a user action on the clock window or by
    explicitly terminating the process with:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 进程通过用户在时钟窗口上的操作或通过显式终止进程来完成，命令如下：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With `Popen`, we can construct Linux pipes in Python. The following script:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Popen`，我们可以在Python中构建Linux管道。下面的脚本：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Corresponds to the UNIX pipe:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对应于UNIX管道：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It displays all files in a directory last accessed in April.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了在四月最后访问的目录中的所有文件。
- en: The module `subprocess` has an object `PIPE` that takes the output of the first
    process `p1`. It is then passed as `stdin` to the command `run`. This command
    then returns a `CompletedProcess` object `cp2` with the attribute `stdout` of
    type `bytes`. Finally, calling the method `decode` allows a nice print of the
    results.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`subprocess`有一个对象`PIPE`，它接受第一个进程`p1`的输出。然后，它被作为`stdin`传递给命令`run`。该命令然后返回一个带有`stdout`属性（类型为`bytes`）的`CompletedProcess`对象`cp2`。最后，调用方法`decode`可以很好地打印结果。
- en: 'Alternatively, the same could be achieved by using two `Popen` processes. The
    second also uses a pipe that can be displayed through the method `communicate`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，也可以通过使用两个`Popen`进程来实现相同的效果。第二个进程也使用管道，可以通过方法`communicate`进行显示：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The method `communicate` returns a tuple with the output on `stdout` and `stderr`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`communicate`返回一个元组，其中包含`stdout`和`stderr`上的输出。
- en: 17.4 Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.4 小结
- en: In this chapter, we demonstrated the interaction of a Python script with system
    commands. Either a Python script can be called in a way as if it would be a system
    command or a Python script can itself create system processes. The chapter is
    based on Linux systems such as Ubuntu and serves only as a demonstration of concepts
    and possibilities. It allows putting scientific computing tasks in an application
    context, where often different software have to be combined. Even hardware components
    might come into play.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们演示了Python脚本与系统命令的交互。Python脚本可以像系统命令一样被调用，或者Python脚本本身可以创建系统进程。本章基于Linux系统，如Ubuntu，仅作为概念和可能性的演示。它允许将科学计算任务置于应用场景中，在这些场景中，通常需要将不同的软件结合起来。甚至硬件组件可能也会涉及其中。
