- en: Grouping, Merging, and Reshaping Data in pandas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在pandas中分组、合并和重塑数据
- en: In this chapter, we'll tackle the question of rearranging and reshaping data
    in our data structures. We'll examine the various functions that enable us to
    rearrange data by utilizing them on real-world datasets. Such functions include
    `groupby`, `concat`, `aggregate`, `append`, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨如何在我们的数据结构中重新排列和重塑数据。我们将通过对真实世界数据集应用不同的函数来审视使我们能够重新排列数据的各种函数。这些函数包括`groupby`、`concat`、`aggregate`、`append`等。
- en: 'The topics that we''ll discuss in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论以下主题：
- en: Aggregating/grouping data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合/分组数据
- en: Merging and concatenating data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并和连接数据
- en: Reshaping data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据重塑
- en: Other methods for reshaping DataFrames
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重塑DataFrame的其他方法
- en: Grouping data
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组数据
- en: 'Grouping data is vital to arrive at key conclusions at an initial exploratory
    analysis phase. For example, when you deal with a retail dataset with variables
    such as *OrderID, CustomerID, Shipping Date, Product Category, Sales Region, Quantity
    Ordered, Cancelation Status, Total Sales, Profit, Discount,* and others,grouping
    the data and aggregating it helps you to arrive at answers to questions such as
    those that follow:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分组对于在初步探索性分析阶段得出关键结论至关重要。例如，当你处理一个零售数据集，数据集包含*OrderID、CustomerID、Shipping
    Date、Product Category、Sales Region、Quantity Ordered、Cancelation Status、Total Sales、Profit、Discount*等变量时，分组数据并进行聚合可以帮助你回答以下类似问题：
- en: Which region was the most profitable?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个地区最具盈利性？
- en: Which product category had the most cancelations?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个产品类别的取消率最高？
- en: What percent of customers contribute to 80% of the profit?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些客户贡献了80%的利润？
- en: Grouping involves aggregating across each category. Aggregation may involve
    operations such as count, sum, exponent, or implementing a complex user-defined
    function. The `groupby` function of pandas helps with grouping. This is not much
    different from the `groupby` query in SQL.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 分组涉及在每个类别下进行聚合。聚合可能包括计数、求和、求指数或实现复杂的用户定义函数。pandas的`groupby`函数有助于分组。这与SQL中的`groupby`查询并没有太大区别。
- en: The groupby operation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: groupby操作
- en: 'Through a `groupby` function, a chain of actions gets executed: splitting,
    applying, and combining. Splitting segments each category from the desired grouping
    variable to perform further operations with it. Then, functions can be individually
    applied across each of these split groups. These functions might involve aggregation
    (sum across a group or mean across a group), transformation (filling NAs within
    a group or sorting), filtration (applying conditions within a group to drop rows),
    or even a combination of these three operations. Finally, the results obtained
    after the functions are applied across each of the split groups are combined together.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`groupby`函数，一系列操作被执行：拆分、应用和合并。拆分将每个类别从所需的分组变量中分离出来，以便对其执行进一步操作。然后，函数可以单独应用于这些拆分后的每个组。这些函数可能涉及聚合（对组进行求和或求均值）、转换（填充组内的NA值或排序）、过滤（在组内应用条件以删除行），甚至是这三种操作的组合。最后，在每个拆分组应用函数后，得到的结果会被合并在一起。
- en: 'Let''s use sample data from a fictitious global retailer. The data available
    as CSV is read as a pandas DataFrame:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用来自一个虚构全球零售商的示例数据。以CSV格式提供的数据被读取为pandas DataFrame：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `head` function will give us a quick glimpse of the dataset we just imported:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`函数将让我们快速浏览刚导入的数据集：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following will be the output:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/bcf0a6c6-1720-4dee-adfc-20c36448a3fa.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcf0a6c6-1720-4dee-adfc-20c36448a3fa.png)'
- en: Snapshot of sample sales data
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 示例销售数据的快照
- en: While a sample of five rows has been shown in the preceding output, the data
    contains 51,290 rows and 15 columns.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在前面的输出中展示了五行数据，但数据总共包含51,290行和15列。
- en: 'Now, to understand how `groupby` splits the data, let''s split it by the `Category`
    variable. The object created is not a DataFrame but rather an object type unique
    to the `groupby` function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了理解`groupby`如何拆分数据，我们按`Category`变量进行拆分。所创建的对象不是DataFrame，而是`groupby`函数特有的对象类型：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The grouping object is referred to as the key. Here, `Category` is the key.
    The groups under the `groupby` object created in the previous step are shown here.
    You can see that each group in `Category` is mapped to the row-index labels covered
    by each category:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 分组对象被称为键。在这里，`Category`就是键。前一步创建的`groupby`对象下的各个组如图所示。你可以看到，每个`Category`中的组都映射到每个类别所覆盖的行索引标签：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following will be the output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/edab4c50-68a7-4d0d-a1e6-a1e882fb9bc2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edab4c50-68a7-4d0d-a1e6-a1e882fb9bc2.png)'
- en: Information for each group
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组的信息
- en: 'The data has four quantitative variables: `Quantity`, `Sales`, `Discount`,
    and `Profit`. Using `groupby`, let''s compute the sum of all these four variables
    across each `Category`. This is an application of aggregation with `groupby`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 数据有四个定量变量：`Quantity`（数量）、`Sales`（销售额）、`Discount`（折扣）和`Profit`（利润）。使用`groupby`，我们来计算每个`Category`（类别）中的这四个变量的总和。这是聚合与`groupby`结合的应用：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following will be the output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/1a2acde3-97d0-4c21-be06-b6f951325fee.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a2acde3-97d0-4c21-be06-b6f951325fee.png)'
- en: Results of groupby and summing
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 分组和求和的结果
- en: 'Modify the code slightly, as shown here, to compute only the sum of sales.
    This involves subsetting the data right before applying `groupby`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微修改代码，如下所示，来计算仅销售额的总和。这涉及在应用`groupby`之前对数据进行子集选择：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following will be the output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/57784647-3ea2-4f59-8078-f78624504dbe.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57784647-3ea2-4f59-8078-f78624504dbe.png)'
- en: groupby and sum across one variable
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 根据一个变量进行`groupby`和求和
- en: 'Aggregation need not be applied across only a quantitative variable. Now, using
    `groupby`, let''s find the `Country` in which each category was first ordered:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合不一定仅限于定量变量。现在，使用`groupby`，让我们找出每个类别首次下单的`Country`（国家）：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following will be the output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/a86594b7-6ffd-4efc-b61d-194b6afac555.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a86594b7-6ffd-4efc-b61d-194b6afac555.png)'
- en: Using the aggregate first along with groupby
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 先使用聚合再进行分组
- en: 'The `size()` function helps to find the number of occurrences of each `Category`.
    After computing `size`, let''s explore the transformation ability of `groupby`
    by sorting the results:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`size()`函数有助于找到每个`Category`（类别）的出现次数。在计算`size`之后，我们通过排序结果来探索`groupby`的变换能力：'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following will be the output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/f44a750b-9060-42c4-bf4c-903a4ae1c2f7.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f44a750b-9060-42c4-bf4c-903a4ae1c2f7.png)'
- en: Aggregation of size after sorting
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 排序后的聚合大小
- en: 'The key or grouping object need not necessarily be an existing column; it can
    also be a function defining a grouping rule. For example, from `OrderDate`, we
    can extract the year and then `groupby` the year in which orders were placed.
    For this, the index is first set to `OrderDate`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 分组的键或分组对象不一定是现有的列；它也可以是定义分组规则的函数。例如，我们可以从`OrderDate`（订单日期）中提取年份，然后按年份进行`groupby`。为此，首先将索引设置为`OrderDate`：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following will be the output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/f2590d6d-1154-4c13-8a81-cb716d75dfb4.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2590d6d-1154-4c13-8a81-cb716d75dfb4.png)'
- en: Groupby to group variables created via a custom& function
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义函数进行分组
- en: 'It is also possible to group by more than one key. Here, let''s group by `ShipMode `and
    `Category `to aggregate by the number of observations. The `groupby` function
    accepts multiple variables as a list:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以根据多个键进行分组。在这里，我们通过`ShipMode`（运输方式）和`Category`（类别）进行分组，以按观察数量进行聚合。`groupby`函数接受一个包含多个变量的列表：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following will be the output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/06986d90-88b0-4d56-a6de-a971031143e4.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06986d90-88b0-4d56-a6de-a971031143e4.png)'
- en: Aggregate of size across two grouping variables
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据两个分组变量进行大小聚合
- en: 'The `get_group()` attribute of the `groupby` function allows data to be filtered
    by one category out of all of the categories available in the group:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby`函数的`get_group()`属性允许根据一个类别过滤数据，从所有类别中选择：'
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following will be the output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/1fc9c1c3-fabf-4aa7-b6d0-56188829e0ec.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fc9c1c3-fabf-4aa7-b6d0-56188829e0ec.png)'
- en: The `get_group` attribute of groupby
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby`的`get_group`属性'
- en: 'The `groupby` object produced by the `groupby` function is iterable. Let''s
    iterate over a simple `groupby` object:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby`函数生成的`groupby`对象是可迭代的。让我们遍历一个简单的`groupby`对象：'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following will be the output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/6fa6ede3-19f0-4fe7-9bab-829bfa19904c.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fa6ede3-19f0-4fe7-9bab-829bfa19904c.png)'
- en: Iterating through the groupby object
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历groupby对象
- en: 'Instead of grouping by a column name, an index can also be used. When using
    an index, the level can be specified in place of the index name. Let''s set `Region `as
    an index to demonstrate this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以根据列名进行分组，也可以使用索引进行分组。在使用索引时，可以指定索引名的层级。让我们设置`Region`（地区）为索引来演示这一点：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following will be the output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/b1c1c5b2-5987-4053-a759-2c3cf5f80dcc.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1c1c5b2-5987-4053-a759-2c3cf5f80dcc.png)'
- en: Grouping with index
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引进行分组
- en: '`groupby `aggregations need not always occur along a column. If required, items
    can be grouped and aggregated along a row by changing the `axis` argument. The
    default setting of the `axis` argument is `0`. Changing it to `axis =  1 `groups
    items along a row:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby` 聚合操作不一定总是沿着某一列进行。如果需要，可以通过更改 `axis` 参数将项目沿着行进行分组和聚合。`axis` 参数的默认设置是
    `0`。将其更改为 `axis = 1` 会将项目沿行进行分组：'
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using groupby with a MultiIndex
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 MultiIndex 上使用 groupby
- en: Let's explore how the `groupby` function works for hierarchically indexed data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 `groupby` 函数如何在分层索引数据中工作。
- en: 'To start with, we can assign two indices to the sample sales data, as shown:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以为示例销售数据分配两个索引，如下所示：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following will be the output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/8596f393-eefc-4ad1-938c-d96d733d66a0.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8596f393-eefc-4ad1-938c-d96d733d66a0.png)'
- en: Snapshot of multi-indexed data
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 多级索引数据的快照
- en: 'Grouping by an index can be done by specifying either the level number or the
    index name:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 按索引分组可以通过指定级别数字或索引名称来实现：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following will be the output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/ce9d8a8b-c144-40a7-9741-534456bd86c2.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce9d8a8b-c144-40a7-9741-534456bd86c2.png)'
- en: The level attribute of groupby
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: groupby 的 `level` 属性
- en: 'The `level` parameter can take names as well instead of numbers as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`level` 参数也可以使用名称而不是数字，如下所示：'
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following will be the output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/11a3d0a5-81ae-4919-bc1f-6eaa0f1f2701.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11a3d0a5-81ae-4919-bc1f-6eaa0f1f2701.png)'
- en: Using the level name to group by
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用级别名称进行分组
- en: 'Index names can be used directly as keys, as shown:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接将索引名称用作键，如下所示：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This results in the following output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出结果：
- en: '![](img/f61d3aeb-42b1-4124-846d-b85e16b75612.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f61d3aeb-42b1-4124-846d-b85e16b75612.png)'
- en: Providing index names as the key
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将索引名称作为键提供
- en: 'Multiple indices can also be passed through the `level` argument of `groupby `to
    obtain the same result as the preceding one:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过 `groupby` 的 `level` 参数传递多个索引，以获得与前述相同的结果：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following will be the output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/fab41586-1523-4031-99d5-d18694ec280b.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fab41586-1523-4031-99d5-d18694ec280b.png)'
- en: Groupby for multiple indexes
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 groupby 进行多索引操作
- en: 'When grouping by index, the aggregation functions can directly take up the
    `level` parameter to enable splitting across groups. Here, we have grouped across
    both levels by specifying the `level` number. Instead of the `level` number, the
    index name can also be specified:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当按索引分组时，聚合函数可以直接使用 `level` 参数来实现按组拆分。在这里，我们通过指定 `level` 数字实现了对两个级别的分组。除了 `level`
    数字，还可以使用索引名称来指定：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following will be the output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/743f2b0e-14f0-4967-a404-7f3f48f79a3e.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/743f2b0e-14f0-4967-a404-7f3f48f79a3e.png)'
- en: Multi-index grouping with the level parameter
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `level` 参数的多级索引分组
- en: 'To group by both index and column name, the following method can be used. The
    level number provided here can also be replaced with the level name. Instead of
    using the `Grouper` function, the index name and column name can be provided as
    a list of keys:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 若要按索引和列名同时进行分组，可以使用以下方法。此处提供的级别数字也可以用级别名称替代。在不使用 `Grouper` 函数的情况下，可以将索引名称和列名作为键的列表提供：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following will be the output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/ff2ca38a-32ab-4df0-9038-8b662d7b0826.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff2ca38a-32ab-4df0-9038-8b662d7b0826.png)'
- en: Using normal columns and index columns together for grouping
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用普通列和索引列一起进行分组
- en: 'Let''s take `groupby` a notch further and apply some data transformation to
    the results. We will begin by computing the ratio of total sales, quantity, profit,
    and discount with respect to the overall `Sales`, `Quantity`, `Profit`, and `Discount`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `groupby` 提升到一个新层次，并对结果应用数据转换。我们将开始计算总销售额、数量、利润和折扣相对于总体 `Sales`、`Quantity`、`Profit`
    和 `Discount` 的比例：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following will be the output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/74a25962-4717-44d9-aee1-11f24a7c6d37.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74a25962-4717-44d9-aee1-11f24a7c6d37.png)'
- en: Groupby to evaluate complex calculations
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 groupby 进行复杂计算评估
- en: 'This results in a series. Remember the `transpose` function from NumPy? Similarly,
    a DataFrame can be transposed as well. However, the output just obtained is a
    series and not a DataFrame. Before transposing, the series has to be converted
    to a DataFrame:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成一个系列。还记得 NumPy 中的 `transpose` 函数吗？同样，DataFrame 也可以进行转置。然而，刚才得到的输出是一个系列，而不是
    DataFrame。转置之前，必须先将系列转换为 DataFrame：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following will be the output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/52fe431e-0691-4cfb-b26f-0247d8d4444b.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52fe431e-0691-4cfb-b26f-0247d8d4444b.png)'
- en: Intermediate result of data transformation
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 数据转换的中间结果
- en: 'The index label in the result is `0`. Let''s rename it to a more appropriate
    label using the following snippet. The output is also shown in the screenshot
    that follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 结果中的索引标签是 `0`。我们可以使用以下代码将其重命名为更合适的标签，输出结果也显示在后续截图中：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Take a look at the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下截图：
- en: '![](img/10b645bc-aeeb-4838-89cc-254374fff7f9.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10b645bc-aeeb-4838-89cc-254374fff7f9.png)'
- en: Result of data transformation
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 数据转换结果
- en: Using the aggregate method
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用聚合方法
- en: 'In all of the previous use cases, we used sum aggregation. We were directly
    able to use `sum` without going through the `aggregate` function of Python. The `sum()`
    function that we used is a Cython-optimized implementation. Some other Cython-optimized
    implementations are `mean`, `std`, and `sem` (standard error of the mean). To
    implement other functions or a combination of aggregations, the `aggregate` function
    comes in handy:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的使用案例中，我们使用了求和聚合。我们能够直接使用 `sum`，而无需经过 Python 的 `aggregate` 函数。我们使用的 `sum()`
    函数是 Cython 优化的实现。其他一些 Cython 优化的实现包括 `mean`、`std` 和 `sem`（标准误差）。为了实现其他函数或聚合的组合，`aggregate`
    函数非常有用：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following will be the output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/6aea7e66-b914-4d4b-95de-20fa6004e452.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6aea7e66-b914-4d4b-95de-20fa6004e452.png)'
- en: Use of the aggregate function
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用聚合函数
- en: All the rules discussed in the sections on handling multiple keys and indices
    are applicable here as well.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理多个键和索引的章节中讨论的所有规则在此处同样适用。
- en: 'Please note that when using multiple keys or Multiindex, the result has a hierarchical
    ordering in indices. To overcome this, you can use the `reset_index` attribute
    of DataFrames:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在使用多个键或多重索引时，结果在索引中会有层次顺序。为了克服这一点，您可以使用 DataFrame 的 `reset_index` 属性：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following will be the output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/71375e84-b550-4424-86a7-a0094780b43d.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71375e84-b550-4424-86a7-a0094780b43d.png)'
- en: The aggregate function for multiple columns
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 多列的聚合函数
- en: 'The index of the output can be reset using the following snippet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码重置输出的索引：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following will be the output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/2fc7c293-f9bb-4314-813e-4bbd3c482d32.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fc7c293-f9bb-4314-813e-4bbd3c482d32.png)'
- en: The aggregate function for multiple grouping variables
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 多重分组变量的聚合函数
- en: 'To achieve the same results, in place of `reset_index`, the `as_index` parameter
    of `groupby` can be set to `False`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现相同的结果，可以将 `groupby` 的 `as_index` 参数设置为 `False`，而不使用 `reset_index`：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Like the implementation of the `sum` function, the following is a list of other
    functions that can be applied to `groupby` objects:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `sum` 函数的实现类似，以下是可以应用于 `groupby` 对象的其他函数列表：
- en: '| **Function** | **Description** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `mean()` | Compute mean of groups |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `mean()` | 计算组的平均值 |'
- en: '| `sum()` | Compute sum of group values |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `sum()` | 计算组值的总和 |'
- en: '| `size()` | Compute group sizes |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 计算组的大小 |'
- en: '| `count()` | Compute count of group |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `count()` | 计算组的数量 |'
- en: '| `std()` | Standard deviation of groups |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `std()` | 计算组的标准差 |'
- en: '| `var()` | Compute variance of groups |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `var()` | 计算组的方差 |'
- en: '| `sem()` | Standard error of the mean of groups |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `sem()` | 计算组的标准误差 |'
- en: '| `describe()` | Generate descriptive statistics |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `describe()` | 生成描述性统计 |'
- en: '| `first()` | Compute first of group values |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `first()` | 计算组值中的第一个 |'
- en: '| `last()` | Compute last of group values |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `last()` | 计算组值中的最后一个 |'
- en: '| `nth()` | Take nth value, or a subset if n is a list |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `nth()` | 获取第 n 个值，或者如果 n 是列表，则获取子集 |'
- en: '| `min()` | Compute min of group values |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `min()` | 计算组值的最小值 |'
- en: '| `max()` | Compute max of group values |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `max()` | 计算组值的最大值 |'
- en: 'Table 6.1: List of all aggregate functions'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1：所有聚合函数列表
- en: Applying multiple functions
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用多个函数
- en: 'For any DataFrame, a list of aggregations can be performed after applying `groupby`.
    In the following example, the mean and standard deviation have been computed for
    `Sales` and `Quantity`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何 DataFrame，在应用 `groupby` 后可以执行一系列聚合操作。在下面的示例中，我们计算了 `Sales` 和 `Quantity`
    的平均值和标准差：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following will be the output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/c2f99b80-8e48-4fd2-ac16-5e5b614b4c63.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2f99b80-8e48-4fd2-ac16-5e5b614b4c63.png)'
- en: Multiple aggregations
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 多重聚合
- en: Note that hierarchy has also been introduced in the column index. `agg` is a
    short form of aggregate. These aggregations will exclude any NAs found for computation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，列索引中也引入了层次结构。`agg` 是聚合的缩写。这些聚合会排除任何 NA 值进行计算。
- en: 'In the preceding example, columns were created with the `mean` and `std `labels.
    Let''s try renaming them. The `rename` argument maps the new name onto the old
    name:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，创建了带有 `mean` 和 `std` 标签的列。让我们尝试重命名这些列。`rename` 参数将新名称映射到旧名称：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following will be the output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是输出结果：
- en: '![](img/ac9f0eda-4a19-4d7b-92d5-6db90a724b2c.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac9f0eda-4a19-4d7b-92d5-6db90a724b2c.png)'
- en: Different aggregates for each column
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每列的不同聚合
- en: 'To apply selected functions to selected columns, the following convention can
    be used. For example, here, the sum of `Sales` and the mean of `Quantity` have
    been computed:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要对选定的列应用选定的函数，可以使用以下约定。例如，这里计算了 `Sales` 的总和和 `Quantity` 的均值：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/e8b130f1-5fbf-4e92-8fbf-6c04d063d6ca.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8b130f1-5fbf-4e92-8fbf-6c04d063d6ca.png)'
- en: Renaming columns after aggregation
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合后重命名列
- en: The transform() method
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`transform()` 方法'
- en: The `transform` function in `groupby` is used to perform transformation operations
    on a `groupby` object. For example, we could replace NaN values in the `groupby`
    object using the `fillna` method. The resultant object after using `transform`
    has the same size as the original `groupby` object.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby` 中的 `transform` 函数用于对 `groupby` 对象执行转换操作。例如，我们可以使用 `fillna` 方法替换 `groupby`
    对象中的 NaN 值。使用 `transform` 后的结果对象与原始 `groupby` 对象大小相同。'
- en: 'Let''s introduce NAs into the sample sales data. The following code injects
    NAs into 25% of the records:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向示例销售数据中引入 NAs。以下代码将 NAs 注入 25% 的记录中：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following will be the output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是输出结果：
- en: '![](img/0fd700e6-42e7-45e6-8ec1-b18d49204f91.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fd700e6-42e7-45e6-8ec1-b18d49204f91.png)'
- en: Snapshot of data with NAs inserted
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 插入 NAs 后的数据快照
- en: 'Now, the four quantitative variables contain NAs in 25% of the rows, and `Category`
    is set as the index. A simple `groupby` and `count` aggregation will give the
    number of non-NA values in each column for each category:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，四个定量变量在 25% 的行中包含 NA，`Category` 被设置为索引。简单的 `groupby` 和 `count` 聚合将显示每个类别中每列非
    NA 值的数量：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following will be the output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是输出结果：
- en: '![](img/7b00bfdf-e910-44c3-b27a-8634e551bc7f.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b00bfdf-e910-44c3-b27a-8634e551bc7f.png)'
- en: Count of non-NA values
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 非 NA 值的计数
- en: 'The `transform()` function fills the NAs with the mean of each group:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform()` 函数用每组的均值填充 NAs：'
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following will be the output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是输出结果：
- en: '![](img/04cf6412-aa6b-4a05-8652-26f60e0f95ba.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04cf6412-aa6b-4a05-8652-26f60e0f95ba.png)'
- en: Using transform to fill NAs
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 transform 填充 NAs
- en: 'The result shows that `transform()` performs group-specific NA handling. The
    count of non-NAs can be seen to have increased:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，`transform()` 执行了按组处理 NA。可以看到非 NA 的计数有所增加：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following will be the output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是输出结果：
- en: '![](img/813570b2-6ab7-46b3-9e0a-7f7026e60a1e.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/813570b2-6ab7-46b3-9e0a-7f7026e60a1e.png)'
- en: Count of non-NAs after transformation
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后的非 NA 值计数
- en: 'To verify the operation, let''s compare averages of the groups before and after
    transformation. The outputs from the two methods are found to be equal as shown
    following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证操作，让我们比较转换前后各组的均值。通过以下代码可以看到两种方法的输出结果相等：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following will be the output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是输出结果：
- en: '![](img/65edcccf-0941-422f-acae-0f9c0ba45e96.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65edcccf-0941-422f-acae-0f9c0ba45e96.png)'
- en: Group means before transformation
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 转换前的组均值
- en: 'Calculating the mean using the object obtained from the transform method can
    be done as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从 `transform` 方法获得的对象来计算均值，可以按如下方式进行：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following will be the output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是输出结果：
- en: '![](img/324c6a91-1599-45b7-a3bd-181fa2418e25.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/324c6a91-1599-45b7-a3bd-181fa2418e25.png)'
- en: Group means after transformation
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后的组均值
- en: 'Some functions, such as `bfill()` (backward fill), `ffill()` (forward fill),
    `fillna()`, and `shift()` can perform transformation by themselves, without the
    need for the `transform()` function:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数，如 `bfill()`（向后填充）、`ffill()`（向前填充）、`fillna()` 和 `shift()` 可以自行执行转换，而不需要
    `transform()` 函数：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following will be the output:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是输出结果：
- en: '![](img/00dc4098-1d60-4637-8836-8a7e224917c2.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00dc4098-1d60-4637-8836-8a7e224917c2.png)'
- en: Transformation with backward fill
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 向后填充的转换
- en: 'Operations such as `rolling()`, `resample()`, and `expanding()` can also be
    used as methods on `groupby`. `rolling() `aggregates values in moving windows,
    `expanding()` cumulates the aggregates, and `resample()` helps to bring regular
    frequency to time-series data with forward fill or backward fill:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`rolling()`、`resample()` 和 `expanding()` 等操作也可以作为方法在 `groupby` 上使用。`rolling()`
    对值进行移动窗口聚合，`expanding()` 累积聚合，`resample()` 帮助将时间序列数据转换为规则的频率，支持向前填充或向后填充：'
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding example of `expanding()` calculates a cumulative sum within each
    group.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个 `expanding()` 示例计算了每个组内的累积和。
- en: Filtering
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤
- en: The `filter` method enables us to apply filtering to a `groupby` object to result
    in a subset of the initial object.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 方法使我们能够对 `groupby` 对象应用过滤，从而得到初始对象的子集。'
- en: 'Let''s apply `filter `to the sample sales data to compute only the sums of
    those groups whose length is more than `10000`, when grouped across `Category`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对示例销售数据应用 `filter`，仅计算那些组的总和，其长度大于 `10000`，当按 `Category` 分组时：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following will be the output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是输出：
- en: '![](img/d4430aea-88b6-4c3a-8304-ec0ab74c01d4.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4430aea-88b6-4c3a-8304-ec0ab74c01d4.png)'
- en: Filtering with groupby
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 groupby 进行过滤
- en: Now, as you can see, filtering removes the `Furniture` category, whose length
    is less than `10000`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你所看到的，过滤移除了 `Furniture` 类别，因为它的长度小于 `10000`。
- en: Merging and joining
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并与连接
- en: 'There are various functions that can be used to merge and join pandas data
    structures, which include the following functions:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种函数可以用来合并和连接 pandas 数据结构，其中包括以下函数：
- en: '`concat`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concat`'
- en: '`append`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append`'
- en: '`join`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join`'
- en: The concat function
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: concat 函数
- en: 'The `concat` function is used to join multiple pandas data structures along
    a specified axis and possibly perform union or intersection operations along other
    axes. The following command explains the `concat` function:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat` 函数用于在指定的轴上连接多个 pandas 数据结构，并可能在其他轴上执行并集或交集操作。以下命令解释了 `concat` 函数：'
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The elements of the `concat` function can be summarized as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat` 函数的元素可以总结如下：'
- en: 'The `objs` function: A list or dictionary of Series, DataFrame, or Panel objects
    to be concatenated.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objs` 函数：一个 Series、DataFrame 或 Panel 对象的列表或字典，待拼接。'
- en: 'The `axis` function: The axis along which the concatenation should be performed.
    `0` is the default value.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`axis` 函数：指定应执行拼接的轴。`0` 是默认值。'
- en: 'The `join` function: The type of join to perform when handling indexes on other
    axes. The `''outer''` function is the default.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join` 函数：在处理其他轴的索引时执行的连接类型。`''outer''` 是默认值。'
- en: 'The `join_axes` function: This is used to specify exact indexes for the remaining
    indexes instead of doing an outer/inner join.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join_axes` 函数：用于指定其余索引的精确索引，而不是执行外连接/内连接。'
- en: 'The `keys` function: This specifies a list of keys to be used to construct
    a MultiIndex.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keys` 函数：指定用于构建 MultiIndex 的键列表。'
- en: For an explanation of the remaining options, please refer to the documentation
    at [http://pandas.pydata.org/pandas-docs/stable/merging.html](http://pandas.pydata.org/pandas-docs/stable/merging.html).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有关其余选项的解释，请参考文档：[http://pandas.pydata.org/pandas-docs/stable/merging.html](http://pandas.pydata.org/pandas-docs/stable/merging.html)。
- en: 'Here is an illustration of the workings of `concat` using our stock price examples
    from earlier chapters:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用我们前面章节中的股票价格示例来说明 `concat` 的工作原理：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We now take various slices of the data:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对数据进行不同的切片：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, we perform concatenation by specifying an outer join, which concatenates
    and performs a union on all three DataFrames and includes entries that do not
    have values for all the columns by inserting `NaN` for such columns:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过指定外连接来执行拼接，该操作会将三个 DataFrame 连接并执行并集，并包括没有所有列值的条目，通过插入 `NaN` 来填充这些列：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can also specify an inner join that performs concatenation but only includes
    rows that contain values for all the columns in the final DataFrame by throwing
    out rows with missing columns; that is, it takes the intersection:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定内连接，执行拼接但仅包括包含所有列值的行，从而去除缺少列的行；也就是说，它取的是交集：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The third case enables us to use the specific index from the original DataFrame
    to join on:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个案例使我们可以使用原始 DataFrame 中的特定索引进行连接：
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In this last case, we see that the `YHOO `row was included even though it wasn''t
    contained in any of the slices that were concatenated. In this case, however,
    the values for all the columns are `NaN`. Here is another illustration of `concat`,
    but this time, it is on random statistical distributions. Note that in the absence
    of an `axis` argument, the default axis of concatenation is `0`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的这个案例中，我们看到 `YHOO` 行被包含进来了，尽管它没有包含在任何被拼接的切片中。然而，在这种情况下，所有列的值都是 `NaN`。这是 `concat`
    的另一个示例，但这次它是在随机统计分布上进行的。请注意，如果没有 `axis` 参数，拼接的默认轴是 `0`：
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Using append
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 append
- en: '`append` is a simpler version of `concat` that concatenates along `axis=0`.
    Here is an illustration of its use, where we slice out the first two rows and
    the first three columns of the `stockData` DataFrame:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`append` 是 `concat` 的简化版本，按 `axis=0` 进行拼接。以下是它的使用示例，我们将 `stockData` DataFrame
    中的前两行和前三列切片出来：'
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And the remaining rows can be obtained as shown following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的行可以按如下方式获取：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we use `append` to combine the two DataFrames from the preceding commands:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用 `append` 将前面命令中的两个 DataFrame 合并：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In order to maintain the order of columns similar to the original DataFrame,
    we can apply the `reindex_axis` function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持列的顺序与原始 DataFrame 相似，我们可以应用 `reindex_axis` 函数：
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that, for the first two rows, the value of the last two columns is `NaN`
    since the first DataFrame only contained the first three columns. The `append`
    function does not work in places, but it returns a new DataFrame with the second
    DataFrame appended to the first.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于前两行，最后两列的值为 `NaN`，因为第一个 DataFrame 仅包含前三列。`append` 函数在某些地方无法正常工作，但它会返回一个新的
    DataFrame，将第二个 DataFrame 追加到第一个 DataFrame 中。
- en: Appending a single row to a DataFrame
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 DataFrame 中追加单行数据
- en: 'We can append a single row to a DataFrame by passing a series or dictionary
    to the `append` method:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将一个系列或字典传递给 `append` 方法，将单行数据追加到 DataFrame 中：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In order for this to work, you must pass the `ignore_index=True` argument so
    that the `index [0,1,2,3]` in `algoDF` is ignored.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此操作生效，必须传递 `ignore_index=True` 参数，以便忽略 `algoDF` 中的 `index [0,1,2,3]`。
- en: SQL-like merging/joining of DataFrame objects
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类似 SQL 的 DataFrame 对象合并/连接
- en: 'The `merge` function is used to join two DataFrame objects similar to those
    used in SQL database queries. It results in a merged DataFrame. DataFrame objects
    are analogous to SQL tables. The following command explains this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge` 函数用于连接两个 DataFrame 对象，类似于 SQL 数据库查询。它返回一个合并后的 DataFrame。DataFrame 对象类似于
    SQL 表。以下命令解释了这一点：'
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following is a summary of the `merge` function:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `merge` 函数的总结：
- en: 'The `left` argument: This is the first DataFrame object.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left` 参数：这是第一个 DataFrame 对象。'
- en: 'The `right` argument: This is the second DataFrame object.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right` 参数：这是第二个 DataFrame 对象。'
- en: 'The `how` argument: This is the type of join and can be inner, outer, left,
    or right. The default is inner.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`how` 参数：这是连接的类型，可以是内连接、外连接、左连接或右连接。默认值为内连接。'
- en: 'The `on` argument: This shows the names of columns to join on as join keys.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on` 参数：此参数显示作为连接键的列名。'
- en: 'The `left_on` and `right_on` arguments: These show the left and right `DataFrame`
    column names to join on.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left_on` 和 `right_on` 参数：这两个参数显示左侧和右侧 `DataFrame` 中的列名，用于连接。'
- en: 'The `left_index` and `right_index` arguments: These have a Boolean value. If
    this is `True`, use the left or right `DataFrame` index/row labels to join on.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left_index` 和 `right_index` 参数：这些参数是布尔值。如果为 `True`，则使用左侧或右侧 `DataFrame` 的索引/行标签进行连接。'
- en: 'The `sort` argument: This has a Boolean value. The default `True` setting results
    in a lexicographical sort. Setting the default value to `False` may improve performance.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort` 参数：该参数是布尔值。默认的 `True` 设置会进行字典顺序排序。将其设置为 `False` 可能会提高性能。'
- en: 'The `suffixes` argument: The tuple of string suffixes to be applied to overlapping
    columns. The defaults are `''_x''` and `''_y''`.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suffixes` 参数：这是一个包含字符串后缀的元组，用于重叠列的命名。默认值为 `''_x''` 和 `''_y''`。'
- en: 'The `copy` argument: The default `True` value causes data to be copied from
    the passed `DataFrame` objects.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy` 参数：默认的 `True` 值会从传递的 `DataFrame` 对象中复制数据。'
- en: The source of the preceding information is [http://pandas.pydata.org/pandas-docs/stable/merging.html](http://pandas.pydata.org/pandas-docs/stable/merging.html).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 上述信息的来源是 [http://pandas.pydata.org/pandas-docs/stable/merging.html](http://pandas.pydata.org/pandas-docs/stable/merging.html)。
- en: 'Let''s create two DataFrames – left and right – to understand merging:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来创建两个 DataFrame —— 左侧和右侧 —— 来理解合并操作：
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following will be the output:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/d4c4680b-f7b6-4f34-aefc-0975de88893a.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4c4680b-f7b6-4f34-aefc-0975de88893a.png)'
- en: Left DataFrame for merge
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 合并的左侧 DataFrame
- en: 'The right dataframe can be viewed using the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下方式查看右侧 DataFrame：
- en: '[PRE54]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following will be the output:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/0a8ccd95-b5df-41e8-8a68-554e4d77df84.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a8ccd95-b5df-41e8-8a68-554e4d77df84.png)'
- en: Right dataframe for merge
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 合并的右侧 DataFrame
- en: 'The DataFrames have five rows each, with `Category `and `Region` as the keys.
    Of these five rows, two rows from each DataFrame share the same set of keys. Let''s
    perform a merge on both keys:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 DataFrame 各有五行，`Category` 和 `Region` 作为连接键。在这五行数据中，每个 DataFrame 中有两行共享相同的连接键。我们来根据这两个键进行合并：
- en: '[PRE55]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following will be the output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/7503539b-acd4-44de-92d2-963dafb0c0db.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7503539b-acd4-44de-92d2-963dafb0c0db.png)'
- en: Default inner merge
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 默认内连接
- en: 'By default, the `how` argument is set to `inner`, hence, in this scenario,
    an inner join is performed. Now, let''s perform a `left` join:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`how` 参数设置为 `inner`，因此在这种情况下会执行内连接。现在，我们来进行一个 `left` 连接：
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following will be the output:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/7f67e3ca-961f-431d-9510-1d54d2b9d21a.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f67e3ca-961f-431d-9510-1d54d2b9d21a.png)'
- en: Left merge
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 左连接
- en: 'In a left join, all the rows found in the left DataFrame are included in the
    result. The rows of `left` not found in `right` get NAs appended to the columns
    originating from the right DataFrame – `Discount` and `Profit` – for which keys
    do not exist in the left DataFrame. A right join would be the exact opposite:
    the result would contain all the rows from the right dataframe and NAs would be
    appended to `Sales` and `Quantity `for cases where keys are found in `left` but
    not in the right DataFrame:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在左连接中，所有在左 DataFrame 中找到的行都会包含在结果中。那些在 `right` 中没有找到的 `left` 行，会将 `right` DataFrame
    中的 `Discount` 和 `Profit` 列补充为 NAs，这些列在左 DataFrame 中找不到对应的键。右连接则恰好相反：结果将包含右 DataFrame
    中的所有行，且在 `left` 中找到的键但在右 DataFrame 中找不到时，`Sales` 和 `Quantity` 列将被补充为 NAs：
- en: '[PRE57]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following will be the output:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/6afd4e55-db7d-4a5d-b3df-7053fd520fff.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6afd4e55-db7d-4a5d-b3df-7053fd520fff.png)'
- en: Right merge
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 右连接
- en: 'In the case of an outer join, no rows are excluded and NAs are appended as
    necessary for missing values:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在外连接的情况下，不会排除任何行，缺失值将根据需要被补充为 NAs：
- en: '[PRE58]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The following will be the output:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/495b4f94-04f1-441e-96a1-16ba7e07555a.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/495b4f94-04f1-441e-96a1-16ba7e07555a.png)'
- en: Outer merge
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 外连接
- en: 'Let''s investigate the behavior of an outer merge when duplicate entries of
    a key are found. The following command duplicates the last key combination of
    the `left `DataFrame. The keys with the `Office Supplies `category and the `Canada `region
    occur twice:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来研究当找到键的重复项时，外连接的行为。以下命令会复制 `left` DataFrame 中最后一个键的组合。带有 `Office Supplies`
    类别和 `Canada` 区域的键出现了两次：
- en: '[PRE59]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following will be the output:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/87a6f49b-a6d7-4901-93b1-4afc77d46ea3.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87a6f49b-a6d7-4901-93b1-4afc77d46ea3.png)'
- en: Inserting duplicates in the left DataFrame
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 向左 DataFrame 插入重复项
- en: 'The result of the outer merge is as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 外连接的结果如下：
- en: '[PRE60]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following will be the output:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/e244184e-5af2-47f4-a354-555f388261a0.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e244184e-5af2-47f4-a354-555f388261a0.png)'
- en: Outer merge for data with duplicates
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 带重复数据的外连接
- en: 'As you can see, the `right` DataFrame gets merged on the `left` DataFrame for
    each occurrence of the key and duplicates are not dropped. This behavior may not
    be desirable in huge datasets. It may be necessary to drop duplicates before merging.
    For such instances, the `validate` argument of `merge` helps to keep a check to
    support only one-to-one merges:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`right` DataFrame 在每次遇到键时会与 `left` DataFrame 合并，并且不会删除重复项。这种行为在处理大数据集时可能不太理想。在这种情况下，可能需要在合并之前删除重复项。对于这种情况，`merge`
    的 `validate` 参数有助于检查并仅支持一对一的合并：
- en: '[PRE61]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following will be the output:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/e0f88a15-4dc6-425a-8b82-2cade3322aa0.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0f88a15-4dc6-425a-8b82-2cade3322aa0.png)'
- en: Error indicating duplicates in the DataFrame when merging
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 合并时指示 DataFrame 中重复项的错误
- en: 'The `indicator` argument of merge indicates the source of a row – `left`, `right`,
    or both:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge` 的 `indicator` 参数表示行的来源——`left`、`right` 或两者都有：'
- en: '[PRE62]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The following will be the output:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/1a1f9823-b09b-449e-8675-733a1dd46390.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a1f9823-b09b-449e-8675-733a1dd46390.png)'
- en: The indicator parameter of merge
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge` 的 indicator 参数'
- en: The join function
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并函数
- en: 'The `DataFrame.join` function is used to combine two DataFrames that have different
    columns with nothing in common. Essentially, this does a longitudinal join of
    two DataFrames. Here is an example:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame.join` 函数用于合并两个没有共同列的 DataFrame。实质上，这是对两个 DataFrame 进行纵向连接。以下是一个例子：'
- en: '[PRE63]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following will be the output:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/f7b1434b-8f15-41a0-83c5-ac228d2057e0.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7b1434b-8f15-41a0-83c5-ac228d2057e0.png)'
- en: Default left join
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 默认左连接
- en: '`join` is almost identical to `merge`, the difference being that, while merge
    works for DataFrames that share identical keys, `join` combines DataFrames by
    the row-index. By default, the `join` function performs a left join. The other
    types of join can be specified through the `how` parameter:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`与`merge`几乎相同，区别在于，`merge`适用于具有相同键的DataFrame，而`join`是通过行索引来合并DataFrame。默认情况下，`join`函数执行左连接。其他类型的连接可以通过`how`参数指定：'
- en: '[PRE64]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The following will be the output:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/71820881-b334-4ba1-b4c1-a263e27dc44e.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71820881-b334-4ba1-b4c1-a263e27dc44e.png)'
- en: Right join
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 右连接
- en: 'The inner join can be performed as shown following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 内连接可以按如下方式执行：
- en: '[PRE65]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following will be the output:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/5c4ff5cd-a51a-4b8f-b9a6-fd3b0ecc61e5.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c4ff5cd-a51a-4b8f-b9a6-fd3b0ecc61e5.png)'
- en: Inner join
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 内连接
- en: 'The outer join can be performed as shown following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 外连接可以按如下方式执行：
- en: '[PRE66]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following will be the output:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/9321a282-86b3-4d85-ba09-52f9b244cc59.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9321a282-86b3-4d85-ba09-52f9b244cc59.png)'
- en: Outer join
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 外连接
- en: If the two DataFrames being joined have a common column over which the join
    should be performed, the key or list of keys can be mentioned in the `on` parameter
    of the `join` function. This is just the same as a `merge` function.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要连接的两个DataFrame具有共同的列作为连接键，则可以在`join`函数的`on`参数中指定该键或键的列表。这与`merge`函数完全相同。
- en: Pivots and reshaping data
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 透视和重塑数据
- en: 'This section deals with how you can reshape data. Sometimes, data is stored
    in what is known as a *stacked* format. Here is an example of stacked data using
    the `PlantGrowth` dataset:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论如何重塑数据。有时，数据以*堆叠*格式存储。以下是使用`PlantGrowth`数据集的堆叠数据示例：
- en: '[PRE67]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This data consists of results from an experiment that compared the dried weight
    yields of plants that were obtained under a **control** (**ctrl**) and two different
    treatment conditions (**trt1 **and **trt2**). Suppose we wanted to do some analysis
    on this data by group value. One way to do this would be to use a logical filter
    on the DataFrame:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据来自一项实验，实验比较了在**对照**（**ctrl**）和两种不同处理条件（**trt1**和**trt2**）下获得的植物干重产量。假设我们想根据组值对这些数据进行一些分析。实现此目标的一种方法是对数据框使用逻辑筛选：
- en: '[PRE68]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This can be tedious, so we would instead like to pivot/unstack this data and
    display it in a form that is more conducive to analysis. We can do this using
    the `DataFrame.pivot` function as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会很繁琐，因此我们希望对这些数据进行透视/解堆叠，并以更有利于分析的形式展示它们。我们可以使用`DataFrame.pivot`函数如下操作：
- en: '[PRE69]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, a DataFrame is created with columns corresponding to the different values
    of a group, or, in statistical parlance, levels of the factor.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建一个DataFrame，其列对应于组的不同值，或者用统计学术语来说，就是因子的各个水平。
- en: 'Some more examples of pivoting on `salesdata.csv` are as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`pivot`的一些更多示例，使用`salesdata.csv`文件如下：
- en: '[PRE70]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following will be the output. This gives the results for all the columns:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果。这是所有列的结果：
- en: '![](img/da032d62-e5ed-4d61-b8cf-a27ea1d6512a.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da032d62-e5ed-4d61-b8cf-a27ea1d6512a.png)'
- en: 'If we specify a `columns` parameter with a variable name, all the categories
    in that variable become separate columns:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定`columns`参数并给定一个变量名，那么该变量的所有类别将成为单独的列：
- en: '[PRE71]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For example, the output of the preceding code would be as shown following:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面代码的输出如下所示：
- en: '![](img/864919be-166e-4a7f-950d-388a0fb46ff7.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![](img/864919be-166e-4a7f-950d-388a0fb46ff7.png)'
- en: 'Multi-indexed pivots are also possible, as shown:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以进行多级索引的透视，如下所示：
- en: '[PRE72]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The following will be the output:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/9d2912c3-41a9-47cc-b692-ee544e9dc9b1.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d2912c3-41a9-47cc-b692-ee544e9dc9b1.png)'
- en: 'A different aggregate function, other than default average, or a custom function
    can be applied for aggregation as shown in the example following:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为聚合应用不同的聚合函数，或者使用自定义函数，示例如下：
- en: '[PRE73]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The following will be the output:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/54a535d8-64f3-479d-8055-d2e50630bd07.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54a535d8-64f3-479d-8055-d2e50630bd07.png)'
- en: 'Some more important tips and tricks to keep in mind while using `pivot_tables`
    are listed following:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pivot_tables`时需要记住的一些重要提示和技巧如下：
- en: 'If you expect missing values in your pivot table, then use `fill.values=0`:'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您预期透视表中有缺失值，则可以使用`fill.values=0`：
- en: '[PRE74]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If you want totals at the end, use `margins=TRUE`:'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想在末尾得到总计，可以使用`margins=TRUE`：
- en: '[PRE75]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You can pass different aggregate functions to different value columns:'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以为不同的数值列传递不同的聚合函数：
- en: '[PRE76]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Stacking and unstacking
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆叠和解堆叠
- en: In addition to pivot functions, the stack and unstack functions are also available
    on Series and DataFrames, which work on objects containing MultiIndex.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 除了透视函数外，`stack`和`unstack`函数也适用于Series和DataFrame，它们可以作用于包含多重索引的对象。
- en: The stack() function
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`stack()`函数'
- en: 'When stacking, a set of column labels get converted to an index level. To explore
    stacking further, let''s use a DataFrame with a MultiIndex along the row-index
    and column-index:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠时，一组列标签会转换为索引级别。为了进一步探索堆叠，让我们使用一个在行索引和列索引上都有多重索引的DataFrame：
- en: '[PRE77]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The following will be the output:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/e2d47143-71d1-4a0b-9a1b-0c05dc5c9d2e.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2d47143-71d1-4a0b-9a1b-0c05dc5c9d2e.png)'
- en: Hierarchical data for stacking and unstacking
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 层次数据用于堆叠和unstack
- en: 'Applying `stack() `makes a wide DataFrame longer. Let''s apply `stack()` on
    the preceding DataFrame. The column labels on the last level get added to the
    MultiIndex:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 应用`stack()`使得宽格式的DataFrame变得更长。让我们在前面的DataFrame上应用`stack()`。最后级别的列标签会添加到多重索引中：
- en: '[PRE78]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following will be the output:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/f573195b-a5cb-41a0-883b-9f63476744fd.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f573195b-a5cb-41a0-883b-9f63476744fd.png)'
- en: Result of stacking
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠的结果
- en: 'The `stack()` function accepts a `level` argument. In this case, the default
    level setting is `1`. Let''s try stacking at level `0`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`stack()`函数接受一个`level`参数。在这种情况下，默认的级别设置是`1`。让我们尝试在级别`0`上进行堆叠：'
- en: '[PRE79]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The following will be the output:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/7f94af5a-13df-4bca-90cb-8a43704d76c2.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f94af5a-13df-4bca-90cb-8a43704d76c2.png)'
- en: Stacking using the level parameter
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`level`参数进行堆叠
- en: 'Instead of specifying level numbers, level names can also be specified when
    stacking. To stack multiple levels, a list of level names or level numbers can
    be passed to the `level` argument. However, the list cannot be a combination of
    both level names and level numbers:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆叠时，可以通过指定层级名称来代替指定层级编号。要堆叠多个级别，可以将层级名称或层级编号的列表传递给`level`参数。不过，列表不能同时包含层级名称和层级编号的组合：
- en: '[PRE80]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The following will be the output:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/53a27fd4-b4cd-4a5b-844f-8764011dab5e.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53a27fd4-b4cd-4a5b-844f-8764011dab5e.png)'
- en: Stacking multiple levels at once
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 一次堆叠多个级别
- en: 'Let''s explore the attributes of the index after stacking. The `index` attribute
    of a DataFrame helps us understand the various levels, labels, and names of each
    index:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索堆叠后索引的属性。DataFrame的`index`属性帮助我们了解每个索引的不同级别、标签和名称：
- en: '[PRE81]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The following will be the output:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/e2bf78e4-cded-4a41-bc98-a7471e103be4.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2bf78e4-cded-4a41-bc98-a7471e103be4.png)'
- en: Index properties after stacking
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠后的索引属性
- en: 'At times, stacking introduces missing values when there are no values for a
    certain combination of index and column name. Consider the following DataFrame:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当某个索引和列名的组合没有值时，堆叠操作会引入缺失值。考虑以下DataFrame：
- en: '[PRE82]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The following will be the output:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/c1985d13-8377-43f4-b81f-f379b458d33f.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1985d13-8377-43f4-b81f-f379b458d33f.png)'
- en: Handling missing values when stacking
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠时处理缺失值
- en: 'Upon stacking, the `dropna` parameter of the `stack` function, which is set
    to `True` by default, automatically drops all NAs:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠时，`stack`函数的`dropna`参数默认设置为`True`，它会自动丢弃所有的NA：
- en: '[PRE83]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The following will be the output:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/5eee33c1-dbd7-47d7-86a6-0e5a23da2279.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5eee33c1-dbd7-47d7-86a6-0e5a23da2279.png)'
- en: dropna set to False when stacking
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠时将`dropna`设置为False
- en: 'By default, it will drop the rows with all missing values, as shown following:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它会丢弃所有缺失值的行，如下所示：
- en: '[PRE84]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The following will be the output:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/8dc1b7ae-f9e8-42f3-8c5e-cd744a0c5c92.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8dc1b7ae-f9e8-42f3-8c5e-cd744a0c5c92.png)'
- en: Dropping NAs by default when stacking
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，堆叠时会丢弃NA
- en: The unstack() function
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`unstack()`函数'
- en: 'The `unstack` function performs the reverse operation of the `stack` function.
    It converts long DataFrames to a wider format. Let''s unstack the multi-level
    indexed sales data. The last level is unstacked by default:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`unstack`函数执行`stack`函数的逆操作。它将长格式的DataFrame转换为宽格式。让我们对具有多重索引的销售数据进行unstack操作，默认情况下，最后一个级别会被unstack：'
- en: '[PRE85]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The following will be the output:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/9b6d4218-e6f7-485d-b16a-45f27fe3df43.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b6d4218-e6f7-485d-b16a-45f27fe3df43.png)'
- en: Unstacking
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Unstack操作
- en: Just like `stack`, `unstack` has a `level` parameter. This `level` parameter
    accepts a level number, a level name, or a list of level names/level numbers.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 和`stack`一样，`unstack`也有一个`level`参数。这个`level`参数可以接受层级编号、层级名称或层级名称/层级编号的列表。
- en: 'Any missing values created when unstacking can be handled using the `fill_value`
    argument of the `unstack` function. Consider the following DataFrame:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在解堆叠时创建的任何缺失值都可以使用 `unstack` 函数的 `fill_value` 参数进行处理。考虑以下 DataFrame：
- en: '[PRE86]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The following will be the output:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/8630f903-1d61-488d-9e42-13e106518daf.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8630f903-1d61-488d-9e42-13e106518daf.png)'
- en: Snapshot of data
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 数据快照
- en: 'Unstacking the preceding DataFrame introduces NAs:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 对前述 DataFrame 进行解堆叠会引入 NAs：
- en: '[PRE87]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The following will be the output:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/1ef3ab3e-d937-426c-bbd3-ddf901936f90.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ef3ab3e-d937-426c-bbd3-ddf901936f90.png)'
- en: Unstacking without handling missing data
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在不处理缺失数据的情况下进行解堆叠
- en: 'We can impute the missing cells with a value of our choice using the `fill_value`
    method. Following are the missing values have been replaced by 0:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `fill_value` 方法用我们选择的值填充缺失的单元格。以下是缺失值已被替换为 0 的示例：
- en: '[PRE88]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '![](img/f7a65c30-3f69-46b8-bda7-e7bea17a0ab4.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7a65c30-3f69-46b8-bda7-e7bea17a0ab4.png)'
- en: Filling NAs with 0 when unstacking
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在解堆叠时填充 NA 为 0
- en: Other methods for reshaping DataFrames
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他 DataFrame 重塑方法
- en: There are various other methods that are related to reshaping DataFrames; we'll
    discuss them here.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他多种与 DataFrame 重塑相关的方法，我们将在此讨论它们。
- en: Using the melt function
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 melt 函数
- en: The `melt` function enables us to transform a DataFrame by designating some
    of its columns as ID columns, ensuring they remain as columns with the remaining
    non-ID columns treated as *variable* columns and are pivoted and become part of
    a name-value two-column scheme. ID columns uniquely identify a row in a DataFrame.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`melt` 函数使我们能够通过指定某些列作为 ID 列来转换 DataFrame，确保它们作为列保持不变，而其余的非 ID 列被视为 *变量* 列并进行透视，最终形成一个名称-值两列的方案。ID
    列唯一标识 DataFrame 中的一行。'
- en: 'The names of those non-ID columns can be customized by supplying the `var_name`
    and `value_name` parameters. The use of `melt` is perhaps best illustrated by
    an example, as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这些非 ID 列的名称可以通过提供 `var_name` 和 `value_name` 参数来定制。使用 `melt` 的方法通过以下示例来说明，效果最好：
- en: '[PRE89]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The pandas.get_dummies() function
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pandas.get_dummies() 函数
- en: 'This function is used to convert a categorical variable into an indicator DataFrame,
    which is essentially a truth table of possible values of the categorical variable.
    An example of this is the following command:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数用于将分类变量转换为指示符 DataFrame，实际上是分类变量可能值的真值表。以下命令是一个示例：
- en: '[PRE90]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The source of the preceding data is [http://vincentarelbundock.github.io/Rdatasets/csv/datasets/PlantGrowth.csv](http://vincentarelbundock.github.io/Rdatasets/csv/datasets/PlantGrowth.csv).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 前述数据的来源是 [http://vincentarelbundock.github.io/Rdatasets/csv/datasets/PlantGrowth.csv](http://vincentarelbundock.github.io/Rdatasets/csv/datasets/PlantGrowth.csv)。
- en: pivot table
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 透视表
- en: 'The pandas `pivot_table` function is more advanced than the `pivot` function
    in several ways. Let''s discuss some interesting parameters of the `pivot_table`
    function:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 的 `pivot_table` 函数在多个方面比 `pivot` 函数更为高级。让我们讨论一些 `pivot_table` 函数的有趣参数：
- en: '`data`: The DataFrame object that is to be reshaped'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：要重塑的 DataFrame 对象'
- en: '`values`: A column or a list of columns that are to be aggregated'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values`：需要聚合的列或列的列表'
- en: '`index`: The key across which grouping of pivot index occurs'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`：用于分组的透视表索引的键'
- en: '`columns`: The key with respect to which grouping of the `pivot` column occurs'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`columns`：用于分组的透视表列的键'
- en: '`aggfunc`: The function to use for aggregation, such as `np.mean`'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aggfunc`：用于聚合的函数，例如 `np.mean`'
- en: 'Let''s pivot the sample sales data to slice and dice `Sales` across `Category`
    and `ShipMode`. Note that when `aggfunc` is empty, the mean is calculated:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们透视示例销售数据，在 `Category` 和 `ShipMode` 上切分 `Sales`。请注意，当 `aggfunc` 为空时，会计算均值：
- en: '[PRE91]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The following will be the output:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/5c9f51e3-4a80-4bbc-9bef-8621031db69a.png)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c9f51e3-4a80-4bbc-9bef-8621031db69a.png)'
- en: Pivot table from pandas
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 透视表
- en: 'Now, it is possible to have multiple values for `values`, `index`, `column`,
    or `aggfunc`. Those multiple values can be passed as a list. Let''s calculate
    `mean` for `Sales` and `sum` for `Quantity`:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`values`、`index`、`column` 或 `aggfunc` 可以有多个值。这些多个值可以作为列表传递。我们来计算 `Sales`
    的 `mean` 和 `Quantity` 的 `sum`：
- en: '[PRE92]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The following will be the output:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/1456c041-5da8-41c0-a546-e79e891deceb.png)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1456c041-5da8-41c0-a546-e79e891deceb.png)'
- en: Pivot table with multiple aggregations
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 带有多个聚合的透视表
- en: Through `pivot_table`, DataFrames with hierarchical indices can be created.
    The `fill_value` and `dropna` parameters of the `pivot_table` function help in
    handling missing values.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`pivot_table`，可以创建具有层次化索引的DataFrame。`pivot_table`函数的`fill_value`和`dropna`参数有助于处理缺失值。
- en: Transpose in pandas
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pandas中的转置
- en: 'The `transpose` function in pandas is similar to that of NumPy. It interchanges
    rows and columns. Let''s find the transpose of the following DataFrame:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: pandas中的`transpose`函数与NumPy中的类似。它可以交换行和列。让我们找出以下DataFrame的转置：
- en: '[PRE93]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The following will be the output:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/6ab29d7a-bafd-482a-8f9f-fbab762e43f2.png)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ab29d7a-bafd-482a-8f9f-fbab762e43f2.png)'
- en: Data to be transposed
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 需要转置的数据
- en: 'In the transpose of the DataFrame, the column labels and row indices are swapped:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在DataFrame的转置中，列标签和行索引被交换：
- en: '[PRE94]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The following will be the output:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/bff6518d-61aa-4a4a-a2fb-ede17f78f66c.png)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bff6518d-61aa-4a4a-a2fb-ede17f78f66c.png)'
- en: Output of transpose
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 转置的输出
- en: '`T` acts as an accessor to the `transpose` function and can be used as shown:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`T`作为`transpose`函数的访问器，可以像下面这样使用：'
- en: '[PRE95]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `swaplevel` function helps to interchange the levels within any axis. Consider
    the following DataFrame:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`swaplevel`函数有助于交换任何轴内的级别。考虑以下DataFrame：'
- en: '[PRE96]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The following will be the output:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/6d98f001-fcf4-4916-9358-4fd619e042f4.png)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d98f001-fcf4-4916-9358-4fd619e042f4.png)'
- en: Data for swaplevel and swapaxes
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: swaplevel和swapaxes的数据
- en: 'Now, let''s switch the positions of the `Category` and `ShipMode `index levels. Level
    numbers or level names can be provided as arguments:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们交换`Category`和`ShipMode`索引级别的位置。可以将级别的数字或名称作为参数提供：
- en: '[PRE97]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The following will be the output:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/8b2d0fe8-1ee8-41c4-a144-b659540c7f08.png)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b2d0fe8-1ee8-41c4-a144-b659540c7f08.png)'
- en: Levels swapped
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 交换的级别
- en: 'Similarly, such switches can also be executed on the column labels by setting
    `axis` to `1`:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您也可以通过将`axis`设置为`1`来交换列标签：
- en: '[PRE98]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The following will be the output:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/8bac432a-2314-4130-ba8a-30df215a7f1a.png)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bac432a-2314-4130-ba8a-30df215a7f1a.png)'
- en: Levels swapped along axis 1
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 沿轴1交换的级别
- en: 'The `swapaxes` function is functionally similar to the `transpose` function.
    The following shows the `swapaxes` function in action:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`swapaxes`函数在功能上与`transpose`函数类似。以下是`swapaxes`函数的示例：'
- en: '[PRE99]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The following will be the output:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/3d40cbf8-aa4d-426a-a215-ef2a8393387e.png)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d40cbf8-aa4d-426a-a215-ef2a8393387e.png)'
- en: Axis swapped
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 交换轴
- en: Squeeze
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压缩
- en: '`squeeze` helps to convert a 1D DataFrame to a series. Let''s consider a 1D
    DataFrame:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`squeeze`有助于将一个1D DataFrame转换为Series。让我们考虑一个1D DataFrame：'
- en: '[PRE100]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The following will be the output:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/42d5196e-b6c1-4cbf-af15-edcb8d8df314.png)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42d5196e-b6c1-4cbf-af15-edcb8d8df314.png)'
- en: Data to squeeze
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩数据
- en: 'The type of the preceding object has been deciphered here – it is a DataFrame:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 前面对象的类型已被解码——它是一个DataFrame：
- en: '[PRE101]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The following will be the output:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/70a1b703-3992-4942-870b-3854bf22cf61.png)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70a1b703-3992-4942-870b-3854bf22cf61.png)'
- en: Object type before squeezing
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩前的对象类型
- en: 'Now, let''s apply the `squeeze` function and find the object type. The required
    snippet and the output looks as shown following:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们应用`squeeze`函数并查找对象类型。所需的代码段和输出如下所示：
- en: '[PRE102]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '![](img/cb19268e-6d19-4e62-a6a6-107dd298f679.png)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb19268e-6d19-4e62-a6a6-107dd298f679.png)'
- en: Object type after squeezing
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩后的对象类型
- en: As you can see, `squeeze` transforms the DataFrame into a series.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`squeeze`将DataFrame转换为Series。
- en: nsmallest and nlargest
  id: totrans-528
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: nsmallest和nlargest
- en: The `nsmallest` and `nlargest `functions are extremely useful for returning
    the n smallest and n largest rows after ordering by the desired column.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`nsmallest`和`nlargest`函数非常有用，可以在按指定列排序后返回n个最小和n个最大的行。'
- en: 'In the sample sales data, let''s find the `3` smallest records by `Profit`:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例销售数据中，让我们通过`Profit`找到`3`个最小记录：
- en: '[PRE103]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The following will be the output:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/087b2825-526c-48bd-a110-585dcc3f4b0a.png)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![](img/087b2825-526c-48bd-a110-585dcc3f4b0a.png)'
- en: 'Figure6.73: Result of nsmallest'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.73：nsmallest函数的结果
- en: 'The ordering can also be done with respect to multiple columns, as shown here:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 排序也可以基于多个列进行，如下所示：
- en: '[PRE104]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The following will be the output:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/7bbd3fc8-f873-470d-a5be-a1595c485d06.png)'
  id: totrans-538
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7bbd3fc8-f873-470d-a5be-a1595c485d06.png)'
- en: Result of nlargest
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: nlargest函数的结果
- en: These functions – `nsmallest` and `nlargest` have the `keep` parameter to decide
    how duplicates are handled. It helps to choose either the first occurrence, the
    last occurrence, or to retain all duplicates.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数——`nsmallest` 和 `nlargest`——有一个 `keep` 参数，用于决定如何处理重复项。它有助于选择第一个出现的、最后一个出现的，或者保留所有重复项。
- en: Summary
  id: totrans-541
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter added to our arsenal of pandas tricks to aggregate, join, and
    transform data. Here is a quick recap of the chapter:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们的 pandas 技巧库增添了新的内容，用于聚合、连接和转换数据。以下是本章的快速回顾：
- en: '`groupby` creates groups of rows – one group for each category in a categorical
    variable (or a combination of categories across categorical variables).'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupby` 会创建一组行——每个类别变量中的一个组（或多个类别变量的组合）。'
- en: Using `groupby`, the same analysis can be performed on different groups efficiently.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `groupby`，可以高效地对不同组进行相同的分析。
- en: Similarly shaped DataFrames can be concatenated or appended to perform analysis
    simultaneously for the entire dataset.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状相似的 DataFrame 可以连接或追加，以便同时对整个数据集进行分析。
- en: SQL-like joining or merging between DataFrames is also possible.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也可以在 DataFrame 之间进行类似 SQL 的连接或合并操作。
- en: Wide data can be made longer, or vice versa, depending on the requirement.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宽格式数据可以根据需求转换为长格式数据，反之亦然。
- en: pandas can handle multi-index data and there are functions to convert multi-index
    data to single-index data and vice versa.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pandas 能够处理多重索引数据，并且提供了将多重索引数据转换为单重索引数据及其反向操作的函数。
- en: Spreadsheet operations such as pivot tables and transposes are possible and
    provide more flexibility than in spreadsheets.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像数据透视表和转置这样的电子表格操作是可能的，并且提供了比电子表格更多的灵活性。
- en: In the next chapter, we will discuss and elaborate on the methods, syntax, and
    usage of some of these special data operations in pandas.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论并详细说明 pandas 中一些特殊数据操作的方法、语法和用法。
