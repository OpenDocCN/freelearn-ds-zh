- en: Signal Processing and Time Series
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理与时间序列
- en: Signal processing is a subdomain of electrical engineering and applied mathematics.
    It covers the analysis and processing of time-related variables or variables that
    change over time, such as analog and digital signals. Analog signals are non-digitized
    signals, such as radio or telephone signals. Digital signals are digitized, discrete,
    time-sampled signals, such as computer and digital device signals. Time-series
    analysis is the category of signal processing that deals with ordered or sequential
    lists of observations. This data can be ordered hourly, daily, weekly, monthly,
    or annually. The time component in the time series plays a very important role.
    We need to extract all the relations in the data with respect to time. There are
    lots of examples that are related to time-series analysis, such as the production
    and sales of a product, predicting stock prices on an hourly or daily basis, economic
    forecasts, and census analysis.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理是电气工程和应用数学的一个子领域。它涵盖了时间相关变量或随时间变化的变量的分析和处理，例如模拟信号和数字信号。模拟信号是非数字化的信号，例如广播或电话信号。数字信号是数字化的、离散的、按时间采样的信号，例如计算机和数字设备信号。时间序列分析是信号处理的一个类别，处理的是有序或按顺序排列的观察列表。这些数据可以按小时、日、周、月或年排序。时间序列中的时间因素非常重要。我们需要提取数据中所有与时间相关的关系。与时间序列分析相关的例子有很多，例如产品的生产和销售、按小时或每天预测股价、经济预测和人口普查分析。
- en: In this chapter, our main focus is on signal processing and time-series operations
    using the NumPy, SciPy, `pandas`, and `statsmodels` libraries. This chapter will
    be helpful for data analysts to understand trends and patterns and forecast sales,
    stock prices, production, population, rainfall, and weather temperature.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的主要关注点是使用NumPy、SciPy、`pandas`和`statsmodels`库进行信号处理和时间序列操作。本章将对数据分析师理解趋势和模式，以及预测销售、股价、生产、人口、降水量和气温等有所帮助。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The `statsmodels` modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statsmodels`模块'
- en: Moving averages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动平均
- en: Window functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口函数
- en: Defining cointegration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义协整
- en: STL decomposition
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL分解
- en: Autocorrelation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自相关
- en: Autoregressive models
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自回归模型
- en: ARMA models
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARMA模型
- en: Generating periodic signals
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成周期信号
- en: Fourier analysis
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 傅里叶分析
- en: Spectral analysis filtering
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谱分析滤波
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有以下技术要求：
- en: 'You can find the code and the dataset at the following GitHub link: [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter08](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter08).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在以下GitHub链接找到代码和数据集：[https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter08](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter08)。
- en: All the code blocks are in the `Ch8.ipynb` file.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的代码块都在`Ch8.ipynb`文件中。
- en: This chapter uses two CSV files (`beer_production.csv` and `sales.csv`) for
    practice purposes.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章使用两个CSV文件（`beer_production.csv`和`sales.csv`）进行实践。
- en: In this chapter, we will use the `pandas` and Scikit-learn Python libraries.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章将使用`pandas`和Scikit-learn Python库。
- en: The statsmodels modules
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: statsmodels模块
- en: '`statsmodels` is an open source Python module that offers functionality for
    various statistical operations, such as central values (mean, mode, and median),
    dispersion measures (standard deviation and variance), correlations, and hypothesis
    tests.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`statsmodels`是一个开源的Python模块，提供了多种统计操作的功能，例如中心值（均值、众数和中位数）、离散度量（标准差和方差）、相关性和假设检验。'
- en: 'Let''s install `statsmodels` using `pip` and run the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`pip`安装`statsmodels`并运行以下命令：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`statsmodels` provides the `statsmodels.tsa` submodule for time-series operations.
    `statsmodels.tsa` provides useful time-series methods and techniques, such as
    autoregression, autocorrelation, partial autocorrelation, moving averages, SimpleExpSmoothing,
    Holt''s linear, Holt-Winters, ARMA, ARIMA, **vector autoregressive** (**VAR**)
    models, and lots of helper functions, which we will explore in the upcoming sections.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`statsmodels`提供了`statsmodels.tsa`子模块用于时间序列操作。`statsmodels.tsa`提供了有用的时间序列方法和技术，例如自回归、
    autocorrelation、部分自相关、移动平均、简单指数平滑、霍尔特线性法、霍尔特-温特斯法、ARMA、ARIMA、**向量自回归**（**VAR**）模型和许多助手函数，我们将在接下来的章节中探讨这些。'
- en: Moving averages
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动平均
- en: 'Moving averages, or rolling means, are time-series filters that filter impulsive
    responses by averaging the set or window of observations. It uses window size
    concepts and finds the average of the continuous window slides for each period.
    The simple moving average can be represented as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均或滚动均值是时间序列滤波器，通过对一组或窗口的观测值进行平均，滤除冲动响应。它使用窗口大小的概念，并计算每个周期连续窗口滑动的平均值。简单移动平均可以表示如下：
- en: '![](img/348b3a98-fd85-4c49-99da-fba169304086.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/348b3a98-fd85-4c49-99da-fba169304086.png)'
- en: 'There are various types of moving averages available, such as centered, double,
    and weighted moving averages. Let''s find the moving average using the `rolling()`
    function, but before that, we''ll first load the data and visualize it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种类型的移动平均可用，例如居中、双重和加权移动平均。让我们使用`rolling()`函数找到移动平均值，但在此之前，我们将首先加载数据并可视化：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This results in the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/f27f7d5f-9df1-4603-a77b-ce85d0b519ef.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f27f7d5f-9df1-4603-a77b-ce85d0b519ef.png)'
- en: 'In the preceding code, we have read the sales dataset of 36 months from January
    2017 to December 2019 and plotted it using Matplotlib. Now, we will compute the
    moving average using the rolling function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们读取了2017年1月到2019年12月36个月的销售数据，并使用Matplotlib绘制了图表。现在，我们将使用滚动函数计算移动平均值：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This results in the following output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/aeeef19b-b968-4207-983b-0adb4b10e638.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aeeef19b-b968-4207-983b-0adb4b10e638.png)'
- en: In the preceding code, we computed the 3 and 5 moving averages using the rolling
    mean and displayed the line plot using Matplotlib. Now, let's see different types
    of window functions for moving averages in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用滚动均值计算了3和5的移动平均值，并使用Matplotlib显示了线形图。现在，让我们在下一节中看看不同类型的移动平均窗口函数。
- en: Window functions
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口函数
- en: NumPy offers several window options that can compute weights in a rolling window
    as we did in the previous section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了多种窗口选项，可以计算滚动窗口中的权重，正如我们在前一节中所做的那样。
- en: 'The window function uses an interval for spectral analysis and filter design
    (for more background information, refer to [http://en.wikipedia.org/wiki/Window_function](http://en.wikipedia.org/wiki/Window_function)).
    The boxcar window is a rectangular window with the following formula:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数用于光谱分析和滤波器设计的间隔（更多背景信息，请参见[http://en.wikipedia.org/wiki/Window_function](http://en.wikipedia.org/wiki/Window_function)）。箱型窗口是一个矩形窗口，其公式如下：
- en: '*w(n) = 1*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*w(n) = 1*'
- en: 'The triangular window is shaped like a triangle and has the following formula:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 三角窗口的形状像一个三角形，其公式如下：
- en: '![](img/ec4ec393-f982-43b3-a864-1d7a1e8817a7.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec4ec393-f982-43b3-a864-1d7a1e8817a7.png)'
- en: Here, *L* can be equal to *N*, *N*+1, or *N*–1.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*L*可以等于*N*、*N*+1或*N*–1。
- en: 'If the value of *L* is *N*–1, it is known as the Bartlett window and has the
    following formula:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*L*的值为*N*–1，则称为Bartlett窗口，其公式如下：
- en: '![](img/715dfe5d-e6dc-4d40-899a-ab61d45b9d98.png)![](img/aaf1be2b-80d5-491c-89aa-42eaf91bb297.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/715dfe5d-e6dc-4d40-899a-ab61d45b9d98.png)![](img/aaf1be2b-80d5-491c-89aa-42eaf91bb297.png)'
- en: 'In the `pandas` module, the `DataFrame.rolling()` function provides the same
    functionality using the `win_type` parameter for different window functions. Another
    parameter is the window for defining the size of the window, which is easy to
    set as shown in the previous section. Let''s use the `win_type` parameter and
    try different window functions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pandas`模块中，`DataFrame.rolling()`函数使用`win_type`参数提供相同的功能，以实现不同的窗口函数。另一个参数是窗口，用于定义窗口的大小，如前一节所示，这非常容易设置。让我们使用`win_type`参数并尝试不同的窗口函数：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This results in the following output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/09dea12c-959b-4080-a1dc-3bc52f73ffe7.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09dea12c-959b-4080-a1dc-3bc52f73ffe7.png)'
- en: In the preceding code block, we have plotted the rolling mean for different
    window functions, such as boxcar, triangular, hamming, and Blackman window, using
    the `win_type` parameter in the `rolling()` function. Now, let's learn how to
    find a correlation between two time series using cointegration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用`rolling()`函数中的`win_type`参数绘制了不同窗口函数的滚动均值，如箱型、三角形、汉明窗口和布莱克曼窗口。现在，让我们学习如何使用协整找到两个时间序列之间的相关性。
- en: Defining cointegration
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义协整
- en: 'Cointegration is just like a correlation that can be viewed as a superior metric
    to define the relatedness of two time series. Cointegration is the stationary
    behavior of the linear combination of two time series. In this way, the trend
    of the following equation must be stationary:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 协整就像是相关性，可以看作是定义两个时间序列相关性的更优指标。协整是两个时间序列线性组合的平稳行为。这样，以下方程的趋势必须是平稳的：
- en: '*y(t) - a x(t)*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*y(t) - a x(t)*'
- en: Consider a drunk man and his dog out on a walk. Correlation tells us whether
    they are going in the same direction. Cointegration tells us something about the
    distance over time between the man and his dog. We will show cointegration using
    randomly generated time-series and real data. The **Augmented Dickey-Fuller**
    (**ADF**) test tests for a unit root in a time series and can be used to determine
    the stationarity of time series.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个醉汉带着他的狗在散步。相关性告诉我们他们是否朝同一方向走。协整则告诉我们男人与狗之间的距离随时间的变化。我们将使用随机生成的时间序列和实际数据来展示协整。**增强型迪基-福勒**（**ADF**）检验用于检验时间序列中的单位根，并可用来判断时间序列的平稳性。
- en: Let's see an example to understand the cointegration of two time series.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解两个时间序列的协整。
- en: 'You can check out the full code for this example at the following GitHub link:
    [](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter08/Ch8.ipynb)
    [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter08/Ch8.ipynb](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter08/Ch8.ipynb).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下GitHub链接查看完整的代码：[https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter08/Ch8.ipynb](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter08/Ch8.ipynb)
- en: 'Let''s get started with the cointegration demo:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始协整演示：
- en: 'Import the required libraries and define the following function to calculate
    the ADF statistic:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库并定义以下函数来计算ADF统计量：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Load the Sunspot data into a NumPy array:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将太阳黑子数据加载到一个NumPy数组中：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Generate a sine wave and calculate the cointegration of the sine with itself:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个正弦波并计算正弦与自身的协整：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code should print the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该打印以下内容：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the printed results, the first value represents the ADF metric and the second
    value represents the p-value. As you can see, the p-value is very high. The following
    values are the lag and sample size. The dictionary at the end gives the t-distribution
    values for this exact sample size.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印的结果中，第一个值代表ADF指标，第二个值代表p值。如你所见，p值非常高。接下来的值为滞后和样本大小。最后的字典给出了此样本大小对应的t分布值。
- en: 'Now, add noise to the sine to demonstrate how noise will influence the signal:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，给正弦波加入噪声，以演示噪声如何影响信号：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With the noise, we get the following results:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有了噪声，我们得到以下结果：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The p-value has gone down considerably. The ADF metric here, `-7.45`, is lower
    than all the critical values in the dictionary. All these are strong arguments
    to reject cointegration.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: p值已经大幅下降。这里的ADF指标`-7.45`低于字典中的所有临界值。所有这些都是强有力的理由来拒绝协整。
- en: 'Let''s generate a cosine of a larger magnitude and offset. Again, let''s add
    noise to it:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们生成一个幅度更大的余弦并进行偏移。再次，加入噪声：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following values get printed:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下值将被打印出来：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similarly, we have strong arguments to reject cointegration. Checking for cointegration
    between the sine and sunspots gives the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们有充分的理由拒绝协整。检查正弦与太阳黑子之间的协整，得到以下输出：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following values get printed:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下值将被打印出来：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The confidence levels are roughly the same for the pairs used here because
    they are dependent on the number of data points, which doesn''t vary much. The
    outcome is summarized in the following table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的配对的置信水平大致相同，因为它们依赖于数据点的数量，而这一点变化不大。结果总结在以下表格中：
- en: '| **Pair** | **Statistic** | **p-value** | **5%** | **1%** | **10%** | **Reject**
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **配对** | **统计量** | **p值** | **5%** | **1%** | **10%** | **拒绝** |'
- en: '| Sine with self | -5.03E-16 | 0.95 | -2.87 | -3.45 | -2.57 | No |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 自身的正弦 | -5.03E-16 | 0.95 | -2.87 | -3.45 | -2.57 | 否 |'
- en: '| Sine versus sine with noise | -7.45 | 5.58E-11 | -2.87 | -3.45 | -2.57 |
    Yes |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 噪声影响下的正弦与正弦 | -7.45 | 5.58E-11 | -2.87 | -3.45 | -2.57 | 是 |'
- en: '| Sine versus cosine with noise | -17.92 | 2.89E-30 | -2.87 | -3.45 | -2.57
    | Yes |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 噪声影响下的正弦与余弦 | -17.92 | 2.89E-30 | -2.87 | -3.45 | -2.57 | 是 |'
- en: '| Sine versus sunspots | -6.72 | 3.42E-09 | -2.87 | -3.45 | -2.57 | Yes |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 正弦与太阳黑子 | -6.72 | 3.42E-09 | -2.87 | -3.45 | -2.57 | 是 |'
- en: In the preceding table, the results are summarized for all four sine waves and
    their significance level with rejection/acceptance is discussed. Let's now move
    on to another important topic of the chapter, which is STL decomposition of any
    time series.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表格中，汇总了所有四个正弦波的结果，并讨论了它们的显著性水平以及拒绝/接受的标准。现在让我们进入本章的另一个重要话题，即任何时间序列的STL分解。
- en: STL decomposition
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL分解
- en: '**STL** stands for **seasonal** **and trend decomposition** **using LOESS**.
    STL is a time-series decomposition method that can decompose an observed signal
    into a trend, seasonality, and residual. It can estimate non-linear relationships
    and handle any type of seasonality. The `statsmodels.tsa.seasonal` subpackage
    offers the `seasonal_decompose` method for splitting a given input signal into
    trend, seasonality, and residual.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**STL** 代表 **季节性** **和趋势分解** **使用LOESS**。STL是一种时间序列分解方法，可以将观测信号分解为趋势、季节性和残差。它能够估计非线性关系并处理任何类型的季节性。`statsmodels.tsa.seasonal`子包提供了`seasonal_decompose`方法，用于将给定的输入信号分解为趋势、季节性和残差。'
- en: 'Let''s see the following example to understand STL decomposition:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看以下示例来理解STL分解：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This results in the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/046872eb-5130-47a0-ad50-32e5ff6ac47d.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/046872eb-5130-47a0-ad50-32e5ff6ac47d.png)'
- en: In the preceding code block, the given time-series signal is decomposed into
    trend, seasonal, and residual components using the `seasonal_decompose()` function
    of the `statsmodels` module. Let's now jump to autocorrelation to understand the
    relationship between a time series and its lagged series.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，给定的时间序列信号通过`statsmodels`模块的`seasonal_decompose()`函数被分解为趋势、季节性和残差组件。现在让我们跳到自相关，理解时间序列与其滞后序列之间的关系。
- en: Autocorrelation
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自相关
- en: 'Autocorrelation, or lagged correlation, is the correlation between a time series
    and its lagged series. It indicates the trend in the dataset. The autocorrelation
    formula can be defined as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 自相关，或滞后相关，是时间序列与其滞后序列之间的相关性。它指示数据集中的趋势。自相关公式可以定义如下：
- en: '![](img/ec5f82f8-a046-410c-abbf-d0204caee611.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec5f82f8-a046-410c-abbf-d0204caee611.png)'
- en: 'We can calculate the autocorrelation using the NumPy `correlate()` function
    to calculate the actual autocorrelation of sunspot cycles. We can also directly
    visualize the autocorrelation plot using the `autocorrelation_plot()` function.
    Let''s compute the autocorrelation and visualize it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用NumPy的`correlate()`函数来计算日冕周期的实际自相关。我们还可以直接使用`autocorrelation_plot()`函数可视化自相关图。让我们计算自相关并可视化它：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This results in the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/d1632364-68b7-4dd0-96d3-2cb448ae27c0.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1632364-68b7-4dd0-96d3-2cb448ae27c0.png)'
- en: 'In the preceding code block, we have seen an autocorrelation example using
    the NumPy module. Let''s compute the autocorrelation plot produced by `pandas`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用NumPy模块看到了一个自相关示例。现在让我们计算由`pandas`生成的自相关图：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This results in the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/022ddef4-7af7-4af0-84d0-38d6d7e85a29.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/022ddef4-7af7-4af0-84d0-38d6d7e85a29.png)'
- en: In the preceding code block, we have produced an autocorrelation plot using
    the `autocorrelation_plot()` function of the `pandas` library. It is easier to
    draw the autocorrelation plot using the `pandas` library compared to the NumPy
    library. Let's now jump to autoregressive models for time-series prediction.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用`pandas`库的`autocorrelation_plot()`函数生成了自相关图。与NumPy库相比，使用`pandas`库更容易绘制自相关图。现在让我们跳到自回归模型进行时间序列预测。
- en: Autoregressive models
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自回归模型
- en: 'Autoregressive models are time-series models used to predict future incidents.
    The following formula shows this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归模型是用于预测未来事件的时间序列模型。以下公式展示了这一点：
- en: '![](img/b8354b08-b851-4de9-bc55-6ed57d7a43ac.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8354b08-b851-4de9-bc55-6ed57d7a43ac.png)'
- en: In the preceding formula, *c* is a constant and the last term is a random component,
    also known as white noise.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的公式中，*c*是常数，最后一项是随机成分，也称为白噪声。
- en: 'Let''s build the autoregression model using the `statsmodels.tsa` subpackage:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`statsmodels.tsa`子包构建自回归模型：
- en: 'Import the libraries and read the dataset:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入库并读取数据集：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Split the Sunspot data into train and test sets:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将日冕数据拆分为训练集和测试集：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Train and fit the autoregressive model:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练并拟合自回归模型：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This results in the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code, we have read the Sunspot dataset and split it into two
    parts: train and test sets. Then, we built the autoregressive model by creating
    an instance and fitting a model. Let''s make predictions and assess the model''s
    performance.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们读取了Sunspot数据集并将其分成了两部分：训练集和测试集。然后，我们通过创建实例并拟合模型构建了自回归模型。接下来，我们进行预测并评估模型的性能。
- en: 'Perform predictions and assess the model:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行预测并评估模型：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This results in the following output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code block, we have made the predictions on the test dataset
    and assessed the model's performance using **Mean Absolute Error** (**MAE**),
    **Mean Squared Error** (**MSE**), and **Root Mean Squared Error** (**RMSE**).
    Let's plot the line plot for the original series and prediction series.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们对测试数据集进行了预测，并使用**平均绝对误差**（**MAE**）、**均方误差**（**MSE**）和**均方根误差**（**RMSE**）评估了模型的性能。接下来，我们绘制原始序列和预测序列的折线图。
- en: 'Let''s plot the predicted and original series to understand the forecasting
    results in a better way:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们绘制预测序列和原始序列，以便更好地理解预测结果：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This results in the following output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/7ee59e6a-6336-42ce-be84-475d25d70eb6.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ee59e6a-6336-42ce-be84-475d25d70eb6.png)'
- en: In the preceding plot, we can see the original series and predicted series using
    the autoregressive model. After generating the autoregressive model, we need to
    jump to one more advanced approach for time-series prediction, which is **Autoregressive
    Moving Average** (**ARMA**).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到使用自回归模型得到的原始序列和预测序列。在生成了自回归模型后，我们需要进入时间序列预测的另一个高级方法——**自回归移动平均**（**ARMA**）。
- en: ARMA models
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARMA模型
- en: 'The ARMA model blends autoregression and moving averages. The ARMA model is
    commonly referred to as ARMA(*p*,*q*), where *p* is the order of the autoregressive
    part, and *q* is the order of the moving average:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ARMA模型结合了自回归和移动平均。ARMA模型通常称为ARMA(*p*,*q*)，其中*p*是自回归部分的阶数，*q*是移动平均部分的阶数：
- en: '![](img/46808db6-b1c1-4d1a-90fb-2818aad116fd.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46808db6-b1c1-4d1a-90fb-2818aad116fd.png)'
- en: 'In the preceding formula, just like in the autoregressive model formula, we
    have a constant and a white noise component; however, we try to fit the lagged
    noise components as well:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的公式中，就像在自回归模型公式中一样，我们有一个常数项和一个白噪声分量；但是，我们还尝试拟合滞后的噪声分量：
- en: 'Import the libraries and read the dataset:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入库并读取数据集：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Split the Sunspot data into train and test sets:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Sunspot数据集分成训练集和测试集：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Train and fit the autoregressive model:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练并拟合自回归模型：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Perform predictions and assess the model:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行预测并评估模型：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This results in the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s plot the predicted and original series to understand the forecasting
    results in a better way:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们绘制预测序列和原始序列，以便更好地理解预测结果：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This results in the following output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/cd0b9027-d622-4cff-920c-8a7a04fbfab1.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd0b9027-d622-4cff-920c-8a7a04fbfab1.png)'
- en: 'In the preceding code, we have read the Sunspot dataset and split it into two
    parts: train and test sets. Then, we built the ARMA model by creating an instance
    and fitting a model. We made the predictions on the test dataset and assessed
    the model performance using MAE, MSE, and RMSE. Finally, we saw the line plot
    for the original series and prediction series. Let''s jump to one more important
    topic, which is generating periodic signals.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们读取了Sunspot数据集并将其分成了两部分：训练集和测试集。然后，我们通过创建实例并拟合模型构建了ARMA模型。我们对测试数据集进行了预测，并使用MAE、MSE和RMSE评估了模型性能。最后，我们查看了原始序列和预测序列的折线图。接下来，我们将讨论另一个重要主题——生成周期性信号。
- en: Generating periodic signals
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成周期性信号
- en: 'Many natural phenomena are regular and trustworthy, such as an accurate clock.
    Some phenomena exhibit patterns that seem regular. A group of scientists found
    three cycles in the sunspot activity with the Hilbert-Huang transform (see [https://en.wikipedia.org/wiki/Hilbert%E2%80%93Huang_transform](https://en.wikipedia.org/wiki/Hilbert%E2%80%93Huang_transform)).
    The cycles have a duration of 11, 22, and 100 years, approximately. Normally,
    we would simulate a periodic signal using trigonometric functions such as a sine
    function. You probably remember a bit of trigonometry from high school. That''s
    all we need for this example. Since we have three cycles, it seems reasonable
    to create a model that is a linear combination of three sine functions. This just
    requires a tiny adjustment of the code for the autoregressive model:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 许多自然现象是规律和可靠的，比如准确的时钟。有些现象展现出看似规律的模式。一组科学家发现，利用Hilbert-Huang变换（参见[https://en.wikipedia.org/wiki/Hilbert%E2%80%93Huang_transform](https://en.wikipedia.org/wiki/Hilbert%E2%80%93Huang_transform)）可以发现太阳黑子活动有三个周期，分别为大约11年、22年和100年。通常，我们会使用三角函数，如正弦函数，来模拟周期信号。你可能记得高中时学过一点三角学。对于这个例子来说，这些知识就足够了。因为我们有三个周期，所以看起来合理的是创建一个由三个正弦函数线性组合而成的模型。这只需要对自回归模型的代码进行一点小的调整：
- en: 'Create model, error, and fit functions:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建模型、误差和拟合函数：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s load the dataset:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载数据集：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Apply and fit the model:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用并拟合模型：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Print the results:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印结果：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This results in the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first line displays the coefficients of the model we attempted. We have
    an MAE of 44, which means that we are off by that amount in either direction on
    average. We also want the coefficient of determination to be as close to 1 as
    possible to have a good fit. Instead, we get a negative value, which is undesirable.
    Let's create a graph to understand the results in detail.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行显示了我们尝试的模型的系数。我们的MAE是44，意味着我们平均偏离这个值无论是正向还是反向。我们还希望决定系数尽可能接近1，这样拟合效果才好。然而，我们得到的是一个负值，这是不理想的。让我们绘制一张图表，详细了解这些结果。
- en: 'Plot the original and predicted series:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制原始数据和预测数据：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This results in the following output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/d5513638-c82d-4233-9cc0-6d3a00b744a0.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5513638-c82d-4233-9cc0-6d3a00b744a0.png)'
- en: From the preceding graph, we can conclude that the model is not able to capture
    the actual pattern of the series. This is why we get a negative coefficient of
    determination or R-squared. Now, we will look at another important technique for
    time-series analysis, Fourier analysis.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表可以得出结论，模型未能捕捉到序列的实际模式。这就是为什么我们得到负的决定系数或R平方值的原因。现在，我们将看另一种重要的时间序列分析技术——傅里叶分析。
- en: Fourier analysis
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 傅里叶分析
- en: 'Fourier analysis uses the Fourier series concept thought up by the mathematician
    Joseph Fourier. The Fourier series is a mathematical method used to represent
    functions as an infinite series of sine and cosine terms. The functions in question
    can be real- or complex-valued:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 傅里叶分析使用了数学家约瑟夫·傅里叶提出的傅里叶级数概念。傅里叶级数是一种将函数表示为正弦和余弦项的无限级数的数学方法。这里的函数可以是实数值或复数值的：
- en: '![](img/09cd1f56-052d-45c9-8953-8386f00c90fc.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09cd1f56-052d-45c9-8953-8386f00c90fc.png)'
- en: For Fourier analysis, the most competent algorithm is **Fast** **Fourier Transform**
    (**FFT**). FFT decomposes a signal into different frequency signals. This means
    it produces a frequency spectrum of a given signal. The SciPy and NumPy libraries
    provide functions for FFT.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于傅里叶分析，最有效的算法是**快速** **傅里叶变换**（**FFT**）。FFT将信号分解为不同频率的信号。这意味着它生成了给定信号的频谱。SciPy和NumPy库提供了FFT的相关函数。
- en: The `rfft()` function performs FFT on real-valued data. We could also have used
    the `fft()` function, but it gives a warning on this Sunspot dataset. The `fftshift()`
    function moves the zero-frequency component to the middle of the spectrum.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`rfft()`函数对实值数据执行FFT。我们也可以使用`fft()`函数，但在这个太阳黑子数据集上会给出警告。`fftshift()`函数将零频率成分移动到频谱的中间。'
- en: 'Let''s see the following example to understand FFT:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来理解FFT：
- en: 'Import the libraries and read the dataset:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入库并读取数据集：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '2\. Compute the FFT for sine waves and sunspots:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 计算正弦波和太阳黑子的FFT：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create the subplots:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建子图：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This results in the following output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/94e62b77-09a9-4614-9f81-fe9a80b38752.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94e62b77-09a9-4614-9f81-fe9a80b38752.png)'
- en: In the preceding code, first, we read the Sunspot dataset and created the sine
    wave. After that, we computed the FFT for the sine wave and the `SUNACTIVITY`
    column. Finally, we plotted the three graphs for the original series and sine
    wave and transformed sunspots and sine wave.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们读取了太阳黑子数据集并创建了正弦波。之后，我们计算了正弦波和`SUNACTIVITY`列的 FFT。最后，我们绘制了原始序列、正弦波以及变换后的太阳黑子和正弦波的三张图。
- en: Spectral analysis filtering
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谱分析滤波
- en: 'In the previous section, we discussed the amplitude spectrum of the dataset.
    Now is the time to explore the power spectrum. The power spectrum of any physical
    signal can display the energy distribution of the signal. We can easily change
    the code and display the power spectrum by squaring the transformed signal using
    the following syntax:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们讨论了数据集的幅度谱。现在是时候探索功率谱了。任何物理信号的功率谱都可以显示信号的能量分布。我们可以通过以下语法轻松地修改代码并通过对变换信号进行平方来显示功率谱：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can also plot the phase spectrum using the following Python syntax:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下 Python 语法绘制相位谱：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s see the complete code for the power and phase spectrum for the Sunspot
    dataset:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下完整的代码，用于计算太阳黑子数据集的功率谱和相位谱：
- en: 'Import the libraries and read the dataset:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入库并读取数据集：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Compute `FFT`, `Spectrum`, and `Phase`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 `FFT`、`Spectrum` 和 `Phase`：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create the subplot:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建子图：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This results in the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/89e49697-731b-4b91-ad92-092f2664662f.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89e49697-731b-4b91-ad92-092f2664662f.png)'
- en: In the preceding code, first, we read the Sunspot dataset and computed the FFT
    for the `SUNACTIVITY` column. After this, we computed the power and phase spectrum
    for the transformed FFT. Finally, we plotted the three graphs for the original
    series and the power and phase spectrums using subplots.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们读取了太阳黑子数据集并计算了 `SUNACTIVITY` 列的 FFT。然后，我们计算了变换后 FFT 的功率谱和相位谱。最后，我们使用子图绘制了原始序列、功率谱和相位谱的三张图。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, the time-series examples we used were annual sunspot cycles
    data, sales data, and beer production. We learned that it's common to try to derive
    a relationship between a value and another data point or a combination of data
    points with a fixed number of periods in the past in the same time series. We
    learned how moving averages convert the random variation trend into a smooth trend
    using a window size. We learned how the `DataFrame.rolling()` function provides
    `win_type` string parameters for different window functions. Cointegration is
    similar to correlation and is a metric to define the relatedness of two time series.
    We also focused on STL decomposition, autocorrelation, autoregression, the ARMA
    model, Fourier analysis, and spectral analysis filtering.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用的时间序列示例包括年度太阳黑子周期数据、销售数据和啤酒生产数据。我们学到，在同一时间序列中，尝试推导一个值与另一个数据点或一组数据点在过去固定周期内的关系是常见的做法。我们了解到，移动平均通过使用窗口大小将随机变化趋势转换为平滑趋势。我们还学到了
    `DataFrame.rolling()` 函数如何为不同的窗口函数提供 `win_type` 字符串参数。协整与相关性类似，是用来定义两个时间序列之间关系的度量指标。我们还重点讲解了
    STL 分解、自相关、自动回归、ARMA 模型、傅里叶分析和谱分析滤波。
- en: The next chapter, [Chapter 9](f3b0dd01-2d5b-41dc-9878-3b7f7eff5e66.xhtml), *Supervised
    Learning – Regression Analysis*, will focus on the important topics of regression
    analysis and logistic regression in Python. The chapter starts with multiple linear
    regression, multicollinearity, dummy variables, and model evaluation measures.
    In the later sections of the chapter, the focus will be on logistic regression.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，[第9章](f3b0dd01-2d5b-41dc-9878-3b7f7eff5e66.xhtml)，*监督学习 – 回归分析*，将重点讲解回归分析和逻辑回归在
    Python 中的重要主题。章节首先介绍了多元线性回归、多重共线性、虚拟变量和模型评估指标。在后面的部分，将重点讨论逻辑回归。
