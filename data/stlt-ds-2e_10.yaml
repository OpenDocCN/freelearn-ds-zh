- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Improving Job Applications with Streamlit
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Streamlit 改进求职申请
- en: At this point in this book, you should already be an experienced Streamlit user.
    You have a good grasp of everything – from Streamlit design to deployment, to
    data visualization, and everything in between. This chapter is designed to be
    application-focused; it will show you some great use cases for Streamlit applications
    so that you can be inspired to create your own! We will start by demonstrating
    how to use Streamlit for **Proof-of-Skill Data Projects**. Then, we will move
    on to discuss how to use Streamlit in the **Take-Home** sections of job applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书这一章时，您应该已经是一个经验丰富的 Streamlit 用户。您已经对一切有了充分的掌握——从 Streamlit 设计到部署，再到数据可视化，以及其中的所有内容。本章重点关注应用，它将向您展示一些
    Streamlit 应用的优秀用例，激发您创造自己的应用！我们将从演示如何使用 Streamlit 进行**技能证明数据项目**开始。然后，我们将讨论如何在求职申请的**自述部分**使用
    Streamlit。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using Streamlit for proof-of-skill data projects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Streamlit 进行技能证明数据项目
- en: Improving job applications in Streamlit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Streamlit 中改进求职申请
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is a list of software and hardware installations that are required
    for this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章所需的软件和硬件安装列表：
- en: '`streamlit-lottie`: We already installed this library in our Components chapter,
    but if you have yet to install it, now is a great time! To download this library,
    run the following code in your Terminal:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`streamlit-lottie`：我们已经在组件章节中安装了这个库，但如果您还没有安装，现在是个好时机！要下载这个库，请在终端中运行以下代码：'
- en: '[PRE0]'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Interestingly, `streamlit-lottie` uses the `lottie` open-source library, which
    allows us to add web-native animations (such as a GIF) to our Streamlit apps.
    Frankly, it is a wonderful library that you can use to beautify Streamlit apps
    and was created by Fanilo Andrianasolo, a prolific Streamlit app creator.
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有趣的是，`streamlit-lottie` 使用了 `lottie` 开源库，允许我们将 Web 原生动画（例如 GIF）添加到我们的 Streamlit
    应用程序中。坦率地说，这是一个极好的库，您可以用它来美化 Streamlit 应用程序，它是由富有创造力的 Streamlit 应用程序开发者 Fanilo
    Andrianasolo 创建的。
- en: 'The job application example folder: The central repository for this book can
    be found at [https://github.com/tylerjrichards/Streamlit-for-Data-Science](https://github.com/tylerjrichards/Streamlit-for-Data-Science).
    Within this repository, the `job_application_example` folder will contain some
    of the files that you will need for the second section of the chapter, covering
    job applications. If you do not have this main repository downloaded already,
    use the following code in your Terminal to clone it:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求职申请示例文件夹：本书的中央仓库可以在 [https://github.com/tylerjrichards/Streamlit-for-Data-Science](https://github.com/tylerjrichards/Streamlit-for-Data-Science)
    找到。在这个仓库中，`job_application_example` 文件夹将包含您在本章第二部分关于求职申请所需的一些文件。如果您还没有下载这个主仓库，请在终端中运行以下代码以克隆它：
- en: '[PRE1]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have everything set up, let’s begin!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了所有的设置，开始吧！
- en: Using Streamlit for proof-of-skill data projects
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Streamlit 进行技能证明数据项目
- en: Proving to others that you are a skilled data scientist is notoriously difficult.
    Anyone can put Python or machine learning on their résumé or even work in a research
    group at a university that might involve some machine learning. But often, recruiters,
    professors you want to work with, and data science managers rely on things on
    your résumé that are proxies for competence, such as having attended the “right”
    university or already having a fancy data science internship or job.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 向他人证明自己是一个熟练的数据科学家是出了名的困难。任何人都可以在简历上写上 Python 或机器学习，甚至可以在一个可能涉及一些机器学习的大学研究小组工作。但通常，招聘人员、你想合作的教授以及数据科学经理们依赖于简历中的一些替代品来衡量你的能力，例如是否毕业于“名校”，或者是否已经有了一个体面的数据科学实习或工作。
- en: Prior to Streamlit, there were not many effective ways to show off your work
    quickly and easily. If you put a Python file or Jupyter notebook on your GitHub
    profile, the time it would take for someone to understand whether the work was
    impressive or not was too much of a risk to take. If the recruiter has to click
    on the right repository in your GitHub profile and then click through numerous
    files until they find a Jupyter notebook with unreadable code (without comments),
    you’ve already lost them. If the recruiter sees “machine learning” on your résumé,
    but it takes five clicks to see any machine learning product or code that you’ve
    written, you’ve already lost them. Most interested parties will spend a very small
    amount of time on your résumé; for example, on average, visitors to my personal
    portfolio site ([www.tylerjrichards.com](http://www.tylerjrichards.com)) spend
    around 2 minutes on the site before moving elsewhere. If this is a recruiter,
    I need to make sure they get a grasp of who I am and why I might be a good candidate
    quickly!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Streamlit出现之前，并没有很多有效的方法可以快速且轻松地展示你的作品。如果你将一个Python文件或Jupyter notebook放在你的GitHub个人资料上，那么让别人理解这项工作是否令人印象深刻的时间就变得太长，风险太大。如果招聘者必须点击你GitHub个人资料中的正确仓库，然后再点击多个文件，直到他们找到一个没有注释的、无法读取的Jupyter
    notebook代码，你就已经失去了他们。如果招聘者在你的简历上看到“机器学习”，但需要点击五次才能看到你编写的任何机器学习产品或代码，你也已经失去了他们。大多数感兴趣的人员在简历上的停留时间非常短；例如，访问我个人作品集网站的访客（[www.tylerjrichards.com](http://www.tylerjrichards.com)）平均在该站点停留约2分钟后就会离开。如果这个人是招聘者，我需要确保他们能快速理解我是谁，以及为什么我可能是一个合适的候选人！
- en: One solution to this issue is to try creating and sharing Streamlit apps that
    are specific to the skills that you would like to showcase the most broadly. For
    instance, if you have a lot of experience in fundamental statistics, you might
    create a Streamlit app that proves, or illustrates, a fundamental statistical
    theorem such as the central limit theorem – just as we did earlier in this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是尝试创建并分享Streamlit应用，这些应用专门展示你最想展示的技能。例如，如果你在基础统计学方面有很多经验，你可以创建一个Streamlit应用，证明或阐明一个基础统计定理，例如中心极限定理——就像我们在本书中早些时候所做的那样。
- en: If instead, you have experience in natural language processing, you could create
    an app that shows off a new text-generating neural network that you have created.
    The point here is to minimize the number of clicks someone would need to make
    until they get proof of your competence within a desired area.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有自然语言处理方面的经验，你可以创建一个展示你所开发的文本生成神经网络的应用。这里的重点是尽量减少用户需要点击的次数，直到他们能够看到你在某一领域的能力。
- en: Many of the Streamlit apps that we have created already do serve this purpose.
    Let’s run through a few examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建的许多Streamlit应用程序确实达到了这个目的。让我们看几个例子。
- en: Machine learning – the Penguins app
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器学习 - Penguins应用
- en: In *Chapter 4*, *Machine Learning and AI with Streamlit*, we created a random
    forest model that was trained on our Palmer Penguins dataset to predict the species
    of penguin according to features such as weight, island of habitation, and bill
    length. Then, we saved that model so that we could use it in our Streamlit app.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第四章*，*使用Streamlit进行机器学习与人工智能*中，我们创建了一个随机森林模型，该模型在我们的Palmer Penguins数据集上进行训练，根据诸如体重、栖息岛屿和喙长等特征预测企鹅的物种。然后，我们保存了该模型，以便在我们的Streamlit应用中使用。
- en: 'Before proceeding to create the Streamlit app, we need (in the first iteration)
    to run the following code, which will create the deployed model:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始创建Streamlit应用之前，我们需要（在第一次迭代中）运行以下代码，这将创建部署的模型：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this first section, we import our libraries, load our data, and train/evaluate
    our model while printing out the evaluation results. Then, we save the model results
    to the `pickle` files using the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们导入库，加载数据，并训练/评估我们的模型，同时打印出评估结果。然后，我们使用以下代码将模型结果保存为`pickle`文件：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Recall that at the end of the chapter, we added a new feature so that if a user
    uploaded their own dataset, they could use our model training script to train
    a model entirely on their data (provided it was in the same format; it came with
    some preconditions).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在本章结束时，我们增加了一个新功能，以便如果用户上传自己的数据集，他们可以使用我们的模型训练脚本在他们的数据上完全训练一个模型（前提是数据格式相同；这带有一些先决条件）。
- en: This app, in its final form, shows that we have at least some knowledge about
    data cleaning, how to do one-hot encoding on our variables, how we think about
    evaluating our models on test data, and finally, how to deploy our pre-trained
    models in an application. That alone is going to look much better than just putting
    “machine learning” on our résumé, and it shows evidence of some of the skills
    that we have. Without this proof of skill, the recruiter or hiring manager who
    is looking at our application will have to either trust that we are being entirely
    honest on our résumé (and from reading hundreds of résumés over the years, that
    is a bad assumption to make) or use a proxy for confidence such as a university
    degree (this is also a bad proxy for assessing competence).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用的最终形式展示了我们至少对数据清洗有所了解，知道如何对变量进行独热编码，如何评估模型在测试数据上的表现，最后，如何将我们训练好的模型部署到应用中。单单这一点，相较于在简历上仅仅写上“机器学习”，它看起来要好得多，并且能证明我们具备一些实际技能。如果没有这一技能的证明，招聘人员或招聘经理在查看我们的申请时，要么只能完全信任我们简历上的内容（而从多年阅读数百份简历的经验来看，这是一个很差的假设），要么只能依赖如大学学位这样的替代指标（这也是一个评估能力的糟糕替代标准）。
- en: In addition to this, when we deploy this app to Streamlit Community Cloud and
    use a public GitHub repository (i.e., like we did in *Chapter 5*, *Deploying Streamlit
    with Streamlit Community Cloud*), we get an automatic feature that comes free
    in our app, which is a GitHub repo button. As you can see in the following screenshot,
    when we deploy our apps to Streamlit Community Cloud, a button is added to the
    top right of the user’s view that allows them to view the source code behind the
    app. If you are the owner of the app, you will see a **Share** button as well,
    which lets you share the app with others!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，当我们将这个应用部署到 Streamlit Community Cloud 并使用公共 GitHub 仓库（即像我们在*第 5 章*，*通过
    Streamlit Community Cloud 部署 Streamlit* 中所做的那样），我们将自动获得一个免费的功能，那就是 GitHub 仓库按钮。如以下截图所示，当我们将应用部署到
    Streamlit Community Cloud 时，应用右上方会添加一个按钮，允许用户查看背后的源代码。如果你是该应用的所有者，你还会看到一个**分享**按钮，可以让你与他人分享应用！
- en: '![](img/B18444_10_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_10_01.png)'
- en: 'Figure 10.1: The View app source option'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：查看应用源选项
- en: In this way, users can always check to make sure malicious code (for example,
    whether a researcher’s Penguin data is being stored by the app) is not being deployed
    by Streamlit Community Cloud. As a secondary feature, the user can also view the
    code that you wrote to build the app, which improves the ability for us to use
    Streamlit as a **Proof-of-Skill** tool.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，用户可以随时检查，确保没有恶意代码（例如，研究人员的企鹅数据是否被应用存储）被 Streamlit Community Cloud 部署。作为一个附加功能，用户还可以查看你为构建应用所写的代码，这提高了我们将
    Streamlit 作为**技能证明**工具的能力。
- en: Visualization – the Pretty Trees app
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化 – 美丽的树应用
- en: 'In *Chapter 6*, *Beautifying Streamlit Apps*, we worked on a Streamlit application
    that could create beautiful and dynamic visualizations of trees in San Francisco,
    which resulted in the following app:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 6 章*，*美化 Streamlit 应用*中，我们曾经开发了一个 Streamlit 应用，它能够创建关于旧金山树木的美丽动态可视化，最终产生了以下这个应用：
- en: '![Figure 9.2 – Mapping a web app ](img/B18444_10_02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 映射一个网页应用](img/B18444_10_02.png)'
- en: 'Figure 10.2: Mapping a web app'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：映射一个网页应用
- en: 'Within this app, we had to create multiple different visualizations (that is,
    two histograms and one map) that dynamically updated based on the user inputs
    on the right-hand side. With an app like this, we were able to show off our data
    manipulation skills, our familiarity with the `pandas`, `matplotlib`, and `seaborn`
    libraries, and even that we understood how to deal with datetimes in Python. Let’s
    take a look at the section of the app’s code that focuses on visualization:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用中，我们需要创建多个不同的可视化（即两个直方图和一张地图），这些可视化会根据右侧的用户输入动态更新。通过这样的应用，我们展示了数据处理能力，熟悉
    `pandas`、`matplotlib` 和 `seaborn` 库的能力，甚至证明了我们理解如何在 Python 中处理日期时间。让我们来看看专注于可视化的应用代码部分：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code is fairly easy to read for anyone who is familiar with Python or other
    scripting languages, and it is a heck of a lot better than simply putting “data
    visualization” or “pandas” on a résumé.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对于任何熟悉 Python 或其他脚本语言的人来说都相当容易阅读，而且它比简单地在简历上写“数据可视化”或“pandas”要好得多。
- en: At this point, I hope you are convinced. Streamlit apps are an excellent way
    to showcase your work to recruiters, potential hiring managers, or anyone to whom
    you need to prove your set of skills. In the next section, we will cover this
    process in a little more detail and demonstrate how to use Streamlit to bolster
    your applications to companies that you might want to work for.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我希望你已经信服了。Streamlit应用是向招聘人员、潜在的招聘经理或任何需要证明你技能的人展示你工作的绝佳方式。在接下来的部分，我们将更详细地介绍这个过程，并演示如何使用Streamlit增强你向心仪公司提交的申请。
- en: Improving job applications in Streamlit
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Streamlit中改进职位申请
- en: Often, data science and machine learning job applications rely on take-home
    data science challenges to judge candidates. Frankly, this is a brutal and annoying
    experience that companies can demand because of the dynamic between the applicant
    and the employer. For instance, it could take a candidate 5–10 hours to fully
    complete a data science challenge, but it might only take the employer 10 minutes
    to evaluate it. Additionally, an individual virtual or telephone interview might
    take 30–45 minutes for the employer, plus an extra 15 minutes to write up feedback,
    compared to the same 30–45 minutes for the applicant. Because getting 5–10 hours
    of work gives them a very high signal per minute of employee time, employers have
    trended toward including these challenges within their job applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学和机器学习职位申请通常依赖于带回家的数据科学挑战来评估候选人。坦率地说，这是一个残酷且令人烦恼的过程，因为在申请人与雇主之间存在动态关系。例如，候选人可能需要花费5到10个小时来完成一个数据科学挑战，但雇主可能只需要10分钟就能评估完成情况。此外，个人的虚拟或电话面试可能需要雇主30到45分钟的时间，再加上额外的15分钟来写反馈，而候选人同样需要花费30到45分钟。因为获得5到10小时的工作为雇主提供了每分钟非常高的员工时间信号，雇主倾向于在职位申请中加入这些挑战。
- en: You can use the opportunity here to use Streamlit to stand out from the crowd
    by creating a fully functioning application instead of sending the company a Jupyter
    notebook, Word document, or PowerPoint deck.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用这个机会通过创建一个完全功能的应用来脱颖而出，而不是发送公司一个Jupyter笔记本、Word文档或PowerPoint演示文稿。
- en: Questions
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s walk through a fictional example about a job applicant who is in the
    middle of applying to a major US airline. They are given two main questions to
    solve – one has a dataset included:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个虚构的例子来讲解一个正在申请美国主要航空公司职位的求职者。他们被给出了两个主要问题来解决——其中一个包含数据集：
- en: 'Question 1: Airport distance'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题1：机场距离
- en: The first exercise asks, “*Given the included dataset of airports and locations
    (in latitude and longitude), write a function that takes an airport code as input
    and returns the airports listed from nearest to furthest from the input airport.*”
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个练习问道：“*鉴于包含的机场和位置数据集（纬度和经度），编写一个函数，该函数接受一个机场代码作为输入，并返回从输入机场最近到最远的机场列表。*”
- en: 'Question 2: Representation'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题2：表示法
- en: The second question asks, “*How would you transform a collection of searches
    into a numeric vector representing a trip? Assume that we have hundreds of thousands
    of users and we want to represent all of their trips this way. Ideally, we want
    this to be a general representation that we could use in multiple different modeling
    projects, but we definitely care about finding similar trips. How, precisely,
    would you compare two trips to see how similar they are? What information do you
    feel might be missing from the preceding data that would help improve your representation?*”
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个问题问道：“*你会如何将一组搜索转换为表示一次旅行的数值向量？假设我们有数十万用户，我们希望以这种方式表示他们的所有旅行。理想情况下，我们希望这是一个通用表示，可以在多个不同的建模项目中使用，但我们显然关心的是找到相似的旅行。你具体会如何比较两次旅行，看它们有多相似？你认为前述数据中缺少什么信息会帮助改进你的表示方式？*”
- en: Now that we have the required questions, we can get a new Streamlit app started.
    To do this, I went through the same process that we have used in each chapter
    thus far. We create a new folder for our app within our central folder (`streamlit_apps`),
    called `job_application_example`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了所需的问题，我们就可以启动一个新的Streamlit应用。为此，我按照每一章到目前为止我们使用的相同流程操作。我们在我们的中央文件夹（`streamlit_apps`）中创建一个新的文件夹，命名为`job_application_example`。
- en: 'Within this folder, we can create a Python file, called `job_streamlit.py`,
    in our Terminal, using the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹中，我们可以创建一个Python文件，命名为`job_streamlit.py`，并在终端中使用以下命令：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Answering Question 1
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回答问题1
- en: It is not hugely important for you to understand exactly how to answer the problem
    at hand (calculating airport distances), but the overall framework of creating
    Streamlit apps is quite important. The Streamlit app we create should read like
    an incredibly dynamic document that answers the question in a unique way, depending
    on the ability of Streamlit to make an application that could not easily be replicated
    by an applicant with a Word document.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对您来说，理解如何解答当前问题（计算机场距离）并不至关重要，但创建Streamlit应用程序的整体框架非常重要。我们创建的Streamlit应用程序应该像一份极具动态性的文档，以独特的方式回答问题，取决于Streamlit能够创建一个无法轻易通过Word文档复制的应用程序。
- en: 'To begin, we can create a title that introduces us and kicks off the format
    for the whole application. One improvement here is to add an optional animation
    at the top of the application using the `streamlit-lottie` library that we learned
    about in *Chapter 7*, *Exploring Streamlit Components*, as shown in the following
    code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以创建一个标题来介绍我们自己，并启动整个应用程序的格式。这里有一个改进，可以使用我们在*第7章*《探索Streamlit组件》中学习到的`streamlit-lottie`库，在应用程序的顶部添加一个可选动画，如以下代码所示：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code will create an application with a beautiful airplane animation
    at the top, as presented in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建一个包含美丽飞机动画的应用程序，如以下截图所示：
- en: '![Figure 9.3 – An airplane GIF  ](img/B18444_10_03.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 一架飞机GIF](img/B18444_10_03.png)'
- en: 'Figure 10.3: An airplane animation'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：飞机动画
- en: 'Next, we need to copy and paste the question below our subheader. Streamlit
    has many options for putting text into applications. One option that we have not
    used yet is to wrap our text inside three apostrophe signs, which tells Streamlit
    to write this text using the Markdown language. This is useful for large blocks
    of text, such as the following one, which begins to answer the first question:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将问题复制并粘贴到子标题下方。Streamlit提供了许多将文本插入应用程序的选项。我们还没有使用的一个选项是将文本包裹在三个撇号符号内，这告诉Streamlit使用Markdown语言来写入这些文本。对于大段的文本，这是非常有用的，比如下面的这个，它开始回答第一个问题：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As mentioned in the *Technical requirements* section of this chapter, two files
    are needed to complete this application. The first is the dataset of the airport
    locations (called `airport_location.csv`), and the second is a picture that shows
    the Haversine distance (that is, the distance between two points on a sphere;
    the file is appropriately named `haversine.png`). Please copy those files into
    the same folder as the Streamlit application Python file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章的*技术要求*部分所述，完成此应用程序需要两个文件。第一个是机场位置的数据集（名为`airport_location.csv`），第二个是展示哈弗辛距离的图片（即球面上两点之间的距离；该文件恰当地命名为`haversine.png`）。请将这些文件复制到与Streamlit应用程序Python文件相同的文件夹中。
- en: 'Now, we need to complete the first step: loading the data. We need to both
    complete this step in Streamlit and also show the code to the user. This is different
    from other Streamlit applications, where the code is hidden in the background.
    However, because the user definitely wants to see our code, as they will be assessing
    us on it, we need to do both. We can use the `st.echo()` function, which we used
    previously, to print out the code block to our app. We can do this with the following
    code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要完成第一步：加载数据。我们既需要在Streamlit中完成此步骤，还需要将代码展示给用户。这与其他Streamlit应用程序不同，后者通常将代码隐藏在后台。然而，因为用户肯定希望看到我们的代码，毕竟他们会基于此进行评估，我们需要同时完成这两个任务。我们可以使用之前使用过的`st.echo()`函数，将代码块打印到我们的应用程序中。我们可以使用以下代码来实现：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I would like to note here that we have placed a comment at the top of this code.
    This is not for the purpose of annotating code for you, the reader, but for the
    application reader. It is good practice to occasionally comment on the purpose
    of the code that you are writing both within the code and in the blocks of text
    before and after; this is so that the reader understands the approach you are
    trying to take. This is especially important in a job application but is a good
    practice for collaborative Streamlit apps, too.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我想指出，我们在此代码的顶部添加了一个注释。这不是为了注解代码以便您理解，而是为了应用程序的读者。偶尔在代码块前后加上关于代码目的的注释是一种好习惯，这样读者就能理解我们所采用的方法。这在求职申请中尤为重要，但对于协作开发的Streamlit应用程序同样也是一种好做法。
- en: 'Our next step is to explain the Haversine formula and show the image in our
    Streamlit application, which we have done in the following code block. It is totally
    acceptable to take a narrative format in your blocks of text. Simply imagine what
    you would like to read as a hiring manager and try to replicate that as well as
    you can:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是解释 Haversine 公式，并在我们的 Streamlit 应用中展示该图片，这在以下代码块中已完成。你完全可以用叙述性的方式编写文本块。只需想象自己是招聘经理，想看到什么样的内容，然后尽量模拟出来：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, our application should look similar to the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用应该类似于以下截图：
- en: '![Figure 9.4 – Loading the data for Question 1 ](img/B18444_10_04.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 加载问题 1 的数据](img/B18444_10_04.png)'
- en: 'Figure 10.4: Loading the data for Question 1'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：加载问题 1 的数据
- en: 'We have our list of items to address, the animation, the Haversine distance
    formula, and the basic code to read in the data. At this point, we need to implement
    the Haversine distance formula in Python and also show our implementation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经列出了要处理的项目，包括动画、Haversine 距离公式，以及读取数据的基础代码。此时，我们需要在 Python 中实现 Haversine
    距离公式，并展示我们的实现：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first section of our code does not create our function but, instead, prints
    out the function that we will create in the Streamlit app. This is so that the
    reader of the application can view both pieces of important code that we have
    written and interact with the code itself. If we had just created a function to
    implement the Haversine distance, the reader of our application would not really
    have known how we solved the problem at hand! The following code block creates
    this function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的第一部分并没有创建函数，而是打印出我们将在 Streamlit 应用中创建的函数。这样做是为了让应用的读者能够查看我们编写的两段重要代码并与代码本身进行互动。如果我们只是创建了一个实现
    Haversine 距离的函数，应用的读者就无法真正了解我们是如何解决当前问题的！以下代码块创建了这个函数：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have completed our Haversine implementation! Whenever we want to find the
    distance between two locations, we can call our formula, input the longitude and
    latitude, and get the distance in kilometers. This app is useful; however, at
    the moment, it is not much better than a Word document. Our next step is to allow
    the user to input their own points to check and see whether the Haversine distance
    is working. Almost no one knows how many kilometers apart two points on the globe
    are, so I have included default points and checked the real distance between them:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 Haversine 实现！每当我们想要计算两地之间的距离时，只需调用我们的公式，输入经度和纬度，即可得到以公里为单位的距离。这个应用很有用，但目前它与
    Word 文档差别不大。我们的下一步是允许用户输入自己的坐标，检查 Haversine 距离是否正常工作。几乎没有人知道地球上两点之间的具体公里数，因此我提供了默认的坐标并验证了它们之间的实际距离：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we put in our default values, the app returns a distance that is approximately
    2 kilometers off, as shown in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入默认值时，应用返回的距离大约偏差 2 公里，如下截图所示：
- en: '![Figure 9.5 – Implementing the Haversine distance  ](img/B18444_10_05.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 实现 Haversine 距离](img/B18444_10_05.png)'
- en: 'Figure 10.5: Implementing the Haversine distance'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5：实现 Haversine 距离
- en: 'At this point, our next step is to combine all of the pieces by using the implemented
    Haversine distance calculator on our given dataset. This is briefly shown in the
    following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的下一步是通过使用已实现的 Haversine 距离计算器，结合给定的数据集。以下截图简要展示了这一过程：
- en: '![](img/B18444_10_06.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_10_06.png)'
- en: 'Figure 10.6: The airport distances that have been given'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6：已给出的机场距离
- en: 'This dataset has airport codes and their corresponding `lat` and `long` values.
    The following code block introduces a solution that combines the two distances
    and leaves out the full `get_distance_list` function, as it is simply a copy of
    the function that we have implemented twice already:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据集包含了机场代码及其对应的 `lat` 和 `long` 值。以下代码块提供了解决方案，结合了两种距离并省略了完整的 `get_distance_list`
    函数，因为它只是我们已经实现过的函数的副本：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we can implement this distance formula on the DataFrame we have been
    given. We can allow the user to input their own airport code from the options
    that we have data on and return the correct values:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在我们获得的 DataFrame 上实现这个距离公式。我们可以允许用户从我们提供数据的机场代码选项中输入自己的代码，并返回正确的值：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is the end of our first question. We can add an optional section at the
    end about how we would change our implementation if we had more time to work on
    this problem. This is always a good idea if you know you only want to spend a
    few hours on the total application, but you also want to demonstrate that you
    know how to improve it if you had more time.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个问题的结尾。我们可以在最后添加一个可选部分，讲述如果我们有更多时间来解决这个问题，我们会如何改变我们的实现。如果你知道自己总共只打算在应用程序上花费几个小时，但又希望展示如果有更多时间，你知道如何改进它，这通常是个不错的主意。
- en: 'An example of this is shown in the following code block, to be placed directly
    after the preceding code block:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块展示了一个示例，应该紧接着前面的代码块放置：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, you could always just end with a statement about the preceding
    code and move on to the second question. At this point, our answer to *Question
    1* is complete and should look similar to the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以选择直接结束前面的代码说明，转而继续处理第二个问题。在这一点上，我们对*问题 1*的回答已经完成，并且应该类似于以下截图：
- en: '![Figure 9.7 – Taking user input  ](img/B18444_10_07.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 获取用户输入](img/B18444_10_07.png)'
- en: 'Figure 10.7: Taking user input'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7：获取用户输入
- en: We have now successfully answered *Question 1*! We can always check the distances
    between these airports by hand to obtain the same result. But let’s move on to
    the second question in our application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在成功地回答了*问题 1*！我们总是可以手动检查这些机场之间的距离，得到相同的结果。但让我们继续处理应用程序中的第二个问题。
- en: Answering Question 2
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回答问题 2
- en: 'The second question is far more straightforward and only asks for text responses.
    Here, the trick is to try to add some lists or Python objects in order to break
    up large paragraphs of text. To begin, we will explain our attempt at answering
    the question and then demonstrate how it might look inside a DataFrame:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题要简单得多，仅要求文本回答。这里的技巧是尽量加入一些列表或 Python 对象，以便将大段的文本分隔开。首先，我们将解释我们尝试回答这个问题的方法，然后展示它在
    DataFrame 中的样子：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we can think of some columns that would be useful for when we are making
    a representation of when a user is searching for flights on this major US airline.
    We can put them into an example DataFrame, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以考虑一些在用户搜索航班时会用到的列。我们可以将它们放入一个示例 DataFrame，如下所示：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For the remainder of the question, we can add a bit of knowledge regarding
    how to find the distance between two points using different methods and then call
    it a day:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于剩下的问题，我们可以加入一些关于如何使用不同方法找到两点之间距离的知识，然后就可以结束了：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The second question’s answer should be similar to the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题的答案应类似于以下截图：
- en: '![Figure 9.8 – Answering Question 2 ](img/B18444_10_08.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 回答问题 2](img/B18444_10_08.png)'
- en: 'Figure 10.8: Answering Question 2'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8：回答问题 2
- en: 'As you can see, this example demonstrates how to approach take-home data assignments
    with the help of the Streamlit library to make more impressive applications. The
    final step of this work is to deploy this Streamlit app and share the link with
    the recruiter. I would strongly advise you to deploy this on Heroku to guarantee
    that no one else can view the questions or the data that has been provided by
    the company. You can also take further precautions, such as putting a textbox
    at the beginning of the application that functions as a password protector (although
    certainly not a good password protector) for the application, as shown in the
    following code block:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个示例展示了如何借助 Streamlit 库处理家庭作业数据任务，以便制作更具吸引力的应用程序。这项工作的最终步骤是部署这个 Streamlit
    应用，并将链接分享给招聘人员。我强烈建议你将它部署到 Heroku，以确保其他人无法查看公司提供的问题或数据。你还可以采取进一步的预防措施，比如在应用程序的开头放置一个文本框，作为密码保护（尽管显然这不是一个好的密码保护措施），如下所示的代码块：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, the entire application will not run unless the user inputs `example_password`
    into the textbox. This is certainly not secure, but it is useful for relatively
    unimportant (at least, in terms of secrecy) applications such as a take-home application:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，除非用户在文本框中输入 `example_password`，否则整个应用程序不会运行。这显然不安全，但对于相对不重要（至少在保密方面）的应用程序，比如家庭作业类应用程序，它是有用的：
- en: '![Figure 9.9 – Entering the password ](img/B18444_10_09.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 输入密码](img/B18444_10_09.png)'
- en: 'Figure 10.9: Entering the password'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9：输入密码
- en: As you can see, the only way for this application to load is if the correct
    password has been entered. Otherwise, the user will see a blank page.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，只有输入正确的密码，应用程序才能加载。否则，用户将看到一个空白页面。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter is the most application-focused chapter we have created so far.
    We focused heavily on job applications and the application cycle for data science
    and machine learning interviews. Additionally, we learned how to password-protect
    our applications, how to create applications that prove to recruiters and data
    science hiring managers that we are the skilled data scientists that we know we
    are, and how to stand out in take-home data science interviews by creating Streamlit
    apps. The next chapter will focus on Streamlit as a toy, and you will learn how
    to create public-facing Streamlit projects for the community.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是我们迄今为止创作的最侧重于实际应用的一章。我们主要关注求职申请以及数据科学和机器学习面试中的申请流程。此外，我们还学习了如何为我们的申请设置密码保护，如何创建能够向招聘人员和数据科学招聘经理证明我们是熟练的数据科学家的申请，以及如何通过创建
    Streamlit 应用程序在数据科学的家庭作业面试中脱颖而出。下一章将重点介绍 Streamlit 作为一个玩具，你将学习如何为社区创建面向公众的 Streamlit
    项目。
- en: Learn more on Discord
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 若要加入本书的 Discord 社区——在这里你可以分享反馈、向作者提问并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/sl](https://packt.link/sl)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/sl](https://packt.link/sl)'
- en: '![](img/QR_Code13440134443835796.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code13440134443835796.png)'
