- en: '*Chapter 5*: Visualizing Data with Pandas and Matplotlib'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：使用 Pandas 和 Matplotlib 可视化数据'
- en: So far, we have been working with data strictly in a tabular format. However,
    the human brain excels at picking out visual patterns; hence, our natural next
    step is learning how to visualize our data. Visualizations make it much easier
    to spot aberrations in our data and explain our findings to others. However, we
    should not reserve data visualizations exclusively for those we present our conclusions
    to, as visualizations will be crucial in helping us understand our data quickly
    and more completely in our exploratory data analysis.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理严格的表格格式数据。然而，人类大脑擅长识别视觉模式；因此，我们的自然下一步是学习如何将数据可视化。可视化使得我们更容易发现数据中的异常，并向他人解释我们的发现。然而，我们不应将数据可视化仅仅保留给向他人呈现结论的人，因为在我们的探索性数据分析中，数据可视化对于帮助我们迅速且全面地理解数据至关重要。
- en: There are numerous types of visualizations that go way beyond what we may have
    seen in the past. In this chapter, we will cover the most common plot types, such
    as line plots, histograms, scatter plots, and bar plots, along with several other
    plot types that build upon these. We won't be covering pie charts—they are notorious
    for being difficult to read properly, and there are better ways to get our point
    across.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种类的可视化远超我们之前可能见过的内容。在本章中，我们将介绍最常见的图表类型，如折线图、直方图、散点图和条形图，以及基于这些类型的一些其他图表。我们不会讨论饼图——它们通常很难正确阅读，而且有更好的方式传达我们的观点。
- en: Python has many libraries for creating visualizations, but the main one for
    data analysis (and other purposes) is `matplotlib`. The `matplotlib` library can
    be a little tricky to learn at first, but thankfully, `pandas` has its own wrappers
    around some of the `matplotlib` functionality, allowing us to create many different
    types of visualizations without needing to write a single line with `matplotlib`
    (or, at least, very few). For more complicated plot types that aren't built into
    `pandas` or `matplotlib`, we have the `seaborn` library, which we will discuss
    in the next chapter. With these three at our disposal, we should be able to create
    most (if not all) of the visualizations we desire. Animations and interactive
    plots are beyond the scope of this book, but you can check out the *Further reading*
    section for more information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有许多用于创建可视化的库，但主要用于数据分析（以及其他目的）的是 `matplotlib`。`matplotlib` 库刚开始学习时可能有点棘手，但幸运的是，`pandas`
    为一些 `matplotlib` 功能提供了自己的封装，使我们能够创建许多不同类型的可视化，而不需要写一行 `matplotlib` 代码（或者至少，写得非常少）。对于那些不在
    `pandas` 或 `matplotlib` 内置的更复杂图表类型，我们有 `seaborn` 库，我们将在下一章讨论。有了这三个工具，我们应该能够创建大多数（如果不是全部）我们所需要的可视化。动画和交互式图表超出了本书的范围，但你可以在*进一步阅读*部分找到更多信息。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: An introduction to matplotlib
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: matplotlib简介
- en: Plotting with pandas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pandas绘图
- en: The pandas.plotting module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pandas.plotting 模块
- en: Chapter materials
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章材料
- en: The materials for this chapter can be found on GitHub at [https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_05](https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_05).
    We will be working with three datasets, all of which can be found in the `data/`
    directory. In the `fb_stock_prices_2018.csv` file, we have the daily opening,
    high, low, and closing prices of Facebook stock from January through December
    2018, along with the volume traded. This was obtained using the `stock_analysis`
    package, which we will build in [*Chapter 7*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146),
    *Financial Analysis – Bitcoin and the Stock Market*. The stock market is closed
    on the weekends, so we only have data for the trading days.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的材料可以在 GitHub 上找到，链接：[https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_05](https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_05)。我们将使用三个数据集，这些数据集都可以在
    `data/` 目录中找到。在 `fb_stock_prices_2018.csv` 文件中，我们有 Facebook 股票从2018年1月到12月的每日开盘价、最高价、最低价和收盘价，以及交易量。这些数据是通过
    `stock_analysis` 包获取的，我们将在[*第7章*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146)，*金融分析
    - 比特币与股票市场*中构建该包。股市在周末休市，因此我们只有交易日的数据。
- en: The `earthquakes.csv` file contains earthquake data collected from the `mag`
    column), the scale it was measured on (the `magType` column), when (the `time`
    column) and where (the `place` column) it occurred, and the `parsed_place` column
    for the state or country where the earthquake occurred (we added this column back
    in [*Chapter 2*](B16834_02_Final_SK_ePub.xhtml#_idTextAnchor035), *Working with
    Pandas DataFrames*). Other unnecessary columns have been removed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`earthquakes.csv`文件包含从`mag`列收集的地震数据，包括震级（`mag`列）、震中测量的尺度（`magType`列）、发生的时间（`time`列）和地点（`place`列），以及标明地震发生所在州或国家的`parsed_place`列（我们在[*第2章*](B16834_02_Final_SK_ePub.xhtml#_idTextAnchor035)，《使用Pandas
    DataFrame》中添加了此列）。其他不必要的列已被删除。'
- en: In the `covid19_cases.csv` file, we have an export from the *daily number of
    new reported cases of COVID-19 by country worldwide* dataset provided by the **European
    Centre for Disease Prevention and Control** (**ECDC**), which can be found at
    [https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide](https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide).
    For scripted or automated collection of this data, the ECDC makes the current
    day's CSV file available via [https://opendata.ecdc.europa.eu/covid19/casedistribution/csv](https://opendata.ecdc.europa.eu/covid19/casedistribution/csv).
    The snapshot we will be using was collected on September 19, 2020 and contains
    the number of new COVID-19 cases per country from December 31, 2019 through September
    18, 2020, with partial data for September 19, 2020\. For this chapter, we will
    look at the 8-month span from January 18, 2020 through September 18, 2020.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在`covid19_cases.csv`文件中，我们有来自**欧洲疾病预防控制中心**（**ECDC**）提供的*全球各国每日新增COVID-19确诊病例数*数据集的导出文件，可以通过[https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide](https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide)获取。对于脚本化或自动化收集此数据，ECDC通过[https://opendata.ecdc.europa.eu/covid19/casedistribution/csv](https://opendata.ecdc.europa.eu/covid19/casedistribution/csv)提供当天的CSV文件。我们将使用的快照数据收集日期为2020年9月19日，包含了2019年12月31日至2020年9月18日各国新增COVID-19病例数，并包含2020年9月19日的部分数据。在本章中，我们将查看2020年1月18日至2020年9月18日这8个月的数据。
- en: Throughout this chapter, we will be working through three notebooks. These are
    numbered in the order they will be used—one for each of the main sections of this
    chapter. We will begin our discussion of plotting in Python with an introduction
    to `matplotlib` in the `1-introducing_matplotlib.ipynb` notebook. Then, we will
    learn how to create visualizations using `pandas` in the `2-plotting_with_pandas.ipynb`
    notebook. Finally, we will explore some additional plotting options that `pandas`
    provides in the `3-pandas_plotting_module.ipynb` notebook. You will be prompted
    when it is time to switch between the notebooks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过三个笔记本进行学习。这些笔记本按使用顺序编号——每个笔记本对应本章的一个主要部分。我们将在`1-introducing_matplotlib.ipynb`笔记本中介绍Python绘图，首先介绍`matplotlib`。然后，我们将在`2-plotting_with_pandas.ipynb`笔记本中学习如何使用`pandas`创建可视化。最后，我们将在`3-pandas_plotting_module.ipynb`笔记本中探索`pandas`提供的一些额外绘图选项。在需要切换笔记本时，系统会提示您。
- en: An introduction to matplotlib
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: matplotlib介绍
- en: 'The plotting capabilities in `pandas` and `seaborn` are powered by `matplotlib`:
    both of these packages provide wrappers around the lower-level functionality in
    `matplotlib`. Consequently, we have many visualization options at our fingertips
    with minimal code to write; however, this comes at a price: reduced flexibility
    in what we can create.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`和`seaborn`的绘图功能由`matplotlib`提供支持：这两个包为`matplotlib`中的底层功能提供了封装。因此，我们只需编写最少的代码，就能拥有丰富的可视化选项；然而，这也有代价：我们在创作时的灵活性有所降低。'
- en: We may find that the `pandas` or `seaborn` implementation isn't quite meeting
    our needs, and, indeed, it may be impossible to override a particular setting
    after creating the plot with them, meaning we will have to do some of the legwork
    with `matplotlib`. Additionally, many of the tweaks that will be made to the final
    appearance of the visualization will be handled with `matplotlib` commands, which
    we will discuss in the next chapter. Therefore, it would greatly benefit us to
    have some understanding of how `matplotlib` works.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会发现`pandas`或`seaborn`的实现无法完全满足我们的需求，实际上，使用它们创建图形后可能无法覆盖某些特定设置，这意味着我们将不得不使用`matplotlib`来完成一些工作。此外，许多对最终可视化效果的微调将通过`matplotlib`命令来处理，我们将在下一章中讨论这些内容。因此，了解`matplotlib`的工作原理将对我们大有裨益。
- en: The basics
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础知识
- en: The `matplotlib` package is rather large since it encompasses quite a bit of
    functionality. Fortunately for us, for most of our plotting tasks, all we need
    is the `pyplot` module, which provides a MATLAB-like plotting framework. Occasionally,
    we will need to import additional modules for other tasks, such as animations,
    changing the style, or altering the default parameters; we will see some examples
    of this in the next chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`matplotlib`包相当大，因为它涵盖了很多功能。幸运的是，对于我们大多数的绘图任务，我们只需要`pyplot`模块，它提供了类似MATLAB的绘图框架。偶尔，我们会需要导入其他模块来处理其他任务，比如动画、改变样式或修改默认参数；我们将在下一章看到一些示例。'
- en: 'Rather than importing the whole `matplotlib` package, we will only import the
    `pyplot` module using the dot (`.`) notation; this reduces the amount of typing
    we need to do in order to access what we need, and we don''t take up more space
    in memory with code we won''t use. Note that `pyplot` is traditionally aliased
    as `plt`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只导入`pyplot`模块，而不是导入整个`matplotlib`包，使用点（`.`）符号；这样可以减少输入量，并且避免在内存中占用不需要的代码空间。请注意，`pyplot`通常会被别名为`plt`：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Before we look at our first plots, let's cover how to actually view them. Matplotlib
    will create our visualizations with the plot commands; however, we won't see the
    visualization until we request to see it. It is done in this fashion so that we
    can continually tweak the visualization with additional code, until we are ready
    to finalize it. Unless we save a reference to our plot, once it is displayed,
    we will have to recreate it to change something. This is because the reference
    to the last plot will have been destroyed to free up resources in memory.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看第一个图形之前，先来了解如何实际查看它们。Matplotlib将通过绘图命令来创建我们的可视化；然而，直到我们请求查看它之前，我们是看不到可视化的。这样做是为了让我们在准备好最终版本之前，能够不断通过额外的代码调整可视化效果。除非我们保存对图形的引用，否则一旦它被显示出来，我们将需要重新创建它以进行更改。这是因为对上一个图形的引用已经被销毁，以释放内存资源。
- en: Matplotlib uses the `plt.show()` function to display the visualization. It must
    be called after each visualization we create. When using the Python shell, it
    will also prevent additional code from being executed until the window is closed
    because it is a blocking function. In Jupyter Notebooks, we can simply use the
    `%matplotlib inline` `%` sign) once, and our visualizations will be automatically
    displayed when the cell with our visualization code is executed. Magic commands
    (or *magics* for short) are run as regular code within a Jupyter Notebook cell.
    If, up to this point in the book, you haven't been keen on using Jupyter Notebooks
    and would like to get that set up now, you can refer to [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015),
    *Introduction to Data Analysis*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib使用`plt.show()`函数来显示可视化。每创建一次可视化都必须调用它。当使用Python Shell时，它还会阻止其他代码的执行，直到窗口被关闭，因为它是一个阻塞函数。在Jupyter
    Notebooks中，我们只需使用一次`%matplotlib inline`，我们的可视化将在执行包含可视化代码的单元时自动显示。魔法命令（或简称*magics*）在Jupyter
    Notebook单元内作为常规代码执行。如果到目前为止你还不热衷于使用Jupyter Notebooks，并希望现在设置它，你可以参考[*第1章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)，*数据分析入门*。
- en: Important note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The `%matplotlib inline` magic embeds static images of the plot into our notebook.
    Another common option is the `%matplotlib notebook` magic. It provides a small
    level of interactivity to the plot by allowing actions such as resizing and zooming,
    though note that this requires some additional setup if you''re using JupyterLab
    and can lead to some confusing bugs, depending on the code that''s running in
    the notebook. Check out this article for more information: [https://medium.com/@1522933668924/using-matplotlib-in-jupyter-notebooks-comparing-methods-and-some-tips-python-c38e85b40ba1](mailto:https://medium.com/@1522933668924/using-matplotlib-in-jupyter-notebooks-comparing-methods-and-some-tips-python-c38e85b40ba1).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`%matplotlib inline` 魔法命令将图表的静态图像嵌入到我们的笔记本中。另一个常见的选项是 `%matplotlib notebook`
    魔法命令。它通过允许进行缩放和调整大小等操作，为图表提供了一定程度的交互性，但请注意，如果你使用 JupyterLab，还需要进行一些额外的设置，而且可能会出现一些困惑的错误，具体取决于笔记本中运行的代码。欲了解更多信息，请查阅此文章：[https://medium.com/@1522933668924/using-matplotlib-in-jupyter-notebooks-comparing-methods-and-some-tips-python-c38e85b40ba1](mailto:https://medium.com/@1522933668924/using-matplotlib-in-jupyter-notebooks-comparing-methods-and-some-tips-python-c38e85b40ba1)。'
- en: 'Let''s create our first plot in the `1-introducing_matplotlib.ipynb` notebook,
    using the Facebook stock prices data from the `fb_stock_prices_2018.csv` file
    in the repository for this chapter. First, we need to import `pyplot` and `pandas`
    (in this example, we will use `plt.show()`, so we don''t need to run the magic
    here):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `1-introducing_matplotlib.ipynb` 笔记本中创建我们的第一个图表，使用本章仓库中的 `fb_stock_prices_2018.csv`
    文件中的 Facebook 股票价格数据。首先，我们需要导入 `pyplot` 和 `pandas`（在这个示例中，我们将使用 `plt.show()`，因此不需要在这里运行魔法命令）：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we read in the CSV file and specify the index as the `date` column, since
    we know what the data looks like from previous chapters:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们读取 CSV 文件，并将 `date` 列指定为索引，因为我们已经知道数据的格式，来自前面的章节：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To understand how Facebook''s stock has evolved over time, we can create a
    line plot of the daily opening price. For this task, we will use the `plt.plot()`
    function, providing the data to be used on the *x*-axis and *y*-axis, respectively.
    We will then follow up with a call to `plt.show()` to display it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 Facebook 股票随时间的变化，我们可以创建一条显示每日开盘价的折线图。对于这个任务，我们将使用`plt.plot()`函数，分别提供用于
    *x* 轴和 *y* 轴的数据。接着，我们会调用`plt.show()`来显示图表：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result is the following plot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下图所示：
- en: '![Figure 5.1 – Our first plot with matplotlib'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 使用 matplotlib 绘制的第一个图表'
- en: '](img/Figure_5.1_B16834.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B16834.jpg)'
- en: Figure 5.1 – Our first plot with matplotlib
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 使用 matplotlib 绘制的第一个图表
- en: If we want to present this visualization, we would have to go back and add our
    axis labels, plot title, legend (if applicable), and possibly fix the *y*-axis
    range; this will be covered in the next chapter when we discuss formatting and
    customizing the appearance of our plots. Pandas and `seaborn` will take care of
    some of this for us, at least.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要展示这个可视化图表，我们需要返回并添加轴标签、图表标题、图例（如果适用），并可能调整 *y* 轴的范围；这些内容将在下一章讨论如何格式化和自定义图表外观时进行讲解。至少，Pandas
    和 `seaborn` 会为我们处理一些部分。
- en: 'For the remainder of this book, we will be using the `%matplotlib inline` magic
    command (remember, this needs to be used in a Jupyter Notebook to work), so we
    won''t be calling `plt.show()` after our plotting code. The following code gives
    the same output as the preceding block:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将使用 `%matplotlib inline` 魔法命令（记住，这个命令仅在 Jupyter Notebook 中有效），所以在绘图代码后，我们将不再调用
    `plt.show()`。以下代码与前面的代码块产生相同的输出：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Important note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be sure to run the `%matplotlib inline` magic command now if you are using a
    Jupyter Notebook. This ensures that the plotting code in the rest of this chapter
    displays the output automatically.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用 Jupyter Notebook，请确保现在运行 `%matplotlib inline` 魔法命令。这将确保本章其余部分的绘图代码能够自动显示输出。
- en: 'We can also use the `plt.plot()` function to generate scatter plots, provided
    that we specify a format string for the plot as the third argument. A format string
    is of the form `''[marker][linestyle][color]''`; for example, `''--k''` for a
    black dashed line. Since we don''t want a line for the scatter plot, we omit the
    `linestyle` component. We can make a scatter plot of red circles with the `''or''`
    format string; here, `o` is for circles and `r` is for the color red. The following
    code generates a scatter plot of high price versus low price. Notice that we can
    pass our dataframe in the `data` argument and then use the string names for the
    columns, instead of passing the series as `x` and `y`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`plt.plot()`函数生成散点图，只要在绘图时指定格式字符串作为第三个参数。格式字符串的形式为`'[marker][linestyle][color]'`；例如，`'--k'`表示黑色虚线。由于我们不希望散点图中显示线条，所以省略了`linestyle`部分。我们可以使用`'or'`格式字符串来绘制红色圆形散点图；其中，`o`代表圆形，`r`代表红色。以下代码生成了一个高价与低价的散点图。请注意，我们可以将数据框传递给`data`参数，然后使用列名字符串，而不是将序列作为`x`和`y`传递：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Barring days of large fluctuations, we would expect the points to be in the
    form of a line, since the high and low prices won''t be far from each other. This
    is true for the most part, but be careful of the scale that was generated automatically—the
    *x*-axis and the *y*-axis don''t line up perfectly:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了大幅波动的日子，我们期望这些点呈现出一条直线的形式，因为高价和低价不会相差太远。这在大多数情况下是正确的，但要小心自动生成的刻度——*x* 轴和 *y*
    轴并未完全对齐：
- en: '![Figure 5.2 – Making a scatter plot with matplotlib'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 使用 matplotlib 创建散点图'
- en: '](img/Figure_5.2_B16834.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.2_B16834.jpg)'
- en: Figure 5.2 – Making a scatter plot with matplotlib
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 使用 matplotlib 创建散点图
- en: 'Note that there is some flexibility in specifying the format string. For instance,
    a format string of the form `''[color][marker][linestyle]''` will work unless
    it is ambiguous. The following table shows some examples of how to formulate a
    format string for a variety of plot styles; the complete list of options can be
    found in the **Notes** section in the documentation at [https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html](https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，指定格式字符串时有一定的灵活性。例如，形如`'[color][marker][linestyle]'`的格式字符串是有效的，除非它具有歧义。下表展示了如何为各种绘图样式构建格式字符串的示例；完整的选项列表可以在文档的**注释**部分找到，地址为[https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html](https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html)：
- en: '![Figure 5.3 – Styling shortcuts for matplotlib'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – matplotlib 的样式快捷方式'
- en: '](img/Figure_5.3_B16834.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.3_B16834.jpg)'
- en: Figure 5.3 – Styling shortcuts for matplotlib
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – matplotlib 的样式快捷方式
- en: The format string is a handy way of specifying many options at once, and the
    good news, as we will see in the *Plotting with pandas* section, is that it works
    with the `plot()` method in `pandas` as well. However, if we would rather specify
    each option separately, we can use the `color`, `linestyle`, and `marker` arguments;
    check out the values we can pass as keyword arguments to `plt.plot()` in the documentation—`pandas`
    will also pass these down to `matplotlib` for us.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串是一种方便的方式，可以一次性指定多个选项，幸运的是，正如我们在*使用 pandas 绘图*部分中将看到的，它同样适用于`pandas`中的`plot()`方法。然而，如果我们宁愿单独指定每个选项，也可以使用`color`、`linestyle`和`marker`参数；可以在文档中查看我们可以作为关键字参数传递给`plt.plot()`的值——`pandas`会将这些参数传递给`matplotlib`。
- en: Tip
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As an alternative to defining styles per variable being plotted, consider trying
    out `cycler` from the `matplotlib` team to specify which combinations `matplotlib`
    should cycle between ([https://matplotlib.org/gallery/color/color_cycler.html](https://matplotlib.org/gallery/color/color_cycler.html)).
    We will see an example of this in [*Chapter 7*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146),
    *Financial Analysis – Bitcoin and the Stock Market*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为为每个绘制变量定义样式的替代方案，可以尝试使用`matplotlib`团队提供的`cycler`，来指定`matplotlib`应当在哪些组合之间循环（[https://matplotlib.org/gallery/color/color_cycler.html](https://matplotlib.org/gallery/color/color_cycler.html)）。我们将在[*第
    7 章*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146)中看到这个例子的应用，*金融分析 – 比特币与股市*。
- en: 'To create histograms with `matplotlib`, we use the `hist()` function instead.
    Let''s make a histogram of the earthquake magnitudes in the `earthquakes.csv`
    file, using those measured with the `ml` magnitude type:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`matplotlib`创建直方图，我们需要使用`hist()`函数。让我们使用`ml`震级类型测量的`earthquakes.csv`文件中的地震震级数据，制作一个直方图：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The resulting histogram gives us an idea of the range of earthquake magnitudes
    we can expect using the `ml` measurement technique:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由此产生的直方图可以帮助我们了解使用`ml`测量技术时，预期地震震级的范围：
- en: '![Figure 5.4 – Making a histogram with matplotlib'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 使用matplotlib绘制直方图](img/Figure_5.4_B16834.jpg)'
- en: '](img/Figure_5.4_B16834.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.4_B16834.jpg)'
- en: Figure 5.4 – Making a histogram with matplotlib
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 使用matplotlib绘制直方图
- en: 'As we could have guessed, the magnitudes tend to be small, and the distribution
    appears to be somewhat normal. However, a word of caution regarding histograms—bin
    size matters. There are cases where we can change the number of bins the data
    is divided into and change what the histogram indicates the distribution to be.
    For example, if we make two histograms for this data using different numbers of
    bins, the distributions look different:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以猜到的那样，震级通常较小，分布看起来相对正常。然而，关于直方图，有一点需要注意——箱子大小很重要。在某些情况下，我们可以通过改变数据被分成的箱子数量，来改变直方图所表示的分布。例如，如果我们使用不同数量的箱子制作两个直方图，分布会看起来不同：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice how the distribution appears unimodal in the left subplot, but seems
    bimodal in the right subplot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，左侧子图中的分布似乎是单峰的，而右侧子图中的分布看起来是双峰的：
- en: '![Figure 5.5 – Different bin sizes can drastically change a histogram'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – 不同的箱子大小会大幅改变直方图'
- en: '](img/Figure_5.5_B16834.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.5_B16834.jpg)'
- en: Figure 5.5 – Different bin sizes can drastically change a histogram
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 不同的箱子大小会大幅改变直方图
- en: Tip
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Some common rules of thumb for selecting the number of bins can be found at
    [https://en.wikipedia.org/wiki/Histogram#Number_of_bins_and_width](https://en.wikipedia.org/wiki/Histogram#Number_of_bins_and_width).
    However, note that, in some cases, a bee swarm plot can be easier to interpret
    than a histogram; this can be created with `seaborn`, as we will see in [*Chapter
    6*](B16834_06_Final_SK_ePub.xhtml#_idTextAnchor125), *Plotting with Seaborn and
    Customization Techniques*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于选择箱子数量的一些常见经验法则，可以参考[https://en.wikipedia.org/wiki/Histogram#Number_of_bins_and_width](https://en.wikipedia.org/wiki/Histogram#Number_of_bins_and_width)。然而，请注意，在某些情况下，蜜蜂群图可能比直方图更容易解释；这一点可以通过`seaborn`来实现，我们将在[*第6章*](B16834_06_Final_SK_ePub.xhtml#_idTextAnchor125)中看到，*使用Seaborn进行绘图及自定义技巧*。
- en: 'There are a couple of additional things to note from this example, which we
    will address in the next section on plot components:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，还有几个额外的注意事项，我们将在下一节的图形组件中讨论：
- en: We can make subplots.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以制作子图。
- en: Plotting functions in `pyplot` can also be used as methods of `matplotlib` objects,
    such as `Figure` and `Axes` objects.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`pyplot`中绘制函数也可以作为`matplotlib`对象的方法使用，例如`Figure`和`Axes`对象。
- en: One last thing regarding basic usage that we will find handy is saving plots
    as images—we shouldn't be limited to showing the figures in Python only. We can
    save the last figure with the `plt.savefig()` function by passing in the path
    to save the image at; for example, `plt.savefig('my_plot.png')`. Note that, if
    `plt.show()` was called prior to saving, the file will be empty, since the reference
    to the last plot will be gone after the call to `plt.show()` (`matplotlib` closes
    the `Figure` object to free up resources in memory). With the `%matplotlib inline`
    magic command, we can both see and save our image in the same cell.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关于基本用法的最后一件事，我们会发现保存图像为图片非常方便——我们不应该仅限于在Python中展示图形。我们可以通过传递保存图像的路径，使用`plt.savefig()`函数来保存最后一张图像；例如，`plt.savefig('my_plot.png')`。请注意，如果在保存之前调用了`plt.show()`，那么文件将是空的，因为在调用`plt.show()`之后，最后一张图形的引用将会消失（`matplotlib`会关闭`Figure`对象以释放内存中的资源）。通过使用`%matplotlib
    inline`魔法命令，我们可以在同一个单元格中同时查看并保存图像。
- en: Plot components
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形组件
- en: In the prior examples using `plt.plot()`, we didn't have to create a `Figure`
    object—`matplotlib` took care of creating it for us in the background. However,
    as we saw when creating *Figure 5.5*, anything beyond a basic plot will require
    a little more legwork, including creating a `Figure` object ourselves. The `Figure`
    class is the top level for `matplotlib` visualizations. It contains the `Axes`
    objects, which themselves contain additional plot objects, such as lines and ticks.
    In the case of subplots, the `Figure` object contains `Axes` objects with additional
    functionality.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前使用`plt.plot()`的例子中，我们不需要创建`Figure`对象——`matplotlib`在后台为我们处理了它。然而，正如我们在创建*图
    5.5*时看到的那样，任何超出基本图形的内容都需要稍微更多的工作，包括我们自己创建`Figure`对象。`Figure`类是`matplotlib`可视化的顶层对象。它包含`Axes`对象，而`Axes`对象本身又包含其他绘图对象，如线条和刻度。对于子图来说，`Figure`对象包含具有附加功能的`Axes`对象。
- en: 'We use the `plt.figure()` function to create `Figure` objects; these will have
    zero `Axes` objects until a plot is added:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`plt.figure()`函数来创建`Figure`对象；这些对象在添加图表之前不会有任何`Axes`对象：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `plt.subplots()` function creates a `Figure` object with `Axes` objects
    for subplots in the arrangement specified. If we ask `plt.subplots()` for one
    row and one column, a `Figure` object with one `Axes` object will be returned.
    This can be useful when writing functions that generate subplot layouts based
    on the input, since we don''t need to worry about needing a special case to handle
    a single subplot. Here, we will specify an arrangement of one row and two columns;
    this returns a `(Figure, Axes)` tuple, which we can unpack:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`plt.subplots()`函数创建一个带有`Axes`对象的`Figure`对象，用于指定排列方式的子图。如果我们请求`plt.subplots()`创建一行一列，它将返回一个包含一个`Axes`对象的`Figure`对象。这在编写根据输入生成子图布局的函数时非常有用，因为我们不需要为单个子图处理特殊情况。这里，我们将指定一行两列的排列方式；这将返回一个`(Figure,
    Axes)`元组，我们可以对其进行解包：'
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When using the `%matplotlib inline` magic command, we will see the figure that
    was created:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`%matplotlib inline`魔法命令时，我们会看到创建的图表：
- en: '![Figure 5.6 – Creating subplots'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – 创建子图'
- en: '](img/Figure_5.6_B16834.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.6_B16834.jpg)'
- en: Figure 5.6 – Creating subplots
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 创建子图
- en: 'The alternative to using `plt.subplots()` would be to use the `add_axes()`
    method on the `Figure` object that we get after running `plt.figure()`. The `add_axes()`
    method takes a list in the form of `[left, bottom, width, height]` as proportions
    of the figure dimensions, representing the area in the figure this subplot should
    occupy:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`plt.subplots()`的替代方法是，在运行`plt.figure()`之后，使用`Figure`对象上的`add_axes()`方法。`add_axes()`方法接受一个列表，形式为`[left,
    bottom, width, height]`，表示子图在图形中占据的区域，它是图形维度的比例：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This enables the creation of plots inside of plots:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得可以在图表内部创建子图：
- en: '![Figure 5.7 – Plot with an inset plot using matplotlib'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – 使用matplotlib绘制带有嵌套图的图表'
- en: '](img/Figure_5.7_B16834.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.7_B16834.jpg)'
- en: Figure 5.7 – Plot with an inset plot using matplotlib
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 使用matplotlib绘制带有嵌套图的图表
- en: 'If our goal is to keep all the plots separate but not all equally sized, we
    can use the `add_gridspec()` method on a `Figure` object to create a grid for
    the subplots. Then, we can run `add_subplot()`, passing in the area(s) from the
    grid that the given subplot should occupy:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的目标是将所有图表分开但不一定是相同大小的，我们可以使用`Figure`对象上的`add_gridspec()`方法来创建子图的网格。然后，我们可以运行`add_subplot()`，传入网格中给定子图应该占据的区域：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This results in the following layout:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下布局：
- en: '![Figure 5.8 – Building custom plot layouts with matplotlib'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8 – 使用matplotlib构建自定义图表布局'
- en: '](img/Figure_5.8_B16834.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.8_B16834.jpg)'
- en: Figure 5.8 – Building custom plot layouts with matplotlib
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 使用matplotlib构建自定义图表布局
- en: 'In the previous section, we discussed how to save visualizations using `plt.savefig()`
    but we also can use the `savefig()` method on `Figure` objects:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了如何使用`plt.savefig()`保存可视化，但我们也可以使用`Figure`对象上的`savefig()`方法：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is very useful to remember since with `plt.<func>()`, we only have access
    to the last `Figure` object; however, if we save the references to our `Figure`
    objects, we can work with any of them, regardless of when they were created. Additionally,
    this foreshadows an important concept that you will notice throughout this chapter:
    `Figure` and `Axes` objects have methods with similar or identical names to their
    `pyplot` function counterparts.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点非常重要，因为使用`plt.<func>()`时，我们只能访问最后一个`Figure`对象；然而，如果我们保存对`Figure`对象的引用，我们就可以操作其中任何一个，不管它们是在什么时候创建的。此外，这也预示了本章中你会注意到的一个重要概念：`Figure`和`Axes`对象具有与其`pyplot`函数对应项相似或相同的方法名称。
- en: 'While it''s convenient to have references to all of the `Figure` objects we
    create, it is good practice to close them when we are done with them so that we
    don''t waste any resources. This can be accomplished with the `plt.close()` function.
    If we don''t pass in anything, it will close the last `Figure` object; however,
    we can pass in a specific `Figure` object to close only that one or `''all''`
    to close all of the `Figure` objects we have open:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管能够引用我们创建的所有`Figure`对象非常方便，但在完成工作后关闭它们是一个好习惯，这样我们就不会浪费任何资源。这可以通过`plt.close()`函数来实现。如果我们不传入任何参数，它将关闭最后一个`Figure`对象；但是，我们可以传入特定的`Figure`对象，以便仅关闭该对象，或者传入`'all'`来关闭我们打开的所有`Figure`对象：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It's important to get comfortable working with `Figure` and `Axes` objects directly
    as it enables more fine-grained control of the resulting visualizations. This
    will become evident in the next chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 直接操作`Figure`和`Axes`对象非常重要，因为这可以让你对结果的可视化进行更精细的控制。下一章中会更加明显地体现这一点。
- en: Additional options
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他选项
- en: 'A few of our visualizations looked a little squished. To remedy this, we can
    pass in a value for `figsize` in our call to `plt.figure()` or `plt.subplots()`.
    We specify the dimensions with a `(width, height)` tuple in inches. The `plot()`
    method we will see with `pandas` also accepts the `figsize` parameter, so bear
    this in mind:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一些可视化图表看起来有些压缩。为了解决这个问题，我们可以在调用`plt.figure()`或`plt.subplots()`时传入`figsize`的值。我们用一个`(宽度,
    高度)`的元组来指定尺寸，单位是英寸。我们将会看到的`pandas`的`plot()`方法也接受`figsize`参数，所以请记住这一点：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice that these subplots are more square-shaped than the subplots in *Figure
    5.6* when we didn''t specify `figsize`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些子图比我们没有指定`figsize`时的*图 5.6*中的子图更接近正方形：
- en: '![Figure 5.9 – Specifying plot size'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.9 – 指定绘图大小'
- en: '](img/Figure_5.9_B16834.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.9_B16834.jpg)'
- en: Figure 5.9 – Specifying plot size
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 指定绘图大小
- en: 'It''s not too bad specifying the `figsize` parameter for our plots one by one.
    However, if we find that we are resizing everything to the same size, there''s
    a better alternative. Matplotlib houses its defaults in `rcParams`, which acts
    like a dictionary, meaning we can easily overwrite what we wish for our session
    and get the defaults back when we restart our Python session. Since there are
    many options in this dictionary (over 300 at the time of writing), let''s randomly
    select a few of them to get an idea of what is available:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的每个图表单独指定`figsize`参数还不算太麻烦。然而，如果我们发现每次都需要调整为相同的尺寸，有一个更好的替代方法。Matplotlib将其默认设置保存在`rcParams`中，`rcParams`像一个字典一样运作，这意味着我们可以轻松覆盖会话中的某些设置，并在重启Python会话时恢复默认值。由于该字典中有许多选项（写作时超过300个），让我们随便选择一些，以了解可用的选项：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, there are many options we can tinker with here. Let''s check
    what the current default value for `figsize` is:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里有许多选项可以调整。让我们检查一下当前`figsize`的默认值是什么：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To change this for our current session, simply set it equal to a new value:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要为当前会话更改此设置，只需将其设置为新值：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before we move on, let''s restore the default settings by using the `mpl.rcdefaults()`
    function. The default value for `figsize` is actually different than what we had
    previously; this is because `%matplotlib inline` sets different values for a few
    of the plot-related parameters when it is first run ([https://github.com/ipython/ipykernel/blob/master/ipykernel/pylab/config.py#L42-L56](https://github.com/ipython/ipykernel/blob/master/ipykernel/pylab/config.py#L42-L56)):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们使用`mpl.rcdefaults()`函数恢复默认设置。`figsize`的默认值实际上与我们之前的不同；这是因为`%matplotlib
    inline`在首次运行时会为一些与绘图相关的参数设置不同的值（[https://github.com/ipython/ipykernel/blob/master/ipykernel/pylab/config.py#L42-L56](https://github.com/ipython/ipykernel/blob/master/ipykernel/pylab/config.py#L42-L56)）：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that we can also use the `plt.rc()` function to update a particular setting
    if we know its group (`figure`, in this case) and parameter name (`figsize`).
    As we did previously, we can use `plt.rcdefaults()` to reset the defaults:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们知道其组（在本例中是`figure`）和参数名称（`figsize`），也可以使用`plt.rc()`函数更新特定的设置。正如我们之前所做的，我们可以使用`plt.rcdefaults()`来重置默认值：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If we find ourselves making the same changes every time we start Python, we
    should look into reading our configuration in rather than updating the default
    values each time. Consult the `mpl.rc_file()` function for more information.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现每次启动Python时都需要做相同的更改，那么我们应该考虑读取配置文件，而不是每次更新默认值。有关更多信息，请参考`mpl.rc_file()`函数。
- en: Plotting with pandas
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pandas进行绘图
- en: 'Both `Series` and `DataFrame` objects have a `plot()` method that allows us
    to create several different plots and control some aspects of their formatting,
    such as subplot layout, figure size, titles, and whether to share an axis across
    subplots. This makes plotting our data much more convenient, as the bulk of the
    work to create presentable plots is achieved with a single method call. Under
    the hood, `pandas` is making several calls to `matplotlib` to produce our plot.
    Some of the most frequently used arguments to the `plot()` method include the
    following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series` 和 `DataFrame` 对象都有一个 `plot()` 方法，可以让我们创建几种不同类型的图表，并控制一些格式方面的内容，如子图布局、图形大小、标题以及是否共享子图之间的坐标轴。这使得绘制数据变得更加方便，因为通过一次方法调用就可以完成大部分用于创建可展示图表的工作。实际上，`pandas`
    在背后调用了多个 `matplotlib` 方法来生成图表。`plot()` 方法中一些常用的参数包括以下内容：'
- en: '![Figure 5.10 – Frequently used pandas plotting arguments'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10 – 常用的 pandas 绘图参数'
- en: '](img/Figure_5.10_B16834.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.10_B16834.jpg)'
- en: Figure 5.10 – Frequently used pandas plotting arguments
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 常用的 pandas 绘图参数
- en: Rather than having separate functions for each plot type, as we saw during our
    discussion of `matplotlib`, the `plot()` method from `pandas` allows us to specify
    the type of plot we want using the `kind` argument. The choice of plot will determine
    which other arguments are required. We can use the `Axes` object that's returned
    by the `plot()` method to further modify our plot.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在讨论 `matplotlib` 时看到的每种图表类型都有单独的函数不同，`pandas` 的 `plot()` 方法允许我们使用 `kind`
    参数来指定我们想要的图表类型。图表类型的选择将决定哪些其他参数是必需的。我们可以使用 `plot()` 方法返回的 `Axes` 对象进一步修改图表。
- en: 'Let''s explore this functionality in the `2-plotting_with_pandas.ipynb` notebook.
    Before we begin, we need to handle our imports for this section and read in the
    data we will be using (Facebook stock prices, earthquakes, and COVID-19 cases):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `2-plotting_with_pandas.ipynb` 笔记本中探索这个功能。在我们开始之前，我们需要处理本节的导入，并读取将要使用的数据（Facebook
    股票价格、地震数据和 COVID-19 病例数据）：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the next few sections, we will discuss how to generate an appropriate visualization
    for a specific analysis goal, such as showing the evolution over time or the relationship
    between the variables in the data. Note that, wherever possible, the plots have
    been styled so that they can be interpreted in black and white for this book.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论如何为特定的分析目标生成合适的可视化图表，比如展示随时间的变化或数据中变量之间的关系。请注意，在可能的情况下，图表已被样式化，使其可以在本书中以黑白形式进行解读。
- en: Evolution over time
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随时间演变
- en: 'When working with time series data (such as the Facebook stock data stored
    in the `fb` variable), we often want to show how the data has changed over time.
    To do this, we use line plots and, in some cases, bar plots (covered in the *Counts
    and frequencies* section). In the case of a line plot, we simply provide `kind=''line''`
    to `plot()`, indicating which columns will be `x` and `y`. Note that we actually
    don''t need to provide a column for `x` because `pandas`, by default, will use
    the index (this also makes it possible to generate the line plot of a `Series`
    object). Additionally, notice that we can provide a format string to the `style`
    argument, just like we did with the `matplotlib` plots:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理时间序列数据时（例如存储在 `fb` 变量中的 Facebook 股票数据），我们通常希望展示数据随时间的变化。为此，我们使用折线图，在某些情况下使用条形图（在*计数与频率*部分中介绍）。对于折线图，我们只需在
    `plot()` 中提供 `kind='line'`，并指定哪些列作为 `x` 和 `y`。请注意，我们实际上不需要为 `x` 提供列，因为 `pandas`
    默认使用索引（这也使得生成 `Series` 对象的折线图成为可能）。此外，注意我们可以像在 `matplotlib` 图表中那样，为 `style` 参数提供格式字符串：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This gives us a plot similar to what we achieved with `matplotlib`; however,
    in this single method call, we specified the figure size for this plot only, turned
    off the legend, and gave it a title:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个与 `matplotlib` 类似的图表；然而，在这次方法调用中，我们只为这个图表指定了图形的大小，关闭了图例，并为其设置了标题：
- en: '![Figure 5.11 – Our first plot with pandas'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11 – 使用 pandas 绘制的第一个图表'
- en: '](img/Figure_5.11_B16834.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.11_B16834.jpg)'
- en: Figure 5.11 – Our first plot with pandas
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 使用 pandas 绘制的第一个图表
- en: 'As with `matplotlib`, we don''t have to use the style format strings—instead,
    we can pass each component separately with its associated keyword. For example,
    the following code gives us the same result as the previous one:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `matplotlib` 一样，我们不必使用样式格式字符串——相反，我们可以将每个组件与其关联的关键字分开传递。例如，以下代码给出的结果与之前的结果相同：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We aren''t limited to plotting one line at a time with the `plot()` method;
    we can also pass in a list of columns to plot and style them individually. Note
    that we actually don''t need to specify `kind=''line''` because that is the default:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在使用 `plot()` 方法时并不局限于一次绘制一条线；我们也可以传递一个列列表来绘制，并单独设置样式。请注意，实际上我们不需要指定 `kind='line'`，因为这是默认值：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This results in the following plot, where each line is styled differently:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下图形，其中每条线的样式不同：
- en: '![Figure 5.12 – Plotting multiple columns'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.12 – 绘制多个列'
- en: '](img/Figure_5.12_B16834.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.12_B16834.jpg)'
- en: Figure 5.12 – Plotting multiple columns
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 绘制多个列
- en: 'Additionally, we can easily have `pandas` plot all our columns in that same
    call. The `x` and `y` arguments can take a single column name or a list of them;
    if we provide nothing, `pandas` will use all of them. Note that the columns must
    be passed as the `y` argument when `kind=''line''`; however, other plot types
    support passing lists of columns to `x` as well. In this case, it may be helpful
    to ask for subplots instead of having all the lines on the same plot. Let''s visualize
    all the columns in the Facebook data as line plots:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以轻松地让 `pandas` 在同一调用中绘制所有列。`x` 和 `y` 参数可以接受单个列名或它们的列表；如果我们不提供任何内容，`pandas`
    将使用所有列。请注意，当 `kind='line'` 时，列必须作为 `y` 参数传递；然而，其他绘图类型也支持将列列表传递给 `x`。在这种情况下，要求子图而不是将所有线条绘制在同一图中可能会更有帮助。让我们将
    Facebook 数据中的所有列作为折线图进行可视化：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using the `layout` argument, we told `pandas` how to arrange our subplots (three
    rows and two columns):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `layout` 参数，我们告诉 `pandas` 如何排列我们的子图（三行两列）：
- en: '![Figure 5.13 – Creating subplots with pandas'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.13 – 使用 pandas 创建子图'
- en: '](img/Figure_5.13_B16834.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.13_B16834.jpg)'
- en: Figure 5.13 – Creating subplots with pandas
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 使用 pandas 创建子图
- en: 'Notice that the subplots automatically share the *x*-axis, since they share
    an index. The *y*-axis is not shared because the `volume` time series is on a
    different scale. We can alter this behavior in some plot types by passing the
    `sharex` or `sharey` argument with a Boolean to `plot()`. The legend will be rendered
    by default, so, for each subplot, we have a single item in the legend indicating
    which data it contains. We didn''t provide a list of subplot titles with the `title`
    argument in this case, since the legend served that purpose; however, we passed
    a single string for the title of the plot as a whole. To summarize, when working
    with subplots, we have two options when it comes to the title:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，子图自动共享 *x* 轴，因为它们共享一个索引。*y* 轴没有共享，因为 `volume` 时间序列的尺度不同。我们可以通过在某些绘图类型中将
    `sharex` 或 `sharey` 参数与布尔值一起传递给 `plot()` 来改变这种行为。默认情况下会渲染图例，因此对于每个子图，我们在图例中有一个单独的项目，表示其包含的数据。在这种情况下，我们没有通过
    `title` 参数提供子图标题列表，因为图例已起到了这个作用；然而，我们为整个图形传递了一个单一字符串作为标题。总结一下，当处理子图时，我们在标题方面有两种选择：
- en: Passing a single string for the title of the figure as a whole.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个字符串作为整个图形的标题。
- en: Passing a list of strings to use as the title for each subplot.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个字符串列表，用作每个子图的标题。
- en: 'Sometimes, we want to make subplots where each has a few variables in them
    for comparison. This can be achieved by first creating the subplots with `plt.subplots()`
    and then providing the `Axes` objects to the `ax` parameter. To illustrate this,
    let''s take a look at daily new cases of COVID-19 in China, Spain, Italy, the
    USA, Brazil, and India. This is long format data, so we must first pivot it so
    that the dates (which we set as the index when we read in the CSV file) are in
    the index of the pivot table and the countries (`countriesAndTerritories`) are
    in the columns. Since there is a lot of fluctuation in these values, we will plot
    the 7-day moving average of new cases using the `rolling()` method introduced
    in [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082), *Aggregating
    Pandas DataFrames*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望制作子图，每个子图包含一些变量供比较。可以通过首先使用 `plt.subplots()` 创建子图，然后将 `Axes` 对象提供给 `ax`
    参数来实现这一点。为了说明这一点，让我们来看一下中国、西班牙、意大利、美国、巴西和印度的 COVID-19 每日新增病例数据。这是长格式数据，因此我们必须首先将其透视，使日期（我们在读取
    CSV 文件时设置为索引）成为透视表的索引，国家（`countriesAndTerritories`）成为列。由于这些值波动较大，我们将使用 [*第 4 章*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082)
    中介绍的 `rolling()` 方法绘制新增病例的 7 天移动平均值，*聚合 Pandas 数据框*：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Rather than create a separate plot for each country (which makes it harder
    to compare) or plot them all together (which will make it difficult to see the
    smaller values), we will plot countries that have had a similar number of cases
    in the same subplot. We will also use different line styles in order to distinguish
    between them in black and white:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会为每个国家创建单独的图表（这会使比较变得更困难），也不会将它们全部绘制在一起（这样会使较小的值难以看到），而是将病例数量相似的国家绘制在同一个子图中。我们还将使用不同的线条样式，以便在黑白图中区分它们：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'By directly using `matplotlib` to generate the `Axes` objects for each subplot,
    we gained a lot more flexibility in the resulting layout:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接使用`matplotlib`生成每个子图的`Axes`对象，我们获得了更多的布局灵活性：
- en: '![Figure 5.14 – Controlling which data gets plotted in each of the subplots'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.14 – 控制每个子图中绘制的数据'
- en: '](img/Figure_5.14_B16834.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.14_B16834.jpg)'
- en: Figure 5.14 – Controlling which data gets plotted in each of the subplots
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 控制每个子图中绘制的数据
- en: 'In the previous plot, we were able to compare countries with similar levels
    of daily new COVID-19 cases, but we couldn''t compare all of them in the same
    subplot due to scale. One way to get around this is to use an **area plot**, which
    makes it possible for us to visualize the overall 7-day rolling average of new
    COVID-19 cases and, at the same time, how much each country is contributing to
    the total. In the interest of readability, we will group Italy and Spain together
    and create another category for countries other than the USA, Brazil, and India:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们能够比较病例数量相似的国家，但由于比例问题，我们无法将所有国家都绘制在同一个子图中。解决这个问题的一种方法是使用**面积图**，这样我们就能在可视化整体7天滚动平均的新增COVID-19病例的同时，看到每个国家对总数的贡献。为了提高可读性，我们将意大利和西班牙归为一组，并为美国、巴西和印度以外的国家创建另一个类别：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For those viewing the resulting plot in black and white, Brazil is the bottom
    layer, with India on top of it and so on. The combined height of the plot areas
    is the overall value, and the height of a given shaded region is the value for
    that country. This shows us that more than half of the daily new cases are in
    Brazil, India, Italy, Spain, and the USA combined:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些以黑白查看结果图的人，巴西是底层，印度在其上方，以此类推。图表区域的合计高度表示总体值，而给定阴影区域的高度表示该国的值。这表明，超过一半的每日新增病例集中在巴西、印度、意大利、西班牙和美国：
- en: '![Figure 5.15 – Creating an area plot'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.15 – 创建面积图'
- en: '](img/Figure_5.15_B16834.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.15_B16834.jpg)'
- en: Figure 5.15 – Creating an area plot
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – 创建面积图
- en: 'Another way to visualize evolution over time is to look at the cumulative sum
    over time. Let''s plot the cumulative number of COVID-19 cases in China, Spain,
    Italy, the USA, Brazil, and India, using the `ax` parameter to once again to create
    subplots. To calculate the cumulative sum over time, we group by the location
    (`countriesAndTerritories`) and the date, which is our index, so we use `pd.Grouper()`;
    this time, we will use `groupby()` and `unstack()` to pivot our data into wide
    format for the plot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可视化随时间演变的方法是查看随时间累积的和。我们将绘制中国、西班牙、意大利、美国、巴西和印度的COVID-19累计病例数，使用`ax`参数再次创建子图。为了计算随时间的累计和，我们按位置（`countriesAndTerritories`）和日期分组，日期是我们的索引，因此我们使用`pd.Grouper()`；这次，我们将使用`groupby()`和`unstack()`将数据透视为宽格式，用于绘图：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Viewing the cumulative COVID-19 cases shows that while China and Italy appear
    to have COVID-19 cases under control, Spain, the USA, Brazil, and India are struggling:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 观察累计COVID-19病例数据表明，尽管中国和意大利似乎已经控制了COVID-19病例，但西班牙、美国、巴西和印度仍在挣扎：
- en: '![Figure 5.16 – Plotting the cumulative sum over time'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.16 – 随时间绘制累计和'
- en: '](img/Figure_5.16_B16834.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.16_B16834.jpg)'
- en: Figure 5.16 – Plotting the cumulative sum over time
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – 随时间绘制累计和
- en: Important note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: We used dotted and dashed lines multiple times in this section to ensure that
    the resulting plots could be interpreted in black and white; note, however, that
    accepting the default colors and line styles will suffice when presenting these
    plots in color. Often, different line styles signify a difference in the data
    types—for example, we could use a solid line for the evolution over time and a
    dashed line to represent the rolling average.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一部分多次使用了虚线和点线，以确保生成的图表可以在黑白模式下进行解读；然而，请注意，当以彩色方式展示这些图表时，接受默认的颜色和线条样式就足够了。通常，不同的线条样式表示数据类型的差异——例如，我们可以使用实线来表示时间演变，使用虚线来表示滚动平均值。
- en: Relationships between variables
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量之间的关系
- en: 'When we want to visualize the relationship between variables, we often begin
    with scatter plots, which show us the value of the `y` variable at different values
    of the `x` variable. This makes it very easy for us to spot correlations and possible
    non-linear relationships. In the previous chapter, when we looked at the Facebook
    stock data, we saw that the days of high volume traded appeared to be correlated
    with large drops in stock price. We can use a scatter plot to visualize this relationship:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要可视化变量之间的关系时，我们通常从散点图开始，散点图展示了不同 `x` 变量值下的 `y` 变量值。这使我们非常容易发现相关性和可能的非线性关系。在上一章，当我们查看
    Facebook 股票数据时，我们看到高交易量的天数似乎与股价的大幅下跌相关。我们可以使用散点图来可视化这种关系：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There appears to be a relationship, but it does not seem linear:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎存在某种关系，但它似乎不是线性的：
- en: '![Figure 5.17 – Making scatter plots with pandas'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.17 – 使用 pandas 绘制散点图'
- en: '](img/Figure_5.17_B16834.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.17_B16834.jpg)'
- en: Figure 5.17 – Making scatter plots with pandas
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – 使用 pandas 绘制散点图
- en: 'Let''s try taking the logarithm (log) of the volume. To do so, we have a couple
    of options:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着取交易量的对数。为此，我们有几个选择：
- en: Create a new column that is the log of the volume using `np.log()`.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的列，将交易量取对数，使用 `np.log()`。
- en: Use a logarithmic scale for the *x*-axis by passing in `logx=True` to the `plot()`
    method or calling `plt.xscale('log')`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将 `logx=True` 传递给 `plot()` 方法或调用 `plt.xscale('log')` 来对 *x* 轴使用对数刻度。
- en: 'In this case, it makes the most sense to simply change how we display our data,
    since we aren''t going to use the new column:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最有意义的是仅仅改变数据的显示方式，因为我们并不会使用新的列：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After modifying the *x*-axis scale, we get the following scatter plot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 *x* 轴刻度后，我们得到如下散点图：
- en: '![Figure 5.18 – Applying a logarithmic scale to the x-axis'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.18 – 对 *x* 轴应用对数刻度'
- en: '](img/Figure_5.18_B16834.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.18_B16834.jpg)'
- en: Figure 5.18 – Applying a logarithmic scale to the *x*-axis
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18 – 对 *x* 轴应用对数刻度
- en: Tip
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The `plot()` method from `pandas` has three arguments for logarithmic scales:
    `logx`/`logy` for single axis adjustments and `loglog` for setting both to the
    logarithmic scale.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` 中的 `plot()` 方法有三个参数用于对数刻度：`logx`/`logy` 用于单轴调整，`loglog` 用于同时设置两个轴为对数刻度。'
- en: 'One problem with scatter plots is that it can be very difficult to discern
    the concentration of points in a given area, since they are simply plotted one
    of top of the other. We can use the `alpha` argument to control the transparency
    of the points; this argument takes values from `0` to `1`, where `0` is entirely
    transparent and `1` is completely opaque. By default, they are opaque (value of
    `1`); however, if we make them more transparent, we should be able to see some
    of the overlap:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图的一个问题是，很难分辨给定区域内点的集中程度，因为它们只是简单地叠加在一起。我们可以使用 `alpha` 参数来控制点的透明度；这个参数的值范围从
    `0` 到 `1`，其中 `0` 表示完全透明，`1` 表示完全不透明。默认情况下，它们是完全不透明的（值为 `1`）；然而，如果我们使它们更透明，我们应该能够看到一些重叠：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now begin to make out the density of points in the lower-left region
    of the plot, but it''s still relatively difficult:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始看出图表左下区域的点密度，但仍然相对较难：
- en: '![Figure 5.19 – Modifying transparency to visualize overlap'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.19 – 修改透明度以可视化重叠'
- en: '](img/Figure_5.19_B16834.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.19_B16834.jpg)'
- en: Figure 5.19 – Modifying transparency to visualize overlap
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19 – 修改透明度以可视化重叠
- en: 'Thankfully, we have another plot type at our disposal: `hexbin`. **Hexbins**
    form a two-dimensional histogram by dividing the plot into a grid of hexagons
    and shading them based on the concentration of points in each bin. Let''s view
    this data as hexbins:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们还有另一种可用的图表类型：`hexbin`。**六边形图**通过将图表划分为一个六边形网格，并根据每个六边形内的点密度来进行着色，形成一个二维直方图。让我们将数据以六边形图的形式展示：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The colorbar on the side indicates the relationship between color and the number
    of points in that bin. The colormap we chose (`gray_r`) shades the bins darker
    (toward black) for high density, and lighter (toward white) for low density. By
    passing in `gridsize=20`, we are specifying that 20 hexagons should be used across
    the *x*-axis, and then having `pandas` determine how many to use along the *y*-axis
    so that they are approximately regular in shape; we can, however, pass a tuple
    to choose the number in both directions. A larger value for `gridsize` will make
    the bins harder to see, while a smaller one will result in fuller bins that take
    up more space on the plot—we must strike a balance:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 侧边的颜色条表示颜色与该 bin 中点数之间的关系。我们选择的色图（`gray_r`）使得高密度的 bins 颜色较深（趋向黑色），低密度的 bins
    颜色较浅（趋向白色）。通过传入 `gridsize=20`，我们指定在 *x* 轴上使用 20 个六边形，并让 `pandas` 确定在 *y* 轴上使用多少个，以使它们大致呈规则形状；不过，我们也可以传入一个元组来选择两个方向上的数量。增大
    `gridsize` 的值会使得 bins 更难以辨识，而减小则会导致 bins 更满，占用更多的空间——我们需要找到一个平衡点：
- en: '![Figure 5.20 – Plotting hexbins with pandas'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.20 – 使用 pandas 绘制 hexbins'
- en: '](img/Figure_5.20_B16834.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.20_B16834.jpg)'
- en: Figure 5.20 – Plotting hexbins with pandas
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20 – 使用 pandas 绘制 hexbins
- en: 'Finally, if we simply want to visualize the correlation between variables,
    we can plot a correlation matrix. A `pandas` and either the `plt.matshow()` or
    `plt.imshow()` function from `matplotlib`. Since there is a lot of code that needs
    to be run in the same cell, we will discuss the purpose of each section immediately
    after this code block:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们只想可视化变量之间的相关性，我们可以绘制一个相关矩阵。使用 `pandas` 和 `matplotlib` 中的 `plt.matshow()`
    或 `plt.imshow()` 函数。由于需要在同一单元格中运行大量代码，我们将在代码块后立即讨论每个部分的目的：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A `seismic` colormap and then setting the limits of the color scale to [-1,
    1], since the correlation coefficient has those bounds:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `seismic` 色图，然后将颜色刻度的限制设置为[-1, 1]，因为相关系数的范围就是这些：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To be able to read the resulting heatmap, we need to label the rows and columns
    with the names of the variables in our data:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够读取生成的热图，我们需要用数据中变量的名称标记行和列：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'While the color scale will make it easy for us to differentiate between weak
    and strong correlations, it is often helpful to annotate the heatmap with the
    actual correlation coefficients. This can be accomplished by using the `text()`
    method on the `Axes` object containing the plot. For this plot, we placed white,
    center-aligned text indicating the value of the Pearson correlation coefficient
    for each variable combination:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然颜色刻度可以帮助我们区分弱相关和强相关，但通常也很有帮助的是在热图上注释实际的相关系数。这可以通过在包含图形的 `Axes` 对象上使用 `text()`
    方法来实现。对于这个图形，我们放置了白色、居中对齐的文本，表示每对变量组合的皮尔逊相关系数的值：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This results in an annotated heatmap showing the correlations between the variables
    in the Facebook dataset:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个带注释的热图，展示 Facebook 数据集中的变量之间的相关性：
- en: '![Figure 5.21 – Visualizing correlations as a heatmap'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.21 – 将相关性可视化为热图'
- en: '](img/Figure_5.21_B16834.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.21_B16834.jpg)'
- en: Figure 5.21 – Visualizing correlations as a heatmap
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21 – 将相关性可视化为热图
- en: In *Figure 5.21*, we can easily see strong positive correlations among the OHLC
    time series, as well as among the volume traded and maximum absolute value of
    change. However, there are weak negative correlations between these groups. Furthermore,
    we can see that taking the logarithm of the volume does indeed increase the coefficient
    of correlation with `max_abs_change` from 0.64 to 0.73\. When we discuss `seaborn`
    in the next chapter, we will learn an easier way to generate a heatmap, and also
    cover annotations in more detail.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 5.21*中，我们可以清楚地看到 OHLC 时间序列之间存在较强的正相关性，以及交易量和最大绝对变化值之间的正相关性。然而，这些组之间存在较弱的负相关性。此外，我们还可以看到，对交易量取对数确实增加了与`max_abs_change`的相关系数，从
    0.64 增加到 0.73。在下一章讨论 `seaborn` 时，我们将学习一种更简单的生成热图的方法，并更详细地讲解注释。
- en: Distributions
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布
- en: 'Often, we want to visualize the distribution of our data to see what values
    it takes on. Depending on the type of data we have, we may choose to use histograms,
    **kernel density estimates** (**KDEs**), box plots, or **empirical cumulative
    distribution functions** (**ECDFs**). When working with discrete data, histograms
    are a good place to start. Let''s take a look at the histogram of daily volume
    traded in Facebook stock:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望可视化数据的分布，以了解数据所呈现的值。根据数据类型的不同，我们可能会选择使用直方图、**核密度估计**（**KDEs**）、箱型图或**经验累积分布函数**（**ECDFs**）。在处理离散数据时，直方图是一个很好的起点。让我们来看一下
    Facebook 股票的每日交易量直方图：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is a great example of real-world data that is, most definitely, not normally
    distributed. The volume traded is right skewed, with a long tail to the right.
    Recall that in [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Aggregating Pandas DataFrames*, when we discussed binning and looked at low,
    medium, and high volume traded, almost all of the data fell in the low bucket,
    which aligns with what we see in this histogram:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的实际数据示例，数据显然不是正态分布的。交易量偏右，右侧有一个长尾。回想一下在[*第 4 章*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082)，*聚合
    Pandas DataFrames* 中，我们讨论了分箱并查看了低、中、高交易量时，几乎所有数据都落在低交易量区间，这与我们在此直方图中看到的情况一致：
- en: '![Figure 5.22 – Creating a histogram with pandas'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.22 – 使用 pandas 创建直方图'
- en: '](img/Figure_5.22_B16834.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.22_B16834.jpg)'
- en: Figure 5.22 – Creating a histogram with pandas
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22 – 使用 pandas 创建直方图
- en: Tip
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As with the `plt.hist()` function from `matplotlib`, we can provide a custom
    value for the number of bins with the `bins` argument. However, we must be careful
    that we don't misrepresent the distribution.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `matplotlib` 中的 `plt.hist()` 函数类似，我们可以通过 `bins` 参数为箱数提供自定义值。但是，我们必须小心，确保不会误导数据分布。
- en: 'We can also create multiple histograms on the same plot to compare distributions
    by using the `ax` parameter to specify the same `Axes` object for each plot. In
    this case, we must use the `alpha` parameter to see any overlaps. Given that we
    have many different measurement techniques for earthquakes (the `magType` column),
    we may be interested in comparing the different ranges of magnitudes they yield:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在同一图表上绘制多个直方图，以比较不同的分布，方法是使用 `ax` 参数为每个图表指定相同的 `Axes` 对象。在这种情况下，我们必须使用
    `alpha` 参数以便看到任何重叠。由于我们有许多不同的地震测量方法（`magType` 列），我们可能会想要比较它们所产生的不同震级范围：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This shows us that `ml` is the most common `magType`, followed by `md`, and
    that they yield similar ranges of magnitudes; however, `mb`, which is the third-most
    common, yields higher magnitudes:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 `ml` 是最常见的 `magType`，其次是 `md`，它们的震级范围相似；然而，第三常见的 `mb` 震级更高：
- en: '![Figure 5.23 – Plotting overlapping histograms with pandas'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.23 – 使用 pandas 绘制重叠直方图'
- en: '](img/Figure_5.23_B16834.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.23_B16834.jpg)'
- en: Figure 5.23 – Plotting overlapping histograms with pandas
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23 – 使用 pandas 绘制重叠直方图
- en: 'When working with continuous data (such as stock prices), we can use KDEs.
    Let''s take a look at the KDE of the daily high price for Facebook stock. Note
    that we can pass either `kind=''kde''` or `kind=''density''`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理连续数据（如股票价格）时，我们可以使用 KDE。让我们看看 Facebook 股票的日最高价的 KDE。请注意，我们可以传递 `kind='kde'`
    或 `kind='density'`：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The resulting density curve has some left skew:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 得到的密度曲线有一些左偏：
- en: '![Figure 5.24 – Visualizing the KDE with pandas'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.24 – 使用 pandas 可视化 KDE'
- en: '](img/Figure_5.24_B16834.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.24_B16834.jpg)'
- en: Figure 5.24 – Visualizing the KDE with pandas
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.24 – 使用 pandas 可视化 KDE
- en: 'We may also want to visualize the KDE superimposed on top of the histogram.
    Pandas allows us to pass the `Axes` object we want to plot on, and also returns
    one after creating the visualization, which makes this a cinch:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还想将 KDE 可视化叠加在直方图上。Pandas 允许我们传递希望绘制的 `Axes` 对象，并且在创建可视化后会返回该对象，这使得操作变得非常简单：
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Notice that we had to pass `density=True` when we generated the histogram to
    make sure that the *y*-axis for the histogram and KDE were on the same scale.
    Otherwise, the KDE would have been too small to see. The histogram then gets plotted
    with density on the *y*-axis so that we can better understand how the KDE got
    its shape. We also increased the transparency of the histogram so that we could
    see the KDE line on top. Note that if we remove the `color=''blue''` part of the
    KDE call, we don''t need to change the value of `alpha` in the histogram call
    because the KDE and histogram will be different colors; we are plotting them both
    in blue since they represent the same data:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们生成直方图时，必须传入`density=True`，以确保直方图和KDE的*y*轴处于相同的尺度。否则，KDE会变得太小，无法看到。然后，直方图会以密度作为*y*轴进行绘制，这样我们就可以更好地理解KDE是如何形成其形状的。我们还增加了直方图的透明度，以便能够看到上面叠加的KDE线。请注意，如果我们移除KDE调用中的`color='blue'`部分，我们就不需要更改直方图调用中的`alpha`值，因为KDE和直方图会使用不同的颜色；我们将它们都绘制为蓝色，因为它们表示的是相同的数据：
- en: '![Figure 5.25 – Combining a KDE and a histogram with pandas'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.25 – 使用pandas结合KDE和直方图](img/Figure_5.25_B16834.jpg)'
- en: '](img/Figure_5.25_B16834.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.25_B16834.jpg)'
- en: Figure 5.25 – Combining a KDE and a histogram with pandas
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.25 – 使用pandas结合KDE和直方图
- en: The KDE shows us an estimated **probability density function** (**PDF**), which
    tells us how probability is distributed over the values of the data. However,
    in some cases, we are more interested in the probability of getting less than
    or equal to (or greater than or equal to) some value, which we can see with the
    **cumulative distribution function** (**CDF**).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: KDE展示了一个估计的**概率密度函数**（**PDF**），它告诉我们概率是如何在数据值上分布的。然而，在某些情况下，我们更关心的是获取某个值以下（或以上）的概率，我们可以通过**累积分布函数**（**CDF**）来查看。
- en: Important note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: With a CDF, the values for the *x* variable go along the *x*-axis, while the
    cumulative probability of getting, at most, a given *x* goes along the *y*-axis.
    This cumulative probability is between 0 and 1 and is written as *P(X ≤ x)*, where
    the lowercase (*x*) is the value for comparison and the uppercase (*X*) is the
    random variable, *X*. More information can be found at [https://www.itl.nist.gov/div898/handbook/eda/section3/eda362.htm](https://www.itl.nist.gov/div898/handbook/eda/section3/eda362.htm).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CDF时，*x*变量的值沿着*x*轴分布，而获取最多某个*x*值的累积概率沿着*y*轴分布。这个累积概率介于0和1之间，并写作*P(X ≤ x)*，其中小写（*x*）是用于比较的值，大写（*X*）是随机变量*X*。更多信息请参考[https://www.itl.nist.gov/div898/handbook/eda/section3/eda362.htm](https://www.itl.nist.gov/div898/handbook/eda/section3/eda362.htm)。
- en: 'Using the `statsmodels` package, we can estimate the CDF giving us the `ml`
    magnitude type:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`statsmodels`包，我们可以估算CDF并得到`ml`震级类型：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This yields the following ECDF:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下ECDF：
- en: '![Figure 5.26 – Visualizing the ECDF'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.26 – 可视化ECDF](img/Figure_5.26_B16834.jpg)'
- en: '](img/Figure_5.26_B16834.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.26_B16834.jpg)'
- en: Figure 5.26 – Visualizing the ECDF
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.26 – 可视化ECDF
- en: 'This can be very useful in gaining a better understanding of our data when
    we conduct our EDA. However, we must be careful how we interpret this and how
    we explain it to others, if we choose to do so. Here, we can see that if this
    distribution is indeed representative of the population, the probability of the
    `ml` magnitude of the earthquake being less than or equal to **3** is **98%**
    for earthquakes measured with that measurement technique:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们进行EDA时非常有用，可以帮助我们更好地理解数据。然而，我们必须小心如何解释这些结果以及如何向他人解释，特别是如果我们选择这么做的话。在这里，我们可以看到，如果该分布确实代表了总体，使用该测量技术测得的地震`ml`震级小于或等于**3**的概率为**98%**：
- en: '![Figure 5.27 – Interpreting the ECDF'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.27 – 解释ECDF](img/Figure_5.25_B16834.jpg)'
- en: '](img/Figure_5.27_B16834.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.27_B16834.jpg)'
- en: Figure 5.27 – Interpreting the ECDF
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.27 – 解释ECDF
- en: 'Finally, we can use box plots to visualize potential outliers and the distribution
    using quartiles. As an example, let''s visualize the OHLC prices for Facebook
    stock across the whole dataset:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用箱线图来可视化潜在的离群值和通过四分位数描述的分布。举个例子，我们来可视化Facebook股票在整个数据集中的OHLC价格：
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice that we do lose some information we had in the other plots. We no longer
    have an idea of the density of points throughout the distribution; with the box
    plot, we focus on the 5-number summary instead:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们确实失去了一些在其他图中得到的信息。我们不再能够了解分布中点的密度；通过箱线图，我们更关注的是五数概括：
- en: '![Figure 5.28 – Creating box plots with pandas'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.28 – 使用pandas创建箱线图](img/Figure_5.28_B16834.jpg)'
- en: '](img/Figure_5.28_B16834.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.28_B16834.jpg)'
- en: Figure 5.28 – Creating box plots with pandas
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.28 – 使用 pandas 创建箱线图
- en: Tip
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can create a notched box plot by passing in `notch=True`. The notch marks
    a 95% confidence interval around the median, which can be helpful when comparing
    differences between groups. There is an example in the notebook.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过传递`notch=True`来创建带缺口的箱线图。缺口标记了中位数的95%置信区间，这在比较组之间的差异时很有帮助。笔记本中有一个示例。
- en: 'We can also call the `boxplot()` method after calling `groupby()`. Let''s examine
    how the box plots change when we calculate them based on the volume traded:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在调用`groupby()`之后调用`boxplot()`方法。让我们来看一下在根据交易量计算时，箱线图如何变化：
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Remember from [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Aggregating Pandas DataFrames,* that most of the days fell in the low volume
    traded bucket, so we would expect to see more variation there because of what
    the stock data looked like over time:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 记得从[*第4章*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082)，“*汇总 Pandas 数据框*”中，我们知道大多数天数都落在低交易量范围内，因此我们可以预期在这里会看到更多的波动，因为股票数据随时间变化的情况：
- en: '![Figure 5.29 – Box plots per group with pandas'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.29 – 使用 pandas 绘制每组箱线图'
- en: '](img/Figure_5.29_B16834.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.29_B16834.jpg)'
- en: Figure 5.29 – Box plots per group with pandas
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.29 – 使用 pandas 绘制每组箱线图
- en: 'We can also use this technique to see the distribution of earthquake magnitudes
    based on which `magType` was used and compare it with the expected ranges on the
    USGS website ([https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types](https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types)):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这种方法查看根据使用的`magType`，地震震级的分布，并与USGS网站上预期的范围进行比较（[https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types](https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types)）：
- en: '[PRE44]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The USGS website mentions situations in which certain measurement techniques
    can''t be used and the range of magnitudes each measurement technique is authoritative
    for (when outside that range, other techniques are used). Here, we can see that,
    together, the techniques cover a wide spectrum of magnitudes, while none of them
    cover everything:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 美国地质调查局（USGS）网站提到了一些情况下无法使用某些测量技术，以及每种测量技术适用的幅度范围（当超出该范围时，使用其他技术）。在这里，我们可以看到这些技术一起覆盖了广泛的幅度范围，但没有一种技术能够覆盖所有的情况：
- en: '![Figure 5.30 – Box plots per group in a single plot'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.30 – 单一图表中每组的箱线图'
- en: '](img/Figure_5.30_B16834.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.30_B16834.jpg)'
- en: Figure 5.30 – Box plots per group in a single plot
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.30 – 单一图表中每组的箱线图
- en: Important note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: While histograms, KDEs, ECDFs, and box plots are all ways of looking at the
    distribution of the data, we saw that each visualization showed us a different
    aspect of it. It's important to visualize the data from many angles before drawing
    any conclusions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直方图、KDE、ECDF和箱线图都是展示数据分布的方式，但我们看到每种可视化方法展示了数据的不同方面。在得出结论之前，从多个角度可视化数据是很重要的。
- en: Counts and frequencies
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数和频率
- en: When working with categorical data, we can create bar plots for displaying counts
    of our data or frequencies of particular values. The bars can be vertical (`kind='bar'`)
    or horizontal (`kind='barh'`). Vertical bar plots are useful when we have many
    categories or there is some order to the categories (for example, an evolution
    over time). Horizontal bar plots make it easy to compare the size of each category
    while allowing sufficient space on the margin for long category names (without
    the need to rotate them).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理分类数据时，我们可以创建条形图来显示数据的计数或特定值的频率。条形图可以是垂直的（`kind='bar'`）或水平的（`kind='barh'`）。当我们有许多类别或类别之间有某种顺序时（例如，随着时间的演变），垂直条形图非常有用。水平条形图便于比较每个类别的大小，并为长类别名称提供足够的空间（无需旋转它们）。
- en: 'We can use a horizontal bar plot to see which places in the `quakes` dataframe
    have had the most earthquakes. First, we call the `value_counts()` method on the
    `parsed_place` series and take the top 15 places for earthquakes. Next, we reverse
    the order so that the smallest ones in this list are on top, which will sort the
    highest to the top of the bar plot that we will make. Note that we could reverse
    the sort order as an argument to `value_counts()`, but since we would still have
    to grab the top 15, we are doing both in a single `iloc` call:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用水平条形图来查看`quakes`数据框中哪些地方发生了最多的地震。首先，我们对`parsed_place`系列调用`value_counts()`方法，提取出发生地震次数最多的前15个地方。接下来，我们反转顺序，以便在条形图中将最小的值排在上面，这样我们将得到按地震次数排序的条形图。注意，我们也可以将反转排序作为`value_counts()`的参数，但由于我们仍然需要提取前15名，因此我们将两者结合在一个`iloc`调用中：
- en: '[PRE45]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Remember, slicing notation is `[start:stop:step]`, and in this case, since
    the step is negative, the order is reversed; we start at index `14` (the 15th
    entry) and get closer to index `0` each time. By passing `kind=''barh''`, we get
    a horizontal bar plot that shows that most of the earthquakes in this dataset
    occur in Alaska. Perhaps it is surprising to see the number of earthquakes over
    such a short time period, but many of these earthquakes are so small in magnitude
    that people don''t even feel them:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，切片表示法是`[start:stop:step]`，在本例中，由于步长是负数，顺序被反转；我们从索引`14`（第15个条目）开始，每次都朝着索引`0`靠近。通过传递`kind='barh'`，我们可以得到水平条形图，显示出该数据集中大多数地震发生在阿拉斯加。也许看到在如此短的时间内发生的地震数量令人惊讶，但许多地震的震级很小，以至于人们根本感觉不到：
- en: '![Figure 5.31 – Plotting horizontal bars with pandas'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.31 – 使用 pandas 绘制水平条形图'
- en: '](img/Figure_5.31_B16834.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.31_B16834.jpg)'
- en: Figure 5.31 – Plotting horizontal bars with pandas
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.31 – 使用 pandas 绘制水平条形图
- en: 'Our data also contains information about whether the earthquake was accompanied
    by a tsunami. Let''s use `groupby()` to make a bar plot of the top 10 places that
    were hit by tsunamis during the time period we have in our data:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据还包含了地震是否伴随海啸的信息。我们可以使用`groupby()`来绘制一个条形图，展示在我们数据中时间段内遭遇海啸的前10个地方：
- en: '[PRE46]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Notice that this time, we used `iloc[-10:,]`, which starts at the 10th largest
    value (since `sort_values()` sorts in ascending order by default) and goes to
    the largest value, giving us the top 10\. Here, we can see that Indonesia had
    many more tsunamis than the other places during this time period:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我们使用了`iloc[-10:,]`，它从第10大值开始（因为`sort_values()`默认按升序排序），一直到最大值，从而得到前10个数据。这里我们可以看到，在这段时间内，印尼发生的海啸数量远远超过其他地区：
- en: '![Figure 5.32 – Plotting the result of a group by calculation'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.32 – 按组计算结果的绘制'
- en: '](img/Figure_5.32_B16834.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.32_B16834.jpg)'
- en: Figure 5.32 – Plotting the result of a group by calculation
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.32 – 按组计算结果的绘制
- en: 'After seeing something like this, we may be prompted to look further into the
    number of tsunamis in Indonesia each day. We can visualize this evolution over
    time as a line plot or with a vertical bar plot by using `kind=''bar''`. Here,
    we will use bars to avoid interpolating the points:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这样的数据后，我们可能会想进一步探究印尼每天发生的海啸数量。我们可以通过线图或使用`kind='bar'`的垂直条形图来可视化这种随时间变化的情况。这里我们将使用条形图，以避免插值点：
- en: '[PRE47]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'On September 28, 2018, we can see a spike in both earthquakes and tsunamis
    in Indonesia; on this date a 7.5 magnitude earthquake occurred, causing a devastating
    tsunami:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年9月28日，我们可以看到印尼的地震和海啸出现了激增；在这一天，发生了一次7.5级地震，引发了毁灭性的海啸：
- en: '![Figure 5.33 – Comparing counts over time'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.33 – 随时间变化的计数比较'
- en: '](img/Figure_5.33_B16834.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.33_B16834.jpg)'
- en: Figure 5.33 – Comparing counts over time
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.33 – 随时间变化的计数比较
- en: 'We can also create grouped bars from a single column''s values by using `groupby()`
    and `unstack()`. This makes it possible for us to generate bars for each distinct
    value in the column. Let''s use this strategy to take a look at the frequency
    of a tsunami accompanying an earthquake, as a percentage. We can handle this using
    the `apply()` method, as we learned in [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Aggregating Pandas DataFrames*, along `axis=1` (to apply row by row). For illustration
    purposes, we will look at the seven places with the highest percentage of earthquakes
    accompanied by a tsunami:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用`groupby()`和`unstack()`从单列的值中创建分组条形图。这使得我们能够为列中的每个独特值生成条形图。让我们用这种方法查看海啸与地震同时发生的频率，作为一个百分比。我们可以使用`apply()`方法，如我们在[*第4章*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082)《聚合
    Pandas DataFrames》中所学，沿着`axis=1`（逐行应用）。为了说明，我们将查看海啸伴随地震发生比例最高的七个地方：
- en: '[PRE48]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Christmas Island had one earthquake during this time period, but it was accompanied
    by a tsunami. Papua New Guinea, on the other hand, had tsunamis alongside roughly
    40% of its earthquakes:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 圣诞岛在这段时间内发生了1次地震，但伴随了海啸。相比之下，巴布亚新几内亚约40%的地震都伴随了海啸：
- en: '![Figure 5.34 – Bar plot with a group by'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.34 – 按组绘制的条形图'
- en: '](img/Figure_5.34_B16834.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.34_B16834.jpg)'
- en: Figure 5.34 – Bar plot with a group by
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.34 – 按组绘制的条形图
- en: Tip
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When saving the preceding plots, long category names may get cut off; if that's
    the case, try running `plt.tight_layout()` before saving.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存前面的图表时，较长的类别名称可能会被截断；如果是这种情况，尝试在保存之前运行`plt.tight_layout()`。
- en: 'Now, let''s use vertical bars to see which methods of measuring earthquake
    magnitude are most prevalent by using `kind=''bar''`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用垂直条形图来查看哪些地震震级测量方法最为常见，方法是使用`kind='bar'`：
- en: '[PRE49]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It appears that `ml` is, by far, the most common method for measuring earthquake
    magnitudes. This makes sense since it is the *original magnitude relationship
    defined by Richter and Gutenberg in 1935 for local earthquakes*, according to
    the USGS page explaining the `magType` field in the dataset we are using ([https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types](https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types)):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`ml`是测量地震震级时最常用的方法。这是有道理的，因为它是*由理查德·里希特和古滕贝格在1935年定义的原始震级关系，用于测量局部地震*，这一点可以参考我们使用的数据集中关于`magType`字段的USGS页面([https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types](https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types))：
- en: '![Figure 5.35 – Comparing category counts'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.35 – 比较类别计数'
- en: '](img/Figure_5.35_B16834.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.35_B16834.jpg)'
- en: Figure 5.35 – Comparing category counts
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.35 – 比较类别计数
- en: 'Say we want to see how many earthquakes of a given magnitude there were and
    to distinguish them by `magType`. This shows us a few things in a single plot:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要查看某一震级的地震数量，并按`magType`区分它们。这样一个图表可以在一个图中展示多个信息：
- en: Which magnitudes occur most often across `magType`.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些震级在`magType`中最常出现。
- en: The relative ranges of magnitude that each `magType` yields.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种`magType`对应的震级的相对范围。
- en: The most common values for `magType`.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`magType`的最常见值。'
- en: 'To do so, we can make a stacked bar plot. First, we will round all magnitudes
    down to the nearest integer. This means that all earthquakes will be marked as
    the part of the magnitude before the decimal point (for example, 5.5 gets marked
    as 5, just like 5.7, 5.2, and 5.0). Next, we will need to create a pivot table
    with the magnitude in the index and the magnitude type along the columns; we will
    count the number of earthquakes for the values:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以制作一个堆叠条形图。首先，我们将所有震级四舍五入到最接近的整数。这意味着所有地震都会标记为小数点前的震级部分（例如，5.5被标记为5，就像5.7、5.2和5.0一样）。接下来，我们需要创建一个透视表，将震级放入索引，将震级类型放入列中；我们将计算各个值对应的地震数量：
- en: '[PRE50]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once we have the pivot table, we can create a stacked bar plot by passing in
    `stacked=True` when plotting:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了透视表，就可以通过在绘制时传入`stacked=True`来创建堆叠条形图：
- en: '[PRE51]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This results in the following plot, which shows that most of the earthquakes
    are measured with the `ml` magnitude type and have magnitudes below four:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下图表，显示大多数地震使用`ml`震级类型，并且震级低于4：
- en: '![Figure 5.36 – Stacked bar plot'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.36 – 堆叠条形图'
- en: '](img/Figure_5.36_B16834.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.36_B16834.jpg)'
- en: Figure 5.36 – Stacked bar plot
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.36 – 堆叠条形图
- en: 'The other bars are dwarfed in comparison to `ml`, which makes it difficult
    for us to see which magnitude types assign higher magnitudes to earthquakes. To
    address this, we can make a normalized stacked bar plot. Rather than showing the
    count of earthquakes for each combination of magnitude and `magType`, we will
    show what percentage of earthquakes of a given magnitude used each `magType`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 其他条形图相比于`ml`显得较小，这使得我们很难看清哪些震级类型将较高的震级赋给了地震。为了解决这个问题，我们可以制作一个标准化堆叠条形图。我们将不再显示每种震级和`magType`组合的地震数量，而是显示每种震级下，使用每种`magType`的地震百分比：
- en: '[PRE52]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we can easily see that `mww` yields higher magnitudes and that `ml` appears
    to be spread across the lower end of the spectrum:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松看到`mww`产生较高的震级，而`ml`似乎分布在震级范围的较低端：
- en: '![Figure 5.37 – Normalized stacked bar plot'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.37 – 标准化堆叠条形图'
- en: '](img/Figure_5.37_B16834.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.37_B16834.jpg)'
- en: Figure 5.37 – Normalized stacked bar plot
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.37 – 标准化堆叠条形图
- en: 'Note that we can also use this strategy with a call to the `groupby()` and
    then `unstack()` methods. Let''s revisit the frequency of a tsunami accompanying
    an earthquake plot, but rather than use grouped bars, we will stack them:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们也可以使用`groupby()`方法和`unstack()`方法来实现这个策略。让我们重新查看伴随地震的海啸频率图，但这次我们不使用分组条形图，而是将其堆叠显示：
- en: '[PRE53]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This stacked bar plot makes it very easy for us to compare the frequencies
    of tsunamis across different places:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个堆叠条形图使得我们很容易比较不同地方的海啸频率：
- en: '![Figure 5.38 – Normalized stacked bar plot with a group by'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.38 – 按组归类的标准化堆叠条形图'
- en: '](img/Figure_5.38_B16834.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.38_B16834.jpg)'
- en: Figure 5.38 – Normalized stacked bar plot with a group by
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.38 – 按组归类的标准化堆叠条形图
- en: Categorical data limits us in terms of the types of plots we can use, but there
    are some alternatives to the bar plot. We will take a look at them in the *Utilizing
    seaborn for advanced plotting* section in the next chapter; for now, let's take
    a look at the `pandas.plotting` module.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 类别数据限制了我们可以使用的图表类型，但也有一些替代方案可以替代条形图。在下一章的*利用 seaborn 进行高级绘图*部分，我们将详细介绍它们；现在，让我们先来看看
    `pandas.plotting` 模块。
- en: The pandas.plotting module
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pandas.plotting 模块
- en: In the *Plotting with pandas* section, we covered standard plots that `pandas`
    has provided easier implementations for. However, `pandas` also has a module (which
    is appropriately named `plotting`) with special plots that we can use on our data.
    Note that the customization options of these may be more limited because of how
    they are composed and returned to us.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用 pandas 绘图*部分，我们讲解了 `pandas` 提供的标准图表类型。 然而，`pandas` 也有一个模块（名为 `plotting`），其中包含一些可以在数据上使用的特殊图表。请注意，由于它们的构成和返回方式，这些图表的自定义选项可能更为有限。
- en: 'We will be working in the `3-pandas_plotting_module.ipynb` notebook for this
    section. As usual, we will begin with our imports and reading in the data; we
    will only be using the Facebook data here:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将在 `3-pandas_plotting_module.ipynb` 笔记本中进行操作。像往常一样，我们将从导入库和读取数据开始；这里只使用
    Facebook 数据：
- en: '[PRE54]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, let's take a tour of some of the plots available in the `pandas.plotting`
    module and learn how we can utilize the resulting visualizations in our EDA.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来了解一下 `pandas.plotting` 模块中提供的一些图表，学习如何将这些可视化结果应用于我们的探索性数据分析（EDA）。
- en: Scatter matrices
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 散点矩阵
- en: 'Earlier in this chapter, we discussed using scatter plots to show relationships
    among variables. Often, we want to see these for each combination of variables
    in the data, which can be tedious to execute. The `pandas.plotting` module contains
    the `scatter_matrix()` function, which makes this much easier. Let''s use it to
    view the scatter plots for each combination of columns in our Facebook stock prices
    data:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们讨论了如何使用散点图来展示变量之间的关系。通常，我们希望查看数据中每一对变量的散点图，这可能会很繁琐。`pandas.plotting`
    模块包含了 `scatter_matrix()` 函数，这使得这个过程变得更加容易。我们可以用它来查看 Facebook 股票价格数据中各列组合的散点图：
- en: '[PRE55]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This results in the following plot matrix, which is often used in machine learning
    to see which variables could be useful in building a model. We can easily see
    that we have strong positive correlations between the opening, high, low, and
    closing prices:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会得到以下的绘图矩阵，这在机器学习中通常用于查看哪些变量在构建模型时可能有用。我们可以很容易地看到，开盘价、最高价、最低价和收盘价之间有强烈的正相关关系：
- en: '![Figure 5.39 – Pandas scatter matrix'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.39 – Pandas 散点矩阵'
- en: '](img/Figure_5.39_B16834.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.39_B16834.jpg)'
- en: Figure 5.39 – Pandas scatter matrix
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.39 – Pandas 散点矩阵
- en: 'By default, on the diagonal, where the column is paired with itself, we get
    its histogram. Alternatively, we can ask for the KDE by passing in `diagonal=''kde''`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在对角线上，列与自己配对时，我们会得到它的直方图。或者，我们可以通过传入 `diagonal='kde'` 来请求 KDE：
- en: '[PRE56]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This results in a scatter matrix with KDEs along the diagonal instead of histograms:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这样得到的散点矩阵在对角线处是 KDE，而不是直方图：
- en: '![Figure 5.40 – Scatter matrix with KDEs'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.40 – 带有 KDE 的散点矩阵'
- en: '](img/Figure_5.40_B16834.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.40_B16834.jpg)'
- en: Figure 5.40 – Scatter matrix with KDEs
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.40 – 带有 KDE 的散点矩阵
- en: While a scatter matrix makes it easy to examine the relationships between our
    variables, sometimes, we are interested in **autocorrelation**, which means that
    the time series is correlated with a lagged version of itself. One way to visualize
    this is with a lag plot.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管散点矩阵可以方便地检查变量之间的关系，但有时我们更关心**自相关性**，即时间序列与其滞后版本之间的相关性。可视化自相关性的一种方法是使用滞后图。
- en: Lag plots
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滞后图
- en: We can use a `data[:-1]` (all but the last entry) and `data[1:]` (from the second
    entry to the last one).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `data[:-1]`（去掉最后一项）和 `data[1:]`（从第二项到最后一项）。
- en: 'If our data is random, this plot will have no pattern. Let''s test this with
    some random data generated with NumPy:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的数据是随机的，这个图表将没有任何模式。让我们用 NumPy 生成一些随机数据来测试这一点：
- en: '[PRE57]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The random data points don''t indicate any pattern, just random noise:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数据点并未显示出任何模式，只有随机噪声：
- en: '![Figure 5.41 – Lag plot of random noise'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.41 – 随机噪声的滞后图'
- en: '](img/Figure_5.41_B16834.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.41_B16834.jpg)'
- en: Figure 5.41 – Lag plot of random noise
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.41 – 随机噪声的滞后图
- en: 'With our stock data, we know that the prices on a given day are determined
    by what happened the day before; therefore, we would expect to see a pattern in
    the lag plot. Let''s use the closing price of Facebook''s stock to test whether
    our intuition is correct:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的股票数据，我们知道某一天的价格是由前一天的情况决定的；因此，我们预计在滞后图中会看到一种模式。让我们使用 Facebook 股票的收盘价来测试我们的直觉是否正确：
- en: '[PRE58]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As expected, this results in a linear pattern:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，这导致了一个线性模式：
- en: '![Figure 5.42 – Lag plot of Facebook stock prices'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.42 – Facebook 股票价格的滞后图'
- en: '](img/Figure_5.42_B16834.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.42_B16834.jpg)'
- en: Figure 5.42 – Lag plot of Facebook stock prices
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.42 – Facebook 股票价格的滞后图
- en: 'We can also specify the number of periods to use for the lag. The default lag
    is one, but we can change this with the `lag` parameter. For example, we can compare
    each value to the value of the week prior with `lag=5` (remember that the stock
    data only contains data for weekdays since the market is closed on the weekends):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定用于滞后的周期数。默认滞后为 1，但我们可以通过 `lag` 参数更改它。例如，我们可以使用 `lag=5` 比较每个值与前一周的值（记住，股票数据仅包含工作日的数据，因为市场在周末关闭）：
- en: '[PRE59]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This still yields a strong correlation, but, compared to *Figure 5.42*, it
    definitely looks weaker:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然产生了强相关性，但与*图 5.42*相比，它看起来明显较弱：
- en: '![Figure 5.43 – Customizing the number of periods for the lag plot'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.43 – 自定义滞后图的周期数'
- en: '](img/Figure_5.43_B16834.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.43_B16834.jpg)'
- en: Figure 5.43 – Customizing the number of periods for the lag plot
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.43 – 自定义滞后图的周期数
- en: While lag plots help us visualize autocorrelation, they don't show us how many
    periods of autocorrelation our data contains. For this purpose, we can use autocorrelation
    plots.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然滞后图帮助我们可视化自相关，但它们并不能告诉我们数据包含多少个自相关周期。为此，我们可以使用自相关图。
- en: Autocorrelation plots
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自相关图
- en: Pandas provides an additional way for us to look for autocorrelation in our
    data with the `autocorrelation_plot()` function, which shows the autocorrelation
    by the number of lags. Random data will be near an autocorrelation of zero.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 提供了一种额外的方法来查找我们数据中的自相关，使用 `autocorrelation_plot()` 函数，它通过滞后的数量来显示自相关。随机数据的自相关值接近零。
- en: 'As we did when discussing lag plots, let''s first examine what this looks like
    for random data generated with NumPy:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论滞后图时所做的那样，让我们首先检查一下使用 NumPy 生成的随机数据是什么样子的：
- en: '[PRE60]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Indeed, the autocorrelation is near zero, and the line is within the confidence
    bands (99% is dashed; 95% is solid):'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，自相关接近零，且该线位于置信带内（99% 是虚线；95% 是实线）：
- en: '![Figure 5.44 – Autocorrelation plot of random data'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.44 – 随机数据的自相关图'
- en: '](img/Figure_5.44_B16834.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.44_B16834.jpg)'
- en: Figure 5.44 – Autocorrelation plot of random data
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.44 – 随机数据的自相关图
- en: 'Let''s explore what the autocorrelation plot looks like for the closing price
    of Facebook''s stock, since the lag plots indicated several periods of autocorrelation:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一下 Facebook 股票收盘价的自相关图，因为滞后图显示了几个自相关周期：
- en: '[PRE61]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here, we can see that there is autocorrelation for many lag periods before
    it becomes noise:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，在变为噪声之前，许多滞后周期存在自相关：
- en: '![Figure 5.45 – Autocorrelation plot of Facebook stock prices'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.45 – Facebook 股票价格的自相关图'
- en: '](img/Figure_5.45_B16834.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.45_B16834.jpg)'
- en: Figure 5.45 – Autocorrelation plot of Facebook stock prices
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.45 – Facebook 股票价格的自相关图
- en: Tip
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Recall from [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015), *Introduction
    to Data Analysis*, that one of the components in an ARIMA model is the autoregressive
    component. The autocorrelation plot can be used to help determine the number of
    time lags to use. We will build an ARIMA model in [*Chapter 7*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146),
    *Financial Analysis – Bitcoin and the Stock Market*.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 [*第 1 章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)，*数据分析导论*，ARIMA
    模型中的一个组成部分是自回归成分。自相关图可以帮助确定要使用的时间滞后数。我们将在 [*第 7 章*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146)，*金融分析
    – 比特币与股市* 中构建一个 ARIMA 模型。
- en: Bootstrap plots
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自助法图
- en: Pandas also provides a plotting function for assessing the uncertainty of common
    summary statistics via `samples` and `size` parameters, respectively) and calculate
    the summary statistics. Then, it will return a visualization of the results.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 还提供了一个绘图功能，用于评估常见汇总统计量的不确定性，通过 `samples` 和 `size` 参数分别计算汇总统计量。然后，它将返回结果的可视化图像。
- en: 'Let''s see what the uncertainty for the summary statistics of the volume traded
    data looks like:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看交易量数据的汇总统计的不确定性情况：
- en: '[PRE62]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This results in the following subplots, which we can use to assess the uncertainty
    in the mean, median, and midrange (the midpoint of the range):'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下子图，我们可以用它来评估均值、中位数和中值范围（区间中点）的不确定性：
- en: '![Figure 5.46 – Pandas bootstrap plot'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.46 – Pandas bootstrap 图'
- en: '](img/Figure_5.46_B16834.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.46_B16834.jpg)'
- en: Figure 5.46 – Pandas bootstrap plot
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.46 – Pandas bootstrap 图
- en: This was a sample of a few of the functions in the `pandas.plotting` module.
    For the full list, check out [https://pandas.pydata.org/pandas-docs/stable/reference/plotting.html](https://pandas.pydata.org/pandas-docs/stable/reference/plotting.html).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`pandas.plotting`模块中一些函数的示例。完整列表请查看[https://pandas.pydata.org/pandas-docs/stable/reference/plotting.html](https://pandas.pydata.org/pandas-docs/stable/reference/plotting.html)。
- en: Summary
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now that we've completed this chapter, we are well-equipped to quickly create
    a variety of visualizations in Python using `pandas` and `matplotlib`. We now
    understand the basics of how `matplotlib` works and the main components of a plot.
    Additionally, we discussed various plot types and the situations in which to use
    them—a crucial component of data visualization is choosing the appropriate plot.
    Be sure to check out the *Choosing the appropriate visualization* section in the
    *Appendix* for future reference.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，我们已经能够使用`pandas`和`matplotlib`快速创建各种可视化图表。我们现在理解了`matplotlib`的基本原理以及图表的主要组成部分。此外，我们讨论了不同类型的图表以及在什么情况下使用它们——数据可视化的一个关键部分是选择合适的图表。请务必参考附录中的*选择合适的可视化*部分以备将来参考。
- en: Note that the best practices for visualization don't just apply to the plot
    type, but also to the formatting of the plot, which we will discuss in the next
    chapter. In addition to this, we will build upon the foundation we laid here to
    discuss additional plots using `seaborn` and how to customize our plots using
    `matplotlib`. Be sure to complete the end-of-chapter exercises to practice plotting
    before moving on, as we will be building on this chapter's material.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最佳的可视化实践不仅适用于图表类型，还适用于图表的格式设置，我们将在下一章讨论此内容。除此之外，我们将在此基础上进一步讨论使用`seaborn`的其他图表，以及如何使用`matplotlib`自定义我们的图表。请务必完成章节末的练习，以便在继续前进之前练习绘图，因为我们将在此章节的内容上进行扩展。
- en: Exercises
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Create the following visualizations using what you have learned up to this
    point in this book. Use the data from this chapter''s `data/` directory:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 使用到目前为止在本书中所学的内容创建以下可视化。请使用本章`data/`目录中的数据：
- en: Plot the rolling 20-day minimum of the Facebook closing price using `pandas`.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pandas`绘制 Facebook 收盘价的 20 天滚动最低值。
- en: Create a histogram and KDE of the change from open to close in the price of
    Facebook stock.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Facebook 股票开盘到收盘价变化的直方图和 KDE。
- en: Using the earthquake data, create box plots for the magnitudes of each `magType`
    used in Indonesia.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用地震数据，为印度尼西亚使用的每个`magType`绘制箱线图。
- en: Make a line plot of the difference between the weekly maximum high price and
    the weekly minimum low price for Facebook. This should be a single line.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一条线图，表示 Facebook 每周的最高价和最低价之间的差异。这应为单条线。
- en: 'Plot the 14-day moving average of the daily change in new COVID-19 cases in
    Brazil, China, India, Italy, Spain, and the USA:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制巴西、中国、印度、意大利、西班牙和美国每日新增 COVID-19 病例的 14 天移动平均值：
- en: a) First, use the `diff()` method that was introduced in the *Working with time
    series data* section of [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Aggregating Pandas DataFrames*, to calculate the day-over-day change in new cases.
    Then, use `rolling()` to calculate the 14-day moving average.
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 首先，使用`diff()`方法，该方法在[《第 4 章》](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082)的*处理时间序列数据*部分介绍，用于计算每日新增病例的变化。然后，使用`rolling()`计算
    14 天的移动平均值。
- en: 'b) Make three subplots: one for China; one for Spain and Italy; and one for
    Brazil, India, and the USA.'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 创建三个子图：一个显示中国；一个显示西班牙和意大利；另一个显示巴西、印度和美国。
- en: 'Using `matplotlib` and `pandas`, create two subplots side-by-side showing the
    effect that after-hours trading has had on Facebook''s stock prices:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`matplotlib`和`pandas`，创建并排显示的两个子图，展示盘后交易对 Facebook 股票价格的影响：
- en: a) The first subplot will contain a line plot of the daily difference between
    that day's opening price and the prior day's closing price (be sure to review
    the *Working with time series data* section of [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Aggregating Pandas DataFrames*, for an easy way to do this).
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 第一个子图将包含每日开盘价与前一天收盘价之间的差值线图（请务必查看[*第 4 章*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082)中的*处理时间序列数据*部分，*聚合
    Pandas 数据框*，以便轻松实现）。
- en: b) The second subplot will be a bar plot showing the net effect this had monthly,
    using `resample()`.
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 第二个子图将是一个条形图，显示这一变动的月度净效应，使用`resample()`。
- en: 'c) Bonus #1: Color the bars according to whether there are gains in the stock
    price (green) or drops in the stock price (red).'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'c) 奖励 #1：根据股价是上涨（绿色）还是下跌（红色）来为条形图着色。'
- en: 'd) Bonus #2: Modify the *x*-axis of the bar plot to show the three-letter abbreviation
    for the month.'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'd) 奖励 #2：修改条形图的 *x* 轴，以显示月份的三字母缩写。'
- en: Further reading
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Take a look at the following resources for additional information on the concepts
    that were discussed in this chapter:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下资源，获取本章讨论概念的更多信息：
- en: '*Bootstrapping (statistics)*: [https://en.wikipedia.org/wiki/Bootstrapping_(statistics)](https://en.wikipedia.org/wiki/Bootstrapping_(statistics))'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自助法（统计学）*: [https://en.wikipedia.org/wiki/Bootstrapping_(statistics)](https://en.wikipedia.org/wiki/Bootstrapping_(statistics))'
- en: '*Data Visualization – Best Practices and Foundations*: [https://www.toptal.com/designers/data-visualization/data-visualization-best-practices](https://www.toptal.com/designers/data-visualization/data-visualization-best-practices)'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据可视化 – 最佳实践与基础*: [https://www.toptal.com/designers/data-visualization/data-visualization-best-practices](https://www.toptal.com/designers/data-visualization/data-visualization-best-practices)'
- en: '*How to Create Animated Graphs in Python (with matplotlib)*: [https://towardsdatascience.com/how-to-create-animated-graphs-in-python-bb619cc2dec1](https://towardsdatascience.com/how-to-create-animated-graphs-in-python-bb619cc2dec1)'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何在 Python 中创建动画图形（使用 matplotlib）*: [https://towardsdatascience.com/how-to-create-animated-graphs-in-python-bb619cc2dec1](https://towardsdatascience.com/how-to-create-animated-graphs-in-python-bb619cc2dec1)'
- en: '*Interactive Plots with JavaScript (D3.js)*: [https://d3js.org/](https://d3js.org/)'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 JavaScript 进行交互式绘图（D3.js）*: [https://d3js.org/](https://d3js.org/)'
- en: '*Intro to Animations in Python (with plotly)*: [https://plot.ly/python/animations/](https://plot.ly/python/animations/)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python 动画入门（使用 plotly）*: [https://plot.ly/python/animations/](https://plot.ly/python/animations/)'
- en: '*IPython: Built-in magic commands*: [https://ipython.readthedocs.io/en/stable/interactive/magics.html](https://ipython.readthedocs.io/en/stable/interactive/magics.html)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IPython: 内置魔法命令*: [https://ipython.readthedocs.io/en/stable/interactive/magics.html](https://ipython.readthedocs.io/en/stable/interactive/magics.html)'
- en: '*The Importance of Integrity: How Plot Parameters Influence Interpretation*:
    [https://www.t4g.com/insights/plot-parameters-influence-interpretation/](https://www.t4g.com/insights/plot-parameters-influence-interpretation/)'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*诚信的重要性：绘图参数如何影响解读*: [https://www.t4g.com/insights/plot-parameters-influence-interpretation/](https://www.t4g.com/insights/plot-parameters-influence-interpretation/)'
- en: '*5 Python Libraries for Creating Interactive Plots*: [https://mode.com/blog/python-interactive-plot-libraries/](https://mode.com/blog/python-interactive-plot-libraries/)'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*5 个用于创建交互式绘图的 Python 库*: [https://mode.com/blog/python-interactive-plot-libraries/](https://mode.com/blog/python-interactive-plot-libraries/)'
