- en: '*Chapter 2*: Quantum Computing and Qubits with Python'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 2 章*：使用 Python 进行量子计算和量子比特'
- en: Quantum computing is a fairly new and fairly old field at the same time. The
    ideas and concepts used to achieve quantum computing (such as quantum mechanical
    superposition and entanglement) have been around for almost a century and the
    field of quantum information science was founded almost 40 years ago. Early explorers,
    such as Peter Shor and Lov Grover, produced quantum computing algorithms (Shor's
    algorithm and Grover's algorithm) that are now starting to become as well known
    as foundational physics concepts such as *E=mc**2*. For details, see the references
    at the end of the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算是一个既新又旧的领域。用于实现量子计算（如量子力学的叠加和纠缠）的思想和概念已经存在了近一个世纪，量子信息科学领域几乎是在 40 年前成立的。早期的探索者，如
    Peter Shor 和 Lov Grover，产生了量子计算算法（Shor 算法和 Grover 算法），这些算法现在开始像基础物理概念（如 *E=mc**2*）一样为人所熟知。有关详细信息，请参阅本章末尾的参考文献。
- en: At the same time, real quantum computers that utilize these effects are a relatively
    recent invention. The requirements for building one were outlined by DiVincenzo
    in the 1990, and IBM opened up its IBM Quantum Experience® and Qiskit® in 2016,
    effectively the first time anyone outside of a research lab could start exploring
    this nascent field for real.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，真正利用这些效果的量子计算机是一种相对较新的发明。在 1990 年，DiVincenzo 概述了构建一个量子计算机的要求，IBM 于 2016 年推出了
    IBM Quantum Experience® 和 Qiskit®，这实际上是第一次任何人（除了研究实验室的人）可以真正开始探索这个新兴领域。
- en: So, what is the difference between classical computing and quantum computing?
    One way to start exploring is by taking a look at the basic computational elements
    used by each—the classical bits and the quantum qubits.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，经典计算和量子计算之间有什么区别呢？一种开始探索的方法是看看每个计算所使用的基本计算元素——经典比特和量子量子比特。
- en: In this chapter, we will contrast bits and qubits, play with some generic linear
    algebra to explore them in more detail, and contrast deterministic (classical)
    computation and probabilistic (quantum) computation. We will even take a quick
    look at some basic Qiskit® presentation methods to visualize a qubit.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对比比特和量子比特，通过一些通用的线性代数来更详细地探索它们，并对比确定性（经典）计算和概率性（量子）计算。我们甚至会快速浏览一些基本的
    Qiskit® 展示方法来可视化量子比特。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Comparing a bit and a qubit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较比特和量子比特
- en: Visualizing a qubit in Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中可视化量子比特
- en: A quick introduction to quantum gates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量子门的快速介绍
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The recipes that we discuss in this chapter can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter02](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter02).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中讨论的食谱可以在这里找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter02](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter02)。
- en: For more information about how to get the recipe sample code, refer to the *Downloading
    the code samples* section in [*Chapter 1*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021),
    *Preparing Your Environment*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何获取示例代码的更多信息，请参阅[*第 1 章*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021)中的*下载代码示例*部分，*准备你的环境*。
- en: Comparing a bit and a qubit
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较比特和量子比特
- en: So, let's start with the obvious—or perhaps, not so obvious—notion that most
    people who read this book know what a bit is.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们从显而易见——或者也许不那么显而易见——的观念开始，即大多数阅读这本书的人都知道比特是什么。
- en: An intuitive feeling that we have says that a bit is something that is either
    **zero** (**0**) or **one** (**1**). By putting many bits together, you can create
    bytes as well as arbitrary large binary numbers, and with those, build the most
    amazing computer programs, encode digital images, encrypt your love letters and
    bank transactions, and more.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一种直观的感觉，即比特要么是**零**（**0**），要么是**一**（**1**）。通过将许多比特组合在一起，你可以创建字节以及任意大的二进制数，并且利用这些数，你可以构建最令人惊叹的计算机程序，编码数字图像，加密你的情书和银行交易，等等。
- en: In a classical computer, a bit is realized by using low or high voltages over
    the transistors that make up the logic board, typically something such as 0 V
    and 5 V. In a hard drive, the bit might be a region magnetized in a certain way
    to represent 0 and the other way for 1, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典计算机中，位是通过在组成逻辑板的晶体管上使用低电压或高电压来实现的，通常是 0 V 和 5 V 这样的事情。在硬盘驱动器中，位可能是一个以某种方式磁化的区域，用来表示
    0，而另一种方式表示 1，等等。
- en: In books about quantum computing, the important point to drive home is that
    a classical bit can only be a 0 or a 1; it can never be anything else. In the
    computer example, you can imagine a box with an input and an output, where the
    box represents the program that you are running. With a classical computer (and
    I use the term classical here to indicate a binary computer that is not a quantum
    computer), the input is a string of bits, the output is another string of bits,
    and the box is a bunch of bits being manipulated, massaged, and organized to generate
    that output with some kind of algorithm. An important thing, again, to emphasize
    is that while in the box, the bits are still bits, always 0s or 1s, and nothing
    else.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于量子计算的书籍中，需要强调的重要观点是，经典位只能是 0 或 1；它永远不能是其他任何东西。在计算机的例子中，你可以想象一个带有输入和输出的盒子，盒子代表你正在运行的程序。在经典计算机（我在这里使用“经典”一词来表示不是量子计算机的二进制计算机）中，输入是一串位，输出是另一串位，盒子是一系列位被操作、按摩和组织以生成该输出的算法。再次强调的一个重要事情是，在盒子中，位仍然是位，始终是
    0 或 1，没有其他。
- en: A qubit, as we will discover in this chapter, is something quite different.
    Let's go explore.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特，正如我们将在本章中发现的那样，是相当不同的东西。让我们去探索。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As recipes go, this one isn't really that much to brag about. It is just a quick
    Python and NumPy implementation that defines a bit as a 2x1 matrix, or a vector
    representing 0 or 1\. We also introduce the Dirac notation of ![](img/Formula_02_001.png)
    to represent our qubits. We then calculate the probability of getting various
    results when measuring the bits and qubits.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为食谱来说，这个并不真正值得炫耀。它只是一个快速的 Python 和 NumPy 实现，将位定义为 2x1 矩阵，或者表示 0 或 1 的向量。我们还引入了狄拉克符号
    ![img/Formula_02_001.png](img/Formula_02_001.png) 来表示我们的量子比特。然后我们计算测量位和量子比特时得到各种结果的概率。
- en: 'The Python file for the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r1_bits_qubits.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r1_bits_qubits.py).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下食谱的 Python 文件可以从这里下载：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r1_bits_qubits.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r1_bits_qubits.py)。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s start by importing `numpy` and `math`, which we will need to do the
    calculations:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先导入 `numpy` 和 `math`，这是我们进行计算所需的：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create and print the bit and qubit vectors for 0, 1, ![](img/Formula_02_001.png)
    as `[1,0]`, `[0,1]`, `[1,0]`, `[0,1]`, and `[a,b]`, respectively:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 0、1、![img/Formula_02_001.png](img/Formula_02_001.png) 创建并打印位和量子比特向量，分别为 `[1,0]`、`[0,1]`、`[1,0]`、`[0,1]`
    和 `[a,b]`：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice the Unicode entries here: `\u27E9`. We use this instead of just `>`
    to create the nice-looking Dirac qubit rendering ![](img/Formula_02_003.png) in
    the output.'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这里的 Unicode 条目：`\u27E9`。我们使用这个而不是简单的 `>` 来在输出中创建看起来很棒的狄拉克量子比特渲染 ![img/Formula_02_003.png](img/Formula_02_003.png)。
- en: You must provide the correct a and b parameters
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您必须提供正确的 a 和 b 参数
- en: Note that the parameter verification code checks whether the values for `a`
    and `b` are *normalized*. If not, then `a` and `b` are reset to a simple 50/50
    superposition by setting ![](img/Formula_02_004.png) and ![](img/Formula_02_005.png).
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意参数验证代码检查 `a` 和 `b` 的值是否 *归一化*。如果不是，则将 `a` 和 `b` 重置为简单的 50/50 超叠加，通过设置 ![img/Formula_02_004.png](img/Formula_02_004.png)
    和 ![img/Formula_02_005.png]。
- en: 'Measure the qubits by creating a measurement dictionary, and then calculate
    the probability of getting `0` and `1` from the bit vectors we created:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建测量字典来测量量子比特，然后计算从我们创建的位向量中得到 `0` 和 `1` 的概率：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code should give the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应产生以下输出：
- en: '![Figure 2.1 – Simulating bits and qubits with NumPy'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – 使用 NumPy 模拟位和量子比特'
- en: '](img/Figure_2.1_B14436.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.1_B14436.jpg](img/Figure_2.1_B14436.jpg)'
- en: Figure 2.1 – Simulating bits and qubits with NumPy
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 使用 NumPy 模拟位和量子比特
- en: Now we know what the probabilities of getting the values of `0` or `1` are when
    measuring the bits and qubits. For some of these (0, 1, ![](img/Formula_02_006.png))
    the outcome is what we expected, 0 or 100%; the bit or qubit is either 0 or 1
    and nothing else. For one (![](img/Formula_02_007.png)), which is a qubit that
    is in a superposition of 0 and 1, the probability of getting either is 50%. This
    is an outcome that can never happen for a classical bit, only for a qubit. We
    will explain why in the next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了在测量比特和量子比特时得到`0`或`1`值的概率。对于其中一些（0，1，![](img/Formula_02_006.png)），结果是我们可以预期的，0或100%；比特或量子比特要么是0要么是1，没有其他。对于其中一个(![](img/Formula_02_007.png))，这是一个处于0和1叠加状态的量子比特，得到任一的概率是50%。这是一个对于经典比特永远不会发生的结果，只有对于量子比特。我们将在下一节中解释原因。
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What we have seen in this recipe is that the probability of reading a classical
    bit will always be *100%*, either 0 or 1; there are no other options. But for
    a qubit that can be expressed as ![](img/Formula_02_008.png) the probability of
    a 0 or 1 is proportional to ![](img/Formula_02_009.png). For pure ![](img/Formula_02_010.png)
    states, *a* or *b* is always 1, and the probability of measuring each is 100%.
    But for the qubit that we labeled ![](img/Formula_02_011.png), a and b are both
    ![](img/Formula_02_012.png), giving a probability of 50% for 0 or 1 ![](img/Formula_02_013.png).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们看到的经典比特读取的概率总是*100%*，要么是0要么是1；没有其他选项。但对于可以表示为![](img/Formula_02_008.png)的量子比特，0或1的概率与![](img/Formula_02_009.png)成正比。对于纯![](img/Formula_02_010.png)状态，*a*或*b*总是1，测量每个的概率都是100%。但对于我们标记为![](img/Formula_02_011.png)的量子比特，a和b都是![](img/Formula_02_012.png)，给出0或1的概率为50%
    ![](img/Formula_02_013.png)。
- en: Measuring a bit and a qubit
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测量比特和量子比特
- en: The word **measure** means two slightly different things in classical computing
    and quantum computing. In classical computing, you can measure your bits at any
    time without seriously disturbing the calculations that you are doing. For a quantum
    computer, measuring is a more definite act that results in your qubit reverting
    from a bit that behaves quantum-mechanically to a bit that behaves classically.
    After you measure a qubit, you are done. You can do no further quantum actions
    on that qubit.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典计算和量子计算中，“测量”这个词意味着两件略有不同的事情。在经典计算中，你可以在任何时候测量你的比特，而不会严重干扰你正在进行的计算。对于量子计算机来说，测量是一个更明确的行为，导致你的量子比特从表现出量子力学行为的比特转变为表现出经典行为的比特。测量量子比特后，你就完成了。你不能再对该量子比特进行任何进一步的量子操作。
- en: Due to the quantum mechanical nature of a qubit, we can describe it as a vector
    similar to the vector we use for a bit. To clarify that, when we are talking about
    qubits, we do not just use 0 and 1 as labels, but rather the Dirac *ket* notation,
    ![](img/Formula_02_014.png) and ![](img/Formula_02_015.png), indicating that these
    are state vectors in a vector space.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于量子比特的量子力学性质，我们可以将其描述为与用于比特的向量相似的向量。为了澄清这一点，当我们谈论量子比特时，我们不仅使用0和1作为标签，而是使用狄拉克*矢量*符号，![](img/Formula_02_014.png)
    和 ![](img/Formula_02_015.png)，表示这些是向量空间中的状态向量。
- en: 'We can write out the state vector, ![](img/Formula_02_016.png) (psi), of a
    qubit like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样写出量子比特的状态向量，![](img/Formula_02_016.png)（psi）：
- en: '![](img/Formula_02_017.png) for a qubit in the *ground state*, representing
    0'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/Formula_02_017.png) 对于处于**基态**的量子比特，表示0'
- en: '![](img/Formula_02_018.png) for a qubit in the *excited state*, representing
    1'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/Formula_02_018.png) 对于处于**激发态**的量子比特，表示1'
- en: Here, we have used **ground state** and **excited state** as one way of categorizing
    qubits. This is appropriate as the Josephson junctions that the IBM Quantum® qubits
    use are quantum systems with two energy levels. Depending on the underlying physical
    system, qubits can also be based on other two-level quantum systems, such as electron
    spin (up or down) or photon polarization (horizontal or vertical).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了**基态**和**激发态**作为对量子比特进行分类的一种方式。这是合适的，因为IBM Quantum®量子比特使用的约瑟夫森结是具有两个能级的量子系统。根据底层物理系统，量子比特也可以基于其他两能级量子系统，例如电子自旋（向上或向下）或光子偏振（水平或垂直）。
- en: 'So far, nothing is intuitively much different from classical bits, as each
    represents just the value 0 or 1\. But now we add a complexity: a qubit can also
    be a superposition of the two states, ![](img/Formula_02_019.png) and ![](img/Formula_02_020.png).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，与经典比特相比，并没有什么直观上的不同，因为每个都只代表值0或1。但现在我们增加了一个复杂性：一个量子比特也可以是两种状态的叠加，![](img/Formula_02_019.png)
    和 ![](img/Formula_02_020.png)。
- en: '![](img/Formula_02_021.png), where *a* and *b* are complex numbers. These numbers
    are normalized so that ![](img/Formula_02_022.png), which geometrically means
    that the resulting vector, ![](img/Formula_02_023.png), has a length of 1\. This
    is important!'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![公式](img/Formula_02_021.png)，其中*a*和*b*是复数。这些数字被归一化，使得![公式](img/Formula_02_022.png)，这在几何上意味着结果向量![公式](img/Formula_02_023.png)的长度为1。这很重要！'
- en: 'Going back to the simplest cases, these can be described as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 回到最简单的例子，这些可以描述如下：
- en: '![](img/Formula_02_024.png) for a qubit in the ground state. In this case,
    a=1 and b=0.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![公式](img/Formula_02_024.png)对于基态的量子比特。在这种情况下，a=1，b=0。'
- en: '![](img/Formula_02_025.png) for a qubit in the excited state. In this case,
    a=0 and b=1.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![公式](img/Formula_02_025.png)对于激发态的量子比特。在这种情况下，a=0，b=1。'
- en: 'So far, so good, but now we add the quantum twist: superposition. The following
    qubit state vector is also supported:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但现在我们加入量子转折：叠加。以下量子比特状态向量也得到支持：
- en: '![](img/Formula_02_026.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![公式](img/Formula_02_026.png)'
- en: Just to check that we are still normalized, in this case,
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了检查我们是否仍然归一化，在这种情况下，
- en: '![](img/Formula_02_027.png).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![公式](img/Formula_02_027.png).'
- en: But what does this state vector mean?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个状态向量意味着什么呢？
- en: The qubit is set up in a state where it is exactly halfway between ![](img/Formula_02_028.png)
    and ![](img/Formula_02_029.png); it exists in a superposition of the two basic
    states. It is behaving quantumly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特被设置在一个状态，它正好位于![公式](img/Formula_02_028.png)和![公式](img/Formula_02_029.png)之间；它存在于两种基本状态的叠加中。它正在表现出量子行为。
- en: Important Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The quantum superposition state of a qubit can only be sustained while we are
    doing calculations on the quantum computer. The same is true for an actual particle
    in nature, such as a photon that behaves quantum-mechanically. For example, the
    polarization of the photon can be described as a superposition of horizontal and
    vertical orientations while the photon is in flight, but when you add a polarizer
    in its path, you will measure it as either horizontal or vertical, and nothing
    else.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特的量子叠加态只能在我们在量子计算机上进行计算时维持。对于自然界中的实际粒子，例如表现出量子行为的光子，也是如此。例如，光子的偏振可以描述为在光子飞行过程中水平方向和垂直方向的叠加，但当你在其路径上添加一个偏振器时，你会测量到它是水平方向或垂直方向，而不会是其他方向。
- en: Going back to the computer-as-a-box example, for a quantum computer we have
    a similar image, a string of bits as input and another string of bits as output.
    The difference comes inside the box where the qubits can exist in superposition
    while we are doing our calculations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 回到计算机作为盒子的例子，对于量子计算机，我们有一个类似的概念，输入是一串比特，输出也是另一串比特。区别在于盒子内部，在计算过程中，量子比特可以处于叠加态。
- en: As soon as we measure the qubits to get that string of output bits however,
    the qubits must decide, quantum-mechanically, if they are a ![](img/Formula_02_030.png)
    or a ![](img/Formula_02_031.png), and here is where those *a* and *b* parameters
    come in.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们测量量子比特以获得那一串输出比特时，量子比特必须量子力学地决定它们是![公式](img/Formula_02_030.png)还是![公式](img/Formula_02_031.png)，这就是那些*a*和*b*参数出现的地方。
- en: The ![](img/Formula_02_032.png) formula not only states that the vector is normalized
    to the length 1, but it also describes the probability of getting the ![](img/Formula_02_033.png)
    and ![](img/Formula_02_034.png) outputs. The probability of getting ![](img/Formula_02_035.png)
    is ![](img/Formula_02_036.png), and ![](img/Formula_02_037.png) is ![](img/Formula_02_038.png).
    This is the core of the difference between a quantum computer and a classical
    computer. The quantum computer is probabilistic—you cannot know in advance what
    the end result will be, only the probability of getting a certain result—whereas
    the classical computer is deterministic—you can always, at least in theory, predict
    what the answer will be.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![公式](img/Formula_02_032.png)公式不仅表明该向量被归一化到长度1，而且还描述了获得![公式](img/Formula_02_033.png)和![公式](img/Formula_02_034.png)输出的概率。获得![公式](img/Formula_02_035.png)的概率是![公式](img/Formula_02_036.png)，![公式](img/Formula_02_037.png)是![公式](img/Formula_02_038.png)。这是量子计算机和经典计算机之间差异的核心。量子计算机是概率性的——你无法预先知道最终结果会是什么，只能知道得到某个结果的概率——而经典计算机是确定性的——你总是可以，至少在理论上，预测出答案会是什么。'
- en: About probabilistic computing
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关于概率计算
- en: People often get a little confused about quantum computers and probabilistic
    outcomes and visualize the whole quantum programming concept as qubits spinning
    randomly and uncontrollably in all different states at the same time. This is
    not a true picture; each qubit is initialized in a specific known state, ![](img/Formula_02_144.png),
    and then acted upon by quantum gate manipulations. Each manipulation is strictly
    deterministic; there is nothing random. At each stage in a quantum state evolution,
    we know exactly what our qubit is doing, expressed as an ![](img/Formula_02_039.png)
    superposition. It is only at the end, when we measure and force the qubit to be
    either 0 or 1, that the probabilistic nature shows with the probability of measuring
    0 or 1 set by the *a* and *b* parameters (![](img/Formula_02_040.png)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常对量子计算机和概率结果感到有些困惑，并将整个量子编程概念可视化为一个量子位在所有不同状态下随机且无法控制地旋转。这不是一个真实的画面；每个量子位都是初始化在特定的已知状态，![](img/Formula_02_144.png)，然后通过量子门操作进行作用。每次操作都是严格确定性的；没有任何随机性。在量子状态演化的每个阶段，我们都能确切地知道我们的量子位在做什么，这可以用一个![](img/Formula_02_039.png)叠加来表示。只有在最后，当我们测量并迫使量子位变为0或1时，概率性质才会显现出来，测量的0或1的概率由*a*和*b*参数(![](img/Formula_02_040.png))设定。
- en: See also
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information about qubits and how to interpret them, refer to the following
    excellent books:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 关于量子位及其解释的更多信息，请参阅以下优秀书籍：
- en: '*Dancing with Qubits, How quantum computing works and how it can change the
    world*, Robert S. Sutor, Packt Publishing Ltd., 2019, [*Chapter 7*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197),
    *One Qubit*'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与量子位共舞：量子计算是如何工作的以及它如何改变世界*，罗伯特·S·萨托，Packt Publishing Ltd.，2019年，[*第7章*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197)，*一个量子位*'
- en: '*Quantum Computation and Quantum Information*, Isaac L. Chuang; Michael A.
    Nielsen, Cambridge University Press, 2010, *Chapter 1.2*, *Quantum bits*'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*量子计算与量子信息*，艾萨克·L·丘昂；迈克尔·A·尼尔森，剑桥大学出版社，2010年，*第1.2章*，*量子比特*'
- en: '*Quantum Mechanics: The theoretical minimum*, Leonard Susskind & Art Friedman,
    Basic Books, 2015, *Lecture 1: Systems and experiments*'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*量子力学：理论最小值*，莱昂纳德·苏斯金德 & 阿特·弗里德曼，基础书籍出版社，2015年，*讲座1：系统和实验*'
- en: '*Shor, I''ll do it*, Scott Aaronson''s blog, [https://www.scottaaronson.com/blog/?p=208](https://www.scottaaronson.com/blog/?p=208)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*肖尔，我会做到的*，斯科特·阿伦森的博客，[https://www.scottaaronson.com/blog/?p=208](https://www.scottaaronson.com/blog/?p=208)'
- en: '*What''s a Quantum Phone Book?*, Lov Grover, Lucent Technologies, [https://web.archive.org/web/20140201230754/http://www.bell-labs.com/user/feature/archives/lkgrover/](https://web.archive.org/web/20140201230754/http://www.bell-labs.com/user/feature/archives/lkgrover/)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*量子电话簿是什么？*，洛夫·格罗弗，朗讯科技公司，[https://web.archive.org/web/20140201230754/http://www.bell-labs.com/user/feature/archives/lkgrover/](https://web.archive.org/web/20140201230754/http://www.bell-labs.com/user/feature/archives/lkgrover/)'
- en: '*The Physical Implementation of Quantum Computation*, David P. DiVincenzo,
    IBM, [https://arxiv.org/abs/quant-ph/0002077](https://arxiv.org/abs/quant-ph/0002077)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*量子计算的物理实现*，大卫·P·迪文森佐，IBM，[https://arxiv.org/abs/quant-ph/0002077](https://arxiv.org/abs/quant-ph/0002077)'
- en: Visualizing a qubit in Python
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中可视化量子位
- en: In this recipe, we will use generic Python with NumPy to create a vector and
    visual representation of a bit and show how it can be in only two states, 0 and
    1\. We will also introduce our first, smallish foray into the Qiskit® world by
    showing how a qubit can not only be in the unique 0 and 1 states but also in a
    superposition of these states. The way to do this is to take the vector form of
    the qubit and project it on the so-called **Bloch sphere**, for which there is
    a Qiskit® method. Let's get to work!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用通用的Python和NumPy创建一个比特的矢量和可视化表示，并展示它只能处于两种状态，0和1。我们还将通过展示量子位不仅可以处于唯一的0和1状态，还可以处于这些状态的叠加，来引入我们对Qiskit®世界的第一次小规模探索。要做到这一点，我们需要将量子位取为矢量形式，并将其投影到所谓的**布洛赫球**上，Qiskit®提供了一个方法。让我们开始工作吧！
- en: In the preceding recipe, we defined our qubits with the help of two complex
    parameters—*a* and *b*. This meant that our qubits could take values other than
    the 0 and 1 of a classical bit. But it is hard to visualize a qubit halfway between
    0 and 1, even if you know *a* and *b*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们通过两个复数参数——*a*和*b*的帮助定义了我们的量子位。这意味着我们的量子位可以取除了经典比特的0和1之外的值。但即使你知道*a*和*b*，也很难想象一个介于0和1之间的量子位。
- en: However, with a little mathematical trickery, it turns out that you can also
    describe a qubit using two angles—**theta** (![](img/Formula_02_041.png)) and
    **phi** (![](img/Formula_02_042.png))—and visualize the qubit on a Bloch sphere.
    You can think of the ![](img/Formula_02_0411.png) and ![](img/Formula_02_0421.png)
    angles much as the latitude and longitude of the earth. On the Bloch sphere, we
    can project any possible value that the qubit can take.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过一点数学技巧，我们发现也可以用两个角度来描述一个量子比特——**theta** (![](img/Formula_02_041.png)) 和
    **phi** (![](img/Formula_02_042.png))——并在布洛赫球上可视化量子比特。你可以把 ![](img/Formula_02_0411.png)
    和 ![](img/Formula_02_0421.png) 角度想象成地球的纬度和经度。在布洛赫球上，我们可以投射量子比特可能取的任何值。
- en: 'The equation for the transformation is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 变换的方程如下：
- en: '![](img/Formula_02_043.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_043.png)'
- en: 'Here, we use the formula we saw before:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用之前看到的公式：
- en: '![](img/Formula_02_044.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_044.png)'
- en: '*a* and *b* are, respectively, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* 和 *b* 分别如下：'
- en: '![](img/Formula_02_045.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_045.png)'
- en: '![](img/Formula_02_046.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_046.png)'
- en: 'I''ll leave the deeper details and math to you for further exploration:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我会把更深入细节和数学留给你们去进一步探索：
- en: '![Figure 2.2 – The Bloch sphere](img/Figure_2.2_B14436.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 布洛赫球](img/Figure_2.2_B14436.jpg)'
- en: Figure 2.2 – The Bloch sphere.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 布洛赫球。
- en: The poor classical bits cannot do much on a Bloch sphere as they can exist at
    the North and South poles only, representing the binary values 0 and 1\. We will
    include them just for comparison.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的经典比特在布洛赫球上无法做太多事情，因为它们只能存在于南北极，代表二进制值 0 和 1。我们只包括它们来进行比较。
- en: 'The reason 0 points up and 1 points down has peculiar and historical reasons.
    The qubit vector representation of ![](img/Formula_02_047.png) is ![](img/Formula_02_048.png),
    or up, and ![](img/Formula_02_049.png) is ![](img/Formula_02_050.png), or down,
    which is intuitively not what you expect. You would think that 1, or a more exciting
    qubit, would be a vector pointing upward, but this is not the case; it points
    down. So, I will do the same with the poor classical bits as well: 0 means up
    and 1 means down.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 0 指向上方和 1 指向下方有特殊的历史原因。![](img/Formula_02_047.png) 的量子比特向量表示为 ![](img/Formula_02_048.png)，或向上，![](img/Formula_02_049.png)
    是 ![](img/Formula_02_050.png)，或向下，这不符合直观的预期。你会认为 1，或者一个更令人兴奋的量子比特，应该是一个指向上方的向量，但事实并非如此；它指向下方。所以，我也会用同样糟糕的经典比特来做：0
    表示向上，1 表示向下。
- en: The latitude, the distance to the poles from a cut straight through the Bloch
    sphere, corresponds to the numerical values of *a* and *b*, with ![](img/Formula_02_051.png)
    pointing straight up for ![](img/Formula_02_052.png) (a=1, b=0), ![](img/Formula_02_053.png)
    pointing straight down for ![](img/Formula_02_054.png) points to the equator for
    the basic superposition where ![](img/Formula_02_055.png).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 纬度，从穿过布洛赫球的切面到两极的距离，对应于 *a* 和 *b* 的数值，![](img/Formula_02_051.png) 指向直上方的 ![](img/Formula_02_052.png)（a=1，b=0），![](img/Formula_02_053.png)
    指向直下方的 ![](img/Formula_02_054.png)，对于基本叠加态 ![](img/Formula_02_055.png) 来说，它指向赤道。
- en: So, what we are adding to the equation here is the *phase* of the qubit. The
    ![](img/Formula_02_042.png) angle cannot be directly measured and has no impact
    on the outcome of our initial quantum circuits. Later on in the book, in [*Chapter
    9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246), *Grover's Search Algorithm*,
    we will see that you can use the phase angle to great advantage in certain algorithms.
    But we are getting ahead of ourselves.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们添加到方程中的是量子比特的**相位**。![](img/Formula_02_042.png) 角度不能直接测量，并且对我们的初始量子电路的结果没有影响。在本书后面的[*第
    9 章*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246)，“Grover 搜索算法”中，我们将看到你可以利用相位角度在某些算法中取得很大的优势。但我们现在走得太远了。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The Python file for the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r2_visualize_bits_qubits.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r2_visualize_bits_qubits.py).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下菜谱的 Python 文件可以从这里下载：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r2_visualize_bits_qubits.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r2_visualize_bits_qubits.py)。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For this exercise, we will use the ![](img/Formula_02_057.png) and ![](img/Formula_02_058.png)
    angles as latitude and longitude coordinates on the Bloch sphere. We will code
    the 0, 1, ![](img/Formula_02_059.png), ![](img/Formula_02_049.png), and ![](img/Formula_02_061.png)
    states with the corresponding angles. As we can set these angles to any latitude
    and longitude value we want, we can put the qubit state vector wherever we want
    on the Bloch sphere:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将使用![公式2.57](img/Formula_02_057.png)和![公式2.58](img/Formula_02_058.png)角度作为Bloch球面上的纬度和经度坐标。我们将使用相应的角度来编码0、1、![公式2.59](img/Formula_02_059.png)、![公式2.049](img/Formula_02_049.png)和![公式2.061](img/Formula_02_061.png)状态。由于我们可以将这些角度设置为任何纬度和经度值，我们可以将量子比特状态向量放置在Bloch球面上的任何位置：
- en: 'Import the classes and methods that we need, including `numpy` and `plot_bloch_``vector`
    from Qiskit®. We also need to use `cmath` to do some calculations on imaginary
    numbers:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的类和方法，包括来自Qiskit®的`numpy`和`plot_bloch_vector`。我们还需要使用`cmath`来对复数进行一些计算：
- en: '[PRE3]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create the qubits:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建量子比特：
- en: '[PRE4]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'From the code sample, you can see that we are using the theta angle only for
    now, with theta = 0 meaning that we point straight up and theta ![](img/Formula_02_062.png)
    meaning straight down for our basic bits and qubits: 0, 1, ![](img/Formula_02_063.png),
    and ![](img/Formula_02_064.png). Theta ![](img/Formula_02_065.png) takes us halfway,
    to the equator, and we use that for the superposition qubit, ![](img/Formula_02_066.png).'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从代码示例中，你可以看到我们现在只使用theta角度，theta = 0表示我们直接向上指，theta ![公式2.062](img/Formula_02_062.png)表示直接向下，对于我们的基本比特和量子比特：0、1、![公式2.063](img/Formula_02_063.png)和![公式2.064](img/Formula_02_064.png)。theta
    ![公式2.065](img/Formula_02_065.png)将我们带到赤道，我们使用这个角度来表示叠加量子比特![公式2.066](img/Formula_02_066.png)。
- en: Print the bits and qubits on the Bloch sphere.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印Bloch球面上的比特和量子比特。
- en: 'The Bloch sphere method takes a three-dimensional vector as input, but we have
    to build the vector first. We can use the following formula to calculate the *X*,
    *Y*, and *Z* parameters to use with `plot_bloch_vector` and display the bits and
    qubits as Bloch sphere representations:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Bloch球面方法接受一个三维向量作为输入，但我们必须首先构建这个向量。我们可以使用以下公式来计算用于`plot_bloch_vector`和显示比特和量子比特的Bloch球面表示的*X*、*Y*和*Z*参数：
- en: '[PRE5]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We now cycle through the bits dictionary to display the Bloch sphere view of
    the bits and qubits, as well as the state vectors that correspond to them:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在遍历比特字典，显示比特和量子比特的Bloch球面视图以及相应的状态向量：
- en: '![](img/Formula_02_069_(1).jpg)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_02_069_(1).jpg)'
- en: 'The state vector is calculated using the equation we saw previously:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 状态向量是使用我们之前看到的方程计算的：
- en: '![](img/Formula_02_070.jpg)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_02_070.jpg)'
- en: What we see now is that *a* and *b* can actually turn into complex values, just
    as defined.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在看到的是，*a*和*b*实际上可以变成复数值，正如定义的那样。
- en: 'Here''s the code:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE6]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The sample code should give an output similar to the following examples.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样本代码应该给出类似于以下示例的输出。
- en: 'First, we show the classical bits, 0 and 1:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们展示经典比特，0和1：
- en: '![Figure 2.3 – Bloch sphere visualization of classical bits](img/Figure_2.3_B14436.jpg)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图2.3 – 经典比特的Bloch球面可视化](img/Figure_2.3_B14436.jpg)'
- en: Figure 2.3 – Bloch sphere visualization of classical bits
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.3 – 经典比特的Bloch球面可视化
- en: Then, we show the quantum bits, or qubits, ![](img/Formula_02_030.png) and ![](img/Formula_02_029.png):![Figure
    2.4 – Bloch sphere visualization of qubits
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们展示量子比特，或称为量子比特，![公式2.30](img/Formula_02_030.png)和![公式2.29](img/Formula_02_029.png)：![图2.4
    – 量子比特的Bloch球面可视化
- en: '](img/Figure_2.4_B14436.jpg)'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_2.4_B14436.jpg)'
- en: Figure 2.4 – Bloch sphere visualization of qubits
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.4 – 量子比特的Bloch球面可视化
- en: 'Finally, we show a qubit in superposition, a mix of ![](img/Formula_02_073.png)
    and ![](img/Formula_02_074.png):'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们展示一个处于叠加状态的量子比特，它是![公式2.073](img/Formula_02_073.png)和![公式2.074](img/Formula_02_074.png)的混合：
- en: '![Figure 2.5 – Bloch sphere visualization of a qubit in superposition'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 – 超叠加态的量子比特的Bloch球面可视化'
- en: '](img/Figure_2.5_B14436.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.5_B14436.jpg)'
- en: Figure 2.5 – Bloch sphere visualization of a qubit in superposition
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 超叠加态的量子比特的Bloch球面可视化
- en: So, there is very little that is earth-shattering with the simple 0, 1, ![](img/Formula_02_075.png),
    and ![](img/Formula_02_076.png) displays. They simply point up and down to the
    north and south pole of the Bloch sphere as appropriate. If we check what the
    value of the bit or qubit is by measuring it, we will get 0 or 1 with 100% certainty.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简单的0、1、![公式2.075](img/Formula_02_075.png)和![公式2.076](img/Formula_02_076.png)显示并没有什么震撼人心的地方。它们只是根据需要指向Bloch球面的北极和南极。如果我们通过测量来检查比特或量子比特的值，我们将以100%的确定性得到0或1。
- en: The qubit in superposition, calculated as ![](img/Formula_02_077.png), on the
    other hand, points to the equator. From the equator, it is an equally long distance
    to either pole, thus a 50/50 chance of getting a 0 or a 1\.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以![](img/Formula_02_077.png)计算的超置量子比特指向赤道。从赤道开始，到两个极点的距离相等，因此得到0或1的概率是50/50。
- en: 'In the code, we include the following few lines, which define the `angles`
    variable that sets ![](img/Formula_02_078.png) and ![](img/Formula_02_079.png)
    for the ![](img/Formula_02_080.png) qubit:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们包括以下几行，这些行定义了`angles`变量，它为![](img/Formula_02_080.png)量子比特设置了![](img/Formula_02_078.png)和![](img/Formula_02_079.png)：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's more…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We mentioned earlier that we weren't going to touch on the phase (![](img/Formula_02_058.png))
    angle, at least not initially. But we can visualize what it does for our qubits.
    Remember that we can directly describe *a* and *b* using the angles ![](img/Formula_02_082.png)
    and ![](img/Formula_02_083.png).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，我们不会涉及相位(![](img/Formula_02_058.png))角，至少最初不会。但我们可以可视化它对我们量子比特的作用。记住，我们可以直接使用角度![](img/Formula_02_082.png)和![](img/Formula_02_083.png)来描述*a*和*b*。
- en: 'To test this out, you can uncomment the lines that define the angles in the
    sample code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这一点，你可以取消注释样本代码中定义角度的行：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can now define what your third qubit looks like by manipulating the ![](img/Formula_02_084.png)
    and ![](img/Formula_02_085.png) values. Let's test what we can do by running the
    script again and plugging in some angles.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过操作![](img/Formula_02_084.png)和![](img/Formula_02_085.png)值来定义你的第三个量子比特的外观。让我们通过再次运行脚本并输入一些角度来测试我们能做什么。
- en: 'For example, we can try the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以尝试以下操作：
- en: '![](img/Formula_02_086.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_086.png)'
- en: '![](img/Formula_02_087.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_087.png)'
- en: 'You should see the final Bloch sphere look something like the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到最终的布洛赫球看起来像以下这样：
- en: '![Figure 2.6 – The qubit state vector rotated by   ](img/Figure_2.6_B14436.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 通过   ](img/Figure_2.6_B14436.jpg)'
- en: Figure 2.6 – The qubit state vector rotated by ![](img/Formula_02_088.png)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 通过 ![公式2.6](img/Formula_02_088.png) 旋转的量子比特状态向量
- en: 'Note how the state vector is still on the equator with ![](img/Formula_02_089.png)
    but now at ![](img/Formula_02_090.png) angle to the *x* axis. You can also take
    a look at the state vector: [0.707+0.j 0.653+0.271j].'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意状态向量仍然位于赤道上的![](img/Formula_02_089.png)，但现在与*x*轴成![](img/Formula_02_090.png)角度。你还可以查看状态向量：[0.707+0.j
    0.653+0.271j]。
- en: 'We have now stepped away from the Bloch sphere prime meridian and out into
    the complex plane, and added a phase angle, which is represented by an imaginary
    state vector component along the *y* axis: ![](img/Formula_02_091.png)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经离开了布洛赫球上的本初子午线，进入了复平面，并添加了一个相位角，它由沿*y*轴的虚状态向量分量表示：![](img/Formula_02_091.png)
- en: Let's go on a trip
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续旅行
- en: 'Go ahead and experiment with different ![](img/Formula_02_092.png) and ![](img/Formula_02_093.png)
    angles to get other *a* and *b* entries and see where you end up. No need to include
    10+ decimals for these rough estimates, two or three decimals will do just fine.
    Try plotting your hometown on the Bloch sphere. Remember that the script wants
    the input in radians and that theta starts at the North Pole, not at the equator.
    For example, the coordinates for Greenwich Observatory in England are 51.4779°
    N, 0.0015° W, which translates into: ![](img/Formula_02_094.png), ![](img/Formula_02_095.png).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不同的![](img/Formula_02_092.png)和![](img/Formula_02_093.png)角度来获取其他*a*和*b*条目，并看看你最终会到达哪里。对于这些粗略估计，不需要包括10+位小数，两位或三位小数就足够了。尝试在你的家乡在布洛赫球上绘制。记住，脚本需要以弧度为单位输入，而theta从北极开始，而不是赤道。例如，英国格林尼治天文台的坐标是51.4779°
    N，0.0015° W，这转化为：![](img/Formula_02_094.png)，![](img/Formula_02_095.png)。
- en: 'Here''s Qiskit® and a globe displaying the same coordinates:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Qiskit®和一个地球仪显示相同的坐标：
- en: '![Figure 2.7 – Greenwich quantumly and on a globe'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 – 格林尼治量子化和在地球仪上'
- en: '](img/Figure_2.7_B14436.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.7_B14436.jpg)'
- en: Figure 2.7 – Greenwich quantumly and on a globe
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 格林尼治量子化和在地球仪上
- en: See also
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Quantum Computation and Quantum Information*, Isaac L. Chuang; Michael A.
    Nielsen, Cambridge University Press, 2010, *Chapter 1.2*, *Quantum bits*, and
    *Chapter 4.2*, *Single qubit operations*.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*量子计算与量子信息*，艾萨克·L·丘恩；迈克尔·A·尼尔森，剑桥大学出版社，2010年，*第1.2章*，*量子比特*，以及*第4.2章*，*单量子比特操作*。'
- en: A quick introduction to quantum gates
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 量子门的快速介绍
- en: Now that we have sorted out the difference between bits and qubits, and have
    also understood how to visualize the qubit as a Bloch sphere, we know all that
    there is to know about qubits, correct? Well, not quite. A qubit, or for that
    matter, hundreds or thousands of qubits, is not the only thing you need to make
    a quantum computer! You need to perform logical operations on and with the qubits.
    For this, just like a classical computer, we need logical gates.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经区分了比特和量子比特的区别，并且也已经了解了如何将量子比特可视化成布洛赫球，我们知道关于量子比特的所有知识，对吗？嗯，并不完全是这样。量子比特，或者更确切地说，成百上千个量子比特，并不是构建量子计算机的唯一东西！你需要对量子比特进行逻辑操作。为此，就像经典计算机一样，我们需要逻辑门。
- en: I will not go into any great detail on how logical gates work, but suffice to
    say that a quantum gate, operates on the input of one or more qubits and outputs
    a result.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细介绍逻辑门的工作原理，但可以说，量子门操作一个或多个量子比特的输入，并输出一个结果。
- en: In this recipe, we will work our way through the mathematical interpretation
    of few quantum gates by using matrix multiplication of single- and multi-qubit
    gates. Don't worry, we will not dig deep, just a little to scratch the surface.
    You will find a deeper look quantum gates in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit Gate Library*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过使用单比特和多比特门的矩阵乘法来逐步解释少数量子门的数学意义。别担心，我们不会深入挖掘，只是浅尝辄止。你将在[*第6章*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156)中找到更深入的量子门内容，*理解Qiskit门库*。
- en: Again, we will not be building any actual Qiskit quantum circuits just yet.
    We are still using more or less plain Python with some NumPy matrix manipulations
    to prove our points.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们目前不会构建任何实际的Qiskit量子电路。我们仍在使用或多或少纯Python和一些NumPy矩阵操作来证明我们的观点。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The Python file for the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r3_qubit_gates.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r3_qubit_gates.py).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下菜谱的Python文件可以从这里下载：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r3_qubit_gates.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r3_qubit_gates.py).
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This recipe will create vector and matrix representations of qubits and gates,
    and use simple algebra to illustrate the behavior of the qubits as gates are applied
    to them:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将创建量子比特和门的向量和矩阵表示，并使用简单的代数来说明量子比特在门作用下的行为：
- en: In your Python environment, run `ch2_r3_qubit_gates.py` and respond to the **Press
    return to continue** prompts to move along the program.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Python环境中运行`ch2_r3_qubit_gates.py`，并响应**按回车键继续**提示以继续程序。
- en: 'First, we see the vector representations of three qubit states: ![](img/Formula_02_075.png),
    ![](img/Formula_02_097.png), and ![](img/Formula_02_098.png):![Figure 2.8 – Qubits
    as vectors'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们看到了三个量子比特状态的向量表示：![Figure 2.8 – 量子比特作为向量
- en: '](img/Figure_2.8_B14436.jpg)'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 2.8 – 量子比特作为向量](img/Figure_2.8_B14436.jpg)'
- en: Figure 2.8 – Qubits as vectors
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.8 – 量子比特作为向量
- en: Next, we display the matrix representation of a couple of gates.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们显示了一些门的矩阵表示。
- en: 'We will use the `Id` (does nothing), `X` (flips the qubit), and `H` (creates
    a superposition) gates:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用`Id`（无操作）、`X`（翻转量子比特）和`H`（创建叠加）门：
- en: '![Figure 2.9 – Single-qubit gates as matrices'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 2.9 – 单量子比特门作为矩阵'
- en: '](img/Figure_2.9_B14436.jpg)'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 2.9 – 单量子比特门作为矩阵](img/Figure_2.9_B14436.jpg)'
- en: Figure 2.9 – Single-qubit gates as matrices
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.9 – 单量子比特门作为矩阵
- en: The final step for our single-qubit setup is to see how each gate manipulates
    the qubits.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们单量子比特设置的最终步骤是查看每个门如何操作量子比特。
- en: 'This is done using matrix multiplication of the qubit vector and the gate matrix:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是通过量子比特向量和门矩阵的矩阵乘法来实现的：
- en: '![Figure 2.10 – Gates acting on qubits'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 2.10 – 对量子比特起作用的门'
- en: '](img/Figure_2.10_B14436.jpg)'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 2.10 – 对量子比特起作用的门](img/Figure_2.10_B14436.jpg)'
- en: Figure 2.10 – Gates acting on qubits
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.10 – 对量子比特起作用的门
- en: 'With the single qubits done, we now move on to working with combinations of
    two qubit states: ![](img/Formula_02_099.png):![Figure 2.11 – Two qubits as vectors'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单量子比特的工作完成之后，我们现在转向处理两个量子比特状态的组合：![Figure 2.11 – 两个量子比特作为向量
- en: '](img/Figure_2.11_B14436.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 2.11 – 两个量子比特作为向量](img/Figure_2.11_B14436.jpg)'
- en: Figure 2.11 – Two qubits as vectors
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.11 – 两个量子比特作为向量
- en: Like for the single qubits, we now show the matrix representations of the two-qubit
    quantum gates.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像单个量子比特一样，我们现在展示两个量子比特量子门的矩阵表示。
- en: 'Here, we use `CX` (controlled NOT, flips one qubit if the other is 1) and `swap`
    (swaps the values of the two qubits):'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们使用 `CX`（受控非，如果另一个量子比特为 1 则翻转一个量子比特）和 `swap`（交换两个量子比特的值）：
- en: '![Figure 2.12 – Two-qubit gates as matrices'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.12 – 二量子比特门作为矩阵'
- en: '](img/Figure_2.12_B14436.jpg)'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.12_B14436.jpg)'
- en: Figure 2.12 – Two-qubit gates as matrices
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.12 – 二量子比特门作为矩阵
- en: Finally, let's see gate manipulations of our multi-qubit states.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们看看我们的多量子比特状态的门操作。
- en: 'Again, we have a matrix multiplication of the qubits vector and the gate matrix:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，我们有量子比特向量和门矩阵的矩阵乘法：
- en: '![Figure 2.13 – Multi-qubit gates acting on two qubits'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.13 – 多量子比特门作用于两个量子比特'
- en: '](img/Figure_2.13_B14436.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.13_B14436.jpg)'
- en: Figure 2.13 – Multi-qubit gates acting on two qubits
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 多量子比特门作用于两个量子比特
- en: That's it… we have now witnessed Python-generated linear algebra that describes
    how our qubits are defined and how they behave when gates are applied to them.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 那就这样……我们现在已经见证了 Python 生成的线性代数，它描述了我们的量子比特是如何定义的，以及当门应用于它们时它们是如何表现的。
- en: How it is works…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The previous section contained a lot of printed information with very little
    explanation of how we got those results. Let''s dig into the sample code to see
    how the output is generated:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节包含了很多打印信息，但对我们如何得到这些结果解释得很少。让我们深入查看示例代码，看看输出是如何生成的：
- en: Tip
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The numbered steps that follow correspond to the same numbered steps in the
    preceding *How to do it…* section. Refer back to those steps to see the result
    of the code samples that follow.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的编号步骤对应于前一节 *如何做* 部分中的相同编号步骤。请参考那些步骤，以查看以下代码示例的结果。
- en: 'Let''s start by importing the math tools we need:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先导入我们需要的数学工具：
- en: '[PRE9]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Set up the basic vectors for our qubits.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们量子比特的基本向量。
- en: 'A qubit set to the value 0 is labeled ![](img/Formula_02_100.png) in the Dirac
    ket notation and is mathematically represented by the ![](img/Formula_02_101.png)
    vector, if it is set to 1 as ![](img/Formula_02_102.png), or the ![](img/Formula_02_103.png)
    vector. So far, so good, still only 0 and 1\. As we have seen, the real magic
    comes when you have a qubit set to a superposition value represented by a vector
    pointing to the equator of the Bloch sphere, or anywhere except the poles—for
    example, ![](img/Formula_02_104.png), which would be represented by the following
    vector:'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将量子比特设置为值 0 时，在狄拉克矢量记法中标记为![公式](img/Formula_02_100.png)，如果设置为 1，则数学上表示为![公式](img/Formula_02_101.png)向量，或者设置为![公式](img/Formula_02_102.png)向量。到目前为止，一切顺利，仍然是
    0 和 1。正如我们所见，真正的魔法出现在量子比特设置为表示指向 Bloch 球赤道的叠加值时，或者在任何除了极点的地方——例如，![公式](img/Formula_02_104.png)，它将被以下向量表示：
- en: '![](img/Formula_02_105.jpg)'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![公式](img/Formula_02_105.jpg)'
- en: '[PRE10]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s how we create a dictionary of our qubits in the sample:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个量子比特字典：
- en: '[PRE11]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Set up the basic matrices for our quantum gates.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们量子门的基矩阵。
- en: 'For qubits, any single-qubit gate can be represented by a 2x2 matrix like this:
    ![](img/Formula_02_109.png).'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于量子比特，任何单个量子比特门都可以用一个 2x2 矩阵来表示，如下所示：![公式](img/Formula_02_109.png)。
- en: 'For single qubits, the math that we have implemented is a matrix operation
    that corresponds to the truth table for the two operations, *ID* and *NOT* (or
    *X*, as the quantum gate is called):'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于单个量子比特，我们实现的数学是一个矩阵运算，对应于两个操作的真值表，*ID* 和 *NOT*（或 *X*，量子门被称为）：
- en: '[PRE12]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here''s how we create a dictionary of our gates in the sample:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个门字典：
- en: '[PRE13]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, let's use NumPy to apply the defined gates on our qubits.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 NumPy 在我们的量子比特上应用定义的门。
- en: 'The application of a gate on a qubit can be expressed as a vector multiplication
    of the qubit and the gate. Here''s the NumPy matrix dot multiplication for an
    X gate on the ![](img/Formula_02_120.png) qubit:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在量子比特上应用一个门可以表示为量子比特和门的向量乘积。以下是在![量子比特](img/Formula_02_120.png)上应用 X 门的 NumPy
    矩阵点乘：
- en: '[PRE14]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In our sample, we step our way through the two dictionaries that we created,
    applying the matrix multiplication to each gate/qubit combination:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们逐步遍历我们创建的两个字典，对每个门/量子比特组合应用矩阵乘法：
- en: '[PRE15]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we see the expected behavior of the gates on our qubits: the ID gate
    does nothing, the X gate flips the qubit, and the H gate creates or uncreates
    a superposition.'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们看到门在我们量子比特上的预期行为：ID 门不做任何事情，X 门翻转量子比特，H 门创建或取消一个叠加。
- en: If you want to experiment a little, you can take a look at the vector representations
    of the various quantum gates that we show in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*, and see whether you can add these gates
    to the **gates** dictionary.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想稍微实验一下，你可以看看我们在 [*第6章*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156)
    中展示的各种量子门的向量表示，*理解Qiskit®门库*，看看你是否可以将这些门添加到 **gates** 字典中。
- en: In this first example, we took a look at how to build our single qubits and
    gates as vectors and matrices, and how to run our qubits through the gates by
    using vector multiplication. Now let's do the same with two qubits…
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，我们探讨了如何将单个量子比特和门作为向量和矩阵构建，以及如何通过向量乘法运行量子比特通过门。现在让我们用两个量子比特来做同样的事情...
- en: Set up our multi-qubit vectors.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们的多量子比特向量。
- en: 'First, we expand our Dirac-noted qubit combinations: ![](img/Formula_02_121.png),
    ![](img/Formula_02_122.png), ![](img/Formula_02_123.png), and ![](img/Formula_02_124.png).'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们扩展我们的狄拉克标记的量子比特组合：![](img/Formula_02_121.png)，![](img/Formula_02_122.png)，![](img/Formula_02_123.png)，和
    ![](img/Formula_02_124.png)。
- en: 'These represent, respectively, both qubits 0, first qubit 1 and second 0, first
    qubit 0 and second 1, and both qubits 1\. Here, we are using the **backward Qiskit®
    notation** for our qubits, starting with the first qubit (![](img/Formula_02_125.png))
    as the **Least Significant Bit** (**LSB**) in the vector notation, like this:
    ![](img/Formula_02_126.png).'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些分别代表量子比特 0，第一个量子比特 1 和第二个 0，第一个量子比特 0 和第二个 1，以及两个量子比特 1。在这里，我们使用 **向后 Qiskit®
    符号**表示我们的量子比特，从第一个量子比特（![](img/Formula_02_125.png)）作为向量子符号中的 **最低有效位**（**LSB**）开始，如下所示：![](img/Formula_02_126.png)。
- en: 'The vector representation of these are, respectively, as follows:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些向量的表示分别是如下：
- en: '![](img/Formula_02_127.jpg)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_02_127.jpg)'
- en: 'We already know how to build our qubits as 2x1 NumPy arrays, so let''s extend
    that to 4x1 vectors. With NumPy, this is how we create, for example, the ![](img/Formula_02_128.png)
    qubit vector:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经知道如何将量子比特作为 2x1 NumPy 数组构建，所以让我们将其扩展到 4x1 向量。使用 NumPy，例如，这样创建 ![](img/Formula_02_128.png)
    量子比特向量：
- en: '[PRE16]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the sample code, we set up a dictionary with the multi-qubit arrays:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在示例代码中，我们使用多量子比特数组设置了一个字典：
- en: '[PRE17]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Set up our multi-qubit gate matrices.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们的多量子比特门矩阵。
- en: 'The two-qubit quantum gates are represented by 4x4 matrices, such as the **controlled-NOT**
    (**CX**) gate, which flips the first qubit (![](img/Formula_02_129.png)) if the
    controlling second qubit (![](img/Formula_02_130.png)) is set to 1:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 双量子比特量子门由 4x4 矩阵表示，例如 **受控非**（**CX**）门，如果控制第二个量子比特（![](img/Formula_02_129.png)）设置为
    1，则翻转第一个量子比特（![](img/Formula_02_130.png)）：
- en: '![](img/Formula_02_131.jpg)'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_02_131.jpg)'
- en: 'Gate matrices like these, where one qubit acts as the control and the other
    as controlled, differ somewhat depending on which qubit you select as the control.
    If the CX gate points the other way, with the first qubit (![](img/Formula_02_132.png))
    as the controlling qubit, the matrix will look like this instead:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种类型的门矩阵，其中一个量子比特作为控制，另一个作为受控，根据你选择的控制量子比特不同而有所不同。如果 CX 门的方向相反，第一个量子比特（![](img/Formula_02_132.png)）作为控制量子比特，矩阵将看起来像这样：
- en: '![](img/Formula_02_133.jpg)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_02_133.jpg)'
- en: 'Here''s how we build the gates:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是构建门的方法：
- en: '[PRE18]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here''s a NumPy matrix dot multiplication example for a CX gate on the ![](img/Formula_02_134.png)
    qubit:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是一个针对 ![](img/Formula_02_134.png) 量子比特的 CX 矩阵点乘示例：
- en: '[PRE19]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here''s the sample code:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是示例代码：
- en: '[PRE20]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we''ll apply the gates to our bits and see the results:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将门应用到我们的比特上，查看结果：
- en: '[PRE21]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The main takeaway with the multi-qubit matrix manipulations is that the output
    is a vector of the same dimensions as the input vector; no information is lost.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多量子比特矩阵操作的主要收获是输出向量与输入向量具有相同的维度；没有信息丢失。
- en: There's more…
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One other aspect of quantum gates that is generally not true of classical gates
    is that they are reversible. If you run the gate backward, you end up with the
    input states of your qubits, and no information is lost. The final recipe in this
    chapter illustrates this.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 量子门的一个其他方面，通常不适用于经典门，是它们是可逆的。如果你反向运行门，你将得到量子比特的输入状态，并且没有信息丢失。本章的最后食谱说明了这一点。
- en: The sample code
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'The sample file for the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r4_reversible_gates.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r4_reversible_gates.py):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '以下示例的样本文件可以从这里下载：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r4_reversible_gates.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r4_reversible_gates.py):'
- en: 'Let''s start by importing all we need:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先导入所有需要的：
- en: '[PRE22]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Set up the basic qubit vectors and gate matrices. When printing out the gates,
    we compare the gate matrix with its complex conjugate. If these are the same,
    the gate and its inverse are identical:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置基本的量子比特向量和门矩阵。当打印出门时，我们比较门矩阵与其复共轭。如果它们相同，则门及其逆是相同的：
- en: '[PRE23]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Demonstrate that the basic quantum gates are reversible by applying the gate
    then its complex conjugate, and then comparing the outcome with the input. For
    the quantum gates, which are reversible, this will bring the qubit back to the
    starting state:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过应用门然后是其复共轭，并比较结果与输入，来证明基本量子门是可逆的。对于可逆的量子门，这将使量子比特回到起始状态：
- en: '[PRE24]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Running the sample
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'When you run this `ch2_r4_reversible_gates.py` script, it will do the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个`ch2_r4_reversible_gates.py`脚本时，它将执行以下操作：
- en: Like before, create and print out vector and matrix representations of our qubits
    and quantum gates.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，创建并打印出我们的量子比特和量子门的向量和矩阵表示。
- en: 'This time, we add three new gates:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，我们添加了三个新的门：
- en: '![](img/Formula_02_135.jpg)![](img/Formula_02_136.jpg)![](img/Formula_02_137.jpg)'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/Formula_02_135.jpg](img/Formula_02_135.jpg)![img/Formula_02_136.jpg](img/Formula_02_136.jpg)![img/Formula_02_137.jpg](img/Formula_02_137.jpg)'
- en: 'Here, *Y* and *Z* perform ![](img/Formula_02_138.png) rotation around the corresponding
    axes, in essence acting as NOT gates along the *y* and *z* axes on the Bloch sphere.
    The S gate adds a new functionality to the gates, ![](img/Formula_02_139.png)
    rotation around the *z* axis. We will return to these gates in more detail in
    [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156), *Understanding
    the Qiskit® Gate Library*:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，*Y*和*Z*在相应的轴上执行![img/Formula_02_138.png](img/Formula_02_138.png)旋转，本质上在布洛赫球上的*y*和*z*轴上充当NOT门。S门为门添加了新的功能，即绕*z*轴的![img/Formula_02_139.png](img/Formula_02_139.png)旋转。我们将在[*第6章*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156)中更详细地介绍这些门，*理解Qiskit®门库*：
- en: '![Figure 2.14 – Quantum gates and their inverses'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 2.14 – 量子门及其逆'
- en: '](img/Figure_2.14_B14436.jpg)'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_2.14_B14436.jpg](img/Figure_2.14_B14436.jpg)'
- en: Figure 2.14 – Quantum gates and their inverses
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 2.14 – 量子门及其逆
- en: The complex conjugate of a complex number is obtained by changing the sign of
    its imaginary part, so for gates with only real numbers in their matrices, the
    complex conjugate does nothing, and the gate is its own reverse.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 复数的复共轭是通过改变其虚部的符号得到的，因此对于矩阵中只有实数的门，复共轭不起作用，门就是其自身的逆。
- en: Then, for each of our qubits, we apply each gate and then its reverse gate and
    show that we end up with the same qubit state as we started with.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，对于我们的每个量子比特，我们应用每个门然后是其逆门，并展示我们最终得到的量子比特状态与开始时相同。
- en: 'The examples that follow are for the X and S gates:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的例子是关于X和S门的：
- en: '![Figure 2.15 – The effects of the X gate and reversed X gate on three qubit
    states'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.15 – X门和反转X门对三个量子比特状态的影响'
- en: '](img/Figure_2.15_B14436.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.15_B14436.jpg](img/Figure_2.15_B14436.jpg)'
- en: Figure 2.15 – The effects of the X gate and reversed X gate on three qubit states
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.15 – X门和反转X门对三个量子比特状态的影响
- en: 'The reversed X gate is simply itself, and applying it twice to a qubit brings
    back the original qubit state:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 反转的X门就是它本身，将其应用于一个量子比特两次会恢复原始的量子比特状态：
- en: '![Figure 2.16 – The effects of the S and reversed S gate () on three qubit
    states'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.16 – S门和反转S门()对三个量子比特状态的影响'
- en: '](img/Figure_2.16_B14436.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.16_B14436.jpg](img/Figure_2.16_B14436.jpg)'
- en: Figure 2.16 – The effects of the S and reversed S gate (![](img/Formula_02_140.png))
    on three qubit states
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.16 – S门和反转S门(![img/Formula_02_140.png](img/Formula_02_140.png))对三个量子比特状态的影响
- en: The reverse of the S gate is called the ![](img/Formula_02_141.png) gate, where
    ![](img/Formula_02_142.png) is the complex conjugation of S. Applying S followed
    by ![](img/Formula_02_143.png) brings back the original qubit state.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: S门的逆称为![img/Formula_02_141.png](img/Formula_02_141.png)门，其中![img/Formula_02_142.png](img/Formula_02_142.png)是S的复共轭。应用S然后是![img/Formula_02_143.png](img/Formula_02_143.png)会恢复原始的量子比特状态。
- en: See also
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Quantum Computation and Quantum Information*, Isaac L. Chuang; Michael A.
    Nielsen, Cambridge University Press, 2010, *Chapter 4.2*, *Single qubit operations*,
    and *Chapter 4.3*, *Controlled operations*.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《量子计算与量子信息》*，艾萨克·L. 库恩；迈克尔·A. 尼尔森，剑桥大学出版社，2010年，*第 4.2 章*，*单量子比特操作*，以及 *第
    4.3 章*，*控制操作*。'
- en: '*The Feynman Lectures on Physics*, Feynman, Richard P.; Leighton, Robert B.;
    Sands, Matthew, 1965, Addison-Wesley. Take a look at the online version, and the
    chapter on amplitudes and vectors, for more about Dirac notation: [https://www.feynmanlectures.caltech.edu/III_08.html#Ch8-S1](https://www.feynmanlectures.caltech.edu/III_08.html#Ch8-S1).'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《费曼物理学讲义》*，费曼，理查德·P.；莱顿，罗伯特·B.；桑德斯，马修，1965年，Addison-Wesley。查看在线版本，以及关于幅度和向量的章节，了解更多关于狄拉克符号的信息：[https://www.feynmanlectures.caltech.edu/III_08.html#Ch8-S1](https://www.feynmanlectures.caltech.edu/III_08.html#Ch8-S1).'
- en: 'For a quick interactive look at a single qubit Bloch sphere representation,
    take a look at the **grok bloch** application by Qiskit Advocate James Weaver:
    [https://github.com/JavaFXpert/grok-bloch](https://github.com/JavaFXpert/grok-bloch).'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要快速查看单个量子比特的 Bloch 球表示，请查看 Qiskit Advocate James Weaver 的 **grok bloch** 应用程序：[https://github.com/JavaFXpert/grok-bloch](https://github.com/JavaFXpert/grok-bloch).
- en: 'You can install and run it from your own Python environment, or run it online
    here: [https://javafxpert.github.io/grok-bloch/](https://javafxpert.github.io/grok-bloch/).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从自己的 Python 环境中安装并运行它，或者在此处在线运行：[https://javafxpert.github.io/grok-bloch/](https://javafxpert.github.io/grok-bloch/).
- en: The application supports the simple X and H gates that we have tested so far,
    as well as additional gates that we will be touching on in the following chapters,
    such as Y, Z, Rx, Ry, Rz, and more. For a deeper dive into the quantum gates that
    are available with Qiskit®, refer to [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序支持我们迄今为止测试过的简单 X 和 H 门，以及以下章节中将要涉及的其他门，如 Y、Z、Rx、Ry、Rz 等。要深入了解 Qiskit® 提供的量子门，请参阅[*第
    6 章*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156)，*理解 Qiskit® 门库*。
