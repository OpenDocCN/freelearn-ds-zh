- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Phylogenetics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统发育学
- en: Phylogenetics is the application of molecular sequencing that is used to study
    the evolutionary relationship among organisms. The typical way to illustrate this
    process is through the use of phylogenetic trees. The computation of these trees
    from genomic data is an active field of research with many real-world applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 系统发育学是应用分子测序技术来研究生物之间的进化关系。通常用系统发育树来表示这一过程。从基因组数据中计算这些树是一个活跃的研究领域，并具有许多现实世界中的应用。
- en: 'In this book, we will take the practical approach that is mentioned to a new
    level: most of the recipes here are inspired by a recent study on the Ebola virus,
    researching the recent Ebola outbreak in Africa. This study is called *Genomic
    surveillance elucidates Ebola virus origin and transmission during the 2014 outbreak*,
    by *Gire et al.*, published in *Science*. It is available at [https://pubmed.ncbi.nlm.nih.gov/25214632/](https://pubmed.ncbi.nlm.nih.gov/25214632/).
    Here, we will try to follow a similar methodology to arrive at similar results
    to the paper.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将把之前提到的实际操作方法推向一个新高度：这里的大部分内容都受到了关于埃博拉病毒的最新研究的启发，研究了最近在非洲爆发的埃博拉疫情。该研究名为*Genomic
    surveillance elucidates Ebola virus origin and transmission during the 2014 outbreak*，由*Gire
    et al.*完成，发表于*Science*期刊。你可以在[https://pubmed.ncbi.nlm.nih.gov/25214632/](https://pubmed.ncbi.nlm.nih.gov/25214632/)阅读到这篇文章。在这里，我们将尝试采用类似的方法，以便得出与该论文相似的结果。
- en: In this chapter, we will use DendroPy (a phylogenetics library) and Biopython.
    The `bioinformatics_phylo` Docker image includes all the necessary software.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将使用 DendroPy（一个系统发育学库）和 Biopython。`bioinformatics_phylo` Docker 镜像包含了所有必需的软件。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: Preparing a dataset for phylogenetic analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为系统发育分析准备数据集
- en: Aligning genetic and genomic data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对齐遗传和基因组数据
- en: Comparing sequences
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较序列
- en: Reconstructing phylogenetic trees
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重建系统发育树
- en: Playing recursively with trees
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归地玩转树状图
- en: Visualizing phylogenetic data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化系统发育数据
- en: Preparing a dataset for phylogenetic analysis
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为系统发育分析准备数据集
- en: In this recipe, we will download and prepare the dataset to be used for our
    analysis. The dataset contains complete genomes of the Ebola virus. We will use
    DendroPy to download and prepare the data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将下载并准备用于分析的数据集。该数据集包含了埃博拉病毒的完整基因组。我们将使用 DendroPy 来下载和准备数据。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will download complete genomes from GenBank; these genomes were collected
    from various Ebola outbreaks, including several from the 2014 outbreak. Note that
    there are several virus species that cause the Ebola virus disease; the species
    involved in the 2014 outbreak (the EBOV virus, which was formally known as the
    Zaire Ebola virus) is the most common, but this disease is caused by more species
    of the genus Ebolavirus; four others are also available in a sequenced form. You
    can read more at [https://en.wikipedia.org/wiki/Ebolavirus](https://en.wikipedia.org/wiki/Ebolavirus).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 GenBank 下载完整的基因组，这些基因组来自多个埃博拉疫情爆发，其中包括2014年疫情中的多个样本。请注意，导致埃博拉病毒病的病毒种类有很多；2014年疫情中的主要病毒是
    EBOV（即正式命名为扎伊尔埃博拉病毒），这是最常见的一种，但此病还由更多的埃博拉病毒属物种引起；另外四种物种的基因组序列也已被测序。你可以在[https://en.wikipedia.org/wiki/Ebolavirus](https://en.wikipedia.org/wiki/Ebolavirus)阅读更多信息。
- en: If you have already gone through the previous chapters, you might panic looking
    at the potential data sizes involved here; this is not a problem at all because
    these are genomes of viruses that are each around 19 kbp in size. So, our approximately
    100 genomes are actually quite light.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了前几章的内容，看到这里可能会对涉及的数据量感到担忧；但这完全不成问题，因为这些是大约 19 kbp 大小的病毒基因组。因此，我们的约 100
    个基因组实际上相当小巧。
- en: 'To do this analysis, we will need to install `dendropy`. If you are using Anaconda,
    please perform the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行这个分析，我们需要安装 `dendropy`。如果你使用的是 Anaconda，请执行以下操作：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As usual, this information is available in the corresponding Jupyter Notebook
    file, which is available at `Chapter07/Exploration.py`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，这些信息可以在相应的 Jupyter Notebook 文件中找到，文件位于`Chapter07/Exploration.py`。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Take a look at the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下步骤：
- en: 'First, let’s start by specifying our data sources using DendroPy, as follows:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用 DendroPy 指定我们的数据源，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we have three functions: one to retrieve data from the most recent EBOV
    outbreak, another to retrieve data from the previous EBOV outbreaks, and one to
    retrieve data from the outbreaks of other species.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有三个函数：一个用于检索最新EBOV爆发的数据，另一个用于检索以前EBOV爆发的数据，第三个用于检索其他物种爆发的数据。
- en: Note that the DendroPy GenBank interface provides several different ways to
    specify lists or ranges of records to retrieve. Some lines are commented out.
    These include the code to download more genomes. For our purpose, the subset that
    we will download is enough.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，DendroPy的GenBank接口提供了几种不同的方式来指定要检索的记录列表或范围。一些行已被注释掉，包括下载更多基因组的代码。对于我们的目的，我们将下载的子集已足够。
- en: 'Now, we will create a set of FASTA files; we will use these files here and
    in future recipes:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一组FASTA文件；我们将在这里以及未来的食谱中使用这些文件：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will generate several different FASTA files, which include either all genomes,
    just EBOV, or just EBOV samples from the 2014 outbreak. In this chapter, we will
    mostly use the `sample.fasta` file with all genomes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成几个不同的FASTA文件，包含所有基因组、仅EBOV基因组或仅包含2014年爆发的EBOV样本的文件。在本章中，我们将主要使用包含所有基因组的`sample.fasta`文件。
- en: Note the use of the `dendropy` functions to create FASTA files that are retrieved
    from GenBank records through conversion. The ID of each sequence in the FASTA
    file is produced by a lambda function that uses the species and the year, alongside
    the GenBank accession number.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用`dendropy`函数创建FASTA文件，这些文件是通过转换从GenBank记录中提取的。FASTA文件中每个序列的ID是通过一个lambda函数生成的，该函数使用物种和年份，以及GenBank的登录号。
- en: 'Let’s extract four (of the total seven) genes in the virus, as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们提取病毒中的四个基因（总共七个），如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We start by searching the first GenBank record for all gene features (please
    refer to [*Chapter 3*](B17942_03.xhtml#_idTextAnchor068), *Next Generation Sequencing*,
    or the **National Center for Biotechnology Information** (**NCBI**) documentation
    for further details; although we will use DendroPy and not Biopython here, the
    concepts are similar) and write to the FASTA files in order to extract the genes.
    We put each gene into a different file and only take two virus species. We also
    get translated proteins, which are available in the records for each gene.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先搜索第一个GenBank记录中的所有基因特征（请参阅[*第3章*](B17942_03.xhtml#_idTextAnchor068)，*下一代测序*，或**国家生物技术信息中心**（**NCBI**）文档获取更多细节；虽然我们将在这里使用DendroPy而不是Biopython，但概念是相似的），并将数据写入FASTA文件，以提取基因。我们将每个基因放入不同的文件中，只取两个病毒物种。我们还获取了转译的蛋白质，这些蛋白质在每个基因的记录中都有提供。
- en: 'Let’s create a function to get the basic statistical information from the alignment,
    as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，从比对中获取基本统计信息，如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our function takes a `DnaCharacterMatrix` DendroPy class and counts the number
    of taxons. Then, we extract all the amino acids per sequence (we exclude gaps
    identified by `-`) to compute the length and report the minimum, mean, and maximum
    sizes. Take a look at the DendroPy documentation for additional details regarding
    the API.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数采用`DnaCharacterMatrix` DendroPy类，并统计分类单元的数量。然后，我们提取每个序列中的所有氨基酸（排除由`-`表示的缺失）来计算长度，并报告最小、平均和最大大小。有关API的更多细节，请查看DendroPy文档。
- en: 'Let’s inspect the sequence of the EBOV genome and compute the basic statistics,
    as shown earlier:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查一下EBOV基因组的序列并计算基本统计数据，如前所示：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We then call a function and get 25 sequences with a minimum size of 18,700,
    a mean size of 18,925.2, and a maximum size of 18,959\. This is a small genome
    when compared to eukaryotes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用一个函数，得到25个序列，最小大小为18,700，平均大小为18,925.2，最大大小为18,959。与真核生物相比，这是一个较小的基因组。
- en: Note that at the very end, the memory structure has been deleted. This is because
    the memory footprint is still quite big (DendroPy is a pure Python library and
    has some costs in terms of speed and memory). Be careful with your memory usage
    when you load full genomes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在最后，内存结构已被删除。这是因为内存占用仍然相当大（DendroPy是一个纯Python库，在速度和内存方面有一些开销）。在加载完整基因组时，要小心内存使用。
- en: 'Now, let’s inspect the other Ebola virus genome file and count the number of
    different species:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们检查另一个埃博拉病毒基因组文件，并统计不同物种的数量：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The name prefix of each taxon is indicative of the species, and we leverage
    that to fill a dictionary of counts.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分类单元的名称前缀表明了物种，我们利用这一点来填充一个计数字典。
- en: The output for the species and the EBOV breakdown is detailed next (with the
    legend as Bundibugyo virus=BDBV, Tai Forest virus=TAFV, Sudan virus=SUDV, and
    Reston virus=RESTV; we have 1 TAFV, 6 SUDV, 6 RESTV, and 5 BDBV).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来详细介绍物种和EBOV的分类（图例中Bundibugyo病毒=BDBV，Tai Forest病毒=TAFV，Sudan病毒=SUDV，Reston病毒=RESTV；我们有1个TAFV，6个SUDV，6个RESTV和5个BDBV）。
- en: 'Let’s extract the basic statistics of a gene in the virus:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们提取病毒中基因的基本统计信息：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This allows you to have an overview of the basic gene information (that is,
    the name and the mean size), as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你概览基本的基因信息（即名称和平均大小），如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There’s more...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Most of the work here can probably be performed with Biopython, but DendroPy
    has additional functionalities that will be explored in later recipes. Furthermore,
    as you will discover, it’s more robust with certain tasks (such as file parsing).
    More importantly, there is another Python library to perform phylogenetics that
    you should consider. It’s called ETE and is available at [http://etetoolkit.org/](http://etetoolkit.org/).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的大部分工作可能可以通过Biopython完成，但DendroPy具有更多额外的功能，将在后续的步骤中进行探索。此外，正如你将发现的，它在某些任务（如文件解析）上更为强大。更重要的是，还有另一个Python库用于执行系统发育学分析，你应该考虑一下。它叫做ETE，可以在[http://etetoolkit.org/](http://etetoolkit.org/)找到。
- en: See also
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The US **Center for Disease Control** (**CDC**) has a good introductory page
    on the Ebola virus disease at [https://www.cdc.gov/vhf/ebola/history/summaries.xhtml](https://www.cdc.gov/vhf/ebola/history/summaries.xhtml).
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美国**疾病控制中心**（**CDC**）在[https://www.cdc.gov/vhf/ebola/history/summaries.xhtml](https://www.cdc.gov/vhf/ebola/history/summaries.xhtml)上有一个关于埃博拉病毒病的很好的简介页面。
- en: The reference application in phylogenetics is Joe Felsenstein’s *Phylip*, which
    can be found at [http://evolution.genetics.washington.edu/phylip.xhtml](http://evolution.genetics.washington.edu/phylip.xhtml).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统发育学中的参考应用是Joe Felsenstein的*Phylip*，可以在[http://evolution.genetics.washington.edu/phylip.xhtml](http://evolution.genetics.washington.edu/phylip.xhtml)找到。
- en: We will use the Nexus and Newick formats in future recipes ([http://evolution.genetics.washington.edu/phylip/newicktree.xhtml](http://evolution.genetics.washington.edu/phylip/newicktree.xhtml)),
    but do also check out the PhyloXML format ([http://en.wikipedia.org/wiki/PhyloXML](http://en.wikipedia.org/wiki/PhyloXML)).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在未来的步骤中使用Nexus和Newick格式（[http://evolution.genetics.washington.edu/phylip/newicktree.xhtml](http://evolution.genetics.washington.edu/phylip/newicktree.xhtml)），但也可以查看PhyloXML格式（[http://en.wikipedia.org/wiki/PhyloXML](http://en.wikipedia.org/wiki/PhyloXML)）。
- en: Aligning genetic and genomic data
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对齐基因和基因组数据
- en: Before we can perform any phylogenetic analysis, we need to align our genetic
    and genomic data. Here, we will use MAFFT ([http://mafft.cbrc.jp/alignment/software/](http://mafft.cbrc.jp/alignment/software/))
    to perform the genome analysis. The gene analysis will be performed using MUSCLE
    ([http://www.drive5.com/muscle/](http://www.drive5.com/muscle/)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何系统发育分析之前，我们需要对基因和基因组数据进行对齐。在这里，我们将使用MAFFT（[http://mafft.cbrc.jp/alignment/software/](http://mafft.cbrc.jp/alignment/software/)）进行基因组分析。基因分析将使用MUSCLE（[http://www.drive5.com/muscle/](http://www.drive5.com/muscle/)）进行。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To perform the genomic alignment, you will need to install MAFFT. Additionally,
    to perform the genic alignment, MUSCLE will be used. Also, we will use trimAl
    ([http://trimal.cgenomics.org/](http://trimal.cgenomics.org/)) to remove spurious
    sequences and poorly aligned regions in an automated manner. All packages are
    available from Bioconda:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行基因组对齐，你需要安装MAFFT。此外，为了进行基因对齐，将使用MUSCLE。我们还将使用trimAl（[http://trimal.cgenomics.org/](http://trimal.cgenomics.org/)）以自动化方式去除虚假序列和对齐不良的区域。所有包都可以从Bioconda获取：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As usual, this information is available in the corresponding Jupyter Notebook
    file at `Chapter07/Alignment.py`. You will need to run the previous notebook beforehand,
    as it will generate the files that are required here. In this chapter, we will
    use Biopython.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，这些信息可以在相应的Jupyter Notebook文件`Chapter07/Alignment.py`中找到。你需要先运行之前的Notebook，因为它会生成这里所需的文件。在本章中，我们将使用Biopython。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Take a look at the following steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下步骤：
- en: 'Now, we will run MAFFT to align the genomes, as shown in the following code.
    This task is CPU-intensive and memory-intensive, and it will take quite some time:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将运行MAFFT来对齐基因组，如下面的代码所示。这个任务是CPU密集型和内存密集型的，且将花费相当长的时间：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding parameters are the same as the ones specified in the supplementary
    material of the paper. We will use the Biopython interface to call MAFFT.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的参数与论文附录中指定的参数相同。我们将使用Biopython接口调用MAFFT。
- en: 'Let’s use trimAl to trim sequences, as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用trimAl来修剪序列，如下所示：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we just call the application using `os.system`. The `-automated1` parameter
    is from the supplementary material.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是通过`os.system`调用应用程序。`-automated1`参数来自补充材料。
- en: 'Additionally, we can run `MUSCLE` to align the proteins:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们可以运行`MUSCLE`来对蛋白质进行比对：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We use Biopython to call an external application. Here, we will align a set
    of proteins.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Biopython来调用外部应用程序。在这里，我们将对一组蛋白质进行比对。
- en: Note that to make some analysis of molecular evolution, we have to compare aligned
    genes, not proteins (for example, comparing synonymous and nonsynonymous mutations).
    However, we just have aligned the proteins. Therefore, we have to convert the
    alignment into the gene sequence form.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了进行分子进化分析，我们必须比较对齐后的基因，而不是蛋白质（例如，比较同义突变和非同义突变）。然而，我们只对齐了蛋白质。因此，我们必须将对齐数据转换为基因序列形式。
- en: 'Let’s align the genes by finding three nucleotides that correspond to each
    amino acid:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过找到三个对应于每个氨基酸的核苷酸来对基因进行比对：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code gets the protein and the gene coding. If a gap is found in a protein,
    three gaps are written; if an amino acid is found, the corresponding nucleotides
    of the gene are written.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码获取蛋白质和基因编码。如果在蛋白质中发现空缺，则写入三个空缺；如果发现氨基酸，则写入相应的基因核苷酸。
- en: Comparing sequences
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较序列
- en: Here, we will compare the sequences we aligned in the previous recipe. We will
    perform gene-wide and genome-wide comparisons.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将比较在上一配方中比对的序列。我们将进行基因范围和基因组范围的比较。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: We will use DendroPy and will require the results from the previous two recipes.
    As usual, this information is available in the corresponding notebook at `Chapter07/Comparison.py`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用DendroPy，并且需要前两个配方的结果。像往常一样，这些信息可以在对应的笔记本`Chapter07/Comparison.py`中找到。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Take a look at the following steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下接下来的步骤：
- en: 'Let’s start analyzing the gene data. For simplicity, we will only use data
    from two other species of the genus Ebola virus that are available in the extended
    dataset, that is, the Reston virus (`RESTV`) and the Sudan virus (`SUDV`):'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始分析基因数据。为简便起见，我们将仅使用来自伊波拉病毒属的另外两种物种的数据，这些数据已包含在扩展数据集中，即雷斯顿病毒（`RESTV`）和苏丹病毒（`SUDV`）：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We get four genes that we stored in the first recipe and aligned in the second.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到在第一步中存储的四个基因，并在第二步中对其进行了比对。
- en: We load all the files (which are FASTA formatted) and create a dictionary with
    all of the genes. Each entry will be a dictionary itself with the RESTV or SUDV
    species, including all reads. This is not a lot of data, just a handful of genes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们加载所有文件（格式为FASTA），并创建一个包含所有基因的字典。每个条目本身也是一个字典，包含RESTV或SUDV物种，及所有读取的数据。这些数据量不大，只有少量基因。
- en: 'Let’s print some basic information for all four genes, such as the number of
    segregating sites (`seg_sites`), nucleotide diversity (`nuc_div`), Tajima’s D
    (`taj_d`), and Waterson’s theta (`wat_theta`) (check out the *There’s more...*
    section of this recipe for links on these statistics):'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打印所有四个基因的一些基本信息，如分离位点数（`seg_sites`）、核苷酸多样性（`nuc_div`）、Tajima’s D（`taj_d`）和Waterson’s
    theta（`wat_theta`）（请查看本配方中*更多...*部分的链接，了解这些统计数据的相关信息）：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, let’s look at the output, and then we’ll explain how to build it:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们来看一下输出，然后再解释如何构建它：
- en: '![Figure 7.1 – A DataFrame for the virus dataset ](img/B17942_07_001.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 病毒数据集的数据框](img/B17942_07_001.jpg)'
- en: Figure 7.1 – A DataFrame for the virus dataset
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 病毒数据集的数据框
- en: I used a `pandas` DataFrame to print the results because it’s really tailored
    to deal with an operation like this. We will initialize our DataFrame with a NumPy
    multidimensional array with four rows (genes) and four statistics times the two
    species.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`pandas`数据框打印结果，因为它非常适合处理这样的操作。我们将用一个NumPy多维数组初始化数据框，数组包含四行（基因）和四个统计数据乘以两个物种。
- en: The statistics, such as the number of segregating sites, nucleotide diversity,
    Tajima’s D, and Watterson’s theta, are computed by DendroPy. Note the placement
    of individual data points in the array (the coordinate computation).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些统计数据，如分离位点数、核苷酸多样性、Tajima’s D和Watterson’s theta，都是通过DendroPy计算的。请注意单个数据点在数组中的位置（坐标计算）。
- en: 'Look at the very last line: if you are in Jupyter, just putting `df` at the
    end will render the DataFrame and the cell output, too. If you are not in a notebook,
    use `print(df)` (you can also perform this in a notebook, but it will not look
    as pretty).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 看看最后一行：如果你在 Jupyter 中，只需要将 `df` 放在末尾，它会渲染出 DataFrame 和单元格输出。如果你不在笔记本中，使用 `print(df)`（你也可以在笔记本中执行这个操作，但显示效果可能不如直接在
    Jupyter 中漂亮）。
- en: 'Now, let’s extract similar information, but genome-wide instead of only gene-wide.
    In this case, we will use a subsample of two EBOV outbreaks (from 2007 and 2014).
    We will perform a function to display basic statistics, as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们提取类似的信息，但这次是基因组范围的数据，而不仅仅是基因范围。在这种情况下，我们将使用两个埃博拉爆发（2007年和2014年）的子样本。我们将执行一个函数来显示基本统计信息，如下所示：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By now, this function should be easy to understand, given the preceding examples.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，鉴于之前的例子，这个函数应该很容易理解。
- en: 'Now, let’s extract a subsample of the data properly, and output the statistical
    information:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们正确地提取数据的子样本，并输出统计信息：
- en: '[PRE17]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we will construct two versions of two datasets: the 2014 outbreak and
    the 2007 outbreak. We will generate one version as `DnaCharacterMatrix` and another
    as a list. We will use this list version at the end of this recipe.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将构建两个数据集的两个版本：2014年爆发和2007年爆发。我们将生成一个版本作为 `DnaCharacterMatrix`，另一个作为列表。我们将在这个食谱的最后使用这个列表版本。
- en: As the dataset for the EBOV outbreak of 2014 is large, we subsample it with
    just eight individuals, which is a comparable sample size to the dataset of the
    2007 outbreak.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于2014年埃博拉爆发的数据集很大，我们仅用8个个体进行子样本抽取，这与2007年爆发的数据集的样本大小相当。
- en: Again, we delete the `ebov_seqs` data structure to conserve memory (these are
    genomes, not only genes).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们删除 `ebov_seqs` 数据结构以节省内存（这些是基因组，而不仅仅是基因）。
- en: If you perform this analysis on the complete dataset for the 2014 outbreak available
    on GenBank (99 samples), be prepared to wait for quite some time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 GenBank 上可用的2014年爆发的完整数据集（99个样本）执行此分析，请准备好等待相当长的时间。
- en: 'The output is shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we perform some statistical analysis on the two subsets of 2007 and
    2014, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们对2007年和2014年的两个子集进行一些统计分析，如下所示：
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that we will perform something slightly different here; we will ask DendroPy
    (`popgenstat.PopulationPairSummaryStatistics`) to directly compare two populations
    so that we get the following results:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们这里执行的操作稍有不同；我们将要求 DendroPy（`popgenstat.PopulationPairSummaryStatistics`）直接比较两个种群，以便获得以下结果：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now the number of segregating sites is much bigger because we are dealing with
    data from two different populations that are reasonably diverged. The average
    number of pairwise differences among populations is quite large. As expected,
    this is much larger than the average number for the population, irrespective of
    the population information.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，分化位点的数量要大得多，因为我们正在处理来自两个合理分化的不同种群的数据。种群间的平均成对差异数值非常大。如预期的那样，这个数值远大于种群内部的平均数值，无论是否有种群信息。
- en: There’s more...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: If you want to get many phylogenetic and population genetics formulas, including
    the ones used here, I strongly recommend that you get the manual for the Arlequin
    software suite ([http://cmpg.unibe.ch/software/arlequin35/](http://cmpg.unibe.ch/software/arlequin35/)).
    If you do not use Arlequin to perform data analysis, its manual is probably the
    best reference to implement formulas. This free document probably has more relevant
    details on formula implementation than any book that I can remember.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取更多的系统发育学和群体遗传学公式，包括这里使用的那些，我强烈推荐你获取 Arlequin 软件套件的手册（[http://cmpg.unibe.ch/software/arlequin35/](http://cmpg.unibe.ch/software/arlequin35/)）。如果你不使用
    Arlequin 进行数据分析，那么它的手册可能是实现公式的最佳参考。这本免费的文档可能包含比任何我能记得的书籍更相关的公式实现细节。
- en: Reconstructing phylogenetic trees
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重建系统发育树
- en: Here, we will construct phylogenetic trees for the aligned dataset for all Ebola
    species. We will follow a procedure that’s quite similar to the one used in the
    paper.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将为所有埃博拉物种的对齐数据集构建系统发育树。我们将遵循与论文中使用的过程非常相似的步骤。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe requires RAxML, a program for maximum likelihood-based inference
    of large phylogenetic trees, which you can check out at [http://sco.h-its.org/exelixis/software.xhtml](http://sco.h-its.org/exelixis/software.xhtml).
    Bioconda also includes it, but it is named `raxml`. Note that the binary is called
    `raxmlHPC`. You can perform the following command to install it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱需要 RAxML，这是一个用于最大似然推断大型系统发育树的程序，你可以在 [http://sco.h-its.org/exelixis/software.xhtml](http://sco.h-its.org/exelixis/software.xhtml)
    上查看它。Bioconda 也包含它，但它的名称是 `raxml`。请注意，二进制文件叫做 `raxmlHPC`。你可以执行以下命令来安装它：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code is simple, but it will take time to execute because it will
    call RAxML (which is computationally intensive). If you opt to use the DendroPy
    interface, it might also become memory-intensive. We will interact with RAxML,
    DendroPy, and Biopython, leaving you with a choice of which interface to use;
    DendroPy gives you an easy way to access results, whereas Biopython is less memory-intensive.
    Although there is a recipe for visualization later in this chapter, we will, nonetheless,
    plot one of our generated trees here.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码很简单，但执行起来需要时间，因为它会调用 RAxML（这是一个计算密集型过程）。如果你选择使用 DendroPy 接口，它也可能会变得内存密集。我们将与
    RAxML、DendroPy 和 Biopython 进行交互，给你选择使用哪个接口的自由；DendroPy 给你提供了一个简单的方式来访问结果，而 Biopython
    则是内存占用较少的选择。尽管本章后面有一个可视化的食谱，但我们仍然会在这里绘制我们生成的树。
- en: As usual, this information is available in the corresponding notebook at `Chapter07/Reconstruction.py`.
    You will need the output of the previous recipe to complete this one.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，这些信息可以在相应的笔记本 `Chapter07/Reconstruction.py` 中找到。你需要前一个食谱的输出才能完成这个食谱。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Take a look at the following steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下步骤：
- en: 'For DendroPy, we will load the data first and then reconstruct the genus dataset,
    as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 DendroPy，我们将首先加载数据，然后重建属数据集，如下所示：
- en: '[PRE22]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Remember that the size of the data structure for this is quite big; therefore,
    ensure that you have enough memory to load this (at least 10 GB).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个数据结构的大小相当大；因此，确保你有足够的内存来加载它（至少 10 GB）。
- en: Be prepared to wait for some time. Depending on your computer, this could take
    more than one hour. If it takes longer, consider restarting the process, as sometimes
    a RAxML bug might occur.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要准备好等待一段时间。根据你的计算机，这可能需要超过一个小时。如果时间过长，考虑重新启动进程，因为有时 RAxML 可能会出现 bug。
- en: We will run RAxML with the GTRΓ nucleotide substitution model, as specified
    in the paper. We will only perform 10 replicates to speed up the results, but
    you should probably do a lot more, say 100\. At the end of the process, we will
    delete the genome data from memory as it takes up a lot of memory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 GTRΓ 核苷酸替代模型运行 RAxML，如论文中所述。我们只进行 10 次重复以加快结果速度，但你可能应该做更多的重复，比如 100 次。在过程结束时，我们将从内存中删除基因组数据，因为它占用了大量内存。
- en: The `ebola_data` variable will have the best RAxML tree, with distances included.
    The `RaxmlRunner` object will have access to other information generated by RAxML.
    Let’s print the directory where DendroPy will execute RAxML. If you inspect this
    directory, you will find a lot of files. As RAxML returns the best tree, you might
    want to ignore all of these files, but we will discuss this a little in the alternative
    Biopython step.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`ebola_data` 变量将包含最佳的 RAxML 树，并且包括距离信息。`RaxmlRunner` 对象将可以访问 RAxML 生成的其他信息。让我们打印出
    DendroPy 将执行 RAxML 的目录。如果你检查这个目录，你会发现很多文件。由于 RAxML 返回的是最佳树，你可能会忽略所有这些文件，但我们将在替代的
    Biopython 步骤中稍作讨论。'
- en: 'We will save trees for future analysis; in our case, it will be a visualization,
    as shown in the following code:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将保存树用于未来的分析；在我们的案例中，它将是一个可视化，如下代码所示：
- en: '[PRE23]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We will write sequences to a NEXUS file because we need to store the topology
    information. FASTA is not enough here.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把序列写入 NEXUS 文件，因为我们需要存储拓扑信息。FASTA 在这里不够用。
- en: 'Let’s visualize our genus tree, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们可视化我们的属树，如下所示：
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will defer the explanation of this code until we come to the proper recipe
    later, but if you look at the following diagram and compare it with the results
    from the paper, you will clearly see that it looks like a step in the right direction.
    For example, all individuals from the same species are clustered together.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后介绍合适的步骤时再解释这段代码，但如果你查看下图并将其与论文中的结果进行比较，你会清楚地看到它像是朝着正确方向迈进的一步。例如，所有同一物种的个体被聚集在一起。
- en: 'You will notice that trimAl changed the names of its sequences, for example,
    by adding their sizes. This is easy to solve; we will deal with this in the *Visualizing
    phylogenetic data* recipe:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，trimAl改变了其序列的名称，例如，通过添加它们的大小。这很容易解决；我们将在*可视化系统发育数据*这一部分中处理这个问题：
- en: '![Figure 7.2 – The phylogenetic tree that we generated with RAxML for all Ebola
    viruses ](img/B17942_07_002.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 我们使用RAxML生成的所有埃博拉病毒的系统发育树](img/B17942_07_002.jpg)'
- en: Figure 7.2 – The phylogenetic tree that we generated with RAxML for all Ebola
    viruses
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 我们使用RAxML生成的所有埃博拉病毒的系统发育树
- en: 'Let’s reconstruct the phylogenetic tree with RAxML via Biopython. The Biopython
    interface is less declarative, but much more memory-efficient than DendroPy. So,
    after running it, it will be your responsibility to process the output, whereas
    DendroPy automatically returns the best tree, as shown in the following code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过Biopython使用RAxML重建系统发育树。Biopython的接口比DendroPy更少声明式，但在内存效率上要高得多。因此，在运行完后，你需要负责处理输出，而DendroPy会自动返回最优的树，如下代码所示：
- en: '[PRE25]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: DendroPy has a more declarative interface than Biopython, so you can take care
    of a few extra things. You should specify the seed (Biopython will put a fixed
    default of 10,000 if you do not do so) and the working directory. With RAxML,
    the working directory specification requires the absolute path.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: DendroPy比Biopython具有更具声明性的接口，因此你可以处理一些额外的事项。你应该指定种子（如果不指定，Biopython会自动使用10,000作为默认值）以及工作目录。使用RAxML时，工作目录的指定要求使用绝对路径。
- en: 'Let’s inspect the outcome of the Biopython run. While the RAxML output is the
    same (save for stochasticity) for DendroPy and Biopython, DendroPy abstracts away
    a few things. With Biopython, you need to take care of the results yourself. You
    can also perform this with DendroPy; however, in this case, it is optional:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查一下Biopython运行的结果。虽然RAxML的输出（除了随机性）对于DendroPy和Biopython是相同的，但DendroPy隐藏了几个细节。使用Biopython，你需要自己处理结果。你也可以使用DendroPy来执行这个操作；不过在这种情况下，它是可选的：
- en: '[PRE26]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code will read the best tree from the RAxML run. The name of the
    file was appended with the project name that you specified in the previous step
    (in this case, `biopython`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将读取RAxML运行中最优的树。文件名后附加了你在前一步中指定的项目名称（在本例中为`biopython`）。
- en: Take a look at the content of the `bp_rx` directory; here, you will find all
    the outputs from RAxML, including all 10 alternative trees.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`bp_rx`目录的内容；在这里，你将找到来自RAxML的所有输出，包括所有10个备选树。
- en: There’s more...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Although the purpose of this book is not to teach phylogenetic analysis, it’s
    important to know why we do not inspect consensus and support information in the
    tree topology. You should research this in your dataset. For more information,
    refer to [http://www.geol.umd.edu/~tholtz/G331/lectures/cladistics5.pdf](http://www.geol.umd.edu/~tholtz/G331/lectures/cladistics5.pdf).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书的目的是不教授系统发育分析，但了解为什么我们不检查树拓扑中的共识和支持信息还是很重要的。你应该在自己的数据集里研究这一点。更多信息，请参考[http://www.geol.umd.edu/~tholtz/G331/lectures/cladistics5.pdf](http://www.geol.umd.edu/~tholtz/G331/lectures/cladistics5.pdf)。
- en: Playing recursively with trees
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归操作树
- en: This is not a book about programming in Python, as the topic is vast. Having
    said that, it’s not common for introductory Python books to discuss recursive
    programming at length. Usually, recursive programming techniques are well tailored
    to deal with trees. It is also a required programming strategy with functional
    programming dialects, which can be quite useful when you perform concurrent processing.
    This is common when processing very large datasets.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本关于Python编程的书，因为这个话题非常广泛。话虽如此，入门级Python书籍通常不会详细讨论递归编程。通常，递归编程技术非常适合处理树结构。而且，它还是功能性编程方言中的一种必要编程策略，这在进行并发处理时非常有用。这在处理非常大的数据集时是常见的。
- en: The phylogenetic notion of a tree is slightly different from that in computer
    science. Phylogenetic trees can be rooted (if so, then they are normal tree data
    structures) or unrooted, making them undirected acyclic graphs. Additionally,
    phylogenetic trees can have weights on their edges. Therefore, be mindful of this
    when you read the documentation; if the text is written by a phylogeneticist,
    you can expect the tree (rooted and unrooted), while most other documents will
    use undirected acyclic graphs for unrooted trees. In this recipe, we will assume
    that all of the trees are rooted.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 系统发育树的概念与计算机科学中的树有所不同。系统发育树可以是有根的（如果是，它们就是普通的树数据结构），也可以是无根的，使其成为无向非循环图。此外，系统发育树的边上可以有权重。因此，在阅读文档时要注意这一点；如果文献是由系统发育学家编写的，你可以期待该树是有根或无根的，而大多数其他文档则会使用无向非循环图来表示无根树。在这个配方中，我们假设所有树都是有根的。
- en: Finally, note that while this recipe is mostly devised to help you understand
    recursive algorithms and tree-like structures, the final part is actually quite
    practical and fundamental for the next recipe to work.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，虽然本配方主要旨在帮助你理解递归算法和树形结构，但最后一部分实际上非常实用，并且对下一个配方的实现至关重要。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have the files from the previous recipe. As usual, you can
    find this content in the `Chapter07/Trees.py` notebook file. Here, we will use
    DendroPy’s tree representations. Note that most of this code is easily generalizable
    compared to other tree representations and libraries (phylogenetic or not).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要准备好前一配方中的文件。像往常一样，你可以在 `Chapter07/Trees.py` 笔记本文件中找到这些内容。在这里，我们将使用 DendroPy
    的树表示。请注意，比较其他树表示和库（无论是系统发育的还是非系统发育的）而言，大部分代码都是易于通用的。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Take a look at the following steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下步骤：
- en: 'First, let’s load the RAxML-generated tree for all Ebola viruses, as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们加载由 RAxML 生成的所有埃博拉病毒树，如下所示：
- en: '[PRE27]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we need to compute the level of each node (the distance to the root node):'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，我们需要计算每个节点的层级（到根节点的距离）：
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: DendroPy’s node representation has a level method (which is used for comparison),
    but the point here is to introduce a recursive algorithm, so we will implement
    it anyway.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: DendroPy 的节点表示有一个层级方法（用于比较），但这里的重点是介绍递归算法，所以我们还是会实现它。
- en: Note how the function works; it’s called with `seed_node` (which is the root
    node, since the code works under the assumption that we are dealing with rooted
    trees). The default level for the root node is `0`. The function will then call
    itself for all its children nodes, increasing the level by one. Then, for each
    node that is not a leaf (that is, it is internal to the tree), the calling will
    be repeated, and this will recurse until we get to the leaf nodes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个函数的工作原理；它是用 `seed_node` 调用的（这是根节点，因为代码假设我们处理的是有根树）。根节点的默认层级是 `0`。然后，该函数会递归调用所有子节点，将层级加一。对于每个非叶子节点（即，它是树的内部节点），这个调用会被重复，直到我们到达叶子节点。
- en: For the leaf nodes, we then print the level (we could have done the same for
    the internal nodes) and show the same information computed by DendroPy’s internal
    function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于叶子节点，我们接着打印出层级（我们也可以对内部节点执行相同的操作），并展示由 DendroPy 内部函数计算出的相同信息。
- en: 'Now, let’s compute the height of each node. The height of the node is the number
    of edges of the maximum downward path (going to the leaves), starting on that
    node, as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们计算每个节点的高度。节点的高度是从该节点开始的最大向下路径（通向叶子）的边数，如下所示：
- en: '[PRE29]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we will use the same recursive strategy, but each node will return its
    height to its parent. If the node is a leaf, then the height is `0`; if not, then
    it’s `1` plus the maximum height of its entire offspring.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用相同的递归策略，但每个节点将把它的高度返回给其父节点。如果该节点是叶子节点，则高度为 `0`；如果不是，则高度为 `1` 加上其所有后代的最大高度。
- en: Note that we use a map over a lambda function to get the heights of all the
    children of the current node. Then, we choose the maximum (the `max` function
    performs a `reduce` operation here because it summarizes all of the values that
    are reported). If you are relating this to MapReduce frameworks, you are correct;
    they are inspired by functional programming dialects like these.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用 `map` 配合 lambda 函数来获取当前节点所有子节点的高度。然后，我们选择最大值（`max` 函数在这里执行一个 `reduce`
    操作，因为它总结了所有报告的值）。如果你将其与 MapReduce 框架联系起来，你是正确的；它们的灵感来自于像这样的函数式编程方言。
- en: 'Now, let’s compute the number of offspring for each node. By now, this should
    be quite easy to understand:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们计算每个节点的子孙数量。到现在为止，这应该很容易理解：
- en: '[PRE30]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we will print all of the leaves (this is, apparently, trivial):'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将打印所有叶节点（显然，这是微不足道的）：
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that all the functions that we have developed so far impose a very clear
    traversal pattern on the tree. It calls its first offspring, then that offspring
    will call their offspring, and so on; only after this will the function be able
    to call its next offspring in a depth-first pattern. However, we can do things
    differently.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，到目前为止，我们开发的所有函数都对树施加了非常明确的遍历模式。它首先调用它的第一个子节点，然后该子节点会调用它的子节点，依此类推；只有这样，函数才能按深度优先的模式调用下一个子节点。然而，我们也可以采取不同的方式。
- en: 'Now, let’s print the leaf nodes in a breadth-first manner, that is, we will
    print the leaves with the lowest level (closer to the root) first, as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们以广度优先的方式打印叶节点，也就是说，我们会首先打印离根节点最近的叶节点，按如下方式：
- en: '[PRE32]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Before we explain this algorithm, let’s look at how different the result from
    this run will be compared to the previous one. For starters, take a look at the
    following diagram. If you print the nodes by depth-first order, you will get Y,
    A, X, B, and C. But if you perform a breath-first traversal, you will get X, B,
    C, Y, and A. Tree traversal will have an impact on how the nodes are visited;
    more often than not, this is important.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释这个算法之前，先看看这个运行的结果与上一次运行的结果有何不同。首先，看看下面的图示。如果你按深度优先顺序打印节点，你会得到Y、A、X、B和C。但是如果你执行广度优先遍历，你会得到X、B、C、Y和A。树的遍历会影响节点的访问顺序；这一点往往非常重要。
- en: Regarding the preceding code, here, we will use a completely different approach,
    as we will perform an iterative algorithm. We will use a **first-in, first-out**
    (**FIFO**) queue to help order our nodes. Note that Python’s deque can be used
    as efficiently as FIFO, as well as in **last-in, first-out** (**LIFO**). That’s
    because it implements an efficient data structure when you operate at both extremes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的代码，在这里我们将采用完全不同的方法，因为我们将执行一个迭代算法。我们将使用**先进先出**（**FIFO**）队列来帮助我们排序节点。请注意，Python的deque可以像FIFO一样高效地使用，也可以用于**后进先出**（**LIFO**）。这是因为它在两端操作时实现了高效的数据结构。
- en: The algorithm starts by putting the root node onto the queue. While the queue
    is not empty, we will take the node out front. If it’s an internal node, we will
    put all of its children into the queue.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 算法从将根节点放入队列开始。当队列不为空时，我们将取出队列中的第一个节点。如果是内部节点，我们将把它的所有子节点放入队列。
- en: 'We will iterate the preceding step until the queue is empty. I encourage you
    to take a pen and paper and see how this works by performing the example shown
    in the following diagram. The code is small, but not trivial:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续执行前一步骤，直到队列为空。我鼓励你拿起笔和纸，通过执行下图所示的示例来看看这个过程是如何运作的。代码虽小，但并不简单：
- en: '![Figure 7.3 – Visiting a tree; the first number indicates the order in which
    that node is visited traversing depth-first, while the second assumes breadth-first
    ](img/B17942_07_003.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 遍历树；第一个数字表示在深度优先遍历中访问该节点的顺序，第二个数字则表示广度优先遍历的顺序](img/B17942_07_003.jpg)'
- en: Figure 7.3 – Visiting a tree; the first number indicates the order in which
    that node is visited traversing depth-first, while the second assumes breadth-first
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 遍历树；第一个数字表示在深度优先遍历中访问该节点的顺序，第二个数字则表示广度优先遍历的顺序
- en: 'Let’s get back to the real dataset. As we have a bit too much data to visualize,
    we will generate a trimmed-down version, where we remove the subtrees that have
    single species (in the case of EBOV, they have the same outbreak). We will also
    ladderize the tree, that is, sort the child nodes in order of the number of children:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到实际的数据集。由于我们有太多数据无法完全可视化，我们将生成一个精简版，去除包含单一物种的子树（以EBOV为例，它们有相同的爆发）。我们还将进行树的阶梯化，即按子节点的数量对子节点进行排序：
- en: '[PRE33]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will perform a deep copy of the tree structure. As our function and the ladderization
    are destructive (they will change the tree), we will want to maintain the original
    tree.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对树结构进行深拷贝。由于我们的函数和阶梯化过程是破坏性的（它们会改变树结构），我们需要保持原始树结构不变。
- en: DendroPy is able to enumerate all the leaf nodes (at this stage, a good exercise
    would be to write a function to perform this). With this functionality, we will
    get all the leaves for a certain node. If they share the same species and outbreak
    year as in the case of EBOV, we remove all of the child nodes, leaves, and internal
    subtree nodes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: DendroPy能够列举出所有叶节点（在这个阶段，一个好的练习是编写一个函数来执行这个操作）。通过这个功能，我们可以获取某个节点的所有叶子。如果它们与EBOV的情况一样，具有相同的物种和爆发年份，我们将移除所有子节点、叶节点和内部子树节点。
- en: If they do not share the same species, we recurse down until that happens. The
    worst case is that when you are already at a leaf node, the algorithm trivially
    resolves to the species of the current node.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们不属于相同物种，我们将递归下去，直到满足条件。最坏的情况是当你已经处于叶节点时，算法会简单地解析为当前节点的物种。
- en: There’s more...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is a massive amount of computer science literature on the topic of trees
    and data structures; if you want to read more, Wikipedia provides a great introduction
    at [http://en.wikipedia.org/wiki/Tree_%28data_structure%29](http://en.wikipedia.org/wiki/Tree_%28data_structure%29).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 关于树和数据结构的话题，有大量的计算机科学文献；如果你想阅读更多内容，维基百科提供了一个很好的介绍，网址是[http://en.wikipedia.org/wiki/Tree_%28data_structure%29](http://en.wikipedia.org/wiki/Tree_%28data_structure%29)。
- en: Note that the use of `lambda` functions and `map` is not encouraged as a Python
    dialect; you can read some (older) opinions on the subject from Guido van Rossum
    at [http://www.artima.com/weblogs/viewpost.jsp?thread=98196](http://www.artima.com/weblogs/viewpost.jsp?thread=98196).
    I presented it here because it’s a very common dialect within functional and recursive
    programming. The more common dialect will be based on a list of comprehensions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`lambda`函数和`map`的使用并不被推荐作为Python方言；你可以阅读Guido van Rossum关于这个主题的一些（较旧的）观点，网址是[http://www.artima.com/weblogs/viewpost.jsp?thread=98196](http://www.artima.com/weblogs/viewpost.jsp?thread=98196)。我在这里呈现它是因为它是函数式和递归编程中的一种非常常见的方言。更常见的方言将基于列表推导式。
- en: In any case, the functional dialect based on using the `map` and `reduce` operations
    is the conceptual base for MapReduce frameworks, and you can use frameworks such
    as Hadoop, Disco, or Spark to perform high-performance bioinformatics computing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，基于使用`map`和`reduce`操作的函数式方言是MapReduce框架的概念基础，你可以使用像Hadoop、Disco或Spark这样的框架来执行高性能的生物信息学计算。
- en: Visualizing phylogenetic data
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化系统发育数据
- en: In this recipe, we will discuss how to visualize phylogenetic trees. DendroPy
    only has simple visualization mechanisms based on drawing textual ASCII trees,
    but Biopython has quite a rich infrastructure, which we will leverage here.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将讨论如何可视化系统发育树。DendroPy仅具有基于绘制文本ASCII树的简单可视化机制，但Biopython拥有非常丰富的基础设施，我们将在这里利用它。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This will require you to have completed all of the previous recipes. Remember
    that we have the files for the whole genus of the Ebola virus, including the RAxML
    tree. Furthermore, a simplified genus version will have been produced in the previous
    recipe. As usual, you can find this content in the `Chapter07/Visualization.py`
    notebook file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将要求你完成所有前面的配方。记住，我们拥有完整的埃博拉病毒属的文件，包括RAxML树。此外，简化版属版本将在前面的配方中生成。如常，你可以在`Chapter07/Visualization.py`笔记本文件中找到这些内容。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Take a look at the following steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请看下面的步骤：
- en: 'Let’s load all of the phylogenetic data:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载所有系统发育数据：
- en: '[PRE34]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For all of the trees that we read, we will change the name of the tree, as the
    name will be printed later.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们读取的所有树，我们将更改树的名称，因为稍后会打印出该名称。
- en: 'Now, we can draw ASCII representations of the trees:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以绘制树的ASCII表示：
- en: '[PRE35]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The ASCII representation of the simplified genus tree is shown in the following
    diagram. Here, we will not print the complete version because it will take several
    pages. But if you run the preceding code, you will be able to see that it’s actually
    quite readable:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 简化版属树的ASCII表示如下所示。在这里，我们不会打印完整版本，因为它将占用好几页。但如果你运行前面的代码，你将能够看到它实际上是非常易于阅读的：
- en: '![Figure 7.4 – The ASCII representation of a simplified Ebola virus dataset
    ](img/B17942_07_004.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 简化版埃博拉病毒数据集的ASCII表示](img/B17942_07_004.jpg)'
- en: Figure 7.4 – The ASCII representation of a simplified Ebola virus dataset
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 简化版埃博拉病毒数据集的ASCII表示
- en: '`Bio.Phylo` allows for the graphical representation of trees by using `matplotlib`
    as a backend:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Bio.Phylo`通过使用`matplotlib`作为后端来实现树的图形表示：'
- en: '[PRE36]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this case, we will print the branch lengths at the edges, but we will remove
    all of the lengths that are less than 0.02 to avoid clutter. The result of doing
    this is shown in the following diagram:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将在边缘处打印分支长度，但会去除所有小于0.02的长度，以避免杂乱。这样做的结果如下图所示：
- en: '![Figure 7.5 – A matplotlib-based version of the simplified dataset with branch
    lengths added ](img/B17942_07_005.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 一个基于matplotlib的简化数据集版本，并添加了分支长度](img/B17942_07_005.jpg)'
- en: Figure 7.5 – A matplotlib-based version of the simplified dataset with branch
    lengths added
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 一个基于matplotlib的简化数据集版本，并添加了分支长度
- en: 'Now we will plot the complete dataset, but we will color each bit of the tree
    differently. If a subtree only has a single virus species, it will get its own
    color. EBOV will have two colors, that is, one for the 2014 outbreak and one for
    the others, as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将绘制完整的数据集，但每个树的部分将使用不同的颜色。如果一个子树只有单一的病毒种类，它将拥有自己独特的颜色。埃博拉病毒（EBOV）将有两种颜色，也就是说，一种用于2014年的疫情，另一种用于其他年份，如下所示：
- en: '[PRE37]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is a tree traversing algorithm, not unlike the ones presented in the previous
    recipe. As a recursive algorithm, it works in the following way. If the node is
    a leaf, it will get a color based on its species (or the EBOV outbreak year).
    If it’s an internal node and all the descendant nodes below it are of the same
    species, it will get the color of that species; if there are several species after
    that, it will be colored in gray. Actually, the color function can be changed
    and will be changed later. Only the edge colors will be used (the labels will
    be printed in black).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个树遍历算法，类似于前面例子中呈现的算法。作为一个递归算法，它的工作方式如下。如果节点是叶子，它将根据其种类（或EBOV疫情年份）来着色。如果它是一个内部节点，并且所有下面的后代节点都是同一物种，它将采用该物种的颜色；如果后代节点包含多个物种，它将被着色为灰色。实际上，颜色函数可以更改，并且稍后会进行更改。只有边缘颜色会被使用（标签会以黑色打印）。
- en: Note that ladderization (performed in the previous recipe with DendroPy) helps
    quite a lot in terms of a clear visual appearance.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，阶梯化（在前面的例子中使用DendroPy完成）对于清晰的视觉效果帮助很大。
- en: We also deep copy the genus tree to color a copy; remember from the previous
    recipe that some tree traversal functions can change the state, and in this case,
    we want to preserve a version without any coloring.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会对属树进行深拷贝，以便对副本进行着色；请记住，在前面的例子中提到的某些树遍历函数可能会改变状态，而在这种情况下，我们希望保留一个没有任何着色的版本。
- en: 'Note the usage of the lambda function to clean up the name that was changed
    by trimAl, as shown in the following diagram:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用了lambda函数来清理由trimAl修改的名称，如下图所示：
- en: '![Figure 7.6 – A ladderized and colored phylogenetic tree with the complete
    Ebola virus dataset ](img/B17942_07_006.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 一个带有完整埃博拉病毒数据集的阶梯化和着色的系统发育树](img/B17942_07_006.jpg)'
- en: Figure 7.6 – A ladderized and colored phylogenetic tree with the complete Ebola
    virus dataset
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 一个带有完整埃博拉病毒数据集的阶梯化和着色的系统发育树
- en: There’s more...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Tree and graph visualization is a complex topic; arguably, here, the tree’s
    visualization is rigorous but far from pretty. One alternative to DendroPy, which
    has more visualization features, is ETE ([http://etetoolkit.org/](http://etetoolkit.org/)).
    General alternatives for drawing trees and graphs include Cytoscape ([https://cytoscape.org/](https://cytoscape.org/))
    and Gephi ([http://gephi.github.io/](http://gephi.github.io/)). If you want to
    know more about the algorithms for rendering trees and graphs, check out the Wikipedia
    page at [http://en.wikipedia.org/wiki/Graph_drawing](http://en.wikipedia.org/wiki/Graph_drawing)
    for an introduction to this fascinating topic.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 树和图的可视化是一个复杂的话题；可以说，这里的树可视化是严谨的，但远不漂亮。DendroPy的一个替代方案是ETE（[http://etetoolkit.org/](http://etetoolkit.org/)），它具有更多的可视化功能。绘制树和图的常见替代方案包括Cytoscape（[https://cytoscape.org/](https://cytoscape.org/)）和Gephi（[http://gephi.github.io/](http://gephi.github.io/)）。如果你想了解更多关于渲染树和图的算法，可以查看Wikipedia页面：[http://en.wikipedia.org/wiki/Graph_drawing](http://en.wikipedia.org/wiki/Graph_drawing)，了解这个迷人的话题。
- en: Be careful not to trade style for substance, though. For example, the previous
    edition of this book had a pretty rendering of a phylogenetic tree using a graph-rendering
    library. While it was clearly the most beautiful image in that chapter, it was
    misleading in terms of branch lengths.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，要小心不要以牺牲实质内容为代价追求风格。例如，本书的上一版使用图形渲染库绘制了一个美观的系统发育树。虽然它显然是该章节中最漂亮的图像，但在分支长度上却具有误导性。
