- en: Searching Genes and Proteins for Domains and Motifs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索基因和蛋白质的结构域与模体
- en: The sequences of genes, proteins, and entire genomes hold clues to their function.
    Repeated subsequences or sequences with a strong similarity to each other can
    be clues to things such as evolutionary conservation or functional relatedness.
    As such, sequence analysis for motifs and domains are core techniques in bioinformatics.
    Bioconductor contains many useful packages for analyzing genes, proteins, and
    genomes. In this chapter, you will learn how to use Bioconductor to analyze sequences
    for features of functional interest, such as de novo DNA motifs and known domains
    from widely used databases. You'll learn about some packages for kernel-based
    machine learning to find protein sequence features. You will also learn some large-scale
    alignment techniques for very many, or very long sequences. You will use Bioconductor
    and other statistical learning packages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基因、蛋白质和整个基因组的序列包含了它们功能的线索。重复的子序列或相互之间高度相似的序列，可能是进化保守性或功能相关性的线索。因此，针对模体和结构域的序列分析是生物信息学的核心技术。Bioconductor
    包含了许多有用的包，用于分析基因、蛋白质和基因组。在本章中，你将学习如何使用 Bioconductor 分析序列中具有功能意义的特征，例如从广泛使用的数据库中提取的
    de novo DNA 模体和已知结构域。你将学习一些基于核函数的机器学习包，用于发现蛋白质序列特征。你还将学习一些大规模比对技术，用于处理非常多或非常长的序列。你将使用
    Bioconductor 和其他统计学习包。
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涉及以下配方：
- en: Finding DNA motifs with universalmotif
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 universalmotif 查找 DNA 模体
- en: Finding protein domains using PFAM and bio3d
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PFAM 和 bio3d 查找蛋白质结构域
- en: Finding InterPro domains
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找 InterPro 结构域
- en: Performing multiple alignments of genes or proteins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行基因或蛋白质的多重比对
- en: Aligning genomic length sequences with DECIPHER
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DECIPHER 对基因组长度序列进行比对
- en: Machine learning for novel feature detection in proteins
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于蛋白质新特征检测的机器学习
- en: 3D structure protein alignment with bio3d
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 bio3d 进行蛋白质的 3D 结构比对
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample data you'll need is available from this book's GitHub repository: [https://github.com/danmaclean/R_Bioinformatics_Cookbook](https://github.com/danmaclean/R_Bioinformatics_Cookbook)[.](https://github.com/danmaclean/R_Bioinformatics_Cookbook) If
    you want to use the code examples as they are written, then you will need to make
    sure that this data is in a sub-directory of whatever your working directory is.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的样本数据可以从本书的 GitHub 仓库获取：[https://github.com/danmaclean/R_Bioinformatics_Cookbook](https://github.com/danmaclean/R_Bioinformatics_Cookbook)[.]（https://github.com/danmaclean/R_Bioinformatics_Cookbook）如果你想直接使用书中的代码示例，则需要确保这些数据位于你工作目录的子目录中。
- en: 'The following are the R packages that you''ll need. Most of these will install
    with `install.packages()`*; *others are a little more complicated:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将需要的 R 包。大多数包可以通过 `install.packages()` 安装；其他包则稍微复杂一些：
- en: '`ape`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ape`'
- en: '`Bioconductor`:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bioconductor`：'
- en: '`Biostrings`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Biostrings`'
- en: '`biomaRt`'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`biomaRt`'
- en: '`DECIPHER`'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DECIPHER`'
- en: '`EnsDb.Rnorvegicus.v79`'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnsDb.Rnorvegicus.v79`'
- en: '`kebabs`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kebabs`'
- en: '`msa`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msa`'
- en: '`org.At.tair.db`'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.At.tair.db`'
- en: '`org.Eck12.db`'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.Eck12.db`'
- en: '`org.Hs.eg.db`'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.Hs.eg.db`'
- en: '`PFAM.db`'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PFAM.db`'
- en: '`universalmotif`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`universalmotif`'
- en: '`bio3d`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bio3d`'
- en: '`dplyr`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dplyr`'
- en: '`e1071`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e1071`'
- en: seqinr
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: seqinr
- en: 'Bioconductor is huge and has its own installation manager. You can install
    it with the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Bioconductor 是一个庞大的工具集，具有自己的安装管理器。你可以使用以下代码进行安装：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Further information is available at [https://www.bioconductor.org/install/](https://www.bioconductor.org/install/).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请访问 [https://www.bioconductor.org/install/](https://www.bioconductor.org/install/)。
- en: Normally, in R, a user will load a library and use the functions directly by
    name. This is great in interactive sessions but it can cause confusion when many
    packages are loaded. To clarify which package and function I'm using at a given
    moment, I will occasionally use the `packageName::functionName()` convention.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在 R 中，用户会加载一个库并直接按名称使用函数。这在交互式会话中非常方便，但当加载了许多包时，可能会引起混淆。为了澄清我在某一时刻使用的是哪个包和函数，我会偶尔使用
    `packageName::functionName()` 的约定。
- en: 'Sometimes, in the middle of a recipe, I''ll interrupt the code so you can see
    some intermediate output or the structure of an object it''s important to understand.
    Whenever that happens, you''ll see a code block where each line begins with ##
    double hash symbols. Consider the command that follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在一个过程的中途，我会中断代码，方便你查看一些中间输出或是需要理解的对象结构。每当发生这种情况时，你会看到一个代码块，其中每行前面都有 `##`
    双井号符号。请参考以下命令：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will give us output as follows – note that the output lines are prefixed
    with `##`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们如下的输出——请注意，输出行以`##`为前缀：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Some of the packages that we want to use in this chapter rely on third-party
    software that must be installed separately. A great way of installing and managing
    bioinformatics software on any of Windows, Linux, or macOS is the conda package
    manager in conjunction with the bioconda package channel. You can install lots
    of software with some simple commands. To install both, start out by reading the
    current instructions at [https://bioconda.github.io/](https://bioconda.github.io/).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们要使用的一些软件包依赖于必须单独安装的第三方软件。在Windows、Linux或macOS上安装和管理生物信息学软件的一种极好的方式是使用conda包管理器，并结合bioconda包频道。你可以通过一些简单的命令安装大量软件。要安装这两者，首先阅读[https://bioconda.github.io/](https://bioconda.github.io/)上的当前安装说明。
- en: Finding DNA motifs with universalmotif
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用universalmotif查找DNA motifs
- en: 'A very common task when working with DNA sequences is finding instances of
    motifs—a short defined sequence—in a longer sequence. These could represent protein—DNA
    binding sites, such as transcription factor binding sites in a gene promoter or
    an enhanced region. There are two start points for this analysis: either you have
    a database of motifs that you wish to use to scan target DNA sequences and extract
    wherever the motif occurs or you have just the sequences of interest and you want
    to find out whether there are any repeating motifs in there. We''ll look at ways
    of doing both of these things in this recipe. We''ll use the `universalmotif` package
    in both cases.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理DNA序列时，一个非常常见的任务是查找motif实例——即在较长序列中定义的短序列。这些可能代表蛋白质- DNA结合位点，例如基因启动子中的转录因子结合位点或增强区域。在此分析中有两种起点：要么你有一个motif数据库，想用它来扫描目标DNA序列并提取出现的motif，要么你只有感兴趣的序列，想要查找其中是否有任何重复的motif。在本食谱中，我们将讨论如何执行这两项操作。我们将在这两种情况下都使用`universalmotif`包。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need the `datasets/ch3/simple_motif.txt` and `datasets/ch3/promoters.fa` files,
    a simple matrix describing a simple motif in a **Position Specific Weight Matrix**
    (**PSWM**) format (see *Appendix* for a brief description), and a set of sequences
    from upstream of transcriptional start sites.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中，我们需要`datasets/ch3/simple_motif.txt`和`datasets/ch3/promoters.fa`文件，一个描述简单motif的简单矩阵，格式为**位置特异性权重矩阵**（**PSWM**）（简要描述请参见*附录*），以及一组来自转录起始位点上游的序列。
- en: This recipe also requires a working copy of `MEME` on your system. `MEME` is
    a program for finding statistically overrepresented sequence motifs in sets of
    sequences. When used on promoter or upstream gene regions, these motifs can represent
    transcription factor-binding sites. The web page for `MEME` is at [http://alternate.meme-suite.org/](http://alternate.meme-suite.org/)
    and if you have conda installed, you can install it with `conda install -c bioconda
    meme`. The `MEME` package isn't available for Windows systems. If you wish to
    run it on Windows, then you should look at running it under Cygwin—a Linux emulation
    layer ([https://www.cygwin.com/](https://www.cygwin.com/)). You may need to install
    a new version of R under Cygwin as well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱还需要在你的系统中有一个有效的`MEME`副本。`MEME`是一个用于在序列集中过度表现的统计序列motif的程序。当用于启动子或基因上游区域时，这些motif可能代表转录因子结合位点。`MEME`的网页地址为[http://alternate.meme-suite.org/](http://alternate.meme-suite.org/)，如果你已经安装了conda，可以通过`conda
    install -c bioconda meme`来安装。`MEME`包无法在Windows系统上使用。如果你希望在Windows上运行它，可以考虑在Cygwin（Linux模拟层）下运行它：[https://www.cygwin.com/](https://www.cygwin.com/)。你可能还需要在Cygwin下安装新的R版本。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Finding DNA motifs with `universalmotif` can be done using the following steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`universalmotif`查找DNA motifs可以按照以下步骤进行：
- en: 'First, load the libraries and a motif of interest:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，加载所需的库和感兴趣的motif：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, load in sequences to scan with the motif:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，加载要用该motif扫描的序列：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Perform a scan of the sequences:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行序列扫描：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that `motif_hits` contains information about the position of the motif
    in each of the target sequences.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`motif_hits`包含关于motif在每个目标序列中位置的信息。
- en: 'Calculate whether the motif is enriched in the sequences:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算该结构是否在序列中富集：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that motif info contains information about statistical enrichment in a
    set of sequences.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，motif信息包含关于在一组序列中统计富集的信息。
- en: 'Run `MEME` to find novel motifs:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`MEME`以查找新型motif：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This is really neat code! In just a few lines, we were able to complete a whole
    analysis. We began by loading in a matrix description of a motif and some sequences
    we hope to find the promoter in—this happened in steps 1 and 2 and we got a `universalmotif` object
    and a `DNAStringSet` object to work with. The real work happens next, in steps
    3 and 4\. The `scan_sequences()` function searches each of the sequences and reports
    where it finds motifs—check out the `motif_hits` object to see where they are.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码真是太棒了！仅用几行代码，我们就完成了整个分析。我们首先加载了一个基序的矩阵描述和一些我们希望找到启动子的序列——这发生在步骤1和2中，结果我们得到了一个`universalmotif`对象和一个`DNAStringSet`对象。接下来的真正工作发生在步骤3和4中。`scan_sequences()`函数会搜索每个序列并报告找到基序的位置——查看`motif_hits`对象，看看它们在哪里。
- en: 'This will result in the following output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When it comes to working out whether a motif is significant, the `enrich_motifs()`
    function in the `universalmotifs` package does this work for us in step 4 and will
    result in the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在判断一个基序是否显著时，`universalmotifs`包中的`enrich_motifs()`函数会在第4步为我们完成这项工作，结果会产生以下输出：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It searches the sequences to find likely instances of motifs and counts them,
    performing Fisher's exact test to compare the frequencies of motifs in our set
    of sequences with their frequencies in an automatically generated background set.
    The final `motif_info` output contains a report of the *p* value. To find novel
    motifs, we run the external software **MEME** in step 5\. The `run_meme()` function
    needs to know where the **MEME** package is on your system, so we define that
    in the `meme_path` variable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它会搜索序列，寻找可能出现基序的地方，并对其进行计数，执行Fisher精确检验，比较我们的序列集中的基序频率与自动生成的背景集中的基序频率。最终的`motif_info`输出包含一个*p*值报告。为了找到新的基序，我们在第5步运行外部软件**MEME**。`run_meme()`函数需要知道**MEME**包在你系统中的位置，因此我们需要在`meme_path`变量中定义该路径。
- en: Note that the value for `meme_path` on your system will be different than the
    value mentioned here—that's an example on my system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，系统中`meme_path`的值与此处提到的值会有所不同——这是我系统中的一个示例。
- en: 'We pass that information to the function, along with the `DNAStringSet` object
    containing our sequences. The function also needs an output directory to write
    `MEME` results to, since it doesn''t return anything useful to R. The `run_meme()`
    function executes `MEME` in the background and once the run is finished, we can
    load in the results from the `meme.txt` file using the `read_meme()` function
    with a filename. It returns a `universalmotif` object. Finally, here, we quickly
    inspect the `motifs` object with the `view_motifs()` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些信息传递给函数，并提供包含序列的`DNAStringSet`对象。该函数还需要一个输出目录，用于写入`MEME`的结果，因为它不会返回任何有用的信息给R。`run_meme()`函数会在后台执行`MEME`，一旦运行完成，我们可以通过`read_meme()`函数和文件名从`meme.txt`文件中加载结果。它会返回一个`universalmotif`对象。最后，在这里，我们通过`view_motifs()`函数快速查看`motifs`对象：
- en: '![](img/51fa1536-9437-4b38-b990-908f51de364f.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51fa1536-9437-4b38-b990-908f51de364f.png)'
- en: This gives us a pretty visualization of the motifs found.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给我们一个非常直观的基序可视化。
- en: There's more...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Loading in motifs from pre-existing databases such as JASPAR and TRANSFAC is
    very easy with `universalmotif` as there are straightforward replacements for
    the `read_matrix()` function. Look at the following functions to load in motifs
    from various formats: `read_cisbp()`, `read_homer()`, `read_jaspar()`, `read_matrix()`,
    `read_meme()`, `read_motifs()`, and `read_uniprobe()`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从现有的数据库（如JASPAR和TRANSFAC）中加载基序非常简单，使用`universalmotif`时，只需对`read_matrix()`函数做直接替换。查看以下函数，它们可以从不同格式中加载基序：`read_cisbp()`、`read_homer()`、`read_jaspar()`、`read_matrix()`、`read_meme()`、`read_motifs()`
    和 `read_uniprobe()`。
- en: Finding protein domains with PFAM and bio3d
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PFAM和bio3d查找蛋白质结构域
- en: Discovering the function of a protein sequence is a key task. We can do this
    in many ways, including by conducting whole sequence similarity searches against
    databases of known proteins using tools such as BLAST. If we want more informative
    and granular information, we can instead look for individual functional domains
    within a sequence. Databases such as `Pfam` and tools such as `hmmer` make this
    possible. `Pfam` encodes protein domains as profile Hidden Markov Models, which
    `hmmer` uses to scan sequences and report any likely occurrences of the domains.
    Often, genome annotation projects will carry out the searches for us, meaning
    that finding the `Pfam` domains in our sequence is a question of searching a database.
    Bioconductor does a great job of packaging up the data in these databases in particular
    packages—usually suffixed with **`.db`**. In this recipe, we'll look at how to
    work out whether a package contains Pfam domain information, how to extract it
    for specific genes of interest, and an alternative method for running a Pfam search
    yourself if there isn't any pre-existing information.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 发现蛋白质序列的功能是一个关键任务。我们可以通过多种方式来完成这项任务，包括使用BLAST等工具对已知蛋白质数据库进行全序列相似性搜索。如果我们希望获得更具信息量和更精细的资料，可以选择在序列中查找个体功能域。`Pfam`等数据库和`hmmer`等工具使得这一过程成为可能。`Pfam`将蛋白质结构域编码为配置文件隐马尔可夫模型，而`hmmer`则使用这些模型扫描序列并报告任何可能存在的结构域。通常，基因组注释项目会为我们完成这些搜索，这意味着要在我们的序列中找到`Pfam`结构域，关键就在于搜索数据库。Bioconductor在这些特定数据库的数据包装方面做得非常出色，通常是以**`.db`**为后缀的包。在本配方中，我们将展示如何判断一个包是否包含Pfam结构域信息，如何为特定基因提取这些信息，以及如果没有现成的信息时，如何自行运行Pfam搜索。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在准备中
- en: For this example, we need some Bioconductor `Annotationdbi` database packages—specifically, `org.Hs.eg.db`,
    `org.EcK12.eg.db`, and `and org.At.tair.db`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要一些Bioconductor的`Annotationdbi`数据库包—具体来说，`org.Hs.eg.db`、`org.EcK12.eg.db`和`org.At.tair.db`。
- en: 'You''ll also need the `bio3d` package, which—at the time of writing—only connects
    to the Pfam server if you use the development version. You can install this version
    from BitBucket with the `devtools` package:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要`bio3d`包，当前版本—在写这篇文档时—只有在使用开发版时，`bio3d`才会连接到Pfam服务器。你可以通过`devtools`包从BitBucket安装该版本：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Finding protein domains with `PFAM.db` and `bio3d` can be done using the following
    steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PFAM.db`和`bio3d`查找蛋白质结构域，可以通过以下步骤完成：
- en: 'Load the database package and inspect the types of keys in the database:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载数据库包并检查数据库中的键类型：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note the `ENSEMBL` key in this output—we can use this to query the database.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个输出中的`ENSEMBL`键—我们可以用它来查询数据库。
- en: 'Get a vector of keys using the `keys()` function:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`keys()`函数获取键的向量：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Query the database:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询数据库：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Load the `PFAM` database to extract descriptions:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`PFAM`数据库以提取描述信息：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Get all keys from the `PFAM` database:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`PFAM`数据库中获取所有键：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Get all descriptions for the `PFAM` IDs:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`PFAM` ID的所有描述：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Join the descriptions to `PFAM`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将描述信息与`PFAM`关联：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The key to this approach is finding out whether the database we''re using actually
    carries the PFAM domain information. That''s what we do in step 1—we use the `keytypes()`
    function to list the search keys available. PFAM can be seen in the results. Once
    we''ve verified that we can use this database for the information we want, we
    can follow a fairly standard procedure:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的关键在于找出我们使用的数据库是否确实包含PFAM域信息。这就是我们在步骤1中做的—我们使用`keytypes()`函数列出可用的搜索键。PFAM出现在结果中。一旦我们确认可以使用此数据库来获取我们需要的信息，就可以遵循一个相当标准的流程：
- en: 'Get a list of keys to query with—such as gene names. Here, we pull them from
    the database directly, but they could come from anywhere. This will result in
    the following output:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取查询用的键列表—比如基因名。这里我们直接从数据库中提取它们，但它们也可以来自其他地方。这将产生以下输出：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Query the database with the `select()` function, which pulls data for the provided
    keys. The `columns` argument tells it which data to pull. The expression here
    is going to get PFAM IDs for our genes of interest.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`select()`函数查询数据库，该函数根据提供的键拉取数据。`columns`参数告诉它要拉取哪些数据。这里的表达式将获取我们感兴趣基因的PFAM
    ID。
- en: 'Make a list of all PFAM IDs and descriptions. We load the `PFAM.db` package
    and use the `PFAMDE` object it provides to get a mapping between IDs and descriptions.
    This will result in the following output. Note that because we''re pulling data
    from an external database, changes in that database could be reflected here:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作所有 PFAM ID 和描述的列表。我们加载 `PFAM.db` 包，并使用它提供的 `PFAMDE` 对象来获取 ID 和描述之间的映射。这将产生以下输出。请注意，因为我们从外部数据库中提取数据，数据库的更改可能会在这里反映出来：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can then get the actual descriptions in an object with the `mappedkeys()`
    function.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `mappedkeys()` 函数获取实际的描述信息对象。
- en: Next, we extract and convert the descriptions of the `all_ids` object to a data
    frame.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，提取和转换 `all_ids` 对象的描述为数据框。
- en: 'And finally, we join the descriptions of the PFAM domains to the PFAM IDs we
    got earlier, using the columns with common data—`PFAM` and `ac`. This will result
    in the following output:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将 PFAM 域的描述与之前获得的 PFAM ID 进行连接，使用具有共同数据的列——`PFAM` 和 `ac`。这将产生以下输出：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There's more...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'I mentioned that the key to the recipe—in particular, the join in step 6—was
    to make sure the database contained the right keys, specifically PFAM, to proceed.
    Depending on the organism and database, the PFAM annotation may not exist. Here''s
    how to check whether it does exist in the database you''re interested in with
    two example databases, `org.At.tair.db` and `org.Eck12.eg.db`, an Arabidopsis database:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到食谱的关键部分——特别是第 6 步的连接——是确保数据库包含正确的键，特别是 PFAM，以便继续进行。根据生物体和数据库的不同，PFAM 注释可能不存在。以下是如何检查你感兴趣的数据库中是否存在它，使用了两个示例数据库
    `org.At.tair.db` 和 `org.Eck12.eg.db`，一个拟南芥数据库：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'and an E.coli database:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要一个 E.coli 数据库：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Simply use the `columns()` function to report the data columns in the database.
    If PFAM shows up, you can follow the procedure. If it doesn''t show up, then as
    an alternative procedure, it is possible to run PFAM and make the annotations
    yourself. The following code takes your input protein sequences and runs a PFAM
    search on the server at EBI using the `bio3d` function, `hmmer()`. The returned
    object contains the PFAM output in a dataframe in the `hit.tbl` slot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用 `columns()` 函数报告数据库中的数据列。如果 PFAM 出现，你可以按照以下步骤进行。如果未出现，则可以作为替代方案，在服务器上运行
    PFAM 并自行进行注释。以下代码使用 `bio3d` 函数 `hmmer()` 在 EBI 服务器上对输入的蛋白质序列进行 PFAM 搜索。返回的对象在
    `hit.tbl` 槽中包含 PFAM 输出的数据帧：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will result in the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finding InterPro domains
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找 InterPro 域
- en: InterPro is a database of predictive models, or signatures, provided by multiple
    protein databases. InterPro aggregates information from multiple sources to reduce
    redundancy in annotations and aid interpretability. In this recipe, we'll extend
    the approach we used for just PFAM domains and look at getting annotations of
    InterPro domains on sequences of interest. We'll start with Ensembl core databases.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: InterPro 是由多个蛋白质数据库提供的预测模型或签名的数据库。InterPro 聚合来自多个来源的信息，以减少注释的冗余性并帮助解释性。在这个示例中，我们将扩展我们用于
    PFAM 域的方法，查看感兴趣序列上的 InterPro 域的注释。我们将从 Ensembl 核心数据库开始。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need the `ensembldb`, `Ensdb.Rnorvegicus.v79`, and `biomaRt` Bioconductor
    packages.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 `ensembldb`、`Ensdb.Rnorvegicus.v79` 和 `biomaRt` 这几个 Bioconductor 包。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Finding InterPro protein domains can be done using the following steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下步骤找到 InterPro 蛋白质域：
- en: 'Load the libraries and double-check whether our database package carries the
    protein data we need:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载库并仔细检查我们的数据库包是否携带所需的蛋白质数据：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Build a list of genes to query with—note the `keytype` I need here is `GENEID`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建要查询的基因列表——请注意，这里我需要的 `keytype` 是 `GENEID`：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Use the `select()` function to pull the relevant data:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `select()` 函数提取相关数据：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The code is a database lookup on, specifically, the Rattus norvegicus Ensembl
    Database through the relevant package. The process is similar to that for PFAM
    domain searches:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是通过相关包在特定的 Rattus norvegicus Ensembl 数据库中进行数据库查找。该过程与 PFAM 域搜索类似：
- en: 'We use the `EnsemblDB` package-specific `hasProteinData()` function to check
    whether the database has the information we need. If the output is `TRUE`, we''re
    good:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `EnsemblDB` 包特定的 `hasProteinData()` 函数来检查数据库是否包含我们需要的信息。如果输出是 `TRUE`，则很好：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We again build a list of genes of interest—here, I pull the list from the database,
    but these IDs can come from anywhere.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次构建感兴趣的基因列表——这里我从数据库中提取列表，但这些 ID 可以来自任何地方。
- en: 'Finally, we search the database with the genes of interest as a key. Note that
    we need the `GeneIdFilter()` function wrapper and the `columns` argument to select
    which data we want to return.  This will result in a data frame with the following
    information:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们用感兴趣的基因作为关键字搜索数据库。 请注意，我们需要`GeneIdFilter()`函数包装器和`columns`参数来选择要返回的数据。
    这将导致一个包含以下信息的数据框架：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There's more...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这里还有更多内容……
- en: 'The approach we used in this recipe works well for Ensembl core databases,
    but there are other non-Ensembl core databases that we might want to search; for
    that, there is biomaRt. biomaRt allows us to define connections to other databases
    we may know of. Many of these databases expose an API we can use to query them.
    To do this, load the `biomaRt` library and use the `useMart()` function to define
    a connection to the appropriate host and dataset. Then, use the `getBM()` function
    with the connection and the columns and gene IDs to query with. You''ll get the
    search results for InterPro back if your query is `interpro`. The following example
    does a search for two *Arabidopsis* genes at `plants.ensembl.org`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个配方中使用的方法非常适合Ensembl核心数据库，但还有其他非Ensembl核心数据库，我们可能想要搜索； 对此，有biomaRt。 biomaRt允许我们定义到我们可能知道的其他数据库的连接。
    许多这些数据库公开了我们可以用来查询它们的API。 为此，加载`biomaRt`库并使用`useMart()`函数来定义与适当主机和数据集的连接。 然后，使用连接和列以及基因ID使用`getBM()`函数进行查询。
    如果您的查询是`interpro`，则会返回InterPro的搜索结果。 以下示例在`plants.ensembl.org`上为两个*拟南芥*基因进行搜索：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This returns the following output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See also...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅……
- en: If you're having trouble working out the names of marts and columns, try the
    `listMarts()` and `listDatasets()` functions from **bioMart**, which will provide
    lists of currently available marts and the data they contain.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在确定marts和columns的名称时遇到问题，请尝试来自**bioMart**的`listMarts()`和`listDatasets()`函数，它们将提供当前可用marts和它们包含的数据列表。
- en: Performing multiple alignments of genes or proteins
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行基因或蛋白质的多重比对
- en: The alignment of sequences as a task prior to building phylogenetic trees or
    as an end in itself to determine conserved and divergent regions is a mainstay
    in bioinformatics analysis and is amply covered in R and Bioconductor with the
    **ape** and **DECIPHER** packages. We'll look at the extremely straightforward
    procedures for going from sequence to alignment in this recipe.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建系统发育树之前或作为确定保守和分散区域的结束任务中，对序列进行对齐是生物信息学分析的重要组成部分，并且在R和Bioconductor中使用**ape**和**DECIPHER**包广泛涵盖了从序列到对齐的极为简单的程序。
    在这个配方中，我们将看看如何实现这一过程。
- en: Note that there are different techniques for different sequence lengths. In
    this first recipe, we'll look at how to align some Kbp-length sequences such as
    those that represent genes and proteins.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不同的序列长度有不同的技术。 在这个第一个配方中，我们将看看如何对齐一些Kbp长度的序列，例如代表基因和蛋白质的序列。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'This recipe needs the `msa` package. This is a pretty hefty package and includes
    external software: Clustal, Clustal Omega, and Muscle. The `ape` and `seqinR` packages are
    also needed. As a test dataset, we''ll use some haemoglobin protein sequences
    stored in the book''s data and code repository at `datasets/ch3/hglobin.fa`. You''ll
    need PDFLatex on your system too. You can find installation information here:
    [https://www.latex-project.org/get/](https://www.latex-project.org/get/).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要`msa`包。 这是一个相当庞大的包，包括外部软件：Clustal、Clustal Omega和Muscle。 还需要`ape`和`seqinR`包。
    作为测试数据集，我们将使用存储在书籍数据和代码存储库中的一些血红蛋白蛋白质序列，路径为`datasets/ch3/hglobin.fa`。 您的系统中还需要PDFLatex。
    您可以在此处找到安装信息：[https://www.latex-project.org/get/](https://www.latex-project.org/get/)。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'Performing multiple alignments of genes or proteins can be done using the following
    steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下步骤执行基因或蛋白质的多重比对：
- en: 'Load in the libraries and sequences:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载库和序列：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Perform the multiple sequence alignment:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行多序列比对：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This returns an alignment object as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个如下所示的对齐对象：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'View the result using the following code:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码查看结果：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'View a zoomed-in region using the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码查看放大区域：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何运行它……
- en: 'The recipe here is short and sweet—performing an MSA with `msa` is very straightforward.
    In step 1, we loaded the packages and sequences using the common `readAAStringSet()`
    function to give us `seqs`—an `AAStringSet` object, which we can inspect and get
    the following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的配方简单而明了——使用`msa`执行MSA非常简单。 在步骤1中，我们使用常见的`readAAStringSet()`函数加载包和序列，以给出`seqs`——一个`AAStringSet`对象，我们可以检查并获取以下输出：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, in *Step 2*, the `msa()` function is passed the `seqs` object and the
    name of an alignment method. Here, we use `ClustalOmega` (you can choose `ClustalOmega`,
    `ClustalW`, or `Muscle`). The method parameter specifies the name of the external
    program that is used to run the actual alignment. The aligner runs and you get
    an `MsaMultipleAlignment` object back—this is a container for the aligned sequences
    and it looks as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在*步骤 2*中，将`msa()`函数传入`seqs`对象和对齐方法的名称。这里我们使用`ClustalOmega`（你可以选择`ClustalOmega`、`ClustalW`或`Muscle`）。`method`参数指定了用于实际对齐的外部程序的名称。对齐器运行后，你将获得一个`MsaMultipleAlignment`对象——这是一个容器，包含了对齐后的序列，格式如下：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In step 3, we write a visualization of the alignment to a PDF file using the
    `msaPrettyPrint()` function. The function takes many arguments that describe the
    layout of the alignment picture. The visualization must be written to a file;
    it can''t be sent to an interactive session plot window like a normal plot object.
    The file the picture ends up in is specified with the file argument. The picture
    looks like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤3中，我们使用`msaPrettyPrint()`函数将对齐的可视化结果写入PDF文件。该函数有多个参数，用于描述对齐图的布局。可视化结果必须写入文件，不能像普通的绘图对象那样发送到交互式会话的绘图窗口中。图片存放的文件由`file`参数指定。生成的图片如下：
- en: '![](img/87df59f6-0c9c-4679-86cd-cf6bfafe0215.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87df59f6-0c9c-4679-86cd-cf6bfafe0215.png)'
- en: 'In step 4, we use the second positional argument to restrict the view to between
    positions 10 and 30 using the start - end `c(10,30)` vector. We get the following
    picture:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤4中，我们使用第二个位置参数，通过`c(10,30)`向量将视图限制在10到30之间。我们得到以下图片：
- en: '![](img/448f1f85-e5d0-4ab9-9217-1990dd4cd25f.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/448f1f85-e5d0-4ab9-9217-1990dd4cd25f.png)'
- en: Unfortunately, because the picture-making process uses Latex in the background,
    we cannot coerce the picture into a more helpful format than PDF or have it render
    like other plot objects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于图片制作过程在后台使用了Latex，因此我们无法将图片强制转换为比PDF更有用的格式，或像其他绘图对象一样进行渲染。
- en: There's more...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A tree visualization of sequence similarity is often useful at this stage.
    We can generate one of these with the `ape` and `seqinr` packages. We can convert
    our alignment object to a `seqinr distance` object that describes the sequence
    distances, and from that, use `ape` to create a simple neighbour-joining tree
    that we can plot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，树形可视化的序列相似性常常非常有用。我们可以使用`ape`和`seqinr`包生成这种可视化。我们可以将对齐对象转换为描述序列距离的`seqinr
    distance`对象，并从中使用`ape`创建一个简单的邻接树，然后进行绘制：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will give the following output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/38084986-a3b9-421d-8bab-349b315c6e23.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38084986-a3b9-421d-8bab-349b315c6e23.png)'
- en: Aligning genomic length sequences with DECIPHER
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DECIPHER对齐基因组长度序列
- en: Aligning sequences longer than genes and proteins, such as contigs from assembly
    projects, chromosomes, or whole genomes is a tricky task and one for which we
    need different techniques than those for short sequences. The longer sequences
    get, the harder they are to align. Long alignments are especially costly in terms
    of the computational time taken, since the algorithms that are effective on short
    sequences take up exponentially more time with increasing sequence length. Performing
    longer alignments generally starts with finding short anchor alignments and working
    the alignment out from there. We typically end up with blocks of synteny—regions
    that match well between the different genome alignments.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐比基因和蛋白质更长的序列，例如来自组装项目的contigs、染色体或整个基因组，是一个棘手的任务，并且需要不同于短序列的技术。序列越长，越难对齐。长序列的对齐尤其在计算时间上非常耗费，因为对于短序列有效的算法，随着序列长度的增加，其计算时间呈指数级增长。执行长序列的对齐通常从寻找短的锚对齐开始，然后从那里进行扩展。我们通常会得到同源块——在不同基因组对齐之间匹配较好的区域。
- en: In this recipe, we'll look at the `DECIPHER` package for genome length alignments.
    We'll use some chloroplast genomes—small organelle genomes of about 150 Kbp in
    length that are pretty well conserved as our sequences of interest.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将介绍`DECIPHER`包用于基因组长度的对齐。我们将使用一些叶绿体基因组——约150 Kbp长的小型细胞器基因组，这些基因组在进化上相对保守，作为我们的目标序列。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Make sure that you have the `DECIPHER` package installed. We'll use the `datasets/ch3/plastid_genomes.fa` file
    as an example.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经安装了`DECIPHER`包。我们将使用`datasets/ch3/plastid_genomes.fa`文件作为示例。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进行...
- en: 'Aligning genomic length sequence with `DECIPHER` can be done using the following
    steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DECIPHER`对齐基因组长度序列可以按照以下步骤进行：
- en: 'Load in the libraries and genome sequences:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载库和基因组序列：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Prepare the sequences in a local database:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地数据库中准备序列：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Find the blocks of `synteny`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 `synteny` 区块：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This will create a dotplot of syntenic blocks.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个同源区块的点图。
- en: 'Plot the `syntenic` blocks:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制 `syntenic` 区块：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, make an actual alignment:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，进行实际的比对：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And save the pairwise alignments one-by-one:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后逐一保存配对比对结果：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The DECIPHER package is very powerful and, as such, there''s a little bit of
    setup to do before we can move on to the meat of the analysis. In step 1, we load
    the libraries and the sequence into `long_seqs`, a **DNAStringSet** object; but
    in step 2, we build a further on-disk SQLite database for the subsequent steps.
    This is done with the `Seqs2DB()` function, which takes `long_seqs`, an input
    type (**XStringSet**—the parent class of **DNAStringSet)**, a name for the database
    (`long_db`), and a vector of sequence names, which we pull with the `names()` function.
    Once we''ve got the database built, we can use it in the following workflow:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: DECIPHER 包非常强大，因此在进行实际分析之前，需要进行一些设置。在步骤 1 中，我们加载库并将序列加载到 `long_seqs`，一个 **DNAStringSet**
    对象中；但在步骤 2 中，我们为后续步骤构建了一个额外的磁盘 SQLite 数据库。这是通过 `Seqs2DB()` 函数完成的，该函数接受 `long_seqs`（输入类型为
    **XStringSet**，**DNAStringSet** 的父类）、数据库的名称（`long_db`）以及一个序列名称的向量，我们通过 `names()`
    函数提取该向量。一旦数据库构建完成，我们就可以在以下工作流中使用它：
- en: 'Find syntenic blocks in a database with the `FindSynteny()` function. This
    will result in the following output:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `FindSynteny()` 函数在数据库中查找同源区块。此操作将产生以下输出：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Use the syntenic blocks to seed and perform an actual alignment with the `AlignSynteny()`
    function.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用同源区块作为种子，并通过 `AlignSynteny()` 函数执行实际的比对。
- en: These things are done in steps 3 and 5\. `FindSynteny()` needs the name of the
    database; `AlignSynteny()` needs the `synteny` object and the database name.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作在步骤 3 和 5 中完成。`FindSynteny()` 需要数据库的名称；`AlignSynteny()` 需要 `synteny` 对象和数据库名称。
- en: 'Finally, we can output the results. The `pairs()` function with the `synteny`
    object will create a dotplot of syntenic blocks:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以输出结果。带有 `synteny` 对象的 `pairs()` 函数将创建一个同源区块的点图：
- en: '![](img/6e4c485b-06c7-40f7-be51-3da141db2acf.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e4c485b-06c7-40f7-be51-3da141db2acf.png)'
- en: 'The `plot()` function with the `synteny` object creates a helpful heatmap as
    a plot of the position of syntenic blocks relative to the first genome. Regions
    of identical colors across the genomes indicate regions of syntenic sequences:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有 `synteny` 对象的 `plot()` 函数，可以创建一个有用的热图，显示同源区块相对于第一个基因组的位置。跨基因组的相同颜色区域表示同源序列区域：
- en: '![](img/ec419285-0479-4751-b51d-53ebd60b3363.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec419285-0479-4751-b51d-53ebd60b3363.png)'
- en: The last step, step 6, is the slightly fiddly save process. The `alignment`
    object is an R list in which each member represents an alignment—itself a list.
    By extracting and then using `unlist()` on each of the returned elements, you
    have an object (`blocks`) that can be saved as a typical FASTA alignment with
    `writeXStringSet()`. Remember that you'll need to do this for every member of
    the `blocks` object separately.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步，步骤 6，是稍微复杂的保存过程。`alignment` 对象是一个 R 列表，每个成员表示一个比对——它本身也是一个列表。通过提取并对每个返回的元素使用
    `unlist()`，你将得到一个可以用 `writeXStringSet()` 保存为典型 FASTA 比对的对象（`blocks`）。记住，你需要分别为
    `blocks` 对象的每个成员执行此操作。
- en: Machine learning for novel feature detection in proteins
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于蛋白质中新特征检测的机器学习
- en: Sometimes, we'll have a list of protein sequences that have come from some analysis
    or experiment that are in some way biologically related—for example, they may
    all bind the same target—and we will want to determine the parts of those proteins
    that are responsible for the action. Domain and motif finding, as we've done in
    the preceding recipes, can be helpful, but only if we've seen the domains before
    or the sequence is particularly well conserved or statistically over-represented.
    A different approach is to try machine learning in which we build a model that
    can classify our proteins of interest accurately and then use the properties of
    the model to show us which parts of the proteins result in the classification.
    We'll take that approach in this recipe; specifically, we'll train a **support
    vector machine** (**SVM**).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会有一个来自某些分析或实验的蛋白质序列列表，这些序列在某种程度上是生物学相关的——例如，它们可能都与同一个靶标结合——我们将希望确定这些蛋白质中负责该功能的部分。正如我们在前面配方中所做的，域和基序的寻找可以有所帮助，但前提是我们之前见过这些域，或者该序列特别保守，或者在统计学上被过度表示。另一种方法是尝试使用机器学习，在这种方法中，我们构建一个可以准确分类我们感兴趣的蛋白质的模型，然后利用该模型的特性来告诉我们哪些部分的蛋白质导致了这个分类。在这个配方中，我们将采用这种方法；具体来说，我们将训练一个**支持向量机**（**SVM**）。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need the `kebabs `and `Biostrings`, `e1071` and `readr`
    libraries, and two input data files. Machine learning works best with many training
    examples but they take time to run, so we have a rather small input of 170 *E.coli* proteins
    for which, according to the `STRING` database ([https://string-db.org/](https://string-db.org/)),
    there is experimental evidence for interacting with the *pfo* protein. These are
    the positive training examples. We also need negative training examples—these
    are another 170 *E.coli* proteins for which there is no evidence of interaction
    with *pfo,* which have been selected at random. All the protein sequences are
    in the `datasets/ch3/ecoli_proteins.fa` file. Accompanying this file is a text
    file of the class of each protein. `datasets/ch3/ecoli_protein_classes.txt` is
    a single-column text file that describes the class of each protein—a "1" for positive
    *pfo* interaction, and a "-1" for negative *pfo* interaction. The row index in
    the class file matches the protein index in the sequence file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要`kebabs`和`Biostrings`、`e1071`以及`readr`库，并且两个输入数据文件。机器学习在有大量训练样本时效果最佳，但它们运行需要时间，因此我们有一个相对较小的输入，即170个*大肠杆菌*蛋白质，根据`STRING`数据库（[https://string-db.org/](https://string-db.org/)）的数据显示，这些蛋白质与*pfo*蛋白有实验性互作证据。这些是正向训练样本。我们还需要负向训练样本——这又是170个与*pfo*蛋白没有互作证据的*大肠杆菌*蛋白，它们是随机选择的。所有蛋白质序列都存储在`datasets/ch3/ecoli_proteins.fa`文件中。与该文件一起，还有一个文本文件记录了每个蛋白质的类别。`datasets/ch3/ecoli_protein_classes.txt`是一个单列文本文件，描述了每个蛋白质的类别——“1”表示正向*pfo*互作，“-1”表示负向*pfo*互作。类别文件中的行索引与序列文件中的蛋白质索引相匹配。
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Machine learning for novel feature detection in proteins can be done using
    the following steps:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 蛋白质的新特征检测的机器学习可以通过以下步骤完成：
- en: 'Load the libraries and input files:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载库和输入文件：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Divide the data into a training and test set:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据划分为训练集和测试集：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Build the model with the training set:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用训练集构建模型：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use the model to predict the classes of the test set:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模型预测测试集的类别：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This will give the following output:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Examine the prediction profile of a sequence:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查序列的预测图谱：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This gives the following output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, plot `prediction_profile` using the following code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下代码绘制`prediction_profile`：
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first step here is straightforward: we load in the sequences we''re interested
    in and the classes they belong to. Because we''re loading the `ecoli_protein_classes.txt` file
    into a **dataframe**, when we need a simple vector, we use the `$` subset operator to
    extract the `classes` column from the dataframe. Doing so returns that single
    column in the vector object we need. After this, the workflow is straightforward:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一步很简单：我们加载我们感兴趣的序列以及它们所属的类别。因为我们将`ecoli_protein_classes.txt`文件加载到一个**数据框**中，当我们需要一个简单的向量时，我们使用`$`子集操作符从数据框中提取`classes`列。这样做会返回我们需要的那个单列向量对象。之后，工作流程很简单：
- en: Decide how much of the data should be training and how much should be test: Here,
    in step 1, we choose 75% of the data as the training set when we create the `training_proportion`
    variable. This is used in conjunction with `num_seqs` in the `sample()` function
    to randomly choose indices of the sequences to put into the training set. The`training_set_indices`
    variable contains integers that we will use to subset data on later. Initially,
    we make a complementary list of indices, `test_set_indices`, by using the square
    bracket, `[]`, subset notation and the negation operator, `-`. Basically, this
    construct is an idiomatic way of creating a vector that contains every index *not*
    in `training_set_indices`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定数据中有多少用于训练，多少用于测试：在第1步中，我们选择将数据的75%作为训练集，在创建`training_proportion`变量时进行设置。它与`num_seqs`一起用于`sample()`函数，以随机选择序列的索引并将其放入训练集。`training_set_indices`变量包含我们稍后将用来子集化数据的整数。最初，我们通过使用方括号`[]`和否定运算符`-`，创建一个互补的索引列表`test_set_indices`。基本上，这种构造方法是创建一个包含所有**不**在`training_set_indices`中的索引的向量的惯用方式。
- en: 'Construct and train the Support Vector Machine model: In step 2, we build our
    classifying model. First, we choose a kernel that maps the input data into a matrix
    space that the Support Vector Machine can learn from. Here, it''s from the `gappyPairKernel()`
    function—note that there are lots of kernel types; this one is pretty well suited
    to sequence data. We pass`kernel` along to the `kbsvm()` function along with the
    `training_set_indices` subset of sequences in `seqs` as the `x` parameter, and
    the `training_set_indices` subset of classes as the `y` parameter. Other arguments
    in this function determine the exact model type and package and training parameters.
    There are lots of options for these and they can have a strong effect on the efficacy
    of the final model. It''s well worth reading up and doing some scientific experimentation
    on what works best for your particular data. The final model is saved in the `model`
    variable.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和训练支持向量机模型：在第2步中，我们构建了分类模型。首先，我们选择一个内核，将输入数据映射到一个支持向量机可以学习的矩阵空间。在这里，它来自`gappyPairKernel()`函数——请注意，内核类型有很多种；这个内核非常适合序列数据。我们将`kernel`传递给`kbsvm()`函数，并将`training_set_indices`子集的序列作为`x`参数传入，`training_set_indices`子集的类别作为`y`参数传入。此函数中的其他参数决定了模型的具体类型、包和训练参数。这些选项非常多，而且它们对最终模型的效果有很大的影响。了解并进行科学实验，找到最适合你数据的设置是非常值得的。最终模型保存在`model`变量中。
- en: 'Test the model on unseen data: Now we have a model, we get to use it to predict
    classes of unseen proteins. This stage will tell us how good the model is. In
    step 3, we use the `predict()` function with the model and the sequences we didn''t
    use to train (the ones in `test_set_indices`) and get a prediction object back.
    Running the predictions through the `evaluatePrediction()` function along with
    the real classes from the classes vector and also a vector of all possible class
    labels using the `allLabels` argument returns a summary of the accuracy and other
    metrics of the model. We have 62% accuracy in the model here, which is only okay;
    it''s better than random. But we have a rather small dataset and the model isn''t
    optimized; with more work, it could be better. Note that if you run the code,
    you may get different answers. Since the selection of training set sequences is
    random, the models might do slightly worse or better depending on the exact input
    data.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在未见数据上测试模型：现在我们有了一个模型，我们可以用它来预测未见蛋白质的类别。这个阶段将告诉我们模型的效果如何。在第3步中，我们使用`predict()`函数与模型以及我们没有用来训练的序列（即`test_set_indices`中的序列）进行预测，并返回一个预测对象。通过将预测结果传递给`evaluatePrediction()`函数，并结合类别向量中的实际类别和所有可能类别标签的向量（使用`allLabels`参数），我们可以得到模型的准确率和其他指标的摘要。这里模型的准确率是62%，这还算可以；比随机猜测要好。但我们数据集相对较小，且模型没有经过优化；如果做更多的工作，模型的表现可能会更好。请注意，如果你运行这段代码，可能会得到不同的结果。由于训练集序列的选择是随机的，模型的表现可能会略微变好或变差，取决于输入数据的具体内容。
- en: 'Estimate the prediction profile of a sequence: To actually find the regions
    that are important in classification, and presumably in the function of the protein,
    we use the `getPredictionProfile()` function on a sequence. We do this in step
    4 on a small 10 AA fragment extracted from the first sequence using list, double-bracket
    indexing to get the first sequence and single-bracket indexing to get a range;
    for example, `seqs[[1]][1:10]`. We do this simply for the clarity of the visualization
    in the last step. You can use whole sequences just as well. The `getPredictionProfile()` function
    needs the `kernel` and `model` objects to function. This will give the following
    output:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 估计序列的预测特征：为了实际找到在分类中重要的区域，可能也涉及蛋白质的功能，我们使用`getPredictionProfile()`函数来分析一个序列。在第四步中，我们用列表和双括号索引提取第一个序列的小片段（10个氨基酸），并用单括号索引获取范围；例如，`seqs[[1]][1:10]`。我们这样做是为了在最后一步中的可视化更清晰。你也可以直接使用完整的序列。`getPredictionProfile()`函数需要`kernel`和`model`对象才能正常工作。它将输出以下结果：
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we can `plot()` the prediction profile: The profile shows the contribution
    of each amino acid to the overall decision and adds to the interpretability of
    the learning results. Here, the fourth residue, **D**, makes a strong contribution
    to the decision made for this protein. By examining this across many sequences,
    the patterns contributing to the decision can be elucidated. It''s worth noting
    that you may get a slightly different picture to the one that follows—because
    of random processes in the algorithms—and its something you should build into
    your analyses: make sure that any apparent differences aren''t due to random choices
    made in the running of the code. The strongest contribution should still come
    from "D" in this example:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以`plot()`预测特征：该特征展示了每个氨基酸对整体决策的贡献，并增加了学习结果的可解释性。在这里，第四个残基**D**对该蛋白质的决策贡献非常大。通过在多个序列中检查这种贡献模式，可以阐明影响决策的模式。值得注意的是，你可能会看到与以下示例略有不同的图像——这是由于算法中的随机过程——这是你应纳入分析的一部分：确保任何显著差异不是由于运行代码时的随机选择造成的。在这个例子中，最强的贡献依然应来自于"D"：
- en: '![](img/2867de45-fb07-4dc4-a939-602caf4c417e.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2867de45-fb07-4dc4-a939-602caf4c417e.png)'
- en: 3D structure protein alignment with bio3d
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用bio3d进行3D结构蛋白质比对
- en: Three-dimensional structural alignments between two molecular models can reveal
    structural properties that are common or unique to either of the proteins. These
    can suggest evolutionary or functional commonalities. In this recipe, we'll look
    at how to get an alignment of two protein sequences in three dimensions and view
    them in 3D-rendering software.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 两个分子模型之间的三维结构比对可以揭示两种蛋白质共有或独特的结构特性。这些结构特性可能暗示着进化或功能上的共性。在本教程中，我们将展示如何在三维空间中对两个蛋白质序列进行比对，并在3D渲染软件中查看它们。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this section, we need at least two external pieces of software—PyMOL and
    MUSCLE—a 3D structure-rendering program and a sequence aligner.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节内容，我们至少需要两个外部软件——PyMOL和MUSCLE——一个是3D结构渲染程序，另一个是序列比对工具。
- en: 'MUSCLE can be installed with conda as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过conda安装MUSCLE，命令如下：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: A version of MUSCLE is installed with the `msa` package, and bio3d can be referred
    to that installation instead. We'll use the **msa** version in this recipe.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: MUSCLE的一个版本已经与`msa`包一起安装，并且bio3d可以引用这个安装版本。我们将在本教程中使用**msa**版本。
- en: 'PyMOL is absolutely necessary for visualization and can be installed with conda
    as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: PyMOL对于可视化至关重要，可以通过conda安装，命令如下：
- en: '[PRE57]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To find the install path for this software, use `which pymol`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找该软件的安装路径，可以使用`which pymol`命令。
- en: Beyond these, you'll need two files containing structures of human and fruit
    fly thioredoxins to work with: `datasets/ch3/1xwc.pdb` and `datasets/ch3/3trx.pdb`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，你还需要两个包含人类和果蝇硫氧还蛋白结构的文件来进行操作：`datasets/ch3/1xwc.pdb`和`datasets/ch3/3trx.pdb`。
- en: How to do it...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: '3D structure protein alignment with bio3d can be done using the following steps:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用bio3d进行3D结构蛋白质比对的步骤如下：
- en: 'Load the library and the PDB structure files:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载库和PDB结构文件：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, carry out the alignment of the structures:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，进行结构比对：
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Launch and render the alignment in PyMOL:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PyMOL中启动并渲染比对：
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As ever, the first steps are to load the library then the input data. Here,
    in step 1, we load two separate PDB files with the `read.pdb()` function. In step
    2, we do the alignment with the `pdbaln()` function. All the PDB objects we want
    to align are first put into a **list** object with the appropriate name. The `fit`
    argument is set to `TRUE` to carry out the superposition of the structures based
    on all the aligned sequences (the superposition being carried out is sequence-based).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，第一步是加载库，然后加载输入数据。这里在第 1 步，我们使用 `read.pdb()` 函数加载两个独立的 PDB 文件。在第 2 步，我们使用
    `pdbaln()` 函数进行对齐。所有我们想要对齐的 PDB 对象首先被放入一个适当命名的 **list** 对象中。`fit` 参数设置为 `TRUE`，以便基于所有对齐的序列执行结构叠加（执行的是基于序列的叠加）。
- en: The `exefile` argument tells `pdbaln()` where to carry out the sequence-based
    alignment portion, as done here; a value of `"msa"` uses the aligners in the **msa** package,
    but you can use a path to an alternative executable, or replace `exefile` with
    your valid email address using the `web.args="your.email@something.org"` form
    to carry out the alignment over the web at EBI.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`exefile` 参数告诉 `pdbaln()` 在哪里执行基于序列的对齐部分，如这里所示；`"msa"` 的值使用 **msa** 包中的对齐工具，但你也可以使用一个指向替代可执行文件的路径，或者将
    `exefile` 替换为你有效的电子邮件地址，使用 `web.args="your.email@something.org"` 这种形式在 EBI 上通过网络进行对齐。'
- en: 'Once we have an alignment object in `pdbs`, we can visualize it in PyMOL. We
    set the path to PyMOL in the `pymol_path` variable and pass that to the `pymol()` function
    along with the type set to `"launch"`, which will create an interactive PyMOL
    session. Alternatively, omitting `type` will result in a PyMOL script being written
    that you can use later. PyMol should show the picture that follows. The screengrab
    shows the rendering of the two aligned proteins: the human version in red and
    the fly version in yellow:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个 `pdbs` 中的对齐对象，就可以在 PyMOL 中可视化它。我们在 `pymol_path` 变量中设置 PyMOL 的路径，并将其与类型
    `"launch"` 一起传递给 `pymol()` 函数，这将创建一个交互式的 PyMOL 会话。或者，省略 `type` 参数将生成一个 PyMOL 脚本，稍后可以使用。PyMol
    应该会显示接下来的图片。截图显示了两种对齐蛋白质的渲染效果：人类版本为红色，果蝇版本为黄色。
- en: '![](img/1e6e656a-6628-4a81-acf7-c5ce4fa6debd.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e6e656a-6628-4a81-acf7-c5ce4fa6debd.png)'
- en: There's More...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `pdbaln()` function works well for structures of similar length. For structures
    with less equal PDBs, you can try the `struct.aln()` function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdbaln()` 函数对于长度相似的结构效果很好。对于那些 PDB 长度不相等的结构，你可以尝试 `struct.aln()` 函数。'
