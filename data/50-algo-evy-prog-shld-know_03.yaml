- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Data Structures Used in Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法中使用的数据结构
- en: Algorithms need in-memory data structures that can hold temporary data while
    executing. Choosing the right data structures is essential for their efficient
    implementation. Certain classes of algorithms are recursive or iterative in logic
    and need data structures that are specially designed for them. For example, a
    recursive algorithm may be more easily implemented, exhibiting better performance,
    if nested data structures are used. In this chapter, data structures are discussed
    in the context of algorithms. As we are using Python in this book, this chapter
    focuses on Python data structures, but the concepts presented in this chapter
    can be used in other languages such as Java and C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 算法在执行过程中需要内存数据结构来存储临时数据。选择合适的数据结构对于其高效实现至关重要。某些类别的算法逻辑是递归或迭代的，需要专门为它们设计的数据结构。例如，如果使用嵌套数据结构，递归算法可能会更容易实现，并展现更好的性能。本章讨论了数据结构在算法中的应用。由于本书使用
    Python，因此本章重点介绍 Python 数据结构，但本章中介绍的概念也适用于 Java 和 C++ 等其他语言。
- en: By the end of this chapter, you should be able to understand how Python handles
    complex data structures and which one should be used for a certain type of data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你应该能够理解 Python 如何处理复杂数据结构，以及应为某种类型的数据选择使用哪种数据结构。
- en: 'Here are the main points discussed in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的主要内容如下：
- en: Exploring Python built-in data types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Python 内置数据类型
- en: Using Series and DataFrames
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Series 和 DataFrames
- en: Exploring matrices and matrix operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索矩阵和矩阵运算
- en: Understanding abstract data types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解抽象数据类型
- en: Exploring Python built-in data types
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Python 内置数据类型
- en: 'In any language, data structures are used to store and manipulate complex data.
    In Python, data structures are storage containers for managing, organizing, and
    searching data in an efficient way. They are used to store a group of data elements
    called collections that need to be stored and processed together. In Python, the
    important data structures that can be used to store collections are summarized
    in *Table 2.1*:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何语言中，数据结构用于存储和操作复杂数据。在 Python 中，数据结构是用于高效管理、组织和查找数据的存储容器。它们用于存储一组称为集合的数据元素，这些数据元素需要一起存储和处理。在
    Python 中，用于存储集合的主要数据结构总结如下*表 2.1*：
- en: '| **Data Structure** | **Brief Explanation** | **Example** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **数据结构** | **简要说明** | **示例** |'
- en: '| List | An ordered, possibly nested, mutable sequence of elements | `["John",
    33,"Toronto", True]` |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | 有序的、可能嵌套的、可变的元素序列 | `["John", 33,"Toronto", True]` |'
- en: '| Tuple | An ordered immutable sequence of elements | `(''Red'',''Green'',''Blue'',''Yellow'')`
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 元组 | 有序的不可变元素序列 | `(''Red'',''Green'',''Blue'',''Yellow'')` |'
- en: '| Dictionary | An unordered collection of key-value pairs | `{''brand'': ''Apple'',
    ''color'': ''black''}` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 字典 | 无序的键值对集合 | `{''brand'': ''Apple'', ''color'': ''black''}` |'
- en: '| Set | An unordered collection of elements | `{''a'', ''b'', ''c''}` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | 无序的元素集合 | `{''a'', ''b'', ''c''}` |'
- en: 'Table 2.1: Python Data Structures'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1：Python 数据结构
- en: Let us look into them in more detail in the upcoming subsections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的子章节中更详细地了解它们。
- en: Lists
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: In Python, a list is the main data type used to store a mutable sequence of
    elements. The sequence of elements stored in the list need not be of the same
    type.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，列表是用于存储可变元素序列的主要数据类型。列表中存储的元素序列不必是相同类型的。
- en: 'A list can be defined by enclosing the elements in `[ ]` and they need to be
    separated by a comma. For example, the following code creates four data elements
    together that are of different types:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将元素放入 `[ ]` 中来定义列表，元素之间需要用逗号分隔。例如，以下代码将创建四个不同类型的元素：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In Python, a list is a handy way of creating one-dimensional writable data structures,
    which are especially needed at different internal stages of algorithms.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，列表是创建一维可写数据结构的便捷方式，这在算法的不同内部阶段尤其需要。
- en: Using lists
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表
- en: Utility functions in data structures make them very useful as they can be used
    to manage data in lists.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构中的实用函数使其非常有用，因为它们可以用来管理列表中的数据。
- en: 'Let’s look into how we can use them:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何使用它们：
- en: '**List indexing**: As the position of an element is deterministic in a list,
    the index can be used to get an element at a particular position. The following
    code demonstrates the concept:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表索引**：由于列表中元素的位置是确定的，因此可以使用索引来获取特定位置的元素。以下代码演示了这个概念：'
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The four-element list created by this code is shown in *Figure 2.1*:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由这段代码创建的四元素列表显示在*图 2.1*中：
- en: '![Diagram  Description automatically generated](img/B18046_02_01.png)'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图表 描述自动生成](img/B18046_02_01.png)'
- en: 'Figure 2.1: A four-element list in Python'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.1：Python 中的四元素列表
- en: 'Now, we will run the code:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们将运行以下代码：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that Python is a zero-indexing language. This means that the initial index
    of any data structure, including lists, will be `0`. `Green`, which is the second
    element, is retrieved by index `1` – that is, `bin_colors[1]`.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，Python 是一个零索引语言。这意味着任何数据结构（包括列表）的初始索引为 `0`。`Green`，即第二个元素，可以通过索引 `1` 获取——即
    `bin_colors[1]`。
- en: '**List slicing**: Retrieving a subset of the elements of a list by specifying
    a range of indexes is called **slicing**. The following code can be used to create
    a slice of the list:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表切片**：通过指定索引范围来获取列表的子集，称为 **切片**。可以使用以下代码创建列表的切片：'
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that lists are one of the most popular single-dimensional data structures
    in Python.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，列表是 Python 中最流行的单维数据结构之一。
- en: 'While slicing a list, the range is indicated as follows: the first number (inclusive)
    and the second number (exclusive). For example, `bin_colors[0:2]` will include
    `bin_color[0]` and `bin_color[1]` but not `bin_color[2]`. While using lists, this
    should be kept in mind, as some users of the Python language complain that this
    is not very intuitive.'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在切片列表时，范围表示如下：第一个数字（包含）和第二个数字（不包含）。例如，`bin_colors[0:2]` 会包括 `bin_color[0]` 和
    `bin_color[1]`，但不包括 `bin_color[2]`。在使用列表时，应该记住这一点，因为一些 Python 用户抱怨这不太直观。
- en: 'Let’s have a look at the following code snippet:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们来看一下以下代码片段：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the starting index is not specified, it means the beginning of the list,
    and if the ending index is not specified, it means the end of the list, as demonstrated
    by the preceding code.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有指定起始索引，则表示列表的开头；如果没有指定结束索引，则表示列表的结尾，正如前面的代码所示。
- en: '**Negative indexing**: In Python, we also have negative indices, which count
    from the end of the list. This is demonstrated in the following code:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负索引**：在 Python 中，我们也可以使用负索引，它是从列表的末尾开始计数的。以下代码演示了这一点：'
- en: '[PRE11]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that negative indices are especially useful when we want to use the last
    element as a reference point instead of the first one.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，负索引在我们想要使用最后一个元素作为参考点而不是第一个元素时尤其有用。
- en: '**Nesting**: An element of a list can be of any data type. This allows nesting
    in lists. For iterative and recursive algorithms, this provides important capabilities.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套**：列表中的元素可以是任何数据类型。这允许列表中嵌套其他列表。对于迭代和递归算法，这提供了重要的功能。'
- en: 'Let’s have a look at the following code, which is an example of a list within
    a list (nesting):'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们来看一下以下代码，这是一个包含列表中的列表（嵌套）示例：
- en: '[PRE17]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Iteration**: Python allows iterating over each element on a list by using
    a `for` loop. This is demonstrated in the following example:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代**：Python 允许通过 `for` 循环对列表中的每个元素进行迭代。以下示例演示了这一点：'
- en: '[PRE21]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the preceding code iterates through the list and prints each element.
    Now let us remove the last element from the stack using `pop()` function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的代码通过列表迭代并打印每个元素。现在让我们使用 `pop()` 函数从栈中删除最后一个元素。
- en: 'Modifying lists: append and pop operations'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改列表：append 和 pop 操作
- en: Let’s take a look at modifying some lists, including the append and pop operations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看修改一些列表，包括 append 和 pop 操作。
- en: Adding elements with append()
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 append() 添加元素
- en: 'When you want to insert a new item at the end of a list, you employ the `append()`
    method. It works by adding the new element to the nearest available memory slot.
    If the list is already at full capacity, Python extends the memory allocation,
    replicates the previous items in this newly carved out space, and then slots in
    the new addition:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要在列表末尾插入新项时，可以使用 `append()` 方法。它的工作原理是将新元素添加到最近的可用内存位置。如果列表已满，Python 会扩展内存分配，在新开辟的空间中复制之前的项，然后插入新元素：
- en: '[PRE23]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Removing elements with pop()
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 pop() 删除元素
- en: 'To extract an element from the list, particularly the last one, the `pop()`
    method is a handy tool. When invoked, this method extracts the specified item
    (or the last item if no index is given). The elements situated after the popped
    item get repositioned to maintain memory continuity:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要从列表中提取元素，特别是最后一个元素，`pop()` 方法是一个方便的工具。调用该方法时，它会提取指定的项目（如果未给出索引，则提取最后一个项目）。被弹出项后面的元素会重新定位，以保持内存的连续性：
- en: '[PRE25]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The range() function
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: range() 函数
- en: The `range()` function can be used to easily generate a large list of numbers.
    It is used to auto-populate sequences of numbers in a list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()` 函数可以用来轻松生成大量数字列表。它被用来自动填充数字序列到列表中。'
- en: 'The `range()` function is simple to use. We can use it by just specifying the
    number of elements we want in the list. By default, it starts from zero and increments
    by one:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()` 函数使用起来非常简单。我们只需指定列表中所需的元素个数。默认情况下，它从零开始，并以1递增：'
- en: '[PRE27]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can also specify the end number and the step:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定结束数字和步长：
- en: '[PRE29]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding range function will give us odd numbers from `3` to `29`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `range()` 函数将返回从 `3` 到 `29` 的奇数。
- en: 'To iterate through a list, we can use the `for` function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历列表，我们可以使用 `for` 函数：
- en: '[PRE31]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can use the `range()` function to generate a list of random numbers. For
    example, to simulate ten trials of a dice, we can use the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `range()` 函数生成一个随机数字列表。例如，模拟十次掷骰子的实验可以使用以下代码：
- en: '[PRE33]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The time complexity of lists
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表的时间复杂度
- en: 'The time complexity of various functions of a list can be summarized as follows
    using the Big O notation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表各个函数的时间复杂度可以用大 O 符号总结如下：
- en: '**Inserting an element**: The insertion of an element at the end of a list
    typically has a constant time complexity, denoted as *O(1)*. This means the time
    taken for this operation remains fairly consistent, irrespective of the list’s
    size.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入元素**：在列表末尾插入一个元素通常具有常数时间复杂度，记作 *O(1)*。这意味着该操作所需的时间相对稳定，与列表的大小无关。'
- en: '**Deleting an element**: Deleting an element from a list can have a time complexity
    of *O(n)* in its worst-case scenario. This is because, in the least favorable
    situation, the program might need to traverse the entire list before removing
    the desired element.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除元素**：从列表中删除元素在最坏情况下的时间复杂度为 *O(n)*。这是因为在最不利的情况下，程序可能需要遍历整个列表才能删除目标元素。'
- en: '**Slicing**: When we slice a list or extract a portion of it, the operation
    can take time proportional to the size of the slice; hence, its time complexity
    is *O(n)*.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切片**：当我们切割列表或提取其中一部分时，该操作可能需要的时间与切片的大小成正比；因此，它的时间复杂度是 *O(n)*。'
- en: '**Element retrieval**: Finding an element within a list, without any indexing,
    can require scanning through all its elements in the worst case. Thus, its time
    complexity is also *O(n)*.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素检索**：在没有索引的情况下查找列表中的元素，最坏情况下可能需要扫描所有元素。因此，它的时间复杂度也是 *O(n)*。'
- en: '**Copying**: Creating a copy of the list necessitates visiting every element
    once, leading to a time complexity of *O(n)*.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制**：创建列表的副本需要访问每个元素一次，导致时间复杂度为 *O(n)*。'
- en: Tuples
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: The second data structure that can be used to store a collection is a tuple.
    In contrast to lists, tuples are immutable (read-only) data structures. Tuples
    consist of several elements surrounded by `( )`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以用来存储集合的数据结构是元组。与列表不同，元组是不可变（只读）的数据结构。元组由多个元素组成，这些元素被 `( )` 括起来。
- en: Like lists, elements within a tuple can be of different types. They also allow
    their elements to be complex data types. So, there can be a tuple within a tuple
    providing a way to create a nested data structure. The capability to create nested
    data structures is especially useful in iterative and recursive algorithms.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 和列表一样，元组中的元素可以是不同类型的。它们还允许元素是复杂数据类型。因此，可以在元组中嵌套元组，从而创建嵌套的数据结构。创建嵌套数据结构的能力在迭代和递归算法中尤其有用。
- en: 'The following code demonstrates how to create tuples:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何创建元组：
- en: '[PRE35]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Wherever possible, immutable data structures (such as tuples) should be preferred
    over mutable data structures (such as lists) due to performance. Especially when
    dealing with big data, immutable data structures are considerably faster than
    mutable ones. When a data structure is passed to a function as immutable, its
    copy does not need to be created as the function cannot change it. So, the output
    can refer to the input data structure. This is called referential transparency
    and improves the performance. There is a price we pay for the ability to change
    data elements in lists and we should carefully analyze whether it is really needed
    so we can implement the code as read-only tuples, which will be much faster.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，应该优先选择不可变数据结构（如元组）而非可变数据结构（如列表），因为不可变数据结构的性能更好。尤其是在处理大数据时，不可变数据结构比可变数据结构要快得多。当一个数据结构作为不可变的传递给函数时，无需创建其副本，因为函数不能修改它。因此，输出可以直接引用输入数据结构。这被称为引用透明性，可以提高性能。我们为了能够修改列表中的数据元素，付出了代价，因此我们应仔细分析是否真的需要修改，以便将代码实现为只读元组，这样会更快。
- en: Note that, as Python is a zero-index-based language, `a[2]` refers to the third
    element, which is a tuple, `(100,200,300)`, and `a[2][1]` refers to the second
    element within this tuple, which is `200`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于 Python 是基于零索引的语言，`a[2]` 指的是第三个元素，它是一个元组 `(100,200,300)`，而 `a[2][1]` 指的是该元组中的第二个元素，它是
    `200`。
- en: The time complexity of tuples
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组的时间复杂度
- en: 'The time complexity of various functions of tuples can be summarized as follows
    (using Big O notation):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 元组各种函数的时间复杂度可以总结如下（使用大O表示法）：
- en: '**Accessing an element**: Tuples allow direct access to their elements via
    indexing. This operation is constant time, *O(1)*, meaning the time taken remains
    consistent regardless of the tuple’s size.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问元素**：元组通过索引允许直接访问其元素。这个操作是常数时间，*O(1)*，意味着无论元组的大小如何，所需的时间保持一致。'
- en: '**Slicing**: When a portion of a tuple is extracted or sliced, the operation’s
    efficiency is proportional to the size of the slice, resulting in a time complexity
    of *O(n)*.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切片**：当提取或切片元组的一部分时，操作的效率与切片的大小成正比，结果的时间复杂度是 *O(n)*。'
- en: '**Element retrieval**: Searching for an element in a tuple, in the absence
    of any indexing aid, might require traversing all its elements in the worst-case
    scenario. Hence, its time complexity is *O(n)*.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素检索**：在没有任何索引帮助的情况下，查找元组中的一个元素，在最坏的情况下可能需要遍历所有元素。因此，它的时间复杂度是 *O(n)*。'
- en: '**Copying**: Duplicating a tuple, or creating its copy, requires iterating
    through each element once, giving it a time complexity of *O(n)*.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制**：复制一个元组，或者创建其副本，需要遍历每个元素一次，因此它的时间复杂度是 *O(n)*。'
- en: Dictionaries and sets
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典与集合
- en: In this section, we will discuss sets and dictionaries, which are used to store
    data in which there is no explicit or implicit ordering. Both dictionaries and
    sets are quite similar. The difference is that a dictionary has a key-value pair.
    A set can be thought of as a collection of unique keys.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论集合和字典，它们用于存储没有显式或隐式顺序的数据。字典和集合非常相似。区别在于字典包含键值对，而集合可以看作是一个唯一键的集合。
- en: Let us look into them one by one.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解它们。
- en: Dictionaries
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: Holding data as key-value pairs is important, especially in distributed algorithms.
    In Python, a collection of these key-value pairs is stored as a data structure
    called a dictionary. To create a dictionary, a key should be chosen as an attribute
    that is best suited to identify data throughout data processing. The limitation
    on the value of keys is that they must be hashable types. A hashable is the type
    of object on which we can run the hash function, generating a hash code that never
    changes during its lifetime. This ensures that the keys are unique and searching
    for a key is fast. Numeric types and flat immutable types are all hashable and
    are good choices for the dictionary keys. The value can be an element of any type,
    for example, a number or string. Python also always uses complex data types such
    as lists as values. Nested dictionaries can be created by using a dictionary as
    the data type of a value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据作为键值对存储非常重要，尤其是在分布式算法中。在 Python 中，这些键值对集合被存储为一种名为字典的数据结构。要创建字典，应该选择一个最适合在数据处理过程中标识数据的属性作为键。键值的限制是它们必须是可哈希类型。可哈希类型是可以运行哈希函数的对象类型，该函数生成的哈希码在对象生命周期内保持不变。这确保了键的唯一性，并且搜索键的速度很快。数值类型和扁平不可变类型都是可哈希的，是字典键的良好选择。值可以是任何类型的元素，例如数字或字符串。Python
    还经常使用复杂数据类型，如列表，作为值。可以通过使用字典作为值的数据类型来创建嵌套字典。
- en: 'To create a simple dictionary that assigns colors to various variables, the
    key-value pairs need to be enclosed in `{ }`. For example, the following code
    creates a simple dictionary consisting of three key-value pairs:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个简单的字典，将颜色分配给各种变量，键值对需要用 `{ }` 括起来。例如，以下代码创建了一个由三个键值对组成的简单字典：
- en: '[PRE41]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The three key-value pairs created by the preceding piece of code are also illustrated
    in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由前面的代码创建的三个键值对在下面的截图中也有展示：
- en: '![Diagram  Description automatically generated](img/B18046_02_02.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![Diagram  Description automatically generated](img/B18046_02_02.png)'
- en: 'Figure 2.2: Key-value pairs in a simple dictionary'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：简单字典中的键值对
- en: 'Now, let’s see how to retrieve and update a value associated with a key:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何检索和更新与某个键相关联的值：
- en: 'To retrieve a value associated with a key, either the `get` function can be
    used or the key can be used as the index:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检索与某个键相关联的值，可以使用`get`函数，或者将键作为索引：
- en: '[PRE43]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To update a value associated with a key, use the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新与某个键相关联的值，使用以下代码：
- en: '[PRE47]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that the preceding code shows how we can update a value related to a particular
    key in a dictionary.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的代码展示了如何更新字典中与特定键相关联的值。
- en: 'When iterating through a dictionary, usually, we will need both the keys and
    the values. We can iterate through a dictionary in Python by using `.items()`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当遍历字典时，通常我们需要同时获取键和值。我们可以通过使用`.items()`来遍历字典：
- en: '[PRE49]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To `del` an element from a dictionary, we will use the `del` function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中`del`一个元素，我们将使用`del`函数：
- en: '[PRE51]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The time complexity of a dictionary
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字典的时间复杂度
- en: 'For Python dictionaries, the time complexities for various operations are listed
    here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 字典，各种操作的时间复杂度如下：
- en: '**Accessing a value by key**: Dictionaries are designed for fast look-ups.
    When you have the key, accessing the corresponding value is, on average, a constant
    time operation, *O(1)*. This holds true unless there’s a hash collision, which
    is a rare scenario.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过键访问值**：字典设计用于快速查找。当你有了键，访问对应的值通常是一个常数时间操作，*O(1)*。除非发生哈希冲突，这是一种罕见的情况，否则通常成立。'
- en: '**Inserting a key-value pair**: Adding a new key-value pair is generally a
    swift operation with a time complexity of *O(1)*.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入键值对**：添加一个新的键值对通常是一个快速的操作，时间复杂度为*O(1)*。'
- en: '**Deleting a key-value pair**: Removing an entry from a dictionary, when the
    key is known, is also an *O(1)* operation on average.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除键值对**：当已知键时，从字典中移除条目，平均来说也是一个*O(1)*操作。'
- en: '**Searching for a key**: Verifying the presence of a key, thanks to hashing
    mechanisms, is usually a constant time, *O(1)*, operation. However, worst-case
    scenarios could elevate this to *O(n)*, especially with many hash collisions.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查找键**：由于哈希机制，验证键的存在通常是一个常数时间*O(1)*操作。然而，最坏情况下可能会将其提高到*O(n)*，特别是在有大量哈希冲突时。'
- en: '**Copying**: Creating a duplicate of a dictionary necessitates going through
    each key-value pair, resulting in a linear time complexity, *O(n)*.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制**：创建字典的副本需要遍历每个键值对，因此时间复杂度为线性*O(n)*。'
- en: Sets
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: 'Closely related to a dictionary is a set, which is defined as an unordered
    collection of distinct elements that can be of different types. One of the ways
    to define a set is to enclose the values in `{ }`. For example, have a look at
    the following code block:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与字典紧密相关的是集合，集合被定义为一个无序的、由不同类型的元素组成的独特元素集合。定义集合的一种方法是将值包裹在`{ }`中。例如，请看下面的代码块：
- en: '[PRE53]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The defining characteristic of a set is that it only stores the distinct value
    of each element. If we try to add another redundant element, it will ignore that,
    as illustrated in the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的定义特征是它只存储每个元素的唯一值。如果我们试图添加另一个冗余元素，集合会忽略它，如下所示：
- en: '[PRE55]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To demonstrate what sort of operations can be done on sets, let’s define two
    sets:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示可以对集合进行哪些操作，让我们定义两个集合：
- en: A set named `yellow`, which has things that are yellow
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`yellow`的集合，包含所有黄色的元素
- en: A set named `red`, which has things that are red
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`red`的集合，包含所有红色的元素
- en: 'Note that some things are common between these two sets. The two sets and their
    relationship can be represented with the help of the following Venn diagram:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个集合之间有一些共同的元素。这两个集合及其关系可以通过以下Venn图来表示：
- en: '![Diagram, venn diagram  Description automatically generated](img/B18046_02_03.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图示，Venn图  描述自动生成](img/B18046_02_03.png)'
- en: 'Figure 2.3: Venn diagram showing how elements are stored in sets'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：展示元素如何存储在集合中的Venn图
- en: 'If we want to implement these two sets in Python, the code will look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在Python中实现这两个集合，代码将如下所示：
- en: '[PRE57]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, let’s consider the following code, which demonstrates set operations using
    Python:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑以下代码，展示了如何使用Python进行集合操作：
- en: '[PRE58]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As shown in the preceding code snippet, sets in Python can have operations
    such as unions and intersections. As we know, a union operation combines all of
    the elements of both sets, and the intersection operation will give a set of common
    elements between the two sets. Note the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，Python中的集合可以执行如并集和交集等操作。我们知道，合并操作将两个集合中的所有元素合并，而交集操作将返回两个集合之间的共同元素。注意以下几点：
- en: '`yellow|red` is used to get the union of the preceding two defined sets.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yellow|red`用于获取前面定义的两个集合的并集。'
- en: '`yellow&red` is used to get the overlap between yellow and red.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yellow&red`用于获取黄色和红色之间的重叠部分。'
- en: As sets are unordered, the items of a set have no index. That means that we
    cannot access the items by referring to an index.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合是无序的，集合的元素没有索引。这意味着我们不能通过索引来访问元素。
- en: 'We can loop through the set items using a `for` loop:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`for`循环遍历集合中的元素：
- en: '[PRE62]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We can also check if a specified value is present in a set by using the `in`
    keyword.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用`in`关键字检查指定的值是否存在于集合中。
- en: '[PRE64]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Time complexity analysis for sets
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合的时间复杂度分析
- en: 'The following is the time complexity analysis for sets:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是集合的时间复杂度分析：
- en: '| **Sets** | **Complexity** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **集合** | **复杂度** |'
- en: '| Add an element | `O(1)` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 添加一个元素 | `O(1)` |'
- en: '| Remove an element | `O(1)` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 移除一个元素 | `O(1)` |'
- en: '| Copy | `O(n)` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 复制 | `O(n)` |'
- en: 'Table 2.2: Time complexity for sets'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2：集合的时间复杂度
- en: When to use a dictionary and when to use a set
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么时候使用字典，什么时候使用集合
- en: 'Let us assume that we are looking for a data structure for our phone book.
    We want to store the phone numbers of the employees of a company. For this purpose,
    a dictionary is the right data structure. The name of each employee will be the
    key and the value will be the phone number:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在寻找一个数据结构来存储我们的电话簿。我们希望存储公司员工的电话号码。为此，字典是正确的数据结构。每个员工的名字将是键，值将是电话号码：
- en: '[PRE66]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'But if we want to store only the unique value of the employees, then that should
    be done using sets:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们只想存储员工的唯一值，那么应该使用集合来完成：
- en: '[PRE67]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Using Series and DataFrames
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Series和DataFrame
- en: Processing data is one of the core things that need to be done while implementing
    most of the algorithms. In Python, data processing is usually done by using various
    functions and data structures of the `pandas` library.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据是实现大多数算法时需要做的核心工作之一。在Python中，数据处理通常通过使用`pandas`库的各种函数和数据结构来完成。
- en: 'In this section, we will look into the following two important data structures
    of the pandas library, which will be used to implement various algorithms later
    in this book:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入了解pandas库中的以下两个重要数据结构，这些数据结构将在本书后续部分中用于实现各种算法：
- en: '**Series**: A one-dimensional array of values'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Series**：一维数组'
- en: '**DataFrame**: A two-dimensional data structure used to store tabular data'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据框（DataFrame）**：一种二维数据结构，用于存储表格数据'
- en: Let us look into the Series data structure first.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解序列数据结构。
- en: Series
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列（Series）
- en: In the `pandas` library, a Series is a one-dimensional array of values for homogenous
    data. We can think of a Series as a single column in a spreadsheet. We can think
    of Series as holding various values of a particular variable.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pandas`库中，序列（Series）是一个一维的同质数据数组。我们可以将序列视为电子表格中的一列。我们可以认为序列保存了某一变量的各种值。
- en: 'A Series can be defined as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 序列（Series）可以按如下方式定义：
- en: '[PRE68]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note that in `pandas` Series-based data structures, there is a term called “axis,”
    which is used to represent a sequence of values in a particular dimension. *Series*
    has only “axis 0” because it has only one dimension. We will see how this axis
    concept is applied to a DataFrame in the next section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`pandas`基于序列的数据结构中，有一个术语叫做“轴（axis）”，它表示某一维度中的值的序列。*Series* 只有“轴 0”，因为它只有一个维度。在下一节中，我们将看到这个轴的概念如何应用于数据框（DataFrame）。
- en: DataFrame
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据框（DataFrame）
- en: 'A DataFrame is built upon the Series data structure. It is stored as two-dimensional
    tabular data. It is used to process traditional structured data. Let’s consider
    the following table:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框（DataFrame）是基于序列数据结构构建的。它以二维表格数据形式存储，用于处理传统的结构化数据。我们来考虑一下以下表格：
- en: '| **id** | **name** | **age** | **decision** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **id** | **name** | **age** | **decision** |'
- en: '| 1 | Fares | 32 | True |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Fares | 32 | True |'
- en: '| 2 | Elena | 23 | False |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Elena | 23 | False |'
- en: '| 3 | Doug | 40 | True |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Doug | 40 | True |'
- en: Now, let’s represent this using a DataFrame.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用数据框来表示这个数据。
- en: 'A simple DataFrame can be created by using the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下代码创建一个简单的数据框：
- en: '[PRE70]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that, in the preceding code, `df.column` is a list that specifies the names
    of the columns. In DataFrame, a single column or row is called an axis.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的代码中，`df.column`是一个列出列名的列表。在数据框中，单独的一列或一行称为轴（axis）。
- en: DataFrames are also used in other popular languages and frameworks to implement
    a tabular data structure. Examples are R and the Apache Spark framework.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框（DataFrame）也在其他流行的编程语言和框架中用于实现表格数据结构。例如，R语言和Apache Spark框架。
- en: Creating a subset of a DataFrame
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建数据框（DataFrame）的子集
- en: 'Fundamentally, there are two main ways of creating the subset of a DataFrame:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上讲，创建数据框子集的方式有两种主要方法：
- en: Column selection
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列选择
- en: Row selection
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行选择
- en: Let’s look at them one by one.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解它们。
- en: Column selection
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列选择
- en: In machine learning algorithms, selecting the right set of features is an important
    task. Out of all of the features that we may have, not all of them may be needed
    at a particular stage of the algorithm. In Python, feature selection is achieved
    by column selection, which is explained in this section.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习算法中，选择合适的特征集是一个重要的任务。在我们可能拥有的所有特征中，并不是每一个在算法的某个特定阶段都是必要的。在 Python 中，特征选择是通过列选择来实现的，这一点将在本节中讲解。
- en: 'A column may be retrieved by `name`, as in the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`name`来获取某一列，如下所示：
- en: '[PRE72]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The positioning of a column is deterministic in a DataFrame. A column can be
    retrieved by its position, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框中列的位置是确定的。可以通过位置来获取列，如下所示：
- en: '[PRE74]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note that, in this code, we are retrieving all rows of the DataFrame.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这段代码中，我们正在获取数据框的所有行。
- en: Row selection
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 行选择
- en: 'Each row in a DataFrame corresponds to a data point in our problem space. We
    need to perform row selection if we want to create a subset of the data elements
    that we have in our problem space. This subset can be created by using one of
    the two following methods:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框中的每一行对应我们问题空间中的一个数据点。如果我们想创建问题空间中的数据元素子集，就需要进行行选择。这个子集可以通过以下两种方法之一来创建：
- en: By specifying their position
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定它们的位置
- en: By specifying a filter
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定过滤条件
- en: 'A subset of rows can be retrieved by its position, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过行的位置来获取子集，方法如下：
- en: '[PRE76]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that the preceding code will return the second and third rows plus all
    columns. It uses the `iloc` method, which allows us to access the elements by
    their numerical index.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的代码将返回第二行和第三行以及所有列。它使用`iloc`方法，可以通过数值索引访问元素。
- en: 'To create a subset by specifying the filter, we need to use one or more columns
    to define the selection criterion. For example, a subset of data elements can
    be selected by this method, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过指定过滤条件来创建子集，我们需要使用一个或多个列来定义选择标准。例如，可以通过以下方法选择数据元素的子集：
- en: '[PRE78]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note that this code creates a subset of rows that satisfies the condition stipulated
    in the filter.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码创建了一个符合筛选条件的行子集。
- en: Time complexity analysis for sets
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集合的时间复杂度分析
- en: Let’s unveil the time complexities of some fundamental DataFrame operations.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们揭示一些基础 DataFrame 操作的时间复杂度。
- en: Selection operations
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择操作
- en: '**Column selection**: Accessing a DataFrame column, often done using the bracket
    notation or dot notation (for column names without spaces), is an *O(1)* operation.
    It offers a quick reference to the data without copying.'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择列**：访问 DataFrame 列，通常使用括号符号或点符号（对于没有空格的列名）进行，是一个 *O(1)* 操作。它提供了对数据的快速引用，而无需复制。'
- en: '**Row selection**: Using methods like `.loc[]` or `.iloc[]` to select rows,
    especially with slicing, has a time complexity of *O(n)*, where “*n*” represents
    the number of rows you’re accessing.'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择行**：使用 `.loc[]` 或 `.iloc[]` 等方法选择行，特别是在切片的情况下，时间复杂度是 *O(n)*，其中“*n*”代表你正在访问的行数。'
- en: Insertion operations
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入操作
- en: '**Column insertion**: Appending a new column to a DataFrame is typically an
    *O(1)* operation. However, the actual time can vary depending on the data type
    and size of the data being added.'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入列**：向 DataFrame 添加新列通常是一个 *O(1)* 操作。然而，实际时间可能会根据数据类型和添加的数据大小而有所不同。'
- en: '**Row insertion**: Adding rows using methods like `.append()` or `.concat()`
    can result in an *O(n)* complexity since it often requires rearranging and reallocation.'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入行**：使用 `.append()` 或 `.concat()` 等方法添加行可能会导致 *O(n)* 复杂度，因为它通常需要重新排列和重新分配内存。'
- en: Deletion operations
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除操作
- en: '**Column deletion**: Dropping a column from a DataFrame, facilitated by the
    `.drop()` method, is an *O(1)* operation. It marks the column for garbage collection
    rather than immediate deletion.'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除列**：通过 `.drop()` 方法从 DataFrame 中删除一列是一个 *O(1)* 操作。它标记该列为垃圾回收对象，而不是立即删除。'
- en: '**Row deletion**: Similar to row insertion, row deletion can lead to an *O(n)*
    time complexity, as the DataFrame has to rearrange its structure.'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除行**：与插入行类似，删除行也可能导致 *O(n)* 时间复杂度，因为 DataFrame 需要重新排列其结构。'
- en: Matrices
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵
- en: A matrix is a two-dimensional data structure with a fixed number of columns
    and rows. Each element of a matrix can be referred to by its column and the row.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是一个具有固定列数和行数的二维数据结构。矩阵的每个元素可以通过其列和行来引用。
- en: 'In Python, a matrix can be created by using a `numpy` array or a list. But
    `numpy` arrays are much faster than lists because they are collections of homogenous
    data elements located in a contiguous memory location. The following code can
    be used to create a matrix from a `numpy` array:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，可以通过使用 `numpy` 数组或列表来创建矩阵。但 `numpy` 数组比列表要快得多，因为它们是位于连续内存位置的同质数据元素集合。以下代码可以用来从
    `numpy` 数组创建矩阵：
- en: '[PRE82]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Note that the preceding code will create a matrix that has three rows and three
    columns.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的代码将创建一个具有三行三列的矩阵。
- en: Matrix operations
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩阵操作
- en: 'There are many operations available for matrix data manipulation. For example,
    let’s try to transpose the preceding matrix. We will use the `transpose()` function,
    which will convert columns into rows and rows into columns:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用于矩阵数据操作的操作。例如，我们尝试转置前面的矩阵。我们将使用 `transpose()` 函数，该函数将列转换为行，行转换为列：
- en: '[PRE86]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note that matrix operations are used a lot in multimedia data manipulation.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，矩阵操作在多媒体数据处理过程中被广泛使用。
- en: Big O notation and matrices
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大 O 符号与矩阵
- en: 'When discussing the efficiency of operations, the Big O notation provides a
    high-level understanding of its impact as data scales:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论操作的效率时，大 O 符号提供了对数据规模扩展时影响的高层次理解：
- en: '**Access**: Accessing an element, whether in a Python list or a `numpy` array,
    is a constant time operation, *O(1)*. This is because, with the index of the element,
    you can directly access it.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：无论是在 Python 列表还是 `numpy` 数组中，访问元素都是一个常数时间操作，*O(1)*。这是因为，通过元素的索引，你可以直接访问它。'
- en: '**Appending**: Appending an element at the end of a Python list is an average-case
    *O(1)* operation. However, for a numpy array, the operation can be *O(n)* in the
    worst case, as the entire array might need to be copied to a new memory location
    if there’s no contiguous space available.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追加**：将元素追加到 Python 列表的末尾是一个平均情况下的 *O(1)* 操作。然而，对于 `numpy` 数组，在最坏情况下，这个操作可能是
    *O(n)*，因为如果没有足够的连续空间，整个数组可能需要被复制到新的内存位置。'
- en: '**Matrix multiplication**: This is where numpy shines. Matrix multiplication
    can be computationally intensive. Traditional methods can have a time complexity
    of *O(n*³*)* for *n x n* matrices. However, `numpy` uses optimized algorithms,
    like the Strassen algorithm, which reduces this significantly.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩阵乘法**：这是 numpy 的强项。矩阵乘法可能会非常耗费计算资源。传统方法对于 *n x n* 矩阵的时间复杂度为 *O(n³)*。然而，`numpy`
    使用了优化算法，如 Strassen 算法，这大大降低了计算复杂度。'
- en: Now that we have learned about data structures in Python, let’s move on to abstract
    data types in the next section.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了 Python 中的数据结构，接下来让我们在下一部分讨论抽象数据类型。
- en: Exploring abstract data types
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索抽象数据类型
- en: '**Abstract data types** (**ADTs**) are high-level abstractions whose behavior
    is defined by a set of variables and a set of related operations. ADTs define
    the implementation guidance of “what” needs to be expected but give the programmer
    freedom in “how” it will be exactly implemented. Examples are vectors, queues,
    and stacks. This means that two different programmers can take two different approaches
    to implementing an ADT, like a stack. By hiding the implementation level details
    and giving the user a generic, implementation-independent data structure, the
    use of ADTs creates algorithms that result in simpler and cleaner code. ADTs can
    be implemented in any programming language, such as C++, Java, and Scala. In this
    section, we shall implement ADTs using Python. Let’s start with vectors first.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象数据类型**（**ADT**）是通过一组变量和一组相关操作来定义行为的高级抽象。ADT 定义了“需要期待什么”的实现指导，但给程序员在“如何实现”的细节上提供自由。例如，向量、队列和栈就是
    ADT。意味着两个不同的程序员可以采用不同的方式来实现一个 ADT，比如栈。通过隐藏实现细节，并给用户提供一个通用、与实现无关的数据结构，ADT 的使用可以创建出更简洁和更清晰的代码。ADT
    可以在任何编程语言中实现，如 C++、Java 和 Scala。本节中，我们将使用 Python 实现 ADT。让我们首先从向量开始。'
- en: Vector
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量
- en: 'A vector is a single-dimension structure for storing data. They are one of
    the most popular data structures in Python. There are two ways of creating vectors
    in Python, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是存储数据的单一维度结构。它们是 Python 中最常见的数据结构之一。创建向量有两种方法，如下所示：
- en: '**Using a Python list**: The simplest way to create a vector is by using a
    Python list, as follows:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Python 列表**：创建一个向量的最简单方法是使用 Python 列表，如下所示：'
- en: '[PRE88]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note that this code will create a list with four elements.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码将创建一个包含四个元素的列表。
- en: '**Using a numpy array**: Another popular way to create a vector is to use `numpy`
    arrays. `numpy` arrays are generally faster and more memory-efficient than Python
    lists, especially for operations that involve large amounts of data. This is because
    `numpy` is designed to work with homogenous data and can take advantage of low-level
    optimizations. A `numpy` array can be implemented as follows:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 numpy 数组**：另一种创建向量的流行方法是使用 `numpy` 数组。`numpy` 数组通常比 Python 列表更快，且内存效率更高，尤其是在处理大量数据的操作时。这是因为
    `numpy` 设计上是为了处理同质数据，并且可以利用底层优化。`numpy` 数组可以通过如下方式实现：'
- en: '[PRE92]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Note that we created `myVector` using `np.array` in this code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这段代码中使用 `np.array` 创建了 `myVector`。
- en: In Python, we can represent integers using underscores to separate parts. This
    makes them more readable and less error-prone. This is especially useful when
    dealing with large numbers. So, one billion can be represented as `1000_000_000`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们可以使用下划线来分隔整数的各个部分。这使得它们更易于阅读并且减少了出错的可能性，特别是在处理大数字时。这对于表示十亿非常有用，可以写作
    `1000_000_000`。
- en: '[PRE96]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Time complexity of vectors
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量的时间复杂度
- en: 'When discussing the efficiency of vector operations, it’s vital to understand
    the time complexity:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论向量操作的效率时，理解时间复杂度是至关重要的：
- en: '**Access**: Accessing an element in both a Python list and a `numpy` array
    (vector) takes constant time, *O(1)*. This ensures rapid data retrieval.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：在 Python 列表和 `numpy` 数组（向量）中访问元素都需要常量时间 *O(1)*。这确保了数据的快速检索。'
- en: '**Appending**: Appending an element to a Python list has an average time complexity
    of *O(1)*. However, for a numpy array, appending could take up to *O(n)* in the
    worst case since numpy arrays require contiguous memory locations.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追加**：向 Python 列表追加一个元素的平均时间复杂度为 *O(1)*。然而，对于 `numpy` 数组，追加操作在最坏情况下可能需要 *O(n)*，因为
    `numpy` 数组要求内存位置是连续的。'
- en: '**Searching**: Finding an element in a vector has a time complexity of *O(n)*
    because, in the worst case, you might have to scan through all elements.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：在向量中查找一个元素的时间复杂度是 *O(n)*，因为在最坏情况下，你可能需要遍历所有元素。'
- en: Stacks
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈
- en: A stack is a linear data structure to store a one-dimensional list. It can store
    items either in a **Last-In, First-Out** (**LIFO**) or **First-In, Last-Out**
    (**FILO**) manner. The defining characteristic of a stack is the way elements
    are added to and removed from it. A new element is added at one end and an element
    is removed from that end only.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种线性数据结构，用于存储一维列表。它可以以 **后进先出**（**LIFO**）或 **先进后出**（**FILO**）的方式存储元素。栈的定义特征是元素的添加和移除方式。新元素添加到一端，并且元素只能从这一端移除。
- en: 'The following are the operations related to stacks:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与栈相关的操作：
- en: '**isEmpty**: Returns `true` if the stack is empty'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isEmpty**：如果栈为空，返回`true`'
- en: '**push**: Adds a new element'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**push**：添加一个新元素'
- en: '**pop**: Returns the element added most recently and removes it'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pop**：返回最近添加的元素并将其移除'
- en: '*Figure 2.4* shows how `push` and `pop` operations can be used to add and remove
    data from a stack:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.4* 显示了如何使用 `push` 和 `pop` 操作向栈中添加和移除数据：'
- en: '![Diagram  Description automatically generated](img/B18046_02_04.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图示 描述自动生成](img/B18046_02_04.png)'
- en: 'Figure 2.4: Push and pop operations'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：Push 和 Pop 操作
- en: The top portion of *Figure 2.4* shows the use of `push` operations to add items
    to the stack. In *steps 1.1*, *1.2*, and *1.3*, `push` operations are used three
    times to add three elements to the stack. The bottom portion of the preceding
    diagram is used to retrieve the stored values from the stack. In *steps 2.2* and
    *2.3*, `pop` operations are used to retrieve two elements from the stack in LIFO
    format.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.4* 的顶部显示了使用 `push` 操作向栈中添加元素的过程。在*步骤 1.1*、*1.2* 和 *1.3* 中，使用了三次 `push`
    操作将三个元素添加到栈中。前面图形的底部用于从栈中检索存储的值。在*步骤 2.2* 和 *2.3* 中，使用了两次 `pop` 操作以 LIFO 格式从栈中取出两个元素。'
- en: 'Let’s create a class named `Stack` in Python, where we will define all of the
    operations related to the `Stack` class. The code of this class will be as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Python 中创建一个名为`Stack`的类，在其中定义所有与`Stack`类相关的操作。该类的代码如下所示：
- en: '[PRE98]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'To push four elements to the stack, the following code can be used:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要将四个元素压入栈中，可以使用以下代码：
- en: '[PRE99]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Note that the preceding code creates a stack with four data elements:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述代码创建了一个包含四个数据元素的栈：
- en: '[PRE100]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Time complexity of stack operations
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈操作的时间复杂度
- en: 'Let us look into the time complexity of stack operations:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看栈操作的时间复杂度：
- en: '**Push**: This operation adds an element to the top of the stack. Since it
    doesn’t involve any iteration or checking, the time complexity of the push operation
    is *O(1)*, or constant time. The element is placed on top regardless of the stack’s
    size.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Push**：该操作将一个元素添加到栈的顶部。由于不涉及任何迭代或检查，push 操作的时间复杂度为 *O(1)*，即常数时间。无论栈的大小如何，元素都会被放置在顶部。'
- en: '**Pop**: Popping refers to removing the top element from the stack. Given that
    there’s no need to interact with the rest of the stack, the pop operation also
    has a time complexity of *O(1)*. It’s a direct action on the top element.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pop**：出栈指的是从栈中移除顶部元素。由于不需要与栈中的其余元素交互，pop 操作的时间复杂度为*O(1)*。这是一个直接作用于顶部元素的操作。'
- en: Practical example
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实际示例
- en: A stack is used as the data structure in many use cases. For example, when a
    user wants to browse the history in a web browser, it is a LIFO data access pattern,
    and a stack can be used to store the history. Another example is when a user wants
    to perform an undo operation in word processing software.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是许多使用案例中的数据结构。例如，当用户想要浏览网页浏览器中的历史记录时，它采用的是 LIFO 数据访问模式，栈可以用来存储历史记录。另一个例子是当用户想在文字处理软件中执行撤销操作时。
- en: Queues
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列
- en: Like stacks, a queue stores *n* elements in a single-dimensional structure.
    The elements are added and removed in FIFO format. One end of the queue is called
    the `rear` and the other is called the `front`. When elements are removed from
    the front, the operation is called `dequeue`. When elements are added at the rear,
    the operation is called `enqueue`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 与栈类似，队列在一维结构中存储 *n* 个元素。元素按 FIFO 格式添加和移除。队列的一端称为 `rear`（后端），另一端称为 `front`（前端）。当从前端移除元素时，该操作称为
    `dequeue`。当在后端添加元素时，该操作称为 `enqueue`。
- en: In the following diagram, the top portion shows the enqueue operation. *Steps
    1.1*, *1.2*, and *1.3* add three elements to the queue and the resultant queue
    is shown in *1.4*. Note that **Yellow** is the `rear` and **Red** is the `front`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，顶部显示了入队操作。*步骤 1.1*、*1.2* 和 *1.3* 将三个元素添加到队列中，结果队列如*1.4*所示。请注意，**黄色**是 `rear`，**红色**是
    `front`。
- en: 'The bottom portion of the following diagram shows a `dequeue` operation. *Steps
    2.2*, *2.3*, and *2.4* remove elements from the queue one by one from the front
    of the queue:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图的底部部分展示了`dequeue`操作。*步骤 2.2*、*2.3* 和 *2.4* 将队列中的元素一个接一个地从队列前端移除：
- en: '![A picture containing diagram  Description automatically generated](img/B18046_02_05.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含图表的图片，描述自动生成](img/B18046_02_05.png)'
- en: 'Figure 2.5: Enqueue and dequeue operations'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：入队和出队操作
- en: 'The queue shown in the preceding diagram can be implemented by using the following
    code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图示的队列可以通过以下代码实现：
- en: '[PRE101]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Let’s enqueue and dequeue elements as shown in the preceding diagramm with
    the help of the following code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码，结合前面的图示，来进行入队和出队操作：
- en: '[PRE102]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Note that the preceding code creates a queue first and then enqueues four items
    into it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述代码首先创建了一个队列，然后将四个项依次入队。
- en: Time complexity analysis for queues
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 队列的时间复杂度分析
- en: 'Let us look into the time complexity for queues:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看队列的时间复杂度：
- en: '**Enqueue**: This operation inserts an element t the end of the queue. Given
    its straightforward nature, without any need for iterating or traversing, the
    `enqueue` operation bears a time complexity of *O(1)* – a constant time.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入队（Enqueue）**：此操作将一个元素插入队列的末尾。由于其简单明了，无需迭代或遍历，`enqueue`操作的时间复杂度为*O(1)* ——
    恒定时间。'
- en: '**Dequeue**: Dequeueing means removing the front element from the queue. As
    the operation only involves the first element without any checks or iterations
    through the queue, its time complexity remains constant at *O(1)*.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**出队（Dequeue）**：出队是指从队列中移除最前面的元素。由于该操作只涉及队列中的第一个元素，且无需检查或遍历队列，因此其时间复杂度仍保持为*O(1)*。'
- en: The basic idea behind the use of stacks and queues
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用栈和队列的基本思想
- en: 'Let’s look into the basic idea behind the use of stacks and queues using an
    analogy. Let’s assume that we have a table where we put our incoming mail from
    our postal service, for example, Canada Mail. We stack them until we have some
    time to open and look at the letters, one by one. There are two possible ways
    of doing this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个类比来理解栈和队列的基本思想。假设我们有一张桌子，放着我们从邮政服务（例如加拿大邮政）收到的邮件。我们将它们堆放在一起，直到有时间一封封地打开并查看这些信件。有两种可能的做法：
- en: We put the letters in a stack and, whenever we get a new letter, we put it on
    the top of the stack. When we want to read a letter, we start with the one that
    is on top. This is what we call a **stack**. Note that the latest letter to arrive
    will be on the top and will be processed first. Picking up a letter from the top
    of the list is called a `pop` operation. Whenever a new letter arrives, putting
    it on the top is called a `push` operation. If we end up having a sizable stack
    and lots of letters are continuously arriving, there is a chance that we never
    get a chance to reach a very important letter waiting for us at the lower end
    of the stack.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将信件放入栈中，每当有新信件到达时，我们将其放在栈的顶部。当我们想读取一封信时，我们从顶部开始。这就是我们所说的**栈**。请注意，最新到达的信件会在栈顶，并会优先处理。将信件从栈顶取出称为`pop`操作。每当有新信件到达，将其放在栈顶称为`push`操作。如果我们最终堆积了大量信件，并且许多信件不断到达，就有可能永远无法处理到堆栈底部那封非常重要的信件。
- en: We put the letters in the pile, but we want to handle the oldest letter first;
    every time we want to look at one or more letters, we take care to handle the
    oldest one first. This is what we call a **queue**. Adding a letter to the pile
    is called an `enqueue` operation. Removing the letter from the pile is called
    a `dequeue` operation.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将信件放入堆中，但我们想先处理最旧的信件；每次我们想查看一封或多封信时，我们会优先处理最旧的那一封。这就是我们所说的**队列**。将信件添加到堆中的操作称为`enqueue`操作。将信件从堆中移除的操作称为`dequeue`操作。
- en: Tree
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树
- en: In the context of algorithms, a tree is one of the most useful data structures
    due to its hierarchical data storage capabilities. While designing algorithms,
    we use trees wherever we need to represent hierarchical relationships among the
    data elements that we need to store or process.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法的上下文中，树是最有用的数据结构之一，因为它具有分层数据存储的能力。在设计算法时，我们在需要表示数据元素之间的层级关系时会使用树。
- en: Let’s look deeper into this interesting and quite important data structure.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解这个既有趣又非常重要的数据结构。
- en: Each tree has a finite set of nodes so that it has a starting data element called
    a **root** and a set of nodes joined together by links called **branches**.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 每棵树都有一个有限的节点集合，它有一个称为**根节点**的起始数据元素，节点之间通过链接连接在一起，称为**分支**。
- en: Terminology
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 术语
- en: 'Let’s look into some of the terminology related to the tree data structure:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看与树数据结构相关的一些术语：
- en: '| **Root node** | A node with no parent is called the root node. For example,
    in the following diagram, the root node is A. In algorithms, usually, the root
    node holds the most important value in the tree structure. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| **根节点** | 没有父节点的节点称为根节点。例如，在下图中，根节点是A。在算法中，通常根节点保存着树结构中最重要的值。 |'
- en: '| **Level of a node** | The distance from the root node is the level of a node.
    For example, in the following diagram, the level of nodes D, E, and F is two.
    |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| **节点的层级** | 节点的层级是指从根节点到该节点的距离。例如，在下图中，节点D、E和F的层级为二。 |'
- en: '| **Siblings nodes** | Two nodes in a tree are called siblings if they are
    at the same level. For example, if we check the following diagram, nodes B and
    C are siblings. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| **兄弟节点** | 树中两个节点如果处于同一层级，则称它们为兄弟节点。例如，在下图中，节点B和C是兄弟节点。 |'
- en: '| **Child and parent node** | Node F is a child of node C if both are directly
    connected and the level of node C is less than node F. Conversely, node C is a
    parent of node F. Nodes C and F in the following diagram show this parent-child
    relationship. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| **子节点与父节点** | 如果节点F和节点C直接相连，并且节点C的层级低于节点F，则节点F是节点C的子节点。反之，节点C是节点F的父节点。下图中，节点C和F展示了这种父子关系。
    |'
- en: '| **Degree of a node** | The degree of a node is the number of children it
    has. For example, in the following diagram, node B has a degree of two. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| **节点的度数** | 节点的度数是指它有多少个子节点。例如，在下图中，节点B的度数为二。 |'
- en: '| **Degree of a tree** | The degree of a tree is equal to the maximum degree
    that can be found among the constituent nodes of a tree. For example, the tree
    presented in the following diagram has a degree of two. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| **树的度数** | 树的度数等于树中各个节点度数的最大值。例如，下图所示的树的度数为二。 |'
- en: '| **Subtree** | A subtree of a tree is a portion of the tree with the chosen
    node as the root node of the subtree and all of the children as the nodes of the
    tree. For example, a subtree at node E of the tree presented in the following
    diagram consists of node E as the root node and nodes G and H as the two children.
    |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **子树** | 树的子树是树的一个部分，选定节点作为子树的根节点，所有子节点作为树的节点。例如，在下图中，树的节点E上的子树由节点E作为根节点，节点G和H作为两个子节点组成。
    |'
- en: '| **Leaf node** | A node in a tree with no children is called a leaf node.
    For example, in the following figure, nodes D, G, H, and F are the four leaf nodes.
    |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| **叶子节点** | 树中没有子节点的节点称为叶子节点。例如，在下图中，节点D、G、H和F是四个叶子节点。 |'
- en: '| **Internal node** | Any node that is neither a root nor a leaf node is an
    internal node. An internal node will have at least one parent and at least one
    child node. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| **内部节点** | 任何既不是根节点也不是叶子节点的节点称为内部节点。内部节点至少有一个父节点和一个子节点。 |'
- en: Note that trees are a kind of network or graph that we will study in *Chapter
    6*, *Unsupervised Machine Learning Algorithms*. For graphs and network analysis,
    we use the terms **link** or **edge** instead of branches. Most of the other terminology
    remains unchanged.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，树是一种我们将在*第6章*、*无监督机器学习算法*中研究的网络或图的类型。对于图和网络分析，我们使用**链接**或**边**来代替分支。其他大多数术语保持不变。
- en: Types of trees
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树的类型
- en: 'There are different types of trees, which are explained as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的树，下面解释了它们：
- en: '**Binary tree**: If the degree of a tree is two, that tree is called a *binary
    tree*. For example, the tree shown in the following diagram is a binary tree as
    it has a degree of two:'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二叉树**：如果树的度数为二，则该树称为*二叉树*。例如，下图所示的树就是一棵二叉树，因为它的度数为二：'
- en: '![Diagram  Description automatically generated](img/B18046_02_06.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![Diagram Description automatically generated](img/B18046_02_06.png)'
- en: 'Figure 2.6: A binary tree'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：一棵二叉树
- en: Note that the preceding diagram shows a tree that has four levels with eight
    nodes.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上面的图显示了一棵有四层、八个节点的树。
- en: '**Full tree**: A full tree is one in which all of the nodes are of the same
    degree, which will be equal to the degree of the tree. The following diagram shows
    the kinds of trees discussed earlier:'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全树**：完全树是指所有节点的度数相同，并且等于树的度数。下图显示了前面讨论的几种树：'
- en: '![Diagram  Description automatically generated](img/B18046_02_07.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图示  描述自动生成](img/B18046_02_07.png)'
- en: 'Figure 2.7: A full tree'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：完全树
- en: Note that the binary tree on the left is not a full tree, as node C has a degree
    of one and all other nodes have a degree of two. The tree in the middle and the
    one on the right are both full trees.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，左侧的二叉树不是完全树，因为 C 节点的度为 1，而其他节点的度为 2。中间和右侧的树都是完全树。
- en: '**Perfect tree**: A perfect tree is a special type of full tree in which all
    the leaf nodes are at the same level. For example, the binary tree on the right
    as shown in the preceding diagram is a perfect, full tree as all the leaf nodes
    are at the same level – that is, **level 2**.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完美树**：完美树是一种特殊的完全树，其中所有的叶节点位于同一层级。例如，前面图示中的右侧二叉树是一个完美的完全树，因为所有的叶节点都在同一层级——也就是**第
    2 层**。'
- en: '**Ordered tree**: If the children of a node are organized in some order according
    to particular criteria, the tree is called an **ordered tree**. A tree, for example,
    can be ordered from left to right in ascending order in which the nodes at the
    same level will increase in value while traversing from left to right.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有序树**：如果一个节点的子节点按照特定标准排列顺序，则该树被称为**有序树**。例如，树可以按从左到右的升序排列，其中同一层级的节点值在从左到右遍历时会逐渐增大。'
- en: Practical examples
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实际例子
- en: An ADT tree is one of the main data structures that is used in developing decision
    trees, as will be discussed in *Chapter 7*, *Traditional Supervised Learning Algorithms*.
    Due to its hierarchical structure, it is also popular in algorithms related to
    network analysis, as will be discussed in detail in *Chapter 6*, *Unsupervised
    Machine Learning Algorithms*. Trees are also used in various search and sort algorithms
    in which divide and conquer strategies need to be implemented.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ADT 树是用于开发决策树的主要数据结构之一，正如在*第 7 章*《传统监督学习算法》中将讨论的那样。由于其层级结构，它在与网络分析相关的算法中也非常流行，正如在*第
    6 章*《无监督机器学习算法》中将详细讨论的那样。树还用于各种搜索和排序算法中，在这些算法中需要实现分治策略。
- en: Summary
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed data structures that can be used to implement
    various types of algorithms. After going through this chapter, you should now
    be able to select the right data structure to be used to store and process data
    with an algorithm. You should also be able to understand the implications of our
    choice on the performance of the algorithm.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了可以用来实现各种类型算法的数据结构。读完本章后，你应该能够选择合适的数据结构来存储和处理数据，并与算法结合使用。你还应该能够理解我们选择的数据结构对算法性能的影响。
- en: The next chapter is about sorting and searching algorithms, in which we will
    use some of the data structures presented in this chapter in the implementation
    of the algorithms.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍排序和查找算法，在这一章中，我们将使用本章中介绍的一些数据结构来实现这些算法。
- en: Learn more on Discord
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在这里你可以分享反馈、向作者提问、并了解新版本的发布——请扫描下面的二维码：
- en: '[https://packt.link/WHLel](https://packt.link/WHLel)'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/WHLel](https://packt.link/WHLel)'
- en: '![](img/QR_Code1955211820597889031.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1955211820597889031.png)'
