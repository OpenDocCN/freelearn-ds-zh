- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Working with Trees and Networks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理树与网络
- en: Networks are objects that contain *nodes* and *edges* between pairs of nodes.
    They can be used to represent a wide variety of real-world situations, such as
    distribution and scheduling. Mathematically, networks are useful for visualizing
    combinatorial problems and make for a rich and fascinating theory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是包含 *节点* 和节点对之间 *边* 的对象。它们可以用来表示各种现实世界的情况，如分配和调度。数学上，网络对于可视化组合问题非常有用，并且它有着丰富且迷人的理论。
- en: There are, of course, several different kinds of networks. We will mostly deal
    with simple networks, where edges connect two distinct nodes (so there are no
    self-loops), there is, at most, one edge between any two nodes, and all the edges
    are bidirectional. A *tree* is a special kind of network in which there are no
    cycles; that is, there are no lists of nodes in which each node is connected to
    the following node by an edge, and the final node is connected to the first. Trees
    are especially simple in terms of their theory because they connect several nodes
    with the fewest possible edges. A *complete network* is a network in which every
    node is connected to every other node by an edge.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，网络有多种类型。我们将主要处理简单网络，其中边连接两个不同的节点（因此没有自环），每两个节点之间最多只有一条边，并且所有边都是双向的。*树* 是一种特殊的网络，其中没有环；也就是说，没有节点列表，每个节点都通过边连接到下一个节点，最后一个节点又连接到第一个节点。树在理论上特别简单，因为它用最少的边连接多个节点。*完全网络*
    是一种每个节点都通过边与其他每个节点相连的网络。
- en: Networks can be directed, where each edge has a source and a destination node
    or can carry additional attributes, such as weights. Weighted networks are especially
    useful in certain applications. There are also networks in which we allow multiple
    edges between two given nodes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 网络可以是有向的，其中每条边都有一个源节点和一个目标节点，或者可以承载额外的属性，例如权重。加权网络在某些应用中尤其有用。还有一些网络允许在两个给定节点之间有多条边。
- en: In this chapter, we will learn how to create, manipulate, and analyze networks,
    and then apply network algorithms to solve various problems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何创建、操作和分析网络，并应用网络算法解决各种问题。
- en: Note
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the literature, especially in mathematical texts, networks are more commonly
    called *graphs*. Nodes are sometimes called *vertices*. We favor the term network
    to avoid confusion with the more common usage of a graph to mean a plot of a function.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在文献中，特别是在数学文本中，网络更常被称为 *图*。节点有时被称为 *顶点*。我们更倾向于使用“网络”这一术语，以避免与更常见的将图表示为函数图像的用法混淆。
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Creating networks in Python
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中创建网络
- en: Visualizing networks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化网络
- en: Getting the basic characteristics of networks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取网络的基本特征
- en: Generating the adjacency matrix for a network
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成网络的邻接矩阵
- en: Creating directed and weighted networks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建有向和加权网络
- en: Finding the shortest paths in a network
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找网络中的最短路径
- en: Quantifying clustering in a network
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定量化网络中的聚类
- en: Coloring a network
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给网络上色
- en: Finding minimal spanning trees and dominating sets
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找最小生成树和支配集
- en: Let’s get started!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will primarily use the NetworkX package for working with
    trees and networks. This package can be installed using your favorite package
    manager, such as `pip`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要使用 NetworkX 包来处理树和网络。您可以通过您喜欢的包管理器（例如 `pip`）来安装此包：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We usually import this under the `nx` alias, following the conventions established
    in the official NetworkX ([https://networkx.org/documentation/stable/](https://networkx.org/documentation/stable/))
    documentation, using the following `import` statement:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用 `nx` 别名导入此模块，遵循官方 NetworkX 文档中建立的惯例（[https://networkx.org/documentation/stable/](https://networkx.org/documentation/stable/)），使用以下
    `import` 语句：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code for this chapter can be found in the `Chapter 05` folder of this book’s
    GitHub repository at [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2005](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2005).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的 GitHub 仓库中的 `Chapter 05` 文件夹找到，链接为 [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2005](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2005)。
- en: Creating networks in Python
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Python 中创建网络
- en: To solve the multitude of problems that can be expressed as network problems,
    we need a way of creating networks in Python. For this, we will make use of the
    NetworkX package and the routines and classes it provides to create, manipulate,
    and analyze networks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决可以表示为网络问题的各种问题，我们需要一种在Python中创建网络的方式。为此，我们将利用NetworkX包及其提供的例程和类来创建、操作和分析网络。
- en: In this recipe, we’ll create an object in Python that represents a network and
    add nodes and edges to this object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将创建一个表示网络的Python对象，并向该对象添加节点和边。
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As we mentioned in the *Technical requirements* section, we need the NetworkX
    package to be imported under the `nx` alias. We can do this using the following
    `import` statement:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*技术要求*部分提到的，我们需要将NetworkX包以`nx`别名导入。我们可以使用以下`import`语句来完成：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to create a Python representation of a simple graph:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个简单图的Python表示：
- en: 'We need to create a new `Graph` object that will store the nodes and edges
    that constitute the graph:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的`Graph`对象，用于存储构成图的节点和边：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we need to add the nodes for the network using the `add_node` method:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用`add_node`方法为网络添加节点：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To avoid calling this method repetitively, we can use the `add_nodes_from`
    method to add nodes from an iterable, such as a list:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免重复调用该方法，我们可以使用`add_nodes_from`方法从可迭代对象（如列表）中添加节点：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we need to add edges between the nodes that we’ve added using either
    the `add_edge` or `add_edges_from` method, which adds either a single edge or
    a list of edges (as tuples), respectively:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用`add_edge`或`add_edges_from`方法为我们已添加的节点之间添加边，这些方法分别是添加单条边或一组边（作为元组）：
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we must retrieve a view of the current nodes and edges in a graph
    by accessing the `nodes` and `edges` attributes, respectively:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须通过访问`nodes`和`edges`属性，分别获取图中当前节点和边的视图：
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The NetworkX package adds several classes and routines for creating, manipulating,
    and analyzing networks using Python. The `Graph` class is the most basic class
    for representing networks that do not contain multiple edges between any given
    nodes and where their edges are undirected (bidirectional).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX包添加了多个类和例程，用于使用Python创建、操作和分析网络。`Graph`类是表示不包含多个边的网络的最基本类，其中边是无向的（双向的）。
- en: Once a blank `Graph` object has been created, we can add new nodes and edges
    using the methods described in this recipe. In this recipe, we created nodes that
    hold integer values. However, a node can hold any hashable Python object except
    `None`. Moreover, associated data can be added to a node via keyword arguments
    passed to the `add_node` method. Attributes can also be added when using the `add_nodes_from`
    method by supplying a list of tuples containing the node object and a dictionary
    of attributes. The `add_nodes_from` method is useful for adding nodes in bulk,
    while `add_node` is useful for attaching individual nodes to an existing network.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个空白的`Graph`对象，我们就可以使用本配方中描述的方法添加新的节点和边。在本配方中，我们创建了包含整数值的节点。然而，节点可以包含任何可哈希的Python对象，除了`None`。此外，还可以通过传递关键字参数给`add_node`方法来为节点添加关联数据。在使用`add_nodes_from`方法时，可以通过提供包含节点对象和属性字典的元组列表来添加属性。`add_nodes_from`方法对于批量添加节点非常有用，而`add_node`方法则适用于将单个节点附加到现有网络中。
- en: An edge in a network is a tuple containing two (distinct) nodes. In a simple
    network, such as the one represented by the basic `Graph` class, there can be,
    at most, one edge between any two given nodes. These edges are added via the `add_edge`
    or `add_edges_from` method, which adds either a single edge or a list of edges
    to the network, respectively. As for the nodes, edges can hold arbitrary associated
    data via an attributes dictionary. In particular, weights can be added by supplying
    the `weight` attribute when adding edges. We will provide more details about weighted
    graphs in the *Creating directed and weighted* *networks* recipe.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的一条边是一个包含两个（不同）节点的元组。在一个简单的网络中，例如由基本的`Graph`类表示的网络，任何两个给定节点之间最多只能有一条边。这些边是通过`add_edge`或`add_edges_from`方法添加的，分别是添加单个边或添加一组边。与节点类似，边也可以通过属性字典来保存任意的关联数据。特别是，当添加边时，可以通过提供`weight`属性来添加权重。我们将在*创建有向和加权*
    *网络*的配方中提供有关加权图的更多细节。
- en: The `nodes` and `edges` attributes hold the nodes and edges that constitute
    the network, respectively. The `nodes` attribute returns a `NodesView` object,
    which is a dictionary-like interface to the nodes and their associated data. Similarly,
    the `edges` attribute returns an `EdgeView` object. This can be used to inspect
    individual edges and their associated data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodes` 和 `edges` 属性分别包含构成网络的节点和边。`nodes` 属性返回一个 `NodesView` 对象，这是一个类似字典的接口，提供节点及其关联数据的访问。同样，`edges`
    属性返回一个 `EdgeView` 对象。我们可以使用这个对象检查个别边及其相关数据。'
- en: There’s more...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Graph` class represents *simple networks*, which are networks in which
    nodes are joined by, at most, one edge, and the edges are not directed. We will
    discuss directed networks in the *Creating directed and weighted networks* recipe.
    There is a separate class for representing networks in which there can be multiple
    edges between a pair of nodes called `MultiGraph`. All of the network types allow
    self-loops, which are sometimes not allowed in a *simple network* in the literature,
    where a simple network typically refers to an undirected network with no self-loops.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graph` 类表示 *简单网络*，它是节点最多由一条边连接且边不具有方向的网络。我们将在 *创建有向和加权网络* 食谱中讨论有向网络。还有一个单独的类用于表示可以在一对节点之间有多条边的网络，称为
    `MultiGraph`。所有网络类型都允许自环，这在文献中的 *简单网络* 中有时是不允许的，简单网络通常指的是没有自环的无向网络。'
- en: All network types offer various methods for adding nodes and edges, as well
    as inspecting the current nodes and edges. There are also methods for copying
    networks into some other kind of network or extracting subnetworks. There are
    also several utility routines in the NetworkX package for generating standard
    networks and adding subnetworks to an existing network.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有网络类型都提供了多种方法来添加节点和边，并检查当前的节点和边。还有方法可以将网络复制到其他类型的网络中，或提取子网络。此外，NetworkX 包还提供了多个实用例程，用于生成标准网络并将子网络添加到现有网络中。
- en: NetworkX also provides various routines for reading and writing networks to
    different file formats, such as GraphML, JSON, and YAML. For example, we can write
    a network to a GraphML file using the `nx.write_graphml` routine and read it using
    the `nx.read_graphml` routine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX 还提供了多种例程，用于将网络读写到不同的文件格式中，例如 GraphML、JSON 和 YAML。例如，我们可以使用 `nx.write_graphml`
    例程将网络写入 GraphML 文件，并使用 `nx.read_graphml` 例程读取它。
- en: Visualizing networks
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化网络
- en: A common first step in analyzing a network is to draw the network, which can
    help us identify some of the prominent features of a network. (Of course, drawings
    can be misleading, so we should not rely on them too heavily in our analysis.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 分析网络的常见第一步是绘制网络，这有助于我们识别网络的一些显著特征。（当然，图示可能会产生误导，因此我们不应过于依赖它们进行分析。）
- en: In this recipe, we’ll describe how to use the network drawing facilities in
    the NetworkX package to visualize a network.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将描述如何使用 NetworkX 包中的网络绘制功能来可视化网络。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need to import the NetworkX package under the `nx`
    alias, as described in the *Technical requirements* section. We will also need
    the Matplotlib package. For this, as usual, we must import the `pyplot` module
    as `plt` using the following `import` statement:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要按 *技术要求* 部分的描述，导入 NetworkX 包并使用 `nx` 别名。我们还需要 Matplotlib 包。为此，我们通常需要使用以下
    `import` 语句导入 `pyplot` 模块，并将其命名为 `plt`：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps outline how to draw a simple network object using the drawing
    routines from NetworkX:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了如何使用 NetworkX 的绘图例程绘制一个简单的网络对象：
- en: 'First, we will create a simple example network to draw:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的示例网络进行绘制：
- en: '[PRE15]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we will create new Matplotlib `Figure` and `Axes` objects for it, ready
    to plot the network using the `subplots` routine from `plt`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为它创建新的 Matplotlib `Figure` 和 `Axes` 对象，准备好使用 `plt` 中的 `subplots` 例程来绘制网络：
- en: '[PRE21]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we can create a layout that will be used to position the nodes on the
    figure. For this figure, we shall use a shell layout using the `shell_layout`
    routine:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个布局，用于在图形中定位节点。对于这个图形，我们将使用 `shell_layout` 例程来创建一个壳布局：
- en: '[PRE22]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can use the `draw` routine to draw the network on the figure. Since we have
    already created a Matplotlib `Figure` and `Axes`, we can supply the `ax` keyword
    argument. We will also add labels to the nodes using the `with_labels` keyword
    argument and specify the layout that we just created using the `pos` argument:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`draw`函数将网络绘制到图形上。由于我们已经创建了一个Matplotlib `Figure`和`Axes`，我们可以提供`ax`关键字参数。我们还将使用`with_labels`关键字参数为节点添加标签，并通过`pos`参数指定我们刚刚创建的布局：
- en: '[PRE23]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The resulting drawing can be seen in the following figure:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图像可以在以下图中看到：
- en: '![Figure 5.1 – A drawing of a simple network arranged using a shell layout'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 使用shell布局排列的简单网络图'
- en: '](img/5.1.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/5.1.jpg)'
- en: Figure 5.1 – A drawing of a simple network arranged using a shell layout
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 使用shell布局排列的简单网络图
- en: Since the number of nodes in this example is relatively small, they are arranged
    in a single circle. The edges are indicated by lines.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本示例中的节点数量相对较少，它们被安排在一个圆圈内。边缘通过线条表示。
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `draw` routine is a specialized plotting routine specifically for drawing
    networks. The layout we created specifies the coordinates at which each of the
    nodes will be placed. We used a *shell layout*, which arranges the nodes in a
    concentric circle arrangement (only a single circle was used in this recipe),
    which is determined by the nodes and edges of the network. By default, the `draw`
    routine creates a randomized layout.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`函数是一个专门的绘图函数，专门用于绘制网络。我们创建的布局指定了每个节点将被放置的坐标。我们使用了*shell布局*，它将节点按同心圆的方式排列（此示例中仅使用了一个圆），该布局由网络的节点和边缘决定。默认情况下，`draw`函数会创建一个随机布局。'
- en: The `draw` routine has numerous keyword arguments for customizing the appearance
    of the plotted network. In this recipe, we added the `with_labels` keyword argument
    to label the nodes in the figure according to the objects they hold. The nodes
    hold integers, which is why the nodes in the preceding figure are labeled by integers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`函数有多个关键字参数，用于定制绘制网络的外观。在本示例中，我们添加了`with_labels`关键字参数，根据节点持有的对象为节点添加标签。节点持有整数值，这就是为什么前面图中的节点按整数标注的原因。'
- en: We also created a set of axes separately using the `plt.subplots` routine. This
    isn’t strictly necessary since the `draw` routine will automatically create a
    new figure and new axes if they’re not provided.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`plt.subplots`函数单独创建了一组坐标轴。严格来说，这不是必须的，因为`draw`函数会在没有提供坐标轴的情况下自动创建一个新的图形和坐标轴。
- en: There’s more...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The NetworkX package provides several layout-generating routines, similar to
    the `shell_layout` routine that we used in this recipe. This layout is simply
    a dictionary, indexed by the nodes, whose elements are the x and y coordinates
    of the position where the node should be plotted. The NetworkX routines for creating
    layouts represent common arrangements that will be useful for most cases, but
    you can also create custom layouts, should you need them. A full list of the different
    layout creation routines is provided in the NetworkX documentation. There are
    also shortcut drawing routines that will use a specific layout with the need to
    create the layout separately; for example, the `draw_shell` routine will draw
    the network with the shell layout that is equivalent to the `draw` call given
    in this recipe.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX包提供了几个布局生成函数，类似于我们在本示例中使用的`shell_layout`函数。此布局实际上是一个字典，以节点为索引，其元素是节点应该绘制的位置的x和y坐标。NetworkX的布局生成函数表示了适用于大多数情况的常见排列，但如果需要，您也可以创建自定义布局。NetworkX文档中提供了不同布局创建函数的完整列表。此外，还有快捷的绘图函数，它们会使用特定的布局，而无需单独创建布局；例如，`draw_shell`函数会绘制使用shell布局的网络，这等同于本示例中`draw`函数的调用。
- en: The `draw` routine takes several keyword arguments to customize the appearance
    of the figure. For example, there are keyword arguments to control the node’s
    size, color, shape, and transparency. We can also add arrows (for directed edges)
    and/or only draw a specific set of nodes and edges from the network.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`函数接受多个关键字参数来定制图形的外观。例如，您可以使用关键字参数控制节点的大小、颜色、形状和透明度。我们还可以添加箭头（用于有向边）和/或仅绘制网络中的特定节点和边。'
- en: Getting the basic characteristics of networks
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取网络的基本特征
- en: Networks have various basic characteristics beyond the number of nodes and edges
    that are useful for analyzing a graph. For example, the *degree* of a node is
    the number of edges that start (or end) at that node. A higher degree indicates
    that the node is better connected to the rest of the network.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 网络除了节点和边的数量之外，还有许多有助于分析图的基本特性。例如，节点的*度数*是指从该节点出发（或到达）的边的数量。度数越高，表示该节点与网络的其他部分连接越紧密。
- en: In this recipe, we will learn how to access the basic attributes and compute
    various basic measures associated with a network.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何访问网络的基本属性，并计算与网络相关的各种基本度量。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As usual, we need to import the NetworkX package under the `nx` alias. We also
    need to import the Matplotlib `pyplot` module as `plt`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们需要导入 `nx` 别名下的 NetworkX 包。我们还需要导入 Matplotlib 的 `pyplot` 模块，别名为 `plt`。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to access the various basic characteristics of a network:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤访问网络的各种基本特征：
- en: 'Create the sample network that we will analyze in this recipe, like so:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们将在本教程中分析的示例网络，代码如下：
- en: '[PRE25]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, it is good practice to draw the network and arrange the nodes in a circular
    layout:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，最好绘制网络并将节点排列成圆形布局：
- en: '[PRE32]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The resulting plot can be seen in the following figure. As we can see, the
    network is split into two distinct parts:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图可以在下图中看到。正如我们所见，网络被分成了两个不同的部分：
- en: '![Figure 5.2 – A simple network drawn in a circular arrangement with two distinct
    components'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 一个简单的网络，采用圆形排列，包含两个不同的组件'
- en: '](img/5.2.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/5.2.jpg)'
- en: Figure 5.2 – A simple network drawn in a circular arrangement with two distinct
    components
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 一个简单的网络，采用圆形排列，包含两个不同的组件
- en: 'Next, we must print the `Graph` object to display some basic information about
    the network:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须打印`Graph`对象以显示网络的基本信息：
- en: '[PRE35]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we can use the `degree` property of the `Graph` object to retrieve the
    degree of a specific node:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`Graph`对象的`degree`属性来获取特定节点的度数：
- en: '[PRE41]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can get the connected components of the network using the `connected_components`
    routine, which returns a generator that we make into a list:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `connected_components` 例程获取网络的连通组件，该例程返回一个生成器，我们将其转换为列表：
- en: '[PRE47]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can compute the **density** of a network using the density routine, which
    returns a float between 0 and 1\. This represents the proportion of edges meeting
    the node to the total number of possible edges at the node:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用密度例程计算网络的**密度**，该例程返回一个介于 0 和 1 之间的浮动值。它表示连接到该节点的边与该节点所有可能的边之间的比例：
- en: '[PRE50]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we can determine whether a network is *planar* – meaning that no two
    edges need to be drawn crossing one another – by using the `check_planarity` routine:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `check_planarity` 例程来确定网络是否是*平面*的——即没有两条边需要交叉——：
- en: '[PRE53]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If we glance back at *Figure 5**.2*, we can see that we can indeed draw this
    graph without having to cross two of the edges.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 回头看看*图 5.2*，我们可以看到，确实可以在不交叉任何两条边的情况下绘制这个图。
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `info` routine generates a small summary of the network, including the type
    of the network (which is a simple `Graph` type in this recipe), the number of
    nodes and edges, and the average degrees of the nodes in the network. The actual
    degree of a node in the network can be accessed using the `degree` property, which
    offers a dictionary-like interface for finding the degree of each node.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`info` 例程生成网络的小结，包括网络的类型（在本教程中是简单的 `Graph` 类型）、节点和边的数量以及网络中节点的平均度数。可以使用 `degree`
    属性访问网络中节点的实际度数，它提供了一种类似字典的接口来查找每个节点的度数。'
- en: A set of nodes is said to be connected if every node in the set is joined to
    the others by an edge or sequence of edges. The *connected components* of a network
    are the largest sets of nodes that are connected. Any two distinct connected components
    are disjointed. Every network can be decomposed into one or more connected components.
    The network we defined in this recipe has two connected components, `{0, 1, 2,
    3, 4, 5}` and `{8, 9, 6, 7}`. These are visible in the preceding figure, where
    the first connected component is drawn above the second connected component. In
    this figure, we can trace a path along the edges of the network from any node
    in a component to any other; for example, from 0 to 5.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一组节点如果该组中的每个节点都通过一条边或一系列边与其他节点相连，则称这组节点为连通的。网络的*连通分量*是最大的一组相互连通的节点。任何两个不同的连通分量是相互不相交的。每个网络都可以分解为一个或多个连通分量。我们在这个示例中定义的网络有两个连通分量，分别是`{0,
    1, 2, 3, 4, 5}`和`{8, 9, 6, 7}`。这些连通分量在前面的图中可见，其中第一个连通分量位于第二个连通分量的上方。在这张图中，我们可以沿着网络的边从组件中的任何节点到达任何其他节点；例如，从0到5。
- en: The *density* of a network measures the ratio of the number of edges in the
    network to the total possible number of edges given by the number of nodes in
    a network. The density of a complete network is 1, but in general, the density
    will be less than 1.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的*密度*衡量的是网络中边的数量与网络中节点数量所能形成的边的总数之间的比例。完全网络的密度为1，但通常情况下，密度会小于1。
- en: A network is *planar* if it can be drawn on a flat surface without crossing
    edges. The easiest example of a non-planar network is a complete network with
    five nodes. Complete networks with, at most, four nodes are planar. A little experimentation
    with the way you draw these networks on paper will reveal a drawing that doesn’t
    contain crossing edges. In addition, any network that contains a complete graph
    with at least five nodes is not planar. Planar networks are important in theory
    due to their relative simplicity, but they are less common in networks that arise
    in applications.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个网络可以在平面上绘制而没有交叉边，则称该网络为*平面网络*。五节点的完全网络是最简单的非平面网络。最多包含四个节点的完全网络是平面网络。通过一些尝试绘制这些网络，你将发现一个没有交叉边的绘图。此外，任何包含至少五个节点的完全图的网络都不是平面网络。平面网络在理论中很重要，因为它们相对简单，但在实际应用中不太常见。
- en: There’s more...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: In addition to the methods on the network classes, there are several other routines
    in the NetworkX package that can be used to access the attributes of the nodes
    and edges in a network. For example, `nx.get_node_attributes` gets a named attribute
    from each node in the network.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网络类中的方法外，NetworkX包中还有其他多个常用函数，可以用来访问网络中节点和边的属性。例如，`nx.get_node_attributes`可以获取网络中每个节点的指定属性。
- en: Generating the adjacency matrix for a network
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为网络生成邻接矩阵
- en: One potent tool for analyzing graphs is the adjacency matrix, which has entries
    ![](img/Formula_05_003.png) if there is an edge from node ![](img/Formula_05_004.png)
    to node ![](img/Formula_05_005.png), and 0 otherwise. For most networks, the adjacency
    matrix will be sparse (most of the entries are 0). For networks that are not directed,
    the matrix will also be symmetric (![](img/Formula_05_006.png)). Numerous other
    matrices can be associated with a network. We will briefly discuss these in the
    *There’s more...* section of this recipe.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 分析图的一个强大工具是邻接矩阵，如果存在从节点 ![](img/Formula_05_004.png) 到节点 ![](img/Formula_05_005.png)
    的边，则矩阵中的值为 ![](img/Formula_05_003.png)，否则为0。对于大多数网络，邻接矩阵通常是稀疏的（大多数值为0）。对于无向网络，邻接矩阵还会是对称的（![](img/Formula_05_006.png)）。可以与网络关联的其他矩阵也有很多。我们将在这个示例的*还有更多内容...*部分简要讨论这些矩阵。
- en: In this recipe, we will generate the adjacency matrix for a network and learn
    how to get some basic properties of the network from this matrix.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将生成一个网络的邻接矩阵，并学习如何从这个矩阵中获取网络的一些基本属性。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will need the NetworkX package imported under the `nx` alias,
    and the NumPy module imported as `np`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将需要导入NetworkX包，并使用`nx`别名，同时导入NumPy模块，使用`np`别名。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The following steps outline how to generate the adjacency matrix for a network
    and derive some simple properties of the network from this matrix:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了如何为网络生成邻接矩阵，并从该矩阵推导出网络的一些简单属性：
- en: 'First, we will generate a network to work with throughout this recipe. We’ll
    generate a random network with five nodes and five edges while using a seed for
    reproducibility:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将生成一个网络，在整个示例中使用。我们将生成一个具有五个节点和五条边的随机网络，并使用种子确保可重复性：
- en: '[PRE56]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To generate the adjacency matrix, we can use the `adjacency_matrix` routine
    from NetworkX. This returns a sparse matrix by default, so we will also convert
    this into a full NumPy array for this demonstration using the `todense` method:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了生成邻接矩阵，我们可以使用 NetworkX 中的 `adjacency_matrix` 函数。默认情况下，这将返回一个稀疏矩阵，因此我们还将通过
    `todense` 方法将其转换为一个完整的 NumPy 数组进行演示：
- en: '[PRE57]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Taking the ![](img/Formula_05_007.png)th power of the adjacency matrix gives
    us the number of paths of length ![](img/Formula_05_007.png) from one node to
    another:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对邻接矩阵进行 ![](img/Formula_05_007.png) 次幂运算，可以得到从一个节点到另一个节点的路径数量，路径长度为 ![](img/Formula_05_007.png)：
- en: '[PRE64]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Both the adjacency matrix from step 2 and the fourth power from step 3 are symmetric
    matrices. Also, notice that the non-zero entries of `paths_len_4` are located
    in the positions where 0 appears in the adjacency matrix. This is because there
    are two distinct groups of nodes, and paths of odd length swap between these two
    groups whereas paths of even length return to the starting group.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤2中的邻接矩阵和步骤3中的四次幂都是对称矩阵。此外，注意到 `paths_len_4` 中非零条目的位置与邻接矩阵中的零位置相对应。这是因为存在两个不同的节点组，而奇数长度的路径在这两个组之间交换，偶数长度的路径则返回到起始组。
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The `dense_gnm_random_graph` routine generates a (dense) random network, chosen
    uniformly from the family of all networks with ![](img/Formula_05_007.png) nodes
    and ![](img/Formula_05_010.png) edges. In this recipe, ![](img/Formula_05_011.png)
    and ![](img/Formula_05_012.png). The `dense` prefix indicates that this routine
    uses an algorithm that should be faster than the alternative `gnm_random_graph`
    for dense networks with a relatively large number of edges compared to nodes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`dense_gnm_random_graph` 函数生成一个（密集）随机网络，网络从所有具有 ![](img/Formula_05_007.png)
    个节点和 ![](img/Formula_05_010.png) 条边的网络族中均匀选择。在这个示例中，![](img/Formula_05_011.png)
    和 ![](img/Formula_05_012.png)。`dense` 前缀表示该函数使用的算法应比替代的 `gnm_random_graph` 在边与节点比值较大的密集网络中速度更快。'
- en: The adjacency matrix of a network is easy to generate, especially in sparse
    form, when the graph is relatively small. For larger networks, this can be an
    expensive operation, so it might not be practical, particularly if you convert
    it into a full matrix, as we saw in this recipe. You don’t need to do this in
    general, since we can simply use the sparse matrix generated by the `adjacency_matrix`
    routine and the sparse linear algebra tools in the SciPy `sparse` module instead.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的邻接矩阵很容易生成，特别是在图较小时，使用稀疏形式尤为方便。对于较大的网络，这可能是一个昂贵的操作，因此可能不太实际，特别是当你像本示例中那样将其转换为完整矩阵时。通常你不需要这样做，因为我们可以简单地使用
    `adjacency_matrix` 函数生成的稀疏矩阵，并使用 SciPy `sparse` 模块中的稀疏线性代数工具。
- en: The matrix powers provide information about the number of paths of a given length.
    This can easily be seen by tracing through the definitions of matrix multiplication.
    Remember that the entries of the adjacency matrix are 1 when there is an edge
    (path of length 1) between two given nodes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的幂次提供了关于给定长度路径数量的信息。通过矩阵乘法的定义，可以很容易地看出这一点。记住，当两个节点之间存在边（路径长度为1）时，邻接矩阵中的条目为1。
- en: There’s more...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: The Eigenvalues of the adjacency matrix for a network provide some additional
    information about the structure of the network, such as the bounds for the chromatic
    number of the network. (See the *Coloring a network* recipe for more information
    about coloring a network.) There is a separate routine for computing the Eigenvalues
    of the adjacency matrix. For example, the `adjacency_spectrum` routine to generate
    the Eigenvalues of the adjacency matrix of a network. Methods involving the Eigenvalues
    of a matrix associated with a network are usually called *spectral methods*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的邻接矩阵的特征值提供了关于网络结构的额外信息，比如网络的着色数界限。（有关着色网络的更多信息，请参见 *着色网络* 这一部分。）有一个单独的函数用于计算邻接矩阵的特征值。例如，`adjacency_spectrum`
    函数可以生成网络邻接矩阵的特征值。涉及到与网络相关的矩阵特征值的方法通常被称为 *谱方法*。
- en: There are other matrices associated with networks, such as the *incidence matrix*
    and the *Laplacian matrix*. The incidence matrix of a network is an ![](img/Formula_05_013.png)
    matrix, where ![](img/Formula_05_014.png) is the number of nodes and ![](img/Formula_05_015.png)
    is the number of edges. This has an ![](img/Formula_05_016.png)th entry of 1 if
    node ![](img/Formula_05_017.png) appears in edge ![](img/Formula_05_018.png) and
    0 otherwise. The Laplacian matrix of a network is defined to be the ![](img/Formula_05_019.png)
    matrix, where ![](img/Formula_05_020.png) is the diagonal matrix containing the
    degrees of the nodes in the network and ![](img/Formula_05_021.png) is the adjacency
    matrix of the network. Both of these matrices are useful for analyzing networks.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中还有其他矩阵，如*关联矩阵*和*拉普拉斯矩阵*。网络的关联矩阵是一个![](img/Formula_05_013.png)矩阵，其中![](img/Formula_05_014.png)是节点数，![](img/Formula_05_015.png)是边的数量。如果节点![](img/Formula_05_017.png)出现在边![](img/Formula_05_018.png)中，则该矩阵的![](img/Formula_05_016.png)项为1，否则为0。网络的拉普拉斯矩阵定义为![](img/Formula_05_019.png)矩阵，其中![](img/Formula_05_020.png)是包含网络中节点度数的对角矩阵，![](img/Formula_05_021.png)是网络的邻接矩阵。这两种矩阵对于网络分析非常有用。
- en: Creating directed and weighted networks
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建有向加权网络
- en: Simple networks, such as those described in the previous recipes, are useful
    for describing networks where the direction of an edge is unimportant and where
    the edges carry equal weight. In practice, most networks carry additional information,
    such as weights or directions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 像之前食谱中描述的简单网络，对于描述边的方向不重要且边权相等的网络非常有用。实际上，大多数网络携带额外的信息，如权重或方向。
- en: In this recipe, we will create a directed and weighted network and explore some
    of the basic properties of such networks.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将创建一个有向加权网络，并探索此类网络的一些基本属性。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will need the NetworkX package, imported under the `nx`
    alias (as usual), the Matplotlib `pyplot` module imported as `plt`, and the NumPy
    package imported as `np`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，我们需要使用NetworkX包，通过别名`nx`导入（如同往常一样），Matplotlib的`pyplot`模块以`plt`导入，以及NumPy包以`np`导入。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following steps outline how to create a directed network with weights,
    as well as how to explore some of the properties and techniques we discussed in
    the previous recipes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了如何创建一个带权重的有向网络，以及如何探索我们在之前的食谱中讨论的一些属性和技术：
- en: 'To create a directed network, we can use the `DiGraph` class from NetworkX
    rather than the simple `Graph` class:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个有向网络，我们可以使用NetworkX中的`DiGraph`类，而不是简单的`Graph`类：
- en: '[PRE71]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'As usual, we must add nodes to the network using the `add_node` or `add_nodes_from`
    method:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常一样，我们必须使用`add_node`或`add_nodes_from`方法向网络中添加节点：
- en: '[PRE72]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To add weighted edges, we can use either the `add_edge` method and provide
    the `weight` keyword argument, or use the `add_weighted_edges_from` method:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加带权重的边，我们可以使用`add_edge`方法并提供`weight`关键字参数，或者使用`add_weighted_edges_from`方法：
- en: '[PRE73]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Next, we must draw the network with arrows to indicate the direction of each
    edge. We must also provide positions for this plot:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须绘制网络，并用箭头表示每条边的方向。我们还必须为此图提供位置：
- en: '[PRE78]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The resulting plot can be seen in the following figure:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图如下所示：
- en: '![Figure 5.3 – A weighted, directed network'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – 一个带权有向网络'
- en: '](img/5.3.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/5.3.jpg)'
- en: Figure 5.3 – A weighted, directed network
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 一个带权有向网络
- en: 'The adjacency matrix of a directed matrix is created in the same way as a simple
    network, but the resulting matrix will not be symmetric:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有向矩阵的邻接矩阵与简单网络创建方式相同，但结果矩阵将不再是对称的：
- en: '[PRE83]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Rather than the number of edges between two given nodes, the adjacency matrix
    contains the sum of the weights of edges between those nodes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与其说是两个给定节点之间的边数，邻接矩阵包含的是这些节点之间边的权重之和。
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `DiGraph` class represents a directed network, where the order of the nodes
    when adding an edge is important. In this recipe, we added two edges for connecting
    nodes 2 and 3, one in each direction. In a simple network (the `Graph` class),
    the addition of the second edge would not add another edge. However, for a directed
    network (the `DiGraph` class), the order that the nodes are given in when adding
    the edge determines the direction.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`DiGraph`类表示一个有向网络，其中添加边时节点的顺序很重要。在本食谱中，我们添加了两条边来连接节点2和节点3，每个方向一条。在简单网络（`Graph`类）中，添加第二条边不会增加另一条边。然而，在有向网络（`DiGraph`类）中，添加边时节点的顺序决定了边的方向。'
- en: There is nothing special about weighted edges except for the addition of the
    `weight` attribute that’s attached to the edge. (Arbitrary data can be attached
    to an edge or node in a network via keyword arguments.) The `add_weighted_edges_from`
    method simply adds the corresponding weight value (the third value in the tuple)
    to the edge in question. Weights can be added to any edge in any network, not
    just the directed networks shown in this recipe.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 加权边没有特别之处，除了附加在边上的`weight`属性。（可以通过关键字参数将任意数据附加到网络中的边或节点。）`add_weighted_edges_from`方法只是将对应的权重值（元组中的第三个值）添加到相关的边上。权重可以添加到任何网络中的任何边，不仅仅是本食谱中展示的有向网络。
- en: The `draw` routine automatically adds arrows to edges when drawing a directed
    network. This behavior can be turned off by passing the `arrows=False` keyword
    argument. The adjacency matrix for a directed or weighted network also differs
    from that of a simple network. In a directed network, the matrix is not generally
    symmetrical, because edges may exist in one direction but not the other. For a
    weighted network, the entries can be different from 1 or 0, and will instead be
    the weight of the corresponding edge.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`例程在绘制有向网络时会自动为边添加箭头。可以通过传递`arrows=False`关键字参数来关闭此行为。有向或加权网络的邻接矩阵也不同于简单网络的邻接矩阵。在有向网络中，矩阵通常不是对称的，因为边可能存在于一个方向上但不在另一个方向上。对于加权网络，矩阵的条目可能不是1或0，而是对应边的权重。'
- en: There’s more...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Weighted networks appear in lots of applications, such as when describing transportation
    networks with distances or speeds. You can also use networks to examine flow through
    a network by providing a *capacity* for edges in the network (as a weight or as
    another attribute). NetworkX has several tools for analyzing flow through a network,
    such as finding the maximum flow through a network via the `nx.maximum_flow` routine.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 加权网络出现在许多应用中，例如描述交通网络中的距离或速度。你还可以使用网络来检查流量通过网络的情况，方法是为网络中的边提供*容量*（作为权重或其他属性）。NetworkX提供了多个分析网络流量的工具，例如通过`nx.maximum_flow`例程找到网络中的最大流量。
- en: Directed networks add directional information to a network. Many real-world
    applications give rise to networks that have unidirectional edges, such as those
    in industrial processes or supply chain networks. This additional directional
    information has consequences for many of the algorithms for working with networks,
    as we’ll see throughout this chapter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有向网络向网络中添加了方向信息。许多实际应用产生了具有单向边的网络，例如工业过程或供应链网络中的那些边。这种额外的方向信息对许多处理网络的算法有影响，正如我们在本章中将看到的那样。
- en: Finding the shortest paths in a network
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络中寻找最短路径
- en: A common problem where networks make an appearance is in the problem of finding
    the shortest – or perhaps more precisely, the highest reward – route between two
    nodes in a network. For instance, this could be the shortest distance between
    two cities, where the nodes represent the cities, and the edges are roads connecting
    pairs of cities. In this case, the weights of the edges would be their lengths.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 网络出现的一个常见问题是找到两个节点之间的最短路径——或者更准确地说，找到最高奖励的路径。例如，这可能是两个城市之间的最短距离，其中节点代表城市，边代表连接城市对的道路。在这种情况下，边的权重就是它们的长度。
- en: In this recipe, we will find the shortest path between two nodes in a network
    with weights.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将找到一个加权网络中两个节点之间的最短路径。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NetworkX package imported, as usual, under
    the `nx` alias, the Matplotlib `pyplot` module imported as `plt`, and a random
    number generator object from NumPy:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，我们将按常规导入NetworkX包，并使用`nx`别名，导入Matplotlib的`pyplot`模块作为`plt`，以及从NumPy导入随机数生成器对象：
- en: '[PRE90]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: How to do it...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to find the shortest path between two nodes in a network:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在网络中找到两个节点之间的最短路径：
- en: 'First, we will create a random network using `gnm_random_graph` and a `seed`
    for this demonstration:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用`gnm_random_graph`和一个`seed`来创建一个随机网络，作为本演示的基础：
- en: '[PRE91]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, we’ll draw the network with a circular arrangement to see how the nodes
    connect:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用圆形布局绘制网络，以便查看节点之间的连接方式：
- en: '[PRE92]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The resulting plot can be seen in the following figure. Here, we can see that
    there is no direct edge from node 7 to node 9:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图形可以在下图中看到。这里，我们可以看到节点7和节点9之间没有直接的边：
- en: '![Figure 5.4 – A randomly generated network with 10 nodes and 17 edges'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 一个随机生成的网络，包含10个节点和17条边'
- en: '](img/5.4.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/5.4.jpg)'
- en: Figure 5.4 – A randomly generated network with 10 nodes and 17 edges
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 一个随机生成的网络，包含10个节点和17条边。
- en: 'Now, we need to add a weight to each of the edges so that some routes are preferable
    to others in terms of the shortest path:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要给每条边添加一个权重，以便在最短路径方面有些路线比其他路线更具优势：
- en: '[PRE95]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Next, we will compute the shortest path from node 7 to node 9 using the `nx.shortest_path`
    routine:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`nx.shortest_path`例程计算从节点7到节点9的最短路径：
- en: '[PRE97]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We can find the length of this shortest path using the `nx.shortest_path_`
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`nx.shortest_path_`来找到这条最短路径的长度。
- en: '`length` routine:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`length`例程：'
- en: '[PRE100]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Here the *length* of the path is the sum of the weights of the edges along the
    shortest path. If the network is not weighted, then this will be equal to the
    number of edges traversed along this path.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里路径的*长度*是沿最短路径遍历的边的权重总和。如果网络没有权重，那么它将等于沿路径遍历的边的数量。
- en: How it works...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The `shortest_path` routine computes the shortest path between each pair of
    nodes. Alternatively, when supplied with the source and destination node, which
    is what we did in this recipe, it computes the shortest path between the two specified
    nodes. We supplied the optional `weight` keyword argument, which makes the algorithm
    find the shortest path according to the *weight* attribute of the edge. This argument
    changes the meaning of *shortest*, with the default being the *fewest edges*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortest_path`例程计算每一对节点之间的最短路径。或者，当提供源节点和目标节点时（这就是我们在本示例中所做的），它计算两个指定节点之间的最短路径。我们提供了可选的`weight`关键字参数，这使得算法根据边的*权重*属性来寻找最短路径。这个参数改变了*最短*的定义，默认情况下是*最少边数*。'
- en: The default algorithm for finding the shortest path between two nodes is Dijkstra’s
    algorithm, which is a staple of computer science and mathematics courses. It is
    a good general-purpose algorithm but is not particularly efficient. Other route-finding
    algorithms include the A* algorithm. Greater efficiency can be obtained by using
    the A* algorithm with additional heuristic information to guide node selection.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 查找两个节点之间最短路径的默认算法是Dijkstra算法，它是计算机科学和数学课程中的基础算法。它是一个通用的算法，但效率并不是特别高。其他的路线寻找算法包括A*算法。通过使用A*算法并加入额外的启发式信息来指导节点选择，可以提高效率。
- en: There’s more...
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: There are many algorithms for finding the shortest path between two nodes in
    a network. There are also variants for finding the maximum weighted path.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多算法可以用来寻找网络中两个节点之间的最短路径。也有一些变体可以寻找最大权重路径。
- en: There are several related problems regarding finding the paths in a network,
    such as the *traveling salesperson problem* and the *route inspection problem*.
    In the traveling salesperson problem, we find a cycle (a path starting and ending
    at the same node) that visits every node in the network, with the smallest (or
    largest) total weight. In the route inspection problem, we seek the shortest cycle
    (by weight) that traverses every edge in the network and returns to the starting
    point. The traveling salesperson problem is known to be NP-hard, but the route
    inspection problem can be solved in polynomial time.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 关于网络中路径查找，有几个相关的问题，比如*旅行推销员问题*和*路径检查问题*。在旅行推销员问题中，我们需要找到一个环路（一个从同一节点出发并返回的路径），它遍历网络中的每个节点，且总权重最小（或最大）。在路径检查问题中，我们寻找遍历网络中每条边并返回起点的最短环路（按权重计算）。旅行推销员问题是已知的NP难题，但路径检查问题可以在多项式时间内解决。
- en: 'A famous problem in graph theory is the bridges at Königsberg, which asks to
    find a path in a network that traverses every edge in the network exactly once.
    It turns out, as proved by Euler, that finding such a path in the Königsberg bridges
    problem is impossible. A path that traverses every edge exactly once is called
    an *Eulerian circuit*. A network that admits an Eulerian circuit is called *Eulerian*.
    A network is Eulerian if and only if every node has an even degree. The network
    representation of the Königsberg bridge problem can be seen in the following figure.
    The edges in this figure represent the different bridges over the rivers, while
    the nodes represent the different land masses. We can see that all four of the
    nodes have an odd degree, which means that there cannot be a path that crosses
    every edge exactly once:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图论中的一个著名问题是哥尼斯堡的桥梁问题，它要求在网络中找到一条路径，使得每条边恰好经过一次。正如欧拉所证明的那样，哥尼斯堡桥问题中找到这样一条路径是不可能的。这样一条恰好经过每条边一次的路径被称为
    *欧拉回路*。一个网络如果包含欧拉回路，则称为 *欧拉网络*。只有当每个节点的度数都是偶数时，网络才是欧拉网络。哥尼斯堡桥问题的网络表示可以在下图中看到。图中的边代表河流上的不同桥梁，而节点代表不同的陆地块。我们可以看到，所有四个节点的度数都是奇数，这意味着不存在一条路径能恰好经过每一条边一次：
- en: '![Figure 5.5 – A network representing the Königsberg bridge problem'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – 代表哥尼斯堡桥问题的网络'
- en: '](img/5.5.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/5.5.jpg)'
- en: Figure 5.5 – A network representing the Königsberg bridge problem
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 代表哥尼斯堡桥问题的网络
- en: The edges represent the bridges between the different land masses represented
    by the nodes.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些边代表连接不同陆地块的桥梁，这些陆地块由节点表示。
- en: Quantifying clustering in a network
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络中的聚类度量
- en: There are various quantities associated with networks that measure the characteristics
    of the network. For example, the clustering coefficient of a node measures the
    interconnectivity between the nodes nearby (here, nearby means connected by an
    edge). In effect, it measures how close the neighboring nodes are to forming a
    complete network or *clique*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中有各种量度用于衡量网络的特征。例如，节点的聚类系数衡量了附近节点之间的互联性（此处，附近指的是通过边连接的节点）。实际上，它衡量了相邻节点形成一个完整网络或
    *团体* 的接近程度。
- en: 'The clustering coefficient of a node measures the proportion of the adjacent
    nodes that are connected by an edge; that is, two adjacent nodes form a triangle
    with the given node. We count the number of triangles and divide this by the total
    number of possible triangles that could be formed, given the degree of the node.
    Numerically, the clustering coefficient at a node, ![](img/Formula_05_022.png),
    in a simple unweighted network is given by the following equation:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的聚类系数衡量了邻近节点通过边连接的比例；也就是说，两个相邻节点与给定节点形成一个三角形。我们计算三角形的数量，并将其除以根据节点的度数可以形成的三角形的总数。从数值上讲，在一个简单的无权网络中，节点的聚类系数
    ![](img/Formula_05_022.png) 由以下公式给出：
- en: '![](img/Formula_05_023.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_05_023.jpg)'
- en: Here, ![](img/Formula_05_024.png) is the number of triangles at ![](img/Formula_05_025.png)
    and the denominator is the total possible number of triangles at ![](img/Formula_05_025.png).
    If the degree of ![](img/Formula_05_025.png) (the number of edges from ![](img/Formula_05_025.png))
    is 0 or 1, then we set ![](img/Formula_05_029.png) to 0.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_05_024.png) 是在 ![](img/Formula_05_025.png) 处的三角形数量，分母是 ![](img/Formula_05_025.png)
    处可能形成的三角形总数。如果 ![](img/Formula_05_025.png) 的度数（即从 ![](img/Formula_05_025.png)
    出发的边数）为 0 或 1，则我们将 ![](img/Formula_05_029.png) 设为 0。
- en: In this recipe, we will learn how to compute the clustering coefficient of a
    node in a network.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何计算网络中节点的聚类系数。
- en: Getting ready
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will need the NetworkX package under the `nx` alias and
    the Matplotlib `pyplot` module imported as `plt`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将需要导入 `nx` 别名下的 NetworkX 包和作为 `plt` 导入的 Matplotlib `pyplot` 模块。
- en: How to do it...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何进行...
- en: 'The following steps show you how to compute the clustering coefficient of a
    node in a network:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何计算网络中节点的聚类系数：
- en: 'First, we need to create a sample network to work with:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个样本网络来进行操作：
- en: '[PRE104]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Next, we must draw the network so that we can compare the clustering coefficients
    that we’ll be calculating. This will allow us to see how these nodes appear in
    the network:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须绘制网络，以便我们能够比较我们将要计算的聚类系数。这样，我们可以看到这些节点在网络中的表现：
- en: '[PRE110]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The resulting plot can be seen in the following figure:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图表可以在下图中看到：
- en: '![Figure 5.6 – A sample network for testing clustering'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – 用于测试聚类的样本网络'
- en: '](img/5.6.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/5.6.jpg)'
- en: Figure 5.6 – A sample network for testing clustering
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 测试聚类的示例网络
- en: 'Now, we can compute the clustering coefficients of the nodes in the network
    using the `nx.clustering` routine:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `nx.clustering` 例程计算网络中节点的聚类系数：
- en: '[PRE113]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The output of the `nx.clustering` routine is a dictionary over the nodes in
    the network. So, we can print some selected nodes as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nx.clustering` 例程的输出是网络中各个节点的字典。因此，我们可以按如下方式打印一些选定的节点：'
- en: '[PRE114]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The average clustering coefficient for all the nodes in the network can be
    computed using the `nx.average_clustering` routine:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有网络节点的平均聚类系数可以通过 `nx.average_clustering` 例程计算：
- en: '[PRE119]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This average clustering coefficient indicates that, on average, the nodes have
    approximately 1/3 of the total possible connections.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这个平均聚类系数表明，平均而言，节点大约拥有 1/3 的所有可能连接。
- en: How it works...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The clustering coefficient of a node measures how close the neighborhood of
    that node is to being a complete network (all the nodes are connected). In this
    recipe, we have three different computed values: 0 has a clustering coefficient
    of 0.5, 2 has a clustering coefficient of 1.0, and 6 has a clustering coefficient
    of 0\. This means that the nodes connected to node 2 form a complete network,
    which is because we designed our network in this way. (Nodes 0 to 4 form a complete
    network by design.) The neighborhood of node 6 is very far from being complete
    since there are no interconnecting edges between either of its neighbors.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的聚类系数衡量的是该节点的邻域有多接近于一个完整的网络（所有节点都相互连接）。在这个例子中，我们计算了三个不同的值：节点 0 的聚类系数为 0.5，节点
    2 的聚类系数为 1.0，节点 6 的聚类系数为 0。这意味着与节点 2 相连的节点构成了一个完整的网络，这是因为我们设计网络时就是这样设计的。（节点 0
    到 4 按设计形成了一个完整的网络。）节点 6 的邻域离完整网络非常远，因为它的两个邻居之间没有任何相互连接的边。
- en: The average clustering value is a simple average of the clustering coefficients
    over all the nodes in the network. It is not quite the same as the global clustering
    coefficient (computed using the `nx.transitivity` routine in NetworkX), but it
    does give us an idea of how close the network is to being a complete network as
    a whole. The global clustering coefficient measures the ratio of the number of
    triangles to the number of triplets – a collection of three nodes that are connected
    by at least two edges – over the whole network.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 平均聚类值是对网络中所有节点的聚类系数的简单平均。它与全局聚类系数（通过 NetworkX 中的 `nx.transitivity` 例程计算）略有不同，但它确实能给我们一个网络整体接近完整网络的程度的概念。全局聚类系数衡量的是三角形的数量与三元组的数量之间的比率——三元组是由至少两条边连接的三个节点组成的集合——覆盖整个网络。
- en: The difference between global clustering and average clustering is quite subtle.
    The global clustering coefficient measures the clustering of the network as a
    whole, but the average clustering coefficient measures how much, on average, the
    network is locally clustered. The difference is best seen in a windmill network,
    which consists of a single node surrounded by a circle of an even number of nodes.
    All the nodes are connected to the center, but the nodes on the circle are only
    connected in an alternating pattern. The outer nodes have a local clustering coefficient
    of 1, while the center node has a local clustering coefficient of ![](img/Formula_05_030.png),
    where ![](img/Formula_05_031.png) denotes the number of triangles joining the
    center node. However, the global clustering coefficient is ![](img/Formula_05_032.png).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 全局聚类和平均聚类之间的差异相当微妙。全局聚类系数衡量的是整个网络的聚类程度，而平均聚类系数衡量的是网络在局部的聚类程度。这个差异在风车型网络中最为明显，该网络由一个中心节点和一个偶数个节点围成的圆圈组成。所有节点都连接到中心，但圆圈上的节点只按交替的模式连接。外部节点的局部聚类系数为
    1，而中心节点的局部聚类系数为 ![](img/Formula_05_030.png)，其中 ![](img/Formula_05_031.png) 表示连接中心节点的三角形数量。然而，全局聚类系数是
    ![](img/Formula_05_032.png)。
- en: There’s more...
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Clustering coefficients are related to *cliques* in a network. A clique is a
    subnetwork that is complete (all the nodes are connected by an edge). An important
    problem in network theory is finding the maximal cliques in a network, which is
    a very difficult problem in general (here, maximal means *cannot be* *made larger*).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类系数与网络中的 *团体*（cliques）有关。团体是一个子网络，其中所有节点都通过边连接。网络理论中的一个重要问题是寻找网络中的最大团体，这通常是一个非常困难的问题（这里，最大意味着
    *不能更大*）。
- en: Coloring a network
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给网络着色
- en: Networks are also useful in scheduling problems, where you need to arrange activities
    into different slots so that there are no conflicts. For example, we could use
    networks to schedule classes to make sure that students who are taking different
    options do not have to be in two classes at once. In this scenario, the nodes
    will represent the different classes and the edges will indicate that students
    are taking both classes. The process we use to solve these kinds of problems is
    called *network coloring*. This process involves assigning the fewest possible
    colors to the nodes in a network so that no two adjacent nodes have the same color.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 网络在调度问题中也非常有用，在这些问题中，你需要将活动安排到不同的时间段，以避免冲突。例如，我们可以使用网络来安排课程，以确保选择不同课程的学生不会同时上两门课。在这种情况下，节点将表示不同的课程，边将表示学生同时选修两门课程。我们用来解决这类问题的过程叫做*网络着色*。这个过程涉及为网络中的节点分配最少的颜色，以确保没有两个相邻节点有相同的颜色。
- en: In this recipe, we will learn how to color a network to solve a simple scheduling
    problem.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何着色一个网络以解决简单的调度问题。
- en: Getting ready
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need the NetworkX package imported under the `nx` alias
    and the Matplotlib `pyplot` module imported as `plt`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要导入NetworkX包并使用`nx`别名，同时导入Matplotlib的`pyplot`模块并命名为`plt`。
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to solve a network coloring problem:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来解决网络着色问题：
- en: 'First, we will create a sample network to use in this recipe:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个示例网络，以便在这个配方中使用：
- en: '[PRE122]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Next, we will draw the network so that we can understand the coloring when
    it is generated. For this, we will use the `draw_circular` routine:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将绘制网络，以便在生成着色时理解它。为此，我们将使用`draw_circular`例程：
- en: '[PRE127]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The resulting plot can be seen in the following figure:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图可以在下图中看到：
- en: '![Figure 5.7 – Example network for a simple scheduling problem'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – 简单调度问题的示例网络](img/5.7.jpg)'
- en: '](img/5.7.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/5.7.jpg)'
- en: Figure 5.7 – Example network for a simple scheduling problem
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 简单调度问题的示例网络
- en: 'We will generate the coloring using the `nx.greedy_color` routine:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`nx.greedy_color`例程生成着色：
- en: '[PRE130]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'To see the actual colors that were used in this coloring, we will generate
    a set of values from the `coloring` dictionary:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看实际使用的颜色，我们将从`coloring`字典中生成一组值：
- en: '[PRE133]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Notice that the number of colors in the coloring cannot be smaller since nodes
    0, 1, 2, and 6 form a complete network – each of these nodes is connected to the
    others, so each of them requires a separate color.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，着色中的颜色数量不能更少，因为节点0、1、2和6构成了一个完全网络——这些节点彼此相连，因此每个节点都需要一个单独的颜色。
- en: How it works...
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `nx.greedy_color` routine colors the network using one of several possible
    strategies. By default, it works in order of degree from largest to smallest.
    In our case, it started by assigning color 0 to node 2, which has a degree of
    6, then color 1 to node 0, which has a degree of 4, and so on. The first available
    color is chosen for each node in this sequence. This is not necessarily the most
    efficient algorithm for coloring a network.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`nx.greedy_color`例程使用几种可能的策略之一来着色网络。默认情况下，它按度数从大到小的顺序工作。在我们的例子中，它首先将颜色0分配给度数为6的节点2，然后将颜色1分配给度数为4的节点0，以此类推。在这个序列中，为每个节点选择第一个可用的颜色。这不一定是最有效的着色算法。'
- en: Any network can be colored by assigning every node a different color, but in
    most cases, fewer colors are necessary. In the recipe, the network has seven nodes,
    but only four colors are required. The smallest number of colors necessary is
    called the **chromatic number** of the network.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 任何网络都可以通过为每个节点分配不同的颜色来着色，但在大多数情况下，只需要更少的颜色。在这个配方中，网络有七个节点，但只需要四种颜色。所需的最小颜色数量称为网络的**色度数**。
- en: The problem we have described here is the *node coloring* problem. There is
    a related problem known as *edge coloring*. We can turn an edge coloring problem
    into a node coloring problem by considering the network whose nodes are the edges
    of the original network, with an edge between two of these notes added whenever
    the edges share a common node in the original network.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里描述的问题是*节点着色*问题。还有一个相关的问题叫做*边着色*。我们可以通过考虑一个网络，其中的节点是原始网络的边，并且当两个节点之间存在共同的原始网络节点时，在这两个节点之间添加一条边，从而将边着色问题转化为节点着色问题。
- en: There’s more...
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are several variations of the coloring problem for networks. One such
    variation is the **list coloring problem**, in which we seek a coloring for a
    network where each node is given a color from a predefined list of possible colors.
    This problem is more difficult than the general coloring problem.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 网络着色问题有多种变体。一个这样的变体是**列表着色问题**，其中我们为网络中的每个节点从预定义的颜色列表中选择一种颜色进行着色。这个问题比一般的着色问题更为复杂。
- en: The general coloring problem has surprising results. For example, every planar
    network can be colored by, at most, four different colors. This is a famous theorem
    from graph theory called the **four-color theorem**, which was proved by Appel
    and Haken in 1977\. This theorem states that every planar graph has a chromatic
    number that is no larger than 4.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的着色问题有一些令人惊讶的结果。例如，每个平面网络最多可以用四种不同的颜色进行着色。这是图论中的一个著名定理，称为**四色定理**，由Appel和Haken在1977年证明。这个定理表明，每个平面图的色数不超过4。
- en: Finding minimal spanning trees and dominating sets
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找最小生成树和支配集
- en: Networks have applications for a wide variety of problems. Two obvious areas
    that see many applications are communication and distribution. For example, we
    might wish to find a way of distributing goods to several cities (nodes) in a
    road network that covers the smallest distance from a particular point. For problems
    like this, we need to look at minimal spanning trees and dominating sets.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 网络在许多问题中都有应用。通信和分配是两个显而易见的应用领域。例如，我们可能希望找到一种将商品分配到多个城市（节点）的方法，前提是它能覆盖从某个特定点出发的最小距离。对于此类问题，我们需要研究最小生成树和支配集。
- en: In this recipe, we will find a minimal spanning tree and a dominating set in
    a network.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将找到网络中的最小生成树和支配集。
- en: Getting ready
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need to import the NetworkX package under the `nx` alias
    and the Matplotlib `pyplot` module as `plt`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，我们需要导入`nx`别名下的NetworkX包和Matplotlib的`pyplot`模块，别名为`plt`。
- en: How to do it...
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to find a minimum spanning tree and dominating set for a
    network:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为网络查找最小生成树和支配集：
- en: 'First, we will create a sample network to analyze:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个示例网络来进行分析：
- en: '[PRE136]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Next, as usual, we will draw the network before doing any analysis:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，和往常一样，我们将在进行任何分析之前先绘制网络：
- en: '[PRE137]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The minimum spanning tree can be computed using the `nx.minimum_``spanning_tree`
    routine:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小生成树可以使用`nx.minimum_``spanning_tree`例程来计算：
- en: '[PRE141]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Next, we will overlay the edges of the minimum spanning tree onto the plot:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将把最小生成树的边叠加到图上：
- en: '[PRE146]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Finally, we will find a dominating set – a set where every node in the network
    is adjacent to at least one node from the set – for the network using the `nx.dominating_set`
    routine:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`nx.dominating_set`例程为网络找到一个支配集——一个网络中每个节点都与集合中的至少一个节点相邻的集合：
- en: '[PRE148]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'A plot of the network with the minimum spanning tree overlaid can be seen in
    the following figure:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下图中看到叠加了最小生成树的网络图：
- en: '![Figure 5.8 – The network drawn with the minimum spanning tree overlaid'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8 – 显示叠加最小生成树的网络'
- en: '](img/5.8.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/5.8.jpg)'
- en: Figure 5.8 – The network drawn with the minimum spanning tree overlaid
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 显示叠加最小生成树的网络
- en: The edges used in the minimum spanning tree are the bold unbroken lines, and
    the edges from the original network are the dashed lines. The fact that the minimum
    spanning tree is indeed a tree is slightly obscured by the layout, but we can
    easily trace through and see that no two nodes connected to a single parent node
    are connected.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 最小生成树中使用的边是粗体的未断开的线，而原始网络中的边是虚线。尽管最小生成树实际上是一个树，但由于布局的原因这一点稍显模糊，但我们可以轻松地追踪并看到没有任何两个节点连接到同一个父节点的情况。
- en: How it works...
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The *spanning tree* of a network is a tree contained in the network that contains
    all the nodes. A *minimum* spanning tree is a spanning tree that contains the
    fewest edges possible – or has the lowest total weight. Minimum spanning trees
    are useful for distribution problems over a network. A simple algorithm for finding
    minimum spanning trees is to simply select the edges (of the smallest weight first,
    if the network is weighted) in such a way that it does not create cycles until
    this is no longer possible.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的*生成树*是包含网络中所有节点的树。*最小*生成树是包含最少边的生成树——或具有最低总权重的生成树。最小生成树在网络分发问题中非常有用。找到最小生成树的一个简单算法是选择边（如果网络是加权的，则优先选择最小权重的边），以避免形成环路，直到无法再避免为止。
- en: A *dominating set* for a network is a set of vertices where every node in the
    network is adjacent to at least one node in the dominating set. Dominating sets
    have applications in communication networks. We are often interested in finding
    minimal dominating sets, but this is computationally difficult. Testing whether
    there is a dominating set that’s smaller than a given size is NP-complete. However,
    there are some efficient algorithms for finding the smallest dominating sets for
    certain classes of graphs. Informally speaking, the problem is that once you’ve
    identified a candidate for a minimum-size dominating set, you have to verify that
    there are no dominating sets that are smaller in size. This is very difficult
    if you do not know all the possible dominating sets in advance.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的*支配集*是一个顶点集合，其中网络中的每个节点都与支配集中的至少一个节点相邻。支配集在通信网络中有应用。我们通常希望找到最小的支配集，但这在计算上是困难的。测试是否存在一个比给定大小更小的支配集是NP完全问题。然而，对于某些类型的图，存在一些高效的算法来找到最小的支配集。非正式地说，问题在于，一旦你找到了一个最小大小支配集的候选集，你还必须验证是否没有比它更小的支配集。如果你事先不知道所有可能的支配集，这会变得非常困难。
- en: Further reading
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'There are several classical texts on graph theory, including books by Bollobás
    and Diestel:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 关于图论，有几本经典的著作，包括Bollobás和Diestel的书：
- en: 'Diestel, R., 2010\. *Graph Theory*. 3rd ed. Berlin: Springer.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Diestel, R., 2010. *图论*。第3版。柏林：Springer。
- en: 'Bollobás, B., 2010\. *Modern Graph Theory*. New York, NY: Springer.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bollobás, B., 2010. *现代图论*。纽约，NY：Springer。
