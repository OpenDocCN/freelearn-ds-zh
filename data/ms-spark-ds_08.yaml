- en: Chapter 8. Building a Recommendation System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。构建推荐系统
- en: If one were to choose an algorithm to showcase data science to the public, a
    recommendation system would certainly be in the frame. Today, recommendation systems
    are everywhere. The reason for their popularity is down to their versatility,
    usefulness, and broad applicability. Whether they are used to recommend products
    based on user's shopping behavior or to suggest new movies based on viewing preferences,
    recommenders are now a fact of life. It is even possible that this book was magically
    suggested based on what marketing companies know about you, such as your social
    network preferences, your job status, or your browsing history.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要选择一个算法来向公众展示数据科学，推荐系统肯定会成为其中的一部分。今天，推荐系统无处不在。它们之所以如此受欢迎，原因在于它们的多功能性、实用性和广泛适用性。无论是根据用户的购物行为推荐产品，还是根据观看偏好建议新电影，推荐系统现在已经成为生活的一部分。甚至可能是这本书是基于你的社交网络偏好、工作状态或浏览历史等营销公司所知道的信息神奇地推荐给你的。
- en: 'In this chapter, we will demonstrate how to recommend music content using raw
    audio signal. For that purpose, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演示如何使用原始音频信号推荐音乐内容。为此，我们将涵盖以下主题：
- en: Using Spark to process audio files stored on HDFS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spark处理存储在HDFS上的音频文件
- en: Learning about *Fourier transform* for audio signal transformation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习关于*傅立叶变换*用于音频信号转换
- en: Using Cassandra as a caching layer between online and offline layers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cassandra作为在线和离线层之间的缓存层
- en: Using *PageRank* as an unsupervised recommendation algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*PageRank*作为无监督的推荐算法
- en: Integrating Spark Job Server with the Play framework to build an end-to-end
    prototype
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Spark作业服务器与Play框架集成，构建端到端原型
- en: Different approaches
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的方法
- en: 'The end goal of a recommendation system is to suggest new items based on a
    user''s historical usage and preferences. The basic idea is to use a ranking for
    any product that a customer has been interested in in the past. This ranking can
    be explicit (asking a user to rank a movie from 1 to 5) or implicit (how many
    times a user visited this page). Whether it is a product to buy, a song to listen
    to, or an article to read, data scientists usually address this issue from two
    different angles: *collaborative filtering* and *content-based filtering*.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统的最终目标是根据用户的历史使用和偏好建议新的物品。基本思想是对客户过去感兴趣的任何产品使用排名。这种排名可以是显式的（要求用户对电影进行1到5的排名）或隐式的（用户访问此页面的次数）。无论是购买产品、听歌曲还是阅读文章，数据科学家通常从两个不同的角度解决这个问题：*协同过滤*和*基于内容的过滤*。
- en: Collaborative filtering
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协同过滤
- en: 'Using this approach, we leverage big data by collecting more information about
    the behavior of people. Although an individual is by definition unique, their
    shopping behavior is usually not, and some similarities can always be found with
    others. The recommended items will be targeted for a particular individual, but
    they will be derived by combining the user''s behavior with that of similar users.
    This is the famous quote from most retail websites:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们通过收集有关人们行为的更多信息来利用大数据。尽管个体在定义上是独特的，但他们的购物行为通常不是，总是可以找到一些与其他人的相似之处。推荐的物品将针对特定个人，但它们将通过将用户的行为与类似用户的行为相结合来推导。这是大多数零售网站的著名引用：
- en: '*"People who bought this also bought that..."*'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“购买这个的人也购买了那个……”*'
- en: Of course, this requires prior knowledge about the customer, their past purchases
    and you must also have enough information about other customers to compare against.
    Therefore, a major limiting factor is that items must have been viewed at least
    once in order to be shortlisted as a potential recommended item. In fact, we cannot
    recommend an item until it has been seen/bought at least once.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这需要关于客户、他们的过去购买以及其他客户的足够信息进行比较。因此，一个主要的限制因素是物品必须至少被查看一次才能被列为潜在的推荐物品。事实上，直到物品被查看/购买至少一次，我们才能推荐该物品。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The iris dataset of collaborative filtering is usually done using samples of
    the LastFM dataset: [http://labrosa.ee.columbia.edu/millionsong/lastfm](http://labrosa.ee.columbia.edu/millionsong/lastfm).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 协同过滤的鸢尾花数据集通常使用LastFM数据集的样本进行：[http://labrosa.ee.columbia.edu/millionsong/lastfm](http://labrosa.ee.columbia.edu/millionsong/lastfm)。
- en: Content-based filtering
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于内容的过滤
- en: An alternative approach, rather than using similarities with other users, involves
    looking at the product itself and the type of products a customer has been interested
    in in the past. If you are interested in both *classical music* and *speed meta*l,
    it is safe to assume that you would probably buy (at least consider) any new albums
    mixing up both classical rhythms with heavy metal riffs. Such a recommendation
    would be difficult to find in a collaborative filtering approach as no one in
    your neighborhood shares your musical taste.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用其他用户相似性不同的替代方法涉及查看产品本身以及客户过去感兴趣的产品类型。如果你对*古典音乐*和*速度金属*都感兴趣，那么可以安全地假设你可能会购买（至少考虑）任何将古典节奏与重金属吉他独奏混合的新专辑。这样的推荐在协同过滤方法中很难找到，因为你周围没有人分享你的音乐口味。
- en: The main advantage of this approach is that, assuming we have enough knowledge
    about the content to recommend (such as the categories, labels, and so on), we
    can recommend a new item even when no one has seen it before. The downside is
    that the model can be more difficult to build and selecting the right features
    with no loss of information can be challenging.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要优势是，假设我们对要推荐的内容有足够的了解（比如类别、标签等），即使没有人看过它，我们也可以推荐一个新的物品。缺点是，模型可能更难建立，并且选择正确的特征而不丢失信息可能具有挑战性。
- en: Custom approach
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义方法
- en: 'As the focus of this book is *Mastering Spark for Data Science* we wish to
    provide the reader with a new and innovative way of addressing the recommendation
    issue, rather than just explaining the standard collaborative filtering algorithm
    that anyone could build using the out-of-the-box Spark APIs and following a basic
    tutorial [http://spark.apache.org/docs/latest/mllib-collaborative-filtering.html](http://spark.apache.org/docs/latest/mllib-collaborative-filtering.html).
    Let''s start with a hypothesis:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的重点是*数据科学中的Spark*，我们希望为读者提供一种新颖的创新方式来解决推荐问题，而不仅仅是解释任何人都可以使用现成的Spark API构建的标准协同过滤算法，并遵循基本教程[http://spark.apache.org/docs/latest/mllib-collaborative-filtering.html](http://spark.apache.org/docs/latest/mllib-collaborative-filtering.html)。让我们从一个假设开始：
- en: '*If we were to recommend songs to end-users, couldn''t we build a system that
    would recommend songs, not based on what people like or dislike, nor on the song
    attributes (genre, artist), but rather on how the song really sounds and how you
    feel about it?*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们要向最终用户推荐歌曲，我们是否可以构建一个系统，不是基于人们喜欢或不喜欢的歌曲，也不是基于歌曲属性（流派、艺术家），而是基于歌曲的真实声音和你对它的感觉呢？*'
- en: In order to demonstrate how to build such a system, (and since you likely do
    not have access to a public dataset containing both music content and ranking
    a legitimate one at least), we will explain how to construct it locally using
    your own personal music library. Feel free to play along!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何构建这样一个系统（因为您可能没有访问包含音乐内容和排名的公共数据集，至少是合法的），我们将解释如何使用您自己的个人音乐库在本地构建它。随时加入！
- en: Uninformed data
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未知数据
- en: The following technique could be seen as something of a game changer in how
    most modern data scientists work. While it is common to work with structured and
    unstructured text, it is less common to work on raw binary data the reason being
    the gap between computer science and data science. Textual processing is limited
    to a standard set of operations that most will be familiar with, that is, acquiring,
    parsing and storing, and so on. Instead of restricting ourselves to these operations,
    we will work directly with audio transforming and enrich the uninformed signal
    data into informed transcription. In doing this, we enable a new type of data
    pipeline that is analogous to teaching a computer to *hear* the voice from audio
    files.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下技术可以被视为现代大多数数据科学家工作方式的一种改变。虽然处理结构化和非结构化文本很常见，但处理原始二进制数据却不太常见，原因在于计算机科学和数据科学之间的差距。文本处理局限于大多数人熟悉的一套标准操作，即获取、解析和存储等。我们将直接处理音频，将未知信号数据转换和丰富为知情的转录。通过这样做，我们实现了一种类似于教计算机从音频文件中“听到”声音的新型数据管道。
- en: A second (breakthrough) idea that we encourage here is a shift in thinking around
    how data scientists engage with Hadoop and big data nowadays. While many still
    consider these technologies as just *yet another database*, we want to showcase
    the vast array of possibilities that become available with these tools. After
    all, no one laughs at the data scientist who can train a machine to talk to customers
    or make sense of call center recordings.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里鼓励的第二个（突破性）想法是，改变数据科学家如今与Hadoop和大数据打交道的方式。虽然许多人仍然认为这些技术只是*又一个数据库*，但我们想展示使用这些工具可以获得的广泛可能性。毕竟，没有人会嘲笑能够训练机器与客户交谈或理解呼叫中心录音的数据科学家。
- en: Processing bytes
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理字节
- en: 'The first thing to consider is the audio file format. The `.wav` files can
    be processed pretty much as they are using the `AudioSystem` library (from `javax.sound`),
    while an `.mp3` would require pre-processing using external codec libraries. If
    we read a file from an `InputStream`, we can create an output byte array containing
    audio signals as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要考虑的是音频文件格式。`.wav`文件可以使用`AudioSystem`库（来自`javax.sound`）进行处理，而`.mp3`则需要使用外部编解码库进行预处理。如果我们从`InputStream`中读取文件，我们可以创建一个包含音频信号的输出字节数组，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Songs are usually encoded using a sample rate of 44KHz, which, according to
    the **Nyquist** theorem, is twice as large as the highest frequency that the human
    ear can perceive (covering ranges from 20Hz to 20KHz).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 歌曲通常使用44KHz的采样率进行编码，根据**奈奎斯特**定理，这是人耳可以感知的最高频率的两倍（覆盖范围从20Hz到20KHz）。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about the Nyquist theorem, please visit: [http://redwood.berkeley.edu/bruno/npb261/aliasing.pdf](http://redwood.berkeley.edu/bruno/npb261/aliasing.pdf).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有关奈奎斯特定理的更多信息，请访问：[http://redwood.berkeley.edu/bruno/npb261/aliasing.pdf](http://redwood.berkeley.edu/bruno/npb261/aliasing.pdf)。
- en: 'In order to represent the sound that a human being can hear, we would need
    around 44,000 samples per seconds, hence 176,400 bytes per second for stereo (two
    channels). The latter is the following byte frequency:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示人类可以听到的声音，我们需要每秒大约44,000个样本，因此立体声（两个声道）每秒需要176,400字节。后者是以下字节频率：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, we access the audio signal by processing the output byte array and
    plotting the first few bytes of our sample data (in this case, *Figure 1*, shows
    the Mario Bros theme song). Note the timestamp that can be retrieved using both
    the byte index and the byte frequency values, like so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过处理输出的字节数组并绘制样本数据的前几个字节（在本例中，*图1*显示了马里奥兄弟主题曲）来访问音频信号。请注意，可以使用字节索引和字节频率值检索时间戳，如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Processing bytes](img/image_08_001.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![处理字节](img/image_08_001.jpg)'
- en: 'Figure 1: Mario Bros theme - time domain'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：马里奥兄弟主题曲 - 时域
- en: 'For convenience, we wrap all these audio characteristics into a case class
    `Audio` (shown in the following snippet) to which we will add additional utility
    methods as we go along in the chapter:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们将所有这些音频特征封装到一个`Audio`案例类中（如下面的代码段所示），随着我们在本章中的进展，我们将添加额外的实用方法：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating a scalable code
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可扩展的代码
- en: 'Now that we have created functions to extract audio signals from `.wav` files
    (via a `FileInputStream`), naturally the next step is to use it to process the
    remaining records stored on HDFS. As already highlighted in previous chapters,
    this isn''t a difficult task once the logic works on a single record. In fact,
    Spark comes with a utility to process binary data out of the box, so we simply
    plug in the following function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了从`.wav`文件中提取音频信号的函数（通过`FileInputStream`），自然的下一步是使用它来处理存储在HDFS上的其余记录。正如在前几章中已经强调的那样，一旦逻辑在单个记录上运行，这并不是一个困难的任务。事实上，Spark自带了一个处理二进制数据的实用程序，因此我们只需插入以下函数：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We make sure we only send `.wav` files to our processor and get a new RDD made
    of a filename (the song name) and its corresponding `Audio` case class (including
    the extracted audio signal).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保只将`.wav`文件发送到我们的处理器，并获得一个由文件名（歌曲名）和其对应的`Audio` case类（包括提取的音频信号）组成的新RDD。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `binaryFiles` method of Spark reads a file whole (without splitting it)
    and outputs an RDD containing both the file path and its corresponding input stream.
    Therefore, it is advised to work on relatively small files (perhaps just a few
    megabytes) as it clearly affects memory consumption and hence performance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Spark的`binaryFiles`方法读取整个文件（不进行分割）并输出一个包含文件路径和其对应输入流的RDD。因此，建议处理相对较小的文件（可能只有几兆字节），因为这显然会影响内存消耗和性能。
- en: From time to frequency domain
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从时间到频率域
- en: Accessing the audio time domain is a great achievement, but sadly it's not much
    value on its own. However, we can use it to better understand what the signal
    truly represents, that is, to extract the hidden frequencies it comprises. Naturally,
    we can convert the time domain signal to a frequency domain using *Fourier transform*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 访问音频时域是一个很大的成就，但遗憾的是它本身并没有太多价值。然而，我们可以使用它来更好地理解信号的真实含义，即提取它包含的隐藏频率。当然，我们可以使用*傅里叶变换*将时域信号转换为频域。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about *Fourier transform* at [http://www.phys.hawaii.edu/~jgl/p274/fourier_intro_Shatkay.pdf](http://www.phys.hawaii.edu/~jgl/p274/fourier_intro_Shatkay.pdf).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://www.phys.hawaii.edu/~jgl/p274/fourier_intro_Shatkay.pdf](http://www.phys.hawaii.edu/~jgl/p274/fourier_intro_Shatkay.pdf)了解更多关于*傅里叶变换*的知识。
- en: As a summary, without going into too much detail or having to tackle the complex
    equations, the basic assumption that Joseph Fourier makes in his legendary and
    eponymous formula is that all signals are made of an infinite accumulation of
    sine waves from different frequencies and phases.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，不需要过多细节或复杂的方程，约瑟夫·傅里叶在他的传奇和同名公式中所做的基本假设是，所有信号都由不同频率和相位的正弦波的无限累积组成。
- en: Fast Fourier transform
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速傅里叶变换
- en: '**Discrete Fourier transform** (**DFT**) is the summation of different sine
    waves and can be represented using the following equation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**离散傅里叶变换**（**DFT**）是不同正弦波的总和，并可以使用以下方程表示：'
- en: '![Fast Fourier transform](img/image_08_002.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![快速傅里叶变换](img/image_08_002.jpg)'
- en: Although this algorithm is trivial to implement using a brute force approach,
    it is highly inefficient *O(n²)* since for each data point *n*, we have to compute
    the sum of *n* exponents. Therefore, a three-minute song would generate *(3 x
    60 x 176,400)²≈ 10^(15)* number of operations. Instead, Cooley and Tukey contributed
    a **Fast Fourier transform** (**FFT**) using a divide and conquer approach to
    the DFT that reduces the overall time complexity to *O(n.log(n))*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用蛮力方法实现这个算法是微不足道的，但它的效率非常低*O(n²)*，因为对于每个数据点*n*，我们必须计算*n*个指数的和。因此，一首三分钟的歌曲将产生*(3
    x 60 x 176,400)²≈ 10^(15)*数量的操作。相反，Cooley和Tukey采用了一种将DFT的时间复杂度降低到*O(n.log(n))*的分治方法，贡献了**快速傅里叶变换**（**FFT**）。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The official paper describing the Cooley and Tukey algorithm can be found online: [http://www.ams.org/journals/mcom/1965-19-090/S0025-5718-1965-0178586-1/S0025-5718-1965-0178586-1.pdf](http://www.ams.org/journals/mcom/1965-19-090/S0025-5718-1965-0178586-1/S0025-5718-1965-0178586-1.pdf)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 描述Cooley和Tukey算法的官方论文可以在网上找到：[http://www.ams.org/journals/mcom/1965-19-090/S0025-5718-1965-0178586-1/S0025-5718-1965-0178586-1.pdf](http://www.ams.org/journals/mcom/1965-19-090/S0025-5718-1965-0178586-1/S0025-5718-1965-0178586-1.pdf)
- en: 'Fortunately for us, there are existing FFT implementations available, and so
    we will compute the FFT using a Java-based library provided by `org.apache.commons.math3`.
    When using this library, we need only to ensure that our input data is padded
    with zeros so that the total length is a power of two and can be divided into odd
    and even sequences:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，现有的FFT实现是可用的，因此我们将使用`org.apache.commons.math3`提供的基于Java的库来计算FFT。使用这个库时，我们只需要确保我们的输入数据用零填充，使得总长度是2的幂，并且可以分成奇偶序列：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This returns an array of `Complex` numbers that are made of real and imaginary
    parts and can be easily converted to a frequency and amplitude (or magnitude)
    as follows. According to the Nyquist theorem, we only need half the frequencies:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个由实部和虚部组成的`Complex`数字数组，并可以轻松转换为频率和幅度（或幅度）如下。根据奈奎斯特定理，我们只需要一半的频率：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we include these functions in the `Audio` case class and plot the
    frequency domain for the first few seconds of the Mario Bros theme song:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这些函数包含在`Audio` case类中，并绘制马里奥兄弟主题曲前几秒的频域：
- en: '![Fast Fourier transform](img/image_08_003.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![快速傅里叶变换](img/image_08_003.jpg)'
- en: 'Figure 2: Mario Bros theme - frequency domain'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：马里奥兄弟主题曲-频域
- en: In Figure 2, significant peaks can be seen in the medium-high frequency range
    (between 4KHz and 7KHz) and we will use these as a fingerprint for the song.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在图2中，可以看到在中高频范围（4KHz至7KHz之间）有显著的峰值，我们将使用这些作为歌曲的指纹。
- en: Sampling by time window
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按时间窗口采样
- en: Although more efficient, the FFT is still an expensive operation due to its
    high memory consumption (remember, a typical three-minute song would have around
    *3 x 60 x 176,400* points to process). This becomes especially problematic when
    applied to a large number of data points and so must be taken into consideration
    for large scale processing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管更有效，但FFT仍然是一个昂贵的操作，因为它的高内存消耗（记住，一首典型的三分钟歌曲将有大约*3 x 60 x 176,400*个点要处理）。当应用于大量数据点时，这变得特别棘手，因此必须考虑大规模处理。
- en: 'Instead of looking at the full spectrum, we sample our songs using a time window.
    In fact, a full FFT wouldn''t be of any use anyway since we want to know the time
    each major frequency was heard. Therefore, we iteratively split each `Audio` class
    into smaller case classes of 20 millisecond samples. This timeframe should be
    small enough for the purpose of analysis meaning small enough so that the FFT
    can be computed and dense enough to ensure that sufficient frequencies are extracted
    to provide an adequate audio fingerprint. The produced chunks of 20 milliseconds
    will drastically increase the overall size of our RDD:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是查看整个频谱，而是使用时间窗口对我们的歌曲进行采样。事实上，完整的FFT无论如何都没有用，因为我们想知道每个主要频率被听到的时间。因此，我们将`Audio`类迭代地分割成20毫秒样本的较小的案例类。这个时间框应该足够小，以便进行分析，这意味着FFT可以被计算，并且足够密集，以确保提取足够的频率，以提供足够的音频指纹。20毫秒的产生的块将大大增加我们RDD的总体大小：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While this is not our primary focus, one could rebuild the full FFT spectrum
    of the entire signal by recombining samples with inner and outer FFT and applying
    a twiddle factor [https://en.wikipedia.org/wiki/Twiddle_factor](https://en.wikipedia.org/wiki/Twiddle_factor).
    This could be useful when processing large records with a limited amount of available
    memory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是我们的主要关注点，但可以通过重新组合内部和外部FFT的样本，并应用一个扭曲因子[https://en.wikipedia.org/wiki/Twiddle_factor](https://en.wikipedia.org/wiki/Twiddle_factor)来重建整个信号的完整FFT频谱。当处理具有有限可用内存的大型记录时，这可能是有用的。
- en: Extracting audio signatures
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取音频签名
- en: Now we have multiple samples at regular time intervals, we can extract frequency
    signatures using FFT. In order to generate a sample signature, instead of using
    the exact peak (which could be approximate), we try to find the closest note in
    different frequency bands. This offers an approximation, but in doing so it overcomes
    any noise issues present in the original signal, as noise interferes with our
    signatures.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有多个样本在规则的时间间隔内，我们可以使用FFT提取频率签名。为了生成一个样本签名，我们尝试在不同的频段中找到最接近的音符，而不是使用精确的峰值（可能是近似的）。这提供了一个近似值，但这样做可以克服原始信号中存在的任何噪音问题，因为噪音会干扰我们的签名。
- en: We look at the following frequency bands 20-60 Hz, 60-250Hz, 250-2000Hz, 2-4Kz,
    and 4-6Kz and find the closest note according to the following frequency reference
    table. These bands are not random. They correspond to the different ranges of
    musical instruments (for example, double bass spans between 50 to 200Hz, piccolo
    from 500 to 5KHz).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看以下频段20-60 Hz，60-250Hz，250-2000Hz，2-4Kz和4-6Kz，并根据以下频率参考表找到最接近的音符。这些频段不是随机的。它们对应于不同乐器的不同范围（例如，低音提琴的频段在50到200Hz之间，短笛在500到5KHz之间）。
- en: '![Extracting audio signatures](img/B05261_08_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![提取音频签名](img/B05261_08_04.jpg)'
- en: 'Figure 3: Frequency note reference table'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：频率音符参考表
- en: '*Figure 4*, shows the first sample of our Mario Bros theme song in a lower
    frequency band. We can see that the highest magnitude of 43Hz corresponds to the
    prime octave of note **F**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4*显示了我们马里奥兄弟主题曲在较低频段的第一个样本。我们可以看到43Hz的最大幅度对应于音符**F**的主音：'
- en: '![Extracting audio signatures](img/image_08_005.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![提取音频签名](img/image_08_005.jpg)'
- en: 'Figure 4: Mario Bros theme-lower frequencies'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：马里奥兄弟主题曲-低频
- en: 'For each sample, we build a hash composed of five letters (such as [**E**-**D#**-**A**-**B**-**B**-**F**])
    corresponding to the strongest note (the highest peak) in each of the preceding
    frequency bands. We consider this hash a fingerprint for that particular 20 milliseconds
    time window. We then build a new RDD made of hash values as follows (we include
    a hashing function within our `Audio` case class):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个样本，我们构建一个由五个字母组成的哈希（比如[**E**-**D#**-**A**-**B**-**B**-**F**]），对应于前面频段中最强的音符（最高峰）。我们认为这个哈希是该特定20毫秒时间窗口的指纹。然后我们构建一个由哈希值组成的新RDD（我们在`Audio`类中包括一个哈希函数）：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we group all song IDs sharing the same hash in order to build an RDD of
    unique hashes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将所有共享相同哈希的歌曲ID分组，以构建一个唯一哈希的RDD：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our assumption is that when a hash is defined in a song at a particular time
    window, similar songs could potentially share similar hashes, but two songs having
    all the same hashes (and in order) would be truly identical; one could share part
    of my DNA, but one having the exact same DNA would be a perfect clone of myself.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的假设是，当一个哈希在特定的时间窗口内在一首歌中被定义时，类似的歌曲可能共享相似的哈希，但两首歌拥有完全相同的哈希（并且顺序相同）将是真正相同的；一个可能分享我的部分DNA，但一个拥有完全相同的DNA将是我的完美克隆。
- en: If a music aficionado is feeling blessed listening to the *concerto in D* by
    Tchaikovsky, can we recommend *Pachelbel's Canon in D* just because both of them
    share a musical cadence (that is, common frequencies around *D*)?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个音乐爱好者在听柴可夫斯基的D大调协奏曲时感到幸运，我们能否推荐帕赫贝尔的D大调卡农，仅仅是因为它们都有一个音乐节奏（即，D音周围的共同频率）？
- en: Is it valid (and feasible) to recommend playlists that are only based on certain
    frequency bands? Surely the frequencies themselves would not be enough to fully
    describe a song. What about tempo, timbre, or rhythm? Is this model complete enough
    to accurately represent all the nuances of musical diversity and range? Probably
    not, but for the purpose of data science, it's worth investigating anyway!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 仅基于某些频段来推荐播放列表是否有效（和可行）？当然，仅仅频率本身是不足以完全描述一首歌的。节奏、音色或韵律呢？这个模型是否足够完整地准确表示音乐多样性和范围的所有细微差别？可能不是，但出于数据科学的目的，还是值得调查的！
- en: Building a song analyzer
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建歌曲分析器
- en: However, before deep diving into the recommender itself, the reader may have
    noticed an important property that we were able to extract out of the signal data.
    Since we generated audio signatures at regular time intervals, we can compare
    signatures and find potential duplicates. For example, given a random song, we
    should be able to guess the title, based on previously indexed signatures. In
    fact, this is the exact approach taken by many companies when providing music
    recognition services. To take it one step further, we could potentially provide
    insight into a band's musical influences, or further, perhaps even identify song
    plagiarism, once and for all settling the *Stairway to Heave*n dispute between
    Led Zeppelin and the American rock band Spirit [http://consequenceofsound.net/2014/05/did-led-zeppelin-steal-stairway-to-heaven-legendary-rock-band-facing-lawsuit-from-former-tourmates/](http://consequenceofsound.net/2014/05/did-led-zeppelin-steal-stairway-to-heaven-legendary-rock-band-facing-lawsuit-from-former-tourmates/).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在深入研究推荐系统之前，读者可能已经注意到我们能够从信号数据中提取出一个重要的属性。由于我们在规则的时间间隔内生成音频签名，我们可以比较签名并找到潜在的重复项。例如，给定一首随机歌曲，我们应该能够根据先前索引的签名猜出标题。事实上，这是许多公司在提供音乐识别服务时采取的确切方法。更进一步，我们可能还可以提供关于乐队音乐影响的见解，甚至进一步，也许甚至可以识别歌曲剽窃，最终解决Led
    Zeppelin和美国摇滚乐队Spirit之间的*Stairway to Heaven*争议[http://consequenceofsound.net/2014/05/did-led-zeppelin-steal-stairway-to-heaven-legendary-rock-band-facing-lawsuit-from-former-tourmates/](http://consequenceofsound.net/2014/05/did-led-zeppelin-steal-stairway-to-heaven-legendary-rock-band-facing-lawsuit-from-former-tourmates/)。
- en: With this in mind, we will take a detour from our recommendation use case by
    continuing our investigation into song identification a little further. Next,
    we build an analyzer system capable of anonymously receiving a song, analyzing
    its stream, and returning the title of the song (in our case, the original filename).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们将从我们的推荐用例中分离出来，继续深入研究歌曲识别。接下来，我们将构建一个分析系统，能够匿名接收一首歌曲，分析其流，并返回歌曲的标题（在我们的情况下，是原始文件名）。
- en: Selling data science is all about selling cupcakes
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销售数据科学就像销售杯子蛋糕
- en: Sadly, an all too often neglected aspect of the data science journey is data visualization.
    In other words, how to present your results back to end users. While many data
    scientists are content to present their findings in an Excel spreadsheet, today's
    end users are keen for richer, more immersive experiences. Often they want to
    play around, *interacting* with data. Indeed, providing an end user with a full,
    end-to-end user experience even a simple one can be a great way to spark interest
    in your science; making a simple proof of concept into a prototype people can
    easily understand. And due to the prevalence of Web 2.0 technologies, user expectations
    are high, but thankfully, there are a variety of free, open source products that
    can help, for example, Mike Bostock’s D3.js, is a popular framework that provides
    a toolkit for creating just such user interfaces.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可悲的是，数据科学旅程中经常被忽视的一个方面是数据可视化。换句话说，如何将结果呈现给最终用户。虽然许多数据科学家乐意在Excel电子表格中呈现他们的发现，但今天的最终用户渴望更丰富、更沉浸式的体验。他们经常希望与数据进行*交互*。事实上，为最终用户提供一个完整的、端到端的用户体验，即使是一个简单的用户体验，也是激发对你的科学兴趣的好方法；将一个简单的概念证明变成一个人们可以轻松理解的原型。由于Web
    2.0技术的普及，用户的期望很高，但幸运的是，有各种免费的开源产品可以帮助，例如Mike Bostock的D3.js，这是一个流行的框架，提供了一个工具包，用于创建这样的用户界面。
- en: Selling data science without rich data visualization is like trying to sell
    a cake without icing, few people will trust in the finished product. Therefore,
    we will build a user interface for our analyzer system. But first, let's get the
    audio data out of Spark (our hashes are currently stored in memory inside an RDD)
    and into a web-scale datastore.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 没有丰富的数据可视化的数据科学就像试图销售没有糖衣的蛋糕，很少有人会信任成品。因此，我们将为我们的分析系统构建一个用户界面。但首先，让我们从Spark中获取音频数据（我们的哈希目前存储在RDD内存中），并将其存储到一个面向Web的数据存储中。
- en: Using Cassandra
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Cassandra
- en: 'We need a fast, efficient, and distributed key-value store to keep all our
    hash values. Although many databases are fit for this purpose, we''ll choose Cassandra
    in order to demonstrate its integration with Spark. First, import the Cassandra
    input and output formats using the Maven dependency:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个快速、高效和分布式的键值存储来保存所有我们的哈希值。尽管许多数据库都适用于此目的，但我们将选择Cassandra来演示其与Spark的集成。首先，使用Maven依赖项导入Cassandra输入和输出格式：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you would expect, persisting (and retrieving) RDDs from Spark to Cassandra
    is relatively trivial:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的那样，将RDD从Spark持久化（和检索）到Cassandra相对来说是相当简单的：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will create a new table `hashes` on keyspace `gzet`, inferring the schema
    from the `HashSongsPair` object. The following is the equivalent SQL statement
    executed (provided here for information only):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在keyspace `gzet`上创建一个新的`hashes`表，从`HashSongsPair`对象中推断出模式。以下是执行的等效SQL语句（仅供参考）：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using the Play framework
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Play框架
- en: As our Web UI will front the complex processing required to transform a song
    into frequency hashes, we want it to be an interactive web application rather
    than a simple set of static HTML pages. Furthermore, this must be done in the
    exact same way and with the same functions as we did using Spark (that is, the
    same song should generate the same hashes). The Play framework ([https://www.playframework.com/](https://www.playframework.com/))
    will allow us to do this, and Twitter's bootstrap ([http://getbootstrap.com/](http://getbootstrap.com/))
    will be used to put the icing on the cake, for a more professional look and feel.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的Web UI将面对将歌曲转换为频率哈希所需的复杂处理，我们希望它是一个交互式的Web应用程序，而不是一组简单的静态HTML页面。此外，这必须以与我们使用Spark相同的方式和相同的功能完成（也就是说，相同的歌曲应该生成相同的哈希）。Play框架（[https://www.playframework.com/](https://www.playframework.com/)）将允许我们这样做，Twitter的bootstrap（[http://getbootstrap.com/](http://getbootstrap.com/)）将用于为更专业的外观和感觉添加润色。
- en: Although this book is not about building user interfaces, we will introduce
    some concepts related to the Play framework, as if used well it can provide a
    source of great value for data scientists. As always, the full code is available
    in our GitHub repository.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书不是关于构建用户界面的，但我们将介绍与Play框架相关的一些概念，因为如果使用得当，它可以为数据科学家提供巨大的价值。与往常一样，完整的代码可以在我们的GitHub存储库中找到。
- en: 'First, we create a **data access layer**, responsible for handling connections
    and queries to Cassandra. For any given hash, we return the list of matching song
    IDs. Similarly, for any given ID, we return the song name:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个**数据访问层**，负责处理与Cassandra的连接和查询。对于任何给定的哈希，我们返回匹配歌曲ID的列表。同样，对于任何给定的ID，我们返回歌曲名称：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we create a simple **view**, made of three objects, a `text` field, a
    file `Upload`, and a `submit` button. These few lines are enough to provide our
    user interface:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个简单的**视图**，由三个对象组成，一个`text`字段，一个文件`Upload`和一个`submit`按钮。这几行足以提供我们的用户界面：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we create a **controller** that will handle both `GET` and `POST` HTTP
    requests through the `index` and `submit` methods, respectively. The latter will
    process the uploaded file by converting a `FileInputStream` into an `Audio` case
    class, splitting it into 20 millisecond chunks, extracting the FFT signatures
    (hashes) and querying Cassandra for matching IDs:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个**控制器**，通过`index`和`submit`方法处理`GET`和`POST` HTTP请求。后者将通过将`FileInputStream`转换为`Audio`
    case类，将其分割成20毫秒的块，提取FFT签名（哈希）并查询Cassandra以获取匹配的ID来处理上传的文件：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we return the matching result (if any) through a flashing message
    and we chain both the view and controller together by defining our new routes
    for our `Analyze` service:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过闪烁消息返回匹配结果（如果有的话），并通过为我们的`Analyze`服务定义新的路由将视图和控制器链接在一起：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The resulting UI is reported in *Figure 5*, and works perfectly with our own
    music library:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的UI如*图5*所示，并且与我们自己的音乐库完美配合：
- en: '![Using the Play framework](img/image_08_006.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![使用Play框架](img/image_08_006.jpg)'
- en: 'Figure 5: Sound analyser UI'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：声音分析器UI
- en: 'The following *Figure 6* shows the end-to-end process:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下图*图6*显示了端到端的过程：
- en: '![Using the Play framework](img/image_08_007.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![使用Play框架](img/image_08_007.jpg)'
- en: 'Figure 6: Sound analyser process'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：声音分析器过程
- en: As mentioned, the Play framework shares some pieces of code with our offline
    Spark job. This is made possible because we are programming in a functional style
    and have applied a good separation of concerns. While the Play framework does
    not work natively with Spark (in terms of RDDs and Spark context objects), because
    they are not dependent on Spark, we can use any of the functions we created earlier
    (such as the ones in the Audio class). This is one of the many advantages of functional
    programming; functions, by definition, are stateless and represent a key component
    in the adoption of a hexagonal **architecture**: [http://wiki.c2.com/?HexagonalArchitecture](http://wiki.c2.com/?HexagonalArchitecture).
    Isolated functions can always be called by different actors, whether it is inside
    of an RDD or within a Play controller.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Play框架与我们的离线Spark作业共享一些代码。这是可能的，因为我们是以函数式风格编程，并且已经很好地分离了关注点。虽然Play框架在本质上不与Spark（即RDD和Spark上下文对象）兼容，因为它们不依赖于Spark，我们可以使用我们之前创建的任何函数（比如Audio类中的函数）。这是函数式编程的许多优势之一；函数本质上是无状态的，并且是六边形架构采用的关键组件之一：[http://wiki.c2.com/?HexagonalArchitecture](http://wiki.c2.com/?HexagonalArchitecture)。隔离的函数始终可以被不同的执行者调用，无论是在RDD内部还是在Play控制器内部。
- en: Building a recommender
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建推荐系统
- en: Now that we've explored our song analyzer, let's get back on track with the
    recommendation engine. As discussed earlier, we would like to recommend songs
    based on frequency hashes extracted from audio signals. Taking as an example the
    dispute between Led Zeppelin and Spirit, we would expect both songs to be relatively
    close to each other, as the allegation is that they share a melody. Using this
    thought as our main assumption, we could potentially recommend *Taurus* to someone
    interested in *Stairway to Heaven*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了我们的歌曲分析器，让我们回到推荐引擎。如前所述，我们希望基于从音频信号中提取的频率哈希来推荐歌曲。以Led Zeppelin和Spirit之间的争议为例，我们期望这两首歌相对接近，因为有指控称它们共享旋律。以这种思路作为我们的主要假设，我们可能会向对《天梯》感兴趣的人推荐《Taurus》。
- en: The PageRank algorithm
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PageRank算法
- en: Instead of recommending a specific song, we will recommend playlists. A playlist
    would consist of a list of all our songs ranked by relevance, most to least relevant.
    Let's begin with the assumption that people listen to music in a similar way to
    the way they browse articles on the web, that is, following a logical path from
    link to link, but occasionally switching direction, or teleporting, and browsing
    to a totally different website. Continuing with the analogy, while listening to
    music one can either carry on listening to music of a similar style (and hence
    follow their most expected journey), or skip to a random song in a totally different
    genre. It turns out that this is exactly how Google ranks websites by popularity
    using a **PageRank** algorithm.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会推荐特定的歌曲，而是推荐播放列表。播放列表将由按相关性排名的所有歌曲列表组成，从最相关到最不相关。让我们从这样一个假设开始，即人们听音乐的方式与他们浏览网页的方式类似，也就是说，从链接到链接，沿着逻辑路径前进，但偶尔改变方向，或者进行跳转，并浏览到完全不同的网站。继续这个类比，当听音乐时，人们可以继续听相似风格的音乐（因此按照他们最期望的路径前进），或者跳到完全不同流派的随机歌曲。事实证明，这正是谷歌使用PageRank算法按照网站的受欢迎程度进行排名的方式。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: For more details on the PageRank algorithm visit: [http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf](http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PageRank算法的更多细节，请访问：[http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf](http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf)。
- en: The popularity of a website is measured by the number of links it points to
    (and is referred from). In our music use case, the popularity is built as the
    number hashes a given song shares with all its neighbors. Instead of popularity,
    we introduce the concept of song commonality.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的受欢迎程度是通过它指向（并被引用）的链接数量来衡量的。在我们的音乐用例中，受欢迎程度是建立在给定歌曲与所有邻居共享的哈希数量上的。我们引入了歌曲共同性的概念，而不是受欢迎程度。
- en: Building a Graph of Frequency Co-occurrence
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建频率共现图
- en: 'We start by reading our hash values back from Cassandra and re-establishing
    the list of song IDs for each distinct hash. Once we have this, we can count the
    number of hashes for each song using a simple `reduceByKey` function, and because
    the audio library is relatively small, we collect and broadcast it to our Spark
    executors:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从Cassandra中读取我们的哈希值，并重新建立每个不同哈希的歌曲ID列表。一旦我们有了这个，我们就可以使用简单的`reduceByKey`函数来计算每首歌曲的哈希数量，因为音频库相对较小，我们将其收集并广播到我们的Spark执行器：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we build a co-occurrence matrix by getting the cross product of every
    song sharing a same hash value, and count how many times the same tuple is observed.
    Finally, we wrap the song IDs and the normalized (using the term frequency we
    just broadcast) frequency count inside of an `Edge` class from GraphX:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过获取共享相同哈希值的每首歌曲的叉积来构建一个共现矩阵，并计算观察到相同元组的次数。最后，我们将歌曲ID和标准化的（使用我们刚刚广播的词频）频率计数包装在GraphX的`Edge`类中：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are only keeping edges with a weight (meaning a hash co-occurrence) greater
    than a predefined threshold in order to build our hash frequency graph.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只保留具有大于预定义阈值的权重（意味着哈希共现）的边，以构建我们的哈希频率图。
- en: Running PageRank
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行PageRank
- en: Contrary to what one would normally expect when running a PageRank, our graph
    is undirected. It turns out that for our recommender, the lack of direction does
    not matter, since we are simply trying to find similarities between Led Zeppelin
    and Spirit. A possible way of introducing direction could be to look at the song
    publishing date. In order to find musical influences, we could certainly introduce
    a chronology from the oldest to newest songs giving directionality to our edges.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与运行PageRank时人们通常期望的相反，我们的图是无向的。事实证明，对于我们的推荐系统来说，缺乏方向并不重要，因为我们只是试图找到Led Zeppelin和Spirit之间的相似之处。引入方向的一种可能方式是查看歌曲的发布日期。为了找到音乐影响，我们可以确实地从最旧的歌曲到最新的歌曲引入一个时间顺序，给我们的边赋予方向性。
- en: 'In the following `pageRank`, we define a probability of 15% to skip, or **teleport**
    as it is known, to any random song, but this can be obviously tuned for different
    needs:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的`pageRank`中，我们定义了一个15%的概率来跳过，或者**跳转**到任意随机歌曲，但这显然可以根据不同的需求进行调整：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we extract the page ranked vertices and save them as a playlist in
    Cassandra via an RDD of the `Song` case class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提取了页面排名的顶点，并将它们保存为Cassandra中的播放列表，通过`Song`类的RDD：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The reader may be pondering the exact purpose of PageRank here, and how it could
    be used as a recommender? In fact, our use of PageRank means that the highest
    ranking songs would be the ones that share many frequencies with other songs.
    This could be due to a common arrangement, key theme, or melody; or maybe because
    a particular artist was a major influence on a musical trend. However, these songs
    should be, at least in theory, more popular (by virtue of the fact they occur
    more often), meaning that they are more likely to have mass appeal.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能会思考PageRank在这里的确切目的，以及它如何作为推荐系统使用？事实上，我们使用PageRank的意思是排名最高的歌曲将是与其他歌曲共享许多频率的歌曲。这可能是由于共同的编曲、主题或旋律；或者可能是因为某位特定艺术家对音乐趋势产生了重大影响。然而，这些歌曲应该在理论上更受欢迎（因为它们出现的频率更高），这意味着它们更有可能受到大众的喜爱。
- en: On the other end of the spectrum, low ranking songs are ones where we did not
    find any similarity with anything we know. Either these songs are so avant-garde
    that no one has explored these musical ideas before, or alternatively are so bad
    that no one ever wanted to copy them! Maybe they were even composed by that up-and-coming
    artist you were listening to in your rebellious teenage years. Either way, the
    chance of a random user liking these songs is treated as negligible. Surprisingly,
    whether it is a pure coincidence or whether this assumption really makes sense,
    the lowest ranked song from this particular audio library is Daft Punk's--*Motherboard*
    it is a title that is quite original (a brilliant one though) and a definite unique
    sound.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，低排名的歌曲是我们没有发现与我们所知的任何东西相似的歌曲。要么这些歌曲是如此前卫，以至于没有人在这些音乐理念上进行探索，要么是如此糟糕，以至于没有人想要复制它们！也许它们甚至是由你在叛逆的少年时期听过的那位新兴艺术家创作的。无论哪种情况，随机用户喜欢这些歌曲的机会被视为微不足道。令人惊讶的是，无论是纯粹的巧合还是这种假设真的有意义，这个特定音频库中排名最低的歌曲是Daft
    Punk的--*Motherboard*，这是一个相当原创的标题（尽管很棒），并且有着独特的声音。
- en: Building personalized playlists
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建个性化播放列表
- en: We just have seen that a simple PageRank could help us create a general-purpose
    playlist. And although this isn't targeted towards any individual, it could serve
    as a playlist for a random user. It is the best recommendation we can make without
    any information about a user's preferences. The more we will learn about a user,
    the better we can personalize the playlist towards what they truly prefer. To
    do this, we would probably follow a content-based recommendation approach.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到，简单的PageRank可以帮助我们创建一个通用的播放列表。尽管这并不针对任何个人，但它可以作为一个随机用户的播放列表。这是我们在没有任何关于用户偏好的信息时能做出的最好的推荐。我们对用户了解得越多，我们就能越好地个性化播放列表以符合他们真正的喜好。为了做到这一点，我们可能会采用基于内容的推荐方法。
- en: Without up-front information about a user's preferences, we can seek to collect
    our own information whenever a user plays a song, and hence personalize their
    playlist at runtime. To do this, we will assume that our user was enjoying the
    previous song that they listened to. We will also need to disable teleporting
    and generate a new playlist that is seeded from that particular song ID.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有关于用户偏好的预先信息的情况下，我们可以在用户播放歌曲时寻求收集我们自己的信息，并在运行时个性化他们的播放列表。为此，我们将假设我们的用户喜欢他们之前听过的歌曲。我们还需要禁用跳转，并生成一个从特定歌曲ID开始的新播放列表。
- en: 'PageRank and personalized PageRank are identical in the way that they compute
    scores (using the weight of incoming/outgoing edges), but the personalized version
    only allows users to teleport to the provided ID. A simple modification of the
    code allows us to personalize PageRank using a certain community ID (see [Chapter
    7](ch07.xhtml "Chapter 7. Building Communities"), *Building Communities*, for
    a definition of communities) or using a certain music attribute such as the artist
    or the genre. Given our previous graph, a personalized page rank is implemented
    as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank和个性化PageRank在计算分数的方式上是相同的（使用传入/传出边的权重），但个性化版本只允许用户跳转到提供的ID。通过对代码进行简单修改，我们可以使用某个社区ID（参见[第7章](ch07.xhtml
    "第7章。构建社区")，*构建社区*，以获取社区的定义）或使用某种音乐属性，如艺术家或流派，来个性化PageRank。根据我们之前的图，个性化的PageRank实现如下：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, the chance of teleporting to a random song is zero. There is still a 10%
    chance of skipping, but within only a very small tolerance of the provided song
    ID. In other words, regardless of the song we are currently listening to, we essentially
    defined a 10% chance of playing the song that we provide as a seed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，随机跳转到一首歌的机会为零。仍然有10%的跳过机会，但只在提供的歌曲ID的非常小的容差范围内。换句话说，无论我们当前正在听的歌曲是什么，我们基本上定义了10%的机会播放我们提供的歌曲作为种子。
- en: Expanding our cupcake factory
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展我们的杯子蛋糕工厂
- en: Similar to our song analyzer prototype, we want to present our suggested playlist
    back to our imaginary customer in a nice and tidy user interface.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的歌曲分析器原型类似，我们希望以一个漂亮整洁的用户界面向我们的想象客户呈现我们建议的播放列表。
- en: Building a playlist service
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建播放列表服务
- en: 'Still using the Play framework, our technology stack stays the same, this time
    we simply create a new endpoint (a new route):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然使用Play框架，我们的技术栈保持不变，这次我们只是创建了一个新的端点（一个新的路由）：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Just as before, we create an additional controller that handles simple GET
    requests (triggered when a user loads the playlist webpage). We load the generic
    playlist stored in Cassandra, wrap all these songs inside of a `Playlist` case
    class, and send it back to the `playlist.scala.html` view. The controller model
    looks as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 就像以前一样，我们创建了一个额外的控制器来处理简单的GET请求（当用户加载播放列表网页时触发）。我们加载存储在Cassandra中的通用播放列表，将所有这些歌曲包装在`Playlist`
    case类中，并将其发送回`playlist.scala.html`视图。控制器模型如下：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The view remains reasonably simple, as we iterate through all the songs to
    display, ordered by commonality (from the most to least common ones):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 视图保持相当简单，因为我们遍历所有歌曲以按常见程度（从最常见到最不常见）排序进行显示：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the `href` attribute in each list item - any time a user clicks on a song
    from that list, we will be generating a new `REST` call to the /playlist/id endpoint
    (this is described in the following section).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个列表项中的`href`属性 - 每当用户点击列表中的歌曲时，我们将生成一个新的`REST`调用到/playlist/id端点（这在下一节中描述）。
- en: Finally, we are pleased to unveil the recommended (generic) playlist in *Figure
    7*. For some reason unknown to us, apparently a novice to classical music should
    start listening to *Gustav Mahler, Symphony No. 5*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们很高兴地揭示了*图7*中推荐的（通用）播放列表。由于我们不知道的某种原因，显然一个对古典音乐一窍不通的新手应该开始听*古斯塔夫·马勒，第五交响曲*。
- en: '![Building a playlist service](img/B05261_08_08-2.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![构建播放列表服务](img/B05261_08_08-2.jpg)'
- en: 'Figure 7: Playlist recommender'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：播放列表推荐器
- en: Leveraging the Spark job server
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用Spark作业服务器
- en: Here comes yet another interesting challenge. Although our list of songs for
    a generic playlist and PageRank score is stored on Cassandra, this is not feasible
    for personalized playlists, as it would require pre-computation of all the PageRank
    scores for all the possible song IDs. And as we want to build the personalized
    playlists in pseudo real time, and we might also be loading new songs fairly regularly,
    we need to find a better approach than starting up a `SparkContext` upon every
    request.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 又来了一个有趣的挑战。尽管我们的通用播放列表和PageRank分数的歌曲列表存储在Cassandra中，但对于个性化播放列表来说，这是不可行的，因为这将需要对所有可能的歌曲ID的所有PageRank分数进行预计算。由于我们希望在伪实时中构建个性化播放列表，并且可能会定期加载新歌曲，所以我们需要找到一个比在每个请求上启动`SparkContext`更好的方法。
- en: The first constraint is that the PageRank function by nature is a distributed
    process and cannot be used outside of the context of Spark (that is, inside our
    Play framework's JVM). We appreciate that creating a new Spark job on each http
    request would certainly be a bit of an overkill, so we would like to start one
    single Spark job and process new graphs only when needed, ideally through a simple
    REST API call.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个限制是PageRank函数本质上是一个分布式过程，不能在Spark的上下文之外使用（也就是说，在我们的Play框架的JVM内部）。我们知道在每个http请求上创建一个新的Spark作业肯定会有点过度，所以我们希望启动一个单独的Spark作业，并且只在需要时处理新的图，最好是通过一个简单的REST
    API调用。
- en: The second challenge is that we do not wish to load the same graph dataset from
    Cassandra repeatedly. This should be loaded once and cached in Spark memory and
    shared across different jobs. In Spark terminology, this would require an RDD
    to be accessible from a shared context.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个挑战是我们不希望重复从Cassandra中加载相同的图数据集。这应该加载一次并缓存在Spark内存中，并在不同的作业之间共享。在Spark术语中，这将需要从共享上下文中访问RDD。
- en: Luckily, both points are addressed with Spark **job server** ([https://github.com/spark-jobserver/spark-jobserver](https://github.com/spark-jobserver/spark-jobserver)).
    Although this project is fairly immature (or at least not quite production-ready
    yet), it is a perfectly viable solution for showcasing data science.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Spark作业服务器解决了这两个问题（[https://github.com/spark-jobserver/spark-jobserver](https://github.com/spark-jobserver/spark-jobserver)）。尽管这个项目还相当不成熟（或者至少还不够成熟），但它是展示数据科学的完全可行的解决方案。
- en: 'For the purpose of this book, we compile and deploy a Spark job server using
    a local configuration only. We strongly encourage the reader to have a deeper
    look at the job server website (see previous link) for more information about
    packaging and deployment. Once our server starts, we need to create a new context
    (meaning starting up a new Spark job) with additional configuration settings for
    handling connection to Cassandra. We give this context a name so that we can use
    it later on:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的目的，我们只使用本地配置编译和部署Spark作业服务器。我们强烈建议读者深入了解作业服务器网站（参见上面的链接），以获取有关打包和部署的更多信息。一旦我们的服务器启动，我们需要创建一个新的上下文（意味着启动一个新的Spark作业），并为处理与Cassandra的连接的附加配置设置。我们给这个上下文一个名称，以便以后可以使用它：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next step is to modify our code to be Spark job server compliant. We need
    the following dependency:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是修改我们的代码以符合Spark作业服务器的要求。我们需要以下依赖项：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We modify our SparkJob using the signature of the `SparkJob` interface that
    comes with job server. This is a requirement of all Spark job server jobs:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改我们的SparkJob，使用作业服务器提供的`SparkJob`接口的签名。这是作业服务器所有Spark作业的要求：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the `validate` method, we ensure that all the job requirements will be satisfied
    (such as the input configuration needed for that job), and in `runJob` we execute
    our normal Spark logic just as we did before. The last change is that, while we
    will still be storing our generic playlist into Cassandra, we will cache the nodes
    and edges RDDs in Spark shared memory where it will be made available to further
    jobs. This can be done by extending the `NamedRddSupport` trait.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`validate`方法中，我们确保所有作业要求将得到满足（例如该作业所需的输入配置），在`runJob`中，我们执行我们的正常Spark逻辑，就像以前一样。最后的变化是，虽然我们仍然将我们的通用播放列表存储到Cassandra中，但我们将在Spark共享内存中缓存节点和边缘RDD，以便将其提供给进一步的作业。这可以通过扩展`NamedRddSupport`特性来实现。
- en: 'We simply have to save both edges and node RDDs (note that saving a `Graph`
    object is not supported yet) to keep accessing the graph in subsequent jobs:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需保存边缘和节点RDD（请注意，目前不支持保存`Graph`对象）以便在后续作业中访问图：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'From the personalized `Playlist` job, we retrieve and process our RDDs as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从个性化的`Playlist`作业中，我们按以下方式检索和处理我们的RDD：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then execute our personalized PageRank, but instead of saving the results
    back to Cassandra, we will simply collect the first 50 songs. When deployed, this
    action will implicitly output this list back to the client thanks to the magic
    of the job server:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们执行我们的个性化PageRank，但是不会将结果保存回Cassandra，而是简单地收集前50首歌曲。当部署时，由于作业服务器的魔力，此操作将隐式地将此列表输出回客户端：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We compile our code and publish our shaded jar file into job server by giving
    it an application name as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编译我们的代码，并通过给它一个应用程序名称将我们的阴影jar文件发布到作业服务器，如下所示：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we are almost ready to deploy our recommendation system, let''s recap
    over what we are going to demo. We will be executing the two different user flows
    shortly:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们几乎准备好部署我们的推荐系统了，让我们回顾一下我们将要演示的内容。我们将很快执行两种不同的用户流程：
- en: When a user logs in to the recommendation page, we retrieve the latest generic
    playlist available in Cassandra. Alternatively, we start a new asynchronous job
    to create a new one if needed. This will load the required RDDs within the Spark
    context.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户登录到推荐页面时，我们从Cassandra中检索最新的通用播放列表。或者，如果需要，我们会启动一个新的异步作业来创建一个新的播放列表。这将在Spark上下文中加载所需的RDD。
- en: When a user plays a new song from our recommended items, we spin up a synchronous
    call to the Spark job server and build the next playlist based around this song
    ID.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户播放我们推荐的新歌曲时，我们会同步调用Spark作业服务器，并基于这首歌曲的ID构建下一个播放列表。
- en: 'The flow for the generic PageRank playlist is shown in *Figure 8*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通用PageRank播放列表的流程如*图8*所示：
- en: '![Leveraging the Spark job server](img/image_08_009.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![利用Spark作业服务器](img/image_08_009.jpg)'
- en: 'Figure 8: Playlist recommender process'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：播放列表推荐器流程
- en: 'The flow for the personalized PageRank playlist is shown in Figure 9:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 个性化PageRank播放列表的流程如图9所示：
- en: '![Leveraging the Spark job server](img/image_08_010.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![利用Spark作业服务器](img/image_08_010.jpg)'
- en: 'Figure 9: Personalized playlist recommender process'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：个性化播放列表推荐器流程
- en: User interface
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户界面
- en: 'The final remaining piece of the puzzle is to make a call to the Spark job
    server from the service layer in Play Framework. Although this is done programmatically
    using the `java.net` package, as it''s a REST API the equivalent `curl` requests
    are shown in the following snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后剩下的问题是从Play框架的服务层调用Spark作业服务器。尽管这是通过`java.net`包以编程方式完成的，但由于它是一个REST API，等效的`curl`请求在以下代码片段中显示：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Initially, when we built our HTML code, we introduced a link, or `href`, to
    `/playlist/${id}`. This REST call will be converted for you into a GET request
    to the `Playlist` controller and bound to your `personalize` function, like so:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，当我们构建HTML代码时，我们引入了一个指向`/playlist/${id}`的链接或`href`。这个REST调用将被转换为对`Playlist`控制器的GET请求，并绑定到您的`personalize`函数，如下所示：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The first call to the Spark job server will spin up a new Spark job synchronously,
    read the results back from the job output, and redirect to the same page view
    with an updated playlist, this time based around this song ID:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对Spark作业服务器的第一次调用将同步启动一个新的Spark作业，从作业输出中读取结果，并重定向到相同的页面视图，这次是基于这首歌曲的ID更新的播放列表：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And voila, the resulting UI is shown in *Figure 10*. Anytime a user plays a
    song, the playlist will be updated and displayed, acting as a full-blown ranking
    recommendation engine.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 结果UI显示在*图10*中。每当用户播放一首歌，播放列表都将被更新和显示，充当一个完整的排名推荐引擎。
- en: '![User interface](img/B05261_08_11-1.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面](img/B05261_08_11-1.jpg)'
- en: 'Figure 10: Personalized playlist recommender process'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：个性化播放列表推荐流程
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: While our recommendation system may not have taken the typical textbook approach,
    nor may it be the most accurate recommender possible, it does represent a fully
    demonstrable and incredibly interesting approach to one of the most commonplace
    techniques in data science today. Further, with persistent data storage, a REST
    API interface, distributed shared memory caching, and a modern web 2.0-based user
    interface, it provides a reasonably complete and rounded candidate solution.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的推荐系统可能并没有采用典型的教科书方法，也可能不是最准确的推荐系统，但它确实代表了数据科学中最常见技术之一的一个完全可演示且非常有趣的方法。此外，通过持久数据存储、REST
    API接口、分布式共享内存缓存和基于现代Web 2.0的用户界面，它提供了一个相当完整和全面的候选解决方案。
- en: Of course, building a production-grade product out of this prototype would still
    require much effort and expertise. There are still improvements to be sought in
    the area of signal processing. For example, one could improve the sound pressure
    and reduce the signal noise by using a loudness filter, [http://languagelog.ldc.upenn.edu/myl/StevensJASA1955.pdf](http://languagelog.ldc.upenn.edu/myl/StevensJASA1955.pdf),
    by extracting pitches and melodies, or most importantly, by converting stereo
    to a mono signal.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要将这个原型产品打造成一个生产级产品仍需要大量的努力和专业知识。在信号处理领域仍有改进空间。例如，可以通过使用响度滤波器来改善声压，并减少信号噪音，[http://languagelog.ldc.upenn.edu/myl/StevensJASA1955.pdf](http://languagelog.ldc.upenn.edu/myl/StevensJASA1955.pdf)，通过提取音高和旋律，或者更重要的是，通过将立体声转换为单声道信号。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: All these processes are actually part of an active area of research - readers
    can look at some of the following publications: [http://www.justinsalamon.com/publications.html](http://www.justinsalamon.com/publications.html)
    and [http://www.mattmcvicar.com/publications/](http://www.mattmcvicar.com/publications/).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些过程实际上都是研究的一个活跃领域 - 读者可以查看以下一些出版物：[http://www.justinsalamon.com/publications.html](http://www.justinsalamon.com/publications.html)
    和 [http://www.mattmcvicar.com/publications/](http://www.mattmcvicar.com/publications/)。
- en: In addition, we questioned how one can improve data science demonstrations by
    using simple (interactive) user interfaces. As mentioned, this is an often overlooked
    aspect and a key feature of presentation. Even in the early stages of a project,
    it's worth investing some time in data visualization, as it can be especially
    useful when convincing business people of the viability of your product.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们质疑如何通过使用简单（交互式）用户界面来改进数据科学演示。正如提到的，这是一个经常被忽视的方面，也是演示的一个关键特点。即使在项目的早期阶段，投资一些时间进行数据可视化也是值得的，因为当说服商业人士你的产品的可行性时，它可能特别有用。
- en: One final thought, as an aspirational chapter we explored innovative ways to
    address data science use cases in a Spark environment. By balancing skills between
    mathematics and computer science, data scientists should feel free to explore,
    to be creative, to push back the frontier of what is feasible, to undertake what
    people say is not, but most importantly, to have fun with data. For this is the
    main reason why being a data scientist is considered the *sexiest job of the 21st
    century*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为一个有抱负的章节，我们探索了在Spark环境中解决数据科学用例的创新方法。通过平衡数学和计算机科学的技能，数据科学家应该可以自由探索，创造，推动可行性的边界，承担人们认为不可能的任务，但最重要的是，享受数据带来的乐趣。因为这正是为什么成为数据科学家被认为是21世纪最性感的工作的主要原因。
- en: This chapter was a musical interlude. In the next chapter, we will be looking
    at classifying GDELT articles by bootstrapping a classification model using Twitter
    data, another ambitious task to say the least.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是一个音乐插曲。在下一章中，我们将通过使用Twitter数据来引导GDELT文章的分类模型来分类GDELT文章，这无疑是另一个雄心勃勃的任务。
