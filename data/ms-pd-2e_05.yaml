- en: Using NumPy and Data Structures with pandas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NumPy和pandas中的数据结构
- en: This chapter is one of the most important ones in this book. We will now begin
    to dive into the nitty-gritty of pandas. We start by taking a tour of NumPy `ndarrays`,
    a data structure not in pandas but NumPy. Knowledge of NumPy `ndarrays` is useful
    as they are the building blocks on which pandas DataFrames have been built. One
    key benefit of NumPy arrays is that they execute what is known as *vectorized*
    operations, which are operations that require traversing/looping on a Python array
    and are much faster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是本书中最重要的章节之一。现在我们将开始深入探讨pandas的细节。我们从了解NumPy的`ndarrays`开始，这是一个不在pandas中的数据结构，而是NumPy的一部分。了解NumPy
    `ndarrays`是非常有用的，因为它们是构建pandas DataFrame的基础。NumPy数组的一个关键优势是，它们可以执行所谓的*矢量化*操作，这些操作是需要遍历/循环Python数组的操作，而且速度要快得多。
- en: In this chapter, I will present the material via numerous examples using Jupyter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将通过多个使用Jupyter的示例来呈现这些内容。
- en: The topics we will cover in this chapter include a tour of the `numpy.ndarray`
    data structure, the `pandas.Series` **one-dimensional** (**1D**) pandas data structure,
    the `pandas.DataFrame` **two-dimensional** (**2D**) pandas tabular data structure,
    and the `pandas.Panel` **three-dimensional** (**3D**) pandas data structure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖的主题包括对`numpy.ndarray`数据结构的介绍，`pandas.Series`**一维**（**1D**）pandas数据结构，`pandas.DataFrame`**二维**（**2D**）pandas表格数据结构，以及`pandas.Panel`**三维**（**3D**）pandas数据结构。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: NumPy `ndarrays`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy `ndarrays`
- en: Implementing neural networks with NumPy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NumPy实现神经网络
- en: Practical applications of multidimensional arrays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多维数组的实际应用
- en: Data structures in pandas
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pandas中的数据结构
- en: NumPy ndarrays
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy的ndarrays
- en: 'Arrays are vital objects in the data analysis scenario. Arrays allow for structured
    handling of elements that are stacked across rows and columns. The elements of
    an array are bound by the rule that they should all be of the same data type.
    For example, the medical records of five patients have been presented as an array as
    follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在数据分析中是至关重要的对象。数组允许对跨行和列堆叠的元素进行结构化处理。数组的元素必须遵守一个规则：它们应该具有相同的数据类型。例如，五个病人的医疗记录可以按如下方式呈现为一个数组：
- en: '|  | **Blood glucose level** | **Heart rate** | **Cholesterol level** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|  | **血糖水平** | **心率** | **胆固醇水平** |'
- en: '| **Peter Parker** | 100 | 65 | 160 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **彼得·帕克** | 100 | 65 | 160 |'
- en: '| **Bruce Wayne** | 150 | 82 | 200 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **布鲁斯·韦恩** | 150 | 82 | 200 |'
- en: '| **Tony Stark** | 90 | 55 | 80 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **托尼·斯塔克** | 90 | 55 | 80 |'
- en: '| **Barry Allen** | 130 | 73 | 220 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **巴里·艾伦** | 130 | 73 | 220 |'
- en: '| **Steve Rogers** | 190 | 80 | 150 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **史蒂夫·罗杰斯** | 190 | 80 | 150 |'
- en: 'It is seen that all 15 elements are of data type `int`. Arrays could also be
    composed of `strings`, `floats`, or complex numbers. Arrays could be constructed
    from lists—a widely used and versatile data structure in Python:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，所有15个元素的数据类型都是`int`。数组也可以由`字符串`、`浮点数`或复数构成。数组可以由列表构造——列表是Python中广泛使用且多功能的数据结构：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An element in the *i*^(th) row and *j*^(th) column (for example, first row
    and second column in the first example) of an array or matrix can be accessed
    as shown in the following code. Note that indexing in Python starts from 0:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下代码访问数组或矩阵中第*i*行和第*j*列的元素（例如，在第一个示例中的第一行第二列）。请注意，Python中的索引从0开始：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Python has an built-in `array` module to create arrays. However, this array
    module is more like a glorified list where all elements are required to have the
    same data type. An array can be created using the `array` module by providing
    two arguments—the type code of the data type, and the elements in a list, string,
    or any iterable object. Let''s create an array of floats. Here, `d` is the type
    code for a double-floating point value:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个内建的`array`模块来创建数组。然而，这个数组模块更像是一个经过美化的列表，要求所有元素具有相同的数据类型。可以通过提供两个参数来使用`array`模块创建数组——数据类型的类型代码，以及列表、字符串或任何可迭代对象中的元素。让我们创建一个浮点数组。这里，`d`是双精度浮点数的类型代码：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is not possible to create a two-dimensional entity with rows and columns
    using the `array` module. This can be achieved through a nested list of such arrays.
    Special functions implicit with matrices or arrays, such as matrix multiplication,
    determinants, and eigenvalues, are not defined in this module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`array`模块无法创建具有行和列的二维实体。这可以通过嵌套列表来实现。该模块没有定义与矩阵或数组相关的特殊函数，如矩阵乘法、行列式和特征值。
- en: 'NumPy is the preferred package to create and work on array-type objects. NumPy
    allows multidimensional arrays to be created. Multidimensional arrays provide
    a systematic and efficient framework for storing data. Complex computations, which
    are built-in vectorized operations in the NumPy package, can be done quickly on
    these multidimensional arrays without the need for loops. Consider the earlier
    example where we created a two-dimensional array to store the medical records
    of five patients. The patients'' names and the clinical indicators were the two
    dimensions in this case. Now, if the clinical parameters of the same patients
    were recorded for three years, from 2016 to 2018, then all this information could
    be conveniently represented in a three-dimensional array. The year in which the
    records were fetched will get in as the third dimension. The resultant array will
    be of dimension 3 x 5 x 3, and entirely composed of integers:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 是创建和操作数组类型对象的首选包。NumPy 允许创建多维数组。多维数组提供了一个系统化和高效的数据存储框架。在这些多维数组上，可以快速进行复杂的计算，这些计算是
    NumPy 包中的内置矢量化操作，无需使用循环。考虑之前的示例，我们创建了一个二维数组来存储五个患者的医疗记录。在这种情况下，患者的姓名和临床指标是两个维度。现在，如果记录了相同患者在三年（2016
    到 2018 年）内的临床参数，那么所有这些信息可以方便地表示为一个三维数组。记录的年份将作为第三维度。结果数组的维度为 3 x 5 x 3，完全由整数组成：
- en: '| **2016** | **2017** | **2018** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **2016** | **2017** | **2018** |'
- en: '| 100 | 65 | 160 | 95 | 68 | 140 | 110 | 72 | 160 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 65 | 160 | 95 | 68 | 140 | 110 | 72 | 160 |'
- en: '| 150 | 82 | 200 | 145 | 80 | 222 | 160 | 95 | 185 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 150 | 82 | 200 | 145 | 80 | 222 | 160 | 95 | 185 |'
- en: '| 90 | 55 | 80 | 90 | 62 | 100 | 100 | 80 | 110 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 90 | 55 | 80 | 90 | 62 | 100 | 100 | 80 | 110 |'
- en: '| 130 | 73 | 220 | 150 | 92 | 200 | 140 | 92 | 120 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 130 | 73 | 220 | 150 | 92 | 200 | 140 | 92 | 120 |'
- en: '| 190 | 80 | 150 | 140 | 60 | 90 | 100 | 55 | 100 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 190 | 80 | 150 | 140 | 60 | 90 | 100 | 55 | 100 |'
- en: In NumPy, these multidimensional arrays are referred to as `ndarrays` (*n*-dimensional
    arrays). All NumPy array objects are of the type `numpy.ndarray`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 中，这些多维数组被称为 `ndarrays` (*n* 维数组)。所有 NumPy 数组对象都是 `numpy.ndarray` 类型。
- en: 'Let''s view the preceding data as an `ndarray`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的数据视为一个 `ndarray`：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Attributes of an `ndarray` such as the data type, shape, number of dimensions,
    and size can be accessed by different attributes of the array. Some attributes
    for the `ndarray` `ndarray_1` have been explored in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`ndarray` 的属性，如数据类型、形状、维度数量和大小，可以通过数组的不同属性进行访问。在以下代码中，探讨了 `ndarray` `ndarray_1`
    的一些属性：'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'NumPy''s `ndarray` makes use of a strided indexing scheme for its internal
    memory layout. A memory segment by itself can accommodate only one-dimensional
    structures. Hence, a specific memory allocation scheme such as the strided indexing
    scheme is needed to facilitate easy indexing and slicing of `ndarrays`. A stride
    indicates the number of bytes to jump to traverse to the subsequent element. The
    number of bytes for each stride is determined by the data type of the array. Let''s
    understand strides through the array explored earlier. The number of bytes occupied
    by each element can be determined as shown in the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的 `ndarray` 使用了步长索引方案来进行内部内存布局。单独的内存段只能容纳一维结构。因此，像步长索引这样的特定内存分配方案是必要的，以便方便地对
    `ndarray` 进行索引和切片。步长表示从当前元素跳到下一个元素所需跳过的字节数。每个步长所占的字节数由数组的数据类型决定。让我们通过前面探讨的数组来理解步长。每个元素占用的字节数可以通过以下代码来确定：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is seen that each element occupies 4 bytes, and the entire array occupies
    180 bytes. The strides for the array are represented as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，每个元素占用4个字节，整个数组占用180个字节。数组的步长表示如下：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The shape of the array is given by the tuple (3, 5, 3). The values in the tuple
    represent the number of years for which there is data, the number of patients,
    and the number of clinical parameters, respectively. For each year or first dimension,
    there are 15 records, and hence to move from one year to another in the array,
    60 bytes should be jumped across. On a similar note, each distinct patient has
    3 records for a given year, and 12 bytes of memory should be moved past to get
    to the next patient.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的形状由元组（3, 5, 3）给出。元组中的值分别代表有数据的年份数、患者数和临床参数数。对于每个年份或第一维度，存在15条记录，因此在数组中从一个年份跳到另一个年份时，需要跳过60个字节。同样地，每个不同的患者在给定的年份中有3条记录，要跳过12个字节才能到达下一个患者。
- en: NumPy array creation
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy 数组创建
- en: NumPy arrays can be created in several ways via calls to various NumPy methods.
    The arrays can be created using the data in lists or any other data structures,
    by specifying numerical ranges to obtain uniformly spaced values or by generating
    random samples.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用各种 NumPy 方法以多种方式创建 NumPy 数组。这些数组可以使用列表或其他数据结构中的数据创建，或者通过指定数值范围来获得均匀间隔的值，或生成随机样本。
- en: 'The simplest routine to create an array is through the `array` function. This
    function accepts any sequential object, such as a list or tuple, and converts
    it to an array. The following code snippet shows how a 1D array can be created
    through the `array` function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组的最简单方法是通过 `array` 函数。此函数接受任何序列对象，如列表或元组，并将其转换为数组。以下代码片段演示了如何通过 `array` 函数创建一个一维数组：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, a multidimensional array can be created by passing a list of lists
    to the array function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以通过将列表的列表传递给 `array` 函数来创建一个多维数组：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Instead of lists, the same result can be achieved with tuples, a list of tuples,
    or a tuple of tuples as well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表不同，元组、元组的列表或元组的元组也能达到相同的结果。
- en: Array of ones and zeros
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一维零一数组
- en: 'Several operations on arrays call for the creation of arrays or matrices with
    ones and zeros. Some special functions in NumPy provide for easy creation of such
    arrays. Usually, these functions take in the shape of the resultant array as an
    input argument in the form of a tuple:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对数组进行的几种操作需要创建包含零和一的数组或矩阵。NumPy 中的一些特殊函数可以方便地创建此类数组。通常，这些函数接受作为输入参数的结果数组形状，形式为元组：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The identity function returns a 2D *n x n* square matrix, where *n* is the
    order of the matrix passed as an input argument:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该单位矩阵函数返回一个二维的 *n x n* 方阵，其中 *n* 是作为输入参数传入的矩阵的阶数：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `eye` function can also be used to create an identity matrix. It differs
    from the identity matrix in two main aspects:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`eye` 函数也可以用来创建单位矩阵。它与单位矩阵在两个方面有所不同：'
- en: The eye function returns a 2D rectangular matrix and accepts both the number
    of rows and number of columns (optional argument) as the input. If the number
    of columns is not specified, a square matrix is returned using just the number
    of rows passed in.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: eye 函数返回一个二维矩形矩阵，并接受行数和列数（可选参数）作为输入。如果未指定列数，将仅使用传入的行数返回一个方阵。
- en: The diagonal can be offset to any position in the upper triangle or lower triangle.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对角线可以偏移到上三角或下三角的任意位置。
- en: 'Take a look at the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下代码：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By default, `k` holds the value 0 in the eye function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`k` 在 eye 函数中保持值 0。
- en: Array based on a numerical range
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于数值范围的数组
- en: 'The `arange` function of NumPy functionally resembles Python''s range function.
    Based on a start value, stop value, and step value to increment or decrement subsequent
    values, the `arange` function generates a set of numbers. Just like the range
    function, the start and step arguments are optional here. But unlike range, which
    generates a list, `arange` generates an array:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的 `arange` 函数在功能上类似于 Python 的 range 函数。根据起始值、结束值和步长值来增量或减量后续值，`arange`
    函数生成一组数字。与 range 函数类似，这里的起始值和步长值是可选的。但不同于 range 函数生成列表，`arange` 会生成一个数组：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `linspace` function generates an array of linearly spaced samples for a
    given start point and end point. Unlike the arrange function, which specifies
    the incremental/decremental interval, the `linspace` function accepts the number
    of samples to be generated as an optional argument. By default, 50 samples are
    generated for a given start point and end point:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`linspace` 函数生成在给定起点和终点之间线性分布的样本数组。与指定增量/减量的 `arrange` 函数不同，`linspace` 函数接受生成样本的数量作为可选参数。默认情况下，会为给定的起点和终点生成
    50 个样本：'
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Similarly, the `logspace` and `geomspace` functions create an array of numbers
    following logarithmic and geometric sequences to be created.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`logspace` 和 `geomspace` 函数可以创建遵循对数和几何序列的数字数组。
- en: The `arange` function and `linspace` function do not allow for any shape specification
    by themselves and produce 1D arrays with the given sequence of numbers. We can
    very well use some shape manipulation methods to mold these arrays to the desired
    shape. These methods will be discussed in the last part of this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`arange` 函数和 `linspace` 函数本身不允许指定任何形状，并生成包含给定数字序列的一维数组。我们完全可以使用一些形状操作方法，将这些数组塑造成所需的形状。这些方法将在本章最后部分讨论。'
- en: Random and empty arrays
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机数组与空数组
- en: The `random` module of the NumPy package packs within it a whole range of functions
    for random sampling that perform operations right from creating a simple array
    of random numbers to drawing random samples from distribution functions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 包的 `random` 模块内置了一整套用于随机抽样的函数，可以执行从创建简单的随机数数组到从分布函数中抽取随机样本的操作。
- en: 'The `random.rand` function generates random values from 0 to 1 (uniform distribution)
    to create an array of given shape:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `random.rand` 生成从 0 到 1 的随机值（均匀分布），以创建给定形状的数组：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `random.randn` function samples values from a standard normal distribution
    to build an array of given shape. If the shape parameter is not specified, a single
    value is returned as output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `random.randn` 从标准正态分布中抽样数值以构建给定形状的数组。如果未指定形状参数，则返回单个值作为输出：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `random.randint` function generates an array of integers between the specified
    lower and upper bounds, with the given shape. The limit excludes the upper bound.
    If the upper bound is not mentioned, it is considered to be 1 more than the lower
    bound defined:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `random.randint` 生成介于指定下限和上限之间的整数数组，具有给定的形状。上限不包括在内。如果未提及上限，则认为上限比定义的下限大
    1：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `empty` function returns an array with arbitrary values for the given shape.
    This array requires no initialization and would perform faster than functions
    such as zeros and ones where the values have to be initialized. Caution is needed
    when using this function, and it is to be used only when it is certain that all
    the values in the array would be filled:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `empty` 返回具有给定形状的带有任意值的数组。此数组不需要初始化，并且在需要填充所有数组值时，执行速度比诸如零和一的函数更快。在使用此函数时需要谨慎，并且仅在确定数组中所有值都将被填充时才使用：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Arrays based on existing arrays
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于现有数组的数组
- en: Some of the NumPy array-creation routines are extremely useful to perform matrix
    operations such as constructing the **diagonal matrix** (**diag**), the **upper
    triangular matrix** (**triu**), and the **lower triangular matrix** (**tril**).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 NumPy 数组创建例程非常有用，可执行诸如构造**对角矩阵**（**diag**）、**上三角矩阵**（**triu**）和**下三角矩阵**（**tril**）之类的矩阵操作。
- en: 'The `diag` function works only on 1D and 2D arrays. If the input array is 2D,
    the output is a 1D array with the diagonal elements of the input array. If the
    input is a 1D array, the output is a matrix with the input array along its diagonal.
    Here, a parameter k helps to offset the position from the main diagonal and can
    be positive or negative:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `diag` 仅适用于 1D 和 2D 数组。如果输入数组为 2D，则输出为输入数组的对角元素的 1D 数组。如果输入为 1D 数组，则输出为具有输入数组沿其对角线的矩阵。此处，参数
    k 可以帮助偏移从主对角线的位置，并且可以是正数或负数：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `triu` and `tril` functions have a similar parameter k, which helps offset
    the diagonal. These functions work with any `ndarray`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `triu` 和 `tril` 具有类似的参数 k，可以帮助偏移对角线。这些函数适用于任何 `ndarray`。
- en: 'Given an array of *n* dimensions, a new array can be created by repeating this
    array multiple times along each axis. This can be done with the `tile` function.
    This function accepts two input arguments—the input array and the number of repetitions:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 *n* 维数组，可以通过沿每个轴重复此数组多次来创建新数组。这可以通过 `tile` 函数完成。此函数接受两个输入参数——输入数组和重复次数：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: NumPy data types
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy 数据类型
- en: All the array-creation functions described earlier (except the functions for
    arrays based on existing arrays—`diag`, `triu`, `tril`, and `tile`) have an argument
    `dtype` to define the data type of the array.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的所有数组创建函数（除了基于现有数组的函数——`diag`、`triu`、`tril` 和 `tile`）都有一个参数 `dtype`，用于定义数组的数据类型。
- en: 'Let''s create an array without predefining the data type, and then check for
    its data type:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个不预定义数据类型的数组，然后检查其数据类型：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s define the same array by also setting its data type to `float`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义同一个数组，并将其数据类型设置为 `float`：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It is seen that the elements of the array are all casted as floating points.
    It is also possible to cast this array as a string:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可见数组的元素全部被转换为浮点数。还可以将此数组转换为字符串：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this case, the elements are cast as strings. The output also specifies the
    data type as `<U2`. It indicates that the elements of the array are Unicode strings
    and the maximum accepted length of string for this array is 2\. This threshold
    on length is decided based on the length of the longest string in the array. Let''s
    understand this with another example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，元素被转换为字符串。输出还显示了数据类型为`<U2`。这表示数组的元素是Unicode字符串，并且该数组的最大字符串长度为2。这个长度阈值是根据数组中最长字符串的长度来决定的。让我们通过另一个例子来理解这一点：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Such typecasting is observed in arrays with strings, as optimal memory has to
    be allocated for the array. A single character occupies four bytes. Based on the
    maximum string length, each element will be allotted a memory block of size equal
    to four times the maximum string length.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型转换在包含字符串的数组中较为常见，因为数组需要为其分配最佳的内存空间。一个字符占用四个字节。根据最大字符串长度，每个元素将被分配一个大小为最大字符串长度四倍的内存块。
- en: 'NumPy arrays also support data types such as boolean and complex:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组还支持布尔型和复数型等数据类型：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The data type of `ndarray` can be changed in much the same way as we cast in
    other languages such as Java or C/C++. The `ndarray.astype` method helps in type
    conversion:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ndarray`的数据类型可以像在其他语言（如Java或C/C++）中进行类型转换一样进行更改。`ndarray.astype`方法有助于进行类型转换：'
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: More information on casting can be found in the official documentation at [http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类型转换的更多信息，请参考官方文档：[http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html)。
- en: NumPy indexing and slicing
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy索引与切片
- en: 'Array indices in NumPy start at `0` as in languages such as Python, Java, and
    C++ and unlike in Fortran, Matlab, and Octave, which start at `1`. Arrays can
    be indexed in the standard way as we would index into any other Python sequences:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy中的数组索引从`0`开始，和Python、Java、C++等语言类似，而不同于Fortran、Matlab和Octave，它们的索引从`1`开始。数组可以像索引其他Python序列一样按标准方式进行索引：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Arrays can be reversed using the `::-1` idiom as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以使用`::-1`惯用法进行反转，如下所示：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Multidimensional arrays are indexed using tuples of integers:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组使用整数元组进行索引：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we set the entry at `row1` and `column1` to `5`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将`row1`和`column1`的元素设置为`5`：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Retrieve row 2:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 获取第2行：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Retrieve column 1:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 获取第1列：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If an index is specified that is out of bounds of the range of an array, `IndexError`
    will be raised:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的索引超出了数组的范围，将会引发`IndexError`错误：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Thus, for 2D arrays, the first dimension denotes rows and the second dimension,
    the columns. The colon (`:`) denotes selection across all elements of the dimension.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于二维数组，第一维表示行，第二维表示列。冒号（`:`）表示选择该维度中的所有元素。
- en: Array slicing
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组切片
- en: 'Arrays can be sliced using the syntax `ar[startIndex: endIndex: stepValue]`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '数组可以使用语法`ar[startIndex: endIndex: stepValue]`进行切片：'
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that if we wish to include the `endIndex` value, we need to go above it,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们希望包含`endIndex`值，需要超出它，如下所示：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Obtain the first `nelements` using `ar[:n]`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ar[:n]`获取前`nelements`：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The implicit assumption here is that `startIndex=0, step=1`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 隐含的假设是`startIndex=0, step=1`。
- en: 'Start at element 4 and select all the elements till the end:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从元素4开始并选择直到末尾的所有元素：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Slice array with `stepValue=3`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`stepValue=3`切片数组：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To illustrate the scope of indexing in NumPy, let''s refer to the following
    diagram, which is taken from a NumPy lecture given at SciPy 2013 and can be found
    at [http://scipy-lectures.github.io/_images/numpy_indexing.png](http://scipy-lectures.github.io/_images/numpy_indexing.png):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明NumPy中索引的范围，参见以下图示，该图示来自2013年在SciPy会议上进行的NumPy讲座，详细信息可参见：[http://scipy-lectures.github.io/_images/numpy_indexing.png](http://scipy-lectures.github.io/_images/numpy_indexing.png)：
- en: '![](img/9378279b-e9f5-4c20-beb3-2a9863c10d54.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9378279b-e9f5-4c20-beb3-2a9863c10d54.png)'
- en: Pictorial illustration of NumPy indexing
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy索引的图示
- en: 'Let''s now examine the meanings of the expressions in the preceding diagram:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来分析前面图示中表达式的含义：
- en: The expression `a[0,3:5]` indicates the start at row 0, columns 3-5, column
    5 not included.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式`a[0,3:5]`表示从第0行开始，选择第3到第5列（不包括第5列）。
- en: In the expression `a[4:,4:]`, the first 4 indicates the start at row 4 and will
    give all columns, that is, the array [[40, 41,42,43,44,45] [50,51,52,53,54,55]].
    The second 4 shows the cutoff at the start of column 4 to produce the array [[44,
    45], [54, 55]].
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表达式`a[4:,4:]`中，第一个4表示从第4行开始，显示所有列，即数组[[40, 41, 42, 43, 44, 45] [50, 51, 52,
    53, 54, 55]]。第二个4表示在第4列开始截断，从而产生数组[[44, 45], [54, 55]]。
- en: The expression `a[:,2]` gives all rows from column 2.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式`a[:,2]`会返回所有行中的第2列。
- en: Now, in the last expression, `a[2::2,::2]`, `2::2` indicates that the start
    is at row 2 and the step value here is also 2\. This would give us the array [[20,
    21, 22, 23, 24, 25], [40, 41, 42, 43, 44, 45]]. Further, `::2` specifies that
    we retrieve columns in steps of 2, producing the end result array ([[20, 22, 24],
    [40, 42, 44]]).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，在最后一个表达式`a[2::2,::2]`中，`2::2`表示从第2行开始，步长为2。这会给我们生成数组[[20, 21, 22, 23, 24,
    25], [40, 41, 42, 43, 44, 45]]。进一步地，`::2`指定我们以步长为2的方式提取列，从而得到最终结果数组[[20, 22, 24],
    [40, 42, 44]]。
- en: 'Assignment and slicing can be combined as shown in the following code snippet:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值和切片可以结合使用，如下代码片段所示：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Array masking
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组掩码
- en: 'NumPy arrays can be used as filters on the larger original array. This process
    of using arrays as filters is called **array masking**. For example, see the following
    snippet:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组可以用作更大原始数组的过滤器。将数组用作过滤器的过程称为**数组掩码**。例如，以下代码片段演示了这一过程：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the following example, we randomly generate an array of 10 integers between
    0 and 25\. Then, we create a boolean mask array that is used to filter out only
    the even numbers. This masking feature can be very useful, say, for example, if
    we wished to eliminate missing values by replacing them with a default value.
    Here, the missing value `''''` is replaced by `''USA''` as the default country.
    Note that `''''` is also an empty string:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们随机生成一个包含10个整数（范围为0到25）的数组。然后，我们创建一个布尔掩码数组，用于仅过滤出偶数。这个掩码功能非常有用，例如，如果我们希望通过用默认值替换来消除缺失值。在这里，缺失值`''`被默认的国家`'USA'`替换。请注意，`''`也是一个空字符串：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Arrays of integers can also be used to index an array to produce another array.
    Note that this produces multiple values; hence, the output must be an array of
    type `ndarray`. This is illustrated in the following snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 整型数组也可以用作索引来访问数组，从而生成另一个数组。注意，这会产生多个值，因此输出必须是`ndarray`类型的数组。以下代码片段中进行了演示：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding code, the selection object is a list, and elements at indices
    1, 3, 4, 2, and 7 are selected. Now, assume that we change it to the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，选择对象是一个列表，选中了索引为1、3、4、2和7的元素。现在，假设我们将其更改为以下内容：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We get an `IndexError` error since the array is 1D and we''re specifying too
    many indices to access it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组是1D的，而我们指定了过多的索引来访问它，因此会引发`IndexError`错误：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This assignment is also possible with array indexing, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这种赋值操作也可以通过数组索引实现，如下所示：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When a new array is created from another array by using a list of array indices,
    the new array has the same shape.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过使用数组索引列表从另一个数组创建一个新数组时，新数组将具有相同的形状。
- en: Complex indexing
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂索引
- en: 'Here, we illustrate the use of complex indexing to assign values from a smaller
    array into a larger one:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们通过使用复杂的索引来将较小数组的值赋值给较大的数组：
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Slice out the first 10 elements of `ar`, and replace them with elements from
    `ar2`, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 切片出`ar`的前10个元素，并用`ar2`中的元素替换它们，如下所示：
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Copies and views
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 副本与视图
- en: A view on a NumPy array is just a particular way of portraying the data it contains.
    Creating a view does not result in a new copy of the array, rather the data it
    contains may be arranged in a specific order, or only certain data rows may be
    shown. Thus, if data is replaced on the underlying array's data, this will be
    reflected in the view whenever the data is accessed via indexing.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组的视图只是以特定方式呈现其包含的数据。创建视图并不会生成数组的新副本，而是可能以特定的顺序排列其中的数据，或只显示某些数据行。因此，如果在底层数组的数据上替换了数据，任何通过索引访问数据时，视图都会反映出这些变化。
- en: 'The initial array is not copied into the memory during slicing and is thus
    more efficient. The `np.may_share_memory` method can be used to see whether two
    arrays share the same memory block. However, it should be used with caution as
    it may produce false positives. Modifying a view modifies the original array:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在切片时，初始数组不会被复制到内存中，因此效率更高。可以使用`np.may_share_memory`方法查看两个数组是否共享同一内存块。然而，应谨慎使用该方法，因为它可能会产生假阳性结果。修改视图会修改原始数组：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To force NumPy to copy an array, we use the `np.copy` function. As we can see
    in the following array, the original array remains unaffected when the copied
    array is modified:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制 NumPy 复制一个数组，我们使用 `np.copy` 函数。如以下数组所示，当修改复制的数组时，原始数组保持不变：
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Operations
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作
- en: Many methods on NumPy arrays require running mathematical operators such as
    addition, subtraction, multiplication, division, and so on, on the arrays. The
    following section deals with explaining how these operators are applied on the
    arrays.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组的许多方法需要在数组上运行数学运算符，如加法、减法、乘法、除法等。以下部分将解释这些运算符如何应用于数组。
- en: Basic operators
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本运算符
- en: 'NumPy is highly efficient in performance as it works based on vectorized operations,
    where the need for loops is avoided and the process becomes several times faster.
    All basic arithmetic operations involving +, -, *, and / take place elementwise
    and are vectorized:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 在性能上非常高效，因为它基于向量化操作工作，避免了循环的需要，使得处理速度快了好几倍。所有基本的算术运算（如 +、-、*、/）都以元素为单位进行，并且是向量化的：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Operations involving two arrays, such as adding or multiplying two arrays,
    also takes place in a vectorized manner:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及两个数组的操作，如加法或乘法，也是以向量化方式进行的：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Python''s `timeit` function will give us a sense of how efficient vectorized
    operations are compared to looping over items:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `timeit` 函数可以让我们了解向量化操作与遍历项进行循环时的效率差异：
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This shows that `numpy` operations are about 100 times faster than for loops.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，`numpy` 操作比 for 循环快大约 100 倍。
- en: Mathematical operators
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学运算符
- en: The mathematical operators of NumPy can mainly support trigonometric operations,
    arithmetic operations, and exponential and logarithmic operations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的数学运算符主要支持三角函数运算、算术运算，以及指数和对数运算。
- en: 'A class of these operators, such as `prod`, `sum`, and so on, perform computations
    within the array and serve to reduce the matrix. For example, the `sum` function
    calculates the sum along a given axis. The output will be the sum of elements
    along the axis. These functions can be called as a `numpy.function` or as an `ndarray.method`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这类运算符，如 `prod`、`sum` 等，会在数组内执行计算并实现矩阵的缩减。例如，`sum` 函数计算沿给定轴的和。输出将是该轴上元素的和。这些函数可以作为
    `numpy.function` 或 `ndarray.method` 调用：
- en: '[PRE52]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Statistical operators
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统计运算符
- en: 'A wide range of statistical operations, such as computing mean, median, variance,
    and standard deviation, can be calculated for NumPy arrays using the available
    statistical operators. The aggregates, such as mean, median, variance, and standard
    deviation, for an entire array can be calculated as shown in the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用现有的统计运算符计算 NumPy 数组的各种统计操作，例如计算均值、中位数、方差和标准差。可以按如下代码计算整个数组的聚合值，例如均值、中位数、方差和标准差：
- en: '[PRE53]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'By default, these statistical parameters are computed by flattening out the
    array. To compute the statistical parameters along any of the axes, the `axis`
    argument can be defined when calling these functions. Let''s look at this behavior
    with the `mean` function as an example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些统计参数是通过展平数组来计算的。要沿某个轴计算统计参数，可以在调用这些函数时定义 `axis` 参数。我们以 `mean` 函数为例来查看这种行为：
- en: '[PRE54]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'There are special implementations of these functions to handle arrays with
    missing values or `NA`s. These functions are `nanmean`, `nanmedian`, `nanstd`,
    `nanvar`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数有专门的实现来处理包含缺失值或 `NA` 的数组。这些函数是 `nanmean`、`nanmedian`、`nanstd`、`nanvar`：
- en: '[PRE55]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `corrcoeff` and `cov` functions help compute the Pearson''s correlation
    coefficients and the covariance matrix for a given array or two given arrays:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`corrcoeff` 和 `cov` 函数帮助计算给定数组或两个给定数组的 Pearson 相关系数和协方差矩阵：'
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Logical operators
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: The logical operators help compare arrays, check the type and contents of an
    array, and perform logical comparison between arrays.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符帮助比较数组、检查数组的类型和内容，并进行数组之间的逻辑比较。
- en: 'The `all` and `any` functions help to evaluate whether all or any values along
    the specified axis evaluate to `True`. Based on the evaluation result, it returns
    `True` or `False`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`all` 和 `any` 函数帮助评估沿指定轴上的所有或任何值是否为 `True`。根据评估结果，它返回 `True` 或 `False`：'
- en: '[PRE57]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: For both the `all` and `any` methods described previously, `axis` is an optional
    parameter. When it is not provided, the array is flattened and considered for
    computation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面描述的 `all` 和 `any` 方法，`axis` 是一个可选参数。如果没有提供，则会将数组展平并用于计算。
- en: 'Some functions test for the presence of `NAs` or infinite values in the array.
    Such functionalities are an essential part of data processing and data cleaning.
    These functions take in an array or array-like object as input and return the
    truth value as output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数用来测试数组中是否存在`NAs`或无限值。这些功能是数据处理和数据清理中的重要组成部分。这些函数接受一个数组或类数组对象作为输入，并返回布尔值作为输出：
- en: '[PRE58]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Operators such as greater, less, and equal help to perform element-to-element
    comparison between two arrays of identical shape:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如大于、小于和等于等运算符帮助在形状相同的两个数组之间执行逐元素比较：
- en: '[PRE59]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Broadcasting
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广播
- en: 'Using broadcasting, we can work with arrays that don''t have exactly the same
    shape. Here is an example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用广播，我们可以处理形状不完全相同的数组。以下是一个示例：
- en: '[PRE60]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Thus, we can see that `ar2` is broadcast across the rows of `ar` by adding
    it to each row of `ar`, producing the preceding result. Here is another example,
    showing that broadcasting works across dimensions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到`ar2`通过将其添加到`ar`的每一行，实现了在`ar`的行上进行广播，得到了上面的结果。以下是另一个示例，展示了广播如何跨维度工作：
- en: '[PRE61]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, both row and column arrays were broadcast and we ended up with a 3 × 3
    array.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，行数组和列数组都进行了广播，最终得到了一个3 × 3的数组。
- en: Array shape manipulation
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组形状操作
- en: More often than not, data needs to be transformed before it becomes usable in
    analysis. The same is true for arrays. NumPy has some special sets of functions
    that help in reshaping and transforming arrays.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在数据可以用于分析之前，需要进行转换。数组也不例外。NumPy提供了一些专门的函数集，帮助重新塑造和转换数组。
- en: Reshaping
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变形状
- en: The `reshape` function helps to modify the shape of the array. It accepts two
    main input arguments—the array to be processed and the expected shape as an integer
    or tuple of integers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`reshape`函数帮助修改数组的形状。它接受两个主要输入参数——需要处理的数组和期望的形状（整数或整数元组）。'
- en: 'Previously in this chapter, we saw that `np.arange` should rely upon an external
    function to transform the data from being 1D:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们看到`np.arange`应该依赖外部函数将数据从一维转换：
- en: '[PRE62]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `np.reshape` function returns a view of the data, meaning the underlying
    array remains unchanged. In special cases, however, the shape cannot be changed
    without the data being copied. For more details on this, see the documentation
    at [http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.reshape`函数返回的是数据的视图，这意味着底层数组保持不变。然而，在特殊情况下，形状不能改变而不复制数据。有关详细信息，请参见[http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html)的文档。'
- en: Transposing
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转置
- en: 'The `transpose` function reverses the dimensions of an array:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`transpose`函数会反转数组的维度：'
- en: '[PRE63]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following result is obtained on applying `transpose` on a multidimensional
    array:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对多维数组应用`transpose`后的结果如下：
- en: '[PRE64]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Ravel
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉平
- en: 'Ravel helps to flatten the data from multidimensional to 1D:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 拉平帮助将数据从多维数组压缩为一维数组：
- en: '[PRE65]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The order in which the array is raveled can be set. The order can be `"C"`,
    `"F"`, `"A"`, or `"K"`. `"C"` is the default order, where the array gets flattened
    along the row major, while with "F", flattening occurs along the column major.
    "A" reads the array elements in a Fortran-like index-based order and "K" reads
    the elements in the order in which they are stored in memory:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置数组拉平的顺序。顺序可以是`"C"`、`"F"`、`"A"`或`"K"`。`"C"`是默认顺序，表示沿着行主序展开数组，而使用`"F"`时，数组沿列主序展开。`"A"`按类似Fortran的索引顺序读取数组元素，而`"K"`则按照元素在内存中存储的顺序读取：
- en: '[PRE66]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Adding a new axis
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新轴
- en: 'NumPy has the `newaxis` method to add additional axes to the existing array:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了`newaxis`方法，用来在现有数组中添加额外的轴：
- en: '[PRE67]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Basic linear algebra operations
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的线性代数运算
- en: Linear algebra constitutes a set of vital operations for matrices and arrays.
    The NumPy package is built with a special module called `linalg` to deal with
    all linear algebra requirements. The following segment discusses some frequently
    used functions of the `linalg` module in detail.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数是矩阵和数组的重要运算集合。NumPy包内置了一个名为`linalg`的特殊模块，用于处理所有线性代数的需求。以下部分将详细讨论`linalg`模块中一些常用的函数。
- en: 'The dot function of the `linalg` module helps in matrix multiplication. For
    2D arrays, it behaves exactly like matrix multiplication. It requires the last
    dimension of the first array to be equal to the last dimension of the second array.
    The arrays need not have equal numbers of dimensions. For an  N-dimensional array,
    the output will have 2N-2 dimensions:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`linalg`模块的点乘函数帮助进行矩阵乘法。对于二维数组，它的行为与矩阵乘法完全相同。它要求第一个数组的最后一个维度与第二个数组的最后一个维度相等。数组的维度不必相等。对于N维数组，输出将具有2N-2个维度：'
- en: '[PRE68]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `linalg.multidot` function can help in computing the product of several
    arrays at once, instead of using a nested sequence of dot functions. This function
    automatically finds the most efficient order for evaluating the sequence of products.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`linalg.multidot`函数可以帮助一次性计算多个数组的乘积，而不是使用嵌套的点乘函数序列。此函数会自动找到最有效的计算顺序来评估乘积序列。'
- en: 'The `linalg.svd` function helps in singular value decomposition and returns
    three arrays as the result of decomposition. It accepts an array with two or more
    dimensions as the input:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`linalg.svd`函数帮助进行奇异值分解，并返回分解后的三个数组。它接受一个具有两个或更多维度的数组作为输入：'
- en: '[PRE69]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Eigenvalues and eigenvectors of an array can be calculated with the `linalg.eig`
    function. The `eig` function requires the last two dimensions of the input array
    to be a square. The same function returns both the eigenvalues and the eigenvectors:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的特征值和特征向量可以通过`linalg.eig`函数计算。`eig`函数要求输入数组的最后两个维度是方阵。该函数返回特征值和特征向量：
- en: '[PRE70]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `linalg` module also has functions to solve linear equations. The `linalg.solve`
    function takes in a coefficient matrix and the dependent variable, and solves
    for the exact solution. It requires that all rows of the coefficient matrix must
    be linearly independent:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`linalg`模块还提供了求解线性方程的函数。`linalg.solve`函数接受一个系数矩阵和因变量，并求解出精确解。它要求系数矩阵的所有行必须是线性独立的：'
- en: '[PRE71]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If the best possible solution is needed instead of the exact solution, the least-squares
    solution could be obtained from the `linalg.lstsq` function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要最优解而非精确解，可以通过`linalg.lstsq`函数获得最小二乘解。
- en: 'The `linalg.det` function computes the determinant of a square array. If there
    are more than two dimensions in the input array, it is treated as a stack of matrices
    and the determinant is computed for each stack. The last two dimensions must,
    however, correspond to a square matrix:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`linalg.det`函数计算方阵的行列式。如果输入数组有超过两个维度，它会被视为矩阵的堆栈，并计算每个堆栈的行列式。不过，最后两个维度必须对应一个方阵：'
- en: '[PRE72]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Array sorting
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组排序
- en: 'Arrays can be sorted in various ways:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以通过多种方式进行排序：
- en: 'Sorting the array along an axis; first, let''s discuss this along the *y* axis:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 沿着某一轴对数组进行排序；首先，我们来讨论沿着*y*轴的排序：
- en: '[PRE73]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here, we will explain the sorting along the *x* axis:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将解释沿着*x*轴的排序：
- en: '[PRE74]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Sorting by in-place (`np.array.sort`) and out-of-place (`np.sort`) functions.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过就地排序（`np.array.sort`）和非就地排序（`np.sort`）函数进行排序。
- en: 'Other operations that are available for array sorting include the following:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他可用于数组排序的操作包括以下内容：
- en: '`np.min()`: This returns the minimum element in the array'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.min()`：此函数返回数组中的最小元素'
- en: '`np.max()`: This returns the maximum element in the array'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.max()`：此函数返回数组中的最大元素'
- en: '`np.std()`: This returns the standard deviation of the elements in the array'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.std()`：此函数返回数组中元素的标准差'
- en: '`np.var()`: This returns the variance of elements in the array'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.var()`：此函数返回数组中元素的方差'
- en: '`np.argmin()`: This returns indices of minimum value in the array'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.argmin()`：此函数返回数组中最小值的索引'
- en: '`np.argmax()`: This returns indices of maximum value in the array'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.argmax()`：此函数返回数组中最大值的索引'
- en: '`np.all()`: This returns elementwise logical ''and'' of all the elements'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.all()`：此函数返回数组中所有元素的逐元素逻辑“与”'
- en: '`np.any()`: This returns elementwise logical ''or'' of all the elements'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.any()`：此函数返回数组中所有元素的逐元素逻辑“或”'
- en: Up to now, we have been getting acquainted with the functionalities of NumPy.
    In the coming sections, we will look at two practical examples where NumPy arrays
    are widely used for performing complex computations. After that, we will move
    on to delving deeper into the core data structures of pandas, such as DataFrames,
    Series, and Panels—how they are created, modified, and used.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经熟悉了NumPy的功能。在接下来的部分中，我们将查看两个实际应用示例，其中广泛使用NumPy数组来执行复杂的计算。之后，我们将深入探讨pandas的核心数据结构，如DataFrame、Series和Panel——它们是如何创建、修改和使用的。
- en: Implementing neural networks with NumPy
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NumPy实现神经网络
- en: While NumPy is definitely not the go-to package for training a neural network
    in real-time scenarios, learning to implement it in NumPy brings out the flexibility
    and might of NumPy for doing complex matrix computations and also provides a better
    understanding of neural networks.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管NumPy并不是训练神经网络的首选包，但通过在NumPy中实现它，能展示NumPy在执行复杂矩阵计算方面的灵活性和强大功能，并且有助于更好地理解神经网络。
- en: 'First, let''s synthetically generate a dataset for a binary classification
    problem that will be used for training the neural network. The data will be from
    two different Gaussian distributions, and the model will be trained to classify
    this data into either of the two categories. Let''s generate the data with 1,000
    samples in each category:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们合成一个用于二分类问题的数据集，将用于训练神经网络。这些数据来自两个不同的高斯分布，模型将被训练来将数据分类为这两类中的任何一类。我们将为每个类别生成1000个样本：
- en: '[PRE75]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now we have two 1000 x 2 arrays. For the predictor variable, we can use the
    `zeros` and `ones` functions to create two different 1D arrays:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个1000 x 2的数组。对于预测变量，我们可以使用`zeros`和`ones`函数来创建两个不同的1D数组：
- en: '[PRE76]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The four arrays—X1, X2, Y1, and Y2—must be stacked together to create the complete
    training set with dimensions 2000 x 3:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 四个数组——X1、X2、Y1和Y2——必须堆叠在一起，形成维度为2000 x 3的完整训练集：
- en: '[PRE77]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Our aim is to build a simple neural network with one hidden layer and three
    neurons. For a moment, let's move away from NumPy to understand the architecture
    of the neural network we will be building from scratch.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是构建一个简单的神经网络，包含一个隐藏层和三个神经元。暂时让我们先不使用NumPy，来理解我们将要从零开始构建的神经网络架构。
- en: 'The following is a schematic diagram of a simple neural network architecture:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单神经网络架构的示意图：
- en: '![](img/a0cca604-4775-4916-ab4c-485a67f061ae.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0cca604-4775-4916-ab4c-485a67f061ae.png)'
- en: Schematic diagram of a simple neural network architecture
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 简单神经网络架构示意图
- en: 'There are two neurons in the input layer, three neurons in the hidden layer,
    and a single output neuron. The squares represent the bias. To implement the neural
    network, the independent variables and predictor have been stored in `x` and `t`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 输入层有两个神经元，隐藏层有三个神经元，输出层有一个神经元。方框表示偏置。为了实现神经网络，独立变量和预测变量已存储在`x`和`t`中：
- en: '[PRE78]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As this is a binary classification problem, a sigmoid function would be an
    ideal choice for the activation function:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个二分类问题，sigmoid函数是激活函数的理想选择：
- en: '[PRE79]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The preceding function does the sigmoid transformation and also derivative computation
    (for backpropagation). The process of training consists of two modes of propagation—feedforward
    and backpropagation.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数执行sigmoid变换，并计算其导数（用于反向传播）。训练过程包含两种传播模式——前馈传播和反向传播。
- en: 'The first stage of feedforward is from the input layer to the hidden layer.
    This stage can be summarized with the following set of equations:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 前馈传播的第一阶段是从输入层到隐藏层。这个阶段可以通过以下方程组来总结：
- en: '*ah1 = sigmoid(x1*w_ih11 + x2*w_ih21 + 1* b_ih1)*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*ah1 = sigmoid(x1*w_ih11 + x2*w_ih21 + 1*b_ih1)*'
- en: '*ah2 = sigmoid(x1*w_ih12 + x2*w_ih22 + 1*b_ih2)*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*ah2 = sigmoid(x1*w_ih12 + x2*w_ih22 + 1*b_ih2)*'
- en: '*ah3 = sigmoid(x1*w_ih13 + x2*w_ih23 + 1*b_ih3)*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*ah3 = sigmoid(x1*w_ih13 + x2*w_ih23 + 1*b_ih3)*'
- en: 'Here, `ah1`, `ah2`, and `ah3` are inputs to the next stage of the feedforward
    network, from the hidden layer to the output. This involves multiplying the input
    matrix of dimensions 2000 x 2 and weight matrix `w_ih` of dimensions 2 x 3 (three
    hidden neurons, hence 3), and then adding the bias. Instead of handling the bias
    components separately, they could be handled as part of the weight matrix. This
    can be done by adding a unit column vector to the input matrix and inserting the
    bias values as the last row of the weight matrix. Hence, the new dimensions of
    the input matrix and weight matrix would be 2000 x 3 and 3 x 3:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ah1`、`ah2`和`ah3`是前馈网络下一阶段的输入，从隐藏层到输出层。这涉及将维度为2000 x 2的输入矩阵与维度为2 x 3的权重矩阵`w_ih`（有三个隐藏神经元，因此是3）相乘，然后加上偏置。与其单独处理偏置分量，不如将它们作为权重矩阵的一部分处理。可以通过向输入矩阵添加单位列向量，并将偏置值作为权重矩阵的最后一行来实现。因此，输入矩阵和权重矩阵的新维度将分别为2000
    x 3和3 x 3：
- en: '[PRE80]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The weight matrix is initialized with random values:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 权重矩阵初始化为随机值：
- en: '[PRE81]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here, `*a_h*` is the input matrix for the second stage of feedforward. Just
    as in the case of input matrix *x, `a_h`* should be appended with unit column
    vectors for the bias and the second weight matrix should be initialized:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`*a_h*` 是前馈阶段第二阶段的输入矩阵。就像输入矩阵 *x* 的情况一样，`a_h`* 应该附加单位列向量作为偏置，并且第二个权重矩阵应该初始化：
- en: '[PRE82]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now the matrix multiplication and sigmoid transformation can be done for this
    stage:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以对这一阶段进行矩阵乘法和 Sigmoid 转换：
- en: '[PRE83]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'For simplicity''s sake, let''s use mean squared error as the loss function,
    though it would be more appropriate to use a log loss function for a classification
    problem:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们使用均方误差作为损失函数，尽管对于分类问题来说，使用对数损失函数会更合适：
- en: E = ((1 / 2) * (np.power((a_o - t), 2)))
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: E = ((1 / 2) * (np.power((a_o - t), 2)))
- en: This marks the end of feedforward and the beginning of backpropagation. Backpropagation
    aims to find the delta or difference to be made to the weights and biases for
    the error *E* to reduce. The entire process of backpropagation can be summarized
    in the following two equations.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着前馈的结束和反向传播的开始。反向传播的目标是找到应对权重和偏置进行的增量或差异，从而使得误差 *E* 减少。整个反向传播过程可以通过以下两个方程式总结。
- en: The first one calculates the change in loss function *E* w.r.t *w_ho* and the
    second one calculates the change in loss function *E* w.r.t *w_ih:*
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个计算损失函数 *E* 关于 *w_ho* 的变化，第二个计算损失函数 *E* 关于 *w_ih* 的变化：
- en: '![](img/770f0a28-dc2c-4cdf-a2ee-d97502b222af.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/770f0a28-dc2c-4cdf-a2ee-d97502b222af.png)'
- en: '![](img/43af660e-3839-4454-b051-0f6acec1f14e.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43af660e-3839-4454-b051-0f6acec1f14e.png)'
- en: 'Now, the implementation of these equations in NumPy is as simple as computing
    all the derivatives necessary and finding the corresponding products:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 NumPy 中实现这些方程式就像计算所有必要的导数并找到相应的乘积一样简单：
- en: '[PRE84]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The change to be made to the weight has been computed. Let''s use these delta
    values to update the weights:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对权重进行的变化已经计算出来。我们来使用这些增量值来更新权重：
- en: '[PRE85]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Here, `*eta*` is the learning rate of the model. Feedforward will take place
    again using the updated weights. Backpropagation will again follow to reduce the
    error. Hence, feedforward and backpropagation should take place iteratively for
    a set number of epochs. The complete code is as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`*eta*` 是模型的学习率。使用更新后的权重将再次进行前馈操作。反向传播将再次跟随，以减少误差。因此，前馈和反向传播应在设定的迭代次数内反复进行。完整代码如下：
- en: '[PRE86]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The neural network has been implemented for 5,000 epochs. This is a simple yet
    efficient model quite suitable for a range of problems. Good accuracy can be obtained
    by choosing the right epoch, learning rate, loss function, and activation function.
    To test and validate, make use of just the feedforward module.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络已经运行了 5,000 次迭代。这是一个简单而高效的模型，非常适合解决各种问题。通过选择合适的迭代次数、学习率、损失函数和激活函数，可以获得良好的准确率。要进行测试和验证，仅使用前馈模块即可。
- en: Practical applications of multidimensional arrays
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多维数组的实际应用
- en: Panel data (spreadsheet-like data with several distinguishable rows and columns;
    the kind of data we generally encounter) is best handled by the DataFrame data
    structure available in pandas and R. Arrays can be used too but it would be tedious.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 面板数据（类似电子表格的数据，具有几个可区分的行和列；我们通常遇到的数据类型）最好由 pandas 和 R 中的 DataFrame 数据结构处理。也可以使用数组，但那样会很繁琐。
- en: So what is a good example of data in real life that can be best represented
    by an array? Images, which are generally represented as multidimensional arrays
    of pixels, are a good example. In this section, we will see examples of multidimensional
    representation of an image and why it makes sense.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现实生活中一个可以最好地用数组表示的数据的好例子是什么呢？图像通常表示为像素的多维数组，是一个很好的例子。在本节中，我们将看到图像的多维表示示例以及为什么它是合理的。
- en: Any object detection or image-processing algorithm performed on an image requires
    it to be represented in a numerical array format. For text data, term-document
    matrix and **term frequency-inverse document frequency** (**TF-IDF**) are used
    to vectorize (create numerical arrays) the data. In the case of an image, pixel
    values are used to represent an image.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在图像上执行的物体检测或图像处理算法都要求将其表示为数值数组格式。对于文本数据，使用术语-文档矩阵和**词频-逆文档频率**（**TF-IDF**）来将数据向量化（创建数值数组）。在图像的情况下，像素值用于表示图像。
- en: 'For a 100 x 50 pixel RGB image, there would be the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个 100 x 50 像素的 RGB 图像，将会有以下内容：
- en: 5,000 pixel values in one channel
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个通道中的 5,000 个像素值
- en: Three channels each for red, blue, and green
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个通道有红色、蓝色和绿色
- en: Hence, if you flatten the image pixels as one single vector, its length would
    be 15,000 (5,000 for each of the three channels). A grayscale image would contain
    a single channel. Each pixel value represents the degree of brightness for each
    channel.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果将图像像素展平为一个单一的向量，它的长度将是15,000（每个通道各5,000）。灰度图像则只有一个通道。每个像素值代表每个通道的亮度程度。
- en: 'A dataset of multiple images then becomes four-dimensional data representing
    the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一组多张图像的数据集会变成四维数据，表示如下：
- en: Width of the image in pixels
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的宽度（以像素为单位）
- en: Height of the image in pixels
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的高度（以像素为单位）
- en: Number of channels
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道数
- en: Serial number of the image
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的序列号
- en: 'Let''s verify the shape of the resultant image pixel arrays by reading an image.
    To work with images, a Python package called **opencv** (`cv2`) is quite helpful:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过读取图像来验证结果图像像素数组的形状。为了处理图像，Python中有一个叫**opencv**（`cv2`）的库非常有帮助：
- en: '[PRE87]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `imread` method returns an array of pixels. Let''s check the object type
    of the returned object `img`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`imread`方法返回一个像素数组。让我们检查返回的对象`img`的类型：'
- en: '[PRE88]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This returns `<class 'numpy.ndarray'>`, which confirms that it returns a `numpy`
    array.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回`<class 'numpy.ndarray'>`，这确认它返回的是一个`numpy`数组。
- en: 'Next, let''s have a look at the shape of the array. It should return us the
    pixel width, pixel height, and number of channels:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看数组的形状。它应该返回像素宽度、像素高度和通道数：
- en: '[PRE89]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This returns (183, 275, 3).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 (183, 275, 3)。
- en: It is a tuple of three numbers representing image height in pixels, image width
    in pixels, and number of channels. Hence, this image has a height of 183 pixels,
    a width of 275 pixels, and three channels of the dimension 183 x 275 representing
    red, blue, and green.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个包含三个数字的元组，分别表示图像的高度（以像素为单位）、图像的宽度（以像素为单位）和通道数。因此，这张图像的高度为183像素，宽度为275像素，并且有三个通道，维度为183
    x 275，分别表示红色、蓝色和绿色。
- en: 'The `img` object looks as follows on printing:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 打印时，`img`对象如下所示：
- en: '![](img/45a81f61-f7c1-4478-ac6c-1ea05abccf92.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45a81f61-f7c1-4478-ac6c-1ea05abccf92.png)'
- en: Image pixels as a multidimensional array
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 作为多维数组的图像像素
- en: 'Now the question arises, why would someone want to subset an array of image
    pixels? There can be multiple reasons for that:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题来了，为什么有人会想要子集化一个图像像素数组呢？这可能有多个原因：
- en: Selecting and/or manipulating a region of interest in the image. This can be
    a small block of the image representing an object.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择和/或操作图像中的兴趣区域。这可以是表示物体的图像中的一个小块。
- en: Selecting only one color channel from the image.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅从图像中选择一个颜色通道。
- en: 'The array of pixels can be seen as a plot/image with pixel height and pixel
    width as the axes labels as shown in the following code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将像素数组视为一个图像/绘图，其中像素高度和像素宽度作为坐标轴标签，代码如下所示：
- en: '[PRE90]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Take a look at the following output:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下输出：
- en: '![](img/cc06a144-45ed-47fa-8a48-76a246519643.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc06a144-45ed-47fa-8a48-76a246519643.png)'
- en: Image pixel arrays plotted as an image
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 作为图像绘制的图像像素数组
- en: Selecting only one channel
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅选择一个通道
- en: As we saw earlier, the third dimension denotes the RGB channel. Hence, to filter
    all the pixels in one channel, we should select all the pixels in the first two
    dimensions and only the channel of interest. Also, the indexing in Python starts
    from 0, thus 0 represents red, 1 represents green, and 2 represents blue. Keeping
    these in mind, let's have a look at the snippets to select the red, green, and
    blue channels of an image.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，第三维表示RGB通道。因此，要过滤某一通道中的所有像素，我们应选择前两维的所有像素，仅选择感兴趣的通道。另外，Python中的索引从0开始，因此0表示红色，1表示绿色，2表示蓝色。牢记这些，接下来让我们看看选择图像中红色、绿色和蓝色通道的代码片段。
- en: 'The snippet to select the red is as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 选择红色通道的代码片段如下：
- en: '[PRE91]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The following is the output:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/6f214d64-224b-44ed-bff5-98cae2c4add8.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f214d64-224b-44ed-bff5-98cae2c4add8.png)'
- en: Image pixel array made of selecting only pixels in the red channel visualized
    as an image
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 仅选择红色通道中的像素构成的图像像素数组，已作为图像可视化
- en: 'The snippet to select the green is as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 选择绿色通道的代码片段如下：
- en: '[PRE92]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The following is the output:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/a5a6e4c2-393f-4a3d-9a0b-ff4dfc11077f.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5a6e4c2-393f-4a3d-9a0b-ff4dfc11077f.png)'
- en: Image pixel array made of selecting only pixels in the green channel visualized
    as an image
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 仅选择绿色通道中的像素构成的图像像素数组，已作为图像可视化
- en: 'The snippet to select the blue is as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 选择蓝色通道的代码片段如下：
- en: '[PRE93]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The following is the output:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/013cbf29-7d82-4c16-91c8-bdfccc7e6c14.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/013cbf29-7d82-4c16-91c8-bdfccc7e6c14.png)'
- en: Image pixel array made of selecting only pixels in the blue channel visualized
    as an image
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 仅选择蓝色通道的像素所构成的图像像素数组，已被可视化为图像
- en: Selecting the region of interest of an image
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择图像的兴趣区域
- en: 'Let''s try to select the tree in the preceding screenshot. Looking at the image
    with axis labels, it is evident that vertical bounds of the tree are within 50
    to 155 pixels while horizontal bounds are within 95 to 190 pixels. Let''s try
    to subset this region with all the channels:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试选择前面截图中的树。通过查看带有坐标轴标签的图像，可以明显看出树的垂直范围在50到155像素之间，水平方向的范围在95到190像素之间。让我们尝试通过所有通道来子集该区域：
- en: '[PRE94]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The following image shows us the **region of interest** (**ROI**) that is selected
    therein:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了所选的**兴趣区域**（**ROI**）：
- en: '**![](img/f8bd95c3-e4a9-4ed7-b0b2-bea749b34226.png)**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/f8bd95c3-e4a9-4ed7-b0b2-bea749b34226.png)**'
- en: Selecting an ROI in an image
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 选择图像中的ROI
- en: This operation is akin to cropping an image.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作类似于裁剪图像。
- en: 'The pixel values of a certain ROI or a channel can be assigned some different
    values. This can be used to do the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 某个ROI或通道的像素值可以被赋予不同的值。这个方法可以用于以下操作：
- en: Remove certain channels (if we replace the values in that channel with 0)
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除某些通道（如果我们将该通道的值替换为0）
- en: Copy and paste a certain ROI to another part of the image
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将某个ROI复制并粘贴到图像的另一部分
- en: 'The following code shows an example of the latter case:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了后者的示例：
- en: '[PRE95]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The following image shows the selected ROI that is being pasted to another
    image area:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了将所选ROI粘贴到另一个图像区域的情况：
- en: '**![](img/025d5551-131f-4e3d-9de8-04017e15976b.png)**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/025d5551-131f-4e3d-9de8-04017e15976b.png)**'
- en: Pasting a selected ROI to another image area
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 将选定的ROI粘贴到另一个图像区域
- en: In this example, we have copied the tree ROI and pasted it to an area to the
    left of the selected ROI. This has been obtained by assigning the pixels of the
    pasting destination values equal to the pixel value of the copy source.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将树的ROI复制并粘贴到所选ROI左侧的区域。此操作通过将粘贴目标位置的像素值设置为复制源的像素值来实现。
- en: Multiple channel selection and suppressing other channels
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多通道选择并抑制其他通道
- en: 'To show pixels of only a certain color, the pixels of other colors need to
    be suppressed or assigned a value of 0\. The channel selection can happen via
    indexing or by passing a list:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示仅某种颜色的像素，其他颜色的像素需要被抑制或赋值为0。通道选择可以通过索引或传递列表来实现：
- en: '**Indexing**: Keep in mind that, while indexing, the value to the right of
    the colon represents the higher limit of the channel. It also counts up to *n*-1\.
    For example, `img[:,:,1:3]` will select channels up to channel 2, namely blue,
    starting from channel 1, namely green, but not channel 0, namely red. The snippet  `img[:,:,0:2]`
    will select channel 0 (red channel) and channel 1 (green) but not channel 2 (blue).'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引**：请记住，在进行索引时，冒号右边的值表示通道的上限。它还计算到 *n*-1。例如，`img[:,:,1:3]` 将选择直到通道2的通道，即蓝色通道，从通道1（绿色）开始，但不包括通道0（红色）。代码片段
    `img[:,:,0:2]` 会选择通道0（红色通道）和通道1（绿色），但不包括通道2（蓝色）。'
- en: '**List**: A list such as [0,2] would mean selecting channels 0 and 2, namely
    red and blue.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：像[0,2]这样的列表表示选择通道0和通道2，即红色和蓝色。'
- en: 'In the following example, we suppress the non-red, non-green, and non-blue
    pixels so that the resultant pixels appear red, green, and blue respectively:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们抑制非红色、非绿色和非蓝色的像素，因此结果图像中的像素分别呈现红色、绿色和蓝色：
- en: '[PRE96]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The following is the output:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '**![](img/94ffe739-2eab-45c1-b5eb-5b45fe244548.png)**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/94ffe739-2eab-45c1-b5eb-5b45fe244548.png)**'
- en: Panel showing image obtained by suppressing the two channels so that it shows
    only the third color (green and blue, red and blue, and red and green respectively
    are suppressed in the three images from left to right)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 面板显示通过抑制两个通道只显示第三种颜色的图像（从左到右，分别抑制了绿色和蓝色、红色和蓝色、红色和绿色）
- en: Audio data can also be represented as arrays of pressure readings across a horizontal
    distance. Similar array manipulation techniques can be used there.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 音频数据也可以表示为跨水平方向的压力读数数组。在这里也可以使用类似的数组操作技巧。
- en: Data structures in pandas
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pandas中的数据结构
- en: The pandas package was created by Wes McKinney in 2008 as a result of frustrations
    he encountered while working on time series data in R. It is built on top of NumPy
    and provides features not available in it. It provides fast, easy-to-understand
    data structures and helps fill the gap between Python and a language like R. NumPy
    deals with homogeneous blocks of data. Using pandas helps to deal with data in
    a tabular structure composed of different data types.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 包是由 Wes McKinney 在 2008 年创建的，起因是他在使用 R 处理时间序列数据时遇到的种种困境。它建立在 NumPy 之上，并提供了
    NumPy 中没有的功能。它提供了快速、易于理解的数据结构，并弥补了 Python 和像 R 这样的语言之间的空白。NumPy 处理的是同质的数据块，而使用
    pandas 可以帮助处理由不同数据类型组成的表格结构数据。
- en: The official documentation for pandas can be found at [http://pandas.pydata.org/pandas-docs/stable/dsintro.html](http://pandas.pydata.org/pandas-docs/stable/dsintro.html).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 的官方文档可以在 [http://pandas.pydata.org/pandas-docs/stable/dsintro.html](http://pandas.pydata.org/pandas-docs/stable/dsintro.html)
    找到。
- en: 'There are three main data structures in pandas:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 中有三种主要的数据结构：
- en: Series—1D
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列—1D
- en: DataFrame—2D
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataFrame—2D
- en: Panel—3D
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Panel—3D
- en: Series
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列
- en: A Series is really a 1D NumPy array under the hood. It consists of a NumPy array
    coupled with an array of labels. Just like a NumPy array, a series can be wholly
    composed of any data type. The labels are together called the index of the series.
    A series consists of two components—1D data and the index.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Series 本质上是一个 1D 的 NumPy 数组。它由一个 NumPy 数组和一个标签数组组成。就像一个 NumPy 数组，Series 可以完全由任何数据类型组成。标签一起被称为
    Series 的索引。Series 包含两个部分——1D 数据和索引。
- en: Series creation
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Series 创建
- en: 'The general construct for creating a series data structure is as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 创建序列数据结构的一般构造如下：
- en: '[PRE97]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Here, data can be one of the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数据可以是以下之一：
- en: An `ndarray`
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `ndarray`
- en: A Python dictionary
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Python 字典
- en: A scalar value
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标量值
- en: If an index is not specified, the following default index [0,... n-1] will be
    created, where n is the length of the data.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定索引，将创建以下默认索引 [0,... n-1]，其中 n 是数据的长度。
- en: A series can be created from a variety of sources as shown in the following
    subsections.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Series 可以从多种来源创建，以下小节将介绍这些方式。
- en: Using an ndarray
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ndarray
- en: 'In this case, the index must be the same length as the data. The following
    example creates a Series structure of seven random numbers between 0 and 1; the
    index is not specified:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，索引必须与数据的长度相同。以下示例创建了一个包含七个介于 0 和 1 之间的随机数的 Series 结构；索引没有指定：
- en: '[PRE98]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'An index can also be string objects. The following example creates a Series
    structure of the first five months of the year with a specified index of month
    names:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 索引也可以是字符串对象。以下示例创建了一个包含前五个月名称的 Series 结构，并指定了月份名称作为索引：
- en: '[PRE99]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Using a Python dictionary
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 字典
- en: 'A dictionary consists of key-value pairs. When a dictionary is used to create
    a Series, the keys form the index, and the values form the 1D data of the Series:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 字典由键值对组成。当使用字典创建 Series 时，字典的键形成索引，值则构成 Series 的 1D 数据：
- en: '[PRE100]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The index of a pandas Series structure is of type `pandas.core.index.Index`
    and can be viewed as an ordered multiset.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: pandas Series 结构的索引类型是 `pandas.core.index.Index`，可以视为一个有序的多重集合。
- en: 'If an index is also specified when creating the Series, then this specified
    index setting overrides the dictionary keys. If the specified index contains values
    that are not keys in the original dictionary, `NaN` is appended against that index
    in the Series:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建 Series 时同时指定了索引，则该指定的索引将覆盖字典中的键。如果指定的索引包含原字典中不存在的键，则会在 Series 中对应的索引位置填充
    `NaN`：
- en: '[PRE101]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Note that a Series also has a name attribute that can be set as shown in the
    preceding snippet. The name attribute is useful in tasks such as combining Series
    objects into a DataFrame structure.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Series 还有一个名称属性，可以像前面的代码片段那样设置。名称属性在将多个 Series 对象合并为 DataFrame 结构时非常有用。
- en: Using a scalar value
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标量值
- en: 'A Series can also be initialized with just a scalar value. For scalar data,
    an index must be provided. The value will be repeated for as many index values
    as possible. One possible use of this method is to provide a quick and dirty method
    of initialization, with the Series structure to be filled in later. Let''s see
    how to create a Series using scalar values:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: Series 也可以仅用标量值初始化。对于标量数据，必须提供索引。该值将为尽可能多的索引值重复。此方法的一种可能用途是提供一种快速且简便的初始化方法，之后再填充
    Series 结构。让我们看看如何使用标量值创建一个 Series：
- en: '[PRE102]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Operations on Series
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 Series 的操作
- en: The behavior of a Series is very similar to that of NumPy arrays, discussed
    previously in this chapter, with one caveat being that an operation such as slicing
    also slices the index of the series.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Series 的行为与本章前面讨论的 NumPy 数组非常相似，唯一的区别是操作（如切片）也会切片 Series 的索引。
- en: Assignment
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值
- en: 'Values can be set and accessed using the index label in a dictionary-like manner:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过类似字典的方式使用索引标签来设置和访问值：
- en: '[PRE103]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Just as in the case of `dict`, `KeyError` is raised if you try to retrieve
    a missing label:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `dict` 相同，如果你尝试检索一个缺失的标签，会引发 `KeyError`：
- en: '[PRE104]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This error can be avoided by explicitly using `get` as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 通过显式使用 `get` 来避免此错误，示例如下：
- en: '[PRE105]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In this case, the default value of `np.NaN` is specified as the value to return
    when the key does not exist in the Series structure.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当 Series 结构中不存在该键时，默认值 `np.NaN` 被指定为返回的值。
- en: Slicing
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: 'The slice operation behaves the same way as a NumPy array. Slicing can be done
    using the index numbers as shown in the following code:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 切片操作与 NumPy 数组的切片方式相同。可以使用索引数字进行切片，如以下代码所示：
- en: '[PRE106]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Other operations
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他操作
- en: 'Arithmetic and statistical operations can be applied, just like for a NumPy
    array. Such operations take place in a vectorized mode in a Series, just as in
    NumPy arrays, and do not require to be looped through:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 算术和统计操作可以像在 NumPy 数组中一样应用。这样的操作以矢量化方式在 Series 中进行，就像在 NumPy 数组中一样，不需要通过循环：
- en: '[PRE107]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Elementwise operations can also be performed on a Series:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以对 Series 执行逐元素操作：
- en: '[PRE108]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'An important feature of a Series is that data is automatically aligned based
    on the label:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Series 的一个重要特性是数据会自动根据标签对齐：
- en: '[PRE109]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Thus, we can see that for non-matching labels, NaN is inserted. The default
    behavior is that the union of the indexes is produced for unaligned Series structures.
    This is preferable as information is preserved rather than lost. We will handle
    missing values in pandas in a later chapter of the book.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到，对于不匹配的标签，会插入 NaN。默认情况下，未对齐的 Series 结构会生成索引的并集。这是首选的行为，因为信息会被保留下来而非丢失。我们将在本书后面的章节中处理
    pandas 中的缺失值。
- en: DataFrames
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DataFrame
- en: A DataFrame is a two-dimensional data structure composed of rows and columns—exactly
    like a simple spreadsheet or a SQL table. Each column of a DataFrame is a pandas
    Series. These columns should be of the same length, but they can be of different
    data types—float, int, bool, and so on. DataFrames are both value-mutable and
    size-mutable. This lets us perform operations that would alter values held within
    the DataFrame or add/delete columns to/from the DataFrame.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 是一个由行和列组成的二维数据结构——就像一个简单的电子表格或 SQL 表格。DataFrame 的每一列都是 pandas Series。这些列应具有相同的长度，但可以是不同的数据类型——如浮点型、整型、布尔型等。DataFrame
    既是值可变的，又是大小可变的。这使我们能够执行修改 DataFrame 中值的操作，或者在 DataFrame 中添加/删除列。
- en: 'Similar to a Series, which has a name and index as attributes, a DataFrame
    has column names and a row index. The row index can be made of either numerical
    values or strings such as month names. Indexes are needed for fast lookups as
    well as proper aligning and joining of data in pandas multilevel indexing is also
    possible in DataFrames. The following is a simple view of a DataFrame with five
    rows and three columns. In general, the index is not counted as a column:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于一个具有名称和索引作为属性的 Series，DataFrame 具有列名和行索引。行索引可以由数字值或字符串（如月份名称）组成。索引对于快速查找以及数据的正确对齐和连接是必需的，pandas
    中也支持多级索引。以下是一个简单的 DataFrame 视图，包含五行三列。通常情况下，索引不算作列：
- en: '| **Index** | **Event type** | **Total attendees** | **Percentage of student
    participants** |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| **索引** | **事件类型** | **总参与人数** | **学生参与比例** |'
- en: '| Monday | C | 42 | 23.56% |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| 星期一 | C | 42 | 23.56% |'
- en: '| Tuesday | B | 58 | 12.89% |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| 星期二 | B | 58 | 12.89% |'
- en: '| Wednesday | A | 27 | 45.90% |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| 星期三 | A | 27 | 45.90% |'
- en: '| Thursday | A | 78 | 47.89% |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| 星期四 | A | 78 | 47.89% |'
- en: '| Friday | B | 92 | 63.25% |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| 星期五 | B | 92 | 63.25% |'
- en: DataFrame creation
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DataFrame 创建
- en: 'A DataFrame is the most commonly used data structure in pandas. The constructor
    accepts many different types of arguments:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 是 pandas 中最常用的数据结构。构造函数接受多种不同类型的参数：
- en: Dictionary of 1D ndarrays, lists, dictionaries, or Series structures
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 1D ndarray、列表、字典或 Series 结构组成的字典
- en: 2D NumPy array
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D NumPy 数组
- en: Structured or record ndarray
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化或记录型 ndarray
- en: Series
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Series
- en: Another DataFrame
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个 DataFrame
- en: Row label indexes and column labels can be specified along with the data. If
    they're not specified, they will be generated from the input data in an intuitive
    fashion, for example, from the keys of `dict `(in the case of column labels) or
    by using `np.range(n)` in the case of row labels, where n corresponds to the number
    of rows.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 行标签索引和列标签可以与数据一起指定。如果没有指定，它们将通过直观的方式从输入数据中生成，例如，从 `dict` 的键中（对于列标签）或使用 `np.range(n)`（对于行标签），其中
    n 是行数。
- en: A DataFrame can be created from a variety of sources as discussed in the following
    subsections.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 可以从多种来源创建，以下小节将详细讨论这些方法。
- en: Using a dictionary of Series
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用包含 Series 的字典
- en: Each individual entity of a dictionary is a key-value pair. A DataFrame is,
    in essence, a dictionary of several Series put together. The name of the Series
    corresponds to the key, and the contents of the Series correspond to the value.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的每个实体都是一个键值对。DataFrame 本质上是将多个 Series 组合在一起的字典。Series 的名称对应键，而 Series 的内容对应值。
- en: 'As the first step, the dictionary with all the Series should be defined:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步，应该定义一个包含所有 Series 的字典：
- en: '[PRE110]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The preceding dictionary summarizes the performance of six different stocks
    and indicates that the DataFrame will have six columns. Observe that each series
    has a different set of indices and is of different length. The final DataFrame
    will contain a unique set of the values in each of the indices. If a certain column
    has no value at a row index, NA is appended to that cell automatically. Now, the
    following step wraps up this dictionary into a DataFrame:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 上述字典总结了六只不同股票的表现，并表示 DataFrame 将有六列。可以观察到，每个 Series 都有不同的索引集合且长度不同。最终的 DataFrame
    将包含每个索引中唯一的一组值。如果某一列在某一行索引位置没有值，系统会自动在该单元格中添加 NA。接下来的步骤将此字典转换为 DataFrame：
- en: '[PRE111]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Let''s print the DataFrame created in the preceding step:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印出前面步骤中创建的 DataFrame：
- en: '![](img/75b068ce-dd4c-4fbc-8730-dbd82b9d04ef.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75b068ce-dd4c-4fbc-8730-dbd82b9d04ef.png)'
- en: 'The DataFrame need not necessarily have all the row and column labels from
    the original dictionary. At times, only a subset of these rows and columns may
    be needed. In such cases, the row and column indices can be restricted as shown
    in the following code:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 不一定需要包含原始字典中的所有行和列标签。有时，可能只需要其中的一部分行和列。在这种情况下，可以限制行和列索引，如下所示：
- en: '[PRE112]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Here, a new column name, `SCNW`, which is not found in the original dictionary,
    has been added. This will result in a column named `SCNW` with NAs throughout.
    Similarly, manually passing an index name that is absent in the original data
    structure will result in a row with NAs throughout.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，添加了一个新的列名 `SCNW`，该列名在原始字典中不存在。这将导致生成一个名为 `SCNW` 的列，其中所有值为 NA。同样，手动传递一个在原始数据结构中不存在的索引名，将导致该行全部为
    NA。
- en: 'Let''s print the preceding DataFrame:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印出前面的 DataFrame：
- en: '![](img/be7e57c0-7726-44fc-a1f3-7bc1ada20582.png)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be7e57c0-7726-44fc-a1f3-7bc1ada20582.png)'
- en: 'The row index and column names can be accessed as attributes of the DataFrame:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 DataFrame 的属性访问行索引和列名称：
- en: '[PRE113]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Using a dictionary of ndarrays/lists
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用包含 ndarray/列表的字典
- en: In the preceding example, the dictionary consisted of Series as the values in
    the key-value pair. It is possible to construct a DataFrame with a dictionary
    of lists instead of a dictionary of Series. Unlike the previous case, the row
    index will not be defined anywhere in the dictionary. Hence, the row label indices
    are generated using `np.range(n)`. Therefore, it is crucial in this case for all
    lists or arrays in the dictionary to be of equal length. If this condition is
    not met, an error occurs.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，字典中的值是 Series，作为键值对的值。也可以通过包含列表的字典来构建 DataFrame，而不是使用包含 Series 的字典。与之前的情况不同，行索引在字典中并未定义。因此，行标签索引是通过
    `np.range(n)` 生成的。因此，在这种情况下，字典中的所有列表或数组必须具有相同的长度。如果不满足这一条件，将会发生错误。
- en: 'The dictionary of lists is defined in the following code:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的字典在以下代码中定义：
- en: '[PRE114]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Now, let''s convert this dictionary to a DataFrame and print it:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个字典转换为 DataFrame 并打印出来：
- en: '[PRE115]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Take a look at the following output:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下输出：
- en: '![](img/f67edac0-e7b9-4f08-ab12-ea05caed53c2.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f67edac0-e7b9-4f08-ab12-ea05caed53c2.png)'
- en: 'Here, the row indices are assigned continuous values from 0 to 4\. The row
    indices can also be given custom values as shown in the following code:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，行索引被分配了从 0 到 4 的连续值。也可以如下面的代码所示，为行索引指定自定义值：
- en: '[PRE116]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Take a look at the following output:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下输出：
- en: '![](img/e909303f-7d27-436b-940b-f289abe522b1.png)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e909303f-7d27-436b-940b-f289abe522b1.png)'
- en: Using a structured array
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用结构化数组
- en: 'Structured arrays are slightly different from `ndarrays`. Each field in a structured
    array can be of a different data type. For more information on structured arrays,
    refer to the following: [http://docs.scipy.org/doc/numpy/user/basics.rec.html](http://docs.scipy.org/doc/numpy/user/basics.rec.html).'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化数组与 `ndarrays` 稍有不同。结构化数组中的每个字段可以具有不同的数据类型。有关结构化数组的更多信息，请参考以下链接：[http://docs.scipy.org/doc/numpy/user/basics.rec.html](http://docs.scipy.org/doc/numpy/user/basics.rec.html)。
- en: 'The following is an example of a structured array:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个结构化数组的示例：
- en: '[PRE117]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'This structured array has three fields for which the data types have been defined
    in a list of tuples along with the field names. The same `DataFrame` function
    can be used to construct a `DataFrame` function from a structured array:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构化数组有三个字段，其数据类型已在一个包含字段名称的元组列表中定义。可以使用相同的 `DataFrame` 函数从结构化数组构建 DataFrame：
- en: '[PRE118]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Take a look at the following output:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下输出结果：
- en: '![](img/04cfbbba-25af-42b0-aa79-dd12c9cfc324.png)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04cfbbba-25af-42b0-aa79-dd12c9cfc324.png)'
- en: 'By default, continuous range of integral values have been assigned to the index.
    It is possible to replace the indices:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，连续的整数值被分配给索引。也可以替换这些索引：
- en: '[PRE119]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Take a look at the following output:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下输出结果：
- en: '![](img/62929fa6-eafd-47b1-97bb-50beb6077f22.png)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62929fa6-eafd-47b1-97bb-50beb6077f22.png)'
- en: 'The columns can be reordered through the `columns` argument of the `DataFrame`
    function:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `DataFrame` 函数的 `columns` 参数重新排序列：
- en: '[PRE120]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Take a look at the following output:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下输出结果：
- en: '![](img/897d3b35-4b88-4f87-bc43-e9017f76aa77.png)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![](img/897d3b35-4b88-4f87-bc43-e9017f76aa77.png)'
- en: Using a list of dictionaries
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字典列表
- en: When a list of dictionaries is converted to a DataFrame, each dictionary in
    the list corresponds to a row in the DataFrame and each key in each dictionary
    represents a column label.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个字典列表被转换为 DataFrame 时，列表中的每个字典对应 DataFrame 中的一行，而每个字典中的键表示列标签。
- en: 'Let''s define a list of dictionaries:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个字典列表：
- en: '[PRE121]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Now the list of dictionaries can be converted to a DataFrame as shown in the
    following code:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，字典列表可以转换为 DataFrame，如下所示：
- en: '[PRE122]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The following is the output:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/d5e285f8-1c32-4def-973e-5917bf985ade.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5e285f8-1c32-4def-973e-5917bf985ade.png)'
- en: Using a dictionary of tuples for multilevel indexing
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元组字典进行多级索引
- en: 'A dictionary of tuples can create a structured DataFrame with hierarchically
    indexed rows and columns. The following is a dictionary of tuples:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 一个元组字典可以创建一个具有分层索引行和列的结构化 DataFrame。以下是一个元组字典：
- en: '[PRE123]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Instead of a regular key-value pair, the key is a tuple with two values denoting
    two levels in the row index, and the value is a dictionary in which each key-value
    pair represents a column. Here, again, the key is a tuple and denotes two column
    indices.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规的键值对不同，键是一个包含两个值的元组，表示行索引中的两个级别，值是一个字典，其中每个键值对表示一列。在这里，键同样是一个元组，表示两个列索引。
- en: 'Now this dictionary of tuples can be converted to a DataFrame and printed:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个元组字典可以转换为 DataFrame 并打印：
- en: '[PRE124]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The following is the output:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/0fcaf4d8-6a68-4568-af64-20f6518a0490.png)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fcaf4d8-6a68-4568-af64-20f6518a0490.png)'
- en: Using a Series
  id: totrans-500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Series
- en: 'Consider the following series:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下系列：
- en: '[PRE125]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Here, the series has a defined index and name. When being converted to a DataFrame,
    this index is retained and the name of the Series gets assigned as a column name:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Series 定义了索引和名称。在转换为 DataFrame 时，保留此索引，并且 Series 的名称被分配为列名：
- en: '[PRE126]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The following is the output:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/88556948-0368-4e92-bc4c-afd428c9e8cb.png)'
  id: totrans-506
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88556948-0368-4e92-bc4c-afd428c9e8cb.png)'
- en: 'There are also alternative constructors for DataFrames; they can be summarized
    as follows:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他替代的 DataFrame 构造方法，可以总结如下：
- en: '`DataFrame.from_dict`: It takes a dictionary of dictionaries or sequences and
    returns a DataFrame. It slightly differs from the method discussed earlier due
    to an argument to specify order. While the other method always converts keys of
    dictionaries to columns, this constructor provides an option to convert the keys
    to row labels:'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataFrame.from_dict`：它接受一个字典的字典或序列，并返回一个 DataFrame。由于可以指定顺序的参数，它与前面讨论的方法略有不同。虽然另一种方法总是将字典的键转换为列，但这个构造函数提供了一个选项，将键转换为行标签：'
- en: '[PRE127]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The following is the output:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/44774fca-917d-4b5d-91cc-55dcad8f314f.png)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44774fca-917d-4b5d-91cc-55dcad8f314f.png)'
- en: 'Another method to do this is as follows:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法如下：
- en: '[PRE128]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The following is the output:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/6d87ba0c-a32e-4482-b1b1-c3c4a801b5db.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d87ba0c-a32e-4482-b1b1-c3c4a801b5db.jpg)'
- en: '`DataFrame.from_records`: It takes a list of tuples or structured `ndarray`
    to construct a DataFrame. Unlike the method mentioned earlier for structured arrays,
    this function allows you to set one of the fields of the array as an index:'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataFrame.from_records`：它接受一个元组列表或结构化 `ndarray` 来构建 DataFrame。与之前提到的结构化数组方法不同，这个函数允许你将数组的某个字段设置为索引：'
- en: '[PRE129]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The following is the output:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/862ba2b3-6ad0-40c3-9d68-64533ecc0ebf.png)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![](img/862ba2b3-6ad0-40c3-9d68-64533ecc0ebf.png)'
- en: Operations on pandas DataFrames
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 pandas DataFrame 的操作
- en: Many operations, such as column/row indexing, assignment, concatenation, deletion,
    and so on, can be performed on DataFrames. Let's have a look at them in the following
    subsections.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对 DataFrame 执行许多操作，例如列/行索引、赋值、拼接、删除等。我们将在以下小节中详细介绍这些操作。
- en: Column selection
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列选择
- en: 'A specific column can be selected out from the DataFrame, as a Series, using
    the column name:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过列名从 DataFrame 中选择出一个特定的列，作为一个 Series：
- en: '[PRE130]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Adding a new column
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新列
- en: 'A new column can be added to a DataFrame by inserting a scalar value into it.
    Inserting a scalar value into any column of a DataFrame will cause the entire
    column to be filled with that scalar value:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过插入一个标量值到 DataFrame 中来添加新列。将标量值插入到 DataFrame 的任何列中，将会使整个列填充为该标量值：
- en: '[PRE131]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The following is the output:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/a9775ac3-2544-48f0-98e4-d7459e807914.png)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9775ac3-2544-48f0-98e4-d7459e807914.png)'
- en: 'Instead of a scalar value, a list of values can also be assigned:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将一组值（而不是标量值）分配给列：
- en: '[PRE132]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The following is the output:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/0d8a27ac-4a7f-4241-ad93-4d4c3dd15f91.png)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d8a27ac-4a7f-4241-ad93-4d4c3dd15f91.png)'
- en: 'A column can also be inserted at the desired position using the `insert` method.
    This needs three arguments: the position in which the column is to be inserted,
    the new column name, and the values to be passed:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用 `insert` 方法将列插入到指定位置。此方法需要三个参数：插入位置、新列名以及传入的值：
- en: '[PRE133]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The following is the output:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/c12d5e49-5608-4fe6-abc6-a42ed2d8d50d.png)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c12d5e49-5608-4fe6-abc6-a42ed2d8d50d.png)'
- en: Deleting columns
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除列
- en: 'The `del` command can be used to delete a single column as shown in the following
    code:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`del` 命令可以用来删除单个列，如下面的代码所示：'
- en: '[PRE134]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The following is the output:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/93bc40ad-3ded-4965-aea4-b12b2a964b20.png)'
  id: totrans-542
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93bc40ad-3ded-4965-aea4-b12b2a964b20.png)'
- en: 'Instead of `del`, the `pop` method can be used, just like in dictionaries:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `del`，也可以使用 `pop` 方法，类似于字典中的操作：
- en: '[PRE135]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The following is the output:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/5764f486-de04-440e-b92a-fe73153e01cc.png)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5764f486-de04-440e-b92a-fe73153e01cc.png)'
- en: Alignment of DataFrames
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DataFrame 对齐
- en: 'The union of two DataFrames occurs based on row and column indices. Let''s
    understand this through an example. Consider two DataFrames:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 DataFrame 的联合是基于行和列的索引进行的。通过一个例子来理解这个过程。考虑以下两个 DataFrame：
- en: '[PRE136]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The `+` operator will add values in columns with the same labels in both DataFrames:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`+` 运算符会在两个 DataFrame 中相同标签的列之间进行加法：'
- en: '[PRE137]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The following is the output:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/5ed89cb6-bbf1-4131-bce3-5c0990bbc714.png)'
  id: totrans-553
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ed89cb6-bbf1-4131-bce3-5c0990bbc714.png)'
- en: The columns—copper and gold—were not found in both the DataFrames. Hence, NA
    has been appended in these columns.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个 DataFrame 中未找到列——铜和金。因此，这些列中被填充为 NA。
- en: 'If you combine a DataFrame object and a Series object, the default behavior
    is to broadcast the Series object across the rows:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 DataFrame 对象与 Series 对象结合使用，默认行为是将 Series 对象广播到所有行：
- en: '[PRE138]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The following is the output:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/9100505a-c637-416d-8434-922c244e322a.png)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9100505a-c637-416d-8434-922c244e322a.png)'
- en: Other mathematical operations
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他数学运算
- en: 'The basic mathematical operators work on DataFrames. For example, a new column
    can be obtained as a result of adding, multiplying, subtracting, or dividing two
    columns:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数学运算符适用于 DataFrame。例如，两个列相加、相乘、相减或相除可以得到一个新列：
- en: '[PRE139]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The following is the output:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/0c9b9d76-9d01-43da-92c9-f9c047be69c2.png)'
  id: totrans-563
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c9b9d76-9d01-43da-92c9-f9c047be69c2.png)'
- en: 'Logical operators such as  | (or), & (and), and ^ (not) work on DataFrames.
    Consider the following two DataFrames:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符如 |（或）、&（与）和 ^（非）适用于 DataFrame。考虑以下两个 DataFrame：
- en: '[PRE140]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Now, performing the logical or between these two columns yields the following
    result:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对这两列进行逻辑“或”运算，得到以下结果：
- en: '[PRE141]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The following is the output:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/098e3a86-cc56-41db-bb50-9e90d0da18be.png)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
  zh: '![](img/098e3a86-cc56-41db-bb50-9e90d0da18be.png)'
- en: 'Operations can also be performed on DataFrames using the NumPy functions:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用NumPy函数在DataFrame上执行操作：
- en: '[PRE142]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The following is the output:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/e57fe462-6e84-436c-8639-dc231cb61d40.png)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e57fe462-6e84-436c-8639-dc231cb61d40.png)'
- en: Panels
  id: totrans-574
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面板
- en: 'A Panel is a 3D array. It is not as widely used as Series or DataFrames. It
    is not as easily displayed on screen or visualized as the other two because of
    its 3D nature. The Panel data structure is the final piece of the data structure
    puzzle in pandas. It is less widely used. It is generally used for 3D time-series
    data. The three axis names are as follows:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 面板是一个3D数组。它不像Series或DataFrame那样广泛使用。由于其3D的特性，它不像另外两个那样容易显示在屏幕上或进行可视化。面板数据结构是pandas中数据结构的最后一块拼图。它的使用相对较少，通常用于3D时间序列数据。三个轴的名称如下：
- en: '`items`: This is axis 0\. Each item corresponds to a DataFrame structure.'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`items`：这是轴0，每个项目对应于一个DataFrame结构。'
- en: '`major_axis`: This is axis 1\. Each item corresponds to the rows of the DataFrame
    structure.'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`major_axis`：这是轴1，每个项目对应于DataFrame结构的行。'
- en: '`minor_axis`: This is axis 2\. Each item corresponds to the columns of each
    DataFrame structure.'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minor_axis`：这是轴2，每个项目对应于每个DataFrame结构的列。'
- en: Panels are deprecated and will not be available in future versions. Hence, it's
    advisable to use multi-indexing in DataFrames instead of Panels.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 面板已被弃用，并且在未来的版本中将不再提供。因此，建议在DataFrame中使用多重索引，替代面板。
- en: As with Series and DataFrames, there are different ways to create Panel objects.
    They are explained in the upcoming sections.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 与Series和DataFrame一样，有多种方法可以创建面板对象。它们将在接下来的章节中讲解。
- en: Using a 3D NumPy array with axis labels
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用带有轴标签的3D NumPy数组
- en: 'Here, we show how to construct a Panel object from a 3D NumPy array. After
    defining the 3D array, a panel could be created by defining each of the three
    axes:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了如何从3D NumPy数组构造面板对象。定义完3D数组后，可以通过定义三个轴中的每一个来创建面板：
- en: '[PRE143]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Using a Python dictionary of DataFrame objects
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python字典形式的DataFrame对象
- en: 'A panel consists of several DataFrames. To create a panel, let''s define two
    DataFrames:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 面板由多个DataFrame组成。为了创建面板，我们来定义两个DataFrame：
- en: '[PRE144]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Now, a dictionary of these DataFrames can be created:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以创建这些DataFrame的字典：
- en: '[PRE145]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Using the DataFrame.to_panel method
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DataFrame.to_panel方法
- en: 'A multi-indexed DataFrame is comparable to a Panel. Hence, a multi-indexed
    DataFrame can be directly converted to a Panel:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 一个多重索引的DataFrame与面板相似。因此，一个多重索引的DataFrame可以直接转换为面板：
- en: '[PRE146]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'The sources of the US/China economic data are the following sites:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 美国/中国经济数据的来源网站如下：
- en: '[http://www.multpl.com/us-gdp-inflation-adjusted/table](http://www.multpl.com/us-gdp-inflation-adjusted/table)'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.multpl.com/us-gdp-inflation-adjusted/table](http://www.multpl.com/us-gdp-inflation-adjusted/table)'
- en: '[http://www.multpl.com/united-states-population/table](http://www.multpl.com/united-states-population/table)'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.multpl.com/united-states-population/table](http://www.multpl.com/united-states-population/table)'
- en: '[http://en.wikipedia.org/wiki/Demographics_of_China](http://en.wikipedia.org/wiki/Demographics_of_China)'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Demographics_of_China](http://en.wikipedia.org/wiki/Demographics_of_China)'
- en: '[http://www.theguardian.com/news/datablog/2012/mar/23/china-gdp-since-1980](http://www.theguardian.com/news/datablog/2012/mar/23/china-gdp-since-1980)'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.theguardian.com/news/datablog/2012/mar/23/china-gdp-since-1980](http://www.theguardian.com/news/datablog/2012/mar/23/china-gdp-since-1980)'
- en: Other operations
  id: totrans-597
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他操作
- en: Insertion, deletion, and itemwise operations behave the same as in the case
    of DataFrames. Panel structures can be rearranged by transposing them. The feature
    set of the operations of Panels is relatively underdeveloped and not as rich as
    for Series and DataFrames.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 插入、删除和逐项操作与DataFrame的情况相同。面板结构可以通过转置进行重新排列。面板操作的功能集相对不成熟，且不如Series和DataFrame那样丰富。
- en: Summary
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter was a quick tour of the power of NumPy and showed a glimpse of
    how it makes life easier while working with pandas. Some of the highlights from
    the chapter were as follows:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了NumPy的强大功能，并展示了它如何在使用pandas时让工作变得更轻松。本章的一些亮点如下：
- en: A  NumPy array is a versatile data structure used for containing multidimensional
    homogeneous data.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy数组是一个多功能的数据结构，用于存储多维的同质数据。
- en: There are a variety of methods available for slicing/dicing, creating, and manipulating
    an array in the NumPy package.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy包中提供了多种方法用于切片、切分、创建和操作数组。
- en: NumPy arrays have practical applications such as being the building blocks of
    linear algebra operations and a tool to manipulate multidimensional array data
    such as images and audio.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 数组具有实际应用，例如作为线性代数运算的构建模块，或作为处理多维数组数据（如图像和音频）的工具。
- en: Arrays (or matrices) are the computational blocks used in advanced mathematical
    models such as neural networks.
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组（或矩阵）是用于高级数学模型（如神经网络）的计算模块。
- en: NumPy arrays are the precursors of some of the essential data structures in
    pandas, namely Series.
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 数组是 pandas 中一些基本数据结构的前身，特别是 Series。
- en: Series are very similar to arrays. Series are one-dimensional. A custom-index
    can be passed to Series. Arrays or lists can be converted to Series. An indexed
    Series can be converted to a DataFrame.
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Series 与数组非常相似。Series 是一维的，可以传递自定义索引给 Series。数组或列表可以转换为 Series，带有索引的 Series
    也可以转换为 DataFrame。
- en: Series, DataFrames, and Panels are other commonly used data structures in pandas,
    of which DataFrames are the most popular.
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Series、DataFrame 和 Panel 是 pandas 中常用的其他数据结构，其中 DataFrame 最为流行。
- en: Multi-indexed DataFrames can be created using a dictionary of tuples. Simple
    dictionaries or dictionaries of lists/arrays can also be used for creating DataFrames.
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用元组字典创建多重索引的 DataFrame。也可以使用简单的字典或包含列表/数组的字典来创建 DataFrame。
- en: In the next chapter, we will focus on a variety of data sources for I/O operations
    in pandas. pandas supports a variety of data structures and sources to be read
    from and to be written to. We will learn about all that and more in the next chapter.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将专注于 pandas 中各种数据源的 I/O 操作。pandas 支持多种数据结构和数据源，可以进行读写操作。我们将在下一章中学习所有这些内容及更多内容。
- en: References
  id: totrans-610
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[https://opencv-python-tutroals.readthedocs.io/en/latest/index.html](https://opencv-python-tutroals.readthedocs.io/en/latest/index.html)'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://opencv-python-tutroals.readthedocs.io/en/latest/index.html](https://opencv-python-tutroals.readthedocs.io/en/latest/index.html)'
- en: '[http://corochann.com/basic-image-processing-tutorial-1220.html](http://corochann.com/basic-image-processing-tutorial-1220.html)'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://corochann.com/basic-image-processing-tutorial-1220.html](http://corochann.com/basic-image-processing-tutorial-1220.html)'
