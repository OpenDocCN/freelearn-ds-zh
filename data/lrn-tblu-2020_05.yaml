- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Leveraging Level of Detail Calculations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用详细程度计算
- en: 'Having considered row-level and aggregate calculations, it''s time to turn
    our attention to the third of the four main types of calculations: **level of
    detail calculations**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了逐行计算和聚合计算后，接下来我们将关注四种主要计算类型中的第三种：**详细程度计算**。
- en: '**Level of detail calculations** (sometimes referred to as **LOD calcs** or
    **LOD expressions**) allow you to perform aggregations at a specified level of
    detail, which may be different from the level of detail that is defined in the
    view. You can leverage this capability to perform a wide variety of analyses that
    would otherwise be quite difficult.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细程度计算**（有时称为 **LOD 计算** 或 **LOD 表达式**）允许你在指定的详细程度上执行聚合，这个详细程度可能与视图中定义的不同。你可以利用这个功能进行各种分析，这些分析在其他情况下可能会非常困难。'
- en: 'In this chapter, we''ll cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Overview of level of detail
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细程度概述
- en: Level of detail calculation syntax and variations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细程度计算语法及其变体
- en: Examples of `FIXED` level of detail calculations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIXED` 详细程度计算示例'
- en: Examples of `INCLUDE` level of detail calculations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INCLUDE` 详细程度计算示例'
- en: Examples of `EXCLUDE` level of detail calculations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXCLUDE` 详细程度计算示例'
- en: Overview of level of detail
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细程度概述
- en: 'What does the term **level of detail** mean? A lot depends on the context in
    which the term is used. Within Tableau, we''ll distinguish several levels of detail,
    each of which is vitally important to understand in order to properly analyze
    data:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细程度**是什么意思？这取决于术语的使用上下文。在 Tableau 中，我们将区分几种不同的详细程度，每种程度都至关重要，必须理解它们才能正确地分析数据：'
- en: '**Data level of detail**: Sometimes referred to as the **grain** of the data,
    this is the level of detail defined by a single record of the data set. When you
    can articulate what one record of the data represents (for example, "Every record
    represents a single order" or "There is one record for every customer"), then
    you have a good understanding of the data level of detail. *Row-level calculations
    operate at this level*.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据详细程度**：有时被称为数据的 **粒度**，这是由数据集中的一条记录定义的详细程度。当你能够阐明一条记录代表什么时（例如，“每条记录代表一个订单”或“每个客户有一条记录”），那么你就对数据的详细程度有了很好的理解。*逐行计算在这一层次操作*。'
- en: '**View level of detail**: We''ve previously discussed that the combination
    of fields used as dimensions in the view defines the view level of detail. Normally
    in a view, Tableau draws a single mark for each distinct combination of values
    present in the data for all the dimensions in the view. For example, if **Customer**
    and **Year** are the two dimensions in your view, Tableau will draw a mark (such
    as a bar or circle) for each **Customer**/**Year** combination present in the
    data (that is not excluded by a filter). *Aggregate calculations operate at this
    level*.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图详细程度**：我们之前讨论过，作为视图中维度的字段组合定义了视图的详细程度。通常，在视图中，Tableau 会为视图中所有维度的每个唯一值组合绘制一个标记（例如条形图或圆形）。例如，如果视图中的两个维度是
    **客户** 和 **年份**，则 Tableau 会为数据中每个存在的 **客户**/**年份** 组合绘制一个标记（前提是没有被筛选器排除）。*聚合计算在这一层次操作*。'
- en: '**Calculated level of detail**: This is a separate level of detail defined
    by a calculation. As we''ll see, you may use any number of dimensions to define
    the level of detail. *Level of detail calculations are used to define this level*.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算的详细程度**：这是由计算定义的一个单独的详细程度。正如我们所看到的，你可以使用任意数量的维度来定义详细程度。*详细程度计算用于定义这个层次*。'
- en: 'Consider the following data set, with a **data level of detail** of one record
    per customer:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下数据集，每条记录对应一个客户，**数据详细程度**为每个客户一条记录：
- en: '| **Customer** | **State** | **Membership Date** | **Membership Level** | **Orders**
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **客户** | **州** | **会员日期** | **会员等级** | **订单数** |'
- en: '| Neil | Kansas | 2009-05-05 | Silver | 1 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Neil | Kansas | 2009-05-05 | Silver | 1 |'
- en: '| Jeane | Kansas | 2012-03-17 | Gold | 5 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Jeane | Kansas | 2012-03-17 | Gold | 5 |'
- en: '| George | Oklahoma | 2016-02-01 | Gold | 10 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| George | Oklahoma | 2016-02-01 | Gold | 10 |'
- en: '| Wilma | Texas | 2018-09-17 | Silver | 4 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Wilma | Texas | 2018-09-17 | Silver | 4 |'
- en: In this case, each record defines a single unique customer. If we were to perform
    a row-level calculation, such as `DATEDIFF('year'`, `[Membership Date]`, `TODAY())`
    to determine the number of years each customer has been a member, then the result
    would be calculated per record.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每条记录定义了一个唯一的客户。如果我们执行逐行计算，例如使用 `DATEDIFF('year'`, `[Membership Date]`,
    `TODAY())` 来确定每个客户成为会员的年数，那么结果将按记录计算。
- en: 'Now consider a view created from the data with a **view level of detail** of
    state:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个由数据创建的视图，该视图的 **视图级别详细程度** 是州：
- en: '![](img/B16021_05_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_05_01.png)'
- en: 'Figure 5.1: The view level of detail of state'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：州的视图级别详细程度
- en: As the only dimension in the view, **State** defines the view level of detail.
    There is one mark per state, and calculations and fields used as aggregates, such
    as **SUM(Orders)**, will be performed per state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为视图中唯一的维度，**State** 定义了视图的详细程度。每个州有一个标记，计算和用作聚合的字段，例如 **SUM(Orders)**，将按州执行。
- en: 'Based on that particular view, we might want to enhance our understanding by
    asking additional questions, such as the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一特定观点，我们可能希望通过提出额外的问题来增强我们的理解，例如以下问题：
- en: Which customer was the first member of each state in the view?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个客户是视图中每个州的第一个成员？
- en: How does the number of orders per state compare to the average number of orders
    for all states?
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各州的订单数量与所有州的平均订单数量相比如何？
- en: Which membership level had the highest or lowest number of orders per state?
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个会员级别在各州的订单数量最高或最低？
- en: In each case, the question involves a level of detail that is different from
    the view (the minimum membership date per state compared to each individual customer,
    the average orders overall compared to orders per state, and the minimum or maximum
    number of orders per membership level per state). In some cases, it might make
    sense to build a new view to answer these questions. But sometimes we want to
    supplement an existing view or compare different levels of detail in the same
    view. Level of detail calculations provide a solution!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，问题涉及的详细程度不同于视图（每个州的最小会员日期与每个客户的比较、所有订单的平均数与各州订单的比较，以及每个州每个会员级别的最小或最大订单数）。在某些情况下，构建一个新的视图来回答这些问题可能是有意义的。但有时我们希望补充现有视图或在同一视图中比较不同的详细程度。详细程度计算提供了解决方案！
- en: Level of detail calculations
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细程度计算
- en: Before getting into practical examples of using level of detail calculations,
    let's take a moment to understand the syntax and types of level of detail calculations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入使用详细程度计算的实际示例之前，让我们先花一点时间理解详细程度计算的语法和类型。
- en: Level of detail syntax
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细程度语法
- en: 'Level of detail calculations follow this basic pattern of syntax:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 详细程度计算遵循以下基本语法模式：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The definitions of the preceding declaration are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前面声明的定义如下：
- en: '`FIXED`, `INCLUDE`, and `EXCLUDE` are keywords that indicate the type of level
    of detail calculation. We''ll consider the differences in detail in the following
    section.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIXED`、`INCLUDE` 和 `EXCLUDE` 是指示详细程度计算类型的关键字。我们将在接下来的章节中考虑这些差异。'
- en: '`Dim 1`, `Dim 2` (and as many dimensions that are needed) is a comma-separated
    list of dimension fields that defines the level of detail at which the calculation
    will be performed.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dim 1`、`Dim 2`（以及所需的其他维度）是以逗号分隔的维度字段列表，定义了执行计算时的详细程度。'
- en: '`AGG` is the aggregate function you wish to perform (such as `SUM`, `AVG`,
    `MIN`, and `MAX`).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AGG` 是你希望执行的聚合函数（例如 `SUM`、`AVG`、`MIN` 和 `MAX`）。'
- en: '`Field` is the value that will be aggregated as specified by the aggregation
    you choose.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Field` 是将根据你选择的聚合方法进行聚合的值。'
- en: Level of detail types
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细程度类型
- en: 'Three types of level of detail calculations are used in Tableau: **FIXED**,
    **INCLUDE**, and **EXCLUDE**.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Tableau 中使用三种类型的详细程度计算：**FIXED**、**INCLUDE** 和 **EXCLUDE**。
- en: FIXED
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FIXED
- en: '**Fixed** level of detail expressions work at the level of detail that''s specified
    by the list of dimensions in the code, regardless of what dimensions are in the
    view. For example, the following code returns the average orders per state, regardless
    of what other dimensions are in the view:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fixed** 详细程度表达式在代码中指定的维度列表定义的详细程度下工作，而不考虑视图中包含的维度。例如，以下代码返回各州的平均订单数量，无论视图中包含其他哪些维度：'
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You may include as many dimensions as needed or none at all. The following
    code represents a fixed calculation of the average orders for the entire set of
    data from the data source:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要包括任意多的维度，或者完全不包括任何维度。以下代码表示对数据源中整个数据集的平均订单数进行的固定计算：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternately, you might write the calculation in the following way with identical
    results:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以用以下方式编写计算，结果相同：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A fixed level of detail expression with no dimensions specified is sometimes
    referred to as a *table-scoped fixed level of detail expression*, because the
    aggregation defined in the calculation will be for the entire table.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 没有指定维度的固定详细程度表达式有时被称为*表格范围的固定详细程度表达式*，因为在计算中定义的聚合将适用于整个表格。
- en: INCLUDE
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: INCLUDE
- en: '**Include** level of detail expressions aggregate at the level of detail that''s
    determined by the dimensions in the view, *along with* the dimensions listed in
    the code. For example, the following code calculates the average orders at the
    level of detail that''s defined by dimensions in the view, but includes the dimension
    `Membership Level`, even if `Membership Level` is not in the view:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**包含**详细程度表达式会在视图中由维度确定的详细程度层级上进行聚合，*同时*包括代码中列出的维度。例如，以下代码计算的是在视图中由维度定义的详细程度层级上的平均订单数，但即使`Membership
    Level`不在视图中，依然包括`Membership Level`这一维度：'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: EXCLUDE
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EXCLUDE
- en: '**Exclude** level of detail expressions aggregate at the level of detail determined
    by the dimensions in the view, *excluding* any listed in the code. For example,
    the following code calculates the average number of orders at the level of detail
    defined in the view, but does not include the `Customer` dimension as part of
    the level of detail, even if `Customer` is in the view:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**排除**详细程度表达式会在由视图中的维度决定的详细程度层级上进行聚合，*排除*代码中列出的任何维度。例如，以下代码计算的是在视图中定义的详细程度层级上的平均订单数，但不包括`Customer`维度，即使`Customer`在视图中存在：'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An illustration of the difference level of detail can make
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细程度差异的示意图
- en: 'As you analyze data, one thing you might often wonder is how slices of data
    relate to the overall picture. For example, you might wonder how the number of
    orders for each state in the view above relates to the overall average number
    of orders. One quick and easy option is to add an **Average Line** to the view
    from the **Analytics** tab, by dragging and dropping like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析数据时，你可能常常会想，数据片段是如何与整体情况相关联的。例如，你可能会想，视图中每个州的订单数量是如何与总体平均订单数相关的。一种快速且简单的方式是通过从**分析**标签中拖放，向视图中添加一个**平均线**，操作如下：
- en: '![](img/B16021_05_02.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_05_02.png)'
- en: 'Figure 5.2: Adding an average line to the view'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：向视图添加平均线
- en: 'You''ll end up with an average line that looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终会得到如下的平均线：
- en: '![](img/B16021_05_03.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_05_03.png)'
- en: 'Figure 5.3: The overall average is reported as 6.66667\. This is the average
    per state'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：总体平均值报告为 6.66667。这是每个州的平均值
- en: 'But is `6.66667` truly the average number of orders overall? It turns out that
    it''s not. It''s actually the average of the sum of the number of orders for each
    state: `(6 + 10 + 4) / 3`. Many times, that average line (that is, the average
    of the total number of orders per state) is exactly what we want to compare when
    using aggregate numbers.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`6.66667`真的是总体的平均订单数吗？事实证明，并不是。它实际上是每个州的订单数量之和的平均值：`(6 + 10 + 4) / 3`。很多时候，那条平均线（即每个州的订单总数的平均值）正是我们在使用聚合数据时希望对比的内容。
- en: 'But sometimes, we might want to calculate the true overall average. To get
    the average number of orders present in the entire data set, we might consider
    creating a calculation named `Overall Average Number of Orders` and using a fixed
    level of detail calculation like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有时候，我们可能希望计算真实的总体平均值。为了获得整个数据集中的平均订单数，我们可以考虑创建一个名为`Overall Average Number
    of Orders`的计算，并使用类似下面的固定详细程度计算：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Adding that calculated field to the **Detail** part of the **Marks** card and
    editing the reference line to use that field instead gives us a different result:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将该计算字段添加到**标记**卡的**详细信息**部分，并将参考线编辑为使用该字段，给我们带来了不同的结果：
- en: '![](img/B16021_05_04.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_05_04.png)'
- en: 'Figure 5.4: The true overall average number of orders per customer is 5'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：每位客户的真实总体平均订单数是 5
- en: 'You''ll recall that the original data set had four records, and a quick check
    validates the result:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你会回忆起原始数据集有四条记录，快速检查可以验证这个结果：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we have examined how level of detail calculations make a real difference;
    let's look at some practical examples.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了详细程度计算如何带来实际差异；接下来让我们看一些实际的例子。
- en: Examples of fixed level of detail calculations
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定详细程度计算的示例
- en: 'As we turn our attention to some practical examples of level of detail calculations,
    we''ll use the `Chapter 05 Loans` data set contained in the `Chapter 05` workbook.
    The true data set contains many more records, but here is an example of the kinds
    of data it contains:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将注意力转向一些关于细节级别计算的实际示例时，我们将使用`Chapter 05 Loans`数据集，该数据集包含在`Chapter 05`工作簿中。真实的数据集包含更多的记录，但这里是它所包含的某些数据示例：
- en: '| **Date** | **Portfolio** | **Loan Type** | **Balance** | **Open Date** |
    **Member Name** | **Credit Score** | **Age** | **State** |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **日期** | **投资组合** | **贷款类型** | **余额** | **开盘日期** | **成员姓名** | **信用评分** |
    **年龄** | **州** |'
- en: '| 3/1/2020 | Auto | New Auto | 15987 | 9/29/2018 | Samuel | 678 | 37 | California
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 3/1/2020 | 汽车贷款 | 新车贷款 | 15987 | 9/29/2018 | Samuel | 678 | 37 | 加利福尼亚州 |'
- en: '| 7/1/2020 | Mortgage | 1st Mortgage | 96364 | 8/7/2013 | Lloyd | 768 | 62
    | Ohio |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 7/1/2020 | 抵押贷款 | 第一抵押贷款 | 96364 | 8/7/2013 | Lloyd | 768 | 62 | 俄亥俄州 |'
- en: '| 3/1/2020 | Mortgage | HELOC | 15123 | 4/2/2013 | Inez | 751 | 66 | Illinois
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 3/1/2020 | 抵押贷款 | 房屋净值信贷（HELOC） | 15123 | 4/2/2013 | Inez | 751 | 66 | 伊利诺伊州
    |'
- en: '| 3/1/2020 | Mortgage | 1st Mortgage | 418635 | 9/30/2015 | Patrick | 766 |
    60 | Ohio |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 3/1/2020 | 抵押贷款 | 第一抵押贷款 | 418635 | 9/30/2015 | Patrick | 766 | 60 | 俄亥俄州
    |'
- en: '| 5/1/2020 | Auto | Used Auto | 1151 | 10/22/2018 | Eric | 660 | 44 | Pennsylvania
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 5/1/2020 | 汽车贷款 | 二手车贷款 | 1151 | 10/22/2018 | Eric | 660 | 44 | 宾夕法尼亚州 |'
- en: '| … | … | … | … | … | … | … | … | … |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| … | … | … | … | … | … | … | … | … |'
- en: '| … | … | … | … | … | … | … | … | … |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| … | … | … | … | … | … | … | … | … |'
- en: The data set represents historical data for loans for members at a bank, credit
    union, or similar financial institution. Each record is a monthly snapshot of
    a loan and contains the date of the snapshot along with fields that describe the
    loan (**Portfolio**, **Loan Type**, **Balance**, and **Open Date**) and fields
    for the member (**Name**, **Credit Score**, **Age**, and **State**).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集代表银行、信用合作社或类似金融机构中成员的贷款历史数据。每条记录是贷款的月度快照，包含快照日期以及描述贷款的字段（**投资组合**，**贷款类型**，**余额**，和**开盘日期**）和描述成员的字段（**姓名**，**信用评分**，**年龄**，和**州**）。
- en: As in previous chapters, the goal is to understand key concepts and some key
    patterns. The following are only a few examples of all the possibilities presented
    by level of detail calculations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，目标是理解关键概念和一些关键模式。以下仅是细节级别计算所呈现的所有可能性中的几个示例。
- en: Was a member ever at risk?
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 某个成员是否曾经处于风险中？
- en: 'Let''s say branch management has determined that any member who has ever had
    a credit score of less than 550 is considered to be at risk and eligible for special
    assistance. Consider the history for the following three individuals:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设分行管理层已确定，任何曾经有过信用评分低于550的成员都被视为处于风险中，并有资格获得特别帮助。考虑以下三位个体的历史记录：
- en: '![](img/B16021_05_05.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_05_05.png)'
- en: 'Figure 5.5: Credit scores for three individuals with scores under the 550 threshold
    indicated via arrows'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：三位信用评分低于550的个体，信用评分低于阈值的部分通过箭头标出
- en: Every month, a new snapshot of history is recorded. Loan balances often change
    along with the member's credit score. Some members have never been at risk. The
    first member, Vicki, has 699 as her lowest recorded score and has never been at
    risk. However, both Charles and Thomas had periods in the history where their
    credit scores fell below the threshold (indicated with arrows in the preceding
    screenshot).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每个月，都会记录新的历史快照。贷款余额通常会随着成员的信用评分变化。一些成员从未处于风险中。第一个成员Vicki，她的最低信用评分为699，且从未处于风险中。然而，Charles和Thomas在历史中都有信用评分低于阈值的时段（在前述截图中以箭头标出）。
- en: A simple row-level calculation, such as `[Credit Score] < 550`, could identify
    each record where the monthly snapshot of credit score indicated a risk. But members
    whose scores fluctuated *below* and *above* the threshold would have records that
    were alternately `TRUE` or `FALSE`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的行级计算，例如`[Credit Score] < 550`，可以识别每条记录，其中信用评分的月度快照显示存在风险。但那些信用评分在阈值上下波动的成员，其记录会交替为`TRUE`或`FALSE`。
- en: We want every record for a given member to be `TRUE` if *any* of the records
    for that member are below the threshold and `FALSE` if *none* of the records are
    below the threshold.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望给定成员的每一条记录如果*任何*记录低于阈值，则为`TRUE`，如果*没有*记录低于阈值，则为`FALSE`。
- en: 'One solution is to use a level of detail calculation, which we''ll name `Member
    Ever at Risk?`, with the code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是使用一个细节级别计算，我们将其命名为`Member Ever at Risk?`，其代码如下：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This calculation determines the lowest credit score for each member and compares
    it to the risk threshold of 550\. The result is the same for each record for a
    given member, as you can see here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该计算确定了每个成员的最低信用分数，并将其与550的风险阈值进行比较。对于给定成员的每一条记录，结果是相同的，如下所示：
- en: '![](img/B16021_05_06.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_05_06.png)'
- en: 'Figure 5.6: The Member Ever at Risk? field is True or False for all records
    of a given member'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：给定成员的所有记录中，Member Ever at Risk? 字段的值为 True 或 False
- en: 'Notice that every record contains the result for the relevant member. This
    illustrates one key concept for fixed level of detail calculations: *while the
    calculation is an aggregation at a defined level of detail, the results are at
    the row level.* That is, the `TRUE` or `FALSE` value is calculated at the member
    level, but the results are available as row-level values for every record for
    that member.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每条记录都包含相关成员的计算结果。这说明了固定细节层级计算的一个关键概念：*虽然计算是在定义的细节层级上进行的聚合，但结果是在行级别上的*。也就是说，`TRUE`
    或 `FALSE` 的值是在成员级别计算的，但这些结果作为行级别的值对于该成员的每条记录都是可用的。
- en: 'This enables all kinds of analysis possibilities, such as:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这为各种分析可能性提供了支持，例如：
- en: Filtering to include only at-risk members but retaining all records for their
    history. If you instead filtered based on individual credit score, you'd lose
    all records for parts of the history where the credit score was above the threshold.
    Those records might be critical for your analysis.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅过滤出处于风险中的成员，同时保留其历史的所有记录。如果你改为基于个人信用评分进行过滤，那么你将丧失那些信用评分高于阈值的历史记录。那些记录可能对你的分析至关重要。
- en: Correctly counting members as either at risk or not while avoiding counting
    them for both cases if the history fluctuated.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确统计成员是否处于风险中，并避免在历史波动的情况下将同一成员同时计入两种情况。
- en: Comparing members who were or were not at risk at other levels of detail. For
    example, this view shows the number of members who were at risk or not at risk
    by portfolio:![](img/B16021_05_07.png)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较不同细节层级下处于风险中和不处于风险中的成员。例如，这个视图展示了按投资组合分类的处于风险中和不处于风险中的成员数量：![](img/B16021_05_07.png)
- en: 'Figure 5.7: We can implement some brushing to show what proportion of members
    has ever been at risk'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.7：我们可以通过一些交互展示有多少比例的成员曾经处于风险中
- en: Fixed level of detail calculations are context sensitive. That is, they operate
    within a context, which is either 1) the entire data set, or 2) defined by **context
    filters** (filters where the drop-down **Add to Context** option has been selected).
    In this example, that means the values calculated for each member will not change
    if you don't use context filters. Consider Thomas, who will always be considered
    at risk, even if you applied a normal filter that kept only dates after March
    2020\. That is because the fixed level of detail calculation would work across
    the entire data set and find at-risk values in January and February. If you were
    to add such a filter to context, the result could change. This behavior of fixed
    level of detail calculations can be leveraged to aid your analysis but can also
    cause unexpected behavior if not understood.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 固定细节层级计算是上下文敏感的。也就是说，它们在某个上下文中进行操作，这个上下文要么是1) 整个数据集，要么是2) 由**上下文过滤器**定义的（即选择了下拉菜单中的**添加到上下文**选项的过滤器）。在这个例子中，这意味着如果不使用上下文过滤器，每个成员的计算值将不会发生变化。以Thomas为例，即使你应用了仅保留2020年3月之后的日期的普通过滤器，他仍然会被认为处于风险中。因为固定细节层级计算会跨整个数据集进行工作，并在1月和2月找到处于风险中的值。如果你将这种过滤器添加到上下文中，结果可能会发生变化。理解固定细节层级计算的这种行为有助于分析，但如果没有理解，也可能导致意外的行为。
- en: This is a single example of the kinds of analysis made simple with level of
    detail calculations. There's so much more we can do and we'll see another example
    next!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过细节层级计算简化的分析类型的一个示例。我们还能做更多的事情，接下来会看到另一个示例！
- en: Latest balance for a member
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给定成员的最新余额
- en: 'Many data sets contain a series of events or a history of transactions. You
    may find yourself asking questions such as:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据集包含一系列事件或交易历史。你可能会提出如下问题：
- en: What diagnoses are common for a patient's first visit to the hospital?
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 患者第一次去医院时常见的诊断是什么？
- en: What was the last reported status of each computer on the network?
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络中每台计算机的最后一次报告状态是什么？
- en: How much did each customer spend on their last order?
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个客户在他们的最后一笔订单上花费了多少？
- en: How much did the first trade of the week make compared to the last?
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本周的第一笔交易与最后一笔交易相比，赚了多少？
- en: None of these questions is simply asking when the earliest or latest event happened.
    A simple `MIN` or `MAX` aggregation of the date would provide that answer. But
    with these questions, there is the added complexity of asking for additional detail
    about what happened on the earliest or latest dates. For these kinds of questions,
    level of detail calculations provide a way to arrive at answers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题不仅仅是在问最早或最新的事件发生了什么。简单的`MIN`或`MAX`日期聚合就能提供答案。但这些问题的复杂性在于，除了要求最早或最新日期的详细信息外，还要求关于这些日期发生的更多内容。对于这类问题，详细级别计算提供了一种得出答案的方式。
- en: 'Consider the following three members'' data contained in the `Chapter 05 Loans`
    data set:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下三位成员的数据，这些数据包含在`Chapter 05 Loans`数据集中：
- en: '![](img/B16021_05_08.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_05_08.png)'
- en: 'Figure 5.8: The data for three selected members in the Loans data set'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：贷款数据集中三位选定成员的数据
- en: 'Each has a history of balances for each of their loans. However, the most recent
    date of history differs for each loan. Kelly''s most recent balance is given for
    July. Joseph''s latest balance is for August. Gerald has two loans: the first
    has the most recent balance for July and the second has the most recent balance
    for September.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个成员都有每个贷款的余额历史。然而，每个贷款的最新历史日期是不同的。凯利的最新余额是七月，约瑟夫的最新余额是八月。杰拉尔德有两个贷款：第一个的最新余额是七月，第二个是九月。
- en: 'What if you want to identify only the records that represent the latest known
    balance for a member? You might consider using a fixed level of detail calculation
    called `Latest Date per Member/Loan` with code such as this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想识别代表成员最新已知余额的记录怎么办？你可以考虑使用一个固定的详细级别计算，名为`Latest Date per Member/Loan`，代码如下：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This determines the maximum date per member per loan and compares the result
    to each row-level date, returning `TRUE` for matches and `FALSE` otherwise.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这决定了每个成员每个贷款的最大日期，并将结果与每行的日期进行比较，匹配时返回`TRUE`，否则返回`FALSE`。
- en: Two dimensions have been used to define the level of detail in the previous
    calculation because a single member can have more than one loan. If you had a
    truly unique identifier for each loan, you could alternatively use that as the
    single dimension defining the level of detail. You will need to have a good understanding
    of your data to accurately leverage level of detail calculations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的计算中，使用了两个维度来定义详细级别，因为一个成员可能有多个贷款。如果你为每个贷款拥有唯一标识符，你也可以使用该标识符作为定义详细级别的单一维度。为了准确利用详细级别计算，你需要对数据有充分的理解。
- en: 'You can see the results of the calculation here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看计算结果：
- en: '![](img/B16021_05_09.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_05_09.png)'
- en: 'Figure 5.9: The latest date per loan per person is indicated by a True value
    for the calculation'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：每个贷款每个人的最新日期通过计算的`True`值表示
- en: If you had wanted to determine the first record for each loan, you would have
    simply changed `MAX` to `MIN` in the code. You can use the level of detail calculation's
    row-level `TRUE` / `FALSE` result as a filter to keep only the latest records,
    or even as part of other calculations to accomplish an analysis, such as comparing,
    starting, and ending balances.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要确定每个贷款的第一条记录，你只需将代码中的`MAX`改为`MIN`。你可以将详细级别计算的行级`TRUE` / `FALSE`结果作为过滤器，只保留最新的记录，或作为其他计算的一部分来完成分析，比如比较、起始余额和结束余额。
- en: The technique demonstrated by this calculation has many applications. In cases
    where data *trickles in*, you can identify the most recent records. In cases where
    you have duplication of records, you can filter to keep only the first or last.
    You can identify a customer's first or last purchase. You can compare historic
    balances to the original balance and much, much more!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该计算展示的技术有许多应用场景。在数据*逐步传入*的情况下，你可以识别出最新的记录。在记录重复的情况下，你可以过滤掉，只保留第一条或最后一条记录。你可以识别客户的首次或最后一次购买。你还可以将历史余额与原始余额进行比较，等等！
- en: We've just seen how fixed level of detail calculations can be leveraged to answer
    some complex questions. Let's continue by examining include level of detail expressions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到如何利用固定详细级别计算来回答一些复杂的问题。接下来，我们将继续查看包含详细级别表达式。
- en: Example of include level of detail expressions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含详细级别表达式的示例
- en: Include level of detail calculations can be very useful when you need to perform
    certain calculations at levels of detail that are lower (more detailed) than the
    view level of detail. Let's take a look at an example.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 包含详细层次计算在你需要在低于（更详细的）视图层次进行某些计算时非常有用。让我们来看一个例子。
- en: Average loans per member
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个成员的平均贷款数
- en: Some members have a single loan. Some have two or three or possibly more. What
    if we wanted to see how many loans the average member has on a state by state
    basis? Let's consider how we might go about that.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有些成员只有一笔贷款，有些则有两笔、三笔，甚至可能更多。如果我们想按州查看每个成员平均有多少笔贷款，该如何进行呢？让我们考虑一下该如何操作。
- en: 'We''ll start with a sheet where the view level of detail is **State**:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个视图层次为**州**的工作表开始：
- en: '![](img/B16021_05_10.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_05_10.png)'
- en: 'Figure 5.10: The starting place for the example—a filled map by state'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：示例的起点—按州填充的地图
- en: 'It would be relatively easy to visualize the average credit score or average
    balance per state. But what if we want to visualize the average number of loans
    per member for each state? While there are several possible approaches to solving
    this kind of problem, here we''ll consider using the following level of detail
    expression named `Number of Loans per Member`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化每个州的平均信用评分或平均余额是相对简单的。但如果我们想要可视化每个州每个成员的平均贷款数量呢？虽然有多种方法可以解决这种问题，但我们将在此考虑使用以下名为`每个成员的贷款数量`的详细层次表达式：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code returns a distinct count of loan numbers at a level of detail that
    includes the member ID along with all dimensions that defined the view level of
    detail (state, in this case). When we add the calculation to the view, we''ll
    need to decide how to aggregate it. In this case, we want the average number of
    loans per member, so we''ll select **Measure** | **Average** from the dropdown
    on the field, revealing an interesting geographic pattern:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码返回了一个独特的贷款数量统计，统计的细节层次包括成员ID以及定义视图层次的所有维度（在此案例中是州）。当我们将计算添加到视图时，我们需要决定如何进行聚合。在此案例中，我们想要每个成员的平均贷款数量，因此我们将在字段的下拉菜单中选择**度量**
    | **平均值**，这将揭示一个有趣的地理模式：
- en: '![](img/Image59131.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image59131.png)'
- en: 'Figure 5.11: Using the Include level of detail calculation to create a gradient
    of color to show average loans per member'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：使用包含详细层次计算创建颜色渐变，以显示每个成员的平均贷款数
- en: 'As you think through how include level of detail calculations work, you might
    want to construct a crosstab at the level of detail:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在你思考包含详细层次计算如何工作的同时，你可能想要在此层次构建一个交叉表：
- en: '![](img/Image59141.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image59141.png)'
- en: 'Figure 5.12: A crosstab helps illustrate how the distinct count of loans can
    be used as a basis for an average'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：交叉表有助于说明如何将贷款的独特统计数用作平均值的基础
- en: '**State**, the first dimension on **Rows**, comes from the view level of detail.
    **Member ID** has been included in the crosstab to simulate the dimension included
    in the level of detail expression. `COUNTD(Loan Number)` gives the number of loans
    per member. Averaging the values for all the members in the state gives the state
    average. A quick check for **North Dakota** gives us an average of 1.2 loans per
    member, which matches the map visualization exactly.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**州**，在**行**上的第一个维度，来自视图层次。**成员ID**已被包含在交叉表中，以模拟包含在详细层次表达式中的维度。`COUNTD(Loan
    Number)`给出了每个成员的贷款数。将所有州内成员的值求平均，得到该州的平均数。快速检查**北达科他州**，我们得到每个成员平均1.2笔贷款，这与地图可视化完全一致。'
- en: In this case, the include level of detail expression gives us a useful solution.
    There are some alternative ways to solve and it is helpful to consider some of
    these as you think through how you might solve similar issues. We'll consider
    those next.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，包含详细层次表达式为我们提供了一个有用的解决方案。虽然有其他的替代方法，但在考虑如何解决类似问题时，思考这些方法是非常有帮助的。我们接下来将考虑这些方法。
- en: Alternative approaches
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代方法
- en: It's worth noting that the above dataset actually allows you to use `MAX([Loan
    Number])` instead of `COUNTD([Loan Number])` as the number simply increments for
    each member based on how many loans they have. The highest number is identical
    to the number of loans for that member. In a significantly large data set, the
    `MAX` calculation should perform better.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，上面的数据集实际上允许你使用`MAX([Loan Number])`，而不是`COUNTD([Loan Number])`，因为贷款数会根据每个成员有多少笔贷款而递增。最大值与该成员的贷款数是相同的。在一个显著大的数据集中，`MAX`计算的性能会更好。
- en: 'There are also a few other approaches to solving this problem, such as the
    calculation. For example, you could write the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题还有一些其他方法，例如计算。例如，您可以编写以下代码：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code takes the distinct count of loans and divides it by the distinct count
    of members. In order to count the distinct number of loans, the code creates a
    unique key by concatenating a string of a member ID and a loan number.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码计算贷款的唯一计数，并将其除以成员的唯一计数。为了计算贷款的唯一数量，代码通过将成员ID和贷款编号的字符串连接起来创建唯一键。
- en: The aggregate calculation alternative has the advantage of working at any level
    of detail in your view. You may find either the level of detail or aggregate calculation
    to be easier to understand, and you will need to decide which best helps you to
    maintain a flow of thought as you tackle the problem at hand.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合计算的替代方法具有在视图的任何详细级别上都能工作的优势。您可能会发现详细级别计算或聚合计算更容易理解，您需要决定哪种方法能帮助您更好地保持思维流畅，在处理当前问题时更加得心应手。
- en: 'Another approach would be to use a fixed level of detail expression, such as:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用固定的详细级别表达式，例如：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This calculation results in the same level of detail as the include expression
    and uses the same distinct count of loan number. It turns out that in this data
    set, each member belongs to only a single state, so state wouldn't necessarily
    have to be included in the fixed level of detail expression. However, if you wanted
    to change the level of detail you'd need to adjust the calculation, whereas, with
    the include expression, you'd only have to add or remove dimensions to the view.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此计算与包含表达式产生相同的详细级别，并使用相同的贷款编号的唯一计数。结果发现，在此数据集中，每个成员只属于一个州，因此州不一定需要包含在固定的详细级别表达式中。然而，如果您想改变详细级别，您需要调整计算，而使用包含表达式时，只需向视图中添加或删除维度即可。
- en: With the include example along with some alternatives in mind, let's turn our
    attention to an example of exclude level of detail calculations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了包含示例和一些替代方法后，让我们将注意力转向排除详细级别计算的示例。
- en: Example of exclude level of detail calculations
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排除详细级别计算的示例
- en: Exclude level of detail calculations are useful when you want to perform certain
    calculations at higher (less detailed) levels than the view level of detail. The
    following example will demonstrate how we can leverage this functionality.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 排除详细级别计算在您希望在比视图详细级别更高（较少详细）的级别上执行某些计算时非常有用。以下示例将演示我们如何利用此功能。
- en: Average credit score per loan type
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每种贷款类型的平均信用评分
- en: 'In this example, we''ll answer the following question: how does the average
    credit score for a given loan type compare to the overall average for the entire
    portfolio?'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将回答以下问题：给定贷款类型的平均信用评分如何与整个投资组合的总体平均信用评分进行比较？
- en: 'Take the following view, which shows the average credit score per loan type
    (where loan types are grouped into portfolios):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下视图，其中显示了每种贷款类型的平均信用评分（其中贷款类型按投资组合分组）：
- en: '![](img/B16021_05_13.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_05_13.png)'
- en: 'Figure 5.13: This crosstab shows the average credit score per loan type'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13：此交叉表显示每种贷款类型的平均信用评分
- en: 'What if we wanted to compare the average credit score of each loan type with
    the overall average credit score for the entire portfolio? We could accomplish
    this with an exclude level of detail calculation that looks like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将每种贷款类型的平均信用评分与整个投资组合的总体平均信用评分进行比较怎么办？我们可以通过如下所示的排除详细级别计算来实现这一点：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This removes **Loan Type** from the level of detail and the average is calculated
    only per portfolio. This gives us results like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将**贷款类型**从详细级别中移除，平均值仅在投资组合级别计算。这为我们提供了如下结果：
- en: '![](img/B16021_05_14.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_05_14.png)'
- en: 'Figure 5.14: The exclude level of detail expression removes Loan Type so the
    average is only at the portfolio level'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14：排除详细级别表达式删除了贷款类型，因此平均值仅在投资组合级别计算
- en: 'You''ll notice that the same value for the average excluding loan type is repeated
    for each loan type. This is expected because the overall average is at the portfolio
    level and is not affected by the loan type. As is, this is perhaps not the most
    useful view. But we can extend the calculation a bit to give us the difference
    between the overall portfolio average and the average of each loan type. The code
    would look like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，排除贷款类型的平均值会为每个贷款类型重复。这是预期中的结果，因为整体平均值是在投资组合级别，而不受贷款类型的影响。按现有方式，这也许不是最有用的视图。但我们可以稍微扩展计算，以便给出整体投资组合平均值与每个贷款类型的平均值之间的差异。代码如下所示：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This takes the average at the view level of detail (loan type and portfolio)
    and subtracts the average at the portfolio level to give us the difference between
    each loan type average and the overall portfolio average. We might rearrange the
    view to see the results visually, like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算会在视图的详细级别（贷款类型和投资组合）上取平均值，并减去投资组合级别的平均值，从而给出每个贷款类型的平均值与整个投资组合平均值之间的差异。我们可以重新排列视图，像这样直观地查看结果：
- en: '![](img/B16021_05_15.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_05_15.png)'
- en: 'Figure 5.15: The final view shows the difference between the loan type average
    credit score and the overall portfolio average'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15：最终视图显示了贷款类型平均信用评分与整体投资组合平均值之间的差异
- en: Exclude level of detail expressions give us the ability to analyze differences
    between the view level of detail and higher levels of detail.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 排除详细级别表达式使我们能够分析视图级别的详细信息与更高层次详细信息之间的差异。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Level of detail expressions greatly extend what you can accomplish with calculations.
    You now have a toolset for working with data at different levels of detail. With
    fixed level of detail calculations, you can identify the first or last event in
    a series or whether a condition is ever true across entire subsets of data. With
    include expressions, you can work at lower levels of detail and then summarize
    those results in a view. With exclude expressions, you can work at higher levels
    of detail, greatly expanding analysis possibilities.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 详细级别表达式极大扩展了你在计算中能做到的事情。你现在拥有了一个在不同详细级别处理数据的工具集。通过固定详细级别计算，你可以识别出系列中的第一个或最后一个事件，或者判断某个条件在整个数据子集中的状态。通过包含表达式，你可以在较低的详细级别进行工作，然后在视图中汇总这些结果。通过排除表达式，你可以在更高的详细级别进行工作，极大地扩展了分析的可能性。
- en: 'In the next chapter, we''ll explore the final main type of calculations: **table
    calculations**. These are some of the most powerful calculations in terms of their
    ability to solve problems, and they open up incredible possibilities for in-depth
    analysis. In practice, they range from very easy to exceptionally complex.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨最后一种主要的计算类型：**表格计算**。这些计算在解决问题的能力上是最强大的，它们为深入分析开辟了难以置信的可能性。实际上，它们从非常简单到极其复杂不等。
