- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Feature Engineering for Time Series Forecasting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列预测中的特征工程
- en: In the previous chapter, we started looking at **machine learning** (**ML**)
    as a tool to solve the problem of **time series forecasting**. We also discussed
    a few techniques, such as **time delay embedding** and **temporal embedding**,
    which cast time series forecasting problems as classical regression problems from
    the ML paradigm. In this chapter, we’ll look at those techniques in detail and
    go through them in a practical sense, using the dataset we have worked with throughout
    this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始将**机器学习**（**ML**）作为解决**时间序列预测**问题的工具进行探讨。我们还讨论了一些技术，如**时间延迟嵌入**和**时间嵌入**，它们将时间序列预测问题视为从ML范式出发的经典回归问题。在本章中，我们将详细介绍这些技术，并通过实践操作，使用我们在本书中一直使用的数据集进行讲解。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Understanding feature engineering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解特征工程
- en: Avoiding data leakage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免数据泄露
- en: Setting a forecast horizon
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置预测视野
- en: Time delay embedding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间延迟嵌入
- en: Temporal embedding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间嵌入
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to set up the **Anaconda** environment, following the instructions
    in the *Preface* of the book, to get a working environment with all the libraries
    and datasets required for the code in this book. Any additional libraries needed
    will be installed while running the notebooks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要按照书籍《前言》中的说明，设置**Anaconda**环境，以便创建一个包含所有代码所需的库和数据集的工作环境。在运行笔记本时，任何额外需要的库都会自动安装。
- en: 'You will need to run the following notebooks before using the code in this
    chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用本章的代码之前，你需要先运行以下笔记本：
- en: '`02-Preprocessing_London_Smart_Meter_Dataset.ipynb from Chapter02`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`02-Preprocessing_London_Smart_Meter_Dataset.ipynb 来自第02章`'
- en: '`01-Setting_up_Experiment_Harness.ipynb from Chapter04`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`01-Setting_up_Experiment_Harness.ipynb 来自第04章`'
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Time-Series-Forecasting-with-Python-2E/tree/main/notebooks/Chapter06](https://github.com/PacktPublishing/Modern-Time-Series-Forecasting-with-Python-2E/tree/main/notebooks/Chapter06).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Modern-Time-Series-Forecasting-with-Python-2E/tree/main/notebooks/Chapter06](https://github.com/PacktPublishing/Modern-Time-Series-Forecasting-with-Python-2E/tree/main/notebooks/Chapter06)找到。
- en: Understanding feature engineering
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解特征工程
- en: '**Feature engineering**, as the name suggests, is the process of engineering
    features from data, mostly using domain knowledge, to make the learning process
    smoother and more efficient. In a typical ML setting, engineering good features
    is essential to get good performance from any ML model. Feature engineering is
    a highly subjective part of ML, where each problem at hand has a different path
    of solution—one that is handcrafted for that problem. Suppose you have a dataset
    of house prices and you have a feature, *Year Built*, which tells you the year
    the house was built. Now, to make the information better, we can create another
    feature, *House Age*, from the *Year Built* feature. This may give the model better
    information, and this is called feature engineering.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**特征工程**顾名思义，是从数据中提取特征的过程，主要通过领域知识来使学习过程更加顺畅高效。在典型的机器学习设置中，工程化良好的特征对于获得优秀的模型性能至关重要。特征工程是机器学习中一个高度主观的部分，每个具体问题都有不同的解决路径——这一路径是为该问题量身定制的。假设你有一个房价数据集，并且有一个特征，*建造年份*，它告诉你房屋的建造年份。那么，为了优化这些信息，我们可以根据*建造年份*特征创建另一个特征，*房屋年龄*。这可能会为模型提供更好的信息，这就是特征工程的应用。'
- en: When we are casting a time series problem as a regression problem, there are
    a few standard techniques that we can apply. This is a key step in the process,
    as how well an ML model acquires an understanding of *time* is dependent on how
    well we engineer features to capture *time*. The baseline methods we covered in
    *Chapter 4*, *Setting a Strong Baseline Forecast*, are the methods that are created
    for the specific use case of time series forecasting, and because of that, the
    temporal aspect of the problem is built into those models. For instance, ARIMA
    doesn’t need any feature engineering to understand time because it is built into
    the model. However, a standard regression model has no explicit understanding
    of time, so we need to create good features to embed the temporal aspect of the
    problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将时间序列问题转化为回归问题时，有一些标准的技术可以应用。这是过程中的关键步骤，因为机器学习模型如何理解*时间*，取决于我们如何设计特征来捕捉*时间*。我们在*第4章*《设定强基准预测》中讨论的基线方法是针对时间序列预测的特定用例设计的，因此问题的时间维度已经内建于这些模型中。例如，ARIMA模型不需要任何特征工程来理解时间，因为它已经内建于模型中。然而，标准回归模型并没有明确的时间理解，因此我们需要创建良好的特征来嵌入问题的时间维度。
- en: 'In the previous chapter (*Chapter 5*, *Time Series Forecasting as Regression*),
    we talked about two main ways to encode time in the regression framework: **time
    delay embedding** and **temporal embedding**. Although we touched on these concepts
    at a high level, it is time to dig deeper and see them in action.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章（*第5章*，《将时间序列预测作为回归问题》）中，我们讨论了在回归框架中编码时间的两种主要方法：**时间延迟嵌入**和**时间嵌入**。虽然我们在高层次上触及了这些概念，但现在是时候深入探讨并看到它们的实际应用了。
- en: '**Notebook alert**:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**笔记本提醒**：'
- en: To follow along with the complete code, use the `01-Feature_Engineering.ipynb`
    notebook in the `Chapter06` folder.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随完整代码，请使用`01-Feature_Engineering.ipynb`笔记本，它位于`Chapter06`文件夹中。
- en: 'We have already split the dataset that we were working on into train, validation,
    and test datasets. However, since we are generating features that are based on
    previous observations, operationally, it is better when we have the train, validation,
    and test datasets combined. It will be clearer why shortly, but for now, let’s
    take it on faith and move ahead. Now, let’s combine the two datasets:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将正在使用的数据集拆分为训练集、验证集和测试集。然而，由于我们正在生成基于先前观察的特征，从操作角度来说，当我们将训练集、验证集和测试集结合时会更好。稍后会更清楚为什么，但现在，让我们先相信这一点，继续前进。现在，让我们将这两个数据集合并：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, we have a `full_df`, which combines the train, validation, and test datasets.
    Some of you may already have alarm bells ringing in your head at combining the
    train and test sets. What about **data leakage**? Let’s check it out.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个`full_df`，它结合了训练、验证和测试数据集。你们中的一些人可能已经在脑海中敲响了警钟，合并训练集和测试集会带来什么问题呢？那就是**数据泄露**。让我们来检查一下。
- en: Avoiding data leakage
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免数据泄露
- en: '**Data leakage** occurs when a model is trained with some information that
    would not be available at the time of prediction. Typically, this leads to high
    performance in the training set but very poor performance in unseen data. There
    are two types of data leakage:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据泄露**发生在模型训练时包含了在预测时无法获得的信息。通常，这会导致训练集中的性能很高，但在未见过的数据中表现非常差。数据泄露有两种类型：'
- en: '**Target leakage** is when the information about the target (that we are trying
    to predict) leaks into some of the features in the model, leading to an overreliance
    of the model on those features, ultimately leading to poor generalization. This
    includes features that use the target in any way.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标泄露**是指关于目标（我们试图预测的内容）的信息泄露到模型中的某些特征中，导致模型过度依赖这些特征，最终导致泛化能力差。这包括以任何方式使用目标的特征。'
- en: '**Train-test contamination** is when there is some information leakage between
    the train and test datasets. This can happen because of the careless handling
    and splitting of data. But it can also happen in more subtle ways, such as scaling
    a dataset before splitting the train and test sets.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**训练-测试污染**是指训练集和测试集之间存在一些信息泄露。这可能是由于数据处理不当或拆分数据时的疏忽造成的。但也可能以更微妙的方式发生，例如在拆分训练集和测试集之前对数据集进行缩放。'
- en: 'When we work with time series forecasting problems, the biggest and most common
    mistake that we can make is target leakage. We will have to think hard about each
    of the features to ensure that we don’t use any data that will not be available
    during prediction. The following diagram will help us remember and internalize
    this concept:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理时间序列预测问题时，最大的且最常见的错误是目标泄漏。我们必须对每个特征进行深思熟虑，确保我们不会使用那些在预测时无法获得的数据。以下的图示可以帮助我们记住并内化这个概念：
- en: '![Figure 6.1 – Usable and not-usable information to avoid data leakage ](img/B22389_06_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 可用与不可用信息，以避免数据泄漏](img/B22389_06_01.png)'
- en: 'Figure 6.1: Usable and unusable information to avoid data leakage'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：可用信息与不可用信息，以避免数据泄漏
- en: To make this concept clearer and more relevant to the time series forecasting
    context, let’s look at an example. Let’s say we are forecasting sales for shampoo,
    and we are using sales for conditioner as a feature. We developed the model, trained
    it on the training data, and tested it on the validation data. The model does
    very well. The moment we start predicting for the future, we can see a problem.
    We don’t know what the sales for conditioner are in the future either. While this
    example is pretty straightforward, there will be times when this becomes not so
    obvious. And that is why we need to exercise a fair amount of caution while creating
    features and always evaluate the features through the lens of *will this feature
    be available at the time of prediction?*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个概念在时间序列预测的背景下更加清晰和相关，我们来看一个例子。假设我们正在预测洗发水的销量，而我们使用护发素的销量作为一个特征。我们开发了模型，在训练数据上进行了训练，并在验证数据上进行了测试。模型表现得非常好。然而，当我们开始预测未来时，就会看到一个问题。我们也不知道护发素的未来销量是多少。虽然这个例子比较简单，但有时这种问题并不那么显而易见。这就是为什么我们在创建特征时需要格外小心，并且始终从*这个特征在预测时是否可用？*的角度来评估特征。
- en: '**Best practices**:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：'
- en: 'There are many ways of identifying target leakage, apart from thinking hard
    about the features:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对特征进行深思熟虑外，还有很多方法可以识别目标泄漏：
- en: If the model you’ve built is too good to be true, you most likely have a leakage
    problem
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你构建的模型好得让人难以置信，那么你很可能存在泄漏问题
- en: If any single feature has too much weightage in the feature importance of the
    model, that feature may have a problem with leakage
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何单一特征在模型的特征重要性中占比过大，那么这个特征可能存在泄漏问题
- en: Double-check the features that are highly correlated with the target
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细检查与目标高度相关的特征
- en: Although we generated forecasts earlier in this book, we never explicitly discussed
    **forecast horizons**. It is an important concept and essential for what we will
    discuss. Let’s take a bit of time to understand forecast horizons.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在本书前面已经生成了预测，但我们从未明确讨论过**预测视野**。这是一个重要的概念，对于我们接下来的讨论至关重要。让我们花点时间来理解预测视野。
- en: Setting a forecast horizon
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置预测视野
- en: A forecast horizon is the number of time steps into the future we want to forecast
    at any point in time. For instance, if we want to forecast the next 24 hours for
    the electricity consumption dataset that we have worked with, the forecast horizon
    becomes 48 (because the data is half-hourly). In *Chapter 5*, *Time Series Forecasting
    as Regression*, where we generated baselines, we just predicted the entire test
    data at once. In such cases, the forecast horizon becomes equal to the length
    of the test data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 预测视野是指我们在任何时间点希望预测的未来时间步数。例如，如果我们想要预测在过去的电力消耗数据集上接下来的24小时的情况，那么预测视野就是48（因为数据是按半小时记录的）。在*第5章*，*时间序列预测作为回归问题*中，我们生成了基准模型，我们一次性预测了所有的测试数据。在这种情况下，预测视野等于测试数据的长度。
- en: We never had to worry about this until now because, in the classical statistical
    methods of forecasting, this decision is decoupled from modeling. If we train
    a model, we can use it to predict any future point without retraining. But with
    *time series forecasting as regression*, we have a constraint on the forecast
    horizon, and it has its roots in data leakage. This might be unclear to you now,
    so we’ll revisit this point after we have learned about the feature engineering
    techniques. For now, let’s only look at single-step-ahead forecasting. In the
    context of the dataset we are working with, this means that we will be answering
    the question, *What is the energy consumption in the next half an hour?* We will
    talk about multi-step forecasting and other mechanics of forecasting in *Part
    4*, *The Mechanics of Forecasting*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前我们从未需要担心这一点，因为在经典的统计预测方法中，这个决策与建模是分开的。如果我们训练了一个模型，就可以用它来预测任何未来的点，而无需重新训练。但是在*时间序列回归预测*中，我们对预测范围有所限制，这与数据泄漏有关。现在这可能对你来说还不清楚，因此我们将在学习特征工程技术后再回顾这一点。目前，我们只关注单步预测。在我们正在使用的数据集上下文中，这意味着我们将回答的问题是：*下一小时的能耗是多少？*
    我们将在*第 4 部分*，*预测的机制* 中讨论多步预测和预测的其他机制。
- en: Now that we have set some ground rules, let’s start looking at the different
    feature engineering techniques. To follow along with the Jupyter notebook, head
    over to the `Chapter06` folder and use the `01-Feature_Engineering.ipynb` file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设定了一些基本规则，让我们开始看看不同的特征工程技术。为了跟随 Jupyter notebook 的操作，前往 `Chapter06` 文件夹并使用
    `01-Feature_Engineering.ipynb` 文件。
- en: Time delay embedding
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间延迟嵌入
- en: The basic idea behind time delay embedding is to embed time in terms of recent
    observations. In *Chapter 5*, *Time Series Forecasting as Regression*, we discussed
    including previous observations of a time series as **lags** (*Figure 5.6* under
    the subsection *Time delay embedding*).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 时间延迟嵌入的基本思想是通过最近的观察值将时间嵌入其中。在*第 5 章*，*时间序列回归预测*中，我们讨论了将时间序列的前几次观察作为**滞后项**（*第
    5.6 图*，位于*时间延迟嵌入*小节下）。
- en: However, there are a few more ways to capture recent and seasonal information
    using this concept.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这个概念还有一些其他方法可以捕捉近期和季节性的信息。
- en: Lags
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滞后项
- en: Rolling window aggregations
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动窗口聚合
- en: Seasonal rolling window aggregations
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 季节性滚动窗口聚合
- en: Exponentially weighted moving averages
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数加权移动平均
- en: Let’s take a look.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看。
- en: Lags or backshift
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滞后项或回溯
- en: 'Let’s assume we have a time series with time steps, *Y*[L]. Consider that we
    are at time *T* and that we have a time series where the length of history is
    *L*. So our time series will have *y*[T] as the latest observation in the time
    series, and then *y*[T-1], *y*[T-2], and so on as we move back in time. So lags,
    as explained in *Chapter 5*, *Time Series Forecasting as Regression*, are features
    that include the previous observations in the time series, as shown in the following
    diagram:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个时间序列，时间步为 *Y*[L]。假设当前时间为 *T*，并且我们有一个历史长度为 *L* 的时间序列。所以我们的时间序列中，*y*[T]
    是最新的观察值，接着是 *y*[T-1]、*y*[T-2] 等等，随着时间的推移向后。正如*第 5 章*，*时间序列回归预测*中所解释的，滞后项是包含时间序列中先前观察值的特征，如下图所示：
- en: '![Figure 6.2 – Lag features ](img/B22389_06_02.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 滞后特征](img/B22389_06_02.png)'
- en: 'Figure 6.2: Lag features'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：滞后特征
- en: 'We can create multiple lags by including observations that are *a* timesteps
    before (*y*[T-a]); we will call this *Lag a*. In the preceding diagram, we have
    shown *Lag 1*, *Lag 2*, and *Lag 3*. However, we can add any number of lags we
    like. Let’s learn how to do that now in code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过包括比当前时间点*早*的时间步（*y*[T-a]）来创建多个滞后项；我们将其称为*滞后 a*。在前面的图示中，我们展示了*滞后 1*、*滞后
    2* 和 *滞后 3*。然而，我们可以根据需要添加任意数量的滞后项。现在让我们来学习如何在代码中实现这一点：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember when we combined the train and test datasets and I asked you to take
    it in good faith? It’s time to repay that faith. If we consider the lag operation
    (or any autoregressive feature), it relies on a continuous representation along
    the time axis. If we consider the test dataset, for the first few rows (or earliest
    dates), the lags would be missing because they are part of the training dataset.
    So by combining the two, we create a continuous representation along the time
    axis where standard functions in pandas, such as `shift`, can be utilized to create
    these features easily and efficiently.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们合并训练集和测试集时，我让你以诚信对待吗？现在是回报这份信任的时候了。如果我们考虑滞后操作（或任何自回归特征），它依赖于时间轴上连续的表示。如果我们考虑测试数据集，对于前几行（或最早的日期），滞后值将会缺失，因为它们属于训练数据集的一部分。因此，通过合并这两个数据集，我们创建了一个沿时间轴的连续表示，其中可以利用
    pandas 中的标准函数，如 `shift`，轻松高效地创建这些特征。
- en: It is as simple as that, but we need to perform the lag operation for each `LCLid`
    separately. We have included a helpful method in `src.feature_engineering.autoregressive_features`
    called `add_lags` that adds all the lags you want for each `LCLid` quickly and
    efficiently. Let’s see how we can use that.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单，但我们需要针对每个 `LCLid` 单独执行滞后操作。我们在 `src.feature_engineering.autoregressive_features`
    中包含了一个名为 `add_lags` 的有用方法，可以快速高效地为每个 `LCLid` 添加所有需要的滞后。让我们看看如何使用它。
- en: 'We are going to import the method and use a few of its parameters to configure
    the lag operation the way we want:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入该方法，并使用其中的一些参数来配置我们希望的滞后操作：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let’s look at the parameters that we used in the previous code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下我们在前面代码片段中使用的参数：
- en: '`lags`: This parameter takes in a list of integers, denoting all the lags we
    need to create as features.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lags`：该参数接收一个整数列表，表示我们需要创建为特征的所有滞后。'
- en: '`column`: The name of the column to be lagged. In our case, this is `energy_consumption`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column`：要进行滞后操作的列名。在我们的例子中，这是 `energy_consumption`。'
- en: '`ts_id`: The name of the column that contains the unique ID of a time series.
    If `None`, it assumes that the DataFrame only contains a single time series. In
    our case, `LCLid` is the name of that column.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ts_id`：包含时间序列唯一 ID 的列名。如果为 `None`，则假定数据框仅包含单一的时间序列。在我们的例子中，`LCLid` 就是该列的名称。'
- en: '`use_32_bit`: This parameter doesn’t do anything functionally but makes the
    DataFrames much smaller in memory, sacrificing the precision of the floating-point
    numbers.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_32_bit`：该参数在功能上没有任何作用，但通过牺牲浮动点数的精度，使得数据框在内存中的大小变得更小。'
- en: This method returns the DataFrame with the lags added, as well as a list with
    the column names of the newly added features.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回添加滞后后的数据框（DataFrame），以及包含新添加特征的列名的列表。
- en: Rolling window aggregations
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动窗口聚合
- en: 'With lags, we connect the present points to single points in the past, but
    with rolling window features, we connect the present with an aggregate statistic
    of a window from the past. Instead of looking at the observation from previous
    time steps, we would look at an average of the observations from the last three
    timesteps. Take a look at the following diagram to understand this better:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用滞后时，我们将当前点与过去的单个点连接，而使用滚动窗口特征时，我们将当前点与过去窗口的汇总统计量连接。我们不是查看前几个时间步的观察值，而是查看过去三个时间步的观察值的平均值。请查看下面的图表，以更好地理解这一点：
- en: '![Figure 6.3 – Rolling window aggregation features ](img/B22389_06_03.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 滚动窗口聚合特征](img/B22389_06_03.png)'
- en: 'Figure 6.3: Rolling window aggregation features'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：滚动窗口聚合特征
- en: We can calculate rolling statistics with different windows, and each of them
    will capture slightly different aspects of the history. In the preceding diagram,
    we can see an example of a window of three and a window of four. When we are at
    timestep *T*, a rolling window of three would have *y*[T] [– 3], *y*[T] [– 2],
    *y*[T] [– 1] as the vector of past observations. Once we have these, we can apply
    any aggregation functions, such as the mean, standard deviation, min, max, and
    so on. Once we have a scalar value after the aggregation function, we can include
    that as a feature for timestep *t*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的窗口来计算滚动统计量，每个窗口将捕捉历史的略有不同的方面。在前面的图表中，我们可以看到一个窗口为三和一个窗口为四的示例。当我们处于时间步*
    T *时，窗口大小为三的滚动窗口将具有 *y*[T] [– 3]，*y*[T] [– 2]，*y*[T] [– 1] 作为过去观察值的向量。一旦我们拥有这些数据，就可以应用任何聚合函数，如均值、标准差、最小值、最大值等。通过聚合函数得到标量值后，我们可以将其作为时间步
    *t* 的特征。
- en: We do *not include* *y*[T] in the vector of past observations because that leads
    to data leakage.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们*不包括* *y*[T]在过去观测值的向量中，因为那会导致数据泄漏。
- en: 'Let’s see how we can do this with pandas:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过pandas来实现这一操作：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Similar to the lags, we need to do this operation for each `LCLid` column separately.
    We have included a helpful method in `src.feature_engineering.autoregressive_features`
    called `add_rolling_features` that adds all the rolling features you want for
    each `LCLid` quickly and efficiently. Let’s see how we can use that.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与滞后类似，我们需要为每个`LCLid`列分别执行此操作。我们在`src.feature_engineering.autoregressive_features`中提供了一个有用的方法`add_rolling_features`，它可以快速有效地为每个`LCLid`添加所需的所有滚动特征。让我们看看如何使用它。
- en: 'We are going to import this method and use a few of its parameters to configure
    the rolling operation the way we want:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入这个方法，并使用它的一些参数来按照我们希望的方式配置滚动操作：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let’s look at the parameters that we used in the previous code snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下在前面代码片段中使用的参数：
- en: '`rolls`: This parameter takes in a list of integers denoting all the windows
    over which we need to calculate the aggregate statistics.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rolls`: 该参数接受一个整数列表，表示我们需要计算聚合统计量的所有窗口。'
- en: '`column`: The name of the column to be lagged. In our case, this is `energy_consumption`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column`: 要进行滞后操作的列名。在我们的案例中，这列是`energy_consumption`。'
- en: '`agg_funcs`: This is a list of aggregations that we want to do for each window
    we declared in `rolls`. Allowable aggregation functions include `{mean, std, max,
    min}`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`agg_funcs`: 这是一个聚合函数列表，用于对`rolls`中声明的每个窗口进行处理。允许的聚合函数包括`{mean, std, max, min}`。'
- en: '`n_shift`: This is the number of timesteps we need to shift before doing the
    rolling operation. This parameter avoids data leakage. Although we are shifting
    by one here, there are cases where we need to shift by more than one as well.
    This is typically used in multi-step forecasting, which we will cover in *Part
    4*, *The Mechanics of Forecasting*.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n_shift`: 这是在进行滚动操作之前需要移动的时间步数。此参数可以避免数据泄漏。虽然我们在这里移动了一个时间步，但也有需要移动多个时间步的情况。通常这用于多步预测，我们将在*第4部分*，*预测的机制*中讨论。'
- en: '`ts_id`: The name of the column name that contains the unique ID of a time
    series. If `None`, it assumes that the DataFrame only has a single time series.
    In our case, `LCLid` is the name of that column.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ts_id`: 包含时间序列唯一ID的列名。如果为`None`，则假定数据框架只有一个时间序列。在我们的案例中，`LCLid`就是该列的名称。'
- en: '`use_32_bit`: This parameter doesn’t do anything functionally but makes the
    DataFrames much smaller in memory, sacrificing the precision of the floating-point
    numbers.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_32_bit`: 该参数在功能上没有任何作用，但能使数据框架在内存中占用更小的空间，牺牲浮动点数的精度。'
- en: This method returns the DataFrame with the rolling features added, as well as
    a list with the column names of the newly added features.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回添加了滚动特征的数据框架，并且返回一个包含新添加特征列名的列表。
- en: Seasonal rolling window aggregations
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 季节性滚动窗口聚合
- en: 'Seasonal rolling window aggregations are very similar to rolling window aggregations,
    but instead of taking past *n* consecutive observations in the window, they take
    a seasonal window, skipping a constant number of timesteps between each item in
    a window. The following diagram will make this clearer:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 季节性滚动窗口聚合与滚动窗口聚合非常相似，但它们不同的是，季节性窗口不会采用过去的*n*个连续观测值，而是采用一个季节性窗口，在窗口中的每个项之间跳过一个恒定数量的时间步。下面的图表将使这一点更加清晰：
- en: '![Figure 6.4 – Seasonal rolling window aggregations ](img/B22389_06_04.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 季节性滚动窗口聚合](img/B22389_06_04.png)'
- en: 'Figure 6.4: Seasonal rolling window aggregations'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：季节性滚动窗口聚合
- en: The key parameter here is the seasonality period, which is commonly referred
    to as *M*. This is the number of timesteps after which we expect the seasonality
    pattern to repeat. When we are at timestep *T*, a rolling window of three would
    have *y*[T] [– 3], *y*[T] [– 2], *y*[T] [– 1], as the vector of past observations.
    But the seasonal rolling window would skip *m* timesteps between each item in
    the window. This means that the observations that are there in the seasonal rolling
    window would be *y*[T] [–] [M], *y*[T] [– 2][M], *y*[T] [– 3][M]. Also, as usual,
    once we have the window vector, we just need to apply the aggregation function
    to get a scalar value and include that as a feature.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键参数是季节性周期，通常称为 *M*。这是我们预计季节性模式会重复的时间步数。在时间步 *T* 时，大小为三的滚动窗口将包含 *y*[T] [–
    3]、*y*[T] [– 2]、*y*[T] [– 1]，作为过去观察值的向量。但是，季节性滚动窗口将在窗口中的每个元素之间跳过 *m* 个时间步数。这意味着季节性滚动窗口中的观察值将是
    *y*[T] [–] [M]、*y*[T] [– 2][M]、*y*[T] [– 3][M]。此外，像往常一样，一旦我们获得窗口向量，我们只需应用聚合函数以获得标量值，并将其作为特征包含在内。
- en: We do *not include* *y*[T] as an element in the seasonal rolling window vector
    to avoid data leakage.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 *不包括* *y*[T] 作为季节性滚动窗口向量中的一个元素，以避免数据泄漏。
- en: This is not an operation that you can do easily and efficiently with pandas.
    Some fancy NumPy indexing and Python loops should do the trick. We will use an
    implementation from `github.com/jmoralez/window_ops/` that uses NumPy and Numba
    to make the operation fast and efficient.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你不能使用 pandas 轻松高效完成的操作。需要一些高级的 NumPy 索引和 Python 循环来实现这个功能。我们将使用来自 `github.com/jmoralez/window_ops/`
    的实现，它利用 NumPy 和 Numba 来使操作更快速高效。
- en: Just like the features we saw earlier, we need to do this operation for each
    `LCLid` separately. We have included a helpful method in `src.feature_engineering.autoregressive_features`
    called `add_seasonal_rolling_features` that adds all the seasonal rolling features
    you want for each `LCLid` quickly and efficiently. Let’s see how we can use that.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前看到的特征一样，我们需要为每个 `LCLid` 单独执行此操作。我们在 `src.feature_engineering.autoregressive_features`
    中提供了一个有用的方法 `add_seasonal_rolling_features`，它可以快速有效地为每个 `LCLid` 添加你需要的所有季节性滚动特征。让我们看看如何使用它。
- en: 'We are going to import the method and use a few parameters of the method to
    configure the seasonal rolling operation the way we want:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入该方法并使用该方法的几个参数来配置我们想要的季节性滚动操作：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let’s look at the parameters that we used in the previous code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在之前的代码片段中使用的参数：
- en: '`seasonal_periods`: This is a list of seasonal periods that should be used
    in the seasonal rolling windows. In the case of multiple seasonalities, we can
    include the seasonal rolling features of all the seasonalities.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seasonal_periods`：这是一个季节性周期的列表，应在季节性滚动窗口中使用。在多季节性的情况下，我们可以包含所有季节性滚动特征。'
- en: '`rolls`: This parameter takes in a list of integers denoting all the windows
    over which we need to calculate aggregate statistics.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rolls`：该参数接受一个整数列表，表示我们需要计算聚合统计量的所有窗口。'
- en: '`column`: The name of the column to be lagged. In our case, this is `energy_consumption`.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column`：要滞后的列名。在我们的例子中，这是 `energy_consumption`。'
- en: '`agg_funcs`: This is a list of aggregations that we want to do for each window
    we declared in `rolls`. The allowable aggregation functions are `{mean, std, max,
    min}`.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`agg_funcs`：这是我们希望对在 `rolls` 中声明的每个窗口进行的聚合操作的列表。允许的聚合函数为 `{mean, std, max,
    min}`。'
- en: '`n_shift`: This is the number of seasonal timesteps we need to shift before
    doing the rolling operation. This parameter prevents data leakage.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n_shift`：这是在进行滚动操作之前需要移动的季节性时间步数。该参数可以防止数据泄漏。'
- en: '`ts_id`: The name of the column name that contains the unique ID of a time
    series. If `None`, it assumes that the DataFrame only contains a single time series.
    In our case, `LCLid` is the name of that column.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ts_id`：包含时间序列唯一 ID 的列名。如果为 `None`，则假设 DataFrame 仅包含单个时间序列。在我们的例子中，`LCLid`
    就是该列名。'
- en: '`Use_32_bit`: This parameter doesn’t do anything functionally but makes the
    DataFrames much smaller in memory, sacrificing the precision of the floating-point
    numbers.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Use_32_bit`：该参数在功能上没有任何作用，但通过牺牲浮动点数的精度，使 DataFrame 在内存中变得更小。'
- en: As always, the method returns the DataFrame with seasonal rolling features and
    a list containing the column names of the newly added features.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，该方法返回包含季节性滚动特征的 DataFrame 以及一个包含新添加特征列名的列表。
- en: Exponentially weighted moving average (EWMA)
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指数加权移动平均（EWMA）
- en: 'With the rolling window mean operation, we calculated the average of the window,
    and it works synonymously with the **moving average**. EWMA is the slightly smarter
    cousin of the moving average. While the moving average considers a rolling window
    and considers each item in the window equally on the computed average, EWMA tries
    to do a weighted average on the window, and the weights decay at an exponential
    rate. There is a parameter, ![](img/B22389_04_009.png), that determines how fast
    the weights decay. Because of this, we can consider all the history available
    as a window and let the ![](img/B22389_04_009.png) parameter decide how much recency
    is included in EWMA. This can be written simply and recursively, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在滚动窗口均值操作中，我们计算了窗口的平均值，这与**移动平均**是同义的。EWMA是移动平均的稍微聪明一些的“亲戚”。移动平均考虑了一个滚动窗口，并且对窗口中的每个项在计算的平均值中赋予相同的权重，而EWMA则尝试对窗口进行加权平均，并且权重按指数速率衰减。有一个参数，![](img/B22389_04_009.png)，决定了权重衰减的速度。因为这个原因，我们可以将所有可用的历史数据视为一个窗口，让![](img/B22389_04_009.png)参数决定EWMA中包括多少近期的数据。这个过程可以简单地递归表示如下：
- en: '![](img/B22389_06_003.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22389_06_003.png)'
- en: 'Here, we can see that the larger the value of ![](img/B22389_04_009.png), the
    more the average is skewed toward recent values (see *Figure 6.6* to get a visual
    impression of how the weights would be). If we expand the recursion, the weights
    of each term work out to be:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，![](img/B22389_04_009.png)的值越大，平均值越偏向于最近的值（查看*图 6.6*以获得关于权重如何分布的直观印象）。如果我们展开递归，每一项的权重将会是：
- en: '![](img/B22389_06_005.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22389_06_005.png)'
- en: 'where *k* is the number of timesteps behind *T*. If we plot the weights, we
    can see them in an exponential decay; ![](img/B22389_04_009.png) determines how
    fast the decay happens. Another way to think about ![](img/B22389_04_009.png)
    is in terms of **span**. Span is the number of periods at which the decayed weights
    approach zero (not in a strictly mathematical way but intuitively). ![](img/B22389_04_009.png)
    and span are related through this equation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*k*是相对于*T*的时间步长。如果我们绘制权重，就能看到它们呈指数衰减；![](img/B22389_04_009.png)决定了衰减的速度。另一种理解![](img/B22389_04_009.png)的方式是从**跨度**的角度来看。跨度是指衰减后的权重接近零的周期数（这不是严格的数学意义，而是直观的理解）。![](img/B22389_04_009.png)和跨度通过以下方程相关：
- en: '![](img/B22389_06_009.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22389_06_009.png)'
- en: 'This will become clearer in the following diagram, where we have plotted how
    the weights decay for different values of ![](img/B22389_04_009.png):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点将在下图中更清晰地展示，我们绘制了不同值下权重衰减的情况 ![](img/B22389_04_009.png)：
- en: '![Figure 6.5 – Exponential weight decay for different values of  ](img/B22389_06_05.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 不同值下的指数权重衰减](img/B22389_06_05.png)'
- en: 'Figure 6.5: Exponential weight decay for different values of ![](img/B22389_04_009.png)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：不同值下的指数权重衰减 ![](img/B22389_04_009.png)
- en: Here, we can see that the weight becomes small by the time we reach the span.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，当我们达到跨度时，权重变得很小。
- en: Intuitively, we can think of EWMA as an average of the entire history of the
    time series, but with parameters such as ![](img/B22389_04_009.png) and **span**,
    we can make different periods of history more representative of the average. If
    we define a 60-period span, we can think that the last 60 time periods are what
    majorly drive the average. So making EWMAs with different spans or ![](img/B22389_04_009.png)
    s gives us representative features that capture different periods of history.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地，我们可以将EWMA视为整个时间序列历史的平均值，但通过![](img/B22389_04_009.png)和**跨度**等参数，我们可以使不同时期的历史对平均值的影响更加显著。如果我们定义了一个60期的跨度，我们可以认为最后的60个时间期主要驱动了平均值。因此，通过使用不同跨度或![](img/B22389_04_009.png)值的EWMA，我们可以得到具有代表性的特征，捕捉不同历史时期的特征。
- en: 'The overall process is depicted in the following diagram:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程在下图中进行了展示：
- en: '![Figure 6.6 – EWMA features ](img/B22389_06_06.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – EWMA特征](img/B22389_06_06.png)'
- en: 'Figure 6.6: EWMA features'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：EWMA特征
- en: 'Now, let’s see how we can do this in pandas:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在pandas中实现这一点：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Like the other features we discussed earlier, EWMA also needs to be done for
    each `LCLid` separately. We have included a helpful method in `src.feature_engineering.autoregressive_features`
    called `add_ewma` that adds all the EWMA features you want for each `LCLid` quickly
    and efficiently. Let’s see how we can use that.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 和我们之前讨论的其他特性一样，EWMA也需要对每个`LCLid`单独进行处理。我们在`src.feature_engineering.autoregressive_features`中包含了一个有用的方法，叫做`add_ewma`，它可以快速高效地为每个`LCLid`添加你所需要的所有EWMA特征。让我们看看如何使用它。
- en: 'We are going to import the method and use a few parameters of the method to
    configure EWMA the way we want to:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入这个方法，并使用该方法的几个参数来配置我们想要的EWMA：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let’s look at the parameters that we used in the previous code snippet:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下在前面的代码片段中使用的参数：
- en: '`alphas`: This is a list of all ![](img/B22389_04_009.png)s we need to calculate
    the EWMA features for.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alphas`：这是我们需要计算EWMA特征的所有![](img/B22389_04_009.png)的列表。'
- en: '`spans`: Alternatively, we can use this to list all the spans we need to calculate
    the EWMA features for. If you use this feature, `alphas` will be ignored.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spans`：作为替代，我们可以用它列出我们需要计算EWMA特征的所有跨度。如果使用此特性，`alphas`将被忽略。'
- en: '`column`: The name of the column to be lagged. In our case, this is `energy_consumption`.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column`：需要进行滞后处理的列名。在我们的案例中，这一列是`energy_consumption`。'
- en: '`n_shift`: This is the number of seasonal timesteps we need to shift before
    doing the rolling operation. This parameter avoids data leakage.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n_shift`：这是我们在进行滚动操作之前需要移动的季节性时间步数。这个参数可以避免数据泄漏。'
- en: '`ts_id`: The name of the column name that has a unique ID for a time series.
    If `None`, it assumes the DataFrame only contains a single time series. In our
    case, `LCLid` is the name of that column.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ts_id`：包含时间序列唯一ID的列名。如果为`None`，则假设数据框仅包含单一时间序列。在我们的案例中，`LCLid`是该列的名称。'
- en: '`use_32_bit`: This parameter doesn’t do anything functionally but makes the
    DataFrames much smaller in memory, sacrificing the precision of the floating-point
    numbers.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_32_bit`：这个参数在功能上没有任何作用，但可以使数据框在内存中占用更少的空间，代价是牺牲浮点数的精度。'
- en: As always, the method returns the DataFrame containing the EWMA features, as
    well as a list with the column names of the newly added features.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，该方法返回包含EWMA特征的数据框，并返回一个包含新添加特征列名的列表。
- en: These are a few standard ways of including time delay embedding in your ML model,
    but you are not restricted to just these. As always, feature engineering is a
    space that is not bound by rules, and we can get as creative as we want and inject
    domain knowledge into the model. Apart from the features we have seen, we can
    include the difference in lag as custom lags that inject domain knowledge, and
    so on. In most practical cases, we end up using more than one way of time delay
    embedding into our models. The lag feature is the most basic and essential in
    most cases, but we do end up encoding more information with seasonal lags, rolling
    features, and so on. As with everything in ML, there is no silver bullet. Each
    dataset has its own intricacies, which makes feature engineering very important
    and different for each case.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是将时间延迟嵌入到机器学习模型中的几种标准方式，但你并不局限于这些。像往常一样，特征工程是一个没有固定规则的领域，我们可以尽情发挥创意，并将领域知识注入到模型中。除了我们已经看到的特征，我们还可以包括滞后差异作为自定义滞后特征来注入领域知识，等等。在大多数实际情况下，我们最终会使用不止一种方式将时间延迟嵌入到模型中。滞后特征在大多数情况下是最基本和最重要的，但我们确实会通过季节性滞后、滚动特征等编码更多信息。和机器学习中的一切一样，没有万能的解决方案。每个数据集都有其独特性，这使得特征工程对于每种情况都非常重要且不同。
- en: Now, let’s look at the other class of features we can add via **temporal embedding**.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下我们可以通过**时间嵌入**添加的另一类特征。
- en: Temporal embedding
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间嵌入
- en: In *Chapter 5*, *Time Series Forecasting as Regression*, we briefly discussed
    temporal embedding as a process where we try to embed *time* into features that
    an ML model can leverage. If we think about *time* for a second, we can see that
    two aspects of time are important to us in the context of time series forecasting—the
    *passage of time* and the *periodicity of time*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第五章*，*时间序列预测作为回归问题*中，我们简要讨论了时间嵌入的过程，即我们尝试将*时间*嵌入到机器学习模型可以利用的特征中。如果我们稍微思考一下*时间*，我们会发现，在时间序列预测的背景下，时间有两个方面对我们来说至关重要——*时间的流逝*和*时间的周期性*。
- en: 'There are a few features that we can add to help us capture these aspects in
    an ML model:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特征可以帮助我们在机器学习模型中捕捉这些方面：
- en: Calendar features
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日历特征
- en: Time elapsed
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间流逝
- en: Fourier terms
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 傅里叶项
- en: Let’s look at each of them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一看一下它们。
- en: Calendar features
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日历特征
- en: The first set of features that we can extract are features based on calendars.
    Although the strict definition of time series is a set of observations taken sequentially
    in time, more often than not, we will have the timestamps of these collected observations
    alongside the time series. We can utilize these timestamps and extract calendar
    features, such as the month, quarter, day of the year, hour, minutes, and so on.
    These features capture the periodicity of time and help an ML model capture seasonality
    well. Only the calendar features that are temporally higher than the frequency
    of the time series make sense. For instance, an hour feature in a time series
    with a weekly frequency doesn’t make sense, but a month feature and week feature
    make sense. We can utilize in-built datetime functionalities in pandas to create
    these features and treat them as categorical features in the model.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提取的第一类特征是基于日历的特征。尽管时间序列的严格定义是按时间顺序获取的一组观测值，但我们通常会在这些观测值的时间戳旁边收集时间序列。我们可以利用这些时间戳并提取日历特征，例如月份、季度、年中的第几天、小时、分钟等。这些特征捕捉了时间的周期性，帮助机器学习模型有效地捕捉季节性。只有比时间序列频率更高的日历特征才有意义。例如，在一个每周频率的时间序列中，小时特征是没有意义的，但月份和周数特征则有意义。我们可以利用
    pandas 中的内置日期时间功能来创建这些特征，并在模型中将它们视为分类特征。
- en: Time elapsed
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间流逝
- en: 'This is another feature that captures the passage of time in an ML model. This
    feature increases monotonically as time increases, giving the ML model a sense
    of the passage of time. There are many ways to create this feature, but one of
    the easiest and most efficient ways is to use the integer representation of dates
    in NumPy:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个在机器学习模型中捕捉时间流逝的特征。随着时间的推移，该特征单调增加，给机器学习模型提供时间流逝的感知。创建这个特征有很多方法，但最简单且高效的方法之一是使用
    NumPy 中日期的整数表示：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have included a helpful method in `src.feature_engineering.temporal_features`
    called `add_temporal_features` that adds all relevant temporal features automatically.
    Let’s see how we can use it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `src.feature_engineering.temporal_features` 中包含了一个有用的方法 `add_temporal_features`，该方法会自动添加所有相关的时间特征。让我们看看如何使用它。
- en: 'We are going to import the method and use a few parameters of this method to
    configure and create the temporal features:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入该方法，并使用该方法的一些参数来配置和创建时间特征：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let’s look at the parameters that we used in the previous code snippet:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在前面的代码片段中使用的参数：
- en: '`field_name`: This is the column name that contains the datetime that should
    be used to create features.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`field_name`：这是包含应当用于创建特征的日期时间的列名。'
- en: '`frequency`: We should provide the frequency of the time series as input so
    that the method automatically extracts the relevant features. These are standard
    pandas frequency strings.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frequency`：我们应当提供时间序列的频率作为输入，以便方法自动提取相关特征。这些是标准的 pandas 频率字符串。'
- en: '`add_elapsed`: This flag turns the creation of the time elapsed feature on
    or off.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_elapsed`：此标志用于开启或关闭时间流逝特征的创建。'
- en: '`use_32_bit`: This parameter doesn’t do anything functionally but makes the
    DataFrames much smaller in memory, sacrificing the precision of the floating-point
    numbers.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_32_bit`：该参数在功能上没有任何作用，但使得 DataFrame 在内存中占用更小的空间，牺牲了浮点数的精度。'
- en: Just like the previous methods we discussed, this also returns the new DataFrame
    with the temporal features added and a list containing the column names of the
    newly added features.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们讨论的前几种方法一样，这个方法也会返回一个新的 DataFrame，添加了时间特征，并返回一个包含新增特征列名的列表。
- en: Fourier terms
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 傅里叶项
- en: 'Previously, we extracted a few calendar features such as the month, year, and
    so on, and we discussed using them as categorical variables in the ML model. Another
    way we can represent the same information, but on a continuous scale, is by using
    **Fourier terms**. We discussed the Fourier series in *Chapter 3*, *Analyzing
    and Visualizing Time Series Data*. Just to reiterate, the sine-cosine form of
    the Fourier series is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提取了一些日历特征，如月份、年份等，并讨论了将它们作为分类变量用于机器学习模型。另一种表示相同信息的方式，是使用 **傅里叶项**，并以连续尺度表示。我们在*第3章*《分析与可视化时间序列数据》中讨论了傅里叶级数。为了重申，傅里叶级数的正弦-余弦形式如下：
- en: '![](img/B22389_06_015.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22389_06_015.png)'
- en: Here, *S*[N] is the *N*-term approximation of the signal, *S*. Theoretically,
    when *N* is infinite, the resulting approximation is equal to the original signal.
    *P* is the maximum length of the cycle, *a*[n] and *b*[n] are the coefficients
    of the cosine and sine term, respectively, of the *n*^(th) term in the expansion,
    and *a*[0] is the intercept.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*S*[N]是信号*S*的*N*项近似。理论上，当*N*为无限时，得到的近似值等于原始信号。*P*是周期的最大长度，*a*[n]和*b*[n]分别是余弦项和正弦项的系数，*a*[0]是截距。
- en: We can create these cosine and sine functions as features to represent the seasonal
    cycle. If we encode the month, we know that it goes from 1 to 12 and then repeats
    itself. So *P*, in this case, will be 12, and *x* will be 1, 2, …12\. Therefore,
    for each *x*, we can calculate the cosine and sine terms and add them as features
    to the ML model. Intuitively, we can think that the model will infer the coefficients
    based on the data and, thus, help the model predict the time series easier.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些余弦和正弦函数作为特征来表示季节性循环。如果我们对月份进行编码，我们知道它的范围从1到12，然后会重复。因此，在这种情况下，*P*将是12，*x*将是1,
    2, …12。因此，对于每个*x*，我们可以计算出余弦和正弦项，并将它们作为特征添加到机器学习模型中。从直观上看，我们可以认为模型会根据数据推断出系数，从而帮助模型更容易地预测时间序列。
- en: 'The following diagram shows the difference in representations between the month
    on an ordinal scale and as a Fourier series:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了按序数尺度表示的月份与作为傅里叶级数表示之间的差异：
- en: '![Figure 6.7 – Month as an ordinal step function (top) versus Fourier terms
    (bottom) ](img/B22389_06_07.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 作为序数步进函数的月份（上图）与傅里叶项（下图）](img/B22389_06_07.png)'
- en: 'Figure 6.7: Month as an ordinal step function (top) versus Fourier terms (bottom)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：作为序数步进函数的月份（上图）与傅里叶项（下图）
- en: The preceding diagram shows just a single Fourier term; we can add multiple
    Fourier terms to help capture complex seasonality.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示了单一傅里叶项；我们可以添加多个傅里叶项来帮助捕捉复杂的季节性。
- en: We cannot say that continuous representation of seasonality is better than categorical
    because it depends on the type of model you use and the dataset. This is something
    we will have to find out empirically.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地说季节性的连续表示优于类别表示，因为这取决于你使用的模型类型和数据集。这是我们需要通过经验来发现的。
- en: To make the process of adding Fourier features easy, we have made some easy-to-use
    methods available in `src.feature_engineering.temporal_features`, in a file called
    `bulk_add_fourier_features` that adds Fourier features for all the calendar features
    we want automatically. Let’s see how we can use that.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化添加傅里叶特征的过程，我们提供了一些易于使用的方法，这些方法位于`src.feature_engineering.temporal_features`中，文件名为`bulk_add_fourier_features`，它会自动为我们需要的所有日历特征添加傅里叶特征。让我们来看看如何使用它。
- en: 'We are going to import the method and use a few of its parameters to configure
    and create the Fourier series-based features:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入该方法，并使用其中的一些参数来配置和创建基于傅里叶级数的特征：
- en: '[PRE10]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let’s look at the parameters that we used in the previous code snippet:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下我们在前面的代码片段中使用的参数：
- en: '`columns_to_encode`: This is the list of calendar features we need to encode
    using Fourier terms.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`columns_to_encode`：这是我们需要使用傅里叶项进行编码的日历特征列表。'
- en: '`max_values`: This is a list of max values for the seasonal cycle for the calendar
    features, in the same order as they are given in `columns_to_encode`. For instance,
    for `month` to encode as a column, we give `12` as the corresponding `max_value`.
    If not given, `max_value` will be inferred. This is only recommended if the data
    you have contains at least a single complete seasonal cycle.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_values`：这是一个季节性循环的最大值列表，对于日历特征，按`columns_to_encode`中给出的顺序排列。例如，对于`month`要作为列进行编码时，我们给出`12`作为对应的`max_value`。如果没有给出，`max_value`将会被推断。只有在你的数据至少包含一个完整的季节性循环时，才建议使用此方法。'
- en: '`n_fourier_terms`: This is the number of Fourier terms to be added. This is
    synonymous with *n* in the equation for the Fourier series mentioned previously.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n_fourier_terms`：这是要添加的傅里叶项数量。这与前面提到的傅里叶级数公式中的*n*是同义词。'
- en: '`use_32_bit`: This parameter doesn’t do anything functionally but makes the
    DataFrames much smaller in memory, sacrificing the precision of the floating-point
    numbers.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_32_bit`：这个参数在功能上没有任何作用，但它会使DataFrame在内存中变得更小，从而牺牲浮点数的精度。'
- en: Just like the previous methods we’ve discussed, this also returns a new DataFrame
    with the Fourier features added, as well as a list with column names of the newly
    added features.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前讨论过的方法一样，它也会返回一个新的DataFrame，添加了傅里叶特征，同时返回一个包含新增特征列名的列表。
- en: 'After executing the `01-Feature_Engineering.ipynb` notebook in `Chapter06`,
    we will have the following feature-engineered files written to disk:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`Chapter06`中的`01-Feature_Engineering.ipynb`笔记本后，我们将生成以下特征工程文件并保存到磁盘：
- en: '`selected_blocks_train_missing_imputed_feature_engg.parquet`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selected_blocks_train_missing_imputed_feature_engg.parquet`'
- en: '`selected_blocks_val_missing_imputed_feature_engg.parquet`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selected_blocks_val_missing_imputed_feature_engg.parquet`'
- en: '`selected_blocks_test_missing_imputed_feature_engg.parquet`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selected_blocks_test_missing_imputed_feature_engg.parquet`'
- en: In this section, we looked at a few popular and effective ways to generate features
    for time series. But there are many more, and depending on your problem and the
    domain, many of them will be relevant.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了一些流行且有效的时间序列特征生成方法。但实际上还有很多其他方法，具体选择哪些方法取决于你的问题和领域，很多方法都将适用。
- en: '**Additional information**:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加信息**：'
- en: The world of feature engineering is vast, and there are a few open-source libraries
    that make exploring that space easier. A few of them are [https://github.com/Nixtla/tsfeatures](https://github.com/Nixtla/tsfeatures),
    [https://tsfresh.readthedocs.io/en/latest/](https://tsfresh.readthedocs.io/en/latest/),
    and [https://github.com/DynamicsAndNeuralSystems/catch22](https://github.com/DynamicsAndNeuralSystems/catch22).
    A preprint by Ben D. Fulcher titled *Feature-based time-series analysis* at [https://arxiv.org/abs/1709.08055](https://arxiv.org/abs/1709.08055)
    also gives a nice summary of the space.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 特征工程的领域非常广泛，已有一些开源库使得探索这一领域变得更加容易。其中一些库包括[https://github.com/Nixtla/tsfeatures](https://github.com/Nixtla/tsfeatures)、[https://tsfresh.readthedocs.io/en/latest/](https://tsfresh.readthedocs.io/en/latest/)以及[https://github.com/DynamicsAndNeuralSystems/catch22](https://github.com/DynamicsAndNeuralSystems/catch22)。Ben
    D. Fulcher撰写的预印本论文《基于特征的时间序列分析》([https://arxiv.org/abs/1709.08055](https://arxiv.org/abs/1709.08055))也提供了对这一领域的良好总结。
- en: A newer library called functime ([https://github.com/functime-org/functime](https://github.com/functime-org/functime))
    also provides fast feature engineering routines, written in Polars, and is worth
    checking out. A lot of the feature engineering discussed in the book can be made
    even faster using functime and Polars.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为functime的新库（[https://github.com/functime-org/functime](https://github.com/functime-org/functime)）也提供了快速的特征工程例程，它是用Polars编写的，值得一试。书中讨论的许多特征工程方法，通过使用functime和Polars可以使处理速度更快。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After a brief overview of the ML for time series forecasting paradigm in the
    previous chapter, in this chapter, we looked at this practically and saw how we
    can prepare the dataset with the required features to start using these models.
    We reviewed a few time series-specific feature engineering techniques, such as
    lags, rolling, and seasonal features. All the techniques we learned in this chapter
    are tools with which we can quickly iterate through experiments to find out what
    works for our dataset. However, we only talked about feature engineering, which
    affects one side of the standard regression equation (*y* = *mX* + *c*). The other
    side, which is the target (*y*) we predict, is also equally important. In the
    next chapter, we’ll look at a few concepts such as stationarity and some transformations
    that affect the target.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章简要概述了时间序列预测的机器学习范式后，本章我们从实践角度深入探讨，了解如何准备带有所需特征的数据集，以开始使用这些模型。我们回顾了几种时间序列特定的特征工程技术，如滞后、滚动窗口和季节性特征。本章中学习的所有技术都是我们可以快速迭代实验的工具，帮助我们找到最适合我们数据集的方案。然而，我们仅讨论了特征工程，它只影响标准回归方程的一部分（*y*
    = *mX* + *c*）。另一个部分，即我们预测的目标（*y*），同样重要。下一章我们将探讨一些概念，比如平稳性以及一些影响目标的转换。
- en: Join our community on Discord
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们在Discord上的社区
- en: 'Join our community’s Discord space for discussions with authors and other readers:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/mts](https://packt.link/mts)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/mts](https://packt.link/mts)'
- en: '![](img/QR_Code15080603222089750.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code15080603222089750.png)'
