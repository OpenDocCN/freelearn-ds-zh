- en: Error and Exception Handling
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 错误和异常处理
- en: In this chapter, we will cover errors and exceptions and how to find and fix
    them. Handling exceptions is an important part of writing reliable and usable
    code. We will introduce basic built-in exceptions and show how to use and treat
    exceptions. We'll introduce debugging and show you how to use the built-in Python
    debugger.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将讨论错误和异常，以及如何查找和修复它们。处理异常是编写可靠且易用代码的重要部分。我们将介绍基本的内置异常，并展示如何使用和处理异常。我们还将介绍调试，并展示如何使用内置的
    Python 调试器。
- en: 'In this chapter, we cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: What are exceptions?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是异常？
- en: 'Finding errors: debugging'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找错误：调试
- en: 12.1 What are exceptions?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.1 什么是异常？
- en: The first error that programmers (even experienced ones) are confronted with
    is when the code has incorrect syntax, meaning that the code instructions are
    not correctly formatted.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员（即使是有经验的程序员）最先遇到的错误是代码语法不正确，即代码指令格式不正确。
- en: 'Consider this example of a syntax error:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个语法错误的示例：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The error occurs because of a missing colon at the end of the `for` declaration.
    This is an example of an exception being raised. In the case of `SyntaxError`,
    it tells the programmer that the code has incorrect syntax and also prints the
    line where the error occurred, with an arrow pointing to where in that line the
    problem is.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为 `for` 声明末尾缺少冒号。这是引发异常的一个示例。在 `SyntaxError` 的情况下，它告诉程序员代码语法错误，并且还会打印出发生错误的行，箭头指向该行中问题所在的位置。
- en: Exceptions in Python are derived (inherited) from a base class called `Exception`. Python
    comes with a number of built-in exceptions. Some common exception types are listed
    in *Table 12.1*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的异常是从一个基类 `Exception` 派生（继承）而来的。Python 提供了许多内置异常。一些常见的异常类型列在 *表 12.1*
    中。
- en: 'Here are two common examples of exceptions. As you might expect, `ZeroDivisionError` is
    raised when you try to divide by zero:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个常见的异常示例。如你所料，`ZeroDivisionError` 是在尝试除以零时引发的：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '| **Exception** | **Description** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **异常** | **描述** |'
- en: '| `IndexError` | Index is out of bounds, for example, `v[10]` when `v` only
    has five elements. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `IndexError` | 索引超出范围，例如，当 `v` 只有五个元素时，尝试访问 `v[10]`。 |'
- en: '| `KeyError` | A reference to an undefined dictionary key. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `KeyError` | 引用未定义的字典键。 |'
- en: '| `NameError` | A name not found, for example, an undefined variable. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `NameError` | 未找到名称，例如，未定义的变量。 |'
- en: '| `LinAlgError` | Errors in the `linalg` module, for example, when solving a
    system with a singular matrix. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `LinAlgError` | `linalg` 模块中的错误，例如，在求解含有奇异矩阵的系统时。 |'
- en: '| `ValueError` | Incompatible data value, for example, when using `dot` with
    incompatible arrays. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `ValueError` | 不兼容的数据值，例如，使用不兼容的数组进行 `dot` 运算。 |'
- en: '| `IOError` | I/O operation fails, for example, `file not found`. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `IOError` | I/O 操作失败，例如，`文件未找到`。 |'
- en: '| `ImportError` | A module or name is not found on import. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `ImportError` | 模块或名称在导入时未找到。 |'
- en: 'Table 12.1: Some frequently used built-in exceptions and their meaning'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.1：一些常用的内置异常及其含义
- en: A division by zero raises `ZeroDivisionError` and prints out the file name,
    the line, and the function name where the error occurred.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除以零时会引发 `ZeroDivisionError` 并打印出文件名、行号和发生错误的函数名。
- en: 'As we have seen before, arrays can only contain elements of the same datatype.
    If you try to assign a value of an incompatible type, `ValueError` is raised.
    An example of a value error is:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，数组只能包含相同数据类型的元素。如果你尝试赋值为不兼容的类型，将引发 `ValueError`。一个值错误的示例是：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `ValueError` is raised because the array contains floats and an element
    cannot be assigned a string value.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`ValueError` 被引发，因为数组包含浮点数，而元素不能赋值为字符串。
- en: 12.1.1 Basic principles
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1.1 基本原则
- en: Let's look at the basic principles on how to use exceptions by raising them
    with `raise` and catching them with `try` statements.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过使用 `raise` 引发异常并通过 `try` 语句捕获异常的基本原则。
- en: Raising exceptions
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引发异常
- en: 'Creating an error is referred to as raising an exception. You saw some examples
    of exceptions in the previous section. You can also define your own exceptions
    of a predefined type or use an exception of an unspecified type. Raising an exception
    is done with a command like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 创建错误称为引发异常。你在前一部分中看到了异常的一些示例。你也可以定义自己的异常，使用预定义类型的异常或使用未指定类型的异常。引发异常的命令如下：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here an exception of an unspecified type was raised.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里引发了一个未指定类型的异常。
- en: 'It might be tempting to print out error messages when something goes wrong,
    for example, like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当某些事情出错时，可能会诱使你打印出错误信息，例如，像这样：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is not recommended for a number of reasons. Firstly, printouts are easy
    to miss, especially if the message is buried in many other messages being printed
    to your console. Secondly, and more importantly, it renders your code unusable
    by other code. The calling code will not *read* what you printed and will not
    have a way of knowing that an error occurred and therefore has no way of taking
    care of it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这不推荐使用，原因有多个。首先，打印输出很容易被忽视，特别是当信息被埋在控制台打印的其他许多消息中时。其次，更重要的是，这会让你的代码无法被其他代码使用。调用代码不会*读取*你打印的内容，并且无法知道发生了错误，因此也无法处理它。
- en: 'For these reasons, it is always better to raise an exception instead. Exceptions
    should always contain a descriptive message, for example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，最好改为引发异常。异常应该总是包含描述性消息，例如：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This message will stand out clearly to the user. It also gives the opportunity
    for the calling code to know that an error occurred, and to possibly find a remedy.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息会清晰地显示给用户。它还为调用代码提供了一个机会，使其知道发生了错误，并可能找到解决方法。
- en: 'Here is a typical example of checking the input inside a function to make sure
    it is usable before continuing. A simple check for negative values and the correct
    datatype ensures the intended input of a function to compute factorials:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个典型的示例，用于在函数内检查输入，确保它在继续之前是可用的。简单地检查负值和正确的数据类型，确保函数的输入符合计算阶乘的预期：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The user of the function will immediately know what the error is, if an incorrect
    input is given, and it is the user's responsibility to handle the exception. Note
    the use of the exception name when raising a predefined exception type, in this
    case, `ValueError` followed by the message. By specifying the type of the exception,
    the calling code can decide to handle errors differently depending on what type
    of error is raised.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定了不正确的输入，函数的用户会立即知道是什么错误，而用户有责任处理该异常。请注意，在抛出预定义异常类型时，使用异常名称，在这个例子中是`ValueError`，后面跟着消息。通过指定异常类型，调用代码可以根据引发的错误类型决定如何不同地处理错误。
- en: Summing up, it is always better to raise exceptions than to print error messages.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，抛出异常总比打印错误信息更好。
- en: Catching exceptions
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获异常
- en: Dealing with an exception is referred to as *catching an exception*. Checking
    for exceptions is done with the commands `try` and `except`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常被称为*捕获异常*。检查异常是通过`try`和`except`命令来完成的。
- en: An exception stops the program execution flow and looks for the closest `try` enclosing
    block. If the exception is not caught, the program unit is left and it continues
    searching for the next enclosing `try` block in a program unit higher up in the
    calling stack. If no block is found and the exception is not handled, execution
    stops entirely and the standard traceback information is displayed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 异常会停止程序的执行流程，并查找最近的`try`封闭块。如果异常没有被捕获，程序单元会被跳出，并继续向调用栈中更高层的程序单元查找下一个封闭的`try`块。如果没有找到任何块并且异常没有被处理，程序执行会完全停止，并显示标准的回溯信息。
- en: 'Let''s look at the factorial example from previously and use it with the `try` statement:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看之前的阶乘示例，并用`try`语句来使用它：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, if the code inside the `try` block raises an error of type `ValueError`,
    the exception will be caught and the action in the `except` block is taken. If
    no exception occurs inside the `try` block, the `except` block is skipped entirely
    and execution continues.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果`try`块中的代码引发了`ValueError`类型的错误，异常将会被捕获，并且执行`except`块中的操作。如果`try`块中没有发生异常，`except`块会完全跳过，程序继续执行。
- en: 'The `except` statement can catch multiple exceptions. This is done by simply
    grouping them in a tuple, like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`except`语句可以捕获多个异常。这是通过将它们简单地组合成一个元组来完成的，例如：'
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `try` block can also have multiple `except` statements. This makes it possible
    to handle exceptions differently depending on the type. Let''s see another example
    of multiple exception types:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`块也可以有多个`except`语句。这使得可以根据异常类型不同来分别处理异常。让我们看一下另一个多个异常类型的示例：'
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, `FileNotFoundError` will be caught if, for example, the file does not
    exist; and `ValueError` will be caught if, for example, the data in the first
    line of the file is not compatible with the float data type.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果文件不存在，`FileNotFoundError`会被捕获；如果文件的第一行数据与浮动数据类型不兼容，`ValueError`会被捕获。
- en: 'In this example, we assigned `FileNotFoundError` to a variable `FnF` by the
    keyword `as`. This allows access to more details when handling this exception.
    Here we printed the error string `FnF.strerror` and the name of the related file
    `FnF.filename`. Each error type can have its own set of attributes depending on
    the type. If the file with the name `data.txt` does not exist, in the preceding
    example, the message is:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们通过关键字`as`将`FileNotFoundError`赋值给变量`FnF`。这允许在处理此异常时访问更多的详细信息。在这里，我们打印了错误字符串`FnF.strerror`和相关文件的名称`FnF.filename`。每种错误类型可以根据类型有自己的属性集。如果名为`data.txt`的文件不存在，在上面的示例中，消息将是：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a useful way to format the output when catching exceptions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在捕获异常时格式化输出的一个有用方法。
- en: The `try`-`except` combination can be extended with optional `else` and `finally` blocks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`-`except`组合可以通过可选的`else`和`finally`块进行扩展。'
- en: 'An example of using `else` can be seen in [Section 15.2.1](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml):
    *Testing the bisection algorithm*. Combining `try` with `finally` gives a useful
    construction when cleanup work needs to happen at the end. This is illustrated
    by an example for making sure a file is closed properly is:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`else`的一个示例可以在[第15.2.1节](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml)中看到：*测试二分法算法*。将`try`与`finally`结合使用，在需要在结束时进行清理工作的情况下，提供了一个有用的结构。通过一个确保文件正确关闭的示例来说明：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will make sure that the file is closed at the end no matter what exceptions are
    thrown while processing the file data. Exceptions that are not handled inside
    the `try` statement are saved and raised after the `finally` block. This combination
    is used in the `with` statement; see Section 12.1.3: *Context managers – the with
    statement*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保无论在处理文件数据时抛出什么异常，文件都会在结束时关闭。`try`语句内部未处理的异常会在`finally`块之后保存并抛出。这个组合在`with`语句中使用；参见第12.1.3节：*上下文管理器——`with`语句*。
- en: 12.1.2 User-defined exceptions
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1.2 用户定义异常
- en: Besides the built-in Python exceptions, it is also possible to define your own
    exceptions. Such user-defined exceptions should inherit from the base class `Exception`.
    This can be useful when you define your own classes such as the polynomial class in
    [Section 19.1](2bd9f874-5cdc-4298-873f-12572838a10c.xhtml).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的Python异常外，还可以定义自己的异常。这样的用户定义异常应继承自基类`Exception`。当你定义自己的类时，这会非常有用，例如在[第19.1节](2bd9f874-5cdc-4298-873f-12572838a10c.xhtml)中定义的多项式类。
- en: 'Take a look at this small example of a simple user-defined exception:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个简单的用户定义异常的小示例：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A random number is generated. If the number is below `0.5`, an exception is
    thrown and a message that the value is too small is printed. If no exception is
    raised, the number is printed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个随机数。如果该数字小于`0.5`，则会抛出一个异常，并打印一个值太小的消息。如果没有抛出异常，则打印该数字。
- en: In this example, you also saw a case of using `else` in a `try` statement. The
    block under `else` will be executed if no exception occurs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你还看到了在`try`语句中使用`else`的一个例子。如果没有发生异常，`else`下的代码块将会被执行。
- en: It is recommended that you define your exceptions with names that end in `Error`,
    like the naming of the standard built-in exceptions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你为你的异常定义以`Error`结尾的名称，就像标准内置异常的命名一样。
- en: 12.1.3 Context managers – the with statement
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1.3 上下文管理器——`with`语句
- en: 'There is a very useful construction in Python for simplifying exception handling
    when working with contexts such as files or databases. The statement encapsulates
    the structure `try ... finally` in one simple command. Here is an example of using `with` to
    read a file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有一个非常有用的结构，在处理文件或数据库等上下文时简化异常处理。该语句将`try ... finally`结构封装为一个简单的命令。以下是使用`with`读取文件的示例：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will try to open the file, run the specified operations on the file (for
    example, reading), and close the file. If anything goes wrong during the execution
    of `process_file_data`, the file is closed properly and then the exception is
    raised. This is equivalent to:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将尝试打开文件，在文件上运行指定的操作（例如，读取），然后关闭文件。如果在执行`process_file_data`期间出现任何问题，文件将被正确关闭，然后抛出异常。这等同于：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will use this option in [Section 14.1](f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml):
    *File handling*, when reading and writing files.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第14.1节](f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml)中使用此选项：*文件处理*，在读取和写入文件时使用。
- en: The preceding file-reading example is an example of using context managers.
    Context managers are Python objects with two special methods, `__enter__` and `__exit__`.
    Any object of a class that implements these two methods can be used as a context
    manager. In this example, the file object `f` is a context manager as there are
    the methods `f.__enter__` and `f.__exit__`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件读取示例是使用上下文管理器的一个例子。上下文管理器是具有两个特殊方法`__enter__`和`__exit__`的 Python 对象。任何实现了这两个方法的类的对象都可以用作上下文管理器。在此示例中，文件对象`f`是一个上下文管理器，因为它具有方法`f.__enter__`和`f.__exit__`。
- en: The method `__enter__` should implement the initialization instructions, for
    example, opening a file or a database connection. If this method has a return
    statement, the returned object is accessed using the construct `as`. Otherwise,
    the keyword `as` is omitted. The method `__exit__` contains the cleanup instructions,
    for example, closing a file or committing transactions and closing a database
    connection. For more explanations and an example of a self-written context manager, see [Section 15.3.3](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml): *Timing
    with a context manager*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`__enter__`应该实现初始化指令，例如打开文件或数据库连接。如果此方法包含返回语句，则通过构造`as`来访问返回的对象。否则，省略关键字`as`。方法`__exit__`包含清理指令，例如关闭文件或提交事务并关闭数据库连接。有关更多解释和自定义上下文管理器的示例，请参见[第15.3.3节](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml)：*使用上下文管理器进行计时*。
- en: There are NumPy functions that can be used as context managers. For example,
    the function `load` supports the context manager for some file formats. NumPy's
    function `errstate` can be used as a context manager to specify floating-point
    error handling behavior within a block of code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些 NumPy 函数可以用作上下文管理器。例如，函数`load`支持某些文件格式的上下文管理器。NumPy 的函数`errstate`可以作为上下文管理器，用于在代码块中指定浮点错误处理行为。
- en: 'Here is an example of working with `errstate` and a context manager:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`errstate`和上下文管理器的示例：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'See [Section 2.2.2](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml): *Floating-point
    numbers* for more details on this example and [Section 15.3.3](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml):
    *Timing wit**h a context manager* for another example.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[第2.2.2节](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml)：*浮动点数*，了解更多此示例的详细信息，并查看[第15.3.3节](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml)：*使用上下文管理器进行计时*以获得另一个示例。
- en: '12.2 Finding errors: debugging'
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.2 查找错误：调试
- en: Errors in software code are sometimes referred to as bugs. Debugging is the
    process of finding and fixing bugs in code. This process can be performed at varying
    degrees of sophistication. The most efficient way is to use a tool called a debugger.
    Having unit tests in place is a good way to identify errors early; see [Section
    15.2.2](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml): *Using the unittest package*.
    When it is not obvious where or what the problem is, a debugger is very useful.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 软件代码中的错误有时被称为bug。调试是找到并修复代码中的bug的过程。这个过程可以在不同的复杂度下进行。最有效的方式是使用名为调试器的工具。提前编写单元测试是识别错误的好方法；请参见[第15.2.2节](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml)：*使用unittest包*。当问题所在和问题是什么不明显时，调试器非常有用。
- en: 12.2.1 Bugs
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2.1 Bugs
- en: 'There are typically two kinds of bugs:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有两种类型的 bug：
- en: An exception is raised and not caught.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常被引发，但未被捕获。
- en: The code does not function properly.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码无法正常运行。
- en: The first case is usually easier to fix. The second can be more difficult as
    the problem can be a faulty idea or solution, a faulty implementation, or a combination
    of the two.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个情况通常比较容易修复。第二种情况可能更难，因为问题可能是一个错误的想法或解决方案、错误的实现，或两者的结合。
- en: We are only concerned with the first case in what follows, but the same tools
    can be used to help find why the code does not do what it is supposed to.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们只关注第一个情况，但同样的工具也可以帮助找出为什么代码没有按预期执行。
- en: 12.2.2 The stack
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2.2 栈
- en: When an exception is raised, you see the call stack. The call stack contains
    the trace of all the functions that called the code where the exception was raised.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当异常被引发时，你会看到调用栈。调用栈包含所有调用异常发生代码的函数的追踪信息。
- en: 'A simple stack example is:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的栈示例是：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The stack, in this case, is `f`, `g`, and `h`. The output generated by running
    this piece of code looks like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，栈是`f`，`g`和`h`。运行这段代码生成的输出如下所示：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The error is printed. The sequence of functions leading up to the error is shown.
    The function `f` on `line 11` was called, which in turn called `g` and then `h`.
    This caused `ZeroDivisionError`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 错误已打印。导致错误的函数序列已显示。`line 11`上的函数`f`被调用，接着调用了`g`，然后是`h`。这导致了`ZeroDivisionError`。
- en: A stack trace reports on the active stack at a certain point in the execution
    of a program. A stack trace lets you track the sequence of functions called up
    to a given point. Often this is after an uncaught exception has been raised. This
    is sometimes called post-mortem analysis, and the stack tracepoint is then the
    place where the exception occurred. Another option is to invoke a stack trace
    manually to analyze a piece of code where you suspect there is an error, perhaps
    before the exception occurs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪报告程序执行某一时刻的活动堆栈。堆栈跟踪可以让你追踪到某一时刻调用的函数序列。通常这是在抛出未捕获的异常之后。这有时被称为事后分析，堆栈跟踪点就是异常发生的位置。另一种选择是手动调用堆栈跟踪来分析你怀疑有错误的代码片段，可能是在异常发生之前。
- en: 'In the following example, an exception is raised to provoke the generation
    of a stack trace:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，引发异常以引发堆栈跟踪的生成：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This returns the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 12.2.3 The Python debugger
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2.3 Python 调试器
- en: Python comes with its own built-in debugger called `pdb`. Some development environments
    come with the debugger integrated. The following process still holds in most of
    these cases.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python 自带有一个内置调试器，叫做`pdb`。一些开发环境中集成了调试器。即使在这些情况下，以下过程依然适用。
- en: 'The easiest way to use the debugger is to enable stack tracing at the point
    in your code that you want to investigate. Here is a simple example of triggering
    the debugger based on the example mentioned in [Section 7.3](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Return
    values*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器的最简单方法是在代码中你想调查的地方启用堆栈跟踪。这里是一个基于[第7.3节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)中的示例触发调试器的简单示例：*返回值*：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The command `pdb.set_trace()` starts the debugger and enables the tracing of
    subsequent commands. The preceding code will show this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`pdb.set_trace()`启动调试器并启用后续命令的跟踪。前面的代码将显示如下：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The debugger prompt is indicated with `(Pdb)`. The debugger stops the program
    execution and gives you a prompt that lets you inspect variables, modify variables,
    step through commands, and so on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器提示符由`(Pdb)`表示。调试器暂停程序执行，并提供一个提示符，允许你检查变量、修改变量、逐步执行命令等。
- en: 'The current line is printed at each step, so you can follow where you are and
    what will happen next. Stepping through commands is done with the command `n` (next),
    like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步都会打印当前行，因此你可以跟踪当前所在的位置以及接下来会发生什么。逐步执行命令可以通过命令`n`（下一个）完成，像这样：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The command `n` (next) will continue to the next line and print the line. If
    you need to see more than one line at a time, the  command `l` (list) shows the
    current line with the surrounding code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`n`（下一个）将继续到下一行并打印该行。如果你需要同时查看多行，命令`l`（列出）将显示当前行及其周围的代码：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The inspection of variables can be done by printing their values to the console
    using the command `p` (print) followed by the variable name. An example of printing
    variables is:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的检查可以通过使用命令`p`（打印）后跟变量名，将其值打印到控制台来完成。打印变量的示例是：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The command `p` (print) will print the variable; the command `c` (continue)
    continues execution.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`p`（打印）将打印变量；命令`c`（继续）将继续执行。
- en: 'Changing a variable mid-execution is useful. Simply assign the new value at
    the debugger prompt and step or continue the execution:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行过程中修改变量是很有用的。只需在调试器提示符下分配新值，并逐步执行或继续执行：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here the variable `z` is assigned a new value to be used throughout the remaining
    code. Note that the final printout has changed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量`z`被赋予一个新值，并在剩余的代码中使用。请注意，最终的打印输出已发生变化。
- en: 12.2.4 Overview – debug commands
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2.4 概述 – 调试命令
- en: In *Table 12.2*, the most common debug commands are shown. For a full listing and
    description of commands, see the documentation for more information [24]. Note
    that any Python command also works, for example, assigning values to variables.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在*表12.2*中，显示了最常用的调试命令。有关完整的命令列表和描述，请参阅文档以获取更多信息[24]。请注意，任何Python命令也都有效，例如，为变量赋值。
- en: If you want to inspect a variable with a name that coincides with any of the
    debugger's short commands, for example, `h`, you must use `!h` to display the
    variable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查一个与调试器短命令重名的变量，例如`h`，你必须使用`!h`来显示该变量。
- en: '| **Command** | **Action** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **操作** |'
- en: '| `h` | Help (without arguments, it prints available commands) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `h` | 帮助（不带参数时，显示可用的命令） |'
- en: '| `l` | Lists the code around the current line |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `l` | 列出当前行周围的代码 |'
- en: '| `q` | Quit (exits the debugger and the execution stops) |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `q` | 退出（退出调试器，停止执行） |'
- en: '| `c` | Continues execution |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 继续执行 |'
- en: '| `r` | Continues execution until the current function returns |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `r` | 继续执行，直到当前函数返回 |'
- en: '| `n` | Continues execution until the next line |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `n` | 继续执行，直到下一行 |'
- en: '| `p <expression>` | Evaluates and prints the expression in the current context
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `p <expression>` | 计算并打印当前上下文中的表达式 |'
- en: 'Table 12.2: The most common debug commands for the debugger'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.2：调试器中最常用的调试命令
- en: 12.2.5 Debugging in IPython
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2.5 IPython 中的调试
- en: IPython comes with a version of the debugger called `ipdb`. At the time of writing this
    book, the differences to `pdb` are very minor but this may change.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 自带一个调试器版本，称为 `ipdb`。在撰写本书时，`ipdb` 与 `pdb` 之间的差异非常小，但这可能会发生变化。
- en: 'There is a command in IPython, `%pdb`, that automatically turns on the debugger
    in case of an exception. This is very useful when experimenting with new ideas
    or code. An example of how to automatically turn on the debugger in IPython is:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPython 中有一个命令 `%pdb`，在出现异常时自动启动调试器。当你在实验新想法或代码时，这非常有用。如何在 IPython 中自动启动调试器的一个示例如下：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The IPython magic command `%pdb` at the IPython prompt automatically enables
    the debugger when exceptions are raised. Here the debugger prompt shows `ipdb` instead
    to indicate that the debugger is running.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPython 提示符下，IPython 魔法命令 `%pdb` 会在抛出异常时自动启用调试器。在此，调试器提示符会显示 `ipdb`，以表明调试器正在运行。
- en: 12.3 Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.3 总结
- en: The key concepts in this chapter were exceptions and errors. We showed how an
    exception is raised to be caught later in another program unit. You can define
    your own exceptions and equip them with messages and current values of given variables.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键概念是异常和错误。我们展示了如何抛出异常并在另一个程序单元中捕获它。你可以定义自己的异常，并为它们配上消息和当前变量的值。
- en: The code may return unexpected results without throwing an exception. The technique
    to localize the source of the erroneous result is called debugging. We introduced
    debugging methods and hopefully encouraged you to train them so that you have
    them readily available when needed. The need for serious debugging comes sooner
    than you might expect.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能会返回意外结果而没有抛出异常。定位错误结果来源的技巧叫做调试。我们介绍了调试方法，并希望能鼓励你训练这些技巧，以便在需要时随时使用。严重的调试需求可能比你预想的更早出现。
