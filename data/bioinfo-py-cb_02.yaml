- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Python and the Surrounding Software Ecology
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 与周边软件生态
- en: We will start by installing the basic software that is required for most of
    this book. This will include the **Python** distribution, some fundamental Python
    libraries, and external bioinformatics software. Here, we will also look at the
    world outside of Python. In bioinformatics and big data, **R** is also a major
    player; therefore, you will learn how to interact with it via **rpy2**, which
    is a Python/R bridge. Additionally, we will explore the advantages that the **IPython**
    framework (via Jupyter Lab) can give us in order to efficiently interface with
    R. Given that source management with Git and GitHub is pervasive, we will make
    sure that our setup plays well with them. This chapter will set the stage for
    all of the computational biologies that we will perform in the remainder of this
    book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从安装本书大部分内容所需的基本软件开始。包括**Python**发行版，一些基本的 Python 库，以及外部生物信息学软件。在这里，我们还将关注
    Python 之外的世界。在生物信息学和大数据领域，**R** 也是一个重要的角色；因此，你将学习如何通过 **rpy2** 与其进行交互，**rpy2**
    是一个 Python/R 桥接工具。此外，我们将探索 **IPython** 框架（通过 Jupyter Lab）所能带来的优势，以便高效地与 R 进行接口。由于
    Git 和 GitHub 在源代码管理中的广泛应用，我们将确保我们的设置能够与它们兼容。本章将为本书剩余部分的所有计算生物学工作奠定基础。
- en: As different users have different requirements, we will cover two different
    approaches for installing the software. One approach is using the Anaconda Python
    ([http://docs.continuum.io/anaconda/](http://docs.continuum.io/anaconda/)) distribution
    and another approach for installing the software is via Docker (which is a server
    virtualization method based on containers sharing the same operating system kernel;
    please refer to https://www.docker.com/). This will still install Anaconda for
    you but inside a container. If you are using a Windows-based operating system,
    you are strongly encouraged to consider changing your operating system or using
    Docker via some of the existing options on Windows. On macOS, you might be able
    to install most of the software natively, though Docker is also available. Learning
    using a local distribution (Anaconda or something else) is easier than Docker,
    but given that package management can be complex in Python, Docker images provide
    a level of stability.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同用户有不同的需求，我们将介绍两种安装软件的方式。一种方式是使用 Anaconda Python（[http://docs.continuum.io/anaconda/](http://docs.continuum.io/anaconda/)）发行版，另一种方式是通过
    Docker 安装软件（Docker 是基于容器共享同一操作系统内核的服务器虚拟化方法；请参考 https://www.docker.com/）。这种方法仍然会为你安装
    Anaconda，但是在容器内安装。如果你使用的是 Windows 操作系统，强烈建议你考虑更换操作系统或使用 Windows 上现有的 Docker 选项。在
    macOS 上，你可能能够原生安装大部分软件，但 Docker 也是可用的。使用本地发行版（如 Anaconda 或其他）学习比使用 Docker 更简单，但考虑到
    Python 中的包管理可能较为复杂，Docker 镜像提供了更高的稳定性。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Installing the required software with Anaconda
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Anaconda 安装所需的软件
- en: Installing the required software with Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 安装所需的软件
- en: Interfacing with R via `rpy2`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `rpy2` 与 R 交互
- en: Performing R magic with Jupyter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Jupyter 中使用 R 魔法
- en: Installing the required basic software with Anaconda
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Anaconda 安装所需的基本软件
- en: Before we get started, we need to install some basic prerequisite software.
    The following sections will take you through the software and the steps that are
    needed to install them. Each chapter and section might have extra requirements
    on top of these – we will make those clear as the book progresses. An alternative
    way to start is to use the Docker recipe, after which everything will be taken
    care of for you via a Docker container.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要安装一些基本的前置软件。接下来的章节将引导你完成所需软件及其安装步骤。每个章节和部分可能会有额外的要求，我们会在本书后续部分中明确说明。另一种启动方式是使用
    Docker 配方，之后所有工作将通过 Docker 容器自动处理。
- en: If you are already using a different Python distribution, you are strongly encouraged
    to consider Anaconda, as it has become the *de-facto* standard for data science
    and bioinformatics. Also, it is the distribution that will allow you to install
    software from **Bioconda** ([https://bioconda.github.io/](https://bioconda.github.io/)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在使用其他 Python 发行版，强烈建议考虑使用 Anaconda，因为它已经成为数据科学和生物信息学的*事实标准*。此外，它是可以让你从
    **Bioconda** 安装软件的发行版（[https://bioconda.github.io/](https://bioconda.github.io/)）。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Python can be run on top of different environments. For instance, you can use
    Python inside the **Java Virtual Machine** (**JVM**) (via **Jython** or with .NET
    via **IronPython**). However, here, we are not only concerned with Python but
    also with the complete software ecology around it. Therefore, we will use the
    standard (**CPython**) implementation, since the JVM and .NET versions exist mostly
    to interact with the native libraries of these platforms.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python 可以在不同的环境中运行。例如，你可以在 **Java 虚拟机**（**JVM**）中使用 Python（通过 **Jython** 或使用
    .NET 中的 **IronPython**）。然而，在这里，我们不仅关注 Python，还关注围绕它的完整软件生态系统。因此，我们将使用标准的（**CPython**）实现，因为
    JVM 和 .NET 版本主要是与这些平台的原生库进行交互。
- en: For our code, we will be using Python 3.10\. If you were starting with Python
    and bioinformatics, any operating system will work. But here, we are mostly concerned
    with intermediate to advanced usage. So, while you can probably use Windows and
    macOS, most of the heavy-duty analysis will be done on Linux (probably on a Linux
    **high-performance computing** or **HPC** cluster). **Next-generation sequencing**
    (**NGS**) data analysis and complex machine learning are mostly performed on Linux
    clusters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的代码，我们将使用 Python 3.10。如果你刚开始学习 Python 和生物信息学，任何操作系统都可以使用。但在这里，我们主要关注的是中级到高级的使用。所以，虽然你可能可以使用
    Windows 和 macOS，但大多数繁重的分析将会在 Linux 上进行（可能是在 Linux **高性能计算**（**HPC**）集群上）。**下一代测序**（**NGS**）数据分析和复杂的机器学习大多数是在
    Linux 集群上进行的。
- en: If you are on Windows, you should consider upgrading to Linux for your bioinformatics
    work because most modern bioinformatics software will not run on Windows. Note
    that macOS will be fine for almost all analyses unless you plan to use a computer
    cluster, which will probably be Linux-based.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Windows，考虑升级到 Linux 来进行生物信息学工作，因为大多数现代生物信息学软件无法在 Windows 上运行。请注意，除非你计划使用计算机集群，否则
    macOS 对几乎所有分析都是可以的，计算机集群通常基于 Linux。
- en: If you are on Windows or macOS and do not have easy access to Linux, don’t worry.
    Modern virtualization software (such as **VirtualBox** and **Docker**) will come
    to your rescue, which will allow you to install a virtual Linux on your operating
    system. If you are working with Windows and decide that you want to go native
    and not use Anaconda, be careful with your choice of libraries; you will probably
    be safer if you install the 32-bit version for everything (including Python itself).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Windows 或 macOS，并且没有轻松访问 Linux 的方式，别担心。现代虚拟化软件（如 **VirtualBox** 和 **Docker**）将会帮你解决问题，它们允许你在操作系统上安装一个虚拟的
    Linux。如果你正在使用 Windows 并决定使用原生方式而不是 Anaconda，要小心选择库；如果你为所有内容（包括 Python 本身）安装 32
    位版本，可能会更安全。
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are on Windows, many tools will be unavailable to you.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Windows，许多工具将无法使用。
- en: Bioinformatics and data science are moving at breakneck speed; this is not just
    hype, it’s a reality. When installing software libraries, choosing a version might
    be tricky. Depending on the code that you have, it might not work with some old
    versions or perhaps not even work with a newer version. Hopefully, any code that
    you use will indicate the correct dependencies – though this is not guaranteed.
    In this book, we will fix the precise versions of all software packages, and we
    will make sure that the code will work with them. It is quite natural that the
    code might need tweaking with other package versions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 生物信息学和数据科学正在以惊人的速度发展，这不仅仅是炒作，而是现实。在安装软件库时，选择版本可能会很棘手。根据你所使用的代码，某些旧版本可能无法工作，或者可能甚至无法与新版本兼容。希望你使用的任何代码会指出正确的依赖项——尽管这并不保证。在本书中，我们将固定所有软件包的精确版本，并确保代码可以与这些版本一起工作。代码可能需要根据其他软件包版本进行调整，这是非常自然的。
- en: The software developed for this book is available at [https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-edition](https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-edition).
    To access it, you will need to install Git. Getting used to Git might be a good
    idea because lots of scientific computing software is being developed with it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本书开发的软件可以在 [https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-edition](https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-edition)
    找到。要访问它，你需要安装 Git。习惯使用 Git 可能是个好主意，因为许多科学计算软件都是在它的基础上开发的。
- en: Before you install the Python stack properly, you will need to install all of
    the external non-Python software that you will be interoperating with. The list
    will vary from chapter to chapter, and all chapter-specific packages will be explained
    in their respective chapters. Fortunately, since the previous editions of this
    book, most bioinformatics software has become available via the Bioconda project;
    therefore, installation is usually easy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确安装 Python 环境之前，你需要先安装所有与 Python 交互的外部非 Python 软件。这个列表会根据章节有所不同，所有章节特定的软件包将在相应的章节中解释。幸运的是，自本书的前几个版本以来，大多数生物信息学软件已经可以通过
    Bioconda 项目安装，因此安装通常很容易。
- en: You will need to install some development compilers and libraries, all of which
    are free. On Ubuntu, consider installing the build-essential package (`apt-get
    install build-essential`), and on macOS, consider **Xcode** ([https://developer.apple.com/xcode/](https://developer.apple.com/xcode/)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装一些开发编译器和库，所有这些都是免费的。在 Ubuntu 上，建议安装 build-essential 包（`apt-get install
    build-essential`），在 macOS 上，建议安装 **Xcode**（[https://developer.apple.com/xcode/](https://developer.apple.com/xcode/)）。
- en: 'In the following table, you will find a list of the most important software
    to develop bioinformatics with Python:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在下表中，你将找到开发生物信息学所需的最重要的 Python 软件列表：
- en: '| **Name** | **Application** | **URL** | **Purpose** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **应用** | **网址** | **目的** |'
- en: '| Project Jupyter | All chapters | https://jupyter.org/ | Interactive computing
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Project Jupyter | 所有章节 | https://jupyter.org/ | 交互式计算 |'
- en: '| pandas | All chapters | https://pandas.pydata.org/ | Data processing |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| pandas | 所有章节 | https://pandas.pydata.org/ | 数据处理 |'
- en: '| NumPy | All chapters | http://www.numpy.org/ | Array/matrix processing |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| NumPy | 所有章节 | http://www.numpy.org/ | 数组/矩阵处理 |'
- en: '| SciPy | All chapters | https://www.scipy.org/ | Scientific computing |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| SciPy | 所有章节 | https://www.scipy.org/ | 科学计算 |'
- en: '| Biopython | All chapters | https://biopython.org/ | Bioinformatics library
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| Biopython | 所有章节 | https://biopython.org/ | 生物信息学库 |'
- en: '| seaborn | All chapters | http://seaborn.pydata.org/ | Statistical chart library
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| seaborn | 所有章节 | http://seaborn.pydata.org/ | 统计图表库 |'
- en: '| R | Bioinformatics and Statistics | https://www.r-project.org/ | Language
    for statistical computing |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| R | 生物信息学与统计 | https://www.r-project.org/ | 统计计算语言 |'
- en: '| rpy2 | R connectivity | https://rpy2.readthedocs.io | R interface |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| rpy2 | R 连接 | https://rpy2.readthedocs.io | R 接口 |'
- en: '| PyVCF | NGS | https://pyvcf.readthedocs.io | VCF processing |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| PyVCF | NGS | https://pyvcf.readthedocs.io | VCF 处理 |'
- en: '| Pysam | NGS | https://github.com/pysam-developers/pysam | SAM/BAM processing
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| Pysam | NGS | https://github.com/pysam-developers/pysam | SAM/BAM 处理 |'
- en: '| HTSeq | NGS/Genomes | https://htseq.readthedocs.io | NGS processing |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| HTSeq | NGS/基因组 | https://htseq.readthedocs.io | NGS 处理 |'
- en: '| DendroPY | Phylogenetics | https://dendropy.org/ | Phylogenetics |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| DendroPY | 系统发育学 | https://dendropy.org/ | 系统发育学 |'
- en: '| PyMol | Proteomics | https://pymol.org | Molecular visualization |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| PyMol | 蛋白质组学 | https://pymol.org | 分子可视化 |'
- en: '| scikit-learn | Machine learning | http://scikit-learn.org | Machine learning
    library |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| scikit-learn | 机器学习 | http://scikit-learn.org | 机器学习库 |'
- en: '| Cython | Big data | http://cython.org/ | High performance |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| Cython | 大数据 | http://cython.org/ | 高性能 |'
- en: '| Numba | Big data | https://numba.pydata.org/ | High performance |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Numba | 大数据 | https://numba.pydata.org/ | 高性能 |'
- en: '| Dask | Big data | http://dask.pydata.org | Parallel processing |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| Dask | 大数据 | http://dask.pydata.org | 并行处理 |'
- en: Figure 1.1 – A table showing the various software packages that are useful in
    bioinformatics
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 显示在生物信息学中有用的各种软件包的表格
- en: We will use `pandas` to process most table data. An alternative would be to
    use just standard Python. `pandas` has become so pervasive in data science that
    it will probably make sense to just process all tabular data with it (if it fits
    in memory).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `pandas` 来处理大多数表格数据。另一种选择是仅使用标准 Python。`pandas` 在数据科学中已经变得非常普及，因此如果数据量适合内存，使用它处理所有表格数据可能是明智之举。
- en: All of our work will be developed inside project Jupyter, namely Jupyter Lab.
    Jupyter has become the *de facto* standard to write interactive data analysis
    scripts. Unfortunately, the default format for Jupyter Notebooks is based on JSON.
    This format is difficult to read, difficult to compare, and needs exporting to
    be fed into a normal Python interpreter. To obviate that problem, we will extend
    Jupyter with `jupytext` ([https://jupytext.readthedocs.io/](https://jupytext.readthedocs.io/)),
    which allows us to save Jupyter notebooks as normal Python programs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的工作将在Jupyter项目内进行，即Jupyter Lab。Jupyter已成为编写交互式数据分析脚本的*事实*标准。不幸的是，Jupyter Notebooks的默认格式基于JSON。这种格式难以阅读、难以比较，并且需要导出才能输入到普通的Python解释器中。为了解决这个问题，我们将使用`jupytext`
    ([https://jupytext.readthedocs.io/](https://jupytext.readthedocs.io/)) 扩展Jupyter，允许我们将Jupyter笔记本保存为普通的Python程序。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 怎么做...
- en: 'To get started, take a look at the following steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请查看以下步骤：
- en: Start by downloading the Anaconda distribution from https://www.anaconda.com/products/individual.
    We will be using version 21.05, although you will probably be fine with the most
    recent one. You can accept all the installation’s default settings, but you might
    want to make sure that the `conda` binaries are in your path (do not forget to
    open a new window so that the path can be updated). If you have another Python
    distribution, be careful with your `PYTHONPATH` and existing Python libraries.
    It’s probably better to unset your `PYTHONPATH`. As much as possible, uninstall
    all other Python versions and installed Python libraries.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先从 https://www.anaconda.com/products/individual 下载Anaconda发行版。我们将使用版本21.05，尽管您可能可以使用最新版本。您可以接受安装的所有默认设置，但您可能希望确保`conda`二进制文件在您的路径中（不要忘记打开一个新窗口，以便路径可以更新）。如果您有另一个Python发行版，请注意您的`PYTHONPATH`和现有的Python库。最好卸载所有其他Python版本和已安装的Python库。尽可能地，删除所有其他Python版本和已安装的Python库。
- en: 'Let’s go ahead with the libraries. We will now create a new `conda` environment
    called `bioinformatics_base` with `biopython=1.70`, as shown in the following
    command:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续使用库。我们现在将使用以下命令创建一个名为`bioinformatics_base`的新`conda`环境，并安装`biopython=1.70`：
- en: '[PRE0]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s activate the environment, as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们按以下步骤激活环境：
- en: '[PRE1]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s add the `bioconda` and `conda-forge` channels to our source list:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`bioconda`和`conda-forge`通道添加到我们的源列表：
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also, install the basic packages:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要安装基本软件包：
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let’s save our environment so that we can reuse it later to create new
    environments in other machines or if you need to clean up the base environment:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们保存我们的环境，以便以后在其他机器上创建新的环境，或者如果需要清理基础环境：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can even install R from `conda`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以从`conda`安装R：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that `r-essentials` installs a lot of R packages, including ggplot2, which
    we will use later. Additionally, we install `r-gridextra` since we will be using
    it in the Notebook.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`r-essentials`会安装许多R包，包括后面要用到的ggplot2。另外，我们还会安装`r-gridextra`，因为我们在Notebook中会用到它。
- en: There’s more...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you prefer not to use Anaconda, you will be able to install many of the Python
    libraries via `pip` using whatever distribution you choose. You will probably
    need quite a few compilers and build tools – not only C compilers but also C++
    and Fortran.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不喜欢使用Anaconda，您可以选择使用任何发行版通过`pip`安装许多Python库。您可能需要许多编译器和构建工具，不仅包括C编译器，还包括C++和Fortran。
- en: We will not be using the environment we created in the preceding steps. Instead,
    we will use it as a base to clone working environments from it. This is because
    environment management with Python – even with the help of the `conda` package
    system – can still be quite painful. So, we will create a clean environment that
    we never spoil and can derive from if our development environments become unmanageable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再使用前面步骤中创建的环境。相反，我们将把它用作克隆工作环境的基础。这是因为使用Python进行环境管理，即使借助`conda`包系统的帮助，仍可能非常痛苦。因此，我们将创建一个干净的环境，以免造成损害，并可以从中派生出开发环境，如果开发环境变得难以管理。
- en: 'For example, imagine you want to create an environment for machine learning
    with `scikit-learn`. You can do the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您想创建一个带有`scikit-learn`的机器学习环境。您可以执行以下操作：
- en: 'Create a clone of the original environment with the following:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建原始环境的克隆：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add `scikit-learn`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`scikit-learn`：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When inside JupyterLab, we should open our jupytext files with the notebook,
    not the text editor. As the jupytext files have the same extension as Python files
    – this is a feature, not a bug – by default, JupyterLab would use a normal text
    editor. When we open a jupytext file, we need to override the default. When opening
    it, right-click and choose **Notebook**, as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JupyterLab 中，我们应该通过 notebook 打开我们的 jupytext 文件，而不是通过文本编辑器。由于 jupytext 文件与
    Python 文件具有相同的扩展名——这是一个特性，而非 bug——JupyterLab 默认会使用普通的文本编辑器。当我们打开 jupytext 文件时，我们需要覆盖默认设置。右键点击并选择
    **Notebook**，如下图所示：
- en: '![Figure 1.2 – Opening a jupytext file in Notebook ](img/B17942_01_002.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 在 Notebook 中打开 jupytext 文件](img/B17942_01_002.jpg)'
- en: Figure 1.2 – Opening a jupytext file in Notebook
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 在 Notebook 中打开 jupytext 文件
- en: Our jupytext files will not be saving graphical outputs and that will suffice
    for this book. If you want to have a version with images, this is possible using
    paired notebooks. For more details, check the Jupytext page ([https://github.com/mwouts/jupytext](https://github.com/mwouts/jupytext)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 jupytext 文件将不会保存图形输出，这对于本书来说已经足够。如果你想要一个带有图片的版本，这是可以通过配对的 notebooks 实现的。更多详情，请查看
    Jupytext 页面 ([https://github.com/mwouts/jupytext](https://github.com/mwouts/jupytext))。
- en: Warning
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: As our code is meant to be run inside Jupyter, many times throughout this book,
    I will not use `print` to output content, as the last line of a cell will be automatically
    rendered. If you are not using notebooks, remember to do a `print`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的代码是为了在 Jupyter 中运行的，本书中很多地方，我不会使用 `print` 输出内容，因为单元格的最后一行会被自动渲染。如果你没有使用
    notebook，请记得使用 `print`。
- en: Installing the required software with Docker
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 安装所需的软件
- en: 'Docker is the most widely-used framework for implementing operating system-level
    virtualization. This technology allows you to have an independent container: a
    layer that is lighter than a virtual machine but still allows you to compartmentalize
    software. This mostly isolates all processes, making it feel like each container
    is a virtual machine.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是实现操作系统级虚拟化的最广泛使用的框架。这项技术使你能够拥有一个独立的容器：一个比虚拟机更轻量的层，但仍然允许你将软件进行隔离。这基本上隔离了所有进程，使得每个容器看起来像一个虚拟机。
- en: 'Docker works quite well at both extremes of the development spectrum: it’s
    an expedient way to set up the content of this book for learning purposes and
    could become your platform of choice for deploying your applications in complex
    environments. This recipe is an alternative to the previous recipe.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 在开发领域的两端表现得非常好：它是设置本书内容以用于学习目的的便捷方式，并且可以成为你在复杂环境中部署应用程序的首选平台。这个方案是前一个方案的替代。
- en: However, for long-term development environments, something along the lines of
    the previous recipe is probably your best route, although it can entail a more
    laborious initial setup.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于长期的开发环境，类似前一个方案的方法可能是你的最佳选择，尽管它可能需要更繁琐的初始设置。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you are on Linux, the first thing you have to do is install Docker. The safest
    solution is to get the latest version from [https://www.docker.com/](https://www.docker.com/).
    While your Linux distribution might have a Docker package, it might be too old
    and buggy.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Linux，首先需要做的是安装 Docker。最安全的解决方案是从 [https://www.docker.com/](https://www.docker.com/)
    获取最新版本。虽然你的 Linux 发行版可能有 Docker 包，但它可能过时且有 bug。
- en: If you are on Windows or macOS, do not despair; take a look at the Docker site.
    There are various options available to save you, but there is no clear-cut formula,
    as Docker advances quite quickly on those platforms. A fairly recent computer
    is necessary to run our 64-bit virtual machine. If you have any problems, reboot
    your machine and make sure that the BIOS, VT-X, or AMD-V is enabled. At the very
    least, you will need 6 GB of memory, preferably more.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Windows 或 macOS，不要灰心；查看 Docker 网站。有多种可供选择的方案，但没有明确的公式，因为 Docker 在这些平台上发展得很快。你需要一台相对较新的计算机来运行我们的
    64 位虚拟机。如果遇到任何问题，重启计算机并确保 BIOS、VT-X 或 AMD-V 已启用。至少你需要 6 GB 内存，最好更多。
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This will require a very large download from the internet, so be sure that you
    have plenty of bandwidth. Also, be ready to wait for a long time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要从互联网进行非常大的下载，因此请确保你有足够的带宽。另外，准备好等待很长时间。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To get started, follow these steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请按照以下步骤操作：
- en: 'Use the following command on your Docker shell:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Docker shell 中使用以下命令：
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On Linux, you will either need to have root privileges or be added to the Docker
    Unix group.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，你需要有 root 权限或被加入到 Docker Unix 组中。
- en: 'Now you are ready to run the container, as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你准备好运行容器，具体如下：
- en: '[PRE9]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Replace `YOUR_DIRECTORY` with a directory on your operating system. This will
    be shared between your host operating system and the Docker container. `YOUR_DIRECTORY`
    will be seen in the container in `/data` and vice versa.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `YOUR_DIRECTORY` 替换为你操作系统中的一个目录。该目录将在主机操作系统和 Docker 容器之间共享。`YOUR_DIRECTORY`
    在容器内会显示为 `/data`，反之亦然。
- en: '`-p 9875:9875` will expose the container’s TCP port `9875` on the host computer
    port, `9875`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p 9875:9875` 将暴露容器的 TCP 端口 `9875` 到主机计算机的端口 `9875`。'
- en: Especially on Windows (and maybe on macOS), make sure that your directory is
    actually visible inside the Docker shell environment. If not, check the official
    Docker documentation on how to expose directories.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在 Windows 上（也许在 macOS 上），请确保你的目录在 Docker shell 环境中确实可见。如果不可见，请查看官方 Docker
    文档，了解如何暴露目录。
- en: Now you are ready to use the system. Point your browser to `http://localhost:9875`,
    and you should get the Jupyter environment.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你准备好使用系统了。将浏览器指向 `http://localhost:9875`，你应该会看到 Jupyter 环境。
- en: If this does not work on Windows, check the official Docker documentation ([https://docs.docker.com/](https://docs.docker.com/))
    on how to expose ports.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Windows 上无法运行，请查看官方 Docker 文档 ([https://docs.docker.com/](https://docs.docker.com/))，了解如何暴露端口。
- en: See also
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'The following is also worth knowing:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容也值得了解：
- en: Docker is the most widely used containerization software and has seen enormous
    growth in usage in recent times. You can read more about it at [https://www.docker.com/](https://www.docker.com/).
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 是最广泛使用的容器化软件，最近在使用量上增长巨大。你可以在 [https://www.docker.com/](https://www.docker.com/)
    阅读更多关于它的信息。
- en: A security-minded alternative to Docker is **rkt**, which can be found at [https://coreos.com/rkt/](https://coreos.com/rkt/).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 Docker 的一个面向安全的替代方案，**rkt** 可以在 [https://coreos.com/rkt/](https://coreos.com/rkt/)
    找到。
- en: If you are not able to use Docker, for example, if you do not have the necessary
    permissions, as will be the case on most computer clusters, then take a look at
    Singularity at [https://www.sylabs.io/singularity/](https://www.sylabs.io/singularity/).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你无法使用 Docker，例如，如果你没有必要的权限（这通常发生在大多数计算集群中），可以查看 Singularity，网址为 [https://www.sylabs.io/singularity/](https://www.sylabs.io/singularity/)。
- en: Interfacing with R via rpy2
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 rpy2 与 R 进行交互
- en: If there is some functionality that you need and you cannot find it in a Python
    library, your first port of call is to check whether it’s been implemented in
    R. For statistical methods, R is still the most complete framework; moreover,
    some bioinformatics functionalities are *only* available in R and are probably
    offered as a package belonging to the Bioconductor project.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要某些功能，但在 Python 库中找不到，首先应该检查该功能是否已经在 R 中实现。对于统计方法，R 仍然是最完整的框架；此外，某些生物信息学功能*仅*在
    R 中可用，并且可能作为 Bioconductor 项目的一部分提供。
- en: '`ggplot2`), we will download its metadata from the Human 1,000 Genomes Project
    ([http://www.1000genomes.org/](http://www.1000genomes.org/)). This is not a book
    on R, but we want to provide interesting and functional examples.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`ggplot2`，我们将从人类 1,000 基因组计划 ([http://www.1000genomes.org/](http://www.1000genomes.org/))
    下载它的元数据。这本书不是关于 R 的，但我们希望提供有趣且实用的示例。'
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to get the metadata file from the 1,000 Genomes sequence index.
    Please check [https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-edition/blob/main/Datasets.py](https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-edition/blob/main/Datasets.py),
    and download the `sequence.index` file. If you are using Jupyter Notebook, open
    the `Chapter01/Interfacing_R.py` file and simply execute the `wget` command on
    top.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从 1,000 基因组序列索引中获取元数据文件。请查看 [https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-edition/blob/main/Datasets.py](https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-edition/blob/main/Datasets.py)，并下载
    `sequence.index` 文件。如果你使用 Jupyter Notebook，打开 `Chapter01/Interfacing_R.py` 文件，并直接执行顶部的
    `wget` 命令。
- en: This file has information about all of the FASTQ files in the project (we will
    use data from the Human 1,000 Genomes Project in the chapters to come). This includes
    the FASTQ file, the sample ID, the population of origin, and important statistical
    information per lane, such as the number of reads and the number of DNA bases
    read.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含了项目中所有 FASTQ 文件的信息（在接下来的章节中，我们将使用来自人类 1,000 基因组项目的数据）。这包括 FASTQ 文件、样本 ID、来源人群以及每条数据通道的重要统计信息，例如读取数和读取的
    DNA 序列数。
- en: 'To set up Anaconda, you can run the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 Anaconda，可以运行以下命令：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With Docker, you can run the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker，你可以运行以下命令：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we can begin.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始了。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To get started, follow these steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请按照以下步骤操作：
- en: 'Let’s start by doing some imports:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从导入一些库开始：
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will be using `pandas` on the Python side. R DataFrames map very well to
    `pandas`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Python 端使用`pandas`。R 中的 DataFrame 与`pandas`非常匹配。
- en: 'We will read the data from our file using R’s `read.delim` function:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 R 的`read.delim`函数从文件中读取数据：
- en: '[PRE13]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first thing that we do after importing is to access the `read.delim` R function,
    which allows you to read files. The R language specification allows you to put
    dots in the names of objects. Therefore, we have to convert a function name into
    `read_delim`. Then, we call the function name proper; note the following highly
    declarative features. Firstly, most atomic objects, such as strings, can be passed
    without conversion. Secondly, argument names are converted seamlessly (barring
    the dot issue). Finally, objects are available in the Python namespace (however,
    objects are actually not available in the R namespace; we will discuss this further
    later).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 导入后，我们做的第一件事是访问 R 中的`read.delim`函数，它允许你读取文件。R 语言规范允许在对象名称中使用点。因此，我们必须将函数名转换为`read_delim`。然后，我们调用正确的函数名；请注意以下几个显著的特性。首先，大多数原子对象（如字符串）可以直接传递而无需转换。其次，参数名也可以无缝转换（除了点问题）。最后，对象可在
    Python 命名空间中使用（然而，对象实际上不能在 R 命名空间中使用；我们稍后会详细讨论）。
- en: For reference, I have included the corresponding R code. I hope it’s clear that
    it’s an easy conversion. The `seq_data` object is a DataFrame. If you know basic
    R or `pandas`, you are probably aware of this type of data structure. If not,
    then this is essentially a table, that is, a sequence of rows where each column
    has the same type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，我附上了相应的 R 代码。我希望你能看出它的转换是非常简单的。`seq_data`对象是一个 DataFrame。如果你了解基本的 R 或者`pandas`，你可能对这种数据结构有所了解。如果不了解，那么它基本上是一个表格，即一系列行，其中每一列都具有相同的数据类型。
- en: 'Let’s perform a basic inspection of this DataFrame, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对这个 DataFrame 进行基本的检查，如下所示：
- en: '[PRE14]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Again, note the code similarity.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意代码的相似性。
- en: 'You can even mix styles using the following code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你甚至可以使用以下代码混合不同的风格：
- en: '[PRE15]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can call R functions directly; in this case, we will call `ncol` if they
    do not have dots in their name; however, be careful. This will display an output,
    not 26 (the number of columns), but [26], which is a vector that’s composed of
    the `26` element. This is because, by default, most operations in R return vectors.
    If you want the number of columns, you have to perform `my_cols[0]`. Also, talking
    about pitfalls, note that R array indexing starts with 1, whereas Python starts
    with 0.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接调用 R 函数；在这种情况下，如果函数名称中没有点，我们将调用`ncol`；但是要小心。这样做会输出结果，而不是 26（列数），而是[26]，这是一个包含`26`元素的向量。这是因为默认情况下，R
    中的大多数操作返回向量。如果你想要列数，必须执行`my_cols[0]`。另外，谈到陷阱，注意 R 数组的索引是从 1 开始的，而 Python 是从 0
    开始的。
- en: 'Now, we need to perform some data cleanup. For example, some columns should
    be interpreted as numbers, but instead, they are read as strings:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要进行一些数据清理。例如，有些列应该解释为数字，但它们却被当作字符串读取：
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `match` function is somewhat similar to the `index` method in Python lists.
    As expected, it returns a vector so that we can extract the `0` element. It’s
    also 1-indexed, so we subtract 1 when working on Python. The `as_integer` function
    will convert a column into integers. The first print will show strings (that is
    values surrounded by `"`), whereas the second print will show numbers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`函数与 Python 列表中的`index`方法有些相似。正如预期的那样，它返回一个向量，因此我们可以提取`0`元素。它也是从 1 开始索引的，因此在
    Python 中工作时需要减去 1。`as_integer`函数会将一列数据转换为整数。第一次打印会显示字符串（即被`"`包围的值），而第二次打印会显示数字。'
- en: 'We will need to massage this table a bit more; details on this can be found
    in the notebook. Here, we will finalize getting the DataFrame to R (remember that
    while it’s an R object, it’s actually visible on the Python namespace):'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要对这张表进行更多处理；有关详细信息可以在笔记本中找到。在这里，我们将完成将 DataFrame 获取到 R 中的操作（请记住，虽然它是一个 R
    对象，但实际上在 Python 命名空间中可见）：
- en: '[PRE17]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will create a variable in the R namespace called `seq.data`, with the content
    of the DataFrame from the Python namespace. Note that after this operation, both
    objects will be independent (if you change one, it will not be reflected in the
    other).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 R 命名空间中创建一个名为`seq.data`的变量，其内容来自 Python 命名空间中的 DataFrame。请注意，在此操作之后，两个对象将是独立的（如果更改其中一个对象，将不会反映到另一个对象中）。
- en: Note
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While you can perform plotting on Python, R has default built-in plotting functionalities
    (which we will ignore here). It also has a library called `ggplot2` that implements
    the **Grammar of Graphics** (a declarative language to specify statistical charts).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以在 Python 上执行绘图，R 默认内置了绘图功能（这里我们将忽略）。它还有一个叫做`ggplot2`的库，实现了**图形语法**（一种声明性语言，用于指定统计图表）。
- en: 'Regarding our concrete example based on the Human 1,000 Genomes Project, first,
    we will plot a histogram with the distribution of center names, where all sequencing
    lanes were generated. For this, we will use `ggplot`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于我们基于人类 1,000 个基因组计划的具体示例，首先，我们将绘制一个直方图，显示生成所有测序通道的中心名称的分布。为此，我们将使用`ggplot`：
- en: '[PRE18]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The second line is a bit uninteresting but is an important piece of boilerplate
    code. One of the R functions that we will call has a parameter with a dot in its
    name. As Python function calls cannot have this, we must map the `axis.text.x`
    R parameter name to the `axis_text_r` Python name in the function theme. We monkey
    patch it (that is, we replace `ggplot2.theme` with a patched version of itself).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行有点无趣，但是是重要的样板代码的一部分。我们将调用的一个 R 函数具有其名称中带有点的参数。由于 Python 函数调用中不能有这个点，我们必须将`axis.text.x`的
    R 参数名称映射到`axis_text_r`的 Python 名称中的函数主题中。我们对其进行了修补（即，我们用其自身的修补版本替换了`ggplot2.theme`）。
- en: Then, we draw the chart itself. Note the declarative nature of `ggplot2` as
    we add features to the chart. First, we specify the `seq_data` DataFrame, then
    we use a histogram bar plot called `geom_bar`. Following this, we annotate the
    `x` variable (`CENTER_NAME`). Finally, we rotate the text of the *x-axis* by changing
    the theme. We finalize this by closing the R printing device.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们绘制图表本身。请注意`ggplot2`的声明性质，因为我们向图表添加特性。首先，我们指定`seq_data`数据框，然后使用称为`geom_bar`的直方图条形图。接下来，我们注释`x`变量（`CENTER_NAME`）。最后，通过更改主题，我们旋转*x轴*的文本。我们通过关闭
    R 打印设备来完成这一操作。
- en: 'Now, we can print the image in the Jupyter Notebook:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 Jupyter Notebook 中打印图像：
- en: '[PRE19]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following chart is produced:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 生成以下图表：
- en: '![Figure 1.3 – The ggplot2-generated histogram of center names, which is responsible
    for sequencing the lanes of the human genomic data from the 1,000 Genomes Project
    ](img/B17942_01_003.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 使用 ggplot2 生成的中心名称直方图，负责从 1,000 个基因组计划中测序人类基因组数据的通道](img/B17942_01_003.jpg)'
- en: Figure 1.3 – The ggplot2-generated histogram of center names, which is responsible
    for sequencing the lanes of the human genomic data from the 1,000 Genomes Project
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 使用 ggplot2 生成的中心名称直方图，负责从 1,000 个基因组计划中测序人类基因组数据的通道
- en: 'As a final example, we will now do a scatter plot of read and base counts for
    all of the sequenced lanes for Yoruban (`YRI`) and Utah residents with ancestry
    from Northern and Western Europe (`CEU`), using the Human 1,000 Genomes Project
    (the summary of the data of this project, which we will use thoroughly, can be
    seen in the *Working with modern sequence formats* recipe of [*Chapter 3*](B17942_03.xhtml#_idTextAnchor068),
    *Next-Generation Sequencing*). Additionally, we are interested in the differences
    between the different types of sequencing (for instance, exome coverage, high
    coverage, and low coverage). First, we generate a DataFrame with just the `YRI`
    and `CEU` lanes, and limit the maximum base and read counts:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一个示例，我们现在将对 Yoruban（`YRI`）和来自北欧和西欧的犹他州居民（`CEU`）的所有测序通道的读取和碱基计数进行散点图绘制，使用人类
    1,000 个基因组计划（该项目的数据总结，我们将充分使用，可以在[*第三章*](B17942_03.xhtml#_idTextAnchor068)的*使用现代序列格式*食谱中看到）。此外，我们对不同类型的测序之间的差异感兴趣（例如，外显子覆盖率、高覆盖率和低覆盖率）。首先，我们生成一个仅包含`YRI`和`CEU`通道的
    DataFrame，并限制最大碱基和读取计数：
- en: '[PRE20]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we are ready to plot:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好绘图了：
- en: '[PRE21]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Hopefully, this example (please refer to the following screenshot) makes the
    power of the Grammar of Graphics approach clear. We will start by declaring the
    DataFrame and the type of chart in use (that is, the scatter plot implemented
    by `geom_point`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个例子（请参考下面的截图）能清楚地展示图形语法方法的强大。我们将首先声明 DataFrame 和正在使用的图表类型（即通过 `geom_point`
    实现的散点图）。
- en: 'Note how easy it is to express that the shape of each point depends on the
    `POPULATION` variable and that the color depends on the `ANALYSIS_GROUP` variable:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到很容易表达每个点的形状取决于 `POPULATION` 变量，而颜色取决于 `ANALYSIS_GROUP` 变量：
- en: '![Figure 1.4 – The ggplot2-generated scatter plot with base and read counts
    for all sequencing lanes read; the color and shape of each dot reflects categorical
    data (population and the type of data sequenced) ](img/B17942_01_004.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 由 ggplot2 生成的散点图，显示所有测序通道的基础和读取计数；每个点的颜色和形状反映了类别数据（种群和所测序的数据类型）](img/B17942_01_004.jpg)'
- en: Figure 1.4 – The ggplot2-generated scatter plot with base and read counts for
    all sequencing lanes read; the color and shape of each dot reflects categorical
    data (population and the type of data sequenced)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 由 ggplot2 生成的散点图，显示所有测序通道的基础和读取计数；每个点的颜色和形状反映了类别数据（种群和所测序的数据类型）
- en: 'Because the R DataFrame is so close to `pandas`, it makes sense to convert
    between the two since that is supported by `rpy2`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 R DataFrame 与 `pandas` 非常相似，因此在两者之间进行转换是很有意义的，因为 `rpy2` 支持这种转换：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We start by importing the necessary conversion module – `rpy2` provides many
    strategies to convert data from R into Python. Here, we are concerned with data
    frame conversion. We then convert the R DataFrame (note that we are converting
    `yri_ceu` in the R namespace, not the one on the Python namespace). We delete
    the column that indicates the name of the paired FASTQ file on the `pandas` DataFrame
    and copy it back to the R namespace. If you print the column names of the new
    R DataFrame, you will see that `PAIRED_FASTQ` is missing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入必要的转换模块 —— `rpy2` 提供了许多将数据从 R 转换到 Python 的策略。这里，我们关注的是数据框的转换。然后，我们转换 R
    DataFrame（请注意，我们正在转换 R 命名空间中的 `yri_ceu`，而不是 Python 命名空间中的）。我们删除了 `pandas` DataFrame
    中指示配对 FASTQ 文件名称的列，并将其复制回 R 命名空间。如果你打印新 R DataFrame 的列名，你会发现 `PAIRED_FASTQ` 列丢失了。
- en: There’s more...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: It’s worth repeating that the advances in the Python software ecology are occurring
    at a breakneck pace. This means that if a certain functionality is not available
    today, it might be released sometime in the near future. So, if you are developing
    a new project, be sure to check for the very latest developments on the Python
    front before using functionality from an R package.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 值得重复的是，Python 软件生态的进展速度非常快。这意味着如果今天某个功能不可用，它可能在不久的将来会发布。因此，如果你正在开发一个新项目，务必在使用
    R 包中的功能之前，先检查 Python 领域的最新进展。
- en: There are plenty of R packages for Bioinformatics in the Bioconductor project
    ([http://www.bioconductor.org/](http://www.bioconductor.org/)). This should probably
    be your first port of call in the R world for bioinformatics functionalities.
    However, note that many R Bioinformatics packages are not on Bioconductor, so
    be sure to search the wider R packages on **Comprehensive R Archive Network**
    (**CRAN**) (refer to CRAN at [http://cran.rproject.org/](http://cran.rproject.org/)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Bioconductor 项目中有许多适用于生物信息学的 R 包（[http://www.bioconductor.org/](http://www.bioconductor.org/)）。这应该是你在
    R 世界中进行生物信息学功能开发的首选。不过，需要注意的是，许多 R 生物信息学包并不在 Bioconductor 上，因此务必在 **综合 R 存档网络**
    (**CRAN**) 中查找更广泛的 R 包（请参阅 CRAN：[http://cran.rproject.org/](http://cran.rproject.org/)）。
- en: There are plenty of plotting libraries for Python. Matplotlib is the most common
    library, but you also have a plethora of other choices. In the context of R, it’s
    worth noting that there is a ggplot2-like implementation for Python based on the
    Grammar of Graphics description language for charts, and – surprise, surprise
    – this is called `ggplot`! ([http://yhat.github.io/ggpy/](http://yhat.github.io/ggpy/)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中有许多绘图库。Matplotlib 是最常用的库，但你也可以选择其他众多的库。在 R 的背景下，值得注意的是，Python 中有一个类似于
    ggplot2 的实现，它基于图形语法描述语言，用于图表的绘制，惊讶吗？这就是 `ggplot`！（[http://yhat.github.io/ggpy/](http://yhat.github.io/ggpy/)）。
- en: See also
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'To learn more about these topics, please refer to the following resources:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于这些主题的信息，请参考以下资源：
- en: There are plenty of tutorials and books on R; check the R web page ([http://www.r-project.org/](http://www.r-project.org/))
    for documentation.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多关于R的教程和书籍；请访问R的官方网站 ([http://www.r-project.org/](http://www.r-project.org/))
    查看文档。
- en: For Bioconductor, check the documentation at [http://manuals.bioinformatics.ucr.edu/home/R_BioCondManual](http://manuals.bioinformatics.ucr.edu/home/R_BioCondManual).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Bioconductor，请查看文档：[http://manuals.bioinformatics.ucr.edu/home/R_BioCondManual](http://manuals.bioinformatics.ucr.edu/home/R_BioCondManual)。
- en: If you work with NGS, you might also want to take look at high throughput sequence
    analysis with Bioconductor at [http://manuals.bioinformatics.ucr.edu/home/ht-seq](http://manuals.bioinformatics.ucr.edu/home/ht-seq).
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你从事NGS工作，可能还想查看Bioconductor中的高通量序列分析：[http://manuals.bioinformatics.ucr.edu/home/ht-seq](http://manuals.bioinformatics.ucr.edu/home/ht-seq)。
- en: The `rpy` library documentation is your Python gateway to R and can be found
    at [https://rpy2.bitbucket.io/](https://rpy2.bitbucket.io/).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rpy`库的文档是你通往R的Python接口，文档可以在[https://rpy2.bitbucket.io/](https://rpy2.bitbucket.io/)找到。'
- en: The *Grammar of Graphics* approach is described in a book aptly named *The Grammar
    of Graphics*, by Leland Wilkinson, Springer.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图形语法*方法在Leland Wilkinson所著的书《*图形语法*》中有详细描述，由Springer出版。'
- en: In terms of data structures, similar functionality to R can be found in the
    `pandas` library. You can find some tutorials at [http://pandas.pydata.org/pandas-docs/dev/tutorials.xhtml](http://pandas.pydata.org/pandas-docs/dev/tutorials.xhtml).
    The book, *Python for Data Analysis*, by Wes McKinney, O’Reilly Media, is also
    an alternative to consider. In the next chapter, we will discuss pandas and use
    it throughout the book.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据结构方面，可以在`pandas`库中找到类似于R的功能。你可以在[http://pandas.pydata.org/pandas-docs/dev/tutorials.xhtml](http://pandas.pydata.org/pandas-docs/dev/tutorials.xhtml)找到一些教程。Wes
    McKinney的《*Python数据分析*》一书（由O'Reilly Media出版）也是一个可以考虑的替代方案。在下一章中，我们将讨论pandas，并在整本书中使用它。
- en: Performing R magic with Jupyter
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jupyter中执行R魔法
- en: Jupyter provides quite a few extra features compared to standard Python. Among
    those features, it provides a framework of extensible commands called **magics**
    (actually, this only works with the IPython kernel of Jupyter since it is actually
    an IPython feature, but that is the one we are concerned with). Magics allow you
    to extend the language in many useful ways. There are magic functions that you
    can use to deal with R. As you will see in our example, it makes R interfacing
    much easier and more declarative. This recipe will not introduce any new R functionalities,
    but hopefully, it will make it clear how IPython can be an important productivity
    boost for scientific computing in this regard.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter相比标准Python提供了许多额外的功能。在这些功能中，它提供了一种名为**魔法**的可扩展命令框架（实际上，这只适用于Jupyter的IPython内核，因为它本质上是IPython的一个功能，但这正是我们关注的内容）。魔法命令允许你以许多有用的方式扩展语言。有一些魔法函数可以用于处理R。如你在示例中将看到的，这使得与R的接口更加简洁和声明式。本配方不会引入任何新的R功能，但希望能清楚地说明，IPython如何在科学计算中为提高生产力提供重要帮助。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need to follow the previous *Getting ready* steps of the *Interfacing
    with R via rpy2* recipe. The notebook is `Chapter01/R_magic.py`. The notebook
    is more complete than the recipe presented here and includes more chart examples.
    For brevity, we will only concentrate on the fundamental constructs to interact
    with R using magics. If you are using Docker, you can use the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要遵循*通过rpy2与R接口*配方中的前期准备步骤。笔记本是`Chapter01/R_magic.py`。该笔记本比这里呈现的配方更完整，包含更多的图表示例。为了简洁起见，我们将只集中介绍与R交互的基本构造。如果你使用Docker，可以使用以下命令：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法...
- en: 'This recipe is an aggressive simplification of the previous one because it
    illustrates the conciseness and elegance of R magics:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方是对前一个配方的大胆简化，它展示了R魔法的简洁性和优雅性：
- en: 'The first thing you need to do is load R magics and `ggplot2`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先需要做的是加载R魔法和`ggplot2`：
- en: '[PRE24]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that `%` starts an IPython-specific directive. Just as a simple example,
    you can write `%R print(c(1, 2))` onto a Jupyter cell.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`%`符号表示一个IPython特定的指令。举个简单的例子，你可以在Jupyter单元格中写入`%R print(c(1, 2))`。
- en: Check out how easy it is to execute the R code without using the `robjects`
    package. Actually, `rpy2` is being used to look under the hood.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一下如何无需使用`robjects`包就能轻松执行R代码。实际上，`rpy2`被用来查看背后的实现。
- en: 'Let’s read the `sequence.index` file that was downloaded in the previous recipe:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们读取在之前配方中下载的`sequence.index`文件：
- en: '[PRE25]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Then, you can specify that the entire cell should be interpreted as R code by
    using `%%R` (note the double `%%`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 `%%R` 来指定整个单元格应该被解释为 R 代码（注意双 `%%`）。
- en: 'We can now transfer the variable to the Python namespace:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将变量传递到 Python 命名空间：
- en: '[PRE26]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The type of the DataFrame is not a standard Python object, but a `pandas` DataFrame.
    This is a departure from previous versions of the R magic interface.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 的类型不是标准的 Python 对象，而是一个 `pandas` DataFrame。这与之前版本的 R magic 接口有所不同。
- en: 'As we have a `pandas` DataFrame, we can operate on it quite easily using the
    `pandas` interface:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们有一个 `pandas` DataFrame，我们可以通过 `pandas` 接口轻松操作它：
- en: '[PRE27]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s put this DataFrame back into the R namespace, as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将这个 DataFrame 重新放入 R 命名空间，如下所示：
- en: '[PRE28]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `-i` argument informs the magic system that the variable that follows on
    the Python space is to be copied into the R namespace. The second line just shows
    that the DataFrame is indeed available in R. The name that we are using is different
    from the original – it’s `seq_data`, instead of `seq.data`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i` 参数通知 magic 系统，将后面的变量从 Python 空间复制到 R 命名空间。第二行仅显示 DataFrame 确实在 R 中可用。我们使用的名称与原始名称不同——它是
    `seq_data`，而不是 `seq.data`。'
- en: 'Let’s do some final cleanup (for further details, see the previous recipe)
    and print the same bar chart as before:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进行最后的清理（有关更多详细信息，请参见之前的食谱），并打印出与之前相同的条形图：
- en: '[PRE29]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Additionally, the R magic system allows you to reduce code, as it changes the
    behavior of the interaction of R with IPython. For example, in the `ggplot2` code
    of the previous recipe, you do not need to use the `.png` and `dev.off` R functions,
    as the magic system will take care of this for you. When you tell R to print a
    chart, it will magically appear in your notebook or graphical console.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，R magic 系统允许您减少代码量，因为它改变了 R 与 IPython 交互的行为。例如，在前一个食谱中的 `ggplot2` 代码中，您无需使用
    `.png` 和 `dev.off` R 函数，因为 magic 系统会为您处理这些。当您告诉 R 打印图表时，它会神奇地出现在您的笔记本或图形控制台中。
- en: There’s more...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: The R magics have seemed to have changed quite a lot over time in terms of their
    interface. For example, I have updated the R code for the first edition of this
    book a few times. The current version of the DataFrame assignment returns `pandas`
    objects, which is a major change.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，R magic 的接口似乎发生了很大的变化。例如，我已经多次更新了本书第一版中的 R 代码。当前版本的 DataFrame 赋值返回 `pandas`
    对象，这是一个重大变化。
- en: See also
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'For more information, check out these links:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请查看以下链接：
- en: For basic instructions on IPython magics, see [https://ipython.readthedocs.io/en/stable/interactive/magics.xhtml](https://ipython.readthedocs.io/en/stable/interactive/magics.xhtml).
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 IPython 魔法命令的基本说明，请参见 [https://ipython.readthedocs.io/en/stable/interactive/magics.xhtml](https://ipython.readthedocs.io/en/stable/interactive/magics.xhtml)。
- en: A list of third-party extensions for IPython, including magic ones can be found
    at [https://github.com/ipython/ipython/wiki/Extensions-Index](https://github.com/ipython/ipython/wiki/Extensions-Index).
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括魔法命令在内的 IPython 第三方扩展的列表可以在 [https://github.com/ipython/ipython/wiki/Extensions-Index](https://github.com/ipython/ipython/wiki/Extensions-Index)
    找到。
