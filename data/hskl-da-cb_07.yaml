- en: Chapter 7. Statistics and Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章 统计与分析
- en: 'One core motivation to analyze big data is to find intrinsic patterns. This
    chapter contains recipes that answer questions about data deviation from the norm,
    existence of linear and quadratic trends, and probabilistic values of a network.
    Some of the most fascinating results can be uncovered by the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分析大数据的一个核心动机是寻找内在的模式。本章包含了可以回答关于数据偏离常态、线性与二次趋势的存在，以及网络的概率值等问题的配方。通过以下配方，可以揭示一些最具魅力的结果：
- en: Calculating a moving average
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算移动平均
- en: Calculating a moving median
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算移动中位数
- en: Approximating a linear regression
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逼近线性回归
- en: Approximating a quadratic regression
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逼近二次回归
- en: Obtaining the covariance matrix from samples
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从样本中获得协方差矩阵
- en: Finding all unique pairings in a list
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找列表中的所有唯一配对
- en: Using the Pearson correlation coefficient
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用皮尔逊相关系数
- en: Evaluating a Bayesian network
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估贝叶斯网络
- en: Creating a data structure for playing cards
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个扑克牌的数据结构
- en: Using a Markov chain to generate text
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用马尔科夫链生成文本
- en: Creating *n*-grams from a list
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表中创建 *n*-gram
- en: Constructing a neural network perception
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建神经网络感知
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '![Introduction](img/ch07.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/ch07.jpg)'
- en: The first two recipes deal with summarizing a series of data. For example, assume
    someone asks, "How old is everyone?". A valid response could be to enumerate through
    the age of each person, but depending on the number of people, this could take
    minutes if not hours. Instead, we can answer in terms of the average or in terms
    of the median to summarize all the age values in one simple number.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个配方处理的是总结一系列数据。例如，假设有人问：“每个人的年龄是多少？”一个有效的回答可能是列举每个人的年龄，但根据人数的不同，如果人数多，这可能需要几分钟甚至几小时。相反，我们可以通过平均值或中位数来回答，将所有年龄值总结为一个简单的数字。
- en: The next two recipes are about approximating an equation that most closely fits
    a collection of points. Given two series of coordinates, we can use a linear or
    quadratic approximation to predict other points.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个配方是关于逼近最能拟合一组点的方程。给定两组坐标，我们可以使用线性或二次逼近来预测其他点。
- en: We can detect relationships between numerical data through covariance matrices
    and Pearson correlation calculations as demonstrated in the corresponding recipes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过协方差矩阵和皮尔逊相关性计算来检测数值数据之间的关系，正如在相应的配方中展示的那样。
- en: The `Numeric.Probability.Distribution` library has many useful functions for
    deeper statistical understanding as demonstrated in the Bayesian network and playing
    cards recipes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Numeric.Probability.Distribution` 库包含许多有用的函数，能够帮助深入理解统计学，正如在贝叶斯网络和扑克牌配方中所展示的那样。'
- en: We will also use Markov chains and *n*-grams for further interesting results.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用马尔科夫链和 *n*-gram 以获得更多有趣的结果。
- en: Finally, we will create a neural network from scratch to learn a labelled set
    of data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将从零开始创建一个神经网络，来学习一个带标签的数据集。
- en: Calculating a moving average
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算移动平均
- en: Summarizing a list of numbers into one representative number can be done by
    calculating the average. The equation for the arithmetic mean is to add up all
    the values and divide by the number of values. However, if the values being summed
    over are extremely large, the total sum may overflow.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将一系列数字总结成一个代表性数字可以通过计算平均值来完成。算术平均数的公式是将所有数值相加，再除以数值的个数。然而，如果所加的数值极其庞大，最终的总和可能会溢出。
- en: In Haskell, the range for `Int` is at least from *-2^29* to *2^29-1*. Implementations
    are allowed to have an `Int` type with a larger range. If we try to naively average
    the numbers *2^29-2* and *2^29-3* by first calculating their sum, the sum may
    overflow, producing an incorrect calculation for the average.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，`Int` 的范围至少是从 *-2^29* 到 *2^29-1*。实现可以允许具有更大范围的 `Int` 类型。如果我们尝试通过先计算它们的总和来天真地计算
    *2^29-2* 和 *2^29-3* 的平均值，总和可能会溢出，从而导致平均值的计算错误。
- en: A moving average (or running average) tries to escape this drawback. We will
    use an exponential smoothing strategy, which means numbers that were seen previously
    contribute exponentially less to the value of the running mean. An exponential
    moving average reacts faster to recent data. It can be used in situations for
    detecting price oscillations or spiking a neuron in a neural network.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均（或滚动平均）试图避免这一缺陷。我们将使用指数平滑策略，这意味着之前看到的数字对当前移动均值的贡献将以指数方式递减。指数移动平均对最近的数据反应更快。它可以用于检测价格波动或在神经网络中激活神经元。
- en: 'The equation of a running mean is as follows, where **α** is a smoothening
    constant, **s[t]** is the moving average value at time *t*, and *x* is the value
    of the raw data:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均的公式如下，其中**α**是平滑常数，**s[t]**是时刻*t*的移动平均值，*x*是原始数据的值：
- en: '![Calculating a moving average](img/6331OS_07_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![计算移动平均](img/6331OS_07_01.jpg)'
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create an `input.txt` file with a list of numbers separated by lines. We will
    be computing the moving average over these numbers:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`input.txt`文件，里面是由换行符分隔的数字列表。我们将对这些数字计算移动平均值：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Create a helper function to convert the raw text input into a list of `Double`
    as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个辅助函数将原始文本输入转换为`Double`类型的列表，如下所示：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Calculate the moving average of a list of numbers using an exponential smoothing
    technique. We **hardcode** the smoothening constant `a` to be `0.95` as shown
    here:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指数平滑技术计算数字列表的移动平均值。我们将平滑常数`a`硬编码为`0.95`，如这里所示：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compute the true arithmetic mean to compare differences in the following manner:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算真实的算术平均值，以比较差异：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Print out the results of computing the moving average and arithmetic mean to
    notice how the values are not equal, but reasonably close:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出计算移动平均和算术平均的结果，看看它们的值虽然不相等，但非常接近：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will see the following output:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将看到以下输出：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There's more…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: The smoothening constant should be changed according to the fluctuation of the
    data. A small smoothening constant remembers previous values better and produces
    an average influenced by the grander structure of the data. On the other hand,
    a larger value of the smoothening constant puts superior emphasis on recent data,
    and easily forgets stale data. We should use a larger smoothening constant if
    we want our average to be more sensitive to new data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 平滑常数应该根据数据的波动来调整。较小的平滑常数能更好地记住先前的值，并产生受数据总体结构影响的平均值。另一方面，较大的平滑常数则更加关注最新的数据，并容易忘记过时的数据。如果我们希望平均值更敏感于新数据，就应使用较大的平滑常数。
- en: See also
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Another way to summarize a list of numbers is explained in the *Calculating
    a moving median* recipe.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 总结数字列表的另一种方式可以参考*计算移动中位数*的做法。
- en: Calculating a moving median
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算移动中位数
- en: The median of a list of numbers has an equal number of values less than and
    greater than it. The naive approach of calculating the median is to simply sort
    the list and pick the middle number. However, on a very large dataset, such a
    computation would be inefficient.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数字列表的中位数有相等数量的值小于和大于它。计算中位数的朴素方法是简单地对列表排序并选取中间的数字。然而，在一个非常大的数据集上，这样的计算会效率低下。
- en: Another approach of finding a moving median is to use a combination of a **minheap**
    and a **maxheap** to sort the values while running through the data. We can insert
    numbers in either heap as they are seen, and whenever needed, the median can be
    calculated by adjusting the heaps to be of equal or near equal size. When the
    heaps are of equal size, it is simple to find the middle number, which is the
    median.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种寻找移动中位数的方法是使用**最小堆**和**最大堆**的组合，在遍历数据时对值进行排序。我们可以将数字插入到任何一个堆中，并且在需要时，可以通过调整堆的大小使其保持相等或接近相等，从而计算中位数。当堆的大小相等时，找到中间的数字就很简单，这就是中位数。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a file, `input.txt`, with some numbers:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含一些数字的文件`input.txt`：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, install a library for dealing with heaps using Cabal as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cabal安装一个处理堆的库，方法如下：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to do it…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Import the heap data structure:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入堆数据结构：
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Convert the raw input as a list of numbers as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原始输入转换为如下所示的数字列表：
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Segregate the numbers in the list into the appropriate heaps. Put small numbers
    in the maxheap, and big numbers in the minheap, as shown in the following code
    snippet:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列表中的数字划分到适当的堆中。将小的数字放入最大堆，将大的数字放入最小堆，代码示例如下：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When there are no more numbers to read, start manipulating the heaps until
    both are of equal size. The median will be the number between the values in both
    heaps, as presented in the following code snippet:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当没有更多数字可以读取时，开始操作堆直到两者大小相等。中位数将是两个堆中数值之间的数字，代码示例如下：
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Test out the code in `main` as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试`main`中的代码，如下所示：
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE13]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: First, we traverse the list of numbers to build up a minheap and maxheap in
    an attempt to efficiently separate the stream of incoming numbers. Then we move
    values between the minheap and maxheap until their sizes differ by at most one
    item. The median is the extra item, or otherwise the average of the minheap and
    maxheap values.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们遍历数字列表，构建一个最小堆和最大堆，以有效地分离流入的数字。然后，我们在最小堆和最大堆之间移动值，直到它们的大小差异不超过一个项目。中位数是额外的项目，或者是最小堆和最大堆值的平均值。
- en: See also
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For summarizing a list of numbers differently, refer to the *Calculating a moving
    average* recipe.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 若要以不同方式总结一组数字，请参考*计算移动平均*的配方。
- en: Approximating a linear regression
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 近似线性回归
- en: Given a list of points, we can estimate the best fit line using a handy library,
    `Statistics.LinearRegression`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组点，我们可以使用一个方便的库`Statistics.LinearRegression`来估算最佳拟合线。
- en: 'It computes the least square difference between points to estimate the best
    fit line. An example of a linear regression of points can be seen in the following
    figure:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它计算点之间的最小二乘差异来估算最佳拟合线。以下图显示了点的线性回归示例：
- en: '![Approximating a linear regression](img/6331OS_07_02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![近似线性回归](img/6331OS_07_02.jpg)'
- en: A best-fit line is drawn through five points using linear regression
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性回归通过五个点绘制最佳拟合线
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the appropriate library using cabal as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cabal安装相应的库，如下所示：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Import the following packages:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下包：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a series of points from their coordinates, and feed it to the `linearRegression`
    function, as shown in the following code snippet:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从它们的坐标创建一系列点，并将其传递给`linearRegression`函数，如以下代码片段所示：
- en: '[PRE16]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The resulting linear equation will be as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果线性方程如下：
- en: '[PRE17]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: We can look up the source code for the `linearRegression` function from the
    `Statistics.LinearRegression` library, [http://hackage.haskell.org/package/statistics-linreg-0.2.4/docs/Statistics-LinearRegression.html](http://hackage.haskell.org/package/statistics-linreg-0.2.4/docs/Statistics-LinearRegression.html).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查找`Statistics.LinearRegression`库中的`linearRegression`函数的源代码，网址为：[http://hackage.haskell.org/package/statistics-linreg-0.2.4/docs/Statistics-LinearRegression.html](http://hackage.haskell.org/package/statistics-linreg-0.2.4/docs/Statistics-LinearRegression.html)。
- en: 'The Wikipedia article on least square approximations ([http://en.wikipedia.org/wiki/Linear_least_squares_(mathematics)](http://en.wikipedia.org/wiki/Linear_least_squares_(mathematics)))
    puts it best in writing:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科关于最小二乘近似的文章（[http://en.wikipedia.org/wiki/Linear_least_squares_(mathematics)](http://en.wikipedia.org/wiki/Linear_least_squares_(mathematics)))写得最好：
- en: '*"The least squares approach to solving this problem is to try to make as small
    as possible the sum of squares of "errors" between the right- and left-hand sides
    of these equations, that is, to find the minimum of the function"*'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“解决这个问题的最小二乘法是尽可能使右侧和左侧方程之间的“误差”平方和最小，也就是找到该函数的最小值”*'
- en: The core calculations involve finding the mean and variance of the two random
    variables, as well as the covariance between them. Thorough mathematics behind
    the algorithm is detailed in [http://www.dspcsp.com/pubs/euclreg.pdf](http://www.dspcsp.com/pubs/euclreg.pdf).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 核心计算涉及寻找两个随机变量的均值和方差，以及它们之间的协方差。算法背后的详细数学原理可以在[http://www.dspcsp.com/pubs/euclreg.pdf](http://www.dspcsp.com/pubs/euclreg.pdf)中找到。
- en: 'If we take a look at the library''s source code, we can discover the underling
    equations:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看库的源代码，我们可以发现其中的基本方程：
- en: '*α = µY - β * µX*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*α = µY - β * µX*'
- en: '*β = covar(X,Y)/σ2X*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*β = covar(X,Y)/σ²X*'
- en: '*f(x) = βx + α*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*f(x) = βx + α*'
- en: See also
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: If the data does not follow a linear trend, try the *Approximating a quadratic
    regression* recipe.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据不符合线性趋势，请尝试*近似二次回归*的配方。
- en: Approximating a quadratic regression
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 近似二次回归
- en: 'Given a collection of points, this recipe will try to find a best fit quadratic
    equation. In the following figure, the curve is a best fit quadratic regression
    of the points:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组点，本配方将尝试找到最佳拟合的二次方程。在下图中，曲线是这些点的最佳拟合二次回归：
- en: '![Approximating a quadratic regression](img/6331OS_07_03.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![近似二次回归](img/6331OS_07_03.jpg)'
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `dsp` package to use `Matrix.LU` as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`dsp`包以使用`Matrix.LU`，如下所示：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In order to perform a quadratic regression, we will use the least square polynomial
    fitting algorithm described in Wolfram MathWorld available at [http://mathworld.wolfram.com/LeastSquaresFittingPolynomial.html](http://mathworld.wolfram.com/LeastSquaresFittingPolynomial.html).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行二次回归，我们将使用 Wolfram MathWorld 上描述的最小二乘多项式拟合算法，详见[http://mathworld.wolfram.com/LeastSquaresFittingPolynomial.html](http://mathworld.wolfram.com/LeastSquaresFittingPolynomial.html)。
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 怎么做…
- en: 'Import the following packages:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下包：
- en: '[PRE19]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement the quadratic regression algorithm, as shown in the following code
    snippet:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现二次回归算法，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Test out the function as follows, using some **hardcoded** data:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试函数如下，使用一些**硬编码**数据：
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following values of the quadratic equation *3x² + 2x + 1* is printed:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三次方程式*3x² + 2x + 1*的以下值被打印：
- en: '[PRE22]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, a design matrix, `mat`, multiplied with a parameter vector
    that we desire to find produces the response vector, `vec`. We can visualize each
    of these arrays and matrices in the following equation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，设计矩阵`mat`与我们希望找到的参数向量相乘，产生响应向量`vec`。我们可以用以下方程式可视化每个数组和矩阵：
- en: '![How it works…](img/6331OS_07_04.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/6331OS_07_04.jpg)'
- en: After constructing the design matrix and the response vector, we use the `dsp`
    library to solve this matrix equation and obtain a list of coefficients for our
    polynomial.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 构建设计矩阵和响应向量后，我们使用`dsp`库解决这个矩阵方程，并获得我们多项式的系数列表。
- en: See also
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: If the data follows a linear trend, refer to the *Approximating a linear regression*
    recipe.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据遵循线性趋势，请参考*逼近线性回归*示例。
- en: Obtaining the covariance matrix from samples
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从样本获取协方差矩阵
- en: A covariance matrix is a symmetric square matrix whose elements in row *i* and
    column *j* correspond to how related they are. More specifically, each element
    is the covariance of the variables represented by its row and column. Variables
    that move together in the same direction have a positive covariance, and variables
    with the opposite behavior have a negative covariance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差矩阵是一个对称的方阵，其第*i*行和第*j*列的元素对应它们之间的相关性。更具体地说，每个元素都是其行和列所代表的变量的协方差。同向运动的变量具有正协方差，而反向运动的变量具有负协方差。
- en: 'Let''s assume we are given four sets of data of three variables as shown in
    the following table:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有三个变量的四组数据，如下表所示：
- en: '![Obtaining the covariance matrix from samples](img/6331OS_07_05.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![从样本获取协方差矩阵](img/6331OS_07_05.jpg)'
- en: Notice how **Feature 1** and **Feature 3** appear to be similar in their patterns,
    yet **Feature 1** and **Feature 2** appear to be uncorrelated. Similarly, **Feature
    2** and **Feature 3** are significantly correlated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意**特征 1**和**特征 3**在模式上看起来相似，然而**特征 1**和**特征 2**似乎不相关。同样，**特征 2**和**特征 3**显著相关。
- en: 'The covariance matrix will be a 3 x 3 symmetric matrix with the following elements:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差矩阵将是一个3 x 3对称矩阵，其元素如下：
- en: '![Obtaining the covariance matrix from samples](img/6331OS_07_06.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![从样本获取协方差矩阵](img/6331OS_07_06.jpg)'
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `hstats` library using cabal as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在 cabal 中安装`hstats`库：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, install the package by performing the following steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，通过以下步骤安装该包：
- en: Download the source code of the package from [http://hackage.haskell.org/package/hstats-0.3/hstats-0.3.tar.gz](http://hackage.haskell.org/package/hstats-0.3/hstats-0.3.tar.gz).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://hackage.haskell.org/package/hstats-0.3/hstats-0.3.tar.gz](http://hackage.haskell.org/package/hstats-0.3/hstats-0.3.tar.gz)下载包的源代码。
- en: Remove the `haskell98` dependency from the cabal file, `hstats.cabal`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 cabal 文件`hstats.cabal`中删除`haskell98`依赖项。
- en: 'In the same directory, run the following command line:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个目录下，运行以下命令行：
- en: '[PRE24]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How to do it…
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 怎么做…
- en: 'Import the `hstats` package as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示导入`hstats`包：
- en: '[PRE25]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a matrix out of a list of lists, and run the `covMatrix` function on
    it using the following code snippet:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据列表列表创建矩阵，并在其中使用以下代码片段运行`covMatrix`函数：
- en: '[PRE26]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Check the output:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查输出：
- en: '[PRE27]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice how the uncorrelated features have a zero value, as we expected.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意无关的特征值为零，正如我们预期的那样。
- en: Finding all unique pairings in a list
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在列表中查找所有唯一的配对
- en: Comparing all pairs of items is a common idiom in data analysis. This recipe
    will cover how to create a list of element pairs out of a list of elements. For
    example, if there is a list [1, 2, 3], we will create a list of every possible
    pair-ups [(1, 2), (1, 3), (2, 3)].
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 比较所有项目对是数据分析中的常见习惯用法。本食谱将介绍如何从一个元素列表中创建一个元素对列表。例如，如果有一个列表 [1, 2, 3]，我们将创建一个所有可能配对的列表
    [(1, 2), (1, 3), (2, 3)]。
- en: Notice that the order of pairing does not matter. We will create a list of unique
    tuple pairs so that we can compare each item to every other item in the list.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意配对的顺序无关紧要。我们将创建一个独特的元组对列表，以便将列表中的每个项目与其他所有项目进行比较。
- en: How it works…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Create a new file, which we call `Main.hs`, and insert the code explained in
    the following steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，我们称之为 `Main.hs`，并插入以下步骤中解释的代码：
- en: 'Import the following packages:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下包：
- en: '[PRE28]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Construct all unique pairs from a list of items as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个项目列表中构造所有独特的配对，方法如下：
- en: '[PRE29]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Print out all unique pairings of the following list:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出以下列表的所有独特配对：
- en: '[PRE30]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output will be as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE31]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See also
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: We can apply the `pairs` algorithm to the *Using the Pearson correlation coefficient*
    recipe.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `pairs` 算法应用于*使用皮尔逊相关系数*这个食谱。
- en: Using the Pearson correlation coefficient
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用皮尔逊相关系数
- en: The Pearson correlation coefficient is a number that ranges between -1.0 and
    1.0, signifying the linear relationship of two numerical series. A value of 1.0
    means strong linear correlation, a -1.0 is a strong negative correlation, and
    a 0.0 means the series is uncorrelated.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 皮尔逊相关系数是一个介于 -1.0 和 1.0 之间的数字，表示两个数值序列的线性关系。值为 1.0 表示强线性相关，-1.0 表示强负相关，0.0 表示这两个序列不相关。
- en: 'A brilliantly informative diagram was created by Kiatdd on [http://en.wikipedia.org/wiki/File:Correlation_coefficient.gif](http://en.wikipedia.org/wiki/File:Correlation_coefficient.gif),
    which is shown in the following figure:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Kiatdd 在[http://en.wikipedia.org/wiki/File:Correlation_coefficient.gif](http://en.wikipedia.org/wiki/File:Correlation_coefficient.gif)上创建了一幅非常有信息量的图表，下面是该图：
- en: '![Using the Pearson correlation coefficient](img/6331OS_07_07.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![使用皮尔逊相关系数](img/6331OS_07_07.jpg)'
- en: For example, Nick is quite a generous movie critic who consistently awards movies
    with high ratings. His friend John might be a more dramatic critic who offers
    a wider range of ratings, yet the two friends tend to always agree on which movies
    they prefer.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Nick 是一个相当慷慨的电影评论家，总是给电影打高分。他的朋友 John 可能是一个更为戏剧化的评论家，提供更广泛的评分，但这两个朋友通常总是能在喜欢的电影上达成一致。
- en: We can use the Pearson correlation coefficient to detect that there is a strong
    linear correspondence between how these two rate movies.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用皮尔逊相关系数来检测这两个人评分之间有很强的线性关系。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `hstats` library using cabal as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cabal 安装 `hstats` 库，方法如下：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Create a file with five star rating values on each line, corresponding to the
    rating given by different people.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个文件，每行包含五个星级评分，表示不同人给出的评分。
- en: 'In our example, three people have given five ratings each, using the following
    command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，三个人每人给出了五个评分，使用以下命令：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice how the first two people rate in similar trends, but the third person
    has a very different rating trend. The algorithm in this recipe will compute the
    Pearson correlation coefficient pairwise and sort the results to find the two
    people who rate most similarly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前两个人的评分趋势相似，但第三个人的评分趋势非常不同。本食谱中的算法将计算皮尔逊相关系数的成对值，并对结果进行排序，以找到评分最相似的两个人。
- en: How to do it…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Import the following packages:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下包：
- en: '[PRE34]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a function as follows to calculate the similarities from a list of lists:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下函数，以计算从列表中获得的相似度：
- en: '[PRE35]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Convert a list of `String` to a list of `Double` as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`String`列表转换为`Double`列表，方法如下：
- en: '[PRE36]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create all possible pairs from a list of items as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目列表中创建所有可能的配对，方法如下：
- en: '[PRE37]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Test the code by finding the two people who rate items most similarly to each
    other, as shown in the following code snippet:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查找评分最相似的两个人来测试代码，如以下代码片段所示：
- en: '[PRE38]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output will be as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE39]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Evaluating a Bayesian network
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估贝叶斯网络
- en: A Bayesian network is a graph of probabilistic dependencies. Nodes in the graph
    are events, and edges represent conditional dependence. We can build a network
    from prior knowledge to find out new probabilistic properties of the events.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 贝叶斯网络是一个概率依赖图。图中的节点是事件，边表示条件依赖。我们可以通过先验知识构建一个网络，从而发现事件的新概率特性。
- en: We will use Haskell's probabilistic functional programming library to evaluate
    such a network and find interesting probabilities.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Haskell的概率函数式编程库来评估此类网络并计算有趣的概率。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `probability` library using cabal as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cabal安装`probability`库，如下所示：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will be representing the following network. Internalize the following figure
    to get an intuitive grasp of the variable names:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将表示以下网络。请将以下图形内化，以直观地理解变量名称：
- en: '![Getting ready](img/6331OS_07_08.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6331OS_07_08.jpg)'
- en: Event **C** depends on events **A** and **B**. Meanwhile, events **D** and **E**
    depend on event **C**. Through the power of the Probabilistic Functional Programming
    library, in this recipe, we will find the probability of event **E** given only
    information about event **D**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 事件**C**依赖于事件**A**和**B**。同时，事件**D**和**E**依赖于事件**C**。通过概率函数式编程库的强大功能，在这个示例中，我们将找到仅根据事件**D**的信息，计算事件**E**的概率。
- en: How to do it…
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何进行…
- en: 'Import the following packages:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下包：
- en: '[PRE41]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a helper function to define conditional probabilities as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个辅助函数来定义条件概率，如下所示：
- en: '[PRE42]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define the probability of variable A, P(A) as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义变量A的概率，P(A)如下：
- en: '[PRE43]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Define the probability of variable B, P(B) as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义变量B的概率，P(B)如下：
- en: '[PRE44]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Define the probability of variable C given A and B, P(C | AB) as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义给定A和B的情况下C的概率，P(C | AB)如下：
- en: '[PRE45]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Define the probability of D given C, P(D | C) as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义在给定C的情况下D的概率，P(D | C)如下：
- en: '[PRE46]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Define the probability of E given C, P(E | C) as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义在给定C的情况下E的概率，P(E | C)如下：
- en: '[PRE47]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Define a data structure for the network as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义网络的数据结构，如下所示：
- en: '[PRE48]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Construct the network according to the preceding figure:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据前面的图形构建网络：
- en: '[PRE49]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Calculate the probability of E given D, P(E | D) as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算在给定D的情况下E的概率，P(E | D)如下：
- en: '[PRE50]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output represented as a fraction is as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出以分数表示如下：
- en: '[PRE51]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Creating a data structure for playing cards
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建扑克牌的数据结构
- en: Many probability and statistic problems are posed using playing cards. In this
    recipe, we will create a data structure and useful functions for the cards.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 许多概率和统计问题都是通过扑克牌提出的。在这个示例中，我们将创建一个数据结构和有用的函数来处理扑克牌。
- en: 'There are a total of 52 playing cards in a standard deck. Each card has one
    of the following four suits:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 标准扑克牌共有52张，每张卡牌都有以下四种花色之一：
- en: Spades
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑桃
- en: Hearts
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红桃
- en: Diamonds
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方块
- en: Clubs
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 梅花
- en: 'Also, each card has one out of 13 ranks as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每张卡牌都有13个等级中的一个，如下所示：
- en: Integers between 2 and 10 inclusive
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数范围从2到10（包括2和10）
- en: Jack
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: J（杰克）
- en: Queen
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Q（皇后）
- en: King
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K（国王）
- en: Ace
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A（王牌）
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `probability` library using cabal as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cabal安装`probability`库，如下所示：
- en: '[PRE52]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Review the sample code on the `probability` package about collections at [http://hackage.haskell.org/package/probability-0.2.4/docs/src/Numeric-Probability-Example-Collection.html](http://hackage.haskell.org/package/probability-0.2.4/docs/src/Numeric-Probability-Example-Collection.html).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 查看关于集合的`probability`包的示例代码，网址：[http://hackage.haskell.org/package/probability-0.2.4/docs/src/Numeric-Probability-Example-Collection.html](http://hackage.haskell.org/package/probability-0.2.4/docs/src/Numeric-Probability-Example-Collection.html)。
- en: The recipe is based heavily on the probability example given in the link.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例 heavily 基于链接中的概率示例。
- en: How to do it…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何进行…
- en: 'Import the following packages:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下包：
- en: '[PRE53]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a data structure of the suits on a card as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建卡牌花色的数据结构，如下所示：
- en: '[PRE54]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create a data structure for the ranks of a card as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一副牌的等级数据结构，如下所示：
- en: '[PRE55]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Define a shortcut type for a card to be a tuple of a rank and a suit as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个快捷类型，将卡牌表示为等级和花色的元组，如下所示：
- en: '[PRE56]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Describe the plain cards as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下描述普通牌：
- en: '[PRE57]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Describe the face cards as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下描述面牌：
- en: '[PRE58]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a helper function as follows to detect whether it is a face card:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个辅助函数，如下所示，用于检测是否是面牌：
- en: '[PRE59]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a helper function as follows to detect whether it is a plain card:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个辅助函数，如下所示，用于检测是否是普通牌：
- en: '[PRE60]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Define all the rank cards as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义所有等级牌如下：
- en: '[PRE61]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Define the suit cards as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义花色牌如下：
- en: '[PRE62]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create a deck of cards out of ranks and suits as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据等级和花色创建一副扑克牌，如下所示：
- en: '[PRE63]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a helper function as follows to select an item from a list for probability
    measurements:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个帮助函数如下以选择列表中的项目进行概率测量：
- en: '[PRE64]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create a function as follows to select some cards from the deck:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数如下以从牌组中选择一些卡片：
- en: '[PRE65]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create a helper function as follows to remove each of the items from a list:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个帮助函数如下，以从列表中移除每个项目：
- en: '[PRE66]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Test out the deck of cards as follows with the probability functions created:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用创建的概率函数测试卡牌组如下：
- en: '[PRE67]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The probability of selecting those two cards from the deck is as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从牌组选择这两张牌的概率如下：
- en: '[PRE68]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Using a Markov chain to generate text
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用马尔可夫链生成文本
- en: A Markov chain is a system that predicts future outcomes of a system given current
    conditions. We can train a Markov chain on a corpus of data to generate new text
    by following the states.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫链是一个系统，根据当前条件预测系统未来的结果。我们可以在数据语料库上训练马尔可夫链，通过跟随状态生成新的文本。
- en: 'A graphical representation of a chain is shown in the following figure:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 链的图形表示如下图所示：
- en: '![Using a Markov chain to generate text](img/6331OS_07_10.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![使用马尔可夫链生成文本](img/6331OS_07_10.jpg)'
- en: Node E has a 70% probability to end up on node A, and a 30% probability to remain
    in place
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 节点E以70%的概率结束在节点A，并以30%的概率保持不变
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: 'Install the `markov-chain` library using cabal as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cabal安装`markov-chain`库如下：
- en: '[PRE69]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Download a big corpus of text, and name it `big.txt`. In this recipe, we will
    be using the text downloaded from [http://norvig.com/big.txt](http://norvig.com/big.txt).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 下载一个大语料库的文本，并命名为`big.txt`。在这个示例中，我们将使用从[http://norvig.com/big.txt](http://norvig.com/big.txt)下载的文本。
- en: How to do it…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Import the following packages:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下包：
- en: '[PRE70]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Train a Markov chain on a big input of text and then run it as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在大文本输入上训练马尔可夫链，然后按以下方式运行它：
- en: '[PRE71]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can run the Markov chain and see the output as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以运行马尔可夫链并查看输出如下：
- en: '[PRE72]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works…
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The code prints our text trained by the corpus, which is fed into the Markov
    chain.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 代码打印我们由语料库训练的文本，该文本被馈送到马尔可夫链中。
- en: In the first character-by-character Markov chain, it tries to generate the next
    letter based on the previous three letters. Notice how most phrases don't make
    sense and some tokens aren't even English words.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个字符级马尔可夫链中，它试图根据前三个字母生成下一个字母。请注意，大多数短语毫无意义，甚至有些标记不是英语单词。
- en: The second Markov chain is generated word by word and only infers based on the
    previous two words. As we see, it emulates English phrases a bit more naturally.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个马尔可夫链是逐词生成的，只基于前两个词进行推断。正如我们所见，它更自然地模拟了英语短语。
- en: These texts are purely generated by evaluating probabilities.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文本纯粹通过评估概率生成。
- en: Creating n-grams from a list
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从列表创建n-gram
- en: An *n*-gram is a sequence of *n* items that occur adjacently. For example, in
    the following sequence of number [1, 2, 5, 3, 2], a possible 3-gram is [5, 3,
    2].
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*-gram是连续*n*个项目的序列。例如，在以下数字序列[1, 2, 5, 3, 2]中，一个可能的3-gram是[5, 3, 2]。'
- en: '*n*-grams are useful in computing probability tables to predict the next item.
    In this recipe, we will be creating all possible *n*-grams from a list of items.
    A Markov chain can easily be trained by using *n*-gram computation from this recipe.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*-gram在计算概率表以预测下一个项目时非常有用。在这个示例中，我们将从项目列表中创建所有可能的*n*-gram。马尔可夫链可以通过这个示例中的*n*-gram计算轻松训练。'
- en: How to do it…
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Define the *n*-gram function as follows to produce all possible *n*-grams from
    a list:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义*n*-gram函数如下以从列表生成所有可能的*n*-gram：
- en: '[PRE73]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Test it out on a sample list as follows:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在样本列表上测试如下：
- en: '[PRE74]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The printed 3-gram is as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印的3-gram如下：
- en: '[PRE75]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Creating a neural network perceptron
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个神经网络感知器
- en: A perceptron is a linear classifier that uses labelled data to converge to its
    answer. Given a set of inputs and their corresponding expected output, a perceptron
    tries to linearly separate the input values. If the input is not linearly separable,
    then the algorithm may not converge.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 感知器是一个线性分类器，使用标记数据收敛到其答案。给定一组输入及其相应的预期输出，感知器试图线性分离输入值。如果输入不是线性可分的，则算法可能不会收敛。
- en: 'In this recipe, we will deal with the following list of data:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将处理以下数据列表：
- en: '[(0,0), (0,1), (1,0), (1,1)].'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[(0,0), (0,1), (1,0), (1,1)].'
- en: 'Each item is labelled with an expected output as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都标有预期输出如下：
- en: '`(0,0)` is expected to output a `0`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(0,0)`预期输出`0`'
- en: '`(0,1)` is expected to output a `0`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(0,1)`预期输出`0`'
- en: '`(1,0)` is expected to output a `0`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(1,0)`预期输出`0`'
- en: '`(1,1)` is expected to output a `1`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(1,1)`期望输出`1`'
- en: 'Graphically, we are trying to find a line that separates these points:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 从图形上看，我们试图找到一条能够分离这些点的线：
- en: '![Creating a neural network perceptron](img/6331OS_07_11.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![创建神经网络感知器](img/6331OS_07_11.jpg)'
- en: Getting ready
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Review the concept of a perceptron by:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式回顾感知器的概念：
- en: Reading the Wikipedia article on the perceptron available at [http://en.wikipedia.org/wiki/Perceptron](http://en.wikipedia.org/wiki/Perceptron)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读关于感知器的维基百科文章，网址为[http://en.wikipedia.org/wiki/Perceptron](http://en.wikipedia.org/wiki/Perceptron)
- en: Skimming the Haskell implementation by Moresmau available at [http://jpmoresmau.blogspot.com/2007/05/perceptron-in-haskell.html](http://jpmoresmau.blogspot.com/2007/05/perceptron-in-haskell.html)
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览Moresmau提供的Haskell实现，网址为[http://jpmoresmau.blogspot.com/2007/05/perceptron-in-haskell.html](http://jpmoresmau.blogspot.com/2007/05/perceptron-in-haskell.html)
- en: How to do it…
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Import `replicateM`, `randomR`, and `getStdRandom` for handling random number
    generation in our neural network as follows:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`replicateM`、`randomR`和`getStdRandom`来处理神经网络中的随机数生成，如下所示：
- en: '[PRE76]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Define types to help describe the variables fed into each helper method as
    follows:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类型来帮助描述传入每个辅助方法的变量，如下所示：
- en: '[PRE77]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Create a function to generate an output value of a neuron that takes in a series
    of inputs, corresponding weights, and a threshold value. The neuron fires a `1`
    if the dot product of the weight vector with the input vector is above the threshold,
    and `0` otherwise, as presented in the following code snippet:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来生成神经元的输出值，该函数接受一系列输入、相应的权重和一个阈值。如果权重向量与输入向量的点积大于阈值，则神经元触发输出`1`，否则输出`0`，如以下代码片段所示：
- en: '[PRE78]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create a function to adjust weights of a neuron given expected and actual results.
    The weights are updated using a learning rule, as presented in the following code
    snippet:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，根据期望结果和实际结果调整神经元的权重。权重使用学习规则进行更新，如以下代码片段所示：
- en: '[PRE79]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Step through one iteration of the perceptron cycle to update weights as follows.
    For this recipe, assume each neuron has a threshold of 0.2:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步进一次感知器循环来更新权重，如下所示。对于这个示例，假设每个神经元的阈值为0.2：
- en: '[PRE80]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create a helper function as follows to compute weight changes per step:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个辅助函数如下，计算每步的权重变化：
- en: '[PRE81]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Run through the steps using `epoch` until the weights converge. Weight convergence
    is detected simply by noticing the first instance when weights no longer significantly
    change values. This is presented in the following code snippet:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`epoch`步骤，直到权重收敛。权重收敛通过注意到权重首次不再显著变化来检测。这在以下代码片段中有所展示：
- en: '[PRE82]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Initialize a weight vector as follows:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化权重向量，如下所示：
- en: '[PRE83]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Test the perceptron network to separate an AND Boolean structure as follows:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试感知器网络以分离一个与运算的布尔结构，如下所示：
- en: '[PRE84]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'A valid output may be:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有效的输出可能是：
- en: '[PRE85]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We can verify that this output is correct since the weights sum to a value greater
    than the threshold value of 0.2, while each weight value individually is less
    than the threshold of 0.2\. Therefore, the output will trigger only when the input
    is (1, 1) as desired.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证该输出是正确的，因为权重的总和大于阈值0.2，而每个权重值本身都小于0.2。因此，输出将仅在输入为(1, 1)时触发，正如所期望的那样。
