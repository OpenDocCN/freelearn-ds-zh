- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Smart File Uploading – Advanced Techniques for Professional Web Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能文件上传 – 专业Web应用程序的高级技术
- en: At this point of our journey, we have almost acquired all the skills we need
    to implement and deploy well-working and nice-looking web applications. Anyway,
    our web apps still have a quite “naive” aspect and are a little bit far from professional
    ones. Starting with this chapter, we will deal with some advanced techniques that
    will help make our products look more complete and professional.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到了这一步，我们几乎掌握了实现和部署高效、美观的Web应用程序所需的所有技能。尽管如此，我们的Web应用程序仍然有些“天真”，离专业应用还有一定距离。从本章开始，我们将处理一些高级技术，帮助使我们的产品看起来更加完善和专业。
- en: Let’s start with the file uploader, a widget that we already used in the *Covid-19
    Detection Tool* app when we were asked to upload an X-ray image of the chest.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从文件上传器开始，这是我们在*Covid-19检测工具*应用程序中已经使用过的小部件，当时我们需要上传胸部X光图像。
- en: What we want to do now is move the file uploader to another level, deeply customizing
    it to automatically detect the type of file we are going to open and adopt the
    appropriate actions. This kind of behavior gives our web applications a very professional
    standing and makes them easy to use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想做的是将文件上传器提升到一个新的层次，深入定制它，自动检测我们要打开的文件类型，并采取适当的操作。这种行为赋予我们的Web应用程序非常专业的形象，并使其易于使用。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要主题：
- en: Understanding the customized features of the file uploader
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解文件上传器的定制功能
- en: Creating a suitable file uploader for web apps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Web应用程序创建合适的文件上传器
- en: Simplifying web apps with smart components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用智能组件简化Web应用程序
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we’ll use the following libraries, packages, and tools:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下库、包和工具：
- en: Sublime Text
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sublime Text
- en: Python 3
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3
- en: '`pipenv`'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipenv`'
- en: Streamlit
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Streamlit
- en: '`docx2txt`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docx2txt`'
- en: '`pdfplumber`'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pdfplumber`'
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/57674ee5b5c58769120051cfb466f4b4d658c20c/Chapter12](https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/57674ee5b5c58769120051cfb466f4b4d658c20c/Chapter12).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/57674ee5b5c58769120051cfb466f4b4d658c20c/Chapter12](https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/57674ee5b5c58769120051cfb466f4b4d658c20c/Chapter12)。
- en: Understanding the customized features of the file uploader
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解文件上传器的定制功能
- en: 'Uploading a file is a simple task. There are several ways to do it, and these
    different approaches have different effects on the so-called *user experience*:
    the way users perceive the application itself. Moreover, a better-implemented
    uploading feature can speed up the entire application, making things easier for
    the users. Let’s imagine that we want to upload a file containing text. It could
    be a `.txt` file, so a plain text file, but also a `.docx` file, a Microsoft Word
    file, or even a `.pdf` file. One approach is to ask the customer, *what kind of
    file do you need to upload (.txtx, .docx, .pdf)?* If the user replies `.txt`,
    the application will launch the `file_uploader` widget customized for this file
    format; if the answer is `.docx`, the `file_uploader` widget customized for Microsoft
    Word will be executed, and so on. This kind of approach works perfectly, but it’s
    a little bit too complex.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上传文件是一个简单的任务。实现方式有很多种，不同的方法会对所谓的*用户体验*产生不同的影响：用户对应用程序本身的感知方式。此外，更好地实现上传功能可以加速整个应用程序，使用户的操作更加便捷。假设我们要上传一个包含文本的文件。它可能是一个`.txt`文件，即纯文本文件，也可能是`.docx`文件，Microsoft
    Word文件，甚至是`.pdf`文件。一种方法是询问客户，*你需要上传哪种文件（.txtx，.docx，.pdf）？* 如果用户回答`.txt`，应用程序将启动为此文件格式定制的`file_uploader`小部件；如果答案是`.docx`，则会执行为Microsoft
    Word定制的`file_uploader`小部件，依此类推。这个方法效果很好，但有点过于复杂。
- en: What if the user updated a file and the web application recognized its type
    automatically without human intervention?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户更新了文件，而Web应用程序能在没有人工干预的情况下自动识别文件类型，怎么办？
- en: Let’s learn how to implement this feature according to both approaches, one
    requiring information from the user and another that’s completely automated.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何根据两种方法实现这一功能，一种需要用户提供信息，另一种则完全自动化。
- en: Creating a new virtual environment
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的虚拟环境
- en: 'First, we’ll create a new virtual environment dedicated to this chapter. So,
    follow these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个专门用于本章的新虚拟环境。请按照以下步骤进行：
- en: Create a new folder and call it `FileUploader`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件夹，并命名为`FileUploader`。
- en: Next, move to the newly created folder and, once inside it, as usual, write
    `pipenv shell` to create the virtual environment.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入新创建的文件夹，一旦进入，像往常一样输入`pipenv shell`以创建虚拟环境。
- en: 'The instructions are shown in *Figure 12**.1*:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些指令如*图12.1*所示：
- en: '![Figure 12.1: Creating a new virtual environment dedicated to this chapter](img/B21147_12_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1：为本章创建新的虚拟环境](img/B21147_12_01.jpg)'
- en: 'Figure 12.1: Creating a new virtual environment dedicated to this chapter'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：为本章创建新的虚拟环境
- en: 'After that, the only library we need is Streamlit, so let’s type the following:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们唯一需要的库是Streamlit，所以我们输入以下内容：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After a few seconds, our environment will be equipped with the latest Streamlit
    version that’s available.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 几秒钟后，我们的环境将配备最新的Streamlit版本。
- en: 'As usual, before we start coding, we have to create an empty Python file, which
    is a very easy operation. We can do this by writing the following instruction:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，在开始编写代码之前，我们需要创建一个空的Python文件，这是一项非常简单的操作。我们可以通过输入以下指令来完成：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `app.py` is the name of our file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`app.py`是我们文件的名称。
- en: We can open the `app.py` file with our favorite IDE, such as Sublime Text.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用自己喜欢的IDE（例如Sublime Text）打开`app.py`文件。
- en: Building the app skeleton
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建应用程序骨架
- en: 'When we have an empty file, the best starting option is to always use the *skeleton*
    we adopted in the two web applications we implemented previously. So, we can import
    the libraries – in this case, just streamlit – and then define a main function
    containing the menu. The menu for this chapter’s app is quite light in that it
    just contains two voices: **Dropfiles** and **About**.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拥有一个空文件时，最佳的起始选项总是使用我们之前在两个Web应用程序中采用的*骨架*。因此，我们可以导入库——在这种情况下，仅是streamlit——然后定义一个包含菜单的主函数。本章应用程序的菜单非常简洁，仅包含两个选项：**Dropfiles**和**About**。
- en: 'In the following figure, we can see how short the skeleton we are using for
    this specific case is:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们可以看到用于此特定情况的骨架是多么简洁：
- en: '![Figure 12.2: The skeleton of our app](img/B21147_12_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2：我们的应用程序骨架](img/B21147_12_02.jpg)'
- en: 'Figure 12.2: The skeleton of our app'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：我们的应用程序骨架
- en: 'Here’s a breakdown of the code shown in *Figure 12**.2*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*图12.2*中展示的代码的详细说明：
- en: On *line 1*, we import the library (here, `streamlit`), while on *line 4*, we
    define the `main` function – that is, the function containing the business logic
    of our app.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第1行*，我们导入了库（此处为`streamlit`），而在*第4行*，我们定义了`main`函数——即包含我们应用程序业务逻辑的函数。
- en: On *line 5*, we have a list named `menu` containing the values of the web application
    menu (the functions this web application can offer).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第5行*，我们有一个名为`menu`的列表，包含了Web应用程序菜单中的值（这个Web应用程序可以提供的功能）。
- en: On *line 6*, we create a select box starting from the menu list in the sidebar.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第6行*，我们从侧边栏的菜单列表开始创建一个下拉框。
- en: On *lines 8* and *13*, we add an `if` clause that enters the proper code to
    execute according to the selection that was performed in the selectbox on *line
    6*.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第8行*和*第13行*，我们添加了一个`if`语句，根据在*第6行*的下拉框中选择的选项，进入适当的代码执行。
- en: 'With that, we have the skeleton of our app. Now, we can write the following
    instruction in the terminal:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们已经完成了应用程序的骨架。现在，我们可以在终端中输入以下指令：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, we can start the web application and see it in our browser:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们可以启动Web应用程序并在浏览器中查看：
- en: '![Figure 12.3: First execution of our new web app](img/B21147_12_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3：首次执行我们的新Web应用](img/B21147_12_03.jpg)'
- en: 'Figure 12.3: First execution of our new web app'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3：首次执行我们的新Web应用
- en: As we can see, in the sidebar, there is a selectbox offering the two options
    in the menu.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在侧边栏中，有一个下拉框提供了菜单中的两个选项。
- en: Let’s focus on the **Dropfile** voice of the menu.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于菜单中的**Dropfile**选项。
- en: Creating a radio button for the app menu
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为应用程序菜单创建单选按钮
- en: 'We can use a radio button to let the user indicate what kind of file they would
    like to upload. Let’s add the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用单选按钮让用户选择他们想要上传的文件类型。我们来添加以下代码：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this way, the file selection is stored in a variable named `file_selection`.
    So far, our app looks as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，文件选择会存储在一个名为`file_selection`的变量中。到目前为止，我们的应用程序如下所示：
- en: '![Figure 12.4: Selecting the file type with radio buttons](img/B21147_12_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4：使用单选按钮选择文件类型](img/B21147_12_04.jpg)'
- en: 'Figure 12.4: Selecting the file type with radio buttons'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4：使用单选按钮选择文件类型
- en: 'Once the user selects an option, we are ready to open `file_uploader` using
    the file type as the selected option. The following code can be adopted in this
    case:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户选择了一个选项，我们就准备使用所选文件类型来打开`file_uploader`。在这种情况下，可以采用以下代码：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Quite easily, after uploading the file (with the `txt` type), we can check that
    the file is not null, read it using `utf-8` encoding, and visualize it on the
    screen. If the uploaded file is null, we just print a warning on the screen stating
    **TXT File** **Fetching Problem...**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易，在上传文件（类型为`txt`）后，我们可以检查文件是否为空，使用`utf-8`编码读取文件，并将其显示在屏幕上。如果上传的文件为空，我们只需在屏幕上打印一个警告，显示**TXT
    文件** **获取问题...**。
- en: '*Figure 12**.5* shows the code in the IDE:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12**.5* 显示了在 IDE 中的代码：'
- en: '![Figure 12.5: Uploading a .txt file](img/B21147_12_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5：上传 .txt 文件](img/B21147_12_05.jpg)'
- en: 'Figure 12.5: Uploading a .txt file'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5：上传 .txt 文件
- en: 'When we move to the browser, something interesting happens. Even if we have
    three different files containing text in our directory – that is, `''txt''`, `''docx''`,
    and `''pdf''` – since we specify `txt` as the type, the file uploader just sees
    and can open the `.``txt` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们切换到浏览器时，会发生一些有趣的事情。即使我们的目录中有三个不同的文本文件——即`'txt'`、`'docx'`和`'pdf'`——由于我们指定了`txt`作为文件类型，文件上传工具只能看到并打开`.txt`文件：
- en: '![Figure 12.6: In the directory on the left, there are three different files,
    but we can only open the .txt file](img/B21147_12_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6：在左侧的目录中，有三种不同的文件，但我们只能打开 .txt 文件](img/B21147_12_06.jpg)'
- en: 'Figure 12.6: In the directory on the left, there are three different files,
    but we can only open the .txt file'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6：在左侧的目录中，有三种不同的文件，但我们只能打开 .txt 文件
- en: 'At this point, to manage other file types, we should write more or less the
    same code we used for the `txt` type but also specify the different types. So,
    the code can evolve into something like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，为了管理其他文件类型，我们应该编写与处理`txt`类型时几乎相同的代码，但还需要指定不同的文件类型。因此，代码可以演变成如下所示：
- en: '![Figure 12.7: Asking the user for the type of file](img/B21147_12_07.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7：询问用户文件类型](img/B21147_12_07.jpg)'
- en: 'Figure 12.7: Asking the user for the type of file'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7：询问用户文件类型
- en: The code in *Figure 12**.7* contains a couple of `pass` calls for `.docx` and
    `.pdf` files. If you want to complete the related functions, you must import the
    proper library and read the content of the files.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12**.7*中的代码包含了一些`pass`调用，用于处理`.docx`和`.pdf`文件。如果你想完成相关功能，必须导入适当的库并读取文件内容。'
- en: 'The real point here is that when approaching file uploading in this way, even
    if the code works very well technically, we are forced to do a couple of operations
    we don’t like that much:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重点是，当以这种方式处理文件上传时，即使代码在技术上运行得很好，我们也不得不执行一些我们不太喜欢的操作：
- en: Asking the user about the type of file at the beginning
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始时询问用户文件类型
- en: Repeating (we just copy and paste) a lot of code that is redundant
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复（我们只是复制和粘贴）很多冗余代码
- en: Now that we’ve explored this solution, let’s try to implement something much
    more elegant and cleaner that can automatically read the type of file, without
    asking the user.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了这个解决方案，让我们尝试实现一些更优雅、更简洁的方法，能够自动读取文件类型，而不需要询问用户。
- en: Creating a suitable file uploader for web apps
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 web 应用程序创建一个合适的文件上传器
- en: As you can imagine, this time, we are not using the radio button. Instead, we
    are directly uploading the files. So, referring to *Figure 12**.7*, let’s comment
    all the code between *lines 11* and *31*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想，这次我们没有使用单选按钮。相反，我们直接上传文件。因此，参考*图 12**.7*，让我们注释掉*第 11 行*到*第 31 行*之间的所有代码。
- en: 'Immediately in the subheading, on *line 10*, we can add `file_uploader`, this
    time including all three types:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻在子标题中，在*第 10 行*，我们可以添加`file_uploader`，这次包括所有三种类型：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When we try to upload the file from the browser, this time in our directory,
    we will see all three types of files and be able to select one of them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试从浏览器上传文件时，这时在我们的目录中，我们将看到所有三种类型的文件，并且能够选择其中一个。
- en: 'As we did on *line 15* in the code presented in *Figure 12**.5*, we can check
    that the file is not null by writing the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*图 12**.5*中的*第 15 行*所做的，我们可以通过编写以下代码来检查文件是否为空：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After this `if` clause, we must get the details of the file. We need these details
    to understand which type of file we selected and how to manage it. By using the
    `raw_file_text` variable, which contains the file we uploaded, we can use three
    methods named `name`, `type`, and `size` to collect the details we need.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`if`语句之后，我们必须获取文件的详细信息。我们需要这些信息来理解我们选择的是哪种类型的文件，以及如何管理它。通过使用包含我们上传文件的`raw_file_text`变量，我们可以使用三个方法，分别是`name`、`type`和`size`，来收集我们需要的详细信息。
- en: 'These details will be put into a dictionary; we are calling it `file_details`.
    Let’s see it in the code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些详细信息将被放入一个字典中，我们称之为`file_details`。让我们在代码中看到它：
- en: '![Figure 12.8: The code for file upload and file detail detection](img/B21147_12_08.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8: 文件上传与文件详细信息检测的代码](img/B21147_12_08.jpg)'
- en: 'Figure 12.8: The code for file upload and file detail detection'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '图 12.8: 文件上传与文件详细信息检测的代码'
- en: 'This is the result in the browser:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是浏览器中的结果：
- en: '![Figure 12.9: File upload and file detail detection in the browser](img/B21147_12_09.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9: 浏览器中的文件上传与文件详细信息检测](img/B21147_12_09.jpg)'
- en: 'Figure 12.9: File upload and file detail detection in the browser'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '图 12.9: 浏览器中的文件上传与文件详细信息检测'
- en: As we can see, in the directory, we have all three types of files and can select
    any one of them since the information about the file details has been intercepted
    correctly. In the case of the `.txt` file, we got the correct filename, the `text/plain`
    type, and its size.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，在目录中，我们有三种类型的文件，并且可以选择其中任何一个，因为文件的详细信息已经正确截取。在`.txt`文件的情况下，我们得到了正确的文件名、`text/plain`类型及其大小。
- en: 'Let’s see what type we get for the `.docx` and `.pdf` files. The `.docx` file,
    as shown here, has a very long type file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`.docx`和`.pdf`文件的类型。这里显示的`.docx`文件具有一个非常长的类型：
- en: '![Figure 12.10: The .docx file](img/B21147_12_10.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10: .docx 文件](img/B21147_12_10.jpg)'
- en: 'Figure 12.10: The .docx file'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '图 12.10: .docx 文件'
- en: 'Meanwhile, the `.pdf` file has a shorter name:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，`.pdf`文件的名字较短：
- en: "![Figure 12.11: The .pdf \uFEFFfile](img/B21147_12_11.jpg)"
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.11: .pdf 文件](img/B21147_12_11.jpg)'
- en: 'Figure 12.11: The .pdf file'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '图 12.11: .pdf 文件'
- en: 'These three different types of files are all we need to manage file uploading
    automatically. To open the `.pdf` and `.docx` files, we need to install the proper
    libraries (`pdfplumber` and `docx2txt`). So, please write the following command
    in your terminal:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种不同类型的文件是我们管理文件自动上传所需的全部内容。要打开`.pdf`和`.docx`文件，我们需要安装合适的库（`pdfplumber`和`docx2txt`）。因此，请在终端中键入以下命令：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first package takes care of `.pdf` files, while the second takes care of
    `.``docx` files.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个包处理`.pdf`文件，而第二个包处理`.docx`文件。
- en: 'Once the installation is finished, we must import these libraries into our
    `app.py` file by typing the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们必须将这些库导入到`app.py`文件中，方法是键入以下内容：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With that, we have everything we need. So, referring to *Figure 12**.8*, continuing
    from *line 15* of our code, we can write the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有了所有需要的信息。因此，参考*图 12.8*，从*第 15 行*继续，我们可以编写如下代码：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code checks that the type of file we uploaded is `text/plain`.
    In this case, it reads it, stores its content in a variable named `raw_text`,
    and prints a label on the screen saying just **Text from TXT file**. This check
    happens in a try cycle; so, in case of an error, a simple exception will be printed
    on the screen.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码检查我们上传的文件类型是否为`text/plain`。在这种情况下，它读取文件内容，将其存储在名为`raw_text`的变量中，并在屏幕上显示标签“**来自TXT文件的文本**”。这个检查发生在一个try循环中，因此，如果发生错误，屏幕上会打印一个简单的异常。
- en: The same code we used for the `.txt` file has to be used for the other kind
    of files; the only differences are the type of the files and the libraries needed
    to read the content of the files (the two libraries we just imported – that is,
    `pdfplumber` and `docx2txt`).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`.txt`文件所使用的代码也适用于其他类型的文件；唯一的区别是文件类型和读取文件内容所需的库（即我们刚刚导入的`pdfplumber`和`docx2txt`）。
- en: 'Let’s look at the code shown in *Figure 12**.12*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下*图 12.12*中展示的代码：
- en: '![Figure 12.12: The code that automatically uploads the files](img/B21147_12_12.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.12: 自动上传文件的代码](img/B21147_12_12.jpg)'
- en: 'Figure 12.12: The code that automatically uploads the files'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '图 12.12: 自动上传文件的代码'
- en: On *line 27*, we used `pdfplumber` because the file type is `"application/pdf"`,
    while on *line 35*, we used `docx2txt` because the file to open is a `.``docx`
    file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 27 行*，我们使用了`pdfplumber`，因为文件类型是`"application/pdf"`，而在*第 35 行*，我们使用了`docx2txt`，因为需要打开的是`.docx`文件。
- en: Finally, on *line 42*, we automatically print the contents of the opened file
    on the screen.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*第42行*，我们自动将打开的文件内容打印到屏幕上。
- en: 'This is the result in the case of a `.docx` file; please note the very long
    name of the file type:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在`.docx`文件情况下的结果；请注意文件类型的非常长的名称：
- en: '![Figure 12.13: A .docx file is automatically recognized and opened](img/B21147_12_13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图12.13：.docx文件被自动识别并打开](img/B21147_12_13.jpg)'
- en: 'Figure 12.13: A .docx file is automatically recognized and opened'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：.docx文件被自动识别并打开
- en: 'The application behavior with a `.pdf` file is the same:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pdf`文件的应用行为是相同的：'
- en: '![Figure 12.14: A .pdf file is automatically recognized and opened](img/B21147_12_14.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图12.14：.pdf文件被自动识别并打开](img/B21147_12_14.jpg)'
- en: 'Figure 12.14: A .pdf file is automatically recognized and opened'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：.pdf文件被自动识别并打开
- en: 'So far, we have learned two ways of uploading files: asking the user about
    the file type and making the file uploading process automated. Both approaches
    are valid, and which one you should choose depends on the use case. Simplifying
    our web apps with smart components should always be the preferred solution.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了两种文件上传方式：一种是询问用户文件类型，另一种是让文件上传过程自动化。两种方法都是有效的，选择哪种取决于具体情况。使用智能组件简化网页应用应该始终是首选方案。
- en: Simplifying web apps with smart components
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用智能组件简化网页应用
- en: So far in this chapter, we have learned about the principles of effective web
    application design. Now, we can move toward the user experience, which should
    always be simple, intuitive, and aesthetically pleasing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了有效的网页应用设计原理。现在，我们可以开始关注用户体验，用户体验应该始终是简单、直观且美观的。
- en: The approach with the radio button, from a functional point of view, works very
    well but makes things a little bit too complex because it requires the user’s
    intervention at the beginning and draws an ugly radio button on the screen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 带有单选按钮的方法，从功能角度来看，效果很好，但使得事情变得有点复杂，因为它需要用户在开始时进行干预，并在屏幕上显示一个难看的单选按钮。
- en: The other approach is very neat and extremely clean because just a file uploader
    widget is present on the screen and the user can select the file by just clicking
    on it (or using drag and drop) without any other kind of intervention.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法非常整洁且极其干净，因为屏幕上仅显示一个文件上传小部件，用户只需点击（或使用拖放）即可选择文件，无需任何其他干预。
- en: This is possible because the web app intercepts the file type property and uses
    it to open the file and read its content by selecting the proper library.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为网页应用拦截了文件类型属性，并利用它打开文件，通过选择合适的库来读取文件内容。
- en: This kind of approach is quite smart and delineates the difference between an
    application made by a rookie and an application that looks very professional.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法相当聪明，区分了一个新手开发的应用和一个看起来非常专业的应用之间的差异。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we learned how to manage file uploading in different ways
    and according to different approaches: first, by specifying the file type at any
    time to trigger the proper function, and second by making the file type detection
    automatic and seamless.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过不同方式和不同方法管理文件上传：第一种是随时指定文件类型以触发适当的功能，第二种是使文件类型检测自动化并无缝进行。
- en: While the first approach involves the user, the second one makes our application
    usage very smooth.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法涉及用户，而第二个方法使我们的应用使用非常流畅。
- en: In the next chapter, we will continue exploring advanced features and solutions
    to make our web applications more professional.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探索先进的功能和解决方案，以使我们的网页应用更加专业。
