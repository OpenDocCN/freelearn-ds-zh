- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Analyzing and Visualizing Time Series Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析和可视化时间序列数据
- en: In the previous chapter, we learned where to obtain time series datasets, as
    well as how to manipulate time series data using pandas, handle missing values,
    and so on. Now that we have the processed time series data, it’s time to understand
    the dataset, which data scientists call **Exploratory Data Analysis** (**EDA**).
    It is a process by which the data scientist analyzes the data by looking at aggregate
    statistics, feature distributions, visualizations, and so on to try and uncover
    patterns in the data that they can leverage in modeling. In this chapter, we will
    look at a couple of ways to analyze a time series dataset, a few specific techniques
    that are tailor-made for time series, and review some of the visualization techniques
    for time series data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何获取时间序列数据集，以及如何使用pandas操作时间序列数据、处理缺失值等。现在我们已经获得了处理过的时间序列数据，是时候理解数据集了，数据科学家将此过程称为**探索性数据分析**（**EDA**）。这是一个数据科学家通过查看聚合统计信息、特征分布、可视化等，分析数据以发现其中的模式并在建模中加以利用的过程。在本章中，我们将探索几种分析时间序列数据集的方法，介绍一些专门为时间序列设计的技术，并回顾一些时间序列数据的可视化技术。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Components of a time series
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列的组成部分
- en: Visualizing time series data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化时间序列数据
- en: Decomposing a time series
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解时间序列
- en: Detecting and treating outliers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测和处理异常值
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to set up the **Anaconda** environment following the instructions
    in the *Preface* of the book to get a working environment with all the libraries
    and datasets required for the code in this book. Any additional library will be
    installed while running the notebooks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要按照书中*前言*中的说明设置**Anaconda**环境，以便获得一个包含本书所需所有库和数据集的工作环境。任何额外的库将在运行笔记本时自动安装。
- en: You will need to run the `02-Preprocessing_London_Smart_Meter_Dataset.ipynb`
    notebook from `Chapter02` folder.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要运行`Chapter02`文件夹中的`02-Preprocessing_London_Smart_Meter_Dataset.ipynb`笔记本。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Time-Series-Forecasting-with-Python-2E/tree/main/notebooks/Chapter03](https://github.com/PacktPublishing/Modern-Time-Series-Forecasting-with-Python-2E/tree/main/notebooks/Chapter03).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Modern-Time-Series-Forecasting-with-Python-2E/tree/main/notebooks/Chapter03](https://github.com/PacktPublishing/Modern-Time-Series-Forecasting-with-Python-2E/tree/main/notebooks/Chapter03)找到。
- en: Components of a time series
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列的组成部分
- en: 'Before we start analyzing and visualizing time series, we need to understand
    the structure of a time series. Any time series can contain some or all of the
    following components:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始分析和可视化时间序列之前，我们需要了解时间序列的结构。任何时间序列都可以包含以下部分中的一些或全部内容：
- en: Trend
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 趋势
- en: Seasonal
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 季节性
- en: Cyclical
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 周期性
- en: Irregular
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不规则性
- en: These components can be mixed in different ways, but two very commonly assumed
    ways are *additive* (*Y* = *Trend* + *Seasonal* + *Cyclical* + *Irregular*) and
    *multiplicative* (*Y* = *Trend* * *Seasonal* * *Cyclical* * *Irregular*), where
    *Y* is the time series.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成分可以以不同的方式混合在一起，但两种最常见的假设方式是*加法模型*（*Y* = *趋势* + *季节性* + *周期性* + *不规则*）和*乘法模型*（*Y*
    = *趋势* * *季节性* * *周期性* * *不规则*），其中*Y*表示时间序列。
- en: The trend component
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 趋势成分
- en: 'The **trend** is a long-term change in the mean of a time series. It is the
    smooth and steady movement of a time series in a particular direction. When the
    time series moves upward, we say there is an *upward or increasing trend*, while
    when it moves downward, we say there is a *downward or decreasing trend*. At the
    time of writing, if we think about the revenue of Tesla over the years, as shown
    in the following figure, we can see that it has been increasing consistently for
    the last few years:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**趋势**是时间序列平均值的长期变化。它是时间序列沿特定方向平稳而稳定的运动。当时间序列向上移动时，我们称之为*上升或增长趋势*，而当它向下移动时，我们称之为*下降或减少趋势*。在撰写本文时，如果我们回顾特斯拉过去几年的收入，如下图所示，我们可以看到它在过去几年里一直在持续增长：'
- en: '![Figure 3.1 – Tesla’s revenue in millions of USD ](img/B22389_03_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 特斯拉的收入（以百万美元计）](img/B22389_03_01.png)'
- en: 'Figure 3.1: Tesla’s revenue in millions of USD'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：特斯拉的收入（以百万美元计）
- en: Looking at the preceding figure, we can say that Tesla’s revenue is having an
    increasing trend. The trend doesn’t need to be linear; it can also be non-linear.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的图表，我们可以说特斯拉的收入呈现增长趋势。趋势不需要是线性的，它也可以是非线性的。
- en: The seasonal component
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 季节性成分
- en: 'When a time series exhibits regular, repetitive, up-and-down fluctuations,
    we call that **seasonality**. For instance, retail sales typically shoot up during
    the holidays, especially during Christmas in Western countries. Similarly, electricity
    consumption peaks during the summer months in the tropics and the winter months
    in colder countries. In all these examples, you can see a specific up-and-down
    pattern repeating every year. Another example is sunspots, as shown in the following
    figure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当时间序列表现出规律的、重复的上下波动时，我们称之为**季节性**。例如，零售销售通常在节假日期间激增，尤其是在西方国家的圣诞节期间。类似地，热带地区的电力消费在夏季高峰，而寒冷地区则在冬季达到高峰。在这些例子中，你可以看到每年重复出现的特定上下波动模式。另一个例子是太阳黑子，如下图所示：
- en: '![Figure 3.2 – Number of sunspots from 1749 to 2017 ](img/B22389_03_02.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 1749 到 2017 年的太阳黑子数量](img/B22389_03_02.png)'
- en: 'Figure 3.2: Number of sunspots from 1749 to 2017'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：1749 到 2017 年的太阳黑子数量
- en: As you can see, sunspots peak every 11 years.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，太阳黑子每11年达到一次高峰。
- en: The cyclical component
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 周期性成分
- en: The **cyclical** component is often confused with seasonality, but it stands
    apart due to a very subtle difference. Like seasonality, the cyclical component
    also exhibits a similar up-and-down pattern around the trend line, but the time
    over which this cycle moves isn’t fixed and is subject to a bit of variation around
    a general time frame. A good example of this is economic recession, which happens
    over a 10-year cycle. However, this doesn’t happen like clockwork; sometimes,
    it can be fewer or more than every 10 years.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**周期性**成分常常与季节性混淆，但由于一个微妙的差异，它们是不同的。像季节性一样，周期性成分也表现出围绕趋势线的相似上下波动模式，但这个周期的时间并不是固定的，并且会有一定的变化。例如，经济衰退通常会在一个10年的周期内发生。然而，这种现象并非如时钟般准确；有时它可能在10年内发生一次，也可能更多或更少。'
- en: The irregular component
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不规则成分
- en: This component is left after removing the trends, seasonality, and cyclicity
    from a time series. Traditionally, this component is considered *unpredictable*
    and is also called the *residual*, *error term*, *or noise term*. In common classical
    statistics-based models, the point of any “model” is to capture all the other
    components to the point that the only part that is not captured is the irregular
    component.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个成分是从时间序列中去除趋势、季节性和周期性后的残余部分。传统上，这个成分被认为是*不可预测*的，也被称为*残差*、*误差项*，或*噪声项*。在常见的基于经典统计的模型中，任何“模型”的目标是捕捉其他所有成分，直到只剩下无法捕捉的非规律成分。
- en: In modern machine learning, we do not consider this component entirely unpredictable.
    We try to capture parts of this component by using exogenous variables. For instance,
    the irregular component of retail sales may be explained by the different promotional
    activities they run. When we have this additional information, the “unpredictable”
    component starts to become predictable again. But no matter how many additional
    variables you add to the model, there will always be some component, which is
    the irreducible error, that is left behind. This is the part of the time series
    which can never be explained no matter how strong the model is or how much additional
    information you add to the model.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代机器学习中，我们并不认为这个成分完全不可预测。我们尝试通过使用外生变量来捕捉这个成分的一部分。例如，零售销售的非规律成分可能是由他们进行的不同促销活动来解释的。当我们有了这些附加信息后，这个“不可预测”的成分开始变得可以预测。但是，无论你向模型中添加多少额外的变量，总会有一些成分，它是无法简化的误差，依然被遗留下来。这部分时间序列是无法通过任何模型解释的，无论模型有多强大，或者你向模型中添加多少额外的信息。
- en: Now that we know what the different components of a time series are, let’s see
    how we can visualize them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了时间序列的不同成分，让我们看看如何可视化它们。
- en: Visualizing time series data
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化时间序列数据
- en: In *Chapter 2*, *Acquiring and Processing Time Series Data*, we learned how
    to prepare a data model as a first step toward analyzing a new dataset. If preparing
    a data model is like approaching someone you like and making that first contact,
    then EDA is like dating that person. At this point, you have the dataset, and
    you are trying to get to know them, trying to figure out what makes them tick,
    what the person likes and dislikes, and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第二章*，*获取和处理时间序列数据*中，我们学习了如何准备数据模型，作为分析新数据集的第一步。如果准备数据模型像是接近你喜欢的人并进行首次接触，那么EDA就像是与这个人约会。此时，你拥有了数据集，正在试图了解它们，试图弄清楚它们的运作方式，喜欢和不喜欢什么，等等。
- en: EDA often employs visualization techniques to uncover patterns, spot anomalies,
    form and test hypotheses, and so on. Spending some time understanding your dataset
    will help you a lot when you are trying to squeeze out every last bit of performance
    from the models. You may understand what sort of features you must create, what
    kind of modeling techniques should be applied, and so on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: EDA（探索性数据分析）通常采用可视化技术来发现模式、识别异常、形成并验证假设等。花些时间理解你的数据集，在你试图从模型中榨取每一分性能时会帮助你很多。你可能会明白需要创建什么样的特征、应该应用哪种建模技术等。
- en: In this chapter, we will cover a few visualization techniques that are well
    suited for time series datasets.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍几种适用于时间序列数据集的可视化技术。
- en: '**Notebook alert**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**笔记本提醒**：'
- en: To follow along with the complete code for visualizing time series, use the
    `01-Visualizing_Time_Series.ipynb` notebook in the `Chapter03` folder.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 若要跟随完整的时间序列可视化代码，请使用 `Chapter03` 文件夹中的 `01-Visualizing_Time_Series.ipynb` 笔记本。
- en: Line charts
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线图
- en: 'This is the most basic and common visualization that is used for understanding
    a time series. We just plot the time on the *x*-axis and the time series value
    on the *y*-axis. Let’s see what it looks like if we plot one of the households
    from our dataset:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最基本和常见的可视化方法，用于理解时间序列。我们只需将时间绘制在 *x* 轴上，将时间序列值绘制在 *y* 轴上。让我们看看如果我们绘制数据集中某个家庭的数据会是什么样子：
- en: '![Figure 3.3 – Line plot of household MAC000193 ](img/B22389_03_03.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 家庭 MAC000193 的线图](img/B22389_03_03.png)'
- en: 'Figure 3.3: Line plot of household MAC000193'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：家庭 MAC000193 的线图
- en: 'When you have a long time series with high variation, as we have, the line
    plot can get a bit chaotic. One of the options to get a macro view of the time
    series in terms of trends and movement is to plot a smoothed version of the time
    series. Let’s see what a rolling monthly average of the time series looks like:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个变化较大的长期时间序列时，就像我们所拥有的，线图可能会显得有些混乱。获得时间序列的宏观趋势和变化的一种选择是绘制平滑版本的时间序列。让我们看看时间序列的滚动月平均值是什么样子：
- en: '![Figure 3.4 – Rolling monthly average energy consumption of household MAC000193
    ](img/B22389_03_04.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 家庭 MAC000193 的滚动月均能耗](img/B22389_03_04.png)'
- en: 'Figure 3.4: Rolling monthly average energy consumption of household MAC000193'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：家庭 MAC000193 的滚动月均能耗
- en: We can see the macro patterns much more clearly now. The seasonality is clear—the
    series peaks in winter and troughs during summer. If you think about it critically,
    it makes sense. This is London we are talking about, and the energy consumption
    would be higher during the winter because of lower temperatures and subsequent
    heating system usage.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更清楚地看到宏观模式。季节性很明显——该序列在冬季达到峰值，夏季则处于最低谷。如果你仔细思考，这也很有道理。我们在谈论的是伦敦，冬季因为低温和随之而来的取暖系统使用，能耗会更高。
- en: For a household in the tropics, for example, the pattern may be reversed, with
    the peaks coming in summer when air conditioners come into play.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于热带地区的家庭，模式可能会反转，能耗的峰值出现在夏季，当空调开始使用时。
- en: 'Another use for the line chart is to visualize two or more time series together
    and investigate any correlations between them. In our case, let’s try plotting
    the temperature along with the energy consumption and see whether the hypothesis
    we have about temperature influencing energy consumption holds good:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 线图的另一个用途是同时可视化两个或多个时间序列，并调查它们之间的相关性。在我们的例子中，试着将温度与能耗一起绘制，看看我们关于温度影响能耗的假设是否成立：
- en: '![Figure 3.5 – Temperature and energy consumption (zoomed-in plot at the bottom)
    ](img/B22389_03_05.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 温度和能耗（底部的放大图）](img/B22389_03_05.png)'
- en: 'Figure 3.5: Temperature and energy consumption (zoomed-in plot at the bottom)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：温度和能耗（底部的放大图）
- en: Here, we can see a clear negative correlation in yearly resolution between energy
    consumption and temperature. Winters show higher energy consumption on a macro
    scale. We can also see the daily patterns that are loosely correlated with temperature,
    but maybe because of other factors such as people coming back home after work
    and so on.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到能耗和温度之间在年度分辨率上的明显负相关。冬季在宏观上表现为更高的能耗。我们还可以看到与温度松散相关的日常模式，但这也许是因为其他因素，例如人们下班后回家等。
- en: There are a few other visualizations that are more suited to bringing out seasonality
    in a time series. Let’s take a look.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他的可视化方法，更适合突出时间序列中的季节性。让我们来看看。
- en: Seasonal plots
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 季节性图
- en: A **seasonal plot** is very similar to a line plot, but the key difference here
    is that the *x*-axis denotes the “seasons,” the *y*-axis denotes the time series
    value, and the different seasonal cycles are represented in different colors or
    line types. For instance, the yearly seasonality at a monthly resolution can be
    depicted with months on the *x*-axis and different years in different colors.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**季节性图**与折线图非常相似，但关键的区别在于，*x*轴表示“季节”，*y*轴表示时间序列值，且不同的季节性周期使用不同的颜色或线型表示。例如，按月分辨率展示的年度季节性可以用月份表示在*x*轴上，并且用不同的颜色表示不同的年份。'
- en: 'Let’s see what this looks like for our household in question. Here, we have
    plotted the average monthly energy consumption across multiple years:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们家庭的情况。这里，我们绘制了多年来的平均月度能源消耗：
- en: '![Figure 3.6 – Seasonal plot at a monthly resolution ](img/B22389_03_06.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 按月分辨率绘制的季节性图](img/B22389_03_06.png)'
- en: 'Figure 3.6: Seasonal plot at a monthly resolution'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：按月分辨率绘制的季节性图
- en: We can instantly see the appeal in this visualization because it lets us visualize
    the seasonality pattern easily. We can see that the consumption goes down in the
    summer months and we can also see that it happens consistently across multiple
    years. In the two years that we have data for, we can see that in October, the
    behavior in 2013 slightly deviated from 2012\. Maybe there is something else that
    can help us explain this difference—what about temperature?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即看到这种可视化的吸引力，因为它让我们能够轻松地看到季节性模式。我们可以看到，夏季的消费量下降，并且我们还可以看到这种情况在多个年份中始终如一。在我们拥有数据的这两年中，我们可以看到，2013年10月的行为与2012年略有不同。也许还有其他因素可以帮助我们解释这一差异——比如温度呢？
- en: 'We can also plot the seasonal plots with another variable of interest, such
    as the temperature:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将季节性图与其他感兴趣的变量一起绘制，比如温度：
- en: '![Figure 3.7 – Seasonal plot at a monthly resolution (energy consumption versus
    temperature) ](img/B22389_03_07.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 按月分辨率绘制的季节性图（能源消耗与温度对比）](img/B22389_03_07.png)'
- en: 'Figure 3.7: Seasonal plot at a monthly resolution (energy consumption versus
    temperature)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：按月分辨率绘制的季节性图（能源消耗与温度对比）
- en: Notice October? In October 2013, the temperature stayed warmer for one month
    more, hence why the energy consumption pattern was slightly different from last
    year.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到10月了吗？2013年10月，气温持续较高长达一个月，因此能源消费模式与去年略有不同。
- en: We can plot these kinds of plots at other resolutions as well, such as hourly
    seasonality. All we need to do is calculate the average consumption for each hour
    and day of the month and plat them with hours on the *x*-axis and different days
    of the month in different colors (*Figure 3.8* (top)). But when there are too
    many seasonal cycles to be plotted, it increases visual clutter. An alternative
    to a seasonal plot is a seasonal box plot.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在其他分辨率下绘制这些图形，比如按小时划分的季节性。我们所需要做的就是计算每个小时和每个月天数的平均消费量，并将它们绘制在*x*轴上显示小时数，使用不同的颜色表示每月的不同天数（*图3.8*（上图））。但是，当季节性周期过多时，图形会变得杂乱无章。季节性图的一个替代方法是季节性箱型图。
- en: Seasonal box plots
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 季节性箱型图
- en: 'Instead of plotting the different seasonal cycles in different colors or line
    types, we can represent them as a box plot (*Figure 3.8* (bottom)). This instantly
    clears up the clutter in the plot. The additional benefit you get from this representation
    is that it lets us understand the variability across seasonal cycles:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将不同的季节性周期表示为箱型图（*图3.8*（下图）），而不是用不同的颜色或线型绘制不同的季节性周期。这样可以立即清除图中的杂乱信息。通过这种表示方法，你还可以理解季节性周期之间的变动性：
- en: '![Figure 3.8 – Seasonal plot (top) and seasonal box plot (bottom) at an hourly
    resolution ](img/B22389_03_08.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 按小时分辨率绘制的季节性图（上图）和季节性箱型图（下图）](img/B22389_03_08.png)'
- en: 'Figure 3.8: Seasonal plot (top) and seasonal box plot (bottom) at an hourly
    resolution'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：按小时分辨率绘制的季节性图（上图）和季节性箱型图（下图）
- en: Here, we can see that the seasonal plot at this resolution is too cluttered
    to make out the pattern and the variation across seasonal cycles. However, the
    seasonal box plot is much more informative. The horizontal line in the box tells
    us about the median, the box is the **interquartile range** (**IQR**), and the
    points that are marked are the outliers. By looking at the medians, we can see
    that the peak consumption occurs from 9 A.M. onward. But the variability is also
    higher from 9 A.M. If you plot separate box plots for each week, for example,
    you will see that the patterns are slightly different on Sundays (additional visualizations
    are in the associated notebook).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这个分辨率下的季节性图像过于杂乱，难以分辨模式和跨季节周期的变化。然而，季节性箱型图提供了更多的信息。箱型中的水平线表示中位数，盒子表示**四分位数范围**（**IQR**），而标记的点是异常值。通过观察中位数，我们可以看到消费的高峰发生在上午9点之后。但从上午9点开始，变化性也变得更大。如果你为每周绘制单独的箱型图，比如说，你会发现周日的模式稍有不同（更多可视化内容请参考关联的笔记本）。
- en: However, there is another visualization that lets you inspect these patterns
    along two dimensions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一种可视化方法可以让你从两个维度检查这些模式。
- en: Calendar heatmaps
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日历热图
- en: Instead of having separate box plots or separate line charts for each week of
    the day, it would be useful if we could condense that information into a single
    plot. This is where **calendar heatmaps** come in. A heatmap visualization uses
    color gradients to represent data values, with different colors indicating varying
    intensities or frequencies. A calendar heatmap uses colored cells in a rectangular
    block to represent the information. Along the two sides of the rectangle, we can
    find two separate granularities of time, such as month and year. In each intersection,
    the cell is colored relative to the value of the time series at that intersection.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与其为每周的每一天绘制单独的箱型图或线图，不如将这些信息浓缩成一张图。这时，**日历热图**就派上用场了。热图可视化使用颜色渐变表示数据值，不同的颜色表示不同的强度或频率。日历热图使用矩形块中的着色单元格来表示信息。在矩形的两侧，我们可以看到两种不同粒度的时间单位，如月份和年份。在每个交点处，单元格的颜色根据该交点处时间序列的值进行着色。
- en: 'Let’s look at the hourly average energy consumption across the different weekdays
    in a calendar heatmap (refer to the color images file:[https://packt.link/gbp/9781835883181](https://packt.link/gbp/9781835883181)):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不同工作日的每小时平均能源消耗在日历热图中的表现（请参见颜色图像文件：[https://packt.link/gbp/9781835883181](https://packt.link/gbp/9781835883181)）：
- en: '![Figure 3.9 – A calendar heatmap for energy consumption ](img/B22389_03_09.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 能源消耗的日历热图](img/B22389_03_09.png)'
- en: 'Figure 3.9: A calendar heatmap for energy consumption'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：能源消耗的日历热图
- en: From the color scale on the right, we know that lighter colors mean higher values.
    We can see how Monday to Saturday have similar peaks—that is, once in the morning
    and once in the evening. However, Sunday has a slightly different pattern, with
    higher consumption throughout the day.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从右侧的颜色比例尺中，我们知道较浅的颜色表示较高的值。我们可以看到从周一到周六的高峰是相似的——也就是早上和晚上各一次。然而，周日的模式略有不同，全天的消费较高。
- en: So far, we’ve reviewed a lot of visualizations that can bring out seasonality.
    Now, let’s look at a visualization for inspecting autocorrelation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经回顾了许多能够突显季节性的可视化。现在，让我们看看用于检查自相关的可视化方法。
- en: Autocorrelation plot
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自相关图
- en: If correlation indicates the strength and direction of the linear relationship
    between two variables, autocorrelation is the correlation between the values of
    a time series in successive periods. Most time series have a heavy dependence
    on the value in the previous period, and this is a critical component in a lot
    of the forecasting models we will be seeing as well.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相关性表示两个变量之间线性关系的强度和方向，那么自相关则是时间序列中连续周期值之间的相关性。大多数时间序列对前一个周期的值有较强的依赖关系，而这也是我们将要看到的许多预测模型中的一个关键组成部分。
- en: Something such as ARIMA (which we will briefly look at in *Chapter 4*, *Setting
    a Strong Baseline Forecast*) is built on autocorrelation. So, it’s always helpful
    to just visualize and understand how strong the dependence on previous time steps
    is.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于ARIMA（我们将在*第4章*，*设定强基准预测*中简要介绍）的方法是基于自相关的。因此，直观地展示并理解对前一时间步的依赖强度总是有帮助的。
- en: 'This is where **autocorrelation plots** come in handy. In such plots, we have
    the different lags (*t-1*, *t-2*, *t-3*, and so on) on the *x*-axis and the correlations
    between *t* and the different lags on the *y*-axis. In addition to autocorrelation,
    we can also look at **partial autocorrelation**, which is very similar to autocorrelation
    but with one key difference: partial autocorrelation removes any indirect correlation
    that may be present before presenting the correlations. Let’s look at an example
    to understand this. If *t* is the current time step, let’s assume *t-1* is highly
    correlated to *t*. So, by extending this logic, *t-2* will be highly correlated
    with *t-1* and because of this correlation, the autocorrelation between *t* and
    *t-2* would be high. However, partial autocorrelation corrects this and extracts
    the correlation, which can be purely attributed to *t-2* and *t*.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**自相关图**派上用场的地方。在这些图中，我们将不同的滞后（*t-1*、*t-2*、*t-3*等）放在* x *轴上，将*t*与不同滞后的相关性放在*y*轴上。除了自相关，我们还可以查看**部分自相关**，它与自相关非常相似，但有一个关键的不同点：部分自相关在展示相关性之前，会去除任何可能存在的间接相关性。让我们通过一个例子来理解这一点。如果*t*是当前时间步长，我们假设*t-1*与*t*有很强的相关性。那么根据这个逻辑，*t-2*会与*t-1*高度相关，由于这种相关性，*t*与*t-2*之间的自相关性会很高。然而，部分自相关纠正了这一点，并提取了这种相关性，它可以纯粹归因于*t-2*和*t*。
- en: One thing we need to keep in mind is that the autocorrelation and partial autocorrelation
    analysis works best if the time series is stationary (we will talk about stationarity
    in detail in *Chapter 6*, *Feature Engineering for Time Series Forecasting*).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住的一点是，自相关和部分自相关分析在时间序列平稳时效果最佳（我们将在*第6章*《时间序列预测的特征工程》中详细讨论平稳性）。
- en: '**Best practice**:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：'
- en: There are many ways of making a series stationary, but a quick and dirty way
    is to use seasonal decomposition and just pick the residuals. It should be devoid
    of trends and seasonality, which are the major drivers of non-stationarity in
    a time series. But as we will see later in this book, this is not a foolproof
    method of making a series stationary in the truest sense.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以使一个序列变得平稳，但一个快速且简便的方法是使用季节性分解，并直接选择残差。它应该没有趋势和季节性，这些是时间序列中非平稳性的主要驱动因素。但正如我们在本书后面将看到的，这并不是将序列真正意义上使其平稳的万无一失的方法。
- en: 'Now, let’s see what these plots look like for our household from the dataset
    (after making it stationary):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这些图表在我们家庭数据集中的表现（在使其平稳后）：
- en: '![Figure 3.10 – Autocorrelation and partial autocorrelation plots ](img/B22389_03_10.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 自相关和部分自相关图](img/B22389_03_10.png)'
- en: 'Figure 3.10: Autocorrelation and partial autocorrelation plots'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：自相关和部分自相关图
- en: Here, we can see that the first lag (*t-1*) has the most influence and that
    its influence quickly drops down to close to zero in the partial autocorrelation
    plot. This means that the energy consumption of a day is highly correlated with
    the energy consumption the day before.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到第一个滞后（*t-1*）具有最大的影响，而且在部分自相关图中，它的影响迅速降到接近零。这意味着一天的能源消耗与前一天的能源消耗高度相关。
- en: If you’ve seen such charts before, you would have seen an envelope over this
    showing the confidence intervals as a guide to selecting significant autocorrelations.
    While that is a good thumb of rule, it’s not included here because I don’t want
    you to use it as a rule. The relevance of the confidence intervals depends on
    some assumptions (normality and so on), which may not be satisfied all the time,
    especially in real-world use cases.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前见过这样的图表，你可能会看到图表上有一个包络线，显示置信区间，作为选择显著自相关的指南。虽然这是一个很好的经验法则，但这里没有包含，因为我不希望你将其作为规则。置信区间的相关性取决于一些假设（如正态性等），这些假设并不总是成立，尤其是在实际使用场景中。
- en: With that, we’ve looked at the different components of a time series and learned
    how to visualize a few of them. Now, let’s see how we can decompose a time series
    into its components.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经看到了时间序列的不同组成部分，并学习了如何可视化其中的一些。现在，让我们看看如何将一个时间序列分解为它的组成部分。
- en: Decomposing a time series
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解时间序列
- en: 'Seasonal decomposition is the process by which we deconstruct a time series
    into its components—typically, trend, seasonality, and residuals. The general
    approach for decomposing a time series is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 季节性分解是将时间序列分解为其组成部分的过程——通常是趋势、季节性和残差。分解时间序列的一般方法如下：
- en: '**Detrending**: Here, we estimate the **trend component** (which is the smooth
    change in the time series) and remove it from the time series, giving us a **detrended
    time series**.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**去趋势化**：在这里，我们估算**趋势成分**（即时间序列中的平滑变化）并将其从时间序列中移除，从而得到**去趋势化的时间序列**。'
- en: '**Deseasonalizing**: Here, we estimate the seasonality component from the detrended
    time series. After removing the seasonal component, what is left is the residual.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**去季节化**：在这里，我们从去趋势化的时间序列中估算季节性成分。去除季节性成分后，剩下的是残差。'
- en: Let’s discuss them in detail.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论一下它们。
- en: Detrending
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 去趋势化
- en: '**Detrending** can be done in a few different ways. Two popular ways of doing
    it are by using **moving averages** and **locally estimated scatterplot smoothing**
    (**LOESS**) **regression**.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**去趋势化**可以通过几种不同的方式进行。两种常用的方法是使用**移动平均**和**局部估计散点图平滑**（**LOESS**）**回归**。'
- en: Moving averages
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动平均
- en: One of the easiest ways of estimating trends is by using a moving average along
    the time series. It can be seen as a window that is moved along the time series
    in steps, and at each step, the average of all the values in the window is recorded.
    This moving average is a smoothed-out time series and helps us estimate the slow
    change in a time series, which is the trend. The downside is that the technique
    is quite noisy. Even after smoothing out a time series using this technique, the
    extracted trend will not be smooth; it will be noisy. The noise should ideally
    reside with the residuals and not the trend (see the trend line shown in *Figure
    3.13*).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 估算趋势的最简单方法之一是使用沿时间序列的移动平均。它可以看作是一个在时间序列上滑动的窗口，每一步记录窗口中所有值的平均值。这个移动平均是一个平滑的时间序列，有助于我们估算时间序列中的缓慢变化，即趋势。缺点是这种技术相当嘈杂。即使使用这种技术平滑时间序列，提取的趋势仍然不会是平滑的，它会带有噪声。理想情况下，噪声应当存在于残差中，而不是趋势中（参见*图3.13*中的趋势线）。
- en: LOESS
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LOESS
- en: The **LOESS** algorithm, which is also called *locally weighted polynomial regression*,
    was developed by Bill Cleveland from the 70s to the 90s. It is a non-parametric
    method that is used to fit a smooth curve onto a noisy signal. We use an ordinal
    variable that moves between the time series as the independent variable and the
    time series signal as the dependent variable.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**LOESS**算法，也称为*局部加权多项式回归*，是由比尔·克利夫兰（Bill Cleveland）在70年代至90年代间开发的。它是一种非参数方法，用于将平滑曲线拟合到噪声信号上。我们使用一个在时间序列中移动的序列变量作为自变量，将时间序列信号作为因变量。'
- en: For each value in the ordinal variable, the algorithm uses a fraction of the
    closest points and estimates a smoothed trend using only those points in a weighted
    regression. The weights in the weighted regression are the closest points to the
    point in question. This is given the highest weight and it decays as we move farther
    away from it. This gives us a very effective tool for modeling the smooth changes
    in the time series (trend) (see the trend line shown in *Figure 3.14*).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个序列变量中的值，算法使用最接近的点的一部分，并仅使用这些点进行加权回归，以估算平滑的趋势。这些加权回归中的权重是与当前点最接近的点。距离当前点越远，权重越小，最接近的点给予最高的权重。这为我们提供了一个非常有效的工具，用于建模时间序列中的平滑变化（趋势）（参见*图3.14*中的趋势线）。
- en: Deseasonalizing
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 去季节化
- en: The seasonality component can also be estimated in a few different ways. The
    two most popular ways of doing this are by using period-adjusted averages or a
    Fourier series.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 季节性成分也可以通过几种不同的方式进行估算。最常见的两种方法是使用周期调整后的平均值或傅里叶级数。
- en: Period adjusted averages
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 周期调整后的平均值
- en: This is a pretty simple technique wherein we calculate a seasonality index for
    each period in the expected cycle by taking the average values of all such periods
    over all the cycles. To make that clear, let’s look at a monthly time series where
    we expect an annual seasonality in this time series. So, the up-and-down pattern
    would complete a full cycle in 12 months, or the seasonality period is 12\. In
    other words, every 12 points in the time series have similar seasonal components.
    So, we take the average of all January values as the period-adjusted average for
    January. In the same way, we calculate the period average for all 12 months. At
    the end of the exercise, we have 12 period averages, and we can also calculate
    an *average* period average. Now, we can make these period averages into an index
    by either subtracting the average of all period averages from each of the period
    averages (for additive) or dividing the average of all period averages from each
    of the period averages (multiplicative).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相当简单的技术，我们通过取所有周期中各期的平均值来计算预期周期中的季节性指数。为了更清楚地说明这一点，我们来看一个月度时间序列，假设我们预期该时间序列具有年季节性。那么，起伏模式将在12个月内完成一个完整周期，或者季节性周期为12。换句话说，时间序列中的每12个数据点具有相似的季节性成分。因此，我们取所有1月数据的平均值作为1月的周期调整平均值。同样，我们计算所有12个月的周期平均值。在整个过程结束时，我们得到12个周期平均值，还可以计算一个*平均*周期平均值。现在，我们可以通过从每个周期平均值中减去所有周期平均值的平均值（加法型）或将每个周期平均值除以所有周期平均值的平均值（乘法型）来将这些周期平均值转化为一个指数。
- en: Fourier series
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 傅里叶级数
- en: In the late 1700s, Joseph Fourier, a mathematician and physicist, while studying
    heat flow, realized something profound—*any* periodic function can be broken down
    into a simple series of sine and cosine waves. Let’s dwell on that for a minute.
    Any periodic function, no matter the shape, curve, or absence of it, or how wildly
    it oscillates around the axis, can be broken down into a series of sine and cosine
    waves.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在18世纪末，数学家和物理学家约瑟夫·傅里叶在研究热流时，意识到了一个深刻的事实——*任何*周期性函数都可以分解为一系列简单的正弦波和余弦波。让我们稍微停下来思考一下。任何周期性函数，无论它的形状如何、是否有曲线，或者它如何围绕轴线剧烈振荡，都可以分解为一系列正弦波和余弦波。
- en: '**Additional information**:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加信息**：'
- en: For the more mathematically inclined, the original theory proposes to decompose
    any periodic function into an integral of exponentials. Using Euler’s identity,
    ![](img/B22389_03_001.png), we can consider them as a summation of sine and cosine
    waves. The *Further reading* section contains a few resources if you want to delve
    deeper and explore related concepts, such as the Fourier transform.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数学较为敏感的人来说，原始理论提出将任何周期性函数分解为指数函数的积分。利用欧拉公式，![](img/B22389_03_001.png)，我们可以将其视为正弦波和余弦波的总和。*进一步阅读*部分包含了一些资源，如果你想更深入地探讨并了解相关概念，比如傅里叶变换。
- en: 'It is this property that we use to extract seasonality from a time series because
    seasonality is a periodic function, and any periodic function can be approximated
    by a combination of sine and cosine waves. The sine-cosine form of a Fourier series
    is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这种特性，我们用它来从时间序列中提取季节性，因为季节性是一个周期性函数，而任何周期性函数都可以通过正弦波和余弦波的组合来近似。傅里叶级数的正弦-余弦形式如下：
- en: '![](img/B22389_03_002.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22389_03_002.png)'
- en: Here, *S*[N] is the *N*-term approximation of the signal, *S*. Theoretically,
    when *N* is infinite, the resulting approximation is equal to the original signal.
    *P* is the maximum length of the cycle.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*S*[N] 是信号 *S* 的 *N* 项近似值。从理论上讲，当 *N* 趋近于无穷大时，所得近似值等于原始信号。*P* 是周期的最大长度。
- en: We can use this Fourier series, or a few terms from the Fourier series, to model
    our seasonality. In our application, *P* is the maximum length of the cycle we
    are trying to model. For instance, for a yearly seasonality for monthly data,
    the maximum length of the cycle (*P*) is 12\. *x* would be an ordinal variable
    that increases from *1* to *P*. In this example, *x* would be *1*, *2*, *3*, …
    *12*. Now, with these terms, all that is left to do is find *a*[n] and *b*[n],
    which we can do by regressing on the signal.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个傅里叶级数，或者从傅里叶级数中提取几个项，来建模我们的季节性。在我们的应用中，*P* 是我们试图建模的周期的最大长度。例如，对于月度数据的年度季节性，周期的最大长度
    (*P*) 为12。*x* 是一个从 *1* 到 *P* 的序数变量。在这个例子中，*x* 将是 *1*, *2*, *3*, … *12*。现在，利用这些项，剩下的就是找到
    *a*[n] 和 *b*[n]，我们可以通过对信号进行回归来完成这个过程。
- en: We’ve seen that with the right combination of Fourier terms, we can replicate
    any signal. But the question is, should we? What we want to learn from data is
    a generalized seasonality profile that does well with unseen data as well. So,
    we use *N* as a hyperparameter to extract as complex a signal as we want from
    the data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，通过适当组合傅里叶项，我们可以复制任何信号。但问题是，我们是否应该这么做？我们希望从数据中学到的是一个通用的季节性特征，这个特征在未见过的数据上也能表现良好。因此，我们使用
    *N* 作为超参数，从数据中提取我们所需的复杂信号。
- en: 'This is a good time to brush up on your trigonometry and remember what sine
    and cosine waves look like. The first Fourier term (*n=1*) is your age-old sine
    and cosine waves, which complete one full cycle in the maximum cycle length (*P*).
    As we increase n, we get sine and cosine waves that have multiple cycles in the
    maximum cycle length (*P*). This can be seen in the following figure:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是复习三角函数的好时机，回想一下正弦波和余弦波的形态。第一个傅里叶项 (*n=1*) 就是你熟悉的正弦波和余弦波，它们在最大周期长度 (*P*) 内完成一个完整的周期。随着
    n 的增加，我们得到的正弦波和余弦波将在最大周期长度 (*P*) 内完成多个周期。下图中可以看到这一点：
- en: '![Figure 3.11 – Cosine Fourier terms (n=1, 2, 3) ](img/B22389_03_11.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 余弦傅里叶项 (n=1, 2, 3)](img/B22389_03_11.png)'
- en: 'Figure 3.11: Cosine Fourier terms (n = 1, 2, 3)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11：余弦傅里叶项 (n = 1, 2, 3)
- en: 'The sine and cosine waves are complementary to each other, as shown in the
    following figure:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦波和余弦波是互为补充的，如下图所示：
- en: '![Figure 3.12 – Sine and cosine Fourier terms (n=1) ](img/B22389_03_12.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 正弦和余弦傅里叶项 (n=1)](img/B22389_03_12.png)'
- en: 'Figure 3.12: Sine and cosine Fourier terms (n = 1)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12：正弦和余弦傅里叶项 (n = 1)
- en: Now, let’s see how we can use this in practice.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在实践中使用它。
- en: Implementations
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现方法
- en: '**Notebook alert**:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**笔记本提示**：'
- en: To follow along with the complete code for decomposing time series, use the
    `02-Decomposing_Time_Series.ipynb` notebook in the `Chapter03` folder.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随完整的时间序列分解代码，可以使用 `Chapter03` 文件夹中的 `02-Decomposing_Time_Series.ipynb` 笔记本。
- en: There are four implementations that we will cover here in the following subsections.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将介绍四种实现方法，接下来的小节中将详细讲解。
- en: seasonal_decompose from statsmodel
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 statsmodel 的 seasonal_decompose
- en: '`statsmodels.tsa.seasonal` has a function called `seasonal_decompose`. This
    is an implementation that uses moving averages for the trend component and period-adjusted
    averages for the seasonal component. It supports both additive and multiplicative
    modes of decomposition. However, it doesn’t tolerate missing values. Let’s see
    how we can use it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`statsmodels.tsa.seasonal` 有一个名为 `seasonal_decompose` 的函数。这个实现使用移动平均来处理趋势成分，使用周期调整的平均值来处理季节性成分。它支持加法模式和乘法模式的分解。然而，它不能处理缺失值。让我们来看看如何使用它：'
- en: '[PRE0]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A few key parameters to keep in mind are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一些需要记住的关键参数如下：
- en: '`period` is the seasonal period you expect the pattern to repeat.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`period` 是你预期模式重复的季节周期。'
- en: '`model` takes `additive` or `multiplicative` as an argument to determine the
    type of decomposition.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model` 需要一个 `additive` 或 `multiplicative` 的参数来确定分解类型。'
- en: '`filt` takes in an array that is used as the weights in the moving average
    (convolution, to be specific). It can also be used to define the window over which
    we need our moving average. We can increase it to smooth out the trend component
    to some extent.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filt` 接受一个数组，作为移动平均（卷积，具体来说）的权重。它也可以用来定义计算移动平均所需的窗口。我们可以增加窗口大小，以在一定程度上平滑趋势成分。'
- en: '`extrapolate_trend` is a parameter that we can use to extend the trend component
    to both sides to avoid the missing values that are generated when applying the
    moving average filter.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extrapolate_trend` 是一个参数，我们可以用它将趋势成分扩展到两侧，以避免在应用移动平均滤波器时生成的缺失值。'
- en: '`two_sided` is a parameter that lets us define how the moving averages are
    calculated. If `True`, which it is by default, the moving average is calculated
    using the past as well as future values because the window for the moving average
    is centered. If `False`, it only uses past values to calculate the moving average.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`two_sided` 是一个参数，允许我们定义如何计算移动平均。如果设置为 `True`（默认值），则移动平均是基于过去和未来的值计算的，因为移动平均的窗口是居中的。如果设置为
    `False`，则只使用过去的值来计算移动平均。'
- en: 'Let’s see how well we have been able to decompose one of the time series in
    our datasets. We used `period=7*48` to capture a weekday-hourly profile and `filt=np.repeat(1/(30*48),
    30*48)` to make the moving average over 30 days with uniform weights:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何能够分解数据集中一个时间序列。我们使用 `period=7*48` 来捕捉工作日的小时数据轮廓，并使用 `filt=np.repeat(1/(30*48),
    30*48)` 对30天内的数据进行均匀权重的移动平均：
- en: '![Figure 3.13 – Seasonal decomposition using statsmodels ](img/B22389_03_13.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 使用 statsmodels 进行季节性分解](img/B22389_03_13.png)'
- en: 'Figure 3.13: Seasonal decomposition using statsmodels'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13：使用 statsmodels 进行季节性分解
- en: We can’t see the seasonal pattern because it’s too small in the grand scale
    of the plot. The associated notebook has zoomed-in plots to help you understand
    the seasonal pattern. Even with a large window (for example, 20 days) of smoothing,
    the trend still has some noise in it. We may be able to reduce this a bit more
    by increasing the window, but there is a better alternative, as we will see now.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看不到季节性模式，因为它在整个图表的尺度下太小了。相关的笔记本有放大的图表，帮助你理解季节性模式。即使使用较大的平滑窗口（例如 20 天），趋势仍然有一些噪音。我们可能通过增加窗口来进一步减少这些噪音，但现在有一个更好的选择，我们马上就会看到。
- en: Seasonality and trend decomposition using LOESS (STL)
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 LOESS 进行季节性和趋势分解（STL）
- en: As we saw earlier, LOESS is much more suited for trend estimation. **STL** is
    an implementation that uses LOESS for trend estimation and period averages for
    seasonality. Although `statsmodels` has an implementation, we have reimplemented
    it for better performance and flexibility.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，LOESS 更适合用于趋势估计。**STL** 是一种使用 LOESS 进行趋势估计，使用周期平均值进行季节性分解的实现。尽管 `statsmodels`
    已经有一个实现，我们重新实现了它，以获得更好的性能和灵活性。
- en: 'This implementation can be found in this book’s GitHub repository under `src.decomposition.seasonal.py`.
    It expects a `pandas` DataFrame or series with a datetime index as an input. Let’s
    see how we can use this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现可以在本书的 GitHub 仓库中的 `src.decomposition.seasonal.py` 找到。它期望输入一个带有日期时间索引的 `pandas`
    DataFrame 或系列。让我们看看如何使用这个：
- en: '[PRE1]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The key parameters here are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键参数如下：
- en: '`seasonality_period` is the seasonal period you expect the pattern to repeat.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seasonality_period` 是你期望模式重复的季节性周期。'
- en: '`model` takes `additive` or `multiplicative` as an argument to determine the
    type of decomposition.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model` 以 `additive` 或 `multiplicative` 作为参数来确定分解类型。'
- en: '`lo_frac` is the fraction of the data that will be used to fit the LOESS regression.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lo_frac` 是用于拟合 LOESS 回归的样本数据的比例。'
- en: '`lo_delta` is the fractional distance within which we use linear interpolation
    instead of weighted regression. Using a non-zero `lo_delta` significantly decreases
    computation time.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lo_delta` 是在其中使用线性插值而非加权回归的距离比例。使用非零的 `lo_delta` 会显著减少计算时间。'
- en: 'Let’s see what this decomposition looks like. Here, we used `seasonality_period=7*48`
    to capture a weekday-hourly profile:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个分解的效果。这里，我们使用了 `seasonality_period=7*48` 来捕捉工作日小时模式：
- en: '![Figure 3.14 – STL decomposition ](img/B22389_03_14.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – STL 分解](img/B22389_03_14.png)'
- en: 'Figure 3.14: STL decomposition'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14：STL 分解
- en: 'Let’s also look at the decomposition for just one month to see the extracted
    seasonality patterns clearer:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看只针对一个月的分解，看看提取的季节性模式更清晰：
- en: '![Figure 3.15 – STL decomposition (zoomed-in for a month) ](img/B22389_03_15.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – STL 分解（放大查看一个月）](img/B22389_03_15.png)'
- en: 'Figure 3.15: STL decomposition (zoomed-in for a month)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15：STL 分解（放大查看一个月）
- en: The trend is smooth enough now and seasonality has also been captured. Here,
    we can clearly see the hourly peaks and valleys and the higher peaks on weekends.
    However, since we are relying on averages to derive the seasonality, it is also
    highly influenced by outliers. A few very high or very low values in the time
    series will skew your seasonality profile that’s been derived from period averages.
    Another disadvantage of this technique is that the “goodness” of the seasonality
    that’s been extracted suffers when the difference between the resolution of the
    data and the expected seasonality cycle is greater. For instance, when extracting
    a yearly seasonality on daily or sub-daily data, this would make the extracted
    seasonality very noisy. This technique will also not work if you have less than
    two cycles of the expected seasonality—for instance, if we want to extract a yearly
    seasonality, but we have less than 2 years of data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在趋势已经足够平滑，季节性也已被捕捉到。这里，我们可以清楚地看到每小时的峰谷变化，并且周末的峰值较高。然而，由于我们依赖于周期平均值来推导季节性，它也会受到异常值的很大影响。时间序列中的一些极高或极低的值会扭曲从周期平均值推导出的季节性模式。这种技术的另一个缺点是，当数据分辨率与预期的季节性周期之间的差异较大时，提取的季节性的“好坏”会受到影响。例如，在日数据或子日数据上提取年度季节性时，这将使提取的季节性非常嘈杂。如果你期望的季节性周期少于两个周期，这种技术也不适用——例如，如果我们想提取年度季节性，但我们只有不到
    2 年的数据。
- en: Fourier decomposition
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 傅里叶分解
- en: 'We can find the Python implementation for decomposing a time series using Fourier
    terms in `src.decomposition.seasonal.py`. It uses LOESS for trend detection and
    Fourier terms for seasonality extraction. There are two ways we can use it. First,
    we can specify `seasonality_period` as one of the `pandas` datetime properties
    (such as `hour` and week_of_day):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`src.decomposition.seasonal.py`中找到使用傅里叶项分解时间序列的Python实现。它使用LOESS进行趋势检测，并使用傅里叶项提取季节性。我们可以通过两种方式使用它。首先，我们可以指定`seasonality_period`为`pandas`的日期时间属性（例如`hour`和week_of_day）：
- en: '[PRE2]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, we can create any custom seasonality array that’s the same length
    as the time series that has an ordinal representation of the seasonality. If it
    is an annual seasonality of daily data, the array would have a minimum value of
    `1` and a maximum value of `365` as it increases by one every day of the year:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以创建一个与时间序列长度相同的自定义季节性数组，该数组具有季节性的序数表示。如果是日数据的年度季节性，则该数组的最小值为`1`，最大值为`365`，因为它每天增加1：
- en: '[PRE3]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The key parameters that are involved in this process are as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 参与此过程的关键参数如下：
- en: '`seasonality_period` is the seasonality to be extracted from the *datetime
    index*. `pandas` datetime properties, such as `week_of_day` and `month`, can be
    used to specify the most prominent seasonality. If left set to `None`, you need
    to provide the seasonality array while calling `fit`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seasonality_period` 是从*日期时间索引*中提取的季节性。可以使用`pandas`的日期时间属性，如`week_of_day`和`month`，来指定最显著的季节性。如果设置为`None`，则在调用`fit`时需要提供季节性数组。'
- en: '`model` takes `additive` or `multiplicative` as an argument to determine the
    type of decomposition.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model` 接受`additive`或`multiplicative`作为参数来确定分解类型。'
- en: '`n_fourier_terms` determines the number of Fourier terms to be used to extract
    the seasonality. The more we increase this parameter, the more complex the seasonality
    that is extracted from the data.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n_fourier_terms` 确定用于提取季节性的傅里叶项的数量。增加该参数时，从数据中提取的季节性会变得更加复杂。'
- en: '`lo_frac` is the fraction of the data that will be used to fit the LOESS regression.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lo_frac` 是用于拟合LOESS回归的数据比例。'
- en: '`lo_delta` is the fractional distance within which we use linear interpolation
    instead of weighted regression. Using a non-zero `lo_delta` significantly decreases
    computation time.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lo_delta` 是我们使用线性插值而不是加权回归的距离比例。使用非零的`lo_delta`显著减少计算时间。'
- en: 'Let’s see the zoomed-in plot for the decomposition using `FourierDecomposition`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`FourierDecomposition`进行分解的放大图：
- en: '![Figure 3.16 – Decomposition using Fourier terms (zoomed-in for a month) ](img/B22389_03_16.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16 – 使用傅里叶项的分解（放大显示一个月的情况）](img/B22389_03_16.png)'
- en: 'Figure 3.16: Decomposition using Fourier terms (zoomed-in for a month)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16：使用傅里叶项的分解（放大显示一个月的情况）
- en: The trend is going to be the same as the STL one because we are using LOESS
    here as well. The seasonality profile may be slightly different and robust to
    outliers because we are doing regularized regression using the Fourier terms on
    the signal. Another advantage is that we have decoupled the resolution of the
    data and the expected seasonality. Now, extracting a yearly seasonality on sub-daily
    data is not as challenging as with period averages.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势将与STL方法相同，因为我们这里也使用了LOESS。季节性轮廓可能略有不同，并且对异常值具有鲁棒性，因为我们使用傅里叶项对信号进行正则化回归。另一个优势是，我们已经解耦了数据分辨率和预期季节性。现在，在子日数据上提取年度季节性不再像使用周期平均值时那样具有挑战性。
- en: So far, we have only seen techniques that extract one seasonality per series;
    mostly, we extract the major seasonality. So, what do we do when we have multiple
    seasonal patterns?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了每个序列提取一个季节性的技术；通常，我们提取的是主要的季节性。那么，当我们有多个季节性模式时，应该怎么办呢？
- en: Multiple seasonality decomposition using LOESS (MSTL)
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用LOESS进行多季节性分解（MSTL）
- en: Time series with high-frequency data (such as daily or hourly data) are prone
    to exhibit multiple seasonal patterns. For instance, there may be an hourly seasonality
    pattern, a weekly seasonality pattern, and a yearly seasonality pattern. But if
    we extract only the dominant pattern and leave the rest to residuals, we are not
    doing justice to the decomposition. Kasun Bandara et al. proposed an extension
    of STL decomposition for multiple seasonality, known as **MSTL**, and a corresponding
    implementation is present in the R ecosystem. A very similar implementation in
    Python can be found in `src.decomposition.seasonal.py`. In addition to MSTL, the
    implementation extracts multiple seasonality using Fourier terms.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 高频数据（如日数据或小时数据）的时间序列往往会表现出多种季节性模式。例如，可能会有小时季节性模式、周季节性模式和年季节性模式。但如果我们只提取主要模式，而将其余的部分留给残差，我们就没有充分做到分解。Kasun
    Bandara 等人提出了一种扩展的 STL 分解方法，用于多重季节性，称为 **MSTL**，并且在 R 生态系统中有相应的实现。Python 中有一个非常相似的实现，可以在
    `src.decomposition.seasonal.py` 中找到。除了 MSTL，实施中还使用傅里叶项提取多重季节性。
- en: '**Reference check**:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考检查**：'
- en: The research paper by Kasun Bandara et al. is cited in the *References* section
    as reference *1*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Kasun Bandara 等人的研究论文在 *参考文献* 部分被引用为参考文献 *1*。
- en: 'Let’s look at an example of how we can use this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个如何使用它的例子：
- en: '[PRE4]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The key parameters here are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键参数如下：
- en: '`seasonality_periods` is the list of expected seasonalities. For `stl`, it
    is a list of seasonal periods, while for `FourierDecomposition`, it is a list
    of strings that denotes `pandas` datetime properties.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seasonality_periods` 是预期季节性的列表。对于 `stl`，它是季节周期的列表，而对于 `FourierDecomposition`，它是表示
    `pandas` 日期时间属性的字符串列表。'
- en: '`seasonality_model` takes `fourier` or `averages` as an argument to determine
    the type of seasonality decomposition.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seasonality_model` 采用 `fourier` 或 `averages` 作为参数来确定季节性分解类型。'
- en: '`model` takes `additive` or `multiplicative` as an argument to determine the
    type of decomposition.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model` 采用 `additive` 或 `multiplicative` 作为参数来确定分解类型。'
- en: '`n_fourier_terms` determines the number of Fourier terms to be used to extract
    the seasonality. As we increase this parameter, the more complex the seasonality
    that is extracted from the data.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n_fourier_terms` 决定了提取季节性时使用的傅里叶项数。随着该参数的增大，从数据中提取的季节性会变得更加复杂。'
- en: '`lo_frac` is the fraction of the data that will be used to fit the LOESS regression.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lo_frac` 是用于拟合 LOESS 回归的数据比例。'
- en: '`lo_delta` is the fractional distance within which we use linear interpolation
    instead of weighted regression. Using a non-zero `lo_delta` significantly decreases
    computation time.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lo_delta` 是我们使用线性插值而不是加权回归的区间距离。使用非零的 `lo_delta` 可以显著减少计算时间。'
- en: 'Let’s see what the decomposition looks like when using Fourier decomposition:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用傅里叶分解时，分解结果是什么样的：
- en: '![Figure 3.17 – Multiple seasonality decomposition using Fourier terms ](img/B22389_03_17.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.17 – 使用傅里叶项进行的多重季节性分解](img/B22389_03_17.png)'
- en: 'Figure 3.17: Multiple seasonality decomposition using Fourier terms'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17：使用傅里叶项进行的多重季节性分解
- en: 'Here, we can see that the `day_of_week` seasonality has been extracted. To
    see the `day_of_week` and `hour` seasonal components, we need to zoom in a bit:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `day_of_week`（星期几）季节性已经被提取出来。为了查看 `day_of_week` 和 `hour`（小时）季节性成分，我们需要稍微放大一下：
- en: '![Figure 3.18 – Multiple seasonality decomposition using Fourier terms (zoomed-in
    for a month) ](img/B22389_03_18.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.18 – 使用傅里叶项进行的多重季节性分解（放大显示一个月的数据）](img/B22389_03_18.png)'
- en: 'Figure 3.18: Multiple seasonality decomposition using Fourier terms (zoomed-in
    for a month)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18：使用傅里叶项进行的多重季节性分解（放大显示一个月的数据）
- en: Here, we can observe that the `hour` seasonality has been extracted well and
    that it has also isolated the `day_of_week` seasonal component, which peaks on
    weekends. The **discrete step** nature of the `day_of_week` seasonal component
    is because the frequency of the data is half-hourly, and for 48 data points, `day_of_week`
    will be the same.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以观察到 `hour`（小时）季节性已经被很好地提取，并且它还隔离了 `day_of_week`（星期几）季节性成分，该成分在周末达到峰值。`day_of_week`
    季节性成分的 **离散步骤** 特性是由于数据的频率是半小时一次，对于 48 个数据点，`day_of_week` 会是相同的。
- en: 'We have summarized the four techniques we’ve covered in the following table:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在下表中总结了我们所涵盖的四种技术：
- en: '| **Implementation** | **Trend** | **Seasonal** | **Supports Multiple Seasonality?**
    | **Supports Missing?** |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| **实现** | **趋势** | **季节性** | **支持多重季节性？** | **支持缺失值？** |'
- en: '| Seasonality decomposition | Moving Averages | Period-Adjusted Averages |
    No | No |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 季节性分解 | 移动平均 | 周期调整平均值 | 否 | 否 |'
- en: '| STL | LOESS | Period-Adjusted Averages | No | Yes |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| STL | LOESS | 周期调整平均值 | 否 | 是 |'
- en: '| Fourier decomposition | LOESS | Fourier Terms | No | No |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 傅里叶分解 | LOESS | 傅里叶项 | 否 | 否 |'
- en: '| Multiple seasonality decomposition | LOESS | Period-Adjusted Averages / Fourier
    Terms | Yes | No |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 多重季节性分解 | LOESS | 周期调整平均值 / 傅里叶项 | 是 | 否 |'
- en: 'Table 3.1: Different seasonal decomposition techniques'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1：不同的季节性分解技术
- en: MSTL has also been implemented in statsmodels and the accompanying notebook
    has the code to use that. The key difference between statsmodels and the implementation
    bundled within the code for the book is that the one in the book also has the
    option for using Fourier-series-based decomposition.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: MSTL也已在statsmodels中实现，并且随附的笔记本中有相应的代码。statsmodels与本书中代码实现的关键区别在于，本书中的实现还提供了使用基于傅里叶级数分解的选项。
- en: Now, let’s understand and analyze a time series dataset.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们理解并分析一个时间序列数据集。
- en: Detecting and treating outliers
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测和处理异常值
- en: An **outlier**, as its name suggests, is an observation that lies at an abnormal
    distance from the rest of the observations. If we are looking at a **data-generating
    process** (**DGP**) as a stochastic process that generates the time series, the
    outliers are the points that have the least probability of being generated from
    the DGP. This can be for many reasons, including faulty measurement equipment,
    incorrect data entry, and black-swan events, to name a few. Being able to detect
    such outliers and *treat* them may help your forecasting model understand the
    data better.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常值**，顾名思义，是指那些与其他观测值距离异常的观测值。如果我们将**数据生成过程**（**DGP**）视为生成时间序列的随机过程，那么异常值就是那些从DGP生成的概率最小的点。这可能有许多原因，包括测量设备故障、数据录入错误和黑天鹅事件等等。能够检测到这样的异常值并*处理*它们，可能有助于你的预测模型更好地理解数据。'
- en: Outlier/anomaly detection is a specialized field itself in time series, but
    in this book, we are going to restrict ourselves to simpler techniques of identifying
    and treating outliers. This is because our main aim is not to detect outliers,
    but to clean the data for our forecasting models to perform better. If you want
    to learn more about anomaly detection, head over to the *Further reading* section
    for a few resources to get started.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 异常值/异常检测本身就是时间序列中的一个专业领域，但在本书中，我们将限制在一些简单的异常值识别和处理技术上。原因是我们的主要目的是清理数据，以便预测模型能够更好地执行，而不是检测异常值。如果你想了解更多关于异常检测的内容，可以前往*进一步阅读*部分，找到一些入门资源。
- en: Now, let’s look at a few techniques for identifying outliers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下几种识别异常值的技术。
- en: '**Notebook alert**:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**笔记本提醒**：'
- en: To follow along with the complete code for detecting outliers, use the `03-Outlier_Detection.ipynb`
    notebook in the `Chapter03` folder.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随完整的异常值检测代码，请使用`Chapter03`文件夹中的`03-Outlier_Detection.ipynb`笔记本。
- en: Standard deviation
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准差
- en: This is a rule of thumb that almost everyone who has worked with data for some
    time would have heard of—if ![](img/B22389_03_003.png) is the mean of the time
    series and ![](img/B22389_03_004.png) is the standard deviation, then anything
    that falls beyond ![](img/B22389_03_005.png) is an **outlier**. The underlying
    theory is deeply rooted in statistics. If we assume that the values of the time
    series follow a normal distribution (which is a symmetrical distribution with
    very desirable properties), using probability theory, we can derive that 68% of
    the area under the normal distribution lies within one standard deviation on either
    side of the mean, about 95% of the area within two standard deviations, and about
    99% of the area within three standard deviations. So, when we make the bounds
    as three standard deviations (by using the rule of thumb), what we are saying
    is that if any observation whose probability of belonging to the probability distribution
    is less than 1%, then they are an outlier.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经验法则，几乎每个有过一段时间数据处理经验的人都听说过——如果![](img/B22389_03_003.png)是时间序列的均值，![](img/B22389_03_004.png)是标准差，那么任何超出![](img/B22389_03_005.png)的值都可以视为**异常值**。其背后的理论深深植根于统计学。如果我们假设时间序列的值遵循正态分布（这是一种具有非常理想性质的对称分布），通过概率论，我们可以推导出正态分布下68%的区域位于均值的一个标准差范围内，约95%的区域位于两个标准差范围内，约99%的区域位于三个标准差范围内。因此，当我们将界限设为三个标准差（使用经验法则）时，我们的意思是，如果任何观测值属于概率分布的概率低于1%，那么它们就是异常值。
- en: Moving slightly to more practical issues, this cutoff of three standard deviations
    is in no way sacrosanct. We need to try out different values of this multiple
    and determine the right multiple by subjectively evaluating the results we get.
    The higher the multiple is, the fewer outliers there will be.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微转向更实际的问题，三倍标准差的截断值并非不可改变。我们需要尝试不同的倍数值，并通过主观评估所得到的结果来确定合适的倍数。倍数越高，异常值越少。
- en: For highly seasonal data, the naïve way of applying the rule to the raw time
    series will not work well. In such cases, we must deseasonalize the data using
    any of the techniques we discussed earlier and then apply the outliers to the
    residuals. If we don’t do that, we may flag a seasonal peak as an outlier, which
    is not what we want.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高度季节性的数据，直接将规则应用于原始时间序列是行不通的。在这种情况下，我们必须使用之前讨论的任一方法来去季节化数据，然后再应用异常值检测于残差。如果不这样做，可能会错误地将季节性峰值标记为异常值，这正是我们不希望发生的情况。
- en: Another key assumption here is the normal distribution. However, in reality,
    a lot of the time series we come across may not be normal and hence the rule will
    lose its theoretical guarantees fast.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的另一个关键假设是正态分布。然而，实际上，我们遇到的许多时间序列数据可能并不是正态分布的，因此此规则的理论保证会迅速失效。
- en: IQR
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IQR
- en: 'Another very similar technique is using the IQR instead of the standard deviation
    to define the bounds beyond which we mark the observations as outliers. A quantile
    arranges all your data in order and then splits it into equal parts, so each part
    has the same number of items. A quartile does the same but specifically divides
    your data into four equal parts. IQR is the difference between the 3^(rd) quartile
    (or the 75^(th) percentile or 0.75 quantile) and the 1^(st) quartile (or the 25^(th)
    percentile or 0.25 quantile). The upper and lower bounds are defined as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种非常相似的技术是使用IQR（四分位距）代替标准差来定义超出范围的观测值，从而标记为异常值。分位数将所有数据按顺序排列，然后将其分成相等的部分，使每部分包含相同数量的项目。四分位数也做同样的事，但特定地将数据分成四等份。IQR是第三四分位数（即第75百分位或0.75分位数）与第一四分位数（即第25百分位或0.25分位数）之间的差值。上下界限定义如下：
- en: '*Upper bound = Q3 + n x IQR*'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上界 = Q3 + n x IQR*'
- en: '*Lower bound = Q1 - n x IQR*'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下界 = Q1 - n x IQR*'
- en: Here, *IQR* = *Q3*-*Q2*, and *n* is the multiple of IQRs that determines the
    width of the acceptable area.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*IQR* = *Q3*-*Q2*，*n*是IQR的倍数，用于确定可接受区域的宽度。
- en: For datasets where we observe high occurrences of outliers and wild variations,
    this is slightly more robust than the standard deviation. This is because the
    standard deviation and the mean are highly influenced by individual points in
    the dataset. If ![](img/B22389_03_006.png) was the rule of thumb in the earlier
    method, here, it is 1.5 times the IQR. This also ties back to the same normal
    distribution assumption, and 1.5 times the IQR is equivalent to ~ ![](img/B22389_03_007.png)
    (![](img/B22389_03_008.png) to be exact). The point about deseasonalizing before
    applying the rule applies here as well. It applies to all the techniques we will
    see here.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些异常值出现频繁且波动剧烈的数据集，这种方法比标准差稍微更稳健。这是因为标准差和均值会受到数据集中单个点的强烈影响。如果 ![](img/B22389_03_006.png)
    是之前方法中的经验法则，那么这里则是IQR的1.5倍。这也与相同的正态分布假设相关，IQR的1.5倍大约等于 ~ ![](img/B22389_03_007.png)
    （精确来说是 ![](img/B22389_03_008.png)）。在应用规则之前去季节化的数据问题同样适用，这对我们接下来会看到的所有技术都适用。
- en: Isolation Forest
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离森林
- en: '**Isolation Forest** is an unsupervised anomaly detection algorithm based on
    decision trees. A typical anomaly detection algorithm models the *normal* points
    and profiles outliers as any points that do not fit the *normal.* However, Isolation
    Forest takes a different path and models the outliers directly. It does this by
    creating a forest of decision trees by randomly splitting the feature space. This
    technique works on the assumption that the outlier points fall in the outer periphery
    and are easier to fall into a leaf node of a tree. Therefore, you can find the
    outliers in short branches, whereas normal points, which are closer together,
    will require longer branches. The “anomaly score” of any point is determined by
    the depth of the tree to be traversed before reaching that particular point. scikit-learn
    has an implementation of the algorithm under `sklearn.ensemble.IsolationForest`.
    Apart from the standard parameters for decision trees, the key parameter here
    is contamination. It is set to `auto` by default but can be set to any value between
    `0` and `0.5`. This parameter specifies what percentage of the dataset you expect
    to be anomalous.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**Isolation Forest** 是一种基于决策树的无监督异常检测算法。典型的异常检测算法会建模*正常*点，并将不符合*正常*的点视为异常值。然而，Isolation
    Forest 采用了不同的方式，直接建模异常值。它通过随机划分特征空间来创建决策树的森林。该技术假设异常值位于外部边缘，且更容易进入树的叶节点。因此，你可以在短枝上找到异常值，而正常点则由于靠得更近需要更长的枝条。任何点的“异常评分”由达到该点之前需要遍历的树的深度来决定。scikit-learn
    提供了该算法的实现，位于 `sklearn.ensemble.IsolationForest`。除了决策树的标准参数外，关键参数是污染度。默认设置为`auto`，但可以设置为`0`到`0.5`之间的任何值。该参数指定你预计数据集中多少百分比的数据是异常的。'
- en: But one thing we have to keep in mind is that `IsolationForest` does not consider
    time at all and just highlights values that fall *outside the norm*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们必须记住的一点是，`IsolationForest` 完全不考虑时间因素，只会突出显示*异常值*。
- en: Extreme studentized deviate (ESD) and seasonal ESD (S-ESD)
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 极端学生化偏差（ESD）和季节性 ESD（S-ESD）
- en: This statistics-based technique is more sophisticated than the basic ![](img/B22389_03_009.png)
    technique but still uses the same assumption of normality. It is based on another
    statistical test, called Grubbs’s test, which is used to find a *single outlier*
    in a normally distributed dataset. ESD iteratively uses Grubbs’s test by identifying
    and removing an outlier at each step. It also adjusts the critical value based
    on the number of points left. For a more detailed understanding of the test, go
    to the *Further reading* section, where we have provided a couple of resources
    about ESD and S-ESD. In 2017, Hochenbaum et al. from Twitter Research proposed
    to use the generalized ESD with deseasonalization as a method of detecting outliers
    for time series.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于统计的技术比基础的 ![](img/B22389_03_009.png) 技术更复杂，但仍然使用相同的正态性假设。它基于另一种统计测试，叫做 Grubbs
    检验，用于在正态分布的数据集中找到*单个异常值*。ESD 通过逐步识别和移除异常值来迭代使用 Grubbs 检验。它还根据剩余点的数量调整临界值。要更详细地了解该测试，请参见*进一步阅读*部分，在那里我们提供了一些关于
    ESD 和 S-ESD 的资源。2017 年，Twitter Research 的 Hochenbaum 等人提出使用去季节化的广义 ESD 作为时间序列异常值检测的方法。
- en: We have adapted an existing implementation of the algorithm for our use case,
    and it is available in this book’s GitHub repository. While all the other methods
    leave it to the user to determine the right level of outliers by tweaking a few
    parameters, S-ESD only takes in an upper bound on the number of expected outliers
    and then identifies the outliers independently. For instance, we set the upper
    bound to 800 and the algorithm identified ~400 outliers in the data we are working
    with.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经根据自己的使用案例调整了该算法的现有实现，并且它可以在本书的 GitHub 仓库中找到。虽然其他所有方法都需要用户通过调整几个参数来确定异常值的适当级别，但
    S-ESD 只需输入预期异常值的上限，然后独立地识别异常值。例如，我们将上限设置为 800，算法在我们使用的数据中识别出了大约 400 个异常值。
- en: '**Reference check:**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考检查：**'
- en: The research paper by Hochenbaum et al. is cited in the *References* section
    as reference *2*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Hochenbaum 等人的研究论文在*参考文献*部分作为参考文献*2*被引用。
- en: 'Let’s see how the outliers were detected using all the techniques we have reviewed:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们回顾的所有技术是如何检测异常值的：
- en: '![Figure 3.19 – Outliers detected using different techniques ](img/B22389_03_19.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.19 – 使用不同技术检测到的异常值](img/B22389_03_19.png)'
- en: 'Figure 3.19: Outliers detected using different techniques'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19：使用不同技术检测到的异常值
- en: Now that we’ve learned how to detect outliers, let’s talk about how we can treat
    them and clean the dataset.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何检测异常值，让我们来谈谈如何处理这些异常值并清理数据集。
- en: Treating outliers
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异常值
- en: The first question that we must answer is whether or not we should correct the
    outliers we have identified. The statistical tests that identify outliers automatically
    should go through another level of human verification. If we blindly “treat” outliers,
    we might be chopping off a valuable pattern that will help us forecast the time
    series. If you are only forecasting a handful of time series, then it still makes
    sense to look at the outliers and anchor them to reality by looking at the causes
    for such outliers.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须回答的第一个问题是，是否应该修正我们识别出的异常值。自动识别异常值的统计检验应该通过另一个层级的人工验证。如果我们盲目地“处理”异常值，可能会剪切掉一个有价值的模式，而这个模式可能有助于我们预测时间序列。如果你只预测少量时间序列，那么查看异常值并通过分析异常值的原因来将其与现实相结合仍然是有意义的。
- en: But when you have thousands of time series, a human can’t inspect all the outliers,
    so we will have to resort to automated techniques. A common practice is to replace
    an outlier with a heuristic such as the maximum, minimum, and 75th percentile.
    A better method is to consider the outliers as missing data and use any of the
    techniques we discussed earlier to impute the outliers.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你拥有数千个时间序列时，人工无法检查所有的异常值，因此我们将不得不求助于自动化技术。一个常见做法是将异常值替换为启发式方法，如最大值、最小值和第75百分位数。更好的方法是将异常值视为缺失数据，并使用我们之前讨论的任何技术来填补这些异常值。
- en: One thing we must keep in mind is that outlier correction is not a necessary
    step in forecasting, especially when using modern methods such as machine learning
    or deep learning. Whether we do outlier correction or not is something we have
    to experiment with and figure out.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住的一点是，异常值修正不是预测中的必要步骤，特别是在使用现代方法，如机器学习或深度学习时。我们是否进行异常值修正是需要实验并加以验证的。
- en: Well done! This was a pretty busy chapter, with a lot of concepts and code,
    so congratulations on finishing it. Feel free to head back and revise a few topics
    as needed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！这一章内容较为繁忙，涉及了许多概念和代码，所以祝贺你完成了这一章。你可以根据需要回头复习一些主题。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the key components of a time series and familiarized
    ourselves with terms such as trend and seasonality. We also reviewed a few time
    series-specific visualization techniques that will come in handy during EDA. Then,
    we learned about techniques that let you decompose a time series into its components
    and saw techniques for detecting outliers in the data. Finally, we learned how
    to treat the identified outliers. Now, you are all set to start forecasting the
    time series, which we will start in the next chapter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了时间序列的关键组成部分，并熟悉了趋势和季节性等术语。我们还复习了几种时间序列特有的可视化技术，这些技术将在探索性数据分析（EDA）过程中派上用场。然后，我们学习了可以将时间序列分解为其组成部分的技术，并看到了检测数据中异常值的技术。最后，我们学习了如何处理已识别的异常值。现在，你已经准备好开始预测时间序列了，这将在下一章开始。
- en: References
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'The following are the references for this chapter:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的参考资料：
- en: 'Kasun Bandara and Rob J Hyndman and Christoph Bergmeir. (2021). *MSTL: A Seasonal-Trend
    Decomposition Algorithm for Time Series with Multiple Seasonal Patterns*. arXiv:2107.13462
    [stat.AP]. [https://arxiv.org/abs/2107.13462](https://arxiv.org/abs/2107.13462).'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kasun Bandara、Rob J Hyndman 和 Christoph Bergmeir。（2021）。*MSTL：一种用于具有多重季节性模式时间序列的季节趋势分解算法*。arXiv:2107.13462
    [stat.AP]。[https://arxiv.org/abs/2107.13462](https://arxiv.org/abs/2107.13462)。
- en: Hochenbaum, J., Vallis, O., & Kejariwal, A. (2017). *Automatic Anomaly Detection
    in the Cloud Via Statistical Learning*. ArXiv, abs/1704.07706\. [https://arxiv.org/abs/1704.07706](https://arxiv.org/abs/1704.07706).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hochenbaum, J., Vallis, O., & Kejariwal, A.（2017）。*通过统计学习实现云中的自动异常检测*。ArXiv，abs/1704.07706。[https://arxiv.org/abs/1704.07706](https://arxiv.org/abs/1704.07706)。
- en: Further reading
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章涉及的主题，请查看以下资源：
- en: 'Fourier Series: [https://www.setzeus.com/public-blog-post/the-fourier-series](https://www.setzeus.com/public-blog-post/the-fourier-series)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 傅里叶级数：[https://www.setzeus.com/public-blog-post/the-fourier-series](https://www.setzeus.com/public-blog-post/the-fourier-series)
- en: 'Fourier Series from Khan Academy: [https://www.youtube.com/watch?v=UKHBWzoOKsY](https://www.youtube.com/watch?v=UKHBWzoOKsY)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Khan Academy 的傅里叶级数：[https://www.youtube.com/watch?v=UKHBWzoOKsY](https://www.youtube.com/watch?v=UKHBWzoOKsY)
- en: 'Fourier Transform: [https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/](https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 傅里叶变换：[https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/](https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/)
- en: Ane Blázquez-García, Angel Conde, Usue Mori, and Jose A. Lozano. (2021). *A
    Review on Outlier/Anomaly Detection in Time Series Data*. arXiv:2002.04236\. [https://arxiv.org/abs/2002.04236](https://arxiv.org/abs/2002.04236)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ane Blázquez-García, Angel Conde, Usue Mori, 和 Jose A. Lozano. (2021). *时间序列数据中的离群点/异常检测综述*。arXiv:2002.04236\.
    [https://arxiv.org/abs/2002.04236](https://arxiv.org/abs/2002.04236)
- en: 'Braei, M., & Wagner, S. (2020). *Anomaly Detection in Univariate Time-series:
    A Survey on the State-of-the-Art*. ArXiv, abs/2004.00433\. [https://arxiv.org/abs/2004.00433](https://arxiv.org/abs/2004.00433)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Braei, M., & Wagner, S. (2020). *单变量时间序列中的异常检测：最新技术综述*。ArXiv, abs/2004.00433\.
    [https://arxiv.org/abs/2004.00433](https://arxiv.org/abs/2004.00433)
- en: 'Generalized ESD Test for Outliers: [https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm](https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离群点的广义ESD检验：[https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm](https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm)
- en: Join our community on Discord
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们在Discord上的社区
- en: 'Join our community’s Discord space for discussions with authors and other readers:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/mts](https://packt.link/mts)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/mts](https://packt.link/mts)'
- en: '![](img/QR_Code15080603222089750.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code15080603222089750.png)'
- en: Leave a Review!
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you’ve completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您购买这本书，我们希望您喜欢！您的反馈对我们至关重要，能帮助我们改进和成长。阅读完后，请花一点时间在亚马逊上留下评论；这只需要一分钟，但对像您这样的读者来说意义重大。
- en: Scan the QR or visit the link to receive a free ebook of your choice.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描二维码或访问链接以获得您选择的免费电子书。
- en: '[https://packt.link/NzOWQ](Chapter_03.xhtml)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/NzOWQ](Chapter_03.xhtml)'
- en: '![A qr code with black squares  Description automatically generated](img/review1.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的带有黑色方块的二维码图片描述](img/review1.jpg)'
