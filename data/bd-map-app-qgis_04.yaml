- en: Chapter 4. Creating QGIS Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 创建QGIS插件
- en: 'In [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting Started with
    QGIS"), *Getting Started with QGIS*, we took a brief look at how QGIS Python plugins
    are organized. In this chapter, we will use this knowledge to create two plugins:
    a simple "Hello World" style plugin, so you can understand the process, and a
    much more sophisticated and useful plugin that displays information about a clicked-on
    geometry. In the process, we will learn how plugins work, how to create and distribute
    plugins, what plugins will allow us to do, and some of the possibilities and limitations
    involved in implementing your mapping applications as QGIS plugins.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0014_split_000.html#page "第1章. QGIS入门")中，我们简要地了解了QGIS Python插件的组织方式。在本章中，我们将利用这些知识来创建两个插件：一个简单的“Hello
    World”风格插件，以便您了解过程，以及一个更复杂、更有用的插件，它可以显示关于点击的几何体的信息。在这个过程中，我们将学习插件的工作原理，如何创建和分发插件，插件将允许我们做什么，以及将您的映射应用程序作为QGIS插件实现的一些可能性和局限性。
- en: Getting ready
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Before we can delve into the plugin development process, there are three things
    you will need to do:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入插件开发过程之前，您需要做三件事：
- en: Install the **Qt developer tools** from the Qt developer website ([http://qt-project.org](http://qt-project.org)).
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Qt开发者网站([http://qt-project.org](http://qt-project.org))安装**Qt开发者工具**。
- en: Install the Python bindings for Qt, called **PyQt**, from [http://www.riverbankcomputing.co.uk/software/pyqt](http://www.riverbankcomputing.co.uk/software/pyqt).
    While we won't be using the Python bindings directly, there are two command-line
    tools included with PyQt that we will need.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://www.riverbankcomputing.co.uk/software/pyqt](http://www.riverbankcomputing.co.uk/software/pyqt)安装Qt的Python绑定，称为**PyQt**。虽然我们不会直接使用Python绑定，但PyQt中包含两个我们将需要的命令行工具。
- en: Tip
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: QGIS is currently based on PyQt4\. Make sure you install Version 4 of the Qt
    Developer tools and the PyQt bindings so that you get the compatible version.
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QGIS目前基于PyQt4。请确保您安装Qt开发者工具和PyQt绑定的第4版本，以确保您获得兼容版本。
- en: PyQt is available as an installer for MS Windows and in source code form for
    Linux. For Mac OS X users, a binary installer is available at [http://sourceforge.net/projects/pyqtx](http://sourceforge.net/projects/pyqtx).
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: PyQt可以作为MS Windows的安装程序和Linux的源代码形式提供。对于Mac OS X用户，可以在[http://sourceforge.net/projects/pyqtx](http://sourceforge.net/projects/pyqtx)找到二进制安装程序。
- en: You should install and enable the **Plugin Reloader** plugin for QGIS. This
    makes it much easier to develop and test your plugins. To do this, you will need
    to turn on experimental plugin support by selecting the **Manage and Install Plugins…**
    item from the **Plugins** menu, clicking on the **Settings** tab, and then turning
    on the **Show also experimental plugins** checkbox. You can then see the experimental
    plugins, including the Plugin Reloader. Select this plugin and then click on the
    **Install Plugin** button to install it.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该安装并启用QGIS的**插件重载器**插件。这使得开发测试插件变得更加容易。为此，您需要通过从**插件**菜单中选择**管理并安装插件…**项，点击**设置**选项卡，然后打开**显示实验性插件**复选框来开启实验性插件支持。您将能够看到实验性插件，包括插件重载器。选择此插件，然后点击**安装插件**按钮进行安装。
- en: 'The Plugin Reloader adds buttons to the QGIS toolbar that you can click on
    in order to reload your plugin:'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 插件重载器向QGIS工具栏中添加了按钮，您可以通过点击这些按钮来重新加载您的插件：
- en: '![Getting ready](img/00036.jpeg)'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![准备就绪](img/00036.jpeg)'
- en: This allows you to make changes to your plugin and see the result right away.
    Without the Plugin Reloader, you would have to quit and restart QGIS for your
    changes to take effect.
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许您对插件进行修改并立即看到结果。如果没有插件重载器，您将不得不退出并重新启动QGIS才能使您的更改生效。
- en: Understanding the QGIS plugin architecture
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解QGIS插件架构
- en: As we saw in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting Started
    with QGIS"), *Getting Started with QGIS*, QGIS plugins are stored as Python packages
    in the `~/.qgis2/python/plugins` directory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](part0014_split_000.html#page "第1章. QGIS入门")中看到的，QGIS插件存储在`~/.qgis2/python/plugins`目录中，作为Python包。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Depending on your operating system and the version of QGIS you're using, the
    `.qgis2` directory might be named `.qgis`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的操作系统和您使用的QGIS版本，`.qgis2`目录可能被命名为`.qgis`。
- en: 'The plugin''s package includes a number of Python modules and other files.
    At a minimum, the plugin package must include:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的包包括多个Python模块和其他文件。至少，插件包必须包括：
- en: '`__init__.py`: This is a package initialization module that contains the **class
    factory** function, which creates and initializes the plugin.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`：这是一个包初始化模块，其中包含**类工厂**函数，该函数创建并初始化插件。'
- en: '`metadata.txt`: This is a text file that contains information about the plugin,
    including the plugin''s version number, the name of the plugin, and the plugin''s
    author.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata.txt`：这是一个包含有关插件信息的文本文件，包括插件的版本号、插件名称和插件作者。'
- en: 'In addition, most plugins will include:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大多数插件还会包括：
- en: A separate Python module that contains a class definition for the plugin. The
    plugin class implements a number of specially named methods that get called to
    start up and shut down the plugin.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单独的Python模块，其中包含插件的类定义。插件类实现了一些特别命名的、用于启动和关闭插件的方法。
- en: One or more user-interface template files with the extension `.ui`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个扩展名为`.ui`的用户界面模板文件。
- en: The compiled version of each user-interface template in the form of a Python
    module with the same name as that of the template.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个用户界面模板的编译版本，形式为一个与模板同名的Python模块。
- en: A `resources.qrc` file, which is an XML format file that lists the various images
    and other resources used by the plugin.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`resources.qrc`文件，这是一个XML格式文件，列出了插件使用的各种图像和其他资源。
- en: The compiled version of the resources file, in the form of a Python module named
    `resources.py`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源文件的编译版本，形式为一个名为`resources.py`的Python模块。
- en: The various `.ui` template files are created using **Qt Designer**, which is
    a part of the standard Qt installation. The command-line tools to convert the
    `.qrc` and `.ui` files into Python modules are part of PyQt.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 各种`.ui`模板文件是使用**Qt Designer**创建的，它是标准Qt安装的一部分。将`.qrc`和`.ui`文件转换为Python模块的命令行工具是PyQt的一部分。
- en: 'When it starts up, QGIS looks through the various Python packages it finds
    in the `~/.qgis2/python/plugins` directory. For each package, it attempts to call
    the top-level function named `ClassFactory()` in the plugin''s `__init__.py` file.
    This function should import and return an instance of the plugin''s object, like
    this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当QGIS启动时，它会查找在`~/.qgis2/python/plugins`目录中找到的各个Python包。对于每个包，它会尝试调用插件`__init__.py`文件中的顶级函数`ClassFactory()`。这个函数应该导入并返回插件对象的实例，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Obviously, you should change the name of `myPlugin` (and `MyPlugin`) to something
    more meaningful when you write a real plugin.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当你编写真正的插件时，你应该将`myPlugin`（以及`MyPlugin`）的名称改为更有意义的东西。
- en: 'While it''s usual to define the plugin in a separate module, you can create
    it directly within the `__init__.py` module if you prefer. The important thing
    is to define a class that provides the following methods:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常会在单独的模块中定义插件，但如果你愿意，也可以直接在`__init__.py`模块中创建它。重要的是要定义一个提供以下方法的类：
- en: '`__init__(iface)`: This initializes the plugin object. Note that this should
    accept the `iface` variable passed to the class factory and store it in an instance
    variable for later use.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__(iface)`：这个方法初始化插件对象。请注意，这应该接受传递给类工厂的`iface`变量并将其存储在实例变量中以供以后使用。'
- en: '`initGui()`: This initializes the plugin''s user interface. This would typically
    involve adding the plugin to the QGIS menus and toolbar, and setting up the signal
    handlers to respond to various events.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initGui()`：这个方法初始化插件的用户界面。这通常涉及将插件添加到QGIS菜单和工具栏，并设置信号处理程序以响应各种事件。'
- en: '`unload()`: This removes the plugin''s user-interface elements. This would
    normally include removing the plugin from the QGIS menus and toolbar, and disconnecting
    the signal handlers defined in the plugin''s `initGui()` method.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unload()`：这个方法移除插件的用户界面元素。这通常包括从QGIS菜单和工具栏中移除插件，以及断开在插件的`initGui()`方法中定义的信号处理程序。'
- en: The `__init__(iface)` method is called by your class factory function to initialize
    the plugin object itself. The `initGui()` method is then called by QGIS when the
    program starts up, or when the user installs the plugin. Finally, the `unload()`
    method is called by QGIS when the user uninstalls the plugin or when QGIS shuts
    down.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__(iface)`方法由你的类工厂函数调用以初始化插件对象本身。然后，当程序启动或用户安装插件时，QGIS会调用`initGui()`方法。最后，当用户卸载插件或QGIS关闭时，会调用`unload()`方法。'
- en: A plugin doesn't usually run right away when QGIS starts up. Instead, it installs
    various menu and toolbar items, which the user can then select to perform various
    actions. For example, a simple plugin may have just one menu item and one toolbar
    item, and when the user selects one of these, the plugin performs its one and
    only action. More sophisticated plugins might have a range of menu and toolbar
    items, each one performing a different action.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 插件通常在 QGIS 启动时不会立即运行。相反，它安装各种菜单和工具栏项，用户可以选择这些项来执行各种操作。例如，一个简单的插件可能只有一个菜单项和一个工具栏项，当用户选择其中一个时，插件执行其唯一且仅有的操作。更复杂的插件可能有各种菜单和工具栏项，每个项执行不同的操作。
- en: Many plugins add their menu items to the **Plugins** menu using the `iface.addPluginToMenu()`
    method. This creates a submenu within the **Plugins** menu for the plugin's menu
    items, making it easy for the user to see which menu items have been provided
    by a given plugin. Alternatively, the plugin might choose to add its menu items
    to one of the existing submenus within the **Vector**, **Raster**, or **Database**
    menu, as appropriate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多插件使用 `iface.addPluginToMenu()` 方法将其菜单项添加到 **插件** 菜单中。这为插件的菜单项在 **插件** 菜单中创建了一个子菜单，使用户能够轻松地看到哪些菜单项是由某个插件提供的。或者，插件可能会选择将其菜单项添加到
    **向量**、**栅格** 或 **数据库** 菜单中的现有子菜单中，具体取决于情况。
- en: In the same way, the plugin might add icons or widgets to the plugin toolbar,
    or to one of the other toolbars if it prefers. A plugin might also add a whole
    new toolbar to the QGIS window if it wants to.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，插件可能会将其图标或小部件添加到插件工具栏中，或者如果它更喜欢的话，添加到其他工具栏中。如果插件想要的话，它还可以在 QGIS 窗口中添加一个全新的工具栏。
- en: Creating a simple plugin
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的插件
- en: Now that we've seen how plugins are structured and used, let's create a very
    simple "Hello World" style plugin to see what's involved in making one. While
    there are various tools such as the **Plugin Builder** plugin, which will create
    the various files for you, we're going to eschew them in favor of creating our
    plugin manually. This will make the process clearer and avoid the situation where
    your code just magically works without knowing why or how.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了插件的结构和使用方法，让我们创建一个非常简单的 "Hello World" 风格的插件，看看制作一个插件需要哪些步骤。虽然有一些工具，如
    **插件构建器** 插件，可以为您创建各种文件，但我们将避免使用它们，而是手动创建插件。这将使过程更清晰，并避免出现代码在没有了解原因或方式的情况下神奇地工作的情况。
- en: 'Go to the `~/.qgis2/python/plugins` directory and create a subdirectory named
    `testPlugin`. In this directory, create a file named `metadata.txt` and enter
    the following values into it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 `~/.qgis2/python/plugins` 目录，并创建一个名为 `testPlugin` 的子目录。在这个目录中，创建一个名为 `metadata.txt`
    的文件，并将以下值输入到其中：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is the minimum metadata you need to enter for a plugin. Obviously, you
    can change these values if you want. Now, create a package initialization file,
    `__init__.py`, and enter the following into that file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您为插件需要输入的最小元数据。显然，如果您想的话，可以更改这些值。现在，创建一个包初始化文件，`__init__.py`，并将以下内容输入到该文件中：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, we''re going to define a class named `TestPlugin` that represents
    our plugin object, and implement it in a module named `testPlugin.py`. Let''s
    create this module now:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将定义一个名为 `TestPlugin` 的类，它代表我们的插件对象，并在名为 `testPlugin.py` 的模块中实现它。现在让我们创建这个模块：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we created a Qt `QAction` object for our menu item, named it
    `Run`, and added it to the **Plugin** menu in a submenu named "Test Plugin". We
    then connected that action to our `onRun()` method, which simply displays a message
    to the user stating that the plugin is running.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们为我们的菜单项创建了一个 Qt `QAction` 对象，命名为 `Run`，并将其添加到名为 "Test Plugin" 的子菜单中的
    **插件** 菜单中。然后我们将该操作连接到我们的 `onRun()` 方法，该方法简单地显示一个消息给用户，说明插件正在运行。
- en: 'This is all we need for a very minimal plugin. Let''s test it out. Start QGIS
    and choose the **Manage and Install Plugins…** item from the **Plugins** menu.
    The QGIS **Plugin Manager** window will appear, and if you scroll down, you should
    see your plugin listed:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个非常简单的插件，我们只需要这些。让我们来测试一下。启动 QGIS 并从 **插件** 菜单中选择 **管理并安装插件…** 项。QGIS **插件管理器**
    窗口将出现，如果您向下滚动，应该会看到您的插件列在列表中：
- en: '![Creating a simple plugin](img/00037.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的插件](img/00037.jpeg)'
- en: If you click on the checkbox, the plugin will be activated. If you then look
    in the **Plugins** menu, you should see your plugin listed, and if you select
    the **Run** item from your plugin's submenu, the "Running" message box should
    be displayed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击复选框，插件将被激活。如果您然后在 **插件** 菜单中查看，应该会看到您的插件列在列表中，如果您从插件的子菜单中选择 **运行** 项，应该会显示
    "正在运行" 消息框。
- en: 'If your plugin isn''t working, or if it isn''t listed in the Plugin Manager
    window, you might have made a mistake in your code. If the plugin can''t be loaded
    for some reason, a window will appear, giving you the Python traceback when you
    attempt to install or reload the plugin:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的插件不起作用，或者它没有在插件管理器窗口中列出，您可能在代码中犯了错误。如果由于某种原因插件无法加载，当您尝试安装或重新加载插件时，将出现一个窗口，显示Python跟踪回溯：
- en: '![Creating a simple plugin](img/00038.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的插件](img/00038.jpeg)'
- en: This window will also appear if your plugin's code generates an exception while
    it is running.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的插件代码在运行时生成异常，此窗口也会出现。
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If there''s a problem with your plugin that prevents it from even being loaded
    (for example, a mistake in the `metadata.txt` file), you might need to check the
    **Log Messages** panel to see the error. You can show this panel by selecting
    it from the **Panels** submenu in the **View** menu; make sure you click on the
    **Plugins** tab to see the log messages associated with your plugin:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的插件存在问题，阻止其加载（例如，`metadata.txt`文件中的错误），您可能需要检查**日志消息**面板以查看错误。您可以通过从**视图**菜单中的**面板**子菜单中选择它来显示此面板；确保您点击**插件**选项卡以查看与您的插件相关的日志消息：
- en: '![Creating a simple plugin](img/00039.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的插件](img/00039.jpeg)'
- en: 'Let''s add one more feature to our test plugin: a toolbar item, which, when
    clicked on, also calls the `onRun()` method. Find a suitable PNG format image
    that is 24 x 24 pixels (the default size for a QGIS toolbar icon), and save that
    image into your plugin''s directory under the name `icon.png`. Then, change your
    `initGui()` method to look like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在测试插件中添加一个额外的功能：一个工具栏项，当点击时，也会调用`onRun()`方法。找到一个合适的24 x 24像素的PNG格式图像（这是QGIS工具栏图标的默认大小），并将该图像保存到您的插件目录下，文件名为`icon.png`。然后，将您的`initGui()`方法更改为以下内容：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The changed lines have been highlighted. As you can see, we've added an icon
    to our `QAction` object, and then also called the `addToolBarIcon()` method to
    add our action to the Plugins toolbar.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 已更改的行已被突出显示。正如您所看到的，我们已向我们的`QAction`对象添加了一个图标，然后还调用了`addToolBarIcon()`方法将我们的操作添加到插件工具栏中。
- en: 'We''ll also have to add one extra line to our `unload()` method to remove the
    toolbar icon when the plugin is unloaded:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在`unload()`方法中添加一行额外的代码，以便在插件卸载时删除工具栏图标：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There''s one last thing we need to do before our toolbar icon will work; we
    need to tell QGIS that the `icon.png` file is a **resource** used by our plugin.
    This is done through the `resources.qrc` file. Create this file now, placing it
    into your plugin''s directory, and edit it using your favorite text editor, so
    that it contains the following XML format text:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工具栏图标起作用之前，我们还需要做最后一件事；我们需要告诉QGIS，`icon.png`文件是我们插件使用的**资源**。这是通过`resources.qrc`文件完成的。现在创建此文件，将其放入您的插件目录中，并使用您喜欢的文本编辑器进行编辑，使其包含以下XML格式文本：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'QGIS can''t use this file directly; it has to be compiled into a `resources.py`
    module using the **pyrcc4** command-line tool. This tool is installed as part
    of PyQt; once you''ve created your `resources.qrc` file, use the following command
    to compile it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS无法直接使用此文件；它必须使用**pyrcc4**命令行工具编译成`resources.py`模块。此工具作为PyQt的一部分安装；一旦您创建了您的`resources.qrc`文件，请使用以下命令编译它：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Depending on where PyQt installed it, you might need to include the path to
    the `pyrcc4` command. If you run this command from a directory other than the
    plugin directory, you will also need to include the path to the `resources.qrc`
    and `resource.py` files.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据PyQt安装的位置，您可能需要包含`pyrcc4`命令的路径。如果您从除插件目录以外的目录运行此命令，您还需要包含`resources.qrc`和`resource.py`文件的路径。
- en: 'Finally, we need to add the following to the top of our `testPlugin.py` module:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将以下内容添加到我们的`testPlugin.py`模块顶部：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This makes the compiled resources available for our plugin to use. When you
    reload your plugin, an icon should appear in the QGIS toolbar, and if you click
    on that icon, the "Running" message box should be displayed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得编译后的资源可供我们的插件使用。当您重新加载插件时，工具栏中应出现一个图标，并且如果您点击该图标，应显示“正在运行”消息框。
- en: 'While this plugin is very basic, we''ve actually learned a lot: how to create
    and install a plugin, how a plugin can add itself to the QGIS user interface,
    how plugins interact with the user, how errors in a plugin are handled, and how
    to deal with images and other plugin resources. Let''s take a closer look now
    at the processes typically used to develop and distribute plugins, before going
    on to create a plugin that actually does something useful.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个插件非常基础，但我们实际上学到了很多：如何创建和安装插件，插件如何将自己添加到QGIS用户界面，插件如何与用户交互，插件中的错误如何处理，以及如何处理图像和其他插件资源。现在，在我们创建一个真正有用的插件之前，让我们更详细地看看通常用于开发和分发插件的过程。
- en: The plugin development process
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件开发过程
- en: In the previous section, we created a plugin by hand, directly storing the necessary
    files in the hidden `~/.qgis2` directory. This isn't a particularly robust way
    of building plugins. In this section, we will look at some of the best practices
    for developing and distributing plugins, as well as some of the things you need
    to be aware of when creating your own plugins.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们手动创建了一个插件，直接将必要的文件存储在隐藏的`~/.qgis2`目录中。这不是构建插件的一种特别稳健的方法。在本节中，我们将探讨一些开发和管理插件的最佳实践，以及创建自己的插件时需要注意的一些事项。
- en: Using the Plugin Builder
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用插件构建器
- en: QGIS provides a plugin called **Plugin Builder** that you can use to create
    your new plugin from a standard template. Plugin Builder is a sophisticated and
    useful tool for creating plugins, but it does make some assumptions about the
    way your plugin will be structured and what it will do. For this reason, we deliberately
    didn't use the Plugin Builder for our example plugins.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS提供了一个名为**插件构建器**的插件，您可以使用它从标准模板创建新的插件。插件构建器是一个复杂且有用的工具，用于创建插件，但它确实对您的插件结构以及它将执行的操作做了一些假设。因此，我们故意没有在我们的示例插件中使用插件构建器。
- en: 'More information on the Plugin Builder can be found at [http://geoapt.net/pluginbuilder](http://geoapt.net/pluginbuilder).
    You can install the Plugin Builder directly from within QGIS, using the **Manage
    and Install Plugins...** item from the **Plugins** menu. Once installed, you simply
    click on the Plugin Builder''s icon in the toolbar, and you will be prompted to
    fill in various details about your new plugin:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于插件构建器的信息可以在[http://geoapt.net/pluginbuilder](http://geoapt.net/pluginbuilder)找到。您可以直接从QGIS中安装插件构建器，使用**插件**菜单中的**管理并安装插件...**项。安装后，您只需在工具栏中点击插件构建器的图标，系统会提示您填写有关您新插件的各种详细信息：
- en: '![Using the Plugin Builder](img/00040.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![使用插件构建器](img/00040.jpeg)'
- en: After filling in the information, you will be prompted to select the directory
    in which your plugin's source code is stored. The Plugin Builder will then create
    the necessary files for you.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 填写信息后，您将被提示选择存储插件源代码的目录。然后，插件构建器将为您创建必要的文件。
- en: It is up to you whether to use Plugin Builder or not, and whether or not to
    use all the features it provides. For example, the Plugin Builder provides a *make*
    target to create the HTML format help files for your plugin, using Sphynx. If
    you prefer to create your help files in a different way, or don't want to create
    help files at all, you can simply ignore this option.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用插件构建器以及是否使用它提供的所有功能取决于您。例如，插件构建器提供了一个*make*目标，用于使用Sphynx创建您插件的HTML格式帮助文件。如果您更喜欢以不同的方式创建帮助文件，或者根本不想创建帮助文件，您可以直接忽略此选项。
- en: 'One of the problems with using Plugin Builder is the complexity of the generated
    plugin. Right from the outset, your plugin will include:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用插件构建器的一个问题是生成的插件复杂性。从一开始，您的插件将包括：
- en: Help files, both in reStructuredText and in HTML format, as well as directories
    for holding images and HTML templates
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助文件，包括reStructuredText和HTML格式，以及用于存储图像和HTML模板的目录
- en: Support for internationalization
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化支持
- en: A Makefile to automate the plugin building process
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于自动化插件构建过程的Makefile
- en: A Python script for uploading the plugin to the QGIS plugin repository
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于将插件上传到QGIS插件库的Python脚本
- en: A `pylintrc` file, allowing you to check your plugin's Python source files using
    the Pylint code-analysis system
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`pylintrc`文件，允许您使用Pylint代码分析系统检查您的插件Python源文件
- en: Two separate README files, one in HTML and another in plain text format
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个单独的README文件，一个是HTML格式，另一个是纯文本格式
- en: Various shell scripts
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种shell脚本
- en: A range of standard unit tests
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列标准单元测试
- en: The UI template and Python code that displays a dialog box when the plugin is
    run
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当插件运行时显示对话框的 UI 模板和 Python 代码
- en: All of this leads to a rather complex directory structure, with lots of files
    that may or may not be relevant to you. You can certainly remove the various files
    and directories you don't need, but this can be risky if you don't know what the
    files and directories are for.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都导致了一个相当复杂的目录结构，其中包含许多可能或可能与你无关的文件。你当然可以删除你不需要的各种文件和目录，但如果你不知道这些文件和目录的作用，这可能会很危险。
- en: Due to all this complexity, we won't be using Plugin Builder in this book. Instead,
    we'll create our plugins manually, only adding the files and directories you need
    so that you can understand what everything does.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些复杂性，我们不会在这本书中使用 Plugin Builder。相反，我们将手动创建我们的插件，只添加你需要的文件和目录，这样你就可以理解每件事的作用。
- en: Automating the build process
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化构建过程
- en: For our example plugin, we had to create the `resources.qrc` file and then compile
    this file into a `resources.py` file using the `pyrcc4` command-line tool. Whenever
    we made a change to the `resources.qrc` file, we had to remember to recompile
    it. The same thing applies to any user-interface template (`.ui`) files in our
    plugin.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例插件，我们必须创建 `resources.qrc` 文件，然后使用 `pyrcc4` 命令行工具将此文件编译成 `resources.py`
    文件。每次我们对 `resources.qrc` 文件进行更改时，都必须记得重新编译它。同样，这也适用于插件中的任何用户界面模板（`.ui`）文件。
- en: 'Manually running the compiler each time you make a change is poor programming
    practice. Instead, you should use a **Makefile** to automate the process. We won''t
    go into the details of how to use *make* here (there are complete books on this
    topic), but we will use it to compile all the necessary files with a single command.
    We will also store the plugin''s source files in a different directory, and use
    *make* to compile and copy all the necessary files into the `~/.qgis2` directory:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每次更改时手动运行编译器是糟糕的编程实践。相反，你应该使用 **Makefile**来自动化这个过程。我们不会详细介绍如何使用 *make*（有关于这个主题的完整书籍），但我们将使用它通过单个命令编译所有必要的文件。我们还将把插件源文件存储在不同的目录中，并使用
    *make* 编译和复制所有必要的文件到 `~/.qgis2` 目录：
- en: '![Automating the build process](img/00041.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![自动化构建过程](img/00041.jpeg)'
- en: This ensures that the various files in the running plugin are all consistent—you
    can't forget to compile a template, or break the running plugin by running an
    updated Python source file before a template has been recompiled. Keeping your
    source files separate from your running code is also an excellent programming
    practice.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了运行中的插件中的各种文件都是一致的——你不会忘记编译一个模板，或者在没有重新编译模板之前运行更新的 Python 源文件，从而破坏正在运行的插件。将源文件与运行代码分开也是一项优秀的编程实践。
- en: 'By using *make* in this way, you end up with a highly productive process for
    developing and testing your plugin:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式使用 *make*，你最终会得到一个高度高效的插件开发和测试过程：
- en: '![Automating the build process](img/00042.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![自动化构建过程](img/00042.jpeg)'
- en: 'A typical Makefile for building and running QGIS plugins looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的用于构建和运行 QGIS 插件的 Makefile 看起来像这样：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The top portion of the Makefile sets five variables that tell *make* about
    your plugin:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 的顶部部分设置了五个变量，告诉 *make* 关于你的插件的信息：
- en: '`PLUGINNAME` is, of course, the name of your plugin.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PLUGINNAME` 当然是你的插件名称。'
- en: '`PY_FILES` is a list of the Python source files that make up your plugin''s
    source code.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PY_FILES` 是一个包含构成你的插件源代码的 Python 源文件的列表。'
- en: '`EXTRAS` is a list of additional files that should be included with your plugin.
    You would typically include the `metadata.txt` file and any additional images
    or other files used by your plugin.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXTRAS` 是一个包含应与你的插件一起包含的附加文件的列表。你通常会包含 `metadata.txt` 文件以及插件使用的任何其他图像或其他文件。'
- en: '`UI_FILES` is a list of the UI templates that need to be compiled for your
    plugin to work. Note that you have to use the `.py` suffix for each template file,
    as you''re telling *make* which file you want to have recompiled when the corresponding
    `.ui` file is changed.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UI_FILES` 是一个包含需要编译以使插件工作的 UI 模板的列表。请注意，你必须为每个模板文件使用 `.py` 后缀，这样你就是在告诉 *make*
    当相应的 `.ui` 文件更改时，你想重新编译哪个文件。'
- en: '`RESOURCE_FILES` is a list of the resource files used by your application.
    Once again, you have to use the `.py` suffix for each resource file rather than
    the `.qrc` version of the file.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RESOURCE_FILES` 是一个包含应用程序使用的资源文件的列表。同样，你必须为每个资源文件使用 `.py` 后缀，而不是文件的 `.qrc`
    版本。'
- en: Typically, you would only have to change the values of these five variables
    to set up your Makefile. However, if the `pyrcc4` or `pyuic4` command-line tools
    are in a nonstandard location, or if QGIS uses a directory other than `~/.qgis2/python/plugins`
    for its Python plugins, then you will have to modify the other parts of the Makefile
    so that it works with your particular development setup.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您只需更改这五个变量的值即可设置您的 Makefile。然而，如果 `pyrcc4` 或 `pyuic4` 命令行工具位于非标准位置，或者如果 QGIS
    使用除 `~/.qgis2/python/plugins` 之外的其他目录作为其 Python 插件目录，那么您将不得不修改 Makefile 的其他部分，以便它与您的特定开发设置兼容。
- en: 'Once it has been set up, the Makefile provides three **make targets** that
    you can use:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，Makefile 提供了三个 **make 目标**，您可以使用：
- en: '`make compile` (or just `make`) will compile your plugin''s `.ui` and `.qrc`
    files into the corresponding `.py` modules.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make compile`（或仅 `make`）将您的插件 `.ui` 和 `.qrc` 文件编译成相应的 `.py` 模块。'
- en: '`make deploy` will compile the `.ui` and `.qrc` files, and then copy all the
    necessary files into the QGIS plugin directory.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make deploy` 将编译 `.ui` 和 `.qrc` 文件，然后将所有必要的文件复制到 QGIS 插件目录中。'
- en: '`make clean` will remove the `.py` version of your `.ui` and `.qrc` files.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make clean` 将删除 `.ui` 和 `.qrc` 文件的 `.py` 版本。'
- en: You can use `make deploy` and then click on the Plugin Reloader tool in QGIS
    to run the latest version of your plugin so you can test it out.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `make deploy` 并在 QGIS 中点击插件重载工具来运行您插件的最新版本，以便您可以对其进行测试。
- en: Plugin help files
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插件帮助文件
- en: 'QGIS allows you to include an HTML-formatted help file for your plugin. This
    file will be displayed using the built-in QGIS help browser if your plugin calls
    the `qgis.utils.showPluginHelp()` function. This function has the following signature:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS 允许您为您的插件包含一个 HTML 格式的帮助文件。如果您的插件调用 `qgis.utils.showPluginHelp()` 函数，则该文件将使用内置的
    QGIS 帮助浏览器显示。此函数具有以下签名：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The various parameters are as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 各种参数如下：
- en: '`packageName`: This is the name of the Python package where the help file can
    be found. If a package is specified, QGIS will look for the help files inside
    the given package directory. Otherwise, it will look for the help files in the
    same directory as the Python module that called `showPluginHelp()`. Note that
    it''s quite unusual for a plugin to use this parameter, and you would normally
    just leave it set to `None`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packageName`：这是可以找到帮助文件的 Python 包的名称。如果指定了包，QGIS 将在给定的包目录中查找帮助文件。否则，它将在调用
    `showPluginHelp()` 的 Python 模块所在的同一目录中查找帮助文件。请注意，插件使用此参数的情况相当不常见，您通常会将其设置为 `None`。'
- en: '`filename`: This is the base name for the HTML help file to display. Note that
    an appropriate suffix (for example, `.html`) will be added to this base name.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename`：这是要显示的 HTML 帮助文件的基名。请注意，将添加适当的后缀（例如，`.html`）到该基名。'
- en: '`section`: This is the name of an optional HTML anchor tag, which the help
    file will be scrolled to when it is opened.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`section`：这是一个可选的 HTML 锚点标签的名称，当帮助文件打开时，它将滚动到该标签。'
- en: Note that the `filename` parameter is the *base* name for the desired HTML file.
    QGIS allows you to have your help files translated into multiple languages, and
    will automatically choose the appropriate version of the file based on the current
    locale. If a translated version of the help file is not available in the current
    language, then QGIS will fall back to displaying the US English version of the
    help file, and if that's not available, it will use the file named `filename.html`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`filename` 参数是所需 HTML 文件的 *基本* 名称。QGIS 允许您将帮助文件翻译成多种语言，并且会根据当前区域设置自动选择适当的文件版本。如果当前语言中没有可用的翻译版本，则
    QGIS 将回退到显示帮助文件的美国英语版本；如果该版本也不可用，则将使用名为 `filename.html` 的文件。
- en: This allows you to include translated versions of your help files if you want
    (for example, `index-es.html`, `index-de.html`, and `index-fr-ca.html`), but if
    you don't want to have translated help files, a single `index.html` file will
    suffice.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您在需要时包含翻译版本的帮助文件（例如，`index-es.html`、`index-de.html` 和 `index-fr-ca.html`），但如果您不想有翻译的帮助文件，一个单独的
    `index.html` 文件就足够了。
- en: 'There are several ways in which you can organize your plugin''s online help.
    The following are some examples:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过几种方式组织您插件的在线帮助。以下是一些示例：
- en: You can put all the documentation for your plugin in a single file named `index.html`,
    and then simply call `showPluginHelp()` with no parameters to display that help
    file when the user asks for help.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将您插件的全部文档放入一个名为 `index.html` 的单个文件中，然后只需调用 `showPluginHelp()` 函数（不带参数）来显示该帮助文件，当用户请求帮助时。
- en: You can use a different filename for your help file and supply that name in
    the `filename` parameter when calling `showPluginHelp()`, for example, `showPluginHelp(filename="plugin_help")`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以为你的帮助文件使用不同的文件名，并在调用`showPluginHelp()`时在`filename`参数中提供该名称，例如，`showPluginHelp(filename="plugin_help")`。
- en: You're not just limited to having one help file. You can have a whole directory
    of help files, and have the `index.html` file act as a table of contents for the
    plugin's online help. To do this, call `showPluginHelp` with `filename` set to
    something like `os.path.join("help_files", "index")` so that the help file is
    found in a subdirectory rather than the main plugin directory.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不仅限于只有一个帮助文件。你可以有一个包含多个帮助文件的整个目录，让`index.html`文件充当插件在线帮助的目录。为此，调用`showPluginHelp`时将`filename`设置为类似`os.path.join("help_files",
    "index")`的值，这样帮助文件就会在子目录中而不是主插件目录中找到。
- en: If you have multiple help files, for example, one for each of your plugin's
    main features, you might choose to display the appropriate help file based on
    which feature the user is using at that time. For example, you might add a **Help**
    button to a complex dialog or window and have that button call `showPluginHelp(filename="my_dialog")`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有多份帮助文件，例如，每份对应你插件的主要功能之一，你可能根据用户当时使用的是哪个功能来选择显示相应的帮助文件。例如，你可能会在复杂的对话框或窗口中添加一个**帮助**按钮，并让该按钮调用`showPluginHelp(filename="my_dialog")`。
- en: 'Finally, you might put all your documentation into a single file, and use HTML
    anchor tags (for example, `<a id="my_dialog">My Dialog</a>`) to define the various
    sections of your documentation. You will then use the `section` parameter to jump
    directly to that section of your plugin''s documentation, like this: `showPluginHelp(section="my_dialog")`.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可能将所有文档放入一个单独的文件中，并使用HTML锚点标签（例如，`<a id="my_dialog">My Dialog</a>`）来定义文档的各个部分。然后，你可以使用`section`参数直接跳转到插件文档的该部分，如下所示：`showPluginHelp(section="my_dialog")`。
- en: Of course, while your help file has to end up in HTML format, you might not
    want to write HTML directly. Instead, you can write your documentation using a
    markup language such as Markdown, reStructuredText, or Latex, and then use a documentation
    generator to convert your marked-up files into HTML. This is a perfect example
    of something that can be automated using a Makefile, and indeed, the Plugin Builder's
    default Makefile includes support for using Sphinx to convert reStructuredText
    markup into HTML.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，虽然你的帮助文件最终需要以HTML格式呈现，但你可能不想直接编写HTML。相反，你可以使用Markdown、reStructuredText或Latex等标记语言编写你的文档，然后使用文档生成器将标记文件转换为HTML。这是一个可以通过Makefile自动化的完美示例，实际上，插件构建器的默认Makefile包括了使用Sphinx将reStructuredText标记转换为HTML的支持。
- en: Unit testing
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Unit tests are a common programming technique to make sure each part of your
    code works as it should. The following is a very simple example of a unit test
    written in Python:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种常见的编程技术，用于确保你的代码的每一部分都能按预期工作。以下是一个用Python编写的非常简单的单元测试示例：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can run this unit test either directly from the command line, or by adding
    extra code to create a `TestRunner` object that you can then use to run the test.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接从命令行运行这个单元测试，或者添加额外的代码来创建一个`TestRunner`对象，然后你可以使用该对象来运行测试。
- en: We're not going to describe the rationale behind unit testing, or how to use
    the `unittest` library to test your Python code. However, it is worth spending
    some time learning how you can write and run unit tests for your QGIS plugins.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会描述单元测试背后的原理，或者如何使用`unittest`库来测试你的Python代码。然而，花些时间学习如何为你的QGIS插件编写和运行单元测试是值得的。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you haven't worked with the `unittest` module before, check out [http://docs.python-guide.org/en/latest/writing/tests](http://docs.python-guide.org/en/latest/writing/tests).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过`unittest`模块，请查看[http://docs.python-guide.org/en/latest/writing/tests](http://docs.python-guide.org/en/latest/writing/tests)。
- en: 'Unit testing is done outside of QGIS itself; that is, the unit tests run as
    an external Python application that loads your plugin and then tests it. Doing
    this isn''t as bad as it sounds; in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with QGIS"), *Getting Started with QGIS*, we looked at a simple external
    application built on top of QGIS, and we can use pretty much the same process
    to write our testing code. Here''s the boilerplate example of an external application,
    copied from [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting Started
    with QGIS"), *Getting Started with QGIS*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是在 QGIS 本身之外进行的；也就是说，单元测试作为外部 Python 应用程序运行，该应用程序加载你的插件然后对其进行测试。这样做并不像听起来那么糟糕；在
    [第 1 章](part0014_split_000.html#page "第 1 章。QGIS 入门")，*QGIS 入门* 中，我们查看了一个基于 QGIS
    的简单外部应用程序，我们可以使用几乎相同的过程来编写我们的测试代码。以下是从 [第 1 章](part0014_split_000.html#page "第
    1 章。QGIS 入门")，*QGIS 入门* 复制的样板外部应用程序示例：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You will also need to use an appropriate wrapper script, as described in [Chapter
    1](part0014_split_000.html#page "Chapter 1. Getting Started with QGIS"), *Getting
    Started with QGIS*, so that the Python path and other environment variables are
    set correctly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要使用一个适当的包装脚本，如 [第 1 章](part0014_split_000.html#page "第 1 章。QGIS 入门")，*QGIS
    入门* 中所述，以确保正确设置 Python 路径和其他环境变量。
- en: 'With QGIS unit tests, you have to set up the QGIS environment before the test
    is run, and then shut it down again once the test finishes. This is done by placing
    the appropriate parts of the boilerplate code into the unit test''s `setup()`
    and `tearDown()` methods, like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QGIS 单元测试中，你必须在测试运行之前设置 QGIS 环境，然后在测试完成后再次关闭。这是通过将样板代码的适当部分放入单元测试的 `setup()`
    和 `tearDown()` 方法中实现的，如下所示：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can then import and test your plugin's Python code within the `test_plugin()`
    method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在 `test_plugin()` 方法中导入并测试你的插件 Python 代码。
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can, of course, have multiple `test_XXX()` methods in your test case. The
    PyQGIS library will be initialized before the first test is run, and shut down
    after the last test finishes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在你的测试用例中拥有多个 `test_XXX()` 方法。PyQGIS 库将在第一个测试运行之前初始化，并在最后一个测试完成后关闭。
- en: 'Testing plugins in this way does reveal a major limitation of this approach:
    there is no `QgisInterface` object available for your plugin to use. This means
    that the parts of the plugin you''re testing can''t interact with the rest of
    the QGIS system via the `iface` variable.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式测试插件确实揭示了这种方法的一个主要局限性：没有 `QgisInterface` 对象可供你的插件使用。这意味着你正在测试的插件部分不能通过
    `iface` 变量与 QGIS 系统的其他部分交互。
- en: 'Unit tests get around this limitation by creating a fake QGIS environment (including
    a Python implementation of `QgisInterface`), which the plugin can use for testing.
    The plugin is then loaded by adding the plugin''s directory to `sys.path` and
    then calling the plugin''s `ClassFactory()` function with the fake `QgisInterface`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通过创建一个假的 QGIS 环境（包括 `QgisInterface` 的 Python 实现）来克服这个限制，插件可以使用这个环境进行测试。然后，通过将插件目录添加到
    `sys.path` 并调用插件的 `ClassFactory()` 函数，使用假的 `QgisInterface` 来加载插件：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: While it seems complex and might introduce errors that only occur while the
    plugin is being tested, this process is actually very useful. If you want to use
    unit tests, you can either implement your own `QgsInterface` or make use of the
    unit testing framework provided by the Plugin Builder.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个过程看起来很复杂，可能会引入仅在插件测试期间出现的错误，但实际上这个过程非常有用。如果你想使用单元测试，你可以实现自己的 `QgsInterface`
    或使用 Plugin Builder 提供的单元测试框架。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to roll your own unit tests, a good starting point is available
    at [http://snorf.net/blog/2014/01/04/writing-unit-tests-for-qgis-python-plugins](http://snorf.net/blog/2014/01/04/writing-unit-tests-for-qgis-python-plugins).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要自己编写单元测试，一个很好的起点可以在 [http://snorf.net/blog/2014/01/04/writing-unit-tests-for-qgis-python-plugins](http://snorf.net/blog/2014/01/04/writing-unit-tests-for-qgis-python-plugins)
    找到。
- en: 'If you are doing unit testing, then you would normally add an extra target
    to your Makefile so you can run the unit tests simply by typing:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在进行单元测试，那么你通常会向你的 Makefile 中添加一个额外的目标，这样你就可以通过简单地输入命令来运行单元测试：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Distributing your plugin
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发你的插件
- en: To share your plugin with others, you have to upload it to a plugin repository.
    Let's look at the steps involved in doing this.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与他人分享你的插件，你必须将其上传到插件仓库。让我们看看完成这一步骤的步骤。
- en: 'Firstly, you need to ensure that your plugin adheres to the following rules:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要确保你的插件遵循以下规则：
- en: The name of your plugin's folder must contain only upper- and lowercase letters,
    digits, underscores, and hyphens, and must not start with a digit.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您插件文件夹的名称必须只包含大写和小写字母、数字、下划线和连字符，并且不能以数字开头。
- en: 'Your `metadata.txt` file must exist and include the following entries:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的 `metadata.txt` 文件必须存在，并包含以下条目：
- en: '| Metadata entry | Description |'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 元数据条目 | 描述 |'
- en: '| --- | --- |'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `name` | The name of your plugin. |'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `name` | 您插件的名称。 |'
- en: '| `qgisMinimumVersion` | The minimum version of QGIS that your plugin will
    run under. |'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `qgisMinimumVersion` | 您的插件将运行的 QGIS 的最低版本。 |'
- en: '| `description` | A brief textual description of your plugin and what it does.
    |'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `description` | 您插件及其功能的简要文本描述。 |'
- en: '| `version` | The version number of your plugin, as a string. Note that you
    can''t upload two copies of a plugin with the same version. |'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `version` | 您插件的版本号，作为字符串。请注意，您不能上传具有相同版本的插件副本。 |'
- en: '| `author` | The name of the plugin''s author. |'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `author` | 插件作者的姓名。 |'
- en: '| `email` | The author''s e-mail address. |'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `email` | 作者的电子邮件地址。 |'
- en: If you don't follow these rules, your plugin will be rejected when you attempt
    to upload it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不遵循这些规则，当您尝试上传插件时，它将被拒绝。
- en: The next step is to compress the plugin into a ZIP archive. Note that you should
    compress the folder that contains your plugin, so that the ZIP archive has only
    one entry (the plugin's directory) rather than a collection of individual files.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将插件压缩成 ZIP 归档。请注意，您应该压缩包含您的插件的文件夹，这样 ZIP 归档就只有一个条目（插件的目录），而不是一系列单独的文件。
- en: 'The final step is to upload the ZIP archive to a QGIS plugin repository. You
    have two options here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将 ZIP 归档上传到 QGIS 插件仓库。这里有您两个选择：
- en: You can use the official plugin repository at [http://plugins.qgis.org](http://plugins.qgis.org).
    This will make your plugin available to all QGIS users.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用官方插件仓库[http://plugins.qgis.org](http://plugins.qgis.org)。这将使您的插件对所有 QGIS
    用户可用。
- en: You can set up your own plugin repository. This means that only people who know
    about your repository or have access to it (for example, via a VPN) can download
    your plugins.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以设置自己的插件仓库。这意味着只有知道您的仓库或可以访问它的人（例如，通过 VPN）才能下载您的插件。
- en: 'Setting up your own plugin repository isn''t nearly as daunting as it sounds;
    you simply create an XML file that lists the plugins that you want to make available,
    and then upload that XML file and the plugins themselves to a web server. Here
    is what the XML file looks like:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 设置您自己的插件仓库并不像听起来那么可怕；您只需创建一个 XML 文件，列出您希望提供的插件，然后将该 XML 文件以及插件本身上传到 Web 服务器。以下是
    XML 文件的外观：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a `<pyqgis_plugin>` section for each of your repository''s plugins.
    Once this file has been uploaded, the user simply goes to the QGIS Plugin Manager
    window, clicks on the **Settings** tab, and clicks on the **Add** button in the
    **Plugin repositories** section of the window. The user will be asked to enter
    the details of the new repository:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为您仓库中的每个插件创建一个 `<pyqgis_plugin>` 部分。一旦上传此文件，用户只需转到 QGIS 插件管理器窗口，点击 **设置** 选项卡，然后点击窗口中
    **插件仓库** 部分的 **添加** 按钮。用户将被要求输入新仓库的详细信息：
- en: '![Distributing your plugin](img/00043.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![分发您的插件](img/00043.jpeg)'
- en: The **URL** field should be set to the complete URL for the XML file you uploaded,
    for example `http://my-site.com/qgis_plugins.xml`. Once the repository has been
    added, the plugins listed in the XML file will appear in the Plugin Manager, and
    the user can install them directly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**URL** 字段应设置为已上传 XML 文件的完整 URL，例如 `http://my-site.com/qgis_plugins.xml`。一旦添加了仓库，XML
    文件中列出的插件将出现在插件管理器中，用户可以直接安装它们。'
- en: Writing a useful plugin
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写有用的插件
- en: Let's now apply the knowledge we've gained to build a plugin that does something
    useful and interesting. While there are built-in tools in QGIS to query a feature
    and identify the feature's attributes, there is no easy way of getting information
    about the *geometry* associated with a feature. So let's write a plugin that lets
    the user click on a feature and display various statistics about that feature's
    geometry.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将所学知识应用于构建一个有用的有趣插件。虽然 QGIS 中有内置工具可以查询要素并识别要素的属性，但没有简单的方法来获取与要素相关的 *几何形状*
    信息。因此，让我们编写一个插件，允许用户点击要素并显示该要素几何形状的各种统计数据。
- en: We're going to call our new plugin **Geometry Info**. When the user clicks on
    our plugin's toolbar icon, we will activate a map tool that listens for mouse
    clicks on the map canvas. When the user clicks on the map canvas, we'll find the
    feature that the user clicked on, and calculate and display statistics about that
    feature's geometry.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的新插件命名为**几何信息**。当用户点击我们的插件工具栏图标时，我们将激活一个地图工具，该工具会监听地图画布上的鼠标点击。当用户点击地图画布时，我们将找到用户点击的特征，并计算并显示该特征的几何统计信息。
- en: 'Let''s start by setting up the basic template for our plugin. Create a directory
    named `geometryInfo`, put it somewhere convenient, and create an `__init__.py`
    file within that directory. In that file, place the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为我们的插件设置一个基本模板。创建一个名为`geometryInfo`的目录，将其放置在方便的位置，并在该目录中创建一个`__init__.py`文件。在该文件中，放置以下代码：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we need to define the metadata for our plugin. Create the `metadata.txt`
    file and add the following to this file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义我们插件的数据。创建`metadata.txt`文件，并将以下内容添加到该文件中：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we need an icon for our plugin. We''re going to use the following icon:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的插件创建一个图标。我们将使用以下图标：
- en: '![Writing a useful plugin](img/00044.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![编写有用的插件](img/00044.jpeg)'
- en: A copy of this icon is available with the sample code that comes with this book,
    though you can create your own icon or find a different one to use somewhere;
    just make sure that the resulting image file is named `icon.png`, and that the
    icon is 24 x 24 pixels. Place this file into your `geometryInfo` directory along
    with the other files.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该图标的副本包含在此书的示例代码中，尽管您可以创建自己的图标或找到其他图标来使用；只需确保生成的图像文件命名为`icon.png`，并且图标大小为24
    x 24像素。将此文件放入您的`geometryInfo`目录中，与其他文件一起放置。
- en: 'We next need to define the `resources.qrc` file that tells QGIS about our icon.
    Create this file and put the following text into it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要定义一个`resources.qrc`文件，这个文件会告诉QGIS关于我们图标的信息。创建这个文件，并将以下文本放入其中：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, let''s create a Makefile to automate the process of compiling and
    deploying our plugin. Here''s a suitable Makefile to get you started:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个Makefile来自动化编译和部署我们插件的过程。以下是一个合适的Makefile，供您开始使用：
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You may need to modify the paths in this file to suit your development setup.
    Notice that because our plugin won't have any UI templates, we've removed the
    portions of the Makefile that compile and deploy the template files.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要修改此文件中的路径以适应您的开发设置。请注意，由于我们的插件没有任何UI模板，我们已经从Makefile中移除了编译和部署模板文件的相应部分。
- en: 'Now that we''ve created the framework for our plugin, let''s start writing
    the code that does the actual work. The final file we need for our plugin will
    be named `geometryInfo.py`. Create this file and put the following code into it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的插件创建了框架，让我们开始编写实际工作的代码。我们插件需要的最后一个文件将命名为`geometryInfo.py`。创建此文件，并将以下代码放入其中：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Apart from a few extra `import` statements (which we'll need later on), this
    is almost identical to our earlier example plugin. The `onClick()` method, of
    course, is just a placeholder so we can tell if the plugin is working.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 除了几个额外的`import`语句（我们稍后会用到）之外，这几乎与我们的早期示例插件相同。`onClick()`方法当然只是一个占位符，这样我们就可以知道插件是否在正常工作。
- en: We can now run our plugin by typing `make deploy` in the command line, starting
    up QGIS, and enabling the plugin using the **Manage and Install Plugins...** command,
    just like we did earlier. If all goes well, the plugin's icon should appear in
    the QGIS toolbar, and when you select it, the "Click" message should be displayed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过在命令行中输入`make deploy`来运行我们的插件，启动QGIS，并使用**管理并安装插件...**命令启用插件，就像我们之前做的那样。如果一切顺利，插件图标应该出现在QGIS工具栏中，并且当您选择它时，应该显示“点击”消息。
- en: 'Next, we want to make our toolbar icon *checkable*. That is, when the user
    clicks on our icon, we want to highlight it, activate our map tool, and keep the
    icon highlighted until the user either clicks on the icon again or switches to
    a different tool. To make the toolbar icon checkable, add the following line to
    your `initGui()` method, immediately after the `self.action = QAction(...)` statement:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望使我们的工具栏图标可勾选。也就是说，当用户点击我们的图标时，我们希望突出显示它，激活我们的地图工具，并保持图标突出显示，直到用户再次点击图标或切换到不同的工具。为了使工具栏图标可勾选，请将以下行添加到您的`initGui()`方法中，紧接在`self.action
    = QAction(...)`语句之后：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We then have to respond to the checking and unchecking of our toolbar icon
    by activating and deactivating our map tool. Here is what the code will look like:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须对工具栏图标的勾选和取消勾选做出响应，通过激活和停用我们的地图工具。以下是代码的示例：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first thing we do is see if the user has unchecked our icon, and if this
    is the case, we deactivate the map tool. Otherwise, we visually highlight the
    icon by calling `self.action.setChecked(True)`, and then activate our map tool.
    In this way, our plugin will act like a mode within QGIS; clicking on the icon
    will activate the map tool, and clicking on it again (or selecting a different
    icon) will deactivate it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查用户是否取消选中了我们的图标，如果是这样，我们就停用地图工具。否则，我们通过调用 `self.action.setChecked(True)`
    来视觉上突出显示图标，然后激活我们的地图工具。这样，我们的插件将像 QGIS 中的一个模式一样工作；点击图标将激活地图工具，再次点击它（或选择不同的图标）将停用它。
- en: We're now ready to implement our map tool. Earlier, we looked at how you can
    use the `QgsMapTool` class to respond to mouse clicks within the map canvas. In
    this case, we'll use a subclass of `QgsMapTool`, called `QgsMapToolIdentify`.
    This class makes it easy to find the feature at a given point. When the user clicks
    on the map canvas, we'll use the `QgsMapToolIdentify.identify()` method to find
    the first clicked-on feature, and then calculate and display various statistics
    about that feature's geometry.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好实现我们的地图工具。之前，我们看了如何使用 `QgsMapTool` 类来响应地图画布内的鼠标点击。在这种情况下，我们将使用 `QgsMapTool`
    的一个子类，称为 `QgsMapToolIdentify`。这个类使得在给定点查找功能变得容易。当用户点击地图画布时，我们将使用 `QgsMapToolIdentify.identify()`
    方法来找到第一个点击的功能，然后计算并显示该功能几何形状的各种统计数据。
- en: 'Add the following code to the end of your `geometryInfo.py` module:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的 `geometryInfo.py` 模块末尾：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This defines our `QgsMapToolIdentify` subclass. It doesn''t do anything useful
    yet, but it will respond with a simple "Canvas Click" message when the user clicks
    on the map canvas. Now, let''s finish writing our plugin''s `onClick()` method
    to activate and deactivate our map tool as the user clicks on our toolbar icon.
    This is what the `onClick()` method should look like:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了我们的 `QgsMapToolIdentify` 子类。目前它还没有做任何有用的事情，但它会在用户点击地图画布时响应一个简单的“Canvas Click”消息。现在，让我们完成编写我们插件中的
    `onClick()` 方法，以便在用户点击我们的工具栏图标时激活和停用我们的地图工具。`onClick()` 方法应该看起来像这样：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You should now be able to run your plugin by typing `make deploy`, and then
    reload it in QGIS to see how it works. If all goes well, the toolbar icon will
    be highlighted when you click on it, and the "Canvas Click" message should appear
    when you click on the map canvas.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够通过输入 `make deploy` 来运行您的插件，然后在 QGIS 中重新加载它以查看其工作情况。如果一切顺利，当您点击图标时，工具栏图标将被突出显示，当您点击地图画布时，“Canvas
    Click”消息应该会出现。
- en: 'Now, let''s replace the `GeometryInfoMapTool.canvasReleaseEvent()` method with
    code to identify the feature the user clicked on. Here''s the necessary code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用识别用户点击的功能的代码替换 `GeometryInfoMapTool.canvasReleaseEvent()` 方法。以下是必要的代码：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we call `QgsMapToolIdentify.identify()` to see which feature
    the user clicked on. The parameters we're using tell the method to only return
    the top-most vector feature at the point where the user clicked; the `identify()`
    method can also return all features at a given point or the pixel value if the
    user clicked on a raster layer, but in our case, we only want the top-most vector
    feature.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们调用 `QgsMapToolIdentify.identify()` 来查看用户点击了哪个功能。我们使用的参数告诉该方法只返回用户点击点的最顶层矢量功能；`identify()`
    方法还可以返回给定点的所有功能或像素值（如果用户点击了栅格图层），但在此情况下，我们只想得到最顶层的矢量功能。
- en: Once we've found the clicked-on feature, we identify which map layer the feature
    is on, and extract the feature's geometry. With this information, we can analyze
    the geometry and display the calculated statistics, which is the whole purpose
    of our plugin.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了点击的功能，我们就确定该功能位于哪个地图图层上，并提取该功能的几何形状。有了这些信息，我们可以分析几何形状并显示计算出的统计数据，这正是我们插件的全部目的。
- en: 'A `QGSGeometry` object can represent a point, a line, a polygon, a number of
    points, a number of lines, a number of polygons, or a collection of different
    types of geometries. To analyze the statistics for any `QGSGeometry` object, we
    have to be ready to handle all these different types of geometries. Fortunately,
    the basic logic is quite straightforward:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `QGSGeometry` 对象可以表示一个点、一条线、一个多边形、多个点、多条线、多个多边形，或者不同类型几何形状的集合。为了分析任何 `QGSGeometry`
    对象的统计数据，我们必须准备好处理所有这些不同类型的几何形状。幸运的是，基本逻辑非常简单：
- en: If the geometry has multiple parts, we split the geometry into its component
    parts, and process each part in turn
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果几何形状有多个部分，我们将几何形状分割成其组成部分，并依次处理每个部分
- en: For point geometries, we count the number of points
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于点几何形状，我们计算点的数量
- en: For line geometries, we count the number of lines and calculate their total
    length
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于线几何形状，我们计算线的数量并计算它们的总长度
- en: For polygon geometries, we count the number of polygons and calculate their
    total area and perimeter
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于多边形几何形状，我们计算多边形的数量并计算它们的总面积和周长
- en: 'Let''s add two methods to our `GeometryInfoMapTool` class to analyze a geometry:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`GeometryInfoMapTool`类中添加两个方法来分析几何形状：
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `add()` method is just a helper method that adds a number to a dictionary
    entry if it exists, and creates that entry if it doesn't. This allows us to use
    the `info` dictionary to store the results as we calculate them.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()`方法只是一个辅助方法，如果字典条目存在，则将其添加到数字中，如果不存在，则创建该条目。这允许我们使用`info`字典在计算过程中存储结果。'
- en: As you can see, the `analyzeGeometry()` method makes use of a `QgsDistanceArea`
    object to calculate the lengths and areas of a geometry. Note that our `analyzeGeometry()`
    method is recursive; if a geometry has multiple parts, each subgeometry might
    also have multiple parts, so we call `analyzeGeometry()` recursively on each part
    to allow these nested geometries to be handled correctly.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`analyzeGeometry()`方法使用`QgsDistanceArea`对象来计算几何形状的长度和面积。请注意，我们的`analyzeGeometry()`方法是递归的；如果一个几何形状有多个部分，每个子几何形状也可能有多个部分，因此我们在每个部分上递归调用`analyzeGeometry()`以正确处理这些嵌套几何形状。
- en: 'When we call `analyzeGeometry()` on a given `QGSGeometry`, the results of the
    analysis will be stored in the `info` dictionary. Let''s add some code to the
    end of our `canvasReleaseEvent()` method to analyze the clicked-on geometry and
    display the results:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在给定的`QGSGeometry`上调用`analyzeGeometry()`时，分析结果将存储在`info`字典中。让我们在我们的`canvasReleaseEvent()`方法的末尾添加一些代码来分析点击的几何形状并显示结果：
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you now do a `make deploy` and reload the plugin, you should be able to
    click on a feature and display information about that feature''s geometry. The
    plugin''s output should look like the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在执行`make deploy`并重新加载插件，您应该能够点击一个要素并显示该要素几何形状的信息。插件输出应如下所示：
- en: '![Writing a useful plugin](img/00045.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![编写有用的插件](img/00045.jpeg)'
- en: This is certainly telling us something useful, but it's not very readable. Let's
    look at how we can improve the way we display the statistics.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然告诉我们一些有用的信息，但可读性并不高。让我们看看我们如何改进显示统计数据的方式。
- en: 'Firstly, notice that the area and perimeter values are not particularly useful;
    the `QgsDistanceArea` object returns lengths and areas in meters, but for most
    geometries, these values are too precise and too big. Let''s make it more readable
    by converting the calculated lengths and areas into a whole number of kilometers.
    To do this, make the following highlighted changes to your `analyzeGeometry()`
    method:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意面积和周长值并不特别有用；`QgsDistanceArea`对象返回的长度和面积以米为单位，但对于大多数几何形状，这些值过于精确且过大。让我们通过将计算出的长度和面积转换为千米整数来使其更易于阅读。为此，请在您的`analyzeGeometry()`方法中进行以下突出显示的更改：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, we're simply dividing the calculated lengths by a thousand to
    get the length in kilometers, and dividing the calculated area by a million to
    get the area in square kilometers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是将计算出的长度除以一千以得到千米长度，将计算出的面积除以一百万以得到平方千米面积。
- en: 'The final thing we want to do is display those calculated statistics in a more
    friendly way. To do this, replace the `QMessageBox.information()` call at the
    end of your `canvasReleaseEvent()` method with the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的最后一件事是以更友好的方式显示这些计算出的统计数据。为此，将您的`canvasReleaseEvent()`方法末尾的`QMessageBox.information()`调用替换为以下内容：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Your plugin will now display the statistics in a more readable format, for
    example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您的插件现在将以更易读的格式显示统计数据，例如：
- en: '![Writing a useful plugin](img/00046.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![编写有用的插件](img/00046.jpeg)'
- en: We've now completed our plugin, and can use it to display information about
    any geometry within QGIS. More importantly, we've learned how to create a complete
    and useful QGIS plugin, and you can build on this knowledge to create your own
    plugins.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的插件，并且可以使用它来显示QGIS中任何几何形状的信息。更重要的是，我们已经学会了如何创建一个完整且有用的QGIS插件，您可以根据这些知识创建自己的插件。
- en: Possibilities and limitations of plugins
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件的可能性和局限性
- en: 'As we have seen, it''s quite possible to write a plugin that acts as a sophisticated
    mapping tool integrated directly into the QGIS user interface, interacting with
    the map canvas and responding in various ways to the user''s actions. Some of
    the other things you can do with a QGIS plugin include:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，编写一个作为复杂地图工具直接集成到QGIS用户界面中的插件是完全可能的，该插件与地图画布交互，并以各种方式响应用户的操作。您可以使用QGIS插件完成的其他一些事情包括：
- en: Creating your own subclass of `QgsMapCanvasItem`, so your plugin can draw items
    directly onto the QGIS map canvas.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的`QgsMapCanvasItem`子类，这样您的插件就可以直接在QGIS地图画布上绘制项目。
- en: Creating a custom map layer by subclassing `QgsPluginLayer`. This allows your
    plugin to act as a completely separate map layer.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过继承`QgsPluginLayer`来创建自定义地图图层。这使得您的插件可以作为一个完全独立的地图图层。
- en: Using signal handlers to intercept standard QGIS actions, for example, redrawing
    the canvas and executing your own code when a signal is sent.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号处理器来拦截标准QGIS操作，例如，在发送信号时重绘画布并执行自己的代码。
- en: Creating map layers programmatically, setting up the data provider, and creating
    custom symbols and renderers to control how the map data is displayed.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编程方式创建地图图层，设置数据提供者，以及创建自定义符号和渲染器来控制地图数据的显示方式。
- en: Using the QGIS Map Composer tools to combine rendered map layers, labels, legends,
    tables, and so on, mimicking the layout of a paper map. The resulting map view
    can be displayed in a window, printed, or saved to disk as an image or a PDF file.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用QGIS地图组合工具来组合渲染的地图图层、标签、图例、表格等，模仿纸质地图的布局。生成的地图视图可以在窗口中显示、打印或保存为图像或PDF文件。
- en: 'There are, however, some limitations on what a QGIS plugin is able to do:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，QGIS插件所能做的事情有一些限制：
- en: By its very nature, a plugin sits inside the running QGIS application. Your
    plugin runs alongside all the other plugins that the user has installed, and shares
    the same user interface and menu structure. This means that you can't implement
    turnkey mapping applications as QGIS plugins. The full complexity of QGIS is shown
    to the user, which can be daunting for the user who might be looking for a custom
    application that performs just one task. In this situation, it might be better
    to write your code as an external application that uses the PyQGIS library, rather
    than attempt to write it as a plugin.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于插件本质上是位于运行的QGIS应用程序内部，因此您的插件将与用户安装的所有其他插件并行运行，并共享相同的外观界面和菜单结构。这意味着您不能将一键式地图应用程序作为QGIS插件实现。QGIS的全部复杂性都呈现给用户，这可能对那些寻找只执行一项任务的定制应用程序的用户来说令人望而却步。在这种情况下，最好将您的代码编写为使用PyQGIS库的外部应用程序，而不是尝试将其编写为插件。
- en: Since the plugin runs within QGIS itself, there are many points of contact between
    the plugin code and the QGIS environment. As QGIS is constantly evolving, this
    means that a plugin can stop working when a new version of QGIS is released. This
    is far more likely to happen with a plugin than with code written as an external
    application using the PyQGIS library.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于插件在QGIS本身内运行，插件代码与QGIS环境之间有许多接触点。由于QGIS不断进化，这意味着当发布新的QGIS版本时，插件可能会停止工作。与使用PyQGIS库编写的代码相比，这种情况在插件中更为常见。
- en: Since the plugin uses the Python interpreter built into QGIS itself, you can't
    make use of third-party Python libraries that aren't included in QGIS's Python
    interpreter. While you can get around this for pure Python libraries (by including
    the Python source code as part of your plugin), if the library you want makes
    use of extensions written in C, you simply won't be able to use that library in
    your plugin.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于插件使用的是QGIS本身内置的Python解释器，您无法使用QGIS Python解释器中未包含的第三方Python库。虽然您可以绕过这一点来使用纯Python库（通过将Python源代码作为插件的一部分包含），但如果您想要的库使用了用C编写的扩展，那么您将无法在插件中使用该库。
- en: Ultimately, it is up to you to decide if plugins are a suitable way of implementing
    your mapping application. For some applications, they are ideal; they are certainly
    a lot easier to develop and distribute than external applications, and if your
    application is aimed at people who are already using QGIS, then the plugin scheme
    is a logical approach to take. In other situations, an external application built
    on top of PyQGIS might be more suitable.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，决定是否使用插件来实现您的地图应用程序取决于您。对于某些应用程序，插件是理想的；它们当然比外部应用程序更容易开发和分发，如果您的应用程序的目标用户已经是QGIS用户，那么插件方案是一种合理的做法。在其他情况下，基于PyQGIS构建的外部应用程序可能更适合。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into the topic of QGIS plugin programming. We created
    two separate plugins, a simple one to get started with, and a more complex and
    useful plugin that displays information about a clicked-on feature's geometry.
    We also looked at the QGIS plugin architecture, the plugin development process,
    and some of the possibilities and limitations of QGIS plugins. Along the way,
    we learned about the tools needed to develop QGIS plugins, discovered that plugins
    are simply Python packages with certain special files in them, and saw how the
    PyQt command-line tools can be used to compile user-interface templates and resource
    description files into Python modules so that they can be used within a plugin.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了QGIS插件编程的主题。我们创建了两个独立的插件，一个简单的用于入门，一个更复杂且实用的插件，用于显示点击特征几何信息。我们还探讨了QGIS插件架构、插件开发过程以及QGIS插件的一些可能性和限制。在这个过程中，我们了解了开发QGIS插件所需的工具，发现插件只是包含某些特殊文件的Python包，并看到了如何使用PyQt命令行工具将用户界面模板和资源描述文件编译成Python模块，以便在插件中使用。
- en: We also looked at how your plugin is integrated into the QGIS user interface
    using icons and menu items, how to run your plugin, and what happens when your
    plugin crashes. We also looked briefly at the Plugin Builder, and how it can be
    useful.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了你的插件如何通过图标和菜单项集成到QGIS用户界面中，如何运行你的插件，以及当你的插件崩溃时会发生什么。我们还简要地介绍了插件构建器，以及它可能的有用之处。
- en: Next, we looked at how to use a Makefile to automate plugin compilation and
    deployment, and the typical write-make-reload-test cycle used to develop plugins.
    We saw how to write and use HTML help files within your plugin, how unit tests
    can be used for QGIS plugins, and how to distribute your plugin, both to the official
    QGIS plugin repository and to a repository that you set up yourself.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了如何使用Makefile来自动化插件的编译和部署，以及用于开发插件时常用的编写-重新加载-测试循环。我们看到了如何在插件内部编写和使用HTML帮助文件，如何使用单元测试来为QGIS插件服务，以及如何分发你的插件，无论是到官方QGIS插件仓库还是到你自己设置的仓库。
- en: We learned that there are many things you can do with plugins, including drawing
    into the map canvas, creating custom layers, intercepting QGIS actions, programmatically
    creating map layers, and composing complex maps. At the same time, we saw that
    there are some constraints in what a QGIS plugin can do, including the need to
    share the QGIS user interface with all other plugins, the inability to create
    turnkey mapping applications, compatibility issues, and difficulties in using
    some third-party Python libraries.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，你可以用插件做很多事情，包括在地图画布上绘图、创建自定义图层、拦截QGIS操作、以编程方式创建地图图层，以及组合复杂地图。同时，我们也看到了QGIS插件在功能上的一些限制，包括需要与其他所有插件共享QGIS用户界面、无法创建一键式地图应用、兼容性问题，以及使用某些第三方Python库的困难。
- en: In the next chapter, we will look at the process of using the PyQGIS libraries
    within your own external Python programs. This gets around many of the limitations
    of a QGIS Plugin, at the cost of some additional complexity.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在你的外部Python程序中使用PyQGIS库的过程。这可以绕过QGIS插件的一些限制，但代价是增加了额外的复杂性。
