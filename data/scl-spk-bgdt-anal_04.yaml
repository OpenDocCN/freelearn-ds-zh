- en: Collection APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合 API
- en: '"That we become depends on what we read after all of the professors have finished
    with us. The greatest university of all is a collection of books."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们最终成为谁，取决于在所有教授讲授完我们之后，我们读了什么书。最伟大的大学是一本本书的集合。"'
- en: '- Thomas Carlyle'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 托马斯·卡莱尔'
- en: 'One of the features that attract most Scala users in its Collection APIs that
    are very powerful, flexible, and has lots of operations coupled with it. The wide
    range of operations will make your life easy dealing with any kind of data. We
    are going to introduce Scala collections APIs including their different types
    and hierarchies in order to accommodate different types of data and solve a wide
    range of different problems. In a nutshell, the following topics will be covered
    in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 吸引大多数 Scala 用户的一个特点是其集合 API，非常强大、灵活，并且拥有大量的操作功能。广泛的操作范围使得你处理各种数据时变得更加轻松。我们将介绍
    Scala 集合 API，包括它们的不同类型和层级，以适应不同类型的数据并解决各种不同的问题。简而言之，本章将涵盖以下内容：
- en: Scala collection APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 集合 API
- en: Types and hierarchies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型和层级
- en: Performance characteristics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能特性
- en: Java interoperability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 互操作性
- en: Using Scala implicits
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Scala 隐式参数
- en: Scala collection APIs
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 集合 API
- en: The Scala collections are a well-understood and frequently used programming
    abstraction that can be distinguished between mutable and immutable collections.
    Like a mutable variable, a *mutable* collection can be changed, updated, or extended
    when necessary. However, like an immutable variable, i*mmutable* collections cannot
    be changed. Most collection classes to utilize them are located in the packages
    `scala.collection`, `scala.collection.immutable`, and `scala.collection.mutable`,
    respectively.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 集合是一个广泛理解且常用的编程抽象，可以区分可变集合和不可变集合。像可变变量一样，*可变*集合可以在必要时更改、更新或扩展。然而，像不可变变量一样，*不可变*集合无法更改。大多数集合类被分别放置在
    `scala.collection`、`scala.collection.immutable` 和 `scala.collection.mutable` 包中。
- en: 'This extremely powerful feature of Scala provides you with the following facility
    to use and manipulate your data:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个极其强大的 Scala 特性为你提供了以下的功能，可以用来操作和处理你的数据：
- en: '**Easy to use**: For example, it helps you eliminate the interference between
    iterators and collection updates. As a result, a small vocabulary consisting of
    20-50 methods should be enough to solve most of your collection problem in your
    data analytics solution.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于使用**：例如，它帮助你消除迭代器和集合更新之间的干扰。因此，20-50 个方法的小词汇量应该足以解决数据分析解决方案中的大多数集合问题。'
- en: '**Concise**: You can use functional operations with a light-weight syntax and
    combine operations and, at the end, you will feel like that you''re using custom
    algebra.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁**：你可以使用轻量级语法进行函数式操作，结合多个操作，最终你会感觉自己在使用自定义代数。'
- en: '**Safe**: Helps you deal with most errors while coding.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：帮助你在编码时处理大多数错误。'
- en: '**Fast**: most collection objects are carefully tuned and optimized; this enables
    you data computation in a faster way.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速**：大多数集合对象经过精心调优和优化，使得你的数据计算能够更快速地进行。'
- en: '**Universal**: Collections enable you to use and perform the same operations
    on any type, anywhere.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用**：集合使你能够对任何类型的数据执行相同的操作，无论在哪里。'
- en: In the next section, we will explore the types and associated hierarchies of
    Scala collection APIs. We will see several examples of using most features in
    the collection APIs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探索 Scala 集合 API 的类型和关联层级。我们将展示如何使用集合 API 中的大多数功能的几个示例。
- en: Types and hierarchies
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型和层级
- en: Scala collections are a well-understood and frequently-used programming abstraction
    that can be distinguished between mutable and immutable collections. Like a mutable
    variable, a mutable collection can be changed, updated, or extended when necessary.
    Like an immutable variable, immutable collections; cannot be changed. Most collection
    classes that utilize them are located in the packages `scala.collection`, `scala.collection.immutable`,
    and `scala.collection.mutable`, respectively.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 集合是一个广泛理解且常用的编程抽象，可以区分可变集合和不可变集合。像可变变量一样，*可变*集合可以在必要时更改、更新或扩展。像不可变变量一样，*不可变*集合无法更改。大多数使用这些集合的类分别位于
    `scala.collection`、`scala.collection.immutable` 和 `scala.collection.mutable` 包中。
- en: The following hierarchical diagram (*Figure 1*) shows the Scala collections
    API hierarchy according to the official documentation of Scala. These all are
    either high-level abstract classes or traits. These have mutable as well as immutable
    implementations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下层级图（*图 1*）展示了根据 Scala 官方文档，Scala 集合 API 的层级结构。这些都是高级抽象类或特质，既有可变的实现，也有不可变的实现。
- en: '![](img/00091.jpeg)**Figure 1:** Collections under package scala.collection'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00091.jpeg)**图 1:** 包下的集合 scala.collection'
- en: Traversable
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Traversable
- en: '**Traversable** is the root of the collections'' hierarchy. In Traversable,
    there are definitions for a wide range of operations that the Scala Collections
    API offers. There is only one abstract method in Traversable, which is the `foreach`
    method.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Traversable** 是集合层级结构的根。在 Traversable 中，定义了 Scala 集合 API 提供的广泛操作。Traversable
    中只有一个抽象方法，即 `foreach` 方法。'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This method is essential to all the operations contained in Traversable. If
    you have studied data structures, you will be familiar with traversing a data
    structure's elements and executing a function on each element. The `foreach` method
    does exactly so that, it traverses the elements in the collection and executes
    a function `f` on each element. As we mentioned, this is an abstract method and
    it was designed to have different definitions according to the underlying collection
    that will make use of it, to ensure highly optimized code for each collection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法对 Traversable 中包含的所有操作至关重要。如果你研究过数据结构，你会熟悉遍历数据结构的元素并在每个元素上执行一个函数。`foreach`
    方法正是做这样的事情，它遍历集合中的元素并对每个元素执行函数 `f`。正如我们提到的，这是一个抽象方法，它被设计成根据底层集合的不同，提供不同的定义，以确保每个集合的代码高度优化。
- en: Iterable
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Iterable
- en: '**Iterable** is the second root in the hierarchy diagram of the Scala collections
    API. It has an abstract method called iterator that must be implemented/defined
    in all other subcollections. It also implements the `foreach` method from the
    root, which is Traversable. But as we mentioned, all the descendent subcollections
    will override this implementation to make specific optimizations related to this
    subcollection.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**Iterable** 是 Scala 集合 API 层级图中的第二个根。它有一个抽象方法叫做 iterator，必须在所有其他子集合中实现/定义。它还实现了来自根
    Traversable 的 `foreach` 方法。正如我们所提到的，所有的后代子集合将会覆盖此实现，以进行与该子集合相关的特定优化。'
- en: Seq, LinearSeq, and IndexedSeq
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Seq、LinearSeq 和 IndexedSeq
- en: A sequence has some differences from the usual Iterable, and it has a defined
    length and order. Seq has two sub-traits such as `LinearSeq` and `IndexedSeq`.
    Let's have a quick overview on them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 序列与常规 Iterable 有一些区别，它有定义的长度和顺序。Seq 有两个子特质，如 `LinearSeq` 和 `IndexedSeq`。让我们快速浏览一下它们。
- en: '`LinearSeq` is a base trait for linear sequences. Linear sequences have reasonably
    efficient head, tail, and `isEmpty` methods. If these methods provide the fastest
    way to traverse the collection, a collection `Coll` that extends this trait should
    also extend `LinearSeqOptimized[A, Coll[A]]`. `LinearSeq` has three concrete methods:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearSeq` 是线性序列的基特质。线性序列具有相对高效的 head、tail 和 `isEmpty` 方法。如果这些方法提供了遍历集合的最快方式，则扩展该特质的集合
    `Coll` 还应该扩展 `LinearSeqOptimized[A, Coll[A]]`。`LinearSeq` 有三个具体方法：'
- en: '**isEmpty:** This checks if the list is empty or not'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isEmpty:** 检查列表是否为空'
- en: '**head**: This returns the first element in the list/sequence'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**head**: 该方法返回列表/序列中的第一个元素'
- en: '**tail**: This returns all the elements of the list but the first one. Each
    of the subcollections that inherit the `LinearSeq` will have its own implementation
    of these methods to ensure good performance. Two collections that inherit/extend
    are streams and lists.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tail**: 返回列表中的所有元素，但不包括第一个元素。每个继承 `LinearSeq` 的子集合将会有自己对这些方法的实现，以确保良好的性能。两个继承/扩展的集合是流和列表。'
- en: For more on this topic, refer to this URL at [http://www.scala-lang.org/api/current/scala/collection/LinearSeq.html.](http://www.scala-lang.org/api/current/scala/collection/LinearSeq.html)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更多内容，请参考此链接：[http://www.scala-lang.org/api/current/scala/collection/LinearSeq.html.](http://www.scala-lang.org/api/current/scala/collection/LinearSeq.html)
- en: 'Finally, `IndexedSeq` has two methods that it''s defined in terms of them:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`IndexedSeq` 有两个方法，它是通过这两个方法定义的：
- en: '**Apply**: This finds elements by index.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apply**: 通过索引查找元素。'
- en: '**length**: This returns the length of the sequence. Finding an element by
    its index requires well performing implementation by the subcollections. Two of
    these indexed sequences are `Vector` and `ArrayBuffer`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**length**：返回序列的长度。通过索引查找元素需要子集合实现的高效性能。这些有索引的序列有`Vector`和`ArrayBuffer`。'
- en: Mutable and immutable
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变与不可变
- en: 'In Scala, you will find mutable and immutable collections. A collection can
    have a mutable implementation and an immutable implementation. That''s the reason
    why, in Java, a `List` can''t be both a `LinkedList` and an `ArrayList`, but `List`
    has a `LinkedList` implementation and an `ArrayList` implementation. The following
    figure shows all collections in the package `scala.collection.immutable`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，你会发现可变和不可变集合。一个集合可以有可变实现和不可变实现。这就是为什么在Java中，`List`不能同时是`LinkedList`和`ArrayList`，但`List`有`LinkedList`实现和`ArrayList`实现的原因。下图展示了`scala.collection.immutable`包中的所有集合：
- en: '![](img/00099.jpeg)**Figure 2:** All collections in package scala.collection.immutable'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00099.jpeg)**图 2：** 所有在包`scala.collection.immutable`中的集合'
- en: 'Scala imports the immutable collections by default, and if you need to use
    a mutable one, then you need to import it yourself. Now to get a brief overview
    of all collections in package `scala.collection.mutable`, refer to the following
    diagram:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Scala默认导入不可变集合，如果你需要使用可变集合，则需要自己导入。现在，为了简要了解包`scala.collection.mutable`中的所有集合，请参考以下图表：
- en: '![](img/00103.jpeg)**Figure 3:** All collections in package Scala.collection.mutable'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00103.jpeg)**图 3：** 所有在包`Scala.collection.mutable`中的集合'
- en: In every OOP and functional programming language, an array is an important collection
    package that helps us to store data objects so that, later on, we can access them
    very easily as well. In the next subsection, we will see a detailed discussion
    on arrays with some examples.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一种面向对象编程（OOP）和函数式编程语言中，数组是一个重要的集合包，帮助我们存储数据对象，之后我们可以非常容易地访问它们。在下一小节中，我们将通过一些示例详细讨论数组。
- en: Arrays
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array is a mutable collection. In arrays, the order of the elements will
    be preserved and duplicated elements will be kept. Being mutable, you can change
    the value of any element of the array by accessing it by its index number. Let''s
    demonstrate arrays with several examples. Use the following line of code to just
    declare a simple array:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个可变的集合。在数组中，元素的顺序会被保留，重复的元素也会被保留。由于是可变的，你可以通过访问其索引号来更改数组中任何元素的值。让我们通过几个例子来演示数组的使用。使用以下代码行来声明一个简单的数组：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, print all the elements of the array:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打印数组的所有元素：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, print a particular element: for example, element 3:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打印特定元素：例如，第3个元素：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s sum all the elements and print the sum:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有元素求和并打印总和：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finding the smallest element:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 查找最小的元素：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finding the largest element:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 查找最大的元素：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another way of creating and defining an array is using the `range ()` method
    that goes as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和定义数组的另一种方式是使用`range()`方法，示例如下：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding line of code means that I have created an array with elements
    between 5 and 20 with the range difference 2\. If you don''t specify the 3^(rd)
    parameter, Scala will assume the range difference is:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码行表示我创建了一个元素在5到20之间且间隔为2的数组。如果你没有指定第3个参数，Scala会假定范围间隔为：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s see how to access the elements as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何访问元素，示例如下：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It''s even possible to concatenate two arrays using the `concat()` method as
    follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`concat()`方法连接两个数组是完全可能的，示例如下：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that for using the `range()` and the `concat()` method, you will need
    to import the Scala `Array` package as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使用`range()`和`concat()`方法，你需要像下面这样导入Scala的`Array`包：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Lastly, it''s even possible to define and use a multi-dimensional array as
    follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也可以像下面这样定义和使用多维数组：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, first create a matrix using the preceding array as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首先使用前面的数组创建一个矩阵，示例如下：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Print the earlier matrix as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式打印之前的矩阵：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The complete source code of the previous example can be seen as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例的完整源代码如下所示：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will get the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In Scala, lists preserve order, keep duplicated elements, and also check their
    immutability. Now, let's see some examples of using lists in Scala in the next
    subsection.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，列表保持顺序，保留重复元素，并且还检查其不可变性。接下来，让我们在下一小节中查看一些使用Scala列表的示例。
- en: Lists
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'As discussed earlier, Scala provides mutable and immutable collections. The
    Immutable collections are imported by default, but if you need to use a mutable
    one you need to import yourself. A list is an immutable collections, and it can
    be used if you want order between the elements to be preserved and duplicates
    to be kept. Let''s demonstrate an example and see how lists preserve order and
    keep duplicated elements, and also check its immutability:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Scala 提供了可变和不可变集合。不可变集合是默认导入的，但如果需要使用可变集合，则需要自行导入。列表是不可变集合，如果你想保持元素之间的顺序并保留重复元素，它可以被使用。让我们通过一个示例来演示列表如何保持顺序并保留重复元素，同时检查它的不可变性：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can define lists using two different building blocks. `Nil` represents
    the tail of the `List` and, afterwards, an empty `List`. So, the preceding example
    can be rewritten as:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用两种不同的构建块来定义列表。`Nil`表示`List`的尾部，之后是一个空的`List`。因此，前面的例子可以重写为：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s check lists with its method in the following detailed example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过下面的详细示例来检查列表及其方法：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You will get the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, let's see another quick overview of how to use sets in your Scala application
    in the next subsection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一个小节中快速回顾一下如何在 Scala 应用中使用集合。
- en: Sets
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'A set is one of the most widely used collections. In sets order will not be
    preserved and sets don''t allow duplicate elements. You can think of it as the
    mathematical notation of sets. Let''s demonstrate this by an example, and we will
    see how sets don''t preserve ordering and don''t allow duplicates:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是最广泛使用的集合之一。在集合中，顺序不会被保留，并且集合不允许重复元素。你可以将其视为数学集合的表示法。让我们通过一个例子来演示这一点，看看集合如何不保留顺序并且不允许重复：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following source code shows the different uses of sets in a Scala program:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下源代码展示了在 Scala 程序中使用集合的不同方式：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will get the following output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From my personal experience while developing Spark applications using Java or
    Scala, I found very frequent uses of tuples, especially for grouping collections
    of elements without using any explicit classes. In the next subsection, we will
    see how to get started with Tuples in Scala.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我在使用 Java 或 Scala 开发 Spark 应用程序时的个人经验，我发现元组的使用非常频繁，尤其是在不使用任何显式类的情况下对元素集合进行分组。在下一个小节中，我们将看到如何在
    Scala 中使用元组。
- en: Tuples
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: Scala tuples are used to combine a fixed number of items together. The ultimate
    target of this grouping is to help in the anonymous function and so that they
    can be passed around as a whole. The real difference with an array or list is
    that a tuple can hold objects of different types while maintaining the information
    of the type of each element, while a collection doesn't and uses, as the type,
    the common type (for instance, in the previous example, the type of that set would
    be `Set[Any]`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 元组用于将固定数量的项组合在一起。这个组合的最终目标是帮助匿名函数，这样它们就可以作为一个整体传递。与数组或列表的真正区别在于，元组可以包含不同类型的对象，同时保持每个元素的类型信息，而集合则不能，集合使用的类型是公共类型（例如，在前面的例子中，集合的类型是
    `Set[Any]`）。
- en: From the computational point of view, Scala tuples are also immutable. In other
    words, Tuples do use a classes to store elements (for example, `Tuple2`, `Tuple3`,
    `Tuple22`, and so on).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从计算角度来看，Scala 元组也是不可变的。换句话说，元组确实使用类来存储元素（例如，`Tuple2`，`Tuple3`，`Tuple22` 等）。
- en: 'The following is an example of a tuple holding an integer, a string, and the
    console:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，演示一个元组包含一个整数、一个字符串和控制台：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Which is syntactic sugar (shortcut) for the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以下内容的语法糖（快捷方式）：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Another example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are no named accessors for you to access the tuple data but instead you
    need to use accessors that are based on the position and are 1-based not 0-based.
    For example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 元组没有命名的访问器让你访问数据，而是需要使用基于位置的访问器，且是从1开始计数，而不是从0开始。比如：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Moreover, tuples can fit perfectly in pattern matching. For example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，元组可以完美地适配模式匹配。例如：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can even use the special operator `->` in order to write a compact syntax
    for 2-values tuples. For example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用特殊运算符`->`来编写一个简洁的语法，用于表示两个值的元组。例如：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following is a more detailed example to demonstrate tuple functionality:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个更详细的示例，演示元组的功能：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will get the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, let's delve into the world of using maps in Scala, these are widely used
    to hold basic datatypes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解 Scala 中使用映射（Maps）的世界，映射广泛用于存储基本数据类型。
- en: Maps
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: 'A map is an `Iterable` consisting of pairs of keys and values (also named mappings
    or associations). A map is also one of the most widely used connections as it
    can be used to hold basic datatypes. For example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`是一个`Iterable`，由键值对（也称为映射或关联）组成。`Map`也是最广泛使用的集合之一，因为它可以用于存储基本数据类型。例如：'
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Scala's `Predef` object offers an implicit conversion that lets you write `key
    -> value` as an alternate syntax for the `pair (key, value)`. For instance, `Map("a"
    -> 10, "b" -> 15, "c" -> 16)` means exactly the same as `Map(("a", 10), ("b",
    15), ("c", 16))`, but reads better.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的`Predef`对象提供了一种隐式转换，使你可以将`key -> value`作为`pair (key, value)`的替代语法。例如，`Map("a"
    -> 10, "b" -> 15, "c" -> 16)`与`Map(("a", 10), ("b", 15), ("c", 16))`完全相同，但可读性更好。
- en: 'Moreover, a `Map` can be simply considered a collection of `Tuple2s`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Map`可以简单地看作是`Tuple2`的集合：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding line will be understood as:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行将被理解为：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the example, we can state that using `Map` a function can be stored, and
    this is the whole point of functions in a Functional Programming language: they
    are first-class citizens and can be used anywhere.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们可以说通过使用`Map`，可以存储一个函数，这就是函数式编程语言中函数的全部意义：它们是第一类公民，可以在任何地方使用。
- en: 'Suppose you have a method for finding the max element in an array as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个方法，用于查找数组中的最大元素，如下所示：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s map it such that using the `Map` the method can be stored:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进行映射，使得可以使用`Map`方法存储数据：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s another of using maps as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一下使用`Map`的另一种方式：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following is a detailed example to demonstrate `Map` functionality:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个详细示例，展示`Map`的功能：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You will get the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, let's take a quick overview of using option in Scala; this is basically
    a data container that can hold data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速了解在Scala中使用Option；它基本上是一个数据容器，可以存储数据。
- en: Option
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Option
- en: The `Option` type is used frequently in Scala programs, and you can compare
    this with the null value available in Java, which indicates no value. Scala `Option
    [T]` is a container for zero or one element for a given type. An `Option [T]`
    can be either a `Some [T]` or `None` object, which represents a missing value.
    For instance, the get method of Scala's `Map` produces `Some` (value) if a value
    corresponding to a given key has been found, or `None` if the given key is not
    defined in the `Map`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option`类型在Scala程序中使用频繁，可以将其与Java中的null值进行比较，null表示没有值。Scala的`Option [T]`是一个容器，用来表示给定类型的零个或一个元素。`Option
    [T]`可以是`Some [T]`或`None`对象，表示缺失的值。例如，Scala的`Map`的`get`方法如果找到了与给定键对应的值，会返回`Some`（值），如果给定键在`Map`中没有定义，则返回`None`。'
- en: 'The basic trait for an `Option` looks like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option`的基本特征如下所示：'
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For example, in the following code, we are trying to map and show some meagacities
    that are located in some countries such as `India`, `Bangladesh`, `Japan`, and
    `USA`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下代码中，我们试图映射并显示位于一些国家（如`印度`、`孟加拉国`、`日本`和`美国`）的一些城市：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, to make the preceding code work, we need to have the `show()` method defined
    somewhere. Here, we can do it by Scala pattern matching using `Option` as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使前面的代码正常工作，我们需要在某处定义`show()`方法。在这里，我们可以通过Scala的模式匹配来使用`Option`，如下所示：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Combining these as follows should print the accurate and desired result that
    we are expecting:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些组合如下所示，应该会打印出我们期望的准确结果：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You will get the following output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Using the `getOrElse()` method, it is possible to access a value or a default
    when no value is present. For example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getOrElse()`方法，当没有值时，可以访问一个值或默认值。例如：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You will get the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Moreover, using the `isEmpty()` method, you can check if the option is `None`
    or not. For example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用`isEmpty()`方法，你可以检查该Option是否为`None`。例如：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, here''s the complete program:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是完整的程序：
- en: '[PRE48]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You will get the following output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE49]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s take a look at other examples on when to use `Option`. For example,
    the `Map.get()` method uses `Option` in order to tell the user if the element
    that he tries to access exists or not. For example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其他一些使用`Option`的示例。例如，`Map.get()`方法使用`Option`来告诉用户他尝试访问的元素是否存在。例如：
- en: '[PRE50]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, we will see how to use exists, which is used to check if a predicate holds
    for a subset of a set of elements in the Traversal collection.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到如何使用`exists`，它用于检查一个谓词是否适用于集合中元素的子集。
- en: Exists
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存在
- en: 'Exists checks if a predicate holds for at least one element in the Traversable
    collection. For example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Exists检查一个谓词是否对可遍历集合中的至少一个元素成立。例如：
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Using the fat arrow:** `=>` is called the *right arrow*, *fat arrow,* or
    *rocket* and is used for passing parameters by name. That means the expression
    will be evaluated when a parameter is accessed. It is actually syntactic sugar
    for a zero parameter function `call: x: () => Boolean`. Let''s see an example
    using this operator is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用fat箭头：** `=>` 被称为*右箭头*、*fat箭头*或*火箭*，用于按名称传递参数。这意味着表达式将在访问参数时求值。它实际上是一个零参数函数`call:
    x: () => Boolean`的语法糖。让我们看看使用这个操作符的示例如下：'
- en: '`package com.chapter4.CollectionAPI`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`package com.chapter4.CollectionAPI`'
- en: '`object UsingFatArrow {`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`object UsingFatArrow {`'
- en: '`def fliesPerSecond(callback: () => Unit) {`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`def fliesPerSecond(callback: () => Unit) {`'
- en: '`while (true) { callback(); Thread sleep 1000 }`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`while (true) { callback(); Thread sleep 1000 }`'
- en: '`}`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`def main(args: Array[String]): Unit= {`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`def main(args: Array[String]): Unit= {`'
- en: '`fliesPerSecond(() => println("Time and tide wait for none but fly like arrows
    ..."))`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`fliesPerSecond(() => println("时间和潮水不等人，但飞如箭一般..."))`'
- en: '`}`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: 'You will get the following output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到如下输出：
- en: '`Time and tide wait for none but flies like an arrow...`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`时间和潮水不等人，但飞如箭一般...`'
- en: '`Time and tide wait for none but flies like an arrow...`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`时间和潮水不等人，但飞如箭一般...`'
- en: '`Time and tide wait for none but flies like an arrow...`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`时间和潮水不等人，但飞如箭一般...`'
- en: '`Time and tide wait for none but flies like an arrow...`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`时间和潮水不等人，但飞如箭一般...`'
- en: '`Time and tide wait for none but flies like an arrow...`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`时间和潮水不等人，但飞如箭一般...`'
- en: '`Time and tide wait for none but flies like an arrow...`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`时间和潮水不等人，但飞如箭一般...`'
- en: 'A detailed example can be seen in the following code as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了一个详细示例：
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You will get the following output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到如下输出：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Note: Using the infix operator in Scala**:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：在Scala中使用中缀操作符：**'
- en: 'In the earlier example and in a subsequent section, we used the Scala infix
    notation. Suppose you would like to perform some operation with complex numbers
    and have a case class with an add method for adding two complex numbers:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例和随后的章节中，我们使用了Scala的中缀表示法。假设你想对复数执行一些操作，并且有一个带有add方法的case类，用于添加两个复数：
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now in order to access the properties of this class, you need to create an
    object like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了访问这个类的属性，你需要创建一个对象，如下所示：
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Moreover, suppose you have the following two complex numbers defined:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设你定义了以下两个复数：
- en: '[PRE56]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now to access the `plus()` method from the case class, you will do something
    like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要访问case类中的`plus()`方法，你可以这样做：
- en: '[PRE57]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This should give you output: `Complex(16.0,29.0)`. However, isn''t it good
    if you just call the method like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给你输出：`Complex(16.0,29.0)`。然而，如果你像这样调用方法，不是更好吗：
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And it really works like a charm. Here is the complete example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它真的像魅力一样有效。这里是完整的示例：
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**The precedence of an infix operator**: This is determined by the operator''s
    first character. Characters are listed below in increasing order of precedence,
    with characters on the same line having the same precedence:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**中缀操作符的优先级：** 由操作符的第一个字符决定。字符按优先级递增的顺序列出，同行的字符具有相同的优先级：'
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**General warning**: Using the infix notation for calling regular, non-symbolic
    methods is discouraged and should be used only if it significantly increases readability.
    One example of a sufficiently motivated use of infix notation is matchers and
    other parts of the tests definition in `ScalaTest`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**常规警告：** 使用中缀表示法调用常规的非符号方法是不推荐的，只有在显著提高可读性的情况下才应使用。中缀表示法的一个充分动机的示例是在`ScalaTest`中定义匹配器和其他部分的测试。'
- en: Another interesting element in the Scala collection package is using `forall`.
    It is used to check if a predicate holds for each element in a `Traversable` collection.
    In the next subsection, we will see an example of it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Scala集合包中另一个有趣的元素是使用`forall`。它用于检查一个谓词是否对`Traversable`集合中的每个元素成立。在接下来的子章节中，我们将看到它的示例。
- en: Forall
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Forall
- en: 'Forall checks if a predicate holds for each element in a `Traversable` collection.
    It can be defined formally as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Forall检查一个谓词是否对`Traversable`集合中的每个元素成立。可以正式地定义如下：
- en: '[PRE61]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s see an example as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如下示例：
- en: '[PRE62]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: While writing Scala code for preprocessing especially, we often need to filter
    selected data objects. The filter feature of the Scala collection API is used
    for that. In the next sub-section, we will see an example of using filter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 Scala 代码进行预处理时，尤其是我们经常需要筛选选定的数据对象。Scala 集合 API 的过滤功能用于此目的。在下一个小节中，我们将看到使用
    filter 的示例。
- en: Filter
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Filter
- en: '`filter` selects all the elements that satisfy a specific predicate. It can
    be defined formally as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 选择所有满足特定条件的元素。它可以正式定义如下：'
- en: '[PRE63]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s see an example as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如下的示例：
- en: '[PRE64]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A map is used to build a new collection or set of elements by traversing a function
    to all elements of the collection. In the next subsection, we will see an example
    of using `Map`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Map 用于通过遍历一个函数作用于集合的所有元素来构建一个新的集合或元素集。在下一个小节中，我们将看到使用 `Map` 的示例。
- en: Map
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map
- en: 'Map is used to build a new collection or set of elements by traversing a function
    to all elements of the collection. It can be defined formally as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Map 用于通过遍历一个函数作用于集合的所有元素来构建一个新的集合或元素集。它可以正式定义如下：
- en: '[PRE65]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s see an example as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如下的示例：
- en: '[PRE66]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: While using the collection API in Scala, you often need to select the n^(th)
    elements of the list or array for example. In the next sub-section, we will explore
    examples of using take.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Scala 集合 API 时，你经常需要选择列表或数组中的第 n^(个) 元素。例如，在下一个小节中，我们将探讨使用 take 的示例。
- en: Take
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Take
- en: 'Take is used to take the first n elements of a collection. The formal definition
    of using `take` is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Take 用于获取集合中的前 n 个元素。使用 `take` 的正式定义如下：
- en: '[PRE67]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s see an example as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如下的示例：
- en: '[PRE68]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You will get the following output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到如下输出：
- en: '[PRE69]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In Scala, if want to partition specific collections into a map of an other `Traversable`
    collection according to a specific partitioning function, you can use the `groupBy()`
    method. In the next subsection, we will show some examples of using `groupBy()`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，如果你想根据特定的分区函数将特定集合划分为另一个 `Traversable` 集合的映射，你可以使用 `groupBy()` 方法。在下一个小节中，我们将展示一些使用
    `groupBy()` 的示例。
- en: GroupBy
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GroupBy
- en: 'GroupBy is used to partition specific collections into a map of other Traversable
    collections according to a specific partitioning function. It can be defined formally
    as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: GroupBy 用于根据特定的分区函数将特定集合划分为其他 `Traversable` 集合的映射。它可以正式定义如下：
- en: '[PRE70]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s see an example as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如下的示例：
- en: '[PRE71]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In Scala, if you want to select all the elements in a Traversable collection
    but the last one, you can use `init`. In the next subsection, we will see examples
    of it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，如果你想选择 `Traversable` 集合中的所有元素，除了最后一个，你可以使用 `init`。在下一个小节中，我们将看到相关示例。
- en: Init
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Init
- en: '`init` selects all the elements in a `Traversable` collection but the last
    one. It can be defined formally as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 选择 `Traversable` 集合中的所有元素，除了最后一个。它可以正式定义如下：'
- en: '[PRE72]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s see an example as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如下的示例：
- en: '[PRE73]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In Scala, if you want to select all elements except the first n elements, you
    should use drop. In the next subsection, we will see how to use drop.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，如果你想选择除前 n 个元素外的所有元素，你应该使用 drop。在下一个小节中，我们将看到如何使用 drop。
- en: Drop
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drop
- en: '`drop` is used to select all elements except the first n elements. It can be
    defined formally as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`drop` 用于选择除前 n 个元素外的所有元素。它可以正式定义如下：'
- en: '[PRE74]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let''s see an example as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如下的示例：
- en: '[PRE75]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In Scala, if you want take a set of elements until a predicate is satisfied,
    you should use `takeWhile`. In the next subsection, we will see how to use `takeWhile`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，如果你想获取一组元素直到满足某个条件，你应该使用 `takeWhile`。在下一个小节中，我们将看到如何使用 `takeWhile`。
- en: TakeWhile
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TakeWhile
- en: 'TakeWhile is used to take a set of elements until a predicate is satisfied.
    It can be defined formally as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: TakeWhile 用于获取一组元素直到满足某个条件。它可以正式定义如下：
- en: '[PRE76]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let''s see an example as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如下的示例：
- en: '[PRE77]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You will get the following output:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到如下输出：
- en: '[PRE78]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In Scala, if you want to omit a set of elements till a predicate is satisfied,
    you should use `dropWhile`. We will see some examples of this in the next subsection.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，如果你想省略一组元素直到满足某个条件，你应该使用 `dropWhile`。我们将在下一个小节中看到一些相关示例。
- en: DropWhile
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DropWhile
- en: '`dropWhile` is used to omit a set of elements till a predicate is satisfied.
    It can be defined formally as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropWhile` 用于省略一组元素直到满足某个条件。它可以正式定义如下：'
- en: '[PRE79]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Let''s see an example as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如下的示例：
- en: '[PRE80]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In Scala, if you want to use your **User Defined Functions** (**UDF**) such
    that it takes a function as an argument in the nested list and combines the output
    back together, `flatMap()` is a perfect candidate. We will see examples of using
    `flatMap()` in the next section.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，如果你想要使用你的 **用户定义函数** (**UDF**)，使其接受嵌套列表中的函数作为参数，并将输出重新组合，`flatMap()`
    是一个完美的选择。我们将在下一节中看到如何使用 `flatMap()` 的示例。
- en: FlatMap
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FlatMap
- en: 'FltatMap takes a function as an argument. The function given to `flatMap()`
    doesn''t work on nested lists but it produces a new collection. It can be defined
    formally as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: FlatMap 接受一个函数作为参数。传递给 `flatMap()` 的函数并不会作用于嵌套列表，而是会生成一个新的集合。它可以正式定义如下：
- en: '[PRE81]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let''s see an example as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个如下的例子：
- en: '[PRE82]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We have just about finished covering the uses of Scala collection features.
    Also note that methods such as `Fold()`, `Reduce()`, `Aggregate()`, `Collect()`,
    `Count()`, `Find()`, and `Zip()` can be used to pass from one collection to another
    (for example, `toVector`, `toSeq`, `toSet`, `toArray`). However, we will see such
    examples in upcoming chapters. For the time being, it's time to see some performance
    characteristics of different Scala collection APIs.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经基本完成了 Scala 集合特性用法的介绍。还需要注意的是，像 `Fold()`、`Reduce()`、`Aggregate()`、`Collect()`、`Count()`、`Find()`
    和 `Zip()` 等方法可以用于从一个集合转换到另一个集合（例如，`toVector`、`toSeq`、`toSet`、`toArray`）。然而，我们将在接下来的章节中看到这些示例。现在是时候查看不同
    Scala 集合 API 的一些性能特性了。
- en: Performance characteristics
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能特性
- en: In Scala, different collections have different performance characteristics and
    these performance characteristics are the reason you will prefer to choose one
    collection over the others. In this section, we will judge the performance characteristics
    of Scala collection objects from the operational and memory usage point of view.
    At the end of this section, we will provide some guidelines for selecting appropriate
    collection objects for your code and problem types.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，不同的集合有不同的性能特性，而这些特性是你选择某个集合而非其他集合的原因。在本节中，我们将从操作和内存使用的角度评估 Scala 集合对象的性能特性。在本节末尾，我们将提供一些指导，帮助你根据代码和问题类型选择合适的集合对象。
- en: Performance characteristics of collection objects
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合对象的性能特性
- en: The following are the performance characteristics Scala Collections, based on
    the official documentation of Scala.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是根据官方文档，Scala 集合的性能特性。
- en: '**Const**: The operation takes only constant time.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常量**：该操作仅需常量时间。'
- en: '**eConst**: The operation takes effectively constant time, but this might depend
    on some assumptions such as the maximum length of a vector or the distribution
    of hash keys.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**eConst**：该操作实际上采用常量时间，但这可能取决于一些假设，例如向量的最大长度或哈希键的分布。'
- en: '**Linear**: The operation grows linearly with the collection size.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性**：该操作随着集合大小按线性增长。'
- en: '**Log**: The operation grows logarithmically with the collection size.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对数**：该操作随着集合大小按对数增长。'
- en: '**aConst**: The operation takes the amortized constant time. Some invocations
    of the operation might take longer, but if many operations are performed on average
    only constant time per operation is taken.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**aConst**：该操作采用摊销常量时间。有些操作的调用可能会更长，但如果执行多个操作，平均每次操作只需常量时间。'
- en: '**NA**: Operation is not supported.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不适用**：操作不支持。'
- en: Performance characteristics of sequence types (immutable) are presented in the
    following table.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 序列类型（不可变）的性能特性在下表中呈现。
- en: '| **Immutable CO*** | **Head** | **Tail** | **Apply** | **Update** | **Prepend**
    | **Append** | **Insert** |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| **不可变 CO*** | **头部** | **尾部** | **应用** | **更新** | **前置** | **附加** | **插入**
    |'
- en: '| List | Const | Const | Linear | Linear | Const | Linear | NA |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | 常量 | 常量 | 线性 | 线性 | 常量 | 线性 | 不适用 |'
- en: '| Stream | Const | Const | Linear | Linear | Const | Linear | NA |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 流 | 常量 | 常量 | 线性 | 线性 | 常量 | 线性 | 不适用 |'
- en: '| Vector | eConst | eConst | eConst | eConst | eConst | eConst | NA |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 向量 | eConst | eConst | eConst | eConst | eConst | eConst | 不适用 |'
- en: '| Stack | Const | Const | Linear | Linear | Const | Linear | Linear |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 栈 | 常量 | 常量 | 线性 | 线性 | 常量 | 线性 | 线性 |'
- en: '| Queue | aConst | aConst | Linear | Linear | Const | Const | NA |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 队列 | aConst | aConst | 线性 | 线性 | 常量 | 常量 | 不适用 |'
- en: '| Range | Const | Const | Const | NA | NA | NA | NA |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 范围 | 常量 | 常量 | 常量 | 不适用 | 不适用 | 不适用 | 不适用 |'
- en: '| String | Const | Linear | Const | Linear | Linear | Linear | NA |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | 常量 | 线性 | 常量 | 线性 | 线性 | 线性 | 不适用 |'
- en: '**Table 1:** Performance characteristics of sequence types (immutable) [*CO==
    Collection Object]'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1：** 序列类型（不可变）的性能特性 [*CO== 集合对象]'
- en: 'The following table shows the meaning of the operations described in **Table
    1** and **Table 3** here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了 **表 1** 和 **表 3** 中描述的操作的含义：
- en: '| **Head** | Is used to select the first few elements of an existing sequence.
    |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **头部** | 用于选择现有序列的前几个元素。 |'
- en: '| **Tail** | Is used to select all elements except the first one and returns
    a new sequence. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| **尾部** | 用于选择所有元素，除了第一个，并返回一个新的序列。 |'
- en: '| **Apply** | Is used for indexing purposes. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| **应用** | 用于索引目的。 |'
- en: '| **Update** | It is used as the functional update for immutable sequences.
    For the mutable sequence, it is a side-effecting update (with update for mutable
    sequences). |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **更新** | 用于不可变序列的功能性更新。对于可变序列，它是带有副作用的更新（适用于可变序列的更新）。 |'
- en: '| **Prepend** | It is used to add an element to the front of an existing sequence.
    A new sequence is produced for immutable sequences. For the mutable sequence,
    the existing one is modified. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| **前置** | 用于将一个元素添加到现有序列的开头。对于不可变序列，会生成一个新的序列。对于可变序列，现有序列会被修改。 |'
- en: '| **Append** | It is used to add an element at the end of an existing sequence.
    A new sequence is produced for immutable sequences. For a mutable sequence, the
    existing one is modified. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| **附加** | 用于在现有序列的末尾添加一个元素。对于不可变序列，会生成一个新的序列。对于可变序列，现有序列会被修改。 |'
- en: '| **Insert** | It is used to insert an element at an arbitrary position in
    an existing sequence. This can be done however directly for mutable sequences.
    |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| **插入** | 用于在现有序列的任意位置插入一个元素。对于可变序列，可以直接执行此操作。 |'
- en: '**Table 2:** The meaning of the operation described in table 1'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2：** 表 1 中描述的操作的含义'
- en: 'Performance characteristics of sequence types (mutable) are shown in **Table
    3** as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 序列类型（可变）的性能特征显示在 **表 3** 中，如下所示：
- en: '| **Mutable CO*** | **Head** | **Tail** | **Apply** | **update** | **Prepend**
    | **Append** | **Insert** |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| **可变 CO*** | **头部** | **尾部** | **应用** | **更新** | **前置** | **附加** | **插入**
    |'
- en: '| ArrayBuffer | Const | Linear | Const | Const | Linear | aConst | Linear |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| ArrayBuffer | 常量 | 线性 | 常量 | 常量 | 线性 | aConst | 线性 |'
- en: '| ListBuffer | Const | Linear | Linear | Linear | Const | Const | Linear |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| ListBuffer | 常量 | 线性 | 线性 | 线性 | 常量 | 常量 | 线性 |'
- en: '| StringBuilder | Const | Linear | Const | Const | Linear | aCconst | Linear
    |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| StringBuilder | 常量 | 线性 | 常量 | 常量 | 线性 | aCconst | 线性 |'
- en: '| MutableList | Const | Linear | Linear | Linear | Const | Const | Linear |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| MutableList | 常量 | 线性 | 线性 | 线性 | 常量 | 常量 | 线性 |'
- en: '| Queue | Const | Linear | Linear | Linear | Const | Const | Linear |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 队列 | 常量 | 线性 | 线性 | 线性 | 常量 | 常量 | 线性 |'
- en: '| ArraySeq | Const | Linear | Const | Const | NA | NA | NA |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| ArraySeq | 常量 | 线性 | 常量 | 常量 | 不适用 | 不适用 | 不适用 |'
- en: '| Stack | Const | Linear | Linear | Linear | Const | Linear | Linear |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 栈 | 常量 | 线性 | 线性 | 线性 | 常量 | 线性 | 线性 |'
- en: '| ArrayStack | Const | Linear | Const | Const | aConst | Linear | Linear |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| ArrayStack | 常量 | 线性 | 常量 | 常量 | aConst | 线性 | 线性 |'
- en: '| Array | Const | Linear | Const | Const | NA | NA | NA |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | 常量 | 线性 | 常量 | 常量 | 不适用 | 不适用 | 不适用 |'
- en: '**Table 3:** Performance characteristics of sequence types (mutable) [*CO==
    Collection Object]'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3：** 序列类型（可变）的性能特征 [*CO== 集合对象]'
- en: For more information about mutable collections and other types of collections,
    you can refer to this link ([http://docs.scala-lang.org/overviews/collections/performance-characteristics.html](http://docs.scala-lang.org/overviews/collections/performance-characteristics.html)).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可变集合和其他类型集合的更多信息，请参考此链接 ([http://docs.scala-lang.org/overviews/collections/performance-characteristics.html](http://docs.scala-lang.org/overviews/collections/performance-characteristics.html))。
- en: 'Performance characteristics of set and map types are shown in the following
    table:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类型和映射类型的性能特征显示在以下表格中：
- en: '| **Collection types** | **Lookup** | **Add** | **Remove** | **Min** |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| **集合类型** | **查找** | **添加** | **删除** | **最小值** |'
- en: '| **immutable** | - | - | - | - |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| **不可变** | - | - | - | - |'
- en: '| HashSet/HashMap | eConst | eConst | eConst | Linear |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| HashSet/HashMap | eConst | eConst | eConst | 线性 |'
- en: '| TreeSet/TreeMap | Log | Log | Log | Log |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| TreeSet/TreeMap | 对数 | 对数 | 对数 | 对数 |'
- en: '| BitSet | Const | Linear | Linear | eConst* |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| BitSet | 常量 | 线性 | 线性 | eConst* |'
- en: '| ListMap | Linear | Linear | Linear | Linear |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| ListMap | 线性 | 线性 | 线性 | 线性 |'
- en: '| **Collection types** | **Lookup** | **Add** | **Remove** | **Min** |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **集合类型** | **查找** | **添加** | **删除** | **最小值** |'
- en: '| **mutable** | - | - | - | - |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| **可变** | - | - | - | - |'
- en: '| HashSet/HashMap | eConst | eConst | eConst | Linear |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| HashSet/HashMap | eConst | eConst | eConst | 线性 |'
- en: '| WeakHashMap | eConst | eConst | eConst | Linear |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| WeakHashMap | eConst | eConst | eConst | 线性 |'
- en: '| BitSet | Const | aConst | Const | eConst* |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| BitSet | 常量 | aConst | 常量 | eConst* |'
- en: '| TreeSet | Log | Log | Log | Log |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| TreeSet | 对数 | 对数 | 对数 | 对数 |'
- en: '**Table 4:** Performance characteristics of set and map types [ * applicable
    only if bits are densely packed]'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4：** 集合和映射类型的性能特性 [ *仅在位图紧凑时适用* ]'
- en: 'The following table shows the meaning of each operation described in **Table
    4**:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了 **表 4** 中描述的每个操作的含义：
- en: '| **Operation** | **Meaning** |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **含义** |'
- en: '| **Lookup** | Is used to test whether an element is contained in a set. Secondly,
    it is also used to select a value associated with a particular key. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| **查找** | 用于测试一个元素是否包含在集合中。其次，也用于选择与特定键相关联的值。 |'
- en: '| **Add** | It is used to add a new element to a set. Secondly, it is also
    used to add a new key/value pair to a map. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| **添加** | 用于向集合中添加一个新元素。同时，也用于向映射中添加一个新的键/值对。 |'
- en: '| **Remove** | It is used to remove an element from a set or a key from a map.
    |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **删除** | 用于从集合中移除一个元素或从映射中移除一个键。 |'
- en: '| **Min** | It is used to select the smallest element of the set or the smallest
    key of a map. |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| **最小值** | 用于选择集合中的最小元素或映射中的最小键。 |'
- en: '**Table 5:** The meaning of each operation described in Table 4'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5：** 表 4 中描述的每个操作的含义'
- en: One of the basic performance metrics is the memory usage by a particular collection
    object. In the next section, we will provide some guidelines about how to measure
    these metrics based on memory usage.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的性能指标之一是特定集合对象的内存使用情况。在接下来的章节中，我们将提供一些基于内存使用情况测量这些指标的指南。
- en: Memory usage by collection objects
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合对象的内存使用情况
- en: 'Sometimes, there are several benchmarking questions arrived for example: A
    `Lists` faster than `Vectors` for what you''re doing or are `Vectors` faster than
    `Lists`? How much memory can you save using unboxed Arrays to store primitives?
    When you do performance tricks such as pre-allocating arrays or using a `while`
    loop instead of a `foreach` call, how much does it really matter? `var l: List`
    or val `b: mutable.Buffer`? Memory usage can be estimated using different Scala
    benchmark codes, for example, refer to [https://github.com/lihaoyi/scala-bench](https://github.com/lihaoyi/scala-bench).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '有时，会遇到几个基准测试问题，例如：对于你的操作，`Lists` 比 `Vectors` 快，还是 `Vectors` 比 `Lists` 快？使用未封装的数组存储原始类型时能节省多少内存？当你做一些性能优化操作，比如预分配数组或使用
    `while` 循环代替 `foreach` 调用时，究竟有多大影响？`var l: List` 还是 `val b: mutable.Buffer`？内存使用情况可以通过不同的
    Scala 基准代码进行估算，例如，参考 [https://github.com/lihaoyi/scala-bench](https://github.com/lihaoyi/scala-bench)。'
- en: 'Table 6 here shows the estimated size (bytes) of the various immutable collections
    of 0-elements, 1- element, 4- elements, and powers of four all the way up to 1,048,576
    elements. Although mostse are deterministic, these might be changed depending
    on your platform:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6 显示了各种不可变集合的估算大小（字节数），包括 0 元素、1 元素、4 元素以及以四的幂次增长的元素数量，一直到 1,048,576 个元素。尽管大多数是确定性的，但这些值可能会根据你的平台有所变化：
- en: '| **Size** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024**
    | **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| **大小** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024** |
    **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
- en: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
- en: '| Vector | 56 | 216 | 264 | 456 | 1,512 | 5,448 | 21,192 | 84,312 | 334,440
    | 1,353,192 | 5,412,168 | 21,648,072 |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 向量 | 56 | 216 | 264 | 456 | 1,512 | 5,448 | 21,192 | 84,312 | 334,440 | 1,353,192
    | 5,412,168 | 21,648,072 |'
- en: '| Array[Object] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 | 323,856
    | 1,310,736 | 5,242,896 | 20,971,536 |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 数组[对象] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 | 323,856 |
    1,310,736 | 5,242,896 | 20,971,536 |'
- en: '| List | 16 | 56 | 176 | 656 | 2,576 | 10,256 | 40,976 | 162,776 | 647,696
    | 2,621,456 | 10,485,776 | 41,943,056 |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | 16 | 56 | 176 | 656 | 2,576 | 10,256 | 40,976 | 162,776 | 647,696 |
    2,621,456 | 10,485,776 | 41,943,056 |'
- en: '| Stream (unforced) | 16 | 160 | 160 | 160 | 160 | 160 | 160 | 160 | 160 |
    160 | 160 | 160 |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 流（非强制） | 16 | 160 | 160 | 160 | 160 | 160 | 160 | 160 | 160 | 160 | 160 |
    160 |'
- en: '| Stream (forced) | 16 | 56 | 176 | 656 | 2,576 | 10,256 | 40,976 | 162,776
    | 647,696 | 2,621,456 | 10,485,776 | 41,943,056 |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 流（强制） | 16 | 56 | 176 | 656 | 2,576 | 10,256 | 40,976 | 162,776 | 647,696
    | 2,621,456 | 10,485,776 | 41,943,056 |'
- en: '| Set | 16 | 32 | 96 | 880 | 3,720 | 14,248 | 59,288 | 234,648 | 895,000 |
    3,904,144 | 14,361,000 | 60,858,616 |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | 16 | 32 | 96 | 880 | 3,720 | 14,248 | 59,288 | 234,648 | 895,000 | 3,904,144
    | 14,361,000 | 60,858,616 |'
- en: '| Map | 16 | 56 | 176 | 1,648 | 6,800 | 26,208 | 109,112 | 428,592 | 1,674,568
    | 7,055,272 | 26,947,840 | 111,209,368 |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 映射 | 16 | 56 | 176 | 1,648 | 6,800 | 26,208 | 109,112 | 428,592 | 1,674,568
    | 7,055,272 | 26,947,840 | 111,209,368 |'
- en: '| SortedSet | 40 | 104 | 248 | 824 | 3,128 | 12,344 | 49,208 | 195,368 | 777,272
    | 3,145,784 | 12,582,968 | 50,331,704 |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 有序集合 | 40 | 104 | 248 | 824 | 3,128 | 12,344 | 49,208 | 195,368 | 777,272
    | 3,145,784 | 12,582,968 | 50,331,704 |'
- en: '| Queue | 40 | 80 | 200 | 680 | 2,600 | 10,280 | 41,000 | 162,800 | 647,720
    | 2,621,480 | 10,485,800 | 41,943,080 |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| Queue | 40 | 80 | 200 | 680 | 2,600 | 10,280 | 41,000 | 162,800 | 647,720
    | 2,621,480 | 10,485,800 | 41,943,080 |'
- en: '| String | 40 | 48 | 48 | 72 | 168 | 552 | 2,088 | 8,184 | 32,424 | 131,112
    | 524,328 | 2,097,192 |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| String | 40 | 48 | 48 | 72 | 168 | 552 | 2,088 | 8,184 | 32,424 | 131,112
    | 524,328 | 2,097,192 |'
- en: '**Table 6:** The estimated size (bytes) of the various collections'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6：** 各种集合的估计大小（字节）'
- en: 'The following table shows the estimated size (bytes) of the array used in Scala
    with 0-elements, 1- element, 4- elements, and powers of four all the way up to
    1,048,576 elements. Although mostse are deterministic, these might change depending
    on your platform:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了 Scala 中数组的估计大小（字节），包括 0 元素、1 元素、4 元素以及四的幂，直到 1,048,576 元素。尽管大多数情况是确定的，但这些值可能会根据平台的不同而变化：
- en: '| **Size** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024**
    | **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| **大小** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024** |
    **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
- en: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
- en: '| Array[Object] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 | 323,856
    | 1,310,736 | 5,242,896 | 20,971,536 |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| Array[Object] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 | 323,856
    | 1,310,736 | 5,242,896 | 20,971,536 |'
- en: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
- en: '| **Size** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024**
    | **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| **大小** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024** |
    **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
- en: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
- en: '| Array[Boolean] | 16 | 24 | 24 | 32 | 80 | 272 | 1,040 | 4,088 | 16,208 |
    65,552 | 262,160 | 1,048,592 |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| Array[Boolean] | 16 | 24 | 24 | 32 | 80 | 272 | 1,040 | 4,088 | 16,208 |
    65,552 | 262,160 | 1,048,592 |'
- en: '| Array[Byte] | 16 | 24 | 24 | 32 | 80 | 272 | 1,040 | 4,088 | 16,208 | 65,552
    | 262,160 | 1,048,592 |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| Array[Byte] | 16 | 24 | 24 | 32 | 80 | 272 | 1,040 | 4,088 | 16,208 | 65,552
    | 262,160 | 1,048,592 |'
- en: '| Array[Short] | 16 | 24 | 24 | 48 | 144 | 528 | 2,064 | 8,160 | 32,400 | 131,088
    | 524,304 | 2,097,168 |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| Array[Short] | 16 | 24 | 24 | 48 | 144 | 528 | 2,064 | 8,160 | 32,400 | 131,088
    | 524,304 | 2,097,168 |'
- en: '| Array[Int] | 16 | 24 | 32 | 80 | 272 | 1,040 | 4,112 | 16,296 | 64,784 |
    262,160 | 1,048,592 | 4,194,320 |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| Array[Int] | 16 | 24 | 32 | 80 | 272 | 1,040 | 4,112 | 16,296 | 64,784 |
    262,160 | 1,048,592 | 4,194,320 |'
- en: '| Array[Long] | 16 | 24 | 48 | 144 | 528 | 2,064 | 8,208 | 32,568 | 129,552
    | 524,304 | 2,097,168 | 8,388,624 |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| Array[Long] | 16 | 24 | 48 | 144 | 528 | 2,064 | 8,208 | 32,568 | 129,552
    | 524,304 | 2,097,168 | 8,388,624 |'
- en: '| Boxed Array[Boolean] | 16 | 40 | 64 | 112 | 304 | 1,072 | 4,144 | 16,328
    | 64,816 | 262,192 | 1,048,624 | 4,194,352 |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| Boxed Array[Boolean] | 16 | 40 | 64 | 112 | 304 | 1,072 | 4,144 | 16,328
    | 64,816 | 262,192 | 1,048,624 | 4,194,352 |'
- en: '| Boxed Array[Byte] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 8,208 | 20,392 |
    68,880 | 266,256 | 1,052,688 | 4,198,416 |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| Boxed Array[Byte] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 8,208 | 20,392 |
    68,880 | 266,256 | 1,052,688 | 4,198,416 |'
- en: '| Boxed Array[Short] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400
    | 323,856 | 1,310,736 | 5,230,608 | 20,910,096 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| Boxed Array[Short] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400
    | 323,856 | 1,310,736 | 5,230,608 | 20,910,096 |'
- en: '| Boxed Array[Int] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 |
    323,856 | 1,310,736 | 5,242,896 | 20,971,536 |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| Boxed Array[Int] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 |
    323,856 | 1,310,736 | 5,242,896 | 20,971,536 |'
- en: '| Boxed Array[Long] | 16 | 48 | 128 | 464 | 1,808 | 7,184 | 28,688 | 113,952
    | 453,392 | 1,835,024 | 7,340,048 | 29,360,144 |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| Boxed Array[Long] | 16 | 48 | 128 | 464 | 1,808 | 7,184 | 28,688 | 113,952
    | 453,392 | 1,835,024 | 7,340,048 | 29,360,144 |'
- en: '**Table 7**: The estimated size (bytes) of the arrays in Scala'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7**：Scala 中数组的估计大小（字节）'
- en: 'However, this book does not set out to distinguish them in a broad way and
    hence we will omit any discussion on these topics. Refer to the following information
    box for further guidelines on these:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本书并未广泛区分这些，因此我们将省略对这些话题的讨论。有关更多指导，请参阅以下信息框：
- en: For very detailed benchmarking for Scala Collections with timed code, refer
    to this link on GitHub ([https://github.com/lihaoyi/scala-bench/tree/master/bench/src/main/scala/bench](https://github.com/lihaoyi/scala-bench/tree/master/bench/src/main/scala/bench)).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 有关带有计时代码的 Scala 集合的详细基准测试，请参考 GitHub 上的此链接（[https://github.com/lihaoyi/scala-bench/tree/master/bench/src/main/scala/bench](https://github.com/lihaoyi/scala-bench/tree/master/bench/src/main/scala/bench)）。
- en: As we mentioned in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, Scala has a very rich Collection API. The same applies
    for Java but there are lots of differences between the two Collection APIs. In
    the next section, we will see some examples on Java interoperability.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c)中提到的，*Scala
    入门*，Scala 有一个非常丰富的集合 API。Java 也是如此，但两者的集合 API 之间有很多差异。在接下来的章节中，我们将看到一些关于 Java
    互操作性的示例。
- en: Java interoperability
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 互操作性
- en: As we mentioned earlier, Scala has very rich collection API. The same applies
    for Java but there are lots of differences between the two collection APIs. For
    example, both APIs have iterable, iterators, maps, sets, and sequences. But Scala
    has advantages; it pays more attention to immutable collections and provides more
    operations for you in order to produce another collection. Sometimes, you want
    to use or access Java collections or vice versa.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Scala 具有非常丰富的集合 API。Java 也是如此，但两者之间有很多差异。例如，两者的 API 都有可迭代（iterable）、迭代器（iterators）、映射（maps）、集合（sets）和序列（sequences）。但是，Scala
    有优势；它更加关注不可变集合，并为你提供了更多的操作，以便生成另一个集合。有时，你可能需要使用或访问 Java 集合，或者反之亦然。
- en: '`JavaConversions` is no longer a sound choice. `JavaConverters` makes the conversion
    between Scala and Java collection explicit and you''ll be much less likely to
    experience implicit conversions you didn''t intend to use.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`JavaConversions` 已不再是一个合适的选择。`JavaConverters` 使得 Scala 和 Java 集合之间的转换更加明确，你会更少遇到那些你并未打算使用的隐式转换。'
- en: 'As a matter of fact, it''s quite trivial to do so because Scala offers in an
    implicit way to convert between both APIs in the `JavaConversion` object. So,
    you might find bidirectional conversions for the following types:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，做到这一点相当简单，因为 Scala 提供了一种隐式的方式在 `JavaConversion` 对象中转换这两种 API。因此，你可能会发现以下类型的双向转换：
- en: '[PRE83]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In order to be able to use these kinds of conversion, you need to import them
    from the `JavaConversions` object. For example:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用这些类型的转换，你需要从 `JavaConversions` 对象中导入它们。例如：
- en: '[PRE84]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'By this, you have automatic conversions between Scala collections and their
    corresponding in Java:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此，你可以在 Scala 集合和其对应的 Java 集合之间进行自动转换：
- en: '[PRE85]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'You can also try to convert other Scala collections into Java ones. For example:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试将其他 Scala 集合转换为 Java 集合。例如：
- en: '[PRE86]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Java doesn''t provide the functionality to distinguish between immutable and
    mutable collections. The `List` will be `java.util.List` where all attempts to
    mutate its elements will throw an `Exception`. The following is an example to
    demonstrate this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Java 不提供区分不可变集合和可变集合的功能。`List` 将是 `java.util.List`，在尝试修改其元素时会抛出 `Exception`。以下是一个示例来演示这一点：
- en: '[PRE87]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In [Chapter 2](part0058.html#1NA0K1-21aec46d8593429cacea59dbdcd64e1c), *Object-Oriented
    Scala*, we briefly discussed using implicits. However, we will provide a detailed
    discussion on using implicits in the next section.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0058.html#1NA0K1-21aec46d8593429cacea59dbdcd64e1c)，*面向对象的 Scala*
    中，我们简要讨论了使用隐式。我们将在接下来的章节中提供关于如何使用隐式的详细讨论。
- en: Using Scala implicits
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Scala 隐式
- en: We have addressed implicits in the previous chapters, but here we are going
    to see more examples. Implicit parameters are very similar to default parameters
    but they use different mechanisms in order to find the default value.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中已经讨论了隐式（implicits），但这里我们将看到更多的示例。隐式参数与默认参数非常相似，但它们使用不同的机制来找到默认值。
- en: 'An implicit parameter is one that is passed to a constructor or a method and
    is marked as implicit, which means that the compiler will search for an implicit
    value within the scope if you don''t provide a value for this parameter. For example:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式参数是传递给构造函数或方法的，并标记为隐式，这意味着如果你没有为该参数提供值，编译器将在作用域内搜索隐式值。例如：
- en: '[PRE88]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Implicits are very useful for the collection API. For example, the collections
    API use implicit parameters to supply `CanBuildFrom` objects for many methods
    in these collections. This happens usually because users aren't concerned with
    these parameters.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式对于集合 API 非常有用。例如，集合 API 使用隐式参数来为这些集合中的许多方法提供 `CanBuildFrom` 对象。这通常发生在用户不关心这些参数的情况下。
- en: 'One constraint is that you can''t have more than one implicit keyword per method
    and it must be at the start of the parameter list. Here are some invalid examples:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 一个限制是，每个方法中只能有一个隐式关键字，并且它必须放在参数列表的开头。以下是一些无效的示例：
- en: '[PRE89]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '**Number of implicit parameters:** Note that you can have more than one implicit
    parameter. But, you cannot have more than one group of implicit parameters.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐式参数的数量：** 请注意，您可以有多个隐式参数。但是，您不能有多个隐式参数组。'
- en: 'The following is for more than 1 implicit parameter:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于多个隐式参数的内容：
- en: '[PRE90]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The final parameter list on a function can be identified or marked as implicit.
    This means the values will be taken from the context as they are being called.
    In other words, if there is no implicit value of the exact type in the scope,
    the source code using implicit will not be compiled. The reason is simple: since
    the implicit value must be resolved to a single value type, it would be a better
    idea to make the type specific to its purpose to avoid implicit clashes.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最终参数列表可以被标记为隐式。这意味着这些值将在调用时从上下文中获取。换句话说，如果作用域中没有确切类型的隐式值，使用隐式值的源代码将无法编译。原因很简单：因为隐式值必须解析为单一的值类型，所以最好使该类型与其目的相匹配，以避免隐式冲突。
- en: 'Moreover, you do not require methods to find an implicit. For example:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您不需要方法来查找隐式转换。例如：
- en: '[PRE91]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'When your Scala compiler finds an expression of wrong types for the context
    it is feeding, it will look for an implicit function value instead for type-checking.
    So, the difference between your regular methods is that the one marked implicit
    will be inserted for you by the compiler when a `Double` is found but an `Int`
    is required. For example:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的Scala编译器发现上下文所需要的表达式类型错误时，它将寻找一个隐式函数值来进行类型检查。因此，您的常规方法和标记为隐式的方法的区别在于，当发现`Double`但需要`Int`时，编译器会为您插入那个隐式方法。例如：
- en: '[PRE92]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The earlier code will work the same as:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将与以下内容相同：
- en: '[PRE93]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In the second we've inserted the conversion manually. At first, the compiler
    did this automatically. The conversion is required because of the type annotation
    on the left-hand side.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况中，我们手动插入了转换。最初，编译器会自动进行此操作。由于左侧的类型注解，转换是必需的。
- en: While working with data, we will often need to convert one type to another.
    Scala implicit type conversion gives us this facility. We will see several examples
    of it in the next section.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据时，我们常常需要将一种类型转换为另一种类型。Scala的隐式类型转换为我们提供了这个功能。我们将在接下来的部分看到几个示例。
- en: Implicit conversions in Scala
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的隐式转换
- en: 'An implicit conversion from type `S` to type `T` is defined by an implicit
    value that has function type `S => T`, or by an implicit method convertible to
    a value of that type. Implicit conversions are applied in two situations (source:
    [http://docs.scala-lang.org/tutorials/tour/implicit-conversions](http://docs.scala-lang.org/tutorials/tour/implicit-conversions)):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 从类型`S`到类型`T`的隐式转换是通过具有函数类型`S => T`的隐式值，或通过可以转换为该类型值的隐式方法定义的。隐式转换在两种情况下应用（来源：[http://docs.scala-lang.org/tutorials/tour/implicit-conversions](http://docs.scala-lang.org/tutorials/tour/implicit-conversions)）：
- en: If an expression e is of type `S`, and S does not conform to the expression's
    expected type `T`
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个表达式`e`的类型是`S`，而`S`不符合该表达式预期的类型`T`：
- en: In a selection `e.m` with `e` of type `S`, if the selector `m` does not denote
    a member of `S`.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`e.m`的选择中，`e`的类型是`S`，如果选择器`m`不是`S`的成员。
- en: 'Well, we have seen how to use infix operator in Scala. Now, let''s see some
    use cases of Scala implicit conversion. Suppose we have the following code segment:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经看到了如何在Scala中使用中缀操作符。现在，让我们看看一些Scala隐式转换的用例。假设我们有以下代码段：
- en: '[PRE94]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'In the preceding code, we defined some methods for performing addition, subtraction,
    and a unary operation for complex numbers (that is, both real and imaginary numbers).
    Inside the `main()` method, we called these methods with real values. The output
    is given as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一些用于执行加法、减法以及复数的单目运算的方法（即包括实数和虚数）。在`main()`方法中，我们使用实数调用了这些方法。输出结果如下：
- en: '[PRE95]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: But what if we want to support adding a normal number to a complex number, how
    would we do that? We could certainly overload our `plus` method to take a `Double`
    argument so that it's going to support the following expression.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们希望支持将一个普通数字添加到一个复数上，我们该如何实现呢？我们当然可以重载我们的`plus`方法，接受一个`Double`参数，这样它就可以支持以下表达式。
- en: '[PRE96]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'For this, we can use Scala implicit conversion. It supports implicit conversion
    for both real and complex numbers for mathematical operation. So, we can just
    use that tuple as the parameter for our implicit conversion and convert it into
    a `Complex` refer to the following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以使用 Scala 隐式转换。它支持对实数和复数的隐式转换，用于数学运算。所以，我们可以将那个元组作为隐式转换的参数，并将其转换为 `Complex`，参考以下内容：
- en: '[PRE97]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Alternatively, for double to complex conversion as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，进行如下的双向到复杂转换：
- en: '[PRE98]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'To take the advantage of this conversion, we need to import the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这种转换，我们需要导入以下内容：
- en: '[PRE99]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, we can execute something like this on Scala REPL/IDE:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 Scala REPL/IDE 上执行如下操作：
- en: '[PRE100]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'You will get the following output:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得以下输出：
- en: '[PRE101]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The full source code for this example can be seen as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整源代码如下所示：
- en: '[PRE102]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: We have now more or less covered Scala collection APIs. There are other features
    too, but page limitations prevented us from covering them. Interested readers
    who still want to explore this should refer to this page [http://www.scala-lang.org/docu/files/collections-api/collections.html](http://www.scala-lang.org/docu/files/collections-api/collections.html).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经或多或少覆盖了 Scala 集合 API。还有其他功能，但由于页面限制，我们未能覆盖它们。对此感兴趣的读者如果仍想进一步了解，应该参考此页面
    [http://www.scala-lang.org/docu/files/collections-api/collections.html](http://www.scala-lang.org/docu/files/collections-api/collections.html)。
- en: Summary
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Throughout this chapter, we have seen many examples of using the Scala collections
    API. It's very powerful, flexible, and has lots of operations coupled with them.
    This wide range of operations will make your life easy dealing with any kind of
    data. We introduced the Scala collections API, and its different types and hierarchies.
    We also demonstrated the capabilities of the Scala collections API and how it
    can be used in order to accommodate different types of data and solve a wide range
    of different problems. In summary, you learned about types and hierarchies, performance
    characteristic, Java interoperability, and the usage of implicits. So, this is
    more or less the end of the learning Scala. However, you will keep on learning
    more advanced topics and operations using Scala through the following chapters.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到许多使用 Scala 集合 API 的示例。它非常强大、灵活，并且与许多操作结合在一起。这个广泛的操作范围将使你在处理任何类型的数据时更加轻松。我们介绍了
    Scala 集合 API，以及它的不同类型和层次结构。我们还演示了 Scala 集合 API 的功能，以及它如何被用来容纳不同类型的数据，并解决广泛的各种问题。总之，你了解了类型和层次结构、性能特性、Java
    互操作性以及隐式转换的使用。因此，这基本上就是学习 Scala 的结束。然而，你将通过接下来的章节继续学习更多的高级主题和操作。
- en: In the next chapter, we will explore data analysis and big data to see the challenges
    that big data provides and how they are dealt via distributed computing and the
    approach suggested by functional programming. You will also learn about MapReduce,
    Apache Hadoop, and finally Apache Spark and see how they embrace this approach
    and these techniques.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨数据分析和大数据，了解大数据所带来的挑战，以及如何通过分布式计算和函数式编程推荐的方法来应对这些挑战。你还将学习到 MapReduce、Apache
    Hadoop，以及最后的 Apache Spark，并了解它们如何采用这种方法和技术。
