- en: Chapter 7.  Spark Machine Learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 Spark机器学习
- en: Calculations based on formulas or algorithms have been used commonly since ancient
    times to find the output for a given input. But without knowing the formulas or
    algorithms, computer scientists and mathematicians devised methods to generate
    formulas or algorithms based on an existing input/output dataset and predicted
    the output of a new input data based on the generated formulas or algorithms.
    Generally, this process of learning from a dataset and doing predictions based
    on the learning is known as machine learning. Machine learning originates from
    the study of artificial intelligence in computer science.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自古以来，基于公式或算法的计算就被广泛用于根据给定输入求得输出。然而，在不了解这些公式或算法的情况下，计算机科学家和数学家设计了方法，通过现有的输入/输出数据集来生成公式或算法，并基于这些生成的公式或算法预测新输入数据的输出。通常，这种从数据集中学习并基于学习进行预测的过程被称为机器学习。机器学习起源于计算机科学中的人工智能研究。
- en: Practical machine learning has numerous applications that are being consumed
    by laymen on a daily basis. YouTube users now get suggestions for the next items
    to be played in the playlist based on the video they are currently viewing. Popular
    movie rating sites give ratings and recommendations based on the user preferences
    of movie genres. Social media web sites such as Facebook suggest a list of names
    of the users' friends for easy tagging of pictures. What Facebook is doing here
    is classifying pictures by the names that are already available in the existing
    albums and checking whether the newly added picture has any similarities with
    the existing ones. If it finds a similarity, it suggests the name. The applications
    of this kind of picture identification are manifold. The way all these applications
    work is based on the huge amount of input/output datasets that have already been
    collected and the learning that has been done based on those datasets. When a
    new input dataset arrives, a prediction is made by making use of the learning
    that the computer or machine has already done.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的机器学习有众多应用，这些应用正被普通民众日常消费。YouTube用户现在根据他们当前观看的视频获得播放列表中下一个项目的推荐。流行的电影评级网站根据用户对电影类型的偏好给出评级和推荐。社交媒体网站如Facebook会提供用户好友的名单，以便于图片标记。Facebook在这里所做的是通过现有相册中已有的名称对图片进行分类，并检查新添加的图片是否与现有图片有任何相似之处。如果发现相似之处，它会推荐该名称。这种图片识别的应用是多方面的。所有这些应用的工作方式都是基于已经收集的大量输入/输出数据集以及基于这些数据集所进行的学习。当一个新的输入数据集到来时，通过利用计算机或机器已经完成的学习来进行预测。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Using Spark for machine learning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spark进行机器学习
- en: Model persistence
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型持久化
- en: Spam filtering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾邮件过滤
- en: Feature algorithms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征算法
- en: Finding synonyms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找同义词
- en: Understanding machine learning
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解机器学习
- en: In traditional computing, input data is fed to a program to generate output.
    But in machine learning, input data and output data are fed to a machine learning
    algorithm to generate a function or program that can be used to predict the output
    of an input according to the learning done on the input/output dataset fed to
    the machine learning algorithm.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统计算中，输入数据被输入程序以生成输出。但在机器学习中，输入数据和输出数据被输入机器学习算法，以生成一个函数或程序，该函数或程序可以根据输入/输出数据集对机器学习算法的学习来预测输入的输出。
- en: The data available in the wild may be classified into groups, it may form clusters,
    or it may fit into certain relationships. These are different kinds of machine
    learning problem. For example, if there is a databank of pre-owned car sale prices
    with its associated attributes or features, it is possible to predict the price
    of a car just by knowing the associated attributes or features. Regression algorithms
    are used to solve these kinds of problem. If there is a databank of spam and non-spam
    e-mails, then when a new e-mail comes, it is possible to predict whether the new
    e-mail is spam or non-spam. Classification algorithms are used to solve these
    kinds of problem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 野外可用的数据可能被分类成组，可能形成集群，或者可能符合某些关系。这些都是不同类型的机器学习问题。例如，如果有一个二手汽车销售价格及其相关属性或特征的数据库，只需了解相关属性或特征，就有可能预测汽车的价格。回归算法用于解决这类问题。如果有一个垃圾邮件和非垃圾邮件的电子邮件数据库，那么当一封新电子邮件到来时，就有可能预测该新电子邮件是垃圾邮件还是非垃圾邮件。分类算法用于解决这类问题。
- en: 'These are just a few machine learning algorithm types. But in general, when
    using a bank of data, if it is necessary to apply a machine learning algorithm
    and use that model to make predictions, then the data should be divided into features
    and outputs. For example, in the case of the car price prediction problem, price
    is the output, and here are some of the possible features of the data:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是机器学习算法的几种类型。但一般来说，在使用数据集时，如果需要应用机器学习算法并使用该模型进行预测，则应将数据分为特征和输出。例如，在汽车价格预测问题中，价格是输出，以下是数据可能的一些特征：
- en: Car make
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汽车品牌
- en: Car model
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汽车型号
- en: Year of manufacture
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产年份
- en: Mileage
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 里程
- en: Fuel type
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 燃料类型
- en: Gearbox type
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变速箱类型
- en: So whichever machine learning algorithm is being used, there will be a set of
    features and one or more outputs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论使用哪种机器学习算法，都会有一组特征和一个或多个输出。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many books and publications use the term *label* for output. In other words,
    *features* are the input and *label* is the output.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 许多书籍和出版物使用*标签*一词来指代输出。换句话说，*特征*是输入，而*标签*是输出。
- en: '*Figure 1* depicts the way a machine learning algorithm works on the underlying
    data to enable predictions.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1*展示了机器学习算法如何处理底层数据以实现预测。'
- en: '![Understanding machine learning](img/image_07_001.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![理解机器学习](img/image_07_001.jpg)'
- en: Figure 1
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: Data comes in various shapes and forms. Depending on the machine learning algorithm
    used, the training data has to be pre-processed to have the features and labels
    in the right format to be fed to the machine learning algorithm. That in turn
    generates the appropriate hypothesis function, which takes the features as the
    input and produces the predicted label.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以各种形式呈现。根据所使用的机器学习算法，训练数据必须经过预处理，以确保特征和标签以正确的格式输入到机器学习算法中。这反过来又生成了适当的假设函数，该函数以特征作为输入并产生预测标签。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The dictionary definition of the word hypothesis is a supposition or proposed
    explanation made on the basis of limited evidence as a starting point for further
    investigation. Here, the function or program that is generated by the machine
    learning algorithm is based on the limited evidence that is the training data
    fed to the machine learning algorithm, and hence it is widely known as hypothesis
    function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一词的词典定义是一种基于有限证据的假设或提议解释，作为进一步调查的起点。在这里，由机器学习算法生成的函数或程序基于有限的证据，即输入到机器学习算法的训练数据，因此它被广泛称为假设函数。
- en: In other words, this hypothesis function is not a definitive function that produces
    consistent results all the time with all types of input data. It is rather a function
    based on the training data. When a new piece of data is added to the training
    dataset, re-learning is required, and at that time even the hypothesis function
    generated will change accordingly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这个假设函数并不是一个能始终对所有类型的输入数据产生一致结果的确定性函数。它更多是基于训练数据的函数。当新的数据添加到训练数据集中时，需要重新学习，届时生成的假设函数也会相应改变。
- en: In reality, the flow given in *Figure 1* is not as simple as it seems. Once
    the model is trained, a lot of testing has to be done on the model to test predictions
    with known labels. The chain of train and test processes is an iterative process,
    and in each iteration the parameters of the algorithm are tweaked to make the
    prediction quality better. Once an acceptable test result is produced by the model,
    the model can be moved to production for doing the live prediction needs. Spark
    comes with a machine learning librarythat is rich with capabilities to make practical
    machine learning a reality.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，*图1*所示流程并不像看起来那么简单。模型训练完成后，需要对模型进行大量测试，以使用已知标签测试预测。训练和测试过程的链条是一个迭代过程，每次迭代都会调整算法的参数以提高预测质量。一旦模型产生了可接受的测试结果，就可以将其部署到生产环境中以满足实时预测需求。Spark自带的机器学习库功能丰富，使得实际应用机器学习成为可能。
- en: Why Spark for machine learning?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Spark进行机器学习？
- en: The previous chapters covered various data processing functionalities of Spark
    in detail. Spark's machine learning library uses many Spark core functionalities
    as well as Spark libraries such as Spark SQL. The Spark machine learning library
    makes machine learning application development easy by combining data processing
    and machine learning algorithm implementations in a unified framework with the
    ability to do data processing on a cluster of nodes, combined with ability to
    read and write data to a variety of data formats.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章详细介绍了Spark的各种数据处理功能。Spark的机器学习库不仅使用了Spark核心的许多功能，还使用了Spark SQL等Spark库。Spark机器学习库通过在统一的框架中结合数据处理和机器学习算法实现，使得机器学习应用开发变得简单，该框架能够在集群节点上进行数据处理，并能够读写各种数据格式。
- en: Spark comes with two flavors of the machine learning library. They are `spark.mllib`
    and `spark.ml`. The first one is developed on top of Spark's RDD abstraction,
    and the second one is developed on top of Spark's DataFrame abstraction. It is
    recommended to use the spark.ml library for any future machine learning application
    developments.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Spark提供了两种机器学习库：`spark.mllib`和`spark.ml`。前者基于Spark的RDD抽象开发，后者基于Spark的DataFrame抽象开发。建议在未来的机器学习应用开发中使用spark.ml库。
- en: 'This chapter is going to focus only on the spark.ml machine learning library.
    The following list explains terminology and concepts that are used again and again
    in this chapter:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于spark.ml机器学习库。以下列表解释了本章中反复使用的术语和概念：
- en: '**Estimator**: This is an algorithm that works on top of a Spark DataFrame
    containing features and labels. It trains on the data provided in the Spark DataFrame
    and creates a model. This model is used to do future predictions.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**估计器**：这是一种算法，它作用于包含特征和标签的Spark DataFrame之上。它对Spark DataFrame中提供的数据进行训练，并创建一个模型。该模型用于未来的预测。'
- en: '**Transformer**: This converts a Spark DataFrame containing features and transforms
    it to another Spark DataFrame containing predictions. The model created by an
    Estimator is a Transformer.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换器**：它将包含特征的Spark DataFrame转换为包含预测的另一个Spark DataFrame。由Estimator创建的模型就是一个Transformer。'
- en: '**Parameter**: This is to be used by the Estimators and Transformers. Often,
    this is specific to the machine learning algorithm. Spark machine learning library
    comes with a uniform API for specifying the right parameters to the algorithms.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：这是供Estimators和Transformers使用的。通常，它特定于机器学习算法。Spark机器学习库提供了一个统一的API，用于为算法指定正确的参数。'
- en: '**Pipeline**: This is a chain of Estimators and Transformers working together
    forming a machine learning workflow.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流水线**：这是一系列Estimators和Transformers协同工作，形成机器学习工作流程。'
- en: All these new terms are slightly difficult to understand in a theoretical perspective
    but if an example is given, the concepts will become much clearer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论角度看，这些新术语略显晦涩，但若辅以实例，概念便会清晰许多。
- en: Wine quality prediction
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 葡萄酒质量预测
- en: The University of California Irvine Machine Learning Repository ([http://archive.ics.uci.edu/ml/index.html](http://archive.ics.uci.edu/ml/index.html))
    provides a lot of datasets as a service to those who are interested in learning
    about machine learning. The Wine Quality Dataset ([http://archive.ics.uci.edu/ml/datasets/Wine+Quality](http://archive.ics.uci.edu/ml/datasets/Wine+Quality))
    is being used here to demonstrate some machine learning applications. It contains
    two datasets with various features of white and red wines from Portugal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 加州大学欧文分校机器学习资料库（[http://archive.ics.uci.edu/ml/index.html](http://archive.ics.uci.edu/ml/index.html)）为对机器学习感兴趣的人提供了大量数据集。葡萄酒质量数据集（[http://archive.ics.uci.edu/ml/datasets/Wine+Quality](http://archive.ics.uci.edu/ml/datasets/Wine+Quality)）在此用于展示一些机器学习应用。它包含两个数据集，分别描述了葡萄牙白葡萄酒和红葡萄酒的各种特征。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Wine Quality Dataset download link lets you download the datasets for red
    wine and white wine as two separate CSV files. Once those files are downloaded,
    edit the two datasets to remove the first header line containing the column names.
    This is to let the programs parse the numerical data without errors. Detailed
    error handling and excluding the header record are avoided on purpose to focus
    on the machine learning functionality.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 葡萄酒质量数据集下载链接允许您下载红葡萄酒和白葡萄酒的两个单独CSV文件。下载这些文件后，编辑两个数据集以删除包含列名的第一行标题。这是为了让程序无误地解析数值数据。为了专注于机器学习功能，故意避免了详细的错误处理和排除标题记录。
- en: 'The dataset containing various features of red wine is used in this wine quality
    prediction use case. The following are the features of the dataset:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本案例中用于葡萄酒质量预测的数据集包含了红葡萄酒的各种特征。以下是数据集的特征：
- en: Fixed acidity
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定酸度
- en: Volatile acidity
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挥发性酸度
- en: Citric acid
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柠檬酸
- en: Residual sugar
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 残余糖分
- en: Chlorides
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 氯化物
- en: Free sulfur dioxide
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游离二氧化硫
- en: Total sulfur dioxide
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总二氧化硫
- en: Density
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密度
- en: pH
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pH
- en: Sulphates
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硫酸盐
- en: Alcohol
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 酒精
- en: Based on these features, the quality (score between 0 and 10) is determined.
    Here, quality is the label of this dataset. Using this dataset, a model is going
    to be trained and then, using the trained model, testing is done and predictions
    are made. This is a regression problem. The Linear Regression algorithm is used
    to train the model. The Linear Regression algorithm generates a linear hypothesis
    function. In mathematical terms, a linear function is a polynomial of degree one
    or less. In this machine learning application use case, it deals with modeling
    the relationship between a dependent variable (wine quality) and a set of independent
    variables (the features of the wine).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些特征，确定质量（分数介于0和10之间）。在这里，质量是此数据集的标签。使用此数据集，将训练一个模型，然后使用训练好的模型进行测试并做出预测。这是一个回归问题。使用线性回归算法来训练模型。线性回归算法生成一个线性假设函数。在数学术语中，线性函数是一次或更低次的多项式。在这个机器学习应用案例中，它涉及建模因变量（葡萄酒质量）和一组自变量（葡萄酒的特征）之间的关系。
- en: 'At the Scala REPL prompt, try the following statements:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala REPL提示符下，尝试以下语句：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code does a lot of things. It performs the following chain of
    activities in a pipeline:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码做了很多事情。它在管道中执行以下一系列活动：
- en: It reads the wine data from the data file to form a training DataFrame.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从数据文件读取葡萄酒数据以形成训练DataFrame。
- en: Then it creates a `LinearRegression` object and sets the parameters.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个`LinearRegression`对象并设置参数。
- en: It fits the model with the training data and this completes the estimator pipeline.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用训练数据拟合模型，从而完成了估计器管道。
- en: It creates a DataFrame containing test data. Typically, the test data will have
    both features and labels. This is to make sure that the model is right and used
    for comparing the predicted label and actual label.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建了一个包含测试数据的DataFrame。通常，测试数据将同时包含特征和标签。这是为了确保模型的正确性，并用于比较预测标签和实际标签。
- en: Using the model created, it does a transformation with the test data, and from
    the DataFrame produced, extracts the features, input labels, and predictions.
    Note that while doing the transformation using the model, the labels are not required.
    In other words, the labels will not be used at all.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用创建的模型，它对测试数据进行转换，并从生成的DataFrame中提取特征、输入标签和预测结果。注意，在使用模型进行转换时，不需要标签。换句话说，标签将完全不被使用。
- en: Using the model created, it does a transformation with the prediction data and
    from the DataFrame produced, extracts the features and predictions. Note that
    while doing the transformation using the model, the labels are not used. In other
    words, the labels are not used while doing the predictions. This completes a transformer
    pipeline.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用创建的模型，它对预测数据进行转换，并从生成的DataFrame中提取特征和预测结果。注意，在使用模型进行转换时，不使用标签。换句话说，在进行预测时，不使用标签。这完成了转换器管道。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The pipelines in the preceding code snippet are single stage pipelines, and
    for this reason there is no need to use the Pipeline object. Multiple stage pipelines
    are going to be discussed in the following sections.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段中的管道是单阶段管道，因此无需使用Pipeline对象。多阶段管道将在后续部分讨论。
- en: 'The fitting/testing phases are repeated iteratively in real-world use cases
    until the model is giving the desired results when doing predictions. Figure 2
    elucidates the pipeline concept that is demonstrated through the code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，拟合/测试阶段会迭代重复，直到模型在进行预测时给出期望的结果。图2通过代码阐明了演示的管道概念：
- en: '![Wine quality prediction](img/image_07_002.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![葡萄酒质量预测](img/image_07_002.jpg)'
- en: Figure 2
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: 'The following code demonstrates the same use case using Python. At the Python
    REPL prompt, try the following statements:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用Python演示了相同的用例。在Python REPL提示符下，尝试以下语句：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As mentioned earlier, linear regression is statistical model and an approach
    for modeling the relationship between two types of variable. One is an independent
    variable, and the other is a dependent variable. The dependent variable is computed
    from the independent variables. In many cases, if there is only one independent
    variable, then the regression will be a simple linear regression. But in reality,
    in practical real-world use cases, there will be multitude of independent variables,
    just like in the wine dataset. This falls into the case of multiple linear regressions.
    This should not be confused with multivariate linear regression. In multivariate
    regression, multiple and correlated dependent variables are predicted.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，线性回归是一种统计模型，用于模拟两种变量之间的关系。一种是自变量，另一种是因变量。因变量由自变量计算得出。在许多情况下，如果只有一个自变量，那么回归将是简单线性回归。但在现实世界的实际应用中，通常会有多个自变量，正如葡萄酒数据集所示。这属于多元线性回归的情况。不应将其与多元线性回归混淆。在多元回归中，预测的是多个且相关的因变量。
- en: In the use case that is being discussed here, the prediction is only done for
    one variable, which is the quality of the wine and hence it is a multiple linear
    regression and not a multivariate linear regression problem. Some schools even
    use multiple linear regression as univariate linear regression. In other words,
    irrespective of the number of independent variables, if there is only one dependent
    variable, it is termed as univariate linear regression.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论的用例中，预测仅针对一个变量，即葡萄酒的质量，因此这是一个多元线性回归问题，而不是多元线性回归问题。一些学校甚至将多元线性回归称为单变量线性回归。换句话说，无论自变量的数量如何，如果只有一个因变量，则称为单变量线性回归。
- en: Model persistence
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型持久性
- en: 'Spark 2.0 comes with the ability to save and load machine learning models across
    programming languages with ease. In other words, you can create a machine learning
    model in Scala and load it in Python. This allows us to create a model in one
    system, save it, copy it, and use it in other systems. Continuing with the same
    Scala REPL prompt, try the following statements:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Spark 2.0具有跨编程语言轻松保存和加载机器学习模型的能力。换句话说，您可以在Scala中创建一个机器学习模型，并在Python中加载它。这使我们能够在一个系统中创建模型，保存它，复制它，并在其他系统中使用它。继续使用相同的Scala
    REPL提示符，尝试以下语句：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now the loaded model can be used for testing or prediction, just like the original
    model. Continuing with the same Python REPL prompt, try the following statements
    to load the model saved using the Scala program:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加载的模型可以用于测试或预测，就像原始模型一样。继续使用相同的Python REPL提示符，尝试以下语句以加载使用Scala程序保存的模型：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Wine classification
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 葡萄酒分类
- en: 'The dataset containing various features of white wine is used in this wine
    quality classification use case. The following are the features of the dataset:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在此葡萄酒质量分类用例中，使用了包含白葡萄酒各种特征的数据集。以下是数据集的特征：
- en: Fixed acidity
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定酸度
- en: Volatile acidity
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挥发性酸度
- en: Citric acid
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柠檬酸
- en: Residual sugar
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 残糖
- en: Chlorides
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 氯化物
- en: Free sulfur dioxide
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游离二氧化硫
- en: Total sulfur dioxide
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总二氧化硫
- en: Density
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密度
- en: pH
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pH值
- en: Sulphates
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硫酸盐
- en: Alcohol
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 酒精
- en: 'Based on these features, the quality (score between 0 and 10) is determined.
    If the quality is less than 7, then it is classified as bad and a value of 0 is
    assigned to the label. If the quality is 7 or above, then it is classified as
    good and a value of 1 is assigned to the label. In other words, the classification
    value is the label of this dataset. Using this dataset, a model is going to be
    trained and then using the trained model, testing is done and predictions are
    made. This is a classification problem. The Logistic Regression algorithm is used
    to train the model. In this machine learning application use case, it deals with
    modeling the relationship between a dependent variable (wine quality) and a set
    of independent variables (the features of the wine). At the Scala REPL prompt,
    try the following statements:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些特征，确定质量（分数介于0和10之间）。如果质量低于7，则将其归类为差，并将标签赋值为0。如果质量为7或以上，则将其归类为好，并将标签赋值为1。换句话说，分类值是此数据集的标签。使用此数据集，将训练一个模型，然后使用训练好的模型进行测试并做出预测。这是一个分类问题。使用逻辑回归算法来训练模型。在这个机器学习应用案例中，它涉及建模因变量（葡萄酒质量）与一组自变量（葡萄酒的特征）之间的关系。在Scala
    REPL提示符下，尝试以下语句：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code snippet works exactly like a linear regression use case,
    except for the model used here. The model used here is Logistic Regression and
    its label takes only two values, 0 and 1\. Creating the model, testing the model,
    and then the predictions are all similar here. In other words, the pipelines look
    very similar.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的工作原理与线性回归用例完全相同，只是所用的模型不同。此处使用的模型是逻辑回归，其标签仅取两个值，0和1。创建模型、测试模型以及进行预测的过程在此都非常相似。换句话说，流程看起来非常相似。
- en: 'The following code demonstrates the same use case using Python. At the Python
    REPL prompt, try the following statements:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用Python演示了相同的用例。在Python REPL提示符下，尝试以下语句：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Logistic regression is very similar to linear regression. The major difference
    in Logistic regression is that its dependent variable is a categorical variable.
    In other words, the dependent variable takes only a selected set of values. In
    this use case the values are 0 or 1\. The value 0 means that the wine quality
    is bad and the value 1 means that the wine quality is good. To be more precise,
    here, the dependent variable used is a binary dependent variable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归与线性回归非常相似。逻辑回归的主要区别在于其因变量是分类变量。换句话说，因变量仅取一组选定值。在本用例中，这些值为0或1。值0表示葡萄酒质量差，值1表示葡萄酒质量好。更准确地说，此处使用的因变量是二元因变量。
- en: The use cases covered so far have only a handful of features. But in real-world
    use cases the number of features is going to be really huge, especially in machine
    learning use cases where lots of text processing is done. The next section is
    going to discuss one such use case.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止所涵盖的用例仅涉及少量特征。但在现实世界的用例中，特征数量将非常庞大，尤其是在涉及大量文本处理的机器学习用例中。下一节将讨论这样一个用例。
- en: Spam filtering
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾邮件过滤
- en: Spam filtering is a very common use case that is used in many applications.
    It is ubiquitous in e-mail applications. It is one of the most widely used classification
    problems. In a typical mail server, a huge number of e-mails are processed. The
    spam filtering is done on the e-mails received before they are delivered to the
    recipient's mailboxes. For any machine learning algorithm, a model has to be trained
    before making a prediction. To train the model, training data is required. How
    is training data collected? A trivial way is that the users themselves mark some
    of the e-mails received as spam. Use all the e-mails in the mail server as training
    data and keep refreshing the model on a regular basis. This includes spam and
    non-spam e-mails. When the model has a good sample of both kinds of e-mail, the
    prediction is going to be good.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾邮件过滤是一个极为常见的用例，广泛应用于多种应用中，尤其在电子邮件应用中无处不在。它是使用最广泛的分类问题之一。在典型的邮件服务器中，会处理大量的电子邮件。垃圾邮件过滤在邮件送达收件人邮箱之前进行。对于任何机器学习算法，在做出预测之前必须先训练模型。训练模型需要训练数据。训练数据是如何收集的呢？一个简单的方法是用户自行将收到的部分邮件标记为垃圾邮件。使用邮件服务器中的所有邮件作为训练数据，并定期更新模型。这包括垃圾邮件和非垃圾邮件。当模型拥有两类邮件的良好样本时，预测效果将会很好。
- en: The spam filtering use case covered here is not a full-blown production-ready
    application, but it gives a good insight into how one can be built. Here, instead
    of using the entire text of an e-mail, only one line is used for simplicity. If
    this is to be extended to process real e-mails, instead of the single strings,
    read the contents of a full e-mail to one string and proceed as per the logic
    given in this application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此处介绍的垃圾邮件过滤用例并非一个完全成熟的生产就绪应用程序，但它提供了构建此类应用的良好洞见。在此，为了简化，我们仅使用电子邮件中的一行文本，而非整封邮件内容。若要扩展至处理真实邮件，则需将整封邮件内容读取为一个字符串，并按照本应用中的逻辑进行处理。
- en: Unlike the numeric features that are covered in the earlier use cases of this
    chapter, the input here is pure text and selecting features is not as easy as
    those use cases. The lines are split into words to have a bag of words and the
    words are chosen as features. Since it is easy to process numerical features,
    these words are transformed to hashed term frequency vectors. In other words,
    the series of words or terms in the lines are converted to their term frequencies
    using a hashing method. So even in small-scale text processing use cases, there
    will be thousands of features. That is why they need to be hashed for easy comparison.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章前面用例中涉及的数值特征不同，这里的输入是纯文本，选择特征并不像那些用例那样简单。文本被分割成单词以形成词袋，单词被选作特征。由于处理数值特征较为容易，这些单词被转换为哈希词频向量。换句话说，文本行中的单词或术语序列通过哈希方法转换为其词频。因此，即使在小型文本处理用例中，也会有数千个特征。这就是为什么需要对它们进行哈希处理以便于比较。
- en: 'As discussed earlier, in typical machine learning applications, the input data
    needs to undergo lots of pre-processing to get it in the right form of features
    and labels in order to build the model. This typically forms a pipeline of transformations
    and estimations. In this use case, the incoming lines are split into words, and
    those words are transformed using HashingTF algorithm and then a LogisticRegression
    model is trained before doing the prediction. This is done using the Pipeline
    abstraction in the Spark machine learning library. At the Scala REPL prompt, try
    the following statements:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在典型的机器学习应用程序中，输入数据需要经过大量预处理才能将其转换为正确的特征和标签形式，以便构建模型。这通常形成一个转换和估计的管道。在这个用例中，传入的文本行被分割成单词，这些单词使用HashingTF算法进行转换，然后训练一个LogisticRegression模型进行预测。这是使用Spark机器学习库中的Pipeline抽象完成的。在Scala
    REPL提示符下，尝试以下语句：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code snippet does the typical chain of activities: preparing
    training data, creating the model using the Pipeline abstraction, and then predicting
    using the test data. It doesn''t reveal how the features are created and processed.
    In an application development perspective, Spark machine learning library does
    the heavy lifting and does everything under the hood using the Pipeline abstraction.
    If the Pipeline methodology is not used, then tokenisation and then hashing are
    to be done as a separate DataFrame transformation. The following code snippet
    executed as the continuation of the preceding commands will give an insight into
    how that can be done as simple transformations to see the features using the naked
    eyes:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段执行了典型的活动链：准备训练数据，使用Pipeline抽象创建模型，然后使用测试数据进行预测。它没有揭示特征是如何创建和处理的。从应用程序开发的角度来看，Spark机器学习库承担了繁重的工作，并使用Pipeline抽象在幕后完成所有工作。如果不使用Pipeline方法，则需要将分词和哈希作为单独的DataFrame转换来完成。以下代码片段作为前面命令的延续执行，将提供一个洞察，了解如何通过简单的转换来直观地查看特征：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The same use case implemented in Python is as follows. At the Python REPL prompt,
    try the following statements:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中实现的相同用例如下。在Python REPL提示符下，尝试以下语句：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As discussed in earlier, the transformations abstracted by the Pipeline is
    elucidated as follows using Python explicitly. The following code snippet executed
    as the continuation of the preceding commands will give an insight into how that
    can be done as simple transformations to see the features using the naked eyes:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Pipeline抽象的转换在Python中明确阐述如下。以下代码片段作为前面命令的延续执行，将提供一个洞察，了解如何通过简单的转换来直观地查看特征：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Based on the insight provided in the preceding use case, lots of text processing
    machine learning applications can be developed by abstracting away lots of transformations
    using the Spark machine learning library Pipelines.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面用例中提供的洞察，可以通过抽象掉许多转换来使用Spark机器学习库Pipelines开发大量的文本处理机器学习应用程序。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Just like the way the machine learning models are persisted to the media, all
    of the Spark machine learning library Pipelines can also be persisted to the media
    and reloaded by other programs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如机器学习模型可以持久化到介质一样，所有Spark机器学习库Pipelines也可以持久化到介质，并由其他程序重新加载。
- en: Feature algorithms
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征算法
- en: 'In real-world use cases, it is not very easy to get the raw data in the appropriate
    form of features and labels in order to train the model. Doing lots of pre-processing
    is very common. Unlike other data processing paradigms, Spark in conjunction with
    the Spark machine learning library provides a comprehensive set of tools and algorithms
    for this purpose. This pre-processing algorithms can be put into three categories:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的用例中，要获得适合特征和标签形式的原始数据以训练模型并不容易。进行大量预处理是很常见的。与其他数据处理范式不同，Spark与Spark机器学习库结合提供了一套全面的工具和算法来实现这一目的。这些预处理算法可以分为三类：
- en: Feature extraction
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征提取
- en: Feature transformation
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征转换
- en: Feature selection
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征选择
- en: The process of extracting the features from the raw data is feature extraction.
    The HashingTF that was used in the preceding use case is a good example of an
    algorithm that converts terms of text data to feature vectors. The process of
    transforming features into different formats is feature transformation. The process
    of selecting a subset of features from a super set is feature selection. Covering
    all these is beyond the scope of this chapter, but the next section is going to
    discuss an Estimator, which is an algorithm that is used to extract features,
    that is used to find synonyms of words in documents,. These are not the word's
    actual synonyms, but the words that are related to a given word in a context.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从原始数据中提取特征的过程称为特征提取。在前述用例中使用的HashingTF就是一个很好的例子，它是一种将文本数据的术语转换为特征向量的算法。将特征转换为不同格式的过程称为特征转换。从超集中选择特征子集的过程称为特征选择。涵盖所有这些内容超出了本章的范围，但下一节将讨论一个Estimator，它是一种用于提取特征的算法，用于在文档中查找单词的同义词。这些并不是单词的实际同义词，而是在给定上下文中与某个单词相关的单词。
- en: Finding synonyms
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找同义词
- en: A synonym is a word or phrase that has exactly the same meaning or very close
    meaning to another word. In a purely literature perspective this explanation is
    correct, but in a much wider perspective, in a given context, some of the words
    will have a very close relationship, and that is also called synonymous in this
    context. For example, Roger Federer is *synonymous* with Tennis. Finding this
    kind of synonym in context is a very common requirement in entity recognition,
    machine translation, and so on. The **Word2Vec** algorithm computes a distributed
    vector representation of words from the words of a given document or collection
    of words. If this vector space is taken, the words that have similarity or synonymity
    will be close to each other.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同义词是指与另一个单词具有完全相同或非常接近意义的单词或短语。从纯粹的文学角度来看，这个解释是正确的，但从更广泛的角度来看，在给定的上下文中，一些单词之间会有非常密切的关系，这种关系在这个上下文中也被称为同义词。例如，罗杰·费德勒与网球*同义*。在上下文中找到这种同义词是实体识别、机器翻译等领域非常常见的需求。**Word2Vec**算法从给定文档或单词集合的单词中计算出单词的分布式向量表示。如果采用这个向量空间，具有相似性或同义性的单词将彼此接近。
- en: The University of California Irvine Machine Learning Repository ([http://archive.ics.uci.edu/ml/index.html](http://archive.ics.uci.edu/ml/index.html))
    provides a lot of datasets as a service to those who are interested to learn machine
    learning. The Twenty Newsgroups Dataset ([http://archive.ics.uci.edu/ml/datasets/Twenty+Newsgroups](http://archive.ics.uci.edu/ml/datasets/Twenty+Newsgroups))
    is being used here to find synonyms of words in context. It contains a dataset
    consists of 20,000 messages taken from 20 newsgroups.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 加州大学欧文分校机器学习库([http://archive.ics.uci.edu/ml/index.html](http://archive.ics.uci.edu/ml/index.html))为那些对机器学习感兴趣的人提供了大量数据集。Twenty
    Newsgroups数据集([http://archive.ics.uci.edu/ml/datasets/Twenty+Newsgroups](http://archive.ics.uci.edu/ml/datasets/Twenty+Newsgroups))被用于在上下文中查找单词的同义词。它包含一个由20个新闻组中的20,000条消息组成的数据集。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Twenty Newsgroups Dataset download link lets you download the dataset discussed
    here. The file `20_newsgroups.tar.gz` is to be downloaded and unzipped. The data
    directory used in the following code snippets should point to the directory where
    the data is available in unzipped form. If the Spark Driver is giving out of memory
    error because of the huge size of the data, remove some of the newsgroups data
    that is of not interest and experiment with a subset of the data. Here, to train
    the model, only the following news group data is used: talk.politics.guns, talk.politics.mideast,
    talk.politics.misc, and talk.religion.misc.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 二十个新闻组数据集下载链接允许您下载此处讨论的数据集。文件 `20_newsgroups.tar.gz` 需要下载并解压缩。以下代码片段中使用的数据目录应指向数据以解压缩形式可用的目录。如果
    Spark 驱动程序因数据量巨大而出现内存不足错误，请删除一些不感兴趣的新闻组数据，并对数据子集进行实验。在这里，为了训练模型，仅使用了以下新闻组数据：talk.politics.guns、talk.politics.mideast、talk.politics.misc
    和 talk.religion.misc。
- en: 'At the Scala REPL prompt, try the following statements:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala REPL 提示符下，尝试以下语句：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code snippet is loaded with a lot of functionality. The dataset
    is read from the filesystem into a DataFrame as one sentence of text from a given
    file. Then tokenisation is done to convert the sentences into words using regular
    expressions and removing the gaps. Then, from those words, the stop words are
    removed so that we only have relevant words. Finally, using the **Word2Vec** estimator,
    a model is trained with the data prepared. From the trained model, synonyms are
    determined.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段包含了许多功能。数据集从文件系统读入 DataFrame，作为给定文件中的一句文本。接着进行分词处理，使用正则表达式将句子转换为单词并去除空格。然后，从这些单词中移除停用词，以便我们只保留相关词汇。最后，使用**Word2Vec**估计器，利用准备好的数据训练模型。从训练好的模型中，确定同义词。
- en: 'The following code demonstrates the same use case using Python. At the Python
    REPL prompt, try the following statements:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 Python 演示了相同的用例。在 Python REPL 提示符下，尝试以下语句：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The major difference between the Scala implementation and Python implementation
    is that in the Python implementation, the stop words have not been removed. That
    is because that functionality is not available in Python API of the Spark Machine
    Library. Because of this difference, the list of synonyms generated by Scala program
    and Python program are different.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 实现与 Python 实现的主要区别在于，在 Python 实现中，停用词未被移除。这是因为 Spark 机器学习库的 Python API
    中没有提供此功能。因此，Scala 程序和 Python 程序生成的同义词列表会有所不同。
- en: References
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'For more information refer the following links:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参考以下链接：
- en: '[http://archive.ics.uci.edu/ml/index.html](http://archive.ics.uci.edu/ml/index.html)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[UCI 机器学习仓库](http://archive.ics.uci.edu/ml/index.html)'
- en: '[http://archive.ics.uci.edu/ml/datasets/Wine+Quality](http://archive.ics.uci.edu/ml/datasets/Wine+Quality)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[葡萄酒质量数据集](http://archive.ics.uci.edu/ml/datasets/Wine+Quality)'
- en: '[http://archive.ics.uci.edu/ml/datasets/Twenty+Newsgroups](http://archive.ics.uci.edu/ml/datasets/Twenty+Newsgroups)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[二十个新闻组数据集](http://archive.ics.uci.edu/ml/datasets/Twenty+Newsgroups)'
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Spark provides a very powerful core data processing framework and the Spark
    machine learning library makes use of all the core features of Spark and Spark
    libraries such as Spark SQL, in addition to its rich set of machine learning algorithms.
    This chapter covered some of the very common prediction use cases and classification
    use cases with Scala and Python implementations using the Spark machine learning
    library with a few lines of code. These wine quality prediction, wine classification,
    spam filter, and synonym finder machine learning use cases have great potential
    to be developed into full-blown real-world use cases. Spark 2.0 brings flexibility
    to model creation, pipeline creation, and their usage in different programs written
    in a different languages by enabling the model and pipeline persistence.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Spark 提供了一个非常强大的核心数据处理框架，而 Spark 机器学习库则利用了 Spark 及其库（如 Spark SQL）的所有核心特性，并拥有丰富的机器学习算法集合。本章涵盖了一些常见的预测和分类用例，使用
    Scala 和 Python 通过 Spark 机器学习库实现，仅用几行代码。这些葡萄酒质量预测、葡萄酒分类、垃圾邮件过滤器和同义词查找器等机器学习用例具有巨大的潜力，可以发展成为完整的现实世界应用。Spark
    2.0 通过启用模型和管道持久化，为模型创建、管道创建及其在不同语言编写的不同程序中的使用带来了灵活性。
- en: Pair-wise relationships are very common in real-world use cases. Backed by a
    strong mathematical theoretical base, computer scientists have developed many
    data structures and the algorithms that are going with it falling under the subject
    of Graph Theory. These data structures and algorithms have huge applicability
    in applications such as social networking websites, scheduling problems, and many
    other applications. Graph processing is very computationally intensive and distributed
    data processing paradigms such as Spark are ideal for doing such computations.
    The Spark GraphX library built on top of Spark is a collection of graph processing
    APIs. The next chapter is going to take a look at Spark GraphX.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 成对关系在现实世界的用例中非常普遍。基于强大的数学理论基础，计算机科学家们开发了多种数据结构及其配套算法，这些都属于图论的研究范畴。这些数据结构和算法在社交网络网站、调度问题以及许多其他应用中具有广泛的应用价值。图处理计算量巨大，而分布式数据处理范式如Spark非常适合进行此类计算。建立在Spark之上的Spark
    GraphX库是一套图处理API集合。下一章将探讨Spark GraphX。
